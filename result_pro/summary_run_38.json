{
  "run_index": 38,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 394,
  "generation_or_validation_failure_count": 45,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,1,3,1,6]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 1, 3, 1, 6]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳所有結果的串列。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有程式碼並執行\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. Use Start, End, Decision etc. Include random module import. Use function definition roll_dice(n). Inside, create list results, loop i in 1..n, generate random int 1-6, append to list. Return list. No actual code. Use arrows. Provide in Chinese. Each line: virtual code step + space + // explanation. Use arrow \"→\" for normal steps, \"Decision:\" for condition. For loops we can use \"→ Loop: i from 1 to n\". Or \"→ Step: 為每次擲骰\" etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Import random module // 引入 random 模組\n→ Function: roll_dice(n) // 定義函式，接收擲骰次數\n    → Step: 初始化 results 為空串列 // 用於儲存每次擲骰結果\n    → Loop: i 從 1 到 n // 重複擲 n 次\n        → Step: value = random.randint(1,6) // 產生 1~6 的隨機整數\n        → Step: results.append(value) // 將結果加入串列\n    → Step: return results // 回傳所有結果\nEnd // 程式執行結束\n\nBut ensure each line has arrow. For loop maybe use \"→ Loop: i in range(1, n+1)\" etc. For function body we indent lines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import random // 引入 random 模組  \n→ Function: roll_dice(n) // 定義 roll_dice 函式，參數為擲骰次數  \n    → Step: results = [] // 初始化空串列，用於存放每次擲骰結果  \n    → Loop: i in 1..n // 重複擲 n 次  \n        → Step: value = random.randint(1, 6) // 產生 1 至 6 的隨機整數  \n        → Step: results.append(value) // 將此擲骰結果加入 results 串列  \n    → Step: return results // 回傳整個結果串列  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"測量函式 func 執行所需的秒數，並回傳四捨五入到小數點 3 位的耗時。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入內容\n    code = sys.stdin.read()\n    # 在包含 measure_time 的全域字典中執行讀入的程式碼\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. The function measure_time(func,*args). Steps: import time, define function measure_time, record start time, call func with *args, record end time, compute elapsed, round to 3 decimal, return result. Also return result of func? The requirement: measure time of func execution and return result? It says \"並回傳結果\" which likely means return the result of func, but also maybe return time? It's ambiguous. Usually measure_time returns the result of func? Or return elapsed time? Might be both. Let's assume returns elapsed time. But maybe they want return elapsed time. We will produce measure_time that returns elapsed time. Also maybe they want round to 3 decimal. We will include rounding. Provide virtual code lines.\n\nWe need to use arrows and Start, End, Decision, etc. For function definition we can use Step 1: define function. Then Step 2: start time. Step 3: call function and store result. Step 4: end time. Step 5: compute elapsed. Step 6: round. Step 7: return rounded elapsed. Also maybe return result? But we will mention that.\n\nWe need to produce code as virtual lines, not real code. Use arrows.\n\nOk produce:\n\nStart\n→ Step 1: Import time module // 引入 time 以取得時間戳\n→ Step 2: Define function measure_time(func, *args) // 宣告測時函式\n    → Step 3: Record start_time ← time.time() // 紀錄起始時間\n    → Step 4: Call result ← func(*args) // 執行目標函式並取得回傳值\n    → Step 5: Record end_time ← time.time() // 紀錄結束時間\n    → Step 6: Compute elapsed ← end_time - start_time // 計算耗時\n    → Step 7: Round elapsed_rounded ← round(elapsed, 3) // 四捨五入到三位小數\n    → Step 8: Return elapsed_rounded // 回傳耗時\nEnd\n\nAlso include maybe return result? But we skip.\n\nWe'll output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Import time module // 引入 time 以取得時間戳\n→ Step 2: Define function measure_time(func, *args) // 宣告測時函式\n    → Step 3: Record start_time ← time.time() // 紀錄起始時間\n    → Step 4: Call result ← func(*args) // 執行目標函式並取得回傳值\n    → Step 5: Record end_time ← time.time() // 紀錄結束時間\n    → Step 6: Compute elapsed ← end_time - start_time // 計算耗時\n    → Step 7: Round elapsed_rounded ← round(elapsed, 3) // 四捨五入到三位小數\n    → Step 8: Return elapsed_rounded // 回傳耗時\nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"orange\",\"melon\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'orange', 'melon', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取輸入（若有的話），這裡實際上不需要使用\n    _ = sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'\n    fruits.discard('pineapple')\n\n    # 輸出結果\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output line by line virtual code. Steps: Start, define fruits set, then add, update, remove, discard, print. Use arrow notation.\n\nEnsure each line has \"虛擬碼步驟 [space] // 解釋\".\n\nWe must not output actual code, only virtual steps. Use arrows, Decision not needed. So simple sequential steps.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: fruits ← {'apple', 'banana'} // 建立集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 一次新增兩個元素\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'\n→ Step 6: output fruits // 輸出最終集合\nEnd // 程式結束\n\nNeed to format exactly: \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow \"→\". Provide comment after space.\n\nThus each line: \"→ Step X: ...\" followed by space then comment. For Start and End: \"Start\" and \"End\". Example: \"Start // 程式開始執行\". Provide consistent.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits ← {'apple', 'banana'} // 建立集合 fruits，初始包含 'apple' 與 'banana'  \n→ Step 2: fruits.add('orange') // 使用 add() 將 'orange' 新增至集合  \n→ Step 3: fruits.update({'grape', 'melon'}) // 一次新增 'grape' 與 'melon' 至集合  \n→ Step 4: fruits.remove('banana') // 移除集合中的 'banana'，若不存在會拋錯  \n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'，不會拋錯  \n→ Step 6: output fruits // 輸出最終集合內容  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef get_rate():\n    \"\"\"\n    取得美元對台幣匯率。若成功回傳浮點數，失敗回傳 None。\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    try:\n        r = requests.get(url, timeout=5)\n        r.raise_for_status()\n        data = r.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\ndef create_gui():\n    \"\"\"\n    建立 tkinter GUI，包含顯示匯率的 Label 與更新按鈕。\n    \"\"\"\n    win = tk.Tk()\n    win.title(\"美元對台幣匯率查詢\")\n\n    # 初始顯示文字\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update():\n        \"\"\"按鈕點擊時呼叫，更新 label 文字。\"\"\"\n        rate = get_rate()\n        if rate is not None:\n            label.config(text=f\"目前美元匯率：約 {rate:.2f} TWD\")\n        else:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n\n    tk.Button(win, text=\"更新匯率\", command=update).pack(pady=5)\n\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    \"\"\"\n    讀取標準輸入，若包含「按下「更新匯率」按鈕」字串即更新匯率並輸出結果。\n    完成後啟動 GUI。\n    \"\"\"\n    # 讀取整個標準輸入\n    input_text = sys.stdin.read()\n    if \"按下「更新匯率」按鈕\" in input_text:\n        rate = get_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate:.2f} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n\n    # 啟動 GUI 介面\n    create_gui()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrows and comments in Traditional Chinese. Should use structure: Start, End, Decision. Use → arrow. Must not output actual code. Just virtual steps. The user: \"請使用 requests 模組串接匯率 API（https://api.exchangerate-api.com/v4/latest/USD），取得當前美元兌換台幣（TWD）的匯率。將結果顯示在 tkinter 視窗中，按下按鈕即可更新最新匯率。請根據輸出格式要求產生虛擬碼和逐行解釋。\"\n\nWe need to produce steps for building such an application: import modules, create Tk window, label, button, function to fetch rate, update label, event binding, main loop. Use Start, End, Decision: maybe decision for success/failure of API. So include steps to handle error.\n\nLet's craft lines:\n\nStart\n→ Step 1: Import requests and tkinter modules // 引入網路請求和圖形介面模組\n→ Step 2: 建立 Tk 主視窗 // 初始化 tkinter 視窗\n→ Step 3: 設定視窗標題 'USD to TWD 匯率' // 顯示標題\n→ Step 4: 建立 Label 用於顯示匯率資訊 // 文字顯示元件\n→ Step 5: 建立 Button 標籤 '更新匯率' // 觸發更新按鈕\n→ Step 6: 定義函式 fetch_rate() 以請求 API // 取得匯率資料\n    → Decision: 如果 HTTP 請求成功? // 檢查回傳碼\n        Yes → Step 7: 解析 JSON 並取出 TWD 匯率 // 取得數值\n        Yes → Step 8: 更新 Label 文字為 'USD/TWD: {rate}' // 顯示最新匯率\n        No  → Step 9: 更新 Label 文字為 '取得匯率失敗' // 顯示錯誤訊息\n→ Step 10: 將 fetch_rate() 綁定至 Button 的 command // 按鈕點擊呼叫\n→ Step 11: 初始化時即呼叫 fetch_rate() 以顯示初始匯率 // 首次顯示\n→ Step 12: 執行 Tk 主迴圈 mainloop() // 開始 GUI 事件循環\nEnd\n\nMake sure each line ends with // explanation. Use correct indentation with spaces maybe.\n\nMake sure to include the arrow symbol '→' at start of each step except Start and End. Provide the explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests and tkinter modules // 引入網路請求與圖形介面模組  \n→ Step 2: 建立 Tk 主視窗 // 初始化 tkinter 視窗  \n→ Step 3: 設定視窗標題 'USD to TWD 匯率' // 顯示視窗標題  \n→ Step 4: 建立 Label 用於顯示匯率資訊 // 文字顯示元件  \n→ Step 5: 建立 Button 標籤 '更新匯率' // 觸發更新按鈕  \n→ Step 6: 定義函式 fetch_rate() 以請求 API // 取得匯率資料  \n  → Decision: 如果 HTTP 請求成功? // 檢查回傳碼  \n    Yes → Step 7: 解析 JSON 並取出 TWD 匯率 // 取得數值  \n    Yes → Step 8: 更新 Label 文字為 'USD/TWD: {rate}' // 顯示最新匯率  \n    No  → Step 9: 更新 Label 文字為 '取得匯率失敗' // 顯示錯誤訊息  \n→ Step 10: 將 fetch_rate() 綁定至 Button 的 command // 按鈕點擊呼叫  \n→ Step 11: 初始化時即呼叫 fetch_rate() 以顯示初始匯率 // 首次顯示  \n→ Step 12: 執行 Tk 主迴圈 mainloop() // 開始 GUI 事件循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp58ulyz_l.py\", line 40, in <module>\n    ops = json.loads(parts[0])\n          ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 94 (char 93)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        # value -> index mapping\n        self.val_to_index = {}\n        # list of values\n        self.values = []\n\n    def insert(self, val):\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.values)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Ensure two separate lists: operations and arguments\n    data = data.replace('], [', '],\\n[')\n    parts = data.split('\\n', 1)\n    ops = json.loads(parts[0])\n    args = json.loads(parts[1])\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            res.append(None)\n        elif op == \"insert\":\n            res.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            res.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            res.append(obj.getRandom())\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for RandomizedSet operations. The user wants Virtual Code lines, each line: \"虛擬碼步驟 // 解釋\". Use arrow, Decision etc.\n\nWe need to include initialization, insert, remove, getRandom. Use data structures: array/list for values, hash map value to index. Each operation average O(1). Provide pseudocode for each method.\n\nWe need to output step by step. Possibly break into main start? Provide overall structure.\n\nThe Virtual Code must be line by line. Provide Start, End. Probably for each method separate? The user didn't specify grouping but we can provide separate sections for each method, each with Start/End. Use arrow for steps.\n\nWe need to use the format: \"虛擬碼步驟 // 解釋\".\n\nExamples show \"Start // 程式開始執行\". We'll produce e.g.:\n\nStart // RandomizedSet initialization\n→ Step 1: 建立空陣列 values // 用於儲存元素\n→ Step 2: 建立空哈希表 idxMap // 值到索引的映射\nEnd // 初始化完成\n\nThen similar for insert, remove, getRandom.\n\nFor insert:\nStart // Insert(val)\n→ Decision: 如果 val 已在 idxMap? // 檢查是否已存在\n    Yes → Return false // 失敗，已存在\n    No  → Step 1: 把 val 加入 values 陣列末尾 // 插入\n         → Step 2: 設定 idxMap[val] = values.size-1 // 记录索引\n         → Return true // 成功\n\nRemove:\nStart // Remove(val)\n→ Decision: 如果 val 不在 idxMap? // 检查存在性\n    Yes → Return false // 失敗，元素不存在\n    No  → Step 1: 取得要移除的索引 removeIdx = idxMap[val]\n         → Step 2: 取得最後一個元素 lastVal = values.last\n         → Step 3: values[removeIdx] = lastVal // 覆盖\n         → Step 4: 更新 idxMap[lastVal] = removeIdx // 更新索引\n         → Step 5: values.pop_back() // 移除最后元素\n         → Step 6: 刪除 idxMap[val] // 删除映射\n         → Return true\n\ngetRandom:\nStart // getRandom()\n→ Step 1: 生成隨機索引 randIdx = random(0, values.size-1)\n→ Step 2: 返回 values[randIdx] // 随机元素\n\nNeed to output each line with arrow. Use \"→\" for steps. For decisions, indent? Example uses \"    Yes →\" etc.\n\nLet's craft.\n\nEnsure each line ends with \"// 解釋\". Also \"Start // ...\".\n\nWe should produce maybe separate sections, but keep separate lines.\n\nLet's produce:\n\nStart // RandomizedSet 初始化\n→ Step 1: 初始化 values 為空列表 // 用於儲存所有元素\n→ Step 2: 初始化 idxMap 為空哈希表 // 存儲元素到索引的映射\nEnd // 初始化完成\n\nStart // insert(val) 方法\n→ Decision: 如果 val 在 idxMap? // 判斷元素是否已存在\n    Yes → Return false // 插入失敗，已存在\n    No  → Step 1: 將 val 加入 values 的末尾 // 添加新元素\n         → Step 2: 設定 idxMap[val] = values.size - 1 // 記錄新元素的位置\n         → Return true // 插入成功\n\nStart // remove(val) 方法\n→ Decision: 如果 val 不在 idxMap? // 判斷元素是否存在\n    Yes → Return false // 刪除失敗，元素不存在\n    No  → Step 1: 取得 val 的索引 removeIdx = idxMap[val] // 找到要刪除的位置\n         → Step 2: 取得 values 的最後一個元素 lastVal = values.back() // 取得最後元素\n         → Step 3: values[removeIdx] = lastVal // 用最後元素覆蓋要刪除的位置\n         → Step 4: 更新 idxMap[lastVal] = removeIdx // 更新最後元素的新索引\n         → Step 5: values.pop_back() // 刪除最後一個元素\n         → Step 6: 刪除 idxMap[val] // 移除 val 的映射\n         → Return true // 刪除成功\n\nStart // getRandom() 方法\n→ Step 1: 生成隨機整數 r 在 [0, values.size-1] // 隨機索引\n→ Step 2: 返回 values[r] // 返回隨機元素\n\nBut need \"虛擬碼步驟\" each line. In the example they used \"→ Step 1: ...\" The format: \"→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\". So we should include \"→ Step X: ...\" for steps. For decisions, use \"→ Decision:\" etc. Use indentation.\n\nWe need to output each line exactly like that.\n\nAlso need \"End // 程式執行結束\" maybe after each method. Example had End after entire flow. For each method we can have End. Provide \"End // 完成 insert\".\n\nBut we can choose to put End after each method. Not necessary but okay.\n\nLet's produce final answer with lines.\n\nWe must not output actual code, just virtual steps. Use Chinese. Ensure each line has \"虛擬碼步驟\" then space then comment. We will not include variable names? We can use pseudocode variable names.\n\nLet's craft final answer.\n...done thinking.\n\nStart // RandomizedSet 初始化\n→ Step 1: 初始化 values 為空列表 // 用於儲存所有元素\n→ Step 2: 初始化 idxMap 為空哈希表 // 存儲元素到索引的映射\nEnd // 初始化完成\n\nStart // insert(val) 方法\n→ Decision: 如果 val 在 idxMap? // 判斷元素是否已存在\n    Yes → Return false // 插入失敗，已存在\n    No  → Step 1: 將 val 加入 values 的末尾 // 添加新元素\n         → Step 2: 設定 idxMap[val] = values.size - 1 // 記錄新元素的位置\n         → Return true // 插入成功\nEnd // insert 完成\n\nStart // remove(val) 方法\n→ Decision: 如果 val 不在 idxMap? // 判斷元素是否存在\n    Yes → Return false // 刪除失敗，元素不存在\n    No  → Step 1: 取得 val 的索引 removeIdx = idxMap[val] // 找到要刪除的位置\n         → Step 2: 取得 values 的最後一個元素 lastVal = values.back() // 取得最後元素\n         → Step 3: values[removeIdx] = lastVal // 用最後元素覆蓋要刪除的位置\n         → Step 4: 更新 idxMap[lastVal] = removeIdx // 更新最後元素的新索引\n         → Step 5: values.pop_back() // 刪除最後一個元素\n         → Step 6: 刪除 idxMap[val] // 移除 val 的映射\n         → Return true // 刪除成功\nEnd // remove 完成\n\nStart // getRandom() 方法\n→ Step 1: 生成隨機整數 r 在 [0, values.size-1] // 隨機索引\n→ Step 2: 返回 values[r] // 返回隨機元素\nEnd // getRandom 完成"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[None,[0,0],[1,0],[2,0],None,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[None, [0, 0], [1, 0], [2, 0], None, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    \"\"\"Binary matrix flip and reset with O(1) random access.\"\"\"\n\n    def __init__(self, n_rows: int, n_cols: int):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols          # remaining zero cells\n        self.flipped = {}                     # mapping from virtual index to real index\n\n    def flip(self):\n        \"\"\"Return a random zero cell and flip it to one.\"\"\"\n        r = random.randint(0, self.total - 1)\n        # Get the real index that currently occupies position r\n        real_index = self.flipped.get(r, r)\n\n        # Decrease the count of remaining zeros\n        self.total -= 1\n\n        # Move the last unused index into position r\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n\n        # Convert 1‑D index back to 2‑D coordinates\n        return [real_index // self.cols, real_index % self.cols]\n\n    def reset(self):\n        \"\"\"Reset all cells to zero.\"\"\"\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\n\ndef main():\n    # Read the whole input; it consists of two Python lists separated by a comma\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split into the two lists\n    first_end = data.find(']')\n    if first_end == -1:\n        raise ValueError(\"Invalid input format\")\n\n    commands_str = data[:first_end + 1]\n    args_str = data[first_end + 2:].strip()  # skip comma and possible space\n\n    commands = ast.literal_eval(commands_str)\n    args = ast.literal_eval(args_str)\n\n    # Execute commands\n    result = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            obj = Solution(*arg)\n            result.append(None)\n        elif cmd == \"flip\":\n            result.append(obj.flip())\n        elif cmd == \"reset\":\n            obj.reset()\n            result.append(None)\n        else:\n            # Unknown command; append None\n            result.append(None)\n\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for algorithm: We can treat the matrix flattened as array of size m*n, use mapping to shuffle. Known solution: maintain list of available indices (0 to m*n-1). Use random index r from 0 to len-1, get idx=arr[r]; set arr[r] = arr[len-1]; reduce len. Then convert idx to (i,j). For reset, reset mapping: repopulate array or use next index approach. Use hash map for mapping. But we need minimal random calls: only one random per flip. We'll implement with vector 'available' and swap trick. Provide virtual code lines.\n\nWe need to output step lines: Start, Step 1: init variables, etc. Use Decision: and arrow. Provide explanation comments. Avoid actual code syntax, just structure. So produce like:\n\nStart // 程式開始\n→ Step 1: 初始化 m, n, total = m*n, idxList = [0..total-1], remaining = total // 設定變數\n→ Decision: 是否已經完成? (remaining == 0) // 檢查是否所有位置已被翻轉\n    Yes → Return None? maybe not needed\n    No  → Step 2: 隨機選取 r in [0, remaining-1] // 只呼叫一次 random\n→ Step 3: 取 idx = idxList[r] // 取得對應的平面索引\n→ Step 4: 交換 idxList[r] 和 idxList[remaining-1] // 移除已選\n→ Step 5: remaining-- // 減少可用數量\n→ Step 6: 將 idx 轉換為 (i, j) = (idx / n, idx % n) // 轉回座標\n→ Step 7: 返回 [i, j]\n→ Step 8: reset: 重新填充 idxList 為 0..total-1, remaining = total // 重置\n\nAlso maybe include Decision for reset? Not necessary.\n\nWe should format each line as \"虛擬碼步驟 // 解釋\".\n\nLet's produce lines accordingly. Provide multiple lines.\n\nEdge cases: no need to handle duplicates. Provide comments. Use arrow symbol only once per line? Format says \"虛擬碼步驟 [space] // 解釋\". So each line: \"Start // ...\". Use arrow \"→\" only at beginning of step lines. For decisions, we indent.\n\nLet's produce full flow:\n\nStart // 程式開始執行\n→ Step 1: Set m, n, total ← m * n // 計算矩陣大小\n→ Step 2: Create list indices ← [0, 1, …, total-1] // 代表所有可翻轉的位置\n→ Step 3: Set remaining ← total // 可用位置的個數\n→ Decision: 若 remaining == 0? // 檢查是否所有位置已翻轉\n    Yes → End // 若已無可翻轉位置，終止\n    No  → Step 4: 隨機產生 r ← RandomInt(0, remaining-1) // 只呼叫一次 random\n→ Step 5: idx ← indices[r] // 取得對應的線性索引\n→ Step 6: Swap indices[r] with indices[remaining-1] // 把已選位置移到末尾\n→ Step 7: remaining ← remaining - 1 // 更新剩餘可用數量\n→ Step 8: i ← idx / n // 計算行號\n→ Step 9: j ← idx % n // 計算列號\n→ Step 10: Return [i, j] // 回傳座標並完成 flip\n→ Step 11: reset() // 將所有位置重設為 0\n    → Step 12: Recreate indices ← [0, 1, …, total-1] // 重新填充索引\n    → Step 13: remaining ← total // 重設剩餘數量\n\nBut we might include reset as separate Start for function. Maybe separate function lines: \"→ Function reset:\" etc. Format may not require separate functions but we can represent as steps.\n\nHowever we must keep within format: each line with 虛擬碼步驟 // 解釋. Use arrow for steps, decision lines with indent. We'll produce code for flip and reset.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: m ← input_m, n ← input_n, total ← m * n // 初始化尺寸與總量\n→ Step 2: indices ← [0 … total-1] // 佈署可用索引池\n→ Step 3: remaining ← total // 可翻轉位置數\nEnd // 結束建構\n\nStart // flip 函式開始\n→ Decision: 若 remaining == 0? // 檢查是否已無可翻轉位置\n    Yes → Return null // 或適當處理\n    No  → Step 4: r ← RandomInt(0, remaining-1) // 隨機索引\n→ Step 5: idx ← indices[r] // 取得線性索引\n→ Step 6: indices[r] ↔ indices[remaining-1] // 將已選位置移至末尾\n→ Step 7: remaining ← remaining - 1 // 減少可用數量\n→ Step 8: i ← idx / n // 轉換為行號\n→ Step 9: j ← idx % n // 轉換為列號\n→ Step 10: Return [i, j] // 回傳並完成翻轉\nEnd // flip 函式結束\n\nStart // reset 函式開始\n→ Step 11: indices ← [0 … total-1] // 重新填充索引\n→ Step 12: remaining ← total // 重設剩餘數\nEnd // reset 函式結束\n\nBut the format might require no function naming; but okay.\n\nEnsure arrow usage: \"→\" at start of each step. For decision lines, we use \"Decision:\" and indent.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: m ← input_m, n ← input_n, total ← m * n // 初始化矩陣尺寸與總個數\n→ Step 2: indices ← [0 … total-1] // 建立所有可翻轉的位置池\n→ Step 3: remaining ← total // 記錄目前還有多少位置未被翻轉\nEnd // 建構完成\n\nStart // flip() 開始\n→ Decision: 若 remaining == 0? // 檢查是否所有位置已翻轉\n    Yes → Return null // 或擲例外，無法再翻轉\n    No  → Step 4: r ← RandomInt(0, remaining-1) // 只呼叫一次 random\n→ Step 5: idx ← indices[r] // 取得線性索引對應的矩陣位置\n→ Step 6: indices[r] ↔ indices[remaining-1] // 交換已選位置與池尾，移除已翻轉\n→ Step 7: remaining ← remaining - 1 // 更新可用位置數量\n→ Step 8: i ← idx / n // 計算行號\n→ Step 9: j ← idx % n // 計算列號\n→ Step 10: Return [i, j] // 回傳座標並完成翻轉\nEnd // flip() 結束\n\nStart // reset() 開始\n→ Step 11: indices ← [0 … total-1] // 重新填充所有索引池\n→ Step 12: remaining ← total // 重設剩餘可翻轉位置數\nEnd // reset() 結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp65_ke7ub.py\", line 34, in <module>\n    obj.buildDict(arg)\n  File \"/tmp/tmp65_ke7ub.py\", line 10, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    commands, args = ast.literal_eval(data)\n\n    results = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MagicDictionary\":\n            obj = MagicDictionary()\n            results.append(None)\n        elif cmd == \"buildDict\":\n            obj.buildDict(arg)\n            results.append(None)\n        elif cmd == \"search\":\n            res = obj.search(arg)\n            results.append(res)\n        else:\n            results.append(None)\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode. Should design MagicDictionary class with methods: constructor, buildDict, search. Use typical approach: store words in map by length or trie? Simpler: iterate over dictionary words, for each word, generate all variants with one wildcard? Approach: create a hash set of all words and a hash map of generic patterns: replace each character with '*' and map to count. For search, check if there exists pattern with count>1 or pattern exists but word not same. But requirement: exactly one character change. So typical solution: for each position in searchWord, replace with '*', check map.\n\nWe need virtual code steps with explanation per line. Use structure with Start, End, Decision. Provide each line with // explanation.\n\nLet's produce steps:\n\nStart\n→ Step 1: 初始化字典資料結構 // 建立存放單詞及通配符映射\n→ Step 2: 建構函式 MagicDictionary() // 只初始化空資料結構\n→ Step 3: 建構函式 buildDict(dictionary) // 將每個單詞加入字典並生成通配符模式\n    → For each word in dictionary\n        → For i from 0 to len(word)-1\n            → pattern = word[0:i] + '*' + word[i+1:]\n            → Increment map[pattern] count\n        → Add word to set\n→ Step 4: 建構函式 search(searchWord) // 檢查是否能改一個字母匹配\n    → For i from 0 to len(searchWord)-1\n        → pattern = searchWord[0:i] + '*' + searchWord[i+1:]\n        → If map contains pattern\n            → If map[pattern] > 1 OR word not equal to any word with this pattern // Actually need to check if there exists word different from searchWord\n                → Return true\n    → Return false\nEnd\n\nBut we must follow the specified format: Each line \"虛擬碼步驟 [space] // 解釋\". Use arrows for decision? We might need Decision: If map contains pattern? etc.\n\nLet's produce in order.\n\nNeed to include Step 1: Start // 程式開始執行\nBut that's the entire program? We produce pseudocode for class.\n\nBetter structure: Start\n→ Define class MagicDictionary\n    → Step 1: 初始化空集合 wordsSet and patternMap\n→ End\n\nBut we need to show methods.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 MagicDictionary 類別 // 建立類別框架\n    → Substep: wordsSet ← 空集合 // 用來存放所有單詞\n    → Substep: patternMap ← 空映射 // key: 通配符模式, value: 出現次數\n→ End // 類別定義結束\n→ Step 2: 建構子 MagicDictionary() // 初始化空資料結構\n    → wordsSet ← 空集合\n    → patternMap ← 空映射\n→ End // 建構子結束\n→ Step 3: 方法 buildDict(dictionary) // 建立字典\n    → For 每個 word 在 dictionary\n        → For i 從 0 到 len(word)-1\n            → pattern ← word[0:i] + '*' + word[i+1:]\n            → patternMap[pattern] ← patternMap.get(pattern,0) + 1\n        → wordsSet.add(word)\n→ End // buildDict 結束\n→ Step 4: 方法 search(searchWord) // 判斷是否能改一字匹配\n    → For i 從 0 到 len(searchWord)-1\n        → pattern ← searchWord[0:i] + '*' + searchWord[i+1:]\n        → Decision: patternMap.contains(pattern)?\n            Yes → If patternMap[pattern] > 1 OR searchWord not in wordsSet\n                → Return true\n            No → Continue\n    → Return false\n→ End // search 方法結束\nEnd // 程式執行結束\n\nBut must use \"Decision:\" lines. So maybe restructure:\n\nStep 4: 方法 search(searchWord)\n→ For i ...\n    → pattern = ...\n    → Decision: patternMap contains pattern?\n        Yes →\n            → Decision: patternMap[pattern] > 1 OR searchWord not in wordsSet?\n                Yes → Step: Return true\n                No → Continue\n        No → Continue\n→ Step: Return false\n\nNeed to include arrow \"→\" before each step.\n\nAlso need to include \"Start\" and \"End\".\n\nLet's write final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MagicDictionary 類別 // 建立類別框架  \n    → Substep 1.1: wordsSet ← 空集合 // 用於存放所有單字  \n    → Substep 1.2: patternMap ← 空映射 // key: 通配符模式, value: 出現次數  \n→ End // 類別定義結束  \n\n→ Step 2: MagicDictionary() // 建構子  \n    → wordsSet ← 空集合 // 初始化空集合  \n    → patternMap ← 空映射 // 初始化空映射  \n→ End // 建構子結束  \n\n→ Step 3: buildDict(dictionary) // 建立字典  \n    → For 每個 word 在 dictionary  \n        → For i 從 0 到 len(word)-1  \n            → pattern ← word[0:i] + '*' + word[i+1:] // 產生通配符模式  \n            → patternMap[pattern] ← patternMap.get(pattern,0) + 1 // 計數累加  \n        → wordsSet.add(word) // 加入單字集合  \n→ End // buildDict 結束  \n\n→ Step 4: search(searchWord) // 判斷是否能改一字匹配  \n    → For i 從 0 到 len(searchWord)-1  \n        → pattern ← searchWord[0:i] + '*' + searchWord[i+1:] // 產生通配符模式  \n        → Decision: patternMap.contains(pattern)? // 檢查是否存在此模式  \n            Yes → Decision: patternMap[pattern] > 1 OR searchWord ∉ wordsSet?  \n                Yes → Step 4.1: Return true // 有合法匹配，回傳真  \n                No → Continue // 不滿足條件，繼續檢查其他位置  \n            No → Continue // 沒有此模式，檢查下一個位置  \n    → Step 4.2: Return false // 所有位置都不符合，回傳假  \n→ End // search 方法結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find K Closest Elements",
      "source_file": "Leetcode/leetcode658.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "arr = [1,2,3,4,5], k = 4, x = 3",
          "expected_output": "[1,2,3,4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6sebflhs.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmp6sebflhs.py\", line 34, in main\n    data = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6sebflhs.py\", line 28, in parse_input\n    return eval(expr)\n           ^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'arr' is not defined"
        },
        {
          "example_index": 1,
          "input": "arr = [1,1,2,3,4,5], k = 4, x = -1",
          "expected_output": "[1,1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuh44qd50.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmpuh44qd50.py\", line 34, in main\n    data = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpuh44qd50.py\", line 28, in parse_input\n    return eval(expr)\n           ^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'arr' is not defined"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findClosestElements(self, arr, k, x):\n        \"\"\"\n        找出陣列 arr 中最接近 x 的 k 個元素，並以升序輸出。\n        使用二分搜尋確定左端點 left，使得 arr[left:left+k] 為答案。\n        \"\"\"\n        left, right = 0, len(arr) - k\n        while left < right:\n            mid = (left + right) // 2\n            # 判斷哪一側更接近 x\n            if x - arr[mid] > arr[mid + k] - x:\n                left = mid + 1\n            else:\n                right = mid\n        return arr[left:left + k]\n\ndef parse_input(raw: str):\n    \"\"\"\n    將輸入字串轉換為字典 {'arr': [...], 'k': int, 'x': int}。\n    允許輸入格式為「arr = [1,2,3], k = 4, x = 5」等。\n    \"\"\"\n    # 把等號改成冒號，方便轉成字典字面量\n    raw = raw.replace('=', ':')\n    # 用花括號包起來，形成合法的 dict 表達式\n    expr = '{' + raw + '}'\n    return eval(expr)\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    data = parse_input(raw_input)\n    arr = data['arr']\n    k = data['k']\n    x = data['x']\n    solution = Solution()\n    result = solution.findClosestElements(arr, k, x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step. We must follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. For algorithm: Given sorted arr, find k closest to x. Approach: binary search to find closest index; then expand window of size k by two pointers. Let's produce steps.\n\nLine1: Start // 程式開始執行\nLine2: → Step 1: 二分搜尋找到 x 或最接近的索引 // 找出 x 或最近的元素索引\nLine3: → Decision: index 是否存在於 arr？ // 判斷是否直接找到 x\n    Yes → Step 2: left = index, right = index // 若找到 x，左右指針同為 index\n    No → Step 2: left = index - 1, right = index // 若未找到，左右分別指向兩邊最近\nLine4: → Step 3: 初始化結果集合 emptyList // 用於存儲 k 個最近元素\nLine5: → While: 結果數量 < k // 循環直到收集 k 個元素\n    → Decision: left 是否超出邊界? 或 right 是否超出邊界? // 檢查邊界\n        Yes → Decision: 左邊界超出? // 如果只有一側還有元素\n            Yes → Step 4: 加入 arr[right] 至結果， right++ // 取右側\n            No  → Step 4: 加入 arr[left] 至結果， left-- // 取左側\n        No  → Step 4: Decision: |arr[left]-x| ≤ |arr[right]-x| // 比較距離\n                Yes → Step 4: 加入 arr[left] 至結果， left-- // 取左側\n                No  → Step 4: 加入 arr[right] 至結果， right++ // 取右側\nLine6: → Step 5: 將結果集合排序 ascending // 排序以符合輸出要求\nLine7: End // 程式執行結束\n\nWe need to output each line with // explanation. Use arrow, indentation for nested decisions. Each line must be one of the steps. Use \"Decision:\" lines. Use arrow for Yes / No. Let's produce.\n\nMake sure each line is separate and no extra content. Use proper indentation spaces to show hierarchy maybe 4 spaces. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 二分搜尋找到 x 或最接近的索引 // 找出 x 或最近的元素索引\n→ Decision: 是否直接找到 x? // 判斷搜尋結果是否正好為 x\n    Yes → Step 2: left = index, right = index // 若找到 x，左右指針同為 index\n    No  → Step 2: left = index - 1, right = index // 若未找到，左右分別指向兩邊最近\n→ Step 3: 初始化結果集合 emptyList // 用於存儲 k 個最近元素\n→ While: 結果數量 < k // 循環直到收集 k 個元素\n    → Decision: 左右指針是否超出邊界? // 檢查是否只有一側還有元素\n        Yes → Decision: 左指針已越界? // 判斷是哪側已結束\n            Yes → Step 4: 加入 arr[right] 至結果， right++ // 取右側元素\n            No  → Step 4: 加入 arr[left] 至結果， left-- // 取左側元素\n        No  → Step 4: Decision: |arr[left]-x| ≤ |arr[right]-x| // 比較左右距離\n                Yes → Step 4: 加入 arr[left] 至結果， left-- // 取距離較近的左側\n                No  → Step 4: 加入 arr[right] 至結果， right++ // 取距離較近的右側\n→ Step 5: 將結果集合排序 ascending // 排序以符合輸出要求\nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbldv2s4r.py\", line 59, in <module>\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbldv2s4r.py\", line 18, in __init__\n    self.lookup[(pref, suff)] = weight  # 之後的索引更大，會覆寫\n    ~~~~~~~~~~~^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    \"\"\"\n    建構 WordFilter 時，預先把所有可能的前綴 + 後綴組合\n    以字典存下來，key 為 (prefix, suffix)，value 為最大索引。\n    \"\"\"\n    def __init__(self, words):\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            # 逐字建立所有前綴、後綴組合\n            for i in range(L + 1):\n                pref = word[:i]\n                for j in range(L + 1):\n                    suff = word[j:]\n                    self.lookup[(pref, suff)] = weight  # 之後的索引更大，會覆寫\n\n    def f(self, prefix, suffix):\n        \"\"\"回傳符合前綴、後綴的最大索引，若不存在則回傳 -1\"\"\"\n        return self.lookup.get((prefix, suffix), -1)\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，格式為：\n        <words array>, <[prefix, suffix] array>\n    例如： '[\"apple\",\"banana\"], [\"a\", \"n\"]'\n    \"\"\"\n    data = data.strip()\n    # 找第一個完整的 words list 結束的位置\n    depth = 0\n    pos = -1\n    for i, ch in enumerate(data):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n            if depth == 0:\n                pos = i\n                break\n    if pos == -1:\n        raise ValueError(\"Invalid input format\")\n\n    words_str = data[:pos+1]\n    rest = data[pos+2:].strip()  # 跳過 ','\n    pref_suff_str = rest\n\n    words = ast.literal_eval(words_str)\n    pref_suff = ast.literal_eval(pref_suff_str)\n    return words, pref_suff[0], pref_suff[1]\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    words, pref, suff = parse_input(raw_input)\n\n    # 建構字典並查詢\n    wf = WordFilter(words)\n    result = wf.f(pref, suff)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the design. Provide a step-by-step algorithm. No actual code, just pseudocode lines with arrows and explanations. The algorithm: For each word, we might precompute prefix-suffix pairs? Typical solution uses Trie for prefixes and suffixes. But we can also use hash map mapping (prefix, suffix) -> max index. But there could be many combinations.\n\nSimpler: Build a trie of words reversed for suffix and forward for prefix, with indices. For each query, traverse both tries to find intersection. However we can store at each node the max index of words that pass through that node. Then we can combine by scanning prefix nodes and suffix nodes and find common index? Another approach: Use a hash map storing key = prefix + \"#\" + suffix -> max index. For all words, for all prefixes and suffixes. That is O(N*L^2). Not efficient.\n\nBut since it's virtual code, we don't need actual complexity analysis, just steps.\n\nWe'll describe: Build prefix trie: each node has children map and list of indices or max index. Similarly suffix trie (reversed words). For query, find all indices that match prefix by traversing prefix trie, collect indices (or node's index list). Find all indices that match suffix via suffix trie. Then intersect to find max index.\n\nAlternatively, we can store at each node a list of word indices sorted descending, then when querying, we traverse prefix node, suffix node, then two-pointer to find largest common.\n\nWe will produce steps:\n\n1. WordFilter constructor: Build prefix trie and suffix trie with nodes containing maxIndex and child map.\n2. For each word with index i:\n   - Insert into prefix trie: for each char c, create node if missing, set node.maxIndex = i (since processing in order, later index is larger, so set).\n   - Insert into suffix trie: reverse word, same insertion.\n3. Query f(pref, suff):\n   - Traverse prefix trie to node for pref; if not found, return -1.\n   - Traverse suffix trie for reversed suff; if not found, return -1.\n   - Use two-pointer technique on the lists of indices stored at these nodes? But we only stored maxIndex. Actually we need all indices to find intersection. Could store list of indices for each node sorted ascending or descending. Then use two-pointer to find max common.\n\nSimplify: store at each node a set of indices sorted ascending. Then intersection by merging.\n\nWe will produce pseudocode accordingly.\n\nAlso include Start, End.\n\nLet's produce virtual code:\n\nStart\n→ BuildTrie(prefixTrie)\n→ BuildTrie(suffixTrie)\n→ For each word, index in words:\n    → Insert into prefixTrie with index\n    → Insert into suffixTrie with reversed word and index\nEnd\n\nFunction f(pref, suff):\n    → nodePref = traverse prefixTrie with pref\n    → Decision: nodePref exists? If No → return -1\n    → nodeSuff = traverse suffixTrie with reversed suff\n    → Decision: nodeSuff exists? If No → return -1\n    → listPref = nodePref.indices // sorted ascending\n    → listSuff = nodeSuff.indices // sorted ascending\n    → i = 0; j = 0; maxIdx = -1\n    → Decision: i < len(listPref) and j < len(listSuff)? while loop\n        → Decision: listPref[i] == listSuff[j]? Yes → set maxIdx = listPref[i]; i++; j++\n        → Decision: listPref[i] < listSuff[j]? Yes → i++ else j++\n    → return maxIdx\n\nOk.\n\nWe'll produce each step with explanation.\n\nMake sure each line ends with // explanation.\n\nUse arrows appropriately.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ BuildTrie(prefixTrie) // 初始化前綴字典樹\n→ BuildTrie(suffixTrie) // 初始化後綴（逆序）字典樹\n\n→ ForEach word, index in words // 逐個處理單詞\n    → InsertWord(prefixTrie, word, index) // 將單詞插入前綴字典樹，並把索引記錄於節點\n    → InsertWord(suffixTrie, Reverse(word), index) // 將逆序單詞插入後綴字典樹，索引同樣記錄於節點\n\nEnd // 建構完成\n\n//----------------------------------------------\n// 函式：f(前綴, 後綴) 取得滿足條件的最大索引\n//----------------------------------------------\nStart // f 函式開始\n→ nodePref = Traverse(prefixTrie, pref) // 從前綴字典樹找到對應節點\n    Decision: nodePref 不是 null? // 檢查前綴是否存在\n        Yes → \n        No  → Return -1 // 前綴不存在，直接返回 -1\n\n→ nodeSuff = Traverse(suffixTrie, Reverse(suff)) // 從後綴字典樹找到對應節點\n    Decision: nodeSuff 不是 null? // 檢查後綴是否存在\n        Yes → \n        No  → Return -1 // 後綴不存在，直接返回 -1\n\n→ listPref = nodePref.indices // 取得前綴節點下所有索引（已升序排列）\n→ listSuff = nodeSuff.indices // 取得後綴節點下所有索引（已升序排列）\n\n→ i = 0 // 初始化前綴索引指標\n→ j = 0 // 初始化後綴索引指標\n→ maxIdx = -1 // 最高符合條件的索引\n\n→ Decision: i < len(listPref) AND j < len(listSuff)? // 若兩個索引列表均未遍歷完畢\n    Yes →\n        Decision: listPref[i] == listSuff[j]? // 兩索引相同\n            Yes → maxIdx = listPref[i]; i++; j++ // 記錄此索引，並同時向前移動兩指標\n            No  → Decision: listPref[i] < listSuff[j]? // 前綴索引較小\n                Yes → i++ // 前綴索引往後移動\n                No  → j++ // 後綴索引往後移動\n        Repeat Decision loop // 繼續尋找較大相同索引\n    No  → // 循環結束\n\n→ Return maxIdx // 回傳最大符合條件的索引，若不存在則為 -1\n\nEnd // f 函式結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Divide Array in Sets of K Consecutive Numbers",
      "source_file": "Leetcode/leetcode1296.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,3,4,4,5,6], k = 4",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9qv71rub.py\", line 38, in <module>\n    nums, k = parse_input(data)\n              ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9qv71rub.py\", line 29, in parse_input\n    nums = eval(nums_str)\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpilmgp5gz.py\", line 38, in <module>\n    nums, k = parse_input(data)\n              ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpilmgp5gz.py\", line 29, in parse_input\n    nums = eval(nums_str)\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpscf73jkv.py\", line 38, in <module>\n    nums, k = parse_input(data)\n              ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpscf73jkv.py\", line 29, in parse_input\n    nums = eval(nums_str)\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def isPossibleDivide(self, nums, k):\n        if len(nums) % k != 0:\n            return False\n        count = Counter(nums)\n        for num in sorted(count):\n            freq = count[num]\n            if freq > 0:\n                for i in range(num, num + k):\n                    if count[i] < freq:\n                        return False\n                    count[i] -= freq\n        return True\n\ndef parse_input(input_str):\n    \"\"\"Parse input of the form 'nums = [...], k = X'.\"\"\"\n    if not input_str:\n        return [], 0\n    # Split by comma that separates nums and k\n    parts = input_str.split(',')\n    if len(parts) < 2:\n        raise ValueError(\"Input must contain nums and k\")\n    # Extract list\n    nums_part = parts[0].strip()\n    nums_str = nums_part.split('=', 1)[1].strip()\n    nums = eval(nums_str)\n    # Extract k\n    k_part = parts[1].strip()\n    k_str = k_part.split('=', 1)[1].strip()\n    k = int(k_str)\n    return nums, k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    nums, k = parse_input(data)\n    solution = Solution()\n    result = solution.isPossibleDivide(nums, k)\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: given array nums and k, check if can divide into sets of k consecutive numbers. This is LeetCode problem 659. Approach: frequency map, sorted keys, iterate from smallest to largest, for each number, if count>0, try to take a consecutive block of length k, decrement counts. If any count becomes negative or missing, return false. Complexity O(n log n).\n\nSo produce steps: Start, build frequency map, sort keys, iterate, check.\n\nLet's write lines with arrows and decisions. Provide explanation comments after each line.\n\nUse \"Start // 程式開始執行\". Use \"→ Step 1: ...\". Use \"Decision:\" etc.\n\nLet's craft.\n\nPotential steps:\n\n1. Start\n2. Build frequency map of nums: freq[nums[i]]++.\n3. Sort unique numbers ascending: sortedNums.\n4. For each num in sortedNums:\n   Decision: if freq[num] > 0? (Yes: need to process block)\n5. Set count = freq[num].\n   For i from 0 to k-1:\n       current = num + i\n       Decision: if freq[current] >= count? (Yes: decrement)\n           freq[current] -= count\n       Else: // not enough consecutive numbers\n           Return false\n6. After loop, continue to next num.\n7. End // return true\n\nNeed to use arrow and decisions with Yes→/No→.\n\nLet's craft lines accordingly.\n\nWe need each line \"虛擬碼步驟 [space] // 解釋\".\n\nLet's output step by step.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個頻率表 freq // 建立一個哈希表來記錄每個數字出現的次數  \n→ Step 2: 遍歷 nums，對每個值 x 執行 freq[x]++ // 统计每个整数的出现次数  \n→ Step 3: 取出 freq 的鍵，並按升序排序得到 sortedNums // 方便按从小到大的顺序处理  \n→ Step 4: 對 sortedNums 中的每個 num 進行以下操作 // 逐个检查每个数  \n    Decision: 如果 freq[num] > 0? // 只有出现次数大于 0 的数字才需要处理  \n        Yes → Step 5: 设 count = freq[num] // 记录当前数字的出现次数，后面会用来减去连续块  \n        → Step 6: 循环 i 从 0 到 k-1 // 为了形成长度为 k 的连续区间  \n            Decision: 如果 freq[num + i] >= count? // 检查连续位置是否有足够的数  \n                Yes → Step 7: freq[num + i] -= count // 减去对应的次数，完成一次完整的区间  \n                No → Step 8: Return false // 若缺少足够的数，无法完成划分，直接返回错误  \n        → Step 9: // 完成当前数字的连续块处理，继续循环到下一个 num  \n    No → Step 10: // freq[num] == 0，跳过该数字，继续循环到下一个 num  \n→ End // 所有数字都已处理完毕，返回 true，表示可以划分为 k 个连续数集  \n→ Step 11: Return true // 说明满足条件，可成功划分成 k 连续数集"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,4,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 4, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    \"\"\"\n    Solution class that stores indices of each number for O(1) random selection.\n    \"\"\"\n    def __init__(self, nums):\n        \"\"\"\n        Initialize the object with the list of numbers.\n        \"\"\"\n        self.indices = {}\n        for i, num in enumerate(nums):\n            self.indices.setdefault(num, []).append(i)\n\n    def pick(self, target):\n        \"\"\"\n        Return a random index where nums[i] == target.\n        Each valid index has equal probability.\n        \"\"\"\n        return random.choice(self.indices[target])\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Parse the input into operations and arguments\n    # Input format: ops, args_list separated by a comma\n    data = ast.literal_eval('[' + raw_input + ']')\n    ops, args_list = data\n\n    results = []\n    obj = None\n\n    for op, args in zip(ops, args_list):\n        if op == 'Solution':\n            # Instantiate Solution with provided nums\n            obj = Solution(*args)\n            results.append(None)  # Constructor returns None\n        else:\n            # Call the method and store its result\n            result = getattr(obj, op)(*args)\n            results.append(result)\n\n    # Print the results in JSON format to match expected output\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. Should include steps: constructor storing array, maybe storing mapping from target to list of indices for O(1) pick. Or use reservoir sampling during pick. Provide decision structure? But requirement: use virtual code with arrow and structure. Provide Start, End, Decision. Need to produce virtual code for whole algorithm.\n\nWe will show Start, Step: initialize map, etc. Then pick: use reservoir sampling: iterate over array, if nums[i]==target, increment count, with probability 1/count choose i. At the end return chosen index. Provide explanation each line.\n\nLet's produce lines:\n\nStart\n→ Step 1:  建立一個空字典 targetToIndices // 用於儲存每個目標值對應的索引列表\n→ Step 2:  從傳入的陣列 nums 遍歷並將索引加入對應目標值的列表 // 準備快速存取\n→ Step 3:  完成建構 // 初始化結束\nEnd // 建構完成\n\nThen pick function:\n\nStart\n→ Step 1:  初始化 count = 0, result = -1 // 進行 reservoir sampling\n→ Decision: 遍歷 nums 的每個索引 i // 為每個元素做判斷\n    → Step 2:  如果 nums[i] == target\n        → Step 3:  count += 1 // 有一個符合的索引\n        → Decision: 產生隨機整數 r 在 [1, count] 中\n            Yes → (r == 1) // 判斷是否選中\n                → Step 4:  result = i // 若被選中，記錄索引\nEnd // 迴圈結束\n→ Step 5:  回傳 result // 返回隨機選取的索引\n\nBut we need to use arrow for decisions: Decision: ...; Yes → ; No →. For random number, we can just show as Decision: 隨機 r 在 1 到 count 中; Yes → r==1? Actually we need condition: r == 1; Yes → set result. No → ignore.\n\nLet's craft proper pseudo.\n\nWe should show lines with arrows; Each line includes '虛擬碼步驟' + ' // 解釋'. So each line is e.g.:\n\nStart // 程式開始執行\n\n→ Step 1: ... // explanation\n\nWe should show nested decisions with indentation? In example they indent. We can indent accordingly.\n\nLet's produce.\n\nWe need to include \"Decision:\" lines for conditionals. For the pick function, inside loop, we need a decision to check if nums[i] == target. That is a Decision line with Yes and No branches. But we can keep it simple: use Decision: if nums[i]==target? Yes → increment count, etc.\n\nOk.\n\nAlso we need to maintain that we don't produce actual code; just pseudo.\n\nWe also should include mapping building logic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1:  建立空字典 `targetToIndices` // 用於存放每個數值對應的所有索引  \n→ Step 2:  對於 `index` 從 0 到 nums.length-1  \n  → Decision: nums[index] 是否已存在於 `targetToIndices`? // 檢查是否已為此目標建立索引清單  \n   Yes → Step 3a:  在 `targetToIndices[nums[index]]` 的清單中加入 `index` // 已有清單，直接加入  \n   No  → Step 3b:  新建清單 `[index]` 並加入 `targetToIndices[nums[index]]` // 第一次遇到此目標  \n→ Step 4:  完成建構 // 所有目標值的索引已存儲  \nEnd // 建構結束  \n\n---  \n\nStart // pick 方法開始執行  \n→ Step 1:  設定 `count = 0`, `chosenIndex = -1` // 準備 reservoir sampling  \n→ Step 2:  遍歷 `index` 從 0 到 nums.length-1  \n  → Decision: nums[index] == target? // 檢查是否符合目標  \n   Yes → Step 3a:  `count += 1` // 有一個符合的索引  \n    → Decision: 產生隨機整數 r 在 1 到 `count` 之間  \n     Yes → r == 1? // 判斷是否被選中  \n      Yes → Step 3b:  `chosenIndex = index` // 這個索引被選中  \n      No  → Step 3c:  留空 // 沒被選中，保持之前選中的索引  \n    No  → Step 3d:  留空 // 不是目標，跳過  \n→ Step 4:  回傳 `chosenIndex` // 返回隨機選取的索引  \nEnd // pick 方法結束\n\n---  \n\n// 以上虛擬碼展示了使用字典快速定位目標索引，以及利用 reservoir sampling 為多重索引提供等機率選取。"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[2,3]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[2, 3]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1], [0, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立字典：每個字串的反向映射到其索引\n        reverse_map = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        # 檢查是否有空字串，若有則與所有回文字串配對\n        if \"\" in words:\n            empty_idx = words.index(\"\")\n            for j, w in enumerate(words):\n                if j != empty_idx and self.is_palindrome(w):\n                    res.append([empty_idx, j])\n                    res.append([j, empty_idx])\n\n        # 針對每個字串進行所有可能的切分\n        for i, word in enumerate(words):\n            word_len = len(word)\n            for j in range(word_len + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                # 情況一：前綴是回文，後綴存在於字典\n                if self.is_palindrome(prefix):\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in reverse_map:\n                        k = reverse_map[rev_suffix]\n                        if k != i:\n                            res.append([i, k])\n\n                # 情況二：後綴是回文，前綴存在於字典\n                # 避免重複：j != 0 保證前綴非空\n                if j != 0 and self.is_palindrome(suffix):\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in reverse_map:\n                        k = reverse_map[rev_prefix]\n                        if k != i:\n                            res.append([k, i])\n\n        return res\n\n    @staticmethod\n    def is_palindrome(s: str) -> bool:\n        \"\"\"判斷字串是否為回文\"\"\"\n        return s == s[::-1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，例如 \"words = [\\\"abcd\\\",\\\"dcba\\\",\\\"lls\\\",\\\"s\\\",\\\"sssll\\\"]\"\n    if \"=\" in data:\n        _, words_part = data.split(\"=\", 1)\n        words_part = words_part.strip()\n    else:\n        words_part = data\n\n    # 使用 ast.literal_eval 以安全方式解析字串\n    words = ast.literal_eval(words_part)\n\n    sol = Solution()\n    result = sol.palindromePairs(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudocode steps. The requirement: virtual code, no actual code. Must explain each line. Must be O(total length). For palindrome pairs problem, typical solution uses hash map of reversed strings. We need to outline steps: build map of word -> index. For each word, iterate over splits, check palindrome prefixes/suffixes, and look up reversed complement. Must avoid duplicate pairs.\n\nWe need to output in specified format, each line: \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nWe need to produce steps: Start, Build map, For each word i, for each split position from 0 to len, check palindrome prefix and suffix, etc. Also handle empty string special case.\n\nAlso need to avoid duplicates: we can store pairs sorted or only add when i < j. But we can just produce all and deduplicate.\n\nLet's craft pseudocode lines. Need to be clear.\n\nWe'll produce steps: Start, Build map, For each word i: iterate over splits, etc.\n\nLet's output in Chinese comments.\n\nAlso need to include decisions with arrow Yes/No.\n\nWe'll produce:\n\nStart // 程式開始執行\n\n→ Step 1: 建立字典 reverse_map，將每個字串的反向映射到其索引 // 方便快速查找\n\n→ Step 2: 初始化空列表 pairs // 儲存所有符合條件的索引對\n\n→ Decision: 是否有空字串在 words? // 空字串與任何回文字串都可形成對\n\n    Yes → For each word j ≠ empty_index: If word[j] is palindrome → pairs add (empty_index, j) and (j, empty_index) // 兩種順序\n\n    No → // 無需處理\n\n→ For each index i, word in words: // 主迴圈\n\n    → For split pos from 0 to len(word): // 分割位置\n\n        → Decision: 前綴 word[0:pos] 是否為回文? // 若為回文\n\n            Yes → suffix = word[pos:] // 後綴\n\n                → Decision: suffix 在 reverse_map? // 以查找相對的反向字串\n\n                    Yes → j = reverse_map[suffix]\n\n                        → Decision: j != i? // 防止自對\n\n                            Yes → pairs add (j, i) // 因為 suffix + prefix = palindrome\n\n                            No → // skip\n\n                    No → // 無對應字串\n\n            No → // 前綴非回文，跳過\n\n        → Decision: 後綴 word[pos:] 是否為回文? // 另一種情況\n\n            Yes → prefix = word[0:pos]\n\n                → Decision: prefix 在 reverse_map? // 查找對應反向\n\n                    Yes → j = reverse_map[prefix]\n\n                        → Decision: j != i?\n\n                            Yes → pairs add (i, j) // 前綴 + suffix = palindrome\n\n                            No → // skip\n\n                    No → // 無對應\n\n            No → // 後綴非回文，跳過\n\n→ End // 程式結束，返回 pairs\n\nWe also need to ensure that for splits where pos==len(word) or pos==0 we treat appropriately: When pos==len(word), prefix is whole word, suffix empty string. If suffix is empty, we check reverse_map['']? That would be empty string index. That will handle empty string pair. But we already handle empty separately.\n\nBut we can keep logic.\n\nMake sure to use arrows \"→\".\n\nLet's format each line with \"虛擬碼步驟\" then space then comment.\n\nWe need to use \"→\" and \"Decision:\" etc.\n\nWe should keep each line separate. Let's craft lines.\n\nNeed to keep consistent indentation? Not required but may help readability.\n\nWe'll use arrow for each step line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 reverse_map，將每個字串的反向映射到其索引 // 方便快速查找  \n→ Step 2: 初始化空列表 pairs // 儲存所有符合條件的索引對  \n→ Decision: words 中是否有空字串？ // 空字串可與任何回文字串配對  \n Yes → Step 3: 找出空字串的索引 empty_idx  \n  → For each index j ≠ empty_idx: // 逐個字串  \n    → Decision: words[j] 是否為回文？  \n     Yes → pairs add (empty_idx, j) // 空+回文  \n     Yes → pairs add (j, empty_idx) // 回文+空  \n     No → // 不是回文，跳過  \n No → // 沒有空字串，無需特別處理  \n→ For each index i, word in words: // 主迴圈，檢查每個字串  \n → For split_pos from 0 to len(word): // 逐位分割  \n  → Decision: 前綴 word[0:split_pos] 是否為回文？  \n   Yes → suffix = word[split_pos:]  \n    → Decision: suffix 是否存在於 reverse_map？  \n     Yes → j = reverse_map[suffix]  \n      → Decision: j ≠ i？  \n       Yes → pairs add (j, i) // suffix+prefix 為回文  \n       No → // 自對，跳過  \n     No → // 無對應字串  \n   No → // 前綴非回文，跳過  \n  → Decision: 後綴 word[split_pos:] 是否為回文？  \n   Yes → prefix = word[0:split_pos]  \n    → Decision: prefix 是否存在於 reverse_map？  \n     Yes → j = reverse_map[prefix]  \n      → Decision: j ≠ i？  \n       Yes → pairs add (i, j) // 前綴+suffix 為回文  \n       No → // 自對，跳過  \n     No → // 無對應字串  \n   No → // 後綴非回文，跳過  \nEnd // 程式執行結束，返回 pairs"
    },
    {
      "title": "Implement Queue using Stacks",
      "source_file": "Leetcode/leetcode232.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,1,false]'\nGot (Norm):      '[null,null,null,[1],[1],false]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, 1, false]'\nRaw Got:      '[null, null, null, [1], [1], false]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyQueue:\n    def __init__(self):\n        # 兩個堆疊，stack_in 儲存進隊的元素，stack_out 儲存即將出隊的元素\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        # 直接將新元素推到進堆疊\n        self.stack_in.append(x)\n\n    def pop(self):\n        # 若 stack_out 為空，先把所有 stack_in 的元素轉移過來\n        self.peek()\n        # 從 stack_out 彈出最先進隊的元素\n        return self.stack_out.pop()\n\n    def peek(self):\n        # 若 stack_out 為空，將 stack_in 的元素全部轉移至 stack_out\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        # stack_out 的頂部即為隊列前端元素\n        return self.stack_out[-1]\n\n    def empty(self):\n        # 當兩個堆疊皆空時，隊列為空\n        return not self.stack_in and not self.stack_out\n\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入，除去可能存在的 'Input' 標頭\n    raw_input = sys.stdin.read().strip().splitlines()\n    if raw_input and raw_input[0].strip().startswith(\"Input\"):\n        raw_input = raw_input[1:]\n\n    # 解析操作名稱與參數\n    ops = ast.literal_eval(raw_input[0].strip())\n    args = ast.literal_eval(raw_input[1].strip())\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyQueue\":\n            obj = MyQueue()\n            results.append(None)\n        elif op == \"push\":\n            obj.push(arg)\n            results.append(None)\n        elif op == \"pop\":\n            results.append(obj.pop())\n        elif op == \"peek\":\n            results.append(obj.peek())\n        elif op == \"empty\":\n            results.append(obj.empty())\n\n    # 輸出結果，使用 json.dumps 可將 None 轉為 null，True/False 轉為 true/false\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing a queue using two stacks. Each line: virtual step + // explanation. Use Start, End, Decision, arrows. No actual code, only pseudo-steps. Should be line-by-line.\n\nWe need to cover push, pop, peek, empty methods. We need to maintain two stacks: stack_in and stack_out. On push: push to stack_in. On pop/peek: if stack_out empty, transfer all from stack_in to stack_out. Then pop/peek from stack_out.\n\nAlso empty: check both stacks empty.\n\nWe need to provide steps for class definition and methods.\n\nSo format:\n\nStart // 開始程式\n\n→ Step: Initialize stack_in, stack_out // 初始化兩個堆疊\n\nThen methods.\n\nMaybe we need separate methods pseudo. Provide as separate blocks.\n\nLet's craft.\n\nWe can include method definitions as separate steps.\n\nMake sure each line includes virtual code step and comment.\n\nUse arrow → for next steps.\n\nUse Decision: for condition checks.\n\nAlso mention loops.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個空堆疊 stack_in、stack_out // 用來儲存進入與移除元素的兩個堆疊  \n\n// -------- push 方法 --------  \n→ Step 2: 定義 push(x) // 進行進隊操作  \n→   → Step 3: 將 x 推入 stack_in // 直接把新元素放到進堆疊頂部  \n\n// -------- pop 方法 --------  \n→ Step 4: 定義 pop() // 進行出隊操作  \n→   → Decision: 若 stack_out 為空? // 需要先把前面的元素移到出堆疊  \n        Yes → Step 5: 重複直到 stack_in 為空: pop stack_in → push 到 stack_out // 將所有進堆疊的元素反轉順序放入出堆疊  \n        No  → No operation // 若 stack_out 已有元素，跳過轉移  \n→   → Step 6: 從 stack_out 彈出頂部元素並返回 // 這即為隊列前端元素  \n\n// -------- peek 方法 --------  \n→ Step 7: 定義 peek() // 取得前端元素但不移除  \n→   → Decision: 若 stack_out 為空? // 同樣需要將元素搬到出堆疊  \n        Yes → Step 8: 重複直到 stack_in 為空: pop stack_in → push 到 stack_out // 轉移  \n        No  → No operation // 已有元素，保持不變  \n→   → Step 9: 取 stack_out 頂部元素但不彈出並返回 // 取得前端值  \n\n// -------- empty 方法 --------  \n→ Step 10: 定義 empty() // 檢查隊列是否為空  \n→   → Decision: 若 stack_in 與 stack_out 均為空?  \n        Yes → Step 11: 回傳 true // 隊列空  \n        No  → Step 12: 回傳 false // 隊列非空  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\ndef find_lus_length(strs):\n    \"\"\"\n    依據題意求「最長不常見子序列」的長度。\n    1. 若某個字串在陣列中唯一，則它本身即為不常見子序列，長度即為答案。\n    2. 若所有字串均相同，則不存在不常見子序列，回傳 -1。\n    \"\"\"\n    freq = Counter(strs)          # 統計每個字串出現的次數\n    max_len = -1                  # 初始答案為 -1，表示尚未找到\n    for s in strs:\n        if freq[s] == 1:          # 只要遇到唯一字串，即可更新最大長度\n            max_len = max(max_len, len(s))\n    return max_len\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個資料，並去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(-1)\n    else:\n        # 解析 JSON 格式的字串陣列，例如 '[\"aba\",\"cdc\",\"eae\"]'\n        try:\n            strs = json.loads(raw_input)\n            if not isinstance(strs, list):\n                raise ValueError\n        except Exception:\n            # 若輸入不是合法的 JSON 陣列，則直接輸出 -1\n            print(-1)\n        else:\n            result = find_lus_length(strs)\n            print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem, in Traditional Chinese, following the format. No actual code. Need to reason about algorithm: longest uncommon subsequence in array of strings.\n\nObservation: If any string is unique among array, answer is length of that string. Else, if all strings equal, no uncommon subsequence exists -> -1. Because any subsequence of a string is also a subsequence of identical string. So algorithm: count frequency of each string. For each string in array, if its frequency is 1, return its length (max). If none unique, return -1.\n\nNeed to handle multiple unique lengths, choose max. Steps: Start; read input array; compute frequency map; initialize maxLen = -1; iterate through array: if freq[str]==1 and len>maxLen => update; end loop; output maxLen. End.\n\nWe need to use virtual code lines with arrows. We'll include Start, Step 1, Step 2, etc. Use Decision for checking uniqueness. Provide explanation comments.\n\nLet's produce step-by-step.\n\nWe need to adhere to format: each line \"虛擬碼步驟 // 解釋\". Use arrows like \"→ Step 1:\".\n\nWe need to show decisions: For each string: check if freq==1.\n\nLet's write:\n\nStart\n→ Step 1: 建立空字典 freq // 初始化字典用於統計每個字串出現次數\n→ Step 2: 對 strs 中每個字串 str 執行 freq[str]++ // 計算頻率\n→ Step 3: 初始化 maxLen ← -1 // 儲存最大長度，預設 -1 表示尚未找到\n→ Step 4: 對 strs 中每個字串 str 執行\n    → Decision: freq[str] == 1 ?\n        Yes → Step 5: 更新 maxLen ← max(maxLen, len(str)) // 若該字串唯一，更新最大長度\n        No  → Step 5a: 跳過 // 不是唯一，忽略\n→ End // 輸出 maxLen 作為結果\n\nBut we need arrow before each line and use arrow for inner decisions maybe indent. Format example shows indentation for decision branches. Use \"→ Decision:\" with indentation. Need to ensure each line has \"虛擬碼步驟\". Example shows \"→ Decision: 如果數字大於 0?\" then indent \"Yes → Step 2:\" etc.\n\nSo we should structure accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 freq // 初始化字典用於統計每個字串出現次數  \n→ Step 2: 對 strs 中每個字串 str 執行 freq[str]++ // 計算頻率  \n→ Step 3: 初始化 maxLen ← -1 // 儲存最大長度，預設 -1 表示尚未找到  \n→ Step 4: 對 strs 中每個字串 str 執行  \n    → Decision: freq[str] == 1? // 檢查該字串是否唯一  \n        Yes → Step 5: 更新 maxLen ← max(maxLen, len(str)) // 若唯一，更新最大長度  \n        No → Step 5a: 跳過 // 不是唯一，忽略該字串  \n→ End // 輸出 maxLen 作為結果，若仍為 -1 則表示不存在不常見子序列"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        \"\"\"找出重複出現的 10 字長 DNA 子字串\"\"\"\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)   # 第二次出現時加入結果\n            else:\n                seen.add(seq)        # 第一次出現\n        return list(repeated)\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：可能是 \"s = '...' \" 或直接字串\n    if '=' in data:\n        _, right = data.split('=', 1)\n        s = right.strip()\n    else:\n        s = data\n\n    # 去除外層單引號或雙引號（如果存在）\n    if (s.startswith(\"'\") and s.endswith(\"'\")) or (s.startswith('\"') and s.endswith('\"')):\n        s = s[1:-1]\n\n    solution = Solution()\n    result = solution.findRepeatedDnaSequences(s)\n    # 輸出符合題目範例格式的 JSON 字串\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for given problem: find all 10-letter substrings that appear more than once in a DNA string. We need to provide step-by-step virtual code, each line with \"→\" and comment after //. We need to use Start, End, Decision, etc. We need to cover reading input string, sliding window of length 10, store counts in hash map, then collect those with count >1, output list. Provide maybe use set to avoid duplicates in output. Provide complexity analysis? Not necessary.\n\nWe should produce code steps.\n\nLet's produce something like:\n\nStart // 開始\n→ Step 1: 取得輸入字串 s // input\n→ Decision: s.length < 10? // 若長度不足，直接返回空\n    Yes → Step 2: 返回空清單 // 無足夠子字串\n    No  → Step 3: 初始化哈希表 counts // 用於記錄子字串出現次數\n    → Step 4: 初始化空集合 result // 儲存重複的 10 字串\n    → Step 5: 對 i 從 0 到 s.length-10 做:\n        → Substring t = s.substring(i, i+10) // 取 10 長度子字串\n        → if counts.containsKey(t):\n            → counts[t] = counts[t] + 1 // 次數加一\n            → if counts[t] == 2:\n                → result.add(t) // 第 2 次出現時加入結果\n          else:\n            → counts[t] = 1 // 第一次出現\n    → Step 6: 將 result 轉為清單回傳 // 產生輸出\nEnd // 結束\n\nNeed to include arrow for loops etc. Use \"→\" for each step. Provide explanation after //.\n\nLet's format each line as required. Use \"→\" and \"Decision:\" for if.\n\nAlso mention the loop: \"→ Loop: i = 0 to s.length-10\" and inside the loop steps.\n\nBetter to represent with indent maybe but not necessary.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者或呼叫介面取得 DNA 序列  \n→ Decision: s.length < 10? // 若字串長度不足 10，無法形成 10 字長子字串  \n Yes → Step 2: 返回空清單 // 直接回傳空結果  \n No  → Step 3: 初始化哈希表 counts // 用於紀錄每個 10 字長子字串的出現次數  \n  → Step 4: 初始化空集合 result // 儲存重複出現的 10 字長子字串  \n  → Step 5: Loop i = 0 to s.length - 10 // 依序檢查所有可能的 10 字長子字串  \n   → Substring t = s.substring(i, i+10) // 取得目前 10 字長子字串  \n   → Decision: counts 內有 t? // 檢查該子字串是否已被遇過  \n    Yes → Step 6: counts[t] = counts[t] + 1 // 次數加一  \n     → Decision: counts[t] == 2? // 只在第二次出現時加入結果，避免重複加入  \n      Yes → result.add(t) // 加入結果集合  \n      No → No operation // 之後再遇到的重複不再加入  \n    No  → Step 7: counts[t] = 1 // 第一次出現，初始化計數  \n  → End Loop // 完成所有子字串檢查  \n→ Step 8: 將 result 轉為清單並回傳 // 產生最終輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        返回 nums 的所有排列，使用回溯 + 交換法\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # 如果已經排好所有位置，將結果加入 res\n            if start == len(nums):\n                res.append(nums[:])   # 做切片拷貝，避免後續變更影響\n                return\n            # 嘗試將剩餘未決定的元素放到 current 位置\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # 交換\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # 回朔\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整行輸入，示例格式： nums = [1,2,3]\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析輸入中的列表\n    if '=' in raw_input:\n        _, list_str = raw_input.split('=', 1)\n        list_str = list_str.strip()\n    else:\n        list_str = raw_input\n\n    # 使用 literal_eval 以安全方式轉換為 list\n    nums = ast.literal_eval(list_str)\n\n    # 取得所有排列並輸出\n    solution = Solution()\n    permutations = solution.permute(nums)\n    print(permutations)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for generating all permutations of an array of distinct integers, in any order. Provide step-by-step virtual code with explanation after each line. Use arrow syntax, decision, Start, End. Should be line by line. Use \"Step 1\" etc.\n\nWe need to show typical backtracking algorithm. We'll write:\n\nStart\n\n→ Step 1: 定義結果列表 result = []\n\n→ Step 2: 定義回溯函式 backtrack(current, remaining)\n\n→ Decision: 如果 remaining 為空? // 當沒有剩餘元素時\n\n    Yes → Step 3: result.append(current.copy()) // 將當前排列加入結果\n\n    No  → Step 4: For each idx, val in enumerate(remaining):\n\n        → Step 5: next_current = current + [val] // 加入選中的元素\n\n        → Step 6: next_remaining = remaining[:idx] + remaining[idx+1:] // 移除選中的元素\n\n        → Step 7: backtrack(next_current, next_remaining) // 進行下一層遞迴\n\n→ Step 8: backtrack([], nums) // 初始呼叫\n\n→ Step 9: return result // 返回所有排列\n\nEnd\n\nWe also need to add explanation after each line. We need to ensure each line has virtual code + space + // explanation.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result = [] // 初始化儲存所有排列的結果列表  \n→ Step 2: define backtrack(current, remaining) // 定義回溯函式，current 為已選元素，remaining 為剩餘未選元素  \n    → Decision: if remaining is empty? // 檢查是否已經選完所有元素  \n        Yes → Step 3: result.append(current.copy()) // 將完整排列加入結果列表  \n        No  → Step 4: for idx, val in enumerate(remaining): // 逐個嘗試剩餘元素作為下一個位置  \n            → Step 5: next_current = current + [val] // 將選中的元素加入目前排列  \n            → Step 6: next_remaining = remaining[:idx] + remaining[idx+1:] // 從剩餘列表中移除已選元素  \n            → Step 7: backtrack(next_current, next_remaining) // 進行下一層遞迴探索  \n→ Step 8: backtrack([], nums) // 從空排列和完整數字列表開始回溯  \n→ Step 9: return result // 回傳所有生成的排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 存放所有元素的列表，方便隨機取值\n        self.data = []\n        # 每個值對應一組其在 data 中的索引，使用 set 方便 O(1) 插入與刪除\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        # 把 val 加到 data 最後\n        self.data.append(val)\n        # 記錄該值的索引\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若是第一次插入該值，返回 True，否則 False\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        # 如果沒有此值，直接返回 False\n        if not self.idx_map[val]:\n            return False\n        # 隨便取出一個該值的索引\n        remove_idx = self.idx_map[val].pop()\n        # 把 data 最後一個元素搬到 remove_idx 的位置\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            self.idx_map[last_val].remove(last_idx)\n            self.idx_map[last_val].add(remove_idx)\n        # 刪除最後一個元素\n        self.data.pop()\n        # 如果該值已經沒有索引了，從字典中移除它\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        # 隨機選取 data 的一個索引並返回對應值\n        return random.choice(self.data)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，將兩個列表包在外層方括號後解析\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    # 例如 input: [\"RandomizedCollection\", \"insert\", ...], [[], [1], ...]\n    # 轉成 ['[\"RandomizedCollection\", \"insert\", ...], [[], [1], ...]']\n    wrapped = f'[{raw_input}]'\n    try:\n        methods, params = json.loads(wrapped)\n    except json.JSONDecodeError:\n        # 如果解析失敗，直接退出\n        sys.exit(1)\n\n    obj = RandomizedCollection()\n    results = [None]  # 第一次為 constructor，返回 null\n\n    for method, arg in zip(methods[1:], params[1:]):\n        if method == 'insert':\n            res = obj.insert(arg[0])\n        elif method == 'remove':\n            res = obj.remove(arg[0])\n        elif method == 'getRandom':\n            res = obj.getRandom()\n        else:\n            res = None\n        results.append(res)\n\n    # 輸出符合 JSON 的格式（None -> null, True/False -> true/false）\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step. We must not output actual code but pseudocode lines with explanation. We need to cover class definition, initialization, data structures, insert, remove, getRandom. Use arrows. Should be clear, step by step. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 RandomizedCollection 類別 // 建立資料結構的類別\n→ Step 2: 內部使用 List<int> values // 存放所有元素，方便隨機取值\n→ Step 3: 內部使用 Dictionary<int, HashSet<int>> indices // 對每個值，存放其在 values 中的所有索引\n→ Decision: 初始化時 values 及 indices 為空容器 // 準備好資料結構\n\nStart // 進入 constructor\n→ Step 4: 建構子 RandomizedCollection() // 初始化空的 values 與 indices\n→ Step 5: values = new List<int>() // 空列表\n→ Step 6: indices = new Dictionary<int, HashSet<int>>() // 空字典\n→ End // 建構子完成\n\nStart // 進入 insert 方法\n→ Step 7: 方法 insert(int val) → bool // 定義插入方法\n→ Step 8: Append val 到 values 列表 // values.add(val)\n→ Step 9: currentIndex = values.size - 1 // 取得新元素的索引\n→ Step 10: 若 indices 沒有 key val，建立新的 HashSet // 如果是第一次插入\n→ Step 11: indices[val].add(currentIndex) // 把索引加入對應集合\n→ Step 12: 若 indices[val] 的大小等於 1，表示此前不存在，返回 true // 第一個插入返回 true\n→ Step 13: 否則，返回 false // 重複值返回 false\n→ End // insert 方法完成\n\nStart // 進入 remove 方法\n→ Step 14: 方法 remove(int val) → bool // 定義刪除方法\n→ Step 15: 若 indices 不含 key val 或 indices[val] 為空，返回 false // 沒有此值時直接返回\n→ Step 16: 從 indices[val] 取得一個任意索引 removeIndex // 取一個要刪除的元素位置\n→ Step 17: 若 removeIndex 不是 values 的最後一個索引\n    → Step 18: lastVal = values.last() // 取得最後一個元素\n    → Step 19: lastIndex = values.size - 1 // 最後索引\n    → Step 20: values[removeIndex] = lastVal // 用最後一個元素覆蓋被刪除位置\n    → Step 21: indices[lastVal].remove(lastIndex) // 移除 lastVal 在最後索引的紀錄\n    → Step 22: indices[lastVal].add(removeIndex) // 加入新的索引\n→ End // 如果 removeIndex 是最後一個索引，直接跳過覆蓋步驟\n→ Step 23: values.removeLast() // 刪除列表最後一個元素\n→ Step 24: indices[val].remove(removeIndex) // 移除 val 在該索引的紀錄\n→ Step 25: 若 indices[val] 為空，從字典中移除 key val // 清理空集合\n→ Step 26: 返回 true // 成功刪除一個元素\n→ End // remove 方法完成\n\nStart // 進入 getRandom 方法\n→ Step 27: 方法 getRandom() → int // 定義隨機取值方法\n→ Step 28: 隨機產生一個 0~values.size-1 的整數 idx // 隨機索引\n→ Step 29: 返回 values[idx] // 直接回傳該索引的值\n→ End // getRandom 方法完成\n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport heapq\n\nclass MedianFinder:\n    \"\"\"\n    使用兩個堆來維持已插入元素的中位數。\n    small：最大堆（存放較小的一半數值，使用負值實現）\n    large：最小堆（存放較大的一半數值）\n    \"\"\"\n    def __init__(self):\n        self.small = []  # 最大堆，存負值\n        self.large = []  # 最小堆\n\n    def addNum(self, num: int) -> None:\n        # 先把新數插入最大堆\n        heapq.heappush(self.small, -num)\n\n        # 若兩堆的最大值和最小值互相交叉，需調整\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 保持兩堆大小差不超過 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    # 解析輸入：兩個列表，中間以 '],' 分隔\n    split_idx = raw.find('],')\n    first_part = raw[:split_idx + 1]\n    second_part = raw[split_idx + 2:].strip()\n    # 確保兩部分都是合法的 Python 列表字面量\n    if not first_part.startswith('['):\n        first_part = '[' + first_part\n    if not second_part.startswith('['):\n        second_part = '[' + second_part\n\n    ops = ast.literal_eval(first_part)\n    args = ast.literal_eval(second_part)\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            result.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            result.append(None)\n        elif op == \"findMedian\":\n            result.append(obj.findMedian())\n        else:\n            # 若出現未知操作，可忽略或抛出錯誤\n            result.append(None)\n\n    # 用 json.dumps 以符合期望的 null、數字格式輸出\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for a MedianFinder with addNum and findMedian, using two heaps (max-heap for lower half, min-heap for upper half). Provide line-by-line virtual code with explanation. Use arrows. Ensure Start/End etc.\n\nLet's design steps:\n\nStart\n→ Initialize maxHeap (lower half)\n→ Initialize minHeap (upper half)\n\nMethod addNum(num):\n→ Insert into maxHeap\n→ Balance: if size(maxHeap) > size(minHeap)+1 => move top of maxHeap to minHeap\n→ else if size(minHeap) > size(maxHeap) => move top of minHeap to maxHeap\n\nMethod findMedian:\n→ If size(maxHeap) == size(minHeap) => return (top(maxHeap)+top(minHeap))/2\n→ else => return top(maxHeap)\n\nWe must represent the class initialization and methods as virtual steps. Use Decision lines.\n\nWe need each line in format \"虛擬碼步驟 // 解釋\". We'll list the class and its methods.\n\nUse Start, End. Probably start at class creation? Might have:\n\nStart // 程式開始執行\n→ Class MedianFinder: // 定義 MedianFinder 類別\n    → Constructor: // 建構子初始化\n        → maxHeap = new MaxHeap()\n        → minHeap = new MinHeap()\n    → Method addNum(num):\n        → maxHeap.insert(num)\n        → Decision: maxHeap.size > minHeap.size + 1?\n            Yes → maxHeap.extractTop() → minHeap.insert(...)\n            No → Decision: minHeap.size > maxHeap.size?\n                Yes → minHeap.extractTop() → maxHeap.insert(...)\n                No → // Balanced\n    → Method findMedian():\n        → Decision: maxHeap.size == minHeap.size?\n            Yes → median = (maxHeap.top + minHeap.top)/2.0\n            No → median = maxHeap.top\nEnd // 程式結束\n\nWe must use arrow symbols: →, Decision:, Yes →, No →. Need to maintain indentation? We can indent lines after Decision.\n\nEnsure each line ends with // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class MedianFinder: // 定義 MedianFinder 類別  \n → Constructor: // 建構子初始化資料結構  \n  → maxHeap = new MaxHeap() // 最大堆，存放較小的一半數值  \n  → minHeap = new MinHeap() // 最小堆，存放較大的一半數值  \n → Method addNum(num): // 新增數值到資料結構  \n  → maxHeap.insert(num) // 先將數值插入最大堆，保持較小的一半  \n  → Decision: maxHeap.size > minHeap.size + 1? // 檢查最大堆是否比最小堆多超過一個元素  \n   Yes → maxHeap.extractTop() → minHeap.insert(...) // 把最大堆最小值移到最小堆，保持平衡  \n   No → Decision: minHeap.size > maxHeap.size? // 檢查最小堆是否比最大堆多元素  \n    Yes → minHeap.extractTop() → maxHeap.insert(...) // 把最小堆最大值移到最大堆，保持平衡  \n    No → // 堆已平衡，無需處理  \n → Method findMedian(): // 取得目前所有數值的中位數  \n  → Decision: maxHeap.size == minHeap.size? // 判斷堆大小是否相等  \n   Yes → median = (maxHeap.top + minHeap.top) / 2.0 // 兩堆大小相等，取兩個中位數平均  \n   No → median = maxHeap.top // 最大堆多一個元素，中位數為最大堆頂部值  \nEnd // 程式結束執行"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwdbl7t5y.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpwdbl7t5y.py\", line 48, in main\n    intervals, new_interval = parse_input(raw)\n                              ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwdbl7t5y.py\", line 40, in parse_input\n    intervals = ast.literal_eval(m1.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpl1d3b1eo.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpl1d3b1eo.py\", line 48, in main\n    intervals, new_interval = parse_input(raw)\n                              ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpl1d3b1eo.py\", line 40, in parse_input\n    intervals = ast.literal_eval(m1.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # 先把所有不與 newInterval 重疊且在前面的區間加入結果\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # 合併所有與 newInterval 有重疊的區間\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # 新區間（已合併完）加入結果\n        result.append(newInterval)\n\n        # 把剩下的區間直接加入\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中擷取 intervals 與 newInterval。\"\"\"\n    # 取得第一個區間列表\n    m1 = re.search(r'intervals\\s*=\\s*(\\[.*?\\])', data, re.S)\n    # 取得第二個區間列表\n    m2 = re.search(r'newInterval\\s*=\\s*(\\[.*?\\])', data, re.S)\n    if not m1 or not m2:\n        raise ValueError(\"輸入格式錯誤\")\n    intervals = ast.literal_eval(m1.group(1))\n    new_interval = ast.literal_eval(m2.group(1))\n    return intervals, new_interval\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    intervals, new_interval = parse_input(raw)\n    solution = Solution()\n    res = solution.insert(intervals, new_interval)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with comments. Steps: Start, iterate intervals, add before newInterval, merge, etc. Use Decision arrows. Should not output actual code. Use virtual code.\n\nLet's draft:\n\nStart\n→ Step 1: 初始化 result list // 空列表用來儲存結果\n→ Step 2: 取 newInterval 的 start 與 end\n→ Decision: 對於每個 interval in intervals: // 逐一處理原始區間\n    → Decision: interval.end < newInterval.start? // 原區間結束在新區間開始之前\n        Yes → Step 3: result.append(interval) // 直接加入\n        No  → Decision: interval.start > newInterval.end? // 原區間開始在新區間結束之後\n            Yes → Step 4: result.append(newInterval) // 插入新區間\n                → Step 5: newInterval = interval // 把當前區間視為新的新區間，繼續處理剩餘\n                → Decision: 是否已處理完? // 若已迴圈完畢則跳到結尾\n                No → (continue loop)\n            No  → Step 6: newInterval.start = min(newInterval.start, interval.start) // 合併起始\n                → Step 7: newInterval.end = max(newInterval.end, interval.end) // 合併結束\n                → (continue loop)\n→ Decision: newInterval 是否已加入? // 若仍在 result 中未加入\n    Yes → (已加入)\n    No  → Step 8: result.append(newInterval) // 將剩餘的新區間加入\n→ End // 返回 result\n\nNeed to include arrow lines with decisions and actions.\n\nWe should produce each line with \"→\" or \"Decision:\" accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← empty list // 初始化結果集合  \n→ Step 2: newStart ← newInterval.start, newEnd ← newInterval.end // 取新區間的起點與終點  \n\n→ Decision: 迭代 intervals 中每個 interval // 對每個原始區間逐一處理  \n    → Decision: interval.end < newStart? // 原區間結束在新區間開始之前  \n        Yes → Step 3: result.append(interval) // 直接加入結果，無需合併  \n        No  → Decision: interval.start > newEnd? // 原區間開始在新區間結束之後  \n            Yes → Step 4: result.append([newStart, newEnd]) // 插入新區間到結果  \n                → Step 5: newStart ← interval.start, newEnd ← interval.end // 以此區間作為新的待合併區間  \n                → Decision: 迴圈已結束? // 若已完成所有區間則跳出迴圈  \n                No  → (繼續迭代)  \n            No  → Step 6: newStart ← min(newStart, interval.start) // 合併起點  \n                → Step 7: newEnd ← max(newEnd, interval.end) // 合併終點  \n                → (繼續迭代)  \n\n→ Decision: 新區間是否已加入結果? // 若仍在 result 中未插入  \n    Yes → (已插入，無需額外處理)  \n    No  → Step 8: result.append([newStart, newEnd]) // 將剩餘的新區間加入結果  \n\nEnd // 程式執行結束，返回 result"
    },
    {
      "title": "K Inverse Pairs Array",
      "source_file": "Leetcode/leetcode629.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 3, k = 0",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 1",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\n\nMOD = 10**9 + 7\n\ndef k_inverse_pairs(n: int, k: int) -> int:\n    if k > n * (n - 1) // 2:\n        return 0\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n        for j in range(1, k + 1):\n            val = dp[i][j - 1] + dp[i - 1][j]\n            if j >= i:\n                val -= dp[i - 1][j - i]\n            dp[i][j] = val % MOD\n    return dp[n][k] % MOD\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    # Extract integers from input\n    nums = [int(x) for x in data if x.lstrip('-').isdigit()]\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    result = k_inverse_pairs(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to count arrays of 1..n with exactly k inversions, modulo 1e9+7. Use DP: dp[i][j] = number arrays of length i with j inversions. Recurrence: dp[i][j] = sum_{t=0}^{min(j, i-1)} dp[i-1][j-t]. Use prefix sums to optimize: dp[i][j] = dp[i][j-1] + dp[i-1][j] - (j>=i? dp[i-1][j-i] : 0). We'll produce steps: Start, input n,k, initialize dp arrays, loop i from 1..n, j from 0..k, compute, mod, final answer dp[n][k]. End.\n\nVirtual code lines: each line as step. Use arrow and decision.\n\nWe need to output step by step, not actual code but pseudocode. Use `Start`, `→`, `Decision:` etc.\n\nLet's craft:\n\nStart // 開始程式\n→ Input n, k // 讀入整數 n 和 k\n→ If k > n*(n-1)/2 → End // 若 k 超過最大可能逆序數，直接結束（結果 0）\n→ Initialize dp array size (n+1) x (k+1) with zeros // 建立 DP 表\n→ Set dp[0][0] = 1 // 空陣列只有 0 個逆序對\n→ For i = 1 to n: // 逐步加入第 i 個元素\n    → For j = 0 to k: // 計算長度 i、逆序數 j\n        → Decision: if j == 0? // 若逆序數為 0\n            Yes → dp[i][j] = 1 // 只有遞增序列\n            No → \n                → temp = dp[i][j-1] + dp[i-1][j] // 前一個逆序數累加\n                → If j >= i: temp -= dp[i-1][j-i] // 減去超過 i 個元素的部分\n                → dp[i][j] = (temp mod MOD + MOD) mod MOD // 取模正整數\n→ Output dp[n][k] // 最終答案\nEnd // 結束\n\nWe need to follow format exactly: each line \"虛擬碼步驟 // 解釋\". Must use arrow and decision etc.\n\nWe need to ensure no actual code. Use placeholders like `Initialize dp array` etc.\n\nWe must ensure each line is in form: `虛擬碼步驟 // 解釋`. For loops we might use `For i = 1 to n: // ...`. Use arrow to indicate step.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n, k // 讀取整數 n 與 k  \n→ Decision: 是否 k 大於最大逆序對數 (n*(n-1)/2)? // 檢查 k 是否可達  \n    Yes → End // 若 k 不可能達到，直接結束，答案為 0  \n    No  → // 繼續計算  \n→ Initialize dp[0…n][0…k] 為 0 // 建立 DP 表格  \n→ dp[0][0] = 1 // 空陣列只有 0 個逆序對  \n→ For i = 1 to n: // 逐步加入第 i 個元素  \n    → For j = 0 to k: // 計算長度 i、逆序數 j 的排列數  \n        → Decision: 是否 j == 0? // 逆序數為 0 時只存在遞增序列  \n            Yes → dp[i][j] = 1 // 直接設為 1  \n            No  → // 使用前一行累加並調整過度項  \n                → temp = dp[i][j-1] + dp[i-1][j] // 前一逆序數累加  \n                → Decision: 是否 j >= i? // 需要扣除超過 i 個元素的情況  \n                    Yes → temp -= dp[i-1][j-i] // 扣除不合法部分  \n                    No  → // 不需要扣除  \n                → dp[i][j] = (temp mod MOD + MOD) mod MOD // 取模並保證非負  \n→ Output dp[n][k] // 輸出最終答案  \nEnd // 程式執行結束"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1deqsx_n.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmp1deqsx_n.py\", line 36, in main\n    exec(data, {}, local_vars)          # 解析矩陣與 k\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptejkleku.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmptejkleku.py\", line 36, in main\n    exec(data, {}, local_vars)          # 解析矩陣與 k\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    matrix = [[-5]], k = 1\n    ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport heapq\n\nclass Solution:\n    def kthSmallest(self, matrix, k):\n        \"\"\"\n        使用最小堆取得第 k 小元素。\n        堆中存放三元組 (value, row, col)。\n        初始時將每一行的第一個元素放入堆。\n        每次彈出最小元素後，若該元素所在行有下一個元素，則把它推入堆。\n        重複 k-1 次後，堆頂即為第 k 小元素。\n        \"\"\"\n        n = len(matrix)\n        # 初始化堆：每行的第一個元素\n        heap = [(matrix[i][0], i, 0) for i in range(n)]\n        heapq.heapify(heap)\n\n        # 彈出前 k-1 個最小元素\n        for _ in range(k - 1):\n            val, r, c = heapq.heappop(heap)\n            if c + 1 < n:\n                heapq.heappush(heap, (matrix[r][c + 1], r, c + 1))\n\n        # 堆頂即為第 k 小的元素\n        return heapq.heappop(heap)[0]\n\n\ndef main():\n    \"\"\"\n    讀取標準輸入，內容預期為類似\n        matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n    使用 exec 解析變數，然後計算結果並輸出。\n    \"\"\"\n    data = sys.stdin.read()\n    local_vars = {}\n    exec(data, {}, local_vars)          # 解析矩陣與 k\n    matrix = local_vars['matrix']\n    k = local_vars['k']\n\n    result = Solution().kthSmallest(matrix, k)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for finding kth smallest element in sorted matrix, O(n^2) memory not allowed. We need to use binary search on value range or min-heap of size n. We choose binary search on value range. Steps: find min and max, binary search. For each mid, count elements <= mid by scanning rows with binary search in each row. Count. Adjust low/high. When low==high return low.\n\nWe need to output line by line pseudocode with arrow syntax. Provide explanation after each line.\n\nLet's produce steps:\n\nStart\n→ Step 1: Read matrix M and integers n, k // input\n→ Step 2: Set low = M[0][0] // smallest element\n→ Step 3: Set high = M[n-1][n-1] // largest element\n→ Decision: While low < high? // loop until low equals high\n    Yes → Step 4: mid = floor((low + high)/2) // middle value\n    → Step 5: count = 0 // initialize counter\n    → Step 6: For i from 0 to n-1: // iterate rows\n        → Step 7: count += upper_bound(M[i], mid) // number of elements <= mid in row i\n    → Decision: If count < k? // fewer than k elements <= mid\n        Yes → low = mid + 1 // need larger values\n        No  → high = mid // mid might be kth smallest\nEnd // return low\n\nBut we need to produce explanation lines.\n\nWe need to use Decision structure: \"Decision: If count < k?\" with Yes and No.\n\nAlso we need to define upper_bound pseudocode: we can use binary search per row. But we can mention: \"count += upper_bound in row i for mid\".\n\nLet's produce step by step. Ensure each line has \"虛擬碼步驟\" then space then comment.\n\nLet's write lines.\n\nAlso include comment after each line.\n\nWe also need to include \"Start\" and \"End\" markers.\n\nAlso we need to use arrow after \"Start\" maybe \"→\".\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取矩陣 M 與整數 n, k // 取得輸入資料  \n→ Step 2: low = M[0][0] // 設定最小值為矩陣左上角元素  \n→ Step 3: high = M[n-1][n-1] // 設定最大值為矩陣右下角元素  \n→ Decision: low < high? // 只要 low 還未等於 high 就繼續搜尋  \n    Yes → Step 4: mid = (low + high) / 2 // 計算中間值  \n    → Step 5: count = 0 // 初始化小於等於 mid 的元素個數  \n    → Step 6: For i = 0 to n-1: // 逐行處理  \n        → Step 7: count += upper_bound_in_row(M[i], mid) // 在第 i 行中找出 ≤ mid 的元素數量  \n    → Decision: count < k? // 小於 k 個元素時，需要搜尋更大的值  \n        Yes → low = mid + 1 // 將 lower bound 上調  \n        No  → high = mid // mid 仍有可能是第 k 小的元素  \nEnd // 回傳 low 為第 k 小的元素 (因 low == high)"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []  # list of [start, end), non-overlapping, sorted\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:  # overlapping\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i - 1][0] <= left and right <= self.ranges[i - 1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    rm = RangeModule()\n    outputs = []\n\n    for line in data:\n        line = line.strip()\n        if not line:\n            continue\n        # remove semicolon and newlines\n        line = line.replace(';', '')\n        # skip initialization line\n        if line.startswith('RangeModule') or line.startswith('rangeModule = new RangeModule()'):\n            continue\n        # replace punctuation with spaces for easy split\n        cleaned = line.replace(')', ' ').replace('(', ' ').replace(',', ' ').split()\n        if not cleaned:\n            continue\n        cmd = cleaned[0]\n        if cmd == 'addRange' and len(cleaned) >= 3:\n            left, right = int(cleaned[1]), int(cleaned[2])\n            rm.addRange(left, right)\n            outputs.append('null')\n        elif cmd == 'removeRange' and len(cleaned) >= 3:\n            left, right = int(cleaned[1]), int(cleaned[2])\n            rm.removeRange(left, right)\n            outputs.append('null')\n        elif cmd == 'queryRange' and len(cleaned) >= 3:\n            left, right = int(cleaned[1]), int(cleaned[2])\n            res = rm.queryRange(left, right)\n            outputs.append('true' if res else 'false')\n        else:\n            # unknown command, ignore\n            continue\n\n    print('[' + ', '.join(outputs) + ']')",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. We must design a data structure. We should likely use an interval tree or a sorted list of non-overlapping intervals. We will produce steps to implement class, methods. Provide start, end. The virtual code is step by step, not actual code. So we need to describe logic like Start, Step 1: 初始化 interval list, etc. Use Decision, loops.\n\nLet's outline:\n\nStart\nStep 1: 初始化空的 interval list // list of [l,r] sorted, non-overlapping\nStep 2: Define addRange method\n   2.1: Find position to insert left, merging with overlapping intervals\n   2.2: Remove fully covered intervals\n   2.3: Insert new interval merging with neighbors\nStep 3: Define queryRange\n   3.1: Find interval containing left\n   3.2: If not found or right > that interval's end, return false\n   3.3: Else true\nStep 4: Define removeRange\n   4.1: Find intervals overlapping with [left,right)\n   4.2: For each, adjust or split\n   4.3: Remove fully overlapped intervals\nEnd\n\nBut must be line-by-line. Use arrows.\n\nWe must include \"Start\" and \"End\". Each line: \"虛擬碼步驟 // 解釋\". Use arrow for transitions.\n\nWe need to use \"→\" for steps, \"Decision:\" etc. Also use \"Yes →\" \"No →\".\n\nWe should produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 empty interval list // 用於存放已追蹤的半開區間\n\nThen maybe \"→ Decision: 是否有初始資料?\" but not needed.\n\nImplement methods as separate sections.\n\nLet's produce.\n\nWe might produce code skeleton like:\n\nClass RangeModule\n  → Step 2: 宣告 intervals // 儲存已追蹤區間\n  → Step 3: constructor // 初始化 intervals 為空\n\nThen each method.\n\nBut we need to output \"虛擬碼步驟\" lines. Use \"→\" for each step. For method definitions, we can use \"→ Step X: 方法 addRange(left,right)\" etc.\n\nBut the user wants \"逐行地產生對應的虛擬碼\". So we should produce code lines describing each step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 RangeModule // 建立區間追蹤結構\n→ Step 2: 宣告 intervals: List of pairs // 儲存已追蹤的半開區間，保持排序且無重疊\n→ Step 3: 定義構造函數 RangeModule() // 初始化 intervals 為空\n\n→ Step 4: 定義方法 addRange(left, right) // 增加區間\n    → Decision: intervals 是否為空? // 判斷是否已有區間\n        Yes → Step 5: 插入 [left,right] 為唯一區間 // 新增整個區間\n        No  → Step 6: 搜尋左側插入點 idxL // 找到第一個 interval.end >= left\n        → Step 7: 搜尋右側插入點 idxR // 找到最後一個 interval.start <= right\n        → Decision: idxL <= idxR? // 是否有重疊區間\n            Yes → Step 8: 計算 newLeft = min(left, intervals[idxL].start)\n            → Step 9: 計算 newRight = max(right, intervals[idxR].end)\n            → Step 10: 刪除 intervals[idxL … idxR] // 移除已重疊的區間\n            → Step 11: 插入 [newLeft, newRight] // 新的合併區間\n            No  → Step 12: 插入 [left,right] // 沒重疊，直接插入並保持排序\n\n→ Step 13: 定義方法 queryRange(left, right) // 查詢區間\n    → Decision: intervals 是否存在 interval 使 interval.start <= left < interval.end? // 判斷左端是否被追蹤\n        No  → Step 14: 回傳 False // 左端不在任何區間內\n        Yes → Step 15: 取得該 interval // 進一步檢查右端\n            → Decision: right <= interval.end? // 右端是否在同一區間內\n                Yes → Step 16: 回傳 True // 整個 [left,right) 被追蹤\n                No  → Step 17: 回傳 False // 右端超出追蹤區間\n\n→ Step 18: 定義方法 removeRange(left, right) // 移除區間\n    → Decision: intervals 是否為空? // 若無區間直接返回\n        Yes → Step 19: 返回 // 無需處理\n        No  → Step 20: 搜尋所有與 [left,right) 重疊的區間 idxL … idxR\n        → Step 21: 針對每個重疊區間進行調整\n            → Decision: intervals[i].start < left? // 是否需要保留左半部分\n                Yes → Step 22: 若 intervals[i].end > right? // 兩端都保留\n                    Yes → Step 23: 將 intervals[i] 分成兩個區間: [intervals[i].start, left) 與 [right, intervals[i].end)\n                    No  → Step 24: 將 intervals[i].end = left // 只保留左半部分\n                No → Decision: intervals[i].end > right? // 只保留右半部分\n                    Yes → Step 25: 將 intervals[i].start = right // 只保留右半部分\n                    No  → Step 26: 刪除 intervals[i] // 完全被覆蓋\n\nEnd // 程式執行結束\n\nThis is good. But we need to format each line with \"虛擬碼步驟 // 解釋\". Also we need to use \"→\" and \"Decision:\" etc. Each line must be separate. Use \"Start\" and \"End\".\n\nWe should keep each line as one step. Let's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 RangeModule // 建立區間追蹤結構  \n→ Step 2: 宣告 intervals: List of pairs // 儲存已追蹤的半開區間，保持排序且無重疊  \n→ Step 3: 定義構造函數 RangeModule() // 初始化 intervals 為空  \n\n→ Step 4: 定義方法 addRange(left, right) // 增加區間  \n    → Decision: intervals 是否為空? // 判斷是否已有區間  \n        Yes → Step 5: 插入 [left,right] 為唯一區間 // 新增整個區間  \n        No  → Step 6: 搜尋左側插入點 idxL // 找到第一個 interval.end >= left  \n        → Step 7: 搜尋右側插入點 idxR // 找到最後一個 interval.start <= right  \n        → Decision: idxL <= idxR? // 是否有重疊區間  \n            Yes → Step 8: 計算 newLeft = min(left, intervals[idxL].start) // 取最左端  \n            → Step 9: 計算 newRight = max(right, intervals[idxR].end) // 取最右端  \n            → Step 10: 刪除 intervals[idxL … idxR] // 移除已重疊的區間  \n            → Step 11: 插入 [newLeft, newRight] // 新的合併區間  \n            No  → Step 12: 插入 [left,right] // 沒重疊，直接插入並保持排序  \n\n→ Step 13: 定義方法 queryRange(left, right) // 查詢區間  \n    → Decision: intervals 是否存在 interval 使 interval.start <= left < interval.end? // 判斷左端是否被追蹤  \n        No  → Step 14: 回傳 False // 左端不在任何區間內  \n        Yes → Step 15: 取得該 interval // 進一步檢查右端  \n            → Decision: right <= interval.end? // 右端是否在同一區間內  \n                Yes → Step 16: 回傳 True // 整個 [left,right) 被追蹤  \n                No  → Step 17: 回傳 False // 右端超出追蹤區間  \n\n→ Step 18: 定義方法 removeRange(left, right) // 移除區間  \n    → Decision: intervals 是否為空? // 若無區間直接返回  \n        Yes → Step 19: 返回 // 無需處理  \n        No  → Step 20: 搜尋所有與 [left,right) 重疊的區間 idxL … idxR  \n        → Step 21: 針對每個重疊區間進行調整  \n            → Decision: intervals[i].start < left? // 是否需要保留左半部分  \n                Yes → Decision: intervals[i].end > right? // 兩端都保留  \n                    Yes → Step 22: 將 intervals[i] 分成兩個區間: [intervals[i].start, left) 與 [right, intervals[i].end) // 左右兩端皆保留  \n                    No  → Step 23: 將 intervals[i].end = left // 只保留左半部分  \n                No → Decision: intervals[i].end > right? // 只保留右半部分  \n                    Yes → Step 24: 將 intervals[i].start = right // 只保留右半部分  \n                    No  → Step 25: 刪除 intervals[i] // 完全被覆蓋  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprz3ndc03.py\", line 88, in <module>\n    main()\n  File \"/tmp/tmprz3ndc03.py\", line 61, in main\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0\n        self.count = 0\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])\n    args = json.loads(data[1]) if len(data) > 1 else []\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(arg[0])\n            res.append(None)\n        elif op == \"insertFront\":\n            res.append(obj.insertFront(arg[0]))\n        elif op == \"insertLast\":\n            res.append(obj.insertLast(arg[0]))\n        elif op == \"deleteFront\":\n            res.append(obj.deleteFront())\n        elif op == \"deleteLast\":\n            res.append(obj.deleteLast())\n        elif op == \"getFront\":\n            res.append(obj.getFront())\n        elif op == \"getRear\":\n            res.append(obj.getRear())\n        elif op == \"isEmpty\":\n            res.append(obj.isEmpty())\n        elif op == \"isFull\":\n            res.append(obj.isFull())\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanations line by line. Need to design MyCircularDeque implementation. Use a circular array. Provide steps: Start, initialize array, front, rear, count. Provide methods.\n\nWe need to output in that format: each line: \"虛擬碼步驟 // 解釋\". Use arrows. Let's structure like:\n\nStart\n→ 初始化 MyCircularDeque: allocate array of size k, front = 0, rear = k-1, count = 0\n→ Method insertFront(value):\n    Decision: 如果 isFull? Yes → return false No →\n    front = (front - 1 + k) % k\n    array[front] = value\n    count++\n    return true\nAnd similar for insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.\n\nWe need to maintain separate methods. Provide each as separate blocks. Use arrow for each step. Each line should be a single step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ 初始化 MyCircularDeque(k): \n    array = new int[k] // 用於存儲元素\n    front = 0 // 前端指標\n    rear = k-1 // 後端指標\n    count = 0 // 目前元素個數\nEnd // 建構完成\n\nThen methods:\n\nMethod: insertFront(value)\nStart // 執行 insertFront\n→ Decision: 如果 count == k? // 判斷是否已滿\n    Yes → return false // 不能插入\n    No  → \n        front = (front - 1 + k) % k // 向前移動前端指標\n        array[front] = value // 存入值\n        count++ // 元素個數加一\n        return true // 插入成功\nEnd\n\nSimilarly for insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.\n\nWe need to ensure each line is a step, but can include sub-steps. Use indentation maybe? Not required. Just each line separated. For Decision block, we can include Yes → ... No → ... lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化 MyCircularDeque(k):  \n array = new int[k] // 用於存儲元素  \n front = 0 // 前端指標  \n rear = k-1 // 後端指標  \n count = 0 // 目前元素個數  \nEnd // 建構完成  \n\nMethod: insertFront(value) // 新增前端元素  \nStart // 執行 insertFront  \n→ Decision: 如果 count == k? // 判斷是否已滿  \n Yes → return false // 不能插入，已滿  \n No →  \n  front = (front - 1 + k) % k // 向前移動前端指標  \n  array[front] = value // 存入值  \n  count++ // 元素個數加一  \n  return true // 插入成功  \nEnd  \n\nMethod: insertLast(value) // 新增後端元素  \nStart // 執行 insertLast  \n→ Decision: 如果 count == k? // 判斷是否已滿  \n Yes → return false // 不能插入，已滿  \n No →  \n  rear = (rear + 1) % k // 向後移動後端指標  \n  array[rear] = value // 存入值  \n  count++ // 元素個數加一  \n  return true // 插入成功  \nEnd  \n\nMethod: deleteFront() // 刪除前端元素  \nStart // 執行 deleteFront  \n→ Decision: 如果 count == 0? // 判斷是否為空  \n Yes → return false // 無法刪除，空  \n No →  \n  front = (front + 1) % k // 向後移動前端指標  \n  count-- // 元素個數減一  \n  return true // 刪除成功  \nEnd  \n\nMethod: deleteLast() // 刪除後端元素  \nStart // 執行 deleteLast  \n→ Decision: 如果 count == 0? // 判斷是否為空  \n Yes → return false // 無法刪除，空  \n No →  \n  rear = (rear - 1 + k) % k // 向前移動後端指標  \n  count-- // 元素個數減一  \n  return true // 刪除成功  \nEnd  \n\nMethod: getFront() // 取得前端元素  \nStart // 執行 getFront  \n→ Decision: 如果 count == 0? // 判斷是否為空  \n Yes → return -1 // 空時回傳 -1  \n No →  \n  return array[front] // 回傳前端值  \nEnd  \n\nMethod: getRear() // 取得後端元素  \nStart // 執行 getRear  \n→ Decision: 如果 count == 0? // 判斷是否為空  \n Yes → return -1 // 空時回傳 -1  \n No →  \n  return array[rear] // 回傳後端值  \nEnd  \n\nMethod: isEmpty() // 檢查是否為空  \nStart // 執行 isEmpty  \n→ return count == 0 // 為空則回傳 true，否則 false  \nEnd  \n\nMethod: isFull() // 檢查是否已滿  \nStart // 執行 isFull  \n→ return count == k // 已滿則回傳 true，否則 false  \nEnd  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnl_ee1i3.py\", line 43, in <module>\n    ops = json.loads(parts[0])\n          ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 18 (char 17)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word):\n        def dfs(node, i):\n            if i == len(word):\n                return node.is_end\n            if word[i] == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                if word[i] not in node.children:\n                    return False\n                return dfs(node.children[word[i]], i + 1)\n        return dfs(self.root, 0)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # The input format is two JSON arrays separated by a comma.\n    # Example: '[\"WordDictionary\",\"addWord\"],[[],[\"bad\"]]'\n    parts = data.split(',', 1)\n    ops = json.loads(parts[0])\n    args = json.loads(parts[1])\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"WordDictionary\":\n            obj = WordDictionary()\n            results.append(None)\n        elif op == \"addWord\":\n            obj.addWord(arg[0])\n            results.append(None)\n        elif op == \"search\":\n            results.append(obj.search(arg[0]))\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for WordDictionary supporting addWord and search with '.' wildcard. This is typical Trie with DFS. We'll produce line by line with arrow syntax. Must use Start, End, Decision, etc.\n\nWe need to produce \"虛擬碼步驟\" each line with comment. The pseudo-code will include: define Node, WordDictionary class, constructor, addWord, search, helper dfs. We'll include the search with recursion.\n\nWe need to produce \"逐行\" and each line ends with comment. Provide arrow syntax. We'll include indentation? They didn't forbid but using arrow for steps. We can use indentation with arrows for nested steps. Use \"Decision:\" for condition checks. Use \"Yes →\" \"No →\" branches. Use \"→\" for next step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 TrieNode 類別 // 定義字典節點結構\n→ Decision: node是否含有字母子節點? // 判斷節點是否已存在子節點\n...\nBut maybe easier: show high-level steps.\n\nWe need to include \"虛擬碼步驟\" such as \"WordDictionary() 初始化物件\" etc.\n\nLet's structure:\n\nStart\n→ Step 1: 定義 TrieNode // 節點包含子節點字典和終止標誌\n→ Step 2: 定義 WordDictionary 類別\n    → Step 2.1: WordDictionary() // 建構子：創建根節點\n    → Step 2.2: addWord(word) // 將單字插入 Trie\n        → Step 2.2.1: 逐字遍歷 current = root\n            → Step 2.2.1.1: 如果 char 未在 current.children, 創建新節點\n            → Step 2.2.1.2: 移動到該子節點\n        → Step 2.2.2: 標記 current.isWord = true\n    → Step 2.3: search(word) // 判斷是否存在匹配字串\n        → Step 2.3.1: 呼叫 DFS(node=root, index=0)\n            → Decision: index 是否等於 word 長度? // 判斷是否到達字串結尾\n                Yes → Decision: node.isWord? // 是否為完整單字\n                    Yes → Return true\n                    No  → Return false\n                No  → Decision: word[index] 是否為 '.'? // 判斷是否為萬用字元\n                    Yes → For each child in node.children:\n                            → If DFS(child, index+1) 返回 true → Return true\n                        → Return false\n                    No  → If word[index] 在 node.children:\n                            → Return DFS(node.children[word[index]], index+1)\n                        Else → Return false\n        → Step 2.3.2: Return DFS結果\nEnd\n\nNeed to include comments in Chinese.\n\nAlso we might include small sub-steps for DFS. Use \"Step 3\" etc. We need to ensure each line ends with comment.\n\nLet's format lines with arrows. Use spaces as indentation. The arrow for steps: \"→ Step ...\". For nested steps, indent more maybe with extra arrow?\n\nSimplify: We'll produce lines each separate step, using arrow for each. For nested decisions, use \"Decision:\" and then \"Yes →\" \"No →\".\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode // 建立 Trie 節點結構，包含子節點映射與是否為單字結尾的標誌  \n→ Step 2: 定義 WordDictionary 類別 // 包含根節點與三個主要方法  \n  → Step 2.1: WordDictionary() // 建構子：創建空白根節點  \n  → Step 2.2: addWord(word) // 將單字插入 Trie  \n    → Step 2.2.1: current ← root // 從根節點開始遍歷  \n    → Decision: 是否已存在 char 子節點? // 檢查當前字母是否已有節點  \n      Yes → current ← current.children[char] // 跳到已有節點  \n      No  → current.children[char] ← 新 TrieNode() // 新增節點  \n    → Step 2.2.2: current.isWord ← true // 標記為完整單字  \n  → Step 2.3: search(word) // 判斷是否有匹配字串  \n    → Step 2.3.1: result ← DFS(root, 0) // 以遞迴方式搜尋  \n    → Step 2.3.2: return result // 回傳搜尋結果  \n      → 定義 DFS(node, idx) // idx 為目前字元索引  \n       → Decision: idx == len(word)? // 已到字串結尾  \n         Yes → Decision: node.isWord? // 是否為完整單字  \n           Yes → return true  \n           No  → return false  \n        No  → Decision: word[idx] == '.'? // 是否為萬用字元  \n          Yes → For each child in node.children: // 逐一嘗試子節點  \n            → If DFS(child, idx+1) == true → return true  \n           → return false  \n          No  → Decision: word[idx] in node.children? // 具體字母是否存在  \n            Yes → return DFS(node.children[word[idx]], idx+1)  \n            No  → return false  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\", \"root/4.txt\"]]'"
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\ndef find_duplicate(paths):\n    \"\"\"Return groups of duplicate file paths based on file content.\"\"\"\n    content_map = defaultdict(list)\n\n    for entry in paths:\n        parts = entry.split()\n        root = parts[0]\n        for file_info in parts[1:]:\n            name, content = file_info.split('(')\n            content = content[:-1]  # remove trailing ')'\n            content_map[content].append(f\"{root}/{name}\")\n\n    # Only keep groups that have more than one file\n    return [files for files in content_map.values() if len(files) > 1]\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # If input contains a leading variable assignment, strip it\n    if raw_input.startswith('paths'):\n        raw_input = raw_input.split('=', 1)[1].strip()\n\n    # Safely evaluate the list literal\n    try:\n        paths = ast.literal_eval(raw_input)\n    except Exception:\n        # If evaluation fails, treat the whole input as a single path string\n        paths = [raw_input]\n\n    result = find_duplicate(paths)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution step by step for the described problem. Must output in requested format: each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision etc. No actual code. Just virtual. Each line must contain step and explanation. Should be line-by-line.\n\nNeed to describe algorithm: parse each path string, extract directory path and files with contents. Use map content->list of paths. Then iterate to produce duplicates. Provide steps accordingly.\n\nLet's craft the virtual code:\n\nStart\n→ Step 1: 初始化映射 contentToPaths: 內容字符串 → 路徑列表\n→ Decision: 是否有輸入資料? // 檢查輸入是否為空\n    Yes → Step 2: 遍歷每個 directoryInfo in inputList // 逐行處理每個資料字串\n        → Step 3: 分離 directoryPath 與 filesString // 以空格拆分第一個空格前後\n        → Step 4: 將 filesString 以空格拆分得到每個 fileWithContent // 逐檔案處理\n            → Decision: fileWithContent 包含 '('? // 確認格式\n                Yes → Step 5: 提取 fileName 與 fileContent // 拆分 '(' 位置\n                No  → Step 5: 跳過此檔案 // 格式不正確，忽略\n            → Step 6: 組成 fullPath = directoryPath + \"/\" + fileName // 完整路徑\n            → Step 7: 將 fullPath 加入 contentToPaths[fileContent] // 建立映射\n        → End // 文件處理完成\n    No  → Step 8: 返回空列表 // 沒有輸入資料，直接結束\n→ Step 9: 初始化 resultList: List<List<string>>\n→ Decision: 是否存在 contentToPaths 內有多於一個路徑的條目? // 檢查是否有重複\n    Yes → Step 10: 遍歷每個 entry in contentToPaths\n            → Decision: entry.Value.size >= 2? // 至少兩個檔案\n                Yes → Step 11: 將 entry.Value 加入 resultList // 收集重複組\n                No  → No operation\n    No  → No operation\n→ Step 12: 返回 resultList // 輸出所有重複檔案組\nEnd // 程式結束\n\nNeed to maintain formatting exactly. Each line should have virtual code then space then comment. Use arrow \"→\". Need to indent decisions? In example they indent inside Decision. We'll replicate similar style.\n\nAlso, must not output actual code. The lines must show virtual steps like \"Start // 程式開始執行\".\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立映射 contentToPaths：內容 → 路徑清單 // 用來把相同內容的檔案路徑聚集  \n→ Decision: 輸入列表 nonEmpty? // 判斷是否有資料  \n    Yes → Step 2: 逐個處理每個 directoryInfo in inputList // 逐行解析  \n        → Step 3: 分離 directoryPath 與 filesPart // 以第一個空格切開  \n        → Step 4: 以空格拆分 filesPart 為 fileEntries // 取得每個檔案資訊  \n            → Decision: fileEntry 包含 '('? // 確認格式正確  \n                Yes → Step 5: 取得 fileName 與 fileContent // 拆分 '(' 位置  \n                No → Step 5: 跳過此檔案 // 非預期格式  \n            → Step 6: 組成 fullPath = directoryPath + \"/\" + fileName // 完整路徑  \n            → Step 7: 把 fullPath 加入 contentToPaths[fileContent] // 更新映射  \n        → End // 完成該 directoryInfo 的檔案處理  \n    No → Step 8: 直接返回空列表 // 無輸入資料，結束  \n→ Step 9: 建立 resultList // 用來收集重複檔案組  \n→ Decision: contentToPaths 中是否存在至少一個值長度 >= 2? // 是否有重複  \n    Yes → Step 10: 逐項檢查 contentToPaths  \n             → Decision: 目前值 listSize >= 2? // 需要至少兩個檔案  \n                    Yes → Step 11: 把此 list 加入 resultList // 收集一組重複檔案  \n                    No → No operation  \n    No → No operation  \n→ Step 12: 返回 resultList // 輸出所有重複檔案組  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[7]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[7]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[10,6]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[10, 6]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[5,10,7]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[5, 10, 7]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport re\n\ndef rand7():\n    \"\"\"返回 1~7 的均勻隨機整數。\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        \"\"\"\n        透過兩次 rand7() 產生 1~49 的均勻分布，\n        再利用 rejection sampling 取得 1~40 的數字，\n        最後映射到 1~10。\n        \"\"\"\n        while True:\n            # (rand7() - 1) * 7 + rand7() 產生 1~49\n            num = (rand7() - 1) * 7 + rand7()\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\ndef main():\n    # 讀取 stdin，例如 \"n = 3\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從字串中擷取數字\n    match = re.search(r'(\\d+)', data)\n    if not match:\n        return\n    n = int(match.group(1))\n\n    sol = Solution()\n    # 呼叫 rand10() n 次，收集結果\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to generate uniform 1-10 from rand7. Classic approach: use two calls to rand7 to get range 1-49, reject 41-49 to get 1-40, then map 1-40 to 1-10 via mod 10. Steps:\n\nStart\n→ Step: Generate x = rand7()\n→ Step: Generate y = rand7()\n→ Step: Compute val = (x-1)*7 + y  // range 1-49\n→ Decision: 如果 val <= 40? // accept\n    Yes → Step: Return (val-1) mod 10 + 1\n    No → Repeat entire process (loop)\nBut need to produce loop. We'll use Decision with loop.\n\nAlso we must not call other APIs. So only rand7.\n\nWe produce virtual code lines with explanations.\n\nWe need to show loop using decision: \"Repeat until success\".\n\nWe can use Start and End.\n\nLet's produce steps:\n\nStart\n→ Step: 重複\n   → Step: x = rand7() // first random\n   → Step: y = rand7() // second random\n   → Step: val = (x-1)*7 + y // combine to 1-49\n   → Decision: val <= 40? // check acceptance\n      Yes → Step: result = (val-1) % 10 + 1 // map to 1-10\n           → Step: Return result // exit\n      No → Go back to start of loop\n\nEnd\n\nBut need explicit loop structure. Use Decision with No → repeat.\n\nWe should use \"Repeat\" or \"Loop\" placeholder.\n\nLet's craft virtual code:\n\nStart\n→ Decision: 是否需要生成新數? // initial flag\n    Yes → Step: x = rand7() // 1-7\n    → Step: y = rand7() // 1-7\n    → Step: val = (x-1)*7 + y // 1-49\n    → Decision: val <= 40? // acceptable?\n        Yes → Step: result = (val-1) % 10 + 1 // 1-10\n              → Step: Return result\n        No  → Go back to start // repeat loop\nEnd\n\nBut we might need explicit 'Loop' indicator. Use \"Loop:\" label.\n\nBetter:\n\nStart\n→ Loop: // 開始迴圈\n    → Step: x = rand7() // 取得 1-7\n    → Step: y = rand7() // 取得 1-7\n    → Step: val = (x-1)*7 + y // 合併為 1-49\n    → Decision: val <= 40? // 是否在可接受區間\n        Yes → Step: result = (val-1) % 10 + 1 // 轉換為 1-10\n              → Step: Return result // 結束\n        No  → Go to Loop // 重複\n\nEnd\n\nAlso mention \"Return\" step.\n\nWe need to include explanation after each line.\n\nLet's format:\n\nStart // 程式開始執行\n→ Loop: // 進入重複迴圈，直到得到合法結果\n    → Step: x = rand7() // 產生第一個隨機數 1-7\n    → Step: y = rand7() // 產生第二個隨機數 1-7\n    → Step: val = (x-1)*7 + y // 組合為 1-49 的隨機數\n    → Decision: val <= 40? // 檢查是否在可接受區間\n        Yes → Step: result = (val-1) % 10 + 1 // 將 1-40 映射為 1-10\n              → Step: Return result // 回傳結果並離開迴圈\n        No  → Go to Loop // 若 val > 40，重複整個過程\nEnd // 程式結束\n\nMake sure each line has \"虛擬碼步驟\" + \" // 解釋\". Need to include indentation properly. Use the arrow and decision formatting exactly.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Loop: // 進入重複迴圈，直到得到合法結果  \n → Step: x = rand7() // 產生第一個隨機數 1-7  \n → Step: y = rand7() // 產生第二個隨機數 1-7  \n → Step: val = (x-1)*7 + y // 組合為 1-49 的隨機數  \n → Decision: val <= 40? // 檢查是否在可接受區間  \n  Yes → Step: result = (val-1) % 10 + 1 // 將 1-40 映射為 1-10  \n   → Step: Return result // 回傳結果並離開迴圈  \n  No  → Go to Loop // 若 val > 40，重複整個過程  \nEnd // 程式結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0]-b[0])**2 + (a[1]-b[1])**2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n\n        for i in range(4):\n            for j in range(i+1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n\n        return (\n            dists[0] > 0 and\n            dists[0] == dists[1] == dists[2] == dists[3] and\n            dists[4] == dists[5] and\n            dists[4] == 2 * dists[0]\n        )\n\ndef main():\n    data = sys.stdin.read()\n    # Extract all integer values (including negatives)\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) != 8:\n        print('false')\n        return\n    points = [[nums[i], nums[i + 1]] for i in range(0, 8, 2)]\n    p1, p2, p3, p4 = points\n    sol = Solution()\n    result = sol.validSquare(p1, p2, p3, p4)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to determine if four points form a square. Steps: calculate all pairwise distances squared (6 distances). Find min distance >0 => side length. Count occurrences: side length should appear exactly 4 times. Diagonal length appears twice and equals 2 * side^2. Then return true else false. Need to handle input unordered. Also need to handle no duplicates. Steps: compute distances list. Sort. Check distinct values. Check counts. Provide steps.\n\nWe need to output line by line virtual code with explanations. Use Start, End, Decision, Yes→, No→. Ensure each line has \"虛擬碼步驟 // 解釋\".\n\nWe'll create steps:\n\nStart\n→ Step 1: 計算所有 6 個點對距離平方 // 得到距離列表\n→ Step 2: 將距離列表排序 // 方便分辨邊長與對角線\n→ Decision: 是否存在相同距離？ // 檢查是否有至少兩種距離\n    Yes → Step 3: 設 side = 第一個距離 // 最短距離為邊長\n           → Decision: side > 0? // 確保邊長正\n               Yes → Step 4: 计数 side 出现次数 // 边长出现次数\n                      → Decision: 次数 == 4? // 四条边相等\n                          Yes → Step 5: 设 diagonal = 第五个距离 // 对角线距离\n                                 → Decision: diagonal == 2 * side^2? // 对角线关系\n                                     Yes → Step 6: 返回 true // 满足正方形条件\n                                     No  → Step 7: 返回 false // 对角线不符合\n                          No  → Step 8: 返回 false // 边长不出现四次\n               No  → Step 9: 返回 false // 边长为 0\n    No  → Step 10: 返回 false // 只有一种距离或不足两种\n\nBut we also need to consider duplicates? We could add earlier check: unique points count == 4. Let's include Step 0 before Step 1: 检查点数是否为 4 并且无重复. But input is 4 points; duplicates may be possible. We can add.\n\nLet's produce final virtual code.\n\nEnsure each line has \"虛擬碼步驟 // 解釋\".\n\nWe need arrow format: → etc. We need to indent decisions maybe. Use \"Decision:\" and \"Yes →\", \"No →\" lines. Provide consistent spacing. Use Start, End. Provide each line. Use bullet? Not required.\n\nWe'll output accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 檢查是否四個點且各點唯一 // 確保不含重複座標  \n→ Decision: 重複點存在? // 若有重複，無法構成正方形  \n  Yes → Step 1a: 返回 false // 直接結束  \n  No  → Step 1: 計算所有 6 個點對距離平方 // 取得距離列表  \n→ Step 2: 將距離列表排序 // 方便區分邊長與對角線  \n→ Decision: 是否至少兩種不同距離? // 正方形需有邊長與對角線兩種距離  \n  Yes → Step 3: side = 第一個距離 // 最短距離視為邊長  \n   → Decision: side > 0? // 邊長必為正  \n    Yes → Step 4: 計算 side 出現的次數 // 边長出現次數  \n     → Decision: 次數 == 4? // 四條邊長相等  \n      Yes → Step 5: diagonal = 第五個距離 // 对角线距离  \n       → Decision: diagonal == 2 * side^2? // 对角线应为边长平方的两倍  \n        Yes → Step 6: 返回 true // 满足正方形条件  \n        No  → Step 7: 返回 false // 对角线不符合正方形比例  \n     No  → Step 8: 返回 false // 边长未出现四次  \n  No  → Step 9: 返回 false // 边长为 0 或不符合正方形条件  \n  No  → Step 10: 返回 false // 仅有一种距离，无法构成正方形  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpejwpw309.py\", line 44, in <module>\n    price, special, needs = parse_input(raw_input)\n                            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpejwpw309.py\", line 38, in parse_input\n    special = get_list('special')\n              ^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpejwpw309.py\", line 34, in get_list\n    return ast.literal_eval(m.group(1))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[3,0,5]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpf3qdaboo.py\", line 44, in <module>\n    price, special, needs = parse_input(raw_input)\n                            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpf3qdaboo.py\", line 38, in parse_input\n    special = get_list('special')\n              ^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpf3qdaboo.py\", line 34, in get_list\n    return ast.literal_eval(m.group(1))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,4]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # base case: buy all items at regular price\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef parse_input(data):\n    # Extract lists for price, special, needs using regex\n    def get_list(var):\n        m = re.search(rf'{var}\\s*=\\s*(\\[[^\\]]*\\])', data)\n        if m:\n            return ast.literal_eval(m.group(1))\n        return []\n\n    price = get_list('price')\n    special = get_list('special')\n    needs = get_list('needs')\n    return price, special, needs\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    price, special, needs = parse_input(raw_input)\n    sol = Solution()\n    result = sol.shoppingOffers(price, special, needs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for the algorithm. Problem is LeetCode 638: Shopping Offers. Use DFS with memoization or DP. Provide step-by-step pseudocode. Each line with explanation. Use arrows and decisions.\n\nWe need to produce in Chinese traditional. Output each line with \"虛擬碼步驟 // 解釋\".\n\nWe must be careful: \"每行虛擬碼\" includes \"虛擬碼步驟\" and explanation. Use arrow etc. Start, End, Decision. We need to produce a structured algorithm, maybe recursive function.\n\nLet's produce:\n\nStart // 程式開始執行\n→ 准備函式: DFS(needs) // 將需求作為參數\n    Decision: 如果所有需求為 0? // 檢查是否已購買足夠\n        Yes → Return 0 // 需求已滿，費用為 0\n        No  → 進行下一步\n    Step: 計算不使用特價的價格 total = Σ needs[i] * price[i] // 基本價格\n    Step: best = total // 初始化最佳價格\n    → Loop over每個特殊優惠 special\n        Decision: 是否可使用此優惠? // 檢查每項是否足夠\n            Yes →\n                Step: 創建新需求 newNeeds = needs - special[0..n-1] // 更新需求\n                Step: cost = special[n] + DFS(newNeeds) // 用此優惠後費用\n                Decision: cost < best? // 與目前最佳比較\n                    Yes → best = cost // 更新最佳\n            No  → continue\n    Step: Memo[tuple(needs)] = best // 記錄結果\n    → Return best // 回傳最佳價格\nEnd // 程式結束\n\nBut need arrow formatting. Provide each step as separate line. Use \"→\" for sequence, \"Decision:\" for branching. Use \"Start\" and \"End\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ 建立 memo 字典 // 用於記錄已計算需求組合的最低價格\n→ 定義函式 DFS(需求) // 以需求為參數進行遞迴計算\n    Decision: 所有需求為 0? // 判斷是否已購足\n        Yes → Return 0 // 無需再購買，價格為 0\n        No  → 進行後續計算\n    Step: base = Σ(需求[i] * price[i]) // 僅購買個別商品的總價\n    Step: best = base // 初始化最佳價格\n    → 迴圈遍歷每個特殊優惠 special\n        Decision: 是否能使用 special? // 檢查每項需求是否足夠減少\n            Yes →\n                Step: newNeeds = [需求[i] - special[i] for i in 0..n-1] // 更新需求\n                Step: cost = special[n] + DFS(newNeeds) // 計算使用該優惠後總價\n                Decision: cost < best? // 比較是否更便宜\n                    Yes → best = cost // 更新最佳價格\n            No → // 跳過此優惠\n    Step: memo[tuple(需求)] = best // 記錄結果\n    → Return best // 回傳最佳價格\n→ result = DFS(needs) // 呼叫主函式得到最小價格\n→ Return result // 傳回答案\nEnd // 程式結束\n\nMake sure each line is separate with line breaks. Use \"→\" as arrow. Indent nested lines. Should be fine. Use Chinese. Provide arrow for decisions and loops. Should follow format.\n...done thinking.\n\nStart // 程式開始執行  \n→ 建立 memo 字典 // 用於記錄已計算需求組合的最低價格  \n→ 定義函式 DFS(需求) // 以需求為參數進行遞迴計算  \n Decision: 所有需求為 0? // 判斷是否已購足  \n  Yes → Return 0 // 無需再購買，價格為 0  \n  No  → 進行後續計算  \n Step: base = Σ(需求[i] * price[i]) // 僅購買個別商品的總價  \n Step: best = base // 初始化最佳價格  \n → 迴圈遍歷每個特殊優惠 special  \n  Decision: 是否能使用 special? // 檢查每項需求是否足夠減少  \n   Yes →  \n    Step: newNeeds = [需求[i] - special[i] for i in 0..n-1] // 更新需求  \n    Step: cost = special[n] + DFS(newNeeds) // 計算使用該優惠後總價  \n    Decision: cost < best? // 比較是否更便宜  \n     Yes → best = cost // 更新最佳價格  \n    No → // 跳過此優惠  \n Step: memo[tuple(需求)] = best // 記錄結果  \n → Return best // 回傳最佳價格  \n→ result = DFS(needs) // 呼叫主函式得到最小價格  \n→ Return result // 傳回答案  \nEnd // 程式結束"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,9,null,8]'\nGot (Norm):      '[None,9,None,8]'\n--- (Raw) ---\nRaw Expected: '[null, 9, null, 8]'\nRaw Got:      '[None, 9, None, 8]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]\n        self.tree = [0] * (self.n + 1)\n        for i in range(self.n):\n            self._add(i + 1, nums[i])\n\n    def _add(self, i, val):\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._add(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._prefix(right + 1) - self._prefix(left)\n\n    def _prefix(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Split into commands and args\n    idx = data.find(']')\n    cmds_str = data[:idx + 1]\n    args_str = data[idx + 2:].strip()\n    commands = ast.literal_eval(cmds_str)\n    args = ast.literal_eval(args_str)\n\n    obj = None\n    results = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"NumArray\":\n            obj = NumArray(arg[0] if isinstance(arg, list) and len(arg) == 1 else arg)\n            results.append(None)\n        elif cmd == \"update\":\n            obj.update(arg[0], arg[1])\n            results.append(None)\n        elif cmd == \"sumRange\":\n            results.append(obj.sumRange(arg[0], arg[1]))\n        else:\n            results.append(None)\n\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing the NumArray class with update and sumRange using e.g., segment tree or fenwick. Provide step by step pseudocode. No actual code. Must include arrow \"→\", Decision, Start, End. Provide explanation per line.\n\nWe need to include initialization, building tree, update, query sum. Likely use Fenwick Tree for simplicity. Provide steps.\n\nLet's design: Start, initialize Fenwick tree array bit of size n+1, fill with zeros. Build by adding each nums[i] to BIT via add(i+1, nums[i]).\n\nUpdate: change value, compute delta = val - nums[index], set nums[index] = val, BIT.add(index+1, delta).\n\nSumRange: sum(right) - sum(left-1). sum(i) returns prefix sum via BIT.\n\nProvide steps: Start, Build BIT, etc.\n\nLet's produce lines:\n\nStart // 程式開始執行\n\n→ Step 1: Receive input array nums and its length n // 初始化輸入\n\n→ Step 2: Create array bit[0…n] initialized to 0 // 建立 Fenwick Tree\n\n→ Step 3: Copy nums to internal array data[0…n-1] // 保留原始資料以便計算 delta\n\n→ Step 4: For i from 0 to n-1: Call add(i+1, data[i]) // 建立樹\n\n→ Step 5: Define function add(idx, delta) // 更新 BIT\n\n→   → Step 5a: While idx ≤ n: bit[idx] += delta; idx += idx & -idx\n\n→ Step 6: Define function prefixSum(idx) // 取得前綴和\n\n→   → Step 6a: sum = 0; While idx > 0: sum += bit[idx]; idx -= idx & -idx\n\n→   → Step 6b: Return sum\n\n→ Step 7: Update(index, val) // 更新元素\n\n→   → Step 7a: delta = val - data[index]\n\n→   → Step 7b: data[index] = val\n\n→   → Step 7c: add(index+1, delta)\n\n→ Step 8: SumRange(left, right) // 計算區間和\n\n→   → Step 8a: return prefixSum(right+1) - prefixSum(left)\n\n→ End // 程式結束\n\nNeed to keep formatting with arrows and decisions? Not necessary decisions here.\n\nBut we need to adhere to format: each line \"虛擬碼步驟\" + \" // 解釋/說明\".\n\nAlso use arrow notation for steps. Provide indentation accordingly.\n\nUse \"→\" before each step. Indent substeps with more arrow? maybe use same arrow but nested? Use indentation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Receive input array nums and its length n // 初始化輸入資料  \n→ Step 2: Create array bit[0…n] initialized to 0 // 建立 Fenwick Tree  \n→ Step 3: Copy nums to internal array data[0…n-1] // 保留原始資料以便計算差值  \n→ Step 4: For i from 0 to n-1: Call add(i+1, data[i]) // 建立樹以便後續查詢  \n→ Step 5: Define function add(idx, delta) // 更新 BIT 的內部函式  \n→   → Step 5a: While idx ≤ n: bit[idx] += delta; idx += idx & -idx // 逐步累加至父節點  \n→ Step 6: Define function prefixSum(idx) // 取得前綴和的內部函式  \n→   → Step 6a: sum = 0; While idx > 0: sum += bit[idx]; idx -= idx & -idx // 逐步減至父節點  \n→   → Step 6b: Return sum // 傳回前綴和結果  \n→ Step 7: Update(index, val) // 更新元素值的外部方法  \n→   → Step 7a: delta = val - data[index] // 計算值的變化量  \n→   → Step 7b: data[index] = val // 更新存儲的原始資料  \n→   → Step 7c: add(index+1, delta) // 在 BIT 中加入差值以維持正確和  \n→ Step 8: SumRange(left, right) // 回傳區間和的外部方法  \n→   → Step 8a: Return prefixSum(right+1) - prefixSum(left) // 先後減得區間和  \nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqek22d_1.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpqek22d_1.py\", line 51, in main\n    ans = sol.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqek22d_1.py\", line 9, in calcEquation\n    graph[a][b] = val\n    ~~~~~^^^\nTypeError: unhashable type: 'list'"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpb6depdkf.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpb6depdkf.py\", line 51, in main\n    ans = sol.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpb6depdkf.py\", line 8, in calcEquation\n    for (a, b), val in zip(equations, values):\n        ^^^^^^\nValueError: too many values to unpack (expected 2)"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjelfizwt.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpjelfizwt.py\", line 51, in main\n    ans = sol.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjelfizwt.py\", line 8, in calcEquation\n    for (a, b), val in zip(equations, values):\n        ^^^^^^\nValueError: not enough values to unpack (expected 2, got 1)"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1.0 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\ndef parse_input(line: str):\n    # Find positions of the three parts\n    eq_start = line.find('equations =')\n    val_start = line.find('values =')\n    qry_start = line.find('queries =')\n\n    equations_str = line[eq_start + len('equations ='):val_start].strip()\n    values_str = line[val_start + len('values ='):qry_start].strip()\n    queries_str = line[qry_start + len('queries ='):].strip()\n\n    equations = ast.literal_eval(equations_str)\n    values = ast.literal_eval(values_str)\n    queries = ast.literal_eval(queries_str)\n    return equations, values, queries\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    equations, values, queries = parse_input(data)\n    sol = Solution()\n    ans = sol.calcEquation(equations, values, queries)\n    formatted = '[' + ','.join(f'{x:.5f}' for x in ans) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code for solving equations and queries. We should provide step-by-step algorithm. Likely we need to build graph adjacency list with weights as division ratios, then BFS/DFS per query. Steps: Build graph, process queries, output result. Provide virtual code line by line with comments. Ensure use of Start, End, Decision, etc. Let's craft.\n\nWe need to use virtual code syntax: \"Start\", \"→ Step 1:\", \"Decision:\" etc. For loops, we can use \"→ For each equation:\". Use arrow and maybe indentation with spaces.\n\nWe should ensure each line ends with // explanation. Use proper Chinese explanation. Each line with code and comment separated by space? They said `虛擬碼步驟` + `[空格]` + `// 解釋/說明`. So code and comment separated by space, not colon? We'll follow example: `→ Step 1: ... // ...`.\n\nLet's produce.\n\nPseudo:\n\nStart\n→ Build adjacency list graph // 建立圖\n→ For each equation i:\n    → Add edge Ai -> Bi weight values[i] // Ai/Bi = value\n    → Add edge Bi -> Ai weight 1/values[i] // Bi/Ai = 1/value\n→ For each query j:\n    → If Cj or Dj not in graph: answer -1.0 // 未定義\n    → If Cj == Dj: answer 1.0 // 同一變量\n    → Else: BFS from Cj to find path to Dj\n        → Initialize queue with Cj, product = 1\n        → While queue not empty:\n            → Dequeue node\n            → If node == Dj: record product, break\n            → For each neighbor:\n                → If not visited:\n                    → Enqueue neighbor, update product * weight\n        → If found: store product\n        → Else: store -1.0\n→ Output answers list\nEnd\n\nNeed to use Decision syntax. For loops we can use \"→ For each ...\". For BFS we may need Decision inside loop.\n\nLet's produce with line numbers? Not necessary but each line separate. Indent decisions accordingly.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Build graph // 建立圖的資料結構  \n→ For each equation i: // 逐一處理輸入的等式  \n  → Add edge Ai → Bi weight values[i] // 代表 Ai / Bi = value  \n  → Add edge Bi → Ai weight 1 / values[i] // 代表 Bi / Ai = 1/value  \n→ For each query j: // 逐一處理查詢  \n  Decision: 是否存在 Cj 或 Dj 未在 graph? // 判斷變數是否已定義  \n   Yes → Append -1.0 to answers // 未定義則答案為 -1.0  \n   No  → Decision: Cj == Dj? // 是否相同變數  \n    Yes → Append 1.0 to answers // 相同變數商為 1  \n    No  → Begin BFS from Cj to Dj // 需要尋找連結  \n     → Initialize queue with (Cj, 1.0) // 起點商為 1  \n     → Mark Cj visited  \n     → While queue not empty: // BFS 主迴圈  \n       → Dequeue (node, prod)  \n       Decision: node == Dj? // 到達目標嗎  \n        Yes → Append prod to answers // 找到商，記錄答案  \n        No  → For each neighbor of node: // 探索鄰接節點  \n         Decision: neighbor 未 visited?  \n          Yes → Enqueue (neighbor, prod * weight[node→neighbor])  \n          No → Continue  \n       Decision: 找到 Dj? // BFS 結束判斷  \n       Yes → 已在前面處理，跳出循環  \n       No  → 循環結束後仍未找到  \n       Decision: 找不到路徑?  \n        Yes → Append -1.0 to answers // 無路徑  \n        No → 這種情況不會發生（已在找到時處理）  \n→ Return answers // 回傳所有查詢結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      \"['dogcatsdog', 'catsdogcats', 'ratcatdogcat']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        words.sort(key=len)\n        word_set = set()\n        res = []\n        for w in words:\n            if not w:  # skip empty strings\n                continue\n            if self._can_form(w, word_set):\n                res.append(w)\n            word_set.add(w)\n        return res\n\n    def _can_form(self, word, word_set):\n        dp = [False] * (len(word) + 1)\n        dp[0] = True\n        for i in range(1, len(word) + 1):\n            for j in range(0, i):\n                if not dp[j]:\n                    continue\n                if word[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(word)]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Extract the list literal from the input string\n    try:\n        start = data.index('[')\n        end = data.rindex(']') + 1\n        list_str = data[start:end]\n        words = ast.literal_eval(list_str)\n    except (ValueError, SyntaxError):\n        words = []\n\n    sol = Solution()\n    result = sol.findAllConcatenatedWordsInADict(words)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: given array words, no duplicates, find all concatenated words that can be formed by concatenating at least two other words in list. Approach: sort words by length, use a set/dictionary for prefix checks, dynamic programming per word to check if it can be formed by shorter words.\n\nSimplify: Steps: Start, load words, sort, initialize set, result list. For each word in sorted order: check if word can be segmented using DP with set of words seen so far. If yes, add to result; else add to set. End. Provide line-by-line virtual code with arrows and explanation.\n\nWe must not output actual code but pseudo steps: e.g.,\n\nStart // 程式開始執行\n→ Step 1: 將 words 按字串長度升序排序 // 讓較短的字先加入集合\n→ Step 2: 初始化 empty set wordSet // 存放已處理的單字\n→ Step 3: 初始化 empty list result // 存放符合條件的連接字\n\nThen iterate:\n\n→ Decision: 是否還有未處理字? Yes → Step 4: 取下列表首 word // 取得下一個要檢查的字\n\nNow DP function:\n\n→ Step 5: 建立布林陣列 dp[0..len(word)] 並設 dp[0]=true // 代表空字串可拆分\n→ Decision: 迴圈 i from 1 to len(word) // 逐個字元檢查\n    → Step 6: Decision: 如果 dp[i] 已為 true? No → continue? Actually we need nested loops: for i from 1..len, if dp[i] then for j from i+1..len, check substring word[i:j] in wordSet. If yes, set dp[j]=true.\n\nBut we can express simply:\n\n→ Decision: For i in 1..len(word)\n    → Decision: 如果 dp[i] 為 true? Yes → Step 7: For j in i+1..len(word)\n        → Decision: substring = word[i:j] 是否在 wordSet? Yes → Step 8: dp[j] = true\n\nAfter loops:\n\n→ Decision: 如果 dp[len(word)] 為 true 且 word 由至少兩個單字組成? Use count? Instead we can check if dp[len] true and not just word itself. Because wordSet doesn't contain current word, so if dp[len] true, it means segmentation using previous words, which ensures at least one split. But could be whole word? Since word not yet added to set, dp[len] true only if segmentation exists with at least two parts. Good.\n\n→ Decision: 是否 dp[len(word)] 為 true? Yes → Step 9: 將 word 加入 result // 符合條件\n    No → Step 10: 將 word 加入 wordSet // 供後續字使用\n\n→ Step 11: 回到 Decision: 是否還有未處理字? 以此迴圈。\n\n→ End // 完成\n\nBut need to produce line-by-line virtual code with arrow notation. Use \"Decision:\" for if. For loops, we can use \"For i in 1..len\" etc. Provide explanation after //.\n\nAlso need to include the DP step as nested decision loops. Use arrow lines.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 將 words 按字串長度升序排序 // 讓較短的字先加入集合\n→ Step 2: 初始化空集合 wordSet // 存放已處理的單字\n→ Step 3: 初始化空列表 result // 存放符合條件的連接字\n\n→ Decision: 是否還有未處理字? Yes → Step 4: 取出第一個字 word // 取得下一個要檢查的字\n\n→ Step 5: 建立布林陣列 dp[0..len(word)] 並設 dp[0] = true // 代表空字串可拆分\n→ For i from 1 to len(word) // 逐個位置\n    → Decision: 是否 dp[i] 為 true? Yes → For j from i+1 to len(word) // 往後搜尋可分割位置\n        → Decision: substring = word[i:j] 是否在 wordSet? Yes → dp[j] = true // 記錄此位置可拆分\n\n→ Decision: 是否 dp[len(word)] 為 true? Yes → Step 6: 將 word 加入 result // 此字可由至少兩個較短字串組成\n    No  → Step 7: 將 word 加入 wordSet // 此字無法拆分，將其加入集合供後續使用\n\n→ Step 8: 回到 Decision: 是否還有未處理字? // 迴圈繼續\n\nEnd // 程式執行結束\n\nWe need to ensure each line has \"虛擬碼步驟\" then space then \"// 解釋\".\n\nAlso arrow indent: Use \"→\" for next step, and \"Decision:\" lines with indentation maybe. We'll include \"→\" for each new line. Use \"Decision:\" lines for condition.\n\nWe need to ensure each line includes the step content and explanation. Use Chinese. Provide final output exactly as specified.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 words 按字串長度升序排序 // 讓較短的字先加入集合  \n→ Step 2: 初始化空集合 wordSet // 存放已處理的單字  \n→ Step 3: 初始化空列表 result // 存放符合條件的連接字  \n\n→ Decision: 是否還有未處理字?  \n Yes → Step 4: 取出第一個字 word // 取得下一個要檢查的字  \n\n→ Step 5: 建立布林陣列 dp[0..len(word)] 並設 dp[0] = true // 代表空字串可拆分  \n→ For i from 1 to len(word) // 逐個位置  \n  Decision: 是否 dp[i] 為 true?  \n   Yes → For j from i+1 to len(word) // 往後搜尋可分割位置  \n    Decision: substring = word[i:j] 是否在 wordSet?  \n     Yes → dp[j] = true // 記錄此位置可拆分  \n\n→ Decision: 是否 dp[len(word)] 為 true?  \n Yes → Step 6: 將 word 加入 result // 此字可由至少兩個較短字串組成  \n No → Step 7: 將 word 加入 wordSet // 此字無法拆分，將其加入集合供後續使用  \n\n→ Step 8: 回到 Decision: 是否還有未處理字? // 迴圈繼續  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,2,2,false]'\nGot (Norm):      '[None,None,None,2,2,False]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 2, 2, false]'\nRaw Got:      '[None, None, None, 2, 2, False]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        # 把新元素放到 q1 的尾部\n        self.q1.append(x)\n\n    def pop(self) -> int:\n        # 若兩個佇列都為空，直接拋出錯誤\n        if not self.q1 and not self.q2:\n            raise IndexError(\"pop from empty stack\")\n        # 把 q1 中除最後一個外的元素都轉移到 q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # 取出頂部元素\n        top_elem = self.q1.popleft()\n        # 交換兩個佇列，恢復原始結構\n        self.q1, self.q2 = self.q2, self.q1\n        return top_elem\n\n    def top(self) -> int:\n        if not self.q1 and not self.q2:\n            raise IndexError(\"top from empty stack\")\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top_elem = self.q1.popleft()\n        # 再把頂部元素放回 q2，保持堆疊不變\n        self.q2.append(top_elem)\n        self.q1, self.q2 = self.q2, self.q1\n        return top_elem\n\n    def empty(self) -> bool:\n        return not self.q1 and not self.q2\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 去除可能的前導文字，例如 \"Input \"\n    if data.startswith(\"Input\"):\n        data = data[5:].strip()\n    # 轉成合法的 Python 兩個列表的元組\n    try:\n        data_tuple = ast.literal_eval(\"(\" + data + \")\")\n    except Exception:\n        # 如果解析失敗，直接結束\n        return\n    commands, arguments = data_tuple\n    stack = None\n    result = []\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"MyStack\":\n            stack = MyStack()\n            result.append(None)\n        elif cmd == \"push\":\n            stack.push(arg[0])\n            result.append(None)\n        elif cmd == \"pop\":\n            result.append(stack.pop())\n        elif cmd == \"top\":\n            result.append(stack.top())\n        elif cmd == \"empty\":\n            result.append(stack.empty())\n    # 輸出結果\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing LIFO stack using two queues. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Decision, etc. We need to outline the class MyStack with push, pop, top, empty. Use two queues: q1 and q2. Approach: push by enqueuing to q1. For pop, move all but last element from q1 to q2, then dequeue last element from q1 as result, then swap q1 and q2. For top, similar but instead of discarding last, peek it. But to avoid duplication we can implement pop that returns value. Top can call pop then push back? But simpler: in top, do same as pop but keep last and re-enqueue it to q2. After operation, swap q1 and q2.\n\nLet's outline virtual steps. We'll start with Start, then initialize queues, then each method's steps. Use Decision structures for checking empty. Use loops maybe represented generically.\n\nWe need to not output actual code but pseudocode lines with explanation. Use arrows.\n\nWe will show flow: Start, Initialize q1,q2 empty. Then method push: q1.enqueue(x). etc.\n\nFor pop: If empty -> return null? But we can show Decision: If empty? No -> return error. else -> loop while size(q1)>1: q2.enqueue(q1.dequeue()). Then last = q1.dequeue(). Then swap q1,q2. Return last.\n\nTop similar: same loop, but store last and re-enqueue it into q2 after loop? Actually after loop, last = q1.dequeue(); then q2.enqueue(last) to keep it. Then swap q1,q2; return last.\n\nEmpty: return q1.isEmpty() && q2.isEmpty().\n\nLet's produce virtual steps. We'll denote loops with \"While\" but keep arrow. Might show \"While q1.size() > 1 → ...\".\n\nWe need to adhere to format: each line \"虛擬碼步驟 // 解釋\". Use \"→\" arrow. Use \"Decision:\" with Yes→, No→.\n\nLet's write. We'll start with \"Start\". Then initialize. Then method definitions. We'll separate methods. We'll use indentation for substeps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個空佇列 q1, q2 // 用來儲存堆疊元素  \n\n// -------------------- push 方法 --------------------\n→ Step 2: 方法 push(x) // 新增元素到堆疊頂部  \n→     q1.enqueue(x) // 直接把元素加入 q1 的尾部  \n\n// -------------------- pop 方法 --------------------\n→ Step 3: 方法 pop() // 移除並返回堆疊頂部元素  \n→     Decision: q1.isEmpty() 且 q2.isEmpty()? // 判斷堆疊是否為空  \n        Yes → Return null // 空堆疊時返回空值  \n        No  →  \n            → Step 4: While q1.size() > 1 → // 移動除最後一個外的所有元素  \n                →     q2.enqueue(q1.dequeue()) // 從 q1 前端移除並加入 q2  \n            → Step 5: topElement ← q1.dequeue() // 取得堆疊頂部元素  \n            → Step 6: Swap(q1, q2) // 交換兩個佇列，恢復為原來的 q1  \n            → Return topElement // 回傳被移除的元素  \n\n// -------------------- top 方法 --------------------\n→ Step 7: 方法 top() // 取得堆疊頂部元素但不移除  \n→     Decision: q1.isEmpty() 且 q2.isEmpty()?  \n        Yes → Return null  \n        No  →  \n            → Step 8: While q1.size() > 1 → // 與 pop 類似移動元素  \n                →     q2.enqueue(q1.dequeue())  \n            → Step 9: topElement ← q1.dequeue() // 取得頂部元素  \n            → Step 10: q2.enqueue(topElement) // 再把它放回 q2  \n            → Step 11: Swap(q1, q2) // 交換佇列  \n            → Return topElement // 回傳頂部值  \n\n// -------------------- empty 方法 --------------------\n→ Step 12: 方法 empty() // 判斷堆疊是否為空  \n→     Return q1.isEmpty() AND q2.isEmpty() // 若兩佇列皆空，堆疊為空  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Longest Palindromic Subsequence",
      "source_file": "Leetcode/leetcode516.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "\"bbbab\"",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '6'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '6'"
        },
        {
          "example_index": 1,
          "input": "\"cbbd\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '4'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n        # 建立 n x n 的 DP 陣列，初始化為 0\n        dp = [[0] * n for _ in range(n)]\n        # 從後往前填表，確保 dp[i+1][j-1] 已經計算完成\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1  # 單個字元本身就是長度 1 的回文子序列\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    # 讀取輸入字串，移除首尾空白\n    s = sys.stdin.readline().strip()\n    solution = Solution()\n    result = solution.longestPalindromeSubseq(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need virtual code for longest palindromic subsequence length. Typical DP: let dp[i][j] length for s[i..j]. Compute length. Complexity O(n^2). Need to produce step-by-step pseudocode. Use Start, Decision, etc. Provide each line with explanation. Use arrow. We need to output line by line. Let's plan:\n\nStart // begin\n→ Step 1: read string s // input\n→ Step 2: n = length of s // get length\n→ Step 3: create 2D array dp[n][n] initialized to 0 // DP table\n→ Decision: if n == 0? // empty string\n    Yes → Step 4: output 0 // no subsequence\n    No → Step 5: for i from 0 to n-1: dp[i][i] = 1 // single chars\n→ Step 6: for length from 2 to n: // substring length\n    → Step 7: for i from 0 to n-length:\n        j = i + length - 1\n        → Decision: if s[i] == s[j]?\n            Yes → dp[i][j] = dp[i+1][j-1] + 2 // chars match\n            No → dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // skip one end\n→ Step 8: result = dp[0][n-1] // full string\n→ Step 9: output result // print\nEnd // finish\n\nNow produce lines with arrow. Each line format: \"Step X: ...\" but need arrow \"→\". Decision lines with indentation. Use // explanation. For Decision: include Yes → ... No → ... lines. Use indentation as per sample.\n\nLet's craft each line. Ensure no actual code syntax, just virtual. Provide explanatory comments. We'll follow format: \"Start // 程式開始執行\". Use arrow \"→\". Indent using spaces maybe. Use \"Decision:\" lines. Provide explanation. Use [空格] between virtual code and explanation.\n\nLet's craft.\n\nAlso need to mention dp[i][j] table. Use step numbers maybe but not necessary. Provide unique labels.\n\nWill output:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 s // 從使用者取得字串\n→ Step 2: 設定 n = 長度(s) // 獲取字串長度\n→ Step 3: 建立 2D 陣列 dp[n][n]，初始化為 0 // 用於存儲子問題結果\n→ Decision: 如果 n == 0? // 判斷字串是否為空\n    Yes → Step 4: 輸出 0 // 空字串的最長回文子序列長度為 0\n    No  → Step 5: 從 i = 0 到 n-1: dp[i][i] = 1 // 單個字符本身為長度 1 的回文\n→ Step 6: 對於子串長度 len 從 2 到 n:\n    → Step 7: 對於起始索引 i 從 0 到 n - len:\n        j = i + len - 1\n        → Decision: 如果 s[i] == s[j]?\n            Yes → dp[i][j] = dp[i+1][j-1] + 2 // 外兩字符相同，長度加 2\n            No  → dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取兩種刪除方式中的較長\n→ Step 8: 結果 = dp[0][n-1] // 整個字串的最長回文子序列長度\n→ Step 9: 輸出 結果 // 將結果輸出給使用者\nEnd // 程式執行結束\n\nCheck formatting: Each line must include \"虛擬碼步驟\" + \" \" + \"// 解釋/說明\". The virtual code step can be \"Step X:\" etc. Indentation should be as sample. We'll follow sample style. For Decision lines, indent the Yes and No branches with spaces. Provide the arrow \"→\" at start of each line. For nested steps, indent appropriately. Use spaces for indentation. Also include \"Decision:\" label.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 從使用者取得字串  \n→ Step 2: 設定 n = 長度(s) // 獲取字串長度  \n→ Step 3: 建立 2D 陣列 dp[n][n]，初始化為 0 // 用於存儲子問題結果  \n→ Decision: 如果 n == 0? // 判斷字串是否為空  \n Yes → Step 4: 輸出 0 // 空字串的最長回文子序列長度為 0  \n No  → Step 5: 從 i = 0 到 n-1: dp[i][i] = 1 // 單個字符本身為長度 1 的回文  \n→ Step 6: 對於子串長度 len 從 2 到 n: // 開始處理較長子串  \n → Step 7: 對於起始索引 i 從 0 到 n - len: // 遍歷所有子串  \n  j = i + len - 1  \n  → Decision: 如果 s[i] == s[j]? // 判斷兩端字符是否相同  \n   Yes → dp[i][j] = dp[i+1][j-1] + 2 // 外兩字符相同，長度加 2  \n   No  → dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取兩種刪除方式中的較長  \n→ Step 8: 結果 = dp[0][n-1] // 整個字串的最長回文子序列長度  \n→ Step 9: 輸出 結果 // 將結果輸出給使用者  \nEnd // 程式執行結束"
    },
    {
      "title": "Median of Two Sorted Arrays",
      "source_file": "Leetcode/leetcode4.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,3], nums2 = [2]",
          "expected_output": "2.00000",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2.00000'\nGot (Norm):      '1.00000'\n--- (Raw) ---\nRaw Expected: '2.00000'\nRaw Got:      '1.00000'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nimport math\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        # 確保 nums1 為較短陣列\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        m, n = len(nums1), len(nums2)\n        total = m + n\n        half = total // 2\n\n        low, high = 0, m\n        while low <= high:\n            partitionX = (low + high) // 2\n            partitionY = half - partitionX\n\n            maxLeftX = -math.inf if partitionX == 0 else nums1[partitionX - 1]\n            minRightX = math.inf if partitionX == m else nums1[partitionX]\n\n            maxLeftY = -math.inf if partitionY == 0 else nums2[partitionY - 1]\n            minRightY = math.inf if partitionY == n else nums2[partitionY]\n\n            if maxLeftX <= minRightY and maxLeftY <= minRightX:\n                if total % 2 == 0:\n                    return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2.0\n                else:\n                    return max(maxLeftX, maxLeftY)\n            elif maxLeftX > minRightY:\n                high = partitionX - 1\n            else:\n                low = partitionX + 1\n        # 理論上不會進到這裡\n        return 0.0\n\ndef parse_input(input_str: str):\n    \"\"\"\n    解析形如 'nums1 = [1,3], nums2 = [2]' 的輸入字串，回傳兩個 list。\n    \"\"\"\n    pattern = r'nums1\\s*=\\s*(\\[.*?\\])\\s*,\\s*nums2\\s*=\\s*(\\[.*?\\])'\n    match = re.search(pattern, input_str, re.S)\n    if match:\n        nums1 = ast.literal_eval(match.group(1))\n        nums2 = ast.literal_eval(match.group(2))\n        return nums1, nums2\n    # 若輸入格式不同，嘗試直接 eval\n    try:\n        data = eval(input_str, {}, {})\n        if isinstance(data, dict) and 'nums1' in data and 'nums2' in data:\n            return data['nums1'], data['nums2']\n    except Exception:\n        pass\n    raise ValueError(\"無法解析輸入\")\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    try:\n        nums1, nums2 = parse_input(raw_input)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        return\n\n    sol = Solution()\n    median = sol.findMedianSortedArrays(nums1, nums2)\n    print(f\"{median:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm: find median of two sorted arrays in O(log(m+n)). Typical approach: binary search partition. Use virtual code with Start, Decision, steps. Provide per line explanation.\n\nWe should break down algorithm:\n\n- Ensure nums1 is smaller array; if not swap.\n\n- Define total = m+n, half = total/2.\n\n- Binary search on smaller array: low=0, high=m.\n\n- While low <= high:\n\n   - partitionX = (low+high)/2\n\n   - partitionY = half - partitionX\n\n   - maxLeftX = if partitionX==0? -∞ : nums1[partitionX-1]\n\n   - minRightX = if partitionX==m? ∞ : nums1[partitionX]\n\n   - similarly for Y.\n\n   - if maxLeftX <= minRightY and maxLeftY <= minRightX:\n\n        - if total is even: median = (max(maxLeftX, maxLeftY)+min(minRightX, minRightY))/2\n\n        - else median = max(maxLeftX, maxLeftY)\n\n   - else if maxLeftX > minRightY: high = partitionX-1\n\n   - else low = partitionX+1\n\n- Return median.\n\nWe need to produce virtual code lines with explanation. Each line must include step and explanation after //.\n\nWe must use arrows and Decision. The algorithm has loops and decisions. Provide Start, End.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 若 nums1 的長度 > nums2 的長度? // 確保較短陣列為 nums1  \n    Yes → Step 1: 交換 nums1 與 nums2；交換 m 與 n // 讓 nums1 為較短陣列  \n    No  → Step 1: 無需交換 // 兩陣列已符合條件  \n→ Step 2: 計算 total = m + n, half = total / 2 // 取得總長度與中位分割點  \n→ Step 3: 初始化 low = 0, high = m // 設定二分搜尋範圍於 nums1  \n→ Decision: low ≤ high? // 開始二分搜尋迴圈  \n    Yes → → Step 4: partitionX = (low + high) / 2 // 取 nums1 的中點作分割  \n        → Step 5: partitionY = half - partitionX // 讓兩邊總元素數相等  \n        → Step 6: maxLeftX = (partitionX == 0) ? -∞ : nums1[partitionX - 1] // 左邊最大值  \n        → Step 7: minRightX = (partitionX == m) ? ∞ : nums1[partitionX] // 右邊最小值  \n        → Step 8: maxLeftY = (partitionY == 0) ? -∞ : nums2[partitionY - 1] // 左邊最大值  \n        → Step 9: minRightY = (partitionY == n) ? ∞ : nums2[partitionY] // 右邊最小值  \n        → Decision: maxLeftX ≤ minRightY AND maxLeftY ≤ minRightX? // 分割是否正確  \n            Yes → → Decision: total 為偶數? // 判斷中位數計算方式  \n                Yes → → Step 10: median = (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2 // 偶數長度取平均  \n                No  → → Step 11: median = max(maxLeftX, maxLeftY) // 奇數長度取左側最大值  \n                → Step 12: Return median // 結束演算法  \n            No → → Decision: maxLeftX > minRightY? // 需要向左調整 partitionX  \n                Yes → → Step 13: high = partitionX - 1 // 向左縮小搜尋範圍  \n                No  → → Step 14: low = partitionX + 1 // 向右擴大搜尋範圍  \n        → Step 15: 回到 Decision: low ≤ high? // 迴圈判斷是否繼續  \n    No → Step 16: End // 程式執行結束，未找到分割點（理論上不會發生）"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        \"\"\"\n        使用 DSU（并查集）將所有具有共同郵件的帳號合併。\n        \"\"\"\n        parent = {}  # email -> 父節點\n\n        def find(x):\n            \"\"\"\n            找到 x 的根節點，並進行路徑壓縮。\n            \"\"\"\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}  # email -> 名稱\n\n        # 建立並查集結構\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                # 連結所有 email 到第一個 email\n                root_email = find(first_email)\n                root_current = find(email)\n                parent[root_current] = root_email\n                email_to_name[email] = name\n\n        # 收集同一個根節點下的所有 email\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        # 產生最終結果，並對每個帳號的 email 做排序\n        return [[email_to_name[root]] + sorted(emails) for root, emails in merged.items()]\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print([])\n        sys.exit(0)\n\n    # 取出列表部分並安全解析\n    idx = raw_input.find('[')\n    accounts_part = raw_input[idx:]\n    accounts = ast.literal_eval(accounts_part)\n\n    # 執行合併\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n\n    # 輸出結果\n    print(merged_accounts)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem is LeetCode \"Accounts Merge\". We need to produce steps: building graph of emails, DFS/BFS, grouping, sorting, output.\n\nWe produce pseudocode lines with arrows.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化圖形、映射和名稱\n→ Step 2: 遍歷 accounts，對每個帳戶建立 email 關聯\n→ Decision: 需要將第一個 email 設為根\n    Yes → Step 3: 對於每個後續 email, 建立雙向邊\n→ Step 4: 建立 email -> name 映射（使用第一個 email）\n→ Step 5: 初始化 visited 集合\n→ Decision: 是否有未訪問的 email?\n    Yes → Step 6: 使用 DFS 找到連通分量\n        → Step 7: 收集此分量內的所有 email\n        → Step 8: 將 email 排序\n        → Step 9: 將 name + sorted emails 加入結果\n        → Step 10: 標記為已訪問\n        → Step 11: 回到 Decision\n    No → End\n\nAlso need mapping from email to name stored. So final code lines.\n\nLet's produce each line.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\" with arrow \"→\". Start and End.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 建立空圖形 adj (email → email 列表) 和空字典 emailToName // 準備儲存 email 關聯與對應名稱\n→ Step 2: 建立空集合 visited // 標記已處理的 email\n→ Step 3: 建立空列表 result // 儲存合併後的帳戶\n→ Decision: 是否還有帳戶未處理? // 準備進入帳戶迴圈\n    Yes → Step 4: 針對每個 account 進行處理\n        → Step 5: 取 name = account[0] // 取得帳戶名稱\n        → Step 6: 取 emails = account[1:] // 取得所有 email\n        → Decision: emails 是否至少有一個? // 確保非空\n            Yes → Step 7: 取 firstEmail = emails[0] // 選擇第一個 email 作為根\n                → Step 8: 將 firstEmail 與 name 相關聯於 emailToName\n                → Decision: 是否有其他 email? // 建立邊\n                    Yes → Step 9: 針對每個 otherEmail in emails[1:]:\n                        → Step 10: adj[firstEmail].add(otherEmail)\n                        → Step 11: adj[otherEmail].add(firstEmail)\n                    No → No-op\n            No → No-op\n        → Step 12: 完成所有帳戶的圖構建\n→ Decision: 是否還有未訪問的 email? // 檢查是否完成 DFS\n    Yes → Step 13: 針對每個未訪問的 email e:\n        → Step 14: 建立空列表 component // 收集此連通分量的 email\n        → Step 15: 使用 DFS( e ):\n            → Step 16: 標記 current email為已訪問\n            → Step 17: 將 current email 加入 component\n            → Step 18: 針對每個相鄰 email nei in adj[current]:\n                → Decision: nei 是否已訪問?\n                    Yes → No-op\n                    No  → DFS( nei )\n        → Step 19: 取得 component 中的名稱 name = emailToName[e]\n        → Step 20: 對 component 進行字母排序\n        → Step 21: 將 [name] + component 連接成 list // 合併後帳戶\n        → Step 22: 將此 list 加入 result\n        → Step 23: 回到 Decision\n    No → End // 程式結束\n\nWe must ensure each line uses '→' and includes explanatory comment. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空圖形 adj (email → email 列表) 和空字典 emailToName // 準備儲存 email 關聯與對應名稱  \n→ Step 2: 建立空集合 visited // 標記已處理的 email  \n→ Step 3: 建立空列表 result // 儲存合併後的帳戶  \n→ Decision: 是否還有帳戶未處理? // 準備進入帳戶迴圈  \n Yes → Step 4: 針對每個 account 進行處理  \n  → Step 5: 取 name = account[0] // 取得帳戶名稱  \n  → Step 6: 取 emails = account[1:] // 取得所有 email  \n  → Decision: emails 是否至少有一個? // 確保非空  \n   Yes → Step 7: 取 firstEmail = emails[0] // 選擇第一個 email 作為根  \n    → Step 8: adj[firstEmail] ← 空列表 // 為根建立鄰接列表  \n    → Step 9: emailToName[firstEmail] ← name // 將根 email 與名稱對應  \n    → Decision: 是否有其他 email? // 建立邊  \n     Yes → Step 10: 針對每個 otherEmail in emails[1:]:  \n      → Step 11: adj[firstEmail].add(otherEmail) // 建立雙向連結  \n      → Step 12: adj[otherEmail] ← adj.get(otherEmail, 空列表) // 確保存在  \n      → Step 13: adj[otherEmail].add(firstEmail)  \n     No → No-op  \n   No → No-op  \n → Step 14: 完成所有帳戶的圖構建  \n→ Decision: 是否還有未訪問的 email? // 檢查是否完成 DFS  \n Yes → Step 15: 針對每個未訪問的 email e:  \n  → Step 16: 建立空列表 component // 收集此連通分量的 email  \n  → Step 17: 執行 DFS(e)  \n   → Step 18: 標記 e 為已訪問  \n   → Step 19: component.add(e) // 加入分量  \n   → Decision: 是否存在相鄰 email nei?  \n    Yes → Step 20: 若 nei 未訪問, 進行 DFS(nei)  \n    No → No-op  \n  → Step 21: 取得 component 中的名稱 name = emailToName[e] // 取根的名稱  \n  → Step 22: 對 component 進行字母排序  \n  → Step 23: 將 [name] + component 連接成 list // 合併後帳戶  \n  → Step 24: 將此 list 加入 result  \n  → Step 25: 回到 Decision  \n No → End // 程式執行結束"
    },
    {
      "title": "My Calendar I",
      "source_file": "Leetcode/leetcode729.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpra3efc1r.py\", line 87, in <module>\n    main()\n  File \"/tmp/tmpra3efc1r.py\", line 60, in main\n    ops, args = parse_input(raw_input)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpra3efc1r.py\", line 54, in parse_input\n    args_list = ast.literal_eval(args)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    , [[], [10, 20], [15, 25], [20, 30]]\n    ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MyCalendar:\n    \"\"\"\n    以簡單的列表儲存已預約的區間。\n    book 方法會檢查與現有區間是否重疊，若無則加入。\n    \"\"\"\n    def __init__(self):\n        self.bookings = []\n\n    def book(self, start, end):\n        for s, e in self.bookings:\n            # 兩區間有重疊時 max(start, s) < min(end, e)\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入文字成 (operations, arguments)。\n    支援以下兩種格式：\n    1. 兩行：第一行為操作列表，第二行為參數列表。\n    2. 單行：操作列表與參數列表以「,」分隔，兩者均為合法 Python 文字。\n    \"\"\"\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if not lines:\n        return [], []\n\n    if len(lines) == 1:\n        # 單行模式：需要自行拆分成兩個表達式\n        line = lines[0]\n        parts = []\n        buf = ''\n        depth = 0\n        for ch in line:\n            if ch == '[':\n                depth += 1\n            if ch == ']':\n                depth -= 1\n            buf += ch\n            if depth == 0 and ch == ']':\n                parts.append(buf)\n                buf = ''\n        ops, args = parts\n    else:\n        ops, args = lines[0], lines[1]\n\n    # 使用 ast.literal_eval 以安全方式解析\n    ops_list = ast.literal_eval(ops)\n    args_list = ast.literal_eval(args)\n    return ops_list, args_list\n\n\ndef main():\n    raw_input = sys.stdin.read()\n    ops, args = parse_input(raw_input)\n\n    if not ops:\n        print('[]')\n        return\n\n    result = []\n    instance = None\n\n    for op, arg in zip(ops, args):\n        if op == 'MyCalendar':\n            instance = MyCalendar()\n            result.append(None)   # MyCalendar 返回 null\n        elif op == 'book':\n            if instance is None:\n                raise RuntimeError(\"MyCalendar instance not created before book()\")\n            res = instance.book(*arg)\n            result.append(res)\n        else:\n            # 若未定義的操作，可視需求擴充\n            result.append(None)\n\n    # 使用 json.dumps 產生符合範例的輸出格式\n    print(json.dumps(result, ensure_ascii=False))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code that describes the implementation of MyCalendar with book method. We'll use a data structure like list of intervals and check overlaps. Or use BST. We'll produce pseudocode with steps. Must follow format: each line \"虛擬碼步驟 // 解釋\". Use arrows. Provide Start, End. So produce stepwise algorithm. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 MyCalendar 類別，內部持有空的事件列表 intervals // 初始化日曆，事件以 [start, end) 存儲\n→ Step 2: 定義 book(start, end) 方法 // 該方法嘗試新增事件並回傳布林值\n→     Decision: 是否有任何已存在事件與 [start, end) 重疊? // 檢查重複預約\n→         Yes → Step 3: 回傳 false，並且不新增事件 // 發現重疊，保留日曆不變\n→         No  → Step 4: 把 [start, end) 加入 intervals 列表 // 事件可安全加入\n→             Step 5: 回傳 true // 成功預約\nEnd // 程式執行結束\n\n// 以上虛擬碼描述了 MyCalendar 的核心邏輯：維護一個事件列表，使用簡單的線性掃描來檢查是否有重疊，若無則新增並回傳成功。"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,6,0,6,6,1,1,0]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 6, 0, 6, 6, 1, 1, 0]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        index = random.randint(0, self.size - 1)\n        return self.mapping.get(index, index)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    # Parse commands and arguments\n    commands = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n    outputs = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            outputs.append(None)\n        elif cmd == \"pick\":\n            outputs.append(obj.pick())\n        else:\n            # Unsupported command, skip\n            outputs.append(None)\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with comments. The algorithm: typical solution: mapping for blacklisted numbers that are less than W = n - blackCount. Use hash map to remap black numbers < W to some white numbers >= W. On pick, generate random r in [0, W-1]; if r in mapping, return mapping[r]; else r.\n\nNeed to produce steps: Start, Initialize: store n, blacklist, calculate W, build mapping, etc. Then pick() uses random call once. Provide pseudo code.\n\nWe must output each line as \"虛擬碼步驟 // 解釋\".\n\nWe need to adhere to format, use arrows and Decision structure.\n\nSo produce Start, Step lines: e.g.,\n\nStart // 程式開始執行\n\n→ Step 1: Set N ← input n // Store original range size\n\n→ Step 2: Set B ← input blacklist array // Store blacklist\n\n→ Step 3: Compute W ← N - size(B) // Number of allowed integers\n\n→ Decision: If size(B) == 0? // No blacklist, trivial case\n\n    Yes → Step 4: mapping ← empty // No mapping needed\n\n    No → Step 5: Initialize empty dictionary M // Mapping for black numbers < W\n\n        → For each x in B: // Iterate over blacklist\n\n            → Decision: If x < W? // Black number inside [0, W-1]\n\n                Yes → Add x to set S // S holds black numbers that need remapping\n\n                No → Continue // ignore\n\n        → Set Y ← N-1 // Start of high range to assign mapping\n\n            → For each x in B: // Assign high numbers to replace black numbers in low range\n\n                → Decision: If x < W? // Only map those inside low range\n\n                    Yes → While Y in B: Y ← Y-1 // Find a high number not blacklisted\n\n                    → M[x] ← Y // Map low black to high white\n\n                    → Y ← Y-1 // Move to next high number\n\n                No → Continue\n\nEnd of initialization\n\nThen pick method:\n\n→ Step 6: r ← randomInt(0, W-1) // Generate random integer within allowed low range\n\n→ Decision: If r in M? // If r is a black number mapped\n\n    Yes → Return M[r] // Return mapped white number\n\n    No  → Return r // Return r itself\n\nEnd // End of algorithm\n\nWe need to include all lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set N ← n // 先儲存整體範圍大小  \n→ Step 2: Set B ← blacklist // 先儲存黑名單  \n→ Step 3: Compute W ← N - size(B) // 允許數字的數量 (白名單長度)  \n\n→ Decision: If size(B) == 0? // 若無黑名單，直接返回  \n    Yes → Step 4: mapping ← empty // 沒有需要的映射  \n    No → Step 5: Initialize empty dictionary M // 用於映射需要重新指派的數字  \n\n        → For each x in B: // 遍歷黑名單  \n            → Decision: If x < W? // 只處理落在低區 [0, W-1] 的黑數  \n                Yes → Add x to set S // 將需要映射的黑數存入集合  \n                No → Continue // 其餘不處理  \n\n        → Set Y ← N-1 // 從最高數字開始尋找可映射的白數  \n            → For each x in B: // 再次遍歷黑名單，進行映射  \n                → Decision: If x < W? // 只對低區黑數進行映射  \n                    Yes → While Y in B: Y ← Y-1 // 找到一個不在黑名單的高數字  \n                    → M[x] ← Y // 建立映射 x → Y  \n                    → Y ← Y-1 // 准備下一個高數字  \n                No → Continue // 跳過高區黑數  \n\nEnd // 初始設定結束  \n\n→ Step 6: r ← randomInt(0, W-1) // 隨機產生 [0, W-1] 範圍內的數字  \n→ Decision: If r in M? // 檢查 r 是否需要映射  \n    Yes → Return M[r] // 回傳映射後的白數  \n    No  → Return r // 回傳原數字  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmperjw8wk5.py\", line 39, in <module>\n    data = json.loads(sys.stdin.read())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 45 (char 44)"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n\nclass MapSum:\n    def __init__(self):\n        # 根節點\n        self.root = TrieNode()\n        # 儲存鍵對應的原始值\n        self.key_val = {}\n\n    def insert(self, key: str, val: int) -> None:\n        old_val = self.key_val.get(key, 0)\n        diff = val - old_val\n        self.key_val[key] = val\n\n        node = self.root\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += diff\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，預期為 JSON 格式\n    data = json.loads(sys.stdin.read())\n    commands, args = data\n\n    obj = None\n    results = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MapSum\":\n            obj = MapSum()\n            results.append(None)\n        elif cmd == \"insert\":\n            key, val = arg[0], arg[1]\n            obj.insert(key, val)\n            results.append(None)\n        elif cmd == \"sum\":\n            prefix = arg[0]\n            results.append(obj.sum(prefix))\n\n    # 輸出結果，使用 JSON 轉換以得到 `null` 的表示\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for MapSum class. Should include initialization, insert, sum. Use virtual code with arrows, decisions etc. Provide line by line. Use Start, End, Decision, etc. We'll produce a high-level algorithm: Use a Trie with cumulative sums. Insert updates sums along path. Need to maintain previous value for key to adjust. We'll keep map key->val. Steps:\n\nStart\n→ Step 1: Initialize MapSum object\n    → Initialize empty trie root node with children map, sum=0\n    → Initialize empty hashmap keyToVal\n→ Step 2: insert(key, val)\n    → Retrieve oldVal = keyToVal.getOrDefault(key, 0)\n    → diff = val - oldVal\n    → keyToVal.put(key, val)\n    → Node curr = root\n    → For each char c in key:\n        → If curr.children doesn't contain c:\n             → curr.children[c] = new TrieNode()\n        → curr = curr.children[c]\n        → curr.sum += diff\n→ Step 3: sum(prefix)\n    → Node curr = root\n    → For each char c in prefix:\n        → If curr.children doesn't contain c:\n             → return 0\n        → curr = curr.children[c]\n    → return curr.sum\nEnd\n\nWe need to produce virtual code with arrows.\n\nWe'll format like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 MapSum 物件 // 創建根節點和 key-to-value 的雜湊表\n    → TrieNode root = new TrieNode() // 根節點\n    → Map<String, Integer> keyToVal = new HashMap() // 儲存鍵對應值\n→ Step 2: insert(key, val) // 插入或更新鍵值對\n    → Integer oldVal = keyToVal.getOrDefault(key, 0) // 取得舊值\n    → Integer diff = val - oldVal // 需要累加的差值\n    → keyToVal.put(key, val) // 更新鍵對應值\n    → TrieNode node = root // 從根節點開始\n    → Decision: 迭代 key 的每個字元? // 處理字串\n        Yes → \n            → Decision: node.children 是否包含 char? // 若沒有節點則新建\n                Yes →\n                No  → node.children.put(char, new TrieNode()) // 新節點\n            → node = node.children.get(char) // 進入子節點\n            → node.sum += diff // 累加差值\n        No → // 完成插入\n→ Step 3: sum(prefix) // 計算前綴總和\n    → TrieNode node = root\n    → Decision: 迭代 prefix 的每個字元?\n        Yes →\n            → Decision: node.children 是否包含 char?\n                Yes → node = node.children.get(char)\n                No  → return 0 // 前綴不存在\n        No → // 所有字元遍歷完畢\n    → return node.sum\nEnd // 程式結束\n\nBut we need to produce exactly virtual code lines each with // explanation. Use arrow for decisions etc. We'll produce consistent formatting. Ensure each line ends with // 解釋. Use Chinese. Provide lines for all steps.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 建立 MapSum 物件 // 初始化根節點與鍵值雜湊表\n    → TrieNode root = new TrieNode() // 根節點，sum 先為 0\n    → Map<String, Integer> keyToVal = new HashMap() // 儲存鍵對應的原始值\n→ Step 2: insert(key, val) // 插入或覆寫鍵值對\n    → Integer oldVal = keyToVal.getOrDefault(key, 0) // 取得舊值，若無則 0\n    → Integer diff = val - oldVal // 計算需要更新的差值\n    → keyToVal.put(key, val) // 更新鍵對應值\n    → TrieNode node = root // 從根節點開始\n    → Decision: 逐字處理 key? // 逐個字元往下走\n        Yes →\n            → Decision: node.children 是否有 char? // 若沒有則新建節點\n                Yes →\n                No  → node.children.put(char, new TrieNode()) // 新建子節點\n            → node = node.children.get(char) // 進入子節點\n            → node.sum += diff // 在此節點累加差值\n        No → // 完成 insert\n→ Step 3: sum(prefix) // 取得前綴總和\n    → TrieNode node = root // 從根節點開始\n    → Decision: 逐字處理 prefix? // 逐個字元往下走\n        Yes →\n            → Decision: node.children 是否有 char? // 若不存在直接回 0\n                Yes → node = node.children.get(char)\n                No  → return 0 // 前綴不存在\n        No → // 所有字元已處理\n    → return node.sum // 返回累加的總和\nEnd // 程式結束\n\nMake sure each line ends with // 解釋. Provide each line individually.\n\nAlso ensure arrow syntax: Use \"→\" before each step. For decisions, we use \"Decision:\" then indentation for Yes/No. Provide lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 MapSum 物件 // 初始化根節點與鍵值雜湊表  \n    → TrieNode root = new TrieNode() // 根節點，sum 初始為 0  \n    → Map<String, Integer> keyToVal = new HashMap() // 儲存鍵對應的原始值  \n→ Step 2: insert(key, val) // 插入或覆寫鍵值對  \n    → Integer oldVal = keyToVal.getOrDefault(key, 0) // 取得舊值，若無則 0  \n    → Integer diff = val - oldVal // 計算需要更新的差值  \n    → keyToVal.put(key, val) // 更新鍵對應值  \n    → TrieNode node = root // 從根節點開始  \n    → Decision: 逐字處理 key? // 逐個字元往下走  \n        Yes →  \n            → Decision: node.children 是否有 char? // 若沒有則新建節點  \n                Yes →  \n                No  → node.children.put(char, new TrieNode()) // 新建子節點  \n            → node = node.children.get(char) // 進入子節點  \n            → node.sum += diff // 在此節點累加差值  \n        No → // 完成 insert  \n→ Step 3: sum(prefix) // 取得前綴總和  \n    → TrieNode node = root // 從根節點開始  \n    → Decision: 逐字處理 prefix? // 逐個字元往下走  \n        Yes →  \n            → Decision: node.children 是否有 char? // 若不存在直接回 0  \n                Yes → node = node.children.get(char)  \n                No  → return 0 // 前綴不存在  \n        No → // 所有字元已處理  \n    → return node.sum // 返回累加的總和  \nEnd // 程式結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.2582003476764494,-0.07081969434570758],[0.15546188903744834,0.22780690980349808],[0.6985607466821037,-0.28177591559361953]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.2582003476764494, -0.07081969434570758], [0.15546188903744834, 0.22780690980349808], [0.6985607466821037, -0.28177591559361953]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    \"\"\"\n    用於在指定圓內產生均勻隨機點的類別。\n    \"\"\"\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        \"\"\"\n        初始化圓的半徑與中心座標。\n        \"\"\"\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        \"\"\"\n        隨機產生一個位於圓內（含邊界）的點。\n\n        產生方式：\n        1. 產生 0~1 的均勻隨機數 u，用 sqrt(u)*radius 取得半徑，\n           這樣能保證在圓面內部的分布均勻。\n        2. 產生 0~1 的均勻隨機數 v，並以 2πv 轉成角度 theta。\n        3. 依極座標轉為直角座標，得到 (x, y)。\n        \"\"\"\n        u = random.random()          # [0, 1)\n        v = random.random()          # [0, 1)\n        r = math.sqrt(u) * self.radius\n        theta = 2 * math.pi * v\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    \"\"\"\n    讀取 stdin 的兩行輸入，分別為指令列表與參數列表，\n    並依序執行，最後將結果輸出為 JSON 格式。\n    \"\"\"\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n\n    commands = json.loads(data[0])          # 例: [\"Solution\", \"randPoint\", ...]\n    arguments = json.loads(data[1]) if len(data) > 1 else []\n\n    results = []\n    obj = None\n\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)             # 建構子回傳 null\n        else:\n            # 取得對應方法並呼叫\n            method = getattr(obj, cmd)\n            results.append(method())\n\n    # 輸出 JSON，Python 的 None 會被轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the task: generate uniform random point inside circle. So algorithm: use polar coordinates: generate random radius sqrt(r)*radius; generate random angle uniform 0 to 2π. Then x = center_x + r * cos(theta); y = center_y + r * sin(theta). Provide step-by-step virtual code lines with explanation comments.\n\nAlso include initialization steps: storing radius, center.\n\nVirtual code must use Start, End, Decision, etc.\n\nWe need to produce each line with \"虛擬碼步驟 // 解釋\". Use arrow lines.\n\nWe need to reflect function calls: constructor, randPoint. Provide internal steps.\n\nWe should include the random number generation calls: rand() for angle and for sqrt.\n\nThus structure: Start -> Step 1: initialize attributes -> Step 2: define randPoint -> inside it: generate u=random uniform [0,1], v=random uniform [0,1], r = sqrt(u)*radius, theta=2π*v, compute x, y. Return [x,y].\n\nAlso decision not needed. But we can still show if needed. But minimal.\n\nLet's craft virtual code lines.\n\nUse \"→\" for progression.\n\nWe might need \"Decision:\" for generating random? Not necessary. We'll just show steps.\n\nWe should include comment after each line.\n\nLet's output as requested.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告屬性 radius, x_center, y_center // 儲存圓半徑與中心座標  \n→ Step 2: Solution(radius, x_center, y_center) // 建構子初始化物件  \n    → Step 2.1: this.radius ← radius  \n    → Step 2.2: this.x_center ← x_center  \n    → Step 2.3: this.y_center ← y_center  \n→ Step 3: 定義方法 randPoint() // 產生隨機點  \n    → Step 3.1: u ← RandomUniform(0, 1) // 產生 [0,1] 之隨機數  \n    → Step 3.2: v ← RandomUniform(0, 1) // 再產生另一個隨機數  \n    → Step 3.3: r ← sqrt(u) * this.radius // 轉換為半徑以保證均勻分布  \n    → Step 3.4: theta ← 2 * PI * v // 生成均勻角度  \n    → Step 3.5: x ← this.x_center + r * cos(theta) // 計算 X 座標  \n    → Step 3.6: y ← this.y_center + r * sin(theta) // 計算 Y 座標  \n    → Step 3.7: return [x, y] // 傳回隨機點座標  \nEnd // 程式執行結束"
    },
    {
      "title": "Ones and Zeroes",
      "source_file": "Leetcode/leetcode474.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuq2053sr.py\", line 20, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp78dzp3ah.py\", line 20, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\n    ^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 逆序遍歷，避免重複使用同一個字串\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 用 exec 解析類似 \"strs = [...], m = 5, n = 3\" 的輸入\n    local_vars = {}\n    exec(data, {}, local_vars)\n    strs = local_vars.get('strs', [])\n    m = local_vars.get('m', 0)\n    n = local_vars.get('n', 0)\n    result = Solution().findMaxForm(strs, m, n)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code flow that solves the problem: given array of binary strings, find largest subset size with at most m zeros and n ones. Classic DP: 2D knapSack.\n\nWe need to output in requested format: line per step with \"虛擬碼步驟\" then space then comment.\n\nWe must use virtual code arrow \"→\", \"Yes →\", \"No →\" etc.\n\nWe need to produce structured steps: Start, compute counts, DP table initialization, iterate strings, inner loops, update DP, return answer, End.\n\nWe need to keep it simple. For each step, provide explanation.\n\nWe must not output actual code. Just steps. Let's craft.\n\nFirst: Start // begin\n\n→ Step 1: Input strs, m, n // get data\n\n→ Step 2: Initialize dp array (m+1) x (n+1) to 0 // DP table\n\n→ Decision: For each string s in strs? // iterate\n\n   → Step 3: Count zeros z and ones o in s // compute counts\n\n   → Decision: If z <= m and o <= n? // check feasibility\n\n       Yes → Step 4: For i from m down to z\n\n           → Step 5: For j from n down to o\n\n               → Step 6: dp[i][j] = max(dp[i][j], dp[i - z][j - o] + 1) // update\n\n       No → Step 7: Continue // skip string\n\n→ Step 8: Find max value in dp[][] // after all strings processed\n\n→ Step 9: Return max // result\n\nEnd // finished\n\nWe also need to use \"Decision:\" format with nested arrows.\n\nAlso \"Yes →\" and \"No →\" inside.\n\nMake sure each line is a separate virtual code step line, with explanation.\n\nWe must also consider the nested loops. Use arrows for loops.\n\nWe need to output each step as separate line. We'll output in order.\n\nLet's craft the lines:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 strs、整數 m、n // 取得問題參數\n→ Step 2: 建立 dp 二維表 dp[m+1][n+1]，並初始化為 0 // 動態規劃表\n→ Decision: 對於陣列中每個字串 s? // 逐一處理\n    Yes → Step 3: 計算 s 中 0 的數量 z 和 1 的數量 o // 獲取限制\n    → Decision: z <= m 且 o <= n? // 確認能否放入表中\n        Yes → Step 4: 由 i = m 降至 z\n            → Step 5: 由 j = n 降至 o\n                → Step 6: dp[i][j] = max(dp[i][j], dp[i - z][j - o] + 1) // 更新 DP\n        No → Step 7: 跳過此字串 // 超過限制不處理\n→ Step 8: 從 dp 表中找出最大值 // 取得答案\n→ Step 9: 回傳最大值 // 結果輸出\nEnd // 程式執行結束\n\nMake sure each step line ends with comment.\n\nAlso use \"→\" at start. Ensure indentation for nested decisions maybe using spaces.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 strs、整數 m、n // 取得問題參數\n→ Step 2: 建立 dp 二維表 dp[m+1][n+1]，並初始化為 0 // 動態規劃表\n→ Decision: 對於陣列中每個字串 s? // 逐一處理\n    Yes → Step 3: 計算 s 中 0 的數量 z 和 1 的數量 o // 獲取限制\n    → Decision: z <= m 且 o <= n? // 確認能否放入表中\n        Yes → Step 4: 由 i = m 降至 z\n            → Step 5: 由 j = n 降至 o\n                → Step 6: dp[i][j] = max(dp[i][j], dp[i - z][j - o] + 1) // 更新 DP\n        No → Step 7: 跳過此字串 // 超過限制不處理\n→ Step 8: 從 dp 表中找出最大值 // 取得答案\n→ Step 9: 回傳最大值 // 結果輸出\nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,3,2],[2,3,1],[2,3,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 3, 2], [2, 3, 1], [2, 3, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列的拷貝，方便 reset\n        self.original = list(nums)\n        # current 用於 shuffle，初始時與 original 相同\n        self.current = list(nums)\n\n    def reset(self):\n        # 把 current 重新設為原始順序\n        self.current = list(self.original)\n        return self.current\n\n    def shuffle(self):\n        n = len(self.current)\n        # Fisher‑Yates 洗牌\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            self.current[i], self.current[j] = self.current[j], self.current[i]\n        return self.current\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把輸入字串包成 tuple 以符合 literal_eval 的語法\n    try:\n        methods, args = ast.literal_eval(f\"({data})\")\n    except Exception as e:\n        raise ValueError(\"Invalid input format\") from e\n\n    outputs = []\n    obj = None\n    for meth, arg in zip(methods, args):\n        if meth == \"Solution\":\n            obj = Solution(arg[0])\n            outputs.append(None)\n        elif meth == \"reset\":\n            outputs.append(obj.reset())\n        elif meth == \"shuffle\":\n            outputs.append(obj.shuffle())\n        else:\n            raise ValueError(f\"Unknown method: {meth}\")\n\n    # 使用 json.dumps 以得到 null 代替 None\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode for solution class with methods: constructor, reset, shuffle. Provide step-by-step pseudo-code lines, with explanations. Use Start, End, Decision arrows. We should include initialization storing original array, and a copy for shuffling. shuffle: Fisher-Yates shuffle. Need random number generator. Provide steps accordingly. Let's produce output lines.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 宣告 Solution 類別\n→ Step 2: 在 Solution 中宣告兩個屬性：original: 整數陣列 // 儲存原始陣列\n    → Step 3: current: 整數陣列 // 儲存目前陣列（可被洗牌）\n→ Decision: 若使用者呼叫建構子？ // 判斷是否有傳入陣列\n    Yes → Step 4: Solution(nums: 整數陣列) // 建構子接收整數陣列\n        → Step 5: original ← 複製 nums // 複製陣列以保留原始順序\n        → Step 6: current ← 複製 nums // 初始 current 與 original 相同\n        → End // 建構子完成\n→ Step 7: 定義方法 reset() // 重設陣列\n    → Step 8: current ← 複製 original // 把 current 重新設為原始順序\n    → Step 9: return current // 回傳重設後的陣列\n→ Step 10: 定義方法 shuffle() // 隨機洗牌\n    → Step 11: size ← current 的長度 // 取得陣列長度\n    → Decision: 若 size ≤ 1？ // 如果陣列長度小於等於1\n        Yes → Step 12: return current // 直接回傳，無需洗牌\n        No  → Step 13: for i from size-1 downto 1 // Fisher-Yates 循環\n                → Step 14: j ← 隨機整數 0 到 i inclusive // 隨機選取索引\n                → Step 15: swap current[i] 與 current[j] // 交換兩個位置\n        → End // 洗牌完成\n    → Step 16: return current // 回傳洗牌後的陣列\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            res.append(path[:])                # 加入目前的子集\n            for i in range(start, len(nums)):\n                path.append(nums[i])           # 將 nums[i] 加入子集\n                backtrack(i + 1, path)         # 以新的子集繼續遞迴\n                path.pop()                     # 回溯，移除最後一個元素\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從輸入字串中擷取方括號內的列表字串\n    left = data.find('[')\n    right = data.rfind(']')\n    if left == -1 or right == -1:\n        print([])\n        sys.exit(0)\n\n    nums = ast.literal_eval(data[left:right+1])\n\n    sol = Solution()\n    result = sol.subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for algorithm: generate all subsets of a set of unique integers, return all subsets, no duplicates. We need to provide line by line virtual code with explanation. Format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc. Should produce pseudo code but not actual code. Use arrows and decisions. Should cover input, recursion or iterative approach. Provide step-by-step. Each line should be a step. So we produce pseudo steps: Start, sort array? Not needed. But we can produce approach: use backtracking. Steps: function to generate subsets. Or iterative: start with empty set and for each element, add to existing subsets. Provide decisions for recursion base case, etc.\n\nWe need to produce code only, no commentary. Each line as \"Start // ...\". Each line must include \"→\" for arrows? In format, we can start with \"Start // ...\". Then \"→ Step 1: ...\". For decision use \"Decision:\" lines. Let's produce about 12-15 lines.\n\nWe must ensure each line includes step text + \" // explanation\".\n\nWe will produce:\n\nStart // 程式開始執行\n→ Step 1: 定義輸入陣列 nums // 取得使用者提供的唯一整數陣列\n→ Step 2: 初始化結果 list subsets = [[]] // 以空集合開始，為後續擴充做準備\n→ Step 3: 遍歷 nums 中每個元素 num // 逐一處理每個數字\n→ Decision: 目前 subsets 是否為空? // 確認是否還有已生成的子集\n    Yes → Step 4: subsets = [] // 若為空，重置為空列表（理論上不會發生）\n    No  → Step 5: 針對每個已存在子集 new_subset = subset + [num] // 將 num 加入到現有子集\n        → Step 6: 將 new_subset 加入 subsets // 將新子集加入結果集合\n→ Step 7: 回傳 subsets // 最終回傳所有子集\nEnd // 程式執行結束\n\nBut we need to produce for each step line: the code plus explanation. Also for loops, decisions.\n\nBetter to use \"Decision:\" and then indent.\n\nWe should produce something like:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入陣列 nums // 從使用者取得唯一整數列表\n→ Step 2: 建立結果 subsets = [[]] // 初始化子集列表，先加入空集合\n→ Step 3: For each element num in nums // 遍歷所有元素\n    → Decision: 是否需要將 num 加入所有已存在子集? // 確認是否有子集可擴充\n        Yes → Step 4: 針對 subsets 中的每個子集 subset\n            → Step 5: new_subset = subset + [num] // 新增元素後產生新子集\n            → Step 6: 將 new_subset 加入 subsets // 把新子集加入結果集合\n        No  → Step 7: （此情況不會發生，因為 subsets 至少包含空集合）\n→ Step 8: 回傳 subsets // 完成所有子集的生成\nEnd // 程式結束\n\nBut \"Decision\" inside for loop may be mis-specified. We can skip decision if not necessary. The requirement: Use Decision: and arrow. But we can use a decision: \"Decision: 是否需要處理新元素?\" But it's always yes. We can simply not use decision.\n\nBut guidelines require use of Decision, arrows. We can incorporate a simple decision: check if num is not null.\n\nLet's produce more steps:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入陣列 nums // 取得使用者提供的唯一整數陣列\n→ Step 2: 建立結果 subsets = [[]] // 初始化子集列表，先加入空集合\n→ Step 3: 逐一處理 nums 中的每個元素 num // 用迴圈遍歷\n    → Decision: 是否已經處理完所有元素? // 判斷是否完成遍歷\n        Yes → Step 4: 跳出迴圈 // 迴圈結束\n        No  → Step 5: 針對目前 subsets 中的每個子集 subset\n            → Step 6: new_subset = subset + [num] // 將 num 加入子集\n            → Step 7: 將 new_subset 加入 subsets // 把新子集存入結果\n→ Step 8: 回傳 subsets // 回傳所有子集\nEnd // 程式結束\n\nBut \"Decision: 是否已經處理完所有元素?\" is not typical; we could skip. But guidelines: Use Decision for if else. We can incorporate decision at start: If nums 為空則只返回 [[]]. Let's include.\n\nLet's craft final code:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入陣列 nums // 取得使用者提供的唯一整數陣列\n→ Decision: nums 是否為空? // 檢查輸入是否為空\n    Yes → Step 2: 回傳 [[]] // 空集合本身即為唯一子集\n    No  → Step 3: 建立結果 subsets = [[]] // 初始化子集列表，先加入空集合\n→ Step 4: 逐一處理 nums 中的每個元素 num // 用迴圈遍歷\n    → Decision: 是否有子集可以擴充? // 判斷 subsets 是否為空（理論上不會）\n        Yes → Step 5: 針對 subsets 中的每個子集 subset\n            → Step 6: new_subset = subset + [num] // 新子集是現有子集加上 num\n            → Step 7: 將 new_subset 加入 subsets // 把新子集加入結果\n        No  → Step 8: （此情況不會發生，因為 subsets 至少包含空集合）\n→ Step 9: 回傳 subsets // 完成所有子集的生成\nEnd // 程式結束\n\nBut the decision inside loop may be unnecessary but okay. Provide as required.\n\nLet's finalize.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 nums // 取得使用者提供的唯一整數陣列  \n→ Decision: nums 是否為空? // 檢查輸入是否為空  \n    Yes → Step 2: 回傳 [[]] // 空集合本身即為唯一子集  \n    No  → Step 3: 建立結果 subsets = [[]] // 初始化子集列表，先加入空集合  \n→ Step 4: 逐一處理 nums 中的每個元素 num // 用迴圈遍歷  \n    → Decision: 是否有子集可以擴充? // 判斷 subsets 是否為空（理論上不會）  \n        Yes → Step 5: 針對 subsets 中的每個子集 subset  \n            → Step 6: new_subset = subset + [num] // 新子集是現有子集加上 num  \n            → Step 7: 將 new_subset 加入 subsets // 把新子集加入結果  \n        No  → Step 8: （此情況不會發生，因為 subsets 至少包含空集合）  \n→ Step 9: 回傳 subsets // 完成所有子集的生成  \nEnd // 程式結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmponkti4eb.py\", line 60, in <module>\n    args = ast.literal_eval(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [ [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity          # 最大容量\n        self.min_freq = 0                 # 最小頻率\n        self.key_to_val_freq = {}         # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys (LRU order)\n\n    def _update(self, key: int) -> None:\n        \"\"\"將 key 的頻率加 1，並維持 min_freq 的正確性。\"\"\"\n        value, freq = self.key_to_val_freq[key]\n        # 從舊頻率字典移除\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # 加入新頻率字典\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # 更新值並提升頻率\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        # 若快取已滿，驅逐 LFU+LRU\n        if len(self.key_to_val_freq) >= self.capacity:\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # 新增項目，頻率為 1\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 分離兩個列表\n    parts = data.split('],', 1)\n    ops_part = parts[0] + ']'\n    args_part = '[' + parts[1]\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            obj = LFUCache(arg[0])\n            results.append(None)\n        elif op == \"put\":\n            obj.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            val = obj.get(arg[0])\n            results.append(val)\n        else:\n            results.append(None)\n\n    # 將 None 轉換成 null 以符合 LeetCode 輸出格式\n    print(str(results).replace(\"None\", \"null\"))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for LFU cache design. Provide steps line by line. Must not output actual code. Use structure Start, End, Decision etc. Need to explain each step. Should include initialization, get, put, eviction logic, freq lists, etc. Virtual code, not actual code, but show algorithm steps. Provide one line per step. Should be comprehensible. Use arrows. Provide explanation after //.\n\nWe need to outline algorithm: Use hashmap key->node, frequency->DLL of nodes. Use minFreq tracking. On get: if key not found return -1; else increment freq: remove from old freq list, add to new freq list; update node freq; update minFreq if needed; return value. On put: if capacity 0, return. If key exists: update value, same as get for freq. Else: if cache at capacity: find minFreq list, remove LRU node from that list, delete from key map. Insert new node with freq=1, add to freq list 1; update key map; set minFreq=1. Done.\n\nWe need to break into steps. Let's structure like: Start, Decision etc. Provide maybe substeps for get and put. Since it's virtual code, each line can be like \"→ Step: description\".\n\nWe need to use arrows. We can have nested decisions: e.g. Decision: key exists? Yes/No.\n\nOk produce step-by-step.\n\nWe should start with initialization: store capacity, create hashmap, freq map, minFreq.\n\nThen get: Check key exists, else return -1. If exists, call incrementFreq, return value.\n\nDefine incrementFreq: remove node from current freq list, add to next freq list, update node freq, if old freq list empty and freq==minFreq, increment minFreq.\n\nPut: If capacity==0, return. If key exists: update value, call incrementFreq. Else: if size==capacity: evict LRU from minFreq list: remove tail, delete key from hashmap. Then insert new node with freq=1, add to freq list 1, set minFreq=1.\n\nWe also need to maintain freq lists with order: use doubly linked list. We can just refer to operations: addNode, removeNode, popTail.\n\nOk produce each step line.\n\nUse \"Start\", \"End\".\n\nLet's produce.\n\nWe need to provide explanation after //.\n\nLet's start.\n\nWe'll produce maybe 30-40 lines.\n\nWe must ensure arrow usage.\n\nWe can have nested decisions like:\n\nDecision: capacity > 0? yes/no\n\nBut simpler: just describe steps.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 變數 init: capacity, keyMap, freqMap, minFreq ← 0 // 初始化容量與資料結構  \n→ Decision: 若 capacity 為 0? // 檢查是否能建立快取  \n    Yes → End // 失敗直接結束（容量為 0 的快取不作任何操作）  \n    No  → Continue  \n\n→ Step 2: keyMap ← 空字典 // key ↦ 節點  \n→ Step 3: freqMap ← 空字典 // freq ↦ 雙向鏈表 (LRU 順序)  \n→ Step 4: minFreq ← 0 // 目前最小使用頻率  \n\n// ==================== get 方法 ====================\n\n→ Step 5: get(key): // 取得鍵值  \n→ Decision: 若 key 不在 keyMap? // 檢查是否存在  \n    Yes → Step 6: return -1 // 未找到，回傳 -1  \n    No  → Continue  \n\n→ Step 7: node ← keyMap[key] // 取得節點  \n→ Step 8: node.value ← node.value // (保持不變，但用於說明)  \n→ Step 9: Call incrementFreq(node) // 更新頻率  \n→ Step 10: return node.value // 回傳值  \n\n// ==================== put 方法 ====================\n\n→ Step 11: put(key, value): // 新增或更新鍵值  \n→ Decision: 若 capacity 為 0? // 無法存儲任何項目  \n    Yes → End // 直接結束  \n    No  → Continue  \n\n→ Decision: 若 key 在 keyMap? // 已存在的鍵  \n    Yes → Step 12: keyMap[key].value ← value // 更新值  \n          → Call incrementFreq(keyMap[key]) // 更新頻率  \n          → End  \n    No  → Continue  \n\n→ Decision: 若 keyMap.size == capacity? // 容量已滿，需驅逐  \n    Yes → Step 13: list ← freqMap[minFreq] // 最小頻率的鏈表  \n          → Step 14: lruNode ← list.popTail() // 移除最舊節點  \n          → Step 15: Delete keyMap[lruNode.key] // 從 keyMap 刪除  \n          → Step 16: If list is empty → Delete freqMap[minFreq] // 清空空鏈表  \n          → End (驅逐完成)  \n    No  → End (不需要驅逐)  \n\n→ Step 17: newNode ← Node(key, value, freq=1) // 建立新節點  \n→ Step 18: If freqMap[1] 不存在 → freqMap[1] ← 新鏈表  \n→ Step 19: freqMap[1].addToHead(newNode) // 加到頻率 1 的頭部（最近使用）  \n→ Step 20: keyMap[key] ← newNode // 加入 keyMap  \n→ Step 21: minFreq ← 1 // 最小頻率重新設為 1  \n→ End // put 完成  \n\n// ==================== incrementFreq 方法 ====================\n\n→ Step 22: incrementFreq(node): // 將節點頻率加 1  \n→ Step 23: oldFreq ← node.freq  \n→ Step 24: newFreq ← oldFreq + 1  \n→ Step 25: node.freq ← newFreq // 更新節點頻率  \n\n→ Step 26: freqMap[oldFreq].remove(node) // 從舊頻率鏈表移除  \n→ Decision: 若 freqMap[oldFreq] 為空? // 若舊頻率鏈表已空  \n    Yes → Step 27: Delete freqMap[oldFreq] // 刪除空鏈表  \n          → Decision: 若 oldFreq == minFreq?  \n              Yes → Step 28: minFreq ← newFreq // minFreq 需升級  \n              No  → Continue  \n    No  → Continue  \n\n→ Step 29: If freqMap[newFreq] 不存在 → freqMap[newFreq] ← 新鏈表  \n→ Step 30: freqMap[newFreq].addToHead(node) // 加到新頻率鏈表頭部  \n→ End // incrementFreq 完成  \n\n// ==================== 資料結構說明 ====================\n\n→ Step 31: Node: key, value, freq, prev, next // 節點存儲鍵值、頻率及鏈表指針  \n→ Step 32: DoublyLinkedList: head, tail, addToHead(node), remove(node), popTail() // 典型雙向鏈表操作  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,0,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 0, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        # 建立前綴和\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 產生 [1, total] 之隨機數\n        target = random.randint(1, self.total)\n        # 二分搜尋最小的 prefix >= target\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把輸入包成一個 JSON 陣列，方便解析\n    data_wrapped = '[' + data + ']'\n    methods, args_list = json.loads(data_wrapped)\n\n    obj = None\n    results = []\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(args[0])\n            results.append(None)            # 建構子回傳 null\n        else:\n            res = getattr(obj, method)(*args)\n            results.append(res)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. The requirement: \"You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index. Implement pickIndex() function that returns random index according to weights.\" So we need to design algorithm: precompute prefix sums, generate random number in [1, total], binary search to find index. The virtual code will include initialization steps: compute prefix sums and total weight. Then pickIndex: generate random integer between 1 and total, binary search over prefix sums to find first index where prefix >= random. Then return that index.\n\nWe need to output step-by-step pseudocode with arrow syntax. Should be multiple lines. Use Start, End, Decision. Provide explanation after each line. Use arrows and indentation.\n\nMake sure to show decision for binary search. Possibly separate lines: Step: initialize array prefix. Step: set total. Step: function pickIndex. Step: generate rand. Step: binary search loop: decision: mid <=? etc.\n\nWe'll produce something like:\n\nStart // Program start\n→ Step 1: Compute prefix sums of w // build cumulative weight array\n→ Step 2: Store total weight = prefix[w.length-1] // total sum\n→ Function: pickIndex // start pickIndex function\n    → Step 3: Generate random integer r between 1 and total // inclusive\n    → Step 4: Set low = 0, high = w.length - 1 // binary search bounds\n    → Decision: While low < high? // binary search loop\n        Yes → Step 5: mid = (low + high) // 2 // middle index\n        → Decision: If prefix[mid] < r? // compare cumulative weight\n            Yes → Step 6: low = mid + 1 // move lower bound\n            No  → Step 7: high = mid // shrink upper bound\n        No  → Step 8: Return low // found index\nEnd // End program\n\nWe need to include explanation comments after each line. Also arrow formatting with indentation. Use `→` before each step. For decisions use `Decision:`. For \"Yes →\" and \"No →\".\n\nMake sure to use indentation properly: maybe 4 spaces before nested lines. Provide explanation after comment.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 prefix[ ] 為 w 的累積和 // 先把各重複的加總存成前綴和  \n→ Step 2: 設定 total = prefix[w.length-1] // 總重複量，作為隨機數上限  \n→ Function: pickIndex // 開始 pickIndex 函式  \n    → Step 3: 產生 r = 隨機整數(1, total) // 取得 [1,total] 之隨機數  \n    → Step 4: low = 0, high = w.length - 1 // 二分搜尋的左右指標  \n    → Decision: while low < high? // 是否還有區間可縮小？  \n        Yes → Step 5: mid = (low + high) // 2 // 計算中間索引  \n        → Decision: prefix[mid] < r? // 前綴和是否小於隨機數？  \n            Yes → Step 6: low = mid + 1 // 前半段全不符合，移到後半段  \n            No  → Step 7: high = mid // 前半段有可能包含答案，縮小上限  \n        No  → Step 8: return low // low 即為符合條件的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Cracking the Safe",
      "source_file": "Leetcode/leetcode753.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '01'\n--- (Raw) ---\nRaw Expected: '\"10\"'\nRaw Got:      '01'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def crackSafe(self, n: int, k: int) -> str:\n        # Special case: n == 1, the shortest sequence is simply all digits\n        if n == 1:\n            return ''.join(str(i) for i in range(k))\n\n        seen = set()\n        res = []\n\n        def dfs(node: str):\n            for d in map(str, range(k)):\n                nxt = node + d\n                if nxt not in seen:\n                    seen.add(nxt)\n                    dfs(nxt[1:])\n                    res.append(d)\n\n        start = '0' * (n - 1)\n        dfs(start)\n        return ''.join(res) + start\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    sol = Solution()\n    answer = sol.crackSafe(n, k)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual algorithm that outputs a string of minimal length that guarantees that the correct password (unknown) appears as a contiguous subsequence of length n in the input sequence of digits 0..k-1. We need to generate a string that contains every possible n-length password as a substring (so that whichever is correct, it will appear). This is De Bruijn sequence problem. We need to produce minimal length = k^n + n -1. The algorithm: build De Bruijn graph of order n over alphabet of size k, find Eulerian circuit, output sequence. Virtual code steps: Start, build graph, find Eulerian circuit using Hierholzer, output first node, then each edge label, etc. Then End. Provide explanation after each line.\n\nWe need to output step-by-step pseudocode with arrow and decision. So structure: Start, Step 1: Build adjacency list for nodes of length n-1, etc. We must use arrow. Let's craft lines.\n\nEnsure we have each line as: `虛擬碼步驟 // 解釋`.\n\nUse Chinese.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 產生所有長度為 n-1 的節點 (所有 (n-1)-長字串) // 建立 De Bruijn 圖的節點  \n→ Step 2: 為每個節點 v 產生 k 條出邊，每條邊標記為 d (0 ≤ d < k)，指向節點 u = (v 的最後 n-2 個字元 + d) // 建立所有可能的遞移  \n→ Decision: 是否所有節點都有出度 k? // 確認圖為正規 De Bruijn 圖  \n  Yes → Step 3: 用 Hierholzer 演算法找到 Euler 循環 // 取得一次完整的 Euler 循環  \n  No  → Step 4: 輸出錯誤訊息並結束 // 若不滿足條件則不可生成序列  \n→ Step 5: 從 Euler 循環取出第一個節點的字串作為起始序列 // 初始 n-1 位數字  \n→ Step 6: 遍歷循環中每條邊，將其標記 d 加到序列尾部 // 形成長度 k^n + n - 1 的序列  \n→ Step 7: 輸出該序列作為最短可能解 // 任何 n 位密碼都將出現在此序列內  \nEnd // 程式執行結束"
    }
  ]
}