{
  "run_index": 8,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 394,
  "generation_or_validation_failure_count": 45,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,3,4,3,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 3, 4, 3, 3]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\n# ----------------------------------------------------\n# 函式：模擬擲 n 次六面骰\n# ----------------------------------------------------\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳結果的串列。\n    :param n: 擲骰次數\n    :return: 由 n 個 1~6 隨機整數所組成的串列\n    \"\"\"\n    results = []                      # 儲存每一次擲骰的結果\n    for _ in range(n):\n        # random.randint(1, 6) 產生 1~6 的隨機整數\n        results.append(random.randint(1, 6))\n    return results\n\n# ----------------------------------------------------\n# 主程式區塊：從 stdin 讀取程式碼並執行\n# ----------------------------------------------------\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入，允許使用者輸入任意 Python 程式碼\n    code = sys.stdin.read()\n\n    # 只將 roll_dice 函式暴露給 exec 的執行環境\n    local_namespace = {\"roll_dice\": roll_dice}\n\n    # 執行使用者輸入的程式碼，任何 print 會直接寫入 stdout\n    exec(code, local_namespace)",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code. Each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use arrows →, Start, End, Decision:. For random module, we need import random, define function roll_dice(n), loop n times generating random int 1-6, append to list, return list.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Import random module // 需要使用隨機數產生器\n→ Step 2: Define function roll_dice(n) // 宣告模擬擲 n 次六面骰的函式\n    → Step 3: Initialise empty list results // 用來儲存每一次擲骰的結果\n    → Step 4: For i from 1 to n // 進行 n 次迴圈\n        → Step 5: Roll a dice using random.randint(1,6) // 產生 1~6 的隨機整數\n        → Step 6: Append the roll to results // 將結果存入列表\n    → Step 7: Return results // 回傳所有擲骰結果的列表\nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\n\ndef measure_time(func, *args):\n    \"\"\"\n    Measure the execution time of a function `func` with arguments `*args`.\n    Uses time.perf_counter() for high‑resolution timing and rounds the\n    elapsed time to 3 decimal places.\n    \"\"\"\n    start = time.perf_counter()\n    func(*args)\n    end = time.perf_counter()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    import sys\n    # 讀取所有輸入，這裡假設輸入的是完整的 Python 程式碼\n    code = sys.stdin.read()\n    # 執行讀入的程式碼，globals() 讓它能使用上面定義的 measure_time\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step with explanation. Must not output actual code. So we need to write steps like Start, Step 1: Import time module, Step 2: Define function measure_time, etc. Use arrows and decisions? Not necessary, but we can show steps. Provide each line: \"虛擬碼步驟 // 解釋\". Use arrows. Should be clear. Use '→' to indicate subsequent steps. We need to show import, definition, record start time, call func, record end time, calculate elapsed, round, return result. Use End. Also maybe input parameters. Use Step numbering or descriptive. Provide explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 引入 Python 標準時間模組  \n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函式，接受任意參數  \n→ Step 3: Record start_time = time.perf_counter() // 取得執行前的高解析度時間點  \n→ Step 4: Execute result = func(*args) // 呼叫目標函式並傳遞所有參數  \n→ Step 5: Record end_time = time.perf_counter() // 取得執行後的時間點  \n→ Step 6: Calculate elapsed = end_time - start_time // 兩個時間點相減得到秒數  \n→ Step 7: Round rounded_elapsed = round(elapsed, 3) // 四捨五入到小數點第三位  \n→ Step 8: Return rounded_elapsed // 回傳已四捨五入的秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"melon\",\"orange\",\"apple\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'melon', 'orange', 'apple', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取所有輸入（即使本題不需要），以符合「不要硬編碼」的規範\n    _ = sys.stdin.read()\n\n    # 建立集合\n    fruits = {'apple', 'banana'}\n\n    # 新增單一元素\n    fruits.add('orange')\n\n    # 一次新增多個元素\n    fruits.update(['grape', 'melon'])\n\n    # 移除已存在的元素\n    fruits.remove('banana')\n\n    # 嘗試移除不存在的元素，會被忽略\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce line by line virtual code following format. Use arrows. No actual code. Just virtual steps. Use Start, End, Decision if needed. For operations: add, update, remove, discard. Show collection initialization. Use comments after each line. Probably need to mention set literal. Provide explanation.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 創建集合 fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 使用 add() 新增元素\n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 一次新增多個元素\n→ Step 4: fruits.remove('banana') // 使用 remove() 移除元素，若不存在會錯誤\n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在元素，無錯誤\n→ Step 6: 輸出 fruits // 顯示最終集合內容\nEnd // 程式執行結束\n\nBut we must maintain format: each line \"虛擬碼步驟 [space] // 解釋\". Use arrow arrow. In example they used \"→ Step 1: ...\" We should follow. Provide \"Step\" maybe. Provide \"Decision\" if needed. But not needed. Also may use \"Decision\" for remove if element may not exist. But we can skip.\n\nWe should include \"Start\" line, then each step with arrow, then \"End\". Use Chinese explanations.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 創建集合 fruits = {'apple', 'banana'} // 初始化集合並加入兩個元素  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange' 到集合  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'，若不存在會拋錯誤  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'，不會產生錯誤  \n→ Step 6: 輸出 fruits // 顯示集合的最終內容  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate():\n    \"\"\"\n    從 exchangerate-api 取得 USD 對 TWD 的匯率。\n    返回匯率數值（float）或 None 表示失敗。\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    try:\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()\n        data = r.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\ndef main():\n    \"\"\"\n    主程式：先從標準輸入讀取指令，\n    若指令包含「更新匯率」，則呼叫 fetch_rate()\n    並將結果列印到標準輸出。\n    接著啟動 tkinter GUI，提供「更新匯率」按鈕\n    讓使用者可以在視窗中再次查詢。\n    \"\"\"\n    # 讀取 stdin（如果有輸入）\n    input_line = sys.stdin.readline().strip()\n\n    # 如果輸入包含「更新匯率」，則立即取得並輸出匯率\n    if \"更新匯率\" in input_line:\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n\n    # --------- tkinter GUI ----------\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update_label():\n        \"\"\"\n        按鈕觸發函式：取得最新匯率並更新標籤文字。\n        \"\"\"\n        rate = fetch_rate()\n        if rate is not None:\n            label.config(text=f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n\n    tk.Button(win, text=\"更新匯率\", command=update_label).pack(pady=5)\n\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. No actual code, just pseudocode lines with comments. Use Start, End, Decision, etc. Must include each line as \"虛擬碼步驟 // 解釋\". Provide each step. Use arrow characters. Let's outline: Start, import modules, define function fetch_rate, use requests.get, parse JSON, get TWD. Then Tkinter GUI: create root, label, button. Button command: call fetch_rate and update label. mainloop. End.\n\nNeed to maintain structure and arrow directions. Use \"→\" to denote progression. For decision branches? We may have simple error handling: if request fails, show error. So Decision: if response.status ok? Yes, update label. No, show error. So include that.\n\nLet's write. Ensure each line ends with // explanation. Use \"Start // 程式開始執行\". Then \"→ Step 1: Import requests and tkinter // 取得需要的模組\". Then \"→ Step 2: 定義函式 fetch_rate() // 用於取得匯率\". Inside fetch_rate: \"→ Step 2.1: 送出 GET 請求到 https://api.exchangerate-api.com/v4/latest/USD // 取得匯率資料\". \"→ Step 2.2: Decision: 如果回應成功? // 檢查 HTTP 狀態碼\". Then Yes and No branches.\n\nWe'll do: Yes → Step 2.3: 解析 JSON // 取出 data['rates']['TWD'] // 取得 TWD 匯率. No → Step 2.4: 返回 None // 表示失敗.\n\nReturn rate.\n\nThen GUI steps: Step 3: Create root window. Step 4: Create label to show rate. Step 5: Create button labeled \"更新匯率\" with command update_rate. Step 6: 定義 update_rate() // 取得匯率並更新 label. Inside: \"→ Step 6.1: rate = fetch_rate()\". \"→ Step 6.2: Decision: 如果 rate 不是 None? // 檢查是否成功\". Yes → Step 6.3: Update label text to f\"USD/TWD: {rate}\". No → Step 6.4: Update label text to \"取得匯率失敗\". End.\n\nThen Step 7: 呼叫 root.mainloop().\n\nEnd.\n\nMake sure to include \"End // 程式執行結束\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests and tkinter // 取得需要的模組  \n→ Step 2: 定義函式 fetch_rate() // 用於取得匯率  \n  → Step 2.1: 送出 GET 請求到 https://api.exchangerate-api.com/v4/latest/USD // 取得匯率資料  \n  → Step 2.2: Decision: 如果回應成功? // 檢查 HTTP 狀態碼  \n    Yes → Step 2.3: 解析 JSON // 取出 data['rates']['TWD'] // 取得 TWD 匯率  \n     → Step 2.3.1: 回傳 rate // 返回匯率值  \n    No  → Step 2.4: 回傳 None // 表示取得失敗  \n→ Step 3: 創建 Tkinter 根視窗 root // 初始化 GUI 視窗  \n→ Step 4: 建立 label 用於顯示匯率 // 初始文字可為空  \n  → Step 4.1: Label = tkinter.Label(root, text=\"\")  \n→ Step 5: 建立按鈕 \"更新匯率\" 並指定 command = update_rate // 觸發匯率更新  \n  → Step 5.1: Button = tkinter.Button(root, text=\"更新匯率\", command=update_rate)  \n→ Step 6: 定義函式 update_rate() // 取得並更新匯率顯示  \n  → Step 6.1: rate = fetch_rate() // 取得最新匯率  \n  → Step 6.2: Decision: 如果 rate 不是 None? // 檢查是否成功  \n    Yes → Step 6.3: 更新 label 文本為 f\"USD/TWD: {rate}\" // 顯示匯率  \n    No  → Step 6.4: 更新 label 文本為 \"取得匯率失敗\" // 顯示錯誤訊息  \n→ Step 7: 佈局並顯示 widget // 放置 label 與按鈕並顯示視窗  \n  → Step 7.1: Label.pack()  \n  → Step 7.2: Button.pack()  \n→ Step 8: 呼叫 root.mainloop() // 開始事件循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Top K Frequent Elements",
      "source_file": "Leetcode/leetcode347.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqr0t1j1j.py\", line 40, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqr0t1j1j.py\", line 30, in parse_input\n    nums = ast.literal_eval(part.split('=', 1)[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,1,2,1,2,3,1,3,2], k = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp13gi1zur.py\", line 40, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp13gi1zur.py\", line 30, in parse_input\n    nums = ast.literal_eval(part.split('=', 1)[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\nimport heapq\n\nclass Solution:\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        Return the k most frequent elements in nums.\n        Uses a min-heap to keep track of the top k elements.\n        \"\"\"\n        # Count frequency of each number\n        freq = Counter(nums)\n        # Retrieve k items with largest frequency\n        top_k = heapq.nlargest(k, freq.items(), key=lambda x: x[1])\n        # Extract just the numbers\n        return [item for item, _ in top_k]\n\ndef parse_input(input_str):\n    \"\"\"\n    Parse input string of the form:\n    'nums = [...], k = ...'\n    and return the corresponding nums list and k integer.\n    \"\"\"\n    parts = [p.strip() for p in input_str.split(',') if p.strip()]\n    nums = None\n    k = None\n    for part in parts:\n        if part.startswith('nums'):\n            nums = ast.literal_eval(part.split('=', 1)[1].strip())\n        elif part.startswith('k'):\n            k = int(part.split('=', 1)[1].strip())\n    if nums is None or k is None:\n        raise ValueError(\"Input must contain both 'nums' and 'k'\")\n    return nums, k\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    solution = Solution()\n    result = solution.topKFrequent(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with each line like \"Start // 程式開始執行\" etc. We need to generate algorithm steps for solving the problem: return k most frequent elements from array. Use frequency map, maybe min-heap or sort. Provide steps. Each line: virtual code step + space + // explanation.\n\nUse arrows: \"→\", \"Yes →\", \"No →\". Use Start and End.\n\nWe need to produce step-by-step algorithm. Use virtual code not actual code. Provide decision points etc.\n\nLet's design:\n\nStart\n→ Step 1: 建立頻率雜湊表 // Count frequency of each number\n→ Step 2: 建立一個空的最小堆（容量為 k） // min-heap to keep top k\n→ Decision: 遍歷頻率表每個 (number, freq) // iterate over map\n    → Step 3: 若堆大小 < k，將 (freq, number) 推入堆 // add if not full\n    → Decision: 否則 // if heap full\n        → Step 4: 若 freq > 堆頂頻率，將堆頂彈出，並將 (freq, number) 推入堆 // replace lower freq\n→ Step 5: 建立結果清單 // extract numbers from heap\n→ Decision: 是否需要逆序 // maybe output any order, just output\n    → Step 6: 返回結果 // return list\nEnd\n\nBut need more detailed steps with decisions. Use \"Decision:\" lines with Yes/No arrow.\n\nLet's produce final answer.\n\nAlso include maybe \"Step X: ...\" but format: \"Step X:\".\n\nOk. Provide each line. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空的頻率雜湊表 // 用於統計每個數字出現的次數  \n→ Step 2: 遍歷輸入陣列 nums，對每個數字更新頻率表 // 形成 num → 次數 的對應  \n→ Step 3: 建立一個容量為 k 的最小堆 // 用於儲存目前頻率最高的 k 個數字  \n→ Decision: 遍歷頻率雜湊表中的每個 (number, freq) // 逐個處理頻率資料  \n    → Step 4: 若 堆 的大小 < k，將 (freq, number) 推入堆 // 堆還沒滿時直接加入  \n    → Decision: 否則 // 堆已滿時需要比較  \n        → Step 5: 若 freq > 堆頂的頻率，彈出堆頂並將 (freq, number) 推入堆 // 用更高頻率替換低頻  \n→ Step 6: 建立一個空的結果清單 // 用於儲存最終的 k 個最頻繁數字  \n→ Step 7: 從堆中彈出所有元素，將其 number 加入結果清單 // 堆中即為所需的 k 個數字  \n→ Step 8: 返回結果清單 // 結果順序不重要，直接輸出即可  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        # val -> index mapping\n        self.val_to_index = {}\n        # list of values\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        # Move last element into the spot of the removed element\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        # Remove last element\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.values)\n\ndef main():\n    # Read entire input and join lines to handle both single-line and multi-line inputs\n    raw = sys.stdin.read().strip().replace('\\n', ', ')\n    # Wrap the string into a tuple for safe literal evaluation\n    try:\n        ops, args = ast.literal_eval('(' + raw + ')')\n    except Exception as e:\n        # If parsing fails, exit silently\n        return\n\n    obj = RandomizedSet()\n    results = [None]  # Constructor returns null\n\n    for op, arg in zip(ops[1:], args[1:]):\n        if op == 'insert':\n            res = obj.insert(arg[0])\n        elif op == 'remove':\n            res = obj.remove(arg[0])\n        elif op == 'getRandom':\n            res = obj.getRandom()\n        else:\n            res = None\n        results.append(res)\n\n    # Convert results to LeetCode style output\n    formatted = []\n    for r in results:\n        if r is None:\n            formatted.append('null')\n        elif isinstance(r, bool):\n            formatted.append('true' if r else 'false')\n        else:\n            formatted.append(str(r))\n    print('[' + ', '.join(formatted) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for implementing RandomizedSet class with insert, remove, getRandom in average O(1). The output should be line-by-line virtual code with explanation. Use arrows, Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to represent algorithm: use hashmap val->index and array list of values. Insert: if val exists return false else push to array and record index. Remove: if val not exist return false else swap with last element in array, update hashmap, pop last, delete entry. getRandom: pick random index from array length.\n\nWe'll produce virtual code lines. Ensure each line includes arrow → and explanation. Use Decision: for insert existence check, remove existence check. Also need random selection.\n\nLet's craft:\n\nStart\n→ Initialize data structures: hashMap, arrayList // 建立兩個資料結構\n→ Function: RandomizedSet() // 建構子\n    → Set hashMap to empty\n    → Set arrayList to empty\n→ Function: insert(val) // 插入值\n    → Decision: If val exists in hashMap? // 檢查值是否已存在\n        Yes → Return false // 已存在，插入失敗\n        No  → Append val to arrayList // 新增值\n        → Record hashMap[val] = index of val in arrayList // 記錄索引\n        → Return true // 插入成功\n→ Function: remove(val) // 刪除值\n    → Decision: If val exists in hashMap? // 檢查是否存在\n        Yes →\n            → Get index of val from hashMap\n            → Get last element in arrayList\n            → Replace arrayList[index] with last element // 交換位置\n            → Update hashMap[last element] = index // 更新索引\n            → Remove last element from arrayList // 刪除最後一項\n            → Delete hashMap[val] // 刪除鍵值對\n            → Return true // 刪除成功\n        No  → Return false // 不存在，刪除失敗\n→ Function: getRandom() // 取得隨機值\n    → Generate random index between 0 and arrayList.size-1\n    → Return arrayList[random index] // 回傳隨機元素\nEnd\n\nWe need to format with arrows and comments. Each line includes a virtual code step and comment. Use \"→\" for continuation, \"Decision:\" for decision points. Provide each line separately.\n\nMake sure each line is separate. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize data structures: hashMap, arrayList // 建立兩個資料結構以支援 O(1) 操作  \n→ Function: RandomizedSet() // 建構子  \n  → Set hashMap to empty // 初始化哈希表  \n  → Set arrayList to empty // 初始化陣列  \n→ Function: insert(val) // 插入值  \n  → Decision: 如果 val 已存在於 hashMap? // 檢查值是否已存在  \n    Yes → Return false // 已存在，插入失敗  \n    No  → Append val to arrayList // 將新值加入陣列  \n      → Record hashMap[val] = index of val in arrayList // 記錄新值的索引  \n      → Return true // 插入成功  \n→ Function: remove(val) // 刪除值  \n  → Decision: 如果 val 存在於 hashMap? // 檢查值是否存在  \n    Yes →  \n      → Get index of val from hashMap // 取得欲刪除值的索引  \n      → Get last element in arrayList // 取得陣列最後一項  \n      → Replace arrayList[index] with last element // 交換位置以維持陣列連續  \n      → Update hashMap[last element] = index // 更新被交換元素的索引  \n      → Remove last element from arrayList // 刪除陣列最後一項  \n      → Delete hashMap[val] // 刪除哈希表中的鍵值對  \n      → Return true // 刪除成功  \n    No  → Return false // 不存在，刪除失敗  \n→ Function: getRandom() // 取得隨機值  \n  → Generate random index between 0 and arrayList.size-1 // 隨機選擇索引  \n  → Return arrayList[random index] // 回傳隨機元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[1,0],[2,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [1, 0], [2, 0], null, [2, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n_rows, n_cols):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找到方法列表與參數列表的分隔點\n    try:\n        sep_idx = data.index('],')\n        method_part = data[:sep_idx + 1]\n        args_part = data[sep_idx + 2:]\n        method_list = ast.literal_eval(method_part)\n        args_list = ast.literal_eval(args_part.strip())\n    except ValueError:\n        # 若格式不符合預期，直接解析為元組\n        method_list, args_list = ast.literal_eval('(' + data + ')')\n\n    result = []\n    obj = None\n    for cmd, args in zip(method_list, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            result.append(None)\n        elif cmd == \"flip\":\n            result.append(obj.flip())\n        elif cmd == \"reset\":\n            obj.reset()\n            result.append(None)\n        else:\n            # 忽略未知方法\n            pass\n\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm. We must not output actual code. Provide steps like Start, Decision, etc. Should include minimal calls to random. We can use reservoir? But known solution: use mapping from index to value. Approach: treat grid flattened to array of size m*n. Maintain count of remaining zeros. Randomly choose a number r in [0, remaining-1]. Map r to actual index via dictionary mapping: if r in map, actual = map[r]; else actual = r. Similarly for last = remaining-1; map[r] = last if last in map else last. Then decrement remaining. Convert actual to (i,j). This uses 1 random per flip. Reset just clear map and remaining.\n\nWe'll produce virtual steps: initialization sets total = m*n, remaining = total, map empty. flip: Decision: remaining > 0? else error. Step: randomIndex ← random(0, remaining-1). Step: actual ← if map contains randomIndex then map[randomIndex] else randomIndex. Step: last ← remaining-1. Step: map[randomIndex] ← if map contains last then map[last] else last. Step: decrement remaining. Step: compute i = actual / n, j = actual mod n. Return [i,j]. reset: clear map, remaining = total.\n\nWe should provide explanation lines.\n\nLet's format each line like:\n\nStart // 程式開始執行\n→ Step 1: Set total ← m * n // 計算矩陣大小\n→ Step 2: Set remaining ← total // 初始還有 total 個 0\n→ Step 3: Initialize map ← empty // 位置映射表\n…\n\nBut we need to produce the entire virtual algorithm including class methods.\n\nProbably produce structure:\n\nStart\n→ Step 1: Initialize class with m,n\n    → Step 1.1: Set total ← m * n\n    → Step 1.2: Set remaining ← total\n    → Step 1.3: Initialize map ← empty\n→ End\n\n→ Method flip\n    → Decision: If remaining == 0? // 檢查是否已無空位\n        No → ... // 執行隨機選取\n        Yes → Throw error or return none\n    → Step 2: randIdx ← random(0, remaining-1) // 一次隨機\n    → Step 3: actual ← map.get(randIdx, randIdx) // 若映射存在則取映射值\n    → Step 4: last ← remaining-1\n    → Step 5: map[randIdx] ← map.get(last, last) // 把最後一個位置映射到 randIdx\n    → Step 6: remaining ← remaining-1\n    → Step 7: i ← actual / n\n    → Step 8: j ← actual % n\n    → Return [i,j]\n→ End\n\n→ Method reset\n    → Step 1: map.clear()\n    → Step 2: remaining ← total\n→ End\n\nEnd // 程式結束\n\nAlso we need to ensure each line has explanation comment.\n\nWe should include arrows for decisions. Use Yes → No → formatting as specified.\n\nWe should also mention time complexity: O(1) per flip and reset O(1) space except map. But we will not output analysis.\n\nBut we need to output virtual code with explanations. Let's produce.\n\nLet's format with indentation for decisions maybe.\n\nEnsure each line ends with comment. Let's output in code block? Not required but we can show.\n\nWe'll produce lines sequentially, using arrow notation.\n\nOk.\n...done thinking.\n\n```\nStart // 程式開始執行\n\n→ Step 1: Set total ← m * n // 計算矩陣的總格數\n→ Step 2: Set remaining ← total // 初始還有 total 個 0\n→ Step 3: Initialize map ← empty // 用於映射已選位置到最後可用位置\n\nEnd // 初始化結束\n\n// ──────────────────────────────────────────────────────\n//  flip() 方法\n// ──────────────────────────────────────────────────────\nStart // flip() 方法開始\n\n→ Decision: 如果 remaining == 0? // 檢查是否已無空位\n    Yes → Throw error // 所有位置已被翻轉，無法再選\n    No  → // 繼續執行隨機選取\n\n→ Step 4: randIdx ← random(0, remaining-1) // 隨機產生 0~remaining-1\n→ Step 5: actual ← map.get(randIdx, randIdx) // 若映射存在則取映射值，否則取 randIdx 本身\n→ Step 6: last ← remaining - 1 // 最後一個可用位置的索引\n→ Step 7: map[randIdx] ← map.get(last, last) // 把最後一個位置映射到 randIdx\n→ Step 8: remaining ← remaining - 1 // 減少剩餘 0 的數量\n\n→ Step 9: i ← actual / n // 計算行號\n→ Step 10: j ← actual % n // 計算列號\n→ Step 11: Return [i, j] // 回傳被翻轉的索引\n\nEnd // flip() 方法結束\n\n// ──────────────────────────────────────────────────────\n//  reset() 方法\n// ──────────────────────────────────────────────────────\nStart // reset() 方法開始\n\n→ Step 12: map.clear() // 清空映射表\n→ Step 13: remaining ← total // 重設剩餘 0 的數量\n\nEnd // reset() 方法結束\n\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5ims6gac.py\", line 51, in <module>\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5ims6gac.py\", line 19, in __init__\n    self.lookup[(prefix, suffix)] = weight\n    ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom typing import List, Tuple\n\nclass WordFilter:\n    def __init__(self, words: List[str]):\n        \"\"\"\n        建構時為每個單詞建立所有可能的前綴與後綴組合，並記錄對應的權重（索引）。\n        權重越大代表字典中位置越靠後，符合題目「取最大索引」的需求。\n        \"\"\"\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):            # i 為前綴長度\n                for j in range(L + 1):        # j 為後綴長度\n                    prefix = word[:i]\n                    suffix = word[j:]\n                    # 只保留最大的權重（索引）\n                    self.lookup[(prefix, suffix)] = weight\n\n    def f(self, prefix: str, suffix: str) -> int:\n        \"\"\"\n        回傳同時以給定前綴與後綴開頭與結尾的單詞最大索引。\n        若不存在符合條件的單詞，回傳 -1。\n        \"\"\"\n        return self.lookup.get((prefix, suffix), -1)\n\nif __name__ == \"__main__\":\n    \"\"\"\n    主程式：從標準輸入讀取資料，格式為：\n        words_list, [prefix, suffix]\n    例如：['apple', 'app'], ['ap', 'le']\n    讀取後建立 WordFilter 物件並輸出 f(prefix, suffix) 的結果。\n    \"\"\"\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        sys.exit()\n\n    # 將整個輸入包裹成外層陣列，方便使用 json.loads\n    try:\n        data = json.loads('[' + data_str + ']')\n    except json.JSONDecodeError as e:\n        # 若格式不符合，直接終止\n        print(-1)\n        sys.exit()\n\n    words = data[0]              # 取得單詞列表\n    query = data[1]              # 取得 [prefix, suffix] 列表\n    prefix, suffix = query[0], query[1]\n\n    wf = WordFilter(words)\n    result = wf.f(prefix, suffix)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The algorithm: We need WordFilter class with constructor and f method. Need to handle prefix and suffix search, return largest index.\n\nWe can implement using Trie with combined prefix and suffix maybe. Simpler: use two Tries: prefix trie and suffix trie. For each word, insert all prefixes and suffixes with index. Then f: traverse prefix trie for pref, get set of indices; traverse suffix trie for suff reversed, get set. Intersect and get max. But we need efficient: we can store for each node the list of indices sorted descending.\n\nSimpler: use a hashmap mapping prefix+suffix to max index; but that would be huge. Alternative: Use trie that stores for each prefix node a map of suffixes to max index.\n\nBut we just need virtual code.\n\nWe'll design as:\n\n- Build a prefix trie where each node has a map suffixTrie root? Actually we can store in each node a list of indices of words that share that prefix. Then in f, we get list from prefix node, iterate to find word that also has suff. We can pre-process suffix trie or for each word we check.\n\nBut we can implement: store words array. In f, iterate words list from last to first, check if startswith and endswith. That's O(n) per query, but okay.\n\nBut produce virtual code accordingly.\n\nWe'll implement WordFilter with words array, and f uses loop. Provide virtual code with Start, etc.\n\nOk.\n\nLet's produce virtual code:\n\nStart\n→ Step 1: WordFilter(words) // 初始化字典\n→ Decision: 何時完成建構? // 建構完成\nEnd\n\nFor f:\n\n→ Step 1: Define f(pref, suff)\n→ Decision: 遍歷 words 從最後到第一? // 逆序尋找最大索引\n→ Loop: for i from len(words)-1 down to 0\n    → Decision: words[i] 是否以 pref 開頭? // 檢查前綴\n        Yes →\n            → Decision: words[i] 是否以 suff 結尾? // 檢查後綴\n                Yes → Step: Return i // 找到最大索引\n                No  → Next loop iteration\n        No  → Next loop iteration\n→ Step: Return -1 // 未找到\n\nBut need to show virtual code lines each with explanation.\n\nWe'll produce.\n\nAlso include maybe \"End\" of f.\n\nLet's craft.\n\nUse arrows.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: WordFilter(words) // 初始化物件，保存原始字串陣列\n→ End // 物件建構完成\n\nNow f method:\n\n→ Step 1: f(pref, suff) // 方法入口\n→ Step 2: n = len(words) // 取得字典長度\n→ Decision: 先從最後一個索引開始遍歷? // 逆序遍歷以取得最大的索引\n    → Loop: i = n-1 到 0\n        → Decision: words[i] 是否以 pref 開頭? // 前綴檢查\n            Yes →\n                → Decision: words[i] 是否以 suff 結尾? // 後綴檢查\n                    Yes → Step: Return i // 找到符合條件的最大索引\n                    No  → Step: Continue // 不是後綴，繼續下一個\n            No  → Step: Continue // 不是前綴，繼續下一個\n→ Step: Return -1 // 所有字串都不符合條件\n\nAdd End for f.\n\nBut we need to use arrows \"→\" each line.\n\nAlso we can indent for decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ WordFilter(words) // 建構函式：將使用者提供的字串陣列存入物件  \nEnd // 物件建構完成  \n\n→ f(pref, suff) // 方法入口：接收前綴 pref 與後綴 suff  \n→ n = len(words) // 取得字典長度  \n→ Decision: 逆序遍歷字典以找尋最大的索引? // 這樣可以在第一次符合時直接回傳  \n    → Loop: i = n-1 到 0  \n        → Decision: words[i] 以 pref 開頭? // 檢查前綴  \n            Yes →  \n                → Decision: words[i] 以 suff 結尾? // 檢查後綴  \n                    Yes → Return i // 找到符合條件的最大索引，結束搜尋  \n                    No  → Continue // 不是後綴，進行下一個迴圈  \n            No  → Continue // 不是前綴，進行下一個迴圈  \n→ Return -1 // 所有字串皆不符合條件，返回 -1  \nEnd // 方法結束執行"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()()\", \"(a())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\nclass Solution:\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        Return all possible strings after removing the minimum number of invalid parentheses.\n        Uses BFS level by level to ensure minimal removals.\n        \"\"\"\n        res = set()\n        # Check if a string is valid\n        def is_valid(st):\n            count = 0\n            for ch in st:\n                if ch == '(':\n                    count += 1\n                elif ch == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        # BFS: start from the original string\n        level = {s}\n        while level:\n            # 找到本層中所有有效的字串\n            valid = [item for item in level if is_valid(item)]\n            if valid:\n                return valid\n            # 若本層沒有有效字串，產生下一層\n            next_level = set()\n            for item in level:\n                for i in range(len(item)):\n                    if item[i] in ('(', ')'):\n                        next_item = item[:i] + item[i+1:]\n                        next_level.add(next_item)\n            level = next_level\n        return []\n\ndef parse_input(text):\n    \"\"\"\n    從標準輸入取得字串 s。假設輸入形如：s = \"()())()\"\n    \"\"\"\n    # 先尋找第一個雙引號\n    m = re.search(r'\\\"(.*?)\\\"', text)\n    if m:\n        return m.group(1)\n    # 若找不到雙引號，直接回傳整段文字（去除首尾空白）\n    return text.strip()\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit(0)\n    s = parse_input(raw_input)\n    solution = Solution()\n    output = solution.removeInvalidParentheses(s)\n    # 轉成 JSON 格式，確保輸出為雙引號字串\n    print(json.dumps(output))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, no real code. The problem: remove minimum number of invalid parentheses to make string valid, return list of unique strings. It's typical BFS or DFS with pruning. Provide steps.\n\nWe output lines starting with Start, steps, decisions, etc. Need to include arrow indicators.\n\nWe'll produce steps:\n\nStart\n→ Step 1: Compute counts of parentheses to remove\n→ Step 2: Define recursive DFS function\n→ Decision: Should we prune? etc\n\nBut we need to be line-by-line. Provide unique steps, no actual code.\n\nLet's outline:\n\nStart\n→ Step 1: 初始化 removeLeft = 0, removeRight = 0 // count invalid parentheses to remove\n→ Decision: 如果 s 中 '(' > ')'? ...\nActually count needed: For each char: if '(' count++ else if ')' and count>0 then count-- else removeRight++.\n\nWe'll produce steps accordingly.\n\nThen Step 2: 定義 DFS(currentIndex, currentString, removeL, removeR, balance, resultSet)\n\nWe'll outline decisions inside DFS: if removeL==0 and removeR==0, then check balance. If balance==0, add to set.\n\nThen iterate over characters, choose to keep or remove.\n\nUse decision arrows.\n\nFinally convert set to list, return.\n\nWe'll output steps line by line.\n\nEnsure each line includes code step and explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算需刪除的左括號數量 removeLeft 與右括號數量 removeRight // 先統計最少要刪除多少個括號  \n→ Decision: 遍歷 s  \n  Yes → Step 2a: 若字符為 '(' → removeLeft++ // 左括號累加  \n  Yes → Step 2b: 若字符為 ')'  \n    Yes → Step 2b1: 若 removeLeft > 0 → removeLeft-- // 與已存在的左括號配對，減少需要刪除的左括號  \n    No  → Step 2b2: removeRight++ // 右括號無法配對，須刪除  \n→ Step 3: 建立空集合 resultSet 以存儲唯一有效字串 // 避免重複結果  \n→ Step 4: 定義遞迴函式 DFS(index, path, remL, remR, bal) // index: 當前處理位置，path: 當前已組成字串，remL/remR: 剩餘可刪除數量，bal: 左右括號平衡計數  \n  Decision: 若 index == len(s)  \n    Yes → Step 5a: 若 bal == 0 → resultSet.add(path) // 完整遍歷且平衡，加入結果集  \n    No  → Step 6: 返回 // 未達結束，返回遞迴  \n  Decision: 取字符 c = s[index]  \n  Decision: 若 c 為 '('  \n    Yes → Decision: 可選刪除  \n      Yes → Step 5b: 若 remL > 0 → DFS(index+1, path, remL-1, remR, bal) // 刪除左括號  \n      No  → Step 5c: DFS(index+1, path+'(', remL, remR, bal+1) // 保留左括號並增加平衡  \n  Decision: 若 c 為 ')'  \n    Yes → Decision: 可選刪除  \n      Yes → Step 5d: 若 remR > 0 → DFS(index+1, path, remL, remR-1, bal) // 刪除右括號  \n      No  → Step 5e: 若 bal > 0 → DFS(index+1, path+')', remL, remR, bal-1) // 保留右括號並減少平衡  \n  Decision: 若 c 為其他字元  \n    Yes → Step 5f: DFS(index+1, path+c, remL, remR, bal) // 字母始終保留  \n→ Step 7: 呼叫 DFS(0, \"\", removeLeft, removeRight, 0) // 開始遞迴  \n→ Step 8: 轉換 resultSet 為列表 outputList // 以列表形式返回  \n→ End // 程式執行結束"
    },
    {
      "title": "leetcode846_problem_1",
      "source_file": "Leetcode/leetcode846.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
          "expected_output": "True",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplw7oem1a.py\", line 37, in <module>\n    main()\n  File \"/tmp/tmplw7oem1a.py\", line 30, in main\n    exec(data, {}, local_vars)  # 執行輸入字串，產生 hand 與 groupSize\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    hand = [1,2,3,6,2,3,4,7,8], groupSize = 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "hand = [1,2,3,4,5], groupSize = 4",
          "expected_output": "False",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgtuly64p.py\", line 37, in <module>\n    main()\n  File \"/tmp/tmpgtuly64p.py\", line 30, in main\n    exec(data, {}, local_vars)  # 執行輸入字串，產生 hand 與 groupSize\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    hand = [1,2,3,4,5], groupSize = 4\n    ^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def isNStraightHand(self, hand, groupSize):\n        \"\"\"\n        判斷能否將手牌重新排列成大小為 groupSize 的連續牌組。\n        \"\"\"\n        if len(hand) % groupSize != 0:\n            return False\n\n        count = Counter(hand)\n        for card in sorted(count):\n            freq = count[card]\n            if freq > 0:\n                for val in range(card, card + groupSize):\n                    if count[val] < freq:\n                        return False\n                    count[val] -= freq\n        return True\n\ndef main():\n    \"\"\"\n    讀取標準輸入，執行判斷並輸出結果。\n    輸入格式示例：\n        hand = [1,2,3,6,2,3,4,7,8], groupSize = 3\n    \"\"\"\n    data = sys.stdin.read()\n    local_vars = {}\n    exec(data, {}, local_vars)  # 執行輸入字串，產生 hand 與 groupSize\n    hand = local_vars['hand']\n    groupSize = local_vars['groupSize']\n    result = Solution().isNStraightHand(hand, groupSize)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code that implements logic: given hand array and groupSize, check if can group into groups of consecutive values of size groupSize. Classic Leetcode 846. Approach: count frequencies, then sort keys, iterate over sorted keys, for each value if count>0, try to subtract counts for consecutive values. Complexity O(n log n). We'll produce virtual code step by step with explanations.\n\nNeed to output each line as \"虛擬碼步驟 // 解釋/說明\".\n\nWe should use Start, End, Decision, etc.\n\nLet's produce something like:\n\nStart\n→ Step 1: If groupSize is zero → Return false? Actually groupSize <= 0 invalid. But we might skip.\n\n→ Step 2: Calculate total cards length = len(hand). // Get number of cards\n→ Decision: If total cards % groupSize != 0? // Check if divisible\n    Yes → Return false // cannot form groups\n\n→ Step 3: Build frequency map freq from hand // count each card value\n→ Step 4: Get sorted unique values sortedKeys = sorted keys of freq // order ascending\n\n→ Decision: For each value in sortedKeys\n   Yes → If freq[value] == 0 → continue // already used\n   No → // need to try forming group starting from this value\n     → Step 5: For i from 0 to groupSize-1\n         current = value + i\n         → Decision: If freq[current] < freq[value]? // not enough consecutive cards\n              Yes → Return false\n              No  → Continue\n         → Step 6: Subtract freq[current] by freq[value] // remove used cards\n     → End For\n   → End Decision\n\n→ Step 7: Return true // all groups formed\n\nBut we need to adhere to format: each line with \"虛擬碼步驟\" and comment. Use arrows. Provide each line separately. Must include Start and End. Use Decision: for conditions. Indentation maybe.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: total ← length(hand) // 取得卡牌總數\n→ Decision: if total mod groupSize ≠ 0? // 確認可否整除\n    Yes → Return false // 若不能整除，無法分組\n    No  → Continue // 可嘗試分組\n→ Step 2: freq ← {} // 建立頻率字典\n→ Step 3: For each card in hand\n    → freq[card] ← freq.get(card, 0) + 1 // 统计每个卡牌出现次数\n→ Step 4: keys ← sorted(freq.keys()) // 取得按升序排列的卡牌值\n→ Decision: for each start in keys\n    → Decision: if freq[start] == 0? // 已经被完全使用\n        Yes → Continue // 跳过\n        No  → // 需要以此值为起点构建一组\n          → Step 5: groupCount ← freq[start] // 该起点需要消耗的卡牌数\n          → Step 6: For i from 0 to groupSize-1\n                → current ← start + i // 计算连续值\n                → Decision: if freq.get(current, 0) < groupCount? // 检查是否足够\n                    Yes → Return false // 缺少必要卡牌\n                    No  → Continue // 继续检查下一个连续值\n                → Step 7: freq[current] ← freq[current] - groupCount // 消耗卡牌\n          → End For\n    → End Decision\n→ Step 8: Return true // 所有卡牌均已成功分组\nEnd // 程式執行結束\n\nWe need to ensure formatting: each line \"虛擬碼步驟\" + space + \"// 解釋\". Also use Decision: properly.\n\nMake sure each line uses arrows and proper indentation with tab? Provide indentation via spaces? In example, indentation used two spaces before nested lines. We'll mimic.\n\nThus produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: total ← length(hand) // 取得卡牌總數\n→ Decision: 如果 total mod groupSize ≠ 0? // 確認總數能否被 groupSize 整除\n    Yes → Return false // 若不能整除，無法分組\n    No  → // 繼續進行分組判斷\n→ Step 2: freq ← {} // 建立空的頻率字典\n→ Step 3: For 每張卡牌 card in hand\n    → freq[card] ← freq.get(card, 0) + 1 // 計算每個卡牌值的出現次數\n→ Step 4: keys ← sorted(freq.keys()) // 取得按升序排列的所有卡牌值\n→ Decision: For 每個起點 start in keys\n    → Decision: 如果 freq[start] == 0? // 這個值已被完全使用\n        Yes → // 跳過已用完的值\n        No  → // 以此值為起點嘗試構造一組\n          → Step 5: groupCount ← freq[start] // 需要消耗的卡牌數量\n          → Step 6: For i 從 0 到 groupSize-1\n                → current ← start + i // 計算需要的連續值\n                → Decision: 如果 freq.get(current, 0) < groupCount? // 連續值不足\n                    Yes → Return false // 缺少必要卡牌，直接失敗\n                    No  → // 連續值足夠，繼續檢查下一個\n                → Step 7: freq[current] ← freq[current] - groupCount // 消耗該連續值的卡牌\n          → End For\n    → End Decision\n→ Step 8: Return true // 所有卡牌均已成功分組\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Solve the Equation",
      "source_file": "Leetcode/leetcode640.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equation = \"x+5-3+x=6+x-2\"",
          "expected_output": "x=2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'x=2'\nGot (Norm):      'x=-2'\n--- (Raw) ---\nRaw Expected: 'x=2'\nRaw Got:      'x=-2'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def solveEquation(self, equation: str) -> str:\n        \"\"\"Solve a linear equation containing only '+', '-', variable 'x' and its coefficient.\"\"\"\n        def parse_side(s: str):\n            \"\"\"Parse one side of the equation, returning (coeff_of_x, constant_sum).\"\"\"\n            x_coeff, const = 0, 0\n            i, n, sign = 0, len(s), 1\n            while i < n:\n                if s[i] == '+':\n                    sign = 1\n                    i += 1\n                elif s[i] == '-':\n                    sign = -1\n                    i += 1\n                else:\n                    j = i\n                    while j < n and s[j] not in '+-':\n                        j += 1\n                    token = s[i:j]\n                    if 'x' in token:\n                        coeff_part = token[:-1]  # remove trailing 'x'\n                        if coeff_part == '' or coeff_part == '+':\n                            coeff = 1\n                        elif coeff_part == '-':\n                            coeff = -1\n                        else:\n                            coeff = int(coeff_part)\n                        x_coeff += sign * coeff\n                    else:\n                        const += sign * int(token)\n                    i = j\n            return x_coeff, const\n\n        left, right = equation.split('=')\n        left_x, left_const = parse_side(left)\n        right_x, right_const = parse_side(right)\n\n        # Bring all terms to the left side: (left_x - right_x) * x + (right_const - left_const) = 0\n        a = left_x - right_x\n        b = right_const - left_const\n\n        if a == 0:\n            return \"Infinite solutions\" if b == 0 else \"No solution\"\n        return f\"x={-b // a}\"\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # If input looks like a variable assignment e.g. 'equation = \"x+5-3+x=6+x-2\"'\n    if '=' in data:\n        # Find the first '=' that separates the assignment from the value\n        assign_index = data.find('=')\n        raw_eq = data[assign_index + 1:].strip()\n        # Remove surrounding quotes if present\n        if (raw_eq.startswith('\"') and raw_eq.endswith('\"')) or (raw_eq.startswith(\"'\") and raw_eq.endswith(\"'\")):\n            raw_eq = raw_eq[1:-1]\n        equation = raw_eq\n    else:\n        equation = data\n\n    solution = Solution()\n    result = solution.solveEquation(equation)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. The problem: Solve linear equation with '+', '-', variable x, coefficient. Return string. Cases: No solution, Infinite solutions, else single integer solution.\n\nWe produce steps: parse equation, separate left and right parts, compute coefficients sum, constant sum, bring to standard form ax + b = 0, etc.\n\nWe need to output step lines with virtual code and comment.\n\nNo actual code, just virtual.\n\nLet's craft: Start → Step 1: 取得等式 // etc.\n\nWe need to be clear. We'll do a simplified approach: split by '=' into left and right.\n\nCompute coefficient of x and constant for each side.\n\nThen bring all to left: coefficient = leftCoeff - rightCoeff, constant = rightConst - leftConst. Then equation becomes coefficient*x + constant = 0.\n\nIf coefficient == 0 and constant == 0 -> infinite. If coefficient == 0 and constant != 0 -> no solution. Else x = -constant / coefficient. Since guaranteed integer.\n\nReturn formatted string.\n\nLet's produce lines.\n\nWe'll include decision steps.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入等式 // 取得待解的字串  \n→ Step 2: 將等式以 '=' 分割為 leftExpr 與 rightExpr // 分成左右兩邊  \n→ Decision: 如果 leftExpr 或 rightExpr 為空? // 檢查是否完整  \n    Yes → Step 3: 回傳 \"No solution\" // 缺失部分視為無解  \n    No  →  \n→ Step 3: 定義變數 leftCoeff, leftConst, rightCoeff, rightConst 為 0 // 初始化係數與常數  \n→ Step 4: 解析 leftExpr  \n    → Decision: 是否包含 'x'? // 判斷是否有變數  \n        Yes → Step 5: 提取 x 的係數並加到 leftCoeff  \n        No  →  \n    → Step 6: 將 leftExpr 轉成單純常數表達式並加到 leftConst // 只剩常數部分  \n→ Step 5: 解析 rightExpr（同左邊的步驟）  \n    → Decision: 是否包含 'x'?  \n        Yes → Step 6: 提取 x 的係數並加到 rightCoeff  \n        No  →  \n    → Step 7: 將 rightExpr 轉成單純常數表達式並加到 rightConst  \n→ Step 8: 轉換為標準形式 ax + b = 0  \n    → Step 9: 計算 a = leftCoeff - rightCoeff // 所有 x 的係數合併  \n    → Step 10: 計算 b = rightConst - leftConst // 所有常數合併  \n→ Decision: 若 a = 0? // 檢查係數為零  \n    Yes →  \n        Decision: 若 b = 0? // 常數是否也為零  \n            Yes → Step 11: 回傳 \"Infinite solutions\" // 無限多解  \n            No  → Step 12: 回傳 \"No solution\" // 無解  \n    No  → // 有唯一解  \n→ Step 13: 計算 x = -b / a // b 與 a 為整數，商為整數  \n→ Step 14: 回傳 \"x=\" + x // 將結果轉成字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Count Binary Substrings",
      "source_file": "Leetcode/leetcode696.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"00110011\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "s = \"10101\"",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '10'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '10'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        groups = []\n        count = 1\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                count += 1\n            else:\n                groups.append(count)\n                count = 1\n        groups.append(count)\n\n        result = 0\n        for i in range(1, len(groups)):\n            result += min(groups[i], groups[i-1])\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取輸入，去除可能的首尾空白與引號\n    raw_input = sys.stdin.read().strip()\n    if raw_input and raw_input[0] in (\"'\", '\"') and raw_input[-1] == raw_input[0]:\n        s = raw_input[1:-1]\n    else:\n        s = raw_input\n\n    solution = Solution()\n    print(solution.countBinarySubstrings(s))",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for algorithm. Problem: count substrings with equal number of 0s and 1s and grouped consecutively. Standard approach: count consecutive groups of same character; the answer is sum over min(len_i, len_{i+1}) for consecutive groups. We need to produce virtual code steps, not actual code, but steps. Use Start, End, Decision, etc. Each line with explanation. Should produce algorithm steps: iterate string, count group lengths in list; then iterate adjacent pairs, sum min; output. Also handle multiple substrings: each pair of groups yields min length. Provide virtual code lines accordingly.\n\nWe must produce each line of virtual code and explanation. Use arrow for each step. Should be in Chinese. Use virtual arrows: →, Yes →, No →. Should produce stepwise. Let's craft.\n\nLine1: Start // program start\n\nLine2: → Step 1: 初始化空列表 group_lengths // 用來存儲連續相同字符的長度\n\nLine3: → Step 2: 設置指標 i = 0 // 索引遍歷字串\n\nLine4: → Decision: i < s.length? // 是否還有字符未處理\n\nLine5: Yes → Step 3: 讀取當前字符 cur = s[i] // 紀錄目前字符\n\nLine6: → Step 4: 設置計數 count = 0 // 為當前組計數\n\nLine7: → Decision: i < s.length AND s[i] == cur? // 繼續計算同組字符\n\nLine8: Yes → Step 5: count++ ; i++ // 計數加1，移動索引\n\nLine9: No  → Step 6: group_lengths.add(count) // 組計完，加入列表\n\nLine10: → Decision: i < s.length? // 是否還有字符待處理\n\nLine11: Yes → 回到 Step 3 // 重新開始下一組\n\nLine12: No  → Step 7: 檢查是否至少兩組 // 若 group_lengths size >=2\n\nLine13: Decision: group_lengths.size < 2? // 判斷是否足夠計算\n\nLine14: Yes → Step 8: return 0 // 沒有足夠組，返回 0\n\nLine15: No  → Step 9: 初始化結果 count_substrings = 0 // 結果累加\n\nLine16: → Step 10: 迭代索引 j from 0 to group_lengths.size-2 // 逐對相鄰組\n\nLine17: → Step 11: result += min(group_lengths[j], group_lengths[j+1]) // 加入最小長度\n\nLine18: → Step 12: return count_substrings // 返回總數\n\nLine19: End // 程式結束\n\nWe also need to include decision lines properly formatted: \"Decision: ...\". We need to use Yes →, No → arrows for decision branches.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空列表 group_lengths // 用來存儲連續相同字符的長度  \n→ Step 2: 設置指標 i = 0 // 索引遍歷字串  \n→ Decision: i < s.length? // 是否還有字符未處理  \n&nbsp;&nbsp;Yes → Step 3: 讀取當前字符 cur = s[i] // 紀錄目前字符  \n&nbsp;&nbsp;→ Step 4: 設置計數 count = 0 // 為當前組計數  \n&nbsp;&nbsp;→ Decision: i < s.length AND s[i] == cur? // 繼續計算同組字符  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: count++ ; i++ // 計數加1，移動索引  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6: group_lengths.add(count) // 組計完，加入列表  \n&nbsp;&nbsp;→ Decision: i < s.length? // 是否還有字符待處理  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → 回到 Step 3 // 重新開始下一組  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 7: 檢查是否至少兩組 // 若 group_lengths size >=2  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: group_lengths.size < 2? // 判斷是否足夠計算  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 8: return 0 // 沒有足夠組，返回 0  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 9: 初始化結果 count_substrings = 0 // 結果累加  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 10: 迭代索引 j from 0 to group_lengths.size-2 // 逐對相鄰組  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 11: count_substrings += min(group_lengths[j], group_lengths[j+1]) // 加入最小長度  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 12: return count_substrings // 返回總數  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[], [1], [2], [1, 2], [2, 2], [1, 2, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        nums.sort()\n        res = [[]]\n        for num in nums:\n            new_subsets = []\n            for subset in res:\n                new_subsets.append(subset + [num])\n            res += new_subsets\n        unique_res = []\n        seen = set()\n        for subset in res:\n            t = tuple(subset)\n            if t not in seen:\n                seen.add(t)\n                unique_res.append(subset)\n        return unique_res\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中抽取整數列表.\"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    # 找到第一個 '[' 與最後一個 ']'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        return []\n    list_str = data[start:end+1]\n    try:\n        nums = ast.literal_eval(list_str)\n        if isinstance(nums, list):\n            return nums\n    except Exception:\n        pass\n    return []\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.subsetsWithDup(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets (power set) from an array that may contain duplicates. We need to avoid duplicate subsets. Typical approach: sort array, then use backtracking, skip duplicates when building subsets by only including the first occurrence or using condition skip if nums[i]==nums[i-1] and not used before.\n\nWe need to produce step-by-step virtual code with arrows. Use Start, End, Decision. Each line: \"虛擬碼步驟 // 解釋\". Must not output actual code. Should include steps: sort array, define result, define backtrack function, call backtrack, return result.\n\nEach line must be preceded by arrow? Format: \"Start // 程式開始執行\". Then \"→ Step 1: ...\". Then Decision: \"Decision: ...\". Inside, indent with Yes →, No →.\n\nWe need to produce all steps for backtracking: choose element, add to current subset, recursive call with next index, after recursion, remove element (backtrack), loop continues. Also skip duplicates: In loop, if i>start and nums[i]==nums[i-1] then skip.\n\nWe must include a step to copy current subset to result. We'll produce generic steps.\n\nWe need to ensure each line includes // explanation. Use Chinese explanations.\n\nWe must not output actual code. Only the structure with \"Step X: ...\".\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 從使用者或函式參數取得數字陣列\n→ Step 2: 將 nums 依升序排序 // 方便後續去重\n→ Step 3: 建立空陣列 result // 用來存所有子集\n→ Step 4: 定義遞迴函式 backtrack(start, current) // backtrack 會從 start 開始選取元素\n→ Decision: 是否已達到陣列結束？ // 判斷是否已遍歷完所有元素\n    Yes → Step 5: 把 current 複製到 result // 目前選取的子集加入結果\n    No  → Decision: 迴圈遍歷 index i 從 start 到 nums.length-1 // 為每個位置嘗試加入子集\n        → Step 6: 判斷 i>start 且 nums[i]==nums[i-1]？ // 判斷是否為重複元素\n            Yes → Step 7: 跳過此 i // 避免重複子集\n            No  → Step 8: 把 nums[i] 加入 current // 選取此元素\n                → Step 9: backtrack(i+1, current) // 進一步遞迴選取後續元素\n                → Step 10: 移除 current 最後一個元素 // 回溯\n→ End // 程式執行結束\n\nBut we need to structure with arrows. The decision for \"是否已達到陣列結束\" might not be necessary because we add current to result regardless. The typical algorithm: at each call, add current to result. Then loop over i from start to n-1: skip duplicates, choose element, recursion, backtrack.\n\nThus we can simplify: start function; add current to result; for loop. Provide steps accordingly.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 從使用者或函式參數取得數字陣列\n→ Step 2: 將 nums 依升序排序 // 方便後續去重\n→ Step 3: 建立空陣列 result // 用來存所有子集\n→ Step 4: 定義遞迴函式 backtrack(start, current) // 回傳所有子集\n→ Decision: 執行 backtrack(0, 空陣列) // 開始遞迴\nEnd\n\nBut we need inside backtrack function: add current to result, loop, skip duplicates, choose element, recursion, backtrack. So we need to detail steps inside.\n\nWe might structure as:\n\nStep 4: 定義遞迴函式 backtrack(start, current) // 定義回傳子集的遞迴\n    → Step 4.1: 把 current 複製到 result // 每次呼叫都把目前子集加入結果\n    → Step 4.2: 迴圈 i 從 start 到 nums.length-1 // 為每個位置嘗試加入子集\n        → Decision: i>start 且 nums[i]==nums[i-1]？ // 判斷是否為重複元素\n            Yes → Step 4.3: 跳過此 i // 避免重複子集\n            No  → Step 4.4: 把 nums[i] 加入 current // 選取此元素\n                → Step 4.5: backtrack(i+1, current) // 進一步遞迴\n                → Step 4.6: 移除 current 最後一個元素 // 回溯\n\nThen after defining backtrack, we call it.\n\nThus final output lines with arrow and explanation.\n\nBe careful: each line needs to have \"虛擬碼步驟\" and // explanation.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 從使用者或函式參數取得數字陣列  \n→ Step 2: 將 nums 依升序排序 // 方便後續去除重複子集  \n→ Step 3: 建立空陣列 result // 用來存所有子集  \n→ Step 4: 定義遞迴函式 backtrack(start, current) // 回傳所有子集  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.1: 把 current 複製到 result // 每次呼叫都把目前子集加入結果  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.2: 迴圈 i 從 start 到 nums.length-1 // 為每個位置嘗試加入子集  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: i>start 且 nums[i]==nums[i-1]? // 判斷是否為重複元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4.3: 跳過此 i // 避免產生重複子集  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 4.4: 把 nums[i] 加入 current // 選取此元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.5: backtrack(i+1, current) // 進一步遞迴選取後續元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.6: 移除 current 最後一個元素 // 回溯至上一層  \n→ Decision: 執行 backtrack(0, 空陣列) // 開始遞迴以產生所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"把原始陣列保存在實例變數，供後續 pick 使用。\"\"\"\n        self.nums = nums\n\n    def pick(self, target):\n        \"\"\"\n        隨機選取所有符合 target 的索引，且每個索引被選到的機率相等。\n        使用 reservoir sampling：遍歷一次陣列，遇到 target 時以 1/count 的機率選擇它。\n        \"\"\"\n        chosen_index = -1\n        count = 0\n        for i, num in enumerate(self.nums):\n            if num == target:\n                count += 1\n                # 產生 1~count 的隨機數，若為 1 則更新 chosen_index\n                if random.randint(1, count) == 1:\n                    chosen_index = i\n        return chosen_index\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 把輸入分成兩部分：操作序列和參數序列\n    # 例子：'[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]'\n    split_index = raw_input.find('],')\n    ops_json = raw_input[:split_index + 1]\n    args_json = raw_input[split_index + 2:]\n\n    ops = json.loads(ops_json)\n    args = json.loads(args_json)\n\n    results = []\n    instance = None\n    for i, op in enumerate(ops):\n        if op == \"Solution\":\n            # 建構子參數為單一列表：[[1, 2, 3, 3, 3]]\n            instance = Solution(args[i][0])\n            results.append(None)          # 第一個結果為 null\n        elif op == \"pick\":\n            # pick 只需要 target，參數為單一元素列表，例如 [3]\n            result = instance.pick(args[i][0])\n            results.append(result)\n\n    # 輸出結果，保持 JSON 格式（None 會被轉成 null）\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to generate virtual code for the described solution. Provide step-by-step. Need to include Start, End, Decision, arrows. We need to think algorithm: given array nums. In constructor, store array. For pick, we need to use reservoir sampling to pick random index among all occurrences of target. Or we can precompute mapping from target to list of indices, but that may be heavy. Let's implement reservoir sampling: iterate over array, maintain count of target occurrences seen, when see target, generate random number between 1 and count, if it's 1, record index as chosen. At end return chosen index. So algorithm:\n\nSolution constructor: store nums. (Optionally store length). pick(target): initialize chosenIndex = -1, count = 0; for i from 0 to nums.length-1: if nums[i]==target: count++; if randomInt(1, count)==1: chosenIndex = i; return chosenIndex.\n\nVirtual code steps: Start; Step: store array; etc.\n\nAlso need explanation each line.\n\nLet's produce steps:\n\nStart\n→ Step 1: Store input array nums into member variable // Constructor\n→ End // Done with initialization\n\nBut need also pick method steps.\n\nWe might separate methods: Start → Constructor block → End; Start → pick method block → End.\n\nMake each line with virtual code step and explanation.\n\nUse arrow syntax: Start, → Step 1, etc. For loops we can use \"→ Loop i from 0 to nums.length-1\" etc. For random: \"→ Generate random number r = random(1, count)\". For Decision: \"Decision: r == 1?\".\n\nWe should also include End for pick method.\n\nMake sure each line has '//' explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式執行入口\n\n→ Step 1: Store the input array `nums` in a member variable `this.nums` // 於建構子內將陣列保存在物件中\n→ Step 2: Record the length `this.n = this.nums.length` // 方便後續迴圈使用\nEnd // 建構子完成\n\nStart // pick 方法開始執行\n\n→ Step 3: Initialize `chosenIndex` to -1 // 預設沒有選到任何位置\n→ Step 4: Initialize `count` to 0 // 記錄目前遇到的 target 數量\n→ Loop i from 0 to this.n - 1 // 逐個檢查陣列中的元素\n    → Decision: if this.nums[i] == target? // 判斷是否為目標值\n        Yes → Step 5: Increment `count` by 1 // 新增一次符合條件的項目\n        → Step 6: Generate random integer `r` between 1 and `count` // 產生一個 1~count 的隨機數\n        → Decision: if r == 1? // 以 1/count 的機率選擇目前索引\n            Yes → Step 7: Set `chosenIndex` to i // 把當前索引記錄為選中的位置\n            No  → // 不做任何改變，繼續迴圈\n        No  → // 當 nums[i] 不是 target，直接跳過\n→ End Loop // 完成所有元素的檢查\n→ Step 8: Return `chosenIndex` // 回傳隨機選到的索引\nEnd // pick 方法結束\n\nEnd // 程式結束執行"
    },
    {
      "title": "Word Break",
      "source_file": "Leetcode/leetcode139.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpm4kkz2d0.py\", line 22, in <module>\n    exec(data, {}, namespace)\n  File \"<string>\", line 1\n    s= \"leetcode\", wordDict= [\"leet\",\"code\"]\n    ^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplmezd06a.py\", line 22, in <module>\n    exec(data, {}, namespace)\n  File \"<string>\", line 1\n    s= \"applepenapple\", wordDict= [\"apple\",\"pen\"]\n    ^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpli0vnklr.py\", line 22, in <module>\n    exec(data, {}, namespace)\n  File \"<string>\", line 1\n    s= \"catsandog\", wordDict= [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n    ^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        word_set = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(s)]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 將輸入字串轉為可 eval 的程式碼\n    data = data.replace('s =', 's=').replace('wordDict =', 'wordDict=')\n    namespace = {}\n    exec(data, {}, namespace)\n    s = namespace['s']\n    wordDict = namespace['wordDict']\n    result = Solution().wordBreak(s, wordDict)\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nThe task: produce virtual code steps for Word Break problem. Use Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to generate algorithm steps in virtual pseudocode, line by line. Probably dynamic programming approach.\n\nLet's outline steps:\n\nStart\n\n→ Initialize DP array of size len(s)+1, DP[0] = true // base case.\n\n→ For i from 1 to len(s) inclusive // iterate over string\n\n   → For each word in wordDict\n\n      → If i >= len(word) AND DP[i - len(word)] == true AND s.substring(i - len(word), i) == word\n\n          → Set DP[i] = true\n\n          → Break inner loop\n\n→ End loop\n\n→ Return DP[len(s)]\n\nThat's the pseudocode.\n\nWe need to format with arrow and decision maybe.\n\nWe need to use decision steps like \"Decision: if DP[i] is true?\" but we can also do loops as steps.\n\nWe need to ensure each line includes code and explanation.\n\nLet's produce lines:\n\nStart // 程式開始執行\n\n→ Step 1: 計算字符串長度 n ← length(s) // 取得 s 的長度\n\n→ Step 2: 初始化布林陣列 dp[n+1]，dp[0] ← true // DP 用來記錄子字串是否可切分\n\n→ Step 3: For i from 1 to n 循環 // 遍歷所有可能的子字串結尾\n\n    → Decision: 如果 dp[i] 已經為 true? // 已經找到切分方式則跳過\n\n        Yes → Continue to next i // 已可切分，直接進下一個\n\n        No → Step 4: For each word in wordDict 循環 // 嘗試使用字典中的每個單字\n\n            → Decision: 如果 i ≥ len(word) 且 dp[i-len(word)] 為 true 且 s 子字串 i-len(word) 到 i == word? // 檢查是否能以此單字結尾\n\n                Yes → Step 5: dp[i] ← true // 設定此位置可切分\n\n                Yes → Break // 找到一個切分就可停止內層循環\n\n→ Step 6: 返回 dp[n] // 若整個字串可切分則為 true，否則 false\n\nEnd // 程式執行結束\n\nNeed to check formatting: Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" before each step. For decision branches, indent appropriately. The sample uses indentation like 4 spaces. Use similar.\n\nMake sure each line ends with // 解釋. For decisions, \"Decision:\" etc.\n\nWe need to maintain structure:\n\nStart // 程式開始執行\n\n→ Step 1: n ← length(s) // 取得 s 的長度\n\n→ Step 2: dp[0..n] ← false; dp[0] ← true // 初始化 DP 陣列\n\n→ Step 3: For i = 1 to n // 循環檢查每個子字串結尾\n\n    → Decision: if dp[i] == true? // 已有切分方法，跳過\n\n        Yes → Continue // 直接進下一個 i\n\n        No  → For each word in wordDict // 逐一嘗試字典單字\n\n            → Decision: if i ≥ len(word) AND dp[i-len(word)] == true AND s.substring(i-len(word), i) == word? // 能否以此單字結尾\n\n                Yes → dp[i] ← true // 設定可切分\n\n                Yes → Break // 找到一個就停止\n\n→ Step 4: return dp[n] // 若整個字串可切分則為 true\n\nEnd // 程式結束\n\nBut we need to maintain the requirement: \"虛擬碼步驟 [空格] // 解釋\" each line.\n\nLet's produce each line exactly. Use Chinese comments.\n\nAlso, for loops we might need \"→ For i from 1 to n\" etc.\n\nLet's produce.\n\nNote: Use '→' at start of each line.\n\nMake sure indentation: For nested lines, indent with 4 spaces before the arrow. Eg: \"    → Decision:\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(s) // 取得字串 s 的長度  \n→ Step 2: dp[0..n] ← false; dp[0] ← true // 初始化 DP 陣列，dp[i] 表示前 i 個字可否切分  \n→ Step 3: For i = 1 to n // 逐個檢查每個可能的子字串結尾  \n  → Decision: 如果 dp[i] == true? // 已有切分方式，直接跳過  \n   Yes → Continue // 進行下一個 i  \n   No → For each word in wordDict // 逐一嘗試字典中的單字  \n     → Decision: 如果 i ≥ length(word) AND dp[i - length(word)] == true AND s.substring(i - length(word), i) == word? // 檢查是否能以此單字結尾  \n      Yes → dp[i] ← true // 設定此位置可切分  \n      Yes → Break // 找到一個切分就停止內層循環  \n→ Step 4: return dp[n] // 若整個字串可切分則為 true，否則為 false  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if '=' in data:\n        _, _, rest = data.partition('=')\n        rest = rest.strip()\n        if rest and rest[0] in (\"'\", '\"') and rest[-1] in (\"'\", '\"'):\n            dna = rest[1:-1]\n        else:\n            dna = rest\n    else:\n        dna = data.strip(\"'\\\"\")\n    sol = Solution()\n    result = sol.findRepeatedDnaSequences(dna)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the format. Steps: read string s, find all substrings length 10, track counts, output those >1.\n\nWe must use Start, End, Decision, etc. We'll produce algorithm: use hash map, loop i from 0 to len-10, substring, increment count, after loop iterate over map and collect keys where count>1.\n\nWe'll follow step by step. Use arrows.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\".\n\nWe produce lines:\n\nStart // 程式開始執行\n→ Step 1: 設定字串 s // 接收 DNA 序列\n→ Step 2: 初始化空字典 freq // 用於紀錄每個 10 字符長子字串出現次數\n→ Step 3: 設定變數 n = len(s) // 序列長度\n→ Decision: n 是否小於 10? // 若長度不足 10 無法形成子字串\n    Yes → End // 程式結束\n    No  →\n→ Step 4: 循環 i 從 0 到 n-10 // 遍歷所有可能的起始位置\n        → Step 5: sub = s[i:i+10] // 取得長度 10 的子字串\n        → Step 6: freq[sub] = freq.get(sub,0)+1 // 更新出現次數\n→ Step 7: 初始化空列表 result // 儲存重複出現的子字串\n→ Step 8: 循環 sub, cnt 在 freq.items() // 遍歷字典\n        → Decision: cnt 是否大於 1? // 判斷是否重複\n            Yes → Step 9: result.append(sub) // 加入結果\n            No  → // 不做任何事\n→ Step 10: 輸出 result // 回傳所有重複的 10 字符長子字串\nEnd // 程式執行結束\n\nCheck format: each line with //.\n\nAlso include arrows. Use \"Yes →\" and \"No →\".\n\nMake sure indentation and arrows consistent. Provide exactly as requested.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定字串 s // 接收 DNA 序列\n→ Step 2: 初始化空字典 freq // 用於紀錄每個 10 字符長子字串出現次數\n→ Step 3: 設定變數 n = len(s) // 序列長度\n→ Decision: n 是否小於 10? // 若長度不足 10 無法形成子字串\n    Yes → End // 程式結束\n    No  →\n→ Step 4: 循環 i 從 0 到 n-10 // 遍歷所有可能的起始位置\n        → Step 5: sub = s[i:i+10] // 取得長度 10 的子字串\n        → Step 6: freq[sub] = freq.get(sub,0)+1 // 更新出現次數\n→ Step 7: 初始化空列表 result // 儲存重複出現的子字串\n→ Step 8: 循環 sub, cnt 在 freq.items() // 遍歷字典\n        → Decision: cnt 是否大於 1? // 判斷是否重複\n            Yes → Step 9: result.append(sub) // 加入結果\n            No  → // 不做任何事\n→ Step 10: 輸出 result // 回傳所有重複的 10 字符長子字串\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpenv003c7.py\", line 72, in <module>\n    main()\n  File \"/tmp/tmpenv003c7.py\", line 53, in main\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nimport random\nimport json\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []                 # 存放所有元素的列表\n        self.idx_map = {}              # value -> set of indices in data\n\n    def insert(self, val):\n        if val not in self.idx_map:\n            self.idx_map[val] = set()\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若首次插入才回傳 True，否則 False\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val):\n        if val not in self.idx_map or not self.idx_map[val]:\n            return False\n        # 取得任意一個出現在 data 的位置\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n        # 把最後一個元素移到要刪除的位置\n        self.data[remove_idx] = last_val\n        # 更新 last_val 的索引集合\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n        # 刪除最後一個元素\n        self.data.pop()\n        # 若該值已無剩餘，移除鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.data)\n\ndef main():\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return\n    # 分離兩個列表\n    m = re.search(r'\\[(.*?)\\],\\s*\\[(.*?)\\]', input_data, re.S)\n    if not m:\n        return\n    commands_str = '[' + m.group(1) + ']'\n    args_str = '[' + m.group(2) + ']'\n    commands = ast.literal_eval(commands_str)\n    args = ast.literal_eval(args_str)\n\n    rc = RandomizedCollection()\n    results = [None]  # constructor returns null\n\n    for cmd, arg in zip(commands[1:], args[1:]):\n        if cmd == 'insert':\n            res = rc.insert(arg[0])\n        elif cmd == 'remove':\n            res = rc.remove(arg[0])\n        elif cmd == 'getRandom':\n            res = rc.getRandom()\n        else:\n            res = None\n        results.append(res)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps describing algorithm for RandomizedCollection with insert, remove, getRandom in O(1). Use array/list + hashmap mapping value to set of indices. Provide step-by-step pseudocode.\n\nNeed to output each line with \"→\" arrow, Decision, etc.\n\nWe must not output actual code, just virtual code with explanation.\n\nLet's produce:\n\nStart\n→ Initialize empty list nums and hashmap valIndices: map int → set of indices\n→ Define insert(val):\n    → Add val to nums list at end index i\n    → Add i to valIndices[val] set\n    → If valIndices[val] size was 1? // check if val existed before\n        Yes → Return false? Actually if it was present before, insert returns false. But after insertion, size >1, so return false if existed before else true. So decision:\n    → Decision: if val existed before?\n        Yes → Return false\n        No  → Return true\n→ Define remove(val):\n    → Decision: if valIndices[val] is empty? // not present\n        Yes → Return false\n        No  → \n            → Pick any index idx from valIndices[val]\n            → Remove idx from valIndices[val]\n            → Get last element lastVal and lastIndex len(nums)-1\n            → Overwrite nums[idx] = lastVal\n            → Update valIndices[lastVal] set: remove lastIndex, add idx\n            → Remove last element from nums list\n            → If valIndices[val] now empty? // optional clean up\n                → Delete valIndices[val]\n            → Return true\n→ Define getRandom():\n    → Randomly pick index r between 0 and len(nums)-1\n    → Return nums[r]\nEnd\n\nWe must provide virtual code lines with explanations. Use arrow \"→\" at start of each step. Use Decision with Yes →, No →. Include Start, End.\n\nWe should break into multiple lines: initialization, functions definitions, etc.\n\nWe need each line \"虛擬碼步驟 [space] // 解釋\". Provide each line.\n\nLet's produce the output.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize nums ← [] // 空陣列儲存所有元素\n→ Initialize valIndices ← {} // map: value → 集合(indices) 在 nums 中的所有位置\n\n→ Define insert(val) // 插入元素\n    → Append val 到 nums 的末尾，index ← len(nums)-1 // 取得新位置\n    → If val 不在 valIndices, 則 valIndices[val] ← empty set // 建立集合\n    → Add index 到 valIndices[val] // 記錄位置\n    → Decision: 若 valIndices[val] 原本為空? // 判斷該值是否首次插入\n        Yes → Return true // 新元素，回傳 true\n        No  → Return false // 已存在，回傳 false\n\n→ Define remove(val) // 刪除一個元素\n    → Decision: 若 val 不在 valIndices 或 valIndices[val] 為空? // 元素不存在\n        Yes → Return false // 無法刪除，回傳 false\n        No  →\n            → Pick 任意 index idx 從 valIndices[val] 中\n            → Remove idx 從 valIndices[val] // 刪除該位置\n            → lastIndex ← len(nums)-1\n            → lastVal ← nums[lastIndex] // 取得最後一個元素\n            → nums[idx] ← lastVal // 將最後一個元素覆蓋到要刪除的位置\n            → Remove lastIndex 從 valIndices[lastVal] // 移除舊位置\n            → Add idx 到 valIndices[lastVal] // 加入新位置\n            → Remove nums[lastIndex] // 從陣列刪除最後一個元素\n            → Decision: 若 valIndices[val] 為空? // 若該值已無剩餘\n                Yes → Delete valIndices[val] // 清除佔用空間\n                No  → Do nothing\n            → Return true // 刪除成功，回傳 true\n\n→ Define getRandom() // 取得隨機元素\n    → r ← RandomInteger(0, len(nums)-1) // 隨機索引\n    → Return nums[r] // 回傳該位置的元素\n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    \"\"\"使用兩個堆來維護中位數，左堆為最大堆，右堆為最小堆。\"\"\"\n    def __init__(self):\n        self.left = []   # max-heap (以負值存儲)\n        self.right = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        # 先把數字放到左堆（最大堆）\n        heapq.heappush(self.left, -num)\n\n        # 如果左堆頂比右堆頂大，兩堆順序錯亂，調整一下\n        if self.left and self.right and (-self.left[0] > self.right[0]):\n            val = -heapq.heappop(self.left)\n            heapq.heappush(self.right, val)\n\n        # 保持兩堆大小差不超過 1\n        if len(self.left) > len(self.right) + 1:\n            val = -heapq.heappop(self.left)\n            heapq.heappush(self.right, val)\n        elif len(self.right) > len(self.left):\n            val = heapq.heappop(self.right)\n            heapq.heappush(self.left, -val)\n\n    def findMedian(self) -> float:\n        if len(self.left) > len(self.right):\n            return -self.left[0]\n        return (-self.left[0] + self.right[0]) / 2.0\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 將輸入包裝成一個 JSON 列表，方便解析\n    data = json.loads('[' + raw + ']')\n    ops, args = data[0], data[1]\n\n    results = []\n    mf = None\n    for op, arg in zip(ops, args):\n        if op == 'MedianFinder':\n            mf = MedianFinder()\n            results.append(None)\n        elif op == 'addNum':\n            mf.addNum(arg[0])\n            results.append(None)\n        elif op == 'findMedian':\n            median = mf.findMedian()\n            results.append(median)\n        else:\n            results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for MedianFinder with addNum and findMedian. We need to design algorithm: use two heaps (max-heap left, min-heap right). Maintain sizes difference <=1. In addNum, push to appropriate heap. In findMedian, if sizes equal, median = (maxLeft + minRight)/2. Else the larger heap's top.\n\nWe need to output each line of virtual code with explanation. Provide Start, End, Decision, etc. Must be step-by-step. Use arrow formatting. Each line: \"虛擬碼步驟 // 解釋\". We need to not output actual code but pseudocode. We can use high-level constructs. Let's produce a linear algorithm representation. Also we need to mention initialization.\n\nSo produce:\n\nStart\n→ Step 1: 初始化兩個堆：左堆（最大堆）和右堆（最小堆） // 用於儲存小半和大半數字\n→ Step 2: 定義 addNum(num) 方法 // 添加新數字\n   → Decision: 若左堆為空或 num <= 左堆頂? // 判斷應放入左堆\n      Yes → 左堆入堆 num // 把數字插入左堆\n      No  → 右堆入堆 num // 否則插入右堆\n   → Decision: 左堆大小 > 右堆大小 + 1? // 檢查左堆是否過大\n      Yes → 右堆入堆 左堆頂並將左堆頂移除 // 平衡兩堆\n      No  → Decision: 右堆大小 > 左堆大小 + 1? // 檢查右堆是否過大\n           Yes → 左堆入堆 右堆頂並將右堆頂移除 // 平衡兩堆\n   → End // addNum 完成\n→ Step 3: 定義 findMedian() 方法 // 計算中位數\n   → Decision: 左堆大小 = 右堆大小? // 數量相等時\n      Yes → Return (左堆頂 + 右堆頂) / 2.0 // 取平均\n      No  → Decision: 左堆大小 > 右堆大小? // 左堆較大\n           Yes → Return 左堆頂 // 左堆頂即為中位數\n           No  → Return 右堆頂 // 右堆頂即為中位數\n→ End // MedianFinder 完成\n\nWe need to include \"Start\" and \"End\" for the whole program and for methods maybe.\n\nBut the format example shows Start/End for program. We can show Start, then the steps, then End. For each method, we can use indentation but not necessary.\n\nLet's produce each line with \"虛擬碼步驟 // 解釋\". Ensure arrow formatting.\n\nWe also might include \"MedianFinder\" initialization step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個堆：左堆（最大堆）和右堆（最小堆） // 用於分別儲存較小與較大的一半數值  \n→ Step 2: 定義方法 addNum(num) // 新增一個整數到資料結構  \n  → Decision: 左堆是否為空 或 num <= 左堆頂？ // 判斷新數字應放入左堆  \n   Yes → 左堆入堆 num // 把數字插入左堆  \n   No  → 右堆入堆 num // 否則插入右堆  \n  → Decision: 左堆大小 > 右堆大小 + 1？ // 檢查左堆是否過大  \n   Yes → 右堆入堆 左堆頂 並將左堆頂移除 // 將左堆最大的數轉移到右堆以平衡  \n   No  → Decision: 右堆大小 > 左堆大小 + 1？ // 檢查右堆是否過大  \n    Yes → 左堆入堆 右堆頂 並將右堆頂移除 // 將右堆最小的數轉移到左堆以平衡  \n  → End // addNum 完成  \n→ Step 3: 定義方法 findMedian() // 取得目前所有數字的中位數  \n  → Decision: 左堆大小 = 右堆大小？ // 數量相等時  \n   Yes → Return (左堆頂 + 右堆頂) / 2.0 // 取兩堆頂值的平均  \n   No  → Decision: 左堆大小 > 右堆大小？ // 左堆較大  \n    Yes → Return 左堆頂 // 左堆頂即為中位數  \n    No  → Return 右堆頂 // 右堆頂即為中位數  \n→ End // MedianFinder 完成程式執行"
    },
    {
      "title": "Data Stream as Disjoint Intervals",
      "source_file": "Leetcode/leetcode352.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,[[1,1]],null,[[1,1],[3,3]],null,[[1,1],[3,3],[7,7]],null,[[1,3],[7,7]],null,[[1,3],[6,7]]]'\nGot (Norm):      '[null,null,[[2,2],[1,1],[3,3],[6,7]],null,[[2,2],[1,1],[3,3],[6,7]],null,[[2,2],[1,1],[3,3],[6,7]],null,[[2,2],[1,1],[3,3],[6,7]],null,[[2,2],[1,1],[3,3],[6,7]]]'\n--- (Raw) ---\nRaw Expected: '[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]'\nRaw Got:      '[null, null, [[2, 2], [1, 1], [3, 3], [6, 7]], null, [[2, 2], [1, 1], [3, 3], [6, 7]], null, [[2, 2], [1, 1], [3, 3], [6, 7]], null, [[2, 2], [1, 1], [3, 3], [6, 7]], null, [[2, 2], [1, 1], [3, 3], [6, 7]]]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass SummaryRanges:\n    def __init__(self):\n        # 用於儲存所有 disjoint 的 interval，格式為 [start, end]\n        self.intervals = []\n\n    def addNum(self, val: int) -> None:\n        # 先找到第一個 end < val-1 的區間位置 i，該位置是 val 可能插入或合併的地方\n        i = 0\n        n = len(self.intervals)\n        while i < n and self.intervals[i][1] < val - 1:\n            i += 1\n\n        # 若 val 已經落在已有區間內，直接返回\n        if i < n and self.intervals[i][0] <= val <= self.intervals[i][1]:\n            return\n\n        # 檢查是否可與前後區間相鄰合併\n        left_adjacent = i > 0 and self.intervals[i-1][1] + 1 == val\n        right_adjacent = i < n and self.intervals[i][0] - 1 == val\n\n        if left_adjacent and right_adjacent:\n            # 同時相鄰於前後區間，合併成一個更大的區間\n            self.intervals[i-1][1] = self.intervals[i][1]\n            del self.intervals[i]\n        elif left_adjacent:\n            # 只相鄰於前區間，延伸前區間結束點\n            self.intervals[i-1][1] = max(self.intervals[i-1][1], val)\n        elif right_adjacent:\n            # 只相鄰於後區間，延伸後區間開始點\n            self.intervals[i][0] = val\n        else:\n            # 兩側都不相鄰，插入一個新的單一區間\n            self.intervals.insert(i, [val, val])\n\n    def getIntervals(self):\n        # 直接回傳目前的區間列表\n        return self.intervals\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = json.loads(data[0])\n    args = json.loads(data[1])\n\n    obj = None\n    results = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"SummaryRanges\":\n            obj = SummaryRanges()\n            results.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(arg[0])\n            results.append(None)\n        elif cmd == \"getIntervals\":\n            results.append(obj.getIntervals())\n\n    # 使用 json.dumps 會把 None 轉成 null，符合題目輸出格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for implementing the SummaryRanges class. Need to produce step-by-step pseudo-code with explanation after each line. Use arrow syntax. Should handle initialization, addNum, getIntervals. Might need data structure: store intervals list. Steps: check if value in any interval, extend, merge.\n\nWe will produce a high-level algorithm. Since it's virtual code, can mention operations like \"if value already present\". We'll output each line with explanation.\n\nWe must ensure each line ends with // explanation.\n\nLet's craft.\n\nStart → Step 1: 初始化 intervals 為空 list // 初始化空的區間列表\n\n→ Step 2: addNum(value) // 添加數字的流程\n\n→ Decision: 值是否已在區間內? // 判斷 value 是否已存在\n\nYes → Step 3: 返回 // 已存在，無需改變\n\nNo → Step 4: 找到插入位置 i // 確定 value 與現有區間的相對位置\n\n→ Decision: value 與前一個區間接觸? // 判斷是否與前一個區間連接\n\nYes → Step 5: 擴展前一個區間的 end 為 value // 合併前一個區間\n\nElse → Decision: value 與後一個區間接觸? // 判斷是否與後一個區間連接\n\n    Yes → Step 6: 擴展後一個區間的 start 為 value // 合併後一個區間\n\n    No  → Step 7: 插入新區間 [value, value] 在 i 位置 // 新增單一區間\n\n→ Decision: 前後兩區間是否都接觸並可合併? // 判斷是否需要合併兩區間\n\n    Yes → Step 8: 合併前後區間為 [prev_start, next_end] 並刪除中間區間 // 形成大區間\n\n    No  → Step 9: 無需合併，保持已更新區間 // 保持現狀\n\n→ End // addNum 結束\n\n→ Step 10: getIntervals() // 返回目前區間列表\n\n→ Step 11: 返回 intervals 的深拷貝 // 為防止外部修改，返回拷貝\n\n→ End // getIntervals 結束\n\nWe also need class definition. Might add Start at class.\n\nLet's structure:\n\nStart // 程式開始執行\n\n→ Start SummaryRanges // 建立 SummaryRanges 類別\n\n→ Step 1: intervals ← 空列表 // 用來存儲 disjoint intervals\n\n→ End SummaryRanges // 類別初始化完成\n\nThen addNum method.\n\n→ Start addNum(value) // 方法開始\n\n→ Decision: value 已存在於 intervals? // 檢查是否重複\n\nYes → Step 2: return // 直接返回\n\nNo → Step 3: 找到第一個 intervals[i] 使 intervals[i].start > value // 找插入點\n\n→ Decision: i > 0 且 intervals[i-1].end + 1 == value? // 與前區間相鄰\n\n    Yes → Step 4: intervals[i-1].end ← value // 延伸前區間\n\nElse → Decision: i < len(intervals) 且 intervals[i].start - 1 == value? // 與後區間相鄰\n\n    Yes → Step 5: intervals[i].start ← value // 延伸後區間\n\n    No  → Step 6: intervals.insert(i, [value, value]) // 新增新區間\n\n→ Decision: i > 0 且 intervals[i-1].end + 1 >= intervals[i].start? // 前後區間相連\n\n    Yes → Step 7: intervals[i-1].end ← intervals[i].end // 合併為一個\n\n    No  → Step 8: // 無需合併\n\n→ End addNum // 方法結束\n\nSimilarly for getIntervals.\n\nBut the output requires each line with arrow and explanation.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Start SummaryRanges // 建立 SummaryRanges 類別\n→ Step 1: intervals ← [] // 用空列表儲存所有 disjoint interval\n→ End SummaryRanges // 初始化完成\n\n→ Start addNum(value) // addNum 方法開始\n→ Decision: value 已存在於 intervals? // 檢查重複數值\n    Yes → Step 2: return // 已存在，無需更動\n    No  → // 進行插入或合併\n→ Step 3: i ← 找到首個 intervals[i] 使 intervals[i].start > value // 確定插入位置\n→ Decision: i > 0 且 intervals[i-1].end + 1 == value? // 與前一個 interval 相鄰\n    Yes → Step 4: intervals[i-1].end ← value // 延伸前 interval 的結束\n    No  → // 不與前 interval 相鄰\n        → Decision: i < len(intervals) 且 intervals[i].start - 1 == value? // 與後 interval 相鄰\n            Yes → Step 5: intervals[i].start ← value // 延伸後 interval 的開始\n            No  → Step 6: intervals.insert(i, [value, value]) // 插入新的單一 interval\n→ Decision: i > 0 且 intervals[i-1].end + 1 >= intervals[i].start? // 前後 interval 之間有重疊或相鄰\n    Yes → Step 7: intervals[i-1].end ← intervals[i].end // 合併為一個更大的 interval\n    No  → // 前後 interval 已保持 disjoint\n→ End addNum // addNum 方法結束\n\n→ Start getIntervals() // getIntervals 方法開始\n→ Step 8: return copy_of(intervals) // 以拷貝的方式返回目前所有 interval，避免外部修改\n→ End getIntervals // getIntervals 方法結束\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdgowe0eg.py\", line 58, in <module>\n    main()\n  File \"/tmp/tmpdgowe0eg.py\", line 48, in main\n    intervals  = eval(m_intervals.group(1))\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,3],[6,9]], newInterval = [2,5]\n                               ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpz02quhd8.py\", line 58, in <module>\n    main()\n  File \"/tmp/tmpz02quhd8.py\", line 48, in main\n    intervals  = eval(m_intervals.group(1))\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n                                                    ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Insert a new interval into a list of sorted, non-overlapping intervals,\n        merging where necessary.\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Append all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Add the merged new interval\n        result.append(newInterval)\n\n        # Append the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    # Extract the two lists from the input string\n    m_intervals = re.search(r'intervals\\s*=\\s*(\\[.*\\])', data)\n    m_new      = re.search(r'newInterval\\s*=\\s*(\\[.*\\])', data)\n\n    if not m_intervals or not m_new:\n        return\n\n    intervals  = eval(m_intervals.group(1))\n    newInterval = eval(m_new.group(1))\n\n    sol = Solution()\n    result = sol.insert(intervals, newInterval)\n\n    # Print result in JSON-like format (no spaces)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code steps line by line with explanation. Problem: Insert interval into sorted non-overlapping intervals, merging as necessary.\n\nWe need steps: Start, maybe variable definitions: result array, iterate intervals, three phases: before new interval, overlap, after.\n\nWe'll produce pseudocode using decision branches. Ensure arrow notation.\n\nLet's produce lines:\n\nStart // Begin algorithm\n→ Initialize result array // empty list to store merged intervals\n→ Initialize i = 0 // index for traversal\n→ Decision: While i < len(intervals) and intervals[i].end < newInterval.start? // intervals before new\n    Yes → Append intervals[i] to result // add non-overlapping before\n    i = i + 1\n→ Decision: While i < len(intervals) and intervals[i].start <= newInterval.end? // overlapping\n    Yes → Update newInterval.start = min(newInterval.start, intervals[i].start)\n         Update newInterval.end = max(newInterval.end, intervals[i].end)\n         i = i + 1\n→ Append newInterval to result // add merged interval\n→ Decision: While i < len(intervals)?\n    Yes → Append intervals[i] to result // remaining after\n    i = i + 1\nEnd // return result\n\nBut need arrow style lines with comments. Use Yes→, No→? In our steps we use loops as decision. Use Decision with conditions, inside Yes branch do actions. Since loops need iteration, maybe treat as while decisions.\n\nWe should produce each step as a line. Provide explanation after comment.\n\nLet's craft:\n\nStart // 程式開始\n→ Initialize result = [] // 儲存最終區間\n→ Initialize i = 0 // 迭代索引\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 前段不重疊\n    Yes → Append intervals[i] to result // 加入前面不重疊的區間\n    i = i + 1\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 重疊段\n        Yes → // 合併區間\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n        No → // no more overlapping, go to append newInterval\n→ Append newInterval to result // 加入合併後的新區間\n→ Decision: i < len(intervals)? // 後段不重疊\n    Yes → Append intervals[i] to result // 加入後面不重疊的區間\n    i = i + 1\n    No → End // 完成\n\nBut we need sequential lines. Maybe better to split loops explicitly. Provide loops as Decision: while.\n\nLet's produce more formal:\n\nStart // 程式開始\n→ result = [] // 初始化結果列表\n→ i = 0 // 迭代指標\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 前段不重疊\n    Yes → Append intervals[i] to result // 加入前段區間\n    i = i + 1\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 重疊段\n        Yes → // 合併\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n        No → // 無重疊，直接後續\n→ Append newInterval to result // 加入合併後區間\n→ Decision: i < len(intervals)? // 後段不重疊\n    Yes → Append intervals[i] to result // 加入後段\n    i = i + 1\n    No → End // 結束\n\nBut we need proper loop over while. Provide repeated decision until condition false.\n\nLet's produce final pseudocode lines:\n\nStart // 程式開始\n→ result = [] // 儲存合併後的區間\n→ i = 0 // 初始化索引\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 處理前段不重疊區間\n    Yes → Append intervals[i] to result // 將前段區間加入結果\n    i = i + 1\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 處理重疊區間\n        Yes → // 合併區間\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n        No → // 無重疊，跳至後段\n→ Append newInterval to result // 加入合併後的新區間\n→ Decision: i < len(intervals)? // 處理後段不重疊區間\n    Yes → Append intervals[i] to result // 加入後段區間\n    i = i + 1\n    No → End // 程式結束\n\nBut this doesn't fully loop over all intervals before merging and after merging. Should be while loops. Provide iterative steps.\n\nLet's produce with while decisions:\n\nStart // 程式開始\n→ result = [] // 儲存結果\n→ i = 0 // 索引\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 前段不重疊\n    Yes → Append intervals[i] to result // 加入前段\n        i = i + 1\n        → Decision: (same condition again) // 迴圈\n            Yes → ...\n            No → ...\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 重疊\n        Yes → // 合併\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n            → Decision: (same overlap condition again) // 迴圈\n                Yes → ...\n                No → ...\n        No → // 跳至後段\n→ Append newInterval to result // 加入合併後\n→ Decision: i < len(intervals)? // 後段\n    Yes → Append intervals[i] to result // 加入\n        i = i + 1\n        → Decision: i < len(intervals)? // 迴圈\n            Yes → ...\n            No → ...\n    No → End\n\nBut the output format expects each line as separate; we can include loops as nested Decision: Yes→.\n\nSimplify: Provide pseudocode with loops:\n\nStart // 程式開始\n→ result = [] // 儲存結果\n→ i = 0 // 索引\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 前段不重疊\n    Yes → Append intervals[i] to result // 加入前段\n        i = i + 1\n        → Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 迴圈\n            Yes → … (repeat) ...\n            No → … // exit loop\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 重疊\n        Yes → // 合併\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n            → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 迴圈\n                Yes → … repeat …\n                No → … exit\n        No → // no overlap\n→ Append newInterval to result // 合併後加入\n→ Decision: i < len(intervals)? // 後段\n    Yes → Append intervals[i] to result // 加入\n        i = i + 1\n        → Decision: i < len(intervals)? // 迴圈\n            Yes → … repeat …\n            No → …\n    No → End\n\nThis is too many lines. The requirement: \"逐行\" but we can condense loops into steps like \"While\". They didn't forbid using While but they want arrow notation. Could use \"While i < len(intervals) and intervals[i].end < newInterval.start:\" but they want Decision.\n\nMaybe simpler: use 5 steps: Append non-overlap before, merge overlapping, append new, append remaining. But need loops inside each.\n\nLet's produce concise pseudocode:\n\nStart // 程式開始\n→ result = [] // 初始化結果\n→ i = 0 // 索引\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 前段不重疊\n    Yes → Append intervals[i] to result // 加入前段\n        i = i + 1\n        → Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 迴圈\n            Yes → ... (repeat) ...\n            No → … // exit\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 重疊\n        Yes → // 合併\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n            → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 迴圈\n                Yes → … repeat\n                No → … exit\n        No → … // no overlap\n→ Append newInterval to result // 合併後加入\n→ Decision: i < len(intervals)? // 後段不重疊\n    Yes → Append intervals[i] to result // 加入後段\n        i = i + 1\n        → Decision: i < len(intervals)? // 迴圈\n            Yes → … repeat …\n            No → … exit\n    No → End // 結束\n\nThis is verbose.\n\nMaybe acceptable but the format requires each line as \"虛擬碼步驟 [space] // 解釋\". We can have nested indent by indenting spaces? But spec not mention indent. Might just list each line sequentially.\n\nSimpler approach: Use explicit loop constructs like \"While\" as virtual steps. That is still a decision but we can label as \"While\".\n\nMaybe we can use:\n\n→ While i < len(intervals) and intervals[i].end < newInterval.start:\n    Append intervals[i] to result\n    i = i + 1\n\nBut the spec uses arrow and Decision. Might accept while loops as lines. Provide:\n\nStart // 程式開始\n→ result = [] // 儲存結果\n→ i = 0 // 索引\n→ While i < len(intervals) and intervals[i].end < newInterval.start: // 前段不重疊\n    Append intervals[i] to result\n    i = i + 1\n→ While i < len(intervals) and intervals[i].start <= newInterval.end: // 重疊段\n    newInterval.start = min(newInterval.start, intervals[i].start)\n    newInterval.end = max(newInterval.end, intervals[i].end)\n    i = i + 1\n→ Append newInterval to result // 合併後加入\n→ While i < len(intervals): // 後段不重疊\n    Append intervals[i] to result\n    i = i + 1\nEnd // 完成\n\nBut spec: use Decision with Yes→ No→. Maybe this still accepted because we use while. But they emphasise arrow, but we can use while as step. Might be okay.\n\nLet's craft final answer with each line as:\n\nStart // 程式開始\n→ result = [] // 初始化結果區間\n→ i = 0 // 設定索引為 0\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 前段不重疊\n    Yes → Append intervals[i] to result // 將前段加入結果\n        i = i + 1\n        → Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 迴圈\n            Yes → … repeat …\n            No → … exit …\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 重疊段\n        Yes → // 合併區間\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n            → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 迴圈\n                Yes → … repeat …\n                No → … exit …\n        No → … // no overlap\n→ Append newInterval to result // 將合併後的新區間加入結果\n→ Decision: i < len(intervals)? // 後段不重疊\n    Yes → Append intervals[i] to result // 加入後段區間\n        i = i + 1\n        → Decision: i < len(intervals)? // 迴圈\n            Yes → … repeat …\n            No → … exit …\n    No → End // 完成\n\nBut too many ellipses. Might not be acceptable. Let's produce concise final pseudocode with loops as while.\n\nI'll produce:\n\nStart // 程式開始\n→ result = [] // 儲存最終區間\n→ i = 0 // 設定迭代指標\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 前段不重疊\n    Yes → Append intervals[i] to result // 加入前段\n        i = i + 1\n        → Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 迴圈\n            Yes → ... repeat\n            No → ...\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 重疊\n        Yes → // 合併\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n            → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 迴圈\n                Yes → ... repeat\n                No → ...\n        No → ...\n→ Append newInterval to result // 加入合併後區間\n→ Decision: i < len(intervals)? // 後段不重疊\n    Yes → Append intervals[i] to result // 加入後段\n        i = i + 1\n        → Decision: i < len(intervals)? // 迴圈\n            Yes → ... repeat\n            No → ...\n    No → End\n\nBut maybe the expected answer is simpler.\n\nLet's produce final answer using while loops but with clear explanations.\n\nWe'll output each line exactly as spec: \"虛擬碼步驟 [space] // 解釋\".\n\nLet's write:\n\nStart // 程式開始\n→ result = [] // 初始化結果區間列表\n→ i = 0 // 設定索引為 0\n→ While i < len(intervals) and intervals[i].end < newInterval.start: // 處理前段不重疊區間\n    Append intervals[i] to result // 加入前段區間\n    i = i + 1\n→ While i < len(intervals) and intervals[i].start <= newInterval.end: // 處理重疊區間\n    newInterval.start = min(newInterval.start, intervals[i].start) // 合併起始點\n    newInterval.end = max(newInterval.end, intervals[i].end) // 合併結束點\n    i = i + 1\n→ Append newInterval to result // 加入合併後的新區間\n→ While i < len(intervals): // 處理後段不重疊區間\n    Append intervals[i] to result // 加入後段區間\n    i = i + 1\nEnd // 程式結束\n\nBut we need arrow '→' before each line, except maybe Start and End? They didn't specify, but earlier example used 'Start' and 'End' as separate lines. So we can keep them same.\n\nWe need to put '→' before 'While' lines, and 'Append' lines etc. The 'While' line ends with colon in some pseudocode, but we can keep.\n\nWe need each line separate.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始\n→ result = [] // 初始化結果區間列表\n→ i = 0 // 設定索引為 0\n→ While i < len(intervals) and intervals[i].end < newInterval.start: // 處理前段不重疊區間\n    Append intervals[i] to result // 加入前段區間\n    i = i + 1\n→ While i < len(intervals) and intervals[i].start <= newInterval.end: // 處理重疊區間\n    newInterval.start = min(newInterval.start, intervals[i].start) // 合併起始點\n    newInterval.end = max(newInterval.end, intervals[i].end) // 合併結束點\n    i = i + 1\n→ Append newInterval to result // 加入合併後的新區間\n→ While i < len(intervals): // 處理後段不重疊區間\n    Append intervals[i] to result // 加入後段區間\n    i = i + 1\nEnd // 程式結束"
    },
    {
      "title": "Intersection of Two Arrays II",
      "source_file": "Leetcode/leetcode350.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[4,9]'\nGot (Norm):      '[9,4]'\n--- (Raw) ---\nRaw Expected: '[4,9]'\nRaw Got:      '[9, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        # 建立 nums1 每個元素的頻率字典\n        freq = Counter(nums1)\n        result = []\n\n        # 遍歷 nums2，若 freq 內仍有該元素，加入結果並遞減頻率\n        for num in nums2:\n            if freq.get(num, 0) > 0:\n                result.append(num)\n                freq[num] -= 1\n\n        return result\n\ndef parse_input(text):\n    \"\"\"\n    從輸入文字中擷取兩個列表。\n    例：'nums1 = [1,2,2,1], nums2 = [2,2]' 會回傳 ([1,2,2,1], [2,2])\n    \"\"\"\n    # 找出兩個方括號內的子字串\n    brackets = re.findall(r'\\[.*?\\]', text)\n    if len(brackets) != 2:\n        raise ValueError(\"輸入格式不正確，無法找到兩個列表。\")\n    nums1 = ast.literal_eval(brackets[0])\n    nums2 = ast.literal_eval(brackets[1])\n    return nums1, nums2\n\ndef main():\n    # 讀取標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    nums1, nums2 = parse_input(raw_input)\n\n    solution = Solution()\n    intersection = solution.intersect(nums1, nums2)\n\n    # 輸出結果\n    print(intersection)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step with explanations. Use arrow lines, Start, End, Decision.\n\nWe need to solve intersection of two integer arrays with duplicates count. Steps: Build frequency map of nums1, iterate nums2, reduce count, collect result.\n\nWe should produce each line of virtual code, e.g., Start, then Step 1: Build frequency map for nums1. Use Map/Hash. Then Step 2: Iterate nums2, check if element in map > 0, then add to result and decrement. Then End.\n\nNeed to use arrows: →, Decision: ... Yes→ etc.\n\nLet's produce virtual code accordingly. Use 'Step X: ...' format. Provide explanation after //. Should be one line per step. Include decisions? For checking if element exists. Provide Decision line.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化一個空字典 freq // 用於存放 nums1 中每個數字的出現次數\n→ Step 2: 對 nums1 的每個元素 val\n    → Decision: 是否已在 freq? // 檢查字典中是否已有此鍵\n        Yes → freq[val] = freq[val] + 1 // 已有，次數加一\n        No  → freq[val] = 1           // 沒有，新增鍵並設為 1\n→ Step 3: 初始化空列表 result // 用於儲存交集元素\n→ Step 4: 對 nums2 的每個元素 val\n    → Decision: freq[val] > 0? // 檢查該元素在 nums1 中是否還有剩餘\n        Yes → result.add(val) // 添加到結果\n              freq[val] = freq[val] - 1 // 次數減一\n        No  → // 跳過，該元素不在交集中\n→ End\n\nWe need to use arrow indentation maybe? In example, they used indentation for nested decisions. Provide that. Each line must be a single line with arrow and step. But nested lines maybe considered separate lines? They had indentation with arrows: \n```\nDecision: ...\n    Yes → Step ...\n    No → Decision: ...\n```\nThus we should produce similar structure: Indent nested lines. Use spaces before arrows for clarity.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 freq // 用來記錄 nums1 中每個數字出現的次數  \n→ Step 2: 對 nums1 的每個元素 val  \n    → Decision: freq 中是否已存在 key val? // 檢查此數字是否已被統計  \n        Yes → freq[val] = freq[val] + 1 // 已存在，次數加一  \n        No  → freq[val] = 1           // 未存在，新增鍵並設為 1  \n→ Step 3: 初始化空列表 result // 用來儲存最終的交集元素  \n→ Step 4: 對 nums2 的每個元素 val  \n    → Decision: freq[val] > 0? // 判斷 nums1 中是否還有此數字可用  \n        Yes → result.add(val)        // 加入交集  \n              freq[val] = freq[val] - 1 // 次數減一，避免重複使用  \n        No  → // 此數字不在交集中，跳過  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i - 1][0] <= left and right <= self.ranges[i - 1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef fmt(val):\n    if val is None:\n        return 'null'\n    if val is True:\n        return 'true'\n    if val is False:\n        return 'false'\n    return str(val)\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    obj = None\n    outputs = []\n\n    for line in lines:\n        if line.endswith(';'):\n            line = line[:-1]\n        # Skip empty lines\n        if not line:\n            continue\n\n        # Initialization\n        if line.startswith('RangeModule'):\n            obj = RangeModule()\n            outputs.append(None)\n            continue\n\n        # Method call\n        if obj is None:\n            # No object created yet; skip\n            continue\n\n        try:\n            before_dot, after_dot = line.split('.', 1)\n            method, args_part = after_dot.split('(', 1)\n            args_part = args_part.rstrip(')')\n            args = [int(a.strip()) for a in args_part.split(',')] if args_part else []\n        except ValueError:\n            continue  # Malformed line\n\n        if method == 'addRange':\n            obj.addRange(*args)\n            outputs.append(None)\n        elif method == 'removeRange':\n            obj.removeRange(*args)\n            outputs.append(None)\n        elif method == 'queryRange':\n            res = obj.queryRange(*args)\n            outputs.append(res)\n        else:\n            # Unknown method; ignore\n            continue\n\n    print('[' + ', '.join(fmt(v) for v in outputs) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for RangeModule with add, query, remove. Probably using interval tree, or sorted list. We'll output step-by-step logic. Probably use TreeMap to store intervals. Use pseudo-code for operations. Let's produce steps.\n...done thinking.\n\nStart // 初始化程式\n→ Step 1: 初始化空有序區間集合 intervals // 以左端點排序，存放已追蹤的 [l, r) 區間\n→ Step 2: 定義函式 addRange(left, right) // 新增區間\n    → Decision: 若 left >= right? // 檢查區間合法性\n        Yes → End // 無效區間，直接結束\n        No  →\n            → Step 3: 找到 intervals 中第一個左端點大於等於 left 的區間 indexStart\n            → Step 4: 從 indexStart 開始向前遍歷，合併任何與 [left, right) 重疊或相連的區間\n                → Decision: 若 intervals[i].right < left? // 與 left 不相連\n                    Yes → Break // 跳出迴圈\n                    No  →\n                        → Step 5: 更新 left = min(left, intervals[i].left)\n                        → Step 6: 更新 right = max(right, intervals[i].right)\n                        → Step 7: 刪除 intervals[i] // 已被合併\n            → Step 8: 插入新合併後的區間 [left, right) 到 intervals\n→ Step 9: 定義函式 queryRange(left, right) // 查詢區間\n    → Decision: 若 left >= right? // 檢查合法性\n        Yes → Return True // 空區間總是被追蹤\n        No  →\n            → Step 10: 找到 intervals 中左端點最接近但小於等於 left 的區間 index\n            → Decision: 若 index 為不存在? 或 intervals[index].right < right? // 沒有足夠覆蓋\n                Yes → Return False\n                No  → Return True\n→ Step 11: 定義函式 removeRange(left, right) // 刪除區間\n    → Decision: 若 left >= right? // 檢查合法性\n        Yes → End // 無效區間，直接結束\n        No  →\n            → Step 12: 找到 intervals 中第一個左端點大於等於 left 的區間 indexStart\n            → Step 13: 從 indexStart 向前遍歷，處理與 [left, right) 重疊的區間\n                → Decision: 若 intervals[i].right <= left? // 與左邊不重疊\n                    Yes → Continue // 跳過\n                    No  →\n                        → Step 14: 若 intervals[i].left < left? // 区间左端在左侧\n                            → Step 15: 插入新的區間 [intervals[i].left, left)\n                        → Step 16: 若 intervals[i].right > right? // 区间右端在右侧\n                            → Step 17: 插入新的區間 [right, intervals[i].right)\n                        → Step 18: 刪除 intervals[i] // 已被截斷或完全移除\n            → Step 19: 完成刪除操作\nEnd // 程式結束\n\nExplanation of key steps:\n- intervals 以左端點排序，可用 BST 或有序陣列存放，方便搜尋重疊區間。\n- addRange 合併所有相交或相連的區間，確保 intervals 始終保持非重疊、非連續。\n- queryRange 只需檢查一個區間是否足以覆蓋查詢區間即可。\n- removeRange 切斷或拆分重疊區間，維持 intervals 的完整性。"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpghu6va2v.py\", line 62, in <module>\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k          # 資料儲存區\n        self.head = 0               # 指向前端位置\n        self.count = 0              # 目前元素個數\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:     # 檢查是否已滿\n            return False\n        self.head = (self.head - 1) % self.k   # 往前移動 head\n        self.buf[self.head] = value            # 放入新值\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k  # 計算插入位置\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k   # 移動 head\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1                         # 只需減少計數，插入時會依照 count 重新定位\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    obj = None\n    output = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(arg[0])\n            output.append(None)                     # constructor -> null\n        elif op == \"insertFront\":\n            output.append(obj.insertFront(arg[0]))\n        elif op == \"insertLast\":\n            output.append(obj.insertLast(arg[0]))\n        elif op == \"deleteFront\":\n            output.append(obj.deleteFront())\n        elif op == \"deleteLast\":\n            output.append(obj.deleteLast())\n        elif op == \"getFront\":\n            output.append(obj.getFront())\n        elif op == \"getRear\":\n            output.append(obj.getRear())\n        elif op == \"isEmpty\":\n            output.append(obj.isEmpty())\n        elif op == \"isFull\":\n            output.append(obj.isFull())\n        else:\n            # 不支援的操作，略過\n            output.append(None)\n\n    print(json.dumps(output))",
      "virtual_code": "Thinking...\nWe need to output virtual code steps, each line with \"虛擬碼步驟\" and \"// 解釋\" and use arrows, Start, End, Decision. The requirement: \"逐行地產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋\". So each line: e.g., \"Start // 程式開始執行\". Use the arrow arrow notation. Need to design implementation of MyCircularDeque. We need to cover initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. The virtual code should illustrate logic. Use steps: Start, Decision, etc. We can outline the structure: Start -> Step 1: Initialize array of size k and head, tail pointers -> Decision: check if full etc. Then insertFront: check isFull? If no, adjust head pointer etc. For each method, we can write as separate functions.\n\nThe virtual code likely should be top-level pseudo algorithm: Start, define class, then methods.\n\nWe need to output each line with arrow arrow? It says \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\". So we should use arrows to indicate flow.\n\nLet's produce something like:\n\nStart // 程式開始\n→ Step 1: 定義 MyCircularDeque 類 // 定義類別\n→ Step 2: 建立容量為 k 的陣列 buffer // 初始化儲存\n→ Step 3: 初始化 head = 0, tail = 0, size = 0 // 初始化指標\n→ Decision: 之後可根據需求執行不同方法\n\nThen we can outline each method:\n\n→ Method insertFront(value) // 方法開始\n    → Decision: 如果 isFull? // 檢查是否已滿\n        Yes → Return false // 已滿則失敗\n        No  → head = (head - 1 + k) % k // 往前移動 head\n             → buffer[head] = value // 存入值\n             → size++ // 大小加一\n             → Return true // 成功\n→ Method insertLast(value)\n    … similarly\n\nWe need to produce each line separately. Use \"Step\" maybe with number. Use \"Decision:\" lines with Yes → and No →. Use \"End\" at end of each method? Probably not necessary but can include. They didn't say to wrap each method in Start/End, but we can.\n\nWe should ensure each line has \"虛擬碼步驟\" then space then \"// 解釋\". So we need to keep consistent. Use \"Start\" line first. Then \"→\" lines.\n\nLet's produce. We'll treat each method as separate block, but within we use arrows.\n\nAlso need to mention getFront: return buffer[head] if size>0 else -1. getRear: compute index (tail-1+k)%k.\n\nImplement isEmpty: size==0. isFull: size==k.\n\nLet's produce the virtual code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCircularDeque 類 // 建立類別容器  \n→ Step 2: 建立容量為 k 的陣列 buffer // 用於儲存元素  \n→ Step 3: 初始化 head = 0, tail = 0, size = 0 // 指標與計數器  \n→ Decision: 之後可呼叫各個方法進行操作 // 接下來執行具體方法  \n\n// ---------- insertFront ----------\n→ Method insertFront(value) // 開始 insertFront 方法  \n    → Decision: 如果 isFull()? // 檢查是否已滿  \n        Yes → Return false // 已滿則插入失敗  \n        No  → head = (head - 1 + k) % k // head 往前移動  \n             → buffer[head] = value // 存入新值  \n             → size++ // 大小 +1  \n             → Return true // 插入成功  \n→ End // insertFront 方法結束  \n\n// ---------- insertLast ----------\n→ Method insertLast(value) // 開始 insertLast 方法  \n    → Decision: 如果 isFull()? // 檢查是否已滿  \n        Yes → Return false // 已滿則插入失敗  \n        No  → buffer[tail] = value // 存入新值  \n             → tail = (tail + 1) % k // tail 往後移動  \n             → size++ // 大小 +1  \n             → Return true // 插入成功  \n→ End // insertLast 方法結束  \n\n// ---------- deleteFront ----------\n→ Method deleteFront() // 開始 deleteFront 方法  \n    → Decision: 如果 isEmpty()? // 檢查是否為空  \n        Yes → Return false // 空則刪除失敗  \n        No  → head = (head + 1) % k // head 往後移動  \n             → size-- // 大小 -1  \n             → Return true // 刪除成功  \n→ End // deleteFront 方法結束  \n\n// ---------- deleteLast ----------\n→ Method deleteLast() // 開始 deleteLast 方法  \n    → Decision: 如果 isEmpty()? // 檢查是否為空  \n        Yes → Return false // 空則刪除失敗  \n        No  → tail = (tail - 1 + k) % k // tail 往前移動  \n             → size-- // 大小 -1  \n             → Return true // 刪除成功  \n→ End // deleteLast 方法結束  \n\n// ---------- getFront ----------\n→ Method getFront() // 開始 getFront 方法  \n    → Decision: 如果 isEmpty()? // 檢查是否為空  \n        Yes → Return -1 // 空則返回 -1  \n        No  → Return buffer[head] // 返回前端值  \n→ End // getFront 方法結束  \n\n// ---------- getRear ----------\n→ Method getRear() // 開始 getRear 方法  \n    → Decision: 如果 isEmpty()? // 檢查是否為空  \n        Yes → Return -1 // 空則返回 -1  \n        No  → rearIndex = (tail - 1 + k) % k // 計算後端指標  \n             → Return buffer[rearIndex] // 返回後端值  \n→ End // getRear 方法結束  \n\n// ---------- isEmpty ----------\n→ Method isEmpty() // 開始 isEmpty 方法  \n    → Return size == 0 // 若大小為 0 則為空  \n→ End // isEmpty 方法結束  \n\n// ---------- isFull ----------\n→ Method isFull() // 開始 isFull 方法  \n    → Return size == k // 若大小等於容量則為滿  \n→ End // isFull 方法結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        content_map = defaultdict(list)\n        for path in paths:\n            parts = path.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content[:-1]  # 去掉末尾的 ')'\n                content_map[content].append(f\"{root}/{name}\")\n        return [files for files in content_map.values() if len(files) > 1]\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 允許輸入形如: paths = [\"root/a 1.txt(abcd) ...\"]\n    if raw_input.startswith('paths'):\n        _, rest = raw_input.split('=', 1)\n        raw_input = rest.strip()\n    # 解析列表字面量\n    try:\n        paths = ast.literal_eval(raw_input)\n    except Exception:\n        paths = eval(raw_input, {})\n    solution = Solution()\n    result = solution.findDuplicate(paths)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines for algorithm: given list of directory strings, parse, map content->list of file paths, then collect groups with size>1. Use steps: Start, for each dirInfo string, split by space, first part is path, rest are fileInfo. For each fileInfo, parse name(content). Build full path. Use map. Then after all, iterate map and collect groups with >1. Output list. End.\n\nReturn groups.\n\nMake sure to use the arrow notation. Let's produce lines. Use Start, End, Decision, etc.\n\nLet's craft:\n\nStart // begin\n→ Step 1: 初始化 map<string, list<string>> contentToPaths // 存储内容到路径列表\n→ For each dirInfo in paths: // 遍历每个目录信息字符串\n    → Step 2: 將 dirInfo 以空格分割為 parts // 将字符串拆分为目录路径和文件信息\n    → Step 3: 取 parts[0] 作為 dirPath // 目录路径\n    → For each fileInfo in parts[1:]: // 处理每个文件\n        → Step 4: 找到 '(' 前的文件名 → filename // 取得文件名\n        → Step 5: 找到 '(' 后和 ')' 之间的内容 → fileContent // 取得文件内容\n        → Step 6: 拼接 fullPath = dirPath + \"/\" + filename // 完整文件路径\n        → Step 7: 如果 contentToPaths 没有 fileContent 键，則初始化空列表 // 创建键\n        → Step 8: 把 fullPath 加入 contentToPaths[fileContent] // 记录路径\n→ Decision: 是否存在内容对应的路径列表长度大于 1? // 检查是否有重复\n    Yes → Step 9: 创建结果列表 result = [] // 初始化结果\n    → For each key, pathsList in contentToPaths:\n        → Decision: 如果 pathsList 长度 > 1? // 只取重复组\n            Yes → Step 10: 把 pathsList 加入 result // 收集重复组\n        → No → 继续 // 跳过单个文件\n    → Step 11: 返回 result // 输出重复文件路径组\n    No → Step 12: 返回空列表 // 没有重复文件\nEnd // 程序结束\n\nNeed to ensure each line with arrow, explanation comment. Use proper indentation? Might use indentation in comments but not necessary. Use arrows per step.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 map contentToPaths 為字典 (內容 → 其相關檔案路徑列表) // 用於儲存每個內容對應的所有檔案路徑  \n→ For each dirInfo in paths: // 逐一處理輸入的每條目錄資訊  \n → Step 2: 將 dirInfo 以空格切割為 parts // 將字串拆成「目錄路徑」與「檔案資訊」  \n → Step 3: 取 parts[0] 作為 dirPath // 取得此條目所屬的目錄路徑  \n → For each fileInfo in parts[1:]: // 處理此目錄下的每個檔案資訊  \n  → Step 4: 找到 '(' 前的文字作為 filename // 取得檔名（例如 \"f1.txt\"）  \n  → Step 5: 找到 '(' 後到 ')' 之間的文字作為 fileContent // 取得檔案內容（例如 \"f1_content\"）  \n  → Step 6: 以 dirPath + \"/\" + filename 組成 fullPath // 完整檔案路徑  \n  → Step 7: 若 contentToPaths 沒有 key fileContent，則新增空列表 // 建立內容對應的列表  \n  → Step 8: 把 fullPath 加入 contentToPaths[fileContent] // 記錄此檔案路徑  \n→ Decision: 是否存在 contentToPaths 中任意鍵對應的列表長度 > 1? // 判斷是否有重複檔案  \n Yes → Step 9: 初始化 result 為空列表 // 用於儲存所有重複檔案的路徑組  \n  → For each key, pathsList in contentToPaths: // 遍歷所有內容對應的路徑列表  \n   Decision: pathsList 長度 > 1? // 只保留重複的組別  \n    Yes → Step 10: 把 pathsList 加入 result // 收集重複檔案路徑組  \n    No → 直接跳過 // 單一檔案不算重複  \n  → Step 11: 回傳 result // 輸出所有重複檔案的路徑組  \n No → Step 12: 回傳空列表 // 沒有任何重複檔案  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Trie (Prefix Tree)",
      "source_file": "Leetcode/leetcode208.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvf7x_enb.py\", line 77, in <module>\n    main()\n  File \"/tmp/tmpvf7x_enb.py\", line 63, in main\n    trie.insert(arg[0])\n    ^^^^^^^^^^^\nAttributeError: 'NoneType' object has no attribute 'insert'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass TrieNode:\n    \"\"\"Trie 树的節點。\"\"\"\n    def __init__(self):\n        # 儲存子節點的字典，key 為字元，value 為 TrieNode\n        self.children = {}\n        # 標記此節點是否為單字結束的位置\n        self.is_end = False\n\nclass Trie:\n    \"\"\"前綴樹實作。\"\"\"\n    def __init__(self):\n        # 根節點不代表任何字元\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        \"\"\"將單字插入前綴樹。\"\"\"\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        \"\"\"若前綴樹中存在完整單字 word，則回傳 True。\"\"\"\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        \"\"\"若前綴樹中存在至少一個單字以 prefix 為前綴，則回傳 True。\"\"\"\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 把兩個 list 包裝成 tuple 方便 literal_eval 解析\n    try:\n        ops, args = ast.literal_eval(f\"({data})\")\n    except Exception as e:\n        print(f\"Input format error: {e}\")\n        return\n\n    trie = None\n    results = [None]  # 第一次建構 Trie 會回傳 null\n\n    for op, arg in zip(ops[1:], args[1:]):  # 跳過第一個 'Trie' 操作\n        if op == 'insert':\n            trie.insert(arg[0])\n            results.append(None)\n        elif op == 'search':\n            results.append(trie.search(arg[0]))\n        elif op == 'startsWith':\n            results.append(trie.startsWith(arg[0]))\n        else:\n            # 如有其他操作可在此處擴充\n            results.append(None)\n\n    # 使用 json.dumps 以符合題目示例輸出格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, with explanation after space. Need to generate steps for Trie class with methods: constructor, insert, search, startsWith. Provide algorithm steps. Use arrow structure. Let's produce pseudocode: Start, initialize root node, node structure: map children, end flag. Then each method: insert: iterate chars, add nodes, mark end. search: iterate, check, return flag. startsWith: iterate, return true if prefix found. End. Use Decision nodes for checking. Let's produce.\n\nMake sure to follow format: each line \"虛擬碼步驟 // 解釋\" with spaces.\n\nLet's do.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Node 類型，包含 children 映射和 isEnd 布林值 // 建立節點結構  \n→ Step 2: Trie() ← new Node() // 初始化 Trie，根節點不代表任何字元  \n→ Step 3: insert(word) // 開始插入單字  \n  → Decision: word 是否為空? // 空字元不插入  \n    Yes → Return // 結束插入  \n    No  → Step 4: current ← root // 從根節點開始  \n      → For 每個字元 c in word: // 逐字元遍歷  \n        Decision: current.children 中是否存在 c? // 字元已存在？  \n         Yes → current ← current.children[c] // 跳到已存在節點  \n         No  → current.children[c] ← new Node() // 新增節點  \n            → current ← current.children[c] // 進入新節點  \n            → Continue // 繼續下一個字元  \n            → End For  \n      → current.isEnd ← true // 標記單字結束位置  \n→ Step 5: search(word) // 查找完整單字  \n  → Decision: word 是否為空? // 空字串不可能存在  \n    Yes → Return false // 返回 false  \n    No  → Step 6: current ← root // 從根節點開始  \n      → For 每個字元 c in word: // 逐字元遍歷  \n        Decision: current.children 中是否存在 c? // 字元存在？  \n         Yes → current ← current.children[c] // 跳到下一節點  \n         No  → Return false // 找不到字元，單字不存在  \n            → End For  \n      → Decision: current.isEnd? // 目前節點是否標記為單字結束  \n        Yes → Return true // 單字存在  \n        No  → Return false // 只是前綴，非完整單字  \n→ Step 7: startsWith(prefix) // 判斷前綴是否存在  \n  → Decision: prefix 是否為空? // 空前綴即始終為 true  \n    Yes → Return true  \n    No  → Step 8: current ← root // 從根節點開始  \n      → For 每個字元 c in prefix: // 逐字元遍歷  \n        Decision: current.children 中是否存在 c? // 字元存在？  \n         Yes → current ← current.children[c] // 前進到下一節點  \n         No  → Return false // 前綴不存在  \n            → End For  \n      → Return true // 所有字元皆存在，前綴成立  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[7]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[7]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[5,4]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[5, 4]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[9,9,10]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[9, 9, 10]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport re\n\n# API: generate a uniform random integer in [1, 7]\ndef rand7() -> int:\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        Generate a uniform random integer in [1, 10] using only rand7().\n        \"\"\"\n        while True:\n            # Combine two rand7 calls to get a uniform range [1, 49]\n            num = (rand7() - 1) * 7 + rand7()\n            # Accept only the first 40 values (40 is divisible by 10)\n            if num <= 40:\n                # Map 1~40 to 1~10\n                return 1 + (num - 1) % 10\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, generate n rand10 values, and print them.\n    Expected input format: \"n = X\" where X is an integer.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    match = re.search(r'(\\d+)', data)\n    if not match:\n        return\n    n = int(match.group(1))\n\n    solver = Solution()\n    results = [solver.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for generating rand10 from rand7. Classic solution: use two rand7 to create a range 1-49; if <=40, use (value-1)%10+1; else reject and repeat. Or use 7*7*7? But simple is fine. Must output step-by-step lines with virtual code arrow. Each line: 虛擬碼步驟 + // 解釋. Use Start, Decision, etc. Should include loops. Provide explanation for each line. Let's create:\n\nStart\n→ Step 1: repeat loop // 重複生成隨機數直到得到合法範圍\n    → Step 2: r1 ← rand7() // 生成第一個 1-7\n    → Step 3: r2 ← rand7() // 生成第二個 1-7\n    → Step 4: val ← (r1 - 1) * 7 + r2 // 將兩個數合併為 1-49\n    → Decision: 如果 val ≤ 40? // 只接受前40個數\n        Yes → Step 5: result ← (val - 1) mod 10 + 1 // 轉換為 1-10\n        Yes → Step 6: return result // 回傳隨機數\n        No  → Step 7: // 如果 val > 40，重新進入循環\nEnd\n\nAlso we might mention rejection step.\n\nLet's write accordingly. Use proper formatting.\n\nNeed each line with 虛擬碼步驟 + space + // explanation. Use arrow symbols: →, Yes →, No →. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: repeat loop // 重複生成隨機數直到得到合法範圍  \n    → Step 2: r1 ← rand7() // 產生第一個 1~7 的隨機數  \n    → Step 3: r2 ← rand7() // 產生第二個 1~7 的隨機數  \n    → Step 4: val ← (r1 - 1) * 7 + r2 // 將兩個隨機數合併成 1~49 的值  \n    → Decision: 如果 val ≤ 40? // 只接受前 40 個數（40 能被 10 整除）  \n        Yes → Step 5: result ← (val - 1) mod 10 + 1 // 將 1~40 映射為 1~10  \n        Yes → Step 6: return result // 回傳生成的 rand10 數值  \n        No  → Step 7: // val > 40 時丟棄，重新進入循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7zxd78ai.py\", line 36, in parse_input\n    data_dict = eval(dict_str, {})\n                ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'price' is not defined. Did you mean: 'print'?\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp7zxd78ai.py\", line 54, in <module>\n    parsed = parse_input()\n             ^^^^^^^^^^^^^\n  File \"/tmp/tmp7zxd78ai.py\", line 43, in parse_input\n    re.search(r'price\\s*=\\s*(\\[[^\\]]*\\])', data).group(1)\n    ^^\nNameError: name 're' is not defined. Did you forget to import 're'?"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpw2k9aej_.py\", line 36, in parse_input\n    data_dict = eval(dict_str, {})\n                ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'price' is not defined. Did you mean: 'print'?\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpw2k9aej_.py\", line 54, in <module>\n    parsed = parse_input()\n             ^^^^^^^^^^^^^\n  File \"/tmp/tmpw2k9aej_.py\", line 43, in parse_input\n    re.search(r'price\\s*=\\s*(\\[[^\\]]*\\])', data).group(1)\n    ^^\nNameError: name 're' is not defined. Did you forget to import 're'?"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # cost without any special offers\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            for offer in special:\n                # check if the offer can be applied\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef parse_input():\n    data = sys.stdin.read().strip()\n    if not data:\n        return None\n    # Try to convert the input into a dictionary string\n    try:\n        dict_str = '{' + data.replace('=', ':') + '}'\n        data_dict = eval(dict_str, {})\n        price = data_dict['price']\n        special = data_dict['special']\n        needs = data_dict['needs']\n    except Exception:\n        # Fallback: use regex extraction\n        price = ast.literal_eval(\n            re.search(r'price\\s*=\\s*(\\[[^\\]]*\\])', data).group(1)\n        )\n        special = ast.literal_eval(\n            re.search(r'special\\s*=\\s*(\\[[^\\]]*\\])', data).group(1)\n        )\n        needs = ast.literal_eval(\n            re.search(r'needs\\s*=\\s*(\\[[^\\]]*\\])', data).group(1)\n        )\n    return price, special, needs\n\nif __name__ == \"__main__\":\n    parsed = parse_input()\n    if parsed:\n        price, special, needs = parsed\n        sol = Solution()\n        result = sol.shoppingOffers(price, special, needs)\n        print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code steps for solving this LeetCode problem: \"Shopping Offers\" typical DP/backtracking with memo. We'll produce virtual code step-by-step with explanation. Use Start, Decision, End. Provide each line with arrow and comment. Should reflect algorithm: recursive function dfs(needs) returns min cost, use memo map. For each offer, check if can apply (needs >= offer counts), if yes, recursively compute cost of needs-usage + offer price. Also compute cost of buying remaining items at full price. Use loops.\n\nWe'll produce steps sequentially.\n\nNeed to mention data structures: price array, special offers list, needs array, memo map keyed by tuple of needs.\n\nWill provide steps: Start, Define function solve, initialize memo, call dfs(needs), return result, End.\n\nIn dfs: compute key from needs; if in memo return. Compute minCost = sum(need_i * price_i). For each offer: check if offer applicable: for all i need >= offer[i]; if yes: newNeeds = need_i - offer_i; cost = dfs(newNeeds)+offer_price; update minCost. After loop, memo[key] = minCost; return minCost.\n\nWill produce line-by-line. Use arrows to indicate transitions.\n\nWe will not output actual code, just pseudocode lines with comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義價格陣列 price, 需求陣列 needs, 特別優惠陣列 special // 取得問題輸入  \n→ Step 2: 初始化快取 Map memo // 用於記錄已計算過的需求組合  \n→ Step 3: 呼叫 dfs(needs) 並回傳結果 // 進行深度優先搜索求最低價格  \n→ End // 程式執行結束  \n\n---  \n\nStart // 定義遞迴函式 dfs  \n→ Step 4: Function dfs(currentNeeds)  \n→ Step 5: 生成 key = currentNeeds 轉成字串 // 用於快取索引  \n→ Step 6: Decision: key 是否在 memo?  \n  Yes → Step 7: 回傳 memo[key] // 快取命中，直接回傳  \n  No  → Step 8: 計算不使用優惠時的價格  \n    → Step 9: baseCost = Σ currentNeeds[i] * price[i] // 逐項單價相加  \n→ Step 10: 初始化 minCost = baseCost // 目前已知的最低價格  \n→ Step 11: 迭代每個 offer in special  \n→ Step 12: Decision: 是否可以套用此 offer（對所有 i: currentNeeds[i] >= offer[i]）  \n  Yes → Step 13: 計算 newNeeds[i] = currentNeeds[i] - offer[i] for 所有項目  \n    → Step 14: cost = dfs(newNeeds) + offer[最後一個元素] // 套用優惠後遞迴求價  \n    → Step 15: Decision: cost 是否小於 minCost  \n      Yes → Step 16: minCost = cost // 更新最低價格  \n  No  → Step 17: 跳過此 offer // 無法套用，繼續下一個  \n→ Step 18: memo[key] = minCost // 記錄快取  \n→ Step 19: 回傳 minCost // 結束此遞迴層  \n→ End // dfs 函式結束  \n\n---  \n\nStart // 程式執行結束  \n→ End // 完成所有步驟，輸出最終最低價格"
    },
    {
      "title": "Time Based Key-Value Store",
      "source_file": "Leetcode/leetcode981.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1v4yc6n9.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmp1v4yc6n9.py\", line 34, in main\n    ops, params = json.loads(raw)\n                  ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 54 (char 53)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport bisect\nfrom collections import defaultdict\n\nclass TimeMap:\n    def __init__(self):\n        # 每個 key 對應一個時間戳與值的列表，保持時間遞增順序\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        # 直接把 (timestamp, value) 加入列表，列表已經是遞增的\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        # 若 key 未存在，直接回傳空字串\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # bisect_right 在 (timestamp, chr(127)) 位置找右側插入點\n        # chr(127) 保證比任何字串都大，找到第一個 > timestamp 的位置\n        idx = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if idx == 0:\n            return \"\"\n        # 回傳最接近但不超過 timestamp 的值\n        return arr[idx - 1][1]\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 解析成兩個列表：操作名與對應參數\n    ops, params = json.loads(raw)\n    results = []\n    obj = None\n\n    for op, p in zip(ops, params):\n        if op == \"TimeMap\":\n            obj = TimeMap()\n            results.append(None)          # constructor 返回 null\n        elif op == \"set\":\n            obj.set(*p)                   # 參數為 [key, value, timestamp]\n            results.append(None)          # set 返回 null\n        elif op == \"get\":\n            res = obj.get(*p)             # 參數為 [key, timestamp]\n            results.append(res)\n        else:\n            # 若遇到未知操作，仍加入 None 以保持輸出長度\n            results.append(None)\n\n    # 輸出為 JSON 以符合題目期望的格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Virtual code includes arrows, decision nodes, Start, End. We need to design a TimeMap data structure. Steps: initialize map of key to list of (timestamp, value). Set: append to list. Get: binary search for largest timestamp <= given. If not found return \"\". So virtual steps. Probably start, Step 1: initialize data structure. Then operations set/get. We'll produce generic pseudocode for each method.\n\nWe must output line by line: each line \"虛擬碼步驟 // 解釋\". Use arrow arrows, decisions.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立一個全域資料結構 map // 用於存放 key -> (timestamp, value) 清單\n→ Decision: 有無使用者請求? // 判斷是否收到 set 或 get 指令\n    Yes → Step 2: 讀取指令類型 (set/get) // 從輸入取得操作類別\n    No  → End // 無操作，結束\n→ Decision: 指令為 set? // 判斷要進行哪種操作\n    Yes → Step 3: 取得 key, value, timestamp // 從參數中提取值\n    → Step 4: 若 map 不包含 key, 則初始化空清單 // 確保 key 有資料結構\n    → Step 5: 將 (timestamp, value) 加入 key 對應清單末尾 // 保持時間遞增順序\n    No  → Decision: 指令為 get? // 若不是 set，則是 get\n        Yes → Step 6: 取得 key, timestamp // 讀取查詢參數\n        → Step 7: 若 map 不包含 key, 立即回傳 \"\" // 沒有任何存儲\n        → Step 8: 取得 key 對應清單 L // 讀取該 key 的時間序列\n        → Decision: L 為空? // 檢查是否有任何時間戳\n            Yes → Step 9: 回傳 \"\" // 無資料\n            No  → Step 10: 執行二分搜尋以找到最大 ≤ timestamp 的索引 // 找到合適的時間點\n            → Decision: 找到有效索引? // 確認是否存在合法的時間戳\n                Yes → Step 11: 取得該索引對應的 value 並回傳 // 返回最近的值\n                No  → Step 12: 回傳 \"\" // 沒有可用時間戳\n→ End // 程式執行結束"
    },
    {
      "title": "Count The Repetitions",
      "source_file": "Leetcode/leetcode466.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        if n1 == 0 or n2 == 0:\n            return 0\n\n        s1_len, s2_len = len(s1), len(s2)\n        s1_count = 0          # 已處理的 s1 次數\n        s2_count = 0          # 已完整匹配到的 s2 次數\n        idx_s2 = 0            # s2 當前指標\n        recall = dict()       # 以 s2 指標作為鍵，記錄 (s1_count, s2_count)\n\n        while s1_count < n1:\n            # 遍歷一整個 s1\n            for ch in s1:\n                if ch == s2[idx_s2]:\n                    idx_s2 += 1\n                    if idx_s2 == s2_len:\n                        idx_s2 = 0\n                        s2_count += 1\n            s1_count += 1\n\n            # 如果相同的 s2 指標再次出現，說明出現週期\n            if idx_s2 in recall:\n                prev_s1, prev_s2 = recall[idx_s2]\n                # 前段\n                pre_loop_s1 = prev_s1\n                pre_loop_s2 = prev_s2\n                # 循環段\n                loop_s1 = s1_count - prev_s1\n                loop_s2 = s2_count - prev_s2\n\n                # 先計算前段能得到多少 s2\n                total_s2 = pre_loop_s2\n\n                # 接著計算能完整覆蓋的循環數\n                remaining_s1 = n1 - s1_count\n                times = remaining_s1 // loop_s1\n                total_s2 += times * loop_s2\n\n                # 處理剩下的 s1\n                rest_s1 = remaining_s1 % loop_s1\n                for _ in range(rest_s1):\n                    for ch in s1:\n                        if ch == s2[idx_s2]:\n                            idx_s2 += 1\n                            if idx_s2 == s2_len:\n                                idx_s2 = 0\n                                total_s2 += 1\n                return total_s2 // n2\n            else:\n                recall[idx_s2] = (s1_count, s2_count)\n\n        # 如果整個過程沒有發現週期，直接計算\n        return s2_count // n2\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入字串中抽取 s1, n1, s2, n2。\n    支援類似 's1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2' 的格式。\n    \"\"\"\n    # 匹配字串\n    s1_match = re.search(r's1\\s*=\\s*\"([^\"]*)\"', text)\n    s2_match = re.search(r's2\\s*=\\s*\"([^\"]*)\"', text)\n    # 匹配整數\n    n1_match = re.search(r'n1\\s*=\\s*(-?\\d+)', text)\n    n2_match = re.search(r'n2\\s*=\\s*(-?\\d+)', text)\n\n    if not (s1_match and s2_match and n1_match and n2_match):\n        raise ValueError(\"Input format error\")\n\n    s1 = s1_match.group(1)\n    s2 = s2_match.group(1)\n    n1 = int(n1_match.group(1))\n    n2 = int(n2_match.group(1))\n    return s1, n1, s2, n2\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s1, n1, s2, n2 = parse_input(data)\n    sol = Solution()\n    result = sol.getMaxRepetitions(s1, n1, s2, n2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps. Problem: Given s1, n1, s2, n2. str1 is s1 repeated n1 times. str2 is s2 repeated n2 times. Need maximum m such that str2 repeated m times can be obtained from str1 (i.e., as subsequence). This is known Leetcode 466. Approach: simulate matching s2 within repetitions of s1, keep track of how many s2 are matched per s1 repetition. Use cycle detection.\n\nPseudo-code:\n\nStart\n→ Input s1, n1, s2, n2\n→ Initialize variables: indexInS1=0, indexInS2=0, countS2=0, dict = {} // map indexInS1 to (countS2, indexInS2)\n→ For i in 1 to n1:\n    → While indexInS1 < len(s1):\n        → if s1[indexInS1] == s2[indexInS2]: \n            → indexInS2 += 1\n            → if indexInS2 == len(s2):\n                → countS2 += 1\n                → indexInS2 = 0\n        → indexInS1 += 1\n    // after processing one s1 repetition\n    → If indexInS1 in dict:\n        → Retrieve prevCountS2, prevIndexInS2\n        → cycleCount = countS2 - prevCountS2\n        → cycleLength = i - prevIndexInS2? Actually we track repetition count? We need mapping from repetition index to state. So key is indexInS2? Use repetition index? Let's define key = indexInS2; but that may not be unique. Actually typical solution: key = indexInS2. But need also repetition index? Use mapping from indexInS2 to (i, countS2). Yes.\n\n    → If key exists:\n        → prevI, prevCountS2 = dict[key]\n        → preCycleCount = prevCountS2\n        → postCycleCount = countS2 - prevCountS2\n        → preCycleLength = prevI\n        → postCycleLength = i - prevI\n        → remainingReps = n1 - i\n        → times = remainingReps // postCycleLength\n        → countS2 += times * postCycleCount\n        → i += times * postCycleLength\n    → dict[indexInS2] = (i, countS2)\n→ result = countS2 // n2\n\nBut we need simpler pseudo-code. Provide steps with decisions.\n\nWe'll produce step-by-step pseudo-code lines.\n\nNeed to output each line as: \"虛擬碼步驟 // 解釋\"\n\nOk.\n\nLet's craft.\n\nWe'll produce Start, read input, initialize variables, loop through n1, inside loop match s2 char by char, increment counters, check cycle, etc. Use decision branches.\n\nRemember to use arrow → etc.\n\nLet's craft lines.\n\nMake sure to include End.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Read s1, n1, s2, n2 // 取得輸入資料  \n→ Initialize lenS1 = length of s1, lenS2 = length of s2 // 計算字串長度  \n→ Set indexS1 = 0, indexS2 = 0 // s1 與 s2 的索引  \n→ Set countS2 = 0 // 已完整匹配到的 s2 次數  \n→ Create empty map Record // 用來偵測重複週期  \n→ For repeat from 1 to n1: // 逐一處理每一個 s1 重複  \n  → While indexS1 < lenS1: // 逐字符遍歷一個 s1  \n    → Decision: s1[indexS1] == s2[indexS2]? // 判斷是否匹配  \n      Yes → indexS2 += 1 // 匹配到，移動到 s2 下一個字符  \n       Decision: indexS2 == lenS2? // 判斷是否完成一個 s2  \n        Yes → countS2 += 1 // 完成一次 s2，計數加一  \n         indexS2 = 0 // 重置到 s2 開頭  \n        No → // 尚未完成，繼續  \n      No → // 不匹配，什麼都不做  \n      → indexS1 += 1 // 移動到 s1 下一個字符  \n  → // 一個完整的 s1 已經遍歷完，回到索引起點  \n  → indexS1 = 0 // 重新開始 s1  \n  → // 檢查是否出現相同的 s2 索引，以偵測週期  \n  → If Record contains key indexS2: // 已經遇到過相同的 s2 索引  \n    → Retrieve (prevRepeat, prevCount) from Record[indexS2]  \n    → Set cycleLen = repeat - prevRepeat // 週期長度（s1 重複次數）  \n    → Set cycleCount = countS2 - prevCount // 週期內完成的 s2 數量  \n    → Set remaining = n1 - repeat // 還剩下多少個 s1 循環可處理  \n    → Set times = remaining // cycleLen // 能夠完整覆蓋的週期數  \n    → countS2 += times * cycleCount // 加上多個週期得到的 s2 數量  \n    → repeat += times * cycleLen // 把重複次數往前跳過已經處理的週期  \n  → Record[indexS2] = (repeat, countS2) // 記錄目前的重複次數和 s2 計數  \n→ // 所有 s1 重複都已處理完畢  \n→ Set result = countS2 // n2 // 將完成的 s2 數量除以每個 str2 需要的 s2 數量  \n→ Output result // 回傳最大可取得的 m  \nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,1,1,5,4,6]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 1, 1, 5, 4, 6]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,2,1,3,2,3]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 2, 1, 3, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        # Step 1: Sort the array in non‑decreasing order\n        nums.sort()\n        # Step 2: Swap every pair of adjacent elements starting from index 1\n        for i in range(1, len(nums) - 1, 2):\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\ndef main():\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    # Extract the list part, e.g. from 'nums = [1,5,1,1,6,4]' get '[1,5,1,1,6,4]'\n    if '=' in raw_input:\n        raw_input = raw_input.split('=', 1)[1].strip()\n    # Safely parse the list using ast.literal_eval\n    nums = ast.literal_eval(raw_input)\n    # Apply the wiggle sort algorithm\n    Solution().wiggleSort(nums)\n    # Output the resulting list\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, no actual code. The requirement: reorder array into wiggle pattern. Need algorithm: sort array, then swap adjacent elements from end? Common solution: sort, then for i=1 to n-1 step 2, swap nums[i] and nums[i+1] if i+1<n. Or use median method. Simplest: sort, then for i=1 to n-2 step 2, swap nums[i] and nums[i+1]. Let's produce virtual code lines accordingly.\n\nStructure: Start, Step 1: Sort nums ascending. Step 2: for i from 1 to length-2 step 2: swap nums[i] with nums[i+1]. End.\n\nNeed each line with explanation. Use arrows. Include Decision? not necessary.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Sort array nums in non‑decreasing order // 先把陣列排好序\n→ Step 2: For index i from 1 to length(nums)-2 with step 2: // 只處理奇數索引位置\n    → Decision: If i+1 < length(nums)? // 確保有下一個元素可交換\n        Yes → Step 3: Swap nums[i] and nums[i+1] // 交換奇偶位置以滿足 < > < > 模式\n        No  → Step 4: Continue // 不需要交換，跳過\nEnd // 程式執行結束\n\nBut we need virtual code line by line, not nested? We can indent. Provide each line as separate line with arrow and explanation. Use Yes → and No → lines.\n\nBetter: Use loop structure: For i from 1 to length-2 step 2: swap nums[i] and nums[i+1]. We can represent as:\n\n→ Step 2: For i = 1 to length(nums)-2 step 2: // 迴圈遍歷奇數索引\n    → Step 3: Swap nums[i] and nums[i+1] // 交換相鄰元素\n\nSimpler. Let's produce.\n\nAlso we might want to mention that final array satisfies wiggle property.\n\nLet's craft output accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort array nums in non‑decreasing order // 先把陣列排好序，方便後續交換  \n→ Step 2: For index i = 1 to length(nums) - 2 with step 2: // 只遍歷奇數索引（1、3、5…）  \n    → Step 3: Swap nums[i] and nums[i+1] // 交換相鄰元素，使 nums[i-1] < nums[i] > nums[i+1]  \nEnd // 程式執行結束，得到 nums[0] < nums[1] > nums[2] < nums[3] … 的波浪排列"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpytjc1qzq.py\", line 79, in <module>\n    main()\n  File \"/tmp/tmpytjc1qzq.py\", line 56, in main\n    ops = ast.literal_eval(ops_str)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 90, in _convert\n    return tuple(map(_convert, node.elts))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Subscript object at 0x71c0281fbb10>"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x):\n        # 將新元素加入主隊列 q1 的尾端\n        self.q1.append(x)\n\n    def pop(self):\n        if not self.q1:\n            return None\n        # 把 q1 除最後一個外的所有元素轉移到 q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # 最後一個元素即為堆疊頂部\n        top = self.q1.popleft()\n        # 交換 q1 與 q2，使 q1 再次成為主隊列\n        self.q1, self.q2 = self.q2, self.q1\n        return top\n\n    def top(self):\n        if not self.q1:\n            return None\n        # 把 q1 除最後一個外的所有元素轉移到 q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # 取出頂部元素\n        top = self.q1.popleft()\n        # 再把頂部元素放回 q2，保持原順序\n        self.q2.append(top)\n        # 交換 q1 與 q2\n        self.q1, self.q2 = self.q2, self.q1\n        return top\n\n    def empty(self):\n        return not self.q1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入格式：[\"MyStack\", \"push\", ...], [[], [1], ...]\n    # 找出 '], [' 的分割點\n    split_point = data.find('], [')\n    if split_point == -1:\n        # 直接解析整體為兩個列表\n        ops, args = ast.literal_eval(data)\n    else:\n        ops_str = data[:split_point + 2]  # 包含前兩個括號\n        args_str = '[' + data[split_point + 3:]  # 加上左括號\n        ops = ast.literal_eval(ops_str)\n        args = ast.literal_eval(args_str)\n\n    stack = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyStack\":\n            stack = MyStack()\n            results.append(None)  # null in LeetCode style\n        elif op == \"push\":\n            stack.push(arg[0])\n            results.append(None)\n        elif op == \"pop\":\n            results.append(stack.pop())\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"empty\":\n            results.append(stack.empty())\n\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. For implementing a stack with two queues. We need to output lines: each line has \"虛擬碼步驟 // 解釋\". Use arrows etc. We'll start with Start, define queues, push, pop, top, empty. Provide algorithm: use queue1 primary, queue2 temporary. For push: enqueue to q1. For pop: move all but last from q1 to q2, then dequeue last from q1 and return. Swap queues. For top: similar but after retrieving last, we need to push it to q2. Use decisions. Provide structure. We'll produce in Chinese. Let's craft.\n\nNeed to keep each line separated, use arrow \"→\". Provide decision steps. For example:\n\nStart // 程式開始\n\n→ 初始化 q1, q2 // 兩個空隊列\n\n→ Function: push(x) // 推入元素\n\n    → q1.Enqueue(x) // 加入後端\n\n→ Function: pop() // 取出頂部\n\n    → Decision: q1.isEmpty()? // 若空則錯誤\n\n        Yes → Return error\n\n        No  → While q1.size > 1\n\n            → temp = q1.Dequeue()\n\n            → q2.Enqueue(temp)\n\n        → topElement = q1.Dequeue() // 取最後一個\n\n        → Swap q1 and q2 // 重新設為主隊列\n\n        → Return topElement\n\n... etc.\n\nWe must follow the format. Provide all functions. We might have separate lines for each step. For decision we use indent. We'll produce a linear representation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Initialize q1, q2 // 兩個空隊列，q1 為主隊列  \n→ Function: push(x) // 推入元素到堆疊頂部  \n → q1.Enqueue(x) // 將 x 加入 q1 的尾端  \n\n→ Function: pop() // 從堆疊頂部取出元素並回傳  \n → Decision: 如果 q1.isEmpty()? // 判斷堆疊是否為空  \n  Yes → Return error // 若空則回傳錯誤值  \n  No  → While q1.size > 1 // 將 q1 除最後一個之外的元素全部轉移  \n    → temp = q1.Dequeue() // 從 q1 前端取出  \n    → q2.Enqueue(temp) // 將其放入 q2 的尾端  \n  → topElement = q1.Dequeue() // 取出最後一個元素，為堆疊頂部  \n  → Swap q1, q2 // 交換 q1 與 q2，使 q1 成為新的主隊列  \n  → Return topElement // 回傳剛剛取出的頂部元素  \n\n→ Function: top() // 回傳堆疊頂部元素但不移除  \n → Decision: 如果 q1.isEmpty()? // 判斷堆疊是否為空  \n  Yes → Return error // 若空則回傳錯誤值  \n  No  → While q1.size > 1 // 與 pop 類似將元素轉移  \n    → temp = q1.Dequeue()  \n    → q2.Enqueue(temp)  \n  → topElement = q1.Dequeue() // 取出最後一個元素  \n  → q2.Enqueue(topElement) // 再將它放回 q2，保持原順序  \n  → Swap q1, q2 // 交換，使 q1 再次為主隊列  \n  → Return topElement // 回傳頂部元素  \n\n→ Function: empty() // 判斷堆疊是否為空  \n → Return q1.isEmpty() // 若主隊列為空即堆疊為空  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        \"\"\"\n        使用「合併集合」(Union‑Find) 來把相同 email 的帳號合併。\n        \"\"\"\n        parent = {}\n\n        # ---------- 1. 先找出某個 email 的根節點 ----------\n        def find(x):\n            parent.setdefault(x, x)          # 如果還沒出現在字典中，先初始化\n            if parent[x] != x:               # 迭代尋找根節點\n                parent[x] = find(parent[x])  # 路徑壓縮\n            return parent[x]\n\n        # email -> name 的映射，方便最後取姓名\n        email_to_name = {}\n\n        # ---------- 2. 建立合併關係 ----------\n        for acc in accounts:\n            name = acc[0]\n            emails = acc[1:]\n            if not emails:\n                continue\n            first = emails[0]\n            for email in emails:\n                # 記錄姓名\n                email_to_name[email] = name\n                # 合併操作：把 email 與第一個 email 合併\n                root_first = find(first)\n                root_email = find(email)\n                if root_first != root_email:\n                    parent[root_email] = root_first\n\n        # ---------- 3. 把同一個根節點的 email 收集在一起 ----------\n        groups = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            groups[root].append(email)\n\n        # ---------- 4. 準備回傳結果 ----------\n        merged = []\n        for root, em_list in groups.items():\n            merged.append([email_to_name[root]] + sorted(em_list))\n        return merged\n\ndef main():\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 可能會有 'accounts = ' 這樣的字串，先把它剔除\n    if raw_input.startswith('accounts'):\n        eq_index = raw_input.find('=')\n        if eq_index != -1:\n            raw_input = raw_input[eq_index + 1:].strip()\n\n    # 解析成 Python 物件（安全解析）\n    try:\n        accounts = ast.literal_eval(raw_input)\n    except Exception:\n        # 若 literal_eval 失敗，使用 eval（較不安全，但能處理更複雜情況）\n        accounts = eval(raw_input, {})\n\n    # 執行合併邏輯\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n\n    # 輸出結果，Python 內建的 print 會直接轉成文字表達式\n    print(merged_accounts)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for merging accounts. Use virtual code style. Provide line-by-line steps. Use decision nodes. We'll produce algorithm: build graph of emails, union find, mapping email to name, DFS to collect groups, sort emails, output.\n\nLet's produce steps:\n\nStart\n→ Step: 初始化 email_to_name 映射和 graph (adjacency list)\n→ Step: 建立圖，將相同帳戶中的每個 email 與第一個 email 連接\n→ Decision: 若 accounts 列表为空? -> End\nBut we may skip such check.\n\nThen DFS each email not visited to collect group.\n\nLet's produce lines.\n\nAlso need arrow formatting: \"→ Step ... // explanation\". For decisions, indent lines.\n\nWe can incorporate \"Decision:\" lines. Example:\n\n→ Decision: accounts 是否为空? // 若無帳戶則直接結束\n    Yes → End // 無帳戶\n\nBut maybe keep simple.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 創建空字典 email_to_name // 用於存儲每個 email 對應的姓名\n→ Step 2: 創建空字典 graph // 用於存儲 email 之間的連接\n→ Step 3: 對於每個帳戶在 accounts 之中進行遍歷 // 主循環\n    → Step 3.1: 取帳戶名稱 name = account[0] // 取得姓名\n    → Step 3.2: 取帳戶電子郵件列表 emails = account[1:] // 取得所有 email\n    → Step 3.3: 對於每個 email 在 emails 中進行遍歷\n        → Step 3.3.1: 若 email 未在 email_to_name 中，將 email_to_name[email] = name // 記錄姓名\n        → Step 3.3.2: 若 email 未在 graph 中，將 graph[email] = 空集合 // 初始化集合\n    → Step 3.4: 若 emails 非空，將第一個 email 作為基準\n        → Step 3.4.1: 基準基 email0 = emails[0]\n        → Step 3.4.2: 對於其餘 email 在 emails[1:] 中\n            → Step 3.4.2.1: 在 graph 中將 email0 與 email 互相加入集合 // 建立邊\n            → Step 3.4.2.2: 在 graph 中將 email 與 email0 互相加入集合\n→ Step 4: 創建空集合 visited // 用於標記已訪問的 email\n→ Step 5: 創建空列表 result // 用於存放合併後的帳戶\n→ Step 6: 對於每個 email 在 graph 的鍵中進行遍歷\n    → Decision: email 是否已在 visited? // 判斷是否已處理\n        Yes → Skip // 已處理則跳過\n        No  → Step 6.1: 初始化空列表 group_emails // 用於收集同一個帳戶的 email\n        → Step 6.2: 執行 DFS 或 BFS 從 email 開始\n            → Step 6.2.1: 將 email 入棧/佇列 // 開始搜尋\n            → Step 6.2.2: 取出頂端節點 cur\n            → Step 6.2.3: 若 cur 已在 visited 則繼續\n            → Step 6.2.4: 否則將 cur 加入 visited 並加入 group_emails\n            → Step 6.2.5: 對於每個相鄰節點 nei 在 graph[cur]\n                → Step 6.2.5.1: 若 nei 未在 visited，將其加入棧/佇列\n        → Step 6.3: 對 group_emails 進行排序 // 以字典序排列\n        → Step 6.4: 取得任意一個 group_emails 中的 email 對應的姓名 name = email_to_name[group_emails[0]]\n        → Step 6.5: 建立帳戶列表 merged = [name] + group_emails // 將姓名放在首位\n        → Step 6.6: 將 merged 加入 result\n→ End // 程式執行結束\n\nAdd explanation comments.\n\nWe need to ensure each line is preceded by arrow and comment. Use \"Decision:\" line indent. Need to maintain indentation with tabs? In example, indentation for sub-steps is 4 spaces. We can mimic.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 創建空字典 email_to_name // 用於存儲每個 email 對應的姓名  \n→ Step 2: 創建空字典 graph // 用於存儲 email 之間的連接  \n→ Step 3: 對於每個帳戶在 accounts 之中進行遍歷 // 主循環  \n    → Step 3.1: 取帳戶名稱 name = account[0] // 取得姓名  \n    → Step 3.2: 取帳戶電子郵件列表 emails = account[1:] // 取得所有 email  \n    → Step 3.3: 對於每個 email 在 emails 中進行遍歷  \n        → Step 3.3.1: 若 email 未在 email_to_name 中，將 email_to_name[email] = name // 記錄姓名  \n        → Step 3.3.2: 若 email 未在 graph 中，將 graph[email] = 空集合 // 初始化集合  \n    → Step 3.4: 若 emails 非空，將第一個 email 作為基準  \n        → Step 3.4.1: 基準基 email0 = emails[0] // 基準 email  \n        → Step 3.4.2: 對於其餘 email 在 emails[1:] 中  \n            → Step 3.4.2.1: 在 graph 中將 email0 與 email 互相加入集合 // 建立邊  \n            → Step 3.4.2.2: 在 graph 中將 email 與 email0 互相加入集合  \n→ Step 4: 創建空集合 visited // 用於標記已訪問的 email  \n→ Step 5: 創建空列表 result // 用於存放合併後的帳戶  \n→ Step 6: 對於每個 email 在 graph 的鍵中進行遍歷  \n    → Decision: email 是否已在 visited? // 判斷是否已處理  \n        Yes → Skip // 已處理則跳過  \n        No  → Step 6.1: 初始化空列表 group_emails // 用於收集同一個帳戶的 email  \n        → Step 6.2: 執行 DFS 從 email 開始  \n            → Step 6.2.1: 將 email 入棧 // 開始搜尋  \n            → Step 6.2.2: 取出棧頂節點 cur  \n            → Step 6.2.3: 若 cur 已在 visited 則繼續  \n            → Step 6.2.4: 否則將 cur 加入 visited 並加入 group_emails  \n            → Step 6.2.5: 對於每個相鄰節點 nei 在 graph[cur]  \n                → Step 6.2.5.1: 若 nei 未在 visited，將其加入棧  \n        → Step 6.3: 對 group_emails 進行排序 // 以字典序排列  \n        → Step 6.4: 取得 group_emails[0] 對應的姓名 name = email_to_name[group_emails[0]] // 所有 email 同名  \n        → Step 6.5: 建立帳戶列表 merged = [name] + group_emails // 將姓名放在首位  \n        → Step 6.6: 將 merged 加入 result // 收集合併後的帳戶  \n→ End // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,6,0,4,0,0,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 6, 0, 4, 0, 0, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black_set = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        idx = random.randint(0, self.size - 1)\n        return self.mapping.get(idx, idx)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1])\n\n    result = []\n    sol = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            n, bl = arg\n            sol = Solution(n, bl)\n            result.append(None)\n        elif op == \"pick\":\n            result.append(sol.pick())\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code lines with comments. Must follow format: \"虛擬碼步驟 // 解釋\". Must use Start, End, Decision, Yes/No arrows.\n\nWe need design algorithm: mapping allowed numbers < n-b count mapping. Approach: Count m = n - len(blacklist). Store map of blacklisted numbers that are < m to corresponding allowed numbers >= m. Use random range [0, m-1]. If chosen in map, map to mapped value else return. That reduces random calls.\n\nImplement Solution constructor: store m, map dictionary. pick() randomInt(m). if in map -> return map[x] else return x.\n\nAlso provide algorithm for building mapping: iterate blacklist; for each b < m, find replacement from end of range (n-1 downwards) not in blacklist; map[b] = replacement; decrement candidate.\n\nWe need virtual code line by line. Let's produce.\n\nNeed to include Start and End. Use Decision for if statements. Use arrows.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 計算 m = n - blacklist.length // 可選數量\n→ Step 2: 初始化 map = 空字典 // 用於映射黑名單內的數\n→ Step 3: 初始化 candidate = n - 1 // 從最大值開始尋找替代\n\n→ Step 4: Decision: blacklist 是否為空? // 判斷是否有黑名單\n    Yes → End // 若無黑名單，直接結束初始化\n    No  → Decision: 迭代每個 b in blacklist? // 為每個黑名單元素進行處理\n        Yes → Decision: b < m? // 只處理小於可選範圍的黑名單\n            Yes → Decision: candidate 在 blacklist? // 確保替代不在黑名單\n                Yes → Step 5: candidate = candidate - 1 // 向下移動\n                No  → Step 6: map[b] = candidate // 建立映射\n                     → Step 7: candidate = candidate - 1 // 之後繼續尋找\n            No  → No action // 大於等於 m 的黑名單不影響映射\n        No  → No action // 完成所有黑名單元素的處理\n\n→ End // 初始化完成，準備呼叫 pick()\n\nStart // pick 方法執行\n\n→ Step 8: x = randomInt(m) // 產生 0 到 m-1 的隨機數\n→ Step 9: Decision: x in map? // 檢查是否需要映射\n    Yes → Step 10: return map[x] // 返回映射值\n    No  → Step 11: return x // 直接返回原值\n\nEnd // pick 方法結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.09312,-0.34637],[-0.43115,0.58941],[-0.07924,-0.84461]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.09312, -0.34637], [-0.43115, 0.58941], [-0.07924, -0.84461]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 產生均勻隨機半徑\n        r = self.radius * math.sqrt(random.random())\n        # 產生均勻隨機角度\n        theta = random.uniform(0, 2 * math.pi)\n        # 轉換回直角座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    lines = sys.stdin.read().strip().splitlines()\n    if not lines:\n        return\n    methods = json.loads(lines[0])\n    args_list = json.loads(lines[1])\n\n    results = []\n    obj = None\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)  # null in JSON\n        elif method == \"randPoint\":\n            point = obj.randPoint()\n            # 將座標保留 5 位小數，避免太多浮點位\n            point = [round(v, 5) for v in point]\n            results.append(point)\n\n    # 輸出為 JSON 格式，符合 LeetCode 的輸出要求\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines for this algorithm: generate uniform random point inside circle. The standard method: choose random radius r = sqrt(random()) * radius, random angle theta = random()*2π. Then x = x_center + r*cos(theta), y = y_center + r*sin(theta). Use random number generator between 0 and 1.\n\nWe need to produce a structure with Start, End, Decision, Steps, arrow syntax. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe have to define the class, constructor, method. Use virtual code lines.\n\nWe can include steps: initialization, random generation, compute. Use Decision? maybe not needed but could include.\n\nWe need to produce lines: Start, Step 1, Step 2, etc. Use arrow.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 定義 Solution 類別並接收 radius, x_center, y_center // 初始化圓參數\n→ Step 2: 在建構子中將 radius, x_center, y_center 存入物件屬性 // 方便之後使用\n→ Step 3: 定義 randPoint() 方法 // 產生隨機點\n    → Step 4: 產生均勻隨機數 u 在 [0,1) // 用於計算半徑\n    → Step 5: 計算 r = radius * sqrt(u) // 調整半徑以保證均勻分佈\n    → Step 6: 產生均勻隨機數 v 在 [0,1) // 用於角度\n    → Step 7: 計算 theta = 2π * v // 隨機角度\n    → Step 8: 計算 x = x_center + r * cos(theta) // 轉換為座標\n    → Step 9: 計算 y = y_center + r * sin(theta) // 轉換為座標\n    → Step 10: 回傳 [x, y] // 結果輸出\nEnd // 程式執行結束\n\nWe could also include Decision steps? maybe not necessary. But maybe we can add a decision: if u < 0? No. But not needed.\n\nThe requirement: Use arrow \"→\", \"Yes →\", \"No →\" and structure Decision. Not mandatory to have decision but can include. But must maintain format.\n\nWe should maintain consistent indent. In sample, they indent decisions. For us we can indent steps under randPoint. Use indentation for substeps. The arrow appears before each step.\n\nThus produce output. Ensure each line has virtual code and comment. Use Traditional Chinese. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Solution 類別並接收 radius, x_center, y_center // 初始化圓參數  \n→ Step 2: 在建構子中將 radius, x_center, y_center 存入物件屬性 // 方便之後使用  \n→ Step 3: 定義 randPoint() 方法 // 產生隨機點  \n    → Step 4: 產生均勻隨機數 u ∈ [0,1) // 用於計算半徑  \n    → Step 5: 計算 r = radius * sqrt(u) // 調整半徑以保證均勻分佈  \n    → Step 6: 產生均勻隨機數 v ∈ [0,1) // 用於角度  \n    → Step 7: 計算 theta = 2π * v // 隨機角度  \n    → Step 8: 計算 x = x_center + r * cos(theta) // 轉換為座標  \n    → Step 9: 計算 y = y_center + r * sin(theta) // 轉換為座標  \n    → Step 10: 回傳 [x, y] // 結果輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Count Different Palindromic Subsequences",
      "source_file": "Leetcode/leetcode730.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '104860361'\nGot (Norm):      '830315412'\n--- (Raw) ---\nRaw Expected: '104860361'\nRaw Got:      '830315412'"
        }
      ],
      "generated_code": "import sys\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # Map characters to indices 0..25\n    def idx(c): return ord(c) - 97\n\n    # next_pos[i][c] = next index >= i with character c, or n if none\n    next_pos = [[n] * 26 for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        next_pos[i] = next_pos[i + 1][:]          # copy from right side\n        next_pos[i][idx(s[i])] = i\n\n    # prev_pos[i][c] = previous index <= i with character c, or -1 if none\n    prev_pos = [[-1] * 26 for _ in range(n)]\n    for i in range(n):\n        if i > 0:\n            prev_pos[i] = prev_pos[i - 1][:]\n        prev_pos[i][idx(s[i])] = i\n\n    # dp[i][j] = number of distinct palindromic subsequences in s[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    for length in range(1, n + 1):\n        for i in range(0, n - length + 1):\n            j = i + length - 1\n            if i == j:\n                dp[i][j] = 1\n                continue\n\n            if s[i] == s[j]:\n                low = next_pos[i + 1][idx(s[i])]\n                high = prev_pos[j - 1][idx(s[j])]\n\n                if low > high:\n                    # no same char inside\n                    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] + 2) % MOD\n                elif low == high:\n                    # exactly one same char inside\n                    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] + 1) % MOD\n                else:\n                    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] +\n                                2 + dp[low + 1][high - 1]) % MOD\n            else:\n                dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] -\n                            dp[i + 1][j - 1]) % MOD\n\n    return dp[0][n - 1] % MOD\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    # Try to extract string inside double quotes, if present\n    first_quote = data.find('\"')\n    last_quote = data.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        s = data[first_quote + 1:last_quote]\n    else:\n        s = data.replace(\"s =\", \"\").replace(\"'\", \"\").replace('\"', '').strip()\n    result = count_palindromic_subsequences(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for solving the problem: count different non-empty palindromic subsequences in s modulo 1e9+7.\n\nWe must output line by line, each line: virtual code step + space + comment. Use arrow etc.\n\nWe need algorithm: dynamic programming over substrings, count[i][j] number of distinct palindromic subsequences in s[i..j]. Recurrence depends on first and last char.\n\nStandard approach: For i>j count=0. For i==j count=1. For i<j: if s[i]==s[j], then count[i][j] = count[i+1][j] + count[i][j-1] + 1; else count[i][j] = count[i+1][j] + count[i][j-1] - count[i+1][j-1]. But this counts not distinct? Actually that's for total palindromic subsequences with duplicates counted. For distinct we need more complex recurrence with next/prev occurrences: If s[i]==s[j], let low=next occurrence of s[i] after i, high=prev occurrence of s[j] before j. If low>high (no same char inside), then add 2. If low==high (one inside), add 1. Else add 2 + count[low+1][high-1]. Then add base count[i+1][j] + count[i][j-1] - count[i+1][j-1]. Use modulo. So we need to compute next and prev arrays.\n\nWe should produce pseudocode lines for: read s, n, modulo, compute nextPos and prevPos, init DP table n x n, iterate lengths, compute DP accordingly, output DP[0][n-1] modulo.\n\nLet's produce virtual code lines accordingly.\n\nBe careful to produce arrow lines and indentation. Use Decision lines.\n\nLet's start:\n\nStart // 程式開始\n\n→ Step 1: 讀取輸入字符串 s // 取得要處理的字串\n\n→ Step 2: 設定常量 MOD = 1000000007 // 取模數\n\n→ Step 3: 設定 n = s.length // 字串長度\n\n→ Step 4: 建立 nextPos[ n ][ 26 ] // 下一個相同字元的位置\n\n→ Step 5: 建立 prevPos[ n ][ 26 ] // 前一個相同字元的位置\n\n→ Step 6: 初始化 nextPos 全部為 n // 代表不存在\n\n→ Step 7: 從右到左遍歷 i = n-1 downto 0\n\n    → Step 7.1: For c in 0..25: nextPos[i][c] = nextPos[i+1][c] // 將右邊資訊複製\n\n    → Step 7.2: nextPos[i][ s[i] ] = i // 更新目前位置\n\n→ Step 8: 初始化 prevPos 全部為 -1 // 代表不存在\n\n→ Step 9: 從左到右遍歷 i = 0 to n-1\n\n    → Step 9.1: For c in 0..25: prevPos[i][c] = prevPos[i-1][c] // 將左邊資訊複製\n\n    → Step 9.2: prevPos[i][ s[i] ] = i // 更新目前位置\n\n→ Step 10: 建立 DP 二維表 dp[ n ][ n ] // dp[i][j] 代表 s[i..j] 的不同回文子序列數\n\n→ Step 11: 迭代長度 len = 1 to n\n\n    → Step 11.1: 迭代 i = 0 to n-len\n\n        → Step 11.1.1: 設定 j = i + len - 1 // 子串結尾位置\n\n        → Decision: 如果 len == 1? // 單一字元子串\n\n            → Yes → Step 11.1.2: dp[i][j] = 1 // 只有自己一個回文\n\n            → No → Decision: 如果 s[i] == s[j]? // 首尾相同\n\n                → Yes → Step 11.1.3: 計算 low = nextPos[i+1][ s[i] ] // 下個同字元\n\n                        → Step 11.1.4: 計算 high = prevPos[j-1][ s[j] ] // 前一個同字元\n\n                        → Decision: 如果 low > high? // 內部沒有相同字元\n\n                            → Yes → Step 11.1.5: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] + 2 ) mod MOD // 加 2\n\n                            → No → Decision: 如果 low == high? // 內部恰好一個相同字元\n\n                                → Yes → Step 11.1.6: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] + 1 ) mod MOD\n\n                                → No → Step 11.1.7: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] + 2 + dp[low+1][high-1] ) mod MOD\n\n                        → End\n\n                    → No → Step 11.1.8: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] ) mod MOD\n\n→ Step 12: Output dp[0][n-1] // 結果\n\nEnd // 程式結束\n\nMake sure each line has arrow and comment. Provide indent lines as needed. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字符串 s // 取得要處理的字串  \n→ Step 2: 設定常量 MOD = 1000000007 // 取模數  \n→ Step 3: 設定 n = s.length // 字串長度  \n→ Step 4: 建立 nextPos[ n ][ 26 ] // 下一個相同字元的位置表  \n→ Step 5: 建立 prevPos[ n ][ 26 ] // 前一個相同字元的位置表  \n→ Step 6: 初始化 nextPos 全部為 n // 代表不存在相同字元  \n→ Step 7: 從右到左遍歷 i = n-1 downto 0  \n  → Step 7.1: For c in 0..25: nextPos[i][c] = nextPos[i+1][c] // 複製右側資訊  \n  → Step 7.2: nextPos[i][ s[i] ] = i // 更新目前位置  \n→ Step 8: 初始化 prevPos 全部為 -1 // 代表不存在相同字元  \n→ Step 9: 從左到右遍歷 i = 0 to n-1  \n  → Step 9.1: For c in 0..25: prevPos[i][c] = prevPos[i-1][c] // 複製左側資訊  \n  → Step 9.2: prevPos[i][ s[i] ] = i // 更新目前位置  \n→ Step 10: 建立 DP 二維表 dp[ n ][ n ] // dp[i][j] 為 s[i..j] 的不同回文子序列數  \n→ Step 11: 迭代長度 len = 1 to n  \n  → Step 11.1: 迭代 i = 0 to n-len  \n    → Step 11.1.1: 設定 j = i + len - 1 // 子串結尾位置  \n    → Decision: 如果 len == 1? // 單一字元子串  \n      Yes → Step 11.1.2: dp[i][j] = 1 // 只有自己一個回文  \n      No → Decision: 如果 s[i] == s[j]? // 首尾相同  \n        Yes → Step 11.1.3: 計算 low = nextPos[i+1][ s[i] ] // 下個同字元  \n        → Step 11.1.4: 計算 high = prevPos[j-1][ s[j] ] // 前一個同字元  \n        → Decision: 如果 low > high? // 內部沒有相同字元  \n          Yes → Step 11.1.5: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] + 2 ) mod MOD // 加 2  \n          No → Decision: 如果 low == high? // 內部恰好一個相同字元  \n           Yes → Step 11.1.6: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] + 1 ) mod MOD  \n           No → Step 11.1.7: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] + 2 + dp[low+1][high-1] ) mod MOD  \n          End  \n        No → Step 11.1.8: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] ) mod MOD  \n→ Step 12: 輸出 dp[0][n-1] // 結果  \nEnd // 程式執行結束"
    },
    {
      "title": "4Sum II",
      "source_file": "Leetcode/leetcode454.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzc_i48ud.py\", line 39, in <module>\n    A, B, C, D = parse_input(raw_input)\n                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzc_i48ud.py\", line 31, in parse_input\n    values[key] = ast.literal_eval(val)\n                  ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef four_sum_count(A, B, C, D):\n    \"\"\"計算滿足 A[i] + B[j] + C[k] + D[l] == 0 的四元組數量。\"\"\"\n    # 先計算所有 A+B 的組合出現頻率\n    AB = Counter(a + b for a in A for b in B)\n    # 再依次遍歷 C+D，累加對應的 A+B 頻率\n    count = 0\n    for c in C:\n        for d in D:\n            count += AB.get(-(c + d), 0)\n    return count\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如\n    A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]\n    的輸入字串，返回四個列表 A, B, C, D。\n    \"\"\"\n    parts = [p.strip() for p in data.split(',')]\n    values = {}\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        # 使用 ast.literal_eval 以安全方式解析列表字面量\n        values[key] = ast.literal_eval(val)\n    return values['A'], values['B'], values['C'], values['D']\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取全部資料\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit()\n    A, B, C, D = parse_input(raw_input)\n    result = four_sum_count(A, B, C, D)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code. Approach: compute pair sums of A and B, count frequencies in map. Then iterate over pairs of C and D, sum to zero: need count of -(Ck+Dl) in map. Complexity O(n^2). Provide steps. Use decision and loops. Provide Start, End. Use arrow. Each line: \"虛擬碼步驟 // 解釋\". Use appropriate indentation maybe with spaces.\n\nWe need use Start and End markers. Use → for steps. Use Decision when checking n? But just loops. Should show loops with \"→ Step: For i in 0 to n-1\" etc. We can do.\n\nLet's craft.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立空字典 pairCount // 用來儲存 A[i]+B[j] 的出現次數\n→ Step 2: For i from 0 to n-1 // 遍歷 A 的索引\n    → Step 3: For j from 0 to n-1 // 遍歷 B 的索引\n        → Step 4: sumAB = A[i] + B[j] // 計算兩個元素的和\n        → Decision: sumAB 是否已存在於 pairCount? // 檢查是否已有該鍵\n            Yes → Step 5: pairCount[sumAB] = pairCount[sumAB] + 1 // 若存在，頻率加一\n            No  → Step 6: pairCount[sumAB] = 1 // 若不存在，初始化頻率為 1\n→ Step 7: 結果 = 0 // 初始化答案\n→ Step 8: For k from 0 to n-1 // 遍歷 C 的索引\n    → Step 9: For l from 0 to n-1 // 遍歷 D 的索引\n        → Step 10: sumCD = C[k] + D[l] // 計算兩個元素的和\n        → Step 11: target = -sumCD // 需要的 A+B 和\n        → Decision: target 是否存在於 pairCount? // 檢查字典\n            Yes → Step 12: 結果 = 結果 + pairCount[target] // 加上符合的組合數\n            No  → // 無需執行任何動作\n→ Step 13: 輸出 結果 // 回傳符合條件的四元組數\nEnd // 程式執行結束\n```\n\nNeed to keep format: each line \"虛擬碼步驟 // 解釋\". Use indent for nested steps? Use spaces and maybe arrow for each step.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 pairCount // 用來儲存 A[i]+B[j] 的出現次數  \n\n→ Step 2: For i from 0 to n-1 // 遍歷 A 的索引  \n  → Step 3: For j from 0 to n-1 // 遍歷 B 的索引  \n    → Step 4: sumAB = A[i] + B[j] // 計算兩個元素的和  \n    → Decision: sumAB 是否已存在於 pairCount? // 檢查是否已有該鍵  \n     Yes → Step 5: pairCount[sumAB] = pairCount[sumAB] + 1 // 若存在，頻率加一  \n     No  → Step 6: pairCount[sumAB] = 1 // 若不存在，初始化頻率為 1  \n\n→ Step 7: 結果 = 0 // 初始化答案  \n\n→ Step 8: For k from 0 to n-1 // 遍歷 C 的索引  \n  → Step 9: For l from 0 to n-1 // 遍歷 D 的索引  \n    → Step 10: sumCD = C[k] + D[l] // 計算兩個元素的和  \n    → Step 11: target = -sumCD // 需要的 A+B 和  \n    → Decision: target 是否存在於 pairCount? // 檢查字典  \n     Yes → Step 12: 結果 = 結果 + pairCount[target] // 加上符合的組合數  \n     No  → // 無需執行任何動作  \n\n→ Step 13: 輸出 結果 // 回傳符合條件的四元組數  \n\nEnd // 程式執行結束"
    },
    {
      "title": "4Sum",
      "source_file": "Leetcode/leetcode18.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,0,-1,0,-2,2], target = 0",
          "expected_output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxj6h8d_6.py\", line 50, in <module>\n    result = solution.fourSum(nums, target)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpxj6h8d_6.py\", line 7, in fourSum\n    nums.sort()\n    ^^^^^^^^^\nAttributeError: 'tuple' object has no attribute 'sort'"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2], target = 8",
          "expected_output": "[[2,2,2,2]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6vk1y2kh.py\", line 50, in <module>\n    result = solution.fourSum(nums, target)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6vk1y2kh.py\", line 7, in fourSum\n    nums.sort()\n    ^^^^^^^^^\nAttributeError: 'tuple' object has no attribute 'sort'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        n = len(nums)\n        res = []\n\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res\n\ndef parse_input(data: str):\n    data = data.strip()\n    if not data:\n        return [], 0\n    # Expect format like: nums = [...], target = ...\n    parts = data.split('target =', 1)\n    nums_part = parts[0].split('=', 1)[1].strip()\n    target_part = parts[1].strip() if len(parts) > 1 else '0'\n    nums = ast.literal_eval(nums_part)\n    target = int(target_part)\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n    solution = Solution()\n    result = solution.fourSum(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the 4Sum problem. Provide step-by-step algorithm: sort, nested loops, two pointers, skip duplicates. Provide explanations. Must use Start, End, Decision, arrows. Each line must have \"虛擬碼步驟 [space] // 解釋/說明\". Use Chinese explanation.\n\nLet's craft:\n\nStart\n→ Sort nums ascending // 排序方便後續雙指針與去重\n→ Step 1: 取 i from 0 to n-4 // 第1個指標\n    Decision: i > 0 AND nums[i] == nums[i-1]? // 跳過重複\n        Yes → Skip i // 略過相同的首元素\n        No  → Step 2: 取 j from i+1 to n-3 // 第2個指標\n            Decision: j > i+1 AND nums[j] == nums[j-1]? // 跳過重複\n                Yes → Skip j\n                No  → Step 3: left = j+1, right = n-1 // 兩指針\n                    Decision: left < right? // 有可能組合\n                        Yes → Step 4: sum = nums[i]+nums[j]+nums[left]+nums[right] // 計算和\n                            Decision: sum == target? // 是否符合\n                                Yes → Add quadruplet to result // 收集答案\n                                → left++ // 移動左指標\n                                → right-- // 移動右指標\n                                → Skip duplicates for left: while left < right AND nums[left]==nums[left-1] left++\n                                → Skip duplicates for right: while left < right AND nums[right]==nums[right+1] right--\n                                → Continue loop\n                                No  → Decision: sum < target? // 需要更大\n                                    Yes → left++ // 移動左指標\n                                    No  → right-- // 移動右指標\n                        No → End of while loop\n            End Decision j duplicate\n        End Decision i duplicate\nEnd Decision i loop\nEnd // 程式結束\n\nNeed to ensure each line exactly one step, and nested indentation is shown via indentation (spaces) but not necessary. Use arrow format. Let's produce each line exactly one. Use Start and End. Provide \"Decision:\" lines with Yes and No arrows. For loops maybe Step lines.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 排序以便後續兩指針處理與去重\n→ Step 2: For i = 0 to n-4 // 選取第一個數\n    Decision: i > 0 AND nums[i] == nums[i-1]? // 檢查重複\n        Yes → Skip i // 跳過相同的首元素\n        No  → Step 3: For j = i+1 to n-3 // 選取第二個數\n            Decision: j > i+1 AND nums[j] == nums[j-1]? // 檢查重複\n                Yes → Skip j // 跳過相同的第二元素\n                No  → Step 4: left = j+1, right = n-1 // 設定兩指針\n                    Decision: left < right? // 是否還能形成四元組\n                        Yes → Step 5: sum = nums[i] + nums[j] + nums[left] + nums[right] // 計算目前四元組和\n                            Decision: sum == target? // 是否符合目標\n                                Yes → Add [nums[i], nums[j], nums[left], nums[right]] to result // 收集結果\n                                → left++ // 移動左指針向右\n                                → right-- // 移動右指針向左\n                                → Decision: left < right AND nums[left] == nums[left-1]? // 跳過左重複\n                                    Yes → left++ // 跳過重複\n                                    No  → // 繼續\n                                → Decision: left < right AND nums[right] == nums[right+1]? // 跳過右重複\n                                    Yes → right-- // 跳過重複\n                                    No  → // 繼續\n                                → Continue while loop\n                                No  → Decision: sum < target? // 和太小\n                                    Yes → left++ // 向右移動左指針\n                                    No  → right-- // 向左移動右指針\n                        No → // 左右指針移動結束\n                    No → // 左右指針已無法再縮小\nEnd // 程式結束\n\nNeed to ensure each line has \"虛擬碼步驟 [space] // 解釋\". We already included arrow \"→\" for steps. For decisions, we need \"Decision:\" lines and Yes/No lines with arrows.\n\nLet's reformat:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 排序以便後續兩指針處理與去重\n→ Step 2: For i = 0 to n-4 // 選取第一個數\n    Decision: i > 0 AND nums[i] == nums[i-1]? // 檢查重複\n        Yes → Skip i // 跳過相同的首元素\n        No  → Step 3: For j = i+1 to n-3 // 選取第二個數\n            Decision: j > i+1 AND nums[j] == nums[j-1]? // 檢查重複\n                Yes → Skip j // 跳過相同的第二元素\n                No  → Step 4: left = j+1, right = n-1 // 設定兩指針\n                    Decision: left < right? // 是否還能形成四元組\n                        Yes → Step 5: sum = nums[i] + nums[j] + nums[left] + nums[right] // 計算目前四元組和\n                            Decision: sum == target? // 是否符合目標\n                                Yes → Add [nums[i], nums[j], nums[left], nums[right]] to result // 收集結果\n                                → left++ // 移動左指針向右\n                                → right-- // 移動右指針向左\n                                → Decision: left < right AND nums[left] == nums[left-1]? // 跳過左重複\n                                    Yes → left++ // 跳過重複\n                                    No  → // 繼續\n                                → Decision: left < right AND nums[right] == nums[right+1]? // 跳過右重複\n                                    Yes → right-- // 跳過重複\n                                    No  → // 繼續\n                                → // 重新進入 while\n                                → // 繼續循環\n                                No  → Decision: sum < target? // 和太小\n                                    Yes → left++ // 向右移動左指針\n                                    No  → right-- // 向左移動右指針\n                        No → // 左右指針移動結束\n                    No → // 左右指針已無法再縮小\nEnd // 程式結束\n\nWe might need to indent properly. Provide each line with indentation as shown. That should satisfy.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 排序以便後續兩指針處理與去重  \n→ Step 2: For i = 0 to n-4 // 選取第一個數  \n Decision: i > 0 AND nums[i] == nums[i-1]? // 檢查重複  \n  Yes → Skip i // 跳過相同的首元素  \n  No  → Step 3: For j = i+1 to n-3 // 選取第二個數  \n   Decision: j > i+1 AND nums[j] == nums[j-1]? // 檢查重複  \n    Yes → Skip j // 跳過相同的第二元素  \n    No  → Step 4: left = j+1, right = n-1 // 設定兩指針  \n     Decision: left < right? // 是否還能形成四元組  \n      Yes → Step 5: sum = nums[i] + nums[j] + nums[left] + nums[right] // 計算目前四元組和  \n       Decision: sum == target? // 是否符合目標  \n        Yes → Add [nums[i], nums[j], nums[left], nums[right]] to result // 收集結果  \n         → left++ // 移動左指針向右  \n         → right-- // 移動右指針向左  \n         → Decision: left < right AND nums[left] == nums[left-1]? // 跳過左重複  \n          Yes → left++ // 跳過重複  \n          No  → // 繼續  \n         → Decision: left < right AND nums[right] == nums[right+1]? // 跳過右重複  \n          Yes → right-- // 跳過重複  \n          No  → // 繼續  \n         → // 重新進入 while  \n         → // 繼續循環  \n        No  → Decision: sum < target? // 和太小  \n         Yes → left++ // 向右移動左指針  \n         No  → right-- // 向左移動右指針  \n      No → // 左右指針移動結束  \n     No → // 左右指針已無法再縮小  \nEnd // 程式結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,1,3],[1,2,3],[2,1,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 1, 3], [1, 2, 3], [2, 1, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport re\n\nclass Solution:\n    \"\"\"隨機洗牌的解決方案。\"\"\"\n\n    def __init__(self, nums):\n        # 儲存原始陣列的複本\n        self._original = list(nums)\n        # 內部可變陣列，初始時與原始相同\n        self._nums = list(self._original)\n\n    def reset(self):\n        \"\"\"重置陣列為原始順序並回傳。\"\"\"\n        self._nums = list(self._original)\n        return self._nums\n\n    def shuffle(self):\n        \"\"\"使用 Fisher‑Yates 洗牌演算法，隨機打亂陣列並回傳。\"\"\"\n        shuffled = list(self._nums)\n        n = len(shuffled)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled\n\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n\n    if not raw_input:\n        sys.exit(0)\n\n    # 把輸入分成兩個 JSON 陣列：commands 與 params\n    # 例：[\"Solution\",\"shuffle\"], [[[1,2,3]],[]]\n    parts = re.split(r'\\],\\s*', raw_input, maxsplit=1)\n    commands_str = parts[0] + ']'          # 加回閉合的 ]\n    params_str = parts[1] if len(parts) > 1 else '[]'\n\n    commands = json.loads(commands_str)\n    params = json.loads(params_str)\n\n    results = []\n    obj = None\n\n    for cmd, arg in zip(commands, params):\n        if cmd == \"Solution\":\n            # 建構子，arg 是一個陣列，例如 [1,2,3]\n            obj = Solution(arg[0] if arg else [])\n            results.append(None)  # 代表 null\n        elif cmd == \"reset\":\n            results.append(obj.reset())\n        elif cmd == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            # 若有未知指令，直接跳過或 raise\n            raise ValueError(f\"未知指令 {cmd}\")\n\n    # 輸出結果，使用 json.dumps 以符合期望格式\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output virtual code lines. Each line has \"虛擬碼步驟\" and comment. We must adhere to format with Start, End, Decision. We need to produce algorithm steps for class Solution with constructor, reset, shuffle. Use pseudo-code with arrows. Let's craft step-by-step:\n\nStart\n→ Step 1: Store original array copy // copy input\n→ Step 2: Initialize internal array // set arr = original\n→ End\n\nThen reset method: Start, Step 1: set arr to original copy, Step 2: return arr.\n\nShuffle method: Start, Step 1: create copy of arr, Step 2: for i from 0 to n-1: generate random index j between i and n-1 inclusive, swap elements at i and j, Step 3: return arr.\n\nNeed to format each line. Use \"→ Step 1: ...\" Each step line maybe nested within methods. Could denote method names as \"Method: reset()\", then steps. Use indentation? Not necessary. Just linear sequence. Use Decision if any but not needed.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收整數陣列 nums 作為建構參數 // 獲取輸入資料\n→ Step 2: 建立 original = nums 的完整拷貝 // 儲存原始順序\n→ Step 3: 初始化 current = original 的拷貝 // 內部可變陣列\n→ End // 建構完成\n\n// -------------------------------------------------\n\nStart // reset 方法開始執行\n→ Step 1: 設定 current 為 original 的拷貝 // 回復原始順序\n→ Step 2: 回傳 current // 返回重置後的陣列\n→ End // reset 方法結束\n\n// -------------------------------------------------\n\nStart // shuffle 方法開始執行\n→ Step 1: 將 current 的拷貝命名為 result // 用於隨機化\n→ Step 2: 取得陣列長度 n\n→ Decision: 是否 n > 1? // 若陣列只有一個元素，直接返回\n    Yes → \n        → Step 3: 從 i = 0 到 n-1 做以下操作\n            → Step 3.1: 隨機產生 j，範圍為 i 到 n-1 // 隨機索引\n            → Step 3.2: 交換 result[i] 與 result[j] // 執行洗牌\n    No → \n        → Step 3: 直接進入下一步\n→ Step 4: 回傳 result // 返回隨機排列\n→ End // shuffle 方法結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    res = []\n\n    def backtrack(start, path):\n        res.append(path[:])              # 收集目前子集\n        for i in range(start, len(nums)):\n            path.append(nums[i])         # 包含 nums[i]\n            backtrack(i + 1, path)       # 進一步遞迴\n            path.pop()                   # 回溯，移除最後加入的元素\n\n    backtrack(0, [])\n    return res\n\ndef format_subsets(subsets_list):\n    \"\"\"將子集列表轉換為符合題目輸出的字串格式\"\"\"\n    return '[' + ','.join(\n        '[' + ','.join(map(str, sub)) + ']' for sub in subsets_list\n    ) + ']'\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取一行，例如: 'nums = [1,2,3]'\n    line = sys.stdin.readline().strip()\n    if not line:\n        print('[]')\n        sys.exit(0)\n\n    # 取出方括號內的部分並解析為列表\n    start = line.find('[')\n    end = line.rfind(']')\n    if start == -1 or end == -1:\n        nums = []\n    else:\n        nums = ast.literal_eval(line[start:end+1])\n\n    result = subsets(nums)\n    print(format_subsets(result))",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for generating power set for unique integer array. Use recursion or backtracking. Each step with explanation. Must be line by line.\n\nUse \"Start\", \"Decision:\", \"Step:\", \"End\". Provide arrow \"→\". Example: \nStart // 程式開始執行\n→ Step 1: 定義結果列表 subsets = [] // 初始化儲存子集\n→ Step 2: 呼叫回溯函式 backtrack(index=0, current=[]) // 開始回溯\n→ Decision: index == len(nums)? // 判斷是否到達尾部\n   Yes → Step 3: 加入 current 到 subsets // 收集子集\n   No  → Step 4: // 兩種選擇：不包含 nums[index]\n       → Step 4a: backtrack(index+1, current) // 跳過\n   No  → Step 5: // 包含 nums[index]\n       → Step 5a: current.append(nums[index]) // 加入元素\n       → Step 5b: backtrack(index+1, current) // 遞歸\n       → Step 5c: current.pop() // 回溯\nEnd // 程式結束\n\nBut we need to match format: each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". For arrows \"→\" etc. For decision we show indentation maybe. Use spaces before lines? In example they used indentation with 4 spaces for nested lines? The example: \n```\nStart // 程式開始執行\n→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\nEnd // 程式執行結束\n```\nSo indentation uses 4 spaces.\n\nThus we need to produce similar.\n\nWe need to include Start and End. Provide each step.\n\nWe must not output actual code. Just virtual steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 subsets 為空列表 // 用來儲存所有子集  \n→ Step 2: 定義遞迴函式 backtrack(index, current) // index 為目前考慮的位置，current 為目前已選的元素集合  \n→     → Decision: index == len(nums)? // 判斷是否已遍歷完整數組  \n>     Yes → Step 3: 將 current 複製並加入 subsets // 收集一個完整的子集  \n>     No  → Step 4: // 不包含 nums[index] 的選擇  \n>         → Step 4a: 呼叫 backtrack(index + 1, current) // 直接跳過目前元素  \n>     No  → Step 5: // 包含 nums[index] 的選擇  \n>         → Step 5a: 把 nums[index] 加入 current // 加入元素  \n>         → Step 5b: 呼叫 backtrack(index + 1, current) // 繼續遞迴  \n>         → Step 5c: 從 current 中移除最後加入的元素 // 回溯到上一層  \n→ Step 6: 呼叫 backtrack(0, []) // 從索引 0 開始回溯，初始子集為空  \n→ Step 7: 返回 subsets // 完成後將所有子集作為結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Task Scheduler",
      "source_file": "Leetcode/leetcode621.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '8'\nGot (Norm):      '10'\n--- (Raw) ---\nRaw Expected: '8'\nRaw Got:      '10'"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '10'\nRaw Got:      '12'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef least_interval(tasks, n):\n    \"\"\"計算完成所有任務所需的最小 CPU 間隔數。\"\"\"\n    # 統計每個任務的出現頻率\n    freq = Counter(tasks)\n    # 找到最高頻率以及有多少個任務達到這個頻率\n    max_freq = max(freq.values())\n    max_count = sum(1 for cnt in freq.values() if cnt == max_freq)\n    # 先計算假設每個最頻任務之間都需要間隔的總間隔數\n    part1 = (max_freq - 1) * (n + 1)\n    # 空閒時間需要填充的空位\n    idle_slots = part1 - max_count\n    if idle_slots < 0:\n        idle_slots = 0\n    # 最終結果為空閒時間加上所有任務數\n    return idle_slots + len(tasks)\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中解析 tasks 與 n。\"\"\"\n    # 先嘗試使用正則式直接抓取 'tasks = [...] , n = ...'\n    pattern = r'tasks\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*n\\s*=\\s*(\\d+)'\n    m = re.search(pattern, data)\n    if m:\n        tasks_str, n_str = m.group(1), m.group(2)\n        tasks = eval(tasks_str)          # 解析為列表\n        n = int(n_str)\n        return tasks, n\n\n    # 若上述失敗，嘗試每行一項\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        tasks = eval(lines[0])           # 第一行為 tasks 列表\n        n = int(lines[1])                # 第二行為 n\n        return tasks, n\n\n    raise ValueError(\"輸入格式不符合預期\")\n\ndef main():\n    data = sys.stdin.read()\n    tasks, n = parse_input(data)\n    result = least_interval(tasks, n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code for scheduling tasks with cooling period. Classic LeetCode 621. Approach: Count frequencies, find max freq, count how many tasks have that max, calculate idle slots. Formula: (maxFreq-1)*(n+1)+countMax. If total tasks > that, answer = total tasks. Steps: count frequencies, find max, count max tasks, compute part1, part2, result. Let's produce step-by-step pseudo.\n\nWe need Start, Steps with arrows, decisions, end. Each line: \"虛擬碼步驟 // 解釋\". Use arrow symbols like →.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 建立頻率表 frequency // 統計每個任務字母出現次數\n→ Step 2: maxFreq = 0, countMax = 0 // 初始化最大頻率與其出現數\n→ Decision: 對於每個 freq in frequency? // 遍歷頻率表\n    Yes → Decision: freq > maxFreq? // 判斷是否更高\n        Yes → maxFreq = freq; countMax = 1 // 更新最大頻率及計數\n        No  → Decision: freq == maxFreq? // 是否相同\n            Yes → countMax += 1 // 同一最大頻率任務數量累加\n            No  → Skip // 不變\n→ Step 3: part1 = (maxFreq - 1) * (n + 1) // 計算必備的間隔段\n→ Step 4: part2 = countMax // 這些最大頻率任務填充最後一段\n→ Step 5: idleSlots = part1 - countMax // 需要空閒的時間點\n→ Decision: idleSlots < 0? // 若無需空閒\n    Yes → idleSlots = 0 // 設為0\n→ Step 6: totalTasks = 任務總數 // 任務數量\n→ Step 7: result = idleSlots + totalTasks // 最小 CPU 間隔數\n→ Decision: result < totalTasks? // 若計算結果小於任務數\n    Yes → result = totalTasks // 用任務數作為最小值\n→ End // 程式結束\n\nBut we need more explicit: maybe use loops and decisions.\n\nLet's produce more structured: Step for counting, then decision loops. Use 'For each task in tasks'. Use Decision for max frequency update. Use Step for calculating idleSlots etc.\n\nAlso we need to mention part1, part2 names accordingly.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立空字典 frequency // 用來存每個任務字母的出現頻率\n→ For each task in tasks:\n    → Step 2: frequency[task] += 1 // 統計每個任務的頻率\n→ Step 3: maxFreq = 0; countMax = 0 // 初始化最大頻率與該頻率任務數量\n→ For each freq in frequency.values():\n    → Decision: freq > maxFreq? // 檢查是否為新的最大頻率\n        Yes → maxFreq = freq; countMax = 1 // 更新最大頻率並重設計數\n        No  → Decision: freq == maxFreq? // 檢查是否與現有最大頻率相同\n            Yes → countMax += 1 // 同一最大頻率的任務數量累加\n            No  → // 其它情況不變\n→ Step 4: part1 = (maxFreq - 1) * (n + 1) // 計算必備的間隔段數（含空閒）\n→ Step 5: idleSlots = part1 - countMax // 需要的空閒時間點\n→ Decision: idleSlots < 0? // 若計算結果為負數，表示不需要空閒\n    Yes → idleSlots = 0\n→ Step 6: totalTasks = len(tasks) // 任務總數\n→ Step 7: result = idleSlots + totalTasks // 最小 CPU 間隔數\n→ Decision: result < totalTasks? // 若計算結果小於實際任務數\n    Yes → result = totalTasks // 用任務數作為下限\n→ End // 程式執行結束\n```"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6_8nnbi1.py\", line 20, in <module>\n    commands, arguments = json.loads(input_data)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 49 (char 48)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    commands, arguments = json.loads(input_data)\n    instance = None\n    results = []\n\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"NumArray\":\n            instance = NumArray(args[0])\n            results.append(None)\n        elif cmd == \"sumRange\":\n            results.append(instance.sumRange(*args))\n        else:\n            # 任何未定義的命令直接忽略\n            results.append(None)\n\n    # 使用 json.dumps 以確保 None 轉成 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the class definition and methods. We have to use virtual code style. Each line must have \"虛擬碼步驟\" + space + \"// 解釋\". Use Start, End, Decision, Yes →, No →. For class definition, we can do Start, then Step: Define class NumArray, Step: Constructor, Step: sumRange method. Also need to handle prefix sum array. We can outline steps: store nums, build prefixSum array; sumRange uses prefixSum[right+1] - prefixSum[left].\n\nWe'll produce virtual code lines.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 NumArray // 建立 NumArray 類別\n→ Step 2: 內部變數 prefixSum ← 空陣列 // 用於存儲前綴和\n→ Step 3: Constructor(nums) // 初始化，接收原始陣列\n    → Step 3a: prefixSum[0] ← 0 // 前綴和初始值\n    → Step 3b: For i from 0 to nums.length-1\n        → Step 3b1: prefixSum[i+1] ← prefixSum[i] + nums[i] // 計算前綴和\n→ Step 4: sumRange(left, right) // 計算區間和\n    → Step 4a: result ← prefixSum[right+1] - prefixSum[left] // 区间和公式\n    → Step 4b: Return result // 回傳結果\nEnd // 程式執行結束\n\nBut we must follow exact format: each line \"虛擬碼步驟 // 解釋\". Also we need arrow formatting: \"→\" preceding each step. For nested steps we can indent? But we just produce separate lines, using indentation maybe but not required. Use \"→ Step X:\" for each step.\n\nAlso for Decision we don't need Decision. But we can show loop as a Decision? Not necessary. The requirement says use arrow and structure (Start, End, Decision). So we can use loops as steps, no decision needed.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 NumArray // 建立 NumArray 類別\n→ Step 2: 定義私有變數 prefixSum: 整數陣列 // 存前綴和\n→ Step 3: Constructor(nums) // 接收原始數組並初始化\n    → Step 3a: prefixSum[0] ← 0 // 前綴和起始值\n    → Step 3b: For i = 0 to nums.length - 1\n        → Step 3b1: prefixSum[i+1] ← prefixSum[i] + nums[i] // 計算前綴和\n→ Step 4: sumRange(left, right) // 回傳區間和\n    → Step 4a: sum ← prefixSum[right+1] - prefixSum[left] // 区间和公式\n    → Step 4b: Return sum // 返回結果\nEnd // 程式執行結束\n\nWe must keep each line separate. We can indent nested steps but still each line separate. Provide \"Step 3b\" maybe not needed; we can just show steps sequentially.\n\nLet's write final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 NumArray // 建立 NumArray 類別\n→ Step 2: 定義私有變數 prefixSum: 整數陣列 // 存前綴和\n→ Step 3: Constructor(nums) // 接收原始數組並初始化\n    → Step 3a: prefixSum[0] ← 0 // 前綴和起始值\n    → Step 3b: For i = 0 to nums.length - 1\n        → Step 3b1: prefixSum[i+1] ← prefixSum[i] + nums[i] // 計算前綴和\n→ Step 4: sumRange(left, right) // 回傳區間和\n    → Step 4a: sum ← prefixSum[right+1] - prefixSum[left] // 区间和公式\n    → Step 4b: Return sum // 返回結果\nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum",
      "source_file": "Leetcode/leetcode39.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpv5ptgwo8.py\", line 30, in <module>\n    target_str = target_part.split('=')[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpw8xxxee4.py\", line 30, in <module>\n    target_str = target_part.split('=')[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def combinationSum(self, candidates, target):\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, total + candidates[i])\n                path.pop()\n\n        backtrack(0, [], 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    parts = [p.strip() for p in data.split(',')]\n    cand_part = parts[0]\n    target_part = parts[1] if len(parts) > 1 else ''\n    cand_list_str = cand_part.split('=')[1].strip()\n    target_str = target_part.split('=')[1].strip()\n    candidates = ast.literal_eval(cand_list_str)\n    target = int(target_str)\n    solution = Solution()\n    result = solution.combinationSum(candidates, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the algorithm of combination sum: backtracking, candidates sorted. Each line with explanation. We need to follow the output format: \"虛擬碼步驟 [space] // 解釋\". Use arrows etc. Start, End, Decision etc. Each line is a step. So need to represent algorithm steps like Start, define function, iterate, recursion, etc.\n\nWe should produce line by line steps that represent algorithm: e.g.:\n\nStart\n→ Define function combine(candidates, target) // main entry\n→ Sort candidates ascending // ensure order to avoid duplicates\n→ Define backtrack(start, current, remaining)\n→ Decision: remaining == 0? // base case success\n  Yes → Append current to result // store combination\n  No → Decision: remaining < 0? // invalid\n    Yes → Return // prune\n    No → Loop i from start to len(candidates)-1\n        → Add candidates[i] to current // choose\n        → Recursively call backtrack(i, current, remaining - candidates[i]) // allow unlimited\n        → Remove last from current // backtrack\n→ End // algorithm finished\nReturn result\n\nWe need each line with explanation. Use arrows. For decision we indent. Also each step is separate line. We need to include arrow before each step, except Start and End maybe no arrow. The example shows \"Start // 程式開始執行\". So we should follow that.\n\nLet's produce steps.\n\nBut careful: Each step line must be like:\n\nStart // 程式開始執行\n→ Define function combinationSum(candidates, target) // 主入口，傳入參數\n→ Sort candidates ascending // 方便遞迴避免重複組合\n→ Initialize result list // 用於存放所有有效組合\n→ Define backtrack(startIndex, currentCombo, remainingSum) // 回溯函式\n→ Decision: remainingSum == 0? // 是否已達目標\n    Yes → Append copy of currentCombo to result // 成功加入結果\n    No → Decision: remainingSum < 0? // 是否超過目標\n        Yes → Return // 超過則停止\n        No → For i from startIndex to len(candidates)-1 // 遍歷候選數\n            → Append candidates[i] to currentCombo // 選擇數字\n            → backtrack(i, currentCombo, remainingSum - candidates[i]) // 允許重複選擇\n            → Remove last element from currentCombo // 回溯\n→ backtrack(0, [], target) // 啟動回溯\n→ Return result // 返回所有組合\nEnd // 程式結束\n\nNeed each line with // explanation.\n\nNow produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define function combinationSum(candidates, target) // 主入口，傳入候選數與目標和  \n→ Sort candidates ascending // 讓遞迴時能以遞增順序遍歷，避免重複組合  \n→ Initialize result list // 用來存放所有符合條件的組合  \n→ Define backtrack(startIndex, currentCombo, remainingSum) // 回溯子函式  \n→ Decision: remainingSum == 0? // 檢查是否已正好達到目標和  \n  Yes → Append copy of currentCombo to result // 成功組合加入結果  \n  No → Decision: remainingSum < 0? // 檢查是否已超過目標和  \n    Yes → Return // 超過就直接回傳，停止此分支  \n    No → For i from startIndex to len(candidates)-1 // 從當前索引開始遍歷所有候選數  \n     → Append candidates[i] to currentCombo // 選擇當前數字  \n     → backtrack(i, currentCombo, remainingSum - candidates[i]) // 允許重複使用相同數字  \n     → Remove last element from currentCombo // 回溯，移除剛選的數字  \n→ backtrack(0, [], target) // 從索引0開始，空組合，目標和為 target  \n→ Return result // 傳回所有找到的唯一組合  \nEnd // 程式結束執行"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,0,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 0, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 隨機產生 1 ~ total 的整數\n        target = random.randint(1, self.total)\n        # bisect_left 找出第一個 >= target 的索引\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 將兩個頂層列表包起來，使其成為合法的 Python 表達式\n    wrapped = '[' + raw_input + ']'\n    try:\n        ops, args = ast.literal_eval(wrapped)\n    except Exception as e:\n        raise ValueError(f\"無法解析輸入: {e}\")\n\n    instance = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # 參數是 w 的列表\n            instance = Solution(arg[0])\n            results.append(None)  # Constructor 沒有回傳值\n        elif op == \"pickIndex\":\n            if instance is None:\n                raise ValueError(\"未先呼叫 Constructor\")\n            results.append(instance.pickIndex())\n        else:\n            raise ValueError(f\"未知的方法名稱: {op}\")\n\n    # 輸出為 JSON 格式，None 會被轉為 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for implementing pickIndex function with weighted random selection. Provide step-by-step lines with explanation comments. Must use virtual code syntax with arrows, Start, End, Decision: etc. Must produce in Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows like \"→\". Provide step by step for initialization and pickIndex method. Provide algorithm: build prefix sum array in constructor, random number in [0,total), binary search for index. Use pseudocode lines.\n\nEnsure each line is a separate step with arrow. Use Start for initialization? We can start with \"Start\" then Steps. Also include Decision. The pseudocode should reflect steps in building prefix sums, then pickIndex steps.\n\nWe should not output actual code. Provide virtual code with comments.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 w // 初始化\n→ Step 2: 建立 prefixSum 陣列 // 用於累計權重\n→ Step 3: 計算 totalWeight ← prefixSum[-1] // 總權重\n→ Step 4: 定義函式 pickIndex() // 開始定義隨機挑選\n    → Step 5: 產生亂數 r 在 [0, totalWeight) // 隨機數\n    → Step 6: binarySearch 於 prefixSum 找出第一個值 ≥ r // 以累積權重定位索引\n    → Decision: r 在 prefixSum 的哪個區間? // 透過二分查找確定\n        Yes → Step 7: 回傳對應索引 i // 找到的索引\n    End // 函式結束\nEnd // 程式結束\n\nBut we need to include Decision: maybe better to show binary search decision steps. Use \"Decision: 如果 r < prefixSum[mid]?\". Provide branch.\n\nLet's produce more detailed steps:\n\nStart // 程式開始執行\n→ Step 1: 輸入權重陣列 w // w 為正整數\n→ Step 2: 初始化 prefixSum[0] ← w[0]\n→ Decision: 是否有更多元素? // 檢查陣列長度\n    Yes → Step 3: 對 i = 1 到 len(w)-1 進行\n        → Step 3a: prefixSum[i] ← prefixSum[i-1] + w[i] // 計算累積\n    No → ...\n→ Step 4: 設定 totalWeight ← prefixSum[len(w)-1] // 總權重\n→ Step 5: 定義函式 pickIndex() // 隨機挑選索引\n    → Step 6: 產生亂數 r 介於 [0, totalWeight) // 隨機數\n    → Decision: 是否 r < prefixSum[0]? // 判斷最小索引\n        Yes → Step 7: 回傳 0 // 選擇第一個\n        No → Step 8: 初始化 low ← 0, high ← len(w)-1\n            → Decision: low < high? // 二分查找\n                Yes → Step 9: mid ← (low+high)/2\n                    → Decision: r < prefixSum[mid]? // 判斷左半區\n                        Yes → Step 10: high ← mid\n                        No → Step 11: low ← mid + 1\n                No → Step 12: 回傳 low // 找到對應索引\n    End // 函式結束\nEnd // 程式結束\n\nThis is more detailed. Ensure each line separate. Use arrows for flow. Provide comments in Chinese. Use \"→\" each line. Use Decision. Ensure format: \"虛擬碼步驟 // 解釋\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入權重陣列 w // w 為正整數的 0‑index 陣列  \n→ Step 2: 初始化 prefixSum[0] ← w[0] // 建立累積權重陣列的第一個元素  \n→ Decision: w 的長度是否大於 1? // 檢查是否還有後續元素  \n  Yes → Step 3: 對 i = 1 到 len(w)-1 進行  \n  → Step 3a: prefixSum[i] ← prefixSum[i-1] + w[i] // 將前一個累積值加上當前權重  \n  No  → // 已完成累積權重計算  \n→ Step 4: 設定 totalWeight ← prefixSum[len(w)-1] // 總權重為累積陣列最後一個值  \n→ Step 5: 定義函式 pickIndex() // 開始定義隨機挑選索引的功能  \n  → Step 6: 產生亂數 r 介於 [0, totalWeight) // 取得一個隨機數作為篩選標準  \n  → Decision: r < prefixSum[0]? // 判斷是否落在第一個索引區間  \n    Yes → Step 7: 回傳 0 // 若在第一個區間，直接返回索引 0  \n    No  → Step 8: 初始化 low ← 0, high ← len(w)-1 // 準備二分搜尋  \n      → Decision: low < high? // 開始二分搜尋流程  \n        Yes → Step 9: mid ← (low + high) / 2 // 計算中點索引  \n        → Decision: r < prefixSum[mid]? // 判斷隨機數落在左半邊還是右半邊  \n          Yes → Step 10: high ← mid // 若在左半邊，將 high 收縮至 mid  \n          No  → Step 11: low ← mid + 1 // 若在右半邊，將 low 移至 mid+1  \n        No  → Step 12: 回傳 low // low 即為符合條件的索引  \n  End // pickIndex 函式結束  \nEnd // 程式執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjruwhrxg.py\", line 34, in <module>\n    exec(raw_input, {}, namespace)\n  File \"<string>\", line 1\n    mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphuizairb.py\", line 34, in <module>\n    exec(raw_input, {}, namespace)\n  File \"<string>\", line 1\n    mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        # Count number of soldiers (1's) in a row using binary search.\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        # Build a list of tuples (soldier_count, row_index).\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        # Sort by soldier count ascending, then by row index ascending.\n        soldiers.sort()\n        # Return the indices of the first k weakest rows.\n        return [idx for _, idx in soldiers[:k]]\n\nif __name__ == \"__main__\":\n    import ast\n\n    # Read the entire input from stdin.\n    raw_input = sys.stdin.read().strip()\n\n    # Execute the input string in a clean namespace to extract mat and k.\n    # The input is expected to contain two assignments, e.g.:\n    #   mat = [[1,0,0],[1,1,0]]\n    #   k = 2\n    namespace = {}\n    exec(raw_input, {}, namespace)\n\n    mat = namespace['mat']\n    k = namespace['k']\n\n    solution = Solution()\n    result = solution.kWeakestRows(mat, k)\n\n    # Print the result as a Python list literal.\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce pseudocode for algorithm. Steps: Count soldiers per row using binary search because rows sorted. Then sort rows by (count, index). Then pick first k indices.\n\nWe must output each line as described. Use virtual code arrow. We'll write:\n\nStart\n→ Step 1: Initialize empty list rows\n→ Decision: iterate rows\n    → Step 2: For each row i, count soldiers via binary search\n        → Step 3: Append (count, i) to rows\n→ Step 4: Sort rows by count ascending, index ascending\n→ Step 5: Initialize result list\n→ Step 6: For t from 0 to k-1:\n    → Step 7: Append rows[t].index to result\n→ End // return result\n\nNeed to use arrow for loops? Use Decision maybe. We can show loops with \"For each\" etc. We'll adhere to format. Use \"→\" preceding each step.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: Create empty list rows // 用於存儲每行的(兵力數, 行號)\n→ Decision: For i from 0 to m-1? Actually we can use For loop as a step: \n    → Step 2: For each row index i in mat // 遍歷每一行\n        → Step 3: count ← BinarySearch(mat[i]) // 用二分搜尋得到 1 的個數\n        → Step 4: Append (count, i) to rows // 儲存 (兵力, 行號)\n→ Step 5: Sort rows by first element ascending, then by second ascending // 先根據兵力，兵力相同則根據行號\n→ Step 6: Create empty list result // 儲存最弱 k 行的行號\n→ Step 7: For t from 0 to k-1:\n    → Step 8: Append rows[t].second to result // 加入對應行號\n→ End // 返回 result\n\nWe need to include comments after each line.\n\nMake sure each line ends with // explanation. Also include indent lines as shown.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始\n→ Step 1: rows ← [] // 建立空列表，存放 (兵力數, 行號)\n→ Decision: For each row index i in mat // 遍歷每一行\n    → Step 2: count ← BinarySearch(mat[i]) // 用二分搜尋找出 1 的個數\n    → Step 3: rows.append((count, i)) // 將 (兵力, 行號) 加入 rows\n→ Step 4: rows.sort(key = (count, i)) // 依兵力升序，兵力相同則依行號升序排序\n→ Step 5: result ← [] // 建立空列表，存放最弱 k 行的行號\n→ Decision: For t from 0 to k-1\n    → Step 6: result.append(rows[t].index) // 加入對應行號\n→ End // 返回 result，包含最弱 k 行的索引\n```"
    },
    {
      "title": "H-Index II",
      "source_file": "Leetcode/leetcode275.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def hIndex(self, citations):\n        \"\"\"\n        將已排序的 citations 進行二分搜尋，找到最大的 h 使\n        至少 h 篇文章被引用至少 h 次。\n        \"\"\"\n        n = len(citations)\n        left, right = 0, n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            needed = n - mid  # 需要至少 cited times 的數量\n            if citations[mid] >= needed:\n                # 符合條件，嘗試找更大的 h\n                left = mid + 1\n            else:\n                # 不符合條件，縮小搜尋範圍\n                right = mid - 1\n        # left 指向第 one 證書數小於所需的第一個位置\n        return n - left\n\ndef parse_citations(input_str: str):\n    \"\"\"\n    從輸入字串中抽取列表。\n    假設輸入類似 'citations = [0,1,3,5,6]' 或只是一個列表字串。\n    \"\"\"\n    input_str = input_str.strip()\n    # 找到第一個 '[' 和最後一個 ']'\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1:\n        return []\n    list_str = input_str[start:end + 1]\n    try:\n        # 使用 eval 解析列表字串，因為輸入由題目給定，安全可接受\n        return eval(list_str)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    if not data:\n        sys.exit(0)\n    citations = parse_citations(data)\n    result = Solution().hIndex(citations)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Chinese. Problem: find h-index for sorted citations ascending. Need log time. Approach: binary search for h: find largest index i such that citations[i] >= n-i, where n = length. h = n - i. Steps: Start, define n, low=0, high=n-1, while low <= high: mid, compute needed = n - mid. If citations[mid] >= needed: low = mid +1, else high = mid -1. After loop, h = n - (high+1). End. Provide explanation per line. Use arrows. Provide each line with explanation. Use Start and End. Use Decision: lines. We'll include binary search logic. Let's produce.\n\nRemember: \"虛擬碼步驟\" and comment after space. Use \"→\". Use \"Decision:\" when evaluating. Provide explanation.\n\nLet's produce step lines:\n\nStart\n→ Step 1: 取得 n = 議題長度 // array length\n→ Step 2: 設 low = 0, high = n - 1 // 初始化二分搜尋區間\n→ Decision: low ≤ high? // 判斷搜尋是否還可進行\n    Yes →\n        → Step 3: mid = (low + high) / 2 // 取中間索引\n        → Step 4: required = n - mid // 需要至少 cited times 的數量\n        → Decision: citations[mid] ≥ required? // 判斷該索引是否符合 h 指標條件\n            Yes →\n                → Step 5: low = mid + 1 // 將搜尋區間右移，尋找更大的 h\n            No  →\n                → Step 6: high = mid - 1 // 將搜尋區間左移，縮小 h\n    No  →\n→ Step 7: h = n - (high + 1) // 根據最後 high 計算 h-index\n→ Step 8: 回傳 h // 結果輸出\nEnd\n\nEnsure each line has \"// 解釋\". Use proper Chinese.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← 議題長度 // 取得 array 的長度  \n→ Step 2: low ← 0, high ← n - 1 // 初始化二分搜尋區間  \n→ Decision: low ≤ high? // 判斷是否還有區間可搜尋  \n    Yes →  \n        → Step 3: mid ← (low + high) / 2 // 取得中間索引  \n        → Step 4: required ← n - mid // 至少需要被引用的次數  \n        → Decision: citations[mid] ≥ required? // 檢查該索引是否符合 h 指標條件  \n            Yes →  \n                → Step 5: low ← mid + 1 // 將搜尋區間右移，尋找更大的 h  \n            No →  \n                → Step 6: high ← mid - 1 // 將搜尋區間左移，縮小 h  \n    No →  \n→ Step 7: h ← n - (high + 1) // 根據最後 high 計算 h-index  \n→ Step 8: 回傳 h // 輸出結果  \nEnd // 程式執行結束"
    }
  ]
}