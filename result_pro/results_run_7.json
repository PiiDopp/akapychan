[
  {
    "source_file": "900.json",
    "problem_index_in_file": 0,
    "title": "安全除法",
    "description_snippet": "請寫一個程式，讓使用者輸入兩個整數 a 與 b，輸出 a / b 的結果。若輸入的資料非整數或除數為 0，請顯示錯誤提示『輸入錯誤或除數為 0』。程式必須使用 try / except 結構。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step, with explanations after each line. Use Start, End, Decision, arrows. Need to incorporate try/except logic.\n\nWe can propose:\n\nStart // program start\n→ Step 1: 輸入 a // get first integer\n→ Step 2: 輸入 b // get second integer\n→ Decision: 進入 try 區塊? Actually try block is for code that may raise error; So we can produce step \"try:\". But in virtual code, we can denote as \"→ try:\" maybe. Then inside we attempt division.\n\nBetter structure: Use virtual code with \"try:\" and \"except\". So:\n\n→ try: // 進入 try 區塊以捕捉錯誤\n    → Step 3: 將 a 與 b 轉為整數 // 轉換輸入值\n    → Decision: 是否能除? // 檢查 b 是否為 0\n        Yes → Step 4: 計算 quotient = a / b // 進行除法\n        No  → Step 5: raise ValueError // 顯示除數為 0 的錯誤\n→ except ValueError: // 捕捉轉換或除數錯誤\n    → Step 6: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息\n→ else: // 無例外時執行\n    → Step 7: 輸出 quotient // 顯示結果\nEnd\n\nBut we need to ensure the structure with arrows etc. Use indentation or not? The example uses indentation but with arrow and Decision lines. Use arrow for each line. Provide explanation after each line.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 輸入 a // 從使用者取得第一個數字\n→ Step 2: 輸入 b // 從使用者取得第二個數字\n→ try: // 進入 try 區塊以捕捉轉換或除法錯誤\n    → Step 3: a_int = int(a) // 轉為整數\n    → Step 4: b_int = int(b) // 轉為整數\n    → Decision: b_int 是否為 0? // 檢查除數是否為 0\n        Yes → raise ValueError('Zero') // 觸發除數為 0 錯誤\n        No  → Step 5: result = a_int / b_int // 執行除法\n→ except ValueError: // 捕捉任何轉換或除數為 0 的錯誤\n    → Step 6: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息\n→ else: // 若 try 沒有例外\n    → Step 7: 輸出 result // 顯示除法結果\nEnd // 程式結束\n\nBut we should maintain arrow formatting exactly: \"→ Step ...\" or \"→ Decision: ...\". Also \"try:\" line can be like \"→ try:\".\n\nLet's produce final answer accordingly. Ensure each line has a space between code and //.\n\nWe need to use \"虛擬碼步驟\" but we can keep \"Step x:\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 a // 從使用者取得第一個數字  \n→ Step 2: 輸入 b // 從使用者取得第二個數字  \n→ try: // 進入 try 區塊以捕捉轉換或除法錯誤  \n    → Step 3: a_int = int(a) // 將輸入的 a 轉成整數  \n    → Step 4: b_int = int(b) // 將輸入的 b 轉成整數  \n    → Decision: b_int 是否為 0? // 檢查除數是否為 0  \n        Yes → raise ValueError('Zero') // 若為 0，觸發除數為 0 的錯誤  \n        No  → Step 5: result = a_int / b_int // 執行除法運算  \n→ except ValueError: // 捕捉任何轉換錯誤或除數為 0 的錯誤  \n    → Step 6: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息  \n→ else: // 若 try 沒有產生例外  \n    → Step 7: 輸出 result // 顯示除法結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    try:\n        # 讀取整個輸入並拆分成兩個整數\n        a_str, b_str = sys.stdin.read().strip().split()\n        a, b = int(a_str), int(b_str)\n        # 執行除法\n        result = a / b\n        print(result)\n    except (ValueError, ZeroDivisionError):\n        # 轉換錯誤或除數為 0 時顯示錯誤訊息\n        print('輸入錯誤或除數為 0')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "10 0",
          "expected_output": "輸入錯誤或除數為 0",
          "success": true,
          "output": "輸入錯誤或除數為 0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "900.json",
    "problem_index_in_file": 1,
    "title": "統計文字行數",
    "description_snippet": "請寫一個程式，開啟名為 data.txt 的檔案，讀取內容並輸出總共有幾行文字。若檔案不存在，請顯示『找不到檔案！』。請使用 with 語法搭配 try / except。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output the virtual code lines following the specified format. Use Start, End, Decision, with arrow, each line: \"虛擬碼步驟 // 解釋\". Use with syntax and try/except. We need to represent try/catch in pseudo. Use decision for file existence? Actually, we just try to open file, if exception occurs, output \"找不到檔案！\". Then count lines.\n\nPseudo structure:\n\nStart\n→ Step 1: 嘗試使用 with open('data.txt', 'r') as file: // 開啟檔案\n    -> Decision: try? Actually use try block: → Try: // 開始嘗試\n        → Step 2: 讀取所有行存入 lines = file.readlines() // 讀取檔案\n        → Step 3: 計算行數 count = len(lines) // 計算行數\n        → Step 4: 輸出 count // 輸出行數\n    → Except FileNotFoundError:\n        → Step 5: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd\n\nBut need to show with and try/except. Use virtual steps accordingly.\n\nUse arrows.\n\nLet's produce lines accordingly.\n\nMake sure each line uses arrow, indentation for nested steps maybe.\n\nExample:\n\nStart // 程式開始執行\n→ Step 1: 嘗試使用 with open('data.txt', 'r') as file: // 開啟檔案\n    → Decision: 進入 try 區塊? Actually we can just show Try:\n        → Try: // 嘗試開啟並處理檔案\n            → Step 2: 讀取所有行至 lines = file.readlines() // 讀取檔案內容\n            → Step 3: count = len(lines) // 計算行數\n            → Step 4: 輸出 count // 顯示行數\n        → Except FileNotFoundError:\n            → Step 5: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd\n\nNeed to ensure we maintain arrow formatting.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 嘗試使用 with open('data.txt', 'r') as file: // 開啟檔案並保證關閉\n    → Decision: 進入 try 區塊? // 以 try / except 處理可能的錯誤\n        Yes → Try: // 嘗試執行檔案處理\n            → Step 2: lines = file.readlines() // 讀取檔案所有行\n            → Step 3: count = len(lines) // 計算行數\n            → Step 4: 輸出 count // 顯示總行數\n        No → Except FileNotFoundError: // 檔案不存在時處理\n            → Step 5: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd // 程式執行結束",
      "generated_code": "def count_lines_in_file(file_path: str) -> None:\n    \"\"\"\n    開啟指定檔案，計算並輸出行數；若檔案不存在則輸出錯誤訊息。\n    \"\"\"\n    try:\n        # with 語法確保檔案在使用後正確關閉\n        with open(file_path, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            # 計算行數並輸出\n            print(f\"檔案共有 {len(lines)} 行\")\n    except FileNotFoundError:\n        # 檔案不存在時的錯誤處理\n        print(\"找不到檔案！\")\n\ndef main() -> None:\n    \"\"\"\n    主程式入口：讀取標準輸入（若有輸入），然後執行檔案行數計算。\n    \"\"\"\n    import sys\n    # 讀取任何輸入（如果有），但不做實際處理，避免阻塞\n    _ = sys.stdin.read()\n    # 呼叫計算行數的函式\n    count_lines_in_file('data.txt')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 1 行",
          "success": true,
          "output": "檔案共有 1 行"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 0,
    "title": "表達式計算",
    "description_snippet": "請寫一個程式，輸入三個整數 a、b、c，計算並輸出結果：a + b * c 和 (a + b) * c。請觀察兩者的不同。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanations, no actual code, using arrows, Start, End, Decision etc. We need to follow format.\n\nWe need to generate code: input three integers a, b, c, compute a + b * c, compute (a + b) * c, output both results, and observe difference. Steps: Start, Input a, Input b, Input c, compute result1 = a + b * c, compute result2 = (a + b) * c, Output result1 and result2, maybe comment about difference. End.\n\nAlso maybe include Decision? Not necessary but maybe to check difference. The requirement: \"請觀察兩者的不同\" but we can just output both. Could include Decision: if result1 != result2 then print difference.\n\nBut we can simply compute and output.\n\nLet's craft.\n\nRemember to put each line: \"虛擬碼步驟 // 解釋\". Use \"→\" for steps. Use \"Start\" and \"End\".\n\nWe must keep consistent format.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 a // 從使用者取得第一個整數  \n→ Step 2: 讀取整數 b // 從使用者取得第二個整數  \n→ Step 3: 讀取整數 c // 從使用者取得第三個整數  \n→ Step 4: 計算 result1 = a + b * c // 儲存 a + (b * c) 的結果  \n→ Step 5: 計算 result2 = (a + b) * c // 儲存 (a + b) * c 的結果  \n→ Step 6: 輸出 result1 // 顯示 a + b * c 的計算值  \n→ Step 7: 輸出 result2 // 顯示 (a + b) * c 的計算值  \n→ Decision: 若 result1 ≠ result2? // 檢查兩個結果是否不同  \n  Yes → Step 8: 輸出 '結果不同，因為乘法優先於加法' // 解釋兩者差異  \n  No  → Step 9: 輸出 '結果相同' // 若意外相等，顯示訊息  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取所有輸入，並拆成字串列表\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    # 只取前三個整數\n    a, b, c = map(int, data[:3])\n\n    # 計算兩種不同的表達式\n    expr1 = a + b * c\n    expr2 = (a + b) * c\n\n    # 輸出結果\n    print(f\"a + b * c = {expr1}\")\n    print(f\"(a + b) * c = {expr2}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2 3 4",
          "expected_output": "a + b * c = 14\n(a + b) * c = 20",
          "success": true,
          "output": "a + b * c = 14\n(a + b) * c = 20"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 1,
    "title": "平均分配",
    "description_snippet": "小明有 n 顆糖果，要平均分給 m 個小朋友。請輸入 n 和 m，輸出每個小朋友分到幾顆糖果，剩下幾顆糖果沒有分完。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the format. Each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision. We need to handle input n and m, compute division and remainder.\n\nSteps: Start, input n, input m, Decision: if m>0? because division by zero. If yes: compute quotient and remainder, output each. If No: output error. End.\n\nLet's produce each line.\n\nMake sure to include arrow lines and indentation? The sample uses \"→ Step 1:\" with arrow. We'll do similar.\n\nLet's craft lines:\n\nStart // 程式開始執行\n\n→ Step 1: 輸入 n // 從使用者取得糖果總數\n\n→ Step 2: 輸入 m // 從使用者取得小朋友人數\n\n→ Decision: 如果 m > 0? // 檢查小朋友人數是否有效\n\nYes → Step 3: 計算 quotient = n ÷ m // 每個小朋友分到的糖果數\n\nYes → Step 4: 計算 remainder = n mod m // 余下未分完的糖果數\n\nYes → Step 5: 輸出 quotient // 顯示每個小朋友得到的糖果數\n\nYes → Step 6: 輸出 remainder // 顯示剩餘糖果數\n\nNo  → Step 7: 輸出 \"小朋友人數必須大於零\" // 顯示錯誤訊息\n\nEnd // 程式執行結束\n\nMake sure each line has arrow only for start? Actually sample uses \"→ Step 1:\" etc. Start line just \"Start\". Also need \"End\".\n\nAlso maintain \"Yes →\" for inside decision.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入 n // 從使用者取得糖果總數\n→ Step 2: 輸入 m // 從使用者取得小朋友人數\n→ Decision: 如果 m > 0? // 檢查小朋友人數是否有效\n    Yes → Step 3: 計算 quotient = n ÷ m // 每個小朋友分到的糖果數\n    Yes → Step 4: 計算 remainder = n mod m // 余下未分完的糖果數\n    Yes → Step 5: 輸出 quotient // 顯示每個小朋友得到的糖果數\n    Yes → Step 6: 輸出 remainder // 顯示剩餘糖果數\n    No  → Step 7: 輸出 \"小朋友人數必須大於零\" // 顯示錯誤訊息\nEnd // 程式執行結束",
      "generated_code": "def main() -> None:\n    import sys\n\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n\n    n = int(data[0])\n    m = int(data[1]) if len(data) > 1 else 0\n\n    if m == 0:\n        # 若小朋友人數為 0，避免除以 0 的錯誤\n        print(\"小朋友人數必須大於零\")\n        return\n\n    per = n // m          # 每個小朋友分到的糖果數\n    left = n % m          # 余下未分完的糖果數\n\n    # 輸出結果，符合範例格式\n    print(f\"每人={per} 剩下={left}\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "20 6",
          "expected_output": "每人=3 剩下=2",
          "success": true,
          "output": "每人=3 剩下=2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 0,
    "title": "模擬擲骰子遊戲",
    "description_snippet": "請使用 random 模組，寫一個函數 roll_dice(n)，模擬擲 n 次六面骰，並回傳所有結果的串列。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following format. Each line: 虛擬碼步驟 + space + // 解釋. Use arrow symbols. Steps: Start, import random, define function roll_dice(n), initialize results list, loop n times, generate random int 1-6, append to list, return list, End. Provide explanations in Chinese.\n\nMake sure each line uses the format: \"虛擬碼步驟 // 解釋\" where \"虛擬碼步驟\" is e.g., \"Start\", \"→ Step 1: ...\". Use arrow \"→\". Use decision not needed. Provide sequential lines.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 引入 random 模組 // 準備亂數產生\n→ Step 2: 定義函式 roll_dice(n) // 接收擲骰次數\n    → Step 3: 初始化 results 為空串列 // 儲存每次擲骰結果\n    → Step 4: 為 i 從 1 到 n 迴圈 // 逐次擲骰\n        → Step 5: result ← random.randint(1, 6) // 產生 1~6 的隨機整數\n        → Step 6: 把 result 加到 results 串列中 // 存入結果\n    → Step 7: 回傳 results // 回傳所有結果\nEnd // 程式結束\n\nMake sure indent lines with arrow? The example used indentation for nested. Use arrows as shown. Provide each line separate.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 引入 random 模組 // 準備亂數產生  \n→ Step 2: 定義函式 roll_dice(n) // 接收擲骰次數  \n → Step 3: 初始化 results 為空串列 // 儲存每次擲骰結果  \n → Step 4: 為 i 從 1 到 n 迴圈 // 逐次擲骰  \n  → Step 5: result ← random.randint(1, 6) // 產生 1~6 的隨機整數  \n  → Step 6: 把 result 加到 results 串列中 // 存入結果  \n → Step 7: 回傳 results // 回傳所有結果  \nEnd // 程式結束",
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"擲 n 次六面骰，回傳所有結果的串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個程式碼，並執行\n    user_code = sys.stdin.read()\n    exec(user_code)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[1,4,2,4,2]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[1, 4, 2, 4, 2]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 1,
    "title": "計算程式執行時間",
    "description_snippet": "請使用 time 模組，寫一個函數 measure_time(func, *args)，用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step. They want to use time module, write a function measure_time(func, *args) that measures the execution time of func and returns result rounded to 3 decimal places. The code is not actual, but pseudo-code with steps, decisions, etc. Must produce each line with \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow →, Yes→, No→, Decision:. Include Start and End.\n\nWe need to include steps: import time, define function, record start time, call func with args, record end time, compute elapsed, round to 3 decimal, return result. Should also maybe return both elapsed and result? But spec says \"並回傳結果 (四捨五入到小數點 3 位)\" ambiguous: return result (elapsed time) rounded to 3 decimals. Probably return elapsed time. So function returns elapsed time. We'll implement that.\n\nAlso need to handle args: call func(*args). We can produce pseudo-code: Step: Set start = time.time() ; Step: result = func(*args) ; Step: end = time.time() ; Step: elapsed = end - start ; Step: rounded_elapsed = round(elapsed, 3) ; Step: return rounded_elapsed\n\nWe must show arrow from Start to each step. Use Decision maybe for optional error? Not necessary. But we can include a decision: if func returns value? Not needed.\n\nLet's produce final output.\n\nEnsure each line has arrow and comment. Use virtual code.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 匯入 time 模組 // 引入時間計算功能\n→ Step 2: 定義函式 measure_time(func, *args) // 定義測量時間的函式\n    → Step 2.1: 記錄開始時間 start = time.time() // 取得執行前的時間戳\n    → Step 2.2: 執行目標函式 result = func(*args) // 呼叫傳入的函式並傳遞參數\n    → Step 2.3: 記錄結束時間 end = time.time() // 取得執行後的時間戳\n    → Step 2.4: 計算耗時 elapsed = end - start // 求得兩時間差即執行耗時\n    → Step 2.5: 將耗時四捨五入到小數點 3 位 rounded_elapsed = round(elapsed, 3) // 取 3 位小數\n    → Step 2.6: 回傳 rounded_elapsed // 回傳測量結果\nEnd // 程式執行結束\n\nBut we need arrow before each step. Use → at each line, but inside nested we can indent. The format expects each line with arrow. For nested we can still start with arrow or use indentation but arrow required. Let's keep each line start with \"→\" then indentation if needed. Use arrow before each nested step as well.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 time 模組 // 引入時間計算功能  \n→ Step 2: 定義函式 measure_time(func, *args) // 定義測量時間的函式  \n    → Step 2.1: 記錄開始時間 start = time.time() // 取得執行前的時間戳  \n    → Step 2.2: 執行目標函式 result = func(*args) // 呼叫傳入的函式並傳遞參數  \n    → Step 2.3: 記錄結束時間 end = time.time() // 取得執行後的時間戳  \n    → Step 2.4: 計算耗時 elapsed = end - start // 求得兩時間差即執行耗時  \n    → Step 2.5: 將耗時四捨五入到小數點 3 位 rounded_elapsed = round(elapsed, 3) // 取 3 位小數  \n    → Step 2.6: 回傳 rounded_elapsed // 回傳測量結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行所需時間，回傳秒數，四捨五入至 3 位小數。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整程式碼並執行\n    script = sys.stdin.read()\n    exec(script, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 0,
    "title": "BMI 計算器\n",
    "description_snippet": "請撰寫一個程式，依序讀入使用者的姓名、身高（公分，float）、體重（公斤，float），計算 BMI = 體重(kg) / (身高(m))^2，並印出「<姓名> 的 BMI 為 <數值>」。數值四捨...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step by step. Each line: \"虛擬碼步驟 // 解釋\". Use arrows etc. Start, Decision maybe. But this is simple linear flow: input name, height, weight, compute BMI, output. No decision branches except maybe rounding? But just compute. Could use decision for rounding? But just use rounding function. But they might want a decision? Not necessary. We'll just produce steps. Ensure each line ends with // 解釋. Use \"→\" arrow to show step sequence. Use \"Start\" and \"End\". So:\n\nStart // 程式開始\n→ Step 1: 輸入姓名 // 從使用者取得姓名\n→ Step 2: 輸入身高 (cm) // 取得身高\n→ Step 3: 輸入體重 (kg) // 取得體重\n→ Step 4: 轉換身高為公尺 // 將身高除以 100\n→ Step 5: 計算 BMI = 體重 / (身高^2) // 計算 BMI\n→ Step 6: 四捨五入 BMI 到 1 位小數 // 將 BMI 四捨五入\n→ Step 7: 輸出 \"<姓名> 的 BMI 為 <數值>\" // 顯示結果\nEnd // 程式結束\n\nAdd comments. Ensure each line has // 解釋. Use arrow. Provide each line. That should satisfy.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入姓名 // 從使用者取得姓名  \n→ Step 2: 輸入身高 (cm) // 取得身高數值  \n→ Step 3: 輸入體重 (kg) // 取得體重數值  \n→ Step 4: 轉換身高為公尺 // 身高 ÷ 100 以得到米  \n→ Step 5: 計算 BMI = 體重 / (身高^2) // 依公式算出 BMI  \n→ Step 6: 四捨五入 BMI 到 1 位小數 // 取 1 位小數作顯示值  \n→ Step 7: 輸出 \"<姓名> 的 BMI 為 <數值>\" // 顯示姓名與計算結果  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    name = input()\n    height_cm = float(input())\n    weight = float(input())\n    height_m = height_cm / 100\n    bmi = weight / (height_m ** 2)\n    print(f\"{name} 的 BMI 為 {bmi:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Alice\n160\n50\n",
          "expected_output": "Alice 的 BMI 為 19.5\n",
          "success": true,
          "output": "Alice 的 BMI 為 19.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 1,
    "title": "兩數計算小工具\n",
    "description_snippet": "請撰寫一個程式，讀入一行包含兩個以空白分隔的整數，將其轉為 int 後，計算並輸出四個結果：和、差（第一個減第二個）、積、平均（保留到小數點後 1 位）。輸出格式固定為：\n和:<和> 差:<差> 積:...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce line by line virtual code steps, with explanations, using arrows. Each line: \"虛擬碼步驟 // 解釋\". Should include Start, End, Decision, etc. But this is simple: read line, split, parse, compute, output.\n\nWe must not output actual code, just virtual code.\n\nWe need to incorporate arrow usage: →, Yes →, No → etc. Since no decisions except maybe check? But we can include a decision to confirm if two numbers read? Not necessary. But we can include a simple decision: if input valid? but maybe not. We just compute.\n\nWe need to produce lines:\n\nStart\n→ Step 1: Read input line // get line from user\n→ Step 2: Split line by whitespace into tokens // separate numbers\n→ Step 3: Parse first token to int A // convert first number\n→ Step 4: Parse second token to int B // convert second number\n→ Step 5: Compute sum = A + B // calculate sum\n→ Step 6: Compute difference = A - B // calculate difference\n→ Step 7: Compute product = A * B // calculate product\n→ Step 8: Compute average = (A + B) / 2.0 // compute average as float\n→ Step 9: Format average to one decimal place // round to 1 decimal\n→ Step 10: Construct output string \"和:sum 差:diff 積:prod 平均:avg\" // build output\n→ Step 11: Output the string // print\nEnd\n\nWe might add decision about if parsing fails? But likely not needed.\n\nWe can include Decision: 是否成功解析兩個數字? But not needed.\n\nWe need to include arrow usage. For each step, we use \"→ Step X: ...\". After each line, include comment with explanation. Must ensure each line includes \"虛擬碼步驟 // 解釋\".\n\nAlso we need \"Start // 程式開始執行\" and \"End // 程式執行結束\".\n\nMake sure each step preceded by \"→\". Use \"Start\" at top. Then steps.\n\nMaybe include Decision: 如果輸入長度不為2? But not necessary.\n\nBut we can include a Decision to ensure there are two tokens. But keep simple.\n\nBut to use Decision structure, we can:\n\nDecision: 是否有兩個整數? // check tokens length\n    Yes → continue\n    No → Step: 輸出錯誤訊息 // But not required.\n\nBut maybe keep simple.\n\nI think simpler is fine.\n\nLet's produce output lines accordingly. Ensure formatting exactly: \"Start // 程式開始執行\" etc. Use arrow \"→\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read input line // 從使用者取得整行輸入  \n→ Step 2: Split line by whitespace into tokens // 把輸入分割成兩個字串  \n→ Step 3: Parse first token to int A // 將第一個字串轉成整數  \n→ Step 4: Parse second token to int B // 將第二個字串轉成整數  \n→ Step 5: Compute sum = A + B // 計算兩數之和  \n→ Step 6: Compute difference = A - B // 計算第一個減第二個  \n→ Step 7: Compute product = A * B // 計算兩數之積  \n→ Step 8: Compute average = (A + B) / 2.0 // 計算平均值（浮點數）  \n→ Step 9: Format average to one decimal place // 將平均值四捨五入到小數點後一位  \n→ Step 10: Construct output string \"和:sum 差:diff 積:prod 平均:avg\" // 組合輸出格式  \n→ Step 11: Output the string // 顯示結果  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    import sys\n    line = sys.stdin.readline().strip()\n    if not line:\n        return\n    a_str, b_str = line.split()\n    a = int(a_str)\n    b = int(b_str)\n    sum_val = a + b\n    diff_val = a - b\n    prod_val = a * b\n    avg_val = (a + b) / 2\n    print(f\"和:{sum_val} 差:{diff_val} 積:{prod_val} 平均:{avg_val:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 3\n",
          "expected_output": "和:15 差:9 積:36 平均:7.5\n",
          "success": true,
          "output": "和:15 差:9 積:36 平均:7.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 0,
    "title": "學生資料類別設計",
    "description_snippet": "請定義一個 Student 類別，具有屬性 name（姓名）與 score（分數）。\n1. 於 __init__() 建構子中初始化這兩個屬性。\n2. 定義方法 show_info()，輸出『XXX ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision etc. There's no decision needed. Just sequence: Start, define class, constructor, method, create objects, call method, End. Each step should be a line. Need arrow → before each step after Start? Format sample shows:\n\nStart\n→ Step 1: ... // ...\n→ Decision: ...\nYes → ...\nEnd\n\nSo we can produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 Student 類別 // 開始定義類別\n→ Step 2: 定義 __init__(self, name, score) // 建構子，初始化屬性\n→ Step 3: self.name = name // 設定 name\n→ Step 4: self.score = score // 設定 score\n→ Step 5: 定義 show_info(self) // 定義顯示方法\n→ Step 6: 輸出 f'{self.name} 的分數是 {self.score}' // 顯示訊息\n→ Step 7: 建立 student1 = Student('Alice', 95) // 建立第一個物件\n→ Step 8: 建立 student2 = Student('Bob', 88) // 建立第二個物件\n→ Step 9: 呼叫 student1.show_info() // 呼叫第一個物件的方法\n→ Step 10: 呼叫 student2.show_info() // 呼叫第二個物件的方法\nEnd // 程式執行結束\n\nMake sure each line includes arrow, number or description, and comment. Should we use arrow and Step numbers? Yes. Use → before each step. In sample, Step lines had \"Step 1:\" etc. So we should do same.\n\nEnsure each line ends with // 解釋.\n\nOk. Provide output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 Student 類別 // 開始定義類別\n→ Step 2: 定義 __init__(self, name, score) // 建構子，初始化屬性\n→ Step 3: self.name = name // 設定 name 屬性\n→ Step 4: self.score = score // 設定 score 屬性\n→ Step 5: 定義 show_info(self) // 定義顯示資訊的方法\n→ Step 6: 輸出 f'{self.name} 的分數是 {self.score}' // 印出姓名與分數\n→ Step 7: 建立 student1 = Student('Alice', 95) // 建立第一個 Student 物件\n→ Step 8: 建立 student2 = Student('Bob', 88) // 建立第二個 Student 物件\n→ Step 9: 呼叫 student1.show_info() // 呼叫第一個物件的 show_info 方法\n→ Step 10: 呼叫 student2.show_info() // 呼叫第二個物件的 show_info 方法\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Student:\n    \"\"\"學生類別，儲存姓名與分數，並提供顯示資訊的方法。\"\"\"\n    def __init__(self, name: str, score: int):\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        \"\"\"印出『姓名 的分數是 分數』的訊息。\"\"\"\n        print(f'{self.name} 的分數是 {self.score}')\n\ndef main():\n    \"\"\"從標準輸入讀取學生資料，若無輸入則使用預設資料。\"\"\"\n    # 讀取所有輸入行\n    raw_data = sys.stdin.read().strip().splitlines()\n    students = []\n\n    if raw_data:\n        # 每行假設為「姓名 分數」\n        for line in raw_data:\n            parts = line.strip().split()\n            if len(parts) >= 2:\n                name = parts[0]\n                try:\n                    score = int(parts[1])\n                except ValueError:\n                    continue  # 若分數無法轉成 int，則忽略此行\n                students.append(Student(name, score))\n    else:\n        # 若沒有輸入，使用示例資料\n        students.append(Student('Alice', 90))\n        students.append(Student('Bob', 80))\n\n    # 顯示所有學生資訊\n    for student in students:\n        student.show_info()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 1,
    "title": "動物類別繼承",
    "description_snippet": "請設計一個父類別 Animal，包含方法 make_sound()，印出『動物發出聲音』。\n建立子類別 Dog 與 Cat：\n1. Dog 覆寫 make_sound()，輸出『汪汪！』。\n2. Ca...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode following format. Use Start, End, Decision maybe not needed. Just class definitions and method calls. Each line with explanation. Use arrow → for step. For class definitions, maybe Step 1: 定義父類別 Animal // etc. Each method definition line. We'll produce lines. Let's craft.\n\nNeed \"逐行輸出\" each line: \"虛擬碼步驟 [space] // 解釋\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Animal // 建立父類別\n    → Step 1.1: 方法 make_sound() // 定義發聲方法\n        → Step 1.1.1: 輸出 '動物發出聲音' // 標準聲音\n→ Step 2: 定義類別 Dog 繼承 Animal // 子類別 Dog\n    → Step 2.1: 覆寫方法 make_sound() // Dog 的發聲\n        → Step 2.1.1: 輸出 '汪汪！' // Dog 聲音\n→ Step 3: 定義類別 Cat 繼承 Animal // 子類別 Cat\n    → Step 3.1: 覆寫方法 make_sound() // Cat 的發聲\n        → Step 3.1.1: 輸出 '喵～' // Cat 聲音\n→ Step 4: 建立 Dog 物件 dog // 創建 Dog 實例\n    → Step 4.1: 呼叫 dog.make_sound() // 執行 Dog 聲音\n→ Step 5: 建立 Cat 物件 cat // 創建 Cat 實例\n    → Step 5.1: 呼叫 cat.make_sound() // 執行 Cat 聲音\nEnd // 程式執行結束\n\nMake sure each line is separate. Use arrow as specified. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Animal // 建立父類別  \n → Step 1.1: 方法 make_sound() // 定義發聲方法  \n  → Step 1.1.1: 輸出 '動物發出聲音' // 標準聲音  \n→ Step 2: 定義類別 Dog 繼承 Animal // 子類別 Dog  \n → Step 2.1: 覆寫方法 make_sound() // Dog 的發聲  \n  → Step 2.1.1: 輸出 '汪汪！' // Dog 聲音  \n→ Step 3: 定義類別 Cat 繼承 Animal // 子類別 Cat  \n → Step 3.1: 覆寫方法 make_sound() // Cat 的發聲  \n  → Step 3.1.1: 輸出 '喵～' // Cat 聲音  \n→ Step 4: 建立 Dog 物件 dog // 創建 Dog 實例  \n → Step 4.1: 呼叫 dog.make_sound() // 執行 Dog 聲音  \n→ Step 5: 建立 Cat 物件 cat // 創建 Cat 實例  \n → Step 5.1: 呼叫 cat.make_sound() // 執行 Cat 聲音  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Animal:\n    def make_sound(self):\n        print('動物發出聲音')\n\nclass Dog(Animal):\n    def make_sound(self):\n        print('汪汪！')\n\nclass Cat(Animal):\n    def make_sound(self):\n        print('喵～')\n\ndef main():\n    # Consume all input (if any) but no further processing needed\n    sys.stdin.read()\n    # Create instances and call their methods\n    dog = Dog()\n    cat = Cat()\n    dog.make_sound()\n    cat.make_sound()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "汪汪！\n喵～",
          "success": true,
          "output": "汪汪！\n喵～"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 0,
    "title": "溫度判斷",
    "description_snippet": "請寫一個程式，輸入一個整數代表氣溫，並依下列規則輸出：\n- 小於 0：『冰點以下』\n- 0~29：『正常範圍』\n- 30~39：『炎熱』\n- 大於等於 40：『極端高溫』...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with arrow arrows and explanations. The input: an integer temperature. Output classification based on ranges. So produce Start, input, decision chain.\n\nWe should include Start, input temperature, then Decision chain with nested decisions or multiple if-else.\n\nWe can implement as: Decision: temp < 0? Yes → output \"冰點以下\", No → Decision: temp <= 29? Yes → output \"正常範圍\", No → Decision: temp <= 39? Yes → output \"炎熱\", No → output \"極端高溫\".\n\nFollow format: each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrows \"→\". Use \"Decision:\" lines. Use nested indent. Provide correct indentation. Use Start and End.\n\nLet's output lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入氣溫 // 取得使用者輸入的整數氣溫\n→ Decision: 氣溫 < 0? // 檢查是否低於冰點\n    Yes → Step 2: 輸出 '冰點以下' // 若低於 0，顯示此訊息\n    No  → Decision: 氣溫 ≤ 29? // 若不低於 0，檢查是否在正常範圍內\n        Yes → Step 3: 輸出 '正常範圍' // 0~29，顯示此訊息\n        No  → Decision: 氣溫 ≤ 39? // 若超過 29，檢查是否為炎熱區\n            Yes → Step 4: 輸出 '炎熱' // 30~39，顯示此訊息\n            No  → Step 5: 輸出 '極端高溫' // 大於等於 40，顯示此訊息\nEnd // 程式執行結束\n\nMake sure indent lines after arrow? In sample, they show:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\n\nSo indent by 4 spaces for nested. Use 4 spaces indent before Yes→ etc. We'll match. So produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入氣溫 // 取得使用者輸入的整數氣溫  \n→ Decision: 氣溫 < 0? // 檢查氣溫是否低於冰點  \n    Yes → Step 2: 輸出 '冰點以下' // 若低於 0，顯示此訊息  \n    No  → Decision: 氣溫 ≤ 29? // 若不低於 0，檢查是否在正常範圍內  \n        Yes → Step 3: 輸出 '正常範圍' // 0~29，顯示此訊息  \n        No  → Decision: 氣溫 ≤ 39? // 若超過 29，檢查是否為炎熱區  \n            Yes → Step 4: 輸出 '炎熱' // 30~39，顯示此訊息  \n            No  → Step 5: 輸出 '極端高溫' // 大於等於 40，顯示此訊息  \nEnd // 程式執行結束",
      "generated_code": "def classify_temperature(temp):\n    if temp < 0:\n        return \"冰點以下\"\n    elif temp < 30:\n        return \"正常範圍\"\n    elif temp < 40:\n        return \"炎熱\"\n    else:\n        return \"極端高溫\"\n\nif __name__ == \"__main__\":\n    import sys\n    data = sys.stdin.read().strip()\n    if data:\n        temp = int(data)\n        print(classify_temperature(temp))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "35",
          "expected_output": "炎熱",
          "success": true,
          "output": "炎熱"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 1,
    "title": "三數最大值",
    "description_snippet": "請寫一個程式，輸入三個整數，輸出其中最大的數字。不得使用 Python 內建 max()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation, following format. The user asks: \"請寫一個程式，輸入三個整數，輸出其中最大的數字。不得使用 Python 內建 max()。請根據輸出格式要求產生虛擬碼和逐行解釋\"\n\nWe produce steps: Start, input three numbers, compare, output max. Use decisions. Must not use Python max().\n\nUse virtual code syntax with arrows. Provide explanation after each line. Let's produce.\n\nRemember to use \"虛擬碼步驟 [space] // 解釋\". Use \"Start\", \"End\", \"Decision:\" etc.\n\nWe'll output: Start // 程式開始執行\n→ Step 1: 輸入整數 a // 取得第一個數字\n→ Step 2: 輸入整數 b // 取得第二個數字\n→ Step 3: 輸入整數 c // 取得第三個數字\n→ Decision: a > b? // 判斷 a 是否大於 b\n   Yes → Decision: a > c? // 如果 a > b，進一步比較 a 與 c\n      Yes → Step 4: max = a // a 是最大的\n      No  → Step 4: max = c // c 大於 a\n   No  → Decision: b > c? // 若 a ≤ b，判斷 b 與 c\n      Yes → Step 4: max = b // b 最大\n      No  → Step 4: max = c // c 最大\n→ Step 5: 輸出 max // 顯示最大值\nEnd // 程式結束\n\nEnsure each line has virtual code step + explanation. Include arrows. Should match format. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 a // 取得第一個整數  \n→ Step 2: 輸入整數 b // 取得第二個整數  \n→ Step 3: 輸入整數 c // 取得第三個整數  \n→ Decision: a > b? // 判斷 a 是否大於 b  \n  Yes → Decision: a > c? // 若 a > b，進一步比較 a 與 c  \n    Yes → Step 4: max = a // a 為三個數中最大者  \n    No  → Step 4: max = c // c 大於 a  \n  No  → Decision: b > c? // 若 a ≤ b，判斷 b 與 c  \n    Yes → Step 4: max = b // b 為三個數中最大者  \n    No  → Step 4: max = c // c 為三個數中最大者  \n→ Step 5: 輸出 max // 顯示最大的數字  \nEnd // 程式執行結束",
      "generated_code": "def find_largest(a: int, b: int, c: int) -> int:\n    \"\"\"\n    比較三個整數，回傳最大的那一個。\n    不使用 Python 內建的 max()。\n    \"\"\"\n    if a >= b and a >= c:\n        return a\n    elif b >= a and b >= c:\n        return b\n    else:\n        return c\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取三個整數，假設以空格分隔\n    a, b, c = map(int, input().split())\n    # 計算最大值並輸出\n    print(find_largest(a, b, c))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 25 7",
          "expected_output": "25",
          "success": true,
          "output": "25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 0,
    "title": "倍數輸出",
    "description_snippet": "請寫一個程式，輸入一個正整數 n，使用 for 迴圈搭配 range()，輸出 1~50 之間所有能被 n 整除的數字。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanations for the given requirement: input positive integer n, use for loop with range, output numbers 1 to 50 that are divisible by n.\n\nWe must follow format: each line \"虛擬碼步驟 // 解釋\". Use arrow (→). Use Start, End, Decision:. Use \"Step\" lines.\n\nStructure: Start // program starts\n→ Step 1: 輸入 n // read integer\n→ Decision: if n <= 0? // check positive\n    Yes → Step 2: 輸出 '請輸入正整數' // error\n    No  → Step 3: 迭代 i from 1 to 50 // range\n        → Step 4: 如果 i mod n == 0? // check divisibility\n            Yes → Step 5: 輸出 i // output number\nEnd // program ends\n\nWe need to include arrow for each step. The decision should have Yes and No branches.\n\nWe need to write each line.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n // 從使用者處取得正整數  \n→ Decision: n 是否小於或等於 0? // 檢查輸入是否為正整數  \n Yes → Step 2: 輸出 '請輸入正整數' // 若不是正整數，顯示錯誤訊息  \n No  → Step 3: 迭代 i 從 1 到 50 // 使用 for 迴圈和 range() 進行遍歷  \n  → Decision: i 是否能被 n 整除? // 判斷 i % n 是否等於 0  \n   Yes → Step 4: 輸出 i // 若能被整除，輸出該數字  \n   No  → Step 5: 跳過 // 若不能整除，直接繼續迴圈  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    import sys\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    result = []\n    for i in range(1, 51):\n        if i % n == 0:\n            result.append(str(i))\n    print(' '.join(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "7",
          "expected_output": "7 14 21 28 35 42 49",
          "success": true,
          "output": "7 14 21 28 35 42 49"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 1,
    "title": "密碼檢查",
    "description_snippet": "請寫一個程式，讓使用者重複輸入密碼，直到輸入正確的密碼 'python123' 為止。每次輸入錯誤都提示『密碼錯誤，請再試一次』，輸入正確時輸出『登入成功』。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce line-by-line virtual code steps with explanation. Use Start, Decision, arrows, etc. Provide the steps for the requirement: repeated input until correct password 'python123', prompt each incorrect attempt, success output. Need to produce only the virtual code lines, each line followed by explanation comment. No real code. Use \"→\" arrow to show next step. Use Decision: structure with Yes/No branches.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 初始化正確密碼 = 'python123' // 設定正確密碼\n→ Step 2: 進入重複輸入循環 // 開始循環\n    → Decision: 是否已輸入密碼？ // 檢查是否已有輸入\n        Yes → Step 3: 檢查輸入是否等於正確密碼 // 比對輸入與正確密碼\n            Yes → Step 4: 輸出 '登入成功' // 密碼正確，登入成功\n            No  → Step 5: 輸出 '密碼錯誤，請再試一次' // 密碼錯誤，提示重試\n        No  → Step 6: 取得使用者輸入 // 請使用者輸入密碼\n    → Decision: 是否輸入正確？ // 再判斷是否正確\n        Yes → End // 結束程序\n        No  → 回到 Step 2 // 重新進行循環\n\nBut must use the format exactly: each line \"虛擬碼步驟 [空格] // 解釋\". Use Start, End, Decision:, arrow. Also we need to include indentation to show branching? The sample uses indentation for branches. We'll replicate similar.\n\nWe must produce each step line as a separate line. Let's design the flow.\n\nWe could structure as:\n\nStart // 程式開始執行\n→ Step 1: Set correctPassword = 'python123' // 設定正確密碼\n→ Step 2: Loop Begin // 開始重複輸入循環\n    → Decision: Is inputPassword equal to correctPassword? // 判斷輸入是否正確\n        Yes → Step 3: Output '登入成功' // 正確密碼，登入成功\n        No  → Step 4: Output '密碼錯誤，請再試一次' // 錯誤提示\n    → Step 5: Prompt user to input password // 重新輸入\n    → Decision: Did user input correctPassword? // 再判斷\n        Yes → End // 結束程式\n        No  → Go back to Step 2 // 重新進入循環\n\nBut need arrow to next step: \"→ Step ...\". For decision branches, we can have \"→ Decision: ...\" then \"Yes → ...\", \"No → ...\". We must maintain the indentation to show nested steps.\n\nLet's create lines:\n\nStart // 程式開始執行\n→ Step 1: Set correctPassword = 'python123' // 設定正確密碼\n→ Step 2: Repeat Loop // 進入重複輸入循環\n    → Decision: 輸入的密碼是否等於 correctPassword? // 檢查輸入是否正確\n        Yes → Step 3: 輸出 '登入成功' // 密碼正確，登入成功\n        No  → Step 4: 輸出 '密碼錯誤，請再試一次' // 密碼錯誤，提示重試\n    → Step 5: 取得使用者輸入密碼 // 重新輸入\n    → Decision: 輸入的密碼是否等於 correctPassword? // 再次判斷\n        Yes → End // 密碼正確，結束程式\n        No  → Go back to Step 2 // 錯誤，返回循環\n\nBut we need to ensure arrow syntax: \"→ Step 2: Repeat Loop\" maybe \"→ Step 2: Start Loop\". The sample uses \"→ Step 1: 輸入使用者數字\". We'll keep.\n\nNow produce the final answer. Ensure each line ends with \"// 解釋\". Use Chinese explanation. Let's format. Use proper indentation: indent 4 spaces? The sample shows 4 spaces before \"Yes →\" etc. We'll follow that.\n\nAlso note that we should not output any actual code or text outside. Just the lines. Provide each line. Let's do it.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set correctPassword = 'python123' // 設定正確密碼  \n→ Step 2: Repeat Loop // 進入重複輸入循環  \n  → Decision: 輸入的密碼是否等於 correctPassword? // 檢查輸入是否正確  \n   Yes → Step 3: Output '登入成功' // 密碼正確，登入成功  \n   No  → Step 4: Output '密碼錯誤，請再試一次' // 密碼錯誤，提示重試  \n  → Step 5: Prompt user for password input // 重新輸入密碼  \n  → Decision: 輸入的密碼是否等於 correctPassword? // 再次判斷  \n   Yes → End // 密碼正確，結束程式  \n   No  → Go back to Step 2 // 錯誤，返回循環",
      "generated_code": "def main():\n    correct_password = 'python123'\n    while True:\n        try:\n            # 從標準輸入讀取一行，作為一次密碼輸入\n            pwd = input()\n        except EOFError:\n            # 若遇到輸入結束，直接跳出循環\n            break\n\n        if pwd == correct_password:\n            # 密碼正確，輸出登入成功並結束程式\n            print('登入成功')\n            break\n        else:\n            # 密碼錯誤，提示使用者重新輸入\n            print('密碼錯誤，請再試一次')\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "abc\n1234\npython123",
          "expected_output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功",
          "success": true,
          "output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 0,
    "title": "串列操作練習",
    "description_snippet": "請建立一個串列，內容包含整數 1 到 5，接著完成以下操作：\n1. 新增一個元素 6 到串列尾端。\n2. 刪除串列中的第 2 個元素（索引 1 的位置）。\n3. 輸出最後的串列結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines per requirement, each line with \"虛擬碼步驟\" + \" // 解釋/說明\". Use arrows. The steps: Start, create list, add element, remove element, output list, End.\n\nWe should ensure \"Step\" formatting similar to example. Provide each step with arrow or Decision? No decision needed.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: list = [1, 2, 3, 4, 5] // 建立初始串列\n→ Step 2: list.append(6) // 在尾端新增元素 6\n→ Step 3: list.remove_at(1) // 刪除索引 1 的元素，即原第二個元素\n→ Step 4: output list // 輸出最終串列\nEnd // 程式執行結束\n\nWe must use virtual code arrow arrow. Use \"→ Step\". Provide explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: list = [1, 2, 3, 4, 5] // 建立初始串列  \n→ Step 2: list.append(6) // 在尾端新增元素 6  \n→ Step 3: list.remove_at(1) // 刪除索引 1 的元素，即原第二個元素  \n→ Step 4: output list // 輸出最終串列  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取輸入（如果有的話）但不做任何處理\n    sys.stdin.read()\n\n    # 建立初始串列\n    nums = [1, 2, 3, 4, 5]\n    # 在尾端新增元素 6\n    nums.append(6)\n    # 刪除索引 1 的元素（即原本的第二個元素）\n    del nums[1]\n    # 輸出最終結果\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[1, 3, 4, 5, 6]",
          "success": true,
          "output": "[1, 3, 4, 5, 6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 1,
    "title": "集合函數練習",
    "description_snippet": "請建立一個集合 fruits = {'apple', 'banana'}，並完成以下操作：\n1. 使用 add() 新增 'orange'。\n2. 使用 update() 一次新增 'grape' 與...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nThe user wants to produce pseudo-code steps according to specified format, not actual code, but pseudocode lines with explanation. Must be line-by-line. The steps: start, create set, add, update, remove, discard, output. Also we might include Decision? Not necessary because no conditions besides remove/discard, but we can show error handling? Maybe show try-catch? But requirement: use arrow, Decision, etc. But for remove, we can just show step. Might include a decision if element exists? Not needed. Use simple steps. Let's produce lines:\n\nStart\n→ Step 1: Initialize set fruits = {'apple', 'banana'} // 建立集合\n→ Step 2: Call fruits.add('orange') // 新增單一元素\n→ Step 3: Call fruits.update({'grape', 'melon'}) // 一次新增多個元素\n→ Step 4: Call fruits.remove('banana') // 移除已存在元素\n→ Step 5: Call fruits.discard('pineapple') // 嘗試移除不存在元素，不會錯誤\n→ Step 6: Output fruits // 顯示最終集合\nEnd\n\nAdd explanation lines after each. Must include arrow. Format: `虛擬碼步驟 // 解釋`. Use arrow for steps. For final line \"End\" maybe no arrow.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize set fruits = {'apple', 'banana'} // 建立包含兩個元素的集合  \n→ Step 2: Call fruits.add('orange') // 將單一元素 'orange' 新增至集合  \n→ Step 3: Call fruits.update({'grape', 'melon'}) // 一次新增多個元素 'grape' 與 'melon'  \n→ Step 4: Call fruits.remove('banana') // 移除已存在的元素 'banana'  \n→ Step 5: Call fruits.discard('pineapple') // 嘗試移除不存在的元素 'pineapple'，不會拋出錯誤  \n→ Step 6: Output fruits // 顯示最終的集合內容  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    # 讀取並忽略任何輸入，確保程式可從 stdin 取得資料\n    import sys\n    sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 使用 add() 新增 'orange'\n    fruits.add('orange')\n\n    # 使用 update() 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 使用 remove() 移除 'banana'\n    fruits.remove('banana')\n\n    # 使用 discard() 嘗試移除不存在的 'pineapple'\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"melon\",\"grape\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'melon', 'grape', 'apple'}\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 0,
    "title": "質數判斷函數",
    "description_snippet": "請寫一個函數 is_prime(n)，判斷一個整數是否為質數。如果是質數回傳 True，否則回傳 False。\n\n質數定義：大於 1，且除了 1 和自己本身外，沒有其他因數。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with comments. Use Start, End, Decision, arrows. Provide a function is_prime(n). Steps: input n, check n <=1? if Yes return False. Then loop i from 2 to sqrt(n). For each i if n mod i == 0 then return False. If loop completes return True. Use decisions appropriately. We'll output each line as \"虛擬碼步驟 // 解釋\". Use arrow notation. Provide line for function start and end. Probably include \"Start // 程式開始執行\" then function header. Provide \"End // 程式執行結束\" after return. We'll include \"Decision:\" lines for conditions. Use \"Yes →\" and \"No →\" arrows. Provide comment after each line. Ensure each line is separate. No actual code. Use 虛擬碼. Provide arrow as \"→\". Provide indentation maybe but not necessary.\n\nLet's craft.\n\nLine1: Start // 程式開始執行\nLine2: → Function is_prime(n) // 定義函式\nLine3: → Decision: n <= 1? // 檢查是否小於等於 1\nLine4:     Yes → Return False // 小於等於 1 不是質數\nLine5:     No  → Step 1: 計算 limit = floor(sqrt(n)) // 設定迴圈上限\nLine6: → Step 2: i = 2 // 初始因子\nLine7: → Decision: i <= limit? // 是否還有因子要檢查\nLine8:     Yes → Decision: n mod i == 0? // i 是否為因子\nLine9:         Yes → Return False // 找到因子，非質數\nLine10:        No  → Step 3: i = i + 1 // 進一步檢查下一個因子\nLine11:        → Back to Decision: i <= limit? // 回到判斷\nLine12:     No  → Return True // 沒有因子，為質數\nLine13: End // 程式執行結束\n\nNeed to ensure \"→ Back to\" not required but we can show loop. Might use \"→ Loop\" but we can use \"→ Decision:\" again.\n\nLet's refine lines:\n\nLine1 Start\nLine2 Function is_prime(n)\nLine3 Decision: n <= 1? // 判斷是否小於等於1\nLine4 Yes → Return False // 非質數\nLine5 No → Step 1: limit = floor(sqrt(n)) // 設定檢查上限\nLine6 Step 2: i = 2 // 開始檢查因子\nLine7 Decision: i <= limit? // 是否還有因子可檢查\nLine8 Yes → Decision: n mod i == 0? // i 是否為 n 的因子\nLine9 Yes → Return False // 找到因子，非質數\nLine10 No → Step 3: i = i + 1 // 移動到下一個因子\nLine11 → Decision: i <= limit? // 重新判斷是否還有因子\nLine12 No → Return True // 無因子，為質數\nLine13 End\n\nWe must maintain arrow notation consistent: \"→\" at start of each line.\n\nAlso need to include \"Yes →\" and \"No →\". Provide indentation via spaces maybe.\n\nEnsure each line has comment after //.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Function is_prime(n) // 定義判斷質數的函式\n→ Decision: n <= 1? // 檢查輸入是否小於等於 1\n    Yes → Return False // 小於等於 1 不是質數，直接回傳 False\n    No  → Step 1: limit = floor(sqrt(n)) // 設定檢查上限為 n 的平方根\n→ Step 2: i = 2 // 初始化因子從 2 開始\n→ Decision: i <= limit? // 判斷是否還有因子需要檢查\n    Yes → Decision: n mod i == 0? // 檢查 i 是否為 n 的因子\n        Yes → Return False // 找到因子，n 不是質數\n        No  → Step 3: i = i + 1 // 移動到下一個可能的因子\n        → Decision: i <= limit? // 重新判斷是否還有因子需要檢查\n    No  → Return True // 未發現任何因子，n 為質數\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef is_prime(n):\n    ...\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    exec(data, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(is_prime(7))\nprint(is_prime(12))",
          "expected_output": "True\nFalse",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'True\\nFalse'\nGot (Norm):      'None\\nNone'\n--- (Raw) ---\nRaw Expected: 'True\\nFalse'\nRaw Got:      'None\\nNone'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 1,
    "title": "計算平均分數",
    "description_snippet": "請寫一個函數 calc_avg(*scores)，接收多個分數作為參數，並回傳平均值 (四捨五入到小數點後 2 位)。\n\n限制：不可使用內建函數 sum()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. We need to write pseudocode for a function calc_avg(*scores) that receives multiple scores, compute average, round to 2 decimal places, without using sum(). Use accumulation loop.\n\nWe should include Start, function definition, accumulate sum, count, compute average, round to 2 decimal places, return value, End. The rounding can be using a multiplication: rounded = (int(avg*100 + 0.5))/100. Or using round? But probably avoid round? Use simple method.\n\nWe need to include virtual arrows: Start, → Step: function, etc. Decision nodes if needed? Not necessary.\n\nWe need to follow output format: Each line: \"虛擬碼步驟 // 解釋\". Use \"Start\" and \"End\". Use \"→\" arrow for steps.\n\nLet's craft:\n\nStart\n→ Step 1: 定義函式 calc_avg(*scores) // 開始定義函式\n→ Step 2: 初始化 total = 0, count = 0 // 用於累積分數與計數\n→ Step 3: 迭代 scores 中的每個 score\n→ Step 4: total = total + score // 將分數累加到總和\n→ Step 5: count = count + 1 // 计数加一\n→ Step 6: End 迴圈 // 完成所有分數處理\n→ Step 7: If count == 0 // 檢查是否有分數\n    Yes → Step 8: Return 0.0 // 無分數時平均為 0.0\n    No  →\n→ Step 9: avg = total / count // 計算平均值\n→ Step 10: rounded = (int(avg * 100 + 0.5)) / 100.0 // 四捨五入到小數點後兩位\n→ Step 11: Return rounded // 返回結果\nEnd\n\nNeed each line with arrow. For decision block, we use indentation with Yes → and No →. Ensure formatting. Use virtual code lines. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 calc_avg(*scores) // 開始定義可接受多個分數的函式  \n→ Step 2: 初始化 total = 0, count = 0 // 用於累加分數與計算分數個數  \n→ Step 3: 迭代 scores 中的每個 score // 逐一處理每個傳入的分數  \n→ Step 4: total = total + score // 將當前分數累加到總和  \n→ Step 5: count = count + 1 // 分數個數加一  \n→ Step 6: End 迴圈 // 所有分數已處理完畢  \n→ Step 7: Decision: 如果 count == 0? // 檢查是否有任何分數  \n  Yes → Step 8: Return 0.0 // 沒有分數時平均值視為 0.0  \n  No  →  \n→ Step 9: avg = total / count // 計算平均值  \n→ Step 10: rounded = (int(avg * 100 + 0.5)) / 100.0 // 四捨五入到小數點後兩位  \n→ Step 11: Return rounded // 回傳四捨五入後的平均值  \nEnd // 程式執行結束",
      "generated_code": "def calc_avg(*scores):\n    \"\"\"計算多個分數的平均值，四捨五入到小數點後兩位。\"\"\"\n    total = 0\n    count = 0\n    for s in scores:\n        total += s\n        count += 1\n    if count == 0:\n        return 0.0\n    return round(total / count, 2)\n\ndef main():\n    import sys\n    # 讀取標準輸入中的所有程式碼並執行\n    code = sys.stdin.read()\n    if code:\n        exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(calc_avg(80, 90, 100))\nprint(calc_avg(70, 75, 85, 95))",
          "expected_output": "90.0\n81.25",
          "success": true,
          "output": "90.0\n81.25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 0,
    "title": "列表與條件生成式練習",
    "description_snippet": "請寫一個程式，建立一個包含 1 到 20 的整數列表，接著使用列表生成式（List Comprehension）產生一個新列表，只保留偶數並將它們平方後輸出結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a virtual code snippet, step by step, using arrow syntax, explaining each line. We need to follow the format: each line \"虛擬碼步驟\" followed by space then \"// 解釋/說明\". Use Start, End, Decision if needed. For this simple code, no decisions needed, just steps. Steps: Start, create list from 1 to 20, list comprehension to filter evens and square, output result, End.\n\nLet's create steps:\n\nStart\n→ Step 1: 初始化列表 numbers = [1, 2, ..., 20] // 建立 1-20 的整數列表\n→ Step 2: new_list = [x*x for x in numbers if x % 2 == 0] // 用列表生成式保留偶數並平方\n→ Step 3: 輸出 new_list // 顯示結果\nEnd\n\nWe should include arrow before steps? Example: \"→ Step 1:\" etc. Use \"→\" for each. Let's match the sample.\n\nAlso might need to mention building list via range. We can use \"range(1, 21)\". Provide that in explanation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: numbers ← range(1, 21) // 建立 1 至 20 的整數序列\n→ Step 2: new_list ← [x*x for x in numbers if x % 2 == 0] // 生成新列表：保留偶數並平方\n→ Step 3: 輸出 new_list // 顯示結果\nEnd // 程式執行結束\n\nMake sure syntax: use ← for assignment? But arrow \"←\" used in example? They used \":\" and \"←\"? They used \"Step 1: 輸入使用者數字\". So we can keep \"Step 1:\" then assignment. Might use \"=\".\n\nI'll do: Step 1: numbers = range(1, 21). That should be fine.\n\nAdd Chinese explanation. Also ensure each line ends with comment. Provide step-by-step.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: numbers = range(1, 21) // 建立 1 至 20 的整數序列  \n→ Step 2: new_list = [x * x for x in numbers if x % 2 == 0] // 生成新列表：保留偶數並平方  \n→ Step 3: 輸出 new_list // 顯示結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取所有輸入（若有，若沒有則不影響程式）\n    _ = sys.stdin.read()\n    # 建立 1~20 的整數序列\n    numbers = range(1, 21)\n    # 列表生成式：保留偶數並平方\n    result = [x * x for x in numbers if x % 2 == 0]\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]",
          "success": true,
          "output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 1,
    "title": "map() / filter() / lambda 綜合練習",
    "description_snippet": "請寫一個程式，建立一個列表 numbers = [3, 7, 10, 15, 20]。\n1. 使用 filter() 搭配 lambda 篩選出可被 5 整除的數。\n2. 使用 map() 將這些數字...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code with comments. Format: each line: \"虛擬碼步驟 // 解釋\". Use arrows, decisions if any. There's no conditional logic needed. Just steps. We'll show Start, define list, filter, map, output, End. Provide brief explanation after each line. We'll adhere to formatting. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義列表 numbers = [3, 7, 10, 15, 20] // 建立初始數字集合  \n→ Step 2: filtered = filter(lambda x: x % 5 == 0, numbers) // 篩選出能被5整除的數字  \n→ Step 3: multiplied = map(lambda x: x * 10, filtered) // 將篩選結果中的每個數字乘以10  \n→ Step 4: result = list(multiplied) // 將 map 物件轉成可列印的列表  \n→ Step 5: 輸出 result // 顯示最終結果列表  \nEnd // 程式執行結束",
      "generated_code": "# 建立初始數字列表\nnumbers = [3, 7, 10, 15, 20]\n\n# 使用 filter() 篩選可被 5 整除的數字\nfiltered = filter(lambda x: x % 5 == 0, numbers)\n\n# 使用 map() 將篩選出的數字乘以 10\nmultiplied = map(lambda x: x * 10, filtered)\n\n# 轉成列表以便輸出\nresult = list(multiplied)\n\ndef main() -> None:\n    \"\"\"\n    主函式，執行程式並輸出結果。\n    本題無需從標準輸入讀取資料，直接使用預設的 numbers 列表。\n    \"\"\"\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[100, 150, 200]",
          "success": true,
          "output": "[100, 150, 200]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 0,
    "title": "JSON 檔案儲存與讀取練習",
    "description_snippet": "請寫一個程式，建立一個字典 data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}。\n1. 使用 json.dump() 將其寫入 data.jso...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. Use \"Start\", \"End\". Steps: import json, define data, open file write, use json.dump, close, open file read, use json.load, extract name and city, print. Use Decision? Not needed.\n\nJust produce lines. Ensure each line ends with // explanation. Use virtual arrow →.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import json module // 匯入 JSON 相關功能  \n→ Step 2: data ← {'name': 'Alice', 'age': 25, 'city': 'Taipei'} // 建立資料字典  \n→ Step 3: Open file 'data.json' in write mode as f_write // 開啟檔案準備寫入  \n→ Step 4: json.dump(data, f_write) // 將字典寫入 JSON 檔  \n→ Step 5: Close f_write // 關閉寫入檔案  \n→ Step 6: Open file 'data.json' in read mode as f_read // 重新開啟檔案準備讀取  \n→ Step 7: loaded_data ← json.load(f_read) // 讀取 JSON 檔為字典  \n→ Step 8: name_value ← loaded_data['name'] // 取出 name 欄位  \n→ Step 9: city_value ← loaded_data['city'] // 取出 city 欄位  \n→ Step 10: Print 'Name: ' + name_value, 'City: ' + city_value // 印出 name 與 city  \nEnd // 程式執行結束",
      "generated_code": "import json\nimport sys\n\n# 準備要寫入的資料字典\ndata = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}\n\ndef main() -> None:\n    # 讀取 stdin，雖然此題目不需要輸入，卻必須呼叫以符合「從標準輸入讀取」的規定\n    _ = sys.stdin.read()\n\n    # 1️⃣ 將資料寫入 data.json\n    with open('data.json', 'w', encoding='utf-8') as f_write:\n        json.dump(data, f_write, ensure_ascii=False, indent=2)\n\n    # 2️⃣ 從 data.json 讀回資料\n    with open('data.json', 'r', encoding='utf-8') as f_read:\n        loaded_data = json.load(f_read)\n\n    # 3️⃣ 印出 name 與 city\n    print('姓名：', loaded_data['name'])\n    print('城市：', loaded_data['city'])\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "姓名： Alice\n城市： Taipei",
          "success": true,
          "output": "姓名： Alice\n城市： Taipei"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 1,
    "title": "即時匯率查詢小工具",
    "description_snippet": "請使用 requests 模組串接匯率 API（https://api.exchangerate-api.com/v4/latest/USD），取得當前美元兌換台幣（TWD）的匯率。\n將結果顯示在 t...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code. Should not output actual code, just virtual code with arrows and steps. Each line: \"虛擬碼步驟 // 解釋\". We need to use Start, End, Decision etc. Steps: import modules, create main window, define function to fetch rate, update label, button, run main loop. Use Decision maybe to check if request successful. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 requests、tkinter、threading 模組 // 引入網路請求與 GUI 需要的函式庫  \n→ Step 2: 建立主視窗 root = Tk() // 初始化 tkinter 視窗  \n→ Step 3: 設定視窗標題 root.title('USD → TWD 匯率查詢') // 顯示視窗標題  \n→ Step 4: 建立顯示匯率的 Label rate_label = Label(root, text='匯率將於此顯示', font=('Helvetica', 14)) // 文字區域  \n→ Step 5: rate_label.pack(padx=20, pady=10) // 放置在視窗中  \n→ Step 6: 定義函式 fetch_rate() // 開始匯率取得流程  \n→ Step 6.1: 在 fetch_rate() 內，設定 API URL = 'https://api.exchangerate-api.com/v4/latest/USD' // 目標 API  \n→ Step 6.2: Decision: 嘗試發送 GET 請求? // 檢查網路請求是否成功  \n  Yes → Step 6.2.1: response = requests.get(URL) // 發送請求  \n   Decision: 回傳碼為 200? // 確認成功  \n    Yes → Step 6.2.1.1: data = response.json() // 解析 JSON  \n     Decision: 'TWD' 內存在 data['rates']? // 檢查是否有台幣匯率  \n      Yes → Step 6.2.1.1.1: rate = data['rates']['TWD'] // 取得匯率  \n       Step 6.2.1.1.1.1: 更新 rate_label.text = f'1 USD = {rate:.4f} TWD' // 顯示匯率  \n       End  \n      No → Step 6.2.1.1.2: rate_label.text = '找不到 TWD 匯率' // 錯誤訊息  \n      End  \n     No → Step 6.2.1.2: rate_label.text = '請求失敗，狀態碼 ' + str(response.status_code) // 顯示失敗碼  \n     End  \n  No → Step 6.2.2: rate_label.text = '網路請求錯誤' // 無法發送請求  \n  End  \n→ Step 7: 建立更新按鈕 update_btn = Button(root, text='更新匯率', command=fetch_rate) // 按鈕觸發 fetch_rate  \n→ Step 8: update_btn.pack(pady=5) // 放置按鈕  \n→ Step 9: 執行主迴圈 root.mainloop() // 啟動 GUI 事件迴圈  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\n# -------------------------------------------------\n# 取得美元對台幣匯率的函式\n# -------------------------------------------------\ndef get_rate():\n    \"\"\"\n    連線至 exchangerate-api 取得最新匯率，回傳\n    文字描述：'目前美元匯率：約 X.XXXX TWD'\n    若發生錯誤，回傳錯誤訊息。\n    \"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=5)\n        r.raise_for_status()                 # 若狀態碼不是 200，拋出例外\n        data = r.json()\n        rate = data['rates']['TWD']\n        return f'目前美元匯率：約 {rate:.4f} TWD'\n    except Exception:\n        return '更新失敗，請檢查網路連線'\n\n# -------------------------------------------------\n# GUI 的建立與功能\n# -------------------------------------------------\ndef create_gui():\n    \"\"\"\n    建立簡易的 Tkinter 視窗，包含：\n    1. 顯示匯率的 Label\n    2. 觸發更新匯率的 Button\n    \"\"\"\n    win = tk.Tk()\n    win.title('匯率查詢')\n\n    # 匯率顯示區\n    label = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    # 按鈕觸發更新\n    def update():\n        msg = get_rate()\n        label.config(text=msg)\n\n    tk.Button(win, text='更新匯率', command=update).pack(pady=5)\n\n    win.mainloop()\n\n# -------------------------------------------------\n# 主程式入口\n# -------------------------------------------------\ndef main():\n    \"\"\"\n    讀取 stdin 的內容，若有輸入則執行相對應的邏輯並輸出結果。\n    若 stdin 沒有內容，則啟動 GUI。\n    \"\"\"\n    input_data = sys.stdin.read().strip()\n    if input_data:\n        # 只處理「按下「更新匯率」按鈕」這一條命令\n        if input_data == '按下「更新匯率」按鈕':\n            print(get_rate())\n        else:\n            # 其餘輸入直接忽略，仍啟動 GUI\n            create_gui()\n    else:\n        # 沒有輸入則直接啟動 GUI\n        create_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.8800TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.8800 TWD'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode306.json",
    "problem_index_in_file": 0,
    "title": "Additive Number",
    "description_snippet": "An additive number is a string whose digits can form an additive sequence.\n\nA valid additive sequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to determine if a string is additive number. The output should be line by line, each line: \"虛擬碼步驟 // 解釋\".\n\nWe must avoid actual code; only pseudo steps. Should include decisions and loops. Likely algorithm: iterate over possible splits for first two numbers, then verify sequence. Steps: Start, iterate i from 1 to n-2, j from i+1 to n-1, get first, second; check no leading zeros; then while sum matches next part, update; if reach end, return true. End. Use recursion maybe.\n\nWe output steps with arrows. Use Start, Decision, etc.\n\nWe need to use virtual code arrows (→, Yes →, No →). Each line includes virtual code and comment.\n\nLet's produce steps:\n\nStart\n→ Step 1: 初始化字符串 s // 取得輸入字串\n→ Step 2: 取得字串長度 n // 方便後續迭代\n→ Decision: 如果 n < 3? // 必須至少三位數\n    Yes → Step 3: 返回 false // 字串太短\n    No → \n→ Step 4: 對 i 迴圈從 1 到 n-2 // 第一個數字的結束位置\n    → Decision: 如果 s[0] 為 '0' 且 i > 1? // 前導零\n        Yes → Continue // 跳過這個 i\n        No →\n    → Step 5: 對 j 迴圈從 i+1 到 n-1 // 第二個數字的結束位置\n        → Decision: 如果 s[i] 為 '0' 且 j-i > 1? // 第二個數字前導零\n            Yes → Continue // 跳過這個 j\n            No →\n        → Step 6: 計算 num1 = s[0:i]，num2 = s[i:j] // 兩個初始數字\n        → Step 7: 呼叫檢查序列(num1, num2, j) // 檢查剩餘部分\n        → Decision: 如果檢查結果為 true?\n            Yes → Step 8: 返回 true // 找到合法序列\n            No →\n    → // j 迴圈結束\n→ // i 迴圈結束\n→ Step 9: 返回 false // 沒有合法序列\n\nNow we need to detail the recursive check function:\n\nStep 10: 定義函數檢查序列(a, b, pos) // a, b 為上兩個數字，pos 為目前索引\n    → Step 11: 計算 sumStr = (a + b) 轉字串 // 以字串方式比較\n    → Decision: 如果 s[pos:] 不以 sumStr 開頭?\n        Yes → Step 12: 返回 false // 符合不了\n        No →\n    → Step 13: posNew = pos + len(sumStr) // 移動位置\n    → Decision: 如果 posNew == n?\n        Yes → Step 14: 返回 true // 成功到達結尾\n        No →\n    → Step 15: 呼叫檢查序列(b, sumStr, posNew) // 迭代下一步\n    → 返回上一層結果\n\nWe should keep consistent format with arrows. Use → for next step; Decision lines with Yes → and No →.\n\nNow produce final output. Ensure each line is \"虛擬碼步驟 // 解釋\". The first line \"Start // 程式開始執行\". Use the arrow syntax: \"→ Step 1: ...\". For decisions, indent maybe but not necessary. We need to include \"Decision:\" lines.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 取得使用者提供的數字字串  \n→ Step 2: 取得字串長度 n // 方便後續迭代與檢查  \n→ Decision: 如果 n < 3? // 最少需要三個數字  \n Yes → Step 3: 返回 false // 字串過短，無法形成加法序列  \n No →  \n→ Step 4: 對 i 迴圈從 1 到 n-2 // 第一個數字結束的位置  \n  → Decision: 如果 s[0] 為 '0' 且 i > 1? // 前導零不允許  \n   Yes → Continue // 跳過此 i，嘗試下一個分割點  \n   No →  \n  → Step 5: 對 j 迴圈從 i+1 到 n-1 // 第二個數字結束的位置  \n    → Decision: 如果 s[i] 為 '0' 且 j-i > 1? // 第二個數字前導零  \n     Yes → Continue // 跳過此 j，嘗試下一個分割點  \n     No →  \n    → Step 6: 計算 num1 = s[0:i]，num2 = s[i:j] // 兩個初始數字  \n    → Step 7: 呼叫檢查序列(num1, num2, j) // 檢查剩餘部分是否符合加法規則  \n    → Decision: 檢查結果為 true?  \n     Yes → Step 8: 返回 true // 找到合法的加法序列  \n     No →  \n     // j 迴圈繼續  \n    // i 迴圈繼續  \n→ Step 9: 返回 false // 所有分割都無法形成合法序列  \n\n// ---------- 檢查序列的遞迴函式 ----------\n→ Step 10: 定義函數檢查序列(a, b, pos) // a, b 為前兩個數字，pos 為當前索引  \n  → Step 11: 計算 sumStr = (a + b) 轉為字串 // 以字串形式比較  \n  → Decision: 如果 s[pos:] 不以 sumStr 開頭?  \n   Yes → Step 12: 返回 false // 無法匹配下個數字  \n   No →  \n   → Step 13: posNew = pos + len(sumStr) // 更新索引到下一段  \n   → Decision: 如果 posNew == n?  \n    Yes → Step 14: 返回 true // 成功到達字串結尾  \n    No →  \n    → Step 15: 呼叫檢查序列(b, sumStr, posNew) // 迭代下一個數字  \n    → 返回上一層結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isAdditiveNumber(self, num: str) -> bool:\n        n = len(num)\n        if n < 3:\n            return False\n        for i in range(1, n):          # first split position\n            for j in range(i + 1, n):  # second split position\n                num1, num2 = num[:i], num[i:j]\n                # skip numbers with leading zeros\n                if (len(num1) > 1 and num1[0] == '0') or (len(num2) > 1 and num2[0] == '0'):\n                    continue\n                k = j\n                while k < n:\n                    sum_str = str(int(num1) + int(num2))\n                    if not num.startswith(sum_str, k):\n                        break\n                    k += len(sum_str)\n                    num1, num2 = num2, sum_str\n                if k == n:\n                    return True\n        return False\n\nif __name__ == \"__main__\":\n    # Read entire input, strip whitespace and possible surrounding quotes\n    raw_input = sys.stdin.read().strip()\n    s = raw_input.strip('\"').strip(\"'\")\n    solution = Solution()\n    result = solution.isAdditiveNumber(s)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"112358\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"199100199\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode739.json",
    "problem_index_in_file": 0,
    "title": "Daily Temperatures",
    "description_snippet": "Given an array of integers temperatures represents the daily temperatures, return an array answer su...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for the problem \"Daily Temperatures\" (Leetcode 739). Provide step-by-step pseudocode using arrow notation. We need to show use of stack to find next greater. Steps: Input array, initialize answer array zeros, stack to store indices. Iterate from end to start or start to end. Common solution: iterate from last index to first, keep stack of indices with temperatures in increasing order. For each index i, pop stack while temp[i] >= temp[stack.top()], then answer[i] = stack.empty ? 0 : stack.top() - i. Push i onto stack. End. Provide each line with explanation.\n\nWe must output each line of virtual code with explanation, following format. Use Start, End, Decision, etc.\n\nWe'll produce lines like:\n\nStart // 程式開始\n→ Step 1: 輸入 temperatures // 取得溫度陣列\n→ Step 2: 建立 answer 陣列長度與 temperatures 相同，預設值 0 // 初始化答案\n→ Step 3: 建立空堆疊 stack 儲存索引 // 用於追蹤未解決的日子\n→ Step 4: 從最後一天 i = n-1 迴圈至 0 // 逆序處理\n    → Decision: 是否有堆疊? // 判斷堆疊是否空\n        Yes → Step 5: 取 stack.top() 作為候選下個更熱日索引\n        No  → Step 6: answer[i] = 0 // 沒有更熱日\n    → Step 7: 循環 while temperatures[i] >= temperatures[stack.top()] 且 stack 非空\n        // 移除所有不比今天熱或相同的日子\n    → Decision: 是否有堆疊? // 再次判斷\n        Yes → Step 8: answer[i] = stack.top() - i // 計算天數差\n        No  → Step 9: answer[i] = 0 // 沒有更熱日\n    → Step 10: push i onto stack // 將今天作為候選\nEnd // 完成\n\nBut the format demands: Each line with virtual code plus // explanation. We need to include the indentation for nested steps. Use arrow notation.\n\nLet's produce like:\n\nStart // 程式開始\n→ Step 1: 獲取輸入陣列 temperatures // 取得每日溫度\n→ Step 2: 初始化 answer = Array(length=temperatures.length, default=0) // 設定答案陣列\n→ Step 3: 初始化 stack = 空堆疊 // 用來儲存未處理的日子索引\n→ Step 4: 對 i 從 temperatures.length-1 迴到 0 // 從最後一天往前遍歷\n    → Decision: 如果 stack 非空? // 判斷堆疊是否有索引\n        Yes → Step 5: // 堆疊非空\n        No  → Step 6: answer[i] = 0 // 沒有更熱的日子\n    → Step 7: while stack 非空 且 temperatures[i] >= temperatures[stack.top()] // 移除不比今天熱的日子\n        // 這裡不需要特別解釋，使用空行\n    → Decision: 如果 stack 非空? // 再次判斷堆疊\n        Yes → Step 8: answer[i] = stack.top() - i // 計算距離\n        No  → Step 9: answer[i] = 0 // 沒有更熱的日子\n    → Step 10: push i onto stack // 把今天的索引加入堆疊\nEnd // 程式結束\n\nBut must follow exactly: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So each line must have exactly one arrow or text before the //.\n\nWe need to use \"→\" arrow at the start of each step line, except Start and End. Indentation may show nested.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 輸入 temperatures // 取得溫度陣列\n→ Step 2: 建立 answer 陣列長度與 temperatures 相同，預設值 0 // 初始化答案\n→ Step 3: 建立空堆疊 stack 儲存索引 // 用於追蹤未解決的日子\n→ Step 4: 從最後一天 i = n-1 迴圈至 0 // 逆序處理\n    → Decision: 是否有堆疊? // 判斷堆疊是否空\n        Yes → Step 5: // 堆疊非空\n        No  → Step 6: answer[i] = 0 // 沒有更熱日\n    → Step 7: 循環 while stack 非空 且 temperatures[i] >= temperatures[stack.top()] // 移除不比今天熱或相同的日子\n    → Decision: 是否有堆疊? // 再次判斷\n        Yes → Step 8: answer[i] = stack.top() - i // 計算天數差\n        No  → Step 9: answer[i] = 0 // 沒有更熱日\n    → Step 10: push i onto stack // 將今天作為候選\nEnd // 程式結束\n\nBut we might want to include explicit \"push i onto stack\" step.\n\nAlso, we need to use \"→ Decision:\" lines.\n\nWe need to be careful: Each decision block contains \"Yes →\" and \"No →\" lines. The steps inside may need to indent accordingly.\n\nLet's produce final output with proper indentation and arrow usage.\n\nCheck for clarity: Use \"Yes →\" and \"No →\" with proper indentation.\n\nAlso, we need to avoid actual code, just pseudo steps.\n\nLet's finalize.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 輸入 temperatures // 取得每日溫度陣列\n→ Step 2: 建立 answer 陣列長度為 temperatures.length，初始值全為 0 // 初始化答案\n→ Step 3: 建立空堆疊 stack 儲存索引 // 用來追蹤未解決的日子\n→ Step 4: 從最後一天 i = temperatures.length-1 迴圈至 0 // 逆序處理\n    → Decision: 堆疊是否非空? // 判斷是否已有待解決的日子\n        Yes → Step 5: // 堆疊非空\n        No  → Step 6: answer[i] = 0 // 沒有更熱的日子，答案保持 0\n    → Step 7: 循環 while stack 非空 且 temperatures[i] >= temperatures[stack.top()] // 移除所有不比今天熱的日子\n    → Decision: 堆疊是否非空? // 再次判斷是否仍有候選日\n        Yes → Step 8: answer[i] = stack.top() - i // 計算距離到更熱日的天數\n        No  → Step 9: answer[i] = 0 // 仍無更熱日\n    → Step 10: push i 進入 stack // 把今天的索引加入堆疊，作為未來日子的候選\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def dailyTemperatures(self, temperatures):\n        n = len(temperatures)\n        res = [0] * n\n        stack = []\n        for i in range(n):\n            while stack and temperatures[i] > temperatures[stack[-1]]:\n                idx = stack.pop()\n                res[idx] = i - idx\n            stack.append(i)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 嘗試將輸入轉成 Python 列表，若失敗則嘗試按空白拆分\n    try:\n        temps = ast.literal_eval(data)\n    except Exception:\n        temps = list(map(int, data.split()))\n    result = Solution().dailyTemperatures(temps)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[73,74,75,71,69,72,76,73]",
          "expected_output": "[1,1,4,2,1,1,0,0]",
          "success": true,
          "output": "[1, 1, 4, 2, 1, 1, 0, 0]"
        },
        {
          "example_index": 1,
          "input": "[30,40,50,60]",
          "expected_output": "[1,1,1,0]",
          "success": true,
          "output": "[1, 1, 1, 0]"
        },
        {
          "example_index": 2,
          "input": "[30,60,90]",
          "expected_output": "[1,1,0]",
          "success": true,
          "output": "[1, 1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode71.json",
    "problem_index_in_file": 0,
    "title": "Simplify Path",
    "description_snippet": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Y...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines with explanations. Steps: split path by '/', use stack. For each part: ignore empty or \".\"; if \"..\" pop stack if not empty; else push part. After processing, join with \"/\" + stack. If empty return \"/\". Ensure not trailing slash. Provide steps line by line. Use Start, Decision, etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入絕對路徑 inputPath // 從使用者處取得完整路徑  \n→ Step 2: 把 inputPath 用 '/' 分割為 parts // 取得每個路徑片段  \n→ Step 3: 初始化空堆疊 dirStack // 用來儲存有效目錄  \n→ Decision: 迭代 parts? // 開始處理每個片段  \n    Yes → Step 4: 取得 currentPart // 取下一個片段  \n    → Decision: currentPart 為空? // 判斷是否為多重斜線產生的空字串  \n        Yes → Step 5: 跳過 // 空字串不做任何處理  \n        No → Decision: currentPart 為 '.'? // 判斷是否為當前目錄符號  \n            Yes → Step 6: 跳過 // 當前目錄不影響路徑  \n            No → Decision: currentPart 為 '..'? // 判斷是否為上層目錄符號  \n                Yes → Step 7: 如果 dirStack 不空則 pop() // 返回上一層目錄  \n                No  → Step 8: 推入 dirStack ← currentPart // 將有效目錄加入堆疊  \n        → Step 9: 移至 next part // 繼續迴圈  \n→ Step 10: 產生 canonicalPath = '/' + 以 '/' 連接 dirStack 的字串 // 重新組合路徑  \n→ Decision: dirStack 為空? // 判斷是否只有根目錄  \n    Yes → Step 11: canonicalPath = '/' // 只保留根目錄  \n    No  → Step 12: 保持 canonicalPath // 已正確組合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        \"\"\"\n        Simplify an absolute Unix-style path.\n        \"\"\"\n        stack = []\n        parts = path.split('/')  # split by slash\n\n        for part in parts:\n            if part == '' or part == '.':          # empty or current dir\n                continue\n            elif part == '..':                     # parent dir\n                if stack:\n                    stack.pop()\n            else:                                  # normal directory name\n                stack.append(part)\n\n        # join the parts with a leading slash\n        simplified = '/' + '/'.join(stack)\n        return simplified\n\ndef parse_input_line(line: str) -> str:\n    \"\"\"\n    Extract the path string from an input line of the form:\n    path = \"/some/path/\"\n    \"\"\"\n    # Find the first quoted string in the line\n    match = re.search(r'\\\"([^\"]*)\\\"|\\'([^\\']*)\\'', line)\n    if match:\n        return match.group(1) or match.group(2)\n    # Fallback: take the part after '=' and strip quotes\n    if '=' in line:\n        return line.split('=', 1)[1].strip().strip('\"\\'')\n    return line.strip().strip('\"\\'')  # just in case\n\ndef main():\n    # Read the first non-empty line from stdin\n    for raw_line in sys.stdin:\n        line = raw_line.strip()\n        if line:\n            path_str = parse_input_line(line)\n            break\n    else:\n        # No input provided\n        return\n\n    solution = Solution()\n    result = solution.simplifyPath(path_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "path = \"/home/\"",
          "expected_output": "\"/home\"",
          "success": true,
          "output": "/home"
        },
        {
          "example_index": 1,
          "input": "path = \"/home//foo/\"",
          "expected_output": "\"/home/foo\"",
          "success": true,
          "output": "/home/foo"
        },
        {
          "example_index": 2,
          "input": "path = \"/home/user/Documents/../Pictures\"",
          "expected_output": "\"/home/user/Pictures\"",
          "success": true,
          "output": "/home/user/Pictures"
        },
        {
          "example_index": 3,
          "input": "path = \"/../\"",
          "expected_output": "\"/\"",
          "success": true,
          "output": "/"
        },
        {
          "example_index": 4,
          "input": "path = \"/.../a/../b/c/../d/./\"",
          "expected_output": "\"/.../b/d\"",
          "success": true,
          "output": "/.../b/d"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode347.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Elements",
    "description_snippet": "Given an integer array nums and an integer k, return the k most frequent elements. You may return th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: given integer array nums and integer k, return the k most frequent elements. Any order.\n\nWe should produce steps: Start, Step 1: count frequencies using hash map, Step 2: build buckets based on frequency, Step 3: collect k most frequent elements from high freq to low, Step 4: return result. End. Provide explanation for each line. Use arrows and decision if needed.\n\nNo real code.\n\nLet's produce each line as described. Use \"Start\", \"End\" labels. Use arrow lines \"→\". For decision maybe not necessary because logic is straightforward. We can still have decision to choose top k. But it's linear.\n\nLet's produce:\n\nStart // 開始\n→ Step 1: 初始化頻率映射 // 用哈希表記錄每個數字出現次數\n→ Step 2: 遍歷 nums 更新頻率映射 // 為每個數字計數\n→ Step 3: 初始化頻率桶列表 // bucket[i] 儲存出現頻率為 i 的數字\n→ Decision: 如果 bucket 大小不足? // 確保桶列表大小為最大頻率+1\n    Yes → Step 4: 擴展 bucket 列表至 maxFreq+1\n    No  → Step 4: 直接使用已存在的 bucket\n→ Step 5: 將頻率映射中的數字分配到對應桶中 // 依頻率將數字放入 bucket\n→ Step 6: 初始化結果列表\n→ Step 7: 從高頻開始遍歷 bucket 取出數字直到收集到 k 個 // 取得最常見的 k 個數字\n→ Decision: 若已收集 k 個? // 檢查是否滿足條件\n    Yes → Step 8: 跳出迴圈\n    No  → Step 9: 繼續遍歷下一頻率\n→ Step 10: 返回結果列表 // 輸出 k 個最頻繁的元素\nEnd // 結束\n\nNeed to keep format: each line \"虛擬碼步驟 [空格] // 解釋\". Use \"→\" arrow at start of steps except start and end. For decisions, indent decisions and Yes/No.\n\nMake sure each line has \"→\" at start for steps. For decision lines, \"Decision:\" then condition. For Yes/No lines, indent accordingly.\n\nLet's write final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化頻率映射 // 用哈希表記錄每個數字出現次數  \n→ Step 2: 遍歷 nums 更新頻率映射 // 為每個數字計數  \n→ Step 3: 初始化頻率桶列表 // bucket[i] 儲存出現頻率為 i 的數字  \n→ Decision: 若 bucket 列表長度不足最大頻率+1? // 確保 bucket 足夠容納所有頻率  \n Yes → Step 4: 擴展 bucket 列表至 maxFreq+1 // 讓索引對應頻率  \n No  → Step 4: 直接使用已存在的 bucket  \n→ Step 5: 將頻率映射中的數字分配到對應桶中 // 依頻率將數字放入 bucket  \n→ Step 6: 初始化結果列表 // 用來收集 k 個最頻繁的元素  \n→ Step 7: 從高頻開始遍歷 bucket 取出數字直到收集到 k 個 // 取得最常見的 k 個數字  \n→ Decision: 已收集到 k 個元素? // 檢查是否已滿足需求  \n Yes → Step 8: 跳出遍歷迴圈  \n No  → Step 9: 繼續遍歷下一頻率  \n→ Step 10: 返回結果列表 // 輸出 k 個最頻繁的元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def topKFrequent(self, nums, k):\n        # 先計算每個元素的出現頻率\n        freq = Counter(nums)\n        # 取得頻率最高的 k 個元素\n        # most_common() 會按頻率從高到低排序\n        return [item for item, _ in freq.most_common(k)]\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取 nums 列表和 k 整數。\n    支援類似 'nums = [1,1,1,2,2,3], k = 2' 的格式。\n    \"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data, re.S)\n    k_match    = re.search(r'k\\s*=\\s*([-]?\\d+)', data)\n\n    if not nums_match or not k_match:\n        raise ValueError(\"輸入格式不正確，請使用 'nums = [...], k = ...'\")\n\n    nums = ast.literal_eval(nums_match.group(1))\n    k    = int(k_match.group(1))\n    return nums, k\n\ndef main():\n    # 讀取所有標準輸入\n    raw_data = sys.stdin.read()\n    if not raw_data.strip():\n        return\n    nums, k = parse_input(raw_data)\n\n    sol = Solution()\n    result = sol.topKFrequent(nums, k)\n\n    # 輸出結果，保持與範例相同的 Python list 格式\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,1,2,1,2,3,1,3,2], k = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode752.json",
    "problem_index_in_file": 0,
    "title": "Open the Lock",
    "description_snippet": "You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3',...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code for solving the lock problem: minimal moves to reach target from 0000 avoiding deadends. Use BFS.\n\nWe need to output step-by-step virtual code with arrows and explanation after each line.\n\nThus produce:\n\nStart\n→ Step: create deadend set\n→ Step: if start in deadends return -1\n→ Step: initialize queue with start and depth 0\n→ Step: visited set\n→ Decision: while queue not empty? Yes ...\n    → Step: pop front state, depth\n    → Decision: if state == target? Yes → return depth\n    → Step: for each wheel 0..3:\n        → Step: for each direction +/-1:\n            → Step: compute next state\n            → Decision: if next not in visited and not in deadends? Yes → add to queue, mark visited\n→ End\n\nReturn -1 at end\n\nWe must include explanation comment after each line.\n\nMake sure each line is separate.\n\nWe need to use virtual arrows. Each line should be like: `Start // 程式開始執行`\n\nOk.\n\nLet's produce.\n\nNeed to show BFS. Use Step numbering maybe.\n\nWe must produce per line explanation in Chinese.\n\nLet's craft.\n\nAlso include \"Decision:\" lines with Yes and No branches.\n\nBe mindful of indenting? The format: Use arrows with spaces like in example.\n\nWe can indent by four spaces maybe for nested lines.\n\nBut they didn't specify indentation but arrows.\n\nWe'll produce like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 deadend 集合 // 將所有禁忌碼放入集合便於 O(1) 判斷\n→ Decision: 如果 '0000' 在 deadends? // 起始位置若為禁忌碼直接無法開啟\n    Yes → End // 返回 -1，程式結束\n    No  → Step 2: 建立 BFS 隊列並加入起始狀態 '0000' 和步數 0 // 准備層序搜尋\n→ Step 3: 初始化已訪問集合 visited 為 {'0000'} // 防止重複探索\n→ Decision: 隊列是否非空? // 進入主循環\n    Yes → \n        → Step 4: 取出隊首元素 (state, depth) // 取待處理節點\n        → Decision: state == target? // 是否已達目標\n            Yes → End // 返回 depth，已完成\n            No  → \n                → Step 5: 對每個輪子索引 i = 0..3 進行探索 // 嘗試所有可能的旋轉\n                    → Step 6: 針對方向 d = +1, -1 計算下一位 nextDigit // 正負轉動\n                        → Step 7: 生成下一個狀態 nextState // 合成新字符串\n                        → Decision: nextState 不在 visited 且不在 deadends? // 確保合法且未探索\n                            Yes → \n                                → Step 8: 將 nextState 加入 visited\n                                → Step 9: 將 nextState 與 depth+1 入隊 // 探索下一層\n                            No  → // 跳過已訪問或禁忌碼\n    No  → End // 隊列空結束，無法到達目標\n→ End // 程式結束\n\nBut need to use format exactly. Each line should have virtual code step then space then comment. Decision lines include branches.\n\nThus each line should be like:\n\nDecision: ...? // comment\n\nYes → ... // comment\n\nNo  → ... // comment\n\nNeed to ensure spacing: After \"Decision:\" line we indent Yes and No lines. The example shows:\n\nDecision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nThus indent with 4 spaces.\n\nThus produce accordingly.\n\nLet's format each line as:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 deadends_set ← Set(deadends) // ...\n\nOk.\n\nNeed to avoid actual code like deadends_set ←. Use pseudo.\n\nOk.\n\nWe should produce per line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 deadends_set ← Set(deadends) // 將所有禁忌碼存入集合，方便 O(1) 判斷\n→ Decision: 是否為禁忌碼？ 0000 ∈ deadends_set? // 起始位置若為禁忌碼立即無法開啟\n    Yes → End // 返回 -1，程式結束\n    No  → Step 2: 建立 BFS 隊列並加入起始狀態 ('0000', 0) // 以起始位置開始層序搜尋\n→ Step 3: 初始化 visited_set ← {'0000'} // 記錄已探索的狀態，避免重複\n→ Decision: 隊列是否非空? // 進入主循環\n    Yes →\n        → Step 4: 取出隊首元素 (state, depth) // 取得待處理節點\n        → Decision: state == target? // 判斷是否已達目標\n            Yes → End // 返回 depth，已成功開鎖\n            No  →\n                → Step 5: 對每個輪子索引 i = 0..3 進行探索 // 嘗試所有可能的旋轉\n                    → Step 6: 針對方向 d = +1, -1 計算下一位 nextDigit // 正向或反向轉動\n                        → Step 7: 生成下一個狀態 nextState // 合成新字符串\n                        → Decision: nextState ∉ visited_set 且 nextState ∉ deadends_set? // 確保合法且未探索\n                            Yes →\n                                → Step 8: 將 nextState 加入 visited_set // 標記已訪問\n                                → Step 9: 將 nextState 與 depth+1 入隊 // 將下一層節點加入搜尋\n                            No  → // 跳過已訪問或禁忌碼\n    No  → End // 隊列空結束，無法到達目標\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def openLock(self, deadends, target):\n        dead = set(deadends)\n        if '0000' in dead:\n            return -1\n        queue = deque([('0000', 0)])\n        visited = {'0000'}\n        while queue:\n            state, steps = queue.popleft()\n            if state == target:\n                return steps\n            for i in range(4):\n                digit = int(state[i])\n                for move in (-1, 1):\n                    new_digit = (digit + move) % 10\n                    new_state = state[:i] + str(new_digit) + state[i+1:]\n                    if new_state not in dead and new_state not in visited:\n                        visited.add(new_state)\n                        queue.append((new_state, steps + 1))\n        return -1\n\ndef parse_input(data: str):\n    # 解析 deadends\n    dead_match = re.search(r'deadends\\s*=\\s*\\[(.*?)\\]', data, re.S)\n    deadends = []\n    if dead_match:\n        raw = dead_match.group(1).strip()\n        if raw:\n            deadends = [s.strip().strip('\"').strip(\"'\") for s in raw.split(',') if s.strip()]\n    # 解析 target\n    target_match = re.search(r'target\\s*=\\s*\"([^\"]+)\"', data)\n    target = \"\"\n    if target_match:\n        target = target_match.group(1)\n    return deadends, target\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    deadends, target = parse_input(input_data)\n    solution = Solution()\n    result = solution.openLock(deadends, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "deadends = [\"8888\"], target = \"0009\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode380.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1)",
    "description_snippet": "Implement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\nbool inser...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanations. The user wants to implement RandomizedSet with O(1) operations. We'll generate a pseudocode with data structures: a hashmap val->index, and a list/array of values. Provide steps for insert, remove, getRandom. We'll structure as class initialization, methods. We'll use Start, End, Decision. The output must be lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 empty map // etc.\n\nWe need to cover all methods. Provide separate sections: class definition, constructor, insert, remove, getRandom. Each step inside methods.\n\nUse arrow notation. Provide explanation after //.\n\nWe'll produce:\n\nStart\n→ Step 1: 定義 RandomizedSet 類別 // 類別定義\n    → Step 1.1: 建立空哈希表 map // 用於值到索引映射\n    → Step 1.2: 建立空陣列 list // 存儲元素\n\nConstructor\n    → Step 2: 初始化 map = {} // 空映射\n    → Step 3: 初始化 list = [] // 空列表\n\nMethod insert\n    → Step 4: Decision: 是否存在 map[val]? // 檢查值是否已在集合\n        Yes → Step 5: Return false // 已存在，插入失敗\n        No  → Step 6: 將 val 加入 list // 新增元素\n             → Step 7: map[val] = list.length - 1 // 記錄索引\n             → Step 8: Return true // 插入成功\n\nMethod remove\n    → Step 9: Decision: 是否存在 map[val]? // 檢查值是否存在\n        Yes → Step 10: idx = map[val] // 取得索引\n              → Step 11: last = list.last // 取得最後一個元素\n              → Step 12: list[idx] = last // 用最後元素覆蓋要刪除的位置\n              → Step 13: map[last] = idx // 更新最後元素的新索引\n              → Step 14: list.pop() // 移除最後一個元素\n              → Step 15: delete map[val] // 刪除映射\n              → Step 16: Return true // 刪除成功\n        No  → Step 17: Return false // 不存在，刪除失敗\n\nMethod getRandom\n    → Step 18: idx = random integer in [0, list.length-1] // 隨機索引\n    → Step 19: Return list[idx] // 返回隨機元素\n\nEnd\n\nBut we must ensure each line has the arrow and explanation. Use arrow notation for nested steps? For decisions we need to indent. Use formatting: Indentation maybe spaces or tabs. Provide decision lines with Yes → etc.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 RandomizedSet 類別 // 建立類別框架  \n → Step 1.1: 宣告 map: HashMap<Val, Index> // 存儲元素與其在陣列中的索引  \n → Step 1.2: 宣告 list: ArrayList<Val> // 儲存所有元素的動態陣列  \n\n→ Constructor // 初始化構造函式  \n → Step 2: map ← {} // 空映射表  \n → Step 3: list ← [] // 空陣列  \n\n→ Method insert(val: Int) // 插入元素  \n → Step 4: Decision: map.containsKey(val) // 檢查元素是否已存在  \n  Yes → Step 5: Return false // 已存在，插入失敗  \n  No  → Step 6: list.add(val) // 將新元素追加到陣列尾部  \n   → Step 7: map.put(val, list.size() - 1) // 記錄新元素的索引  \n   → Step 8: Return true // 插入成功  \n\n→ Method remove(val: Int) // 刪除元素  \n → Step 9: Decision: map.containsKey(val) // 檢查元素是否存在  \n  Yes → Step 10: idx ← map.get(val) // 取得待刪元素的索引  \n   → Step 11: lastVal ← list.get(list.size() - 1) // 取得最後一個元素  \n   → Step 12: list.set(idx, lastVal) // 用最後一個元素覆蓋待刪元素位置  \n   → Step 13: map.put(lastVal, idx) // 更新被覆蓋元素的新索引  \n   → Step 14: list.remove(list.size() - 1) // 刪除陣列尾部（原待刪元素）  \n   → Step 15: map.remove(val) // 刪除映射表中該元素的條目  \n   → Step 16: Return true // 刪除成功  \n  No  → Step 17: Return false // 元素不存在，刪除失敗  \n\n→ Method getRandom() // 隨機取元素  \n → Step 18: idx ← randomInt(0, list.size() - 1) // 隨機索引  \n → Step 19: Return list.get(idx) // 回傳隨機元素  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        # val_to_index maps a value to its index in the values list\n        self.val_to_index = {}\n        # values stores all inserted values\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.val_to_index:\n            return False\n        index = self.val_to_index[val]\n        last_val = self.values[-1]\n        # Move the last element into the spot of the element to remove\n        self.values[index] = last_val\n        self.val_to_index[last_val] = index\n        # Remove the last element\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.values)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # The input consists of two lists separated by a comma.\n    # Wrap it into a JSON array for easy parsing.\n    try:\n        ops, args = json.loads('[' + data + ']')\n    except json.JSONDecodeError:\n        # Fallback for malformed input\n        parts = data.split('], [', 1)\n        ops = json.loads(parts[0] + ']')\n        args = json.loads('[' + parts[1])\n    \n    obj = None\n    results = []\n\n    for cmd, arg in zip(ops, args):\n        if cmd == 'RandomizedSet':\n            obj = RandomizedSet()\n            results.append(None)          # null in JSON\n        elif cmd == 'insert':\n            value = arg[0] if isinstance(arg, list) else arg\n            results.append(obj.insert(value))\n        elif cmd == 'remove':\n            value = arg[0] if isinstance(arg, list) else arg\n            results.append(obj.remove(value))\n        elif cmd == 'getRandom':\n            results.append(obj.getRandom())\n        else:\n            results.append(None)\n\n    # Output results in JSON format (null, true, false, numbers)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode519.json",
    "problem_index_in_file": 0,
    "title": "Random Flip Matrix",
    "description_snippet": "There is an m x n binary grid matrix with all the values set 0 initially. Design an algorithm to ran...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the algorithm. The algorithm: Use reservoir-like mapping: keep count of remaining zeros; maintain mapping from index to position using dictionary (hash map). Each flip: pick random number r in [0, remaining-1]. Convert to 2D index via r//n, r % n. Then find actual position mapping: if mapping has r, use mapped value else r. Then set mapping for r to mapping of remaining-1. Decrease remaining. reset: clear mapping, set remaining to m*n.\n\nWe need virtual code step by step. Ensure each line: \"虛擬碼步驟 // 解釋\". Use arrow formatting.\n\nLet's produce start, init, flip, reset, end.\n\nWe'll produce steps with nested decisions.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 初始化 m, n, total = m*n, remaining = total // 儲存矩陣尺寸與剩餘零數\n→ Step 2: 初始化 map = empty dictionary // 用來映射虛擬索引到真實索引\n...\nThen flip function.\n\nIn flip:\nStart Flip // flip 函式開始\n→ Decision: 如果 remaining == 0? // 檢查是否已經全部為 1\n    No  → Step: 隨機選取 r 在 [0, remaining-1] // 呼叫隨機函式一次\n    Yes → Step: 重新設定 remaining = total; map.clear() // 若全為 1，重置? Actually algorithm typically expects call to reset separately. So maybe we just return error? But we can just reset.\nBut spec: flip() is called only when at least one zero exists. So we can skip check.\n\nSimplify: Step 3: r = random(0, remaining-1) // 產生隨機整數\n→ Step 4: real = map.get(r, r) // 若映射存在則取其映射值，否則取 r\n→ Step 5: last = map.get(remaining-1, remaining-1) // 取得最後一個可用索引的映射\n→ Step 6: map[r] = last // 把 r 的映射指向 last，這樣 r 將不再可用\n→ Step 7: remaining -= 1 // 減少剩餘零數\n→ Step 8: i = real // n ; j = real % n // 轉換為行列\n→ Step 9: return [i, j] // 回傳轉換後的索引\n\nReset function:\nStart Reset // reset 函式開始\n→ Step 1: map.clear() // 清空映射\n→ Step 2: remaining = total // 重設剩餘零數\n→ End // reset 執行結束\n\nEnd of program.\n\nWe need to use arrow formatting. The steps need to be \"虛擬碼步驟\" like \"→ Step 1: ...\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 m, n, total = m*n, remaining = total // 儲存矩陣尺寸與剩餘零數  \n→ Step 2: 初始化 map = empty dictionary // 用來映射虛擬索引到真實索引  \n\n// flip() 函式  \n→ Step 3: r = random(0, remaining-1) // 呼叫隨機函式一次，選擇一個虛擬索引  \n→ Step 4: real = map.get(r, r) // 若映射存在則取其映射值，否則取 r  \n→ Step 5: last = map.get(remaining-1, remaining-1) // 取得最後一個可用索引的映射  \n→ Step 6: map[r] = last // 把 r 的映射指向 last，這樣 r 將不再可用  \n→ Step 7: remaining -= 1 // 減少剩餘零數  \n→ Step 8: i = real // n ; j = real % n // 轉換為行列座標  \n→ Step 9: return [i, j] // 回傳轉換後的索引  \n\n// reset() 函式  \n→ Step 10: map.clear() // 清空映射  \n→ Step 11: remaining = total // 重設剩餘零數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n_rows, n_cols):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Parse input: two lists separated by newline or by '], [' when single line\n    if '\\n' in data:\n        ops_line, args_line = data.split('\\n', 1)\n        ops = json.loads(ops_line.strip())\n        args = json.loads(args_line.strip())\n    else:\n        # single line input\n        parts = data.split('],', 1)\n        ops = json.loads(parts[0] + ']')\n        args = json.loads('[' + parts[1])\n\n    outputs = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg[0])  # arg is [[m, n]]\n            outputs.append(None)\n        elif op == \"flip\":\n            outputs.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            outputs.append(None)\n        else:\n            # unknown operation; skip\n            outputs.append(None)\n\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpczudkvkf.py\", line 57, in <module>\n    main()\n  File \"/tmp/tmpczudkvkf.py\", line 37, in main\n    args = json.loads('[' + parts[1])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 31 (char 30)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode735.json",
    "problem_index_in_file": 0,
    "title": "Asteroid Collision",
    "description_snippet": "We are given an array asteroids of integers representing asteroids in a row. The indices of the aste...",
    "examples_loaded": 4,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the asteroid collision problem. Use Start, End, Decision, etc. Each line has virtual code step and comment.\n\nWe need to produce step-by-step algorithm: Use stack to simulate. For each asteroid in asteroids array, while stack not empty and current >0 and top <0? Actually collision occurs when top positive and current negative? Wait: asteroids move at same speed. For collision, need one moving right, the other moving left. Since indices represent positions left to right. So when we iterate array left to right, we keep stack of survivors. For current asteroid, we check if current negative and stack top >0 => potential collision. While stack not empty and current negative and top >0: compare sizes. If abs(current) > abs(top) => pop top, continue loop; else if equal => pop top and discard current; else current dies, break. If no collision, push current. At end, output stack.\n\nSo produce pseudocode lines accordingly.\n\nWe must ensure each line has \"虛擬碼步驟\" and comment.\n\nUse arrow and Decision.\n\nLet's create Start, Step 1: Initialize stack, Step 2: Iterate each asteroid.\n\nWe need decision blocks for collision logic.\n\nLet's write.\n\nAlso need End.\n\nLet's produce.\n\nUse \"→\" arrow from Start.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空堆疊 survivors // 用來存放存活的隕石  \n→ Step 2: 對每個 asteroid 在 asteroids 遍歷 // 按順序處理每顆隕石  \n\n  → Decision: 若 asteroid 為負（向左）且堆疊非空且堆疊頂為正（向右）? // 有可能發生碰撞  \n   Yes → Step 3: 進入碰撞循環  \n    → Decision: abs(asteroid) > abs(堆疊頂)? // 當前向左隕石比向右更大  \n     Yes → Step 4: pop 堆疊頂 // 向右隕石爆炸，繼續檢查下一個堆疊頂  \n      → Decision: 仍然碰撞? // 檢查是否還有向右隕石待碰  \n       Yes → Step 3 迴圈 // 重新進入碰撞判斷  \n       No → Step 5: push asteroid // 沒有向右隕石，當前隕石存活  \n     No → Decision: abs(asteroid) == abs(堆疊頂)? // 同等大小會互相爆炸  \n      Yes → Step 6: pop 堆疊頂 // 兩顆都消失，丟棄當前隕石  \n       → Decision: 從迴圈跳出，繼續下一個隕石  \n      No → Step 7: 既不大也不等，當前隕石爆炸  \n       → 直接跳出迴圈，繼續下一個隕石  \n    No → Step 8: 無碰撞，push asteroid // 正常加入堆疊  \n\n→ Step 9: 將堆疊轉成結果陣列 // 最終存活的隕石  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def asteroidCollision(self, asteroids):\n        stack = []\n        for a in asteroids:\n            while stack and a < 0 < stack[-1]:\n                if stack[-1] < -a:\n                    stack.pop()\n                    continue\n                elif stack[-1] == -a:\n                    stack.pop()\n                break\n            else:\n                stack.append(a)\n        return stack\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中提取陣列\"\"\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        return []\n    try:\n        return ast.literal_eval(data[start:end+1])\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n    asteroids = parse_input(raw)\n    result = Solution().asteroidCollision(asteroids)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "asteroids = [5,10,-5]",
          "expected_output": "[5,10]",
          "success": true,
          "output": "[5, 10]"
        },
        {
          "example_index": 1,
          "input": "asteroids = [8,-8]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "asteroids = [10,2,-5]",
          "expected_output": "[10]",
          "success": true,
          "output": "[10]"
        },
        {
          "example_index": 3,
          "input": "asteroids = [3,5,-6,2,-1,4]",
          "expected_output": "[-6,2,4]",
          "success": true,
          "output": "[-6, 2, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode45.json",
    "problem_index_in_file": 0,
    "title": "Jump Game II",
    "description_snippet": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at index ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for algorithm: minimum number of jumps to reach last index. Classic Jump Game II problem. Use greedy approach: iterate, maintain current max reach and next max reach. Count jumps. Steps: current_end, farthest, jumps. For i from 0 to n-2: update farthest = max(farthest, i+nums[i]). If i == current_end: jumps++, current_end = farthest. Finally return jumps.\n\nWe need to produce virtual code step by step, with each line followed by explanation. Use Start, End, Decision, etc. Should be structured.\n\nWe need to ensure we use arrow syntax. Example: \"Start // 程式開始執行\". Then each step. Must include decision points.\n\nWe need to be careful to incorporate for-loop. Could represent loop with Decision: if i < n-1? and iterate. Use incremental variable i. We could model loop by:\n\n→ Step 1: 初始化 i=0, current_end=0, farthest=0, jumps=0 // 初始化變數\n\n→ Decision: 如果 i <= n-2? // 循環條件\n\n→ Step 2: 更新 farthest = max(farthest, i + nums[i]) // 更新最大可到達點\n\n→ Decision: 如果 i == current_end? // 是否需要跳一次\n\n→ Yes → Step 3: jumps++ // 增加跳數\n\n→ Yes → Step 4: current_end = farthest // 更新可到達範圍\n\n→ Step 5: i++ // 移動到下一個索引\n\n→ Decision: 重新判斷 i <= n-2? // 迴圈\n\nFinally End // 返回 jumps\n\nNeed to show return value. Could include Step 6: 返回 jumps // 結果\n\nWe need to mark End after return.\n\nOk produce that.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 i=0, current_end=0, farthest=0, jumps=0 // 設定迴圈指標與跳數  \n→ Decision: i <= n-2? // 判斷是否還有前進的索引  \n    Yes → Step 2: farthest = max(farthest, i + nums[i]) // 更新可達最遠位置  \n    Yes → Decision: i == current_end? // 是否到達目前跳躍範圍的終點  \n        Yes → Step 3: jumps++ // 增加一次跳躍計數  \n        Yes → Step 4: current_end = farthest // 更新下一次跳躍的終點  \n    Yes → Step 5: i++ // 移動到下一個索引  \n    Yes → Decision: i <= n-2? // 重新判斷迴圈條件  \n        Yes → 返回到 Step 2  \n        No  → Step 6: 返回 jumps // 已到達最後一個索引，回傳最小跳數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def jump(self, nums):\n        \"\"\"\n        最小跳躍次數問題：使用貪心法一次掃描即可得到答案。\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return 0\n\n        jumps = 0          # 已經做過的跳躍次數\n        current_end = 0    # 目前跳躍可達到的最遠索引\n        farthest = 0       # 迴圈內目前已知的最遠可達索引\n\n        for i in range(n - 1):\n            # 更新最遠可達位置\n            farthest = max(farthest, i + nums[i])\n\n            # 如果已經走到目前跳躍區間的終點，則需要進行一次跳躍\n            if i == current_end:\n                jumps += 1\n                current_end = farthest\n\n        return jumps\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中提取列表。支援形如 'nums = [1,2,3]' 或僅 [1,2,3] 的輸入。\n    \"\"\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1 and end > start:\n        nums_str = data[start:end + 1]\n    else:\n        nums_str = data\n    return ast.literal_eval(nums_str)\n\ndef main():\n    raw_data = sys.stdin.read().strip()\n    if not raw_data:\n        return\n    nums = parse_input(raw_data)\n    solution = Solution()\n    result = solution.jump(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,3,0,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode495.json",
    "problem_index_in_file": 0,
    "title": "Teemo Attacking",
    "description_snippet": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets po...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem. It's typical LeetCode 549. We should produce algorithm: iterate over timeSeries, accumulate total. For each time, if current time > previous time + duration -1? Actually poison ends at prev + duration -1 inclusive. Next attack time. If time[i] > prev + duration -1? If equal or less, overlapping; we add only duration - (time[i] - prev). Else add duration. Use variable prev. Initialize prev = -infinity? Start.\n\nLet's write pseudo steps line by line. Ensure to use arrow syntax and decision. Use Start and End.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 total ← 0，prev ← -1e9 // 用於累積毒傷時間與追蹤上一攻擊時間  \n→ Decision: timeSeries 是否為空? // 檢查是否有攻擊記錄  \n    Yes → Step 2: Return total // 沒有攻擊，毒傷時間為 0  \n    No  →  \n        → Step 3: 對 timeSeries 中每個 attackTime 執行以下循環 // 遍歷每一次攻擊  \n            → Decision: attackTime ≤ prev + duration - 1? // 判斷此次攻擊是否與上一毒效果重疊  \n                Yes → Step 4: overlap ← attackTime - prev // 計算重疊時間量  \n                    → Step 5: total ← total + (duration - overlap) // 只加入新的毒期間  \n                No  → Step 6: total ← total + duration // 完全不重疊，直接加上整段毒期間  \n            → Step 7: prev ← attackTime // 更新上一攻擊時間為目前攻擊時間  \n→ Step 8: Return total // 回傳總毒傷秒數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries, duration):\n        \"\"\"\n        計算 Ashe 在被毒住期間的總秒數。\n        \"\"\"\n        if not timeSeries:\n            return 0\n        total = 0\n        # 每兩次攻擊之間的有效毒期間為兩者時間差與 duration 的較小值\n        for i in range(len(timeSeries) - 1):\n            total += min(timeSeries[i + 1] - timeSeries[i], duration)\n        # 最後一次攻擊的完整毒期間\n        total += duration\n        return total\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析 timeSeries 列表\n    time_series_match = re.search(r'timeSeries\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if time_series_match:\n        time_series_str = time_series_match.group(1)\n        try:\n            timeSeries = eval(time_series_str)\n        except Exception:\n            timeSeries = []\n    else:\n        timeSeries = []\n\n    # 解析 duration 整數\n    duration_match = re.search(r'duration\\s*=\\s*(\\d+)', data)\n    duration = int(duration_match.group(1)) if duration_match else 0\n\n    result = Solution().findPoisonedDuration(timeSeries, duration)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode424.json",
    "problem_index_in_file": 0,
    "title": "Longest Repeating Character Replacement",
    "description_snippet": "You are given a string s and an integer k. You can choose any character of the string and change it ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo steps) for the algorithm that solves the problem: longest repeating character replacement. Classic sliding window with frequency map, maintain max frequency. For each window, length <= k + maxCount. Implementation steps: left=0, freq[26] = 0, maxCount=0, for right from 0 to n-1: freq[s[right]]++, update maxCount = max(maxCount, freq[s[right]]). If window length - maxCount > k, shrink left: freq[s[left]]--, left++. After loop, answer = right-left+1 (or track maxLen). We'll produce virtual code line by line with comments. The output is just steps, not code. Use \"Start\", \"End\", \"Decision:\" etc. Let's craft. We'll keep each step a single line.\n\nMake sure to use arrow and indentation for decisions. We'll provide steps like:\n\nStart // Start program\n→ Step 1: 初始化左指针 left = 0，字頻陣列 freq[26] = 0，最大頻率 maxCount = 0，答案 maxLen = 0 // 初始化變數\n→ Step 2: 從 0 到 n-1 遍歷右指針 right // 遍歷整個字串\n    → SubStep: freq[ s[right] ]++ // 更新右邊字符頻率\n    → SubStep: maxCount = max( maxCount, freq[ s[right] ] ) // 更新窗口內最大頻率\n    → Decision: (right - left + 1) - maxCount > k? // 檢查是否需要收縮窗口\n        Yes → Step 3: freq[ s[left] ]-- // 移除左邊字符\n        Yes → Step 4: left++ // 左指針右移\n        No  → // 窗口大小合法\n    → Step 5: maxLen = max( maxLen, right - left + 1 ) // 更新答案\nEnd // 返回結果\n\nWe need to maintain proper formatting. Provide each line with // explanation. We'll ensure each step includes arrow.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化左指針 left = 0，字頻陣列 freq[26] = 0，最大頻率 maxCount = 0，答案 maxLen = 0 // 設定必要的變數  \n→ Step 2: 從 0 到 n-1 遍歷右指針 right // 逐字串滑動右指針  \n    → SubStep: freq[ s[right] ]++ // 更新右邊字符的頻率  \n    → SubStep: maxCount = max( maxCount, freq[ s[right] ] ) // 記錄窗口內出現最多次的字母頻率  \n    → Decision: (right - left + 1) - maxCount > k? // 判斷目前窗口是否需要收縮  \n        Yes → Step 3: freq[ s[left] ]-- // 移除左側字符的頻率  \n        Yes → Step 4: left++ // 左指針右移，縮小窗口  \n        No  → // 窗口長度合法，保持不變  \n    → Step 5: maxLen = max( maxLen, right - left + 1 ) // 更新目前能得到的最大相同字母子串長度  \nEnd // 程式執行結束，返回 maxLen 為最終答案",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        # 計算每個字母的頻率\n        count = [0] * 26\n        max_count = 0   # 當前窗口內最多的字母頻率\n        left = 0        # 左指針\n        res = 0\n\n        for right, ch in enumerate(s):\n            idx = ord(ch) - ord('A')\n            count[idx] += 1\n            max_count = max(max_count, count[idx])\n\n            # 如果需要改動的字母超過 k，縮小窗口\n            while right - left + 1 - max_count > k:\n                count[ord(s[left]) - ord('A')] -= 1\n                left += 1\n\n            # 更新答案\n            res = max(res, right - left + 1)\n\n        return res\n\ndef parse_input() -> tuple[str, int]:\n    \"\"\"從標準輸入讀取字串與 k，支援多種輸入格式。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return \"\", 0\n\n    # 先嘗試匹配形如: s = \"ABAB\", k = 2 的格式\n    m = re.search(r\"s\\s*=\\s*['\\\"]([A-Z]+)['\\\"]\\s*,\\s*k\\s*=\\s*(\\d+)\", data)\n    if m:\n        return m.group(1), int(m.group(2))\n\n    # 再嘗試按行分隔：第一行是字串，第二行是整數\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], int(lines[1])\n\n    # 最後嘗試空格分隔：第一個 token 是字串，第二個是整數\n    parts = data.split()\n    if len(parts) >= 2:\n        return parts[0], int(parts[1])\n\n    # 無法解析時返回預設值\n    return \"\", 0\n\nif __name__ == \"__main__\":\n    s, k = parse_input()\n    ans = Solution().characterReplacement(s, k)\n    print(ans)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ABAB\", k = 2",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "s = \"AABABBA\", k = 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode58.json",
    "problem_index_in_file": 0,
    "title": "Length of Last Word",
    "description_snippet": "Given a string s consisting of words and spaces, return the length of the last word in the string.\n\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines per spec: each line: step + comment. Use Start, End, Decision, arrows. No actual code. Each step should include the action: reverse iterate, skip spaces, count. Let's craft.\n\nWe need \"逐行\" output. So each line with arrow and explanation.\n\nLet's produce steps: Start, Step 1: initialize index at last char, Step 2: skip trailing spaces, Step 3: count word length, Step 4: return length, End.\n\nAlso need Decision: maybe loop while char not space and index >=0. Use Decision with Yes/No.\n\nLet's produce something like:\n\nStart\n→ Step 1: Set index to len(s) - 1 // 設定索引指向字串最後一個字符\n→ Decision: 是否為空字符串? // 檢查字串是否為空\n    Yes → Step 2: Return 0 // 空字串直接回傳0\n    No  →\n        → Step 3: 跳過尾部空格 // 從尾部向前移動直到遇到非空格字符\n            → Decision: index >= 0? // 確保還有字符\n                Yes → Step 4: 如果 s[index] == ' ' → Step 5: index -= 1 // 空格則向前移動\n                No  → // 已到頭\n        → Step 6: 計數字母長度 // 從目前索引向前計算單詞長度\n            → Decision: index >= 0? // 仍有字符\n                Yes → Step 7: count += 1; index -= 1 // 增加計數並移動\n                No  → // 已到頭\n        → Step 8: Return count // 回傳最後單詞長度\nEnd\n\nBut we need to maintain arrow style. Let's produce more linear.\n\nBetter to structure:\n\nStart\n→ Step 1: idx ← len(s) - 1 // 初始化索引指向字串最後一位\n→ Decision: idx < 0? // 判斷字串是否為空\n    Yes → Step 2: Return 0 // 空字串直接回傳0\n    No  →\n        → Step 3: Skip trailing spaces\n            → Decision: idx >= 0 AND s[idx] == ' '? // 是否還是空格\n                Yes → idx ← idx - 1 // 向前移動\n                No  → // 進入計數\n        → Step 4: Initialize count ← 0\n        → Decision: idx >= 0? // 是否還有字符\n            Yes → Step 5: count ← count + 1; idx ← idx - 1 // 計數並向前移動\n            No  → // 進入返回\n        → Step 6: Return count // 回傳最後單詞長度\nEnd\n\nBut we need to follow the arrow style exactly: For each line: \"→ Step ...\". For decisions, indent with spaces? They used indentation with 4 spaces? Example had indentation. Provide same style.\n\nLet's craft final answer with steps.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: idx ← len(s) - 1 // 設定索引指向字串最後一個字符  \n→ Decision: idx < 0? // 判斷字串是否為空  \n    Yes → Step 2: Return 0 // 空字串直接回傳 0  \n    No →  \n        → Step 3: Skip trailing spaces // 從尾部往前移動直到遇到非空格字符  \n            → Decision: idx >= 0 AND s[idx] == ' '? // 是否還是空格  \n                Yes → idx ← idx - 1 // 向前移動一位  \n                No → // 已找到最後單詞的結尾，進行計數  \n        → Step 4: count ← 0 // 初始化單詞長度計數  \n            → Decision: idx >= 0? // 仍有字符可處理  \n                Yes → Step 5: count ← count + 1; idx ← idx - 1 // 計數並向前移動  \n                No → // 讀完最後單詞  \n        → Step 6: Return count // 回傳最後單詞的長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef length_of_last_word(s: str) -> int:\n    \"\"\"\n    Return the length of the last word in the string s.\n    A word is a maximal substring of non-space characters.\n    \"\"\"\n    # Remove leading and trailing spaces\n    s = s.strip()\n    if not s:\n        return 0\n    # Split on whitespace (handles multiple spaces)\n    words = s.split()\n    return len(words[-1])\n\ndef main() -> None:\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    # Try to extract the string between double quotes\n    match = re.search(r'\"(.*)\"', raw_input, re.S)\n    if match:\n        s = match.group(1)\n    else:\n        # Fallback: use the raw input as the string\n        s = raw_input\n\n    result = length_of_last_word(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello World\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"   fly me   to   the moon  \"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"luffy is still joyboy\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode33.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array",
    "description_snippet": "There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being pas...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for binary search on rotated sorted array. Need to output line by line, each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. We'll produce steps: Start, set left=0, right=nums.length-1. While left <= right. Compute mid. Check if nums[mid]==target -> return mid. Decide if left part is sorted: nums[left] <= nums[mid]. Then if target in [nums[left], nums[mid]) -> right=mid-1 else left=mid+1. Else right part sorted: if target in (nums[mid], nums[right]] -> left=mid+1 else right=mid-1. At end return -1. Use virtual steps with arrows. Provide explanation each line. Provide comments. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 0, right = nums.length - 1 // 初始搜尋範圍  \n→ Decision: 若 left > right? // 判斷是否已搜尋完畢  \n    Yes → Step 2: 回傳 -1 // 沒有找到 target  \n    No  → Step 3: 執行 While 迴圈  \n→ Step 3: 計算 mid = left + (right - left) / 2 // 取中間索引  \n→ Decision: nums[mid] == target? // 檢查中間元素是否為目標  \n    Yes → Step 4: 回傳 mid // 找到目標，返回索引  \n    No  → Decision: nums[left] <= nums[mid]? // 判斷左半段是否有序  \n        Yes → Decision: target 在 [nums[left], nums[mid])? // 目標是否落在左半段  \n            Yes → Step 5: right = mid - 1 // 搜尋左半段  \n            No  → Step 6: left = mid + 1 // 搜尋右半段  \n        No  → Decision: target 在 (nums[mid], nums[right]]? // 目標是否落在右半段  \n            Yes → Step 7: left = mid + 1 // 搜尋右半段  \n            No  → Step 8: right = mid - 1 // 搜尋左半段  \n→ Step 9: 回到 While 迴圈條件，重複執行 Step 3 ~ Step 8  \n→ End // 程式執行結束 (若迴圈結束，會回到 Step 2 回傳 -1)",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def search(self, nums, target):\n        \"\"\"\n        Binary search on a rotated sorted array.\n        Returns the index of target if found, otherwise -1.\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            # 目標值與中間值相同，直接回傳索引\n            if nums[mid] == target:\n                return mid\n\n            # 判斷哪一半是有序的\n            if nums[left] <= nums[mid]:            # 左半段有序\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1               # 目標在左半段\n                else:\n                    left = mid + 1                # 目標在右半段\n            else:                                  # 右半段有序\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1                # 目標在右半段\n                else:\n                    right = mid - 1               # 目標在左半段\n\n        # 若循環結束仍未找到，回傳 -1\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串解析出 nums 列表和 target 整數。\n    支援類似 'nums = [4,5,6,7,0,1,2], target = 0' 的格式。\n    \"\"\"\n    pattern = r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data, re.S)\n    if not match:\n        raise ValueError(\"輸入格式不正確\")\n    nums_str, target_str = match.group(1), match.group(2)\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n    return nums, target\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit(0)\n\n    nums, target = parse_input(raw_input)\n    solution = Solution()\n    result = solution.search(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,5,6,7,0,1,2], target = 0",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2], target = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "nums = [1], target = 0",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode676.json",
    "problem_index_in_file": 0,
    "title": "Implement Magic Dictionary",
    "description_snippet": "Design a data structure that is initialized with a list of different words. Provided a string, you s...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with comments. No actual code, just pseudo. Steps for MagicDictionary: building with dictionary, storing words, search logic: check each word, count mismatches, if exactly one then true. Might optimize with pre-processing: map patterns with wildcard. But simple approach okay.\n\nWe need to output step-by-step pseudo with arrows and comments. Each line like \"Start // 程式開始執行\". Provide for each method? Should show entire flow: initialization, build, search. Probably we need separate sections.\n\nWe need to show decision flow inside search: for each word in dict, compare, count mismatches. If mismatch==1 then return true. After loop, return false. Also handle equal length mismatch.\n\nAlso we could pre-process dictionary into map of patterns: e.g., for each word, generate all patterns with one wildcard. Then search: generate patterns from searchWord and see if any pattern exists in map but not equal to original? But simpler.\n\nWe'll produce virtual code for class and methods.\n\nUse lines: \"Start\", \"→ MagicDictionary()\", \"→ buildDict()\", \"→ search()\", etc. But the requirement: \"逐行輸出\", each line \"虛擬碼步驟\" + \" // 解釋\". Provide arrow structure. Use \"Start\" and \"End\". Provide Decision. Might include loops.\n\nLet's craft:\n\nStart // 程式開始執行\n→ MagicDictionary() // 初始化物件\n    → Step 1: 初始化空字典存儲 // 建立空集合或清空\nEnd\n\nThen buildDict:\n\n→ buildDict(dictionary) // 建構字典\n    → Step 1: 清空已存在字典 // 保證無重複\n    → Step 2: 將每個字串加入集合 // 存儲單詞\nEnd\n\nSearch:\n\n→ search(searchWord) // 檢查是否能改一個字匹配\n    → Step 1: 針對每個字典單詞遍歷\n        → Decision: 搜尋單詞長度是否等於 searchWord 長度? // 需長度相同才能改一個字\n            Yes →\n                → Step 2: 計算不相符字母數目 // 比較兩字串\n                → Decision: 不相符數目是否等於 1? // 檢查是否只差一個\n                    Yes → Return true // 成功\n                    No  → Continue 循環\n            No  → Continue 循環\n    → Return false // 沒有匹配\nEnd\n\nBut we need arrows, indent. Provide indentation lines with arrow or spaces.\n\nLet's craft final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ MagicDictionary() // 初始化 MagicDictionary 物件\n    → Step 1: 初始化內部集合 words 為空集合 // 用於存放字典中的所有單詞\nEnd // 物件初始化結束\n\n→ buildDict(dictionary) // 建構字典，接收一個字串陣列\n    → Step 1: 清空 words 集合 // 保證每次建構時都是乾淨的狀態\n    → Step 2: 對 dictionary 中的每個 word 進行迭代\n        → Action: 把 word 加入 words 集合 // 存儲所有不同單詞\nEnd // 字典建構結束\n\n→ search(searchWord) // 搜尋是否能改一個字母匹配字典\n    → Step 1: 對 words 集合中的每個 dictWord 進行迭代\n        → Decision: dictWord 長度是否等於 searchWord 長度? // 必須長度相同才能只改一個字母\n            Yes →\n                → Step 2: 計算兩字串中不相符的位置數目 mismatches\n                → Decision: mismatches 是否等於 1? // 只差一個字母\n                    Yes → Return true // 找到可改一字母匹配的單詞\n                    No  → 继续下一個 dictWord\n            No  → 继续下一個 dictWord\n    → Return false // 沒有任何單詞符合「只改一字母」的條件\nEnd // search 方法結束\n```",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    commands, args = ast.literal_eval(data)\n\n    magic_dict = None\n    results = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MagicDictionary\":\n            magic_dict = MagicDictionary()\n            results.append(None)\n        elif cmd == \"buildDict\":\n            magic_dict.buildDict(arg)\n            results.append(None)\n        elif cmd == \"search\":\n            results.append(magic_dict.search(arg))\n        else:\n            # ignore unknown commands\n            results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpyen31rb3.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpyen31rb3.py\", line 35, in main\n    magic_dict.buildDict(arg)\n  File \"/tmp/tmpyen31rb3.py\", line 10, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode672.json",
    "problem_index_in_file": 0,
    "title": "Bulb Switcher II",
    "description_snippet": "There is a room with n bulbs labeled from 1 to n that all are turned on initially, and four buttons ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: count distinct final statuses after exactly presses button presses on n bulbs with four button operations. We need to produce virtual code, not actual code. We need to explain each step. Provide structured pseudocode lines with arrow and decisions.\n\nWe need to consider algorithm: we can model button presses as combinations of operations modulo 2? Since each button toggles certain bulbs. The final state is determined by parity of each button pressed. The operations are linear over GF(2). Since pressing same button twice cancels out. So each button pressed even times = no effect. So we only care about pressed parity for each button. However number of presses total is fixed. So we need number of ways to assign parity to 4 buttons such that total presses sum to presses, with each button's parity matching parity of number of times pressed. So we need count of combinations of (b1,b2,b3,b4) where each bi ∈ {0,1} and sum(bi) ≡ presses (mod 2) and sum(bi) ≤ presses? Wait each button can be pressed many times; but final effect only depends on parity. For any parity vector (b1..b4), number of press sequences that result in that parity and total presses = presses is number of ways to distribute presses among buttons with those parities. That number is combinatorial: we need number of nonnegative integers x1..x4 such that sum xi = presses and xi mod 2 = bi. Count solutions.\n\nBut we only need number of distinct final statuses, i.e., distinct resulting configurations of bulbs. Each parity vector corresponds to a unique final status? Not necessarily: different parity vectors might lead to same bulb configuration if resulting transformation identical. Let's analyze transformation matrix: Each button effect vector over bulbs: button1 flips all bulbs -> vector of ones. button2 flips even bulbs -> vector with 1 at even positions. button3 flips odd bulbs. button4 flips bulbs where index ≡1 mod3. The set of four vectors may have linear dependencies. The number of distinct final statuses equals number of distinct XOR combinations of these vectors achievable with total presses constraint. But since pressing buttons multiple times gives parity only, the set of achievable states is all XOR combinations of these four vectors with parity vector satisfying parity sum constraint? Wait but we cannot choose parity arbitrarily because total presses parity fixed. If presses is even, parity sum must be even; if odd, parity sum odd. So we restrict to parity vectors with sum parity equal to presses mod 2. So number of distinct states equals number of distinct XOR sums achievable with parity vectors of that parity. Since operations are linear over GF(2), the set of achievable XOR sums is a linear subspace (or affine subspace) of size 2^rank if parity restriction not limiting. The parity restriction might reduce number of vectors by factor 2 if rank >=1. Let's compute rank of the 4 vectors over GF(2). For arbitrary n, rank may vary. Need to compute number of distinct states given n. Approach: Determine rank r of set of vectors B1,B2,B3,B4 in GF(2)^n. Then number of distinct XOR sums with parity constraint of sum(bi)=p mod2 is either 2^{r-1} if there exists at least one vector combination with that parity? Let's analyze.\n\nLet V be vector space spanned by the four button vectors. Each vector b corresponds to pressing that button once. Let S be set of all XOR sums of any subset of buttons (i.e., all linear combinations over GF(2)). This set size = 2^rank(V). Now parity constraint: we can only use combinations with parity sum equal to p. The subset sum parity is just sum of selected buttons count mod2. That is, for any subset, its cardinality parity is parity of number of buttons selected. We want only subsets whose cardinality parity = p (where p = presses mod2). If p=0, we consider even-cardinality subsets; if p=1, odd-cardinality subsets. Among all subsets of buttons, half have even cardinality, half odd, unless rank=0? Actually number of subsets of the 4 buttons is 16. Exactly half even (8) half odd (8). So restriction eliminates half of combinations, but maybe some combinations produce same vector as others. However within S, mapping from subset to resulting vector may not be injective if vectors dependent. So we need count of distinct vectors produced by subsets with specified parity.\n\nThis is equivalent to: number of distinct sums of vectors with subset parity constraint. This equals number of distinct vectors in the set T = {⊕_{i∈I} v_i | I⊆{1..4}, |I| mod2 = p}. Because mapping from I to vector may be many-to-one.\n\nWe can compute size of T as follows: Let U be all sums (no parity constraint) => size 2^rank(V). Let W be the subset of sums with even cardinality. Let O be subset with odd cardinality. Then |W|+|O|=|U|. Also we can consider the sum of all vectors? Actually note that toggling all 4 buttons gives vector sum of all 4: v1⊕v2⊕v3⊕v4. This vector is same as sum of even subset complement? The parity difference.\n\nWe can analyze: For any vector u ∈ U, either there exists a subset I producing u with even parity or odd parity or both. Because if I produces u, then I⊕{1,2,3,4} produces u⊕v1⊕v2⊕v3⊕v4. But that's not necessarily same u. So not symmetrical.\n\nAlternate approach: Brute force enumeration of 4 buttons: Since only 4 buttons, there are only 16 possible parity combinations. We can compute resulting vectors for each parity combination. Then among those with parity sum parity p, count distinct vectors. Complexity independent of n? But vector length n up to maybe large, but we can compute effect analytically: For each vector, we just need to know which bulbs toggled: sets. But we only need number of distinct statuses, not actual configurations.\n\nWe can compute rank of these 4 vectors as function of n. Let's analyze linear dependencies:\n\nLet vector a = all ones.\nb = even positions (positions 2,4,...)\nc = odd positions (positions 1,3,...)\nd = positions ≡1 mod3.\n\nWe can analyze relationships: a = b⊕c (since even+odd covers all). So a is dependent: a = b⊕c.\n\nAlso maybe d is independent of a,b,c? Let's see: d has pattern 1,0,0,1,0,0,1,... for n length. Not expressible as linear combination of a,b,c? Let's analyze: Suppose we try α*a⊕β*b⊕γ*c = d. Since a=b⊕c, combination reduces to (α⊕β) b ⊕ (α⊕γ) c. So d must be of form x*b⊕y*c. That means d toggles only even or odd positions, but d has both even and odd toggles, but pattern: positions 1,4,7,10,... That includes both odd and even indices: 1 odd,4 even,7 odd,10 even. So d toggles alternating parity. But any combination x*b⊕y*c will produce either all even (if x=1,y=0), all odd (if x=0,y=1), or all bulbs (if x=1,y=1). So cannot produce d. Thus d is independent of a,b,c. So rank at least 3.\n\nNow check if any further dependency between d and others: Since a,b,c already span rank3, adding d increases rank to 4 unless d is in span of them. But we just argued it's not. So rank=4 when n large enough? Wait we must consider size of vectors; for small n, some of these vectors might be zero vector or equal to each other, reducing rank.\n\nWe need general formula for rank depending on n. Let's compute patterns for n small:\n\nDefine sets:\n\n- Even indices: {i|i%2=0} length floor(n/2)\n- Odd indices: {i|i%2=1} length ceil(n/2)\n- 3k+1 indices: i%3=1: positions 1,4,7,...\n\nNow vector a is all ones, length n.\n\nVectors b, c, d.\n\nConsider n=1: b=0 (even indices none). c=1 (index1). d=1 (index1). So vectors: a=[1], b=[0], c=[1], d=[1]. So we have a=c=d=[1], b=[0]. Rank=1. Distinct statuses with parity? There are only 2 possible states: all off (initial all on, pressing nothing). Wait initial all on. After pressing parity combos, we get? We can compute later.\n\nn=2: indices 1,2. b=[0,1], c=[1,0], d: indices ≡1 mod3: 1 only. So d=[1,0]. So a=[1,1], b=[0,1], c=[1,0], d=[1,0]. So c and d equal. b distinct. a = b⊕c. So rank? b and c independent? Let's see: b=[0,1], c=[1,0] independent => rank=2. a is dependent. d=c duplicate. So rank=2.\n\nn=3: indices 1,2,3. b=[0,1,0], c=[1,0,1], d indices 1,4? only 1. d=[1,0,0]. So a=[1,1,1]. Let's compute rank: b and c independent? yes. d? d is not linear combination of b and c: b⊕c = [1,1,1] = a. So d not equal to any of those? d=[1,0,0] which is not b, c, a. But can it be expressed as x*b⊕y*c? x*b⊕y*c = x[0,1,0]⊕y[1,0,1] = [y, x, y]. For this to equal d=[1,0,0], we need y=1, x=0, y=0? impossible. So d independent. So rank=3.\n\nn=4: indices 1-4. b=[0,1,0,1], c=[1,0,1,0], d indices 1,4 => [1,0,0,1]. a=[1,1,1,1]. b⊕c=a. d not combination of b,c? Try x*b⊕y*c = [y, x, y, x]. Set equal [1,0,0,1]. So y=1,x=0 for first entry? yields [1,0,1,0] not match. So independent. rank=3? Wait maybe d equals a⊕b? a⊕b=[1,0,1,0] = c. Not d. So rank=3? But we have 3 independent vectors: b,c,d. So rank=3.\n\nn=5: indices 1-5. b=[0,1,0,1,0], c=[1,0,1,0,1], d indices 1,4 => [1,0,0,1,0]. a=[1,1,1,1,1]. b⊕c=a. d? test if combination: x*b⊕y*c = [y, x, y, x, y] => to equal d [1,0,0,1,0], need y=1, x=0 for first entry -> [1,0,1,0,1] not match. So independent. rank=3.\n\nn=6: b=[0,1,0,1,0,1], c=[1,0,1,0,1,0], d indices 1,4 => [1,0,0,1,0,0]. a=[1,1,1,1,1,1]. b⊕c=a. d? check combination: [y, x, y, x, y, x]. Want [1,0,0,1,0,0]. So y=1,x=0 gives [1,0,1,0,1,0] not match. So independent. rank=3.\n\nn=7: d indices 1,4,7 => [1,0,0,1,0,0,1]. Check combination: [y,x,y,x,y,x,y] = [1,0,0,1,0,0,1] => y=1,x=0 matches all. So d equals [1,0,1,0,1,0,1]? Wait compute: y=1,x=0 => vector [1,0,1,0,1,0,1], but d is [1,0,0,1,0,0,1]. Not equal. So independent. rank=3? Wait we have 3 independent vectors: b,c,d. But maybe a also independent? No a=b⊕c. So rank=3. So far for n>=3, rank=3? But earlier we thought rank=4 for large n, but maybe d always dependent on b and c? Let's test general: Can d be expressed as x*b⊕y*c? That requires d[i] = y if i odd, x if i even. But d pattern repeats every 3: 1 at positions 1,4,7,... pattern of length 3: (1,0,0). So for even positions, d=0; for odd positions, pattern 1,0,1? Wait positions 1 (odd)=1, 2(even)=0,3(odd)=0,4(even)=1? Wait d index 4 is even, but d=1 at 4. So pattern not constant per parity. So cannot be expressed with just parity.\n\nBut can d be expressed as combination of a,b,c? Since a,b,c span subspace of dimension 3? Actually a,b,c are not independent: a=b⊕c. So subspace spanned by a,b,c equals span(b,c). So dimension 2. Wait b and c independent => rank 2. So subspace of dimension 2. d may increase rank to 3. But can d be expressed as linear combination of b and c? We already tested: requires vector [y,x,y,x,...] pattern. d doesn't match. So rank increases to 3. So rank=3 for all n≥3? Let's check n=8: d indices 1,4,7,10? but 10>8. So d=[1,0,0,1,0,0,1,0]. pattern: 1,0,0,1,0,0,1,0. Is this expressible as [y,x,y,x,y,x,y,x]? For n=8, pattern of combination: odd positions all y, even positions all x. For d, odd positions: positions 1,3,5,7 => [1,0,0,1] not all equal. So not. So d independent. So rank=3 for all n≥3.\n\nBut is it ever rank=4? Maybe if n is such that d vector becomes combination of b,c and some other vector? But we only have 4 vectors; b,c produce subspace of dimension 2. Adding d increases to 3. There is no fourth independent vector among these 4 because a is dependent. So rank <=3. So maximum rank 3.\n\nThus number of distinct statuses achievable with no parity restriction = 2^rank = 2^3 = 8 for n≥3. For n=1, rank=1 => 2. For n=2, rank=2 => 4.\n\nNow with parity restriction: need count of distinct vectors achievable by subsets with parity sum = p. For rank=3, we have 8 total vectors. How many correspond to even cardinality subsets? We can compute mapping from parity vector to result vector. Because there are 16 subsets of 4 buttons. For n≥3, mapping from 16 subsets to 8 vectors is 2-to-1? Because each vector has exactly two subsets mapping to it: one with even parity and one with odd parity? Let's test: Since a = b⊕c, we have dependencies that cause duplicate outputs. We need to analyze.\n\nLet's label button indices 1-4. Subsets produce vector sum of selected buttons. We need to find equivalence classes.\n\nGiven that a = b⊕c, pressing button1 and button2 together equals pressing button3? Wait compute: b⊕c = a. So subset {1} (press button1) gives a. Subset {2,3} gives b⊕c = a. So two different subsets produce same vector. Also {1} vs {2,3} parity: |{1}|=1 odd; |{2,3}|=2 even. So indeed each vector appears at least twice with opposite parity. Similarly other combinations? Let's analyze all possibilities:\n\nWe have vectors:\n- V1 = a\n- V2 = b\n- V3 = c\n- V4 = d\n\nWe know a = b⊕c.\n\nCompute all subset sums:\n\n- Empty set: 0 vector (all bulbs off). Cardinality 0 even.\n- {1}: a (odd)\n- {2}: b (odd)\n- {3}: c (odd)\n- {4}: d (odd)\n- {1,2}: a⊕b = (b⊕c)⊕b = c (since b⊕b=0). So {1,2} gives c. Cardinality 2 even. Parity even vs {3} odd produce same vector c.\n- {1,3}: a⊕c = b. Even vs {2} odd produce same vector b.\n- {1,4}: a⊕d\n- {2,3}: b⊕c = a. Even vs {1} odd produce same vector a.\n- {2,4}: b⊕d\n- {3,4}: c⊕d\n- {1,2,3}: a⊕b⊕c = (b⊕c)⊕b⊕c = 0. So empty vector. Odd parity 3 vs empty even produce same vector 0.\n- {1,2,4}: a⊕b⊕d = c⊕d\n- {1,3,4}: a⊕c⊕d = b⊕d\n- {2,3,4}: b⊕c⊕d = a⊕d\n- {1,2,3,4}: a⊕b⊕c⊕d = d\n\nSo mapping summary:\n\nVector 0: subsets {} (even), {1,2,3} (odd). Two subsets, parity differ.\nVector a: subsets {1} (odd), {2,3} (even). Also {2,3,4} (odd?), check {2,3,4} gives a⊕d not a. So just two.\nVector b: subsets {2} (odd), {1,3} (even). Also {1,3,4} gives b⊕d not b.\nVector c: subsets {3} (odd), {1,2} (even). Also {1,2,4} gives c⊕d not c.\nVector d: subsets {4} (odd), {1,2,3,4} (even). Good.\nVector a⊕d: subsets {1,4} (even), {2,3,4} (odd). Good.\nVector b⊕d: subsets {2,4} (even), {1,3,4} (odd). Good.\nVector c⊕d: subsets {3,4} (even), {1,2,4} (odd). Good.\n\nThus for each of the 8 vectors, there are exactly two subsets mapping to it: one even cardinality, one odd. So the parity restriction halves the set: For given parity p, exactly 4 distinct vectors possible. So number of distinct statuses = 4 for n≥3.\n\nEdge cases: n=1: rank 1 => vectors possible? Let's enumerate: n=1, bulbs labeled 1. All bulbs on initially (state 1). Button effects:\n\n- b: even bulbs: none => vector 0.\n- c: odd bulbs: [1].\n- d: j=1 mod3: [1].\n- a: all bulbs: [1].\n\nSo b=0, c=d=a=[1]. So distinct vectors: 0 and [1]. Subsets produce mapping:\n\n- {} => 0 (even)\n- {1} => 1 (odd)\n- {2} => 0 (odd? Actually button2=0 no effect, but parity odd)\n- {3} => 1 (odd)\n- {4} => 1 (odd)\n- {1,2} => 1 (even)\n- {1,3} => 0 (even)\n- {1,4} => 0 (even)\n- {2,3} => 1 (even)\n- {2,4} => 1 (even)\n- {3,4} => 0 (even)\n- {1,2,3} => 0 (odd)\n- {1,2,4} => 0 (odd)\n- {1,3,4} => 1 (odd)\n- {2,3,4} => 1 (odd)\n- {1,2,3,4} => 0 (even)\n\nSo number of distinct vectors with parity even? 0 and maybe 1? Actually vector 0 appears in even subsets, vector 1 appears in even subsets too. So both present. So for n=1, all 2 vectors accessible for any parity? Let's see parity: For parity even, we have subsets of even size produce both 0 and 1. For parity odd, subsets of odd size produce also both 0 and 1. So regardless of parity, we have 2 distinct vectors. So answer for n=1: 2.\n\nn=2: rank 2 => total vectors 4. Let's enumerate mapping: vectors: 0, a, b, c (d=c). Parity mapping similar? Let's check quickly: b, c distinct. a = b⊕c. Distinct vectors: 0, a, b, c. Subsets produce mapping? Let's check parity. We can reason similar: Since we have 4 vectors with 4 independent? Actually rank 2 gives 4 vectors. Since dependency a=b⊕c, we may still have mapping with 2-to-1 parity? Let's test: subsets mapping to each vector:\n\n- 0: {} even, {1,2,3} odd? Wait but we only have 4 buttons: 1-4. But d=c duplicates. So effectively we have 3 distinct button vectors: a,b,c. But pressing button4 same as c. So subsets that include 4 but not 3 produce same as with 3? Let's analyze. It's easier: Represent vectors with three distinct buttons: 1->a, 2->b, 3->c, 4->c. So duplicates. The distinct output vectors set: 0, a, b, c. Let's find parity sets. For each vector:\n\n- 0: subsets {} even; {1,2,3} odd? but {1,2,3} uses a,b,c => a⊕b⊕c = (b⊕c)⊕b⊕c = 0. So parity odd. Also subsets {1,2,3,4} (even?) but includes duplicate c, still 0. So yes both parity.\n\n- a: subsets {1} odd; {2,3} even; {2,4} odd? {2,4} b⊕c = a even? Wait b⊕c = a, so {2,4} gives a with cardinality 2 even. So parity even as well. So both parity.\n\n- b: subsets {2} odd; {1,3} even; {1,4} odd? {1,4} a⊕c = b⊕c⊕c? Wait a⊕c = (b⊕c)⊕c = b. So {1,4} gives b cardinality 2 even? Actually subset {1,4} has size 2 even. So both parity.\n\n- c: subsets {3} odd; {1,2} even; {2,?}?? etc.\n\nThus all 4 vectors have both parity types. So regardless of parity, we get all 4 distinct states. So answer for n=2: 4.\n\nThus for n>=3, answer is 4.\n\nHence algorithm: If n==1 return 2; else if n==2 return 4; else return 4. Actually for n>=3 answer 4. Wait but maybe presses can be 0? If presses=0, parity=0. We need to count distinct statuses achievable after exactly presses presses. If presses=0, only empty subset, parity even, but we might only get 1 status: initial all on (i.e., vector 0). But our counting above considered all parity subsets regardless of number of presses. But we must restrict to sequences of length presses. For each parity vector satisfying parity sum = p, we need to count distinct vector results, but also ensure that there exists a way to realize that parity vector with exactly presses presses. That is, we need to count number of parity vectors (b1..b4) with sum(bi)=p such that there exists a nonnegative integer solution to xi ≡ bi (mod 2) and sum xi = presses. This is possible iff presses >= sum(bi) and (presses - sum(bi)) even? Wait because we can add 2 extra presses to any button to keep parity same. So we need presses >= sum(bi) and presses≡sum(bi) (mod2). Equivalent to presses >= sum(bi) and presses ≡ p (mod2). Since sum(bi) ≡ p (mod2) already, so condition reduces to presses >= sum(bi). So for a given parity vector, if presses >= sum(bi), then there is at least one sequence achieving that parity. But we also need to consider presses exactly. Since we can always add extra 2 presses to any button. So as long as presses >= sum(bi) and parity matches, it's feasible.\n\nThus among parity vectors with sum(bi)=p, only those with sum(bi)<=presses are realizable. So distinct statuses may be fewer if presses small. For large presses, all parity vectors of that parity are realizable. But with small presses, maybe only some.\n\nThus we need to compute number of distinct vectors achievable with exact presses presses, given n. So need to consider presses value.\n\nGiven n≥3, rank 3 => 8 vectors, but each vector corresponds to exactly two parity vectors with opposite parity. For a given parity p, the vectors correspond to parity vectors with that parity. Among those 4 vectors, some parity vectors may have sum(bi)=k minimal. For each vector, we need to know minimal number of button presses required to realize that vector (i.e., minimal sum(bi) among parity vectors mapping to it). Since there are exactly two parity vectors mapping to each vector, one with even parity, one odd. Their sums may differ by 2? Let's compute minimal sums.\n\nTake vector a: parity vectors: {1} sum=1; {2,3} sum=2. Minimal is 1.\n\nVector b: {2} sum=1; {1,3} sum=2. Minimal 1.\n\nVector c: {3} sum=1; {1,2} sum=2. Minimal 1.\n\nVector d: {4} sum=1; {1,2,3,4} sum=4. Minimal 1.\n\nVector a⊕d: {1,4} sum=2; {2,3,4} sum=3. Minimal 2.\n\nVector b⊕d: {2,4} sum=2; {1,3,4} sum=3. Minimal 2.\n\nVector c⊕d: {3,4} sum=2; {1,2,4} sum=3. Minimal 2.\n\nVector 0: {} sum=0; {1,2,3} sum=3. Minimal 0.\n\nThus minimal presses for each vector:\n\n- 0: 0\n- a,b,c,d: 1\n- a⊕d, b⊕d, c⊕d: 2\n\nNow for given presses P, we need to count vectors whose minimal required presses <= P and parity constraint satisfied: there exists a parity vector with sum(bi) <= P and parity = P mod2. Since minimal sum for each vector may differ parity: For vector 0: minimal 0 (even). For a,b,c,d: minimal 1 (odd). For a⊕d etc: minimal 2 (even).\n\nThus for presses P:\n\n- If P==0: only vector 0 achievable. So answer 1.\n- If P==1: can achieve vectors with minimal 0? No because minimal 0 requires 0 presses; but we need exactly 1 press. Can we realize vector 0 with 1 press? need parity 0, but 1 press parity odd. There is no parity vector with sum(bi)=0 and parity odd. So cannot achieve vector 0. But can achieve a,b,c,d each with minimal 1. So 4 vectors. So answer 4.\n- If P==2: Need parity even. Options: vector 0 (minimal 0, parity even). Also a⊕d,b⊕d,c⊕d minimal 2 parity even. Also can we realize a,b,c,d? minimal 1 odd, but we can add 1 extra press to same button to keep parity odd? Wait to keep parity odd, we would need sum(bi) odd. For P=2 even, can't realize odd parity vectors. So only even parity vectors: 0 and the three with minimal 2. So total 4 vectors. So answer 4.\n- If P>=3: parity can be odd or even depending on P. Let's examine P=3 (odd). Parity odd. We need vectors with minimal presses <=3 and parity odd. Minimal odd vectors: a,b,c,d (minimal 1). Also 0 minimal 0 even cannot because parity mismatch. a⊕d,b⊕d,c⊕d minimal 2 even cannot. So only 4 vectors. So answer 4.\n\nThus for any P>=1, answer 4. Except P=0 gives 1.\n\nCheck n=2: rank 2, minimal sums? Let's compute quickly. Distinct vectors: 0, a,b,c. We had mapping earlier: \n- 0: minimal 0\n- a: minimal 1 (subset {1}) and also subset {2,3} sum=2 even. minimal 1 odd.\n- b: minimal 1 (subset {2}) and subset {1,3} sum=2 even. minimal 1 odd.\n- c: minimal 1 (subset {3}) and subset {1,2} sum=2 even. minimal 1 odd.\n\nThus for P=0: only 0. For P>=1: parity may be odd or even. But we need to ensure that vectors with parity matching P exist. For P odd: we can achieve a,b,c with minimal 1, but can we achieve 0? parity 0 requires even sum; but P odd cannot. So answer 3? Wait we have 3 vectors with parity odd. For P even >=2: we can realize 0 (minimal 0), and also a,b,c using minimal 1 odd but can we make them even? Yes we can add one extra press to any button to flip parity to even? Actually to realize vector a with even parity, we need parity even vector mapping to a: subset {2,3} sum=2. So for P even >=2, we can realize a,b,c also. So number of distinct vectors: 4. For P odd >=1, number: 3.\n\nLet's test P=1: odd. Vectors: a,b,c. So answer 3.\n\nP=2: even. Vectors: 0,a,b,c. Answer 4.\n\nThus for n=2: answer depends on presses: if presses=0 =>1, if presses odd >=1 =>3, if presses even >=2 =>4.\n\nn=1: Distinct vectors: 0,1. Let's compute minimal sums: vector 0 minimal 0 even; vector 1 minimal 1 odd. For P=0 => only 0. For P>=1: parity: if P odd, can get vector1; if P even, can we get vector1? Need parity even vector mapping to 1: subset {2,3} sum=2? Actually {2,3} parity even gives vector 1? Let's check: {2,3} uses button2 (0) and button3 (1) gives 1. So parity even vector mapping to 1 exists. So for any P>=1, we can achieve both 0 and 1? Wait vector 0 has parity even; vector1 has parity odd and also even (via subset {2,3}). So both parities. Thus for P>=1: we can achieve both states regardless of parity? Let's confirm: For P even >=2, we can realize 0 via 0 presses plus extra even; we can realize 1 via subset {2,3} with 2 presses. So yes both. For P odd >=1, we can realize 1 via subset {1} (1 press) and 0 via subset {1,2,3} (3 presses) but need 1? can't. But we can use extra even? For P=1 odd, we cannot achieve vector 0 because parity mismatch. So only 1 vector. Wait check: For P=1, parity odd. 0 requires parity even; we cannot. So only vector 1. So answer 1? But earlier we reasoned both parity. But need exactly presses. So for P=1 odd, vector 0 not reachable. So answer 1.\n\nSimilarly for P>=2: for P even, both reachable; for P odd >=3, parity odd; 0 requires even parity, cannot. So vector 0 not reachable. But we can reach 1 via odd parity. So answer 1. So for n=1, answer is 1 for P odd बुध? Actually for any P odd, answer 1. For P even >=2, answer 2.\n\nCheck P=0 even: 0 reachable only. So answer 1.\n\nThus n=1: if presses even >=2 =>2; else =>1.\n\nLet's summarize results:\n\n- n=1:\n    - presses=0 =>1\n    - presses even >=2 =>2\n    - presses odd =>1\n\n- n=2:\n    - presses=0 =>1\n    - presses odd >=1 =>3\n    - presses even >=2 =>4\n\n- n>=3:\n    - presses=0 =>1\n    - presses>=1 =>4\n\nThus algorithm: compute answer based on n and presses.\n\nEdge case: presses could be 0: return 1 for any n? For n>=3, only vector 0 reachable with 0 presses; so answer 1. For n=2: 1? Wait 0 presses -> only vector 0. So answer 1. For n=1: also 1.\n\nThus overall answer:\n\nIf presses==0 return 1.\n\nElse if n==1:\n    if presses even: 2\n    else: 1\n\nElse if n==2:\n    if presses%2==1: 3\n    else: 4\n\nElse (n>=3):\n    return 4\n\nCheck sample? Not given. Let's test P=1, n=3: answer 4. We earlier derived. Good.\n\nEdge: presses maybe less than minimal for some vectors? For P=1, we cannot achieve vector0 due to parity mismatch, but minimal 0 even; but we can't add even number? To keep parity odd, need sum(bi) odd. So 0 cannot. So answer 4? Wait we have a,b,c,d with minimal 1 odd; 0 not. So 4 states. Good.\n\nFor P=2 even: 0 minimal 0 even; also a⊕d etc minimal 2 even. So 4 states.\n\nOk.\n\nNow produce pseudocode steps: Precompute minimal presses for each vector given n≥3? But we derived general formulas.\n\nSimplify:\n\nIf presses==0: answer=1.\n\nElse if n==1:\n    if presses%2==0: answer=2 else answer=1\n\nElse if n==2:\n    if presses%2==1: answer=3 else answer=4\n\nElse (n>=3):\n    answer=4\n\nCheck n=1 with presses=1: odd => answer 1. With presses=2 even => 2. With presses=3 odd => 1. With presses=4 even =>2. Works.\n\nCheck n=2 presses=1 odd =>3 states. Presses=2 even =>4. Presses=3 odd =>3? Wait we earlier said for odd presses >=1, answer 3. But for P=3 odd, parity odd. 0 requires even parity, not reachable. a,b,c reachable via odd parity with minimal 1 plus 2 extra presses? For P=3, we can realize vector a via subset {1} + 2 extra presses? But adding 2 to any button changes sum by 2 but parity same. So parity odd stays. So we can achieve vector a with 3 presses (1+2). So yes a,b,c reachable. 0 not reachable. So 3. So answer 3.\n\nThus n=2, if presses is odd and >0, answer=3. If presses is even and >0, answer=4.\n\nn=1, if presses is odd, answer=1; else even and >0, answer=2.\n\nNow we must produce algorithm steps in pseudocode.\n\nOk.\n\nNow produce explanation.\n\nLet's produce a step-by-step solution in pseudocode, along with justification of formulas.\n\nWill produce:\n\n1. Read n, p\n2. If p==0: return 1\n3. If n==1:\n    - if p%2==0: return 2 else return 1\n4. If n==2:\n    - if p%2==1: return 3 else return 4\n5. Else:\n    - return 4\n\nNeed to confirm for p even >0 for n=1: returns 2; we computed earlier: if p even >=2, we can get both states. Good.\n\nEdge case p=0 already handled.\n\nEdge case p=1 for n=1 returns 1. Good.\n\nEdge case p=1 for n=2 returns 3. Good.\n\nEdge case p=1 for n>=3 returns 4. Good.\n\nEdge case p=2 for n=1 returns 2 (even). Good.\n\nEdge case p=2 for n=2 returns 4 (even). Good.\n\nEdge case p=2 for n>=3 returns 4. Good.\n\nThus final answer.\n\nNow produce pseudocode.\n\nWe'll produce high-level explanation:\n\n- Precompute minimal required presses for each achievable configuration given n.\n- Use combinatorics to determine which configurations are reachable with exactly p presses given parity constraints.\n\nOk.\n\nNow produce final explanation with reasoning.\n\nLet's produce final message.\n...done thinking.\n\n**High‑level idea**\n\nFor a fixed `n` the set of all possible “effects” of the four buttons can be described by\nfour vectors over `GF(2)` :\n\n| button | effect on a bulb `j` |\n|--------|----------------------|\n| 1      | all bulbs            |\n| 2      | even–indexed bulbs   |\n| 3      | odd–indexed bulbs    |\n| 4      | bulbs `j ≡ 1 (mod 3)`|\n\nAll bulbs are initially *on* (vector `1` for every bulb).\nA sequence of presses of length `P` corresponds to a vector\n\n```\nV = (x1 mod 2)·B1 ⊕ (x2 mod 2)·B2 ⊕ (x3 mod 2)·B3 ⊕ (x4 mod 2)·B4\n```\n\nwhere `xk` is the number of times button `k` is pressed and  \n`P = x1 + x2 + x3 + x4`.\n\nBecause pressing the same button twice cancels its effect, the only\ninformation that matters for the final configuration is the *parity*\nvector\n\n```\nb = (b1,b2,b3,b4)  with  bk = xk mod 2\n```\n\nA parity vector `b` is **realizable** with exactly `P` presses iff\n\n```\nP ≥ Σ bk          (we can add arbitrary pairs of presses to any button)\nΣ bk ≡ P (mod 2)  (same parity as P)\n```\n\nFor a fixed `n` we enumerate all distinct vectors that can be produced,\nfind for each of them the *minimal* number of presses `minPress`,\nand count those with `minPress ≤ P` and having a parity compatible\nwith `P`.\n\n\n\n--------------------------------------------------------------------\n\n### 1.  What distinct vectors can appear?\n\n| `n` | rank of the button matrix | number of distinct vectors |\n|-----|----------------------------|---------------------------|\n| 1   | 1                          | 2                         |\n| 2   | 2                          | 4                         |\n| ≥3  | 3                          | 8                         |\n\nThe rank follows from the linear dependence\n\n```\nB1 = B2 ⊕ B3            (all bulbs = even bulbs ⊕ odd bulbs)\n```\n\nand the fact that `B4` is independent of the first three for `n ≥ 3`.\nThe explicit mapping from all 16 subsets of the four buttons to the\n8 vectors for `n ≥ 3` is\n\n```\nvector :   0      B1   B2   B3   B4   B1⊕B4  B2⊕B4  B3⊕B4\nparity  :  even  odd  odd  odd  odd  even   even   even\nminimal : 0     1    1    1    1    2      2      2\n```\n\n--------------------------------------------------------------------\n\n### 2.  Minimal number of presses for every vector\n\n*For `n = 1`*  \n```\n0   → 0 presses (even)\n1   → 1 press  (odd)  and also 2 presses  (even)  (buttons 2+3)\n```\n\n*For `n = 2`*  \n```\n0   → 0 presses (even)\nA   → 1 press (odd)   and 2 presses (even)   (buttons 2+3)\nB   → 1 press (odd)   and 2 presses (even)   (buttons 1+3)\nC   → 1 press (odd)   and 2 presses (even)   (buttons 1+2)\n```\n\n*For `n ≥ 3`*  \n```\n0                → 0  (even)\nA,B,C,D          → 1  (odd)\nA⊕D, B⊕D, C⊕D   → 2  (even)\n```\n(As listed above.)\n\n--------------------------------------------------------------------\n\n### 3.  Counting reachable configurations\n\nLet `P` be the required number of presses and `parity = P mod 2`.\n\n*If `P = 0`*  \nOnly the empty subset is allowed → exactly **1** configuration\n(the initial “all on” state).\n\n*Otherwise (`P > 0`)*  \nA configuration is reachable iff it has a minimal required press\n`minPress ≤ P` **and** the parity of that minimal press equals `parity`.\n\nThe tables below give the answer for every `(n , P)`:\n\n| `n` | `P = 0` | `P` odd ≥ 1 | `P` even ≥ 2 |\n|-----|---------|-------------|---------------|\n| 1   | 1 | 1 | 2 |\n| 2   | 1 | 3 | 4 |\n| ≥3  | 1 | 4 | 4 |\n\n--------------------------------------------------------------------\n\n### 4.  Algorithm (pseudocode)\n\n```pseudocode\nfunction countConfigurations(n, P):\n    if P == 0:\n        return 1                    // only the empty subset\n\n    if n == 1:\n        if P % 2 == 0:             // even number of presses\n            return 2               // both states reachable\n        else:\n            return 1               // only state “bulb 1 on” reachable\n\n    else if n == 2:\n        if P % 2 == 1:             // odd number of presses\n            return 3               // 3 states (A, B, C)\n        else:                      // even number of presses (≥2)\n            return 4               // all 4 states reachable\n\n    else:                          // n ≥ 3\n        return 4                   // always 4 states for any P ≥ 1\n```\n\n--------------------------------------------------------------------\n\n### 5.  Correctness proof\n\nWe prove that the algorithm returns the exact number of distinct\nconfigurations achievable after exactly `P` presses.\n\n---\n\n#### Lemma 1  \nFor any `n`, a vector `V` can be produced with exactly `P` presses\niff there exists a parity vector `b` (i.e. a 0/1 vector for the four\nbuttons) such that\n\n```\nΣ bi ≤ P     and     Σ bi ≡ P (mod 2)\n```\n\n*Proof.*  \n`bi` is the desired parity of button `i`.  \nIf a solution `x1,…,x4` with `xk ≡ bk (mod 2)` and `Σ xk = P` exists,\nthen necessarily `Σ bk ≡ P (mod 2)`.  \nConversely, if `Σ bk ≤ P` and the parity matches,\nadd `2·t` presses to any button (t≥0) to raise `Σ xk` to `P`. ∎\n\n\n\n#### Lemma 2  \nFor `n ≥ 3` the set of reachable vectors with parity `p` (i.e. with\n`Σ bi ≡ p (mod 2)`) is exactly 4 distinct vectors.\n\n*Proof.*  \nWe have the 8 distinct vectors listed in Section&nbsp;1.\nEach of them is produced by exactly two parity vectors of opposite\nparity (shown by explicit subset mapping).  \nHence for a fixed parity `p` the number of reachable vectors equals\nhalf of 8, i.e. 4. ∎\n\n\n\n#### Lemma 3  \nFor `n = 2` the distinct vectors are  \n`0, A, B, C` with minimal presses  \n`0, 1, 1, 1` respectively, and both parities are attainable for\n`A,B,C` by using subsets `{2,3}`, `{1,3}`, `{1,2}` respectively.\n\n*Proof.*  \nImmediate from the mapping table of Section&nbsp;2. ∎\n\n\n\n#### Lemma 4  \nFor `n = 1` the distinct vectors are  \n`0` (minimal 0, even) and `1` (minimal 1, odd).  \nVector `1` also has an even‑parity representation (`{2,3}`).\n\n*Proof.*  \nDirect enumeration of the four buttons for a single bulb. ∎\n\n\n\n#### Lemma 5  \nThe algorithm’s output equals the number of reachable distinct vectors\nfor every `(n, P)`.\n\n*Proof.*  \n\n*Case `P = 0`.*  \nOnly the empty subset is allowed, giving vector `0`.  \nThe algorithm returns 1 in all cases. ✓\n\n*Case `n = 1`, `P ≥ 1`.*\n\n- If `P` is odd, parity odd forces vector `0` to be impossible\n  (no odd parity subset maps to `0`).  \n  Vector `1` is reachable via subset `{1}`.  \n  → 1 configuration. The algorithm returns 1.\n\n- If `P` is even (`≥2`), vector `0` is reachable by adding\n  any even number of extra presses to the empty subset, and vector\n  `1` is reachable by `{2,3}` (2 presses).  \n  → 2 configurations. The algorithm returns 2. ✓\n\n*Case `n = 2`.*\n\n- `P` even (`≥2`): all 4 vectors are reachable (0 via 0 presses,\n  `A,B,C` via `{2,3}`, `{1,3}`, `{1,2}` respectively).  \n  → 4 configurations. The algorithm returns 4.\n\n- `P` odd (`≥1`): only vectors `A,B,C` can have the required odd\n  parity.  \n  → 3 configurations. The algorithm returns 3. ✓\n\n*Case `n ≥ 3`.*\n\nFrom Lemma&nbsp;2 every parity has exactly 4 distinct vectors.\nFor any `P ≥ 1`, the minimal required press for each of those 4 vectors\nis at most 2 (see Section&nbsp;2).  \nThus `Σ bi ≤ P` holds for all of them, so each of the 4 vectors is\nrealizable.  \nIf `P = 0` only vector `0` is reachable.  \nHence the algorithm’s answer (1 for `P=0`, 4 otherwise) is correct. ✓\n\n∎\n\n\n\n#### Theorem  \nThe algorithm `countConfigurations(n,P)` returns the exact number of\ndistinct configurations that can be achieved after exactly `P` button\npresses for the given number of bulbs `n`.\n\n*Proof.*  \nDirectly follows from Lemma&nbsp;5. ∎\n\n\n\n--------------------------------------------------------------------\n\n### 6.  Complexity analysis\n\nThe algorithm uses only a handful of constant‑time arithmetic\noperations; therefore\n\n```\nTime   : O(1)\nMemory : O(1)\n```\n\n--------------------------------------------------------------------\n\n### 7.  Reference implementation (Python 3)\n\n```python\ndef count_configurations(n: int, p: int) -> int:\n    \"\"\"\n    Return the number of distinct configurations that can be achieved\n    after exactly p button presses, for a line of n bulbs.\n    \"\"\"\n    if p == 0:\n        # only the initial state (all on) is reachable\n        return 1\n\n    if n == 1:\n        # for odd p only the state with bulb 1 on is reachable\n        return 2 if p % 2 == 0 else 1\n\n    if n == 2:\n        return 4 if p % 2 == 0 else 3\n\n    # n >= 3\n    return 4\n\n\n# Example usage\nif __name__ == \"__main__\":\n    n, p = map(int, input().split())\n    print(count_configurations(n, p))\n```\n\nThe program follows exactly the algorithm proven correct above\nand runs in constant time and memory.",
      "generated_code": "import sys\n\ndef count_configurations(n: int, p: int) -> int:\n    if p == 0:\n        return 1\n    if n == 1:\n        return 2 if p % 2 == 0 else 1\n    if n == 2:\n        return 4 if p % 2 == 0 else 3\n    return 4\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Expect input format like \"n = 1, presses = 1\"\n    parts = data.replace('n', '').replace('presses', '').replace('=', '').replace(',', ' ').split()\n    n = int(parts[0])\n    p = int(parts[1])\n    print(count_configurations(n, p))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1, presses = 1",
          "expected_output": "2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "n = 2, presses = 1",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "n = 3, presses = 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode60.json",
    "problem_index_in_file": 0,
    "title": "Permutation Sequence",
    "description_snippet": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations.\n\nBy listing and labeling all o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the k-th permutation problem. Should output step by step with explanations. No actual code. Use arrow syntax. Should include steps: compute factorials, determine which number at each position, decrement k etc. Provide explanation. Should be in Traditional Chinese. Provide each line. Let's produce typical algorithm. Use decision. Provide Start, End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀入整數 n 和 k // 取得集合大小與目標排列順序\n→ Step 2: 建立列表 numbers = [1, 2, ..., n] // 用於取出尚未使用的數字\n→ Step 3: 先計算 factorial 陣列 fact[0..n] // 方便快速取得 (n-i-1)! 的值\n    → Step 3a: fact[0] ← 1\n    → Step 3b: 迴圈 i 從 1 到 n，fact[i] ← fact[i-1] * i\n→ Step 4: 調整 k 為 0 索引 // 方便用除法與取餘數計算\n    → k ← k - 1\n→ Step 5: 初始化空字串 result // 用於累積最終排列\n→ Step 6: 迴圈 i 從 1 到 n // 為每一個位置決定該放哪個數字\n    → Decision: 如果 numbers 為空則跳過 // 防止下標錯誤\n        → No → // 正常流程\n    → Step 6a: 取 factorial = fact[n - i] // 目前剩餘位置數的階乘\n    → Step 6b: index ← k / factorial // 整除得到在 numbers 中的索引\n    → Step 6c: append numbers[index] 到 result // 把選出的數字加到結果中\n    → Step 6d: 刪除 numbers[index] // 這個數字已被使用\n    → Step 6e: k ← k mod factorial // 更新 k 為剩餘部分\n→ Step 7: 輸出 result // 將完成的排列字串回傳\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\nimport re\n\ndef get_permutation(n: int, k: int) -> str:\n    \"\"\"\n    返回第 k 個排列（1 索引）作為字串。\n    \"\"\"\n    numbers = list(range(1, n + 1))\n    k -= 1                     # 轉成 0 索引\n    result = []\n\n    for i in range(n, 0, -1):\n        fact = math.factorial(i - 1)      # (i-1)! 的階乘\n        index = k // fact                 # 在 numbers 中的索引\n        result.append(str(numbers.pop(index)))  # 加入結果並移除已用數字\n        k %= fact                          # 更新剩餘 k\n\n    return ''.join(result)\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取 n 與 k，輸出第 k 個排列。\n    輸入可為「n = 3, k = 3」或任何包含兩個整數的文字。\n    \"\"\"\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)        # 擷取所有整數\n    if len(nums) < 2:\n        return\n    n, k = int(nums[0]), int(nums[1])\n\n    print(get_permutation(n, k))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 3",
          "expected_output": "\"213\"",
          "success": true,
          "output": "213"
        },
        {
          "example_index": 1,
          "input": "n = 4, k = 9",
          "expected_output": "\"2314\"",
          "success": true,
          "output": "2314"
        },
        {
          "example_index": 2,
          "input": "n = 3, k = 1",
          "expected_output": "\"123\"",
          "success": true,
          "output": "123"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode744.json",
    "problem_index_in_file": 0,
    "title": "Find Smallest Letter Greater Than Target",
    "description_snippet": "You are given an array of characters letters that is sorted in non-decreasing order, and a character...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Chinese (Traditional). Must be line-by-line, each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision.\n\nWe need algorithm: find smallest character greater than target. Since letters sorted, can binary search or iterate. Use binary search typical. Steps: Start, Step 1: initialize low, high; Step 2: binary search loop: while low < high; Step 3: mid = (low+high)/2; Step 4: if letters[mid] <= target, low = mid+1 else high = mid; After loop, check if low < len: return letters[low] else return letters[0]. Use decision nodes. We need to output virtual code and explanation. Let's produce maybe 15 lines. Use arrows like \"→\". Use Decision with \"Yes →\" \"No →\". Use indentation.\n\nLet's craft.\n\nStart // 程式開始\n→ Step 1: 設定 low = 0, high = len(letters) // 初始化搜尋區間\n→ Decision: 是否還有可搜尋區間? // 判斷搜尋是否結束\n    Yes → Step 2: 計算 mid = (low + high) // 2 // 找到中間位置\n    → Decision: letters[mid] 是否小於等於 target? // 判斷中間字元是否 <= 目標\n        Yes → Step 3: low = mid + 1 // 將搜尋區間縮小到右半邊\n        No  → Step 4: high = mid // 將搜尋區間縮小到左半邊\n    → Decision: low 是否小於 high? // 判斷是否還有區間可搜尋\n        Yes → 回到 Decision: 是否還有可搜尋區間? // 重複搜尋\n        No  → Step 5: // 搜尋結束\n→ Decision: low 是否小於 len(letters)? // 檢查是否找到符合條件的字元\n    Yes → Step 6: return letters[low] // 返回最小大於目標的字元\n    No  → Step 7: return letters[0] // 沒有找到，返回首字元\nEnd // 程式執行結束\n\nBut ensure arrows: Use \"→\". For decision we show \"Decision:\" with arrows. Use indent with spaces. Let's produce.\n\nNote: Use \"Decision:\" lines maybe \"Decision: low < high?\" etc.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 low = 0, high = len(letters) // 初始化搜尋區間  \n→ Decision: low < high? // 判斷是否還有區間可搜尋  \n    Yes → Step 2: mid = (low + high) // 2 // 找到中間位置  \n    → Decision: letters[mid] <= target? // 判斷中間字元是否 <= 目標  \n        Yes → Step 3: low = mid + 1 // 將搜尋區間縮小到右半邊  \n        No  → Step 4: high = mid // 將搜尋區間縮小到左半邊  \n    → Decision: low < high? // 判斷是否還有區間可搜尋  \n        Yes → 回到 Decision: low < high? // 重複搜尋  \n        No  → Step 5: // 搜尋結束  \n→ Decision: low < len(letters)? // 檢查是否找到符合條件的字元  \n    Yes → Step 6: return letters[low] // 返回最小大於目標的字元  \n    No  → Step 7: return letters[0] // 沒有找到，返回首字元  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def nextGreatestLetter(self, letters, target):\n        # 二分搜尋尋找最小大於 target 的字元\n        left, right = 0, len(letters) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if letters[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        # 如果 left 趕到結尾，使用模數回到起始\n        return letters[left % len(letters)]\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'letters = [\"c\",\"f\",\"j\"], target = \"a\"' 的字串。\n    返回 letters list 與 target 字元。\n    \"\"\"\n    letters_match = re.search(r'letters\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*\"([^\"]*)\"', data)\n    if not letters_match or not target_match:\n        raise ValueError(\"Invalid input format\")\n    letters = ast.literal_eval(letters_match.group(1))\n    target = target_match.group(1)\n    return letters, target\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n    letters, target = parse_input(input_data)\n    solution = Solution()\n    result = solution.nextGreatestLetter(letters, target)\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"a\"",
          "expected_output": "\"c\"",
          "success": true,
          "output": "\"c\""
        },
        {
          "example_index": 1,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"c\"",
          "expected_output": "\"f\"",
          "success": true,
          "output": "\"f\""
        },
        {
          "example_index": 2,
          "input": "letters = [\"x\",\"x\",\"y\",\"y\"], target = \"z\"",
          "expected_output": "\"x\"",
          "success": true,
          "output": "\"x\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode496.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element I",
    "description_snippet": "The next greater element of some element x in an array is the first greater element that is to the r...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for the algorithm: given two arrays nums1 and nums2, find for each element in nums1 its next greater element in nums2. Standard approach: use stack to compute next greater for each element in nums2. Map element to its next greater. Then build ans by mapping nums1 to map. Complexity O(n). Provide step by step virtual code with arrows, decisions.\n\nWe should produce line by line virtual code, with comment after space. Should include Start, End, Decision etc. Let's craft.\n\nSteps: Start\n→ Step 1: Initialize empty stack S and empty map M // stack for indices or values; map for next greater\n→ Step 2: For each element num in nums2 from left to right // iterate through array\n    → Decision: Is stack empty? // check if no previous elements\n        No → Decision: If top of stack element < num? // find first greater on left? Actually we need next greater to right: we traverse left to right, we need to pop smaller elements as we find next greater. So algorithm: for each num, while stack not empty and top < num: pop and set map[pop] = num. After that push num onto stack.\nWe need to describe in virtual code.\n\nSo:\n\n→ Decision: While stack not empty and stack top < num? // need to pop and assign\nBut decision inside loop.\n\nLet's structure:\n\n→ Step 3: While stack not empty and stack top < num // pop smaller elements\n        → Step 3.1: Pop element top from stack // remove smaller element\n        → Step 3.2: Map[top] = num // set next greater for popped element\n        → Decision: Continue while loop? // loop condition automatically.\n\nAfter loop ends:\n\n→ Step 3.3: Push num onto stack // push current element\n\nAfter loop for all elements done:\n\n→ Step 4: For any remaining elements in stack: // no next greater\n    → While stack not empty:\n        → Step 4.1: Pop element top\n        → Step 4.2: Map[top] = -1\n\n→ Step 5: Initialize ans array of length nums1.length\n→ Step 6: For i from 0 to nums1.length-1:\n    → Step 6.1: ans[i] = Map[nums1[i]] // get next greater\n→ End // return ans\n\nBut we need virtual code lines; we can combine loops but each step should be line.\n\nLet's produce lines:\n\nStart\n→ Step 1: stack = empty stack // 用於存放尚未找到更大元素的數字\n→ Step 2: nextGreater = empty map // 數字 -> 下一個更大元素\n→ Step 3: for num in nums2: // 依序處理 nums2 中的每個數字\n    → Decision: while stack not empty and stack.top < num? // 檢查是否存在更大的左側元素\n        → Step 3.1: pop = stack.pop() // 取出較小的數字\n        → Step 3.2: nextGreater[pop] = num // 設定其下一個更大元素\n        → Decision: repeat while? // 循環條件自動檢查\n    → Step 3.3: stack.push(num) // 把目前數字加入棧中\n→ Step 4: // 以後的棧中數字都沒有更大的元素\n    → Decision: while stack not empty? \n        → Step 4.1: pop = stack.pop()\n        → Step 4.2: nextGreater[pop] = -1\n→ Step 5: ans = new array of size nums1.length\n→ Step 6: for i from 0 to nums1.length-1:\n    → Step 6.1: ans[i] = nextGreater[nums1[i]] // 取得對應的下一個更大元素\n→ End\n\nBut we need each line with comment after space. The decision lines need arrow? They already have arrow. For decision we use \"Decision:\".\n\nBetter format:\n\nStart // 程式開始執行\n→ Step 1: stack = empty stack // 用於暫存未找到更大元素的數字\n→ Step 2: nextGreater = empty map // 存放數字對應的下一個更大元素\n→ Step 3: for num in nums2: // 遍歷 nums2\n    → Decision: while stack not empty and stack.top < num? // 若棧頂小於當前數字\n        → Step 3.1: pop = stack.pop() // 取出棧頂\n        → Step 3.2: nextGreater[pop] = num // 設定 pop 的下一個更大\n        → Decision: continue while? // 循環判斷自動\n    → Step 3.3: stack.push(num) // 把 num 放入棧中\n→ Step 4: // 處理棧中剩餘元素，無更大值\n    → Decision: while stack not empty? // 棧仍有元素\n        → Step 4.1: pop = stack.pop() // 取出\n        → Step 4.2: nextGreater[pop] = -1 // 無更大\n→ Step 5: ans = array of size nums1.length // 準備結果\n→ Step 6: for i in 0..nums1.length-1:\n    → Step 6.1: ans[i] = nextGreater[nums1[i]] // 填入對應值\n→ End // 回傳 ans\n\nBut need each line separate, and inside loops we may need indentation? But the requirement is each line is separate. We can represent nested levels with indentation maybe? But they didn't specify indentation, just line breaks.\n\nBetter to flatten loops: Use lines with labels. Example:\n\n→ Step 3: for num in nums2: //...\nBut then inside we need separate lines, but we need to show decision lines inside. We can use indentation to indicate block. Not required but helpful.\n\nGiven requirement: \"逐行輸出\" each line must contain virtual code step + space + // explanation. They didn't say no indentation but okay.\n\nLet's produce as:\n\nStart // 程式開始執行\n→ Step 1: stack = empty stack // 用於暫存尚未找到更大元素的數字\n→ Step 2: nextGreater = empty map // 存放數字對應的下一個更大元素\n→ Step 3: for num in nums2: // 遍歷 nums2 中的每個元素\n    → Decision: while stack not empty and stack.top < num? // 檢查棧頂是否小於當前元素\n        → Step 3.1: pop = stack.pop() // 取出棧頂\n        → Step 3.2: nextGreater[pop] = num // 設定 pop 的下一個更大元素\n        → Decision: continue while? // 由循環條件自動檢查\n    → Step 3.3: stack.push(num) // 將當前元素入棧\n→ Step 4: // 把棧中剩餘元素設為 -1，因為沒有更大元素\n    → Decision: while stack not empty? // 若棧非空\n        → Step 4.1: pop = stack.pop() // 取出\n        → Step 4.2: nextGreater[pop] = -1 // 設定為 -1\n→ Step 5: ans = array of size nums1.length // 準備答案陣列\n→ Step 6: for i in 0..nums1.length-1: // 為每個 nums1 的元素填寫答案\n    → Step 6.1: ans[i] = nextGreater[nums1[i]] // 取得對應的下一個更大元素\n→ End // 回傳 ans\n\nNeed to show mapping ans return. But we can mention returning ans. Maybe step 6.1 is final fill, and then End returns ans. Could add comment.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: stack = empty stack // 用於暫存尚未找到更大元素的數字  \n→ Step 2: nextGreater = empty map // 存放每個數字對應的下一個更大元素  \n→ Step 3: for num in nums2: // 依序處理 nums2 中的每個數字  \n  → Decision: while stack not empty and stack.top < num? // 若棧頂小於當前數字，說明當前數字為其下一個更大元素  \n    → Step 3.1: pop = stack.pop() // 取出棧頂的數字  \n    → Step 3.2: nextGreater[pop] = num // 設定 pop 的下一個更大元素為 num  \n    → Decision: continue while? // 由循環條件自動檢查是否仍有更小的棧頂  \n  → Step 3.3: stack.push(num) // 把 num 入棧，等待後續更大的元素  \n→ Step 4: // 以後棧中剩餘的數字沒有更大元素  \n  → Decision: while stack not empty? // 若棧仍有元素  \n    → Step 4.1: pop = stack.pop() // 取出剩餘數字  \n    → Step 4.2: nextGreater[pop] = -1 // 設定為 -1，表示無更大元素  \n→ Step 5: ans = array of size nums1.length // 準備答案陣列  \n→ Step 6: for i in 0..nums1.length-1: // 為每個 nums1 的元素填寫答案  \n  → Step 6.1: ans[i] = nextGreater[nums1[i]] // 取得對應的下一個更大元素  \n→ End // 回傳 ans，完成運算",
      "generated_code": "import sys\nimport re\n\ndef next_greater_element(nums1, nums2):\n    stack = []\n    next_greater = {}\n    for num in nums2:\n        while stack and num > stack[-1]:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n    return [next_greater.get(x, -1) for x in nums1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the two lists from the input string\n    matches = re.findall(r'\\[.*?\\]', data)\n    if len(matches) < 2:\n        print(\"[]\")\n        sys.exit(0)\n    nums1 = eval(matches[0])\n    nums2 = eval(matches[1])\n    result = next_greater_element(nums1, nums2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [4,1,2], nums2 = [1,3,4,2]",
          "expected_output": "[-1,3,-1]",
          "success": true,
          "output": "[-1, 3, -1]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [2,4], nums2 = [1,2,3,4]",
          "expected_output": "[3,-1]",
          "success": true,
          "output": "[3, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode658.json",
    "problem_index_in_file": 0,
    "title": "Find K Closest Elements",
    "description_snippet": "Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the ar...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The algorithm: find k closest numbers. Approach: binary search to find insertion point of x, then two pointers expanding outward. Steps: Start, input arr, k, x. Find left and right indices via binary search for x. Then while k > 0: compare left and right boundaries, choose closer, decrement k, move pointer. Edge cases. After selection, sort result ascending. Then output.\n\nWe need to produce virtual code step by step with arrows. We'll use Decision lines. Let's create steps.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 初始化 left = 0, right = length(arr)-1 // 設定搜尋範圍\n→ Decision: 是否在 arr 中存在 x? // 檢查是否有等於 x 的元素\n    Yes → Step 2: 取得 x 的索引 idx // 若存在，設定左右指標\n        → Step 3: left = idx\n        → Step 4: right = idx\n    No  → Decision: x 在 arr 的插入位置? // 若不存在，找出插入點\n        → Step 5: binarySearch(arr, x) -> pos // pos 為插入位置\n        → Step 6: left = pos-1\n        → Step 7: right = pos\n→ Step 8: 建立空列表 result // 儲存 k 個最接近的數\n→ Decision: k > 0? // 是否還有數要挑選\n    Yes → Decision: left < 0 and right >= len? // 若兩側都已走完\n        Yes → Step 9: 若 left < 0 则 result += arr[right] ; right +=1 ; k -=1\n        No → Step 10: 若 right >= len 或 (left >=0 and |arr[left]-x| <= |arr[right]-x|) // 左邊更近或等距且更小\n                → Step 11: result += arr[left] ; left -=1 ; k -=1\n                No → Step 12: result += arr[right] ; right +=1 ; k -=1\n        → Go back to Decision: k > 0? // 重新檢查\n    No  → Step 13: Sort result ascending // 排序\n→ End // 程式結束\n\nBut we need arrow formatting consistent. Also include '→' for steps, 'Decision:' etc.\n\nMake sure each line has \"虛擬碼步驟 [space] // 解釋\".\n\nWe can break each decision branch lines accordingly.\n\nBetter to produce more concise steps.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0, right = len(arr) - 1 // 設定搜尋區間  \n→ Decision: arr 包含 x? // 判斷是否有等於 x 的元素  \n  Yes → Step 2: idx = index of x in arr // 找到 x 的索引  \n   → Step 3: left = idx  \n   → Step 4: right = idx  \n  No → Step 5: pos = binarySearchInsertPos(arr, x) // 取得 x 的插入位置  \n   → Step 6: left = pos - 1  \n   → Step 7: right = pos  \n→ Step 8: result = [] // 用於儲存 k 個最接近的數字  \n→ Decision: k > 0? // 是否還有數字需要挑選  \n  Yes → Decision: left < 0 or right >= len(arr)? // 是否兩側已走完  \n    Yes → Decision: left < 0? // 只有右側可取  \n      Yes → Step 9: result.append(arr[right])  \n       → right += 1  \n       → k -= 1  \n      No → Step 10: result.append(arr[left])  \n       → left -= 1  \n       → k -= 1  \n    No → Step 11: leftDist = abs(arr[left] - x)  \n      rightDist = abs(arr[right] - x)  \n      Decision: leftDist <= rightDist? // 左邊更近或相等且較小  \n       Yes → Step 12: result.append(arr[left])  \n        → left -= 1  \n        → k -= 1  \n       No → Step 13: result.append(arr[right])  \n        → right += 1  \n        → k -= 1  \n      → Go back to Decision: k > 0? // 重新檢查是否還有數字需要挑選  \n  No → Step 14: result.sort() // 將選出的 k 個數字按升序排列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findClosestElements(self, arr, k, x):\n        \"\"\"\n        Find the k closest numbers to x in a sorted array arr.\n        Uses binary search on the starting index of the window.\n        \"\"\"\n        left, right = 0, len(arr) - k\n        while left < right:\n            mid = (left + right) // 2\n            # Compare distances at the ends of the window [mid, mid+k-1]\n            if x - arr[mid] > arr[mid + k] - x:\n                left = mid + 1\n            else:\n                right = mid\n        return arr[left:left + k]\n\ndef parse_input(text):\n    \"\"\"\n    Parse input text to extract array, k, and x.\n    Supports formats like:\n        arr = [1,2,3,4,5], k = 4, x = 3\n    or just a sequence of numbers where the last two are k and x.\n    \"\"\"\n    arr = None\n    # Search for a list representation\n    match = re.search(r'\\[.*?\\]', text)\n    if match:\n        try:\n            arr = ast.literal_eval(match.group(0))\n        except Exception:\n            arr = None\n    if arr is not None:\n        # Remove the matched part and extract remaining integers\n        remaining = text[:match.start()] + text[match.end():]\n        nums = list(map(int, re.findall(r'-?\\d+', remaining)))\n        if len(nums) >= 2:\n            k, x = nums[0], nums[1]\n        else:\n            k, x = 0, 0\n    else:\n        # No explicit list; assume last two numbers are k and x\n        nums = list(map(int, re.findall(r'-?\\d+', text)))\n        if len(nums) < 3:\n            raise ValueError(\"Insufficient input data.\")\n        k, x = nums[-2], nums[-1]\n        arr = nums[:-2]\n    return arr, k, x\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    data = sys.stdin.read()\n    # Parse input\n    arr, k, x = parse_input(data)\n    # Ensure arr is sorted (problem guarantees this, but we sort to be safe)\n    arr.sort()\n    # Compute result\n    sol = Solution()\n    result = sol.findClosestElements(arr, k, x)\n    # Print result as a Python list\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [1,2,3,4,5], k = 4, x = 3",
          "expected_output": "[1,2,3,4]",
          "success": true,
          "output": "[1, 2, 3, 4]"
        },
        {
          "example_index": 1,
          "input": "arr = [1,1,2,3,4,5], k = 4, x = -1",
          "expected_output": "[1,1,2,3]",
          "success": true,
          "output": "[1, 1, 2, 3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode93.json",
    "problem_index_in_file": 0,
    "title": "Restore IP Addresses",
    "description_snippet": "A valid IP address consists of exactly four integers separated by single dots. Each integer is betwe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Essentially algorithm: backtracking to insert dots at positions. Conditions: each segment 1-3 digits, value 0-255, no leading zeros unless single digit 0. Input string s digits only. Output list.\n\nWe need to produce step-by-step pseudocode, each line with explanation. Use arrows, decisions. Include Start, End. Also show recursion/backtracking. Let's produce structured pseudocode.\n\nWe need to adhere to format: each line: `虛擬碼步驟 // 解釋`. Use arrows like `→`. Provide decisions.\n\nLet's outline:\n\nStart\n→ Initialize result list // 存儲有效IP\n→ Call DFS(index=0, part=0, current=\"\") // index pointer, part count, current IP string\n\nDefine DFS(index, part, current)\n→ Decision: if part==4 and index==len(s) → Add current to result // 完成一個IP\n    Yes → Return\n→ Decision: if part==4 or index==len(s) → Return // 已達4段或字串結束但不完整\n→ For lenSeg from 1 to 3:\n    → Decision: if index+lenSeg > len(s) → Continue\n    → segment = s[index:index+lenSeg]\n    → Decision: if segment has leading zero and len>1 → Continue\n    → Decision: if int(segment) > 255 → Continue\n    → Decision: part==3? newIP = current + segment : newIP = current + segment + \".\"\n    → Call DFS(index+lenSeg, part+1, newIP)\n\nEnd\n\nBut we need to produce step-by-step lines.\n\nWe should include function definition lines. We need to decide indentation? It's just lines with arrows; but can use spaces.\n\nLet's produce.\n\nWe must ensure each line is distinct.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Set result ← [] // 儲存所有合法IP\n→ Define DFS(index, part, current) // 回溯函式\n    → Decision: 若 part == 4 且 index == len(s) // 檢查是否完整\n        Yes → Add current 到 result // 存入合法IP\n        Yes → Return // 結束此路徑\n        No  → Decision: 若 part == 4 或 index == len(s) // 超過段數或字串結束但不完整\n            Yes → Return // 放棄此路徑\n    → For segLen in {1,2,3} // 嘗試不同長度\n        → Decision: 若 index + segLen > len(s) // 超出字串\n            Yes → Continue // 跳到下一長度\n        → seg ← s[index : index + segLen] // 取子字串\n        → Decision: 若 segLen > 1 且 seg[0] == '0' // 前導零\n            Yes → Continue // 無效\n        → Decision: 若 int(seg) > 255 // 超過範圍\n            Yes → Continue\n        → newCurrent ← current + seg + (若 part==3 ? \"\" : \".\") // 加上分隔符\n        → DFS(index + segLen, part + 1, newCurrent) // 進一步遞迴\n→ DFS(0, 0, \"\") // 開始回溯\nEnd // 程式結束\n\nBut each line must be separate. We need to use arrows each line. Indentation inside? Use arrows at start of each line: \"→\" or \"    →\"? The example uses \"→\" at start of each line and then indent for nested decisions. Let's match style: each line starts with \"→\" except Start and End? The example has \"Start\" no arrow. They use \"→ Step 1: ...\" etc. For nested decisions, they indent with 4 spaces then arrow? In example: \n```\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // ...\n```\nSo we need to indent nested lines with spaces. Let's do that.\n\nWe'll produce lines accordingly.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Set result ← [] // 初始化儲存合法 IP 的結果清單  \n→ Define DFS(index, part, current) // 定義回溯函式  \n → Decision: 若 part == 4 且 index == len(s) // 完整且已使用全部字元  \n  Yes → Add current 到 result // 把符合條件的 IP 加入結果  \n  Yes → Return // 回到上一層遞迴  \n  No  → Decision: 若 part == 4 或 index == len(s) // 超過段數或未使用完字串  \n   Yes → Return // 放棄此路徑  \n → For segLen in {1, 2, 3} // 嘗試 1 到 3 位長的片段  \n  → Decision: 若 index + segLen > len(s) // 片段長度會超出字串長度  \n   Yes → Continue // 跳到下一個 segLen  \n  → seg ← s[index : index + segLen] // 取得當前片段  \n  → Decision: 若 segLen > 1 且 seg[0] == '0' // 前導零且長度>1  \n   Yes → Continue // 片段不合法  \n  → Decision: 若 int(seg) > 255 // 數值超過 255  \n   Yes → Continue // 片段不合法  \n  → newCurrent ← current + seg + (若 part == 3 ? \"\" : \".\") // 加上分隔符（最後一段不加）  \n  → DFS(index + segLen, part + 1, newCurrent) // 進行下一段的遞迴  \n→ DFS(0, 0, \"\") // 從字串開頭開始回溯  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def restoreIpAddresses(self, s: str):\n        res = []\n\n        def backtrack(start: int, path: list):\n            # 完成四段且已使用完所有字元\n            if start == len(s) and len(path) == 4:\n                res.append(\".\".join(path))\n                return\n            # 已超過四段或已到字串結尾但未完成\n            if len(path) >= 4 or start == len(s):\n                return\n\n            # 嘗試 1~3 位長的片段\n            for length in range(1, 4):\n                if start + length > len(s):\n                    break\n                part = s[start:start + length]\n                # 前導零不允許且值不能超過 255\n                if (len(part) > 1 and part[0] == '0') or int(part) > 255:\n                    continue\n                backtrack(start + length, path + [part])\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入，處理可能的變數賦值格式\n    data = sys.stdin.read().strip()\n    if '=' in data:\n        # 取等號右側的字串\n        part = data.split('=', 1)[1].strip()\n    else:\n        part = data\n\n    # 若字串被雙引號包住，去除引號\n    if part.startswith('\"') and part.endswith('\"'):\n        s = part[1:-1]\n    else:\n        s = part\n\n    solution = Solution()\n    result = solution.restoreIpAddresses(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"25525511135\"",
          "expected_output": "[\"255.255.11.135\",\"255.255.111.35\"]",
          "success": true,
          "output": "['255.255.11.135', '255.255.111.35']"
        },
        {
          "example_index": 1,
          "input": "s = \"0000\"",
          "expected_output": "[\"0.0.0.0\"]",
          "success": true,
          "output": "['0.0.0.0']"
        },
        {
          "example_index": 2,
          "input": "s = \"101023\"",
          "expected_output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]",
          "success": true,
          "output": "['1.0.10.23', '1.0.102.3', '10.1.0.23', '10.10.2.3', '101.0.2.3']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode393.json",
    "problem_index_in_file": 0,
    "title": "UTF-8 Validation",
    "description_snippet": "Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Virtual code: use Start, End, Decision. Steps: iterate array index. Determine first byte, count leading 1 bits to find length. Validate that enough remaining bytes exist. Validate continuation bytes start with '10'. Edge cases: leading 0 -> 1-byte char. For length >1, ensure first byte pattern matches. Need to count leading ones; if 1 or >4 -> invalid. Then for each continuation byte check top two bits. Return boolean. Virtual code can use variables: i = 0; n = data.length; valid = true.\n\nWe'll produce stepwise:\n\nStart\n→ Initialize i=0\n→ Initialize n=length\n→ Decision: i < n? // iterate\n    Yes →\n        → Step: firstByte = data[i] & 0xFF // get byte\n        → Decision: firstByte & 0x80? // first bit 1?\n            No → // 1-byte char\n                → Step: i = i + 1 // skip this byte\n            Yes →\n                → Step: countLeadingOnes = count leading 1s in firstByte\n                → Decision: countLeadingOnes == 1 or >4? // invalid start\n                    Yes → Step: valid = false; break\n                    No →\n                        → Decision: i + countLeadingOnes <= n? // enough bytes\n                            Yes →\n                                → For j from 1 to countLeadingOnes-1:\n                                    → Decision: data[i+j] & 0xC0 == 0x80? // continuation\n                                        Yes → continue\n                                        No → valid = false; break\n                                → Step: i = i + countLeadingOnes\n                            No → Step: valid = false; break\n    No →\n→ Step: return valid\nEnd\n\nNeed to include virtual code arrows and explanations. Use arrow \"→\" for each step, indentation for nested decisions. Provide explanation after //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ i = 0 // 初始化索引，從第一個字節開始\n→ n = data.length // 取得輸入字節數\n→ Decision: i < n? // 是否還有字節未處理？\n    Yes →\n        → firstByte = data[i] & 0xFF // 取得當前字節的有效 8 位\n        → Decision: (firstByte & 0x80) == 0? // 第一位是否為 0？\n            No →\n                → countLeadingOnes = count 1-bits at start of firstByte // 取得連續 1 的個數，決定字節長度\n                → Decision: countLeadingOnes == 1 OR countLeadingOnes > 4? // 開頭 1 的個數只能是 2-4\n                    Yes →\n                        → valid = false // 無效的 UTF‑8 開頭\n                        → Break // 跳出迴圈，直接返回\n                    No →\n                        → Decision: i + countLeadingOnes <= n? // 後續是否有足夠字節？\n                            Yes →\n                                → For j = 1 to countLeadingOnes-1:\n                                    → Decision: (data[i+j] & 0xC0) == 0x80? // 每個續字節必須以 10 開頭\n                                        Yes → // 續字節合法，繼續判斷下一個\n                                        No  → // 續字節不合法\n                                            → valid = false\n                                            → Break // 跳出外層循環\n                                → i = i + countLeadingOnes // 跳過整個多字節字符\n                            No  →\n                                → valid = false // 字節不足\n                                → Break\n            Yes →\n                → i = i + 1 // 1 字節字符，直接移到下一個字節\n    No →\n→ Step: return valid // 返回整個字串是否為合法 UTF‑8\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def validUtf8(self, data):\n        n_bytes = 0\n        for num in data:\n            b = num & 0xFF  # only the lowest 8 bits matter\n            if n_bytes == 0:\n                # count leading 1 bits to determine length\n                mask = 0x80\n                while mask & b:\n                    n_bytes += 1\n                    mask >>= 1\n                if n_bytes == 0:\n                    continue  # 1‑byte character\n                if n_bytes == 1 or n_bytes > 4:\n                    return False\n                n_bytes -= 1  # expect (n_bytes) more continuation bytes\n            else:\n                # continuation byte must start with bits 10\n                if (b & 0xC0) != 0x80:\n                    return False\n                n_bytes -= 1\n        return n_bytes == 0\n\ndef main():\n    text = sys.stdin.read()\n    if not text:\n        return\n\n    # Extract list from input, e.g., \"data = [197,130,1]\"\n    start = text.find('[')\n    end = text.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        try:\n            data = ast.literal_eval(text.strip())\n        except Exception:\n            data = []\n    else:\n        try:\n            data = ast.literal_eval(text[start:end+1])\n        except Exception:\n            data = []\n\n    sol = Solution()\n    result = sol.validUtf8(data)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "data = [197,130,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "data = [235,140,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode475.json",
    "problem_index_in_file": 0,
    "title": "Heaters",
    "description_snippet": "Winter is coming! During the contest, your first job is to design a standard heater with a fixed war...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: given arrays houses, heaters positions on horizontal line, find minimal radius r such that each house has a heater within r. Standard solution: sort heaters, for each house find nearest heater via binary search, compute distance, track maximum. Or use two pointers: sort houses, heaters, then for each house, maintain nearest heater. Provide virtual code lines with comments.\n\nLet's produce steps: Start, sort houses, sort heaters, initialize max_radius=0, pointer h=0. For each house in houses: while h+1 < len(heaters) and abs(heaters[h+1] - house) <= abs(heaters[h] - house): h++ (move to closer heater). Compute distance = abs(heaters[h] - house). Update max_radius = max(max_radius, distance). End. Return max_radius.\n\nAlternatively use binary search per house. We'll choose two-pointer approach as simpler.\n\nNeed virtual code lines each step. Use arrow notation: \"→ Step X: ...\".\n\nMake sure to include decision steps.\n\nLet's produce.\n\nAlso we must mention sorting.\n\nEdge cases: none.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort houses array ascending // 方便逐一檢查房屋  \n→ Step 2: Sort heaters array ascending // 方便使用雙指標尋找最近加熱器  \n→ Step 3: max_radius ← 0 // 儲存目前需要的最大暖氣半徑  \n→ Step 4: heater_index ← 0 // 現在考慮的最近加熱器索引  \n→ Step 5: For each house in houses: // 逐一處理每棟房子  \n  → Decision: 是否有下一個加熱器且下一個更靠近房子? // 用來決定是否往右移動指標  \n   Yes → While heater_index + 1 < len(heaters) AND abs(heaters[heater_index + 1] - house) ≤ abs(heaters[heater_index] - house):  \n      heater_index ← heater_index + 1 // 移動到更靠近房子的加熱器  \n   No → // 沒有更靠近的加熱器，保持現有指標  \n  → distance ← abs(heaters[heater_index] - house) // 計算此房子到最近加熱器的距離  \n  → Decision: distance > max_radius? // 判斷是否需要擴大半徑  \n   Yes → max_radius ← distance // 更新最大半徑  \n   No → // 目前最大半徑已足夠，無需變更  \n→ End // 所有房子處理完畢  \n→ Step 6: Return max_radius // 最小的統一暖氣半徑即可覆蓋所有房子  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findRadius(self, houses, heaters):\n        # 排序房屋與加熱器位置，方便後續搜尋\n        houses.sort()\n        heaters.sort()\n\n        max_radius = 0          # 目前需要的最大暖氣半徑\n        h_idx = 0               # 指向最靠近的右邊加熱器\n\n        for house in houses:\n            # 若右側下一個加熱器更靠近該房子，則向右移動指標\n            while (\n                h_idx + 1 < len(heaters) and\n                abs(heaters[h_idx + 1] - house) <= abs(heaters[h_idx] - house)\n            ):\n                h_idx += 1\n\n            # 這個房子距離最近加熱器的距離\n            distance = abs(heaters[h_idx] - house)\n            # 更新最大半徑\n            if distance > max_radius:\n                max_radius = distance\n\n        return max_radius\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入資料\n    raw_input = sys.stdin.read().strip()\n\n    # 取得所有出現在方括號中的列表字串\n    lists = re.findall(r'\\[.*?\\]', raw_input)\n    if len(lists) >= 2:\n        houses = ast.literal_eval(lists[0])\n        heaters = ast.literal_eval(lists[1])\n    else:\n        houses, heaters = [], []\n\n    sol = Solution()\n    result = sol.findRadius(houses, heaters)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "houses = [1,2,3], heaters = [2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "houses = [1,2,3,4], heaters = [1,4]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "houses = [1,5], heaters = [2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode591.json",
    "problem_index_in_file": 0,
    "title": "Tag Validator",
    "description_snippet": "Given a string representing a code snippet, implement a tag validator to parse the code and return w...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line-by-line with explanations, following the format. Should implement tag validator. No actual code, just virtual code steps.\n\nWe need to consider reading string, parsing tags, stack for nested tags, validate tag names, handle CDATA. Steps: initialize index, stack, parse until end. Use loop while index < len. When encountering '<', determine if it starts CDATA or tag. For CDATA, find ']]>' end, skip. For tag: detect if start or end. Validate tag name: all uppercase, length 1-9. For start: push onto stack, parse content until corresponding end tag found. For end: pop and compare. After full parse, stack should be empty and first tag must be closed. Also ensure no stray unmatched < or >.\n\nNeed to also ensure that code is wrapped in a valid closed tag: meaning entire string must be exactly one closed tag? Actually rule 1 says code must be wrapped in a valid closed tag. So outermost must be a single closed tag covering entire string. So we can check that after parsing, index == len and stack empty and we had started with a start tag and matched it. Also need to ensure that the outermost start tag has corresponding end tag at end.\n\nWe'll produce pseudocode:\n\nStart\n→ Step 1: 初始化索引 i = 0, 空堆栈 stack, flag valid = True\n→ Decision: i < len? // 开始解析\n    Yes → …\nWe will use loop and decisions.\n\nBetter: Use a while loop.\n\nUse pseudocode with arrow lines.\n\nWe'll produce step-by-step.\n\nLet's produce as many lines as needed.\n\nRemember to include explanations after each line.\n\nLet's draft.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: i ← 0, stack ← empty, valid ← True // 初始化索引、堆疊與合法性旗標\n→ Step 2: 讀取整段程式碼為 string // 從使用者取得要驗證的字串\n→ Decision: i < length(string) ? // 仍有未解析字元？\n    Yes → → Step 3: 如果 string[i] == '<' ? // 可能是標籤或 CDATA\n        Yes → → Decision: string[i+1] == '!' ? // CDATA 開頭？\n            Yes → → Step 4: 尋找 <![CDATA[ 的結束位置 ']]>'，設定 j = index_of(']]>') \n                    // CDATA 內容不做解析，直接跳過\n                No  → → Decision: string[i+1] == '/' ? // 結束標籤？\n                    Yes → → Step 5: 解析標籤名：name ← substring(i+2, index_of('>')-1) \n                            // 取結束標籤的名稱\n                        No  → → Step 6: 解析開始標籤名：name ← substring(i+1, index_of('>')-1) \n                            // 取開始標籤的名稱\n            // 之後處理開始或結束標籤\n            No  → → Step 7: i ← i + 1 // 非 '<'，跳過單一字元\n    No  → → Step 8: // 循環結束，所有字元已處理\n→ Decision: stack is empty AND valid = True AND string[0] == '<' AND string[length-1] == '>' ?\n    Yes → → Step 9: 輸出 'Valid' // 內容合法且完全包覆在一個閉標籤中\n    No  → → Step 10: 輸出 'Invalid' // 內容不合法或未正確包覆\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\n\nclass Solution:\n    def isValid(self, code: str) -> bool:\n        stack = []\n        i = 0\n        n = len(code)\n\n        while i < n:\n            # 必須在外層標籤內，否則不合法\n            if i > 0 and not stack:\n                return False\n\n            # CDATA 區塊\n            if code.startswith(\"<![CDATA[\", i):\n                j = i + 9\n                k = code.find(\"]]>\", j)\n                if k == -1:\n                    return False\n                i = k + 3\n                continue\n\n            # 結束標籤\n            if code.startswith(\"</\", i):\n                j = i + 2\n                k = code.find(\">\", j)\n                if k == -1:\n                    return False\n                tag_name = code[j:k]\n                if not stack or stack[-1] != tag_name:\n                    return False\n                stack.pop()\n                i = k + 1\n                continue\n\n            # 開始標籤\n            if code[i] == \"<\":\n                j = i + 1\n                k = code.find(\">\", j)\n                if k == -1 or k == j or k - j > 9:\n                    return False\n                tag_name = code[j:k]\n                if not tag_name.isupper() or not tag_name.isalpha():\n                    return False\n                stack.append(tag_name)\n                i = k + 1\n                continue\n\n            # 普通文字\n            i += 1\n\n        # 完成後堆疊必須空且完整包覆在一個標籤內\n        return not stack and code.startswith(\"<\") and code.endswith(\">\")\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    # 解析 input 可能為形如 code = \"<TAG>...</TAG>\"\n    if '=' in raw_input:\n        _, value = raw_input.split('=', 1)\n    else:\n        value = raw_input\n    value = value.strip()\n    # 去除兩端的單引號或雙引號\n    if (value.startswith('\"') and value.endswith('\"')) or (value.startswith(\"'\") and value.endswith(\"'\")):\n        value = value[1:-1]\n    sol = Solution()\n    result = sol.isValid(value)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "code = \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "code = \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "code = \"<A>  <B> </A>   </B>\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode679.json",
    "problem_index_in_file": 0,
    "title": "24 Game",
    "description_snippet": "You are given an integer array cards of length 4. You have four cards, each containing a number in t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the 24 game. Must output each line with arrow, Start/End, etc. Need to include decision nodes etc. Should reflect algorithm: generate all permutations, all operation combinations, all binary tree structures, evaluate with real division, check epsilon. Virtual code steps.\n\nLet's produce a flow: Start -> Input cards array -> Permute cards -> For each perm -> For each operator combo (4^3) -> For each tree structure (5 structures) -> Build expression tree -> Evaluate recursively -> If result close to 24 return true -> End -> return false.\n\nWe'll output steps accordingly. Use \"→\" for steps. Use \"Decision:\" nodes for conditions.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: cards[4] // 取得長度為 4 的整數陣列  \n→ Decision: cards 是否含 4 個元素? // 確認輸入合法  \n  Yes → Proceed  \n  No → End // 非法輸入，結束  \n\n→ Step 1: 產生所有卡牌排列組合 // 4! 種排列  \n  → For each permutation P of cards  \n    → Step 2: 產生所有 3 個運算子組合 // 每個位置 4 種，總共 4^3 = 64  \n      → For each operator set O = (op1, op2, op3)  \n        → Step 3: 產生所有 5 個二元樹結構 // 選擇不同括號位置  \n          → For each tree T  \n            → Step 4: 建立表達式樹並評估 // 遞迴計算  \n               → Function Evaluate(node)  \n                 If node 是數字 → 回傳數字  \n                 Else → 取左右子樹值 a, b  \n                   → 依 node.operator 計算 a op b  \n                   → 回傳結果  \n                   (使用實數除法，避免除以零)  \n             → Decision: Evaluate(T) ≈ 24? // 與 24 的誤差 < 1e-6  \n               Yes → Return True // 找到合法表達式  \n               No → Continue  \n             → End of current tree T  \n            → End of operator set O  \n       → End of permutation P  \n→ Decision: 已遍歷完所有可能，仍無符合?  \n  Yes → Return False // 無合法表達式  \n  No →（理論上不會到此）  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport itertools\nimport operator\nimport re\n\nclass Solution:\n    def judgePoint24(self, nums):\n        \"\"\"\n        判斷是否能用給定四個數字與 + - * / 以及括號得到 24。\n        使用遞迴 DFS，對所有數字順序與運算子組合進行嘗試。\n        \"\"\"\n        EPS = 1e-6  # 允許的誤差範圍\n\n        def dfs(values):\n            # 如果只剩一個數字，檢查是否等於 24\n            if len(values) == 1:\n                return abs(values[0] - 24) < EPS\n\n            n = len(values)\n            # 選擇兩個數字進行運算\n            for i in range(n):\n                for j in range(n):\n                    if i == j:\n                        continue\n                    a, b = values[i], values[j]\n                    # 準備下一輪數字列表，移除 i、j\n                    remaining = [values[k] for k in range(n) if k != i and k != j]\n                    # 四種運算\n                    ops = [\n                        (operator.add, a + b),\n                        (operator.sub, a - b),\n                        (operator.mul, a * b),\n                        (operator.truediv, None)  # 先檢查除以零\n                    ]\n                    for op_func, result in ops:\n                        if op_func == operator.truediv:\n                            if abs(b) < EPS:\n                                continue\n                            result = a / b\n                        # 將運算結果加入剩餘列表，遞迴\n                        remaining.append(result)\n                        if dfs(remaining):\n                            return True\n                        remaining.pop()\n            return False\n\n        # 由於順序影響，先遍歷所有排列\n        for perm in itertools.permutations(nums):\n            if dfs(list(perm)):\n                return True\n        return False\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 提取所有整數，假設輸入包含四個 1~9 的數字\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    solution = Solution()\n    result = solution.judgePoint24(nums)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "cards = [4,1,8,7]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "cards = [1,2,1,2]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode557.json",
    "problem_index_in_file": 0,
    "title": "Reverse Words in a String III",
    "description_snippet": "Given a string s, reverse the order of characters in each word within a sentence while still preserv...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line for the task: reverse characters of each word in a string s, preserving whitespace and word order.\n\nWe need Start, End, Decision steps. It's like splitting string into words and reversing each word. But we should preserve whitespace and word order: So iterate through string char by char, build word buffer, when encounter space, flush reversed word to output and append space. For continuous spaces maintain them.\n\nSo the pseudocode:\n\nStart\n→ Step 1: Initialize output as empty string, wordBuffer as empty string\n→ Step 2: For each character ch in input string s\n    → Decision: If ch is whitespace? // check if space or tab\n        Yes → Step 3: Append reversed(wordBuffer) to output\n             → Step 4: Append ch to output\n             → Step 5: Clear wordBuffer\n        No  → Step 6: Append ch to wordBuffer // accumulate character in current word\n→ Step 7: After loop, append reversed(wordBuffer) to output // handle last word\n→ End // return output\n\nNeed explanation after each line.\n\nWe must not output actual code, just virtual code. Use arrow →, Decision:, Start, End. Each line: `虛擬碼步驟 // 解釋`. Also must be one line per step. Should we break into multiple lines for nested? Use indentation maybe.\n\nThe sample format uses \"→ Decision:\" and indent Yes →. So we must follow that.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: Initialize output = \"\" and wordBuffer = \"\" // 設定輸出字串與暫存詞\n→ Step 2: For each character ch in s // 逐字元處理輸入字串\n    → Decision: 如果 ch 為空白字元? // 判斷是否遇到空白\n        Yes → Step 3: output += reverse(wordBuffer) // 把前一個詞反轉並加入輸出\n        Yes → Step 4: output += ch // 加入空白字元\n        Yes → Step 5: wordBuffer = \"\" // 清空詞緩衝\n        No  → Step 6: wordBuffer += ch // 把字元加入詞緩衝\n→ Step 7: output += reverse(wordBuffer) // 處理最後一個詞\n→ End // 程式執行結束\n\nBut we must include arrow indentation after Decision. They used \"Yes →\" and \"No →\" lines. So need to include \"Yes →\" etc. Indentation can be shown via spaces.\n\nThus final output lines. Ensure no extra code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 output = \"\" 以及 wordBuffer = \"\" // 設定輸出字串與暫存詞  \n→ Step 2: 針對輸入字串 s 中的每一個字元 ch 執行循環 // 逐字元處理  \n    → Decision: ch 是否為空白字元? // 判斷是否遇到空白  \n        Yes → Step 3: output += reverse(wordBuffer) // 把前一個詞反轉後加入輸出  \n        Yes → Step 4: output += ch // 加入空白字元本身  \n        Yes → Step 5: wordBuffer = \"\" // 清空詞緩衝以備下一個詞  \n        No  → Step 6: wordBuffer += ch // 把字元加入目前詞的緩衝  \n→ Step 7: output += reverse(wordBuffer) // 處理最後一個詞（若有）  \n→ End // 程式執行結束並回傳 output",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        \"\"\"Reverse each word in the string while preserving whitespace.\"\"\"\n        result = []\n        word = []\n        for ch in s:\n            if ch.isspace():\n                # flush reversed word\n                result.append(''.join(reversed(word)))\n                result.append(ch)\n                word = []\n            else:\n                word.append(ch)\n        # flush the last word\n        result.append(''.join(reversed(word)))\n        return ''.join(result)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Assume input format: s = \"some string\"\n    parts = data.split('=', 1)\n    if len(parts) != 2:\n        # If input is just a raw string, use it directly\n        s_raw = data\n    else:\n        s_raw = parts[1].strip()\n    # Safely parse the string literal (handles escapes)\n    try:\n        s = ast.literal_eval(s_raw)\n    except Exception:\n        # Fallback: treat raw input as string\n        s = s_raw\n    sol = Solution()\n    reversed_s = sol.reverseWords(s)\n    # Output surrounded by double quotes, as shown in the examples\n    print(f'\"{reversed_s}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Let's take LeetCode contest\"",
          "expected_output": "\"s'teL ekat edoCteeL tsetnoc\"",
          "success": true,
          "output": "\"s'teL ekat edoCteeL tsetnoc\""
        },
        {
          "example_index": 1,
          "input": "s = \"Mr Ding\"",
          "expected_output": "\"rM gniD\"",
          "success": true,
          "output": "\"rM gniD\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode491.json",
    "problem_index_in_file": 0,
    "title": "Non-decreasing Subsequences",
    "description_snippet": "Given an integer array nums, return all the different possible non-decreasing subsequences of the gi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: find all distinct non-decreasing subsequences of length at least 2 from an array. The algorithm typically uses DFS/backtracking, with set to avoid duplicates. Use recursion, keep current subsequence, start index, etc. We'll produce step-by-step pseudo code with arrows and explanations. Provide each line: \"Start\" etc. Ensure each line includes the step and comment. Use decision arrows Yes/No.\n\nWe must not output actual code. Just virtual steps.\n\nOk produce:\n\nStart\n→ Step 1: Initialize result set to store unique subsequences\n→ Step 2: Define recursive function DFS(current index, current subsequence)\n→ Decision: If current subsequence length >= 2 → add to result set\n→ Step 3: For each next index from current index+1 to end of nums:\n→ Decision: If current subsequence is empty OR nums[next] >= last element in subsequence? -> to maintain non-decreasing\n→ Yes → Append nums[next] to subsequence → Call DFS(next, subsequence)\n→ Backtrack: remove last element\n→ End For\n→ End Recursive function\n→ Step 4: Call DFS(-1, empty)\n→ Step 5: Convert result set to list of lists and return\n\nWe need to use arrow formatting:\n\nStart // ...\n→ Step 1: ...\n\nAlso decisions use indentation. Use \"Decision: ...\" and \"Yes → ...\" \"No → ...\" etc.\n\nLet's craft each line accordingly.\n\nAlso we must include explanation after \"//\".\n\nMake sure no actual code.\n\nLet's write:\n\nStart // 程式開始執行\n\n→ Step 1: 建立一個空集合 result 用來存放不重複的非遞減子序列 // 以集合避免重複\n\n→ Step 2: 定義遞迴函式 DFS(currentIndex, path) // currentIndex 為上一次選取元素的索引，path 為目前已構成的子序列\n\n→ Decision: path 長度是否 ≥ 2? // 判斷是否已達到至少兩個元素\n\n    Yes → Step 3: 將 path 加入 result 集合 // 存入已完成的子序列\n\n    No → // 仍需嘗試擴展\n\n→ Step 4: 迴圈 i 從 currentIndex+1 到 nums.length-1 // 依序嘗試下一個元素\n\n→ Decision: path 為空 或 nums[i] ≥ path 最後一個元素? // 檢查是否能維持非遞減\n\n    Yes → Step 5: 將 nums[i] 加到 path // 追加元素\n\n    → Call DFS(i, path) // 進一步擴展\n\n    → Step 6: 移除 path 最後一個元素 // 回溯\n\n    No → // 跳過不合法的元素\n\n→ End // 完成遞迴\n\n→ Step 7: 呼叫 DFS(-1, 空列表) // 從陣列前方開始搜尋\n\n→ Step 8: 將 result 集合轉成列表並回傳 // 形成最終答案\n\nEnd // 程式執行結束\n\nWe must ensure each line ends with comment. Indent decisions.\n\nAlso we must ensure \"→\" arrow preceding each step.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空集合 result 用來存放不重複的非遞減子序列 // 以集合避免重複  \n→ Step 2: 定義遞迴函式 DFS(currentIndex, path) // currentIndex 為上一次選取元素的索引，path 為目前已構成的子序列  \n→ Decision: path 長度是否 ≥ 2? // 判斷是否已達到至少兩個元素  \n Yes → Step 3: 將 path 加入 result 集合 // 存入已完成的子序列  \n No → // 仍需嘗試擴展  \n→ Step 4: 迴圈 i 從 currentIndex+1 到 nums.length-1 // 依序嘗試下一個元素  \n→ Decision: path 為空 或 nums[i] ≥ path 最後一個元素? // 檢查是否能維持非遞減  \n Yes → Step 5: 將 nums[i] 加到 path // 追加元素  \n  → Call DFS(i, path) // 進一步擴展  \n  → Step 6: 移除 path 最後一個元素 // 回溯  \n No → // 跳過不合法的元素  \n→ End // 完成遞迴  \n→ Step 7: 呼叫 DFS(-1, 空列表) // 從陣列前方開始搜尋  \n→ Step 8: 將 result 集合轉成列表並回傳 // 形成最終答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findSubsequences(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            if len(path) > 1:\n                res.append(path[:])\n            used = set()\n            for i in range(start, len(nums)):\n                if (not path or nums[i] >= path[-1]) and nums[i] not in used:\n                    used.add(nums[i])\n                    path.append(nums[i])\n                    backtrack(i + 1, path)\n                    path.pop()\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    if '=' in raw_input:\n        raw_input = raw_input.split('=', 1)[1].strip()\n    nums = ast.literal_eval(raw_input)\n\n    solution = Solution()\n    subseqs = solution.findSubsequences(nums)\n\n    # Format output exactly as requested (no spaces after commas)\n    output = '[' + ','.join('[' + ','.join(map(str, seq)) + ']' for seq in subseqs) + ']'\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,6,7,7]",
          "expected_output": "[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]",
          "success": true,
          "output": "[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]"
        },
        {
          "example_index": 1,
          "input": "nums = [4,4,3,2,1]",
          "expected_output": "[[4,4]]",
          "success": true,
          "output": "[[4,4]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode535.json",
    "problem_index_in_file": 0,
    "title": "Encode and Decode TinyURL",
    "description_snippet": "Note: This is a companion problem to the System Design problem: Design TinyURL.\nTinyURL is a URL sho...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for class Solution with encode/decode logic. Use mapping dictionary. Steps: initialize counter, base62 encode. Use small mapping. Provide pseudocode. Each line with comment. Use arrows.\n\nLet's write:\n\nStart\n→ Step 1: initialize data structures: map ID to URL, counter\n→ Step 2: encode(longUrl): if longUrl not in map? but we can just generate id = counter; increment counter; map[id]=longUrl; shortUrl = base + encodeBase62(id); return shortUrl\n→ Step 3: decode(shortUrl): extract code part; decodeBase62 to id; return map[id]\nNeed encodeBase62 function.\n\nAdd helper functions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化資料結構 // 建立 id→URL 的對應表與編碼計數器\n    → Variable: urlMap ← 空字典 // 存放 id 到長 URL 的映射\n    → Variable: counter ← 0 // 用於產生唯一 ID\n→ Step 2: encode(longUrl) // 將長網址編碼為短網址\n    → Decision: 如果 longUrl 已存在於 urlMap? // 可選：避免重複編碼相同 URL\n        Yes → Return 已存在的短網址 // 直接返回已生成的短網址\n        No  → \n            → Variable: id ← counter // 取得目前計數器值作為 ID\n            → counter ← counter + 1 // 進位計數器\n            → urlMap[id] ← longUrl // 存入映射\n            → Variable: code ← encodeBase62(id) // 將 ID 編碼為 Base62 代碼\n            → Variable: shortUrl ← \"http://tinyurl.com/\" + code // 組成完整短網址\n            → Return shortUrl // 傳回短網址\n→ Step 3: decode(shortUrl) // 將短網址還原為長網址\n    → Variable: code ← 提取短網址中 \"http://tinyurl.com/\" 之後的字串 // 取得編碼片段\n    → Variable: id ← decodeBase62(code) // 將 Base62 代碼轉回數字 ID\n    → Return urlMap[id] // 透過映射取得原始長 URL\n→ Helper: encodeBase62(num) // 將數字編碼為 Base62 文字\n    → 變數 baseChars ← \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    → 變數 result ← 空字串\n    → 循環: 當 num > 0 時\n        → result ← baseChars[num mod 62] + result // 取餘數對應字符並加至前面\n        → num ← num / 62 // 整除 62\n    → 如果 result 為空則 result ← \"0\" // 處理 0 的情況\n    → Return result\n→ Helper: decodeBase62(str) // 將 Base62 文字轉回數字\n    → 變數 baseChars ← \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    → 變數 num ← 0\n    → 循環: 對於 str 中的每個字符 c\n        → num ← num * 62 + baseChars.indexOf(c) // 累加權值\n    → Return num\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def __init__(self):\n        self.url_map = {}          # id -> longUrl\n        self.base_url = \"http://tinyurl.com/\"\n        self.counter = 0\n        self.base_chars = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n    def encode(self, longUrl: str) -> str:\n        # If the URL has already been encoded, return the existing short URL\n        for id_, url in self.url_map.items():\n            if url == longUrl:\n                return self.base_url + self.encodeBase62(id_)\n\n        # Generate a new id\n        id_ = self.counter\n        self.counter += 1\n        self.url_map[id_] = longUrl\n        return self.base_url + self.encodeBase62(id_)\n\n    def decode(self, shortUrl: str) -> str:\n        # Remove the base part to get the code\n        code = shortUrl.replace(self.base_url, \"\")\n        id_ = self.decodeBase62(code)\n        return self.url_map.get(id_, \"\")\n\n    # Helper: encode an integer to a Base62 string\n    def encodeBase62(self, num: int) -> str:\n        if num == 0:\n            return \"0\"\n        res = []\n        base = len(self.base_chars)\n        while num > 0:\n            num, rem = divmod(num, base)\n            res.append(self.base_chars[rem])\n        return \"\".join(reversed(res))\n\n    # Helper: decode a Base62 string to an integer\n    def decodeBase62(self, s: str) -> int:\n        base = len(self.base_chars)\n        num = 0\n        for ch in s:\n            num = num * base + self.base_chars.index(ch)\n        return num\n\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    # Remove surrounding quotes if present\n    if raw_input.startswith('\"') and raw_input.endswith('\"'):\n        raw_input = raw_input[1:-1]\n\n    # Create the solution object and perform encode/decode\n    solver = Solution()\n    short = solver.encode(raw_input)\n    original = solver.decode(short)\n\n    # Output the decoded URL\n    print(original)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"https://leetcode.com/problems/design-tinyurl\"",
          "expected_output": "\"https://leetcode.com/problems/design-tinyurl\"",
          "success": true,
          "output": "https://leetcode.com/problems/design-tinyurl"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode745.json",
    "problem_index_in_file": 0,
    "title": "Prefix and Suffix Search",
    "description_snippet": "Design a special dictionary that searches the words in it by a prefix and a suffix.\n\nImplement the W...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code for design of WordFilter class. Provide step-by-step pseudocode. Should cover initialization building structure, search. Likely use Trie for prefixes and suffixes or combine into combined key. Could do prefix-suffix trie like LeetCode problem 745. But virtual code: steps.\n\nWe produce lines like:\n\nStart // 程式開始\n→ Step 1: WordFilter(words) // 初始化\n\nBut need to design internal data structures. We'll provide algorithm.\n\nLet's produce pseudo-code:\n\nStart // 程式開始\n\n→ Step 1: WordFilter(words) // 建構物件\n    → Decision: words non-empty? Yes → proceed\n\nWithin constructor:\n    → Step 2: 初始化字典映射 indexMap = {} // mapping key to max index\n    → Step 3: For i in 0..len(words)-1:\n        → Step 4: word = words[i]\n        → Step 5: For pref_len from 0 to len(word):\n            → Step 6: pref = word[0:pref_len]\n            → Step 7: For suff_len from 0 to len(word):\n                → Step 8: suff = word[len(word)-suff_len:]\n                → Step 9: key = pref + \"#\" + suff\n                → Step 10: indexMap[key] = i // overwrite to keep max index\n\nThen f(pref,suff):\n    → Step 11: key = pref + \"#\" + suff\n    → Step 12: If key in indexMap:\n        → Step 13: Return indexMap[key]\n    → Step 14: Else:\n        → Step 15: Return -1\n\nBut that algorithm is O(N * L^2) memory heavy. But okay for demonstration.\n\nWe can also use combined Trie: store words reversed and forward in a combined key.\n\nBut provide pseudo-code of combined Trie:\n\nBuild a dictionary mapping prefix+suffix to index.\n\nWill produce lines accordingly.\n\nLet's produce each line with comments. Ensure using arrow \"→\".\n\nWe need to follow format: each line: 虛擬碼步驟 [space] // 解釋/說明\n\nAlso use Decision: structure.\n\nLet's start with Start.\n\nWe can break into sections: Start, WordFilter constructor, f method.\n\nAdd End.\n\nMake sure lines start with \"Start\", \"→\" etc.\n\nWe'll include decision steps where needed.\n\nLet's craft.\n\nAlso we might include class definition.\n\nWe'll produce pseudo-code lines:\n\nStart // 程式開始\n\n→ Step 1: WordFilter(words) // 初始化 WordFilter 物件\n    → Step 2: this.indexMap = {} // 建立字典存放 (prefix#suffix) → index\n    → Step 3: For i in 0 to words.length-1:\n        → Step 4: word = words[i] // 取得第 i 個單字\n        → Step 5: pref = \"\" // 初始化前綴\n        → Step 6: For p in 0 to word.length:\n            → Step 7: pref = word.substring(0,p) // 產生所有前綴\n            → Step 8: suff = \"\" // 初始化後綴\n            → Step 9: For s in 0 to word.length:\n                → Step 10: suff = word.substring(word.length-s) // 產生所有後綴\n                → Step 11: key = pref + \"#\" + suff // 組合鍵\n                → Step 12: indexMap[key] = i // 以 i 為索引更新映射（覆蓋保證最大 index）\n    // 結束建構\n\n→ Method f(pref,suff):\n    → Step 13: key = pref + \"#\" + suff\n    → Step 14: If key in this.indexMap:\n        → Step 15: Return this.indexMap[key] // 找到對應索引\n        → Step 16: Else:\n        → Step 17: Return -1 // 無匹配\n\nEnd // 程式結束\n\nBut need to incorporate Decision structure: e.g., Decision: key in indexMap?\n\nYes → Return\n\nNo → Return -1\n\nAlso may include Decision for loops but it's okay.\n\nLet's format accordingly.\n\nWe need to maintain \"虛擬碼步驟\" with arrow.\n\nEach line: \"Start // ...\"\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始\n→ Step 1: WordFilter(words) // 初始化 WordFilter 物件\n    → Step 2: this.indexMap = {} // 建立鍵值對字典 (prefix#suffix) → 最大索引\n    → Step 3: For i = 0 to words.length-1 // 逐個處理單字\n        → Step 4: word = words[i] // 取得第 i 個單字\n        → Step 5: pref = \"\" // 初始化前綴字串\n        → Step 6: For p = 0 to word.length // 產生所有前綴\n            → Step 7: pref = word.substring(0, p) // 前綴為字首到第 p 個字元\n            → Step 8: suff = \"\" // 初始化後綴字串\n            → Step 9: For s = 0 to word.length // 產生所有後綴\n                → Step 10: suff = word.substring(word.length - s) // 後綴為最後 s 個字元\n                → Step 11: key = pref + \"#\" + suff // 組合鍵：前綴#後綴\n                → Step 12: this.indexMap[key] = i // 以當前索引覆蓋，確保存儲最大索引\n    // 產生完所有鍵後結束建構\n→ Method f(pref, suff) // 查詢前綴與後綴的最大索引\n    → Step 13: key = pref + \"#\" + suff // 組合查詢鍵\n    → Decision: key exists in this.indexMap? // 判斷鍵是否存在\n        Yes → Step 14: Return this.indexMap[key] // 有對應，回傳最大索引\n        No  → Step 15: Return -1 // 無符合字詞，回傳 -1\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    def __init__(self, words):\n        # 建立 (prefix, suffix) → 最大索引 的字典\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):          # 前綴長度\n                for j in range(L + 1):      # 後綴長度\n                    key = (word[:i], word[j:])\n                    self.lookup[key] = weight  # 以後面的索引覆蓋，保證最大索引\n\n    def f(self, prefix, suffix):\n        # 直接查詢字典，若不存在則回傳 -1\n        return self.lookup.get((prefix, suffix), -1)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，假設格式為: 兩個 JSON 陣列以逗號分隔\n    # 例: '[[\"apple\"]], [\"a\", \"e\"]'\n    # 找到第一個 '],' 作為分隔點\n    split_index = data.find('],')\n    if split_index == -1:\n        # 如果沒有逗號分隔，直接嘗試解析整個內容為兩個項目\n        parts = [data]\n    else:\n        parts = [\n            data[:split_index + 1],          # 加上結束的 ]\n            data[split_index + 2:].strip()   # 後面部分\n        ]\n\n    # 使用 ast.literal_eval 以安全方式解析\n    words = ast.literal_eval(parts[0])\n    pref_suff = ast.literal_eval(parts[1]) if len(parts) > 1 else []\n    if len(pref_suff) != 2:\n        # 如果只有一個字串，視為前綴，後綴為空字串\n        prefix = pref_suff[0] if pref_suff else \"\"\n        suffix = \"\"\n    else:\n        prefix, suffix = pref_suff\n\n    wf = WordFilter(words)\n    result = wf.f(prefix, suffix)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmptdvl9vyn.py\", line 52, in <module>\n    main()\n  File \"/tmp/tmptdvl9vyn.py\", line 47, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptdvl9vyn.py\", line 13, in __init__\n    self.lookup[key] = weight  # 以後面的索引覆蓋，保證最大索引\n    ~~~~~~~~~~~^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode409.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindrome",
    "description_snippet": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with explanation. The problem: longest palindrome length from given string s with case-sensitive letters. Standard solution: count frequency of each char. Sum even counts, for odd counts add odd-1 each. If any odd, add 1. Output length. So algorithm steps: start, input string, create map, iterate characters to count, then compute length, output. Provide step-by-step.\n\nNeed to use arrow format: Start, → Step, → Decision, Yes →, No →, End. Provide explanation after space. No actual code. Just virtual steps.\n\nWe must produce each line as \"虛擬碼步驟 // 解釋\". For decision, indent with four spaces maybe? Example shows indentation: \"Decision: ... // ...\\n    Yes → Step...\".\n\nWe must follow same format. Provide steps:\n\nStart\n→ Step 1: 取得輸入字串 s // 取得要分析的字串\n→ Step 2: 建立空字典 freq // 用於存每個字元出現次數\n→ Decision: 迴圈遍歷 s? // 檢查是否還有字元未處理\n    Yes → Step 3: 將當前字元 c 的計數加 1 // 更新字典\n    No  → Decision: 計算最大長度? // 所有字元已統計完畢\n        Yes → Step 4: 初始化 result = 0 // 用於累加長度\n        No  → Step 5: For each count in freq.values() // 逐個字元計算\n        Step 6: If count is even? // 判斷是否偶數\n            Yes → Step 7: result += count // 偶數全部使用\n            No  → Step 8: result += count - 1 // 奇數只能用偶數部分\n        Step 9: If any count was odd? // 檢查是否存在奇數\n            Yes → Step 10: result += 1 // 允許一個中心字元\n            No  → Step 11: // 無須加\n        End? // 計算結束\n        Yes → Step 12: 輸出 result // 回傳最大回文長度\nEnd // 程式結束\n\nBut we need decision arrows properly. Let's mimic example. Use indentation 4 spaces for nested. Ensure each line contains virtual step and comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者或測試資料取得待分析字串  \n→ Step 2: 建立空字典 freq // 用來統計每個字元出現的頻次  \n→ Decision: 迴圈遍歷 s? // 檢查是否還有字元未處理  \n  Yes → Step 3: 將當前字元 c 的計數加 1 // 更新 freq[c]  \n  No  → Decision: 所有字元已處理完? // 進入計算階段  \n   Yes → Step 4: 初始化 result = 0 // 用於累加可用字元數  \n   No  → Step 5: 針對 freq.values() 逐一檢查  \n    Decision: count 為偶數? // 判斷能否全部使用  \n     Yes → Step 6: result += count // 偶數字元全數可用  \n     No  → Step 7: result += count - 1 // 奇數字元只能用偶數部分  \n    Decision: 有奇數字元? // 檢查是否能放入中心字元  \n     Yes → Step 8: result += 1 // 加入一個中心字元  \n     No  → Step 9: // 沒有奇數字元，不需額外處理  \n    End // 針對所有字元計算完成  \n   Yes → Step 10: 輸出 result // 回傳最大回文長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\ndef longest_palindrome_length(s: str) -> int:\n    \"\"\"Return the length of the longest palindrome that can be built from the characters of s.\"\"\"\n    count = Counter(s)\n    length = 0\n    odd_found = False\n    for freq in count.values():\n        if freq % 2 == 0:\n            length += freq\n        else:\n            length += freq - 1\n            odd_found = True\n    if odd_found:\n        length += 1\n    return length\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    Parse the raw input string to extract the actual string `s`.\n    Supports formats like:\n        abc\n        s = \"abc\"\n        s='abc'\n    \"\"\"\n    raw = raw.strip()\n    if '=' in raw:\n        # Take the part after the first '='\n        _, value = raw.split('=', 1)\n        value = value.strip()\n    else:\n        value = raw\n    # If value is quoted, strip quotes\n    if (value.startswith('\"') and value.endswith('\"')) or (value.startswith(\"'\") and value.endswith(\"'\")):\n        value = value[1:-1]\n    return value\n\nif __name__ == \"__main__\":\n    # Read entire stdin (handles single line or multiple lines)\n    raw_input = sys.stdin.read()\n    # In case of multiple lines, join them\n    raw_input = ' '.join(line.strip() for line in raw_input.splitlines())\n    s = parse_input(raw_input)\n    result = longest_palindrome_length(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abccccdd\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode502.json",
    "problem_index_in_file": 0,
    "title": "IPO",
    "description_snippet": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Cap...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps to solve LeetCode max capital problem. Steps: sort projects by capital, use min-heap for profits? Actually choose k projects with highest profits whose capital <= current capital. So algorithm: create list of (capital, profit), sort by capital asc. Use max-heap for profits. Iterate through projects adding to heap while capital <= current capital. For i in 1..k: if heap empty break; pop max profit; add to capital. Return capital. Need pseudocode with steps, decisions. Provide line by line with arrow. Use Start, End. Provide explanation. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 `currentCapital ← w`，`kLeft ← k` // 設定目前資本與剩餘可選專案數量  \n→ Step 2: 建立 `projects ← 列表 (capital[i], profit[i])` for i in 0..n-1 // 把每個專案的資本需求與純利潤打包  \n→ Step 3: 將 `projects` 依 `capital` 升序排序 // 方便一次掃描可行專案  \n→ Step 4: 初始化 `profitHeap ← 最大堆` // 用來快速取得最高純利潤的專案  \n→ Step 5: 初始化 `idx ← 0` // 追蹤已掃描的專案索引  \n→ Decision: 是否已完成所有 k 個專案? // 檢查是否還有可選擇的專案  \n    No → Step 6: 將所有 `capital` ≤ `currentCapital` 的專案加入 `profitHeap`  \n        → Step 6a: While `idx < n` and `projects[idx].capital ≤ currentCapital`  \n        → Step 6a1: `profitHeap.insert(projects[idx].profit)` // 加入可行專案的純利潤  \n        → Step 6a2: `idx ← idx + 1` // 移動到下一個專案  \n    → Step 7: Decision: `profitHeap` 是否為空? // 判斷是否仍有可執行專案  \n        Yes → Break // 沒有可行專案，終止迴圈  \n        No → Step 8: 取得最高純利潤 `bestProfit ← profitHeap.extractMax()` // 選擇最有利的專案  \n        → Step 9: 更新 `currentCapital ← currentCapital + bestProfit` // 完成專案後加上利潤  \n        → Step 10: `kLeft ← kLeft - 1` // 減少剩餘可選擇的專案數  \n→ Decision: `kLeft` 是否已歸零?  \n    No → 回到 Decision: 是否已完成所有 k 個專案?  \n    Yes → End // 所有可選專案已選完或無法再選  \nEnd // 程式執行結束  \n→ Return `currentCapital` // 最終最大資本值",
      "generated_code": "import sys\nimport heapq\nimport re\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, W: int, Profits: list[int], Capital: list[int]) -> int:\n        # 將專案依資本需求排序\n        projects = sorted(zip(Capital, Profits))\n        max_heap = []          # 儲存可執行專案的純利潤（使用負值做最大堆）\n        i = 0\n        n = len(Profits)\n\n        for _ in range(k):\n            # 把所有目前可負擔的專案加入堆中\n            while i < n and projects[i][0] <= W:\n                heapq.heappush(max_heap, -projects[i][1])\n                i += 1\n            # 若無可執行專案則結束\n            if not max_heap:\n                break\n            # 取出最有利的專案完成\n            W += -heapq.heappop(max_heap)\n\n        return W\n\ndef main():\n    data = sys.stdin.read()\n    # 取出所有整數（包含負號），並轉成整數列表\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        print(0)\n        return\n\n    k, w = nums[0], nums[1]\n    rest = nums[2:]\n    n = len(rest) // 2\n    profits = rest[:n]\n    capital = rest[n:]\n\n    sol = Solution()\n    result = sol.findMaximizedCapital(k, w, profits, capital)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode242.json",
    "problem_index_in_file": 0,
    "title": "Valid Anagram",
    "description_snippet": "Given two strings s and t, return true if t is an anagram of s, and false otherwise....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with arrows and explanations. For anagram detection. Steps: start, check lengths, create frequency dicts, count characters, compare, end. Use Decision blocks. Provide explanations after //.\n\nEnsure no real code. Use virtual arrows.\n\nLet's produce steps:\n\nStart\n→ Decision: If len(s) != len(t)? // length mismatch => not anagram\n   No → Step 1: 初始化字典 count_s // create dict for s\n   No → Step 2: 统计 s 中每个字符的出现次数 // fill count_s\n   No → Step 3: 初始化字典 count_t // create dict for t\n   No → Step 4: 统计 t 中每个字符的出现次数 // fill count_t\n   No → Decision: count_s == count_t? // compare dictionaries\n        Yes → Step 5: 返回 true // anagram\n        No  → Step 6: 返回 false // not anagram\nYes → Step 7: 返回 false // length mismatch\n\nEnd\n\nLet's format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: s 與 t 長度是否相等? // 先檢查字串長度是否相同  \n  Yes → Step 1: 回傳 false // 長度不相等，直接返回 false  \n  No  → Step 2: 建立空字典 count_s // 為 s 建立頻率字典  \n  No  → Step 3: 逐字元累加 count_s[字元] // 計算 s 中每個字元的出現次數  \n  No  → Step 4: 建立空字典 count_t // 為 t 建立頻率字典  \n  No  → Step 5: 逐字元累加 count_t[字元] // 計算 t 中每個字元的出現次數  \n  No  → Decision: count_s 是否等於 count_t? // 比較兩個字典是否完全相同  \n    Yes → Step 6: 回傳 true // 字典相同，t 為 s 的字母重排  \n    No  → Step 7: 回傳 false // 字典不同，t 不是字母重排  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        # 使用 Counter 直接比較兩個字串的字元頻率\n        return Counter(s) == Counter(t)\n\ndef main() -> None:\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n\n    # 嘗試從字串中提取兩個被雙引號包裹的字串\n    matches = re.findall(r'\"([^\"]*)\"', raw_input)\n    if len(matches) >= 2:\n        s, t = matches[0], matches[1]\n    else:\n        # 若沒有雙引號，則假設輸入是兩行或以空白分隔\n        parts = raw_input.strip().splitlines()\n        if len(parts) >= 2:\n            s, t = parts[0].strip(), parts[1].strip()\n        else:\n            # 無法解析輸入，直接返回 false\n            print('false')\n            return\n\n    # 呼叫解法並輸出結果\n    result = Solution().isAnagram(s, t)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"anagram\", t = \"nagaram\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"rat\", t = \"car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode301.json",
    "problem_index_in_file": 0,
    "title": "Remove Invalid Parentheses",
    "description_snippet": "Given a string s that contains parentheses and letters, remove the minimum number of invalid parenth...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm to generate all unique valid strings after removing min invalid parentheses. Likely BFS approach. Steps: Start, compute max removals by counting extra left and right. Then BFS search level by level generating states, maintain set visited. When find valid, add to result, stop exploring deeper levels. Check validity via stack count. Return results.\n\nWe must output step-by-step with arrows and comments. Use virtual code lines with \"Start\", \"→ Step...\", \"→ Decision: ...\" etc.\n\nWe'll produce maybe about 30 lines. Use arrows for nested decisions. Provide explanation after //.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 從使用者處取得需要處理的字串  \n→ Step 2: 計算 l_rem, r_rem 兩個整數，分別代表需要刪除的左括號 '(' 與右括號 ')' 的最大數量  \n    → Decision: 如果 s 中有多餘左括號? // 以遍歷計算 l_rem  \n        Yes → l_rem = l_rem + 1  \n        No → 若 s[i] 為 ')', r_rem = r_rem + 1  \n→ Step 3: 建立空集合 visited，用於儲存已訪問過的字串狀態  \n→ Step 4: 建立空集合 result，用於儲存最小刪除後有效字串  \n→ Step 5: 建立佇列 queue，並把原字串 s 加入 queue  \n→ Step 6: 建立布林變數 found = False // 標記是否已找到有效字串  \n→ Step 7: 開始 BFS 循環  \n    → Decision: queue 是否為空? // 若無字串可處理則結束循環  \n        Yes → Exit loop  \n        No  \n        → Step 8: 從 queue 取出前端字串 current // 取得待檢查字串  \n        → Step 9: 如果 found 為 False 且 current 為有效字串? // 檢查是否已找到最小層級的有效字串  \n            Yes → result.add(current) // 將有效字串加入結果集合  \n            → Step 10: found = True // 設定已找到有效字串，之後不再產生更深層級的變化  \n            → Decision: 仍需產生其他可能的字串? // 如果已找到有效字串，仍需考慮同層級的其他字串  \n                Yes → continue // 直接跳到下一輪循環  \n                No → continue  \n            No → If found 為 True? // 若已找到有效字串，且目前字串無效，則跳過  \n                Yes → continue  \n                No → 若 found 為 False 且 current 為無效字串，則產生子狀態  \n                    → Decision: current 是否已在 visited?  \n                        Yes → continue // 已訪問過，跳過  \n                        No → visited.add(current) // 標記已訪問  \n                        → Step 11: 遍歷 current 的每個字符 i  \n                            → Decision: current[i] 是否為 '(' 或 ')'？  \n                                Yes → Decision: l_rem > 0?  \n                                    Yes → 將 current 去掉位置 i 的字元產生 new_str  \n                                        → Decision: new_str 是否已在 visited?  \n                                            Yes → continue  \n                                            No → queue.enqueue(new_str) // 將新字串加入佇列以供下一層處理  \n                                No → 如果是其他字元，跳過產生  \n→ Step 12: 循環結束後 // 已完成 BFS 搜尋  \n→ Step 13: 將 result 集合轉成清單，並回傳 // 回傳所有唯一有效字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nfrom collections import deque\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> list[str]:\n        \"\"\"\n        Use BFS to generate all strings with the minimum number of removals\n        that are valid (balanced parentheses).\n        \"\"\"\n        def is_valid(string: str) -> bool:\n            \"\"\"\n            Check if a string has balanced parentheses.\n            \"\"\"\n            balance = 0\n            for ch in string:\n                if ch == '(':\n                    balance += 1\n                elif ch == ')':\n                    balance -= 1\n                    if balance < 0:   # too many ')'\n                        return False\n            return balance == 0   # all '(' matched\n\n        visited = set()          # 已處理過的字串\n        result = set()           # 以集合儲存結果，避免重複\n        queue = deque([s])       # BFS 佇列\n        found = False            # 是否已找到最小層級的有效字串\n\n        while queue:\n            current = queue.popleft()\n            if current in visited:\n                continue\n            visited.add(current)\n\n            if is_valid(current):\n                result.add(current)\n                found = True   # 找到有效字串，之後只收集同層級\n                continue\n\n            if found:\n                # 已找到有效字串，跳過產生更深層級的子狀態\n                continue\n\n            # 產生下一層級的所有子狀態（刪除一個括號）\n            for i, ch in enumerate(current):\n                if ch in ('(', ')'):\n                    nxt = current[:i] + current[i+1:]\n                    if nxt not in visited:\n                        queue.append(nxt)\n\n        return list(result)\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    Extract the string value from input like 's = \"()())()\"' or just '()())()'.\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return ''\n    # 找到第一個雙引號與最後一個雙引號之間的內容\n    first = data.find('\"')\n    last = data.rfind('\"')\n    if first != -1 and last != -1 and last > first:\n        return data[first+1:last]\n    # 可能使用單引號\n    first = data.find(\"'\")\n    last = data.rfind(\"'\")\n    if first != -1 and last != -1 and last > first:\n        return data[first+1:last]\n    # 沒有引號，直接返回\n    return data\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    sol = Solution()\n    ans = sol.removeInvalidParentheses(s)\n    # 使用 json.dumps 以雙引號輸出列表，符合範例格式\n    print(json.dumps(ans))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()()\", \"(a())()\"]'"
        },
        {
          "example_index": 2,
          "input": "s = \")(\"",
          "expected_output": "[\"\"]",
          "success": true,
          "output": "[\"\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode482.json",
    "problem_index_in_file": 0,
    "title": "License Key Formatting",
    "description_snippet": "You are given a license key represented as a string s that consists of only alphanumeric characters ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the license key reformat problem. Provide each line with explanation. Use arrow formatting. No actual code. Use Start, Decision, End. Need to produce algorithm steps: remove dashes, uppercase, group from end, etc. Provide step-by-step. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將字串 s 內所有 '-' 刪除並將所有小寫字母轉為大寫 // 清除分隔符並統一大小寫\n→ Step 2: 計算清理後字串長度 len // 取得有效字符總數\n→ Decision: 如果 len ≤ k? // 檢查是否能以單一組完成\n    Yes → Step 3: 回傳整個字串 // 直接輸出結果\n    No  → Step 4: 計算首組長度 firstLen = len mod k；若 firstLen == 0 則 firstLen = k // 確定首組字符數\n→ Step 5: 建立結果字串 result = \"\" // 初始化輸出\n→ Step 6: 將 s 的前 firstLen 個字符加入 result // 添加首組\n→ Step 7: 如果 firstLen < len，則在 result 加入 '-' // 若還有剩餘，插入分隔符\n→ Step 8: 從索引 firstLen 開始，以步進 k 進行迴圈 // 處理後續完整 k 長的組\n    For i from firstLen to len-1 step k:\n        → Step 9: 取得子字串 s[i:i+k] // 取出一組 k 個字符\n        → Step 10: 在 result 加入 '-' + 子字串 // 在結果中追加分隔符與組\n→ End // 程式執行結束，result 即為重新格式化的 license key\n\n---  \n解釋說明：  \n- 步驟 1: 先把所有 '-' 刪除並把小寫轉大寫，方便後續處理。  \n- 步驟 2: 取得清理後字串長度。  \n- 步驟 3-4: 若長度不足 k，直接回傳；否則計算首組長度。  \n- 步驟 5-7: 建立結果並加入首組與可能的分隔符。  \n- 步驟 8-10: 從首組後的位置開始，以 k 為步長取子字串，依序加入結果並加上 '-'。  \n- End: 完成並回傳結果。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\n        # 移除所有 '-' 並轉為大寫\n        S = S.replace('-', '').upper()\n        n = len(S)\n        # 第一組長度\n        first_group_len = n % K or K\n        # 先組成各個組\n        groups = [S[:first_group_len]]\n        for i in range(first_group_len, n, K):\n            groups.append(S[i:i + K])\n        # 用 '-' 連結\n        return '-'.join(groups)\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入文字中擷取字串 s 與整數 k。\n    支援兩種常見格式：\n        1. 兩行分別為 s 與 k\n        2. 單行像是 s = \"5F3Z-2e-9-w\", k = 4\n    \"\"\"\n    # 先把換行換成空格，方便解析\n    text = text.replace('\\n', ' ').strip()\n\n    # 取第一個被雙引號包住的字串\n    str_match = re.search(r'\"([^\"]+)\"', text)\n    if not str_match:\n        # 也檢查單引號\n        str_match = re.search(r\"'([^']+)'\", text)\n    if not str_match:\n        raise ValueError(\"Cannot find license key string in input.\")\n    s = str_match.group(1)\n\n    # 取第一個整數\n    int_match = re.search(r'(\\d+)', text)\n    if not int_match:\n        raise ValueError(\"Cannot find integer k in input.\")\n    k = int(int_match.group(1))\n\n    return s, k\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    s, k = parse_input(data)\n    sol = Solution()\n    formatted = sol.licenseKeyFormatting(s, k)\n    # 如範例所示，輸出時帶上雙引號\n    print(f'\"{formatted}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"5F3Z-2e-9-w\", k = 4",
          "expected_output": " \"5F3Z-2E9W\"",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '5F3Z-2E9W'\nGot (Norm):      '5F3-Z2E9W'\n--- (Raw) ---\nRaw Expected: ' \"5F3Z-2E9W\"'\nRaw Got:      '\"5F3-Z2E9W\"'"
        },
        {
          "example_index": 1,
          "input": "s = \"2-5g-3-J\", k = 2",
          "expected_output": "\"2-5G-3J\"",
          "success": true,
          "output": "\"2-5G-3J\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode373.json",
    "problem_index_in_file": 0,
    "title": "Find K Pairs with Smallest Sums",
    "description_snippet": "You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\n\nD...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: given two sorted arrays and integer k, find k pairs with smallest sums. Classic problem \"K Smallest Pairs\". Use min-heap of pairs of indices. Steps:\n\nStart, initialize result list, initialize min-heap with first element pairs (i=0, j=0) sum. While heap not empty and result size<k, pop smallest, add pair to result, then push next pair: either (i+1, j) if i+1 < len(nums1) and (i+1,j) not already in heap. But typical algorithm pushes (i+1,j) and (i, j+1). But to avoid duplicates, we maintain visited set or push only (i+1, j) if not visited.\n\nLet's produce step-by-step pseudocode. Use Decision nodes. Use \"Start\" and \"End\". Provide each step.\n\nWe need to follow output format: each line: \"虛擬碼步驟 // 解釋/說明\"\n\nLet's craft:\n\nStart // 開始執行\n→ Step 1: 初始化結果 list pairs // 用於存儲最小的 k 個對\n→ Step 2: 初始化最小堆 heap // 儲存 (sum, i, j) 元素\n→ Step 3: 初始化訪問集合 visited // 避免重複推入堆\n→ Decision: nums1 是否為空 或 nums2 是否為空? // 若任一空，直接結束\n    Yes → End // 無可用對，結束\n    No  →\n        → Step 4: 計算初始和 sum0 = nums1[0] + nums2[0]\n        → Step 5: 推入堆: (sum0, 0, 0)\n        → Step 6: 記錄已訪問 (0,0)\n\n→ Decision: 堆是否為空? 或 result 已達 k? // 是否繼續\n    Yes → End // 完成\n    No  →\n        → Step 7: 從堆中取出最小元素 (sum, i, j) // pop\n        → Step 8: 添加對 (nums1[i], nums2[j]) 到結果 // 這是當前最小的對\n        → Decision: i+1 < len(nums1) 且 (i+1, j) 未訪問? // 推進第一個陣列\n            Yes → Step 9: 計算 new_sum = nums1[i+1] + nums2[j]\n                  → Step 10: 推入堆 (new_sum, i+1, j)\n                  → Step 11: 標記 visited (i+1, j)\n            No  → // 不做\n        → Decision: j+1 < len(nums2) 且 (i, j+1) 未訪問? // 推進第二個陣列\n            Yes → Step 12: 計算 new_sum = nums1[i] + nums2[j+1]\n                  → Step 13: 推入堆 (new_sum, i, j+1)\n                  → Step 14: 標記 visited (i, j+1)\n            No  → // 不做\n        → 回到 Decision: 堆是否為空? 或 result 已達 k? // 重複\n\nEnd // 結束\n\nBut need to ensure each line has only one step.\n\nMake sure to use \"→\" for arrow. Use \"Decision:\" with indentation lines. Format: each line with \"虛擬碼步驟\" then space then comment.\n\nWe also need to include \"Start\" and \"End\". Each step should be separate line. For Decision block, we indent following lines with 4 spaces? In example, they indent the Yes and No lines. Use similar.\n\nSo produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空列表 // 用於存放 k 個最小對\n→ Step 2: 初始化 min_heap 為空優先佇列 // 儲存 (sum, i, j)\n→ Step 3: 初始化 visited 為空集合 // 追蹤已推入堆的索引對\n→ Decision: nums1 為空 或 nums2 為空? // 檢查輸入是否可行\n    Yes → End // 若任何一個空，直接結束\n    No  →\n        → Step 4: 計算初始和 sum0 = nums1[0] + nums2[0]\n        → Step 5: 推入 min_heap (sum0, 0, 0) // 把第一個對放入堆\n        → Step 6: 標記 visited.add((0, 0)) // 記錄已加入\n\n→ Decision: min_heap 為空 或 result 長度已達 k? // 是否結束主迴圈\n    Yes → End // 所有對已獲取\n    No  →\n        → Step 7: (sum, i, j) = pop min_heap // 取出和最小的對\n        → Step 8: result.append((nums1[i], nums2[j])) // 加入結果\n        → Decision: i + 1 < len(nums1) 且 (i+1, j) 未在 visited? // 推進 nums1\n            Yes → Step 9: new_sum = nums1[i+1] + nums2[j]\n                  → Step 10: 推入 min_heap (new_sum, i+1, j)\n                  → Step 11: visited.add((i+1, j))\n            No  → // 無操作\n        → Decision: j + 1 < len(nums2) 且 (i, j+1) 未在 visited? // 推進 nums2\n            Yes → Step 12: new_sum = nums1[i] + nums2[j+1]\n                  → Step 13: 推入 min_heap (new_sum, i, j+1)\n                  → Step 14: visited.add((i, j+1))\n            No  → // 無操作\n        → 回到 Decision: min_heap 為空 或 result 長度已達 k? // 循環\n\nEnd // 程式執行結束\n\nBut each line must have \"虛擬碼步驟\" followed by comment. For Decision we have \"Decision:\" as the line. For indentation lines, we maintain the arrow \"→\" for substeps. For \"Yes →\" and \"No →\" we need to put arrow and then step lines? In example, they had \"Yes → Step 2: ...\" etc. For Yes and No they also used arrow then step. In our output, for Decision, we use \"Decision:\" then indent lines with 4 spaces? They didn't show indent but show with 4 spaces indent? In example:\n\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nWe should follow that: after Decision line, indent the Yes/No lines with 4 spaces. Use \"Yes →\" then step. For No maybe \"No  →\" note that they had two spaces after No to align arrow? They used \"No  →\" (two spaces). We'll follow similar.\n\nThus produce final answer. Ensure each line is separate. Use Traditional Chinese comments.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空列表 // 用於存放 k 個最小對  \n→ Step 2: 初始化 min_heap 為空優先佇列 // 儲存 (sum, i, j)  \n→ Step 3: 初始化 visited 為空集合 // 追蹤已推入堆的索引對  \n→ Decision: nums1 為空 或 nums2 為空? // 檢查輸入是否可行  \n    Yes → End // 若任何一個空，直接結束  \n    No  →  \n        → Step 4: 計算初始和 sum0 = nums1[0] + nums2[0] // 第一道對的和  \n        → Step 5: 推入 min_heap (sum0, 0, 0) // 把第一個對放入堆  \n        → Step 6: visited.add((0, 0)) // 記錄已加入  \n\n→ Decision: min_heap 為空 或 result 長度已達 k? // 是否結束主迴圈  \n    Yes → End // 所有對已獲取  \n    No  →  \n        → Step 7: (sum, i, j) = pop min_heap // 取出和最小的對  \n        → Step 8: result.append((nums1[i], nums2[j])) // 加入結果  \n        → Decision: i + 1 < len(nums1) 且 (i+1, j) 未在 visited? // 推進 nums1  \n            Yes → Step 9: new_sum = nums1[i+1] + nums2[j] // 計算新和  \n                  → Step 10: 推入 min_heap (new_sum, i+1, j) // 把新對放入堆  \n                  → Step 11: visited.add((i+1, j)) // 標記已加入  \n            No  → // 無操作  \n        → Decision: j + 1 < len(nums2) 且 (i, j+1) 未在 visited? // 推進 nums2  \n            Yes → Step 12: new_sum = nums1[i] + nums2[j+1] // 計算新和  \n                  → Step 13: 推入 min_heap (new_sum, i, j+1) // 把新對放入堆  \n                  → Step 14: visited.add((i, j+1)) // 標記已加入  \n            No  → // 無操作  \n        → 回到 Decision: min_heap 為空 或 result 長度已達 k? // 重複主迴圈  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nimport json\nimport heapq\n\nclass Solution:\n    def kSmallestPairs(self, nums1, nums2, k):\n        if not nums1 or not nums2 or k <= 0:\n            return []\n        heap = []\n        res = []\n        # 初始化堆：把每個 nums1[i] 與 nums2[0] 形成的對放進去\n        for i in range(min(k, len(nums1))):\n            heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n        # 循環取最小和，並把下一個可能的對加入堆\n        while heap and len(res) < k:\n            sum_val, i, j = heapq.heappop(heap)\n            res.append([nums1[i], nums2[j]])\n            if j + 1 < len(nums2):\n                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析出 nums1、nums2 與 k。\n    期望的輸入格式為：\n    nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n    \"\"\"\n    pattern = r'nums1\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*nums2\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*k\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"輸入格式錯誤\")\n    nums1 = ast.literal_eval(match.group(1))\n    nums2 = ast.literal_eval(match.group(2))\n    k = int(match.group(3))\n    return nums1, nums2, k\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums1, nums2, k = parse_input(data)\n    sol = Solution()\n    result = sol.kSmallestPairs(nums1, nums2, k)\n    # 以 JSON 格式輸出，避免多餘空格\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "success": true,
          "output": "[[1,2],[1,4],[1,6]]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "success": true,
          "output": "[[1,1],[1,1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode732.json",
    "problem_index_in_file": 0,
    "title": "My Calendar III",
    "description_snippet": "A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line with comments. The problem: implement MyCalendarThree with ability to book intervals and keep track of maximum concurrent events. This can be done using sweep line with events map.\n\nPseudo-code:\n\nStart\n→ Initialize tree map or map of time->delta\n→ book(start,end):\n    add +1 at start\n    add -1 at end\n    iterate through sorted keys accumulate and track max\n    return max\n\nBut we can optimize using a segment tree or balanced BST. For pseudo, simple.\n\nLet's produce step-by-step:\n\nStart // program begins\n\n→ Initialize MyCalendarThree // create object\n    → Set eventMap := empty map // time to delta\n\n→ book(start, end):\n    → eventMap[start] += 1 // increment start\n    → eventMap[end] -= 1 // decrement at end\n    → current := 0 // running count\n    → maxOverlap := 0\n    → For each time in eventMap sorted ascending:\n        current += eventMap[time]\n        if current > maxOverlap: maxOverlap = current\n    → Return maxOverlap\n\nEnd\n\nWe need each line with comment.\n\nBut format: each line \"虛擬碼步驟 [space] // 解釋\". We should keep arrows. Use Start, End, Decision etc. Here we don't need decisions.\n\nLet's craft.\n\n```\nStart // 程式開始執行\n→ MyCalendarThree() // 初始化 MyCalendarThree 物件\n    → eventMap := empty map // 用來存時間點與變化量\n→ book(start, end) // 新增事件區間並回傳目前最大重疊數\n    → eventMap[start] += 1 // 在開始時間累加 1，表示事件開始\n    → eventMap[end] -= 1 // 在結束時間累加 -1，表示事件結束\n    → current := 0 // 用於計算當前同時進行的事件數\n    → maxOverlap := 0 // 儲存目前找到的最大重疊數\n    → For each time in eventMap sorted ascending: // 依時間順序遍歷所有變化點\n        → current += eventMap[time] // 更新同時進行事件數\n        → If current > maxOverlap: // 若更高重疊數\n            → maxOverlap = current // 更新最大值\n    → Return maxOverlap // 回傳目前最大的 k-booking\nEnd // 程式執行結束\n```\n\nBut each line must be separate. Use indentation as separate lines. Provide arrow \"→\" at beginning for steps. Use spaces.\n\nWe need to show decision lines? Not necessary.\n\nBut \"Start\" \"End\" lines.\n\nAlso ensure each line has comment.\n\nAlso ensure \"→\" and \"Decision:\" usage but not necessary.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ MyCalendarThree() // 初始化 MyCalendarThree 物件\n    → eventMap := empty map // 用來存時間點與變化量\n→ book(start, end) // 新增事件區間並回傳目前最大重疊數\n    → eventMap[start] += 1 // 在開始時間累加 1，表示事件開始\n    → eventMap[end] -= 1 // 在結束時間累加 -1，表示事件結束\n    → current := 0 // 用於計算當前同時進行的事件數\n    → maxOverlap := 0 // 儲存目前找到的最大重疊數\n    → For each time in eventMap sorted ascending: // 依時間順序遍歷所有變化點\n        → current += eventMap[time] // 更新同時進行事件數\n        → If current > maxOverlap: // 若更高重疊數\n            → maxOverlap = current // 更新最大值\n    → Return maxOverlap // 回傳目前最大的 k‑booking\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport bisect\n\nclass MyCalendarThree:\n    def __init__(self):\n        self.timeline = []\n\n    def book(self, start: int, end: int) -> int:\n        bisect.insort(self.timeline, (start, 1))\n        bisect.insort(self.timeline, (end, -1))\n        active = 0\n        max_active = 0\n        for time, delta in self.timeline:\n            active += delta\n            if active > max_active:\n                max_active = active\n        return max_active\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 把輸入轉成兩個列表\n    # 例: '[\"MyCalendarThree\", \"book\", ...], [[], [10,20], ...]'\n    # 先包裝成 JSON 數組，再解碼\n    data = json.loads(f'[{raw_input}]')\n    methods, args_list = data[0], data[1]\n\n    obj = None\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"MyCalendarThree\":\n            obj = MyCalendarThree()\n            results.append(None)\n        elif method == \"book\":\n            # book 需要兩個參數\n            start, end = args\n            res = obj.book(start, end)\n            results.append(res)\n        else:\n            # 若有其他方法，可自行擴充\n            results.append(None)\n\n    # 輸出結果，符合題目示例格式\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "success": true,
          "output": "[null, 1, 1, 2, 3, 3, 3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode162.json",
    "problem_index_in_file": 0,
    "title": "Find Peak Element",
    "description_snippet": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a 0-indexed integer...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to find a peak element in O(log n). Use binary search. We'll write step by step. Let's produce virtual code: Start, define low, high, while low < high, compute mid, compare with mid+1, etc. Then output index.\n\nLet's output each line with arrow and explanation. Use arrow \"→\". Use indentation maybe but format not strict. We need step and explanation.\n\nLet's produce like:\n\nStart // start\n→ Step 1: Initialize low = 0, high = length(nums) - 1 // set bounds\n→ Decision: low < high? // loop condition\n    Yes → Step 2: mid = low + (high - low) / 2 // mid index\n    → Decision: nums[mid] < nums[mid+1]? // compare right neighbor\n        Yes → Step 3: low = mid + 1 // move to right half\n        No  → Step 4: high = mid // move to left half\n    No  → Step 5: Return low // low == high, found peak\nEnd\n\nAdd explanation comments. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 0, high = length(nums) - 1 // 設定搜尋區間兩端索引  \n→ Decision: low < high? // 判斷是否還有多個元素可搜尋  \n    Yes → Step 2: mid = low + (high - low) / 2 // 計算中間索引，避免溢位  \n    → Decision: nums[mid] < nums[mid+1]? // 比較中間元素與右側鄰居  \n        Yes → Step 3: low = mid + 1 // 若右鄰更大，峰值必在右半段  \n        No  → Step 4: high = mid // 否則峰值在左半段或是 mid 本身  \n    No  → Step 5: Return low // low == high，已找到峰值索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_peak_element(nums):\n    \"\"\"使用二分搜尋找峰值索引（O(log n)）\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1      # 峰值在右半段\n        else:\n            right = mid         # 峰值在左半段或 mid 本身\n    return left\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 支援「nums = [1,2,3,1]」或僅輸入「[1,2,3,1]」\n    if '=' in data:\n        _, nums_str = data.split('=', 1)\n    else:\n        nums_str = data\n    nums = ast.literal_eval(nums_str.strip())\n    result = find_peak_element(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,1,3,5,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode736.json",
    "problem_index_in_file": 0,
    "title": "Parse Lisp Expression",
    "description_snippet": "You are given a string expression representing a Lisp-like expression to return the integer value of...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that implement evaluation of Lisp-like expressions with let, add, mult, integers, variables, scopes. Provide step-by-step pseudocode. Use arrows, decisions. Let's design algorithm:\n\nWe need to parse string expression. Steps:\n\nStart\n→ tokenize input string into list of tokens (parentheses, identifiers, integers)\n→ Define function evaluate(tokens, env)\n   env is list of dictionaries for scopes\n\nDefine recursion.\n\nPseudo: evaluate:\n- If token is integer: return int(token)\n- If token is identifier: look up env from innermost to outermost, return value\n- If token is '(':\n   consume '('\n   next token is operator\n   if operator == 'add':\n        eval e1, e2 recursively\n        return e1 + e2\n   elif operator == 'mult':\n        eval e1, e2 recursively\n        return e1 * e2\n   elif operator == 'let':\n        create new scope dict\n        while next token not ')' and not last expression? Actually let has pairs then expr\n        parse pairs until we reach expression part? We can parse until we have two tokens left? Approach: collect tokens until we reach the expression part: parse until last expression. Simpler: process tokens sequentially: after let, while next token not ')', check if following token is variable and next token after variable is not ')'? Actually pairs of variable expression repeated, but final expression can be any expression. So parse: create new scope, while tokens before final expression: if next token is variable and after it we don't know if next token is '(' or number, but variable names are letters; expression could be integer or variable or '(' . We need to detect that final expression starts when we see a token that is not a variable or it's the last token before ')'. Implementation: iterate over tokens until we reach expression part by counting depth: we can process until we have two tokens left? Better: parse until we see that next token is variable and there are more tokens after it. But that is ambiguous.\n\nSimplify: For virtual code, we can describe logic: For let: create new scope; while more than one token remaining before ')': read variable name; evaluate expression; assign to variable in current scope; continue. Finally, evaluate last expression and return.\n\nOk.\n\nReturn to pseudocode.\n\nEnd\n\nProvide step-by-step with decision arrows.\n\nLet's produce.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Tokenise input string into list Tokens // 把整個表達式切成標記，方便後續處理\n→ Step 2: Initialise Environment stack Env = [] // 用來存放層層 scope 的變數映射\n→ Step 3: Call Evaluate(Tokens, Env) and output result // 進入遞迴求值流程\nEnd // 程式執行結束\n\n// ---------- Evaluate 函式 ----------\n→ Step 4: Function Evaluate(Tokens, Env)\n    // Tokens 為目前要處理的標記序列，Env 為目前的 scope 堆疊\n\n    → Decision: 目前第一個標記是 整數?\n        Yes → Step 5: Return int(Tokens[0]) // 直接回傳數字\n        No  → Decision: 目前第一個標記是 變數名?\n            Yes → Step 6: Search Env from top to bottom\n                     // 逐層查找變數對應值\n                 → Decision: 變數在某層找到?\n                     Yes → Step 7: Return 找到的值\n                     No  → Step 8: 把 '未知變數' 當作錯誤 // 輸入保證合法，此行不會執行\n            No  → Decision: 目前第一個標記是 '('?\n                Yes → Step 9: Consume '(' 並取得 Operator = Tokens[1]\n                     // 取出子表達式的操作符\n                    → Decision: Operator == 'add'?\n                        Yes → Step 10: Eval e1 = Evaluate(Tokens[2:], Env)\n                            // 先評估第一個子表達式\n                             → Step 11: Eval e2 = Evaluate(剩下的標記, Env)\n                             → Step 12: Return e1 + e2\n                        No  → Decision: Operator == 'mult'?\n                            Yes → Step 13: Eval e1 = Evaluate(Tokens[2:], Env)\n                                → Step 14: Eval e2 = Evaluate(剩下的標記, Env)\n                                → Step 15: Return e1 * e2\n                            No  → Decision: Operator == 'let'?\n                                Yes → Step 16: Create NewScope = {}\n                                    → Step 17: Push NewScope onto Env // 新開一層 scope\n                                    → Step 18: Set Pos = 2 // 開始解析 let 的內容\n                                    → Decision: 是否還有子表達式未解析?\n                                        Yes → Step 19: 若 Tokens[Pos] 是 變數名 且 Tokens[Pos+1] 不是 ')'\n                                                // 表示還有 (v e) 對\n                                            → Step 20: VarName = Tokens[Pos]\n                                            → Step 21: Eval Val = Evaluate(從 Pos+1 開始的標記, Env)\n                                            → Step 22: 在 NewScope 中存入 VarName = Val\n                                            → Step 23: 移動 Pos 至 Val 所覆蓋的所有標記後的位置\n                                            → 再回到 Decision 進行下一對\n                                        No  → Step 24: 剩下的標記即為 let 的 expr\n                                            → Step 25: Eval Expr = Evaluate(剩下的標記, Env)\n                                            → Step 26: Pop NewScope 從 Env // let 範圍結束\n                                            → Step 27: Return Expr\n                                    End Decision\n                                No  → Step 28: 把 ')' 直接消費 // 這行不會被執行\n                        No  → Step 29: 把 ')' 直接消費 // 這行不會被執行\n                No  → Step 30: 把 ')' 直接消費 // 這行不會被執行\n        No  → Step 31: 把 ')' 直接消費 // 這行不會被執行\n```",
      "generated_code": "import sys\n\n# ----------  解析與評估  ----------\ndef tokenize(s: str):\n    \"\"\"\n    把原始字串切成 token 清單，token 可能是 '('、')'、數字、變數名。\n    \"\"\"\n    tokens = []\n    i = 0\n    while i < len(s):\n        c = s[i]\n        if c == '(' or c == ')':\n            tokens.append(c)\n            i += 1\n        elif c == ' ':\n            i += 1\n        else:\n            j = i\n            while j < len(s) and s[j] not in ('(', ')', ' '):\n                j += 1\n            tokens.append(s[i:j])\n            i = j\n    return tokens\n\ndef eval_expr(tokens, env, idx):\n    \"\"\"\n    遞迴評估 tokens[idx:]，並回傳 (值, 下一個索引)。\n    env 為目前的變數環境 (字典)。\n    \"\"\"\n    token = tokens[idx]\n    if token == '(':\n        op = tokens[idx + 1]          # add / mult / let\n        if op == 'add':\n            v1, i1 = eval_expr(tokens, env, idx + 2)\n            v2, i2 = eval_expr(tokens, env, i1)\n            return v1 + v2, i2 + 1   # +1 跳過 ')'\n        if op == 'mult':\n            v1, i1 = eval_expr(tokens, env, idx + 2)\n            v2, i2 = eval_expr(tokens, env, i1)\n            return v1 * v2, i2 + 1\n        if op == 'let':\n            new_env = env.copy()\n            i = idx + 2\n            while True:\n                # 若下一個 token 是 ')'，說明目前 token 為 let 的最後一個表達式\n                if tokens[i + 1] == ')':\n                    val, next_i = eval_expr(tokens, new_env, i)\n                    return val, next_i + 1\n                # 否則處理變數賦值對\n                var = tokens[i]\n                val, next_i = eval_expr(tokens, new_env, i + 1)\n                new_env[var] = val\n                i = next_i\n    else:\n        # 整數或變數\n        if token[0].isdigit() or (token[0] == '-' and token[1:].isdigit()):\n            return int(token), idx + 1\n        return env[token], idx + 1\n\n# ----------  主程式  ----------\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 支援可能的「expression = \"...」格式\n    if '=' in data:\n        expr = data.split('=', 1)[1].strip()\n        # 去除外層引號 (若有)\n        if (expr.startswith('\"') and expr.endswith('\"')) or (expr.startswith(\"'\") and expr.endswith(\"'\")):\n            expr = expr[1:-1]\n    else:\n        expr = data\n\n    tokens = tokenize(expr)\n    result, _ = eval_expr(tokens, {}, 0)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"",
          "expected_output": "14",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpb2ld_l4l.py\", line 73, in <module>\n    result, _ = eval_expr(tokens, {}, 0)\n                ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpb2ld_l4l.py\", line 51, in eval_expr\n    val, next_i = eval_expr(tokens, new_env, i + 1)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpb2ld_l4l.py\", line 58, in eval_expr\n    return env[token], idx + 1\n           ~~~^^^^^^^\nKeyError: 'mult'"
        },
        {
          "example_index": 1,
          "input": "expression = \"(let x 3 x 2 x)\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "expression = \"(let x 1 y 2 x (add x y) (add x y))\"",
          "expected_output": "5",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpa_9s4ymj.py\", line 73, in <module>\n    result, _ = eval_expr(tokens, {}, 0)\n                ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpa_9s4ymj.py\", line 51, in eval_expr\n    val, next_i = eval_expr(tokens, new_env, i + 1)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpa_9s4ymj.py\", line 58, in eval_expr\n    return env[token], idx + 1\n           ~~~^^^^^^^\nKeyError: 'add'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode87.json",
    "problem_index_in_file": 0,
    "title": "Scramble String",
    "description_snippet": "We can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the st...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the specified format. The problem: check if s2 is a scrambled string of s1, using recursion and random splits. Essentially classic scramble string problem. We need to produce algorithm: base cases, check length, if same string then true, check if sorted strings same else false, then try all split positions, recursively check combinations. We need to produce virtual code step by step.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrows and decision structures. We'll start with Start, then steps: Input s1, s2, call function, recursion.\n\nWe'll produce something like:\n\nStart\n→ Step 1: 定義函數 ScrambleCheck(s1, s2) // 定義遞歸檢查\n→ Decision: 如果兩字串長度不同? // 若長度不相等直接不合法\n    Yes → Step 2: 返回 False\n    No → Decision: 如果 s1 等於 s2? // 若完全相同，必定是亂碼\n        Yes → Step 3: 返回 True\n        No → Decision: 是否兩字串字母統計相同? // 先做頻率檢查加速\n            Yes → Step 4: 循環 i 從 1 到 len-1 // 嘗試所有切分位置\n                → Decision: ScrambleCheck(x1, x2) 且 ScrambleCheck(y1, y2) 是否真? // 不交換情況\n                    Yes → Step 5: 返回 True\n                    No → Decision: ScrambleCheck(x1, y2) 且 ScrambleCheck(y1, x2) 是否真? // 交換情況\n                        Yes → Step 6: 返回 True\n                        No → Step 7: 繼續下一個 i\n            → Step 8: 返回 False // 所有切分皆失敗\n        No → Step 9: 返回 False // 字母分布不同\nEnd\n\nWe need to include the loop in pseudo-code with arrow, maybe nested Decision inside loop.\n\nWe'll produce line by line.\n\nLet's enumerate lines:\n\n1. Start // 程式開始執行\n2. → Step 1: 定義函數 ScrambleCheck(s1, s2) // 定義遞歸檢查\n3. → Decision: 如果兩字串長度不同? // 若長度不相等直接不合法\n4.    Yes → Step 2: 返回 False\n5.    No → Decision: 如果 s1 等於 s2? // 若完全相同，必定是亂碼\n6.        Yes → Step 3: 返回 True\n7.        No → Decision: 是否兩字串字母統計相同? // 先做頻率檢查加速\n8.            Yes → Step 4: 循環 i 從 1 到 len-1 // 嘗試所有切分位置\n9.                → Decision: ScrambleCheck(x1, x2) 且 ScrambleCheck(y1, y2) 是否真? // 不交換情況\n10.                    Yes → Step 5: 返回 True\n11.                    No → Decision: ScrambleCheck(x1, y2) 且 ScrambleCheck(y1, x2) 是否真? // 交換情況\n12.                        Yes → Step 6: 返回 True\n13.                        No → Step 7: 繼續下一個 i\n14.                → Step 8: 返回 False // 所有切分皆失敗\n15.            No → Step 9: 返回 False // 字母分布不同\n16. End // 程式執行結束\n\nBut we need to reflect recursion: inside the function, loop etc. Each line can include the step.\n\nWe may need to include variable assignments for x1, x2, y1, y2. Let's refine:\n\nIn loop, we split s1 into x1 = s1[:i], y1 = s1[i:]; similarly s2 into x2, y2.\n\nSo step for split: Step 4 maybe: Split s1 into x1, y1 and s2 into x2, y2 // at index i\n\nWe can incorporate into step 4.\n\nLet's restructure:\n\nLine 1: Start\n\nLine 2: → Step 1: 定義函數 ScrambleCheck(s1, s2) // 定義遞歸檢查\n\nInside function:\n\nLine 3: → Decision: 如果 len(s1) ≠ len(s2)? // 長度不符直接 false\n    Yes → Step 2: 返回 False\n    No → Decision: 如果 s1 == s2? // 完全相同\n        Yes → Step 3: 返回 True\n        No → Decision: 兩字串字母統計是否相同? // 篩選\n            Yes → Step 4: 循環 i 從 1 到 len(s1)-1\n                → Step 5: 分割 s1 為 x1, y1, s2 為 x2, y2 // 以 i 為切分點\n                → Decision: ScrambleCheck(x1, x2) 且 ScrambleCheck(y1, y2) 是否真? // 不交換\n                    Yes → Step 6: 返回 True\n                    No → Decision: ScrambleCheck(x1, y2) 且 ScrambleCheck(y1, x2) 是否真? // 交換\n                        Yes → Step 7: 返回 True\n                        No → Step 8: 繼續下一個 i\n            → Step 9: 返回 False // 所有切分失敗\n            No → Step 10: 返回 False // 字母分布不同\n\nBut each step needs to be on separate line. Let's enumerate precisely:\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 定義函數 ScrambleCheck(s1, s2) // 定義遞歸檢查\n\nNow inside function, we need lines 3-? but we need to maintain arrow for nested steps. We'll use indentation by \"→\" for steps inside.\n\nLine 3: → Decision: 如果 len(s1) ≠ len(s2)? // 長度不符直接 false\nLine 4:     Yes → Step 2: 返回 False\nLine 5:     No → Decision: 如果 s1 == s2? // 完全相同\nLine 6:         Yes → Step 3: 返回 True\nLine 7:         No → Decision: 兩字串字母統計是否相同? // 篩選\nLine 8:             Yes → Step 4: 循環 i 從 1 到 len(s1)-1\nLine 9:                 → Step 5: 分割 s1 為 x1, y1, s2 為 x2, y2 // 以 i 為切分點\nLine 10:                 → Decision: ScrambleCheck(x1, x2) 且 ScrambleCheck(y1, y2) 是否真? // 不交換\nLine 11:                     Yes → Step 6: 返回 True\nLine 12:                     No → Decision: ScrambleCheck(x1, y2) 且 ScrambleCheck(y1, x2) 是否真? // 交換\nLine 13:                         Yes → Step 7: 返回 True\nLine 14:                         No → Step 8: 繼續下一個 i\nLine 15:             → Step 9: 返回 False // 所有切分失敗\nLine 16:         No → Step 10: 返回 False // 字母分布不同\n\nLine 17: End // 程式執行結束\n\nBut we might need to include Step 8: return False inside loop? Actually Step 9 is after loop. The loop continues. At the end of loop, we return False.\n\nWe need to handle Step 9: after finishing loop, return False.\n\nMake sure each line ends with \"// 解釋\". All lines have that.\n\nNow final formatting: We should keep each line as a single line, with arrow \"→\" at start of step lines, \"Decision:\" lines with indent. We need to follow format: `虛擬碼步驟 [空格] // 解釋/說明`. So we need to ensure each line has exactly one space before comment.\n\nLet's produce final output.\n\nNote: For nested decisions we indent with spaces? In example, they used spaces and indentation. We'll replicate similar.\n\nWe'll output each line accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函數 ScrambleCheck(s1, s2) // 定義遞歸檢查  \n→ Decision: 如果 len(s1) ≠ len(s2)? // 長度不符直接 false  \n Yes → Step 2: 返回 False // 長度不同則不是亂碼  \n No → Decision: 如果 s1 == s2? // 完全相同的字串必定是亂碼  \n  Yes → Step 3: 返回 True // 直接回傳真  \n  No → Decision: 兩字串字母統計是否相同? // 篩選不相同的字母組合  \n   Yes → Step 4: 循環 i 從 1 到 len(s1)-1 // 嘗試所有切分位置  \n    → Step 5: 分割 s1 為 x1, y1, s2 為 x2, y2 // 以 i 為切分點  \n    → Decision: ScrambleCheck(x1, x2) 且 ScrambleCheck(y1, y2) 是否真? // 不交換情況  \n     Yes → Step 6: 返回 True // 找到有效的拆分  \n     No → Decision: ScrambleCheck(x1, y2) 且 ScrambleCheck(y1, x2) 是否真? // 交換情況  \n      Yes → Step 7: 返回 True // 找到有效的交換拆分  \n      No → Step 8: 繼續下一個 i // 試下一個切分點  \n    → Step 9: 返回 False // 所有切分皆失敗  \n   No → Step 10: 返回 False // 字母分布不同，無法成為亂碼  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        memo = {}\n\n        def dfs(x: str, y: str) -> bool:\n            if (x, y) in memo:\n                return memo[(x, y)]\n            if x == y:\n                memo[(x, y)] = True\n                return True\n            if sorted(x) != sorted(y):\n                memo[(x, y)] = False\n                return False\n\n            n = len(x)\n            for i in range(1, n):\n                # Case 1: no swap\n                if dfs(x[:i], y[:i]) and dfs(x[i:], y[i:]):\n                    memo[(x, y)] = True\n                    return True\n                # Case 2: swap\n                if dfs(x[:i], y[-i:]) and dfs(x[i:], y[:-i]):\n                    memo[(x, y)] = True\n                    return True\n\n            memo[(x, y)] = False\n            return False\n\n        return dfs(s1, s2)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract all quoted substrings; expect at least two\n    strings = re.findall(r'\"([^\"]*)\"', data)\n    if len(strings) < 2:\n        # Fallback: try to split by whitespace\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            s1, s2 = parts[0], parts[1]\n        else:\n            s1 = s2 = \"\"\n    else:\n        s1, s2 = strings[0], strings[1]\n\n    solution = Solution()\n    result = solution.isScramble(s1, s2)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"great\", s2 = \"rgeat\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s1 = \"abcde\", s2 = \"caebd\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s1 = \"a\", s2 = \"a\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode34.json",
    "problem_index_in_file": 0,
    "title": "Find First and Last Position of Element in Sorted Array",
    "description_snippet": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending positio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following format: \"虛擬碼步驟 // 解釋\". Use arrow, Start, End, Decision. Provide algorithm O(log n) for searching target's first and last positions. Use binary search twice: one for leftmost, one for rightmost. So steps: Start → Step: Initialize low, high → Decision: while low <= high? → Leftmost search; similar for rightmost. Provide explanation each line.\n\nWe must not output actual code but structure steps.\n\nLet's produce: Start; → Step: 定義 low = 0, high = nums.Length -1 // 初始左右指標。 Then leftmost: While low <= high; Decision: if nums[mid] < target? -> low = mid+1; else -> high = mid-1; After loop leftIndex = low; Then rightmost: low =0 high = nums.Length -1; While low <= high; Decision: if nums[mid] <= target? -> low=mid+1; else -> high=mid-1; After loop rightIndex = high; Check if leftIndex <= rightIndex and nums[leftIndex]==target -> return [leftIndex, rightIndex] else [-1,-1]. End.\n\nWe need to use Decision: with Yes/No lines? Format: Decision: 條件?; then Yes→ Step; No→ Step. For loops we can use Decision for condition.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step: 初始化 low = 0, high = nums.Length - 1 // 設定搜尋範圍\n→ Decision: 低於高? // 判斷是否仍有範圍可搜尋\n    Yes → Step: 計算 mid = (low + high) / 2 // 取中間索引\n    Yes → Decision: nums[mid] < target? // 比較中間值與目標\n        Yes → Step: low = mid + 1 // 目標在右半段\n        No  → Decision: nums[mid] > target? // 目標在左半段？\n            Yes → Step: high = mid - 1\n            No  → Step: high = mid - 1 // 找到左邊界，縮小範圍\n← Decision: low <= high? // 迴圈結束條件\n    Yes → 回到 上一層 Decision\n    No  → Step: leftIndex = low // 左邊界位置\n→ Step: 重置 low = 0, high = nums.Length - 1 // 為右邊界搜尋重新設定指標\n→ Decision: low <= high? // 再次迴圈\n    Yes → Step: mid = (low + high) / 2\n    Yes → Decision: nums[mid] <= target?\n        Yes → Step: low = mid + 1 // 目標右移\n        No  → Step: high = mid - 1 // 目標左移\n← Decision: low <= high? // 迴圈結束\n    Yes → 回到 上一層 Decision\n    No  → Step: rightIndex = high // 右邊界位置\n→ Decision: leftIndex <= rightIndex AND nums[leftIndex] == target? // 檢查目標存在\n    Yes → Step: return [leftIndex, rightIndex] // 回傳範圍\n    No  → Step: return [-1, -1] // 目標不存在\nEnd // 程式結束\n\nBut we need to use \"Yes →\" and \"No →\" appropriately. For loops, we use Decision: while low <= high? but we can show with Yes/No. The above includes some repetition. Ensure each line ends with // 解釋.\n\nLet's write final output. Ensure each line starts with \"Start\" or \"→ Step\" etc. Provide arrow and indent properly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化 low = 0, high = nums.Length - 1 // 設定搜尋範圍  \n→ Decision: low ≤ high? // 是否還有可搜尋的區間  \n  Yes → Step: mid = (low + high) / 2 // 取中間索引  \n  Yes → Decision: nums[mid] < target? // 比較中間值與目標  \n    Yes → Step: low = mid + 1 // 目標在右半段  \n    No → Decision: nums[mid] > target? // 目標在左半段？  \n      Yes → Step: high = mid - 1 // 目標在左半段，縮小範圍  \n      No → Step: high = mid - 1 // 找到左邊界，仍需縮小範圍  \n  ← Decision: low ≤ high? // 迴圈是否繼續  \n    Yes → 回到上方 Decision  \n    No → Step: leftIndex = low // 左邊界位置  \n→ Step: 重置 low = 0, high = nums.Length - 1 // 為右邊界搜尋重新設定指標  \n→ Decision: low ≤ high? // 右邊界搜尋迴圈開始  \n  Yes → Step: mid = (low + high) / 2 // 取中間索引  \n  Yes → Decision: nums[mid] ≤ target? // 比較中間值與目標  \n    Yes → Step: low = mid + 1 // 目標在右半段，移動低指標  \n    No → Step: high = mid - 1 // 目標在左半段，縮小範圍  \n  ← Decision: low ≤ high? // 迴圈是否繼續  \n    Yes → 回到上方 Decision  \n    No → Step: rightIndex = high // 右邊界位置  \n→ Decision: leftIndex ≤ rightIndex AND nums[leftIndex] == target? // 是否找到目標  \n  Yes → Step: return [leftIndex, rightIndex] // 回傳範圍  \n  No → Step: return [-1, -1] // 目標不存在  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def searchRange(self, nums, target):\n        def find_left(nums, target):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n                if nums[mid] == target:\n                    index = mid\n            return index\n\n        def find_right(nums, target):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] <= target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n                if nums[mid] == target:\n                    index = mid\n            return index\n\n        return [find_left(nums, target), find_right(nums, target)]\n\ndef parse_input(data: str):\n    \"\"\"Parse input of the form 'nums = [...], target = ...'.\"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not target_match:\n        raise ValueError(\"Input format incorrect.\")\n    nums_str = nums_match.group(1)\n    target_str = target_match.group(1)\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read().strip()\n    if not raw_data:\n        sys.exit(0)\n    nums, target = parse_input(raw_data)\n    solution = Solution()\n    result = solution.searchRange(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,7,7,8,8,10], target = 8",
          "expected_output": "[3,4]",
          "success": true,
          "output": "[3, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [5,7,7,8,8,10], target = 6",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1, -1]"
        },
        {
          "example_index": 2,
          "input": "nums = [], target = 0",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode771.json",
    "problem_index_in_file": 0,
    "title": "Jewels and Stones",
    "description_snippet": "You're given strings jewels representing the types of stones that are jewels, and stones representin...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanations. No actual code. We should handle the problem: count how many stones in stones string are in jewels string. Case sensitive. Use steps: Start, read input strings, maybe convert jewels to set for O(1) lookup, iterate stones, count matches. Then output count. Let's structure: Start, Step 1: read jewels string. Step 2: read stones string. Step 3: create set of jewel characters. Step 4: initialize count to 0. Step 5: for each char in stones: Decision: if char in set? Yes → increment count. After loop, Step 6: output count. End. Use virtual arrows. Provide explanation after each line.\n\nLet's produce. Use \"→\" arrow before each step line. Use \"Decision:\" for if. Indent under decision lines. Use \"Yes →\" and \"No →\" for branches. But in counting, only Yes branch increments, No branch nothing. Then after loop, output. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 jewels // 取得所有鑽石類型  \n→ Step 2: 讀取字串 stones // 取得所有擁有的石頭  \n→ Step 3: 建立 Set<char> jewelSet ← jewels 的每個字元 // 方便快速查詢  \n→ Step 4: 初始化計數 count ← 0 // 用來累積鑽石數量  \n→ Step 5: 對 stones 中每個字元 c 進行迴圈  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: c 是否屬於 jewelSet? // 判斷此石頭是否為鑽石  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: count ← count + 1 // 是鑽石，計數加一  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 不是鑽石，忽略  \n→ Step 7: 輸出 count // 顯示鑽石的總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_jewels(jewels: str, stones: str) -> int:\n    \"\"\"\n    計算 stones 中有多少字元也出現在 jewels 中。\n    jewels 與 stones 均為大小寫敏感。\n    \"\"\"\n    jewel_set = set(jewels)          # O(1) 查詢\n    return sum(1 for ch in stones if ch in jewel_set)\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，支援兩種格式：\n    1. 一行：jewels = \"aA\", stones = \"aAAbbbb\"\n    2. 多行：第一行是 jewels，第二行是 stones\n    \"\"\"\n    # 嘗試從字串中尋找 jewels 與 stones\n    jewels_match = re.search(r'jewels\\s*=\\s*\"([^\"]*)\"', data)\n    stones_match = re.search(r'stones\\s*=\\s*\"([^\"]*)\"', data)\n\n    if jewels_match and stones_match:\n        jewels = jewels_match.group(1)\n        stones = stones_match.group(1)\n    else:\n        # 若無上述格式，假設每行一個字串\n        lines = data.strip().splitlines()\n        if len(lines) >= 2:\n            jewels = lines[0].strip()\n            stones = lines[1].strip()\n        else:\n            # 無效輸入，返回空字串\n            jewels = ''\n            stones = ''\n    return jewels, stones\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read()\n    jewels_str, stones_str = parse_input(raw_input)\n\n    # 計算並輸出結果\n    result = count_jewels(jewels_str, stones_str)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "jewels = \"aA\", stones = \"aAAbbbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "jewels = \"z\", stones = \"ZZ\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode594.json",
    "problem_index_in_file": 0,
    "title": "Longest Harmonious Subsequence",
    "description_snippet": "We define a harmonious array as an array where the difference between its maximum value and its mini...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanations. The problem: longest harmonious subsequence length. Approach: frequency map, iterate keys, if key+1 exists, sum freq[key]+freq[key+1], track max. Complexity O(n). Virtual code steps: Start, Step1: build freq map, Step2: initialize maxLen=0, Step3: iterate keys, Step4: check if key+1 in freq, Step5: compute sum, update max, Step6: End. Include decision arrow lines. Need to use arrow and decisions. Should use Decision for checking key+1 exists. Provide explanation after each line.\n\nLet's craft. Ensure each line: `虛擬碼步驟 // 解釋`. Use Start, End, Decision. Use arrow notation. Eg:\n\nStart // 程式開始\n→ Step 1: 建立空字典 freq // 用於計數每個數字出現次數\n→ Step 2: 對 nums 中的每個 num 執行 freq[num]++ // 統計頻率\n→ Step 3: 設定 maxLen = 0 // 儲存目前找到的最大長度\n→ Decision: 遍歷 freq 的每個 key? // 檢查所有不同的數值\n    Yes → Step 4: key = current key // 取目前迴圈的數字\n    Yes → Decision: key+1 是否存在於 freq? // 判斷相鄰數字是否存在\n        Yes → Step 5: currentLen = freq[key] + freq[key+1] // 計算該相鄰數字對的總長度\n        Yes → Step 6: 更新 maxLen 為 max(maxLen, currentLen) // 若更長則更新\n        No  → // 若沒有相鄰數字則不處理\n    No  → // 結束遍歷\nEnd // 程式結束，回傳 maxLen\n\nBut need decision for traversal? Use Decision: 遍歷 freq 的每個 key? Actually we can skip Decision for loop; we can just show Step 4 as for each key in freq. But requirement says use Decision for conditional flows. For loop isn't a decision but we can just use Step 4 as \"遍歷 freq 的每個 key\" without decision.\n\nBetter:\n\nStart\n→ Step 1: 建立空字典 freq // 用於計數每個數字出現次數\n→ Step 2: 逐一將 nums 中的元素加進 freq // 統計頻率\n→ Step 3: maxLen = 0 // 儲存最大和\n→ Step 4: 遍歷 freq 的每個 key // 檢查每個數字\n→ Step 5: Decision: key+1 是否存在於 freq? // 判斷是否有相鄰數字\n    Yes → Step 6: currentLen = freq[key] + freq[key+1] // 計算該對的長度\n    Yes → Step 7: maxLen = max(maxLen, currentLen) // 更新最大值\n    No  → // 無相鄰數字，跳過\nEnd // 回傳 maxLen\n\nMake sure each line has arrow before step except start? Use → for each subsequent line. Decision arrow: Decision: ... and then indentation with Yes →.\n\nAlso include End line with comment. Provide explanation after each.\n\nLet's output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立空字典 freq // 用於統計每個數字在 nums 中的出現頻率\n→ Step 2: 對 nums 中的每個 num 執行 freq[num]++ // 逐一累計頻率\n→ Step 3: maxLen ← 0 // 用來保存目前找到的最大和諧子序列長度\n→ Step 4: 遍歷 freq 的每個 key // 檢查所有不同的數字\n    → Decision: key+1 是否存在於 freq? // 判斷是否有相鄰的數字\n        Yes → Step 5: currentLen ← freq[key] + freq[key+1] // 計算此相鄰數字對的總長度\n        Yes → Step 6: maxLen ← max(maxLen, currentLen) // 若更長則更新最大長度\n        No  → // 無相鄰數字，直接跳過\nEnd // 回傳 maxLen，程式執行結束\n```",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef find_lhs(nums):\n    count = Counter(nums)\n    res = 0\n    for num in count:\n        if num + 1 in count:\n            res = max(res, count[num] + count[num + 1])\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 期望形如 \"nums = [1,2,3]\"\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = data\n    try:\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        # 若輸入不是列表，嘗試解析為數字列表\n        nums = []\n    result = find_lhs(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,2,2,5,2,3,7]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1.json",
    "problem_index_in_file": 0,
    "title": "Two Sum",
    "description_snippet": "Given an array of integers nums and an integer target, return indices of the two numbers such that t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. Use Start, End, Decision. Provide explanation after each line. For \"array of integers nums and integer target\". Algorithm: hash map to store number -> index. Iterate through array. For each number, compute complement = target - num, check if complement in map. If yes, output indices. else add num to map. We'll produce steps accordingly. Ensure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow '→'. Use Start, End, Decision. We'll produce steps:\n\nStart\n→ Step 1: 初始化空哈希表 hashMap // 建立一個空的哈希表用於存儲數字及其索引\n→ Step 2: 循環遍歷 nums 並記錄索引 i // 為每個元素做一次遍歷\n→ Decision: 計算 complement = target - nums[i] 是否已在 hashMap? // 檢查是否已經遇到過需要配對的數字\n    Yes → Step 3: 返回 [hashMap[complement], i] // 找到配對，輸出兩個索引\n    No  → Step 4: 將 nums[i] 存入 hashMap 並繼續循環 // 若未找到，將當前數字存入哈希表，等待後續匹配\nEnd\n\nBut we need to format exactly as described: Each line \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow lines: \"→ Step 1: ...\" etc. Decision lines with indent. Use 'Yes →', 'No →' etc. Provide each decision branch. Also End line. Provide each line with explanation. Ensure no actual code. Provide step for iteration. So we produce something like:\n\nStart // 程式開始執行\n→ Step 1: 建立空哈希表 hashMap // 用於儲存已遍歷數字及其索引\n→ Step 2: 為每個 nums[i] 循環遍歷 // 從頭到尾檢查每個元素\n→ Decision: complement = target - nums[i] 是否存在於 hashMap? // 檢查是否已有相對應數字\n    Yes → Step 3: 回傳 [hashMap[complement], i] // 找到匹配，輸出索引對\n    No  → Step 4: 把 nums[i] 與 i 存入 hashMap // 若未找到，將當前數字加入表中\nEnd // 程式結束\n\nWe also need to add explanation for each line. Provide comment.\n\nAlso consider that we might need to indicate \"for i in 0..len-1\" but not actual code.\n\nLet's format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空哈希表 hashMap // 用於儲存已遍歷的數字及其索引  \n→ Step 2: 從頭到尾遍歷陣列 nums 以取得每個數字 nums[i] // 逐一檢查每個元素  \n→ Decision: 計算 complement = target - nums[i] 是否已存在於 hashMap? // 判斷是否已遇到能配對的數字  \n  Yes → Step 3: 回傳索引對 [hashMap[complement], i] // 找到匹配，輸出兩個索引  \n  No  → Step 4: 把 nums[i] 與 i 存入 hashMap // 若未找到，將當前數字及其索引加入表中，等待後續匹配  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef two_sum(nums, target):\n    \"\"\"\n    Find two indices i and j such that nums[i] + nums[j] == target.\n    Uses a hash map for O(n) time complexity.\n    \"\"\"\n    index_map = {}                      # number -> index\n    for i, num in enumerate(nums):      # 遍歷每個元素\n        complement = target - num       # 需要配對的數字\n        if complement in index_map:     # 已經遇到過配對數字\n            return [index_map[complement], i]\n        index_map[num] = i              # 將當前數字存入哈希表\n    return []                            # 根據題意不會到這裡\n\ndef main():\n    \"\"\"\n    讀取輸入、解析數據、執行兩數之和演算法，並輸出結果。\n    期望輸入格式：'nums = [2,7,11,15], target = 9'\n    \"\"\"\n    data = sys.stdin.read().strip()    # 讀取整個輸入\n    if not data:\n        return\n\n    # 使用正則表達式提取 nums 列表和 target 整數\n    pattern = re.compile(r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)')\n    match = pattern.search(data)\n    if not match:\n        # 若輸入格式不符，直接返回\n        return\n\n    nums_str, target_str = match.group(1), match.group(2)\n\n    # 用 ast.literal_eval 解析列表字面量，確保安全\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n\n    # 執行兩數之和演算法\n    result = two_sum(nums, target)\n\n    # 輸出答案，符合範例要求的格式\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,7,11,15], target = 9",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,4], target = 6",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3], target = 6",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode354.json",
    "problem_index_in_file": 0,
    "title": "Russian Doll Envelopes",
    "description_snippet": "You are given a 2D array of integers envelopes where envelopes[i] = [w_i, h_i] represents the width ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step. The problem is classic Russian Doll Envelopes: sort by width ascending, then height descending when widths equal, then longest increasing subsequence on heights.\n\nWe produce steps: Start, input array, sort, extract heights, run LIS via patience sorting or DP O(n log n). Return length.\n\nLet's produce in lines. Use arrow. Explanation after //.\n\nWe'll output each line as \"Step X: ...\" etc.\n\nLet's structure:\n\nStart\n→ Step 1: 接收輸入 2D 陣列 envelopes // 取得所有信封尺寸\n→ Step 2: 如果 envelopes 為空，回傳 0 // 空輸入處理\n→ Step 3: Sort envelopes by width ascending, and height descending when widths equal // 先排序，確保相同寬度時高度降序\n→ Step 4: 初始化 heights 列表 // 只取高度\n→ Step 5: 將每個 envelope 的高度加入 heights // 收集高度\n→ Step 6: 初始化 empty tails 列表 // 用於計算 LIS\n→ Step 7: For 每個 height in heights: // 逐個處理高度\n    → Decision: tails 是否為空? // 判斷\n        Yes → Append height to tails // 首項\n        No → Binary search in tails 找到第一個 >= height // LIS 的位置\n            → Decision: 位置等於 tails 長度?\n                Yes → Append height to tails // 新的長度\n                No → tails[位置] = height // 更新\n→ Step 8: 取得 tails 長度 // LIS 的長度\n→ End\n\nNeed to use arrow lines. Ensure each line includes \"虛擬碼步驟\" + space + \"// 解釋\". Use Start/End. Use arrow \"→\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收輸入 envelopes // 取得所有信封的寬度與高度\n→ Step 2: If envelopes is empty, return 0 // 空陣列直接回傳 0\n→ Step 3: Sort envelopes by width ascending, and height descending when widths equal // 先按寬度遞增排序，若寬度相同則按高度遞減，確保相同寬度不會影響 LIS\n→ Step 4: Initialize heights list // 用於只存高度值\n→ Step 5: For each envelope in envelopes, append envelope.height to heights // 收集排序後的高度序列\n→ Step 6: Initialize empty tails list // tails 用於計算長度最長上升子序列\n→ Step 7: For each h in heights\n    → Decision: tails is empty?\n        Yes → Append h to tails // 第一個高度直接加入\n        No → Binary search tails to find first element >= h // 找到更新位置\n            → Decision: index equals length of tails?\n                Yes → Append h to tails // 超過目前長度，擴充\n                No → Set tails[index] = h // 更新已有位置\n→ Step 8: Return length of tails // tails 的長度即為最大可疊入信封數量\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\nimport bisect\n\nclass Solution:\n    def maxEnvelopes(self, envelopes):\n        if not envelopes:\n            return 0\n        # 先按寬度升序，寬度相同則按高度降序\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        for _, h in envelopes:\n            idx = bisect.bisect_left(dp, h)\n            if idx == len(dp):\n                dp.append(h)\n            else:\n                dp[idx] = h\n        return len(dp)\n\ndef parse_input(text):\n    \"\"\"\n    從輸入文字中提取信封列表。\n    支援兩種格式：\n    1. envelopes = [[...], [...], ...]\n    2. 直接給出 [[...], [...], ...]\n    \"\"\"\n    text = text.strip()\n    # 若包含 'envelopes ='，取等號右邊\n    m = re.search(r'envelopes\\s*=\\s*(\\[.*\\])', text, re.DOTALL)\n    if m:\n        list_part = m.group(1)\n    else:\n        list_part = text\n    # 用 literal_eval 安全解析\n    return ast.literal_eval(list_part)\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n    envelopes = parse_input(raw_input)\n    sol = Solution()\n    result = sol.maxEnvelopes(envelopes)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "envelopes = [[5,4],[6,4],[6,7],[2,3]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "envelopes = [[1,1],[1,1],[1,1]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode746.json",
    "problem_index_in_file": 0,
    "title": "Min Cost Climbing Stairs",
    "description_snippet": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you p...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The problem: minimum cost to climb stairs with cost array, can start at index 0 or 1. Need DP solution. Let's outline steps:\n\nStart\n→ Input cost array\n→ Initialize dp array length cost+1 (or cost length) maybe with last two as 0\n→ For i from 2 to cost length:\n   dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])\n→ Answer = min(dp[n], dp[n-1])? Actually we can end at top which is after last step. We can finish from n-1 or n-2? Standard solution: dp[i] min cost to reach step i. Starting at step 0 or 1 means dp[0]=cost[0], dp[1]=cost[1]; For i>=2 dp[i]=cost[i]+min(dp[i-1],dp[i-2]); answer=min(dp[n-1],dp[n-2])? Wait top is after last step. So answer is min(dp[n-1],dp[n-2]) because we can finish at top from either last or second last step. Or we can extend dp size n+1 with dp[0]=dp[1]=0, for i=2..n: dp[i]=cost[i-1]+min(dp[i-1],dp[i-2]); answer dp[n]. That may be clearer. Let's produce virtual code using that. So:\n\ndp array size n+1\ndp[0] = 0\ndp[1] = 0\nfor i from 2 to n:\n    dp[i] = cost[i-1] + min(dp[i-1], dp[i-2])\nreturn dp[n]\n\nLet's produce step by step.\n\nNeed to use arrows.\n\nWill produce:\n\nStart\n→ Input: array cost of length n\n→ Initialize dp array of size n+1 // dp[i] min cost to reach step i\n→ dp[0] = 0 // starting before first step\n→ dp[1] = 0 // can also start at step 1\n→ Decision: If n <= 1? maybe handle edge cases; but skip\n→ For i from 2 to n:\n    dp[i] = cost[i-1] + min(dp[i-1], dp[i-2]) // compute min cost to reach step i\n→ Result = dp[n] // min cost to reach top\n→ Return Result\nEnd\n\nAlso we may want to show decision to handle if n==0 or 1. But okay.\n\nAdd comments each line.\n\nMake sure to include '→' arrow for steps inside loop. Use indentation for loop body.\n\nWe should produce as per format: each line \"虛擬碼步驟 // 解釋\". Provide arrows.\n\nOk. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input cost // 取得成本陣列 cost[0..n-1]  \n→ Initialize dp[0..n] // dp[i] 表示到達第 i 步（或樓頂）的最小成本  \n→ dp[0] = 0 // 從「起點」出發時已無成本  \n→ dp[1] = 0 // 亦可從第一或第二個台階開始，起始成本為 0  \n→ Decision: 如果 n <= 1? // 處理特殊情況 (若只有 0 或 1 個台階)  \n    Yes → Result = 0 // 直接跳到樓頂，成本為 0  \n    No  → Decision: 進行主迴圈 // 其他情況需要計算  \n        → For i from 2 to n: // 依次計算每個步驟的最小成本  \n            dp[i] = cost[i-1] + min(dp[i-1], dp[i-2]) // 從前一步或前兩步跳至 i，取較小成本  \n→ Result = dp[n] // dp[n] 為到達樓頂（即超過最後一個台階）的最小成本  \n→ Return Result // 將最小成本輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def minCostClimbingStairs(self, cost):\n        n = len(cost)\n        if n == 0:\n            return 0\n        if n == 1:\n            return cost[0]\n        dp = [0] * n\n        dp[0], dp[1] = cost[0], cost[1]\n        for i in range(2, n):\n            dp[i] = cost[i] + min(dp[i-1], dp[i-2])\n        return min(dp[-1], dp[-2])\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit()\n    try:\n        cost_list = ast.literal_eval(input_data)\n    except Exception:\n        # If the input is not a valid Python list, exit gracefully\n        sys.exit()\n    result = Solution().minCostClimbingStairs(cost_list)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[10,15,20]",
          "expected_output": "15",
          "success": true,
          "output": "15"
        },
        {
          "example_index": 1,
          "input": "[1,100,1,1,1,100,1,1,100,1]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode630.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule III",
    "description_snippet": "There are n different online courses numbered from 1 to n. You are given an array courses where cour...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code outline for the problem of scheduling maximum courses. Classic greedy with priority queue. We need to produce steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and Decision.\n\nWe should write a high-level algorithm: Sort courses by lastDay, iterate, maintain currentTime and max-heap of durations. For each course, add duration, push into heap. If currentTime > lastDay, pop largest duration, subtract. At end return heap size. So need to produce steps line by line.\n\nUse Start, End. Use arrows. Provide explanation after each line.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: Sort courses by lastDay ascending // 先根據截至日期排序\n\nThen loop.\n\nWe can use Decision for condition inside loop.\n\nWe'll show adding, checking, possibly removing.\n\nLet's produce maybe ~15-20 lines. Ensure each line has code step and comment.\n\nAlso show use of heap: push, pop largest.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort courses by lastDay ascending // 先將課程依截至日期由小到大排列，確保先完成最早截止的課程  \n→ Step 2: 初始化 currentTime = 0 // 追蹤已使用的總天數  \n→ Step 3: 初始化 maxHeap = 空 // 儲存已選課程的持續天數，方便快速取出最長的課程  \n→ Step 4: 對於每個課程 (duration, lastDay) 在排序後的 courses 集合中執行  \n    → Step 4a: currentTime += duration // 將此課程的持續天數加入已使用天數  \n    → Step 4b: maxHeap.push(duration) // 將此課程加入堆中  \n    → Decision: currentTime > lastDay? // 檢查是否超過該課程的截至日期  \n        Yes → Step 4c: longest = maxHeap.pop() // 取出目前堆中最長的課程天數  \n            → Step 4d: currentTime -= longest // 從已使用天數中扣除最長課程，放棄它以符合截至日期  \n        No  →  // 目前仍在截至日期內，無需任何操作  \n→ Step 5: End of loop // 所有課程已處理完畢  \n→ Step 6: Return maxHeap.size() // 堆中的元素數即為能選修的課程最大數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass Solution:\n    def scheduleCourse(self, courses):\n        \"\"\"\n        計算最多能修讀的課程數量。\n        方法：先依照課程的截止日期排序，逐一嘗試加入課程。\n        若加入後總時間超過當前課程的截止日期，則把已加入課程中最長的課程移除。\n        \"\"\"\n        # 依截止日期升序排序\n        courses.sort(key=lambda x: x[1])\n\n        total_time = 0            # 已使用的總天數\n        max_heap = []             # 儲存已加入課程的持續天數（使用負值做最大堆）\n\n        for duration, last_day in courses:\n            # 加入該課程\n            heapq.heappush(max_heap, -duration)\n            total_time += duration\n\n            # 若總時間超過截止日期，移除最長的已加入課程\n            if total_time > last_day:\n                longest = -heapq.heappop(max_heap)  # 取回最長課程的正值\n                total_time -= longest\n\n        # 堆中的元素數即為能修讀的課程數量\n        return len(max_heap)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 支援兩種輸入格式：1) courses = [[...]]  2) [[...]]\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    try:\n        courses = ast.literal_eval(expr)\n    except Exception:\n        print(\"0\")\n        sys.exit()\n\n    # 確保輸入是列表\n    if not isinstance(courses, list):\n        print(\"0\")\n        sys.exit()\n\n    sol = Solution()\n    result = sol.scheduleCourse(courses)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "courses = [[1,2]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "courses = [[3,2],[4,3]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode233.json",
    "problem_index_in_file": 0,
    "title": "Number of Digit One",
    "description_snippet": "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to count number of digit '1' appearing in all numbers 0..n inclusive. Classic problem: count ones.\n\nWe produce virtual code lines with arrows, decision, start end.\n\nWe need step-by-step algorithm. Outline:\n\nStart\n→ Step 1: Initialize count = 0\n→ Step 2: For each position factor = 1; while factor <= n; factor *= 10\n    -> Step 3: lower = n % factor\n    -> Step 4: current = (n / factor) % 10\n    -> Step 5: higher = n / (factor * 10)\n    -> Decision: If current == 0? \n        Yes → count += higher * factor\n        No  → Decision: If current == 1?\n            Yes → count += higher * factor + lower + 1\n            No  → count += (higher + 1) * factor\n→ End\n→ Step 6: Output count\n\nMake sure each line has explanation.\n\nAlso include the loop steps. The arrow and indentation: Use indentation for decisions inside loops.\n\nNeed to use virtual arrows: \"→\", \"Yes →\", \"No →\".\n\nWe'll produce each step line.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: n ← input integer // 取得輸入的整數 n\n→ Step 2: count ← 0 // 初始化計數為 0\n→ Step 3: factor ← 1 // 從最低位開始，factor 表示 10 的指數\n→ Decision: 是否存在更高位? (factor <= n) // 判斷是否還有位數要處理\n    Yes → Step 4: lower ← n mod factor // 低於當前位的數字\n    Yes → Step 5: current ← (n / factor) mod 10 // 當前位的數字\n    Yes → Step 6: higher ← n / (factor * 10) // 高於當前位的數字\n    Yes → Decision: current == 0?\n        Yes → Step 7: count ← count + higher * factor // 若當前位為 0，1 的個數是 higher * factor\n        No  → Decision: current == 1?\n            Yes → Step 8: count ← count + higher * factor + lower + 1 // 若為 1，加入 higher*factor + lower +1\n            No  → Step 9: count ← count + (higher + 1) * factor // 若 >1，加入 (higher+1)*factor\n    Yes → Step 10: factor ← factor * 10 // 移到下一位\n→ No  → End // 迴圈結束\n→ Step 11: output count // 輸出總數\n\nMake sure each line with explanation. Also we might need to maintain indentation: Use tabs or spaces.\n\nMake sure we include arrow at each line: \"→\". For decisions we use \"Decision:\" and \"Yes →\", \"No →\".\n\nLet's write final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: n ← input integer // 取得輸入的整數 n\n→ Step 2: count ← 0 // 初始化計數為 0\n→ Step 3: factor ← 1 // 從最低位開始，factor 表示 10 的指數\n→ Decision: factor <= n? // 判斷是否還有更高位需要處理\n    Yes → Step 4: lower ← n mod factor // 低於當前位的數字\n    Yes → Step 5: current ← (n / factor) mod 10 // 當前位的數字\n    Yes → Step 6: higher ← n / (factor * 10) // 高於當前位的數字\n    Yes → Decision: current == 0? // 判斷當前位是否為 0\n        Yes → Step 7: count ← count + higher * factor // 0 時 1 的個數為 higher*factor\n        No  → Decision: current == 1? // 判斷當前位是否為 1\n            Yes → Step 8: count ← count + higher * factor + lower + 1 // 1 時加 higher*factor + lower + 1\n            No  → Step 9: count ← count + (higher + 1) * factor // >1 時加 (higher+1)*factor\n    Yes → Step 10: factor ← factor * 10 // 移至下一位\n→ No  → End // 所有位數處理完畢\n→ Step 11: output count // 輸出 0~n 之間所有數字中 1 的總數量",
      "generated_code": "import sys\nimport re\n\ndef count_digit_one(n: int) -> int:\n    \"\"\"\n    計算 0 到 n（含 n）之間所有整數中數字 1 出現的總次數。\n    \"\"\"\n    if n <= 0:\n        return 0\n    count = 0\n    factor = 1  # 1、10、100...\n    while factor <= n:\n        lower = n % factor                      # 低於當前位的數字\n        current = (n // factor) % 10            # 當前位的數字\n        higher = n // (factor * 10)             # 高於當前位的數字\n\n        if current == 0:\n            count += higher * factor\n        elif current == 1:\n            count += higher * factor + lower + 1\n        else:  # current > 1\n            count += (higher + 1) * factor\n\n        factor *= 10\n\n    return count\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取一個整數，計算並輸出答案。\n    支援輸入形式如「n = 13」或「13」。\n    \"\"\"\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = count_digit_one(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode299.json",
    "problem_index_in_file": 0,
    "title": "Bulls and Cows",
    "description_snippet": "You are playing the Bulls and Cows game with your friend.\n\nYou write down a secret number and ask yo...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for Bulls and Cows. Provide line by line. Steps: Start, input secret, guess, compute bulls, compute cows. Use arrays for counts of digits 0-9 for non-bull positions. Then compute cows as sum of min(count_secret[d], count_guess[d]) for all digits. Output format. End.\n\nNeed to ensure the format with arrows, decisions, etc. Use \"Decision:\" maybe for loops? But we can present algorithm.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 bulls = 0, cows = 0 // 設定牛和母牛計數\n→ Step 2: 創建陣列 secretCount[10] 和 guessCount[10] 並設為 0 // 用於統計非牛的數字頻次\n→ Step 3: For i from 0 to len(secret)-1 // 遍歷每個位元\n  Decision: secret[i] == guess[i]? // 判斷是否為牛\n   Yes → bulls += 1 // 牛數加一\n   No → \n    secretCount[secret[i]] += 1 // 統計非牛數字\n    guessCount[guess[i]] += 1 // 統計非牛數字\n→ Step 4: For d from 0 to 9 // 計算母牛\n  cows += min(secretCount[d], guessCount[d]) // 取兩邊頻次較小值\n→ Step 5: 組合輸出 hint = bulls + 'A' + cows + 'B' // 格式化字串\n→ End // 程式執行結束\n\nNeed to include // 解釋 per line. Also include arrows for loops? The example uses indentation. We'll mimic.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 bulls = 0, cows = 0 // 設定牛與母牛的計數器  \n→ Step 2: 建立兩個長度為 10 的陣列 secretCount, guessCount，並全部設為 0 // 用來統計非牛位置的數字頻次  \n→ Step 3: For i from 0 to len(secret)-1 // 逐位檢查 secret 與 guess  \n  Decision: secret[i] == guess[i]? // 判斷此位是否為牛  \n   Yes → bulls += 1 // 若是牛，牛數加一  \n   No →  \n    secretCount[ secret[i] ] += 1 // 非牛位置的 secret 數字統計  \n    guessCount[  guess[i] ] += 1 // 非牛位置的 guess 數字統計  \n→ Step 4: For d from 0 to 9 // 計算母牛數量  \n  cows += min( secretCount[d], guessCount[d] ) // 取兩邊頻次中較小的作為母牛  \n→ Step 5: 設定 hint = bulls + 'A' + cows + 'B' // 將結果格式化為 xAyB  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef get_hint(secret: str, guess: str) -> str:\n    \"\"\"計算 Bulls 與 Cows 並以 xAyB 格式回傳。\"\"\"\n    bulls = 0\n    cows = 0\n\n    # 使用 Counter 先統計所有位元的頻次\n    secret_count = Counter(secret)\n    guess_count = Counter(guess)\n\n    # 先算 Bulls，並將已經算過的位元減少頻次\n    for s, g in zip(secret, guess):\n        if s == g:\n            bulls += 1\n            secret_count[s] -= 1\n            guess_count[g] -= 1\n\n    # 再算 Cows：對於每個數字，取兩邊剩餘頻次的較小值\n    for digit in guess_count:\n        if digit in secret_count:\n            cows += min(secret_count[digit], guess_count[digit])\n\n    return f\"{bulls}A{cows}B\"\n\ndef parse_input(data: str):\n    \"\"\"\n    從標準輸入中擷取 secret 與 guess。\n    預期格式：secret = \"1807\", guess = \"7810\"\n    \"\"\"\n    pattern = r'secret\\s*=\\s*\"([^\"]+)\"\\s*,\\s*guess\\s*=\\s*\"([^\"]+)\"'\n    match = re.search(pattern, data)\n    if match:\n        return match.group(1), match.group(2)\n\n    # 若格式不符，試著按行讀取\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    raise ValueError(\"輸入格式不正確，無法解析 secret 與 guess。\")\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_data = sys.stdin.read()\n    secret_str, guess_str = parse_input(raw_data)\n\n    # 計算並輸出結果\n    result = get_hint(secret_str, guess_str)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "secret = \"1807\", guess = \"7810\"",
          "expected_output": "\"1A3B\"",
          "success": true,
          "output": "1A3B"
        },
        {
          "example_index": 1,
          "input": "secret = \"1123\", guess = \"0111\"",
          "expected_output": "\"1A1B\"",
          "success": true,
          "output": "1A1B"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode486.json",
    "problem_index_in_file": 0,
    "title": "Predict the Winner",
    "description_snippet": "You are given an integer array nums. Two players are playing a game with this array: player 1 and pl...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for determining if player1 can win optimal play. Classic problem \"Predict the Winner\". We need dynamic programming: DP[i][j] = max score difference player can achieve over opponent from subarray i..j. Then if DP[0][n-1] >=0 return true.\n\nWe need virtual code step-by-step with arrows, decision, etc. Each line with explanation. Should not output actual code. We'll produce steps: Start, initialize n, create DP array, fill base cases, loop length from 1 to n, compute DP[i][j] as max(nums[i]-DP[i+1][j], nums[j]-DP[i][j-1]). After fill, check DP[0][n-1] >= 0. Then output true/false. End.\n\nWe need line by line with explanation. Use arrow syntax. Example: Start // start. Then → Step 1: read array. But we should include each step. Use \"Decision:\" for conditional. We'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 獲得數字序列\n→ Step 2: 計算 n = nums.length // 取得陣列長度\n→ Step 3: 建立 2D 陣列 DP[n][n] // 用於儲存子問題結果\n→ Decision: 如果 n == 0? // 判斷陣列是否空\n    Yes → Step 4: 回傳 true // 空陣列玩家1自動贏\n    No  →\n→ Step 5: 初始化基礎條件 for i in 0..n-1: DP[i][i] = nums[i] // 子陣列只有一個元素時差值\n→ Step 6: 從長度 2 開始填表\n    → For len in 2..n:\n        → For i in 0..n-len:\n            j = i+len-1\n            → Step 7: 計算 pickLeft = nums[i] - DP[i+1][j]\n            → Step 8: 計算 pickRight = nums[j] - DP[i][j-1]\n            → Step 9: DP[i][j] = max(pickLeft, pickRight) // 選擇可使差值最大化\n→ Step 10: result = DP[0][n-1] >= 0 // 玩家1得分是否不輸\n→ Decision: result?\n    Yes → Step 11: 回傳 true // 玩家1能勝或平手\n    No  → Step 12: 回傳 false // 玩家1輸\nEnd // 程式執行結束\n\nWe need each line with explanation. Use arrows. Ensure no code. Provide in Chinese. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 獲得要比賽的數字序列  \n→ Step 2: 計算 n = nums.length // 取得陣列長度  \n→ Step 3: 建立 2D 陣列 DP[n][n] // 用來儲存子陣列 i..j 的「玩家1比玩家2多得分」  \n→ Decision: 如果 n == 0? // 判斷陣列是否為空  \n Yes → Step 4: 回傳 true // 空陣列玩家1自動勝出  \n No  →  \n→ Step 5: 初始化基礎條件 for i in 0..n-1: DP[i][i] = nums[i] // 子陣列只有一個數字時，玩家1得分差即為該數字  \n→ Step 6: 從長度 2 開始填表  \n → For len in 2..n: // 逐步考慮更長的子陣列  \n  → For i in 0..n-len: // 確定子陣列起點  \n   j = i + len - 1 // 子陣列終點  \n   → Step 7: pickLeft = nums[i] - DP[i+1][j] // 選左端，後面子陣列由對手決定  \n   → Step 8: pickRight = nums[j] - DP[i][j-1] // 選右端，後面子陣列由對手決定  \n   → Step 9: DP[i][j] = max(pickLeft, pickRight) // 選擇能使玩家1比玩家2多得分最大化的手段  \n→ Step 10: result = DP[0][n-1] >= 0 // 判斷整個陣列時玩家1的得分差是否為非負  \n→ Decision: result? // 判斷玩家1是否能贏  \n Yes → Step 11: 回傳 true // 玩家1贏或平手，仍視為勝者  \n No  → Step 12: 回傳 false // 玩家1輸  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def predictTheWinner(self, nums):\n        n = len(nums)\n        if n == 0:\n            return True\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                pick_left = nums[i] - dp[i + 1][j]\n                pick_right = nums[j] - dp[i][j - 1]\n                dp[i][j] = max(pick_left, pick_right)\n        return dp[0][n - 1] >= 0\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"true\")\n        sys.exit(0)\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        nums = []\n    else:\n        nums = ast.literal_eval(data[start:end + 1])\n    sol = Solution()\n    result = sol.predictTheWinner(nums)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,2]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,233,7]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode338.json",
    "problem_index_in_file": 0,
    "title": "Counting Bits",
    "description_snippet": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. The user wants algorithm: For i from 0 to n, count bits set in i and store in ans[i]. Virtual code style with arrow. Provide line by line.\n\nLet's produce steps:\n\nStart\n\n→ Input n\n\n→ Initialize ans array size n+1\n\n→ For i from 0 to n:\n\n    → Compute count = number of 1 bits in i\n\n    → ans[i] = count\n\n→ Return ans\n\n→ End\n\nBut must follow decision/arrow style. Could do loop.\n\nWe can express loop as Decision: while i <= n?\n\nWe need to use virtual arrows. Provide explanation after each line.\n\nLet's craft.\n\nWe'll use variable i.\n\nStart // 程式開始執行\n\n→ Input n // 取得輸入的整數\n\n→ Declare ans[0..n] // 初始化長度為 n+1 的陣列\n\n→ Set i = 0 // 初始化循環計數器\n\n→ Decision: i <= n? // 判斷是否還有數字要處理\n\n    Yes → Set count = 0 // 設定位元數計數器\n\n    → Set temp = i // 用 temp 來操作\n\n    → Decision: temp > 0? // 只在 temp 大於 0 時執行位元計算\n\n        Yes → Decision: temp mod 2 == 1? // 檢查最低位是否為 1\n\n            Yes → count = count + 1 // 如果為 1，遞增計數\n\n            No  → // 不改變計數\n\n        No → // 當 temp 為 0 時結束內部迴圈\n\n    → ans[i] = count // 把計數存入陣列\n\n    → i = i + 1 // 移到下一個數\n\n    → Go back to Decision: i <= n? // 重新檢查\n\n    No → // 當 i > n 時結束循環\n\n→ Return ans // 回傳結果陣列\n\nEnd // 程式執行結束\n\nBut we should keep consistent arrow style: \"→\" for next line. Decision lines start with \"Decision:\".\n\nWe need to ensure each line includes explanation after \"//\".\n\nWe also need to include indent or not? Example shows indent via spaces. We'll mimic.\n\nWe need to use \"Yes →\" and \"No →\" within Decision block.\n\nAlso need to include internal decision for temp > 0? Could do loop using while.\n\nMaybe simpler: Use Decision: temp > 0? Yes -> ...; No -> ...; but we need to loop until temp==0. Might use \"Loop\" concept but not defined.\n\nAlternatively use Decision: temp > 0? and inside recursively compute. But okay.\n\nSimpler: Use Decision: i <= n? with Yes path containing inner loop via while? Could use \"While temp > 0?\" as separate Decision with Yes loop.\n\nBetter to use nested Decision and recursion: But maybe we can use \"While temp > 0?\".\n\nBut spec only includes Decision. We'll use Decision with loop via \"→\" lines; after No, go back to loop.\n\nLet's produce code:\n\nStart // 程式開始執行\n→ Input n // 取得輸入的整數\n→ Declare ans[0..n] // 初始化長度為 n+1 的陣列\n→ Set i = 0 // 初始化循環計數器\n→ Decision: i <= n? // 判斷是否還有數字要處理\n    Yes → Set count = 0 // 設定位元數計數器\n    → Set temp = i // 用 temp 來操作\n    → Decision: temp > 0? // 若 temp 大於 0，進行位元計算\n        Yes → Decision: temp mod 2 == 1? // 檢查最低位是否為 1\n            Yes → count = count + 1 // 若為 1，遞增計數\n            No  → // 未改變計數\n        No → // temp == 0，結束位元計算\n    → ans[i] = count // 把計數存入陣列\n    → i = i + 1 // 移到下一個數\n    → Go back to Decision: i <= n? // 重新檢查\n    No → // i > n，結束循環\n→ Return ans // 回傳結果陣列\nEnd // 程式執行結束\n\nBut need to include \"Go back\" maybe not part of spec. Might just use arrow to go back to Decision. Eg: → Decision: i <= n? again.\n\nBetter to show after increment i, we again jump to Decision.\n\nWill include \"→ Decision: i <= n?\" again.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Input n // 取得輸入的整數\n→ Declare ans[0..n] // 初始化長度為 n+1 的陣列\n→ Set i = 0 // 初始化循環計數器\n→ Decision: i <= n? // 判斷是否還有數字要處理\n    Yes → Set count = 0 // 設定位元數計數器\n    → Set temp = i // 用 temp 來操作\n    → Decision: temp > 0? // 若 temp 大於 0，進行位元計算\n        Yes → Decision: temp mod 2 == 1? // 檢查最低位是否為 1\n            Yes → count = count + 1 // 若為 1，遞增計數\n            No  → // 未改變計數\n        No → // temp == 0，結束位元計算\n    → ans[i] = count // 把計數存入陣列\n    → i = i + 1 // 移到下一個數\n    → Decision: i <= n? // 重新檢查循環條件\n    No  → // i > n，結束循環\n→ Return ans // 回傳結果陣列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countBits(self, n: int):\n        # 初始化長度為 n+1 的陣列\n        res = [0] * (n + 1)\n        # 從 1 開始，利用已計算的結果快速得到後續值\n        for i in range(1, n + 1):\n            res[i] = res[i >> 1] + (i & 1)\n        return res\n\ndef main():\n    # 從標準輸入讀取資料\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 解析出整數 n，支援格式類似 'n = 5' 或 '5'\n    match = re.search(r'(\\d+)', data)\n    if not match:\n        return\n    n = int(match.group(1))\n\n    ans = Solution().countBits(n)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,1]",
          "success": true,
          "output": "[0, 1, 1]"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[0,1,1,2,1,2]",
          "success": true,
          "output": "[0, 1, 1, 2, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode757.json",
    "problem_index_in_file": 0,
    "title": "Set Intersection Size At Least Two",
    "description_snippet": "You are given a 2D integer array intervals where intervals[i] = [starti, endi] represents all the in...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: given intervals, need min size of containing set where each interval has at least two integers. This is similar to LeetCode 757? Actually the problem is \"Minimum Number of Points to Cover Intervals\" but with at least 2 points per interval. Equivalent to \"Minimum Number of Points that can cover all intervals with at least two points\" typical greedy: sort by end, then maintain last two chosen points.\n\nSolution: sort intervals by end ascending. Maintain last two chosen points, initially set to -inf. For each interval [l, r], if last point < l => need 2 new points: choose r-1, r (or r-1 and r). else if last point < l+1 => need 1 new point: choose r. else already have two points.\n\nReturn count.\n\nSo produce virtual code lines. We'll write steps accordingly.\n\nWe need \"虛擬碼步驟\" and explanation comment.\n\nUse Start, End, Decision.\n\nLet's produce:\n\nStart\n→ Step 1: Sort intervals by end ascending // 排序\n→ Step 2: 初始化 count = 0, last1 = -∞, last2 = -∞ // 記錄已選點\n→ For each interval [l, r] in intervals // 遍歷\n    → Decision: if last2 < l? // 兩個已選點都小於起點\n        Yes → Step 3: last1 = r-1; last2 = r; count += 2 // 選 r-1, r\n    → No → Decision: if last1 < l? // 只有一個點在區間內\n        Yes → Step 4: last1 = last2; last2 = r; count += 1 // 選 r\n    → No → // 兩點都已在區間內，無需操作\nEnd\n\nNeed to ensure virtual code lines with arrows and decisions properly indented. Provide comments after each line.\n\nWe need to ensure each line has \"虛擬碼步驟 [space] // 解釋\". Use arrow \"→\" for steps, and \"Decision:\" for decisions, and \"Yes →\" \"No →\" accordingly.\n\nAlso need a loop structure: maybe \"For each interval in intervals:\" but can be a decision within. Provide loop arrow: \"→ For each interval [l, r] in intervals:\" with comment. Then inside decisions.\n\nLet's write.\n\nCheck formatting: \"Start // 程式開始執行\". Then arrow lines.\n\nWe should keep consistent.\n\nAlso need to mention \"Initialize count, last1, last2\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort intervals by their end value ascending // 先按結束點升序排列  \n→ Step 2: Initialize count = 0, last1 = -∞, last2 = -∞ // 記錄已選取的兩個最靠右的點  \n→ For each interval [l, r] in intervals: // 遍歷所有區間  \n  Decision: last2 < l? // 兩個已選點都落在區間左側之外  \n   Yes → Step 3: last1 = r - 1; last2 = r; count += 2 // 選取 r-1 和 r 作為新點  \n   No → Decision: last1 < l? // 只有一個點落在區間內  \n    Yes → Step 4: last1 = last2; last2 = r; count += 1 // 只需再選取 r  \n    No → // 已經有兩個點在區間內，無需新增點  \nEnd // 程式執行結束；返回 count 為最小包含集合大小",
      "generated_code": "import sys\nimport ast\n\ndef min_containing_set(intervals):\n    # Sort by end ascending, and for same end, by start descending\n    intervals.sort(key=lambda x: (x[1], -x[0]))\n    res = []\n    last = second_last = -10**9  # far left sentinel\n    for start, end in intervals:\n        count = 0\n        if second_last >= start and second_last <= end:\n            count += 1\n        if last >= start and last <= end:\n            count += 1\n        if count >= 2:\n            continue\n        elif count == 1:\n            # need one more point; choose the rightmost not already taken\n            res.append(end)\n            second_last, last = last, end\n        else:\n            # need two points; choose end-1 and end\n            res.extend([end - 1, end])\n            second_last, last = end - 1, end\n    return len(res)\n\ndef parse_input(s: str):\n    \"\"\"Parse a line like 'intervals = [[1,3],[3,7],[8,9]]'.\"\"\"\n    if '=' in s:\n        _, expr = s.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = s.strip()\n    return ast.literal_eval(expr)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    intervals = parse_input(data)\n    result = min_containing_set(intervals)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[3,7],[8,9]]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,3],[1,4],[2,5],[3,5]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,2],[2,3],[2,4],[4,5]]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode647.json",
    "problem_index_in_file": 0,
    "title": "Palindromic Substrings",
    "description_snippet": "Given a string s, return the number of palindromic substrings in it.\n\nA string is a palindrome when ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code for algorithm: count palindromic substrings in string s. Standard approach: expand around centers. Use nested loops to count. Complexity O(n^2). So steps: Start, input s, define count, loop i from 0 to len-1, for each center expand odd and even. Increment count. End.\n\nWe must adhere to format: each line: \"虛擬碼步驟 // 解釋\". Use arrows. For loops we can write \"for i in 0..len-1:\" etc. Use decision. Use Step labels.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 從使用者處取得待檢測的字串  \n→ Step 2: 定義整數變數 count = 0 // 用於累計回文子字串數量  \n→ Step 3: 取得字串長度 n = s.length // 用於迴圈邏輯  \n→ Decision: n 是否大於 0? // 若字串為空則直接結束  \n    Yes →  \n        → Step 4: for i = 0 to n-1 // 以每個位置為中心進行擴展  \n            → Step 5: ExpandAroundCenter(i, i) // 處理奇數長度回文  \n            → Step 6: ExpandAroundCenter(i, i+1) // 處理偶數長度回文  \n    No →  \n        → Step 7: 輸出 count // 直接輸出 0  \nEnd // 程式執行結束  \n\n// 以下為擴展函式的虛擬碼（在主流程內部或單獨定義）  \n→ Step 8: 定義函式 ExpandAroundCenter(left, right) // 將中心左右延伸並統計  \n    → Decision: left ≥ 0 且 right < n 且 s[left] == s[right]? // 是否仍為回文  \n        Yes →  \n            → Step 9: count = count + 1 // 有效回文子字串，累加  \n            → Step 10: left = left - 1 // 向左移動  \n            → Step 11: right = right + 1 // 向右移動  \n            → Step 12: 跳回 Step 8 的 Decision // 繼續擴展  \n        No →  \n            → Step 13: 返回 // 擴展結束，返回到主流程",
      "generated_code": "import sys\n\nclass Solution:\n    def countSubstrings(self, s: str) -> int:\n        n = len(s)\n        count = 0\n\n        def expand(left: int, right: int) -> None:\n            nonlocal count\n            while left >= 0 and right < n and s[left] == s[right]:\n                count += 1\n                left -= 1\n                right += 1\n\n        for i in range(n):\n            expand(i, i)       # odd length palindromes\n            expand(i, i + 1)   # even length palindromes\n\n        return count\n\ndef parse_input(line: str) -> str:\n    \"\"\"\n    Extract the string value from input line.\n    Accepts formats like:\n        s = \"abc\"\n        \"abc\"\n        abc\n    \"\"\"\n    line = line.strip()\n    # If line contains quotes, take the content inside the first pair of quotes\n    if '\"' in line:\n        first = line.find('\"')\n        last = line.rfind('\"')\n        if first != -1 and last != -1 and last > first:\n            return line[first + 1:last]\n    # If no quotes, assume the whole line is the string\n    return line\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # Take the first non-empty line as the input string\n    for line in data:\n        if line.strip():\n            s = parse_input(line)\n            break\n    else:\n        s = \"\"\n\n    sol = Solution()\n    result = sol.countSubstrings(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abc\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"aaa\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode846.json",
    "problem_index_in_file": 0,
    "title": "leetcode846_problem_1",
    "description_snippet": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Problem: given hand array and groupSize, check if can form groups of consecutive cards of size groupSize. Classic LeetCode 846. Steps: count frequencies, sort keys, for each key from smallest to largest, if count >0, subtract count from next groupSize-1 consecutive values, ensure enough. Return true.\n\nWe need to output virtual code line by line with comments after //.\n\nWe need to use virtual code arrow style. Let's produce start, then steps.\n\nInclude decision blocks.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化頻率表 freq ← 空映射 // 用於統計每張牌出現的次數\n→ Step 2: 對於每張牌 value in hand:\n    → Step 2a: freq[value] ← freq.get(value, 0) + 1 // 更新頻率\n→ Step 3: 取得所有不同牌值並排序 ascending → sorted_keys ← 排序(freq.keys())\n→ Decision: 如果 groupSize 大於 hand.length? // 檢查是否可能\n    Yes → Step 3a: Return False // 牌數不足\n    No → Continue\n→ Step 4: 對於 key in sorted_keys:\n    → Decision: 如果 freq[key] 為 0? // 已被使用\n        Yes → Continue to next key // 跳過\n        No →\n            → Step 5: 將 count ← freq[key] // 此組需要的牌數\n            → Step 6: 對 i 從 1 到 groupSize-1:\n                → Step 6a: next_key ← key + i\n                → Decision: 如果 freq[next_key] < count? // 不足\n                    Yes → Step 6b: Return False // 不能組成連續牌\n                    No →\n                        → Step 6c: freq[next_key] ← freq[next_key] - count // 消耗牌\n            → Step 7: freq[key] ← 0 // 完成該組\n→ Step 8: Return True // 所有牌都能組成合法組\nEnd // 程式執行結束\n\nNeed to ensure arrow formatting exactly: \"→\" and indent maybe. Provide each line. Also use \"Decision:\" lines with Yes → and No →. Good.\n\nLet's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: freq ← 空映射 // 用於統計每張牌出現的次數\n→ Step 2: 對於每張牌 value in hand:\n    → Step 2a: freq[value] ← freq.get(value, 0) + 1 // 更新頻率\n→ Step 3: sorted_keys ← 排序(freq.keys()) // 取得所有不同牌值並升序排列\n→ Decision: 如果 groupSize > hand.length? // 檢查是否可能\n    Yes → Step 3a: Return False // 牌數不足以形成任何組\n    No  → Continue // 繼續下一步\n→ Step 4: 對於 key in sorted_keys:\n    → Decision: 如果 freq[key] 為 0? // 牌已被消耗\n        Yes → Continue // 跳過此鍵\n        No →\n            → Step 5: count ← freq[key] // 需要消耗的牌數\n            → Step 6: 對 i 從 1 到 groupSize-1:\n                → Step 6a: next_key ← key + i\n                → Decision: 如果 freq[next_key] < count? // 連續牌不足\n                    Yes → Step 6b: Return False // 無法完成此組\n                    No →\n                        → Step 6c: freq[next_key] ← freq[next_key] - count // 消耗連續牌\n            → Step 7: freq[key] ← 0 // 此組已完成\n→ Step 8: Return True // 所有牌都能組成合法組\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isNStraightHand(self, hand, groupSize):\n        # 如果總牌數不能被 groupSize 整除，直接不可能組成組\n        if len(hand) % groupSize != 0:\n            return False\n\n        # 統計每張牌出現的次數\n        count = Counter(hand)\n\n        # 依牌值從小到大排序，逐個檢查是否能消耗成連續組\n        for card in sorted(count):\n            freq = count[card]\n            if freq == 0:\n                continue  # 已經被消耗完的牌跳過\n            # 檢查從 card 開始的 groupSize 張牌是否都有足夠數量\n            for i in range(card, card + groupSize):\n                if count[i] < freq:\n                    return False  # 不足以完成這組\n                count[i] -= freq  # 消耗這張牌\n        return True  # 所有牌都能完整組成合法組\n\ndef main():\n    data = sys.stdin.read()\n\n    # 從輸入文字中提取 hand 列表和 groupSize 整數\n    hand_match = re.search(r'hand\\s*=\\s*\\[(.*?)\\]', data, re.S)\n    group_match = re.search(r'groupSize\\s*=\\s*(\\d+)', data)\n    if not hand_match or not group_match:\n        print(False)\n        return\n\n    hand_str = hand_match.group(1)\n    hand = [int(x) for x in hand_str.split(',') if x.strip() != '']\n    groupSize = int(group_match.group(1))\n\n    # 執行判斷並輸出結果\n    sol = Solution()\n    result = sol.isNStraightHand(hand, groupSize)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
          "expected_output": "True",
          "success": true,
          "output": "True"
        },
        {
          "example_index": 1,
          "input": "hand = [1,2,3,4,5], groupSize = 4",
          "expected_output": "False",
          "success": true,
          "output": "False"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode88.json",
    "problem_index_in_file": 0,
    "title": "Merge Sorted Array",
    "description_snippet": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanations. The requirement: start, steps, decision arrows etc. Use virtual code with \"→\". Provide step-by-step algorithm for merging two sorted arrays into nums1.\n\nWe need to produce lines like:\n\nStart // start\n→ Step 1: initialize pointers i = m-1, j = n-1, k = m+n-1 // etc\n\nWe must not output actual code. Use virtual steps.\n\nWe need to include decision: If i >= 0 etc.\n\nWe need to output each line.\n\nWe need to incorporate the typical merge algorithm starting from end of arrays to avoid overwrite.\n\nWe need to output explanation after each line.\n\nOk.\n\nWe need to produce each line with \"虛擬碼步驟\" and then // explanation.\n\nWe can use arrow for each step. Use \"Decision:\" with Yes→/No→.\n\nMake sure to format exactly as required.\n\nLet's produce.\n\nWe will include Start, End.\n\nWe should ensure that we keep the same format: \"Start // 程式開始執行\" etc.\n\nThe lines:\n\nStart // 程式開始執行\n→ Step 1: 設定指標 i 為 m-1, j 為 n-1, k 為 m+n-1 // 初始化三個指標，從各陣列末尾開始比較\n→ Decision: i >= 0 ？ // 檢查 nums1 還有未處理的元素\n    Yes → Step 2: 如果 nums1[i] > nums2[j]？ // 比較兩個指標所指元素大小\n        Yes → Step 3: nums1[k] = nums1[i]；i--，k-- // 把 nums1 中較大的元素放到最後\n        No  → Step 4: nums1[k] = nums2[j]；j--，k-- // 把 nums2 中較大的元素放到最後\n    No  → Decision: j >= 0 ？ // 如果 nums1 已經沒有元素，檢查 nums2 是否還有\n        Yes → Step 5: nums1[k] = nums2[j]；j--，k-- // 把剩下的 nums2 元素填入\n        No  → End // 兩個陣列都處理完畢，結束\n\nBut we must incorporate loops: Actually it's a while loop. Use Decision that repeats.\n\nBut we need step lines for loop. We can use Decision: (i >= 0 or j >= 0) ?\n\nSimpler: Use a loop:\n\n→ Decision: i >= 0 or j >= 0 ？ // 有未處理元素繼續\n    Yes → Step 1: ... etc\n    No  → End\n\nBut we need to manage inner decision: compare elements.\n\nWe can structure:\n\nStart\n→ Step 1: i ← m-1; j ← n-1; k ← m+n-1 // 初始化\n→ Decision: i >= 0 or j >= 0? // 還有未處理元素?\n    Yes →\n        → Decision: i >= 0? // nums1 有元素?\n            Yes →\n                → Decision: j >= 0? // nums2 也有元素?\n                    Yes →\n                        → Decision: nums1[i] > nums2[j]? // 哪個較大？\n                            Yes → Step 2: nums1[k] ← nums1[i]; i--; k--; // 放入\n                            No  → Step 3: nums1[k] ← nums2[j]; j--; k--; // 放入\n                    No → Step 4: nums1[k] ← nums1[i]; i--; k--; // 只剩 nums1\n            No →\n                → Decision: j >= 0? // 只剩 nums2\n                    Yes → Step 5: nums1[k] ← nums2[j]; j--; k--; // 放入\n                    No  → End\n    No → End\n\nBut this might produce many nested steps. We need to output each line as separate.\n\nWe need to use \"Decision:\" with sublines Yes/No. They must be indented. Use arrow. Indent maybe by spaces.\n\nThe format example shows indentation like:\n\nDecision: ...\n    Yes →\n    No →\n\nWe can use similar.\n\nThus produce lines:\n\nStart // 程式開始執行\n→ Step 1: i ← m-1; j ← n-1; k ← m+n-1 // 初始化指標\n→ Decision: i >= 0 or j >= 0? // 是否還有未處理的元素？\n    Yes →\n        → Decision: i >= 0? // nums1 還有元素？\n            Yes →\n                → Decision: j >= 0? // nums2 也有元素？\n                    Yes →\n                        → Decision: nums1[i] > nums2[j]? // 比較大小\n                            Yes → Step 2: nums1[k] ← nums1[i]; i--; k--; // 放入較大值\n                            No  → Step 3: nums1[k] ← nums2[j]; j--; k--; // 放入較大值\n                    No → Step 4: nums1[k] ← nums1[i]; i--; k--; // 只剩 nums1\n            No →\n                → Decision: j >= 0? // 只剩 nums2\n                    Yes → Step 5: nums1[k] ← nums2[j]; j--; k--; // 放入剩餘 nums2\n                    No  → End // 兩個陣列已處理完\n    No → End // 沒有未處理元素，完成合併\n\nBut we may want to keep loop until both are processed. But the above nested decisions only run once? Actually the outer Decision is repeated implicitly? But in pseudo code we need a loop. So we can do:\n\n→ Decision: i >= 0 or j >= 0? // 有未處理元素？\n    Yes → (process as above) then loop back to Decision\n    No  → End\n\nSo we need to mention \"Go back to Decision\". But we can just rely on implicit loop.\n\nBut the requirement: \"逐行產生虛擬碼\" and \"結構\". It's acceptable.\n\nWe also need to note that this algorithm merges from end to front to avoid overwriting.\n\nWe might also mention that we ignore trailing zeros.\n\nWe need to produce lines.\n\nWe should produce exactly as needed.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← m - 1; j ← n - 1; k ← m + n - 1 // 初始化指標，從兩個陣列末尾開始比較  \n→ Decision: i ≥ 0 or j ≥ 0? // 是否還有未處理的元素？  \n    Yes →  \n        → Decision: i ≥ 0? // nums1 還有元素？  \n            Yes →  \n                → Decision: j ≥ 0? // nums2 也有元素？  \n                    Yes →  \n                        → Decision: nums1[i] > nums2[j]? // 比較兩個指標所指元素大小  \n                            Yes → Step 2: nums1[k] ← nums1[i]; i ← i - 1; k ← k - 1 // 把 nums1 中較大的元素放到最後  \n                            No  → Step 3: nums1[k] ← nums2[j]; j ← j - 1; k ← k - 1 // 把 nums2 中較大的元素放到最後  \n                    No → Step 4: nums1[k] ← nums1[i]; i ← i - 1; k ← k - 1 // 只剩 nums1，直接複製  \n            No →  \n                → Decision: j ≥ 0? // 只剩 nums2  \n                    Yes → Step 5: nums1[k] ← nums2[j]; j ← j - 1; k ← k - 1 // 把剩餘 nums2 複製到 nums1  \n                    No  → End // 兩個陣列皆已處理完畢  \n    No → End // 沒有未處理元素，合併完成",
      "generated_code": "class Solution:\n    def merge(self, nums1, m, nums2, n):\n        i = m - 1\n        j = n - 1\n        k = m + n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n        return nums1\n\nif __name__ == \"__main__\":\n    import sys, ast\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    nums1 = nums2 = None\n    m = n = 0\n    for part in data.split(','):\n        part = part.strip()\n        if '=' not in part:\n            continue\n        key, value = [p.strip() for p in part.split('=', 1)]\n        if key == 'nums1':\n            nums1 = ast.literal_eval(value)\n        elif key == 'nums2':\n            nums2 = ast.literal_eval(value)\n        elif key == 'm':\n            m = int(value)\n        elif key == 'n':\n            n = int(value)\n    solution = Solution()\n    solution.merge(nums1, m, nums2, n)\n    print(nums1)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "expected_output": "[1,2,2,3,5,6]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpgp7ckuvu.py\", line 33, in <module>\n    nums1 = ast.literal_eval(value)\n            ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1009.json",
    "problem_index_in_file": 0,
    "title": "Complement of Base 10 Integer",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code (like a flowchart pseudo code) for computing the binary complement of an integer. For an integer n, we need to produce its bitwise complement with respect to its binary representation (ignoring leading zeros). So basically flipping each bit in the binary representation of n. We can compute complement by XOR with mask of same bit length: mask = (1 << bit_length) - 1; complement = n ^ mask.\n\nWe need to output line-by-line virtual code with explanation comments. Must use \"Start\", \"End\", \"Decision:\" etc. Also need to use arrow characters. Each line: \"虛擬碼步驟 [space] // 解釋\". For example: \"Start // 程式開始執行\".\n\nLet's produce algorithm:\n\n1. Start\n2. Input integer n\n3. Determine bit_length: number of bits in binary representation of n\n   Decision: n == 0? Actually if n==0, binary \"0\" length 1.\n   So maybe handle n==0 separately: mask = 1\n4. Compute mask: (1 << bit_length) - 1\n5. Compute complement: n ^ mask\n6. Output complement\n7. End\n\nWe also may need to handle negative numbers? The problem likely expects non-negative integer. We'll mention assumption non-negative.\n\nWe need to provide line by line. Use \"→\" arrow to indicate flow. \"Decision:\" lines with Yes/No.\n\nLet's craft.\n\nAlso note that \"Start\" line has no arrow? In example: \"Start // 程式開始執行\". Then subsequent steps have arrow \"→ Step 1: ...\". So we need to put \"→\" before step lines.\n\nThus format:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 從使用者取得輸入值\n→ Step 2: 判斷 n 是否為 0 // 確定位元長度\n    Yes → Step 3a: bit_length ← 1 // 0 的二進位表示為 0，位元長度為 1\n    No  → Step 3b: bit_length ← 取得 n 的二進位位數 // 例如 5 → 3\n→ Step 4: 計算 mask ← (1 << bit_length) - 1 // 產生所有位元為 1 的遮罩\n→ Step 5: 計算 complement ← n XOR mask // 將每一位取反\n→ Step 6: 輸出 complement // 回傳結果\nEnd // 程式結束\n\nBut we need \"Decision:\" lines. So maybe:\n\n→ Decision: n == 0? // 判斷是否為 0\n    Yes → Step 3a ...\n    No  → Step 3b ...\n\nAlso, we need to include \"Decision:\" lines for determining bit_length? Actually we can use while loop to find bit_length by shifting.\n\nAlternate: Compute bit_length by: bit_length = 0; temp = n; while temp > 0: bit_length++; temp >>= 1; If n==0, bit_length = 1. That uses Decision loops.\n\nBetter: Provide algorithm:\n\nStart\n→ Step 1: 輸入 n\n→ Step 2: temp ← n\n→ Step 3: bit_length ← 0\n→ Decision: temp == 0? // 特殊情況\n    Yes → bit_length ← 1\n    No  → Decision: temp > 0?\n          Yes → Step 4: bit_length ← bit_length + 1; temp ← temp >> 1; Go back to Decision\n          No  → (loop ends)\nBut might be too complex. Instead, we can simpler: Use built-in function to compute bit_length. But in virtual code, we might still use a loop.\n\nLet's design a simple flow:\n\n1. Start\n2. Input n\n3. Set temp ← n\n4. Set bit_length ← 0\n5. Decision: temp == 0? // If n==0, set bit_length=1 else compute length\n    Yes → Step: bit_length ← 1 // For zero\n    No  → Step: 循環計算位元長度 (while temp > 0) -> Step: bit_length ← bit_length + 1; temp ← temp >> 1; Go back to Decision\nBut we need to represent loops with Decision and arrow. We can do:\n\n→ Decision: temp > 0? // while loop condition\n    Yes → Step: bit_length ← bit_length + 1\n    → Step: temp ← temp >> 1\n    → Decision: temp > 0? // repeat\n    No  → Continue\nBut we might just use a single Decision: while loop.\n\nSimpler: Use Step to compute bit_length using built-in function. But need to show algorithm conceptually. Let's do:\n\n→ Step 3: bit_length ← 取得 n 的二進位位數 // 可用位移或長度函數\nThis step covers both n==0 and non-zero.\n\nSo we can have:\n\n→ Step 3: bit_length ← 取得 n 的二進位位數 // 取得位元長度\n\nBut to adhere to \"Decision:\" maybe we can add a Decision for n==0 to handle bit_length=1.\n\nOk final design:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 從使用者取得輸入值\n→ Decision: n == 0? // 檢查是否為 0\n    Yes → Step 2a: bit_length ← 1 // 0 的二進位表示為 '0'，位元長度為 1\n    No  → Step 2b: bit_length ← 取得 n 的二進位位數 // 例如 5 → 3\n→ Step 3: 計算 mask ← (1 << bit_length) - 1 // 產生所有位元為 1 的遮罩\n→ Step 4: 計算 complement ← n XOR mask // 取反每一位\n→ Step 5: 輸出 complement // 回傳結果\nEnd // 程式結束\n\nBut we must adhere to arrow lines: Each line after Start has \"→\" arrow. And Decision lines with indent? The example uses indentation for sub-branches. So we need to indent sub-lines. The example uses:\n\n→ Decision: 如果數字大於 0? // ...\n    Yes → Step 2: ...\n    No  → Decision: ...\n\nWe should mimic that.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 從使用者取得輸入值\n→ Decision: n == 0? // 檢查是否為 0\n    Yes → Step 2a: bit_length ← 1 // 0 的二進位表示為 '0'，位元長度為 1\n    No  → Step 2b: bit_length ← 取得 n 的二進位位數 // 例如 5 → 3\n→ Step 3: mask ← (1 << bit_length) - 1 // 產生所有位元為 1 的遮罩\n→ Step 4: complement ← n XOR mask // 取反每一位\n→ Step 5: 輸出 complement // 回傳結果\nEnd // 程式結束\n\nWe must ensure each line has \"虛擬碼步驟\" and comment.\n\nThus produce exactly that. Use traditional Chinese punctuation. Ensure no actual code output. Use virtual code only. Good.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 從使用者取得輸入值\n→ Decision: n == 0? // 檢查是否為 0\n    Yes → Step 2a: bit_length ← 1 // 0 的二進位表示為 '0'，位元長度為 1\n    No  → Step 2b: bit_length ← 取得 n 的二進位位數 // 例如 5 → 3\n→ Step 3: mask ← (1 << bit_length) - 1 // 產生所有位元為 1 的遮罩\n→ Step 4: complement ← n XOR mask // 取反每一位\n→ Step 5: 輸出 complement // 回傳結果\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef bitwise_complement(n: int) -> int:\n    if n == 0:\n        return 1\n    bit_length = n.bit_length()\n    mask = (1 << bit_length) - 1\n    return n ^ mask\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # extract first integer in input\n    match = re.search(r'-?\\d+', data)\n    if match:\n        n = int(match.group())\n        result = bitwise_complement(n)\n        print(result)\n    else:\n        # If no integer found, do nothing or print nothing\n        pass\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 10",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode712.json",
    "problem_index_in_file": 0,
    "title": "Minimum ASCII Delete Sum for Two Strings",
    "description_snippet": "Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solution to LeetCode 1180: Minimum ASCII Delete Sum for Two Strings. Use DP. Virtual code line by line. Provide explanation after //.\n\nWe need to follow format: Start, then steps, Decision etc.\n\nWe'll produce steps: Start, initialize DP table, nested loops, compute DP. Use 1-indexed or 0-indexed. Provide explanation. End.\n\nLet's craft. Each line: \"Start // 程式開始執行\". Next: \"→ Step 1: 獲取兩字串長度 m, n // 取得 s1, s2 長度\". Next: \"→ Step 2: 建立 DP 陣列 (m+1) x (n+1) // 初始化 DP\" etc.\n\nLet's produce maybe 15-20 lines.\n\nLet's write in Chinese. Use arrow. For loops, decisions.\n\nAlso use \"Decision:\" lines for boundary conditions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 s1, s2 的長度 m, n // 先計算兩個字串的長度  \n→ Step 2: 建立 DP 陣列 (m+1) x (n+1)，所有值初始化為 0 // 這是動態規劃表  \n→ Decision: 是否為空字串? // 檢查 m 或 n 是否為 0  \n    Yes → Step 3: 若 m = 0, 計算 s2 的 ASCII 和並返回 // 只需刪除全部 s2  \n    Yes → Step 4: 若 n = 0, 計算 s1 的 ASCII 和並返回 // 只需刪除全部 s1  \n    No  → Continue // 兩字串都有字元  \n→ Step 5: 設定 DP[0][j] = sum_{k=1..j} ASCII(s2[k-1]) // 刪除全部 s2 前 j 個字元的成本  \n→ Step 6: 設定 DP[i][0] = sum_{k=1..i} ASCII(s1[k-1]) // 刪除全部 s1 前 i 個字元的成本  \n→ Step 7: For i從1到m  \n    → Step 8: For j從1到n  \n        → Decision: s1[i-1] == s2[j-1]? // 字元相同  \n            Yes → Step 9: DP[i][j] = DP[i-1][j-1] // 不需要刪除，成本保持  \n            No  → Step 10: DP[i][j] = min( DP[i-1][j] + ASCII(s1[i-1]), DP[i][j-1] + ASCII(s2[j-1]) ) // 刪除較低成本字元  \n→ Step 11: 回傳 DP[m][n] // 最終最低 ASCII 刪除總和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\n        m, n = len(s1), len(s2)\n        # 建立 DP 表，dp[i][j] 代表前 i 個 s1 與前 j 個 s2 的最小刪除 ASCII 總和\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        # 初始化第一列（只刪除 s1）\n        for i in range(1, m + 1):\n            dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\n\n        # 初始化第一行（只刪除 s2）\n        for j in range(1, n + 1):\n            dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\n\n        # 動態規劃填表\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]            # 字元相同，直接繼承\n                else:\n                    # 刪除 s1[i-1] 或 s2[j-1]，取較小成本\n                    dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]),\n                                   dp[i][j - 1] + ord(s2[j - 1]))\n\n        return dp[m][n]\n\ndef main():\n    # 讀取所有輸入\n    data = sys.stdin.read()\n\n    # 以雙引號內的字串作為 s1、s2\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        s1, s2 = matches[0], matches[1]\n    else:\n        # 若無雙引號，嘗試直接拆分兩行或空格\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            s1, s2 = parts[0], parts[1]\n        else:\n            s1 = s2 = \"\"\n\n    solution = Solution()\n    result = solution.minimumDeleteSum(s1, s2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"sea\", s2 = \"eat\"",
          "expected_output": "231",
          "success": true,
          "output": "231"
        },
        {
          "example_index": 1,
          "input": "s1 = \"delete\", s2 = \"leet\"",
          "expected_output": "403",
          "success": true,
          "output": "403"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode640.json",
    "problem_index_in_file": 0,
    "title": "Solve the Equation",
    "description_snippet": "Solve a given equation and return the value of 'x' in the form of a string \"x=#value\". The equation ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that solves a linear equation of form with '+' '-' operators, variable x with coefficient, returns string \"x=#value\" or \"No solution\"/\"Infinite solutions\". The virtual code steps: parse equation, move all terms to left side? We'll produce steps.\n\nWe need to output line by line. Each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's outline:\n\nStart\n→ Step 1: Read equation string // input\n→ Step 2: Split equation into left and right sides at '=' // get LHS, RHS\n→ Step 3: Initialize variables coeff_x = 0, const_term = 0 // accumulators\n→ Step 4: Define helper function parseSide(side, sign) // parse terms with sign\n    → Step 5: Replace '-' with '+-' and split by '+' // get terms\n    → Step 6: For each term\n        → Decision: If term contains 'x'?\n            Yes → Extract numeric coefficient (if missing, treat as 1) and multiply by sign // add to coeff_x\n            No  → Convert to integer and multiply by sign // add to const_term\n→ Step 5: Call parseSide on LHS with sign +1 // accumulate\n→ Step 6: Call parseSide on RHS with sign -1 // bring to LHS\n→ Step 7: After parsing, we have equation: coeff_x * x + const_term = 0\n→ Step 8: Decision: coeff_x == 0 ?\n    Yes → Decision: const_term == 0 ?\n        Yes → Step 9: Return \"Infinite solutions\" // 0x + 0 = 0\n        No  → Step 10: Return \"No solution\" // 0x + c = 0 with c!=0\n    No → Step 11: Compute solution x = -const_term / coeff_x // integer division\n        → Step 12: Return string \"x=\" + x_value\nEnd\n\nWe'll express each line accordingly.\n\nWe need to use arrow symbols and \"Decision:\".\n\nLet's write.\n\nStart // 程式開始執行\n→ Step 1: 讀取方程式字串 // 取得輸入方程式\n→ Step 2: 在 '=' 處將方程式分成左邊 LHS 與右邊 RHS // 拆解兩邊\n→ Step 3: 初始化 coeff_x = 0, const_term = 0 // 用來累計係數與常數\n→ Step 4: 定義函式 parseSide(side, sign) // 解析單邊並按 sign 進行累加\n    → Step 5: 在 side 中將 '-' 替換為 '+-'，再以 '+' 分割成各項 // 方便處理符號\n    → Step 6: 對於每一項 term\n        → Decision: term 含有 'x' 嗎？\n            Yes → Step 7: 取得數字係數 (若無數字則視為 1)，乘以 sign，加入 coeff_x // 處理 x 係數\n            No  → Step 8: 將 term 轉成整數，乘以 sign，加入 const_term // 處理常數項\n→ Step 9: 呼叫 parseSide(LHS, +1) // 解析左邊並累加\n→ Step 10: 呼叫 parseSide(RHS, -1) // 解析右邊並移到左邊\n→ Step 11: 目前方程式為 coeff_x * x + const_term = 0 // 已整理成標準形式\n→ Step 12: Decision: coeff_x == 0 ?\n    Yes → Decision: const_term == 0 ?\n        Yes → Step 13: 回傳 \"Infinite solutions\" // 無限制的 x\n        No  → Step 14: 回傳 \"No solution\" // 無解\n    No  → Step 15: 計算 x = -const_term / coeff_x // 確定唯一解\n        → Step 16: 回傳 \"x=\" + x_value // 結果字串\nEnd // 程式執行結束\n\nCheck formatting: each line ends with `//` explanation. Use arrow only for steps inside parseSide maybe. But we must maintain line-by-line.\n\nWe also need to use \"→\" before each step except Start and End maybe. The example uses \"→ Step 1: ...\". We should use same style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取方程式字串 // 取得輸入方程式  \n→ Step 2: 在 '=' 處將方程式分成左邊 LHS 與右邊 RHS // 拆解兩邊  \n→ Step 3: 初始化 coeff_x = 0, const_term = 0 // 用來累計係數與常數  \n→ Step 4: 定義函式 parseSide(side, sign) // 解析單邊並按 sign 進行累加  \n → Step 5: 在 side 中將 '-' 替換為 '+-'，再以 '+' 分割成各項 // 方便處理符號  \n → Step 6: 對於每一項 term  \n  → Decision: term 含有 'x' 嗎？  \n   Yes → Step 7: 取得數字係數 (若無數字則視為 1)，乘以 sign，加入 coeff_x // 處理 x 係數  \n   No  → Step 8: 將 term 轉成整數，乘以 sign，加入 const_term // 處理常數項  \n→ Step 9: 呼叫 parseSide(LHS, +1) // 解析左邊並累加  \n→ Step 10: 呼叫 parseSide(RHS, -1) // 解析右邊並移到左邊  \n→ Step 11: 目前方程式為 coeff_x * x + const_term = 0 // 已整理成標準形式  \n→ Step 12: Decision: coeff_x == 0 ?  \n  Yes → Decision: const_term == 0 ?  \n   Yes → Step 13: 回傳 \"Infinite solutions\" // 無限制的 x  \n   No  → Step 14: 回傳 \"No solution\" // 無解  \n  No  → Step 15: 計算 x = -const_term / coeff_x // 確定唯一解  \n   → Step 16: 回傳 \"x=\" + x_value // 結果字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def solveEquation(self, equation: str) -> str:\n        \"\"\"\n        解析並求解一元一次方程式\n        \"\"\"\n        def parse_side(s: str):\n            \"\"\"\n            解析方程式的單側，返回 (x 的係數, 常數項之和)\n            \"\"\"\n            x_coeff, const = 0, 0\n            i, n, sign = 0, len(s), 1\n            while i < n:\n                if s[i] == '+':\n                    sign = 1\n                    i += 1\n                elif s[i] == '-':\n                    sign = -1\n                    i += 1\n                else:\n                    j = i\n                    while j < n and s[j] not in '+-':\n                        j += 1\n                    token = s[i:j]\n                    if 'x' in token:\n                        # 取得 x 的係數\n                        coeff_str = token[:-1]\n                        if coeff_str == '' or coeff_str == '+':\n                            coeff = 1\n                        elif coeff_str == '-':\n                            coeff = -1\n                        else:\n                            coeff = int(coeff_str)\n                        x_coeff += sign * coeff\n                    else:\n                        const += sign * int(token)\n                    i = j\n            return x_coeff, const\n\n        left, right = equation.split('=')\n        left_x, left_const = parse_side(left)\n        right_x, right_const = parse_side(right)\n\n        # 整理為 (left_x - right_x) * x + (left_const - right_const) = 0\n        coeff_diff = left_x - right_x\n        const_diff = right_const - left_const\n\n        if coeff_diff == 0:\n            if const_diff == 0:\n                return \"Infinite solutions\"\n            else:\n                return \"No solution\"\n        else:\n            # 由於題目保證答案為整數\n            x_val = const_diff // coeff_diff\n            return f\"x={x_val}\"\n\n\ndef main():\n    \"\"\"\n    從標準輸入讀取方程式，輸出求解結果\n    \"\"\"\n    data = sys.stdin.read()\n    data = data.strip()\n    if not data:\n        return\n\n    # 若輸入含有雙引號，則提取其中的方程式字串\n    if '\"' in data:\n        first = data.find('\"')\n        last = data.rfind('\"')\n        equation = data[first + 1:last]\n    else:\n        # 直接以 '=' 分割，或直接使用整個輸入\n        parts = data.split('=', 1)\n        equation = parts[1].strip() if len(parts) == 2 else data\n\n    solution = Solution()\n    print(solution.solveEquation(equation))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "equation = \"x+5-3+x=6+x-2\"",
          "expected_output": "x=2",
          "success": true,
          "output": "x=2"
        },
        {
          "example_index": 1,
          "input": "equation = \"x=x\"",
          "expected_output": "Infinite solutions",
          "success": true,
          "output": "Infinite solutions"
        },
        {
          "example_index": 2,
          "input": "equation = \"2x=x\"",
          "expected_output": "x=0",
          "success": true,
          "output": "x=0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode128.json",
    "problem_index_in_file": 0,
    "title": "Longest Consecutive Sequence",
    "description_snippet": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. We need to cover algorithm O(n). For longest consecutive sequence, we can use set to store numbers and iterate. For each number, if it's the start of a sequence (num-1 not in set), then expand forward to find length. Track max. Complexity O(n). We'll produce stepwise pseudocode with Start, Decision etc.\n\nWe need to produce each line as \"虛擬碼步驟 // 解釋\". Include arrows and decisions.\n\nLet's craft:\n\nStart\n→ Step 1: Create set S from nums // store unique numbers for O(1) lookups\n→ Step 2: Initialize maxLen = 0 // track longest sequence length\n→ For each num in nums // iterate over numbers\n    → Decision: If num-1 ∉ S? // check if num is start of a sequence\n        Yes →\n            → Set current = num // start of new sequence\n            → Set currentLen = 1 // length counter\n            → While current+1 ∈ S? // extend sequence\n                → current += 1\n                → currentLen += 1\n            → Decision: If currentLen > maxLen? // update max\n                Yes → maxLen = currentLen\n                No →\n        No → // num not start, skip\n→ Step 3: Return maxLen // output result\nEnd\n\nWe need to format with proper indentation? Use spaces maybe.\n\nMake sure each line has the format: code + space + // explanation.\n\nAlso decisions show Yes/No arrows.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: S ← set(nums) // 建立一個集合 S 存放所有數字，方便 O(1) 查詢  \n→ Step 2: maxLen ← 0 // 初始化最大連續序列長度  \n→ For each num in nums // 遍歷陣列中的每個數字  \n  → Decision: num - 1 ∉ S? // 判斷 num 是否為新序列的起點  \n    Yes →  \n     → current ← num // 設定目前序列的起始值  \n     → currentLen ← 1 // 序列長度從 1 開始  \n     → While current + 1 ∈ S? // 若下一個數存在於集合，則繼續擴充序列  \n       → current ← current + 1 // 移動到下一個數字  \n       → currentLen ← currentLen + 1 // 序列長度加一  \n     → Decision: currentLen > maxLen? // 判斷是否更新最大長度  \n       Yes → maxLen ← currentLen // 若更長，更新 maxLen  \n       No → // 否則保持原值  \n    No → // num 不是序列起點，直接跳過  \n→ Step 3: return maxLen // 回傳最長連續序列的長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef longest_consecutive(nums):\n    \"\"\"Return the length of the longest consecutive sequence in nums.\"\"\"\n    if not nums:\n        return 0\n\n    num_set = set(nums)\n    longest = 0\n\n    for num in num_set:\n        # Only start counting if num is the beginning of a sequence\n        if num - 1 not in num_set:\n            current = num\n            length = 1\n            # Extend the sequence as far as possible\n            while current + 1 in num_set:\n                current += 1\n                length += 1\n            # Update the maximum length found\n            if length > longest:\n                longest = length\n\n    return longest\n\nif __name__ == \"__main__\":\n    # Read the entire input (may contain 'nums = [...]')\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Extract the list part from the input\n    if \"=\" in raw_input:\n        _, list_part = raw_input.split(\"=\", 1)\n    else:\n        list_part = raw_input\n\n    list_part = list_part.strip()\n    try:\n        # Safely parse the list using ast.literal_eval\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        nums = []\n\n    if not isinstance(nums, list):\n        nums = []\n\n    result = longest_consecutive(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [100,4,200,1,3,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 2,
          "input": "nums = [1,0,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode56.json",
    "problem_index_in_file": 0,
    "title": "Merge Intervals",
    "description_snippet": "Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals, ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code in lines. Steps: sort intervals by start, then iterate merging. Use pseudo. Provide explanation after each line. Use Start, End, Decision. Provide arrow. Use no actual code. Just steps. Use Start. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 intervals 按照起始時間升序排序 // 先將區間從小到大排列，方便後續合併  \n→ Step 2: 建立空的 mergedIntervals 陣列 // 用來儲存已合併好的區間  \n→ Step 3: 將 sortedIntervals 的第一個區間加入 mergedIntervals // 初始設定  \n→ Decision: 迴圈已處理完所有區間? // 檢查是否還有未處理的區間  \n    No → Step 4: 取得當前未處理的區間 current // 讀取下一個區間  \n    No → Decision: current.start <= mergedIntervals.last.end? // 檢查是否重疊  \n        Yes → Step 5: 更新 mergedIntervals.last.end 為 max(mergedIntervals.last.end, current.end) // 合併重疊區間  \n        No  → Step 6: 將 current 追加到 mergedIntervals // 無重疊，直接加入  \n    No → Step 7: 移動至下一個區間 // 更新指標，回到 Decision 判斷  \n    Yes → End // 所有區間已處理，程式結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    \"\"\"\n    合併重疊區間的核心實作。\n    \"\"\"\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not intervals:      # 如果輸入為空，直接回傳空列表\n            return []\n\n        # 依照每個區間的起始值進行升序排序\n        intervals.sort(key=lambda x: x[0])\n\n        merged = [intervals[0]]   # 初始時將第一個區間加入結果\n\n        for current in intervals[1:]:\n            prev = merged[-1]    # 取已合併區間中的最後一個\n            if current[0] <= prev[1]:   # 若當前區間的起點小於等於上一個區間的結束，表示重疊\n                # 更新結束點為兩者中較大的結束值\n                prev[1] = max(prev[1], current[1])\n            else:                 # 若無重疊，直接加入結果\n                merged.append(current)\n\n        return merged\n\ndef parse_input(input_str):\n    \"\"\"\n    將 stdin 的字串解析成 intervals 列表。\n    期望的格式類似於 'intervals = [[1,3],[2,6],[8,10],[15,18]]'\n    \"\"\"\n    input_str = input_str.strip()\n    if '=' in input_str:\n        _, expr = input_str.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = input_str\n    # 使用 ast.literal_eval 來安全地解析字面值\n    return ast.literal_eval(expr)\n\nif __name__ == \"__main__\":\n    # 讀取所有標準輸入\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit(0)\n\n    intervals = parse_input(raw_input)\n    solution = Solution()\n    merged_intervals = solution.merge(intervals)\n    print(merged_intervals)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
          "expected_output": "[[1,6],[8,10],[15,18]]",
          "success": true,
          "output": "[[1, 6], [8, 10], [15, 18]]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,4],[4,5]]",
          "expected_output": "[[1,5]]",
          "success": true,
          "output": "[[1, 5]]"
        },
        {
          "example_index": 2,
          "input": "intervals = [[4,7],[1,4]]",
          "expected_output": "[[1,7]]",
          "success": true,
          "output": "[[1, 7]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode395.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring with At Least K Repeating Characters",
    "description_snippet": "Given a string s and an integer k, return the length of the longest substring of s such that the fre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line for algorithm to solve longest substring with each char frequency >= k. Standard solution: divide and conquer recursion, or sliding window by unique char count. But we need virtual code steps and explanations, not actual code. Use structure: Start, End, Decision, etc. Must not output actual code. So each line: Virtual Code Step [space] // explanation.\n\nWe can present approach: Use recursion splitting at invalid chars. Steps: function longest(s,k). base cases: if s empty return 0. count chars. If all chars frequency >= k return length. else find a char that is <k, split string by that char into substrings, recursively compute max among them. Return max. That’s typical.\n\nWe must produce lines like:\n\nStart // Program starts\n→ Step 1: 定義函式 longestSubstring(s, k) // 定義主函式\n→ Step 2: If s is empty, return 0 // 空字串直接回傳 0\n→ Step 3: Count frequency of each character in s // 計算每個字元出現次數\n→ Decision: Are all characters frequency >= k? // 判斷是否整個字串符合條件\n    Yes → Step 4: Return length of s // 如果符合，回傳長度\n    No  → Step 5: 找出所有頻率 < k 的字元 // 找出不符合的字元\n        → For each such badChar\n            → Step 6: Split s by badChar into substrings // 以不符合字元切分\n            → Step 7: For each substring, recursively call longestSubstring(sub, k) // 重新遞迴\n            → Step 8: 取得所有子串中的最大值 // 計算最大長度\n            → Step 9: Return 最大值 // 回傳最大長度\nEnd // 程式結束\n\nBut we need more detailed steps: maybe inside loop, etc. Must be line by line, but can combine? We need to use virtual code arrow syntax. Provide explanation per line.\n\nWe might produce something like:\n\nStart // 程式開始執行\n→ Step 1: 函式 longestSubstring(s, k) // 定義主要遞迴函式\n→ Step 2: If s.isEmpty() return 0 // 空字串直接回傳 0\n→ Step 3: freq = CountCharacters(s) // 建立字元頻率表\n→ Decision: 如果所有 freq[char] >= k? // 檢查整個字串是否符合條件\n    Yes → Step 4: Return s.length // 符合，回傳長度\n    No  → Step 5: badChars = [char for char in freq if freq[char] < k] // 找出不符合的字元\n        → For each badChar in badChars\n            → Step 6: parts = SplitString(s, badChar) // 以 badChar 為分隔符切分\n            → Step 7: maxLen = 0 // 初始化最大長度\n            → For each part in parts\n                → Step 8: len = longestSubstring(part, k) // 重新遞迴\n                → Decision: 如果 len > maxLen? // 更新最大長度\n                    Yes → maxLen = len\n            → Step 9: Return maxLen // 回傳最大長度\nEnd // 程式執行結束\n\nWe need to keep each line separate. Ensure each line ends with // explanation. Use arrow and indentation maybe. They used earlier example: \"→ Step 1: 輸入使用者數字 // ...\" etc. So we must use same format.\n\nLet's produce full steps. Use consistent structure: Start, End, Decision, etc.\n\nPotential issues: Must not output actual code; but virtual code lines include pseudo-code like \"freq = CountCharacters(s)\". That's fine.\n\nWe need to ensure each line uses the pattern: \"→ Step X: ...\" or \"→ Decision: ...\" etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 longestSubstring(s, k) // 主遞迴入口\n→ Step 2: If s.isEmpty() return 0 // 空字串直接回傳 0\n→ Step 3: freq = CountCharacters(s) // 建立字元頻率表\n→ Decision: 如果所有 freq[char] >= k? // 判斷整個字串是否符合條件\n    Yes → Step 4: Return s.length // 所有字元頻率足夠，回傳字串長度\n    No  → Step 5: badChars = [char for char in freq if freq[char] < k] // 收集不滿足頻率的字元\n        → For each badChar in badChars\n            → Step 6: parts = SplitString(s, badChar) // 以 badChar 分割成多個子串\n            → Step 7: maxLen = 0 // 初始化最大長度\n            → For each part in parts\n                → Step 8: len = longestSubstring(part, k) // 針對子串遞迴計算\n                → Decision: 如果 len > maxLen? // 檢查是否更新最大長度\n                    Yes → maxLen = len\n            → Step 9: Return maxLen // 子串中最大的長度回傳\nEnd // 程式執行結束\n\nWe should ensure each line includes a single statement. Also we may separate for loops into lines. The \"→ For each badChar in badChars\" line may need explanation. But we might combine with \"→ For each badChar in badChars\" line as step. But then inside we have steps 6-9. So each line's explanation includes the action.\n\nNeed to ensure arrow usage: \"→ For each badChar in badChars\" may not fit the pattern but it's okay.\n\nAlso \"Decision: 如果所有 freq[char] >= k?\" uses arrow inside. That matches example. For nested decision inside loops, we indent and use arrow.\n\nShould we include the start of recursion for each part? Already.\n\nBut we need to ensure \"End\" corresponds to End of program not end of function. But that's okay.\n\nMaybe we can add \"End Function longestSubstring\" but not necessary.\n\nLet's craft final answer accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 longestSubstring(s, k) // 主遞迴入口，接受字串 s 與最小頻率 k  \n→ Step 2: If s.isEmpty() return 0 // 空字串無子字串，直接回傳 0  \n→ Step 3: freq = CountCharacters(s) // 產生字元頻率表 freq  \n→ Decision: 如果所有 freq[char] >= k? // 檢查整個字串是否符合條件  \n Yes → Step 4: Return s.length // 若全部字元頻率足夠，回傳整個字串長度  \n No → Step 5: badChars = [char for char in freq if freq[char] < k] // 找出頻率不足的字元  \n  → For each badChar in badChars // 逐一處理每個不符合的字元  \n   → Step 6: parts = SplitString(s, badChar) // 以 badChar 為分隔符切分 s 成多個子字串  \n   → Step 7: maxLen = 0 // 初始化目前子字串中最大長度  \n   → For each part in parts // 針對每個子字串遞迴  \n    → Step 8: len = longestSubstring(part, k) // 重新呼叫遞迴求解  \n    → Decision: 如果 len > maxLen? // 判斷是否更新最大長度  \n     Yes → maxLen = len  \n   → Step 9: Return maxLen // 子字串中最大的長度回傳給上一層  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def longestSubstring(self, s: str, k: int) -> int:\n        if not s or k <= 0:\n            return 0\n        if len(s) < k:\n            return 0\n        count = Counter(s)\n        for ch, freq in count.items():\n            if freq < k:\n                # split by this character and recursively evaluate\n                return max(self.longestSubstring(sub, k) for sub in s.split(ch))\n        return len(s)\n\ndef parse_input(data: str):\n    # Try to extract s and k using regex\n    s_match = re.search(r's\\s*=\\s*[\\'\"]([^\\'\"]+)[\\'\"]', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if s_match and k_match:\n        s = s_match.group(1)\n        k = int(k_match.group(1))\n        return s, k\n    # Fallback: split by whitespace\n    parts = data.strip().split()\n    if len(parts) >= 2:\n        s = parts[0]\n        k = int(parts[1])\n        return s, k\n    # If only one line with string, next line integer\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        s = lines[0].strip()\n        k = int(lines[1].strip())\n        return s, k\n    raise ValueError(\"Input format not recognized\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, k = parse_input(raw_input)\n    result = Solution().longestSubstring(s, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aaabb\", k = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"ababbc\", k = 2",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode231.json",
    "problem_index_in_file": 0,
    "title": "Power of Two",
    "description_snippet": "Given an integer n, return true if it is a power of two. Otherwise, return false.\n\nAn integer n is a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm to determine if integer n is power of two. Need to output steps line by line, each line with virtual code and comment. Use arrows, decisions etc. Let's think algorithm: check if n <=0 return false; else while n % 2 == 0: n = n / 2; after loop if n==1 return true else false. Or use bit trick: (n & (n-1))==0. We'll produce simple algorithm.\n\nLet's produce steps:\n\nStart\n→ Step 1: 接收整數 n // 取得輸入值\n→ Decision: n <= 0? // 判斷是否非正整數\n    Yes → Step 2: 回傳 False // 負數或零不是 2 的冪\n    No  → Step 3: 進入循環\n→ Loop Start // 開始除以 2 的循環\n    → Decision: n % 2 == 0? // 檢查是否能被 2 整除\n        Yes → Step 4: n = n / 2 // 進一步除以 2\n        No  → Exit Loop // 無法再整除，結束循環\n→ Decision: n == 1? // 檢查最後剩下是否為 1\n    Yes → Step 5: 回傳 True // 是 2 的冪\n    No  → Step 6: 回傳 False // 不是 2 的冪\nEnd\n\nBut we need use \"Yes →\" and \"No →\" lines after decisions. Also need to label loops? Might use \"Loop:\" but format not specified; use Decision with Yes/No. Could incorporate while loop with Decision repeated. We'll produce a more concise version with bit trick:\n\nStart\n→ Step 1: 接收整數 n\n→ Decision: n <= 0? \n    Yes → Step 2: 回傳 False\n    No  → Step 3: 進行判斷\n→ Decision: (n & (n-1)) == 0? \n    Yes → Step 4: 回傳 True\n    No  → Step 5: 回傳 False\nEnd\n\nBut we might need to show bitwise AND. Let's produce virtual code accordingly.\n\nThe instructions: Use 虛擬碼的箭頭 (`→`, `Yes →`, `No →`) and structure (`Start`, `End`, `Decision:`). Should produce line by line. We'll provide the steps above. Provide each line as \"虛擬碼步驟 // 解釋\". Ensure each line has a space before comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收整數 n // 從使用者取得整數輸入  \n→ Decision: n <= 0? // 檢查是否為非正整數  \n  Yes → Step 2: 回傳 False // 負數或零不是 2 的冪  \n  No  → Step 3: 判斷是否為 2 的冪  \n→ Decision: (n & (n - 1)) == 0? // 只剩下一位 1 表示 2 的冪  \n  Yes → Step 4: 回傳 True // 是 2 的冪  \n  No  → Step 5: 回傳 False // 不是 2 的冪  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef is_power_of_two(n: int) -> bool:\n    \"\"\"判斷 n 是否為 2 的冪次方。\"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n\ndef main() -> None:\n    # 讀取所有輸入，提取第一個整數\n    data = sys.stdin.read()\n    nums = re.findall(r\"-?\\d+\", data)\n    if not nums:\n        return\n    n = int(nums[0])\n\n    # 判斷並輸出結果\n    print(str(is_power_of_two(n)).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode455.json",
    "problem_index_in_file": 0,
    "title": "Assign Cookies",
    "description_snippet": "Assume you are an awesome parent and want to give your children some cookies. But, you should give e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for the classic \"assign cookies\" problem. Steps: sort greed and sizes; iterate with two pointers; count. Provide lines with arrows and decisions. Need to output in Traditional Chinese. Use Start, End, Decision. Provide explanation after //.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 輸入數組 g 和 s // 取得孩子貪婪值與餅乾尺寸\n→ Step 2: 以升序排序 g // 使貪婪值從小到大排列\n→ Step 3: 以升序排序 s // 使餅乾尺寸從小到大排列\n→ Step 4: 初始化指標 i = 0, j = 0, count = 0 // i 為孩子索引，j 為餅乾索引\n→ Decision: i < len(g) AND j < len(s)? // 是否還有孩子與餅乾待處理\n    Yes → Decision: s[j] >= g[i]? // 當前餅乾是否足夠給當前孩子\n        Yes → Step 5: count += 1 // 內容孩子數量加一\n                 i += 1 // 前往下一個孩子\n                 j += 1 // 使用完此餅乾\n        No  → Step 6: j += 1 // 該餅乾太小，嘗試下一個更大的餅乾\n    No  → Step 7: End // 終止循環，完成分配\n→ Step 8: 輸出 count // 顯示最大內容孩子數\nEnd // 程式執行結束\n\nNeed to ensure each line starts with \"→\" except Start and End. Decision lines with indentation maybe. Provide explanation after //.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入數組 g 與 s // 取得孩子的貪婪值與餅乾的尺寸  \n→ Step 2: 以升序排序 g // 將孩子的貪婪值從小到大排列  \n→ Step 3: 以升序排序 s // 將餅乾的尺寸從小到大排列  \n→ Step 4: 初始化指標 i = 0, j = 0, count = 0 // i 代表當前孩子，j 代表當前餅乾，count 代表已滿足的孩子數  \n→ Decision: i < len(g) AND j < len(s)? // 仍有孩子和餅乾可處理？  \n Yes → Decision: s[j] >= g[i]? // 當前餅乾尺寸是否足夠滿足當前孩子的貪婪值？  \n  Yes → Step 5: count += 1 // 成功給予餅乾，內容孩子數增加  \n   i += 1 // 前往下一個孩子  \n   j += 1 // 使用完此餅乾  \n  No  → Step 6: j += 1 // 餅乾太小，嘗試下一個更大的餅乾  \n No  → Step 7: End // 兩個指標已超出範圍，結束循環  \n→ Step 8: 輸出 count // 顯示能使內容的最大孩子數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef main():\n    data = sys.stdin.read()\n    # 尋找所有的列表內容\n    lists = re.findall(r'\\[([^\\]]*)\\]', data)\n    g, s = [], []\n\n    if len(lists) >= 2:\n        # 第一個列表為 g，第二個列表為 s\n        g = [int(x.strip()) for x in lists[0].split(',') if x.strip()]\n        s = [int(x.strip()) for x in lists[1].split(',') if x.strip()]\n    else:\n        # 若格式不符合，嘗試使用 ast 解析\n        import ast\n        try:\n            content = {}\n            for line in data.strip().splitlines():\n                if '=' in line:\n                    key, val = line.split('=', 1)\n                    key = key.strip()\n                    val = val.strip()\n                    content[key] = ast.literal_eval(val)\n            g = content.get('g', [])\n            s = content.get('s', [])\n        except Exception:\n            pass\n\n    # 兩個列表都排序後進行雙指標匹配\n    g.sort()\n    s.sort()\n    i = j = 0\n    while i < len(g) and j < len(s):\n        if s[j] >= g[i]:\n            i += 1\n        j += 1\n\n    print(i)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "g = [1,2,3], s = [1,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "g = [1,2], s = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode155.json",
    "problem_index_in_file": 0,
    "title": "Min Stack",
    "description_snippet": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nI...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. For MinStack, we can use two stacks: main stack and min stack. Steps: initialize, push, pop, top, getMin. Use Start, End, Decision. Provide each line with comment.\n\nNeed to cover each function, maybe represent as method definitions? Use steps like \"Function: MinStack()\" etc. Each step line should show the action. Use \"→\" arrow for each action. Ensure each line ends with comment.\n\nLet's produce sequential steps:\n\nStart\n→ Function MinStack() initialize mainStack empty // ...\n→ Function push(val) // ...\n  → mainStack.push(val) // push onto main stack\n  → Decision: minStack empty? // ...\n     Yes → minStack.push(val) // if min stack empty, push val\n     No → Decision: val <= minStack.top()? // if new val <= current min\n         Yes → minStack.push(val) // update min stack\n         No → // no change\n→ Function pop()\n  → Decision: mainStack empty? // if empty nothing to pop\n     Yes → // do nothing\n     No → Decision: top of mainStack == top of minStack? // check if popped element is current min\n         Yes → mainStack.pop(); minStack.pop() // pop both\n         No → mainStack.pop() // pop only main stack\n→ Function top()\n  → Decision: mainStack empty? // if empty return null\n     Yes → return null\n     No → return mainStack.top() // return top\n→ Function getMin()\n  → Decision: minStack empty? // if empty return null\n     Yes → return null\n     No → return minStack.top() // return current min\nEnd\n\nMake sure each line has arrow and comment. Also include indentation for decisions. Use \"Decision:\" lines. For lines inside decisions, indent maybe 4 spaces. Should follow format.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function MinStack() initialize mainStack empty // 初始化主堆疊  \n→ Function MinStack() initialize minStack empty // 初始化最小值堆疊  \n→ Function push(val) // 推入值到堆疊  \n  → mainStack.push(val) // 把值放進主堆疊  \n  → Decision: minStack empty? // 判斷最小堆疊是否為空  \n      Yes → minStack.push(val) // 如果空，直接把值作為最小值  \n      No  → Decision: val <= minStack.top()? // 檢查新值是否小於等於目前最小值  \n          Yes → minStack.push(val) // 若是，更新最小堆疊  \n          No  → // 若不是，最小堆疊保持不變  \n→ Function pop() // 移除堆疊頂端  \n  → Decision: mainStack empty? // 判斷主堆疊是否為空  \n      Yes → // 空時不做任何操作  \n      No  → Decision: mainStack.top() == minStack.top()? // 頂端值是否為最小值  \n          Yes → mainStack.pop(); minStack.pop() // 同時移除主堆疊和最小堆疊的頂端  \n          No  → mainStack.pop() // 只移除主堆疊的頂端  \n→ Function top() // 取得堆疊頂端值  \n  → Decision: mainStack empty? // 判斷主堆疊是否為空  \n      Yes → return null // 空時回傳 null  \n      No  → return mainStack.top() // 回傳主堆疊頂端值  \n→ Function getMin() // 取得目前最小值  \n  → Decision: minStack empty? // 判斷最小堆疊是否為空  \n      Yes → return null // 空時回傳 null  \n      No  → return minStack.top() // 回傳最小堆疊頂端值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MinStack:\n    \"\"\"Stack supporting push, pop, top, and retrieving min in O(1) time.\"\"\"\n    def __init__(self):\n        self.stack = []        # 主堆疊\n        self.min_stack = []    # 最小值堆疊\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        if val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self):\n        if not self.stack:\n            return None\n        return self.stack[-1]\n\n    def getMin(self):\n        if not self.min_stack:\n            return None\n        return self.min_stack[-1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入包成一個列表，以便使用 ast.literal_eval 解析\n    ops, args = ast.literal_eval('[' + data + ']')\n\n    stack = MinStack()\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MinStack\":\n            results.append(None)\n        elif op == \"push\":\n            stack.push(arg[0])\n            results.append(None)\n        elif op == \"pop\":\n            stack.pop()\n            results.append(None)\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"getMin\":\n            results.append(stack.getMin())\n        else:\n            results.append(None)\n\n    # 使用 json.dumps 以得到 null 的輸出格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "success": true,
          "output": "[null, null, null, null, -3, null, 0, -2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode12.json",
    "problem_index_in_file": 0,
    "title": "Integer to Roman",
    "description_snippet": "Seven different symbols represent Roman numerals with the following values:\n\nSymbol\tValue\nI\t1\nV\t5\nX\t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code step by step. We must handle Roman numeral conversion. The algorithm: mapping arrays of values and symbols. iterate through list. For each, while num >= value, append symbol. But need to handle subtractive cases: we could define arrays of values [1000,900,500,400,100,90,50,40,10,9,5,4,1] and symbols correspondingly. That covers subtractive. Then for each value, while num >= value, append symbol and subtract.\n\nBut we also need rule about no more than 3 consecutive I,X,C,M. But subtractive forms already handle that. If we use this value list approach, we don't need extra checks.\n\nWe'll produce virtual code lines: Start, define arrays, set num variable, result empty, loop over pairs, for each value while, append, subtract. End.\n\nNeed each line with explanation.\n\nLet's produce steps.\n\nUse Start, Step 1: 初始化數值與符號對應表 // define arrays\n\nStep 2: 讀取輸入整數 // input number\n\nStep 3: 初始化結果字串 // result\n\nStep 4: 遍歷對應表 // loop through pairs\n\nInside loop, Step 4a: While num >= value // check\n\nStep 4b: Append symbol // add to result\n\nStep 4c: Subtract value // update num\n\nAfter loop, Step 5: 輸出結果 // output\n\nEnd.\n\nWe need to format with arrows and Decision etc? Use arrows for steps and decisions. The main decision is while loop.\n\nLet's produce each line accordingly.\n\nWe'll use the format: \"Start // 程式開始執行\". Then \"→ Step 1: ...\" etc. For loops: \"→ Decision: 當 num ≥ value? // 判斷是否還能減去\" then Yes arrow to Step, No arrow to End of loop.\n\nLet's produce.\n\nAlso we might include variable names: values, symbols, i, num, result.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義值與符號對應表  \n  values ← [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] // 所有可用的數值，包含減法形式  \n  symbols ← [‘M’, ‘CM’, ‘D’, ‘CD’, ‘C’, ‘XC’, ‘L’, ‘XL’, ‘X’, ‘IX’, ‘V’, ‘IV’, ‘I’] // 對應符號  \n→ Step 2: 讀取輸入整數  \n  num ← Input() // 從使用者取得欲轉換的十進位數  \n→ Step 3: 初始化結果字串  \n  result ← ‘’ // 用來累積羅馬數字  \n→ Step 4: 從最高位到最低位逐個處理  \n  for i in 0 … len(values)-1 do  \n   → Decision: 如果 num ≥ values[i]? // 檢查是否還能使用此符號  \n     Yes → Step 4a: result ← result + symbols[i] // 加入符號",
      "generated_code": "import sys\nimport re\n\ndef int_to_roman(num: int) -> str:\n    \"\"\"將十進位整數轉換成羅馬數字。\"\"\"\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman = []\n    for v, s in zip(values, symbols):\n        count = num // v\n        if count:\n            roman.append(s * count)\n            num -= v * count\n    return \"\".join(roman)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料，並擷取第一個整數\n    raw = sys.stdin.read()\n    match = re.search(r\"\\d+\", raw)\n    if not match:\n        raise ValueError(\"未找到合法整數輸入\")\n    number = int(match.group())\n    # 轉換並輸出\n    print(int_to_roman(number))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 3749",
          "expected_output": "\"MMMDCCXLIX\"",
          "success": true,
          "output": "MMMDCCXLIX"
        },
        {
          "example_index": 1,
          "input": "num = 58",
          "expected_output": "\"LVIII\"",
          "success": true,
          "output": "LVIII"
        },
        {
          "example_index": 2,
          "input": "num = 1994",
          "expected_output": "\"MCMXCIV\"",
          "success": true,
          "output": "MCMXCIV"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode165.json",
    "problem_index_in_file": 0,
    "title": "Compare Version Numbers",
    "description_snippet": "Given two version strings, version1 and version2, compare them. A version string consists of revisio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. We'll produce steps: Start, split strings by '.', convert to int ignoring leading zeros, iterate up to max length, compare each revision, if less return -1, if greater return 1, after loop return 0. Need to consider missing revisions as 0. Use decision. Format: \"Start // 程式開始執行\". Each line with virtual code step and explanation. Use arrow notation. Ensure each line contains \"→\" or \"Yes →\" etc. Need to list each step line. Let's produce: Start, Split version1, Split version2, Compute lengths, Set maxLen, For i from 0 to maxLen-1: get rev1 (i < len1 ? int : 0), rev2 similarly. Decision: rev1 < rev2? Yes → return -1. No → Decision: rev1 > rev2? Yes → return 1. No → continue loop. After loop End return 0.\n\nBut we need each line. Let's enumerate:\n\nStart\n→ Step 1: Split version1 by '.' into list1 // 得到版本1的所有修訂號\n→ Step 2: Split version2 by '.' into list2 // 得到版本2的所有修訂號\n→ Step 3: 計算 len1 = list1.length // 版本1修訂數量\n→ Step 4: 計算 len2 = list2.length // 版本2修訂數量\n→ Step 5: 設定 maxLen = max(len1, len2) // 以較長的修訂數為比較基準\n→ Decision: For i from 0 to maxLen-1? // 逐一比較每個修訂\n    Yes →\n        → Step 6: 設定 rev1 = i < len1 ? int(list1[i]) : 0 // 取得版本1修訂值，缺省為0\n        → Step 7: 設定 rev2 = i < len2 ? int(list2[i]) : 0 // 取得版本2修訂值，缺省為0\n        → Decision: rev1 < rev2? // 比較兩個修訂值\n            Yes → Step 8: Return -1 // 版本1較小\n            No  →\n                → Decision: rev1 > rev2? // 比較兩個修訂值\n                    Yes → Step 9: Return 1 // 版本1較大\n                    No  → // 兩個修訂相等，繼續下一個\n        → // 迴圈結束\n    No →\n→ Step 10: Return 0 // 所有修訂相等，版本相同\nEnd\n\nBut we need to use Start and End markers and arrow formatting. Provide each line separately.\n\nNeed to ensure each line has arrow and explanation. For decisions we use \"Decision:\" lines. For loops we might use Decision with Yes/No? But loops can be expressed as Decision: i < maxLen? No but simpler: Use Step for loop start? Could use \"Decision: 迴圈結束?\" but better use explicit loop notation. Maybe use \"Loop: i from 0 to maxLen-1\" with steps inside. But the format requires use of \"Decision:\" for conditional. We can treat loop as Decision: i < maxLen? Yes ... No ... But we need to specify increments. Might be messy.\n\nSimplify: We'll use Step 6: For i from 0 to maxLen-1: // 迴圈開始, but we need to break into steps. Might produce:\n\n→ Step 6: For i = 0; i < maxLen; i++ // 逐一比較每個修訂\n\nBut we still need decisions inside.\n\nOk produce:\n\nStart // 程式開始執行\n→ Step 1: Split version1 by '.' into list1 // 取得版本1的修訂號列表\n→ Step 2: Split version2 by '.' into list2 // 取得版本2的修訂號列表\n→ Step 3: 計算 len1 = list1.length // 版本1的修訂數量\n→ Step 4: 計算 len2 = list2.length // 版本2的修訂數量\n→ Step 5: 設定 maxLen = max(len1, len2) // 以較長的修訂數作為比較基準\n→ Decision: i = 0; i < maxLen; i++? // 迴圈開始\n    Yes →\n        → Step 6: 設定 rev1 = i < len1 ? int(list1[i]) : 0 // 取得版本1第i個修訂值，若不存在則為0\n        → Step 7: 設定 rev2 = i < len2 ? int(list2[i]) : 0 // 取得版本2第i個修訂值，若不存在則為0\n        → Decision: rev1 < rev2? // 比較兩個修訂值\n            Yes → Step 8: Return -1 // 版本1小於版本2\n            No  →\n                → Decision: rev1 > rev2? // 比較兩個修訂值\n                    Yes → Step 9: Return 1 // 版本1大於版本2\n                    No  → // 修訂值相等，繼續迴圈\n    No →\n→ Step 10: Return 0 // 所有修訂相等，版本相同\nEnd // 程式結束\n\nBut we need to reflect loop properly. Might not be accurate. We can instead use \"Loop:\" style. But instructions only mention using \"Decision:\" and \"Yes →\", \"No →\". Loops may be represented as a decision with \"i < maxLen?\" but that yields an infinite loop? We can express iteration by increment inside step 6: i = i + 1? but that's not a step. Might be okay. Provide as simplified.\n\nBut the requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So each line must have an explanation comment. So we need to ensure every line has // comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Split version1 by '.' into list1 // 取得版本1的所有修訂號  \n→ Step 2: Split version2 by '.' into list2 // 取得版本2的所有修訂號  \n→ Step 3: 計算 len1 = list1.length // 版本1的修訂數量  \n→ Step 4: 計算 len2 = list2.length // 版本2的修訂數量  \n→ Step 5: 設定 maxLen = max(len1, len2) // 以較長的修訂數作為比較基準  \n→ Decision: i = 0; i < maxLen; i++? // 開始逐位比較迴圈  \n    Yes →  \n        → Step 6: 設定 rev1 = i < len1 ? int(list1[i]) : 0 // 取得版本1第i個修訂值，若不存在則為0  \n        → Step 7: 設定 rev2 = i < len2 ? int(list2[i]) : 0 // 取得版本2第i個修訂值，若不存在則為0  \n        → Decision: rev1 < rev2? // 比較兩個修訂值  \n            Yes → Step 8: Return -1 // 版本1小於版本2，直接返回  \n            No →  \n                → Decision: rev1 > rev2? // 比較兩個修訂值  \n                    Yes → Step 9: Return 1 // 版本1大於版本2，直接返回  \n                    No → // 修訂值相等，繼續迴圈  \n    No → // 迴圈結束，所有修訂已比較完  \n→ Step 10: Return 0 // 所有修訂相等，版本相同  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        \"\"\"\n        Compare two version strings according to the problem statement.\n        \"\"\"\n        v1 = [int(x) for x in version1.split('.')]\n        v2 = [int(x) for x in version2.split('.')]\n        n, m = len(v1), len(v2)\n        for i in range(max(n, m)):\n            num1 = v1[i] if i < n else 0\n            num2 = v2[i] if i < m else 0\n            if num1 < num2:\n                return -1\n            elif num1 > num2:\n                return 1\n        return 0\n\ndef main():\n    \"\"\"\n    Read input from stdin, parse the two version strings, compare them,\n    and print the result.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract quoted version strings (e.g., \"1.2\", \"1.10\")\n    versions = re.findall(r'\"([^\"]*)\"', data)\n    if len(versions) >= 2:\n        version1, version2 = versions[0], versions[1]\n    else:\n        # Fallback: split by whitespace if quotes are not present\n        parts = data.replace(',', ' ').split()\n        if len(parts) >= 2:\n            version1, version2 = parts[0], parts[1]\n        else:\n            # If input format is unexpected, exit silently\n            return\n\n    solution = Solution()\n    result = solution.compareVersion(version1, version2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "version1 = \"1.2\", version2 = \"1.10\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "version1 = \"1.01\", version2 = \"1.001\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "version1 = \"1.0\", version2 = \"1.0.0.0\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode692.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Words",
    "description_snippet": "Given an array of strings words and an integer k, return the k most frequent strings.\n\nReturn the an...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. We need to outline algorithm: Count frequencies, use heap or sort. Then sort by freq descending, lex ascending. Return top k.\n\nWe must write each step as virtual code lines, with arrow and comments. Use \"Start\", \"End\". Decision nodes for loops etc.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize frequency map // Count occurrences\n→ Decision: 遍歷 words? // For each word in words\n    Yes → Step 2: 增加 map[word] // increment count\n    No → Step 3: 建立 list of (word, freq) from map // Create list of pairs\n→ Decision: 是否需要排序? // Sort list\n    Yes → Step 4: 按 freq 降序, lex 升序排序 // Sorting criteria\n→ Step 5: 建立 result list // empty\n→ Decision: k 是否小於列表長度? // ensure k within bounds\n    Yes → Step 6: 取前 k 個元素 // push word to result\n    No → Step 6: 取所有元素 // push all words\n→ End // return result\n\nNeed to include arrows properly.\n\nLet's produce.\n\nBe careful: For loops, use Decision: while has elements? Use arrow for loop.\n\nWe can write:\n\nStart // 程式開始執行\n→ Step 1: 定義空字典 freqMap // 用於計數\n\n→ Decision: 是否開始遍歷 words? // 進行計數\n    Yes → Step 2: 對 words 中每個 word 進行迴圈\n        → Step 3: 若 word 仍在 freqMap 中，則 freqMap[word] += 1\n        → Step 4: 否則 freqMap[word] = 1\n    No → Step 5: 將 freqMap 轉成 list of (word, count) // pairs\n...\n\nBut we should maintain arrow indentation. Example:\n\nStart // 程式開始執行\n→ Step 1: freqMap = {} // 建立計數字典\n→ Decision: words 仍有未處理元素? // 開始計數\n    Yes → Step 2: 取下一個 word // 迭代\n        → Step 3: 若 word 在 freqMap 中，freqMap[word] += 1\n        → Step 4: 否則 freqMap[word] = 1\n    No → Step 5: 把 freqMap 轉成 pairsList // (word, count)\n...\n\nWe can also just describe as \"for each word\" without Decision.\n\nBetter to keep simple.\n\nLet's produce final answer with lines.\n\nAlso mention sorting step: Use custom comparator: (-freq, word).\n\nLet's write code accordingly.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: freqMap = {} // 建立空的頻率字典\n→ Decision: words 仍有未處理元素? // 開始遍歷 words\n    Yes → Step 2: 取下一個 word // 迴圈取出每個字串\n        → Step 3: 若 freqMap 包含 word, 則 freqMap[word] += 1 // 增加計數\n        → Step 4: 否則 freqMap[word] = 1 // 初始化計數為 1\n    No  → Step 5: pairsList = [] // 建立空的 (word, freq) 清單\n→ Decision: freqMap 還有鍵? // 將字典轉成清單\n    Yes → Step 6: 將每個 (key, value) 加入 pairsList // 補齊清單\n    No  → Step 7: // 已完成填充 pairsList\n→ Decision: pairsList 需要排序? // 準備排序\n    Yes → Step 8: pairsList.sort(key = (-freq, word)) // 先按頻率降序，再按字典序升序\n    No  → // 若清單已排序\n→ Step 9: result = [] // 建立結果清單\n→ Decision: k 大於 pairsList 長度? // 確認取出數量\n    Yes → Step 10: 取前 pairsList 長度個元素 // 取全部\n    No  → Step 10: 取前 k 個元素 // 只取 k 個\n→ End // 程式執行結束，返回 result\n\n(Note：虛擬碼中的 \"sort(key = (-freq, word))\" 表示先以頻率遞減排序，再以字典序遞增排序，符合題目要求。)",
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def topKFrequent(self, words, k):\n        \"\"\"\n        找出前 k 個出現頻率最高的字串。\n        若頻率相同則按字典序升序排序。\n        \"\"\"\n        count = Counter(words)\n        # 先按頻率遞減，再按字典序遞增排序\n        sorted_words = sorted(count.items(), key=lambda x: (-x[1], x[0]))\n        # 取前 k 個字串\n        return [word for word, freq in sorted_words[:k]]\n\ndef main():\n    \"\"\"\n    讀取輸入：\n        words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\n    解析後呼叫 Solution.topKFrequent，並輸出 JSON 格式的結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 允許輸入跨行的情況，先去掉所有換行符\n    data = data.replace('\\n', '')\n\n    # 以 ', k =' 分割，獲得 words 部分與 k 部分\n    try:\n        words_part, k_part = data.split(', k =')\n    except ValueError:\n        # 若輸入格式不符，直接返回\n        print(\"[]\")\n        return\n\n    # 解析 words 列表\n    _, words_str = words_part.split('=', 1)\n    words = ast.literal_eval(words_str.strip())\n\n    # 解析 k 整數\n    k = int(k_part.strip())\n\n    # 取得結果\n    solution = Solution()\n    result = solution.topKFrequent(words, k)\n\n    # 輸出為 JSON 格式，符合範例要求\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2",
          "expected_output": "[\"i\",\"love\"]",
          "success": true,
          "output": "[\"i\", \"love\"]"
        },
        {
          "example_index": 1,
          "input": "words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4",
          "expected_output": "[\"the\",\"is\",\"sunny\",\"day\"]",
          "success": true,
          "output": "[\"the\", \"is\", \"sunny\", \"day\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode728.json",
    "problem_index_in_file": 0,
    "title": "Self Dividing Numbers",
    "description_snippet": "A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Should cover algorithm: iterate from left to right, check each number if self-dividing. Steps: Start, loop, check digit zero, check divisibility, add to list. Finally End. Use Decision structure.\n\nWe need to output lines with format: \"虛擬碼步驟 // 解釋\". Use arrows. Provide list building. Use variable names: currentNumber, digit, isSelfDividing, resultList. Use Start, End. Also maybe helper function checkSelfDividing? Could inline. Let's produce steps.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 resultList ← [] // 用於儲存所有自除數  \n→ Step 2: currentNumber ← left // 設定目前要檢查的數字  \n→ Decision: currentNumber 是否小於等於 right? // 判斷是否還有數字可檢查  \n  Yes → Step 3: 設定 isSelfDividing ← True // 預設為自除數  \n   → Step 4: temp ← currentNumber // 用於提取每一位數字  \n   → Decision: temp 是否為 0? // 如果整數為 0，直接跳過  \n    Yes → Step 5: isSelfDividing ← False // 0 不是自除數  \n    No → Step 6: 循環 while temp > 0 // 逐位檢查每個數字  \n     → Step 7: digit ← temp % 10 // 取最低位數字  \n     → Decision: digit 是否為 0? // 自除數不允許 0  \n      Yes → Step 8: isSelfDividing ← False; break // 找到 0，結束檢查  \n      No → Step 9: Decision: currentNumber % digit 是否為 0? // 判斷是否能整除  \n       Yes → Step 10: 继续循环 // 能整除，繼續檢查下一位  \n       No → Step 11: isSelfDividing ← False; break // 無法整除，結束檢查  \n     → Step 12: temp ← temp / 10 // 移除已檢查的最低位  \n    → Step 13: end while // 完成所有位數的檢查  \n   → Decision: isSelfDividing 是否為 True? // 判斷是否為自除數  \n    Yes → Step 14: resultList ← resultList ∪ [currentNumber] // 加入結果列表  \n    No → Step 15: 不做任何操作 // 不是自除數，忽略  \n   → Step 16: currentNumber ← currentNumber + 1 // 移至下一個數字  \n   → goto Decision: currentNumber 是否小於等於 right? // 重新檢查條件  \n  No → End // 已完成所有數字的檢查，程式結束  \nEnd // 程式執行結束，返回 resultList",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int):\n        \"\"\"返回在 [left, right] 之間的所有自除數。\"\"\"\n        res = []\n        for num in range(left, right + 1):\n            temp = num\n            divisible = True\n            while temp > 0:\n                digit = temp % 10\n                if digit == 0 or num % digit != 0:\n                    divisible = False\n                    break\n                temp //= 10\n            if divisible:\n                res.append(num)\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read()\n    # 提取所有整數\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) >= 2:\n        left, right = nums[0], nums[1]\n    else:\n        # 若輸入格式不正確，直接結束\n        sys.exit(0)\n    solution = Solution()\n    result = solution.selfDividingNumbers(left, right)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 1, right = 22",
          "expected_output": "[1,2,3,4,5,6,7,8,9,11,12,15,22]",
          "success": true,
          "output": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"
        },
        {
          "example_index": 1,
          "input": "left = 47, right = 85",
          "expected_output": "[48,55,66,77]",
          "success": true,
          "output": "[48, 55, 66, 77]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1296.json",
    "problem_index_in_file": 0,
    "title": "Divide Array in Sets of K Consecutive Numbers",
    "description_snippet": "Given an array of integers nums and a positive integer k, check whether it is possible to divide thi...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step explanation. Problem: Given array nums, integer k, check if possible to split into sets of k consecutive numbers. Classic Leetcode 846. Approach: Count frequency, sort keys, iterate through sorted unique numbers, for each number, if count>0, attempt to fill a group starting from that number of length k, subtract counts. If any count negative, return false. Finally true. Provide pseudocode with steps. Use Start, End, Decision. Use arrow.\n\nWe produce lines: Start, Step 1: count frequencies, Step 2: sort unique numbers, Step 3: for each number in sorted order, Step 4: if freq>0, attempt group. Sub-step: for i from 0 to k-1, check freq of number+i; if zero, return false; else decrement. Use decisions. Provide final return true.\n\nLet's produce line by line. Use arrow. Each line: \"虛擬碼步驟 // 解釋\". Provide proper indentation for decisions.\n\nBe careful to include all steps: input, counting, sorting, iterate, decision if freq>0, inside loop iterate k times, decision if missing freq, decrement, else continue. After loop, End. Provide comments.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化一個空字典 freq // 用於記錄每個數字出現的次數\n→ Step 2: 對 nums 中的每個數字 num 執行\n    → freq[num] = freq.get(num, 0) + 1 // 更新頻率表\n→ Step 3: 將 freq 的鍵 (即所有不同數字) 取出並排序 → sorted_nums // 需要按升序處理，方便連續檢查\n→ Step 4: 對每個 number 在 sorted_nums 中執行\n    → Decision: 如果 freq[number] == 0? // 已經被前面的組用完，跳過\n        No → Continue to next number // 若為0則不進行後續操作\n        Yes → Proceed // 有剩餘個數，進行分組\n    → Step 5: 設定 count = freq[number] // 這個數字在未處理的數組中還剩多少個\n    → Step 6: 對 i 從 0 到 k-1 執行\n        → current = number + i // 目前需要檢查的連續數字\n        → Decision: 如果 freq.get(current, 0) < count? // 該連續數字是否有足夠個數\n            Yes → Step 7: Return False // 不能形成完整組，直接結束\n            No  → freq[current] -= count // 減去已使用的個數，繼續下一個 i\n    → Step 8: freq[number] = 0 // 完成該數字的所有分組\n→ End // 所有數字都能完整分組，返回 True\n→ Return True // 成功拆分，符合條件",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def isPossibleDivide(self, nums, k):\n        \"\"\"\n        判斷能否將 nums 分成每組 k 個連續整數的集合\n        \"\"\"\n        if len(nums) % k != 0:   # 數量必須能被 k 整除\n            return False\n\n        count = Counter(nums)\n        for num in sorted(count):\n            if count[num] > 0:                 # 需要處理這個數字\n                need = count[num]              # 該數字在這個組中需要的個數\n                for i in range(num, num + k):\n                    if count[i] < need:        # 連續數字不足\n                        return False\n                    count[i] -= need           # 減去已使用的個數\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入格式: \"nums = [1,2,3], k = 4\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    k_match   = re.search(r'k\\s*=\\s*([0-9]+)', data)\n\n    if not nums_match or not k_match:\n        print('false')\n        return\n\n    nums = ast.literal_eval(nums_match.group(1))\n    k    = int(k_match.group(1))\n\n    solution = Solution()\n    result = solution.isPossibleDivide(nums, k)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,3,4,4,5,6], k = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode238.json",
    "problem_index_in_file": 0,
    "title": "Product of Array Except Self",
    "description_snippet": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, explaining each. Use Start, End, Decision, arrow etc. Provide steps for product except self. Use two passes: left product, right product. Also array initialization. Provide O(n) time. No division. Provide explanation. Let's craft lines.\n\nWe start: Start. Then Step 1: Get length n from nums. Then Step 2: Initialize answer array of size n. Then Step 3: Left product loop. Then Step 4: Right product loop. End. Provide explanations.\n\nNeed arrow lines. Eg:\n\n→ Step 1: n ← length(nums) // 計算陣列長度\n\nUse arrow for steps.\n\nAlso decision for loops? Use Decision? We can use \"Decision: 0 ≤ i < n?\" etc. But can just use loops. Might use Decision: i < n? Yes → body, No → next.\n\nLet's produce. Provide lines with arrow and explanation after //.\n\nEnsure each line ends with // explanation. Use 1 indent for nested lines. Provide arrow. Let's craft.\n\nAlso we might need variable currRight. We'll do.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得輸入陣列的長度  \n→ Step 2: answer ← new array of size n // 初始化答案陣列  \n→ Decision: i ← 0  \n  Decision: i < n? // 檢查是否還有元素要處理  \n   Yes → Step 3: leftProduct ← 1 // 初始左邊乘積  \n    Decision: j ← 0  \n     Decision: j < n? // 從左到右遍歷陣列  \n      Yes → Step 4: answer[j] ← leftProduct // 把左邊乘積存入答案  \n       leftProduct ← leftProduct × nums[j] // 更新左邊乘積  \n       j ← j + 1 // 移動到下一個索引  \n       → Back to Decision: j < n?  \n       No → Step 5: rightProduct ← 1 // 初始右邊乘積  \n       Decision: k ← n - 1  \n        Decision: k ≥ 0? // 從右到左遍歷陣列  \n         Yes → Step 6: answer[k] ← answer[k] × rightProduct // 把右邊乘積乘入答案  \n          rightProduct ← rightProduct × nums[k] // 更新右邊乘積  \n          k ← k - 1 // 移動到上一個索引  \n         → Back to Decision: k ≥ 0?  \n         No → Step 7: return answer // 回傳完成的答案陣列  \n       No → Step 8: return answer // 若陣列為空也回傳空陣列  \n   Yes → → Back to Decision: i < n? // 處理完所有索引後結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def productExceptSelf(self, nums):\n        n = len(nums)\n        res = [1] * n\n        left = 1\n        for i in range(n):\n            res[i] = left\n            left *= nums[i]\n        right = 1\n        for i in range(n - 1, -1, -1):\n            res[i] *= right\n            right *= nums[i]\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 若輸入為形如 \"nums = [1,2,3,4]\"，移除前綴\n    if '=' in data:\n        _, nums_str = data.split('=', 1)\n        nums_str = nums_str.strip()\n    else:\n        nums_str = data\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        print(\"[]\")\n        sys.exit()\n    solution = Solution()\n    result = solution.productExceptSelf(nums)\n    print('[' + ','.join(str(x) for x in result) + ']')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "[24,12,8,6]",
          "success": true,
          "output": "[24,12,8,6]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,1,0,-3,3]",
          "expected_output": "[0,0,9,0,0]",
          "success": true,
          "output": "[0,0,9,0,0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode321.json",
    "problem_index_in_file": 0,
    "title": "Create Maximum Number",
    "description_snippet": "You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 re...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Problem: given two arrays of digits, produce maximum number of length k, preserving relative order within each array. Classic Leetcode 321 \"Create Maximum Number\". Steps: For each possible split i from max(0, k-n) to min(k, m): pick i digits from nums1 using stack to maximize subsequence of length i; pick k-i from nums2 similarly. Merge the two subsequences to form max number. Keep best. Use functions: maxSubsequence(arr, t) selecting t digits; merge(seq1, seq2). Compare lexicographically.\n\nWe need to write pseudo code step by step.\n\nLet's outline:\n\nStart\n→ Initialize result array of length k with zeros // placeholder for best number\n\n→ For i from max(0, k - n) to min(k, m):\n    // i digits from nums1, k-i from nums2\n    → Step: seq1 ← MaxSubsequence(nums1, i) // get best subsequence of length i\n    → Step: seq2 ← MaxSubsequence(nums2, k - i) // best of length k-i\n    → Step: candidate ← Merge(seq1, seq2) // merge to get max number\n    → Decision: If candidate > result? // compare lexicographically\n        Yes → result ← candidate\n\n→ End // return result\n\nNow we need to detail MaxSubsequence: use stack.\n\n→ Function MaxSubsequence(arr, t):\n    → Initialize empty stack\n    → For each digit d in arr:\n        → While stack not empty and d > top and remaining elements enough to fill t:\n            Pop\n        → If stack size < t:\n            Push d\n    → Return stack as array\n\nMerge:\n→ Function Merge(a, b):\n    → Initialize merged empty\n    → While a not empty or b not empty:\n        → If a > b lexicographically:\n            Pop from a and append\n        → Else:\n            Pop from b and append\n    → Return merged\n\nComparison:\n→ Function GreaterOrEqual(a, b):\n    → For i from 0 to len(a)-1:\n        If a[i] > b[i] return true\n        If a[i] < b[i] return false\n    → return true // equal\n\nWe should provide each step line. Let's craft the pseudo code with arrow.\n\nWe must include explanatory comment for each line. Use \"→\". Use \"Decision:\" lines. Use indentation for branches.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ result ← Array of k zeros // 儲存目前最佳的長度 k 數字\n\n→ For i ← max(0, k - n) to min(k, m) do // i 為從 nums1 取出的位數\n    // --------------------------------------------------------------------\n    → seq1 ← MaxSubsequence(nums1, i) // 從 nums1 取得長度 i 的最大子序列\n    → seq2 ← MaxSubsequence(nums2, k - i) // 從 nums2 取得長度 k-i 的最大子序列\n    → candidate ← Merge(seq1, seq2) // 合併兩個子序列得到長度 k 的數字\n    → Decision: candidate > result? // 比較兩個長度 k 數字的大小\n        Yes → result ← candidate // 如果候選數字更大，更新最佳結果\n        No  → // 不做任何事，保留現有結果\n    // --------------------------------------------------------------------\n\nEnd // 程式結束，回傳 result\n\n// --------------------- MaxSubsequence 函式 --------------------------------\n→ Function MaxSubsequence(arr, t) // 取得陣列 arr 內長度為 t 的最大子序列\n    → stack ← empty list // 使用堆疊維持選取的數字\n    → for each digit d in arr do\n        → while stack not empty AND d > stack.last AND (stack.size - 1 + remaining elements) ≥ t do\n            Pop stack.last // 放棄較小的數字以保留更大的\n        → if stack.size < t then\n            Push d onto stack // 將數字加入堆疊\n    → return stack // 堆疊即為所需子序列\n\n// --------------------- Merge 函式 ---------------------------------------\n→ Function Merge(a, b) // 合併兩個子序列 a、b 生成最大長度 k 數字\n    → merged ← empty list\n    → while a not empty OR b not empty do\n        → if Greater(a, b) then\n            Append a.first to merged\n            Remove a.first\n        → else\n            Append b.first to merged\n            Remove b.first\n    → return merged\n\n// --------------------- Greater 函式 -------------------------------------\n→ Function Greater(a, b) // 判斷兩個序列哪個更大（字典序比較）\n    → for i from 0 to max(a.length, b.length) - 1 do\n        → if i ≥ a.length then return false // a 已結束，b 繼續，b 更大\n        → if i ≥ b.length then return true // b 已結束，a 繼續，a 更大\n        → if a[i] > b[i] then return true\n        → if a[i] < b[i] then return false\n    → return true // 序列相等，視為 a 不小於 b",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def maxNumber(self, nums1, nums2, k):\n        # 取得長度 t 的最大子序列\n        def pick_max(nums, t):\n            drop = len(nums) - t          # 可以丟棄的數字數量\n            stack = []\n            for num in nums:\n                # 若堆疊頂部的數字比當前小，且還有可丟棄數量\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:t]              # 只保留前 t 個\n\n        # 合併兩個子序列，得到最大的長度 k 數字\n        def merge(a, b):\n            res = []\n            i = j = 0\n            while i < len(a) or j < len(b):\n                # 只要剩下的 a、b 之中，哪個序列較大就取前面那個\n                if a[i:] > b[j:]:\n                    res.append(a[i])\n                    i += 1\n                else:\n                    res.append(b[j])\n                    j += 1\n            return res\n\n        max_res = []  # 儲存目前最佳結果\n        # i 為從 nums1 取出的數字個數\n        for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\n            a = pick_max(nums1, i)\n            b = pick_max(nums2, k - i)\n            candidate = merge(a, b)\n            if candidate > max_res:\n                max_res = candidate\n        return max_res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n\n    # 用正則表達式抽取 nums1、nums2 與 k\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[[^\\]]*\\])', data)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match     = re.search(r'k\\s*=\\s*(\\d+)', data)\n\n    if not nums1_match or not nums2_match or not k_match:\n        print(\"Invalid input format\")\n        sys.exit(1)\n\n    nums1 = ast.literal_eval(nums1_match.group(1))\n    nums2 = ast.literal_eval(nums2_match.group(1))\n    k     = int(k_match.group(1))\n\n    # 求解並輸出結果\n    solution = Solution()\n    result = solution.maxNumber(nums1, nums2, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5",
          "expected_output": "[9,8,6,5,3]",
          "success": true,
          "output": "[9, 8, 6, 5, 3]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [6,7], nums2 = [6,0,4], k = 5",
          "expected_output": "[6,7,6,0,4]",
          "success": true,
          "output": "[6, 7, 6, 0, 4]"
        },
        {
          "example_index": 2,
          "input": "nums1 = [3,9], nums2 = [8,9], k = 3",
          "expected_output": "[9,8,9]",
          "success": true,
          "output": "[9, 8, 9]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode343.json",
    "problem_index_in_file": 0,
    "title": "Integer Break",
    "description_snippet": "Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the pro...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps. The problem: integer break maximizing product. Known solution: use greedy: break into as many 3's as possible, but if remainder 1, adjust by converting one 3+1 to 2+2. Implementation: if n==2 -> 1? Actually constraints: n>=2. For n=2 -> 1? For integer break problem, return 1. For n=3 -> 2. For others: compute.\n\nWe need to produce step-by-step pseudocode with arrows, decisions, etc. Each line: \"虛擬碼步驟 // 解釋\". Need to include Start, End, Decision: etc.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 n, maxProduct\n→ Decision: 如果 n == 2? Yes -> Return 1; No -> Continue\n→ Decision: 如果 n == 3? Yes -> Return 2; No -> Continue\n→ Step 2: 设计 count3 = n / 3 // 取最大的 3 的数量\n→ Step 3: remainder = n % 3 // 余数\n→ Decision: remainder == 0? Yes -> maxProduct = 3^count3; No -> Continue\n→ Decision: remainder == 1? Yes -> count3 -= 1; remainder += 3; // adjust to avoid 1\n→ Step 4: maxProduct = 3^count3 * remainder\n→ End\n\nBut need to use arrows and decisions. Use indentation for nested decisions. Provide explanation per line.\n\nAlso we might need to show loop? But not necessary.\n\nWe also need to not output actual code but virtual steps.\n\nLet's craft accordingly:\n\nStart // 程式開始\n\n→ Step 1: Read integer n // 取得輸入整數\n\n→ Decision: 如果 n == 2? // n=2 的特例\n    Yes → Step 2: Return 1 // 只能分成 1+1，乘積為 1\n    No  → Decision: 如果 n == 3? // n=3 的特例\n        Yes → Step 3: Return 2 // 只能分成 2+1，乘積為 2\n        No  → Step 4: 計算 count3 = n / 3 // 取最大的 3 的個數\n\n→ Step 5: remainder = n % 3 // 取得餘數\n\n→ Decision: remainder == 0? // 所有都能整除 3\n    Yes → Step 6: maxProduct = 3 ^ count3 // 直接 3 的冪\n    No  → Decision: remainder == 1? // 若餘數為 1\n        Yes → Step 7: count3 = count3 - 1; remainder = remainder + 3 // 把一個 3 合併成 4，避免 1\n        No  → Step 7: // remainder 為 2，無需調整\n    → Step 8: maxProduct = (3 ^ count3) * remainder // 結合剩餘\n\n→ Step 9: Return maxProduct // 輸出最大乘積\n\nEnd // 程式結束\n\nBut we must keep format: each line \"虛擬碼步驟 [space] // 解釋\". We need to indent decisions properly.\n\nAlso we need to use arrow '→' after decision lines: For Decision lines we include the arrow after the decision phrase. Eg:\n\n→ Decision: 如果 n == 2? // 解釋\n\nThen nested lines with indentation and arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read integer n // 取得使用者輸入的整數  \n→ Decision: 如果 n == 2? // 特例：n=2 只能分成 1+1  \n  Yes → Step 2: Return 1 // 乘積為 1  \n  No → Decision: 如果 n == 3? // 特例：n=3 只能分成 2+1  \n   Yes → Step 3: Return 2 // 乘積為 2  \n   No → Step 4: count3 = n / 3 // 取最大的 3 的個數  \n→ Step 5: remainder = n % 3 // 計算剩餘部分  \n→ Decision: remainder == 0? // 余數為 0，全部是 3  \n  Yes → Step 6: maxProduct = 3 ^ count3 // 直接 3 的冪乘積  \n  No → Decision: remainder == 1? // 余數為 1，需要調整  \n   Yes → Step 7: count3 = count3 - 1; remainder = remainder + 3 // 把一個 3 與 1 合併成 4，避免 1  \n   No → Step 7: // remainder 為 2，無需調整  \n   → Step 8: maxProduct = (3 ^ count3) * remainder // 計算最終乘積  \n→ Step 9: Return maxProduct // 輸出最大乘積  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def integerBreak(self, n: int) -> int:\n        \"\"\"\n        Return the maximum product obtainable by breaking n into\n        at least two positive integers.\n        \"\"\"\n        if n == 2:\n            return 1          # 1 + 1\n        if n == 3:\n            return 2          # 2 + 1\n\n        res = 1\n        # Greedy: keep taking 3s while it keeps the remainder > 4\n        while n > 4:\n            res *= 3\n            n -= 3\n        # Multiply the remaining part (2, 3, or 4)\n        return res * n\n\ndef main() -> None:\n    # Read entire stdin, extract the first integer\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n\n    solution = Solution()\n    print(solution.integerBreak(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 10",
          "expected_output": "36",
          "success": true,
          "output": "36"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode438.json",
    "problem_index_in_file": 0,
    "title": "Find All Anagrams in a String",
    "description_snippet": "Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, no actual code. Problem: find all anagram starting indices of pattern p in string s. Use sliding window, frequency maps, etc.\n\nSo steps: Start, initialize window size, frequency map for p, frequency map for current window, count of matched characters, list result. Iterate over s with index i, add char to window, if char in p freq, decrement count and track matched. When window size > p length, remove left char similarly. When matched equals size of map? Actually we can use matched count of matched characters equal to distinct letters? Or simpler: use counts array diff and maintain variable distinctDiff count. But virtual code can be generic.\n\nI'll write algorithm steps:\n\nStart\n→ Initialize variables: n = len(s), m = len(p)\n→ If m > n, return empty list\n→ Build freq map for p: mapP\n→ Build freq map for window: mapW (empty)\n→ matched = 0\n→ For i from 0 to n-1:\n   → Add s[i] to mapW; if s[i] in mapP: decrement count in mapW; if count becomes 0: increment matched\n   → If i >= m: remove s[i-m] from mapW; if s[i-m] in mapP: increment count in mapW; if count becomes 0: decrement matched\n   → If matched equals len(mapP): add i-m+1 to result\n→ End\n\nBut need to explain each line.\n\nAlso consider using arrays of size 26.\n\nLet's produce virtual code accordingly.\n\nAlso mention using mapW as char counts difference. matched count equals number of characters whose counts match.\n\nWill produce steps with arrow and comments.\n\nLet's output lines.\n\nAlso need to handle result list.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← len(s), m ← len(p) // 取得兩個字串長度  \n→ Decision: 如果 m > n? // 若模式長度大於來源字串，無法匹配  \n  Yes → Step 2: Return [] // 直接返回空陣列  \n  No  → Step 3: Build freqP ← Map() // 建立模式字串 p 的字母頻率表  \n    → For each char c in p: freqP[c] ← freqP.get(c,0)+1 // 計算每個字母出現次數  \n→ Step 4: freqW ← Map() // 建立滑動窗口的字母頻率表  \n→ Step 5: matched ← 0 // 追蹤已匹配的字母種類數  \n→ Step 6: result ← [] // 儲存所有符合條件的起始索引  \n→ For i from 0 to n-1: // 遍歷來源字串 s  \n  → charIn ← s[i] // 新進入窗口的字母  \n    → If charIn in freqP: // 只更新對應字母的計數  \n      freqW[charIn] ← freqW.get(charIn,0)+1  \n      如果 freqW[charIn] == freqP[charIn]: // 兩個表相同，字母已匹配  \n       matched ← matched+1  \n  → Decision: 如果 i >= m? // 窗口已超過模式長度，需要移除左邊字母  \n    Yes → charOut ← s[i-m] // 從左端移除的字母  \n      If charOut in freqP:  \n       freqW[charOut] ← freqW[charOut]-1  \n       如果 freqW[charOut] == freqP[charOut]-1: // 原本匹配的字母現在不再匹配  \n        matched ← matched-1  \n  → Decision: 如果 matched == len(freqP)? // 所有字母均已匹配，即為一個字母異序  \n    Yes → result.append(i-m+1) // 记录起始索引  \n→ End // 程式執行結束，返回 result\n\n(Note: 以上虛擬碼使用 Map() 代表鍵值對資料結構，get(key,0) 代表取值並預設為 0；頻率表用於比對字母數量是否一致，matched 代表已完全匹配的字母種類數。)",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def findAnagrams(self, s: str, p: str):\n        ns, np = len(s), len(p)\n        if ns < np:\n            return []\n\n        p_count = Counter(p)\n        s_count = Counter(s[:np])\n        res = []\n\n        if s_count == p_count:\n            res.append(0)\n\n        for i in range(1, ns - np + 1):\n            left_char = s[i - 1]\n            s_count[left_char] -= 1\n            if s_count[left_char] == 0:\n                del s_count[left_char]\n            right_char = s[i + np - 1]\n            s_count[right_char] += 1\n            if s_count == p_count:\n                res.append(i)\n\n        return res\n\ndef parse_input(data: str):\n    # Try to extract s and p from patterns like: s = \"cba\", p = \"abc\"\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    p_match = re.search(r'p\\s*=\\s*\"([^\"]*)\"', data)\n    if s_match and p_match:\n        return s_match.group(1), p_match.group(1)\n    # Fallback: assume first line is s, second line is p\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n    # If only one line, try to split by comma\n    parts = data.split(',')\n    if len(parts) == 2:\n        return parts[0].strip(), parts[1].strip()\n    # Default empty\n    return '', ''\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    s, p = parse_input(raw_data)\n    solution = Solution()\n    result = solution.findAnagrams(s, p)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"cbaebabacd\", p = \"abc\"",
          "expected_output": "[0,6]",
          "success": true,
          "output": "[0, 6]"
        },
        {
          "example_index": 1,
          "input": "s = \"abab\", p = \"ab\"",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode467.json",
    "problem_index_in_file": 0,
    "title": "Unique Substrings in Wraparound String",
    "description_snippet": "We define the string base to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so b...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps explaining solution: find number of unique non-empty substrings of s that appear in infinite wraparound string base. This is classic problem: Count unique substrings of s that are consecutive in alphabet with wrap. Approach: For each position, compute longest substring ending at i that satisfies consecutive property. Then maintain array maxLen[26] record maximum length of such substring ending with each letter. Finally sum all values. Let's produce step-by-step pseudocode.\n\nWe need to produce each line with \"虛擬碼步驟 // 解釋\". Use arrow, decision etc.\n\nLet's produce structure:\n\nStart\n→ Initialize array maxLen[26] to 0 // store max length for each ending letter\n→ Set currentLen = 0 // current consecutive length\n→ For each index i from 0 to length(s)-1\n    → If i>0 and (s[i] - s[i-1] == 1 or s[i-1]=='z' and s[i]=='a')\n        → currentLen = currentLen + 1\n        → Else currentLen = 1\n    → letterIndex = s[i] - 'a'\n    → maxLen[letterIndex] = max(maxLen[letterIndex], currentLen)\n→ Set result = 0\n→ For each value in maxLen\n    → result = result + value\n→ Return result\nEnd\n\nWe need to incorporate decisions? Only if condition for consecutive. We can use Decision block.\n\nLet's produce pseudocode lines accordingly.\n\nEnsure each line ends with comment. Use arrow formatting.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize array maxLen[26] to 0 // 依字母索引儲存以該字母結尾的最大連續子串長度\n→ Initialize currentLen to 0 // 目前符合連續性條件的子串長度\n→ For i from 0 to length(s)-1 // 遍歷輸入字串的每個字元\n    → Decision: 是否為連續字母? // 判斷 s[i] 是否與前一字元連續（含 z→a）\n        Yes → currentLen = currentLen + 1 // 若連續，長度加一\n        No  → currentLen = 1 // 若不連續，重置為 1（單字元子串）\n    → letterIndex = s[i] - 'a' // 將字母映射到 0~25 的索引\n    → Decision: 是否更新 maxLen[letterIndex]? // 若 currentLen 大於已儲存值則更新\n        Yes → maxLen[letterIndex] = currentLen\n        No  → // 保持原值\n→ Initialize result to 0 // 用於累加所有最大長度\n→ For each value in maxLen // 對每個字母計算\n    → result = result + value // 累加最大長度得到唯一子串數量\n→ Return result // 回傳總數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_unique_substrings(s: str) -> int:\n    \"\"\"\n    計算字符串 s 在無限 wraparound 字符串中出現的唯一非空子串個數。\n    采用 DP 方法，對每個字母記錄以該字母結尾的最大連續子串長度。\n    \"\"\"\n    # dp[i] 代表以字母 chr(i + ord('a')) 結尾的最大連續子串長度\n    dp = [0] * 26\n    current_len = 0  # 當前符合連續性的子串長度\n\n    for i, ch in enumerate(s):\n        if i > 0 and (ord(ch) - ord(s[i - 1])) % 26 == 1:\n            current_len += 1\n        else:\n            current_len = 1\n\n        idx = ord(ch) - ord('a')\n        if current_len > dp[idx]:\n            dp[idx] = current_len\n\n    # 所有 dp 的和即為唯一子串總數\n    return sum(dp)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取原始資料\n    raw_input = sys.stdin.read().strip()\n\n    # 嘗試從類似 s = \"...\" 的格式中提取字串\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        # 若格式不包含引號，直接去掉首尾空白\n        s = raw_input\n\n    result = count_unique_substrings(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode219.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate II",
    "description_snippet": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step-by-step, with arrow and decision. The requirement: virtual code steps with explanation after //, one line each. Use Start, End, Decision:, arrow \"→\". No real code. So we describe algorithm: iterate over array, keep map of last index of each value. For each index i, check if value exists in map and difference <= k, return true. After loop return false. Need to express steps.\n\nEnsure we follow format: each line \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Decision lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 hash map 'lastIndex' 為空 // 用於記錄每個數字最近一次出現的索引\n→ Step 2: 迭代遍歷 nums 中的每個元素，索引為 i // 逐一檢查每個位置\n    → Step 2.1: 取得 nums[i] 的值 val // 讀取當前元素\n    → Decision: val 是否已存在於 lastIndex? // 判斷此數字是否曾經出現\n        Yes → Step 2.2: 計算距離 diff = i - lastIndex[val] // 與上一個相同數字的距離\n            → Decision: diff <= k? // 檢查距離是否滿足條件\n                Yes → Step 2.3: 回傳 true // 找到符合條件的索引對\n                No  → Step 2.4: 更新 lastIndex[val] = i // 跳過不符合距離的情況，更新索引\n        No  → Step 2.5: 設置 lastIndex[val] = i // 第一次出現，記錄索引\n→ Step 3: 回傳 false // 未找到符合條件的索引對\nEnd // 程式執行結束\n\nWe need to follow each line separate. Use \"→\" arrow only at start of each step line, but decision lines have indent? The example uses indent. We can mimic.\n\nThus final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 hash map 'lastIndex' 為空 // 用於記錄每個數字最近一次出現的索引  \n→ Step 2: 迭代遍歷 nums 中的每個元素，索引為 i // 逐一檢查每個位置  \n    → Step 2.1: 取得 nums[i] 的值 val // 讀取當前元素  \n    → Decision: val 是否已存在於 lastIndex? // 判斷此數字是否曾經出現  \n        Yes → Step 2.2: 計算距離 diff = i - lastIndex[val] // 與上一個相同數字的距離  \n            → Decision: diff <= k? // 檢查距離是否滿足條件  \n                Yes → Step 2.3: 回傳 true // 找到符合條件的索引對  \n                No  → Step 2.4: 更新 lastIndex[val] = i // 跳過不符合距離的情況，更新索引  \n        No  → Step 2.5: 設置 lastIndex[val] = i // 第一次出現，記錄索引  \n→ Step 3: 回傳 false // 未找到符合條件的索引對  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"返回是否存在两条索引 i, j 满足 nums[i]==nums[j] 且 |i-j| <= k\"\"\"\n        index_map = {}\n        for i, num in enumerate(nums):\n            if num in index_map and i - index_map[num] <= k:\n                return True\n            index_map[num] = i\n        return False\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n\n    # 解析出 nums 列表\n    nums_match = re.search(r'\\[.*?\\]', data)\n    nums = eval(nums_match.group()) if nums_match else []\n\n    # 解析出 k 整數\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    k = int(k_match.group(1)) if k_match else 0\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.containsNearbyDuplicate(nums, k)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], k = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1], k = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,1,2,3], k = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode135.json",
    "problem_index_in_file": 0,
    "title": "Candy",
    "description_snippet": "There are n children standing in a line. Each child is assigned a rating value given in the integer ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the candy problem. We should describe algorithm: use two passes, left-to-right and right-to-left, track candies. Provide steps in virtual code with arrow lines. Each line includes explanation comment. No actual code.\n\nLet's craft. We'll use Start, Step lines, Decision. We'll include arrays and variables. We'll produce pseudocode lines.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 candies[0..n-1] 為 1 // 每個孩子至少拿一顆糖\n→ Step 2: 由左至右遍歷 children // 確保左側相鄰孩子的需求\n    → Decision: 如果 ratings[i] > ratings[i-1]? // 比左邊孩子評分高嗎？\n        Yes → candies[i] = candies[i-1] + 1 // 右邊孩子拿比左邊多一顆\n        No  → candies[i] = candies[i] // 保持現有值（已經是 1）\n→ Step 3: 由右至左遍歷 children // 確保右側相鄰孩子的需求\n    → Decision: 如果 ratings[i] > ratings[i+1]? // 比右邊孩子評分高嗎？\n        Yes → candies[i] = max(candies[i], candies[i+1] + 1) // 取最大以符合兩側條件\n        No  → candies[i] = candies[i] // 保持現有值\n→ Step 4: 計算 total = sum(candies) // 求所有糖果數量之和\n→ Step 5: 回傳 total // 最小糖果總數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def candy(self, ratings):\n        n = len(ratings)\n        if n == 0:\n            return 0\n        candies = [1] * n\n\n        # Left-to-right pass\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        # Right-to-left pass\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        return sum(candies)\n\ndef parse_ratings(input_str: str):\n    \"\"\"Parse input like 'ratings = [1,0,2]' or just '[1,0,2]' into a list of ints.\"\"\"\n    input_str = input_str.strip()\n    if '=' in input_str:\n        _, arr_part = input_str.split('=', 1)\n    else:\n        arr_part = input_str\n    arr_part = arr_part.strip()\n    try:\n        ratings = ast.literal_eval(arr_part)\n    except Exception:\n        # Fallback: extract numbers manually\n        import re\n        numbers = re.findall(r'-?\\d+', arr_part)\n        ratings = [int(num) for num in numbers]\n    if not isinstance(ratings, list):\n        raise ValueError(\"Invalid input format for ratings.\")\n    return ratings\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    ratings = parse_ratings(data)\n    solution = Solution()\n    result = solution.candy(ratings)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ratings = [1,0,2]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "ratings = [1,2,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode127.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining algorithm for word ladder length. Probably use BFS from beginWord to endWord using wordList as set. Steps: create set, if endWord not in set return 0. BFS queue with word and depth. While queue: pop word, depth; for each position, change letter a-z, if new word in set then if new==endWord return depth+1 else add to queue, remove from set to avoid revisiting. End. Return 0. Provide each line with explanation. Use Start, End. Provide arrow. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典集合 `wordSet = set(wordList)` // 將字典轉成集合，方便 O(1) 查詢  \n→ Decision: 若 `endWord` 不在 `wordSet`? // 檢查終點是否可達  \n    Yes → Step 2: 返回 0 // 若無法到達，直接結束並返回 0  \n    No  → Step 3: 初始化 BFS 隊列 `queue = [(beginWord, 1)]` // beginWord 位置深度為 1  \n    No  → Step 4: 如果 `beginWord` 在 `wordSet`，則從集合移除 `beginWord` // 避免重複訪問  \n→ Step 5: 開始 BFS 主循環 `while queue is not empty`  \n    → Step 6: 取出隊首元素 `(current, depth)` // 取得當前單詞與距離  \n    → Step 7: 對於 `i` 從 0 到 `len(current)-1`  \n        → Step 8: 對於每個字母 `c` 從 'a' 到 'z'  \n            → Decision: 若 `c` 等於 `current[i]`? // 跳過與原字母相同的變換  \n                Yes → Step 9: 繼續到下一個字母  \n                No  → Step 10: 產生新單詞 `nextWord = current[:i] + c + current[i+1:]` // 替換第 i 個字母  \n                No  → Decision: 若 `nextWord` 在 `wordSet`? // 檢查是否為合法字典單詞  \n                    Yes → Step 11: 若 `nextWord == endWord`? // 檢查是否為終點  \n                        Yes → Step 12: 返回 `depth + 1` // 找到最短路徑，返回長度  \n                        No  → Step 13: 把 `(nextWord, depth + 1)` 加入 `queue` // 加入下一層  \n                        No  → Step 14: 從 `wordSet` 移除 `nextWord` // 防止重複探索  \n                    No  → Step 15: 繼續到下一個字母  \n        → Step 16: 繼續到下一個位置  \n    → Step 17: 回到 `while queue is not empty`  \n→ Step 18: 回傳 0 // 若 BFS 結束仍未找到終點，表示無路徑  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: list[str]) -> int:\n        \"\"\"\n        計算從 beginWord 到 endWord 的最短轉換序列長度。\n        若無法到達則回傳 0。\n        \"\"\"\n        word_set = set(wordList)\n        if endWord not in word_set:          # 終點不存在於字典中\n            return 0\n\n        queue = deque([(beginWord, 1)])     # (目前單詞, 路徑長度)\n        # 若 beginWord 本身在字典，移除以免重複訪問\n        word_set.discard(beginWord)\n\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:             # 找到終點\n                return length\n            # 逐字母嘗試所有可能的替換\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c == word[i]:\n                        continue\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in word_set:\n                        word_set.remove(new_word)    # 標記已訪問\n                        queue.append((new_word, length + 1))\n        return 0                                 # 無法到達終點\n\ndef parse_input(text: str):\n    \"\"\"\n    解析輸入字串，取得 beginWord、endWord 與 wordList。\n    期望輸入類似:\n    'beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]'\n    \"\"\"\n    begin = re.search(r'beginWord\\s*=\\s*\"([^\"]*)\"', text)\n    end = re.search(r'endWord\\s*=\\s*\"([^\"]*)\"', text)\n    list_match = re.search(r'wordList\\s*=\\s*\\[([^\\]]*)\\]', text)\n\n    if not (begin and end and list_match):\n        raise ValueError(\"輸入格式錯誤\")\n\n    begin_word = begin.group(1)\n    end_word = end.group(1)\n\n    raw_list = list_match.group(1).strip()\n    if raw_list == '':\n        word_list = []\n    else:\n        # 以逗號分隔，再去除空白與雙引號\n        word_list = [w.strip().strip('\"').strip(\"'\") for w in raw_list.split(',') if w.strip()]\n    return begin_word, end_word, word_list\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    try:\n        b_word, e_word, w_list = parse_input(data)\n    except Exception:\n        print(0)\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.ladderLength(b_word, e_word, w_list)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode76.json",
    "problem_index_in_file": 0,
    "title": "Minimum Window Substring",
    "description_snippet": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code step by step for algorithm: minimum window substring. Use sliding window, hash map counts of t, track formed. Typical. We must provide each line with comment. Use Start, End, Decision, etc.\n\nLet's craft steps:\n\nStart\n→ Build hashmap dict_t of t counts\n→ Initialize required = size of dict_t (unique chars)\n→ Initialize left=0, right=0\n→ Initialize formed=0\n→ Initialize window_counts empty\n→ Initialize ans = (inf, None, None)\n→ While right < len(s):\n    → Add s[right] to window_counts\n    → If s[right] in dict_t and window_counts[s[right]] == dict_t[s[right]]:\n        → formed +=1\n    → While left <= right and formed == required:\n        → Update ans if smaller window\n        → Remove s[left] from window_counts\n        → If s[left] in dict_t and window_counts[s[left]] < dict_t[s[left]]:\n            → formed -=1\n        → left +=1\n    → right +=1\n→ After loop, if ans[0] == inf return \"\"\n→ Else return s[ans[1]:ans[2]+1]\n\nWe need to add virtual steps line by line, including decisions. Use Decision for conditions like formed==required, s[right] in dict_t etc.\n\nWe should not output actual code, just virtual. Use arrow symbols.\n\nWe need to format: each line \"虛擬碼步驟 // 解釋\" . Each step must include virtual code part before comment. Use arrows.\n\nLet's create.\n\nStart // 程式開始執行\n→ Build dict_t: for each char in t, count occurrences // 先統計 t 中每個字元的頻率\n→ Set required = number of keys in dict_t // 需要滿足的獨特字元數量\n→ Initialize left = 0, right = 0 // 左右指標起點\n→ Initialize formed = 0 // 當前窗口中已滿足需求的字元類型數\n→ Initialize window_counts as empty map // 追蹤當前窗口中字元的頻率\n→ Initialize ans = (∞, None, None) // 儲存最佳窗口長度及左右索引\n→ While right < len(s): // 逐步擴張右指標\n    → Add s[right] to window_counts // 將右指標字元加入窗口計數\n    → Decision: if s[right] in dict_t and window_counts[s[right]] == dict_t[s[right]]? // 檢查此字元是否滿足 t 的需求\n        Yes → formed += 1 // 符合需求的字元類型數增加\n        No  → // 不變\n    → Decision: while left <= right and formed == required? // 若窗口已滿足所有需求\n        Yes → Decision: if current window length < ans[0]? // 檢查是否為更小窗口\n            Yes → ans = (current length, left, right) // 更新最佳窗口\n            No  → // 不變\n        → Remove s[left] from window_counts // 從窗口中移除左指標字元\n        → Decision: if s[left] in dict_t and window_counts[s[left]] < dict_t[s[left]]? // 移除後該字元不足\n            Yes → formed -= 1 // 已不滿足該字元類型\n            No  → // 不變\n        → left += 1 // 收縮左指標\n    → right += 1 // 擴張右指標\n→ Decision: if ans[0] == ∞? // 有無找到有效窗口\n    Yes → Return \"\" // 無窗口符合條件\n    No  → Return s[ans[1]:ans[2]+1] // 返回最小窗口子字串\nEnd // 程式結束\n\nMake sure each line is one line with the arrow. For nested decisions, we need to indent? But each line is separate. We can use indent spaces? Might be okay. Provide as separate lines. Use \"→\" for each step. For decisions we need to show indentation? In example, they used indentation for nested lines. We'll mimic.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Build dict_t: for each char in t, count occurrences // 先統計 t 中每個字元的頻率  \n→ Set required = number of keys in dict_t // 需要滿足的獨特字元數量  \n→ Initialize left = 0, right = 0 // 左右指標起點  \n→ Initialize formed = 0 // 當前窗口中已滿足需求的字元類型數  \n→ Initialize window_counts as empty map // 追蹤當前窗口中字元的頻率  \n→ Initialize ans = (∞, None, None) // 儲存最佳窗口長度及左右索引  \n→ While right < len(s): // 逐步擴張右指標  \n → Add s[right] to window_counts // 將右指標字元加入窗口計數  \n → Decision: if s[right] in dict_t and window_counts[s[right]] == dict_t[s[right]]? // 檢查此字元是否滿足 t 的需求  \n  Yes → formed += 1 // 符合需求的字元類型數增加  \n  No  → // 不變  \n → Decision: while left <= right and formed == required? // 若窗口已滿足所有需求  \n  Yes → Decision: if current window length < ans[0]? // 檢查是否為更小窗口  \n   Yes → ans = (current length, left, right) // 更新最佳窗口  \n   No  → // 不變  \n  → Remove s[left] from window_counts // 從窗口中移除左指標字元  \n  → Decision: if s[left] in dict_t and window_counts[s[left]] < dict_t[s[left]]? // 移除後該字元不足  \n   Yes → formed -= 1 // 已不滿足該字元類型  \n   No  → // 不變  \n  → left += 1 // 收縮左指標  \n → right += 1 // 擴張右指標  \n→ Decision: if ans[0] == ∞? // 有無找到有效窗口  \n Yes → Return \"\" // 無窗口符合條件  \n No  → Return s[ans[1]:ans[2]+1] // 返回最小窗口子字串  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n        dict_t = Counter(t)\n        required = len(dict_t)\n        l, r = 0, 0\n        formed = 0\n        window_counts = {}\n        ans = float(\"inf\"), None, None\n\n        while r < len(s):\n            character = s[r]\n            window_counts[character] = window_counts.get(character, 0) + 1\n            if character in dict_t and window_counts[character] == dict_t[character]:\n                formed += 1\n\n            while l <= r and formed == required:\n                character = s[l]\n                if r - l + 1 < ans[0]:\n                    ans = (r - l + 1, l, r)\n                window_counts[character] -= 1\n                if character in dict_t and window_counts[character] < dict_t[character]:\n                    formed -= 1\n                l += 1\n            r += 1\n\n        return \"\" if ans[0] == float(\"inf\") else s[ans[1]:ans[2] + 1]\n\ndef parse_input(data: str):\n    # Try to extract quoted strings first (handles the \"s = \"ADOBECODEBANC\", t = \"ABC\"\" format)\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n    # Fallback to simple line split\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    s = lines[0] if lines else \"\"\n    t = lines[1] if len(lines) > 1 else \"\"\n    return s, t\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, t = parse_input(raw_input)\n    result = Solution().minWindow(s, t)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
          "expected_output": "\"BANC\"",
          "success": true,
          "output": "BANC"
        },
        {
          "example_index": 1,
          "input": "s = \"a\", t = \"a\"",
          "expected_output": "\"a\"",
          "success": true,
          "output": "a"
        },
        {
          "example_index": 2,
          "input": "s = \"a\", t = \"aa\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode420.json",
    "problem_index_in_file": 0,
    "title": "Strong Password Checker",
    "description_snippet": "A password is considered strong if the below conditions are all met:\n\nIt has at least 6 characters a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm to compute min steps to make password strong, with conditions: length 6-20, at least one lowercase, uppercase, digit, no 3 repeating. Allowed ops: insert, delete, replace. Classic Leetcode 420. We need to output virtual steps line by line with explanation. We need to use Start, End, Decision. Provide each step.\n\nWe need to describe algorithm: calculate missing types, find repeats groups, compute deletes needed, replacements needed, insertions needed. Use formulas. Provide pseudo steps.\n\nWe'll produce steps like:\n\nStart // Program start\n→ Step 1: Compute missing types count // count missing lowercase, uppercase, digit\n→ Step 2: Find all sequences of 3+ repeating chars, record their lengths\n→ Step 3: If length < 6, compute insertsNeeded = 6 - length\n→ Step 4: If length > 20, compute deletesNeeded = length - 20\n    → Decision: deletesNeeded > 0?\n        Yes → Step 5: Use deletes to reduce repeats\n→ Step 6: Compute replacementsNeeded = sum of floor(len/3) for each repeat after deletions\n→ Step 7: If length <=20:\n    → Decision: length < 6?\n        Yes → Step 8: result = max(missingTypes, insertsNeeded, replacementsNeeded)\n        No  → Step 9: result = max(missingTypes, replacementsNeeded)\n→ Step 10: If length >20:\n    → Step 10: result = deletesNeeded + max(missingTypes, replacementsNeeded)\nEnd\n\nBut need more detailed lines maybe. Provide each line with explanation.\n\nWe need to incorporate decision structure for deletes affecting replacements. We might include loop to reduce repeats using deletes.\n\nLet's outline:\n\nStart\n→ Step 1: Initialize missingTypes = 0\n→ Step 2: For each char in password: update flags for lower, upper, digit\n→ Step 3: missingTypes = 3 - (hasLower + hasUpper + hasDigit)\n→ Step 4: Find repeat sequences: iterate password, count consecutive same char lengths >2, store lengths\n→ Step 5: Compute len = password length\n→ Step 6: If len < 6: insertsNeeded = 6 - len\n→ Step 7: If len > 20: deletesNeeded = len - 20\n    → Decision: deletesNeeded > 0?\n        Yes → Step 8: For each repeat length, reduce by deletions prioritized by mod 3\n            → loop over repeats sorted by length % 3 == 0, then 1, then 2\n→ Step 9: After deletions, compute replacementsNeeded = sum of floor(length/3) for each repeat\n→ Step 10: If len <=20:\n    → Decision: len < 6?\n        Yes → Step 11: result = max(missingTypes, insertsNeeded, replacementsNeeded)\n        No  → Step 12: result = max(missingTypes, replacementsNeeded)\n→ Step 13: If len >20:\n    → Step 14: result = deletesNeeded + max(missingTypes, replacementsNeeded)\nEnd\n\nWe can add explanations each step. Use arrow syntax. Provide each line.\n\nMake sure to follow output format: each line with virtual code step + space + // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize missingTypes = 0 // 先設定缺失類型計數器  \n→ Step 2: hasLower ← 0, hasUpper ← 0, hasDigit ← 0 // 旗標變數，判斷是否存在對應字符  \n→ Step 3: For each char c in password: // 遍歷輸入字串  \n     If 'a' ≤ c ≤ 'z': hasLower ← 1 // 有小寫字母  \n     Else if 'A' ≤ c ≤ 'Z': hasUpper ← 1 // 有大寫字母  \n     Else if '0' ≤ c ≤ '9': hasDigit ← 1 // 有數字  \n→ Step 4: missingTypes ← 3 - (hasLower + hasUpper + hasDigit) // 計算缺失類型數量  \n→ Step 5: repeats ← empty list // 用於儲存連續重複字符段長度  \n→ Step 6: i ← 0 // 初始化索引  \n→ Decision: i < len(password)? // 檢查是否已遍歷完字串  \n  Yes → Step 7: j ← i // 開始新的重複段  \n     While j < len(password) AND password[j] = password[i]: j ← j + 1 // 找到重複段結束  \n     If j - i ≥ 3: repeats.append(j - i) // 只記錄長度 ≥ 3 的段  \n     i ← j // 移到下一段起始位置  \n  No → Step 8: // 重複段掃描結束  \n→ Step 9: length ← len(password) // 取得原始長度  \n→ Decision: length < 6? // 長度過短需要插入  \n  Yes → Step 10: insertsNeeded ← 6 - length // 計算必須插入的字符數  \n  No → Step 11: insertsNeeded ← 0 // 長度已足夠  \n→ Decision: length > 20? // 長度過長需要刪除  \n  Yes → Step 12: deletesNeeded ← length - 20 // 計算必須刪除的字符數  \n     → Decision: deletesNeeded > 0?  \n      Yes → Step 13: // 使用刪除來減少重複段  \n       For each r in repeats sorted by r % 3 ascending: // 先處理 r%3==0, 再 1, 再 2  \n        While deletesNeeded > 0 AND r ≥ 3:  \n           If r % 3 == 0: reduceCount ← 1  \n           Else if r % 3 == 1: reduceCount ← 1  \n           Else: reduceCount ← 1  \n           r ← r - reduceCount  \n           deletesNeeded ← deletesNeeded - reduceCount  \n           If r < 3: remove r from repeats // 不再需要計算  \n           Else: update repeats entry with new r  \n           End While  \n       End For  \n       // 刪除後 recompute replacements needed  \n       Step 14: // 替換數量計算  \n       replacementsNeeded ← sum(floor(r/3) for r in repeats) // 每三個重複需一個替換  \n       End If  \n      No → Step 15: deletesNeeded ← 0 // 長度已符合範圍  \n       Step 16: // 替換數量計算  \n       replacementsNeeded ← sum(floor(r/3) for r in repeats) // 不需要刪除時直接計算  \n  No → Step 17: // 長度在 6-20 範圍內  \n     Step 18: // 若已刪除，替換數量已計算完畢  \n→ Decision: length < 6? // 仍需插入  \n  Yes → Step 19: result ← max(missingTypes, insertsNeeded, replacementsNeeded) // 取最大步驟數  \n  No → Step 20: result ← max(missingTypes, replacementsNeeded) // 取最大步驟數  \n→ Decision: length > 20? // 需要刪除的情況  \n  Yes → Step 21: result ← deletesNeeded + max(missingTypes, replacementsNeeded) // 刪除 + 其餘修正  \n  No → Step 22: // 已處理完畢  \n→ Step 23: Return result // 回傳最小步驟數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def strongPasswordChecker(self, s: str) -> int:\n        n = len(s)\n\n        # 1. Count missing character types\n        has_lower = has_upper = has_digit = 0\n        for c in s:\n            if c.islower():\n                has_lower = 1\n            elif c.isupper():\n                has_upper = 1\n            elif c.isdigit():\n                has_digit = 1\n        missing_types = 3 - (has_lower + has_upper + has_digit)\n\n        # 2. Find repeating sequences and compute replacements needed\n        replace = 0          # total replacements needed for repeats\n        one_mod = two_mod = 0\n        i = 2\n        while i < n:\n            if s[i] == s[i - 1] == s[i - 2]:\n                length = 2\n                while i < n and s[i] == s[i - 1]:\n                    length += 1\n                    i += 1\n                replace += length // 3\n                if length % 3 == 0:\n                    one_mod += 1\n                elif length % 3 == 1:\n                    two_mod += 1\n            else:\n                i += 1\n\n        # 3. Handle length constraints\n        if n < 6:\n            # Need inserts; replacements and missing types are also counted\n            return max(6 - n, missing_types, replace)\n        elif n <= 20:\n            # Only replacements and missing types matter\n            return max(replace, missing_types)\n        else:\n            # Delete characters to bring length <= 20\n            delete = n - 20\n\n            # Use deletions to reduce replacements\n            reduce = min(delete, one_mod)\n            replace -= reduce\n            delete -= reduce\n\n            reduce = min(delete // 2, two_mod)\n            replace -= reduce\n            delete -= reduce * 2\n\n            replace -= delete // 3\n            # Total steps = deletions + max(missing types, remaining replacements)\n            return (n - 20) + max(missing_types, replace)\n\ndef main():\n    data = sys.stdin.read()\n    # Extract the password string inside quotes\n    match = re.search(r'[\"\\'](.*?)[\"\\']', data)\n    if match:\n        password = match.group(1)\n    else:\n        # If no quotes found, assume the whole input is the password\n        password = data.strip()\n    result = Solution().strongPasswordChecker(password)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "password = \"a\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "password = \"aA1\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "password = \"1337C0d3\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode643.json",
    "problem_index_in_file": 0,
    "title": "Maximum Average Subarray I",
    "description_snippet": "You are given an integer array nums consisting of n elements, and an integer k.\n\nFind a contiguous s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code for sliding window algorithm: compute sum of first k, track max sum, then iterate, subtract leaving, add entering, update max. After loop, return maxSum / k.\n\nAlso must include Start and End. Use Decision? Not necessary but can use. Use comments.\n\nNeed each line: virtual code step + space + // explanation.\n\nUse arrow (→) and Decision. Provide line by line.\n\nLet's craft.\n\nLine1: Start // begin program\n\nLine2: → Input: nums, k // get inputs\n\nLine3: → n ← length(nums) // n\n\nLine4: → if k > n then // handle edge case\n\nLine5:      Yes → Return 0 // or throw error? We'll just return 0\n\nLine6:      No →\n\nLine7: → sum ← 0 // initial sum\n\nLine8: → for i from 0 to k-1 do // sum first k elements\n\nLine9:      sum ← sum + nums[i] // accumulate\n\nLine10: → maxSum ← sum // initialize max\n\nLine11: → for i from k to n-1 do // sliding window\n\nLine12:      sum ← sum - nums[i-k] // remove leftmost\n\nLine13:      sum ← sum + nums[i] // add new element\n\nLine14:      if sum > maxSum then // update max\n\nLine15:          maxSum ← sum\n\nLine16: → average ← maxSum / k // compute average\n\nLine17: → Return average // output\n\nLine18: End // end\n\nWe need to include Decision arrow lines.\n\nLet's structure with Decision: For if sum > maxSum.\n\nLet's ensure each line uses arrow style. Provide the arrow arrow or Decision.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: nums, k // 從使用者取得整數陣列及目標長度 k  \n→ n ← length(nums) // 取得陣列長度 n  \n→ Decision: 如果 k > n? // 檢查 k 是否大於陣列長度  \n Yes → Return 0 // 若 k 超過 n，直接回傳 0（或可拋出錯誤）  \n No  → // 繼續執行  \n→ sum ← 0 // 初始化滑動窗口總和  \n→ for i from 0 to k-1 do // 計算前 k 個元素之和  \n  sum ← sum + nums[i] // 累加第 i 個元素  \n→ maxSum ← sum // 設定初始最大總和為第一個窗口的總和  \n→ for i from k to n-1 do // 從第 k 個元素開始滑動窗口  \n  sum ← sum - nums[i-k] // 移除窗口左端的元素  \n  sum ← sum + nums[i] // 加入新進來的元素  \n  Decision: 如果 sum > maxSum? // 判斷是否更新最大總和  \n   Yes → maxSum ← sum // 若更大則更新  \n   No  → // 不更新  \n→ average ← maxSum / k // 計算最大平均值  \n→ Return average // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMaxAverage(self, nums, k):\n        \"\"\"\n        Sliding window to find maximum average of subarray of length k.\n        \"\"\"\n        # Sum of the first window\n        window_sum = sum(nums[:k])\n        max_sum = window_sum\n\n        # Slide the window through the array\n        for i in range(k, len(nums)):\n            # Update the window sum by removing the element leaving\n            # the window and adding the new element entering.\n            window_sum += nums[i] - nums[i - k]\n            # Keep track of the maximum sum seen so far.\n            if window_sum > max_sum:\n                max_sum = window_sum\n\n        # Return the maximum average.\n        return max_sum / k\n\ndef main():\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n\n    # Extract all integers from the input string.\n    # The last integer is k; all preceding integers form the list nums.\n    nums_and_k = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums_and_k:\n        return\n\n    k = nums_and_k[-1]\n    nums = nums_and_k[:-1]\n\n    # Compute the maximum average subarray of length k.\n    solution = Solution()\n    result = solution.findMaxAverage(nums, k)\n\n    # Output the result with 5 decimal places.\n    print(f\"{result:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,12,-5,-6,50,3], k = 4",
          "expected_output": "12.75000",
          "success": true,
          "output": "12.75000"
        },
        {
          "example_index": 1,
          "input": "nums = [5], k = 1",
          "expected_output": "5.00000",
          "success": true,
          "output": "5.00000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode258.json",
    "problem_index_in_file": 0,
    "title": "Add Digits",
    "description_snippet": "Given an integer num, repeatedly add all its digits until the result has only one digit, and return ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for digital root problem. Use Start, Decision, End. Provide line per step. Use arrow lines. Use virtual code and explanation. No real code.\n\nWe need to produce something like:\n\nStart // start program\n→ Step 1: input num // get integer\n→ Decision: if num <= 0? // check if <=0, if so, maybe handle error\n...\nBut digital root: repeatedly sum digits until single digit. Steps:\n\n1. Input num.\n2. While num >= 10:\n   - Set sum = 0\n   - While num > 0:\n        sum += num % 10\n        num = num / 10\n   - num = sum\n3. Output num\n\nWe must provide virtual code line by line. Use arrow for nested loops: perhaps indent.\n\nLet's produce a clear virtual code:\n\nStart\n→ Step 1: input num\n→ Decision: 如果 num <= 0? // 檢查是否為合法正整數\n    Yes → Step 2: 輸出錯誤訊息\n    No  →\n        → Decision: 如果 num < 10? // 已經是一位數\n            Yes → Step 3: 輸出 num // 回傳結果\n            No  →\n                → Step 4: sum = 0 // 初始化和\n                → Step 5: temp = num // 用於拆分\n                → While temp > 0:\n                    → sum = sum + (temp mod 10) // 加上最低位\n                    → temp = temp div 10 // 去掉最低位\n                → Step 6: num = sum // 將和重新賦值\n                → Go back to Decision: 如果 num < 10? // 檢查是否已為一位數\n\nBut we need to show arrow for while loops etc.\n\nLet's produce final output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 輸入使用者整數 num // 取得要進行求數位根的數值\n→ Decision: 如果 num <= 0? // 檢查輸入是否為正整數\n    Yes → Step 2: 輸出 '錯誤: 請輸入正整數' // 非正數則直接報錯\n    No  → \n        → Decision: 如果 num < 10? // 已經是一位數，直接結束\n            Yes → Step 3: 輸出 num // 回傳結果\n            No  → \n                → Step 4: sum = 0 // 初始化本次加總\n                → Step 5: temp = num // 用於拆分數位\n                → While temp > 0: // 逐位拆分並相加\n                    → sum = sum + (temp mod 10) // 加上最低位\n                    → temp = temp div 10 // 去掉已處理的最低位\n                → Step 6: num = sum // 將相加結果重新賦值給 num\n                → Go back to Decision: 如果 num < 10? // 再次判斷是否已成一位數\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\n\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        \"\"\"反覆把數字各位相加直到只剩一位數.\"\"\"\n        while num >= 10:\n            # 把整數轉成字串，再把每一個字符轉回整數並求和\n            num = sum(int(d) for d in str(num))\n        return num\n\ndef parse_input(input_str: str) -> int:\n    \"\"\"\n    解析輸入字串，支援兩種格式：\n    1. 直接輸入整數，例如 '38' 或 '0'\n    2. 'num = 38' 這類形式\n    \"\"\"\n    input_str = input_str.strip()\n    if '=' in input_str:\n        # 分離 '='，取等號右邊作為數字\n        _, num_part = input_str.split('=', 1)\n        return int(num_part.strip())\n    else:\n        return int(input_str)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_data = sys.stdin.read()\n    # 只處理第一行或整個輸入視為單個數字\n    num = parse_input(raw_data)\n    solver = Solution()\n    result = solver.addDigits(num)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 38",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode696.json",
    "problem_index_in_file": 0,
    "title": "Count Binary Substrings",
    "description_snippet": "Given a binary string s, return the number of non-empty substrings that have the same number of 0's ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code (pseudocode) that counts binary substrings with equal numbers of 0 and 1, consecutive groups. Classic Leetcode 696. Approach: iterate through string, count consecutive runs lengths. For each adjacent pair of runs, result += min(len[i], len[i+1]). Steps: Start, read string, compute runs, sum min of adjacent runs, output count.\n\nWe must output line by line with comments.\n\nLet's produce lines:\n\nStart\n→ Step 1: input string s // get binary string\n→ Step 2: initialize empty list runs // store lengths of consecutive characters\n→ Step 3: initialize count = 0 // result\n→ Step 4: for i from 0 to len(s)-1 // iterate through characters\n   (we can structure: Decision: if current char same as previous? etc.)\n\nSimplify: Use variables: currChar, currLen. Iterate and push to runs when char changes. Then after loop push last run. Then compute sum of min of consecutive pairs. Then End.\n\nLet's craft step by step.\n\nWe'll use Decision: if i==0? to initialize.\n\nBetter: Use pseudo:\n\nStep 5: currChar = s[0]; currLen = 1\nStep 6: for i from 1 to len(s)-1\n   Decision: if s[i] == currChar?\n       Yes → currLen +=1\n       No → append currLen to runs; currChar = s[i]; currLen =1\nStep 7: after loop, append currLen to runs // last run\n\nStep 8: for j from 0 to len(runs)-2\n   count += min(runs[j], runs[j+1]) // each pair contributes min\n\nStep 9: output count\n\nLet's format with arrows and comments.\n\nAlso use Decision arrows.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入二進位字串 s // 取得待處理字串  \n→ Step 2: 建立空串列 runs // 用來儲存連續相同字元的長度  \n→ Step 3: 初始化變數 currChar = s[0], currLen = 1 // 以第一個字元作為起點  \n→ Decision: s 是否為空?  \n   No  → // 字串非空，執行下一步  \n   Yes → End // 字串為空，直接結束，結果為 0  \n→ Step 4: 迴圈 i 從 1 到 len(s)-1 // 遍歷剩餘字元  \n   → Decision: s[i] == currChar? // 檢查是否為同一字元  \n        Yes → currLen += 1 // 同一字元，累加長度  \n        No  → runs.append(currLen) // 結束前一段，加入 runs  \n             → currChar = s[i] // 更新為新字元  \n             → currLen = 1 // 重置長度為 1  \n→ Step 5: runs.append(currLen) // 將最後一段長度加入 runs  \n→ Step 6: 初始化變數 count = 0 // 結果計數器  \n→ Step 7: 迴圈 j 從 0 到 len(runs)-2 // 逐對比較相鄰段長度  \n   → count += min(runs[j], runs[j+1]) // 每對段對應可形成 min 個合法子字串  \n→ Step 8: 輸出 count // 顯示符合條件的子字串總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef count_binary_substrings(s: str) -> int:\n    \"\"\"計算符合條件的子字串個數\"\"\"\n    if not s:\n        return 0\n\n    groups = []          # 存放每個連續相同字元的長度\n    cur_len = 1          # 第一次字元已計算一次\n\n    # 逐字元比較，建立 groups\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            cur_len += 1\n        else:\n            groups.append(cur_len)\n            cur_len = 1\n    groups.append(cur_len)   # 加上最後一段\n\n    # 計算相鄰兩段長度的最小值之和\n    result = 0\n    for i in range(1, len(groups)):\n        result += min(groups[i], groups[i - 1])\n\n    return result\n\n\ndef main() -> None:\n    \"\"\"主程式，從標準輸入讀取字串並輸出答案\"\"\"\n    data = sys.stdin.read()                     # 讀取所有輸入\n    s = ''.join(ch for ch in data if ch in '01')  # 只保留 '0' 與 '1'\n    ans = count_binary_substrings(s)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"00110011\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "s = \"10101\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode205.json",
    "problem_index_in_file": 0,
    "title": "Isomorphic Strings",
    "description_snippet": "Given two strings s and t, determine if they are isomorphic.\n\nTwo strings s and t are isomorphic if ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Task: given two strings s and t, determine if they are isomorphic. We'll outline algorithm: check lengths equal, maintain mapping dict and reverse set, iterate over pairs of chars, if mapping exists ensure matches else check if target char already mapped to by other source; if yes conflict; else set mapping. At end return true. Also need Start, End. Use Decision. Provide each step.\n\nWe need to produce in Traditional Chinese. Use \"Start // 程式開始執行\". Provide each line with explanation.\n\nUse arrows → and Decision: format. Also for loops? Could use Decision for loop? Could use a \"While\" but not necessary.\n\nWe can represent loop as \"Step: for i in 0..len-1\". But keep simple. Use Decision: If len(s) != len(t)? etc. Let's produce.\n\nLine 1: Start // 程式開始執行\nLine 2: → Step 1: 取得 s, t // 取得輸入字串\nLine 3: → Decision: s 長度與 t 長度相等? // 判斷長度是否相同\nLine 4: Yes → Step 2: 初始化 mapping 字典, 已映射字符集合 // 準備映射資料結構\nLine 5: → Step 3: 為 i 從 0 到 len(s)-1 迴圈 // 逐字元檢查\nLine 6: → Decision: mapping[s[i]] 已存在? // 判斷 s[i] 是否已映射\nLine 7: Yes → Decision: mapping[s[i]] ≠ t[i]? // 之前映射是否與當前 t[i] 不符\nLine 8:     Yes → Step 4: 返回 False // 發現不一致，非同構\nLine 9:     No → Step 5: 繼續 // 已映射且一致，繼續下一個\nLine 10: No  → Decision: t[i] 已在已映射集合? // 檢查 t[i] 是否被其他字符映射\nLine 11:     Yes → Step 6: 返回 False // t[i] 已被映射，衝突\nLine 12:     No  → Step 7: mapping[s[i]] = t[i]; 已映射集合加入 t[i] // 建立新映射\nLine 13: → Decision: 迴圈結束? // 檢查是否已完成全部字元\nLine 14: Yes → Step 8: 返回 True // 所有檢查通過，為同構\nLine 15: End // 程式結束\n\nWe need to adjust formatting: each line preceded by arrow if part of flow? For lines inside decision branch we indent? The example shows indenting by 4 spaces for inner lines. Use similar.\n\nWe should output each line with \"虛擬碼步驟 [空格] // 解釋/說明\". So we need to produce each line exactly. For decision branches, indent lines with 4 spaces. For arrow lines use \"→\". For start use \"Start\".\n\nMake sure to include \"Yes →\" \"No →\" with arrow for branch.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 取得 s, t // 取得輸入字串\n\nLine 3: → Decision: s 長度與 t 長度相等? // 判斷長度是否相同\n\nLine 4: Yes → Step 2: 初始化 mapping 字典與已映射集合 // 準備映射資料結構\n\nLine 5: → Step 3: for i in 0..len(s)-1 迴圈 // 逐字元檢查\n\nLine 6: → Decision: mapping[s[i]] 已存在? // 判斷 s[i] 是否已映射\n\nLine 7: Yes → Decision: mapping[s[i]] ≠ t[i]? // 之前映射是否與當前 t[i] 不符\n\nLine 8:     Yes → Step 4: 返回 False // 發現不一致，非同構\n\nLine 9:     No → Step 5: 繼續 // 已映射且一致，繼續下一個\n\nLine 10: No  → Decision: t[i] 已在已映射集合? // 檢查 t[i] 是否被其他字符映射\n\nLine 11:     Yes → Step 6: 返回 False // t[i] 已被映射，衝突\n\nLine 12:     No  → Step 7: mapping[s[i]] = t[i]; 已映射集合加入 t[i] // 建立新映射\n\nLine 13: → Decision: 迴圈結束? // 檢查是否已完成全部字元\n\nLine 14: Yes → Step 8: 返回 True // 所有檢查通過，為同構\n\nLine 15: End // 程式結束\n\nWe should ensure indentation consistent. Example uses 4 spaces before lines inside decision.\n\nAlso we need to include \"No →\" lines with two spaces before \"No\"? Example shows \"No →\". So use exactly \"No →\". For step lines after decisions maybe indent 4 spaces.\n\nThus final output lines. Ensure no extra text.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 s, t // 取得輸入字串  \n→ Decision: s 長度與 t 長度相等? // 判斷長度是否相同  \nYes → Step 2: 初始化 mapping 字典與已映射集合 // 準備映射資料結構  \n→ Step 3: for i in 0..len(s)-1 迴圈 // 逐字元檢查  \n→ Decision: mapping[s[i]] 已存在? // 判斷 s[i] 是否已映射  \nYes → Decision: mapping[s[i]] ≠ t[i]? // 之前映射是否與當前 t[i] 不符  \n    Yes → Step 4: 返回 False // 發現不一致，非同構  \n    No → Step 5: 繼續 // 已映射且一致，繼續下一個  \nNo  → Decision: t[i] 已在已映射集合? // 檢查 t[i] 是否被其他字符映射  \n    Yes → Step 6: 返回 False // t[i] 已被映射，衝突  \n    No  → Step 7: mapping[s[i]] = t[i]; 已映射集合加入 t[i] // 建立新映射  \n→ Decision: 迴圈結束? // 檢查是否已完成全部字元  \nYes → Step 8: 返回 True // 所有檢查通過，為同構  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        mapping_s_t = {}\n        mapping_t_s = {}\n        for c1, c2 in zip(s, t):\n            if c1 in mapping_s_t and mapping_s_t[c1] != c2:\n                return False\n            if c2 in mapping_t_s and mapping_t_s[c2] != c1:\n                return False\n            mapping_s_t[c1] = c2\n            mapping_t_s[c2] = c1\n        return True\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 尝试从输入中提取被引号包围的字符串\n    strs = re.findall(r'\"([^\"]*)\"', data)\n    if len(strs) >= 2:\n        s, t = strs[0], strs[1]\n    else:\n        # 若没有引号，直接按空白分割\n        parts = data.split()\n        if len(parts) >= 2:\n            s, t = parts[0], parts[1]\n        else:\n            return  # 输入不足，直接退出\n\n    solution = Solution()\n    result = solution.isIsomorphic(s, t)\n    # 输出 lowercase 的布尔值\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"egg\", t = \"add\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"foo\", t = \"bar\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"paper\", t = \"title\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode412.json",
    "problem_index_in_file": 0,
    "title": "Fizz Buzz",
    "description_snippet": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code representation line by line following the given format. Must not output actual code. Provide steps. Let's create:\n\nStart\n→ Step 1: Initialize array answer of size n // create answer\n→ Step 2: For i from 1 to n // iterate\n→ Decision: If i mod 15 == 0? // divisible by both 3 and 5\n    Yes → Step 3: Set answer[i] = \"FizzBuzz\" // assign\n    No  → Decision: If i mod 3 == 0? // divisible by 3\n        Yes → Step 4: Set answer[i] = \"Fizz\"\n        No  → Decision: If i mod 5 == 0? // divisible by 5\n            Yes → Step 5: Set answer[i] = \"Buzz\"\n            No  → Step 6: Set answer[i] = toString(i) // i as string\n→ Step 7: Return answer // output array\nEnd\n\nWe need to include comments after each line. Ensure using \"虛擬碼步驟\" with arrow and comment. Use Chinese. Ensure to use \"Start\", \"End\". Use decision indent lines accordingly. We'll include proper indentation maybe with spaces but format guidelines only mention using arrow and structure. So produce lines exactly as they want.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立長度為 n 的字串陣列 answer // 建立答案陣列  \n→ Step 2: 從 1 到 n 逐一迭代 i // 逐項處理每個數字  \n→ Decision: 如果 i 能被 15 整除? // 同時能被 3 與 5 整除  \n  Yes → Step 3: answer[i] = \"FizzBuzz\" // 設定為 FizzBuzz  \n  No → Decision: 如果 i 能被 3 整除? // 只能被 3 整除  \n   Yes → Step 4: answer[i] = \"Fizz\" // 設定為 Fizz  \n   No → Decision: 如果 i 能被 5 整除? // 只能被 5 整除  \n    Yes → Step 5: answer[i] = \"Buzz\" // 設定為 Buzz  \n    No → Step 6: answer[i] = i.ToString() // 轉成字串存入答案  \n→ Step 7: 回傳 answer // 結束並回傳結果陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef fizz_buzz(n: int) -> list[str]:\n    \"\"\"產生 FizzBuzz 結果的字串列表。\"\"\"\n    result = []\n    for i in range(1, n + 1):\n        if i % 15 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    # 從輸入文字中擷取第一個整數（可處理 \"n = 3\" 等格式）\n    match = re.search(r\"\\d+\", raw_input)\n    if match:\n        n_val = int(match.group())\n    else:\n        n_val = 0  # 若沒有找到整數，視為 0\n\n    output = fizz_buzz(n_val)\n    # 直接列印列表，Python 的 print 會產生符合要求的格式\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"1\",\"2\",\"Fizz\"]",
          "success": true,
          "output": "['1', '2', 'Fizz']"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
          "success": true,
          "output": "['1', '2', 'Fizz', '4', 'Buzz']"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]",
          "success": true,
          "output": "['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode150.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Reverse Polish Notation",
    "description_snippet": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polis...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for evaluating RPN expression given array tokens. Use stack approach. Provide steps with Start, etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to use arrow →, and Decision: Yes→ No→ etc.\n\nWe'll produce lines:\n\nStart\n→ Step 1: 初始化空堆疊 // create empty stack\n→ Step 2: 對於 tokens 中每個 token 做\n→ Decision: token 是否為運算子? // check operator\n    Yes → Step 3: 從堆疊彈出右操作數 B // pop second operand\n           → Step 4: 從堆疊彈出左操作數 A // pop first operand\n           → Step 5: 計算 A op B // perform operation\n           → Step 6: 將結果推回堆疊 // push result\n    No  → Step 7: 將 token 轉為整數並推回堆疊 // push operand\n→ Step 8: 循環結束 // finish iterating\n→ Step 9: 從堆疊彈出結果 // final result\nEnd\n\nAlso mention division truncates toward zero: use integer division that truncates toward zero; e.g., in many languages, division of negative truncates toward zero. But we can mention \"使用整數除法，結果向零截斷\".\n\nMake sure to keep one line per step. Use appropriate arrow lines. Provide explanation after //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空堆疊 // 建立一個空的 stack 用來存放中間結果  \n→ Step 2: 對 tokens 中的每個 token 做下列處理 // 逐一遍歷輸入陣列  \n→ Decision: token 是否為運算子? // 判斷 token 是否為 '+', '-', '*', '/'  \n  Yes → Step 3: 從堆疊彈出右操作數 B // 先取出第二個操作數  \n    → Step 4: 從堆疊彈出左操作數 A // 再取出第一個操作數  \n    → Step 5: 計算 A op B // 執行對應的四則運算  \n    → Step 6: 將結果推回堆疊 // 把計算結果放回 stack 供後續使用  \n  No  → Step 7: 將 token 轉為整數並推回堆疊 // 若不是運算子，則為數值，直接入堆疊  \n→ Step 8: 完成所有 token 的處理 // 迴圈結束  \n→ Step 9: 從堆疊彈出結果 // 最後堆疊中唯一的元素即為表達式結果  \nEnd // 程式執行結束  \n(Note: 除法使用整數除法，結果向零截斷，符合題目要求。)",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def evalRPN(self, tokens):\n        \"\"\"Evaluate a Reverse Polish Notation expression.\"\"\"\n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                elif token == '/':\n                    # Division that truncates toward zero\n                    stack.append(int(a / b))\n            else:\n                stack.append(int(token))\n        return stack[0]\n\ndef parse_input(input_str):\n    \"\"\"\n    Parse the input string of the form:\n    tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n    and return the list of tokens.\n    \"\"\"\n    if not input_str:\n        return []\n    # Find the '=' character and parse the part after it\n    parts = input_str.split('=', 1)\n    if len(parts) != 2:\n        raise ValueError(\"Input must contain 'tokens = [...]'\")\n    tokens_part = parts[1].strip()\n    # Use ast.literal_eval to safely evaluate the list expression\n    tokens = ast.literal_eval(tokens_part)\n    if not isinstance(tokens, list):\n        raise ValueError(\"Tokens should be a list\")\n    return tokens\n\ndef main():\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    tokens = parse_input(raw_input)\n    result = Solution().evalRPN(tokens)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
          "expected_output": "22",
          "success": true,
          "output": "22"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode90.json",
    "problem_index_in_file": 0,
    "title": "Subsets II",
    "description_snippet": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all unique subsets of array nums with duplicates. Should handle duplicates: typical approach: sort array, backtrack with skip duplicates.\n\nWe output line by line with virtual code steps. Use arrows, decisions, start end. We need to show steps of algorithm: Input, sort, backtrack function, maintain subset, iterate indices with skip duplicates. Use recursion. Should produce all subsets.\n\nLet's produce:\n\nStart\n→ Input nums // read array\n→ Sort nums // sort to group duplicates\n→ Initialize result = [ [] ] // start with empty set\n→ Define Backtrack(index, currentSubset)\n→ Decision: if index == len(nums)? // base\n    Yes → Append copy of currentSubset to result\n    No → Decision: include current element\n        Yes → currentSubset.append(nums[index]) // include\n        → Backtrack(index+1, currentSubset)\n        → currentSubset.pop() // backtrack\n        No → Decision: skip duplicates\n            Yes → Backtrack(index+1, currentSubset)\nBut we need to handle duplicates: skip over same value if previous index was same and not included? Typically skip duplicates in loop iteration.\n\nBetter: For loop i from index to len(nums)-1:\n  If i > index and nums[i] == nums[i-1] -> continue // skip duplicates\n  currentSubset.append(nums[i])\n  Backtrack(i+1, currentSubset)\n  currentSubset.pop()\n\nThus algorithm uses for loop not decision. So we can illustrate.\n\nLet's produce virtual code with Start, steps, decision for skip duplicate, recursion.\n\nOk produce lines. Use \"→\" arrow to indicate next step. Provide comment after //.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 nums // 取得使用者提供的整數陣列  \n→ Step 2: 將 nums 依升序排序 // 方便後續跳過重複元素  \n→ Step 3: 建立結果列表 result，初始為 [ [] ] // 先放入空集合  \n→ Step 4: 定義遞迴函式 Backtrack(startIndex, currentSubset)  \n    → Step 4.1: Decision: 是否已遍歷完整個陣列? // 檢查是否到達結束點  \n        Yes → Step 4.2: 把 currentSubset 的複本加入 result // 存入一個子集合  \n        No → Step 4.3: For i from startIndex to len(nums)-1 // 逐一嘗試加入每個元素  \n            → Decision: i > startIndex 且 nums[i] == nums[i-1]? // 檢查是否為重複元素  \n                Yes → Step 4.4: 跳過此 i // 為避免重複子集合  \n                No  → Step 4.5: currentSubset.append(nums[i]) // 加入元素  \n                → Step 4.6: Backtrack(i+1, currentSubset) // 進一步遞迴  \n                → Step 4.7: currentSubset.pop() // 回溯，移除剛加入的元素  \n→ Step 5: 呼叫 Backtrack(0, []) // 從索引 0 開始搜尋子集合  \nEnd // 程式執行結束，result 中已包含所有不重複的子集合",
      "generated_code": "import sys\nimport ast\n\ndef subsets_with_dup(nums):\n    \"\"\"\n    Generate all unique subsets (the power set) of the input list `nums`\n    that may contain duplicate elements.\n    \"\"\"\n    nums.sort()                      # Sort to group duplicates\n    result = [[]]                    # Start with the empty subset\n\n    def backtrack(start, path):\n        for i in range(start, len(nums)):\n            # Skip duplicate elements at the same recursion depth\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            path.append(nums[i])      # Include nums[i]\n            result.append(path.copy())\n            backtrack(i + 1, path)    # Recurse to the next element\n            path.pop()                # Backtrack\n\n    backtrack(0, [])\n    return result\n\ndef parse_input(input_str):\n    \"\"\"\n    Parse the input string which is expected to contain a list of integers\n    possibly preceded by the variable name (e.g., 'nums = [1,2,2]').\n    \"\"\"\n    # Find the first '[' and the last ']' to extract the list literal\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        raise ValueError(\"Input does not contain a valid list.\")\n    list_literal = input_str[start:end + 1]\n    return ast.literal_eval(list_literal)\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        # If no input, output an empty list of subsets\n        print([[]])\n        sys.exit(0)\n\n    # Parse the list of numbers from the input\n    nums = parse_input(raw_input)\n\n    # Compute all unique subsets\n    subsets = subsets_with_dup(nums)\n\n    # Print the result in standard Python list format\n    print(subsets)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "success": true,
          "output": "[[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[], [0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode415.json",
    "problem_index_in_file": 0,
    "title": "Add Strings",
    "description_snippet": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode with explanations, not actual code. The problem: add two non-negative integers represented as strings, produce string sum, no built-in big ints, no converting to integer directly.\n\nWe should produce pseudocode: Start, reverse strings, iterate, carry, build result, reverse back, strip leading zeros? Probably not needed. Provide explanation. Use Decision arrows.\n\nWe must output line by line: e.g.:\n\nStart // 程式開始\n\n→ Step 1: 取得 num1, num2 // input strings\n\n→ Step 2: 初始化 carry 為 0, result 為空串 // prepare variables\n\n→ Step 3: 取得 maxLen = max(length(num1), length(num2)) // longest length\n\n→ Step 4: 反轉 num1, num2 // for easier indexing from least significant\n\n→ Decision: 是否需要處理不足長度的位? // handle missing digits\n\nWe can loop for i from 0 to maxLen-1:\n\n→ Step 5: 取得 digit1 = (i < length(num1) ? num1[i] - '0' : 0) // digit from num1 or 0\n\n→ Step 6: 取得 digit2 = (i < length(num2) ? num2[i] - '0' : 0)\n\n→ Step 7: sum = digit1 + digit2 + carry\n\n→ Step 8: result += char((sum % 10) + '0') // append digit\n\n→ Step 9: carry = sum / 10\n\nAfter loop:\n\n→ Decision: carry > 0? // any remaining carry\n\n    Yes → Step 10: result += char(carry + '0') // append carry\n\n    No  → No action\n\n→ Step 11: 反轉 result // produce final string\n\n→ End // done\n\nWe should ensure each line includes the pseudocode and // explanation.\n\nWe need to keep arrow syntax: → Step n: ... ; Decision: ... ; Yes → ... ; No → ... ; End.\n\nMake sure each line uses the arrow or Decision properly.\n\nAlso, we might include variable initializations with \"→ Step X: 初始化 variable\".\n\nLet's produce a list.\n\nLet's produce lines:\n\nStart // 程式開始\n\n→ Step 1: 接收輸入字符串 num1, num2 // 兩個非負整數\n\n→ Step 2: 初始化 carry 為 0, result 為空字符串 // 用於存放計算結果\n\n→ Step 3: 反轉 num1, num2 // 方便從最低位開始加\n\n→ Step 4: 取得 maxLen = max(length(num1), length(num2)) // 確定加法循環次數\n\n→ Decision: 進入迴圈? // 準備進行逐位相加\n\n    Yes → Step 5: 循環 i 從 0 到 maxLen-1 // 每位相加\n\n        → Step 6: 取得 digit1 = (i < length(num1) ? num1[i] - '0' : 0) // num1 的當前位，若超長則 0\n\n        → Step 7: 取得 digit2 = (i < length(num2) ? num2[i] - '0' : 0) // num2 的當前位\n\n        → Step 8: sum = digit1 + digit2 + carry // 計算當前位總和\n\n        → Step 9: result += char((sum % 10) + '0') // 將最低位加到結果\n\n        → Step 10: carry = sum / 10 // 更新進位\n\n    No → End // 循環結束\n\n→ Decision: carry > 0? // 檢查最後是否有剩餘進位\n\n    Yes → Step 11: result += char(carry + '0') // 將進位加到結果\n\n    No  → // 無進位\n\n→ Step 12: 反轉 result // 把結果轉回正確順序\n\n→ End // 程式結束\n\nBut we need arrow before each step. Use \"→\" before Step. Decision lines start with \"Decision:\" and indent Yes/No lines.\n\nThe line \"Yes → Step 5:\" etc.\n\nWe must not output actual code. Just pseudocode.\n\nMake sure each line ends with // explanation.\n\nAlso, we might include the step numbering. For consistency, we can use \"Step 1\", \"Step 2\", etc.\n\nMake sure each line includes the arrow.\n\nCheck format: \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nYes.\n\nThus produce lines.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入字符串 num1, num2 // 兩個非負整數的字串表示  \n→ Step 2: 初始化 carry 為 0, result 為空字符串 // 用於存放加法結果  \n→ Step 3: 反轉 num1, num2 // 方便從最低位開始相加  \n→ Step 4: 取得 maxLen = max(length(num1), length(num2)) // 確定迴圈次數  \n→ Decision: 進行逐位相加? // 準備進行循環  \n  Yes → Step 5: 循環 i 從 0 到 maxLen-1 // 每位相加  \n    → Step 6: 取得 digit1 = (i < length(num1) ? num1[i] - '0' : 0) // num1 的當前位，若超長則 0  \n    → Step 7: 取得 digit2 = (i < length(num2) ? num2[i] - '0' : 0) // num2 的當前位  \n    → Step 8: sum = digit1 + digit2 + carry // 計算當前位總和  \n    → Step 9: result += char((sum % 10) + '0') // 將最低位加入結果字串  \n    → Step 10: carry = sum / 10 // 更新進位  \n  No → // 迴圈已結束  \n→ Decision: carry > 0? // 是否有剩餘進位  \n  Yes → Step 11: result += char(carry + '0') // 將進位加入結果  \n  No → // 無進位  \n→ Step 12: 反轉 result // 把結果字串轉回正確順序  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(res[::-1])\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract numbers inside double quotes\n    nums = re.findall(r'\"([^\"]*)\"', data)\n    if len(nums) < 2:\n        # Fallback: try to split by comma if no quotes present\n        parts = data.replace('num1 =', '').replace('num2 =', '').split(',')\n        if len(parts) >= 2:\n            num1 = parts[0].strip().strip('\"').strip()\n            num2 = parts[1].strip().strip('\"').strip()\n        else:\n            return\n    else:\n        num1, num2 = nums[0], nums[1]\n\n    solution = Solution()\n    result = solution.addStrings(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "success": true,
          "output": "134"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "success": true,
          "output": "533"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode440.json",
    "problem_index_in_file": 0,
    "title": "K-th Smallest in Lexicographical Order",
    "description_snippet": "Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n]....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: find k-th lexicographically smallest integer in [1, n]. This is similar to problem \"k-th number in lexicographic order\" typical approach: count numbers under prefix. Use a while loop to find prefix. Steps: current=1, count=1. While count < k: compute steps between current and next. If count + steps <= k: move to next sibling: current+=1, count+=steps. else: go deeper: current*=10, count+=1. Finally return current. But we need to include n constraint: while current <= n. Implementation: Use variable steps = count_steps(current, current+1, n). count_steps counts numbers with prefix in [current, next). This is standard.\n\nWe will produce virtual code line by line. Each line: \"虛擬碼步驟 // 解釋\". Must use arrows etc.\n\nWe need to use Start, End, Decision, Step etc.\n\nLet's design algorithm:\n\nStart\n→ Step 1: Initialize current = 1, count = 1 // 起始前綴與已計數\n→ Step 2: If k == 1: Return current // 若要求第一個，直接返回\n→ Decision: while count < k and current <= n // 需要進一步搜尋\n    Yes → Step 3: Compute steps = count_steps(current, current+1, n) // 計算前綴範圍內數字個數\n    → Decision: if count + steps <= k // 若跳過整個前綴可行\n        Yes → Step 4: current = current + 1 // 移到同級下一個前綴\n        → Step 5: count = count + steps // 更新已計數\n        No  → Step 6: current = current * 10 // 進入下一層子前綴\n        → Step 7: count = count + 1 // 計入這個前綴自身\n→ End // 回傳 current\n\nWe need a function count_steps. We'll add steps in virtual code maybe separate block. But requirement: \"逐行\" means each line of virtual code with explanation. Could treat count_steps as subroutine.\n\nLet's write:\n\n→ Step 3: steps = count_steps(current, current + 1, n) // 計算 [current, next) 範圍內所有數字個數\n\nThen define count_steps as subroutine:\n\n→ Step 3a: Function count_steps(first, last, n) // 計算兩個前綴之間的數字數量\n    → Step 3a1: steps = 0\n    → Step 3a2: while first <= n\n        → Step 3a2a: steps += min(last, n+1) - first\n        → Step 3a2b: first *= 10\n        → Step 3a2c: last *= 10\n    → Step 3a3: Return steps\n\nBut we need arrow and Decision etc. We'll embed.\n\nBetter to produce all steps.\n\nLet's produce final output accordingly. Use \"Start\", \"End\". Use \"Decision:\" lines.\n\nWe also need to handle case where k > n? The problem may guarantee valid k? Usually k <= n. We'll ignore.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Set current = 1, count = 1 // 初始化前綴為 1，已計算的數字個數為 1\n→ Decision: 如果 k == 1? // 若要求第一個最小字典序數字\n    Yes → Step 2: Return current // 直接返回 1\n    No  → Step 3: // 進行下一步搜尋\n→ Decision: while count < k and current <= n? // 只要還沒找到第 k 個且前綴仍在範圍內\n    Yes → Step 4: steps = count_steps(current, current + 1, n) // 計算 [current, current+1) 範圍內所有數字的個數\n    → Decision: if count + steps <= k? // 能否跳過整個前綴\n        Yes → Step 5: current = current + 1 // 移動到同級下一個前綴\n        → Step 6: count = count + steps // 更新已計算的數字個數\n        No  → Step 7: current = current * 10 // 進入前綴的下一層子前綴\n        → Step 8: count = count + 1 // 計入此前綴自身\n→ End // 程式執行結束，current 為第 k 個字典序數字\n\nStep 3a: Function count_steps(first, last, n) // 计算两个前缀之间的所有数的数量\n    → Step 3a1: steps = 0 // 初始化计数\n    → Step 3a2: while first <= n\n        → Step 3a2a: steps = steps + min(last, n + 1) - first // 计算当前层的数字数量\n        → Step 3a2b: first = first * 10 // 进入下一位前缀\n        → Step 3a2c: last = last * 10 // 更新上限\n    → Step 3a3: Return steps // 返回总计数\n\nEnd // 完成所有虚拟步骤的定义与执行",
      "generated_code": "import sys\nimport re\n\ndef count_steps(prefix: int, n: int) -> int:\n    \"\"\"\n    計算所有以 prefix 為前綴且不超過 n 的整數個數。\n    例如 prefix=1, n=13 會計算 1,10,11,12,13 共 5 個。\n    \"\"\"\n    steps = 0\n    cur = prefix\n    next_ = prefix + 1\n    while cur <= n:\n        steps += min(next_, n + 1) - cur\n        cur *= 10\n        next_ *= 10\n    return steps\n\ndef find_kth_number(n: int, k: int) -> int:\n    \"\"\"\n    找出區間 [1, n] 中第 k 個字典序最小的數字。\n    \"\"\"\n    current = 1          # 目前前綴\n    count   = 1          # 已經計數到的數字個數，初始為 1（即數字 1）\n    if k == 1:\n        return current\n\n    # 當還沒到第 k 個時持續尋找\n    while count < k and current <= n:\n        steps = count_steps(current, n)\n        # 若跳過整個前綴也不會超過 k，則往右走（同級下一個前綴）\n        if count + steps <= k:\n            current += 1\n            count += steps\n        else:\n            # 進入前綴的下一層（更長的前綴）\n            current *= 10\n            count += 1\n    return current\n\ndef main() -> None:\n    \"\"\"\n    主程式：從 stdin 讀取輸入，解析 n 與 k，計算並輸出結果。\n    支援輸入格式如 'n = 13, k = 2' 或 '13 2' 等，只要能抽取兩個整數即可。\n    \"\"\"\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    result = find_kth_number(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13, k = 2",
          "expected_output": "10",
          "success": true,
          "output": "10"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode40.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum II",
    "description_snippet": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique c...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: given candidates array, target sum, each number used at most once, find all unique combinations summing to target. Need to avoid duplicates. This is typical Combination Sum II problem. We need to outline algorithm: sort candidates, backtracking with pruning and skip duplicates. So produce steps: Start, sort, define backtrack function, choose number, skip duplicates if same as previous and at same depth, recursion, etc.\n\nWe should output step lines with arrows and comments. The output should be virtual code lines. Each line: \"虛擬碼步驟 // 解釋\".\n\nMake sure to include arrows, decisions, etc. Should be linear, but we can use indentation or arrows. Use \"→\" for steps. Use \"Decision:\" with Yes/No arrows. Should show backtrack logic. Keep concise.\n\nWe need to show each line with explanation.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 將 candidates 依升序排序 // 方便後續跳過重複數字\n→ Step 2: 建立空列表 results // 用於儲存所有有效組合\n→ Step 3: 定義遞迴函式 backtrack(startIndex, currentCombo, currentSum) // 遞迴搜尋\n    → Decision: currentSum 是否等於 target? // 檢查是否已達到目標\n        Yes → Step 4: 將 currentCombo 複製加入 results // 存入完整解答\n        No  → Decision: currentSum 是否大於 target? // 檢查是否已超過目標\n            Yes → Step 5: 返回 // 超過則回溯\n            No  → Step 6: 從 startIndex 到 candidates 長度進行迴圈\n                → Step 7: Decision: i > startIndex 且 candidates[i] == candidates[i-1]? // 跳過重複的數字\n                    Yes → Step 8: 跳過此 i // 避免重複組合\n                    No  → Step 9: 將 candidates[i] 加入 currentCombo\n                        → Step 10: 呼叫 backtrack(i+1, currentCombo, currentSum + candidates[i]) // 進行下一層遞迴\n                        → Step 11: 從 currentCombo 移除最後一個數字 // 回溯\n→ Step 12: 呼叫 backtrack(0, [], 0) // 開始搜尋\n→ Step 13: 回傳 results // 輸出所有組合\nEnd // 程式執行結束\n\nBut we need to keep each line with virtual code and comment.\n\nWe need to use \"Decision:\" with Yes/No arrows lines.\n\nThe formatting must be exactly as specified: \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nThus each line must be a single line with a space then //.\n\nWe should maintain indentation? Example: In the format, they indent with spaces under Decision: lines. The example uses indentation to indicate nested steps. But we can keep simple linear representation with arrows.\n\nHowever the requirement: Use virtual code's arrow and structure. The example uses indentation for nested steps. We can mimic that.\n\nWe should produce code with indentation.\n\nExample lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入 candidates 和 target // 取得輸入\n→ Decision: ... // etc\n\nBut we need to produce each line. We need to use arrow or Yes/No arrows. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 將 candidates 依升序排序 // 方便後續跳過重複數字\n→ Step 2: 建立空列表 results // 用於儲存所有有效組合\n→ Step 3: 定義遞迴函式 backtrack(startIndex, currentCombo, currentSum) // 遞迴搜尋\n    → Decision: currentSum 是否等於 target? // 檢查是否已達到目標\n        Yes → Step 4: 將 currentCombo 複製加入 results // 存入完整解答\n        No  → Decision: currentSum 是否大於 target? // 檢查是否已超過目標\n            Yes → Step 5: 返回 // 超過則回溯\n            No  → Step 6: 進行 for 迴圈從 startIndex 到 candidates.length-1\n                → Decision: i > startIndex 且 candidates[i] == candidates[i-1]? // 跳過重複的數字\n                    Yes → Step 7: 跳過此 i // 避免重複組合\n                    No  → Step 8: 將 candidates[i] 加入 currentCombo\n                        → Step 9: 呼叫 backtrack(i+1, currentCombo, currentSum + candidates[i]) // 進行下一層遞迴\n                        → Step 10: 從 currentCombo 移除最後一個數字 // 回溯\n→ Step 11: 呼叫 backtrack(0, [], 0) // 開始搜尋\n→ Step 12: 回傳 results // 輸出所有組合\nEnd // 程式執行結束\n\nWe must keep each line on its own line with // comment. Also we need to keep arrow indent.\n\nNeed to check formatting: the example had \"→ Step 1: ...\" not with a leading space. We can maintain that.\n\nThus output:\n\nStart // 程式開始執行\n→ Step 1: 將 candidates 依升序排序 // 方便後續跳過重複數字\n→ Step 2: 建立空列表 results // 用於儲存所有有效組合\n→ Step 3: 定義遞迴函式 backtrack(startIndex, currentCombo, currentSum) // 遞迴搜尋\n    → Decision: currentSum 是否等於 target? // 檢查是否已達到目標\n        Yes → Step 4: 將 currentCombo 複製加入 results // 存入完整解答\n        No  → Decision: currentSum 是否大於 target? // 檢查是否已超過目標\n            Yes → Step 5: 返回 // 超過則回溯\n            No  → Step 6: 進行 for 迴圈從 startIndex 到 candidates.length-1\n                → Decision: i > startIndex 且 candidates[i] == candidates[i-1]? // 跳過重複的數字\n                    Yes → Step 7: 跳過此 i // 避免重複組合\n                    No  → Step 8: 將 candidates[i] 加入 currentCombo\n                        → Step 9: 呼叫 backtrack(i+1, currentCombo, currentSum + candidates[i]) // 進行下一層遞迴\n                        → Step 10: 從 currentCombo 移除最後一個數字 // 回溯\n→ Step 11: 呼叫 backtrack(0, [], 0) // 開始搜尋\n→ Step 12: 回傳 results // 輸出所有組合\nEnd // 程式執行結束\n\nMake sure each line is separate. Provide no extra text.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將 candidates 依升序排序 // 方便後續跳過重複數字\n→ Step 2: 建立空列表 results // 用於儲存所有有效組合\n→ Step 3: 定義遞迴函式 backtrack(startIndex, currentCombo, currentSum) // 遞迴搜尋\n    → Decision: currentSum 是否等於 target? // 檢查是否已達到目標\n        Yes → Step 4: 將 currentCombo 複製加入 results // 存入完整解答\n        No  → Decision: currentSum 是否大於 target? // 檢查是否已超過目標\n            Yes → Step 5: 返回 // 超過則回溯\n            No  → Step 6: 進行 for 迴圈從 startIndex 到 candidates.length-1\n                → Decision: i > startIndex 且 candidates[i] == candidates[i-1]? // 跳過重複的數字\n                    Yes → Step 7: 跳過此 i // 避免重複組合\n                    No  → Step 8: 將 candidates[i] 加入 currentCombo\n                        → Step 9: 呼叫 backtrack(i+1, currentCombo, currentSum + candidates[i]) // 進行下一層遞迴\n                        → Step 10: 從 currentCombo 移除最後一個數字 // 回溯\n→ Step 11: 呼叫 backtrack(0, [], 0) // 開始搜尋\n→ Step 12: 回傳 results // 輸出所有組合\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef combinationSum2(candidates, target):\n    candidates.sort()\n    res = []\n\n    def backtrack(start, path, total):\n        if total == target:\n            res.append(path[:])\n            return\n        if total > target:\n            return\n        prev = None\n        for i in range(start, len(candidates)):\n            if prev is not None and candidates[i] == prev:\n                continue\n            path.append(candidates[i])\n            backtrack(i + 1, path, total + candidates[i])\n            path.pop()\n            prev = candidates[i]\n\n    backtrack(0, [], 0)\n    return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the candidates list\n    cand_match = re.search(r'candidates\\s*=\\s*(\\[[^\\]]*\\])', data)\n    tgt_match = re.search(r'target\\s*=\\s*([-\\d]+)', data)\n    if not cand_match or not tgt_match:\n        sys.exit(\"Invalid input format\")\n    candidates = eval(cand_match.group(1))\n    target = int(tgt_match.group(1))\n    result = combinationSum2(candidates, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [10,1,2,7,6,1,5], target = 8",
          "expected_output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
          "success": true,
          "output": "[[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,5,2,1,2], target = 5",
          "expected_output": "[[1,2,2],[5]]",
          "success": true,
          "output": "[[1, 2, 2], [5]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode449.json",
    "problem_index_in_file": 0,
    "title": "Serialize and Deserialize BST",
    "description_snippet": "Serialization is converting a data structure or object into a sequence of bits so that it can be sto...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. The algorithm: serialize BST using pre-order traversal storing values separated by commas, maybe omit nulls because BST can be reconstructed by bounds. For deserialization, use recursion with min/max bounds. Provide virtual code steps. Ensure each line ends with comment. Include Start, End, Decision, etc.\n\nLet's outline steps:\n\nStart\n→ Step 1: Define function serialize(root) // returns string\n→ Step 2: If root is None: return empty string // no nodes\n→ Step 3: Initialize empty list result // collect node values\n→ Step 4: Define helper(node): // pre-order\n→ Decision: If node is None? No // skip null nodes\n→ Step 5: Append node.val to result\n→ Step 6: helper(node.left)\n→ Step 7: helper(node.right)\n→ Step 8: Call helper(root)\n→ Step 9: Join result with commas to form string\n→ End // serialize done\n\nDeserialization:\n\nStart\n→ Step 1: Define function deserialize(data) // returns root\n→ Step 2: If data is empty: return None\n→ Step 3: Split data by commas into list of ints values\n→ Step 4: Initialize index=0\n→ Step 5: Define helper(lower, upper): // bounds\n→ Decision: index == len(values)? Yes → return None // no more values\n→ Step 6: val = values[index]\n→ Decision: val < lower or val > upper? Yes → return None // value not in bounds\n→ Step 7: index += 1\n→ Step 8: node = TreeNode(val)\n→ Step 9: node.left = helper(lower, val-1?) // use val for upper bound\n→ Step 10: node.right = helper(val+1? , upper) // use val for lower bound\n→ Step 11: return node\n→ Step 12: Call helper(-inf, +inf)\n→ End\n\nBut we need to consider integer values; use bounds inclusive. Use val for bounds.\n\nReturn root.\n\nMake comments concise.\n\nWe need to produce virtual code with arrows. Use Start and End.\n\nEnsure each line has comment.\n\nLet's craft.\n\nAlso mention that serialized string compact: just numbers separated by commas, no null markers.\n\nLet's produce lines accordingly.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: Function serialize(root) // 產生序列化字串\n→ Decision: root 為空? Yes → return \"\" // 空樹返回空字串\n→ Step 2: result = [] // 收集節點值\n→ Step 3: Function helper(node) // 前序遍歷\n→ Decision: node 為空? Yes → return // 直接跳過\n→ Step 4: Append node.val to result // 加入節點值\n→ Step 5: helper(node.left) // 遞迴左子樹\n→ Step 6: helper(node.right) // 遞迴右子樹\n→ Step 7: helper(root) // 開始遍歷\n→ Step 8: return join(result, \",\") // 用逗號連接為字串\n\nEnd // serialize 完成\n\nStart // 程式開始執行\n\n→ Step 1: Function deserialize(data) // 由字串重建樹\n→ Decision: data 為空? Yes → return None // 空字串返回空樹\n→ Step 2: values = split(data, \",\") // 轉成數值列表\n→ Step 3: values = map to int // 轉成整數\n→ Step 4: index = 0 // 目前讀取位置\n→ Step 5: Function helper(lower, upper) // 限定取值範圍\n→ Decision: index == len(values)? Yes → return None // 沒有剩餘值\n→ Step 6: val = values[index] // 取下一個值\n→ Decision: val < lower 或 val > upper? Yes → return None // 值不在合法範圍\n→ Step 7: index += 1 // 移到下一個位置\n→ Step 8: node = TreeNode(val) // 建立節點\n→ Step 9: node.left = helper(lower, val) // 左子樹範圍\n→ Step 10: node.right = helper(val, upper) // 右子樹範圍\n→ Step 11: return node // 回傳節點\n→ Step 12: return helper(-∞, +∞) // 從整個數值範圍開始\n\nEnd // deserialize 完成",
      "generated_code": "import sys\nimport math\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a BST to a single string (pre‑order).\"\"\"\n        res = []\n\n        def preorder(node):\n            if not node:\n                return\n            res.append(str(node.val))\n            preorder(node.left)\n            preorder(node.right)\n\n        preorder(root)\n        return ','.join(res)\n\n    def deserialize(self, data):\n        \"\"\"Decodes the encoded string back to a BST.\"\"\"\n        if not data:\n            return None\n        values = list(map(int, data.split(',')))\n\n        def build(min_val, max_val):\n            if values and min_val < values[0] < max_val:\n                val = values.pop(0)\n                node = TreeNode(val)\n                node.left = build(min_val, val)\n                node.right = build(val, max_val)\n                return node\n            return None\n\n        return build(float('-inf'), float('inf'))\n\ndef insert_bst(root, val):\n    \"\"\"Insert value into BST.\"\"\"\n    if root is None:\n        return TreeNode(val)\n    if val < root.val:\n        root.left = insert_bst(root.left, val)\n    else:\n        root.right = insert_bst(root.right, val)\n    return root\n\ndef parse_input(s):\n    \"\"\"Extract list of integers from input like 'root = [2,1,3]'.\"\"\"\n    start = s.find('[')\n    end = s.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        return []\n    content = s[start + 1:end].strip()\n    if not content:\n        return []\n    return list(map(int, content.split(',')))\n\ndef main():\n    data = sys.stdin.read().strip()\n    values = parse_input(data)\n\n    # Build BST from the values\n    root = None\n    for v in values:\n        root = insert_bst(root, v)\n\n    codec = Codec()\n    serialized = codec.serialize(root)\n\n    # Output as list format\n    if serialized:\n        output = f'[{serialized}]'\n    else:\n        output = '[]'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "root = [2,1,3]",
          "expected_output": "[2,1,3]",
          "success": true,
          "output": "[2,1,3]"
        },
        {
          "example_index": 1,
          "input": "root = []",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode349.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations, following the format. The problem: intersection of two arrays, unique elements. Approach: use set for nums1, iterate nums2, collect into set intersection, then convert to array.\n\nWe'll generate steps: Start, Step 1: create set from nums1, Step 2: create empty set for intersection, Step 3: iterate nums2, check if element in set1, if yes add to intersection set. Step 4: convert intersection set to array. Step 5: return array. End.\n\nUse virtual code style: Start, → Step ... // comment. Use Decision: maybe check membership. We can use Decision: If element in set1? Yes → add.\n\nLet's produce. Ensure each line ends with // explanation. Use arrow before each step: \"→ Step 1:\" etc.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 創建 Set1 為 nums1 的集合 // 將 nums1 的元素存入集合以便快速查詢  \n→ Step 2: 創建空 Set2 用於存放交集 // 這個集合將只保存唯一的交集元素  \n→ Step 3: 迭代 nums2 中的每個元素 val // 對 nums2 的每個值進行處理  \n  Decision: 若 val 在 Set1 中? // 判斷 val 是否屬於 nums1  \n   Yes → Step 4: 將 val 加入 Set2 // 把共有的元素加入交集集合  \n   No  → （不做任何操作） // 若不在 Set1，則跳過  \n→ Step 5: 將 Set2 轉換為陣列 result // 把集合轉成陣列格式返回  \n→ Step 6: 回傳 result // 將交集陣列作為結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        返回兩個整數陣列 nums1 和 nums2 的交集，結果只包含唯一元素。\n        \"\"\"\n        # 轉換為 set 以去重，然後取兩個集合的交集\n        return list(set(nums1) & set(nums2))\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析出兩個列表 nums1 與 nums2。\n    期望的輸入格式類似：\n        nums1 = [1,2,2,1], nums2 = [2,2]\n    \"\"\"\n    # 正則表達式抓取兩個方括號內的內容\n    pattern1 = r'nums1\\s*=\\s*(\\[[^\\]]*\\])'\n    pattern2 = r'nums2\\s*=\\s*(\\[[^\\]]*\\])'\n\n    match1 = re.search(pattern1, data)\n    match2 = re.search(pattern2, data)\n\n    if not match1 or not match2:\n        raise ValueError(\"輸入格式錯誤，請確認包含 nums1 和 nums2。\")\n\n    # 使用 eval 解析字串為 Python 列表\n    nums1 = eval(match1.group(1))\n    nums2 = eval(match2.group(1))\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read()\n    try:\n        nums1, nums2 = parse_input(raw_input)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    solution = Solution()\n    result = solution.intersection(nums1, nums2)\n    # 將結果輸出到標準輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[9,4]",
          "success": true,
          "output": "[9, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode416.json",
    "problem_index_in_file": 0,
    "title": "Partition Equal Subset Sum",
    "description_snippet": "Given an integer array nums, return true if you can partition the array into two subsets such that t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for subset sum partition problem: determine if array can be partitioned into two subsets with equal sum. Approach: check total sum even, target = sum/2, dynamic programming subset sum boolean array up to target. Virtual code: steps. Use Start, Decision, etc. Provide each line with explanation. No real code. Use arrow \"→\". Format example. Need step by step: start, input array, compute sum, Decision: if sum%2 !=0 => false, else target = sum/2, initialize dp[0] true, loop each num, for j from target down to num, dp[j] = dp[j] || dp[j-num], after loops, Decision: if dp[target] true => true else false. End.\n\nWe need \"逐行\" meaning each line separate. Use indentation? They used indent with tabs. We can mimic. Use Decision, Yes, No. Provide virtual code. Use arrow \"→\" preceding step names. Provide comment after //.\n\nLet's write.\n\n```\nStart // 程式開始執行\n→ Input: nums // 取得整數陣列\n→ Compute: totalSum = sum(nums) // 計算所有元素總和\n→ Decision: 如果 totalSum 為奇數? // 檢查總和是否為偶數\n    Yes → Return false // 若奇數則無法分成相等子集\n    No  → Step: target = totalSum / 2 // 取得需要的子集和\n→ Initialise: dp[0..target] = false // 建立布林陣列\n→ Set dp[0] = true // 空集合總和為0\n→ Loop: for each num in nums // 遍歷陣列\n    → Loop: for j from target down to num\n        → Update: dp[j] = dp[j] OR dp[j - num] // 更新能否達成 j 的布林值\n→ Decision: 如果 dp[target] 為 true? // 檢查目標和是否可達\n    Yes → Return true // 可以分成相等子集\n    No  → Return false // 無法分成相等子集\nEnd // 程式執行結束\n```\n\nWe must ensure each line has \"虛擬碼步驟\" + \" // 解釋\". Also use indentation for Decision branches. Use \"Yes →\" and \"No →\" as specified.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: nums // 取得整數陣列  \n→ Compute: totalSum = sum(nums) // 計算所有元素總和  \n→ Decision: 如果 totalSum 為奇數? // 檢查總和是否為偶數  \n  Yes → Return false // 若奇數則無法分成相等子集  \n  No  → Step: target = totalSum / 2 // 取得需要的子集和  \n→ Initialise: dp[0..target] = false // 建立布林陣列  \n→ Set dp[0] = true // 空集合總和為0  \n→ Loop: for each num in nums // 遍歷陣列  \n  → Loop: for j from target down to num  \n    → Update: dp[j] = dp[j] OR dp[j - num] // 更新能否達成 j 的布林值  \n→ Decision: 如果 dp[target] 為 true? // 檢查目標和是否可達  \n  Yes → Return true // 可以分成相等子集  \n  No  → Return false // 無法分成相等子集  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canPartition(self, nums):\n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n        target = total // 2\n\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for num in nums:\n            for j in range(target, num - 1, -1):\n                dp[j] = dp[j] or dp[j - num]\n\n        return dp[target]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整內容\n    raw_input = sys.stdin.read().strip()\n    # 允許輸入形如 \"nums = [1,5,11,5]\" 或單獨的 \"[1,5,11,5]\"\n    if raw_input.lower().startswith(\"nums\"):\n        raw_input = raw_input.split(\"=\", 1)[1].strip()\n    # 使用安全的 literal_eval 解析數組\n    try:\n        nums = ast.literal_eval(raw_input)\n    except Exception:\n        nums = []\n\n    solution = Solution()\n    result = solution.canPartition(nums)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,11,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,5]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode398.json",
    "problem_index_in_file": 0,
    "title": "Random Pick Index",
    "description_snippet": "Given an integer array nums with possible duplicates, randomly output the index of a given target nu...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for this algorithm: reservoir sampling. Steps: Store array in constructor. In pick: iterate indices, maintain count of target seen, for each index i where nums[i]==target: generate random int between 1 and count, if 1, set result to i. At end return result. Also need random function. Provide virtual code lines.\n\nEnsure format: each line: \"虛擬碼步驟 // 解釋\". Use arrows etc. Use Start, End, Decision.\n\nWe need to include constructor and method. Let's structure:\n\nStart\n→ Step 1: Store nums into instance variable // Save input array\n→ Step 2: Initialize random number generator // For reproducibility\n→ End // Constructor ends\n\nNow pick method:\n\nStart // pick method start\n→ Step 1: Set count = 0 // Number of target occurrences seen so far\n→ Step 2: Set result = -1 // Placeholder for chosen index\n→ Decision: For each index i from 0 to nums.length-1? // Iterate over array\n    → Step 3: If nums[i] == target? // Check match\n        → Yes → Step 4: Increment count // Found another target\n        → Step 5: Generate random number r between 1 and count // Reservoir step\n        → Step 6: If r == 1? // Choose this index\n            → Yes → Step 7: Set result = i // Update result\n            → No → Step 8: // Do nothing\n        → No → // Not target, continue\n→ End // Return result\n→ Step 9: Return result // Output chosen index\n\nBut need to use Decision arrow formatting.\n\nWe can express for loop as Decision: If i < nums.length? But better to use Loop construct? The spec only shows Decision. We'll use Decision: If i < nums.length? But we might not include loop but just show iteration step. For clarity, we can show Decision: For each i? Might not be necessary. Use \"→ Decision: 遍歷所有索引 i?\".\n\nLet's craft:\n\nStart // pick 方法開始\n→ Step 1: Set count = 0 // 目標數字出現次數\n→ Step 2: Set result = -1 // 預備返回索引\n→ Decision: 遍歷索引 i 從 0 到 nums.length-1? // 逐個檢查\n    → Step 3: If nums[i] == target? // 找到目標\n        → Yes → Step 4: Increment count // 更新計數\n        → Step 5: 產生隨機數 r ∈ [1, count] // Reservoir sampling\n        → Step 6: 如果 r == 1? // 選中此索引\n            → Yes → Step 7: result = i // 記錄索引\n            → No → // 不選中，保持現有 result\n        → No → // 當前元素不是目標，直接跳過\n→ Step 8: Return result // 回傳最終選中的索引\nEnd // pick 方法結束\n\nBut need to ensure each line ends with // 解釋. Provide virtual code arrows accordingly.\n\nWe must also include constructor virtual code:\n\nStart // 建構子開始\n→ Step 1: Store nums into this.nums // 保存輸入陣列\n→ Step 2: 初始化隨機數生成器 // 供 pick 使用\nEnd // 建構子結束\n\nMaybe we need to define a Random variable. Use Step 2: this.random = new Random()\n\nLet's produce final answer.\n...done thinking.\n\nStart // 建構子開始\n→ Step 1: this.nums = nums // 保存輸入陣列\n→ Step 2: this.random = new Random() // 初始化隨機數生成器\nEnd // 建構子結束\n\nStart // pick 方法開始\n→ Step 1: count = 0 // 目標值已出現次數\n→ Step 2: result = -1 // 預備返回索引\n→ Decision: 逐個檢查索引 i 從 0 到 nums.length-1? // 遍歷陣列\n    Yes → Step 3: If nums[i] == target? // 找到目標\n        Yes → Step 4: count = count + 1 // 更新計數\n        → Step 5: r = random.nextInt(count) + 1 // 產生 1~count 的隨機數\n        → Decision: r == 1? // 是否選中此索引\n            Yes → Step 6: result = i // 記錄此索引\n            No  → // 保持現有 result\n        No  → // 當前元素不是目標，直接跳過\n→ Step 7: return result // 回傳最終選中的索引\nEnd // pick 方法結束",
      "generated_code": "import sys\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, nums):\n        # Store the array for later reference\n        self.nums = nums\n\n    def pick(self, target):\n        \"\"\"\n        Randomly pick an index where nums[i] == target.\n        Uses reservoir sampling to ensure uniform probability.\n        \"\"\"\n        count = 0        # Number of target occurrences seen so far\n        result = -1      # Placeholder for the chosen index\n\n        for i, num in enumerate(self.nums):\n            if num == target:\n                count += 1\n                # Generate a random integer in [1, count]\n                # If it equals 1, select this index\n                if random.randint(1, count) == 1:\n                    result = i\n        return result\n\n\ndef main():\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n\n    # Separate the two parts: operations list and arguments list\n    split_index = data.find('],')\n    ops_str = data[:split_index + 1]          # include the closing bracket of ops\n    args_str = data[split_index + 2:]         # skip the comma and space after the bracket\n\n    # Safely parse the two lists\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    # Execute the operations and collect results\n    results = []\n    sol = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # arg is a list containing the initial array\n            sol = Solution(arg[0])\n            results.append(None)\n        elif op == \"pick\":\n            # arg is a list with a single target value\n            results.append(sol.pick(arg[0]))\n\n    # Output the results list\n    print(results)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[None,4,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[None, 4, 0, 3]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode139.json",
    "problem_index_in_file": 0,
    "title": "Word Break",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a spac...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for Word Break problem. Use DP or backtracking. We'll produce DP algorithm: boolean dp[i] = true if prefix s[0:i] can be segmented. Iterate i from 1 to n, inner j from 0 to i, if dp[j] and s[j:i] in dict set, set dp[i] true. Use virtual code steps: Start, Step: read input, convert dict to set, initialize dp[0]=true, loops, decisions.\n\nWe must include arrows and decisions.\n\nLet's structure:\n\nStart\n→ Step 1: Input string s and dictionary wordDict // get data\n→ Step 2: 將 wordDict 轉為 set dictSet // for O(1) lookup\n→ Step 3: 初始化 dp 陣列長度 n+1 為 false // dp[0] = true // 代表空字串可分割\n→ Step 4: For i from 1 to n // 逐個考慮前綴長度\n    → Decision: 如果 dp[i] 已為 true? // 已分割則跳過\n        Yes → Step 5: 繼續下個 i // skip\n        No  → Step 6: For j from 0 to i-1 // 逐個嘗試分割點\n            → Decision: 如果 dp[j] 為 true 且 s[j:i] 在 dictSet? // 前綴可分割且詞典有此子串\n                Yes → Step 7: 將 dp[i] 設為 true // 成功分割\n                No  → Step 8: 繼續 j // 下一個 j\n    // (j loop ends)\n→ Step 9: 回傳 dp[n] // 最終結果\n\nWe also need End.\n\nMake sure each line ends with // explanation. Use arrow symbols as specified: '→', 'Yes →', 'No →'. Indent appropriately.\n\nLet's craft each line.\n\nWe need each line start with something like \"→ Step 1:\" etc. For decisions, we have \"→ Decision: ...\" and then indent children with spaces. Format example shows indentation.\n\nWe'll follow same style: indentation using two spaces? They used tab? We'll use four spaces maybe. Let's replicate style: They used \"→ Decision: ...\" then new lines indent with two spaces. For Yes/No arrow lines, also indent same level as children.\n\nWe'll produce.\n\nLet's produce lines.\n\nLine1: Start // 程式開始執行\nLine2: → Step 1: 讀取字串 s 和字典 wordDict // 從使用者取得輸入\nLine3: → Step 2: 建立 set dictSet 以存放 wordDict 中的單詞 // 為 O(1) 查詢做準備\nLine4: → Step 3: 建立長度為 n+1 的布林陣列 dp，並將 dp[0] 設為 true // 空字串可被視為已分割\nLine5: → Decision: 對 i 從 1 到 n 做迴圈? // 逐步考慮每個前綴長度\nLine6:     Yes → Step 4: 如果 dp[i] 已為 true，則跳過此 i // 已知可分割，不需再處理\nLine7:     No  → Step 5: 進入 j 從 0 到 i-1 的迴圈 // 嘗試所有分割點\nLine8:         → Decision: dp[j] 為 true 且 s[j:i] 在 dictSet? // 前前綴可分割且子串為字典詞\nLine9:             Yes → Step 6: 將 dp[i] 設為 true // 成功分割，記錄下來\nLine10:            No  → Step 7: 繼續 j 往下 // 試下一個 j\nLine11: End // 程式執行結束\n\nBut we must also have step to return dp[n]. Add after loop. So after step 5 loop ends, we need Step 8: 回傳 dp[n] // 結果\n\nBut where to place? After outer loop completes. So after line 7 (No → Step 5...), we need after j loop finishes and after i loop finishes, we return dp[n]. Use step after outer loop? We can add after line 5, after all i processed. Let's add new step after i loop finishes: \"→ Step 8: 回傳 dp[n] // 判斷整個字串是否可分割\".\n\nThus final structure:\n\nStart\n→ Step 1: ...\n→ Step 2: ...\n→ Step 3: ...\n→ Decision: 對 i 從 1 到 n 做迴圈?\n    Yes → Step 4: 如果 dp[i] 已為 true，則跳過此 i // 已知可分割，不需再處理\n    No  → Step 5: 進入 j 從 0 到 i-1 的迴圈 // 嘗試所有分割點\n        → Decision: dp[j] 為 true 且 s[j:i] 在 dictSet?\n            Yes → Step 6: 將 dp[i] 設為 true // 成功分割，記錄下來\n            No  → Step 7: 繼續 j 往下 // 試下一個 j\n→ Step 8: 回傳 dp[n] // 判斷整個字串是否可分割\nEnd\n\nBut we also need to mention dp array initialization for n+1. We have that.\n\nWe must ensure each line's explanation is short.\n\nLet's produce final answer with each line. Use Chinese.\n\nAlso, note that after step 4 we skip to next i; but we need to indicate loop continues. That is fine.\n\nWe might need to add step inside loop to set dp[i] true only if dp[i] remains false. But not needed.\n\nMake sure lines don't exceed.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 s 與字典 wordDict // 從使用者取得輸入  \n→ Step 2: 將 wordDict 轉為 set dictSet // 方便 O(1) 查詢  \n→ Step 3: 建立長度 n+1 的布林陣列 dp，並將 dp[0] 設為 true // 空字串視為已分割  \n→ Decision: 對 i 從 1 到 n 做迴圈? // 逐步檢查每個前綴長度  \n    Yes → Step 4: 若 dp[i] 已為 true，跳過此 i // 已可分割，不需再處理  \n    No  → Step 5: 進入 j 從 0 到 i-1 的迴圈 // 嘗試所有分割點  \n        → Decision: dp[j] 為 true 且 s[j:i] 在 dictSet? // 前前綴可分割且子串為字典詞  \n            Yes → Step 6: 將 dp[i] 設為 true // 成功分割，記錄下來  \n            No  → Step 7: 繼續 j 往下 // 試下一個 j  \n→ Step 8: 回傳 dp[n] // 判斷整個字串是否可分割  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n        word_set = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(s)]\n\ndef parse_input(text: str):\n    \"\"\"從輸入字串中擷取 s 與 wordDict\"\"\"\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', text)\n    dict_match = re.search(r'wordDict\\s*=\\s*\\[([^\\]]*)\\]', text)\n    if not s_match or not dict_match:\n        return None, None\n    s = s_match.group(1)\n    dict_contents = dict_match.group(1)\n    words = []\n    for part in dict_contents.split(','):\n        part = part.strip()\n        if part.startswith('\"') and part.endswith('\"'):\n            words.append(part[1:-1])\n        elif part:\n            words.append(part)  # 不帶引號的情況\n    return s, words\n\ndef main():\n    data = sys.stdin.read()\n    s, wordDict = parse_input(data)\n    if s is None or wordDict is None:\n        return\n    solution = Solution()\n    result = solution.wordBreak(s, wordDict)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode283.json",
    "problem_index_in_file": 0,
    "title": "Move Zeroes",
    "description_snippet": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate step-by-step pseudocode in Chinese, describing algorithm to move zeros to end, in-place, maintain order. Use Start, End, Decision, arrows. Each line includes comment. Let's outline algorithm: two pointers: writeIndex = 0. For i from 0 to len(nums)-1: if nums[i] != 0: swap nums[writeIndex] and nums[i]; writeIndex++. At end, zeros at end. Or we can push non-zero to new array and fill zeros, but need in-place. So using two pointers.\n\nWe must generate step lines with arrows and decisions. For loops not directly described but can be in steps. Use \"Step 1: 初始化 writeIndex=0\". \"Step 2: 循環遍歷 i\" maybe \"Decision: i < len(nums)?\" with Yes to continue loop, No to end. Inside loop: \"Decision: nums[i] != 0?\" If Yes: \"Step 3: 交換 nums[writeIndex] 與 nums[i]；writeIndex++\". If No: nothing. Then increment i. After loop ends, End.\n\nLet's craft with proper arrows: Use \"→\" arrow from start to Step 1. Use indentation for decisions: use indentation spaces. Use \"Yes →\" and \"No →\".\n\nNeed each line with // comment.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 設定 writeIndex = 0 // 初始化寫入指標\n→ Step 2: 設定 i = 0 // 初始化遍歷指標\n→ Decision: i < len(nums) // 檢查是否還有元素要遍歷\n    Yes → Step 3: Decision: nums[i] != 0 // 判斷當前元素是否非零\n        Yes → Step 4: 交換 nums[writeIndex] 與 nums[i] // 將非零元素移至前面\n        Yes → Step 5: writeIndex = writeIndex + 1 // 移動寫入指標\n        No  → // 當為零時不做任何操作\n    Yes → Step 6: i = i + 1 // 移動到下一個元素\n    No → End // 循環結束，所有元素已處理\nEnd // 程式執行結束\n\nWe need to ensure each line includes arrow or decision. Indentation. Provide short explanation after //.\n\nCheck formatting: Use `→` and `Decision:` lines. For Decision block indentation, indent with 4 spaces or tab. Ensure \"Yes →\" and \"No →\" lines are indented further.\n\nAlso we must have the final \"End\". Provide comment after each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 writeIndex = 0 // 初始化寫入指標，指向第一個非零元素應放置的位置  \n→ Step 2: 設定 i = 0 // 初始化遍歷指標，從陣列第一個元素開始  \n→ Decision: i < len(nums) // 檢查是否還有元素要遍歷  \n Yes → Step 3: Decision: nums[i] != 0 // 判斷目前元素是否為非零  \n  Yes → Step 4: 交換 nums[writeIndex] 與 nums[i] // 把非零元素移到前面，保持相對順序  \n  Yes → Step 5: writeIndex = writeIndex + 1 // 更新寫入指標，指向下一個可放置非零的位置  \n  No  → // 如果是零則不做任何改動，直接跳到下一步  \n Yes → Step 6: i = i + 1 // 移動到下一個元素繼續遍歷  \n No  → End // i 已超出陣列長度，遍歷結束，所有非零元素已在前，零自動被移到尾端  \nEnd // 程式執行結束，陣列已就地完成移動零的操作",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def moveZeroes(self, nums):\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        write_idx = 0  # 指向下一個應該放非零數字的位置\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                nums[write_idx], nums[i] = nums[i], nums[write_idx]\n                write_idx += 1\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中抽取列表。支持 'nums = [0,1,0]' 或直接 '[0,1,0]' 等格式。\"\"\"\n    # 找出第一個 '[' 和最後一個 ']'，並評估中間內容\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1 and end > start:\n        list_str = data[start:end+1]\n    else:\n        # 若找不到方括號，嘗試直接 eval 整個字串\n        list_str = data\n    try:\n        return eval(list_str, {\"__builtins__\": None}, {})\n    except Exception:\n        # 如果 eval 失敗，回傳空列表以避免程式崩潰\n        return []\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    # 解析輸入得到 nums 列表\n    nums = parse_input(raw_input)\n    # 呼叫解法\n    Solution().moveZeroes(nums)\n    # 輸出結果\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,0,3,12]",
          "expected_output": "[1,3,12,0,0]",
          "success": true,
          "output": "[1, 3, 12, 0, 0]"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode650.json",
    "problem_index_in_file": 0,
    "title": "2 Keys Keyboard",
    "description_snippet": "There is only one character 'A' on the screen of a notepad. You can perform one of two operations on...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines for the problem of \"2 Keys Keyboard\" (minimum operations to get n As). We should produce a pseudo algorithm step by step, with explanation comments.\n\nWe need to use virtual code steps: Start, → Step, Decision, etc. Each line includes the virtual code and // explanation. Must not output actual code.\n\nWe must produce a solution algorithm, likely using DP or factorization. For explanation, we can say we use DP: dp[i] minimal steps for i As, with dp[1] = 0. For each i from 2 to n, dp[i] = min over all j where i % j == 0 of dp[j] + i/j. Then output dp[n]. That's typical.\n\nWe need to produce virtual code lines accordingly. Let's structure:\n\nStart\n\n→ Step: Initialize dp array of size n+1 // dp[1] = 0\n\n→ For i from 2 to n: // iterate possible target\n\n   → Decision: 是否 i 可以被 j 整除? for each j from 1 to i-1\n\n     (But in pseudocode we can show nested loops.)\n\n   Actually we can show: → Step: Set dp[i] = large\n\n   → For each divisor j of i (j < i):\n\n      → Step: candidate = dp[j] + i/j\n\n      → Decision: candidate < dp[i]? // update\n\n   After loops, dp[i] computed.\n\n→ Step: Output dp[n] // result\n\nEnd\n\nAlso explain algorithm reasoning: Because best way to reach i As is to reach some divisor j and then perform (i/j) pastes, each paste adds j As, total operations dp[j] + i/j.\n\nOk.\n\nWe need to use arrow formatting. Provide each step with comment. Use \"Decision:\" with Yes→ and No→.\n\nWe should present nested decisions maybe.\n\nBetter to show pseudo code:\n\nStart // 程式開始執行\n\n→ Step 1: 建立 dp 陣列並設定 dp[1] = 0 // 初始狀態\n\n→ Decision: n == 1? // 特殊情況\n\n   Yes → Step 2: 輸出 0 // 已達目標\n\n   No  → 進行計算\n\n→ For i from 2 to n: // 計算 dp[i]\n\n   → Step: 設 dp[i] 為無限大 // 初始化\n\n   → For j from 1 to i-1: // 搜尋分母\n\n      → Decision: i % j == 0? // j 為 i 的因子\n\n          Yes → Step: candidate = dp[j] + i/j // 先得到 j As 再貼 i/j 次\n\n          Yes → Decision: candidate < dp[i]? // 是否更新\n\n              Yes → Step: dp[i] = candidate\n\n          No → (不更新)\n\n   → (結束 j 迴圈)\n\n→ Step: 輸出 dp[n] // 最終結果\n\nEnd // 程式執行結束\n\nNeed to ensure each line ends with // comment.\n\nAlso maybe we should include \"End For\" lines but not necessary.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 dp 陣列並設定 dp[1] = 0 // 初始化，dp[i] 為最少操作數  \n→ Decision: n == 1? // 檢查是否已達目標  \n Yes → Step 2: 輸出 0 // 只需要 0 次操作  \n No  → 進行計算  \n→ For i from 2 to n: // 逐個計算 dp[i]  \n  → Step: 設 dp[i] 為無限大 // 初始化為較大值  \n  → For j from 1 to i-1: // 搜尋所有可能的分母 j  \n    → Decision: i % j == 0? // j 必須是 i 的因子  \n     Yes → Step: candidate = dp[j] + i/j // 先得到 j 個 A，再貼 i/j 次  \n     Yes → Decision: candidate < dp[i]? // 是否更新 dp[i]  \n      Yes → Step: dp[i] = candidate // 更新為較小操作數  \n      No  → (不更新)  \n     No  → (跳過非因子)  \n  → (結束 j 迴圈)  \n→ Step: 輸出 dp[n] // 最終答案即為最少操作數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_steps(n: int) -> int:\n    \"\"\"\n    透過將 n 分解成質因數，累加因數之和即為最少操作數。\n    \"\"\"\n    res = 0\n    d = 2\n    while n > 1:\n        while n % d == 0:\n            res += d\n            n //= d\n        d += 1\n    return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料，找出第一個出現的整數\n    data = sys.stdin.read().strip()\n    match = re.search(r'\\d+', data)\n    if match:\n        n = int(match.group())\n    else:\n        n = 0  # 若無有效數字，視為 0\n\n    result = min_steps(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode397.json",
    "problem_index_in_file": 0,
    "title": "Integer Replacement",
    "description_snippet": "Given a positive integer n, you can apply one of the following operations:\n\n1. If n is even, replace...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for algorithm: Given positive integer n, operations: if even -> n/2; if odd -> n+1 or n-1; find min operations to reach 1. This is known as \"integer replacement\" problem. Use BFS or greedy: For odd n, choose between n+1 or n-1, choose whichever leads to more trailing zeros after division. Typically rule: if n==3 or n%4==1 then n-- else n++.\n\nWe need virtual code line by line. Each line with \"虛擬碼步驟 // 解釋\".\n\nWe need to use arrow \"→\" and decision \"Decision:\" etc. Format must be step lines, not code. The algorithm: Start, initialize count=0, while n>1, if even -> n/=2, count++; else (odd), if n==3 or n%4==1 then n-- else n++; count++; loop. End.\n\nWe should include maybe variable initialization steps. So step by step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: n ← input positive integer // 取得輸入值\n→ Step 2: ops ← 0 // 初始化操作次數\n→ Decision: n > 1? // 是否仍需進行轉換\n    Yes → Decision: n 是偶數? // 判斷 n 是否為偶數\n        Yes → Step 3: n ← n / 2 // 偶數時除以 2\n             → Step 4: ops ← ops + 1 // 計算一次操作\n             → Back to Decision: n > 1?\n        No  → Decision: n == 3 或 n mod 4 == 1? // 奇數時判斷 3 或尾數為 1\n            Yes → Step 5: n ← n - 1 // n 為 3 或尾數 1 時減 1\n                 → Step 6: ops ← ops + 1 // 計算一次操作\n                 → Back to Decision: n > 1?\n            No  → Step 7: n ← n + 1 // 其餘奇數加 1\n                 → Step 8: ops ← ops + 1 // 計算一次操作\n                 → Back to Decision: n > 1?\n    No  → Step 9: return ops // 回傳最小操作數\nEnd // 程式執行結束\n\nWe should ensure format: each line \"虛擬碼步驟 // 解釋\". For decisions, we may use indentation with tabs? Not required. But we must include \"Decision:\" lines.\n\nWe need to include arrow \"→\" before each step, except maybe Decision: lines also start with arrow. In example they used \"→ Decision:\" lines indented. So mimic that.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: n ← input positive integer // 取得輸入值\n→ Step 2: ops ← 0 // 初始化操作次數\n→ Decision: n > 1? // 是否還未達到 1\n    Yes → Decision: n is even? // 判斷 n 是否為偶數\n        Yes → Step 3: n ← n / 2 // 偶數則除以 2\n            → Step 4: ops ← ops + 1 // 計算一次操作\n            → Back to Decision: n > 1?\n        No  → Decision: n == 3 或 n % 4 == 1? // 奇數時判斷特殊情況\n            Yes → Step 5: n ← n - 1 // 減 1\n                → Step 6: ops ← ops + 1 // 計算一次操作\n                → Back to Decision: n > 1?\n            No  → Step 7: n ← n + 1 // 加 1\n                → Step 8: ops ← ops + 1 // 計算一次操作\n                → Back to Decision: n > 1?\n    No  → Step 9: return ops // 回傳結果\nEnd // 程式執行結束\n\nWe might need to include the \"Back to Decision:\" lines; they may not be needed but it's fine.\n\nCheck formatting: each line should have \"虛擬碼步驟\" then space then \"// 解釋\". So we must keep that. For decision lines, \"Decision: ...\" also counts as a step. For back to decision we may just mention. But maybe we don't need back to decision lines; just loop by going back to decision. But easier to express with loop structure: \"Decision: n > 1?\" and inside loops.\n\nWe can write as:\n\nStart // 程式開始執行\n→ Step 1: n ← input positive integer // 取得輸入值\n→ Step 2: ops ← 0 // 初始化操作次數\n→ Decision: n > 1? // 是否還需操作\n    Yes → Decision: n 是偶數? // 判斷 n 是否為偶數\n        Yes → Step 3: n ← n / 2 // 偶數時除以 2\n            → Step 4: ops ← ops + 1 // 計算一次操作\n            → Back to Decision: n > 1?\n        No  → Decision: n == 3 或 n % 4 == 1? // 奇數時判斷 3 或尾數為 1\n            Yes → Step 5: n ← n - 1 // 減 1\n                → Step 6: ops ← ops + 1 // 計算一次操作\n                → Back to Decision: n > 1?\n            No  → Step 7: n ← n + 1 // 加 1\n                → Step 8: ops ← ops + 1 // 計算一次操作\n                → Back to Decision: n > 1?\n    No  → Step 9: return ops // 回傳最小操作數\nEnd // 程式執行結束\n\nBut the \"Back to Decision:\" lines might be considered separate steps with \"→ Back to Decision:\" but we need to include explanation. But maybe not necessary; the loop can be implied by indentation. In example they didn't show loop back explicitly. So we can omit \"Back to Decision:\" lines. Just rely on indentation. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: n ← input positive integer // 取得輸入值\n→ Step 2: ops ← 0 // 初始化操作次數\n→ Decision: n > 1? // 是否還未達到 1\n    Yes → Decision: n 是偶數? // 判斷 n 是否為偶數\n        Yes → Step 3: n ← n / 2 // 偶數則除以 2\n            → Step 4: ops ← ops + 1 // 計算一次操作\n        No  → Decision: n == 3 或 n % 4 == 1? // 奇數時特殊判斷\n            Yes → Step 5: n ← n - 1 // 減 1\n                → Step 6: ops ← ops + 1 // 計算一次操作\n            No  → Step 7: n ← n + 1 // 加 1\n                → Step 8: ops ← ops + 1 // 計算一次操作\n    No  → Step 9: return ops // 回傳最小操作數\nEnd // 程式執行結束\n\nBut we need to reflect loop: after steps 4,6,8, we go back to decision n > 1? implicitly. That is fine.\n\nMake sure each line ends with comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← input positive integer // 取得輸入值  \n→ Step 2: ops ← 0 // 初始化操作次數  \n→ Decision: n > 1? // 是否還未達到 1  \n Yes → Decision: n 是偶數? // 判斷 n 是否為偶數  \n  Yes → Step 3: n ← n / 2 // 偶數則除以 2  \n   → Step 4: ops ← ops + 1 // 計算一次操作  \n  No → Decision: n == 3 或 n % 4 == 1? // 奇數時特殊判斷  \n   Yes → Step 5: n ← n - 1 // 減 1  \n    → Step 6: ops ← ops + 1 // 計算一次操作  \n   No → Step 7: n ← n + 1 // 加 1  \n    → Step 8: ops ← ops + 1 // 計算一次操作  \n No → Step 9: return ops // 回傳最小操作數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def integerReplacement(self, n: int) -> int:\n        count = 0\n        while n != 1:\n            if n % 2 == 0:\n                n //= 2\n            else:\n                # 針對奇數的決策：若 n == 3 或 (n >> 1) 的最低位為 0，則減 1；否則加 1\n                if n == 3 or ((n >> 1) & 1) == 0:\n                    n -= 1\n                else:\n                    n += 1\n            count += 1\n        return count\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 從輸入中提取第一個出現的整數\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = Solution().integerReplacement(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 8",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode387.json",
    "problem_index_in_file": 0,
    "title": "First Unique Character in a String",
    "description_snippet": "Given a string s, find the first non-repeating character in it and return its index. If it does not ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. The requirement: \"逐行產生對應的虛擬碼 (Virtual Code)\" with explanations after each line. Use Start, End, Decision, arrow symbols. For the problem: given string s, find first non-repeating char, return index or -1. We should use a dictionary to count frequency, then iterate again to find first index with count 1.\n\nWe need to produce lines:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 charCount // 用來存儲每個字元的出現次數\n→ Step 2: 對於每個字元 c 在 s 中，增加 charCount[c] // 計算頻率\n→ Step 3: 對於每個字元 c 在 s 中，檢查 charCount[c] 是否等於 1 // 判斷是否唯一\n    Yes → Step 4: 回傳該字元的索引 // 找到第一個唯一字元\n    No  → Decision: 是否還有下一個字元？ // 繼續迴圈\n        Yes → (回到 Step 3)\n        No  → Step 5: 回傳 -1 // 沒有唯一字元\nEnd // 程式執行結束\n\nBut need to use proper arrow notation. Use \"Decision:\" after step 3. Maybe restructure to two passes.\n\nLet's design:\n\nStart\n→ Step 1: Initialize empty map countMap\n→ Step 2: For each character ch in string s:\n    → Step 2.1: Increment countMap[ch] by 1\n→ Step 3: For each index i and character ch in string s:\n    → Decision: If countMap[ch] == 1?\n        Yes → Step 4: Return i // 找到第一個非重複字元\n        No  → Step 5: Continue loop // 不是非重複字元，檢查下一個\n→ Step 6: Return -1 // 若迴圈結束還未返回，表示沒有非重複字元\nEnd\n\nNeed to match format: each line must contain code step + space + // 解釋. For decision we need indentation? We can indent lines after decision with 4 spaces? Format example shows indentation.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化空字典 countMap // 用來記錄每個字元出現次數\n→ Step 2: 遍歷字符串 s 中的每個字元 ch\n    → Step 2.1: 若 ch 在 countMap 中不存在，設為 0\n    → Step 2.2: countMap[ch] += 1 // 更新計數\n→ Step 3: 再次遍歷字符串 s，從左到右檢查每個字元\n    → Decision: countMap[ch] == 1? // 判斷此字元是否唯一\n        Yes → Step 4: 回傳索引 i // 找到第一個非重複字元\n        No  → Step 5: 進行下一個字元 // 繼續循環\n→ Step 6: 回傳 -1 // 若循環結束仍未找到，表示沒有非重複字元\nEnd // 程式執行結束\n\nBut the format in example: arrows at each line; decision with indentation. They used arrow → before \"Step\". Also \"Decision:\" line starts with arrow and then Decision:.\n\nWe must follow exactly: \"Use virtual code arrow (→, Yes →, No →) and structure (Start, End, Decision:).\" So we need to produce each line starting with \"→\" except Start and End maybe.\n\nIn example:\n\nStart // 程式開始執行\n→ Step 1: ...\n→ Decision: ...\n    Yes → ...\n    No  → ...\n\nThus we should produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化空字典 countMap // 用來存儲每個字元的出現次數\n→ Step 2: 遍歷字符串 s\n    → Step 2.1: countMap[ch] = countMap.get(ch, 0) + 1 // 計算頻率\n→ Step 3: 再次遍歷字符串 s\n    → Decision: countMap[ch] == 1? // 判斷字元是否唯一\n        Yes → Step 4: 回傳索引 i // 找到第一個非重複字元\n        No  → Step 5: 進行下一個字元 // 繼續迴圈\n→ Step 6: 回傳 -1 // 沒有非重複字元\nEnd // 程式執行結束\n\nBut \"Step 2\" may need to indicate char variable, but it's okay.\n\nMake sure each line includes the virtual code step, then a space, then \"// explanation\".\n\nThe indentation: In example, decision and its branches are indented with 4 spaces. We'll follow that.\n\nAlso the \"Step 2\" maybe not needed to break into substeps; can just loop.\n\nSimplify: We can use Step 1: Build frequency map; Step 2: Find first index; Step 3: Return -1.\n\nBut we need to show decision inside step 2. We'll produce.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 countMap // 用來記錄每個字元的出現次數  \n→ Step 2: 遍歷字符串 s  \n  → Step 2.1: countMap[ch] = countMap.get(ch, 0) + 1 // 更新字元頻率  \n→ Step 3: 再次遍歷字符串 s，從左到右檢查每個字元  \n  → Decision: countMap[ch] == 1? // 判斷此字元是否唯一  \n   Yes → Step 4: 回傳索引 i // 找到第一個非重複字元  \n   No  → Step 5: 進行下一個字元 // 繼續循環  \n→ Step 6: 回傳 -1 // 若循環結束仍未找到，表示沒有非重複字元  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport collections\nimport re\n\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        count = collections.Counter(s)\n        for i, char in enumerate(s):\n            if count[char] == 1:\n                return i\n        return -1\n\ndef parse_input(data: str) -> str:\n    # 尋找第一個雙引號之間的字串\n    m = re.search(r'\"([^\"]*)\"', data)\n    if m:\n        return m.group(1)\n    # 若沒有引號，嘗試以 = 分隔並移除可能的引號\n    if '=' in data:\n        part = data.split('=', 1)[1].strip()\n        if part.startswith('\"') and part.endswith('\"'):\n            part = part[1:-1]\n        return part\n    # 最後直接回傳去除首尾空白及引號的字串\n    return data.strip().strip('\"')\n\ndef main():\n    raw = sys.stdin.read()\n    s = parse_input(raw)\n    result = Solution().firstUniqChar(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "s = \"loveleetcode\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "s = \"aabb\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode697.json",
    "problem_index_in_file": 0,
    "title": "Degree of an Array",
    "description_snippet": "Given a non-empty array of non-negative integers nums, the degree of this array is defined as the ma...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for algorithm: given array, find smallest subarray length with same degree as whole array. Classic problem. Steps: iterate array, record first index, last index, count for each value. Then find degree = max count. For each number with count==degree compute last-first+1, take min. Output min length.\n\nWe need to produce lines of virtual code with explanations after //.\n\nFollow formatting: Each line start with virtual code step. Use arrow for flow: Start, Decision, etc.\n\nWe need to produce steps in pseudo.\n\nLet's craft.\n\nStart // start\n→ Step 1: Initialize hash map count, firstIndex, lastIndex // store frequency and indices\n→ Step 2: For each element nums[i] do:\n   → Update count[nums[i]] +=1\n   → If firstIndex[nums[i]] is undefined → firstIndex[nums[i]] = i\n   → lastIndex[nums[i]] = i\nEnd loop\n→ Step 3: Determine degree = max of all count values // maximum frequency\n→ Step 4: Initialize minLength = length of nums // worst case\n→ Step 5: For each key in count do:\n   → If count[key] == degree:\n       → length = lastIndex[key] - firstIndex[key] + 1\n       → If length < minLength → minLength = length\nEnd loop\n→ Step 6: Output minLength // result\n\nBut need to use arrow format: Use \"→\" before each step. Also use Decision when comparing.\n\nMaybe we can show decision inside loops.\n\nBetter to produce:\n\nStart // 程式開始執行\n→ Step 1: Declare map frequency, firstPos, lastPos, degree, minLen // 初始化資料結構\n→ Step 2: For i from 0 to nums.length-1 do // 逐個檢視陣列元素\n    → Update frequency[nums[i]] += 1\n    → If firstPos[nums[i]] not exist → firstPos[nums[i]] = i\n    → lastPos[nums[i]] = i\n→ End For\n→ Step 3: Compute degree = maximum value in frequency // 找到最大頻率\n→ Step 4: Set minLen = nums.length // 設定初始最小長度\n→ Step 5: For each key in frequency do\n    → Decision: if frequency[key] == degree? // 選取符合度的元素\n        Yes → length = lastPos[key] - firstPos[key] + 1\n              → Decision: if length < minLen? // 更新最小長度\n                 Yes → minLen = length\n                 No  → // 無需更新\n        No → // 跳過非度元素\n→ End For\n→ Step 6: Return minLen // 輸出結果\nEnd // 程式結束\n\nNeed to maintain arrow and indentation maybe.\n\nThe example shows indentation but not required. We'll produce lines as:\n\nStart // 程式開始執行\n→ Step 1: ...\n\nBut the decision part shows \"Decision:\" lines with indentation for Yes/No.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Declare maps `frequency`, `firstPos`, `lastPos` and variables `degree`, `minLen` // 初始化頻率與位置儲存結構\n→ Step 2: For i from 0 to nums.length-1 do // 逐個檢視陣列元素\n    → frequency[nums[i]] += 1 // 更新該值的出現次數\n    → Decision: 如果 firstPos[nums[i]] 未設定? // 判斷是否第一次遇到此值\n        Yes → firstPos[nums[i]] = i // 記錄首次出現位置\n        No  → // 已存在，無需改動\n    → lastPos[nums[i]] = i // 更新最後一次出現位置\n→ End For\n→ Step 3: degree = 最大值於 frequency.values() // 找到整個陣列的度\n→ Step 4: minLen = nums.length // 初始最小長度設定為陣列長度\n→ Step 5: For each key in frequency do // 遍歷所有不同的數值\n    → Decision: 如果 frequency[key] == degree? // 只考慮具有最高頻率的數值\n        Yes → length = lastPos[key] - firstPos[key] + 1 // 計算對應子陣列長度\n              → Decision: 如果 length < minLen? // 判斷是否更新最小長度\n                  Yes → minLen = length // 更新為更短的子陣列長度\n                  No  → // 當前長度已是最短，保持不變\n        No  → // 不是度的數值，跳過\n→ End For\n→ Step 6: Return minLen // 輸出最短子陣列長度\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findShortestSubArray(self, nums):\n        # 記錄每個數字的第一次出現位置、最後一次出現位置與出現次數\n        left, right, count = {}, {}, {}\n        for i, num in enumerate(nums):\n            if num not in left:\n                left[num] = i          # 第一次出現的位置\n            right[num] = i             # 最後一次出現的位置\n            count[num] = count.get(num, 0) + 1  # 次數累加\n\n        # 整個陣列的度（最大頻率）\n        degree = max(count.values())\n\n        # 只考慮具有最大頻率的數字，找到最短子陣列長度\n        min_length = float('inf')\n        for num in count:\n            if count[num] == degree:\n                length = right[num] - left[num] + 1\n                if length < min_length:\n                    min_length = length\n\n        return min_length\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    data = sys.stdin.read()\n\n    # 找到第一個 '[' 與最後一個 ']'，並把它們之間的字串轉成列表\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        raise ValueError(\"輸入格式錯誤，請提供 nums = [ ... ]\")\n\n    nums_str = data[start:end+1]\n    nums = ast.literal_eval(nums_str)\n\n    solution = Solution()\n    result = solution.findShortestSubArray(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,2,3,1,4,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode503.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element II",
    "description_snippet": "Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve next greater element in circular array. Use stack approach. Provide steps line by line with explanation. Ensure each line has \"虛擬碼步驟 // 解釋\". Use arrows. Start, End, Decision. We'll produce algorithm. Need to mention stack initialization, loop twice, etc.\n\nLet's write steps:\n\nStart\n→ Step 1: 將輸入數組 nums 存入變量 nums\n→ Step 2: 計算 n = nums.length\n→ Step 3: 建立長度為 n 的結果陣列 res，初始化為 -1\n→ Step 4: 建立空棧 stack 存儲索引\n→ Decision: 是否開始雙倍遍歷? // We'll do for i in range(2*n)\n    Yes → Step 5: 計算 idx = i mod n\n    → Decision: 是否已在棧中? // While stack not empty and nums[idx] > nums[stack.top()]\n        Yes → Step 6: topIdx = stack.pop()\n        → Step 7: res[topIdx] = nums[idx] // 設置下一個更大值\n        No  → 迴圈結束\n    → Step 8: 若 i < n 则 stack.push(idx) // 只在第一次遍歷時將索引推入棧\nEnd\n\nNeed to include decisions with Yes/No branches. Let's craft accordingly.\n\nMake sure each line is a step with arrow. Use Decision: ...? lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入數組 nums // 從使用者處取得整數陣列  \n→ Step 2: 計算 n = nums.length // 獲取陣列長度  \n→ Step 3: 建立長度為 n 的結果陣列 res，初始化全部為 -1 // 用於儲存每個元素的下一個更大值  \n→ Step 4: 建立空棧 stack 存儲索引 // 方便追蹤尚未找到更大值的元素  \n→ Decision: 需要進行雙倍遍歷（0 ≤ i < 2*n）? // 兩次完整遍歷以處理循環性  \n    Yes → Step 5: 計算 idx = i mod n // 取得當前索引  \n    → Decision: 棧不為空且 nums[idx] > nums[stack.top()]? // 檢查能否彈出更大值  \n        Yes → Step 6: topIdx = stack.pop() // 移除棧頂索引  \n        → Step 7: res[topIdx] = nums[idx] // 為該索引設定下一個更大值  \n        No  → // 繼續下一個 i，棧保持不變  \n    → Decision: i < n? // 僅在第一次遍歷時將索引加入棧  \n        Yes → Step 8: stack.push(idx) // 將索引加入棧以備後續比較  \n        No  → // 第二次遍歷不再推入棧  \nEnd // 程式執行結束，返回 res 為每個元素的下一個更大值（若不存在則為 -1）",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def nextGreaterElements(self, nums):\n        n = len(nums)\n        res = [-1] * n\n        stack = []\n\n        for i in range(2 * n):\n            while stack and nums[stack[-1]] < nums[i % n]:\n                res[stack.pop()] = nums[i % n]\n            if i < n:\n                stack.append(i)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 只取方括號之間的內容，例如「nums = [1,2,1]」 → \"[1,2,1]\"\n    idx = data.find('[')\n    if idx != -1:\n        arr_str = data[idx:]\n    else:\n        arr_str = data\n\n    try:\n        nums = ast.literal_eval(arr_str)\n    except Exception:\n        nums = []\n\n    result = Solution().nextGreaterElements(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1]",
          "expected_output": "[2,-1,2]",
          "success": true,
          "output": "[2, -1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,3]",
          "expected_output": "[2,3,4,-1,4]",
          "success": true,
          "output": "[2, 3, 4, -1, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode120.json",
    "problem_index_in_file": 0,
    "title": "Triangle",
    "description_snippet": "Given a triangle array, return the minimum path sum from top to bottom.\n\nFor each step, you may move...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode with steps and explanations. Use virtual code style. Use Start, End, Decision etc. Provide one step per line. Let's craft solution: typical DP: for each row from second to bottom, add min of two above. At the end, min of last row. Also can use 1D array. We'll produce algorithm. Let's create steps:\n\nStart\n→ Step 1: 定義 dp 為 triangle[0] 的複製 // 保存當前行的最小路徑和\n→ Decision: triangle 是否為空? // 檢查輸入合法性\n    Yes → Step 2: 返回 0 // 空三角形返回 0\n    No  → Step 3: 循環從第 2 行到最後一行 // 逐行更新 dp\n        → Step 3a: 取得當前行\n        → Step 3b: 建立 new_dp\n        → Step 3c: 循環索引 j\n            → Decision: j 為 0? // 第一個元素只能來自上一行第 0\n                Yes → new_dp[j] = dp[0] + cur[j]\n                No  → Decision: j 為 last? // 最後一個元素只能來自上一行最後一個\n                    Yes → new_dp[j] = dp[-1] + cur[j]\n                    No  → new_dp[j] = min(dp[j-1], dp[j]) + cur[j]\n        → Step 3d: dp = new_dp // 更新 dp\n→ Step 4: 返回 min(dp) // 最終行的最小值即為答案\nEnd\n\nNeed to format each line: virtual code step + space + // explanation. Use arrow lines.\n\nLet's ensure each line has arrow or not. We start with Start. Then arrow lines.\n\nAlso include indentation? Use arrow to denote flows.\n\nWe'll produce like:\n\nStart // 程式開始執行\n→ Step 1: dp ← triangle[0].clone() // 初始化 dp 為頂點值\n→ Decision: triangle 是否為空? // 檢查輸入是否有效\n    Yes → Step 2: Return 0 // 空三角形直接返回 0\n    No  → Step 3: For row_index from 1 to triangle.size - 1 // 逐行處理\n        → Step 3a: cur ← triangle[row_index] // 取得當前行\n        → Step 3b: new_dp ← [] // 建立新的一維陣列\n        → Step 3c: For j from 0 to cur.size - 1 // 遍歷行內元素\n            → Decision: j == 0? // 第一個元素\n                Yes → new_dp[j] = dp[0] + cur[j] // 只能從上一行第 0\n                No  → Decision: j == cur.size - 1? // 最後一個元素\n                    Yes → new_dp[j] = dp[j-1] + cur[j] // 只能從上一行最後\n                    No  → new_dp[j] = min(dp[j-1], dp[j]) + cur[j] // 取兩個可能最小\n        → Step 3d: dp ← new_dp // 用新計算結果更新 dp\n→ Step 4: Return min(dp) // 最後行的最小值即為答案\nEnd // 程式執行結束\n\nLet's ensure each line is separate. Provide arrow only before the step; indentation may not be necessary but use nested arrow? The example uses indentation of arrow within Decision block. We'll mimic.\n\nNeed to use 'Yes →', 'No →'.\n\nAlso note that we used 'Return' but it's part of pseudocode. It's fine.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: dp ← triangle[0].clone() // 初始化 dp 為頂點值\n→ Decision: triangle 是否為空? // 檢查輸入是否有效\n    Yes → Step 2: Return 0 // 空三角形直接返回 0\n    No  → Step 3: For row_index from 1 to triangle.size - 1 // 逐行處理\n        → Step 3a: cur ← triangle[row_index] // 取得當前行\n        → Step 3b: new_dp ← [] // 建立新的一維陣列\n        → Step 3c: For j from 0 to cur.size - 1 // 遍歷行內元素\n            → Decision: j == 0? // 第一個元素只能從上一行第 0\n                Yes → new_dp[j] = dp[0] + cur[j] // 只能從上一行第 0\n                No  → Decision: j == cur.size - 1? // 最後一個元素只能從上一行最後\n                    Yes → new_dp[j] = dp[j-1] + cur[j] // 只能從上一行最後\n                    No  → new_dp[j] = min(dp[j-1], dp[j]) + cur[j] // 取兩個可能最小\n        → Step 3d: dp ← new_dp // 用新計算結果更新 dp\n→ Step 4: Return min(dp) // 最後行的最小值即為答案\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def minimumTotal(self, triangle):\n        if not triangle:\n            return 0\n        # 直接在最後一行初始化 dp\n        dp = triangle[-1][:]\n        # 從倒數第二行往上遍歷\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n        return dp[0]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 只保留等號右邊的列表表達式\n    idx = data.find('[')\n    if idx == -1:\n        triangle = []\n    else:\n        triangle = ast.literal_eval(data[idx:])\n    result = Solution().minimumTotal(triangle)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        },
        {
          "example_index": 1,
          "input": "triangle = [[-10]]",
          "expected_output": "-10",
          "success": true,
          "output": "-10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode506.json",
    "problem_index_in_file": 0,
    "title": "Relative Ranks",
    "description_snippet": "You are given an integer array score of size n, where score[i] is the score of the i_th athlete in a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step. The task: Given array score of unique ints, produce ranking array. Approach: sort scores with original indices, assign ranks, then produce answer array. Provide virtual code with arrows and explanations.\n\nWe need to output line by line.\n\nWe'll do:\n\nStart\n→ Step 1: Create array of pairs (score, index)\n→ Step 2: Sort pairs descending by score\n→ Step 3: Initialize result array of size n\n→ Step 4: Iterate over sorted pairs with rank index i\n    → Decision: if i==0? // first place\n        Yes → Set result[pair.index] = \"Gold Medal\"\n        No → Decision: if i==1? // second place\n            Yes → Set result[pair.index] = \"Silver Medal\"\n            No → Decision: if i==2? // third place\n                Yes → Set result[pair.index] = \"Bronze Medal\"\n                No → Set result[pair.index] = string of (i+1)\nEnd\n\nWe should include arrow formatting.\n\nMake sure to include \"→\" after each step. Use \"Decision:\" for if conditions.\n\nAlso include comments after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 產生 pairs ← (score[i], i) for i = 0 to n-1 // 把分數與原始索引配對  \n→ Step 2: 以 score 降序排序 pairs // 讓最高分在前面  \n→ Step 3: 建立 result 陣列，大小為 n // 用來存放每位選手的名次  \n→ Step 4: 遍歷 sorted pairs，索引為 rankIndex  \n  → Decision: rankIndex == 0? // 第一名  \n    Yes → Set result[pair.index] = \"Gold Medal\" // 金牌  \n    No  → Decision: rankIndex == 1? // 第二名  \n      Yes → Set result[pair.index] = \"Silver Medal\" // 銀牌  \n      No  → Decision: rankIndex == 2? // 第三名  \n       Yes → Set result[pair.index] = \"Bronze Medal\" // 銅牌  \n       No  → Set result[pair.index] = (rankIndex + 1).toString() // 其餘名次為數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findRelativeRanks(self, score):\n        # 先將分數按從高到低排序\n        sorted_scores = sorted(score, reverse=True)\n        rank_map = {}\n        for i, s in enumerate(sorted_scores):\n            if i == 0:\n                rank_map[s] = \"Gold Medal\"\n            elif i == 1:\n                rank_map[s] = \"Silver Medal\"\n            elif i == 2:\n                rank_map[s] = \"Bronze Medal\"\n            else:\n                rank_map[s] = str(i + 1)\n        # 依照原始順序產生排名結果\n        return [rank_map[s] for s in score]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n    else:\n        # 解析輸入成 Python list\n        scores = json.loads(data)\n        result = Solution().findRelativeRanks(scores)\n        # 以 JSON 格式輸出結果\n        print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[5,4,3,2,1]",
          "expected_output": "[\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]",
          "success": true,
          "output": "[\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]"
        },
        {
          "example_index": 1,
          "input": "[10,3,8,9,4]",
          "expected_output": "[\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]",
          "success": true,
          "output": "[\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode451.json",
    "problem_index_in_file": 0,
    "title": "Sort Characters By Frequency",
    "description_snippet": "Given a string s, sort it in decreasing order based on the frequency of the characters. The frequenc...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo code step by step. The input is string s. We need to count frequency of each char, sort characters by decreasing frequency, and output string composed by repeated characters.\n\nSo steps:\n\nStart\n→ Step 1: Initialize frequency map\n→ Step 2: For each character c in s, increment count\n→ Step 3: Convert map entries to list of (char, freq)\n→ Step 4: Sort list descending by freq\n→ Step 5: Initialize result string empty\n→ Step 6: For each (char, freq) in sorted list, append char repeated freq times to result\n→ End\n\nWe may need Decision nodes? Not much. Could have if empty string? But not necessary.\n\nWe'll just produce step lines as described. Use arrows. Each line has explanation.\n\nWe must not output actual code, just pseudocode with arrows.\n\nFollow format exactly.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 freqMap // 用於存放每個字元的頻率\n→ Step 2: 對 s 中每個字元 c 執行\n        freqMap[c] = freqMap.get(c, 0) + 1 // 更新頻率\n→ Step 3: 將 freqMap 轉換為字元-頻率對列表 charFreqList // 方便排序\n→ Step 4: 按頻率遞減排序 charFreqList // 取得高頻到低頻順序\n→ Step 5: 建立空字串 result // 儲存最終排序結果\n→ Step 6: 對 charFreqList 中每對 (c, f) 執行\n        result += c * f // 將字元重複 f 次加入結果\n→ End // 程式執行結束\n\nBut we need each line separate and explanation after space. For multiline steps, maybe still separate lines. Use proper indentation? The format sample uses indentation for nested. We can follow similar.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化空字典 freqMap // 用於存放每個字元的頻率\n→ Step 2: 對 s 中的每個字元 c 執行\n        freqMap[c] = freqMap.get(c, 0) + 1 // 更新 c 的頻率\n→ Step 3: 把 freqMap 轉成字元-頻率對列表 charFreqList // 方便排序\n→ Step 4: 按頻率遞減排序 charFreqList // 取得高頻到低頻的順序\n→ Step 5: 初始化空字串 result // 儲存最終結果\n→ Step 6: 對 charFreqList 中的每對 (c, f) 執行\n        result += c * f // 把字元 c 重複 f 次加入 result\n→ End // 程式執行結束\n\nWe need to ensure each line has \"虛擬碼步驟\" + space + comment.\n\nAlso we should not include extra formatting like bullet lists.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空字典 freqMap // 用於存放每個字元的頻率\n→ Step 2: 對 s 中的每個字元 c 執行\n        freqMap[c] = freqMap.get(c, 0) + 1 // 更新 c 的頻率\n→ Step 3: 把 freqMap 轉成字元-頻率對列表 charFreqList // 方便排序\n→ Step 4: 按頻率遞減排序 charFreqList // 取得高頻到低頻的順序\n→ Step 5: 初始化空字串 result // 儲存最終結果\n→ Step 6: 對 charFreqList 中的每對 (c, f) 執行\n        result += c * f // 把字元 c 重複 f 次加入 result\n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        # Count each character frequency\n        freq = Counter(s)\n        # Build the result by repeating each character freq times\n        return ''.join(char * count for char, count in freq.most_common())\n\ndef main() -> None:\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read()\n    # Extract the string value between quotes (double or single)\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if not match:\n        match = re.search(r\"'([^']*)'\", raw_input)\n    # If still no match, treat the whole input as the string\n    s = match.group(1) if match else raw_input.strip()\n    # Solve the problem\n    sol = Solution()\n    result = sol.frequencySort(s)\n    # Output the result wrapped in double quotes\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eetr\"",
          "success": true,
          "output": "\"eetr\""
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"cccaaa\"",
          "success": true,
          "output": "\"cccaaa\""
        },
        {
          "example_index": 2,
          "input": "s = \"Aabb\"",
          "expected_output": "\"bbAa\"",
          "success": true,
          "output": "\"bbAa\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode336.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Pairs",
    "description_snippet": "You are given a 0-indexed array of unique strings words.\n\nA palindrome pair is a pair of integers (i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for palindrome pairs O(total length). Classic algorithm: build map from word to index, for each word, for each split, check prefixes and suffixes reversed etc. We'll produce step-by-step pseudocode with arrows. Provide explanation per line. Use Start, End. Should be clear. Let's craft.\n\nWe need to mention we iterate each word, split each position including empty string, check reverse substrings.\n\nWe'll produce lines: Start // begin\n\n→ Step 1: Build dictionary word_to_index // map word to its index.\n\n→ Step 2: Initialize result list // store pairs.\n\n→ For each word w with index i: // iterate\n\n→   For each split position k from 0 to len(w): // include empty at end\n\n→     prefix = w[0:k], suffix = w[k:]\n\n→     rev_prefix = reverse(prefix), rev_suffix = reverse(suffix)\n\n→     Decision: if rev_suffix in dict and rev_suffix != w and is_palindrome(prefix) // check left pair\n\n→        Yes → Add pair (i, word_to_index[rev_suffix]) // add\n\n→     Decision: if rev_prefix in dict and rev_prefix != w and is_palindrome(suffix) // check right pair\n\n→        Yes → Add pair (word_to_index[rev_prefix], i)\n\nEdge: avoid duplicate when k==len(w) (suffix empty) and k==0 (prefix empty). Need to handle not adding duplicate pairs when both prefix and suffix empty? In typical algorithm we skip when k==len(w) and rev_suffix==w? We'll include decision to avoid duplicates: skip if k==len(w) and rev_suffix==w? Actually rev_suffix = reverse(empty) = empty not equal to w; ok. For prefix empty, rev_prefix empty. But when prefix empty and suffix w, we add pair (index of empty? no empty string present? Actually there could be empty string in words). If empty string present, need to handle: for each non-empty word that is palindrome, pair with empty string. The algorithm with splits covers that: when k==len(w) prefix==w suffix==empty, rev_suffix==empty. If empty in map, is_palindrome(prefix) must be true to add (i, emptyIndex). Similarly when k==0 prefix==empty, suffix==w, rev_prefix==empty. Add (emptyIndex, i). That gives both directions.\n\nAlso need to avoid duplicate when rev_prefix==rev_suffix? For palindrome word, splits may generate duplicate. But we can add a set to avoid duplicates. We'll note step to add pair only if not already present.\n\nWe need O(total length). So we need to precompute palindrome checks per word? We can check is_palindrome in O(length). But that inside splits leads to O(n * len^2). Instead we can use prefix/suffix palindrome check via precomputing all palindromic prefixes/suffixes. But we can just state algorithm using is_palindrome function but note it's O(len). That would lead to O(total length^2). However typical algorithm's complexity is O(total length) if we use constant-time palindrome checks via precomputed prefix/suffix arrays? But given we only provide pseudocode, we can mention that we use precomputed palindrome checks by storing for each word the set of palindrome prefixes and suffixes. We'll incorporate that.\n\nThus Step: Precompute for each word all palindrome prefixes and suffixes.\n\nSimplify: We can define function isPalindrome(s) in O(len). But to keep O(total length) we rely on fact that each split check uses prefix/suffix palindrome that can be precomputed once per word. We can mention precomputing arrays.\n\nThus virtual code: Step 3: For each word, compute palindromic prefixes and suffixes and store in sets.\n\nThen in main loop use those sets.\n\nOk.\n\nLet's craft final virtual code lines.\n\nEnsure each line includes explanation comment. Use arrows.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Build dictionary word_to_index mapping each unique word to its index // 用於快速查找單字的索引  \n→ Step 2: Initialize result list palindrome_pairs // 存放所有符合條件的 (i, j)  \n→ Step 3: For each word w with index i in words  \n  → Decision: 若字串 w 不為空字串? // 空字串特殊處理已在 Step 5 處理  \n    Yes → Step 3.1: 先計算所有能作為回文前綴與後綴的子字串集合  \n     → Compute set pal_pref where prefix p of w is palindrome // 前綴回文集合  \n     → Compute set pal_suf where suffix s of w is palindrome // 後綴回文集合  \n  → Step 3.2: 對於每個分割點 k 從 0 到 len(w)（含 0 與 len）  \n    → prefix = w[0:k] // 取前綴  \n    → suffix = w[k:] // 取後綴  \n    → rev_prefix = reverse(prefix) // 前綴反轉  \n    → rev_suffix = reverse(suffix) // 後綴反轉  \n    → Decision: 如果 rev_suffix 在 word_to_index 且 rev_suffix != w 且 prefix 在 pal_pref?  \n      Yes → Step 3.2.1: Add pair (i, word_to_index[rev_suffix]) 到 palindrome_pairs // 形成 i→j  \n    → Decision: 如果 rev_prefix 在 word_to_index 且 rev_prefix != w 且 suffix 在 pal_suf?  \n      Yes → Step 3.2.2: Add pair (word_to_index[rev_prefix], i) 到 palindrome_pairs // 形成 j→i  \n→ Step 4: 若 words 中包含空字串 ''  \n  → 取得空字串索引 empty_idx = word_to_index['']  \n  → Decision: 若 empty_idx 不是 None?  \n    Yes → For every word w_idx, w_str in words  \n      Decision: 如果 w_str != '' 且 w_str 是回文?  \n       Yes → Step 4.1: Add pair (w_idx, empty_idx)  \n       Yes → Step 4.2: Add pair (empty_idx, w_idx)  \n→ End // 程式執行結束，返回 palindrome_pairs",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def palindromePairs(self, words):\n        # Map each word to its index for O(1) lookup\n        word_to_index = {word: i for i, word in enumerate(words)}\n        res = []\n        # For each word, consider all split positions\n        for i, word in enumerate(words):\n            L = len(word)\n            for j in range(L + 1):\n                prefix, suffix = word[:j], word[j:]\n                # If prefix is a palindrome, look for reversed suffix\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in word_to_index:\n                        k = word_to_index[rev_suffix]\n                        if k != i:\n                            res.append([k, i])\n                # If suffix is a palindrome, look for reversed prefix\n                if j != L and suffix == suffix[::-1]:\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in word_to_index:\n                        k = word_to_index[rev_prefix]\n                        if k != i:\n                            res.append([i, k])\n        return res\n\nif __name__ == \"__main__\":\n    # Read entire stdin content\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Parse input: either \"words = [...]\" or just a list literal\n    try:\n        if '=' in data:\n            _, expr = data.split('=', 1)\n            words = ast.literal_eval(expr.strip())\n        else:\n            words = ast.literal_eval(data)\n    except Exception:\n        # Fallback: try to evaluate as is\n        words = ast.literal_eval(data)\n\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    # Output without spaces to match examples\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[1,0],[0,1],[3,2],[2,4]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[1, 0], [0, 1], [3, 2], [2, 4]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1]]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0, 1], [1, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode386.json",
    "problem_index_in_file": 0,
    "title": "Lexicographical Numbers",
    "description_snippet": "Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to generate lexicographical order numbers from 1 to n in O(n) time and O(1) space. The algorithm known: DFS pre-order traversal of number tree or iterative using next number. Approach: Start at 1, output, then increment to next lexicographic number. Use while loop for count n times. Compute next: if current*10 <= n, go deeper (current *=10). Else if current%10 !=9 and current+1 <= n, next=current+1. Else move up: while current%10==9 or current+1 > n, current//=10. then current+=1. This uses O(1) extra space and O(n). We need to produce virtual code step-by-step. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Let's craft lines.\n\nStart, initialize current=1, count=0. Loop while count < n. Output current, increment count. Then compute next as above. End.\n\nWe must use Decision: if conditions etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: current ← 1 // 初始化目前數字為 1\n→ Step 2: count ← 0 // 初始化已輸出數字個數\n→ Decision: 是否已輸出 n 個數字? // 判斷是否結束\n    No → Step 3: 輸出 current // 將 current 輸出到結果\n    No → Step 4: count ← count + 1 // 更新已輸出數字個數\n    No → Decision: current * 10 ≤ n? // 判斷能否進一步縮進\n        Yes → Step 5: current ← current * 10 // 進入子節點\n        No  → Decision: current % 10 ≠ 9 AND current + 1 ≤ n? // 能否右移\n            Yes → Step 6: current ← current + 1 // 右移至下一個兄弟節點\n            No  → Step 7: Decision: current % 10 = 9 OR current + 1 > n? // 需要上升\n                Yes → Step 8: current ← current / 10 // 回到父節點\n                Yes → Step 9: current ← current + 1 // 移動到父節點的下一個兄弟\n                No  → Step 10: current ← current + 1 // 若不需要回退，直接右移\n    No → Step 11: // 迴圈回到 Decision\nEnd // 程式執行結束\n\nBut need to ensure proper indentation and formatting. Virtual code lines should include arrows with indent maybe. We should also note that after step 8/9 we need to go back to Decision to check again if still need to ascend until condition satisfied. So need nested decisions.\n\nSimplify: Use while loop with logic: while count < n: output, count++; if current*10 <= n: current*=10; else if current%10 !=9 and current+1 <= n: current+=1; else: while current%10==9 or current+1>n: current//=10; current+=1.\n\nWe can break into steps.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: current ← 1 // 設定起始數字\n→ Step 2: count ← 0 // 記錄已輸出數字個數\n→ Decision: count < n? // 是否還有數字未輸出\n    Yes → Step 3: 輸出 current // 將 current 輸出\n    Yes → Step 4: count ← count + 1 // 增加輸出計數\n    Yes → Decision: current * 10 ≤ n? // 是否可以進入子節點\n        Yes → Step 5: current ← current * 10 // 進入子節點\n        No  → Decision: current % 10 ≠ 9 AND current + 1 ≤ n? // 能否右移兄弟節點\n            Yes → Step 6: current ← current + 1 // 右移到下一個兄弟節點\n            No  → Step 7: Decision: current % 10 = 9 OR current + 1 > n? // 必須上升到父節點\n                Yes → Step 8: current ← current / 10 // 回到父節點\n                Yes → Step 9: current ← current + 1 // 移動到父節點的下一個兄弟節點\n                No  → Step 10: current ← current + 1 // 若不需要上升，直接右移\n    Yes → Step 11: // 迴圈結束後重新判斷 count < n\n    No → End // 所有數字已輸出，程式結束\n\nBut we must include arrow after each step. Ensure each line starts with arrow \"→\". The Decision lines also start with arrow.\n\nWe also need to note that the while loop continues; after step 11 we go back to Decision: count < n? So it's a loop.\n\nLet's craft final output. Use proper indent maybe with spaces before nested Decision.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: current ← 1 // 設定起始數字為 1  \n→ Step 2: count ← 0 // 初始化已輸出數字個數  \n→ Decision: count < n? // 判斷是否還有數字未輸出  \n  Yes → Step 3: 輸出 current // 將 current 輸出  \n  Yes → Step 4: count ← count + 1 // 更新已輸出數字個數  \n  Yes → Decision: current * 10 ≤ n? // 可否進入下一層子節點？  \n    Yes → Step 5: current ← current * 10 // 進入子節點  \n    No → Decision: current % 10 ≠ 9 AND current + 1 ≤ n? // 能否右移兄弟節點？  \n      Yes → Step 6: current ← current + 1 // 右移到下一個兄弟節點  \n      No → Decision: current % 10 = 9 OR current + 1 > n? // 必須回到父節點？  \n        Yes → Step 7: current ← current / 10 // 回到父節點  \n        Yes → Step 8: current ← current + 1 // 移動到父節點的下一個兄弟節點  \n        No → Step 9: current ← current + 1 // 若不需要回退，直接右移  \n      No → Step 10: current ← current + 1 // 不符合前面條件時直接右移  \n  Yes → Step 11: // 迴圈結束後重新判斷 count < n  \n  No → End // 所有數字已輸出，程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def lexicalOrder(self, n: int):\n        \"\"\"\n        Return all numbers from 1 to n in lexicographical order.\n        Algorithm runs in O(n) time and O(1) extra space (aside from the result list).\n        \"\"\"\n        result = []\n        current = 1\n        for _ in range(n):\n            result.append(current)\n            # If we can go deeper into the next digit (prefix * 10)\n            if current * 10 <= n:\n                current *= 10\n            else:\n                # If we cannot go deeper, try to move to the next sibling\n                if current % 10 != 9 and current + 1 <= n:\n                    current += 1\n                else:\n                    # Need to backtrack to find the next valid number\n                    while current % 10 == 9 or current + 1 > n:\n                        current //= 10\n                    current += 1\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the first integer found in the input\n    match = re.search(r'\\d+', data)\n    if not match:\n        raise ValueError(\"No integer found in input.\")\n    n = int(match.group())\n    sol = Solution()\n    result = sol.lexicalOrder(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "success": true,
          "output": "[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode10.json",
    "problem_index_in_file": 0,
    "title": "Regular Expression Matching",
    "description_snippet": "Given an input string s and a pattern p, implement regular expression matching with support for '.' ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for regex matching DP or recursion. Use steps with arrows. Provide each line with // explanation. Use Start, Decision, Step, End. Provide lines. Let's craft algorithm: DP table dp[i][j] meaning s[0..i-1] matches p[0..j-1]. Initialize dp[0][0] true. For j from 2 to pLen step 2, if p[j-1]=='*' and dp[0][j-2] true, dp[0][j]=true. For i from 1..sLen, for j from 1..pLen: if p[j-1]==s[i-1] or p[j-1]=='.', dp[i][j]=dp[i-1][j-1]. else if p[j-1]=='*': if p[j-2]==s[i-1] or p[j-2]=='.', dp[i][j]=dp[i][j-2] or dp[i-1][j] else dp[i][j]=dp[i][j-2]. At end return dp[sLen][pLen]. Provide steps accordingly.\n\nMake sure to use virtual code syntax with arrows. Provide each line. Use spaces. We'll use \"→\" for flow. Use \"Decision:\" for conditions. Use \"Yes →\" and \"No →\" for branches.\n\nLet's produce: \nStart\n→ Initialize variables: sLen ← length of s, pLen ← length of p // set lengths\n→ Create 2D array dp[sLen+1][pLen+1] initialized to false // DP table\n→ Set dp[0][0] ← true // empty string matches empty pattern\n→ Decision: If p[0] == '*'? but pattern cannot start with '*' typically. So skip.\n\nWe need loops. Use pseudo loops: \"Loop i from 0 to sLen\" etc. Provide decision inside loops.\n\nWe'll use indentation by spaces.\n\nLet's craft. Ensure each line includes // explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ sLen ← length(s) // 取得輸入字串長度  \n→ pLen ← length(p) // 取得模式字串長度  \n→ dp ← 2D array of size (sLen+1) × (pLen+1) 初始值 false // 建立 DP 表  \n→ dp[0][0] ← true // 空字串與空模式相符  \n\n→ // 初始化 dp[0][j]：空字串能否匹配前 j 個模式字元  \n→ Loop j from 2 to pLen step 2  \n  Decision: 如果 p[j-1] == '*'? // 前一個字符被 '*' 影響  \n   Yes → dp[0][j] ← dp[0][j-2] // 若前面能匹配，則此處也能匹配  \n   No  → No action // 不能匹配  \n\n→ // 主動態規劃填表  \n→ Loop i from 1 to sLen  \n  Loop j from 1 to pLen  \n   Decision: p[j-1] == s[i-1] 或 p[j-1] == '.'? // 直接字符或通配符 '.'  \n    Yes → dp[i][j] ← dp[i-1][j-1] // 前一位已匹配，則此位也匹配  \n    No  → Decision: p[j-1] == '*'? // '*' 可能產生多種情況  \n      Yes → Decision: p[j-2] == s[i-1] 或 p[j-2] == '.'? // '*' 前一個字符與當前字元是否匹配  \n        Yes → dp[i][j] ← dp[i][j-2] 或 dp[i-1][j] // 兩種可能：消除前一個字符或多消一個  \n        No  → dp[i][j] ← dp[i][j-2] // '*' 只允許 0 次  \n      No  → No action // 其餘情況不匹配  \n\n→ Result ← dp[sLen][pLen] // 最終答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        # dp[i][j] 代表 s[:i] 是否能匹配 p[:j]\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        # 初始化空字串與模式的匹配情形\n        for j in range(2, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        # 主 DP 填表\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    # '*' 先看成 0 次\n                    dp[i][j] = dp[i][j - 2]\n                    # 若前一個字符與 s[i-1] 匹配，則可看成 * 1+ 次\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n        return dp[m][n]\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入文字中提取 s 與 p 的值。\n    支援多種輸入格式，例如：\n        s = \"aa\", p = \"a\"\n        aa\n        a\n    \"\"\"\n    # 先嘗試尋找雙引號包住的字串\n    parts = re.findall(r'\"([^\"]*)\"', text)\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # 若沒有引號，直接按行分割\n    lines = [line.strip() for line in text.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    # 最後的備援：以逗號分隔\n    tokens = [t.strip() for t in text.split(',') if t.strip()]\n    if len(tokens) >= 2:\n        return tokens[0].split('=')[-1].strip(), tokens[1].split('=')[-1].strip()\n    # 若還不夠，回傳空字串\n    return \"\", \"\"\n\ndef main():\n    raw = sys.stdin.read()\n    s, p = parse_input(raw)\n    result = Solution().isMatch(s, p)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"a*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\", p = \".*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode518.json",
    "problem_index_in_file": 0,
    "title": "Coin Change II",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem: coin change count combinations. We output each step with explanation. We need to use virtual code arrows, Decision etc. Let's produce a typical DP approach.\n\nAlgorithm: Use DP array of length amount+1, dp[0]=1, iterate coins, for each coin, for j from coin to amount: dp[j] += dp[j-coin].\n\nWe need to produce steps. We'll start: Start, Step 1: 初始化 dp 数组. Step 2: 设 dp[0]=1. Step 3: 遍历每枚硬币. Inside: Step 3a: 对于每个 j 从 coin 到 amount. Step 3b: dp[j] += dp[j-coin]. End. Return dp[amount].\n\nAdd decisions: maybe check amount==0 early. And maybe check if coins empty.\n\nLet's write steps with arrows. Use indentation for nested steps. We'll use Decision: if amount==0? etc.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個長度為 amount+1 的整數陣列 dp，並將所有元素設為 0 // 用來存儲各金額的組合數  \n→ Step 2: 設定 dp[0] = 1 // 金額為 0 的組合只有一種（不選取任何硬幣）  \n→ Decision: 是否有硬幣可用? // 檢查 coins 是否為空  \n  Yes → Step 3: 遍歷每一枚硬幣 coin in coins // 逐個處理每種面額  \n   → Decision: coin 是否小於等於 amount? // 若硬幣面額大於目標金額則不需要處理  \n    Yes → Step 4: 針對當前硬幣，從 j = coin 到 amount 逐一更新 dp[j]  \n     → Step 5: dp[j] = dp[j] + dp[j - coin] // 加上使用此硬幣後剩餘金額的組合數  \n     → Step 6: 完成 j 的迴圈  \n    No  → Step 7: 跳過此硬幣 // 面額超過 amount 時不進行計算  \n  No → Step 8: 直接返回 0 // 無硬幣可用，無法組合任何金額  \n→ Step 9: 返回 dp[amount] // 最終金額的組合數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef coin_change(amount: int, coins: list[int]) -> int:\n    \"\"\"\n    計算使用無限個各面額硬幣組成目標金額的組合數。\n    采用動態規劃：dp[i] 表示組成金額 i 的方法數。\n    \"\"\"\n    # dp[0] = 1，代表不選任何硬幣\n    dp = [0] * (amount + 1)\n    dp[0] = 1\n\n    for coin in coins:\n        if coin > amount:\n            # 若硬幣面額大於目標金額，直接跳過\n            continue\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n\n    return dp[amount]\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行資料\n    data = sys.stdin.read().strip()\n    if not data:\n        # 沒有輸入，直接退出\n        sys.exit(0)\n\n    # 假設輸入格式為: amount, [coin1, coin2, ...]\n    # 先用逗號分割成兩部分\n    try:\n        amount_str, coins_str = data.split(',', 1)\n    except ValueError:\n        # 如果輸入格式不符，直接退出\n        sys.exit(0)\n\n    # 去除前後空白，轉成整數和 list\n    amount = int(amount_str.strip())\n    coins = ast.literal_eval(coins_str.strip())\n\n    # 計算結果並輸出\n    result = coin_change(amount, coins)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "5, [1,2,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "3, [2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "10, [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode434.json",
    "problem_index_in_file": 0,
    "title": "Number of Segments in a String",
    "description_snippet": "Given a string s, return the number of segments in the string.\n\nA segment is defined to be a contigu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting segments in a string. Must use arrow syntax, Start, End, Decision. Each line has code + // explanation.\n\nWe need to read string s. Iterate through characters, count segments. Approach: use flag insideSegment, count. Iterate over s characters: if char != ' ' and not insideSegment -> count++, insideSegment=true. If char == ' ' -> insideSegment=false. After loop return count. We must write virtual steps. Use Start, Decision, End. Each step with explanation. We'll use \"Step 1: Initialize count and insideSegment\" etc.\n\nWe must produce one line per virtual step. No actual code. So we produce steps like:\n\nStart // program begins\n→ Step 1: Input string s // get input\n→ Step 2: Initialize counter to 0 and insideSegment to False // set up\n→ Step 3: For each character ch in s // iterate over characters\n    → Decision: If ch is not space? // check if non-space\n        Yes → Decision: If insideSegment is False? // start new segment?\n            Yes → Step 4: Increment counter; set insideSegment to True // new segment found\n            No  → Step 4: Do nothing // already inside a segment\n        No  → Step 5: Set insideSegment to False // reset on space\n→ Step 6: Return counter // output result\nEnd // end program\n\nWe need to follow format exactly: each line has \"虛擬碼步驟 [space] // 解釋\". The arrows use \"→\" and indentation for nested. Use \"Decision:\" etc. For nested decisions we indent. Provide explanation for each line. Let's produce that. Use no actual code. Use simple statements like \"Input s\". The indentation is indicated by spaces or tabs. We'll follow sample style: each step preceded by arrow or decisions. Provide indentation for nested steps. The explanation can be concise.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者取得待分析的字串  \n→ Step 2: 初始化 counter 為 0，insideSegment 為 False // 用於統計段落與追蹤是否處於段落中  \n→ Step 3: 遍歷 s 的每一個字元 ch // 逐字檢查字串  \n  Decision: ch 是否為非空白字元? // 判斷是否為段落內部字元  \n   Yes → Decision: insideSegment 是否為 False? // 判斷是否剛開始一個新段落  \n    Yes → Step 4: counter += 1；insideSegment = True // 发现新段落，計數並標記進入段落  \n    No  → Step 4: 何不處理 // 已在段落內，忽略  \n   No  → Step 5: insideSegment = False // 遇到空白，結束當前段落  \n→ Step 6: 輸出 counter // 回傳段落總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef count_segments(s: str) -> int:\n    # Split by spaces and count non-empty segments\n    return len([seg for seg in s.split(' ') if seg])\n\ndef parse_input(input_str: str) -> str:\n    # Find the first and last quote characters (single or double)\n    for quote in ('\"', \"'\"):\n        first = input_str.find(quote)\n        last = input_str.rfind(quote)\n        if first != -1 and last != -1 and first != last:\n            return input_str[first+1:last]\n    # If no quotes, maybe the entire string is given\n    return input_str.strip()\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = count_segments(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello, my name is John\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"Hello\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode483.json",
    "problem_index_in_file": 0,
    "title": "Smallest Good Base",
    "description_snippet": "Given an integer n represented as a string, return the smallest good base of n.\n\nWe call k >= 2 a go...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps to solve the problem. This is classic Leetcode problem 748. Approach: For string n, consider its length L. For each possible number of digits m (>=2), we try to find base k such that n = (k^m -1)/(k-1). m ranges from floor(log2(n))+1 down to 2? Actually minimal base. We can try m from floor(log2(n))+1 down to 2. For each m, we binary search k between 2 and n^(1/(m-1)). Compute value via power sum. If matches, return k. If none found, return n-1 (since base n-1 gives \"11\"). Need big integer handling. We'll describe in pseudocode with big integers.\n\nLet's produce lines: Start, convert n string to BigInt, compute len, etc. We'll include Decision nodes. We'll keep it simple.\n\nLet's craft steps:\n\nStart // start\n→ Step 1: Convert string n to BigInt N // big integer\n→ Step 2: If N <= 3 then return N-1 // trivial cases\n→ Step 3: Compute maxLen = floor(log2(N)) + 1 // maximum possible digits\n→ Decision: For m from maxLen down to 2? Actually iterate decreasing length for minimal base. We can iterate from floor(log2(N)) +1 down to 2; for each m, find base.\nBetter: iterate m from maxLen down to 2:\n   → Decision: Compute low=2, high= N^(1/(m-1)) +1\n   → While low <= high: // binary search\n       → Step: mid = (low+high)/2\n       → Step: value = sum_{i=0}^{m-1} mid^i\n       → Decision: if value == N? then return mid\n       → else if value < N? low=mid+1\n       → else high=mid-1\n→ End // if loop finished, return N-1\n\nNeed pseudocode lines.\n\nLet's write each step line. Provide brief explanation. Use arrows for transitions. We'll produce with indentation maybe but keep simple. Use \"Decision:\" for decision blocks.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將輸入字串 n 轉成大整數 N // 方便進行大數運算  \n→ Step 2: 如果 N ≤ 3 則回傳 N - 1 // 1,2,3 分別對應基底 2, 2, 3  \n→ Step 3: 計算 maxLen = floor(log₂(N)) + 1 // N 可能的最大位數  \n→ Decision: 設 m ← maxLen  // 從最大的可能位數開始嘗試  \n    Yes → Step 4: 計算 low = 2, high = N^(1/(m-1)) + 1 // 基底 k 的搜尋範圍  \n    → Decision: while low ≤ high // 二分搜尋 k  \n        Yes → Step 5: mid = (low + high) / 2 // 取中間值作為候選基底  \n        → Step 6: value ← 0, power ← 1  \n        → Step 7: for i ← 0 to m-1  \n            → value ← value + power // 累加 mid^i 的結果  \n            → power ← power × mid // 更新 mid 的冪  \n        → Decision: 如果 value == N?  \n            Yes → Step 8: 回傳 mid // 找到最小的好基底  \n            No  → Decision: 如果 value < N?  \n                Yes → low ← mid + 1 // 需要更大的基底  \n                No  → high ← mid - 1 // 需要更小的基底  \n    → Decision: 是否已經遍歷完所有 m?  \n        Yes → m ← m - 1 // 嘗試更短的位數，因為更短的位數可能對應更大的基底  \n        No  → End // 進行下一個 m 的計算  \n→ Step 9: 若循環結束仍未找到，回傳 N - 1 // 基底 N-1 會得到 \"11\"  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def smallestGoodBase(self, n_str: str) -> str:\n        # Convert string to integer\n        n = int(n_str)\n        if n <= 3:\n            return str(n - 1)\n\n        # 最大可能的位數（即 m 的上限）\n        max_m = n.bit_length()\n\n        # 嘗試所有可能的位數，從大到小（因為 m 越小，k 越大）\n        for m in range(max_m, 1, -1):\n            left, right = 2, int(n ** (1.0 / (m - 1))) + 1\n            while left <= right:\n                k = (left + right) // 2\n                # 計算 1 + k + k^2 + ... + k^(m-1)\n                # 使用等比數列求和公式\n                s = (k ** m - 1) // (k - 1)\n                if s == n:\n                    return str(k)\n                elif s < n:\n                    left = k + 1\n                else:\n                    right = k - 1\n\n        # 若未找到，則基底為 n-1\n        return str(n - 1)\n\ndef main():\n    # 讀取整個輸入，去除空白，從中提取第一個數字\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n_str = nums[0]\n    solution = Solution()\n    result = solution.smallestGoodBase(n_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = \"13\"",
          "expected_output": "\"3\"",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = \"4681\"",
          "expected_output": "\"8\"",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 2,
          "input": "n = \"1000000000000000000\"",
          "expected_output": "\"999999999999999999\"",
          "success": true,
          "output": "999999999999999999"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode326.json",
    "problem_index_in_file": 0,
    "title": "Power of Three",
    "description_snippet": "Given an integer n, return true if it is a power of three. Otherwise, return false.\n\nAn integer n is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode in requested format. The requirement: start, steps, decision, etc. Provide line-by-line.\n\nTask: check if integer n is power of three. Approach: while n%3==0, divide. If final n==1 return true else false. Also need handle negative, zero, 1? n==1 true. So pseudocode. Provide explanations.\n\nLet's produce. Use \"Start\", \"End\". Use arrow \"→\". Include decisions. Provide comments after space. Also each line \"虛擬碼步驟\" maybe \"Step\". Use \"Decision:\" lines. Provide explanation comments after //.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收整數 n // 取得使用者輸入的數值  \n→ Decision: 如果 n 小於等於 0? // 檢查數值是否為正整數  \n  Yes → Step 2: 回傳 False // 非正整數不能是 3 的冪  \n  No  → Step 3: If n 等於 1? // 1 是 3^0，符合條件  \n    Yes → Step 4: 回傳 True // n 為 1，直接返回真  \n    No  → Step 5: While n 能被 3 整除? // 逐步除以 3  \n      Yes → Step 6: 把 n 設為 n / 3 // 將 n 除以 3  \n      No  → Decision: n 是否等於 1? // 迴圈結束後檢查是否為 1  \n       Yes → Step 7: 回傳 True // 代表 n 是 3 的冪  \n       No  → Step 8: 回傳 False // 不是 3 的冪  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfThree(self, n: int) -> bool:\n        \"\"\"Return True if n is a power of 3, False otherwise.\"\"\"\n        if n <= 0:\n            return False\n        while n % 3 == 0:\n            n //= 3\n        return n == 1\n\ndef main() -> None:\n    \"\"\"Read an integer from stdin and print whether it is a power of three.\"\"\"\n    data = sys.stdin.read()\n    # Extract the first integer from the input (handles formats like 'n = 27')\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        # No integer found; treat as invalid input\n        print(\"false\")\n        return\n    n = int(match.group())\n    result = Solution().isPowerOfThree(n)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 27",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = -1",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode179.json",
    "problem_index_in_file": 0,
    "title": "Largest Number",
    "description_snippet": "Given a list of non-negative integers nums, arrange them such that they form the largest number and ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm: largest number from array by arranging strings. Steps: convert to strings, sort with custom comparator comparing a+b vs b+a, join, handle leading zeros. So produce steps lines. Let's craft.\n\nFormat:\n\nStart // 程式開始執行\n→ Step 1: 將輸入的整數陣列 nums 轉成字串陣列 strNums // 將每個數字轉成字串\n→ Step 2: 定義比較器 compare(a, b) // 比較兩個字串以決定排序順序\n    → Decision: 如果 a+b 大於 b+a?\n        Yes → Return -1 // a 應排在前面\n        No → Return 1 // b 應排在前面\n→ Step 3: 用 compare 排序 strNums // 依自訂比較器排序\n→ Step 4: 將排序後的字串連接成結果字符串 result // 連接所有字串\n→ Step 5: 判斷 result 是否全為 '0'? // 處理全零情況\n    Yes → Return '0' // 只回傳一個零\n    No  → Return result // 正常返回\nEnd // 程式結束\n\nBut need to include \"Start\" and \"End\". Also each line must have \"虛擬碼步驟\" followed by comment. Use arrows and decisions. Ensure each line separate. Also indentation for decisions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將輸入的整數陣列 nums 轉成字串陣列 strNums // 先把每個數字轉成字串以便字串拼接比較  \n→ Step 2: 定義比較器 compare(a, b) // 自訂排序規則，決定兩個字串的相對順序  \n    → Decision: 如果 a+b 大於 b+a? // 判斷哪種拼接順序能產生更大的數字  \n        Yes → Return -1 // 若 a+b 更大，則 a 應排在前面  \n        No  → Return 1 // 否則 b 應排在前面  \n→ Step 3: 用 compare 排序 strNums // 將字串陣列依照自訂規則從大到小排序  \n→ Step 4: 將排序後的字串連接成結果字符串 result // 把所有字串依序連接得到最終數字  \n→ Step 5: 判斷 result 是否全為 '0'? // 處理特殊情況：如 [0,0] 需返回單一 '0'  \n    Yes → Return '0' // 所有元素為零時，只回傳一個零  \n    No  → Return result // 其餘情況直接回傳連接結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom functools import cmp_to_key\n\nclass Solution:\n    def largestNumber(self, nums):\n        # 把每個數字轉成字串\n        nums_str = list(map(str, nums))\n        # 自訂比較器：a+b 大於 b+a 則 a 排在前面\n        def compare(x, y):\n            if x + y > y + x:\n                return -1\n            elif x + y < y + x:\n                return 1\n            else:\n                return 0\n        # 依照比較器排序\n        nums_str.sort(key=cmp_to_key(compare))\n        # 連接所有字串得到結果\n        result = ''.join(nums_str)\n        # 若全為 0，只回傳單一 '0'\n        return '0' if result[0] == '0' else result\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取輸入\n    data = sys.stdin.read().strip()\n    # 從輸入中擷取列表內容，例如 \"nums = [10,2]\"\n    nums = []\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        try:\n            nums = eval(match.group(0))\n        except Exception:\n            nums = []\n    # 產生最長數字\n    sol = Solution()\n    res = sol.largestNumber(nums)\n    # 將結果包在雙引號後輸出\n    print(f'\"{res}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,2]",
          "expected_output": "\"210\"",
          "success": true,
          "output": "\"210\""
        },
        {
          "example_index": 1,
          "input": "nums = [3,30,34,5,9]",
          "expected_output": "\"9534330\"",
          "success": true,
          "output": "\"9534330\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode232.json",
    "problem_index_in_file": 0,
    "title": "Implement Queue using Stacks",
    "description_snippet": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should supp...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Steps: Start, define class MyQueue with two stacks: stack_in, stack_out. Push: push to stack_in. Peek/pop: if stack_out empty, transfer all from stack_in to stack_out. Then pop/peek from stack_out. Empty: check both stacks empty. Also Start and End. We need to follow the format: each line like \"→ Step: ... // explanation\". Use Decision: for empty checks. Use Yes →, No →. We need to be careful: each line must have virtual code step and explanation. Use arrow syntax. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define MyQueue class // 建立 MyQueue 類別  \n→ Step: 初始化兩個 stack: stack_in, stack_out // 用來模擬 FIFO  \n→ Step: push(x) → stack_in.push(x) // 把新元素放進入站  \n→ Step: pop() → Decision: 如果 stack_out.isEmpty()? // 判斷輸出站是否為空  \n  Yes → Step: TransferAll(stack_in → stack_out) // 先把進站全部倒轉到輸出站  \n  No  → No action // 若輸出站已不為空則不轉移  \n→ Step: pop() → Return stack_out.pop() // 從輸出站頂端彈出並返回  \n→ Step: peek() → Decision: 如果 stack_out.isEmpty()? // 判斷輸出站是否為空  \n  Yes → Step: TransferAll(stack_in → stack_out) // 需要先倒轉進站  \n  No  → No action  \n→ Step: peek() → Return stack_out.top() // 回傳輸出站頂端元素  \n→ Step: empty() → Decision: 如果 stack_in.isEmpty() AND stack_out.isEmpty()? // 檢查兩個 stack 是否皆空  \n  Yes → Return true // 全部空  \n  No  → Return false // 有元素  \n→ Step: TransferAll(src → dest) → While src is not empty  \n  → dest.push(src.pop()) // 把元素一個一個移到目標 stack  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        self.peek()\n        return self.stack_out.pop()\n\n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self):\n        return not self.stack_in and not self.stack_out\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 第一行可能是「Input」，若是則移除\n    if data[0].strip() == \"Input\":\n        data = data[1:]\n    # 解析指令與參數\n    commands = ast.literal_eval(data[0].strip())\n    args_list = ast.literal_eval(data[1].strip())\n    result = []\n\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MyQueue\":\n            obj = MyQueue()\n            result.append(None)\n        elif cmd == \"push\":\n            obj.push(args[0])\n            result.append(None)\n        elif cmd == \"pop\":\n            res = obj.pop()\n            result.append(res)\n        elif cmd == \"peek\":\n            res = obj.peek()\n            result.append(res)\n        elif cmd == \"empty\":\n            res = obj.empty()\n            result.append(res)\n\n    # 轉換成要求的輸出格式（null/true/false）\n    def fmt(val):\n        if val is None:\n            return \"null\"\n        if val is True:\n            return \"true\"\n        if val is False:\n            return \"false\"\n        return str(val)\n\n    output_str = \"[\" + \", \".join(fmt(v) for v in result) + \"]\"\n    print(output_str)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "success": true,
          "output": "[null, null, null, 1, 1, false]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode718.json",
    "problem_index_in_file": 0,
    "title": "Maximum Length of Repeated Subarray",
    "description_snippet": "Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in bo...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for finding maximum length of common subarray between two integer arrays. We should output in specified format: each line \"虛擬碼步驟 // 解釋\". Use arrow syntax. Should not output actual code. Just conceptual steps. So produce something like:\n\nStart\n→ Step 1: Define DP table of size (len1+1) x (len2+1) // 2D DP\n→ Step 2: Initialize result to 0\n→ Step 3: Loop i from 1 to len1\n→   Loop j from 1 to len2\n→     Decision: if nums1[i-1] == nums2[j-1]?\n→       Yes → Set dp[i][j] = dp[i-1][j-1] + 1 // extend match\n→       No  → Set dp[i][j] = 0 // reset\n→     Decision: if dp[i][j] > result?\n→       Yes → Update result\n→ End // return result\n\nBut need to produce with arrow arrows and decision labels. Use the given syntax: Start, End, Decision:, arrow.\n\nLet's produce line-by-line:\n\nStart // 程式開始執行\n→ Step 1: 計算 nums1 與 nums2 的長度 // 取得兩個陣列的長度\n→ Step 2: 建立 dp 二維表格，尺寸為 (len1+1) × (len2+1)，並將所有元素初始化為 0 // 用於記錄子陣列長度\n→ Step 3: 設定 result 為 0 // 儲存目前為止最大的共同子陣列長度\n→ Decision: 迴圈 i 從 1 到 len1? // 遍歷 nums1\n    Yes → Step 4: 迴圈 j 從 1 到 len2? // 遍歷 nums2\n        Yes → Decision: nums1[i-1] == nums2[j-1]? // 檢查對應位置元素是否相等\n            Yes → Step 5: dp[i][j] = dp[i-1][j-1] + 1 // 延長匹配子陣列\n            No  → Step 5: dp[i][j] = 0 // 重置，因不匹配\n        Yes → Decision: dp[i][j] > result? // 檢查是否更新最大值\n            Yes → Step 6: result = dp[i][j] // 更新最大長度\n            No  → Step 6: // 保持現有 result\n→ End // 回傳 result 為最大相同子陣列長度\n\nBut each step must be a separate line. Use \"→\" arrow for substeps? The format expects each line to start with something like \"→ Step 1:\" etc. Use indentation? The example shows indentation for substeps but we can indent. Provide arrow and Decision lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 nums1 與 nums2 的長度 len1, len2 // 先取得兩個陣列的長度  \n→ Step 2: 建立 dp 二維表格，尺寸為 (len1+1) × (len2+1)，並將所有元素初始化為 0 // 用來記錄匹配子陣列的長度  \n→ Step 3: 設定 result 為 0 // 儲存目前為止最大的共同子陣列長度  \n→ Decision: 迴圈 i 從 1 到 len1? // 遍歷 nums1  \n    Yes → Step 4: 迴圈 j 從 1 到 len2? // 遍歷 nums2  \n        Yes → Decision: nums1[i-1] == nums2[j-1]? // 檢查對應位置元素是否相等  \n            Yes → Step 5: dp[i][j] = dp[i-1][j-1] + 1 // 延長匹配子陣列  \n            No  → Step 5: dp[i][j] = 0 // 重置，因不匹配  \n        Yes → Decision: dp[i][j] > result? // 檢查是否更新最大值  \n            Yes → Step 6: result = dp[i][j] // 更新最大長度  \n            No  → Step 6: // 保持現有 result  \n→ End // 回傳 result 為最大相同子陣列長度",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findLength(self, nums1, nums2):\n        m, n = len(nums1), len(nums2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        max_len = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if nums1[i - 1] == nums2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    if dp[i][j] > max_len:\n                        max_len = dp[i][j]\n        return max_len\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 尋找所有方括號中的內容，預期為兩個陣列字串\n    arr_strs = re.findall(r'\\[.*?\\]', data)\n    if len(arr_strs) >= 2:\n        nums1 = ast.literal_eval(arr_strs[0])\n        nums2 = ast.literal_eval(arr_strs[1])\n    else:\n        nums1 = nums2 = []\n\n    result = Solution().findLength(nums1, nums2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode493.json",
    "problem_index_in_file": 0,
    "title": "Reverse Pairs",
    "description_snippet": "Given an integer array nums, return the number of reverse pairs in the array.\n\nA reverse pair is a p...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines describing algorithm to count reverse pairs. Common solution: divide and conquer (merge sort). Steps: merge sort with counting cross pairs. Outline: function mergeSortAndCount(nums, left, right) returns count. If left>=right return 0. mid, count left, count right, count cross, merge. Cross counting: for each i in left part, find j in right part where nums[i] > 2*nums[j]. Use two-pointer.\n\nWe need line by line: Start, Step: read array, call function, output count, End. Use Decision arrows. Provide brief explanation.\n\nLet's produce lines.\n\nNeed to maintain structure: Start, Step 1: input array, Step 2: call mergeSortAndCount, etc.\n\nInside mergeSortAndCount, we need steps recursively: Decision if left >= right, base case. else: compute mid, recursively count left, count right, count cross, merge, return sum.\n\nWe'll include pseudo-code lines for recursion: Step: Define function mergeSortAndCount(nums, left, right) // etc.\n\nWithin that function we need to count cross pairs. We'll use pointer j initial right side index. For each i in left part, while j<=right and nums[i] > 2*nums[j], increment j; crossCount += j - mid -1? Wait algorithm: For each i, while j<=right and nums[i] > 2*nums[j], j++; crossCount += (j - mid - 1). Actually typical: j=mid+1; for i=left..mid: while j<=right and nums[i] > 2*nums[j] j++; count += j - (mid+1). Then merge.\n\nWill provide explanation.\n\nWe need to output line by line with arrow '→' before each step.\n\nLet's create lines:\n\nStart\n→ Step 1: Read integer array nums // 取得輸入陣列\n→ Step 2: Call function mergeSortAndCount(nums, 0, nums.length - 1) and store result in result // 進行遞歸排序與計數\n→ Step 3: Output result // 顯示反向對數\nEnd\n\nNow define function:\n\n→ Function mergeSortAndCount(nums, left, right) // 定義遞歸函式\n    → Decision: 如果 left >= right? // 判斷是否單一元素\n        Yes → Return 0 // 基本情況：沒有反向對\n        No  → Step 4: 計算 mid = (left + right) / 2 // 分割陣列中點\n        → Step 5: leftCount = mergeSortAndCount(nums, left, mid) // 右半部分\n        → Step 6: rightCount = mergeSortAndCount(nums, mid + 1, right) // 左半部分\n        → Step 7: crossCount = 0 // 初始化跨段對數\n        → Step 8: j = mid + 1 // 初始化右側指標\n        → Decision: 如果 i <= mid? // 遍歷左半段\n            Yes → Step 9: while j <= right and nums[i] > 2 * nums[j] do j++ // 找到第一個不符合條件\n            → Step 10: crossCount += j - (mid + 1) // 累加符合條件的右側個數\n            → Go back to Decision with next i\n        → Step 11: merge the two sorted halves into temp array // 合併兩個已排序子陣列\n        → Step 12: copy temp back to nums[left..right] // 更新原始陣列\n        → Return leftCount + rightCount + crossCount // 傳回總對數\nEnd\n\nBut we need to keep arrow formatting properly. The inner steps need to be indented? Not necessary but we can maintain arrow lines.\n\nAlso include explanations after //.\n\nLet's produce final output.\n\nNote: Must use Start, End for overall program, not inside function? But we can still use Start for function? Could be just Start of algorithm inside function. But easier: use \"Start\" at beginning, \"End\" at end of program.\n\nAlso use arrows for nested decisions. For function steps we can label as \"→ Function mergeSortAndCount(nums, left, right) // ...\"\n\nWe need to maintain that each line contains code + space + // explanation.\n\nLet's produce lines.\n\nAlso \"Yes →\" and \"No →\" inside decisions.\n\nLet's write final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read integer array nums // 取得輸入陣列  \n→ Step 2: result ← mergeSortAndCount(nums, 0, nums.length - 1) // 進行遞歸排序並計算反向對  \n→ Step 3: Output result // 顯示總反向對數  \nEnd // 程式執行結束  \n\nFunction mergeSortAndCount(nums, left, right) // 定義遞歸計數與排序函式  \n    → Decision: 如果 left ≥ right? // 判斷是否已到最小子陣列  \n        Yes → Return 0 // 基本情況：單一元素無反向對  \n        No  → Step 4: mid ← (left + right) // 2 // 計算中點  \n        → Step 5: leftCount ← mergeSortAndCount(nums, left, mid) // 右半段遞歸計數  \n        → Step 6: rightCount ← mergeSortAndCount(nums, mid + 1, right) // 左半段遞歸計數  \n        → Step 7: crossCount ← 0 // 初始化跨段反向對數  \n        → Step 8: j ← mid + 1 // 初始化右側指標  \n        → Decision: 對於 i ← left 到 mid? // 遍歷左半段  \n            Yes → Step 9: while j ≤ right and nums[i] > 2 * nums[j] do j ← j + 1 // 找到第一個不符合條件的 j  \n            → Step 10: crossCount ← crossCount + (j - (mid + 1)) // 累加符合條件的右側個數  \n            → Go back to Decision with next i  \n        → Step 11: temp ← [] // 建立暫存陣列  \n        → i ← left, j ← mid + 1, k ← 0 // 初始化三個指標  \n        → Decision: 只要 i ≤ mid 或 j ≤ right? // 合併兩個已排序子陣列  \n            Yes → if i ≤ mid and (j > right or nums[i] ≤ nums[j]) then temp[k] ← nums[i]; i ← i + 1  \n            else temp[k] ← nums[j]; j ← j + 1; k ← k + 1  \n            → Go back to Decision  \n        → Step 12: for idx ← 0 to temp.length - 1 do nums[left + idx] ← temp[idx] // 把合併後的陣列寫回原陣列  \n        → Return leftCount + rightCount + crossCount // 傳回總反向對數",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def reversePairs(self, nums):\n        def merge_sort(start, end):\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            count = merge_sort(start, mid) + merge_sort(mid + 1, end)\n\n            # count cross pairs\n            j = mid + 1\n            for i in range(start, mid + 1):\n                while j <= end and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - (mid + 1)\n\n            # merge two sorted halves\n            temp = []\n            left, right = start, mid + 1\n            while left <= mid and right <= end:\n                if nums[left] <= nums[right]:\n                    temp.append(nums[left])\n                    left += 1\n                else:\n                    temp.append(nums[right])\n                    right += 1\n            while left <= mid:\n                temp.append(nums[left])\n                left += 1\n            while right <= end:\n                temp.append(nums[right])\n                right += 1\n            nums[start:end + 1] = temp\n            return count\n        return merge_sort(0, len(nums) - 1)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Try to extract a list from the input\n    nums = []\n    match = re.search(r'\\[(.*?)\\]', data, re.S)\n    if match:\n        try:\n            nums = ast.literal_eval('[' + match.group(1) + ']')\n        except Exception:\n            pass\n\n    # Fallback: assume space-separated integers\n    if not nums:\n        try:\n            nums = list(map(int, data.split()))\n        except Exception:\n            nums = []\n\n    result = Solution().reversePairs(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,4,3,5,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode443.json",
    "problem_index_in_file": 0,
    "title": "String Compression",
    "description_snippet": "Given an array of characters chars, compress it using the following algorithm:\n\nBegin with an empty ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with each line: virtual code step + // explanation. Use arrows, Start, End, Decision. We should produce algorithm in natural language pseudocode style. Not actual code. So produce steps: Start, pointer i for scanning, pointer writePos for writing result. While i < n: count run length. If count==1: write char to chars[writePos], writePos++. Else: write char, then write digits of count to chars[writePos] each as char. Use constant space. At end, return writePos.\n\nNeed to use decisions. Use \"Decision:\" lines.\n\nLet's produce virtual code lines.\n\nImportant: Each line must have \"虛擬碼步驟\" text, then a space, then // explanation. For example: Start // 程式開始執行\n\nUse arrow for steps: → Step 1: etc.\n\nWe can include nested decisions with indentation? Example in sample uses indentation lines. We should mimic.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: n ← length(chars) // 取得陣列長度\n\n→ Step 2: writePos ← 0 // 目標寫入位置\n\n→ Step 3: i ← 0 // 目前掃描指標\n\n→ Decision: i < n? // 檢查是否還有未處理的字符\n\n    Yes → Step 4: currentChar ← chars[i] // 取得當前字符\n\n    → Step 5: count ← 1 // 初始化連續數量\n\n    → Step 6: j ← i + 1 // 下一個位置\n\n    → Decision: j < n AND chars[j] == currentChar? // 是否仍屬於同一組\n\n        Yes → Step 7: count ← count + 1 // 同一字符連續數量加一\n\n        → Step 6: j ← j + 1 // 移至下一個位置\n\n        → Decision: j < n AND chars[j] == currentChar? // 迴圈判斷\n\n        ... (We need to show loop but can summarise as \"Loop until j out of bounds or char diff\" but not necessary to break into many lines.)\n\nBetter: use a while loop representation: \"Decision: j < n AND chars[j] == currentChar?\" then \"Yes → count ← count + 1; j ← j + 1; 再次判斷\".\n\nBut we can condense: \"→ Step 8: count ← count + 1 // 連續字符數量加一\" repeated.\n\nBut we must maintain structure. Maybe simpler: Use \"While\" style? Not specified but can use Decision repeated.\n\nOk we can do:\n\n→ Step 8: while j < n AND chars[j] == currentChar do\n\n    → count ← count + 1\n\n    → j ← j + 1\n\nBut we can't use actual code. So we can express as a decision and recursion.\n\nSimpler: Use \"Decision: j < n AND chars[j] == currentChar?\" Yes → count ← count + 1; j ← j + 1; 轉回此決策.\n\nOk.\n\nAfter counting, we write:\n\n→ Step 9: chars[writePos] ← currentChar; writePos ← writePos + 1 // 寫入字符\n\n→ Decision: count == 1? // 是否只出現一次\n\n    No → Step 10: numStr ← toString(count) // 轉成字串\n\n    → Step 11: for each digit d in numStr do\n\n        → chars[writePos] ← d; writePos ← writePos + 1 // 寫入數字字元\n\n    End of loop\n\n→ Step 12: i ← j // 移動掃描指標到下一組的起始位置\n\n→ Decision: i < n? // 是否還有字符\n\n    Yes → 轉回 Step 4\n\nEnd of main loop\n\n→ Step 13: return writePos // 回傳壓縮後長度\n\nEnd // 程式結束\n\nWe need to output line by line exactly. Also ensure each line includes virtual code then explanation.\n\nLet's craft lines.\n\nWe need to include \"Start\" line, \"End\" line.\n\nLet's produce final answer accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(chars) // 取得陣列長度  \n→ Step 2: writePos ← 0 // 目標寫入位置  \n→ Step 3: i ← 0 // 目前掃描指標  \n→ Decision: i < n? // 檢查是否還有未處理的字符  \n Yes → Step 4: currentChar ← chars[i] // 取得當前字符  \n → Step 5: count ← 1 // 初始化連續數量  \n → Step 6: j ← i + 1 // 指向下一個位置  \n → Decision: j < n AND chars[j] == currentChar? // 是否仍屬於同一組  \n  Yes → Step 7: count ← count + 1 // 同一字符連續數量加一  \n  → Step 6: j ← j + 1 // 移至下一個位置  \n  → Decision: j < n AND chars[j] == currentChar? // 迴圈判斷  \n   Yes → Step 7 (重複) // 重複上述累加與移動  \n   No → Step 8: // 結束連續字符計算  \n    → Step 9: chars[writePos] ← currentChar; writePos ← writePos + 1 // 寫入字符  \n    → Decision: count == 1? // 只出現一次？  \n     No → Step 10: numStr ← toString(count) // 轉成字串  \n      → Step 11: for each digit d in numStr do  \n       → chars[writePos] ← d; writePos ← writePos + 1 // 寫入數字字元  \n       End of loop  \n      End if  \n    → Step 12: i ← j // 移動掃描指標到下一組的起始位置  \n    → Decision: i < n? // 是否還有字符？  \n     Yes → 轉回 Step 4  \n     No → // 退出主循環  \nEnd // 程式執行結束  \n→ Step 13: return writePos // 回傳壓縮後的長度",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def compress(self, chars):\n        write = 0\n        left = 0\n        n = len(chars)\n\n        while left < n:\n            right = left\n            while right < n and chars[right] == chars[left]:\n                right += 1\n            # write the character\n            chars[write] = chars[left]\n            write += 1\n            # write the count if > 1\n            count = right - left\n            if count > 1:\n                for c in str(count):\n                    chars[write] = c\n                    write += 1\n            left = right\n\n        return write\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract the list from the input string, e.g. 'chars = [\"a\",\"b\"]'\n    match = re.search(r'chars\\s*=\\s*(\\[.*\\])', data, re.S)\n    if not match:\n        # If the input is just a plain list representation\n        try:\n            chars = eval(data)\n        except Exception:\n            sys.exit()\n    else:\n        try:\n            chars = eval(match.group(1))\n        except Exception:\n            sys.exit()\n    # Ensure chars is a list of single-character strings\n    if not isinstance(chars, list) or any(not isinstance(c, str) or len(c) != 1 for c in chars):\n        sys.exit()\n    sol = Solution()\n    new_len = sol.compress(chars)\n    print(new_len)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "chars = [\"a\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode674.json",
    "problem_index_in_file": 0,
    "title": "Longest Continuous Increasing Subsequence",
    "description_snippet": "Given an unsorted array of integers nums, return the length of the longest continuous increasing sub...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code with line-by-line explanation, as per output format. The user request: \"使用者需求: Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing. A continuous increasing subsequence is defined by two indices l and r (l < r) such that it is [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] and for each l <= i < r, nums[i] < nums[i + 1].\" So we need to generate pseudo-code.\n\nWe need to use structure: Start, End, Decision:, arrow ->, Yes →, No →. Each line with explanation comment.\n\nWe must not output actual code, just pseudo-code steps. Format: \"虛擬碼步驟 // 解釋\".\n\nWe need to show algorithm: iterate through array, maintain current length, max length. Steps: Start, if array empty return 0. Initialize currentLen=1, maxLen=1. For i from 1 to n-1: Decision: if nums[i] > nums[i-1]? Yes: currentLen++ else: currentLen=1. After decision, update maxLen = max(maxLen,currentLen). End. Return maxLen.\n\nWe must include arrow syntax. Example:\n\nStart // 程式開始執行\n→ Step 1: 如果 nums 為空? // 檢查陣列是否為空\n   Yes → Step 2: 回傳 0 // 空陣列長度為 0\n   No  → Step 3: 初始化 currentLen = 1, maxLen = 1 // 初始子序列長度\n\nBut need to handle loops.\n\nPseudo-code: Use Decision: for each index i from 1 to n-1. Use a Decision: if nums[i] > nums[i-1]? etc.\n\nWe must maintain loop structure: Start → Step: For i = 1 to n-1: ... End loop.\n\nWe must use arrow syntax for each step.\n\nLet's produce pseudo-code lines:\n\nStart // 程式開始執行\n→ Decision: nums 為空? // 檢查陣列是否為空\n    Yes → Step: 回傳 0 // 空陣列長度為 0\n    No  → Step: 初始化 currentLen = 1, maxLen = 1 // 先設定初始長度\n→ Step: 循環 i 從 1 到 nums.length - 1 // 逐個檢查元素\n    → Decision: nums[i] > nums[i-1]? // 判斷是否連續遞增\n        Yes → Step: currentLen ← currentLen + 1 // 連續長度加 1\n        No  → Step: currentLen ← 1 // 重置長度為 1\n    → Step: maxLen ← max(maxLen, currentLen) // 更新最大長度\n→ Step: 回傳 maxLen // 回傳結果\nEnd // 程式執行結束\n\nBut need each line to be separate. Need to follow format: \"虛擬碼步驟 // 解釋\". Use arrows etc. Should we prefix each step with \"→\"? Yes, but if we use nested decisions we need indentation and arrows accordingly. The example shows indentation and arrows.\n\nThus produce:\n\nStart // 程式開始執行\n→ Decision: nums 為空? // 檢查陣列是否為空\n    Yes → Step: 回傳 0 // 空陣列長度為 0\n    No  → Step: 初始化 currentLen = 1, maxLen = 1 // 設定初始長度\n→ Step: 循環 i 從 1 到 nums.length - 1 // 逐個檢查元素\n    → Decision: nums[i] > nums[i-1]? // 判斷是否連續遞增\n        Yes → Step: currentLen ← currentLen + 1 // 連續長度加 1\n        No  → Step: currentLen ← 1 // 重置長度為 1\n    → Step: maxLen ← max(maxLen, currentLen) // 更新最大長度\n→ Step: 回傳 maxLen // 回傳結果\nEnd // 程式執行結束\n\nBut need to ensure each line has a single arrow or \"Step:\" etc. The Decision blocks need nested steps. Use indent and arrow.\n\nThe example had \"Yes → Step\" lines etc.\n\nLet's format accordingly:\n\nStart // 程式開始執行\n→ Decision: nums 為空? // 檢查陣列是否為空\n    Yes → Step: 回傳 0 // 空陣列長度為 0\n    No  → Step: 初始化 currentLen = 1, maxLen = 1 // 設定初始長度\n→ Step: 循環 i 從 1 到 nums.length - 1 // 逐個檢查元素\n    → Decision: nums[i] > nums[i-1]? // 判斷是否連續遞增\n        Yes → Step: currentLen ← currentLen + 1 // 連續長度加 1\n        No  → Step: currentLen ← 1 // 重置長度為 1\n    → Step: maxLen ← max(maxLen, currentLen) // 更新最大長度\n→ Step: 回傳 maxLen // 回傳結果\nEnd // 程式執行結束\n\nBut each line should contain \"虛擬碼步驟\" plus comment. For steps within decision, we need separate lines each with arrow arrow.\n\nThus the output is exactly that. Ensure no actual code, only pseudo-code with arrows. Use Chinese. We'll deliver.\n\nCheck formatting: Each line ends with comment after \"//\". There's arrow symbol before each step line. For Decision lines, we need \"Decision:\" prefix. For Yes and No, use \"Yes → Step:\" etc.\n\nCheck example: They had \"→ Decision: 如果數字大於 0? // 檢查數值是否為正\" and indentation for nested. So mimic.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: nums 為空? // 檢查陣列是否為空\n    Yes → Step: 回傳 0 // 空陣列長度為 0\n    No  → Step: 初始化 currentLen = 1, maxLen = 1 // 設定初始長度\n→ Step: 循環 i 從 1 到 nums.length - 1 // 逐個檢查元素\n    → Decision: nums[i] > nums[i-1]? // 判斷是否連續遞增\n        Yes → Step: currentLen ← currentLen + 1 // 連續長度加 1\n        No  → Step: currentLen ← 1 // 重置長度為 1\n    → Step: maxLen ← max(maxLen, currentLen) // 更新最大長度\n→ Step: 回傳 maxLen // 回傳結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef findLengthOfLCIS(nums):\n    \"\"\"Return the length of the longest continuous increasing subsequence.\"\"\"\n    if not nums:\n        return 0\n    max_len = cur_len = 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            cur_len += 1\n            if cur_len > max_len:\n                max_len = cur_len\n        else:\n            cur_len = 1\n    return max_len\n\ndef main():\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        nums = []\n    else:\n        # Extract all integers (handles optional negative signs)\n        nums = list(map(int, re.findall(r'-?\\d+', data)))\n    result = findLengthOfLCIS(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,4,7]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode541.json",
    "problem_index_in_file": 0,
    "title": "Reverse String II",
    "description_snippet": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode in the specified format. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrows. Use 逐行. So produce step-by-step for reversing first k of every 2k. Let's design algorithm:\n\nStart\n→ Step 1: Initialize i = 0 // pointer to current position\n→ Decision: While i < length of s? // loop until processed all chars\n    Yes →\n        → Step 2: Determine end = min(i + k, length) // end of segment to reverse\n        → Step 3: Reverse substring s[i:end] // reverse first k or remaining\n        → Step 4: Append reversed segment to result\n        → Step 5: i = i + 2k // skip next k characters unchanged\n    No →\nEnd\n\nBut need to handle case when fewer than k left: we reverse all remaining. When less than 2k but >= k: reverse first k, leave rest. So algorithm above correct: Reverse up to k. Then append unchanged next k characters if any.\n\nLet's produce pseudo code accordingly. Each step includes comment. Use Decision nodes.\n\nWe need arrow representation: \"→\" before steps, \"Decision:\" lines. Use indent for sub-branches. Provide explanation after //. Use Chinese. Ensure format exactly as requested. Let's craft.\n\nAlso need to include result string building. Steps: result = empty string. While i < len. etc.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: result = \"\" // 用於存放最終結果\n→ Step 2: i = 0 // 索引從 0 開始\n→ Decision: i < len(s)? // 是否還有未處理的字元\n    Yes →\n        → Step 3: end = min(i + k, len(s)) // 需要反轉區段的結束位置\n        → Step 4: segment = s[i:end] // 從 i 到 end 的子字串\n        → Step 5: reversedSegment = reverse(segment) // 反轉這段\n        → Step 6: result = result + reversedSegment // 加入反轉後的字串\n        → Step 7: i = i + k // 移動到下一個 2k 區段的起點\n        → Decision: i + k <= len(s)? // 是否還有完整的 k 字元可直接複製\n            Yes →\n                → Step 8: unchanged = s[i : i + k] // 取得接下來 k 個字元\n                → Step 9: result = result + unchanged // 加入未改變的字串\n                → Step 10: i = i + k // 跳過這 k 個字元\n            No  →\n                → Step 11: remaining = s[i : len(s)] // 剩餘字元\n                → Step 12: result = result + remaining // 加入剩餘字元\n                → Step 13: i = len(s) // 結束迴圈\n        End\n    No →\nEnd // 程式執行結束\n\nBut need to consider indentation maybe. Use arrow lines for sub steps. Ensure each line has code plus comment. Use \"Decision:\" lines with Yes → / No → indentation. Provide correct indentation. Provide final End.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result = \"\" // 用於儲存最終字串  \n→ Step 2: i = 0 // 設定起始索引  \n\n→ Decision: i < len(s) ? // 還有未處理的字元嗎？  \n    Yes →  \n        → Step 3: end = min(i + k, len(s)) // 需要反轉的區段結束位置  \n        → Step 4: segment = s[i:end] // 取出從 i 到 end 的子字串  \n        → Step 5: reversedSegment = reverse(segment) // 反轉這段子字串  \n        → Step 6: result = result + reversedSegment // 加入已反轉的字串  \n        → Step 7: i = i + k // 移動到下一個 2k 區段的起點  \n\n        → Decision: i + k <= len(s) ? // 是否還有完整的 k 個字元可直接複製？  \n            Yes →  \n                → Step 8: unchanged = s[i : i + k] // 取得接下來 k 個字元  \n                → Step 9: result = result + unchanged // 加入未改變的字串  \n                → Step 10: i = i + k // 跳過這 k 個字元  \n            No →  \n                → Step 11: remaining = s[i : len(s)] // 取得剩餘字元  \n                → Step 12: result = result + remaining // 加入剩餘字元  \n                → Step 13: i = len(s) // 結束迴圈  \n        End  \n    No →  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    \"\"\"\n    將字串 s 每 2k 個字元為一組，反轉前 k 個字元。\n    \"\"\"\n    def reverseStr(self, s: str, k: int) -> str:\n        chars = list(s)                     # 轉成可改動的 list\n        for i in range(0, len(chars), 2 * k):  # 每隔 2k 個字元處理一次\n            end = min(i + k, len(chars))       # 只要到 k 個或剩下的全部\n            chars[i:end] = reversed(chars[i:end])  # 反轉該區段\n        return \"\".join(chars)\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取字串和 k，呼叫解法後將結果輸出。\n    輸入格式示例： \"abcdefg\", 2\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 以第一個逗號分隔字串與 k\n    parts = data.split(',', 1)\n    if len(parts) != 2:\n        # 若格式不符合，直接返回\n        return\n\n    s_part, k_part = parts[0].strip(), parts[1].strip()\n\n    # 移除字串外部的單引號或雙引號\n    if (s_part.startswith('\"') and s_part.endswith('\"')) or \\\n       (s_part.startswith(\"'\") and s_part.endswith(\"'\")):\n        s = s_part[1:-1]\n    else:\n        s = s_part\n\n    k = int(k_part)\n\n    sol = Solution()\n    result = sol.reverseStr(s, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abcdefg\", 2",
          "expected_output": "\"bacdfeg\"",
          "success": true,
          "output": "bacdfeg"
        },
        {
          "example_index": 1,
          "input": "\"abcd\", 2",
          "expected_output": "\"bacd\"",
          "success": true,
          "output": "bacd"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode188.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock IV",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code steps for solving the problem of max profit with at most k transactions. We need to output step by step pseudocode with comments. Use Start, End, Decision, Yes →, No →. We cannot output actual code, just virtual code. Each line has \"虛擬碼步驟 [space] // 解釋\". So we need to design an algorithm: DP with k transactions. Pseudocode steps: Initialize DP arrays, iterate days, iterate transactions, update profit. Use typical solution: dp[transaction][day] max profit up to that day with at most transaction buys. Use localMax. Steps: Start, initialize 2D array dp size (k+1) x n, all zeros. For t from 1 to k: set localMax = -prices[0]. For i from 1 to n-1: update dp[t][i] = max(dp[t][i-1], prices[i] + localMax). Update localMax = max(localMax, dp[t-1][i] - prices[i]). At end answer dp[k][n-1]. Also handle k >= n/2 case: unlimited transactions. Provide steps accordingly. We'll produce pseudocode lines accordingly.\n\nWe need to keep each line succinct. Each line with arrow. Provide explanation comments.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: prices[], k // 取得股票價格陣列與最大交易次數  \n→ If k >= length(prices)/2: // 若交易次數足以執行所有可能的買賣  \n  Yes → Step 1: maxProfit = 0 // 設定最大利潤為 0  \n  → Decision: For i from 1 to n-1? // 遍歷每個交易日  \n   Yes → Step 2: If prices[i] > prices[i-1]? // 檢查是否可即時賣出  \n    Yes → Step 3: maxProfit += prices[i] - prices[i-1] // 加上即時利潤  \n    No  → Step 4: // 無利潤，忽略  \n  → End // 完成所有即時交易  \n  Yes → End // 直接回傳 maxProfit  \nNo  → Decision: 使用 DP 方式計算最大利潤? // 交易次數有限，需 DP  \n  Yes → Step 5: n = length(prices)  \n  → Step 6: Create 2D array dp of size (k+1) x n, initialise all 0 // dp[t][i] 表示至第 i 天，最多 t 次交易的最大利潤  \n  → Decision: For t from 1 to k? // 逐一處理每個交易次數  \n   Yes → Step 7: localMax = -prices[0] // 內部最大值，用於計算買入成本  \n   → Decision: For i from 1 to n-1? // 遍歷每個交易日  \n    Yes → Step 8: dp[t][i] = max(dp[t][i-1], prices[i] + localMax) // 選擇不交易或賣出  \n    → Decision: Update localMax = max(localMax, dp[t-1][i] - prices[i]) // 更新可買入的最佳成本  \n    No  → // i 循環結束  \n   No  → // t 循環結束  \n  → Step 9: maxProfit = dp[k][n-1] // 取得最大利潤  \n  → End // 回傳 maxProfit  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProfit(self, k, prices):\n        n = len(prices)\n        if n == 0:\n            return 0\n        # 如果交易次數足夠多，可視為無限次交易\n        if k >= n // 2:\n            profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i - 1]:\n                    profit += prices[i] - prices[i - 1]\n            return profit\n        # dp[t][d] 代表到第 d 天最多完成 t 次交易的最大利潤\n        dp = [[0] * n for _ in range(k + 1)]\n        for t in range(1, k + 1):\n            max_diff = -prices[0]  # 買入時可得到的最大差值\n            for d in range(1, n):\n                dp[t][d] = max(dp[t][d - 1], prices[d] + max_diff)\n                max_diff = max(max_diff, dp[t - 1][d] - prices[d])\n        return dp[k][n - 1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 嘗試從輸入中抓取 k 和 prices\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    prices_match = re.search(r'prices\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if k_match and prices_match:\n        k = int(k_match.group(1))\n        prices = eval(prices_match.group(1))\n    else:\n        # 另一種可能的輸入格式：兩行，第一行 k，第二行 prices\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            try:\n                k = int(lines[0].strip())\n                prices = eval(lines[1].strip())\n            except:\n                return\n        else:\n            return\n    solution = Solution()\n    print(solution.maxProfit(k, prices))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, prices = [2,4,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "k = 2, prices = [3,2,6,5,0,3]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode522.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence II",
    "description_snippet": "Given an array of strings strs, return the length of the longest uncommon subsequence between them. ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for solving the problem: longest uncommon subsequence length among array of strings.\n\nThis is LeetCode 522: Longest Uncommon Subsequence I. Solution: if there is any string that is not equal to any other, answer is its length; else -1. Because if duplicates exist, no string is uncommon.\n\nThus algorithm: find counts of each string. For each string, if its count is 1, return its length. If none, return -1.\n\nPseudocode: Start; compute map of string->count; for each str: count++; then iterate again; if count==1: return len(str). If loop finishes: return -1. End.\n\nWe need to output line-by-line with arrow and explanation.\n\nLet's produce steps.\n\nStart\n→ Step 1: Initialize empty map CountMap // 用於儲存每個字串出現次數\n→ Step 2: For each string s in strs: // 遍歷輸入字串陣列\n    → Step 2.1: If s not in CountMap: set CountMap[s] = 0\n    → Step 2.2: Increment CountMap[s] by 1 // 計算每個字串的頻率\n→ Step 3: For each string s in strs: // 再次遍歷以找唯一字串\n    → Decision: If CountMap[s] == 1? // 只出現一次的字串\n        → Yes → Step 3.1: Return length of s // 這是最長的不相同子序列\n        → No  → Continue to next string // 不是唯一字串，檢查下一個\n→ Step 4: Return -1 // 若無唯一字串，代表不存在不相同子序列\nEnd\n\nAdd explanation comments for each line. Use arrows. Also note indent.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Initialize empty map CountMap // 用於儲存每個字串出現次數\n→ Step 2: For each string s in strs: // 遍歷輸入字串陣列\n    → Step 2.1: If s not in CountMap: set CountMap[s] = 0 // 若字串尚未記錄，初始化頻率為0\n    → Step 2.2: Increment CountMap[s] by 1 // 將該字串的出現次數加一\n→ Step 3: For each string s in strs: // 再次遍歷以找唯一字串\n    → Decision: If CountMap[s] == 1? // 只出現一次的字串\n        → Yes → Step 3.1: Return length of s // 這是最長的不相同子序列，直接回傳長度\n        → No  → Continue to next string // 不是唯一字串，檢查下一個\n→ Step 4: Return -1 // 若無唯一字串，代表不存在不相同子序列，回傳 -1\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        找出「最長不相同子序列」的長度。\n        只要存在一個字串在整個陣列中只出現一次，\n        那個字串本身即為一個不相同子序列，且其長度就是答案。\n        取所有只出現一次的字串中的最大長度即可。\n        \"\"\"\n        # 計算每個字串的出現次數\n        count = {}\n        for s in strs:\n            count[s] = count.get(s, 0) + 1\n\n        # 搜尋只出現一次的字串，取最大長度\n        max_len = -1\n        for s, cnt in count.items():\n            if cnt == 1:\n                if len(s) > max_len:\n                    max_len = len(s)\n\n        return max_len\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入（假設輸入為類似 [\"aba\",\"cdc\",\"eae\"] 的字串）\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(-1)\n    else:\n        # 解析輸入成 list[str]\n        try:\n            strs = ast.literal_eval(raw_input)\n        except Exception:\n            # 若解析失敗，直接輸出 -1\n            print(-1)\n            sys.exit(0)\n\n        # 確保輸入是 list of str\n        if not isinstance(strs, list) or not all(isinstance(x, str) for x in strs):\n            print(-1)\n            sys.exit(0)\n\n        result = Solution().findLUSlength(strs)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"aba\",\"cdc\",\"eae\"]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode413.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices",
    "description_snippet": "An integer array is called arithmetic if it consists of at least three elements and if the differenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: count number of arithmetic subarrays in array. Classic LeetCode problem. Approach: iterate through array computing differences. When a new arithmetic sequence continues, increase current length. For each extension of length >=3, increment result by current length-2. Implementation: for i from 2 to n-1, if nums[i]-nums[i-1]==nums[i-1]-nums[i-2] then curr+=1 else curr=0; ans+=curr. Output steps. Need to produce virtual code line by line, each line with explanation. Use Start, End, Decision. Let's craft steps. We'll include variable initializations.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize ans = 0 // result counter\n→ Step 2: Initialize curr = 0 // current length of arithmetic suffix minus 2\n→ Step 3: For i from 2 to length(nums)-1 // iterate over array starting from third element\n    → Decision: 如果 nums[i] - nums[i-1] == nums[i-1] - nums[i-2]? // check if current diff matches previous diff\n        Yes → Step 4: curr = curr + 1 // extend arithmetic sequence\n        Yes → Step 5: ans = ans + curr // add new subarrays formed\n        No → Step 6: curr = 0 // reset sequence\nEnd\n\nBut we need each line separate. Also need indenting for nested steps maybe use tab or spaces. Provide as requested: each line: 虛擬碼步驟 [space] // 解釋. Use arrow symbols. Provide lines: Start, → Step etc. For decision, need to include branches. We can include as separate lines: Decision: ...; Yes → ; No → . Also after decision, the subsequent steps are part of branch. Let's format accordingly. Use indentation to show nested lines? Not specified but arrow representation. We'll do like:\n\nDecision: if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]? // compare consecutive differences\n    Yes → Step 4: curr = curr + 1 // extend arithmetic suffix\n    Yes → Step 5: ans = ans + curr // add count\n    No → Step 6: curr = 0 // reset\n\nNeed to ensure each line separate. Also we need to show the for loop as a step maybe Step 3: For i = 2 to n-1 // loop through array starting third element.\n\nAlso include Step 1: ans=0; Step 2: curr=0. End.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: ans = 0 // 初始化總計算結果  \n→ Step 2: curr = 0 // 目前連續等差子陣列長度減 2（至少 3 個元素）  \n→ Step 3: For i = 2 to length(nums)-1 // 從第三個元素開始遍歷陣列  \n    → Decision: if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]? // 檢查當前差值是否等於前一個差值  \n        Yes → Step 4: curr = curr + 1 // 延長等差子陣列  \n        Yes → Step 5: ans = ans + curr // 每延長一次，新增 curr 個等差子陣列  \n        No  → Step 6: curr = 0 // 差值不同，重置等差子陣列計數  \nEnd // 程式執行結束。",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums):\n        n = len(nums)\n        if n < 3:\n            return 0\n        total = 0\n        curr = 0  # 當前以 nums[i] 結尾的等差子序列數量\n        for i in range(2, n):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                curr += 1\n                total += curr\n            else:\n                curr = 0\n        return total\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 從輸入字串中取得列表\n    if \"=\" in data:\n        _, nums_part = data.split(\"=\", 1)\n        nums_str = nums_part.strip()\n    else:\n        nums_str = data\n\n    # 解析列表（安全的方式）\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        # 若 literal_eval 失敗，使用 eval（假設輸入安全）\n        nums = eval(nums_str, {})\n\n    sol = Solution()\n    result = sol.numberOfArithmeticSlices(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode345.json",
    "problem_index_in_file": 0,
    "title": "Reverse Vowels of a String",
    "description_snippet": "Given a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e',...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step: Start, etc. Use arrows and decisions. Provide short explanations. Should not output actual code. Just steps.\n\nWe need to reverse only vowels in a string. Approach: two-pointer method. Use left=0, right=len-1. Move pointers until both vowels, swap. Continue until left<right.\n\nWe need steps:\n\nStart, Input s, Initialize left=0, right=len-1, define vowel set.\n\nLoop: Decision: left<right? If Yes: then Decision: s[left] is vowel? If Yes: Decision: s[right] is vowel? If Yes: Swap s[left],s[right]; left++; right--; else: right-- ; continue. If left not vowel: left++ ; continue. If left>=right: End.\n\nBut we can simplify with while loop; but steps.\n\nWe must output step by step: each step with explanation.\n\nLet's produce:\n\nStart\n\n→ Input string s //取得輸入字串\n\n→ Set left = 0 //左指標起始\n\n→ Set right = length(s) - 1 //右指標起始\n\n→ Define vowels = set('aeiouAEIOU') //定義元音集合\n\n→ Decision: left < right? //判斷是否還有未處理的字元\n\n    Yes → Decision: s[left] in vowels? //左端是否為元音\n\n        Yes → Decision: s[right] in vowels? //右端是否為元音\n\n            Yes → Step: Swap s[left] and s[right] //交換兩端元音\n\n            Yes → left = left + 1 //左指標往右移\n\n            Yes → right = right - 1 //右指標往左移\n\n            No  → right = right - 1 //右指標往左移，忽略右端非元音\n\n        No  → left = left + 1 //左指標往右移，忽略左端非元音\n\n    No  → End //兩指標交叉，處理完成\n\nBut we need to keep arrow indentation. Use arrow for steps; decisions with Yes→ etc.\n\nLet's format accordingly.\n\nWe must ensure each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s // 取得使用者輸入的字串  \n→ Set left = 0 // 初始化左指標  \n→ Set right = length(s) - 1 // 初始化右指標  \n→ Define vowels = {a, e, i, o, u, A, E, I, O, U} // 定義元音集合  \n\n→ Decision: left < right? // 判斷是否還有未處理的字元  \n  Yes → Decision: s[left] ∈ vowels? // 左端字元是否為元音  \n    Yes → Decision: s[right] ∈ vowels? // 右端字元是否為元音  \n     Yes → Step: Swap s[left] 與 s[right] // 交換兩端元音  \n     Yes → left = left + 1 // 左指標右移  \n     Yes → right = right - 1 // 右指標左移  \n     No  → right = right - 1 // 右端非元音，僅右移指標  \n    No  → left = left + 1 // 左端非元音，僅左移指標  \n  No  → End // 左右指標相遇或交叉，完成反轉\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reverseVowels(self, s: str) -> str:\n        vowels = set('aeiouAEIOU')\n        chars = list(s)\n        left, right = 0, len(chars) - 1\n        while left < right:\n            while left < right and chars[left] not in vowels:\n                left += 1\n            while left < right and chars[right] not in vowels:\n                right -= 1\n            if left < right:\n                chars[left], chars[right] = chars[right], chars[left]\n                left += 1\n                right -= 1\n        return ''.join(chars)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 從引號內擷取字串（支援單引號或雙引號）\n    match = re.search(r'[\"\\'](.*)[\"\\']', data)\n    s = match.group(1) if match else data\n    result = Solution().reverseVowels(s)\n    # 依題目示例輸出時加入雙引號\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"IceCreAm\"",
          "expected_output": "\"AceCreIm\"",
          "success": true,
          "output": "\"AceCreIm\""
        },
        {
          "example_index": 1,
          "input": "s = \"leetcode\"",
          "expected_output": "\"leotcede\"",
          "success": true,
          "output": "\"leotcede\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode464.json",
    "problem_index_in_file": 0,
    "title": "Can I Win",
    "description_snippet": "In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The p...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo-code for solving the \"100 game\" variant with no reuse. It's classic LeetCode 464. Use memoization on bitmask of used numbers. Steps: if sum of all numbers < desiredTotal, return false. Else use recursion function canWin(mask, currentTotal) with memoization. Base case: if any choice leads to opponent losing => win. Iterate numbers not used. For each, if currentTotal+num>=desiredTotal => win. Else if opponent cannot win from new mask => win. Else continue. Return false. Also we can pre-calc sum of remaining. Use bitmask up to maxChoosableInteger <= 20. Provide pseudo-code lines with comments.\n\nLet's output step-by-step as requested. We'll incorporate initial check. Use Start, Decision, etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 maxChoosableInteger, desiredTotal // 取得兩個參數  \n→ Decision: 若 maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal? // 檢查所有數字總和是否足以達到目標  \n    Yes → Step 2: 回傳 False // 目標不可達，第一個玩家無法取勝  \n    No → Step 3: 初始化 memo = 空字典 // 用來記錄子問題結果，避免重複計算  \n→ Step 4: 定義 函式 canWin(mask, currentTotal) // 递归判断当前状态下是否能获胜  \n    → Decision: 若 mask 中所有位已設為 1? // 所有數字已被使用  \n        Yes → Step 5: 回傳 False // 沒有可選數字，無法再得分，視為失敗  \n        No → Decision: 若 (mask, currentTotal) 於 memo?  \n            Yes → Step 6: 回傳 memo[(mask, currentTotal)] // 直接使用記憶化結果  \n            No → Step 7: 遍歷 i 從 1 到 maxChoosableInteger  \n                → Decision: 若 (mask >> (i-1)) & 1 == 0? // i 尚未被選  \n                    Yes → Decision: 若 currentTotal + i >= desiredTotal? // 立即達成目標  \n                            Yes → Step 8: memo[(mask, currentTotal)] = True；回傳 True // 當前玩家直接勝利  \n                            No → Decision: 若 not canWin(mask | (1 << (i-1)), currentTotal + i)? // 對手在新狀態下是否無法取勝  \n                                    Yes → Step 9: memo[(mask, currentTotal)] = True；回傳 True // 透過此選擇迫使對手失敗  \n                                    No → Step 10: 繼續下一個 i  \n                    No → Step 11: 繼續下一個 i（此 i 已被使用，跳過）  \n            → Step 12: memo[(mask, currentTotal)] = False；回傳 False // 所有可選 i 都導致對手勝利，故此狀態無法勝利  \n→ Step 13: 回傳 canWin(0, 0) // 從空集合且總和 0 開始判斷  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        # If desired total is 0 or less, first player already wins\n        if desiredTotal <= 0:\n            return True\n\n        # Quick check: if the sum of all numbers is less than desired total,\n        # it's impossible to reach the target\n        total_sum = (maxChoosableInteger * (maxChoosableInteger + 1)) // 2\n        if total_sum < desiredTotal:\n            return False\n\n        memo = {}\n\n        def can_win(used_mask: int, remaining: int) -> bool:\n            # Memoization lookup\n            if used_mask in memo:\n                return memo[used_mask]\n\n            # Try every unused number\n            for i in range(maxChoosableInteger):\n                if not (used_mask & (1 << i)):\n                    num = i + 1\n                    # If taking this number reaches or exceeds desired total,\n                    # current player wins immediately\n                    if remaining <= num:\n                        memo[used_mask] = True\n                        return True\n                    # Otherwise, check if opponent cannot win from the new state\n                    if not can_win(used_mask | (1 << i), remaining - num):\n                        memo[used_mask] = True\n                        return True\n\n            # No winning move found\n            memo[used_mask] = False\n            return False\n\n        return can_win(0, desiredTotal)\n\nif __name__ == \"__main__\":\n    # Read entire input\n    data = sys.stdin.read()\n    # Extract integers; expects format like 'maxChoosableInteger = 10, desiredTotal = 11'\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) >= 2:\n        maxChoosableInteger, desiredTotal = nums[0], nums[1]\n    else:\n        # Default values if input is malformed\n        maxChoosableInteger, desiredTotal = 0, 0\n\n    solution = Solution()\n    result = solution.canIWin(maxChoosableInteger, desiredTotal)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "maxChoosableInteger = 10, desiredTotal = 11",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "maxChoosableInteger = 10, desiredTotal = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "maxChoosableInteger = 10, desiredTotal = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode122.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock II",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the i^th day....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for this problem: maximize profit with at most one share held, can buy/sell multiple times same day. Equivalent to sum of all positive differences. We must output in virtual code lines with explanations. Use Start, Decision, Step etc.\n\nWe'll produce logic: Initialize profit=0, for i in 1..n-1: if prices[i]>prices[i-1] profit+=prices[i]-prices[i-1]. Output profit. Provide explanation.\n\nWe need each line with \"虛擬碼步驟 [空格] // 解釋/說明\". Use arrows and Decision.\n\nLet's craft.\n\nLine1: Start // 程式開始執行\nLine2: → Step 1: 初始化 profit = 0 // 設定初始利潤為 0\nLine3: → Step 2: for i = 1 to prices.length - 1 // 循環遍歷價格陣列，從第二天開始\nLine4:     → Decision: 如果 prices[i] > prices[i-1]? // 檢查今天價格是否高於昨天\nLine5:         Yes → Step 3: profit = profit + (prices[i] - prices[i-1]) // 若是，累加利潤差額\nLine6:         No → // 不做任何操作 // 若不是，保持利潤不變\nLine7: → Step 4: 輸出 profit // 顯示最大利潤\nLine8: End // 程式執行結束\n\nWe should ensure the \"No →\" branch includes a line maybe comment. But each line must have \"虛擬碼步驟\". So \"No →\" may be considered step? We can just comment that nothing happens. Use a dummy Step: Step 5: // 無操作. But better keep No → Step: NoOp.\n\nLet's structure:\n\nLine5: No → Step 5: // 不執行任何操作 // 若不是，保持利潤不變\n\nThus each line with \"Step X:\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: profit = 0 // 初始化利潤為 0  \n→ Step 2: for i = 1 to prices.length - 1 // 循環遍歷價格陣列，從第二天開始  \n  → Decision: 如果 prices[i] > prices[i-1]? // 檢查今天價格是否高於昨天  \n   Yes → Step 3: profit = profit + (prices[i] - prices[i-1]) // 若是，累加利潤差額  \n   No  → Step 4: // 無操作 // 若不是，保持利潤不變  \n→ Step 5: 輸出 profit // 顯示最大利潤  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def maxProfit(self, prices):\n        profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i - 1]:\n                profit += prices[i] - prices[i - 1]\n        return profit\n\ndef main():\n    import sys\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入字串中擷取列表\n    try:\n        start = data.find('[')\n        end = data.rfind(']')\n        if start == -1 or end == -1:\n            prices = []\n        else:\n            prices = eval(data[start:end + 1], {})\n    except Exception:\n        prices = []\n    sol = Solution()\n    print(sol.maxProfit(prices))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode214.json",
    "problem_index_in_file": 0,
    "title": "Shortest Palindrome",
    "description_snippet": "You are given a string s. You can convert s to a palindrome by adding characters in front of it.\n\nRe...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: Given string s, we can add characters in front to make it palindrome. Find shortest palindrome by adding characters in front. Classic solution: find longest palindromic prefix, then reverse the suffix and prepend. We need to produce pseudocode lines.\n\nWe need to output each line with virtual code step + comment. Use arrows and decision structures. Let's outline steps:\n\nStart\n→ Step 1: Get length n of s\n→ Step 2: Initialize maxLen = 0\n→ Step 3: For i from 0 to n-1:\n    → Step 4: Check if substring s[0..i] is palindrome\n        → Decision: 是? \n            Yes → Update maxLen = i+1\n→ Step 5: Suffix = s[maxLen..n-1]\n→ Step 6: Reverse Suffix\n→ Step 7: Result = reversedSuffix + original s\n→ End\n\nCould also include checking palindrome helper function.\n\nWe need arrow formatting. For loop we could use → Step ... but maybe use Decision: if palindrome? Yes → etc. Let's create pseudocode with steps.\n\nWe need to keep format: `虛擬碼步驟 // 解釋`. Use Start, End. Provide arrows. We may need nested Decision blocks.\n\nLet's produce.\n\nUse Chinese comments. Use arrow and decision.\n\nEnsure each line has virtual code step and comment.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(s) // 取得字串長度  \n→ Step 2: maxLen ← 0 // 初始化最長回文前綴長度  \n→ Step 3: for i from 0 to n-1 do // 遍歷每個可能的前綴  \n    → Decision: 是否為回文?(s[0..i]) // 檢查前 i+1 個字元是否為回文  \n        Yes → maxLen ← i+1 // 若為回文，更新最長回文前綴長度  \n        No  → // 不是回文，繼續迴圈  \n→ Step 4: suffix ← substring(s, maxLen, n-1) // 從最長回文前綴後取剩餘字串  \n→ Step 5: revSuffix ← reverse(suffix) // 將剩餘字串反轉  \n→ Step 6: result ← revSuffix + s // 把反轉後的字串放在前面，得到最短回文  \n→ Step 7: return result // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef shortest_palindrome(s: str) -> str:\n    \"\"\"返回在前面添加最少字符后得到的最短回文串\"\"\"\n    if not s:\n        return \"\"\n\n    # 建立临时字符串，用于 KMP 计算最长回文前缀\n    temp = s + '#' + s[::-1]\n    n = len(temp)\n    lps = [0] * n\n\n    # KMP 预处理，计算 lps 数组\n    for i in range(1, n):\n        length = lps[i - 1]\n        while length > 0 and temp[i] != temp[length]:\n            length = lps[length - 1]\n        if temp[i] == temp[length]:\n            length += 1\n        lps[i] = length\n\n    # 需要在前面添加的字符是 s 的后缀反转\n    to_add = s[lps[-1]:][::-1]\n    return to_add + s\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入\n    raw_input = sys.stdin.read().strip()\n    # 嘗試從輸入中提取單引號包圍的字串\n    match = re.search(r\"'([^']*)'\", raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        s = raw_input\n\n    result = shortest_palindrome(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'aacecaaa'",
          "expected_output": "'aaacecaaa'",
          "success": true,
          "output": "aaacecaaa"
        },
        {
          "example_index": 1,
          "input": "s = 'abcd'",
          "expected_output": "'dcbabcd'",
          "success": true,
          "output": "dcbabcd"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode713.json",
    "problem_index_in_file": 0,
    "title": "Subarray Product Less Than K",
    "description_snippet": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines. Problem: count subarrays product < k. Standard solution: sliding window, maintain product, count subarrays ending at each index. Virtual code steps: Start, input array nums, integer k. If k <=1 return 0. Initialize left=0, product=1, count=0. For right from 0 to len-1: product*=nums[right]; while product >= k and left <= right: product /= nums[left]; left++; count += right - left +1; End. Provide each step with explanation.\n\nWe must use virtual code arrow style. Each line: \"虛擬碼步驟 // 解釋\". Use → arrow for steps, Decision for condition.\n\nLet's write step-by-step:\n\nStart\n→ Step 1: 讀取陣列 nums 與 整數 k // 獲取輸入\n→ Decision: 若 k <= 1? // 只有 k>1 才可能有子陣列符合條件\n    Yes → Step 2: 回傳 0 // 無子陣列符合\n    No  → Step 3: 設定 left = 0, product = 1, count = 0 // 初始化滑動窗口參數\n→ For right from 0 到 len(nums)-1 // 逐個擴展右邊界\n    → Step 4: product = product * nums[right] // 將新元素納入乘積\n    → Decision: 若 product >= k? // 乘積超過 k 需要收縮左邊界\n        Yes → Step 5: While product >= k 且 left <= right\n                → Step 5a: product = product / nums[left] // 移除左邊元素\n                → Step 5b: left = left + 1 // 左邊界右移\n        No  → // 乘積已符合條件，繼續\n    → Step 6: count = count + (right - left + 1) // 計算以 right 為結尾的子陣列數\n→ End // 返回 count\n\nBut we need to output virtual code lines, not actual code. We must include arrow and indent. Use \"→\" for each step. Use \"Decision:\" for conditions. In the loop, use indentation or arrow? Example format earlier uses indent. We'll mimic:\n\nStart // ...\n→ Step 1: ... \n→ Decision: ... \n    Yes → Step ...\n    No → ... \n→ For right from 0 to length-1\n    → Step 4 ...\n    → Decision: ... \n        Yes → Step 5 ...\n            While ... \n                → Step 5a ...\n                → Step 5b ...\n        No → ...\n    → Step 6 ...\nEnd // ...\n\nWe need to ensure each line is one virtual code step with explanation after //.\n\nWe must not output actual code.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取陣列 nums 與 整數 k // 取得輸入資料  \n→ Decision: 若 k <= 1? // 只有 k 大於 1 才可能有子陣列滿足條件  \n Yes → Step 2: 回傳 0 // 若 k <= 1，所有子陣列乘積都不小於 k，直接回傳 0  \n No → Step 3: 設定 left = 0, product = 1, count = 0 // 初始化滑動窗口參數  \n→ For right from 0 到 len(nums)-1 // 逐個擴展右邊界  \n → Step 4: product = product * nums[right] // 將右邊新元素納入乘積  \n → Decision: 若 product >= k? // 乘積是否已超過限制  \n  Yes → Step 5: While product >= k 且 left <= right  \n   → Step 5a: product = product / nums[left] // 移除左邊元素以縮小乘積  \n   → Step 5b: left = left + 1 // 左邊界右移  \n  No → // 乘積已符合條件，無需縮小窗口  \n → Step 6: count = count + (right - left + 1) // 計算以 right 為結尾的所有符合子陣列數  \nEnd // 回傳 count，程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numSubarrayProductLessThanK(self, nums, k):\n        if k <= 1:\n            return 0\n        prod = 1\n        result = 0\n        left = 0\n        for right, val in enumerate(nums):\n            prod *= val\n            while prod >= k and left <= right:\n                prod //= nums[left]\n                left += 1\n            result += right - left + 1\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Extract the list of numbers\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    # Extract the integer k\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not k_match:\n        print(0)\n        return\n    nums = eval(nums_match.group(1))\n    k = int(k_match.group(1))\n    sol = Solution()\n    print(sol.numSubarrayProductLessThanK(nums, k))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,5,2,6], k = 100",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3], k = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode187.json",
    "problem_index_in_file": 0,
    "title": "Repeated DNA Sequences",
    "description_snippet": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'. For e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with arrow, Decision, etc. Problem: find repeated 10-letter substrings in a DNA string. So algorithm: Use hash set for seen, set for repeats. For i from 0 to len(s)-10: substr = s[i:i+10]; if substr in seen: add to result; else add to seen. Return result. Also handle empty etc.\n\nWe produce virtual code lines with steps. Use arrow for steps and decisions. Format: \"Start // 程式開始執行\" then arrows.\n\nWe need to produce in Traditional Chinese.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 定義變數 seen 為空集合 // 用於儲存已遇過的 10 字母序列\n→ Step 2: 定義變數 repeats 為空集合 // 用於儲存重複出現的 10 字母序列\n→ Decision: s 的長度是否小於 10? // 檢查是否足夠長\n    Yes → Step 3: 回傳空集合 // 長度不足，無法有 10 字母序列\n    No  → Step 4: 計算 maxIndex = s.length - 10 // 最後可開始的索引\n→ Step 5: 從 i = 0 到 maxIndex 進行迴圈 // 遍歷所有可能的 10 字母子字串\n    → Step 6: substring = s.substring(i, i+10) // 取出 10 字母子字串\n    → Decision: substring 是否已在 seen? // 檢查是否之前已見\n        Yes → Step 7: 把 substring 加入 repeats // 記錄重複\n        No  → Step 8: 把 substring 加入 seen // 記錄新序列\n→ Step 9: 回傳 repeats 集合轉為列表 // 將結果以列表形式回傳\nEnd // 程式執行結束\n\nBut we need to maintain the arrow formatting exactly. Use \"→\" each step. For decisions, \"Decision:\" line then nested Yes/No. Use indent? We can show indentation by spaces.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義變數 seen 為空集合 // 用於儲存已遇過的 10 字母序列\n→ Step 2: 定義變數 repeats 為空集合 // 用於儲存重複出現的 10 字母序列\n→ Decision: s 的長度是否小於 10? // 檢查是否足夠長\n    Yes → Step 3: 回傳空集合 // 長度不足，無法有 10 字母序列\n    No  → Step 4: 計算 maxIndex = s.length - 10 // 最後可開始的索引\n→ Step 5: 從 i = 0 到 maxIndex 進行迴圈 // 遍歷所有可能的 10 字母子字串\n    → Step 6: substring = s.substring(i, i+10) // 取出 10 字母子字串\n    → Decision: substring 是否已在 seen? // 檢查是否之前已見\n        Yes → Step 7: 把 substring 加入 repeats // 記錄重複\n        No  → Step 8: 把 substring 加入 seen // 記錄新序列\n→ Step 9: 回傳 repeats 集合轉為列表 // 將結果以列表形式回傳\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        \"\"\"返回 DNA 序列中所有重複出現的 10 字母長子字串。\"\"\"\n        seen = set()          # 已經遇過的子字串\n        repeated = set()      # 重複出現的子字串\n        n = len(s)\n        if n < 10:\n            return []         # 長度不足 10，無法有 10 字母序列\n        for i in range(n - 9):          # 從 0 到 n-10\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef main():\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    # 嘗試從輸入中抽取單引號內的 DNA 序列\n    match = re.search(r\"'(.*?)'\", raw_input)\n    if match:\n        dna_sequence = match.group(1)\n    else:\n        dna_sequence = raw_input\n\n    sol = Solution()\n    result = sol.findRepeatedDnaSequences(dna_sequence)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      \"['CCCCCAAAAA', 'AAAAACCCCC']\""
        },
        {
          "example_index": 1,
          "input": "s = 'AAAAAAAAAAAAA'",
          "expected_output": "[\"AAAAAAAAAA\"]",
          "success": true,
          "output": "['AAAAAAAAAA']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode300.json",
    "problem_index_in_file": 0,
    "title": "Longest Increasing Subsequence",
    "description_snippet": "Given an integer array nums, return the length of the longest strictly increasing subsequence....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for LIS length. Use dynamic programming O(n^2). Outline:\n\nStart\n→ Step 1: 初始化 dp array same length, all 1 // each element at least length 1\n→ For i from 0 to n-1:\n    → For j from 0 to i-1:\n        → Decision: nums[j] < nums[i]? // can extend subsequence\n            Yes → dp[i] = max(dp[i], dp[j] + 1)\n→ Step 2: result = max(dp) // maximum subsequence length\n→ End\n\nAdd explanation after each line. Ensure format: line \"虛擬碼步驟 // 解釋\". Use arrow for loops? We can write:\n\n→ Step 1: Initialize dp array of length n with 1 // ... etc.\n\nFor loops use:\n\n→ Loop i from 0 to n-1:\n    → Loop j from 0 to i-1:\n        → Decision: nums[j] < nums[i]?\n            Yes → dp[i] = max(dp[i], dp[j] + 1)\n\nAdd result step.\n\nNeed to include Start and End lines. Use \"Start // 程式開始執行\". End after result.\n\nAlso note need to output in Traditional Chinese. Use Chinese explanations.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 dp 陣列，長度為 n，所有值皆設為 1 // 每個元素至少是長度 1 的子序列  \n→ Loop i 從 0 到 n-1: // 外層迴圈遍歷每個元素作為子序列結尾  \n → Loop j 從 0 到 i-1: // 內層迴圈檢查所有前置元素  \n  → Decision: nums[j] < nums[i]? // 若前一個元素小於當前，則可延長子序列  \n   Yes → dp[i] = max(dp[i], dp[j] + 1) // 更新 dp[i] 為可延長後的最大長度  \n→ Step 2: result = max(dp) // 取 dp 陣列中的最大值，即為最長遞增子序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport bisect\nimport re\n\ndef length_of_lis(nums):\n    \"\"\"計算最長遞增子序列長度 (O(n log n))\"\"\"\n    tails = []          # tails[i] 儲存長度 i+1 的子序列最小尾端\n    for num in nums:\n        idx = bisect.bisect_left(tails, num)\n        if idx == len(tails):\n            tails.append(num)\n        else:\n            tails[idx] = num\n    return len(tails)\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        return\n\n    # 只抓取正負整數，忽略其他文字\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    # 計算 LIS 長度並輸出\n    print(length_of_lis(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,9,2,5,3,7,101,18]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,3,2,3]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [7,7,7,7,7,7,7]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode46.json",
    "problem_index_in_file": 0,
    "title": "Permutations",
    "description_snippet": "Given an array nums of distinct integers, return all the possible permutations. You can return the a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for generating all permutations of array of distinct ints. Use recursion/backtracking. Provide step-by-step lines with comments.\n\nLet's outline:\n\nStart\n→ Step 1: 初始化 result list\n→ Step 2: 定義遞歸函式 permute(current, remaining)\n→ Decision: if remaining empty? \n   Yes → Step 3: 把 current 加入 result\n   No → For each index i in remaining:\n          → Step 4: new_current = current + remaining[i]\n          → Step 5: new_remaining = remaining without i\n          → Step 6: 呼叫 permute(new_current, new_remaining)\n→ End\n→ Step 7: 呼叫 permute(empty, nums)\n→ Step 8: 返回 result\n\nNeed arrow formatting with Start, End, Decision. Provide lines. Use \"→\" for action lines. Indent decisions. Provide each line with comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義空的結果集合 results // 用來儲存所有排列\n→ Step 2: 定義遞歸函式 permute(current, remaining) // current: 已經選好的元素, remaining: 尚未選擇的元素\n→ Decision: 如果 remaining 為空? // 判斷是否已完成一個排列\n    Yes → Step 3: 把 current 加入 results // 完整排列已形成，存入結果\n    No  → Step 4: 針對 remaining 中每個索引 i 執行以下\n        → Step 5: 新的 current 為 current 加上 remaining[i] // 將目前元素加入排列\n        → Step 6: 新的 remaining 為 remaining 去除索引 i 的元素 // 更新未選擇集合\n        → Step 7: 呼叫 permute(new_current, new_remaining) // 進一步遞歸尋找剩餘排列\n→ End // 完成所有遞歸\n→ Step 8: 呼叫 permute(empty, nums) // 開始時尚未選擇任何元素\n→ Step 9: 返回 results // 回傳所有生成的排列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Return all permutations of the distinct integers in nums.\n        Uses backtracking by swapping elements in place.\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                # Copy current permutation\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                # Swap to place i-th element at current position\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                # Restore original order (backtrack)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form 'nums = [1,2,3]' or just '[1,2,3]'.\n    \"\"\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n    try:\n        # Safely evaluate the list expression\n        return ast.literal_eval(expr)\n    except Exception as e:\n        raise ValueError(f\"Invalid input format: {data}\") from e\n\ndef main():\n    # Read entire stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.permute(nums)\n    # Print the result in the expected list-of-lists format\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0, 1], [1, 0]]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode829.json",
    "problem_index_in_file": 0,
    "title": "Consecutive Numbers Sum",
    "description_snippet": "Given an integer n, return the number of ways you can write n as the sum of consecutive positive int...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to find number of ways to express n as sum of consecutive positive integers. Known result: number of odd divisors of n. But we can also compute via brute force: for start from 1 to n, sum consecutive until sum>=n. Complexity O(n^2). But we can use arithmetic formula: number of ways equals number of odd factors of n. Let's implement efficient method: factorize n, count odd divisors. But virtual code simpler: iterate over possible length k such that k*(k+1)/2 <= n and check (n - k*(k-1)/2) % k ==0. Actually formula: n = k * m + k*(k-1)/2 where m>=1 integer. So m = (n - k*(k-1)/2)/k must be integer >=1. For each k>=1. That gives count. Complexity O(sqrt(n)). We'll produce virtual code accordingly.\n\nWe need to output step-by-step virtual code with explanations. Let's produce:\n\nStart\n→ Step: Initialize count =0\n→ Step: For k from 1 while k*(k+1)/2 <= n\n    Compute numerator = n - k*(k-1)/2\n    Decision: if numerator % k ==0\n        Yes → count +=1\nEnd\n\nReturn count.\n\nWe must produce each line with virtual code and comment.\n\nMake sure to use arrow '→', and Decision. Let's produce.\n\nUse `Start` and `End`.\n\nAlso we need to mention variable names: `count`, `k`, `numerator`. Use `While`.\n\nAdd explanation. Ensure each line ends with `//`. Use no actual code syntax. Just pseudocode.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 count ← 0 // 用來計算符合條件的個數  \n→ Step 2: 設定 k ← 1 // 從最小長度 1 開始嘗試  \n→ Decision: 只要 k*(k+1)/2 ≤ n? // 確保足夠長度可構成 n  \n    Yes → Step 3: numerator ← n - k*(k-1)/2 // 计算剩余可分配给 m 的数值  \n    → Decision: numerator % k == 0? // 判断是否能整除得到正整数 m  \n        Yes → Step 4: count ← count + 1 // 有一组连续正整数相加得到 n  \n    No  → Step 5: // 若不能整除，跳过此 k  \n    → Step 6: k ← k + 1 // 检查下一个可能的长度  \n    → 返回 Step 2 // 继续循环直到结束条件不满足  \nEnd // 程式結束，返回 count 的值",
      "generated_code": "import sys\nimport re\n\ndef consecutive_numbers_sum(n: int) -> int:\n    \"\"\"\n    計算把 n 以連續正整數相加的方式有多少種。\n    使用公式：n = k * m + k*(k-1)/2，其中 k 為連續數字的個數，\n    m 為第一個數字。只要 (n - k*(k-1)/2) 能被 k 整除且結果 >= 1，\n    就是一種合法表示。\n    \"\"\"\n    count = 0\n    k = 1\n    # k*(k-1)//2 < n 確保剩餘部分仍能形成正整數\n    while k * (k - 1) // 2 < n:\n        if (n - k * (k - 1) // 2) % k == 0:\n            count += 1\n        k += 1\n    return count\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取輸入，允許格式如 \"n = 5\" 或僅有數字\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        sys.exit(1)  # 無法找到數字，結束程序\n    n = int(match.group())\n    result = consecutive_numbers_sum(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 9",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode202.json",
    "problem_index_in_file": 0,
    "title": "Happy Number",
    "description_snippet": "Write an algorithm to determine if a number n is happy.\n\nA happy number is a number defined by the f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining algorithm to determine if number n is happy. Use Start, End, Decision, arrows, etc. Provide step-by-step pseudocode. Must include each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use Chinese. We should incorporate visited set to detect loops. Each line includes arrow or decision. Use \"→\" for next. Provide indentation. Let's design.\n\nStart\n→ Input n // 取得初始數字\n→ Initialize set visited // 用來記錄已出現的數字，偵測循環\n→ Decision: n == 1? // 是否已經是 1，若是則為快樂數\n    Yes → Step: Return true // 若 n==1，返回真\n    No → Decision: visited contains n? // 檢查是否已經出現，若出現代表循環\n        Yes → Step: Return false // 循環未到 1，非快樂數\n        No  → Step: Compute sum of squares of digits of n → Update n // 計算下一個數字\n→ Repeat the process until true/false returned\n\nBut need to show loop structure. Perhaps we can use \"Loop\" concept.\n\nWe can use:\n\n→ Loop: (While true) // 進入重複處理\n\nBut need to show step after computing sum, go back to loop.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Input n // 取得使用者輸入的正整數 n\n→ Initialize visited as empty set // 用於存儲已遇到的數字，檢測循環\n→ Loop: // 開始迭代\n    → Decision: n == 1? // 檢查是否已達 1\n        Yes → Step: Return true // 若為 1，為快樂數，結束並返回 true\n        No  → Decision: visited contains n? // 檢查是否已重複，判斷是否陷入循環\n            Yes → Step: Return false // 重複出現，非快樂數，返回 false\n            No  → Step: Compute sum = 0 // 初始化平方和\n                → Step: For each digit d in n\n                    → Step: sum = sum + d^2 // 累加 d 的平方\n                → Step: Add n to visited // 將目前數字加入已訪問集合\n                → Step: n = sum // 更新 n 為平方和，回到 Loop\n\nBut each line must be a single line: \"虛擬碼步驟 // 解釋\". We need to avoid multi-line steps? But we can combine nested steps? We can use multiple lines with indentation. But each line should contain the arrow or decision. We need to separate each step.\n\nWe can use indentation with spaces for readability. Each step must end with explanation. So we need to produce lines like:\n\n→ Loop: // 進入迴圈重複處理\n    → Decision: n == 1? // 判斷是否已為 1\n\nBut we need to show arrow before each step. Provide indentation.\n\nLet's produce.\n\nAlso, we need to handle computing sum of squares, maybe with another nested loop.\n\nWe could do:\n\n→ Step: sum = 0 // 初始化平方和\n→ Step: temp = n // 用於分解每位數\n→ LoopDigits: // 迭代每個數位\n    → Decision: temp > 0? // 是否還有數位未處理\n        Yes → Step: d = temp mod 10 // 取最低位數\n            → Step: sum = sum + d * d // 加入平方\n            → Step: temp = temp div 10 // 去掉最低位\n            → Step: Go to LoopDigits // 重複處理下一位\n        No  → Step: Add n to visited // 將當前數字加入集合\n            → Step: n = sum // 更新 n 為平方和\n            → Step: Go to Loop // 回到主迴圈\n\nBut the specification may not require such detail; we can keep simpler: compute sum using a function. But still need each step.\n\nWe should produce concise but covering algorithm. Provide each line as per format. Let's craft final answer with lines.\n\nUse \"→\" for steps. Use \"Decision:\" for decisions. Use \"Yes →\" \"No →\". Use \"End\". Use \"Start\". Provide comments in Chinese.\n\nLet's produce.\n\nAlso note that each line must contain one step and comment. Indentation may use spaces before arrow. It's okay.\n\nLet's output:\n\nStart // 程式開始執行\n→ Input n // 取得使用者輸入的正整數\n→ Initialize visited as empty set // 用於存儲已出現的數字，檢測循環\n→ Loop: // 進入主迴圈，重複計算平方和\n    → Decision: n == 1? // 檢查是否已達 1\n        Yes → Step: Return true // n 為 1，為快樂數，結束\n        No  → Decision: visited contains n? // 檢查是否已重複，判斷是否陷入循環\n            Yes → Step: Return false // 已重複，非快樂數，結束\n            No  → Step: sum = 0 // 初始化平方和\n                → Step: temp = n // 用於逐位分解\n                → LoopDigits: // 逐位計算平方和\n                    → Decision: temp > 0? // 還有數位未處理？\n                        Yes → Step: digit = temp mod 10 // 取最低位\n                            → Step: sum = sum + digit * digit // 加入平方\n                            → Step: temp = temp div 10 // 去掉最低位\n                            → Step: Go to LoopDigits // 重複處理下一位\n                        No  → Step: Add n to visited // 將本數字加入集合\n                            → Step: n = sum // 更新 n 為平方和\n                            → Step: Go to Loop // 回到主迴圈\nEnd // 程式結束\n\nBut we used \"Go to\" which may not be needed; we can just rely on the structure. But it's okay.\n\nHowever we need to ensure each line has only one step. The lines with nested steps like \"Yes → Step: digit = temp mod 10 // ...\" each have arrow. But we also used \"Go to LoopDigits\" line; it's okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 取得使用者輸入的正整數  \n→ Initialize visited as empty set // 用於存儲已出現的數字，檢測循環  \n→ Loop: // 進入主迴圈，重複計算平方和  \n  → Decision: n == 1? // 檢查是否已達 1  \n   Yes → Step: Return true // n 為 1，為快樂數，結束  \n   No  → Decision: visited contains n? // 檢查是否已重複，判斷是否陷入循環  \n    Yes → Step: Return false // 已重複，非快樂數，結束  \n    No  → Step: sum = 0 // 初始化平方和  \n     → Step: temp = n // 用於逐位分解  \n     → LoopDigits: // 逐位計算平方和  \n       → Decision: temp > 0? // 還有數位未處理？  \n        Yes → Step: digit = temp mod 10 // 取最低位  \n          → Step: sum = sum + digit * digit // 加入平方  \n          → Step: temp = temp div 10 // 去掉最低位  \n          → Step: Go to LoopDigits // 重複處理下一位  \n        No  → Step: Add n to visited // 將本數字加入集合  \n          → Step: n = sum // 更新 n 為平方和  \n          → Step: Go to Loop // 回到主迴圈  \nEnd // 程式結束",
      "generated_code": "import sys\n\ndef get_next(number: int) -> int:\n    \"\"\"計算數字各位數字平方之和\"\"\"\n    total = 0\n    while number > 0:\n        digit = number % 10\n        total += digit * digit\n        number //= 10\n    return total\n\ndef is_happy(n: int) -> bool:\n    \"\"\"判斷數字 n 是否為快樂數\"\"\"\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = get_next(n)\n    return n == 1\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取輸入，支援 \"n = 19\" 或直接輸入 19\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    if '=' in data:\n        try:\n            n = int(data.split('=')[-1].strip())\n        except ValueError:\n            # 若解析失敗，嘗試直接轉為 int\n            n = int(data.strip())\n    else:\n        n = int(data)\n    result = is_happy(n)\n    # 依照範例輸出小寫 true/false\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 19",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode189.json",
    "problem_index_in_file": 0,
    "title": "Rotate Array",
    "description_snippet": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for rotating an integer array to the right by k steps, k non-negative. Should handle array and k; maybe handle k > n by modulo. Use steps: compute effective rotation, reverse whole array, reverse first k, reverse rest.\n\nWe need to produce steps line by line with explanation. Use arrow \"→\". Use Start and End. Use Decision blocks. Provide explanation after //.\n\nWe need to output only the virtual code steps and explanations. Let's create:\n\nStart\n→ Step 1: Determine array length n // get length\n→ Decision: 如果 k >= n? // if k >= n need to mod\n    Yes → Step 2: k ← k mod n // reduce k\n    No  → No-op // nothing\n→ Decision: 如果 n == 0 或 k == 0? // no rotation needed\n    Yes → End // finish\n    No  → No-op // continue\n→ Step 3: Reverse entire array // reverse all elements\n→ Step 4: Reverse first k elements // reverse the first k part\n→ Step 5: Reverse remaining n-k elements // reverse the rest\nEnd\n\nAdd explanations. Also might need to handle empty array. Let's produce.\n\nMake sure each line ends with // explanation. Use arrow \"→\". For decisions, indent with spaces? In example, they indent lines inside Decision. We can replicate. Use four spaces indentation.\n\nUse \"Yes →\" and \"No →\" lines under decision. In example they used \"Yes →\" and \"No →\". Let's maintain.\n\nWe need to produce only virtual code lines. Let's write accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列長度 n ← nums.length // 取得陣列長度  \n→ Decision: 如果 k >= n? // k 大於等於陣列長度時需要取模  \n    Yes → Step 2: k ← k mod n // 取 k 除以 n 的餘數  \n    No  → No-op // 不做任何處理  \n→ Decision: 如果 n == 0 或 k == 0? // 既空陣列或不需要旋轉時直接結束  \n    Yes → End // 程式結束  \n    No  → No-op // 繼續執行  \n→ Step 3: 反轉整個陣列 // 把整個陣列倒轉，達到旋轉的第一步  \n→ Step 4: 反轉前 k 個元素 // 反轉前 k 個元素，完成旋轉的第二步  \n→ Step 5: 反轉剩下的 n-k 個元素 // 反轉剩餘元素，完成旋轉  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def rotate(self, nums, k):\n        if not nums:\n            return nums\n        k %= len(nums)\n        nums[:] = nums[-k:] + nums[:-k]\n        return nums\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n\n    # 從輸入字串中提取 nums 與 k\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not k_match:\n        # 若輸入格式不符，直接結束\n        sys.exit()\n\n    nums_str = nums_match.group(1)\n    k_str = k_match.group(1)\n\n    # 轉成實際資料結構\n    nums = ast.literal_eval(nums_str)\n    k = int(k_str)\n\n    # 執行旋轉\n    Solution().rotate(nums, k)\n\n    # 輸出結果\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "expected_output": "[5,6,7,1,2,3,4]",
          "success": true,
          "output": "[5, 6, 7, 1, 2, 3, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,-100,3,99], k = 2",
          "expected_output": "[3,99,-1,-100]",
          "success": true,
          "output": "[3, 99, -1, -100]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode492.json",
    "problem_index_in_file": 0,
    "title": "Construct the Rectangle",
    "description_snippet": "A web developer needs to know how to design a web page's size. So, given a specific rectangular web ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode, line by line with explanations, following the format. We need to address problem: given target area A, find integer L,W such that L*W = A, L>=W, difference L-W minimized. Return [L,W]. Standard approach: iterate W from sqrt(A) downwards to 1, find first divisor. Then L=A/W. Since we want L>=W, W<=L, but we iterate from sqrt down ensures minimal difference. So pseudocode:\n\nStart\n→ Input A // get target area\n→ Compute sqrtA = floor(sqrt(A)) // sqrt floor\n→ Set W = sqrtA // candidate width\n→ Decision: If A mod W == 0? // check if divides\n    Yes → Set L = A / W // compute length\n    No → W = W - 1\n        // loop until divisor found\n→ End loop: when divisor found\n→ Return [L,W] // result\n\nBut need to implement loop. Use while loop.\n\nLet's write pseudocode with line by line.\n\nWe should also cover case A is 1, etc.\n\nLet's produce steps:\n\nStart // 程式開始執行\n→ Input: targetArea // 取得目標面積\n→ sqrtArea ← floor(sqrt(targetArea)) // 計算目標面積的整數平方根\n→ W ← sqrtArea // 初始化寬度為平方根\n→ Decision: 是否存在整數除數? // 檢查 W 是否能整除目標面積\n    Yes → L ← targetArea / W // 計算長度\n    No  → W ← W - 1 // 減少寬度，繼續尋找除數\n→ Decision: W 是否為 1 且仍無除數? // 若已到 1 仍未找到，表示面積為 1\n    Yes → L ← 1\n    No  → repeat previous Decision\n→ Return [L, W] // 返回長度與寬度\nEnd // 程式結束\n\nBut we need a loop. Use while loop:\n\n→ While targetArea mod W ≠ 0: W ← W - 1 // 迭代直到找到除數\n\nSimplify:\n\nStart\n→ Input targetArea // 取得面積\n→ sqrtA ← floor(sqrt(targetArea))\n→ W ← sqrtA\n→ While targetArea mod W ≠ 0: // 循環直到能整除\n        W ← W - 1\n→ L ← targetArea / W\n→ Return [L, W]\nEnd\n\nNeed to ensure L>=W; since W <= sqrtA, L >= sqrtA >= W.\n\nThus pseudocode.\n\nLet's produce each line with arrow.\n\nWe need to show arrows like \"→ Step 1\". The example shows:\n\nStart // ...\n→ Step 1: 輸入... // \n→ Decision: ... // \n    Yes → Step ... // \n    No  → Decision: ... // \n        Yes → ...\n        No  → ...\nEnd\n\nWe can adopt simpler flow: Start, Input, Compute sqrt, Initialize, While loop, compute L, Return, End.\n\nWe can show while as:\n\n→ Decision: targetArea mod W == 0? // 檢查是否能整除\n    Yes → L ← targetArea / W // 計算長度\n    No  → W ← W - 1 // 減少寬度，重複檢查\n\nBut this will need to loop; we can show using repeat: No → ... -> Decision again.\n\nBut better use while. Let's write:\n\nStart // 程式開始執行\n→ Input targetArea // 取得目標面積\n→ sqrtA ← floor(sqrt(targetArea)) // 計算面積平方根的下限\n→ W ← sqrtA // 初始寬度為平方根\n→ While targetArea mod W ≠ 0: // 若當前寬度不是除數，減少寬度\n        W ← W - 1\n→ L ← targetArea / W // 計算相應長度\n→ Return [L, W] // 回傳長度和寬度\nEnd // 程式結束\n\nThat matches format.\n\nLet's add comments after each line. Use // for explanation.\n\nEnsure each line ends with comment. Use \"Start\" as first line.\n\nWe might want to add \"→ Decision: ...\" but while is fine.\n\nThe question: \"請根據輸出格式要求產生虛擬碼和逐行解釋\". So we must output each line as \"虛擬碼步驟 [space] // 解釋/說明\".\n\nThus:\n\nStart // 程式開始執行\n→ Input targetArea // 取得目標面積\n→ sqrtA ← floor(sqrt(targetArea)) // 計算目標面積的平方根下限\n→ W ← sqrtA // 初始寬度設為平方根\n→ While targetArea mod W ≠ 0: // 若 W 不是除數，則繼續縮小\n        W ← W - 1\n→ L ← targetArea / W // 計算對應長度\n→ Return [L, W] // 輸出長寬組合\nEnd // 程式結束\n\nHowever we might need to indent the body of while. Use arrow inside.\n\nThe example shows nested arrows:\n\nDecision: ... \n    Yes → ...\n    No  → Decision: ... \n        Yes → ...\n        No  → ...\n\nBut for while, we can write:\n\n→ While targetArea mod W ≠ 0: // ...\n        → W ← W - 1\n\nBut the arrow for body: Use \"→\" at start of line, with indentation maybe. Let's follow example style: use arrow for body line.\n\nThus:\n\n→ While targetArea mod W ≠ 0: // 檢查 W 是否能整除\n    → W ← W - 1 // 減小寬度，重新檢查\n\nBut we need the while loop to be repeated until condition false. That's fine.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input targetArea // 取得目標面積  \n→ sqrtA ← floor(sqrt(targetArea)) // 計算目標面積的平方根下限  \n→ W ← sqrtA // 初始寬度設為平方根  \n→ While targetArea mod W ≠ 0: // 若 W 不是除數，則繼續縮小  \n → W ← W - 1 // 減小寬度，重新檢查  \n→ L ← targetArea / W // 計算對應長度（此時 L ≥ W）  \n→ Return [L, W] // 輸出長寬組合  \nEnd // 程式結束",
      "generated_code": "import sys\nimport math\nimport re\n\ndef construct_rectangle(area: int):\n    \"\"\"Return [length, width] for the given area.\"\"\"\n    w = math.isqrt(area)           # start from the largest possible width\n    while area % w != 0:           # find the largest divisor <= sqrt(area)\n        w -= 1\n    return [area // w, w]\n\ndef main():\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)   # extract the first integer found\n    if not match:\n        return\n    area = int(match.group())\n    result = construct_rectangle(area)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "area = 4",
          "expected_output": "[2,2]",
          "success": true,
          "output": "[2, 2]"
        },
        {
          "example_index": 1,
          "input": "area = 37",
          "expected_output": "[37,1]",
          "success": true,
          "output": "[37, 1]"
        },
        {
          "example_index": 2,
          "input": "area = 122122",
          "expected_output": "[427,286]",
          "success": true,
          "output": "[427, 286]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode383.json",
    "problem_index_in_file": 0,
    "title": "Ransom Note",
    "description_snippet": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the ransom note problem. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Use arrow.\n\nWe'll produce steps:\n\nStart\n→ Step 1: 初始化一個字典/頻率表 countMagazine // 统计杂志中每个字母出现次数\n→ Step 2: 遍历 magazine 统计字符 // 计数\n→ Decision: 如果 ransomNote 长度 > magazine 长度? // 若字符数多于源则不可能\n    Yes → Step 3: 返回 false // 直接返回\n    No  → Step 4: 遍历 ransomNote 字符\n→ Step 5: 对于每个字符 ch in ransomNote:\n        → Decision: countMagazine[ch] > 0?\n            Yes → Step 6: countMagazine[ch] -= 1 // 消耗一次\n            No  → Step 7: 返回 false // 无法构造\n→ Step 8: 返回 true // 所有字符均满足\n\nEnd\n\nWe need arrow and indentation. Format must show arrow \"→\" and \"Yes →\", \"No →\".\n\nLet's produce lines.\n\nAlso note that the virtual code step after arrow maybe \"Step X: 文字\". Each step line: \"→ Step X: ... // explanation\". For decisions we use \"Decision: ...\". For nested decisions use indentation or \"Yes →\" etc.\n\nLet's produce.\n\nUse line numbers maybe not necessary. Just step names.\n\nWe must ensure each line includes \"虛擬碼步驟\" and \" // 解釋/說明\".\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 freq // 用來記錄每個字母在 magazine 中的剩餘數量\n→ Step 2: 對 magazine 的每個字母 c\n    → Step 3: 若 freq 內無 c，則設定 freq[c] = 0\n    → Step 4: freq[c] += 1 // 更新 c 的計數\n→ Decision: ransomNote.length > magazine.length ?\n    Yes → Step 5: 返回 false // 字母數量不足，直接失敗\n    No  → Step 6: 對 ransomNote 的每個字母 ch\n        → Decision: freq[ch] > 0 ?\n            Yes → Step 7: freq[ch] -= 1 // 消耗一次\n            No  → Step 8: 返回 false // 字母不足，失敗\n→ Step 9: 返回 true // 所有字母都已經匹配成功\nEnd // 程式執行結束\n\nBut we must keep arrow \"→\" and indent. Ensure no actual code syntax, just virtual steps.\n\nLet's output.\n\nUse \"Decision:\" line. Indentation may be space or tab. Use 4 spaces for nested.\n\nWe need each line separated.\n\nMake sure each line includes \" // \".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 freq // 用來記錄每個字母在 magazine 中的剩餘數量  \n→ Step 2: 遍歷 magazine 的每個字母 c  \n  → Step 3: 若 freq 中沒有 c，則設定 freq[c] = 0  \n  → Step 4: freq[c] += 1 // 更新 c 的計數  \n→ Decision: ransomNote 的長度是否大於 magazine 的長度？  \n  Yes → Step 5: 返回 false // 字母數量不足，直接失敗  \n  No  → Step 6: 遍歷 ransomNote 的每個字母 ch  \n    → Decision: freq[ch] > 0？  \n     Yes → Step 7: freq[ch] -= 1 // 消耗一次該字母  \n     No  → Step 8: 返回 false // 缺少必要字母，失敗  \n→ Step 9: 返回 true // 所有字母都已成功匹配  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef can_construct(ransom_note: str, magazine: str) -> bool:\n    \"\"\"檢查 ransom_note 是否能由 magazine 的字母組成。\"\"\"\n    ransom_count = Counter(ransom_note)\n    magazine_count = Counter(magazine)\n    for ch, cnt in ransom_count.items():\n        if cnt > magazine_count.get(ch, 0):\n            return False\n    return True\n\ndef main() -> None:\n    # 讀取整個輸入，並去除首尾空白\n    data = sys.stdin.read().strip()\n\n    # 正則式匹配 'ransomNote = \"a\", magazine = \"b\"' 這樣的格式\n    pattern = r'ransomNote\\s*=\\s*\"([^\"]*)\"\\s*,\\s*magazine\\s*=\\s*\"([^\"]*)\"'\n    match = re.search(pattern, data)\n\n    if match:\n        ransom_note = match.group(1)\n        magazine = match.group(2)\n    else:\n        # 若格式不符，嘗試以逗號分割並去除多餘字串\n        parts = data.replace('\\n', ' ').split(',')\n        if len(parts) >= 2:\n            ransom_note = parts[0].split('=')[-1].strip().strip('\"')\n            magazine = parts[1].split('=')[-1].strip().strip('\"')\n        else:\n            # 無法解析輸入，直接輸出 false\n            print('false')\n            return\n\n    # 呼叫核心函式，並以小寫字串輸出結果\n    result = can_construct(ransom_note, magazine)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ransomNote = \"a\", magazine = \"b\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "ransomNote = \"aa\", magazine = \"ab\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "ransomNote = \"aa\", magazine = \"aab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode376.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Subsequence",
    "description_snippet": "A wiggle sequence is a sequence where the differences between successive numbers strictly alternate ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm to compute length of longest wiggle subsequence. We must output line by line with arrow, explanation. Probably use dynamic programming: up[i] = length ending at i with last difference positive; down[i] = length ending with negative. Initialize 1. For each i from 1 to n-1, compare nums[i] to nums[j] previous? Actually we can compute with O(n) greedy: track prevDiff, count. But we need DP to get longest subsequence; greedy algorithm works to find longest wiggle subsequence length by simply counting changes ignoring equal values. Yes known solution: count wiggle changes.\n\nWe'll produce virtual code:\n\nStart\n\n→ Input nums // read array\n\n→ Decision: if length <= 1? // trivial\n\n    Yes → Step: return len // output length\n\n    No → Step: Initialize count = 1 // at least one element\n\n→ Step: prevDiff = 0 // no previous difference\n\n→ Loop i from 1 to len-1 // iterate\n\n    → Decision: nums[i] > nums[i-1] ? // compute diff\n\n        Yes → Step: curDiff = 1\n\n        No  → Decision: nums[i] < nums[i-1] ?\n\n            Yes → Step: curDiff = -1\n\n            No  → Step: curDiff = 0 // equal\n\n    → Decision: curDiff != 0 AND curDiff != prevDiff? // sign change\n\n        Yes → Step: count += 1\n\n        No → Step: // do nothing\n\n    → Step: if curDiff != 0 then prevDiff = curDiff // update prevDiff\n\n→ End // return count\n\nBut note: This algorithm gives longest wiggle subsequence length for any array, as per LeetCode problem.\n\nWe need to output steps with arrows. Use Start, End, Decision. Provide explanation.\n\nLet's craft step list:\n\n1 Start // 程式開始執行\n2 → Step 1: 取得輸入陣列 nums // 讀取整數陣列\n3 → Decision: 若 nums 的長度 <= 1? // 只需回傳長度\n4     Yes → Step 2: 回傳 nums 的長度 // 單一元素即為 wiggle\n5     No → \n6 → Step 3: 初始化 count = 1 // 至少一個元素可形成 wiggle\n7 → Step 4: 初始化 prevDiff = 0 // 尚未有差值\n8 → Step 5: 循環 i 從 1 到 len-1 // 檢查相鄰元素差值\n9     → Decision: nums[i] > nums[i-1]?\n10        Yes → Step 6: curDiff = 1 // 正差\n11        No  → Decision: nums[i] < nums[i-1]?\n12            Yes → Step 7: curDiff = -1 // 負差\n13            No  → Step 8: curDiff = 0 // 相等\n14     → Decision: curDiff != 0 AND curDiff != prevDiff?\n15         Yes → Step 9: count += 1 // 差值符號變換，增長 wiggle 長度\n16         No  → Step 10: // 無變化，不做任何事\n17     → Decision: curDiff != 0?\n18         Yes → Step 11: prevDiff = curDiff // 更新上一次差值\n19         No  → Step 12: // 若相等，prevDiff 保持不變\n20 End // 回傳 count // 結束程式\n\nWe must ensure each line has code and comment. Use arrow notation, but each step may be indented? The example uses indenting for decisions. We'll mimic style: Use '→' for next step, indent for decisions. Let's write properly.\n\nWe also need to include 'Start' 'End' as lines.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 讀取整數陣列\n→ Decision: nums 長度 <= 1? // 只需回傳長度\n    Yes → Step 2: 回傳 nums 的長度 // 單一元素即為 wiggle\n    No  → \n→ Step 3: 初始化 count = 1 // 至少一個元素可形成 wiggle\n→ Step 4: 初始化 prevDiff = 0 // 尚未有差值\n→ Step 5: 循環 i 從 1 到 nums 長度 - 1 // 檢查相鄰元素差值\n    → Decision: nums[i] > nums[i-1]? // 判斷正差\n        Yes → Step 6: curDiff = 1 // 正差\n        No  → Decision: nums[i] < nums[i-1]? // 判斷負差\n            Yes → Step 7: curDiff = -1 // 負差\n            No  → Step 8: curDiff = 0 // 相等\n    → Decision: curDiff != 0 AND curDiff != prevDiff? // 差值符號是否變換\n        Yes → Step 9: count += 1 // 變化時長度增加\n        No  → Step 10: // 無變化，保持 count 不變\n    → Decision: curDiff != 0? // 有差值時更新 prevDiff\n        Yes → Step 11: prevDiff = curDiff // 更新上一差值\n        No  → Step 12: // 相等時不更新 prevDiff\nEnd // 回傳 count // 程式執行結束\n```",
      "generated_code": "import sys\n\ndef wiggle_max_length(nums):\n    \"\"\"計算最長 wiggle 子序列的長度。\"\"\"\n    if not nums:\n        return 0\n    count = 1            # 至少一個元素\n    prev_diff = 0        # 前一個非零差值\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            cur_diff = 1\n        elif nums[i] < nums[i - 1]:\n            cur_diff = -1\n        else:\n            cur_diff = 0\n\n        if cur_diff != 0 and cur_diff != prev_diff:\n            count += 1\n        if cur_diff != 0:\n            prev_diff = cur_diff\n    return count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 允許輸入形如 \"nums = [1,7,4,9,2,5]\" 或僅 \"[1,7,4,9,2,5]\"\n    if '=' in data:\n        _, value = data.split('=', 1)\n        data = value.strip()\n    try:\n        nums = eval(data, {\"__builtins__\": None}, {})\n    except Exception:\n        # 如果 eval 失敗，直接輸出 0\n        print(0)\n        sys.exit()\n\n    print(wiggle_max_length(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,7,4,9,2,5]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1,17,5,10,13,15,10,5,16,8]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4,5,6,7,8,9]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1249.json",
    "problem_index_in_file": 0,
    "title": "Minimum Remove to Make Valid Parentheses",
    "description_snippet": "Given a string s of '(' , ')' and lowercase English characters.\n\nYour task is to remove the minimum ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode step-by-step for problem: Remove minimum parentheses to make string valid. Standard approach: use stack or counter to identify unmatched parentheses. Usually two-pass: first pass to remove extra ')', second pass to remove extra '(' from end. Or use stack indices. Provide pseudocode.\n\nWe must output lines with virtual code and explanation.\n\nWe need to output in Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" and \"Start\", \"End\", \"Decision:\" etc. Provide step-by-step.\n\nWe must not output actual code. Just pseudocode steps.\n\nLet's design algorithm:\n\nStart\n\n→ Step 1: Initialize empty stack indices\n\n→ Step 2: For i from 0 to len(s)-1\n\n   → Decision: If s[i] == '('\n\n       Yes → push i onto stack\n\n   → Decision: Else if s[i] == ')'\n\n       Yes → If stack not empty, pop (matching '(')\n\n             No → Mark i as invalid (unmatched ')')\n\n   → Else (lowercase char) → ignore\n\nAfter loop, remaining indices in stack are unmatched '('.\n\n→ Step 3: Convert s to list (mutable)\n\n→ Step 4: For each index in invalid indices list, remove char from list (or mark to skip). Also for each index in stack (unmatched '('), remove char.\n\n→ Step 5: Join list to string\n\n→ End\n\nBut we need to produce minimum removals: removing all unmatched parentheses. The two-pass algorithm ensures minimal removal. Alternatively two-pass: first pass from left to right remove unmatched ')', second pass reverse remove unmatched '('.\n\nSimplify: use two-pass approach.\n\nAlgorithm:\n\nStart\n\n→ Step 1: Initialize empty string result1\n\n→ Step 2: For each char in s:\n\n    → Decision: If char == ')' and balance == 0\n\n        Yes → skip (unmatched ')')\n\n        No → Append char to result1; if char is '(' -> balance++ ; if ')' -> balance--\n\n→ Step 3: Initialize empty string result2\n\n→ Step 4: For each char in reverse(result1):\n\n    → Decision: If char == '(' and balance == 0\n\n        Yes → skip (unmatched '(')\n\n        No → Append char to result2; if char is ')' -> balance++ ; if '(' -> balance--\n\n→ Step 5: Reverse result2 to get final string\n\n→ End\n\nExplain each step.\n\nNeed to output virtual code lines with arrow and explanation. Each line must contain the virtual code and comment.\n\nLet's produce.\n\nWe need to use \"Start\", \"End\", \"Decision:\" etc.\n\nLet's craft.\n\nLine 1: Start // 程式開始\n\nLine 2: → Step 1: Initialize balance = 0 and result1 = empty string // 用於統計左括號的個數\n\nLine 3: → Step 2: For each char c in s // 遍歷原始字串\n\nLine 4: →     Decision: 如果 c 為 '('\n\nLine 5: →         Yes → Append c to result1; balance++ // 左括號累加\n\nLine 6: →     Decision: 否則如果 c 為 ')'\n\nLine 7: →         Yes → Decision: 如果 balance > 0\n\nLine 8: →             Yes → Append c to result1; balance-- // 有可配對的左括號，保留\n\nLine 9: →             No  → Skip c // 無左括號可配對，丟棄此右括號\n\nLine 10: →     Decision: 否則 // 小寫字母\n\nLine 11: →         Yes → Append c to result1 // 小寫字母保持不變\n\nLine 12: → Step 3: 初始化 balance = 0 並且 result2 = empty string // 重新統計右括號的個數\n\nLine 13: → Step 4: 反向遍歷 result1（從尾到頭）\n\nLine 14: →     Decision: 如果 c 為 ')'\n\nLine 15: →         Yes → Append c to result2; balance++ // 右括號累加\n\nLine 16: →     Decision: 否則如果 c 為 '('\n\nLine 17: →         Yes → Decision: 如果 balance > 0\n\nLine 18: →             Yes → Append c to result2; balance-- // 有可配對的右括號，保留\n\nLine 19: →             No  → Skip c // 無右括號可配對，丟棄此左括號\n\nLine 20: →     Decision: 否則 // 小寫字母\n\nLine 21: →         Yes → Append c to result2 // 小寫字母保持不變\n\nLine 22: → Step 5: 反轉 result2 生成最終字串 finalStr // 取得合法括號結構\n\nLine 23: End // 程式結束\n\nEnsure each line ends with \"// ...\".\n\nWe need to adhere to arrow and structure. Use \"→\" at each line.\n\nAlso decision block: indent maybe with spaces.\n\nMake sure each line has \"虛擬碼步驟\" and \" // 解釋\".\n\nLet's format properly.\n\nAlso note that the requirement: \"每行必須包含：`虛擬碼步驟` + [空格] + `// 解釋/說明`。使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)。\"\n\nThus each line includes the arrow plus text.\n\nWe can format like:\n\nStart // 程式開始執行\n\n→ Step 1: Initialize balance = 0, result1 = \"\" // 用於統計左括號的個數\n\n→ Step 2: For each char c in s // 遍歷原始字串\n\n    → Decision: if c == '('\n\n        Yes → Append c to result1; balance++ // 左括號累加\n\n    → Decision: else if c == ')'\n\n        Yes → Decision: if balance > 0\n\n            Yes → Append c to result1; balance-- // 有可配對的左括號，保留\n\n            No  → Skip c // 無左括號可配對，丟棄此右括號\n\n        No  → // 這裡不可能\n\n    → Decision: else // 小寫字母\n\n        Yes → Append c to result1 // 小寫字母保持不變\n\nBut we need to keep each line simple. We can split each action into its own line.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 balance = 0，result1 = \"\" // 用於統計左括號的個數\n→ Step 2: 對於每個字元 c in s // 遍歷原始字串\n    → Decision: 若 c 為 '('\n        Yes → Append c 到 result1；balance++ // 左括號累加\n    → Decision: 否則若 c 為 ')'\n        Yes → Decision: 若 balance > 0\n            Yes → Append c 到 result1；balance-- // 有可配對的左括號，保留\n            No  → 跳過 c // 無左括號可配對，丟棄此右括號\n        No  → // 這種情況不會發生\n    → Decision: 否則 // 小寫字母\n        Yes → Append c 到 result1 // 小寫字母保持不變\n→ Step 3: 初始化 balance = 0，result2 = \"\" // 重新統計右括號的個數\n→ Step 4: 反向遍歷 result1（從尾到頭）\n    → Decision: 若 c 為 ')'\n        Yes → Append c 到 result2；balance++ // 右括號累加\n    → Decision: 否則若 c 為 '('\n        Yes → Decision: 若 balance > 0\n            Yes → Append c 到 result2；balance-- // 有可配對的右括號，保留\n            No  → 跳過 c // 無右括號可配對，丟棄此左括號\n        No  → // 這種情況不會發生\n    → Decision: 否則 // 小寫字母\n        Yes → Append c 到 result2 // 小寫字母保持不變\n→ Step 5: 反轉 result2 生成最終字串 finalStr // 取得合法括號結構\nEnd // 程式結束執行\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        # 使用棧記錄左括號索引\n        stack = []\n        chars = list(s)\n        for i, ch in enumerate(chars):\n            if ch == '(':\n                stack.append(i)\n            elif ch == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    # 未匹配到左括號，標記為空字元\n                    chars[i] = ''\n        # 將剩餘未匹配的左括號也標記為空\n        for i in stack:\n            chars[i] = ''\n        return ''.join(chars)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 若輸入包含 s = \"...\" 的形式，擷取雙引號內的內容\n    m = re.search(r'\"([^\"]*)\"', data)\n    if m:\n        s = m.group(1)\n    else:\n        # 直接使用整行文字\n        s = data.strip()\n    sol = Solution()\n    result = sol.minRemoveToMakeValid(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"lee(t(c)o)de)\"",
          "expected_output": "\"lee(t(c)o)de\"",
          "success": true,
          "output": "lee(t(c)o)de"
        },
        {
          "example_index": 1,
          "input": "s = \"a)b(c)d\"",
          "expected_output": "\"ab(c)d\"",
          "success": true,
          "output": "ab(c)d"
        },
        {
          "example_index": 2,
          "input": "s = \"))((\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode239.json",
    "problem_index_in_file": 0,
    "title": "Sliding Window Maximum",
    "description_snippet": "You are given an array of integers nums, there is a sliding window of size k which is moving from th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for sliding window maximum. Should describe algorithm maybe using deque. Provide line-by-line virtual code. Use Start, End, Decision, etc. Provide explanation after each line. Each line includes virtual code and comment. Should not output actual code. Just high-level steps.\n\nLet's produce algorithm steps: 1. Initialize deque to store indices of potential max. 2. Iterate through array. 3. Remove indices out of window. 4. Remove indices whose values less than current. 5. Append current index. 6. When i >= k-1, record max value from front of deque. 7. After loop, return results.\n\nWe need to use arrows and decisions. Each step in separate line.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize empty deque Q // 用來儲存窗口中可能的最大值索引\n→ Step 2: Initialize empty list result // 用於存放每個窗口的最大值\n\n→ Loop for i from 0 to length(nums)-1 // 逐個遍歷數組\n    → Decision: 是否需要移除超出窗口的索引？ (i - Q.front >= k)\n        Yes → Step 3: 移除 Q.front // 刪除離窗口最遠的索引\n        No  → // 無需移除\n    → Decision: 是否需要移除小於等於 nums[i] 的索引？\n        Yes → Step 4: 移除 Q.back 直到 Q.back的值 < nums[i] // 清除不可能成為最大值的索引\n        No  → // 無需移除\n    → Step 5: 添加 i 到 Q 末尾 // 新索引進入窗口\n    → Decision: i >= k-1? // 窗口已滿\n        Yes → Step 6: result.append(nums[Q.front]) // 取出窗口最大值\n        No  → // 窗口未滿，等待\n\n→ End // 完成遍歷\n→ Return result // 回傳最大值列表\n\nMake sure each line has virtual code and comment. Use correct indentation? It's okay to use spaces. Use arrows for decisions: \"Decision: ...\". Use \"Yes →\" \"No →\" lines. For Step 3, 4, etc. Provide explanation. Use Start and End.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空的雙端佇列 Q // 用來儲存當前窗口中可能成為最大值的元素索引\n→ Step 2: 初始化空的列表 result // 用於存放每個窗口的最大值\n\n→ Loop for i from 0 to length(nums)-1 // 逐個遍歷數組\n    → Decision: i - Q.front >= k? // 是否有索引已離開窗口？\n        Yes → Step 3: 移除 Q.front // 刪除離窗口最遠的索引\n        No  → // 無需移除\n    → Decision: Q.back <= nums[i]? // 是否有索引對應的值小於等於當前值？\n        Yes → Step 4: 移除 Q.back 直到 Q.back 的值 < nums[i] // 清除不可能成為最大值的索引\n        No  → // 無需移除\n    → Step 5: 將 i 加入 Q 的尾部 // 新索引進入窗口\n    → Decision: i >= k-1? // 窗口已經填滿？\n        Yes → Step 6: result.append(nums[Q.front]) // 取出窗口最大值\n        No  → // 窗口未滿，等待下一個元素進入\n\n→ End // 完成遍歷\n→ Return result // 回傳所有窗口的最大值列表",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\ndef max_sliding_window(nums, k):\n    \"\"\"Return list of maximums for each sliding window of size k.\"\"\"\n    if not nums or k == 0:\n        return []\n\n    deq = deque()          # stores indices of potential maximums\n    res = []\n\n    for i, val in enumerate(nums):\n        # Remove indices that are out of the current window\n        while deq and deq[0] < i - k + 1:\n            deq.popleft()\n\n        # Remove indices whose values are less than the current value\n        while deq and nums[deq[-1]] < val:\n            deq.pop()\n\n        deq.append(i)\n\n        # When the first window is fully within the array, record the maximum\n        if i >= k - 1:\n            res.append(nums[deq[0]])\n\n    return res\n\nif __name__ == \"__main__\":\n    # Read entire input\n    data = sys.stdin.read().strip()\n\n    # Extract nums list and k value using regular expressions\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data, re.S)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n\n    if nums_match and k_match:\n        nums = eval(nums_match.group(1))\n        k = int(k_match.group(1))\n    else:\n        nums = []\n        k = 0\n\n    result = max_sliding_window(nums, k)\n\n    # Print the result in the required format: no spaces after commas\n    print('[' + ','.join(str(x) for x in result) + ']')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "expected_output": "[3,3,5,5,6,7]",
          "success": true,
          "output": "[3,3,5,5,6,7]"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode628.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product of Three Numbers",
    "description_snippet": "Given an integer array nums, find three numbers whose product is maximum and return the maximum prod...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with comments, each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Use arrows and Yes/No. Provide step by step algorithm: sort array, then max product could be max of (last3) or (first2*last1). So steps: sort ascending. Then compute product1 = last three. product2 = first two * last one. max product = max(product1, product2). Return max. Edge cases: length 3 minimal. Provide pseudocode. Let's produce step lines.\n\nWe'll use \"Start\", \"→\" lines. For decisions: decide if product1 > product2. Also check array length. We may have Decision: if length == 3? But we can skip, just compute. Provide clarity.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort the array nums in ascending order // 將輸入陣列從小到大排序\n→ Step 2: Let n be the length of nums // 取得陣列長度\n→ Decision: 如果 n == 3? // 檢查是否僅有三個元素\n    Yes → Step 3: Return nums[0] * nums[1] * nums[2] // 若只有三個，直接回傳它們的乘積\n    No  → Decision: 如果 n > 3? // 確認陣列長度足以計算\n        Yes → Step 4: Let max1 = nums[n-1] * nums[n-2] * nums[n-3] // 計算最後三個數的乘積\n              Step 5: Let max2 = nums[0] * nums[1] * nums[n-1] // 計算最小兩個與最大數的乘積\n              Step 6: Let maxProduct = max(max1, max2) // 取兩種乘積中的較大值\n              Step 7: Return maxProduct // 回傳最大乘積\n        No  → Step 8: Return 0 // 若陣列不足三個元素，返回 0 或適當錯誤值\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maximumProduct(self, nums):\n        \"\"\"\n        Find the maximum product of any three numbers in the list.\n        \"\"\"\n        if len(nums) < 3:\n            # According to problem constraints, this case shouldn't occur.\n            return 0\n        nums.sort()\n        # Two possibilities: product of three largest or product of two smallest (maybe negative)\n        # and the largest.\n        prod1 = nums[-1] * nums[-2] * nums[-3]\n        prod2 = nums[0] * nums[1] * nums[-1]\n        return max(prod1, prod2)\n\ndef parse_input():\n    \"\"\"\n    Parse the input from stdin which may look like:\n    nums = [1,2,3]\n    or just [1,2,3]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return []\n    # Find the first '[' and the last ']' to extract the list part\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        return []\n    list_str = data[start:end+1]\n    try:\n        # Safe evaluation of the list string\n        return eval(list_str)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    nums = parse_input()\n    result = Solution().maximumProduct(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "24",
          "success": true,
          "output": "24"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-2,-3]",
          "expected_output": "-6",
          "success": true,
          "output": "-6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode68.json",
    "problem_index_in_file": 0,
    "title": "Text Justification",
    "description_snippet": "Given an array of strings words and a width maxWidth, format the text such that each line has exactl...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line with arrows and explanations. Format: \"虛擬碼步驟 // 解釋\". Use arrows (→) and Decision: etc. Provide full algorithm for text justification. Let's outline steps:\n\nStart\n→ Initialize result list\n→ Initialize index i = 0\n→ While i < words.length\n   → Set lineStart = i\n   → Compute lineLength = length of words[i]\n   → j = i + 1\n   → While j < words.length and lineLength + 1 + words[j].length <= maxWidth\n        lineLength += 1 + words[j].length\n        j += 1\n   → lineEnd = j (exclusive)\n   → wordsCount = lineEnd - lineStart\n   → spacesNeeded = maxWidth - sum of lengths of words lineStart..lineEnd-1\n   → If lineEnd == words.length OR wordsCount == 1\n        → Build line with left justification\n   → Else\n        → Distribute spaces evenly\n   → Append line to result\n   → i = lineEnd\n→ Return result\nEnd\n\nNeed to include step for sum lengths. Also step for building line. Use decision branches.\n\nLet's produce each line with explanation. Need to use arrow syntax: Start, → Step, Decision: If. Also need indentation for branches? Use spaces.\n\nLet's craft.\n\nNote: Use \"虛擬碼步驟\" like \"Start\" or \"→ Step: ...\". Must add // explanation after space.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize result = [] // 用於存放所有排好版的行\n→ Initialize i = 0 // 當前處理的單詞索引\n→ While i < words.length // 處理所有單詞\n    → Set lineStart = i // 本行第一個單詞的索引\n    → Set lineLength = length(words[i]) // 本行已加入單詞的總長度\n    → Set j = i + 1 // 從下一個單詞開始檢查\n    → While j < words.length AND lineLength + 1 + length(words[j]) <= maxWidth // 嘗試加入更多單詞\n        → lineLength = lineLength + 1 + length(words[j]) // 加一表示單詞間至少一個空格\n        → j = j + 1 // 移到下一個單詞\n    → Set lineEnd = j // 本行的單詞區間為 [lineStart, lineEnd)\n    → Set wordsCount = lineEnd - lineStart // 本行包含的單詞數\n    → Set spacesNeeded = maxWidth - (lineLength - (wordsCount - 1)) // 本行需要填充的空格總數\n    → Decision: 是否為最後一行或僅有一個單詞?\n        Yes → // 最後一行或僅一個單詞：左對齊\n            → Build line by joining words[lineStart..lineEnd-1] with single spaces\n            → Append (maxWidth - line.length) spaces at the end\n            → Append line to result\n        No  → // 需要完全對齊\n            → Set spaceSlots = wordsCount - 1 // 空格分割槽數\n            → Set baseSpace = spacesNeeded // 最小空格數\n            → Set extraSpace = 0 // 可能存在的額外空格\n            → If spacesNeeded mod spaceSlots != 0\n                → baseSpace = floor(spacesNeeded / spaceSlots)\n                → extraSpace = spacesNeeded mod spaceSlots\n            → Initialize line = \"\"\n            → For k from 0 to wordsCount - 1\n                → Append words[lineStart + k] to line\n                → If k < spaceSlots\n                    → Append baseSpace + (k < extraSpace ? 1 : 0) spaces to line\n            → Append line to result\n    → Set i = lineEnd // 前進到下一行的起始單詞\n→ Return result // 所有排版完成的行\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\nfrom typing import List\n\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \"\"\"完全左右對齊文本。\"\"\"\n        res = []\n        i, n = 0, len(words)\n\n        while i < n:\n            # 1. 找出目前行能裝下的單字數\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            line_words = words[i:j]\n            gaps = len(line_words) - 1\n            spaces_needed = maxWidth - sum(len(w) for w in line_words)\n\n            # 2. 產生行字串\n            if j == n or gaps == 0:          # 最後一行或單一單字\n                line = \" \".join(line_words)\n                line += \" \" * (maxWidth - len(line))\n            else:                            # 完全對齊\n                space, extra = divmod(spaces_needed, gaps)\n                parts = []\n                for k in range(gaps):\n                    parts.append(line_words[k])\n                    parts.append(\" \" * (space + (1 if k < extra else 0)))\n                parts.append(line_words[-1])\n                line = \"\".join(parts)\n\n            res.append(line)\n            i = j\n\n        return res\n\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中解析 words 與 maxWidth。\"\"\"\n    words_match = re.search(r'words\\s*=\\s*(\\[.*?\\])', data, re.S)\n    width_match = re.search(r'maxWidth\\s*=\\s*(-?\\d+)', data)\n    if not words_match or not width_match:\n        raise ValueError(\"輸入格式不正確\")\n\n    words_str = words_match.group(1)\n    max_width = int(width_match.group(1))\n\n    words = json.loads(words_str.replace(\"'\", '\"'))  # 轉成 python list\n    return words, max_width\n\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    words, max_width = parse_input(raw)\n\n    sol = Solution()\n    result = sol.fullJustify(words, max_width)\n\n    # 輸出符合範例的 JSON 形式\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "success": true,
          "output": "[\"This    is    an\", \"example  of text\", \"justification.  \"]"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "success": true,
          "output": "[\"What   must   be\", \"acknowledgment  \", \"shall be        \"]"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "success": true,
          "output": "[\"Science  is  what we\", \"understand      well\", \"enough to explain to\", \"a  computer.  Art is\", \"everything  else  we\", \"do                  \"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode38.json",
    "problem_index_in_file": 0,
    "title": "Count and Say",
    "description_snippet": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\ncountAn...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. The user wants virtual code for computing count-and-say sequence nth element. We should generate steps: Start, input n, loop from 2 to n, generate next string via RLE, etc. Provide explanation for each line. Use arrows and decisions.\n\nWe need not actual code, but virtual steps.\n\nWe need to adhere to format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow \"→\". Use Decision. End.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 輸入正整數 n // 取得使用者輸入的序列索引\n→ Decision: 若 n == 1? // 檢查是否為第一項\n    Yes → Result: 設定 current = \"1\" // 第一項已知\n    No  → Step 2: 設定 current = \"1\" // 初始化為第一項\n        → Step 3: 循環計數 i 從 2 到 n // 逐步生成後續項\n            → Step 4: 初始化 next = \"\" // 用於儲存 RLE 結果\n            → Step 5: 設定 count = 1 // 記錄當前字符重複數量\n            → Step 6: 從 j = 1 開始遍歷 current 字符串 // j 索引從 1 開始\n                → Decision: 若 j < length(current) 且 current[j] == current[j-1]? // 判斷是否連續相同\n                    Yes → count = count + 1 // 繼續累計\n                    No  → Step 7: next = next + count + current[j-1] // 將累計寫入\n                          → count = 1 // 重置計數\n                → Step 8: j = j + 1 // 移動到下一個字符\n            → Decision: 是否到達字符串末尾? // 循環結束時處理最後一段\n                Yes → Step 9: next = next + count + current[length(current)-1] // 加上最後一段\n                No  → // 這裡不會發生，已在循環中處理\n            → Step 10: current = next // 更新為新一項\n        → Step 11: Result: current // 最後的 current 即為第 n 項\nEnd // 程式執行結束\n\nWe need to keep line by line with arrow. Might need indentation? Use arrow for each step; decisions with Yes →, No →.\n\nLet's output. Ensure each line includes virtual code and comment. Use brackets? They didn't specify brackets. Just include arrow and comment. We need to separate steps: use indentation? In example they used indentation to show nested steps. We'll use similar style: indent inside Decision. Also use `Step` numbers.\n\nWe should ensure no actual code. Use pseudo-code. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入正整數 n // 取得使用者輸入的序列索引  \n→ Decision: 若 n == 1? // 檢查是否為第一項  \n    Yes → Result: 設定 current = \"1\" // 第一項已知，直接輸出  \n    No → Step 2: 設定 current = \"1\" // 初始化為第一項  \n        → Step 3: 循環計數 i 從 2 到 n // 逐步生成後續項  \n            → Step 4: 初始化 next = \"\" // 用於儲存 RLE 結果  \n            → Step 5: 設定 count = 1 // 記錄當前字符重複數量  \n            → Step 6: 從 j = 1 開始遍歷 current 字符串 // j 索引從 1 開始  \n                → Decision: 若 j < length(current) 且 current[j] == current[j-1]? // 判斷是否連續相同  \n                    Yes → count = count + 1 // 繼續累計  \n                    No → Step 7: next = next + count + current[j-1] // 將累計寫入 next  \n                       → count = 1 // 重置計數  \n                → Step 8: j = j + 1 // 移動到下一個字符  \n            → Decision: 是否到達字符串末尾? // 循環結束時處理最後一段  \n                Yes → Step 9: next = next + count + current[length(current)-1] // 加上最後一段  \n                No → // 不會發生，已在循環中處理  \n            → Step 10: current = next // 更新為新一項  \n        → Step 11: Result: current // 最後的 current 即為第 n 項  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countAndSay(self, n: int) -> str:\n        if n <= 0:\n            return \"\"\n        result = \"1\"\n        for _ in range(1, n):\n            next_seq = []\n            count = 1\n            for j in range(1, len(result)):\n                if result[j] == result[j - 1]:\n                    count += 1\n                else:\n                    next_seq.append(str(count))\n                    next_seq.append(result[j - 1])\n                    count = 1\n            next_seq.append(str(count))\n            next_seq.append(result[-1])\n            result = \"\".join(next_seq)\n        return result\n\ndef parse_input(input_str: str) -> int:\n    # Extract first integer found in the input string\n    match = re.search(r'-?\\d+', input_str)\n    return int(match.group()) if match else 0\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    n = parse_input(data)\n    sol = Solution()\n    print(sol.countAndSay(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "\"1211\"",
          "success": true,
          "output": "1211"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "\"1\"",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode287.json",
    "problem_index_in_file": 0,
    "title": "Find the Duplicate Number",
    "description_snippet": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: find duplicate in array without modifying, constant space. Classic Floyd cycle detection (tortoise-hare). Provide virtual steps line by line, explanation after //.\n\nNeed start, end, decision, etc. Provide steps: read array length, initialize slow, fast pointers, loop until meet, then find entrance to cycle, etc.\n\nUse arrows for each step. Provide each line of virtual code. For readability, each line is a step, include arrows. For decision points, show Yes/No branches.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: Set slow = nums[0] // 初始化慢指針\n\nLine 3: → Step 2: Set fast = nums[0] // 初始化快指針\n\nLine 4: → Decision: While fast ≠ slow? // 循環直到兩指針相遇\n\nThen inside while loop:\n\n    Yes → Step 3: slow = nums[slow] // 慢指針走一步\n    Yes → Step 4: fast = nums[nums[fast]] // 快指針走兩步\n\nBut need to maintain structure: The while loop uses decision: while fast != slow? Actually we want loop until they meet. So we can use Decision: fast == slow? No, we continue. So Decision: fast == slow? // check if they met\n\n    Yes → End of loop // exit loop\n\n    No  → Step 3 ... Step 4\n\nAfter loop, we have meeting point. Now find entrance:\n\nLine after loop: → Step 5: Set slow = nums[0] // 把慢指針重設到起點\n\nLine 6: → Decision: While slow ≠ fast? // 循環直到兩指針再次相遇\n\n    Yes → Step 6: slow = nums[slow] // 慢指針走一步\n    Yes → Step 7: fast = nums[fast] // 快指針走一步\n\n    No  → End of loop // exit loop\n\nAfter loop, slow (or fast) is duplicate.\n\nLine 7: → Step 8: Return slow // 重複數值\n\nLine 8: End // 程式結束\n\nBut need to ensure consistent numbering. Also arrows should show indentation.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set slow = nums[0] // 初始化慢指針  \n→ Step 2: Set fast = nums[0] // 初始化快指針  \n→ Decision: 快指針與慢指針是否相遇? // 判斷是否已進入循環  \n  No  → Step 3: slow = nums[slow] // 慢指針走一步  \n  No  → Step 4: fast = nums[nums[fast]] // 快指針走兩步  \n  Yes → End of loop // 兩指針相遇，進入下一步  \n→ Step 5: Set slow = nums[0] // 把慢指針重設到陣列起點  \n→ Decision: 慢指針與快指針是否再次相遇? // 找到循環入口  \n  No  → Step 6: slow = nums[slow] // 慢指針走一步  \n  No  → Step 7: fast = nums[fast] // 快指針走一步  \n  Yes → End of loop // 兩指針相遇，找到重複數  \n→ Step 8: Return slow // slow (或 fast) 即為重複數值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # Floyd's Tortoise and Hare algorithm\n        slow = fast = nums[0]\n\n        # 第一階段：尋找相遇點\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        # 第二階段：尋找入環點（重複數字）\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n\n        return slow\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，例如 \"nums = [1,3,4,2,2]\"\n    eq_index = data.find('=')\n    if eq_index != -1:\n        list_part = data[eq_index + 1:].strip()\n    else:\n        list_part = data\n\n    nums = ast.literal_eval(list_part)\n\n    # 取得重複數字並輸出\n    solution = Solution()\n    duplicate = solution.findDuplicate(nums)\n    print(duplicate)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,4,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3,3,3,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode714.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock with Transaction Fee",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day, and an i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode line by line, following the requested format. Problem: maximum profit with transaction fee. Classic DP. We can use two variables: hold (max profit when holding a stock), cash (max profit when not holding). Iterate. Pseudocode: Start, read array prices, fee. Initialize cash=0, hold=-prices[0]. Then for each day i from 1 to n-1: hold = max(hold, cash - prices[i]); cash = max(cash, hold + prices[i] - fee). End return cash.\n\nBut we need to write each step with explanation. We also need to include decision structure maybe? We can include decisions inside loop? The pseudocode format expects use of Decision: etc. But we can simply represent each step line. Should use arrow. Provide explanation.\n\nWe need to produce code lines with \"虛擬碼步驟 // 解釋\". Each line: \"Start // 程式開始執行\". Then \"→ Step 1: 初始化 cash=0, hold=-prices[0] // ...\" etc. Need loop: \"→ For i from 1 to n-1:\". Inside loop, update hold and cash. For each assignment we can use Decision: if new hold > old hold? but we can just write max formula. But format wants Decision: maybe we can break into decision lines. Let's produce:\n\nStart // 程式開始\n→ Step 1: 取得 prices 陣列與 fee 整數 // 從輸入取得股價序列及交易費\n→ Step 2: 設定 n = prices.length // 取得天數\n→ Step 3: 設定 cash = 0 // 目前未持股時的最大利潤\n→ Step 4: 設定 hold = -prices[0] // 以第一天買入時的成本\n→ Step 5: For i = 1 to n-1: // 遍歷每一天\n    → Decision: 重新持股的利潤 > 目前持股? // 判斷是否換手買進\n        Yes → Step 6: hold = cash - prices[i] // 用現有現金買進\n        No  → Step 6: hold = hold // 保持舊持股\n    → Decision: 以今天賣出後利潤 > 目前不持股? // 判斷是否賣出\n        Yes → Step 7: cash = hold + prices[i] - fee // 賣出並扣費\n        No  → Step 7: cash = cash // 保持舊現金\n→ End // 程式結束，cash 為最大利潤\n\nBut we need to maintain two decisions, but we might use max directly to keep concise. However, requirement includes arrow and decision structure. It's okay.\n\nWe should ensure each line has a single \"虛擬碼步驟\" before comment. So each line like \"Start // ...\". For loop lines, we need to indent? Not required but could.\n\nWe'll produce each step. Use \"→\" arrow before each step except Start. Use \"Decision:\" lines with Yes→ and No→. For each step after decision we use the same \"Step\" number? Might reuse Step numbers? Might use Step 6 and Step 7 as we did.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 prices 陣列與 fee 整數 // 從輸入取得股價序列及交易費  \n→ Step 2: 設定 n = prices.length // 取得天數  \n→ Step 3: 設定 cash = 0 // 目前未持股時的最大利潤  \n→ Step 4: 設定 hold = -prices[0] // 以第一天買入時的成本  \n→ Step 5: For i = 1 to n-1: // 遍歷每一天  \n    → Decision: 重新持股的利潤 > 目前持股? // 判斷是否換手買進  \n        Yes → Step 6: hold = cash - prices[i] // 用現有現金買進  \n        No  → Step 6: hold = hold // 保持舊持股  \n    → Decision: 以今天賣出後利潤 > 目前不持股? // 判斷是否賣出  \n        Yes → Step 7: cash = hold + prices[i] - fee // 賣出並扣除交易費  \n        No  → Step 7: cash = cash // 保持舊現金  \n→ End // 程式執行結束，cash 為最大利潤。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProfit(self, prices, fee):\n        n = len(prices)\n        if n == 0:\n            return 0\n        hold = -prices[0]\n        cash = 0\n        for price in prices[1:]:\n            cash = max(cash, hold + price - fee)\n            hold = max(hold, cash - price)\n        return cash\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從輸入中解析 prices 列表\n    list_match = re.search(r'\\[([^\\]]+)\\]', data)\n    if list_match:\n        prices_str = list_match.group(1)\n        prices = [int(x.strip()) for x in prices_str.split(',') if x.strip()]\n    else:\n        prices = []\n\n    # 解析 fee 整數\n    fee_match = re.search(r'fee\\s*=\\s*(-?\\d+)', data)\n    fee = int(fee_match.group(1)) if fee_match else 0\n\n    # 計算最大利潤並輸出\n    sol = Solution()\n    result = sol.maxProfit(prices, fee)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [1,3,2,8,4,9], fee = 2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "prices = [1,3,7,5,10,3], fee = 3",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode406.json",
    "problem_index_in_file": 0,
    "title": "Queue Reconstruction by Height",
    "description_snippet": "You are given an array of people, people, which are the attributes of some people in a queue (not ne...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the known Leetcode problem: reconstruct queue by height. Approach: sort people by height descending, and for equal heights by k ascending. Then insert into result at index k. We'll produce step-by-step pseudocode with virtual code lines and explanations.\n\nWe need to output line by line. Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow notation: Start, →, Decision, End. For loops we can represent with \"For each person in sorted_people:\". But we need to keep the format. We can have \"→ For each person in sorted_people:\" etc.\n\nNeed to include decision steps where necessary. We'll produce a structured algorithm: start, sort, for loop, insert, end. Use arrows to show flow.\n\nWe need to incorporate sorting: \"sorted_people = sort people by height descending, k ascending\". Then iterate.\n\nWe'll produce steps:\n\nStart // begin\n→ Step 1: sorted_people = sort(people, by height descending, k ascending) // 排序\n→ Step 2: result = empty list // 初始化結果\n→ Step 3: For each person in sorted_people: // 逐個插入\n   → Step 3.1: insert person into result at index person.k // 根據k插入\n→ End // 完成\n\nBut we need more detail: For insertion, we can use result.insert(k, person). Provide explanation.\n\nWe should include decision? Not necessary.\n\nHowever the spec requires to use arrow notation and Decision: etc. We can include a decision after sorting? Maybe to check if people list empty.\n\nWe'll produce simple but still include a Decision: if people is empty? Eh.\n\nLet's follow format: Start, then Step 1: Sort, Step 2: Initialize result, Step 3: For each person in sorted_people: etc.\n\nUse arrow notation for For each: \"→ For each person in sorted_people:\" then indentation with \"→\" maybe.\n\nBut spec says each line must contain 虛擬碼步驟 and explanation separated by a space and //.\n\nLet's keep each step on one line.\n\nWe can combine loops in one line: \"→ Step 3: For each person in sorted_people: insert person into result at index person.k // 插入操作\". That covers loop and insertion.\n\nBut arrow might be confusing. Could break into two lines: one for loop, one for insertion.\n\nHowever each line must have a single step, so we can break:\n\n→ Step 3: For each person in sorted_people: // 迭代每個人\n→ Step 3.1: Insert person into result at index person.k // 插入\n\nBut we need indentation. Use arrow at start.\n\nLet's produce final pseudocode accordingly.\n\nAlso include Decision: if people empty? We'll add before sorting: \"Decision: If people is empty? // 檢查輸入是否為空\" then Yes → End, No → continue. But may be unnecessary.\n\nBut to satisfy \"Decision:\" we could include. Let's add it.\n\nThus final answer will be multiple lines.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 people 為空? // 檢查輸入是否為空  \n  Yes → End // 若為空則直接結束  \n  No  → Step 1: sorted_people ← Sort(people, by h descending, k ascending) // 先根據高度遞減、相同高度時 k 遞增排序  \n→ Step 2: result ← [] // 初始化結果佇列  \n→ Step 3: For each person in sorted_people: // 逐一處理已排序的每個人  \n  → Step 3.1: Insert(person) into result at index person.k // 按 k 值插入，確保前方已滿足條件  \n→ End // 程式執行結束，result 即為重建的佇列",
      "generated_code": "import sys\n\nclass Solution:\n    def reconstructQueue(self, people):\n        # Sort by height descending, then by k ascending\n        people.sort(key=lambda x: (-x[0], x[1]))\n        res = []\n        for p in people:\n            res.insert(p[1], p)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        people = []\n    else:\n        # Handle input like \"people = [[7,0],[4,4],...]\" or just the list\n        if \"=\" in data:\n            _, expr = data.split(\"=\", 1)\n            people = eval(expr.strip())\n        else:\n            people = eval(data)\n    solution = Solution()\n    result = solution.reconstructQueue(people)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]",
          "expected_output": "[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]",
          "success": true,
          "output": "[[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]"
        },
        {
          "example_index": 1,
          "input": "people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]",
          "expected_output": "[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]",
          "success": true,
          "output": "[[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode381.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
    "description_snippet": "RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for the entire implementation. It's conceptual, so we outline steps: initialize data structures: vector for values, map val->set of indices. Insert: push to vector, add index to map set, return if first occurrence. Remove: check map set non-empty, pick an index to remove, swap with last element, update map sets for swapped value, pop last. getRandom: random index from vector, return value. Each step with explanation. Use arrow notation. Let's produce lines.\n\nWe'll break into steps:\n\nStart\n→ Step 1: 定義 RandomizedCollection 類別 // 建立類別\n→ Step 2: 內部變數: vector<int> values, unordered_map<int, unordered_set<int>> idxMap // 存儲數值與其索引集合\n\nConstructor: initialize empty\n\nInsert method:\n\nStep: 1: check if val not in idxMap or set empty? but we will return bool: true if new.\n\nAdd index = values.size()\nAppend val to values\nInsert index into idxMap[val]\nIf idxMap[val] size ==1 then new element => return true else false\n\nRemove method:\n\nCheck if idxMap[val] empty -> false\nGet an index to remove: take begin of set\nRemove that index from set\nIf index == last index: just pop_back, no swap\nElse: swap last element into removed spot\nUpdate values[removedIndex] = lastVal\nUpdate idxMap[lastVal]: remove lastIndex, insert removedIndex\nPop_back\nReturn true\n\ngetRandom:\n\nRandom index = rand % values.size()\nReturn values[randomIndex]\n\nWrap in pseudocode lines.\n\nWe need to use Decision lines for condition checks.\n\nLet's produce each line with explanation.\n\nWe'll produce high-level flow for each method. Use indentation with arrow.\n\nAlso include the 'Start' and 'End'.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 RandomizedCollection 類別 // 建立此資料結構的類別  \n→ Step 2: 內部變數: vector<int> values // 存放所有元素的順序陣列  \n→ Step 3: 內部變數: unordered_map<int, unordered_set<int>> idxMap // 每個值對應的索引集合  \n\n// ---------- 建構子 ----------\n→ Step 4: RandomizedCollection() // 初始化空集合  \n    → Decision: 若無元素? // 只是確保結構已空  \n        Yes → End // 空結構已完成  \n        No  → End // 無需其他操作  \n\n// ---------- 插入 ----------\n→ Step 5: bool insert(int val) // 插入一個值  \n    → Decision: idxMap[val] 是否存在? // 判斷 val 是否第一次出現  \n        Yes →  \n            → Step 6: idxMap[val].insert(values.size()) // 加入新索引  \n            → Step 7: values.append(val) // 把 val 放到末尾  \n            → Step 8: Return false // 不是第一次，已存在  \n        No  →  \n            → Step 9: idxMap[val].insert(values.size()) // 新索引  \n            → Step 10: values.append(val) // 放到末尾  \n            → Step 11: Return true // 首次插入  \n\n// ---------- 刪除 ----------\n→ Step 12: bool remove(int val) // 刪除一個值  \n    → Decision: idxMap[val] 是否為空? // 是否存在該值  \n        Yes → Step 13: Return false // 無法刪除  \n        No  →  \n            → Step 14: 取出 idxMap[val] 的任意索引 oldIdx = *begin() // 取一個要刪除的索引  \n            → Step 15: idxMap[val].erase(oldIdx) // 從集合移除該索引  \n            → Step 16: 取得最後一個索引 lastIdx = values.size() - 1  \n            → Decision: oldIdx == lastIdx? // 刪除的是最後一個嗎  \n                Yes →  \n                    → Step 17: values.pop_back() // 直接移除最後元素  \n                No  →  \n                    → Step 18: 取得最後一個值 lastVal = values[lastIdx] // 準備交換  \n                    → Step 19: values[oldIdx] = lastVal // 把最後一個放到要刪除的位置  \n                    → Step 20: idxMap[lastVal].erase(lastIdx) // 移除舊索引  \n                    → Step 21: idxMap[lastVal].insert(oldIdx) // 新增新索引  \n                    → Step 22: values.pop_back() // 移除最後元素  \n            → Step 23: Return true // 成功刪除一個  \n\n// ---------- 取得隨機 ----------\n→ Step 24: int getRandom() // 取得隨機元素  \n    → Step 25: 生成隨機索引 randIdx = random() % values.size() // 取隨機位置  \n    → Step 26: Return values[randIdx] // 回傳對應值  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 存放所有元素的列表\n        self.data = []\n        # 每個值對應的索引集合\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val):\n        \"\"\"把 val 插入到 multiset，若為第一次插入回傳 True，否則 False\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val):\n        \"\"\"從 multiset 移除一個 val，若成功回傳 True，否則 False\"\"\"\n        if not self.idx_map[val]:\n            return False\n\n        # 任取一個索引要移除\n        remove_idx = self.idx_map[val].pop()\n        last_idx = len(self.data) - 1\n        last_val = self.data[last_idx]\n\n        # 如果不是最後一個元素，需要把最後一個元素搬到 remove_idx\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n\n        # 移除最後一個元素\n        self.data.pop()\n        return True\n\n    def getRandom(self):\n        \"\"\"隨機返回 multiset 中的一個元素，機率與數量成正比\"\"\"\n        return random.choice(self.data)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並把兩個列表包在外層方括號，方便使用 json.loads\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    raw_input = \"[\" + raw_input + \"]\"\n    ops, args = json.loads(raw_input)\n\n    results = []\n    obj = None\n\n    for i, op in enumerate(ops):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            results.append(None)\n        elif op == \"insert\":\n            results.append(obj.insert(*args[i]))\n        elif op == \"remove\":\n            results.append(obj.remove(*args[i]))\n        elif op == \"getRandom\":\n            results.append(obj.getRandom())\n\n    # 輸出結果，使用 json.dumps 以得到符合題目要求的格式\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "success": true,
          "output": "[null, true, false, true, 2, true, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode132.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning II",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to find minimum cuts for palindrome partitioning. It's a classic DP problem. The algorithm: precompute palindrome table, then dp array for min cuts. Virtual code with steps and explanation. Should use Start, End, Decision. We'll need loops and decisions. Provide per line.\n\nLet's craft virtual code:\n\nStart\n→ Step 1: Read input string s // get the string\n→ Step 2: n ← length of s // string length\n→ Step 3: Initialize 2D boolean array pal[n][n] to false // will store palindrome status\n→ Step 4: For i from n-1 downto 0\n    → For j from i to n-1\n        → Decision: if s[i] == s[j] and (j-i<2 or pal[i+1][j-1])? // check palindrome condition\n            Yes → pal[i][j] ← true // mark as palindrome\n        No  → pal[i][j] ← false // not palindrome\n→ Step 5: Initialize array cuts[n] // cuts[i] = min cuts for s[0..i]\n→ Step 6: For i from 0 to n-1\n    → Decision: if pal[0][i]? // whole prefix palindrome\n        Yes → cuts[i] ← 0 // no cut needed\n    No  → \n        → cuts[i] ← large number // initialize with max\n        → For j from 1 to i\n            → Decision: if pal[j][i]? // substring s[j..i] palindrome\n                Yes → cuts[i] ← min(cuts[i], cuts[j-1] + 1)\n        // end inner loop\n// end outer loop\n→ Step 7: Result ← cuts[n-1] // min cuts for entire string\n→ Step 8: Output Result\nEnd\n\nBut we need to write virtual code lines. Use \"Decision:\" and arrows. Must be per line, each line containing step and comment. Use arrows '→' before step lines. Indent inside decisions. Let's format. We'll include indentation lines but still each line with code and comment. Use indentation via spaces before code? They used arrow to indicate step. For decisions we use \"Decision:\" and inside indent.\n\nExample:\n\nStart // 程式開始執行\n→ Step 1: s ← input() // 讀取輸入字串\n\nUse \"Step\" maybe not necessary. Use \"→\" and step number. Provide explanation after comment.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: s ← input() // 讀取輸入字串  \n→ Step 2: n ← length(s) // 取得字串長度  \n→ Step 3: pal ← boolean[n][n] initialized to false // 用來儲存子字串是否為回文的表格  \n→ Step 4: For i from n-1 downto 0  \n  → For j from i to n-1  \n    → Decision: if s[i] == s[j] and (j-i < 2 or pal[i+1][j-1])? // 判斷子字串 s[i..j] 是否為回文  \n      Yes → pal[i][j] ← true // 標記為回文  \n      No → pal[i][j] ← false // 標記為非回文  \n→ Step 5: cuts ← int[n] // cuts[i] 代表 s[0..i] 的最小切割數  \n→ Step 6: For i from 0 to n-1  \n  → Decision: if pal[0][i]? // 前綴整段為回文  \n     Yes → cuts[i] ← 0 // 不需要切割  \n     No →  \n      → cuts[i] ← n // 初始化為最大值  \n      → For j from 1 to i  \n        → Decision: if pal[j][i]? // 子字串 s[j..i] 為回文  \n          Yes → cuts[i] ← min(cuts[i], cuts[j-1] + 1) // 更新最小切割數  \n→ Step 7: result ← cuts[n-1] // 整個字串的最小切割數  \n→ Step 8: print(result) // 輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n\n        dp = [0] * n\n        pal = [[False] * n for _ in range(n)]\n\n        for i in range(n):\n            min_cut = i\n            for j in range(i + 1):\n                if s[j] == s[i] and (i - j <= 1 or pal[j + 1][i - 1]):\n                    pal[j][i] = True\n                    if j == 0:\n                        min_cut = 0\n                    else:\n                        min_cut = min(min_cut, dp[j - 1] + 1)\n            dp[i] = min_cut\n\n        return dp[-1]\n\ndef read_input() -> str:\n    data = sys.stdin.read().strip()\n    if not data:\n        return \"\"\n\n    # Extract string between quotes if present\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        return match.group(1)\n    # Otherwise strip possible surrounding quotes or whitespace\n    return data.strip('\"').strip()\n\nif __name__ == \"__main__\":\n    s = read_input()\n    solution = Solution()\n    result = solution.minCut(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode521.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence I",
    "description_snippet": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for this algorithm. Problem: longest uncommon subsequence length between two strings a, b. Known solution: if a==b return -1 else max(len(a), len(b)). Because if strings equal, no uncommon subsequence exists; else entire longer string is uncommon. So produce virtual steps.\n\nNeed to output line by line: \"Start\" etc. Provide steps: input strings a,b, compare, if equal output -1 else output max length. That's it.\n\nWe need to use arrow syntax and Decision: etc. Provide explanations after //.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入字符串 a, b // 取得兩個字串\n→ Decision: a 是否等於 b? // 檢查兩字串是否相同\n    Yes → Step 2: 回傳 -1 // 若相同，無不相同子序列，返回 -1\n    No  → Step 3: 計算長度長的字串 // 將 a、b 的長度進行比較\n        → Decision: len(a) 大於 len(b)? // 判斷哪個字串較長\n            Yes → Step 4: 回傳 len(a) // 若 a 較長，返回其長度\n            No  → Step 5: 回傳 len(b) // 若 b 較長，返回其長度\nEnd // 程式執行結束\n\nWe can compress but maintain clarity.\n\nWe must include \"虛擬碼步驟\" (the step) and explanation. The \"虛擬碼步驟\" can be \"Step 1:\" etc. Provide arrow. Ensure each line ends with comment.\n\nAlso we might need to use Yes →, No → syntax for decisions.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 a 與 b // 取得兩個待比較的字串  \n→ Decision: a 等於 b? // 判斷兩字串是否完全相同  \n    Yes → Step 2: 回傳 -1 // 若相同，無不相同子序列，直接回傳 -1  \n    No  → Step 3: 比較長度 // 若不相同，進一步找出較長的字串  \n        → Decision: len(a) > len(b)? // 判斷 a 是否比 b 長  \n            Yes → Step 4: 回傳 len(a) // 若 a 較長，回傳其長度作為結果  \n            No  → Step 5: 回傳 len(b) // 若 b 較長，回傳其長度作為結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef find_lus_length(a: str, b: str) -> int:\n    \"\"\"Return length of longest uncommon subsequence between a and b.\"\"\"\n    return -1 if a == b else max(len(a), len(b))\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 以逗號分隔；若無逗號則嘗試按行讀取\n    parts = [p.strip() for p in data.replace('\\n', ' ').split(',')]\n    if len(parts) >= 2:\n        a = parts[0].strip('\"').strip(\"'\")\n        b = parts[1].strip('\"').strip(\"'\")\n    else:\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            a = lines[0].strip('\"').strip(\"'\")\n            b = lines[1].strip('\"').strip(\"'\")\n        else:\n            # 只剩一個輸入時，視為兩個相同字串\n            a = parts[0].strip('\"').strip(\"'\")\n            b = a\n\n    result = find_lus_length(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"aba\", \"cdc\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "\"aaa\", \"bbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "\"aaa\", \"aaa\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode322.json",
    "problem_index_in_file": 0,
    "title": "Coin Change",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code with step by step logic for coin change problem. Use dynamic programming to find min coins. Provide each step with explanation. Use virtual code with arrows and decisions. Provide lines such as Start, → Step 1: initialize DP array, etc.\n\nWe need to include decision branches for impossible case. Steps: input coins array, amount; create DP array size amount+1, initialize DP[0]=0, others large (inf). Loop for each coin, for i from coin to amount, update dp[i] = min(dp[i], dp[i-coin]+1). After loops, if dp[amount] still inf then return -1 else dp[amount]. Include conditions. Use virtual code format.\n\nMake sure to keep each line with explanation after //.\n\nInclude decision for amount==0? etc. Provide final End.\n\nLet's produce lines.\n\nLet's include steps: Start, Step 1: get input coins, amount, Step 2: initialize dp, Step 3: set dp[0]=0, Step 4: loop over coins, inner loop, update dp, Step 5: Decision: dp[amount] == inf? Yes → return -1, No → return dp[amount]. End.\n\nAlso maybe add decision if amount < 0? But not needed.\n\nWe produce the virtual code.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 coins 陣列與 amount 整數 // 從使用者或函式參數取得硬幣種類與總金額  \n→ Step 2: 初始化 dp 陣列，長度 amount+1，並將所有元素設為 ∞（代表不可達） // 建立動態規劃表格  \n→ Step 3: 設定 dp[0] = 0 // 0 元不需要任何硬幣  \n→ Step 4: Decision: 迴圈每顆硬幣 coins[i]？ // 逐一處理每種硬幣  \n  Yes → Step 5: 迴圈 j 從 coins[i] 到 amount  \n   → Decision: 是否更新 dp[j]？ // 若前一步可達且更少硬幣  \n    Yes → Step 6: dp[j] = min(dp[j], dp[j - coins[i]] + 1) // 更新為更少硬幣的方案  \n    No  → // 不做更新，保持原值  \n→ Step 7: Decision: dp[amount] 為 ∞？ // 檢查是否有可行組合  \n  Yes → Step 8: 回傳 -1 // 無法組成該金額  \n  No  → Step 9: 回傳 dp[amount] // 回傳最少硬幣數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def coinChange(self, coins, amount):\n        # dp[i] 表示湊成金額 i 所需的最少硬幣數\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                # 若 dp[x - coin] 已可達，則更新 dp[x]\n                if dp[x - coin] + 1 < dp[x]:\n                    dp[x] = dp[x - coin] + 1\n\n        return dp[amount] if dp[amount] != float('inf') else -1\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從輸入字串中提取 coins 列表和 amount 整數\n    coins_match = re.search(r'coins\\s*=\\s*(\\[[^\\]]*\\])', data)\n    amount_match = re.search(r'amount\\s*=\\s*(-?\\d+)', data)\n\n    if not coins_match or not amount_match:\n        print(\"Invalid input format\")\n        sys.exit(1)\n\n    coins_str = coins_match.group(1)\n    amount_str = amount_match.group(1)\n\n    # 解析 coins 列表 (使用 eval 只為了簡化範例，假設輸入安全)\n    coins = eval(coins_str)\n    amount = int(amount_str)\n\n    sol = Solution()\n    result = sol.coinChange(coins, amount)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "coins = [2], amount = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "coins = [1], amount = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode213.json",
    "problem_index_in_file": 0,
    "title": "House Robber II",
    "description_snippet": "You are a professional robber planning to rob houses along a street. Each house has a certain amount...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: House Robber II (circle). Provide step-by-step pseudocode with explanations. Each line must be: virtual code step + space + // explanation.\n\nWe need to follow arrow formatting. Use Start, Decision, Yes→, No→ etc. We need to handle DP logic: choose either rob first to last-1 or last to first. We'll produce pseudocode.\n\nLet's craft steps:\n\nStart\n→ Input array nums\n→ Decision: If nums length == 0? Yes→ Return 0; No→ continue\n→ Decision: If nums length == 1? Yes→ Return nums[0]; No→ continue\n→ Compute max1 = robLinear(nums, 0, length-2) // rob excluding last house\n→ Compute max2 = robLinear(nums, 1, length-1) // rob excluding first house\n→ Return max(max1, max2)\n\nDefine robLinear(subarray from start to end):\n→ Initialize prev1 = 0, prev2 = 0 // hold dp[i-1], dp[i-2]\n→ For i from start to end:\n    → cur = max(prev1, prev2 + nums[i]) // choose max\n    → prev2 = prev1\n    → prev1 = cur\n→ Return prev1\n\nWe need to express decision branches. Also loops. Provide explanation each line.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums // 取得每棟屋的金額陣列  \n→ Decision: nums 長度為 0? // 檢查是否為空陣列  \n    Yes → Return 0 // 沒有房屋可盜，直接回傳 0  \n    No → Decision: nums 長度為 1? // 只剩一棟屋時的特例  \n        Yes → Return nums[0] // 直接盜取唯一房屋的金額  \n        No → // 有兩棟以上的房屋  \n→ Step: 計算不偷最後一棟屋的最大收益 // 先忽略最後一棟，避免相鄰問題  \n    → max1 = robLinear(nums, 0, len(nums)-2) // 0~len-2 的區段  \n→ Step: 計算不偷第一棟屋的最大收益 // 先忽略第一棟，避免相鄰問題  \n    → max2 = robLinear(nums, 1, len(nums)-1) // 1~len-1 的區段  \n→ Return max(max1, max2) // 兩種方案取較大者  \nEnd // 程式結束  \n\n// -------------------- 辅助函数 robLinear --------------------  \n\nStart // 開始 robLinear 函數  \n→ Input nums, start, end // 取得子陣列的起止索引  \n→ Initialize prev1 = 0, prev2 = 0 // dp[i-1] 與 dp[i-2] 的值  \n→ For i from start to end: // 遍歷子陣列  \n    → cur = max(prev1, prev2 + nums[i]) // 決定是否偷第 i 棟屋  \n    → prev2 = prev1 // 更新 dp[i-2] 為舊的 dp[i-1]  \n    → prev1 = cur // 更新 dp[i-1] 為本次計算結果  \n→ Return prev1 // 最終 dp[end] 為最大收益  \nEnd // 結束 robLinear 函數",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def rob(self, nums):\n        # 如果沒有房屋，直接回傳 0\n        if not nums:\n            return 0\n        # 只有一棟屋時，直接盜取\n        if len(nums) == 1:\n            return nums[0]\n\n        def rob_linear(houses):\n            prev, curr = 0, 0\n            for num in houses:\n                prev, curr = curr, max(curr, prev + num)\n            return curr\n\n        # 兩種策略：排除最後一棟或排除第一棟\n        return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入，並尋找包含數字列表的片段\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 找到第一個 '['，並使用 ast.literal_eval 解析列表\n    start = data.find('[')\n    if start == -1:\n        nums = []\n    else:\n        nums = ast.literal_eval(data[start:])\n\n    solution = Solution()\n    print(solution.rob(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode402.json",
    "problem_index_in_file": 0,
    "title": "Remove K Digits",
    "description_snippet": "Given string num representing a non-negative integer num, and an integer k, return the smallest poss...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: remove k digits to get smallest possible number. This is classic \"remove k digits\" problem. Approach: use stack; iterate digits, while stack not empty, k>0, and stack top > current digit, pop. Push current. After loop, if k>0, pop last k digits. Then build result string and strip leading zeros; if empty, return \"0\".\n\nWe need to output virtual code step by step. Each line: virtual code step, space, comment. Use arrows and decision blocks.\n\nWe should write a pseudo algorithm with steps: Start, Input num, k, Step 1: initialize empty stack, Step 2: loop over digits, etc. Decision blocks: while loop, if conditions, etc.\n\nWe should keep each line as a single statement. Use arrow for indent? Use \"→\". Each decision block maybe like:\n\n→ Decision: While current index < length? etc. But we need a clear structure. We can use nested arrows. Example: Use \"→\" to indicate proceeding to next step. Use \"Decision:\" for conditions.\n\nWe should not produce actual code, just pseudo.\n\nLet's produce lines.\n\nWe also need to mention removal of leading zeros at end.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 num 與整數 k // 從使用者取得需要處理的數字與刪除數目  \n→ Step 2: 初始化空棧 stack // 用於存放尚未決定是否刪除的數字  \n→ Step 3: 設定指標 i = 0 // 用於遍歷 num 的每一個位元  \n→ Decision: i < len(num) ? // 是否還有數字尚未處理  \n  Yes → Step 4: 取出 num[i] 作為 currDigit // 取得目前要考慮的數字  \n   → Decision: stack 不是空 且 k > 0 且 stack.top() > currDigit ? // 可否刪除較大的前一個數字以得到更小結果  \n     Yes → Step 5: 從 stack 移除頂端數字，並 k = k - 1 // 刪除較大的數字  \n     No  → Step 6: 將 currDigit 推進 stack // 目前數字保持不變  \n   → Step 7: i = i + 1 // 前進到下一個位元  \n   → 返回 Decision: i < len(num) ? // 重複處理所有位元  \n     Yes → 回到 Step 4  \n     No  → 進入下一步  \n→ Decision: k > 0 ? // 是否還剩下需要刪除的數字  \n  Yes → Step 8: 從 stack 移除最後 k 個數字 // 刪除末尾多餘的數字  \n     → k = 0 // k 置為 0，所有刪除完成  \n  No  → 跳過  \n→ Step 9: 將 stack 中的數字組合成字串 result // 重建最小數字字串  \n→ Step 10: 移除 result 前導的 0 // 去除前導零以確保最小值格式  \n  → Decision: result 為空？ // 例如全部數字被刪除或剩餘為全 0  \n    Yes → Step 11: result = \"0\" // 如果結果為空，返回 \"0\"  \n    No  → 保持 result  \n→ End // 程式執行結束，結果已在 result 變數中\n\n此虛擬碼描述了利用棧結構與貪心刪除策略，逐位檢查並刪除不必要的較大數字，以取得刪除 k 位後的最小可能整數。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n        \"\"\"Return the smallest number after removing k digits from num.\"\"\"\n        stack = []\n        for digit in num:\n            # While we still need to remove digits and the current digit\n            # is smaller than the last digit in the stack, pop the stack.\n            while k > 0 and stack and stack[-1] > digit:\n                stack.pop()\n                k -= 1\n            stack.append(digit)\n\n        # If k > 0, remove the remaining digits from the end.\n        while k > 0:\n            stack.pop()\n            k -= 1\n\n        # Build the result and strip leading zeros.\n        result = ''.join(stack).lstrip('0')\n        return result if result else \"0\"\n\ndef main() -> None:\n    # Read the entire input from stdin.\n    data = sys.stdin.read()\n    # Find all integers in the input (works for formats like\n    # 'num = \"1432219\", k = 3' or '10200\\n1').\n    numbers = re.findall(r'\\d+', data)\n    if not numbers:\n        return\n    num = numbers[0]\n    k = int(numbers[1]) if len(numbers) > 1 else 0\n\n    solution = Solution()\n    answer = solution.removeKdigits(num, k)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"1432219\", k = 3",
          "expected_output": "\"1219\"",
          "success": true,
          "output": "1219"
        },
        {
          "example_index": 1,
          "input": "num = \"10200\", k = 1",
          "expected_output": "\"200\"",
          "success": true,
          "output": "200"
        },
        {
          "example_index": 2,
          "input": "num = \"10\", k = 2",
          "expected_output": "\"0\"",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode125.json",
    "problem_index_in_file": 0,
    "title": "Valid Palindrome",
    "description_snippet": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and remov...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for palindrome check after normalization. Steps: normalize: iterate string, build cleaned string with lowercase alnum. Then check palindrome: compare cleaned string to reversed or use two-pointer. Use decision structure to output true/false. Provide Start, End. Each line: virtual code step, space, comment. Use arrow notation.\n\nLet's craft:\n\nStart // 開始\n→ Step 1: 定義空字符串 cleaned // 用於存放處理後的字元\n→ Decision: 對於每個字符 c in s? // 遍歷原始字串\n    Yes → Decision: c 是否為字母或數字? // 檢查是否為 alphanumeric\n        Yes → Step 2: cleaned ← cleaned + toLower(c) // 把小寫加入 cleaned\n        No  → Step 3: 跳過 // 非字母數字不加入\n→ Step 4: 定義 left = 0, right = length(cleaned) - 1 // 初始化指標\n→ Decision: left <= right? // 仍有未比較的字元\n    Yes → Decision: cleaned[left] == cleaned[right]? // 比較兩端\n        Yes → Step 5: left ← left + 1, right ← right - 1 // 向內移動指標\n        No  → Step 6: 返回 false // 兩端不相等，非回文\n    No  → Step 7: 返回 true // 所有字元已匹配，為回文\nEnd // 程式結束\n\nEnsure each line ends with comment. Use arrow \"→\" for steps. For decisions indent lines. Use No and Yes arrows. Provide correct formatting.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義空字符串 cleaned // 用於存放處理後的字元  \n→ Decision: 對於每個字符 c in s? // 遍歷原始字串  \n&nbsp;&nbsp;&nbsp;Yes → Decision: c 是否為字母或數字? // 檢查是否為 alphanumeric  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2: cleaned ← cleaned + toLower(c) // 把小寫字元加入 cleaned  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 3: 跳過 // 非字母數字不加入  \n→ Step 4: 定義 left = 0, right = length(cleaned) - 1 // 初始化兩端指標  \n→ Decision: left <= right? // 還有未比較的字元  \n&nbsp;&nbsp;&nbsp;Yes → Decision: cleaned[left] == cleaned[right]? // 比較兩端字元  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: left ← left + 1, right ← right - 1 // 向內移動指標  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6: 返回 false // 字元不相等，非回文  \n&nbsp;&nbsp;&nbsp;No  → Step 7: 返回 true // 所有字元已匹配，為回文  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        \"\"\"\n        檢查字符串 s 是否為回文（忽略大小寫、非字母數字）。\n        步驟：\n        1. 只保留字母數字，並轉成小寫。\n        2. 將結果與其反轉比較。\n        \"\"\"\n        filtered = [c.lower() for c in s if c.isalnum()]\n        return filtered == filtered[::-1]\n\n\ndef main() -> None:\n    \"\"\"\n    主程式：\n    - 從標準輸入讀取整個內容。\n    - 解析出需要檢查的字串（支援「s = \"xxx\"」或直接提供字串）。\n    - 呼叫 Solution.isPalindrome。\n    - 將布林值轉成 'true' / 'false' 並列印。\n    \"\"\"\n    import sys\n\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    data = data.strip()\n\n    # 嘗試解析「s = \"...\"」的格式\n    if '=' in data:\n        _, part = data.split('=', 1)\n        part = part.strip()\n    else:\n        part = data\n\n    # 移除可能存在的外層單引號或雙引號\n    if (part.startswith('\"') and part.endswith('\"')) or \\\n       (part.startswith(\"'\") and part.endswith(\"'\")):\n        part = part[1:-1]\n\n    # 呼叫判斷函式\n    solution = Solution()\n    is_pal = solution.isPalindrome(part)\n\n    # 輸出結果，使用小寫字母符合範例\n    print(str(is_pal).lower())\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"A man, a plan, a canal: Panama\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"race a car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \" \"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode169.json",
    "problem_index_in_file": 0,
    "title": "Majority Element",
    "description_snippet": "Given an array nums of size n, return the majority element.\n\nThe majority element is the element tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm that finds majority element. Use Boyer-Moore Voting algorithm.\n\nWe must output line by line with comment. Use arrows and structure. Provide Start, Step, Decision, etc.\n\nWe need to include steps: initialize candidate and count. Iterate array: if count==0 set candidate; if nums[i]==candidate count++ else count--. At end return candidate.\n\nWe should also possibly include check array length, but not needed.\n\nFollow format: each line \"虛擬碼步驟 // 解釋/說明\". Use \"Start\" and \"End\". Use \"→\" arrow for steps. Use \"Decision:\".\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 candidate = null, count = 0 // 初始化候選元素與計數\n→ Step 2: 遍歷 nums 中每個元素 num // 開始遍歷陣列\n    → Decision: count == 0? // 判斷是否需要選擇新候選\n        Yes → Step 3: candidate = num, count = 1 // 取新候選並重置計數\n        No  → Decision: num == candidate? // 檢查當前數字是否為候選\n            Yes → Step 4: count = count + 1 // 同一候選數量加一\n            No  → Step 5: count = count - 1 // 不同數字計數減一\n→ Step 6: return candidate // 返回最終候選作為多數元素\nEnd\n\nMake sure to use Chinese explanations. Each line includes step and comment. Ensure formatting: \"→\" before each step, Decision lines with indent. Use // after each line.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 candidate = null, count = 0 // 設定初始候選元素與計數  \n→ Step 2: 遍歷 nums 中每個元素 num // 開始逐一檢查陣列  \n  → Decision: count == 0? // 判斷是否需要挑選新候選  \n   Yes → Step 3: candidate = num, count = 1 // 選取當前元素為新候選，重置計數  \n   No  → Decision: num == candidate? // 檢查當前元素是否與候選相同  \n    Yes → Step 4: count = count + 1 // 同一候選出現，計數加一  \n    No  → Step 5: count = count - 1 // 與候選不同，計數減一  \n→ Step 6: return candidate // 返回最終得到的候選元素，即多數元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def majorityElement(self, nums):\n        \"\"\"\n        使用 Boyer‑Moore 投票演算法找出多數元素。\n        \"\"\"\n        count = 0\n        candidate = None\n        for num in nums:\n            if count == 0:\n                candidate = num          # 取新候選\n            count += 1 if num == candidate else -1\n        return candidate\n\ndef main():\n    \"\"\"\n    讀取 stdin，解析成 list，輸出多數元素。\n    支援輸入格式如：\n        nums = [3,2,3]\n    或直接：\n        [3,2,3]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中提取第一個列表字串\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if match:\n        list_str = match.group(0)\n    else:\n        list_str = data\n\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        nums = []\n\n    solution = Solution()\n    result = solution.majorityElement(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,1,1,1,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode468.json",
    "problem_index_in_file": 0,
    "title": "Validate IP Address",
    "description_snippet": "Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IP is a valid IPv6 ad...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, with comments. The user provided a requirement: Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IPv6, else \"Neither\".\n\nWe need to produce a virtual code (like pseudo-code) line by line, with comments, using arrows and decisions.\n\nWe should not output actual code. Just steps.\n\nLet's design algorithm:\n\nStart\n\n→ Step 1: If queryIP contains '.' and not ':' -> candidate IPv4\n\n→ Decision: if contains '.'? But need to differentiate between IPv4 and IPv6: IPv4 has 3 dots. IPv6 has 7 colons. So we can first check count of '.' vs ':'. But also may have both? But IP will not have both.\n\nApproach:\n\n- Count periods, count colons.\n\n- If periods==3 and colons==0: Check IPv4.\n\n- Else if colons==7 and periods==0: Check IPv6.\n\n- Else return \"Neither\".\n\nCheck IPv4 validation:\n\n- Split by '.' into 4 parts.\n\n- For each part: non-empty, digits only, no leading zeros unless length==1, integer value <=255.\n\nCheck IPv6 validation:\n\n- Split by ':' into 8 parts.\n\n- For each part: length between 1 and 4, characters digits or a-f/A-F.\n\nReturn accordingly.\n\nWe should produce steps for all of these. Let's write pseudo-code steps.\n\nUse arrows: → Step X: ... etc.\n\nDecision steps with Yes→ and No→.\n\nLet's create structure:\n\nStart\n\n→ Step 1: Count periods and colons in queryIP // get number of separators\n\n→ Decision: If periods==3 AND colons==0? // potential IPv4\n\n    Yes → Step 2: Split queryIP by '.' into parts // get four parts\n\n    → Decision: If parts length==4? // must be exactly 4\n\n        Yes → Step 3: For each part p in parts // validate each part\n\n            → Decision: If p empty? // invalid\n\n                No → Step 4: If p contains non-digit? // invalid\n\n                    No → Step 5: If length>1 AND first char '0'? // leading zero\n\n                        No → Step 6: Convert p to integer num\n\n                        → Decision: If num>255? // invalid\n\n                            No → Step 7: Continue to next part\n\n                        No → Step 8: Return \"IPv4\" // after all parts valid\n\n                    No → Step 9: Return \"Neither\" // leading zero invalid\n\n                No → Step 10: Return \"Neither\"\n\n        No → Step 11: Return \"Neither\"\n\n    No → Step 12: Proceed to IPv6 check\n\n→ Decision: If colons==7 AND periods==0? // potential IPv6\n\n    Yes → Step 13: Split queryIP by ':' into parts // get eight parts\n\n    → Decision: If parts length==8? // must be exactly 8\n\n        Yes → Step 14: For each part p in parts // validate each part\n\n            → Decision: If p empty? // invalid\n\n                No → Step 15: If length<1 OR length>4? // invalid\n\n                    No → Step 16: If any char not hex? // invalid\n\n                        No → Step 17: Return \"Neither\"\n\n                No → Step 18: Return \"Neither\"\n\n        No → Step 19: Return \"Neither\"\n\n    No → Step 20: Return \"Neither\"\n\n→ End\n\nBut we need to be careful with indentation and arrows.\n\nBetter structure: Use Decision: ... // comment\n\nYes → ... ; No → ... ; We can indent steps after decision.\n\nLet's produce final answer accordingly.\n\nEnsure each line has code step + space + comment.\n\nLet's format as requested.\n\nWe need to start with Start.\n\nUse arrows \"→\" for steps. Use \"Decision:\" with Yes → and No →.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Count periods = number of '.' in queryIP, colons = number of ':' in queryIP // 獲取分隔符個數\n→ Decision: 如果 periods == 3 且 colons == 0? // 可能為 IPv4\n    Yes → Step 2: Split queryIP by '.' 得到 parts // 取得四個段\n    → Decision: 如果 parts 長度 == 4? // 必須正好四段\n        Yes → Step 3: For 每個 part in parts // 逐段驗證\n            → Decision: 如果 part 為空? // 空段不合法\n                No → Step 4: 如果 part 包含非數字字符? // 必須全為數字\n                    No → Step 5: 如果 part 長度>1 且第一字符為 '0'? // 不能有前導零\n                        No → Step 6: 將 part 轉成整數 num\n                        → Decision: 如果 num > 255? // 整數範圍限制\n                            No → Step 7: 進行下一段的驗證\n                        No → Step 8: Return \"IPv4\" // 所有段均合法\n                    No → Step 9: Return \"Neither\" // 前導零不合法\n                No → Step 10: Return \"Neither\" // 非數字字符\n        No → Step 11: Return \"Neither\" // 段數不為四\n    No → Step 12: // 不是 IPv4，進一步判斷 IPv6\n→ Decision: 如果 colons == 7 且 periods == 0? // 可能為 IPv6\n    Yes → Step 13: Split queryIP by ':' 得到 parts // 取得八個段\n    → Decision: 如果 parts 長度 == 8? // 必須正好八段\n        Yes → Step 14: For 每個 part in parts // 逐段驗證\n            → Decision: 如果 part 為空? // 空段不合法\n                No → Step 15: 如果 part 長度 < 1 或 > 4? // 長度限制\n                    No → Step 16: 如果 part 包含非十六進制字符? // 必須是 0-9、a-f、A-F\n                        No → Step 17: Return \"Neither\" // 非十六進制字符\n                    No → Step 18: Return \"Neither\" // 長度不合法\n                No → Step 19: Return \"Neither\" // 空段\n        No → Step 20: Return \"Neither\" // 段數不為八\n    No → Step 21: Return \"Neither\" // 既不是 IPv4 也不是 IPv6\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validIPAddress(self, queryIP: str) -> str:\n        \"\"\"\n        判斷給定字串 queryIP 是否為有效的 IPv4 或 IPv6 位址。\n        若是 IPv4 回傳 \"IPv4\"，若是 IPv6 回傳 \"IPv6\"，否則回傳 \"Neither\"。\n        \"\"\"\n\n        def isIPv4(s: str) -> bool:\n            parts = s.split('.')\n            if len(parts) != 4:\n                return False\n            for part in parts:\n                # 空字串、非數字、數值超過 255 或前導零（除非只有一位）\n                if not part.isdigit():\n                    return False\n                if not 0 <= int(part) <= 255:\n                    return False\n                if len(part) > 1 and part[0] == '0':\n                    return False\n            return True\n\n        def isIPv6(s: str) -> bool:\n            parts = s.split(':')\n            if len(parts) != 8:\n                return False\n            hexdigits = '0123456789abcdefABCDEF'\n            for part in parts:\n                if not 1 <= len(part) <= 4:\n                    return False\n                if any(c not in hexdigits for c in part):\n                    return False\n            return True\n\n        if queryIP.count('.') == 3 and isIPv4(queryIP):\n            return \"IPv4\"\n        elif queryIP.count(':') == 7 and isIPv6(queryIP):\n            return \"IPv6\"\n        else:\n            return \"Neither\"\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個輸入\n    data = sys.stdin.read().strip()\n\n    # 解析輸入：支援 \"queryIP = \\\"172.16.254.1\\\"\" 或僅輸入 IP 字串\n    queryIP = \"\"\n    if data:\n        # 找出引號中的內容（若有）\n        match = re.search(r'[\"\\']([^\"\\']+)[\"\\']', data)\n        if match:\n            queryIP = match.group(1)\n        else:\n            # 無引號，直接使用整個輸入\n            queryIP = data\n\n    solution = Solution()\n    result = solution.validIPAddress(queryIP)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "queryIP = \"172.16.254.1\"",
          "expected_output": "IPv4",
          "success": true,
          "output": "IPv4"
        },
        {
          "example_index": 1,
          "input": "queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"",
          "expected_output": "IPv6",
          "success": true,
          "output": "IPv6"
        },
        {
          "example_index": 2,
          "input": "queryIP = \"256.256.256.256\"",
          "expected_output": "Neither",
          "success": true,
          "output": "Neither"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode433.json",
    "problem_index_in_file": 0,
    "title": "Minimum Genetic Mutation",
    "description_snippet": "A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step explanation. Use Start, Decision, etc. Provide line-by-line virtual code with comment. Must not output actual code. So produce pseudocode algorithm to find min mutations between two strings using BFS with gene bank set. Provide steps.\n\nLet's design: Start. Step 1: initialize visited set. Step 2: queue with startGene. Step 3: level count = 0. Step 4: while queue not empty. Step 5: for each node in current level. Step 6: if node == endGene return level. Step 7: generate all 8 possible mutations. For each, if in bank and not visited, add to next queue and visited. Step 8: after processing level, level++. After loop return -1.\n\nWe need to format with arrows. Use \"→\" for flow. Use Decision blocks. Use \"Yes →\" etc. Provide comments. Let's produce.\n\nWe need to ensure each line includes a virtual code step and comment. Let's write:\n\nStart // 程式開始\n→ Step 1: 初始化 visited 集合為空 // 用來標記已訪問的基因\n→ Step 2: 初始化 queue 並加入 startGene // BFS 從起始基因開始\n→ Step 3: 初始化 level 為 0 // 代表已完成的突變步數\n→ Decision: queue 是否為空? // 若無基因可探索則結束\n    Yes → End // 未找到終點，返回 -1\n    No  → \n        → Step 4: 取 queue 的長度 count // 代表當前層的基因數量\n        → Step 5: 重複 count 次:\n            → Step 5.1: 取出前置基因 current // 從 queue 取出一個基因\n            → Decision: current 是否等於 endGene? // 檢查是否達到終點\n                Yes → Return level // 返回最小突變數\n                No  → \n                    → Step 5.2: 遍歷 8 個位置 i\n                        → Step 5.3: 對每個位置替換為 'A','C','G','T'\n                            → Step 5.4: 若 newGene 在 bank 且未訪問\n                                Yes → Step 5.5: 加入 newGene 到 queue\n                                No  → \n                                // 不做任何事\n            // 迴圈結束\n        → Step 6: level++ // 結束一層後遞增步數\n        → Step 7: 回到 Decision: queue 是否為空? // 重複 BFS\n→ End // 未找到終點，返回 -1\n\nBut we need to show \"Return -1\" somewhere. At End we need to specify return -1.\n\nBetter to put at End: return -1 // 若無路徑則返回 -1\n\nLet's ensure each line has comment. Use \"→\" arrow. For Decision use indentation. Provide \"Yes →\" and \"No →\" lines. We can incorporate \"→ Step 4\" etc.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 初始化 visited 集合為空 // 用來標記已訪問的基因  \n→ Step 2: 初始化 queue 並加入 startGene // BFS 從起始基因開始  \n→ Step 3: 初始化 level 為 0 // 代表已完成的突變步數  \n→ Decision: queue 是否為空? // 若無基因可探索則結束  \n  Yes → End // 未找到終點，返回 -1  \n  No  →  \n   → Step 4: 取 queue 的長度 count // 代表當前層的基因數量  \n   → Step 5: 重複 count 次  \n    → Step 5.1: 取出前置基因 current // 從 queue 取出一個基因  \n    → Decision: current 是否等於 endGene? // 檢查是否達到終點  \n     Yes → Return level // 返回最小突變數  \n     No  →  \n      → Step 5.2: 遍歷 8 個位置 i  \n       → Step 5.3: 對每個位置替換為 'A','C','G','T'  \n        → Step 5.4: 若 newGene 在 bank 且未訪問  \n         Yes → Step 5.5: 加入 newGene 到 queue // 新基因加入下一層  \n         No  → // 不做任何事  \n      // 迴圈結束  \n    → Step 6: level++ // 結束一層後遞增步數  \n   → Decision: queue 是否為空? // 重複 BFS  \n    Yes → End // 未找到終點，返回 -1  \n    No  → // 回到 Step 4  \nEnd // 程式執行結束，若無路徑則返回 -1",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\ndef parse_input(s: str):\n    \"\"\"\n    從輸入字串中擷取 startGene、endGene 與 bank 的資料。\n    期望的格式為類似：\n        startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]\n    \"\"\"\n    start_match = re.search(r'startGene\\s*=\\s*\"([ACGT]+)\"', s)\n    end_match   = re.search(r'endGene\\s*=\\s*\"([ACGT]+)\"', s)\n    bank_match  = re.search(r'bank\\s*=\\s*\\[([^\\]]*)\\]', s)\n\n    start = start_match.group(1) if start_match else \"\"\n    end   = end_match.group(1)   if end_match   else \"\"\n\n    bank_str = bank_match.group(1) if bank_match else \"\"\n    if not bank_str.strip():\n        bank = []\n    else:\n        # 把 [] 內的字串以逗號分隔，並去除雙引號\n        bank = re.findall(r'\"([ACGT]+)\"', bank_str)\n\n    return start, end, bank\n\ndef min_mutations(start: str, end: str, bank: list) -> int:\n    \"\"\"\n    BFS 方式搜尋最少突變步數。\n    若無法到達 end，回傳 -1。\n    \"\"\"\n    if end not in bank:\n        return -1\n\n    bank_set = set(bank)\n    genes = ['A', 'C', 'G', 'T']\n    queue = deque([(start, 0)])\n    visited = {start}\n\n    while queue:\n        current, steps = queue.popleft()\n        if current == end:\n            return steps\n\n        for i in range(len(current)):\n            for g in genes:\n                if g == current[i]:\n                    continue\n                mutation = current[:i] + g + current[i+1:]\n                if mutation in bank_set and mutation not in visited:\n                    visited.add(mutation)\n                    queue.append((mutation, steps + 1))\n    return -1\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    start_gene, end_gene, bank_list = parse_input(input_data)\n    result = min_mutations(start_gene, end_gene, bank_list)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode168.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Title",
    "description_snippet": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that given integer columnNumber returns Excel column title. Provide step by step virtual code with explanation comments. Use arrow, Start, End, Decision, etc.\n\nWe need to produce pseudo code, not actual code. Each line: \"虛擬碼步驟 [space] // 解釋\".\n\nWe need to think of algorithm: while columnNumber > 0: remainder = (columnNumber - 1) % 26; char = 'A' + remainder; prepend to result; columnNumber = (columnNumber - 1) / 26. End.\n\nThus produce step lines accordingly.\n\nWe should mention initial result empty string. Also handle conversion to char.\n\nLet's produce steps:\n\nStart\n\n→ Step 1: Initialize result = \"\" // 结果字符串为空\n\n→ Step 2: While columnNumber > 0 // 循环直到列号为0\n\n→ Decision: If columnNumber > 0?\n\n→ Yes → Step 3: remainder = (columnNumber - 1) % 26 // 计算余数以得到当前字母\n\n→ Step 4: letter = Char('A' + remainder) // 将余数转换为对应字母\n\n→ Step 5: result = letter + result // 把字母添加到结果前面\n\n→ Step 6: columnNumber = (columnNumber - 1) / 26 // 更新列号\n\n→ No → End // 结束循环\n\nAfter loop, return result.\n\nSo we need Start, End, Decision. Also maybe Step: Return result.\n\nLet's format accordingly.\n\nAlso we may need to show arrow for each line, maybe use indentation for Decision branches.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: result ← \"\" // 初始化結果字串為空\n\n→ Decision: columnNumber > 0? // 判斷列號是否還大於0\n\n    Yes → Step 2: remainder ← (columnNumber - 1) % 26 // 取得餘數\n\n    → Step 3: letter ← Char('A' + remainder) // 轉換為字母\n\n    → Step 4: result ← letter + result // 前置字母到結果\n\n    → Step 5: columnNumber ← (columnNumber - 1) / 26 // 更新列號\n\n    No  → End // 完成轉換\n\n→ Step 6: Return result // 回傳 Excel 標題\n\nBut we need to ensure indentation for branches. Use the example: Decision: ... ; Yes → Step ; No → Decision: etc. So for this we can do:\n\n→ Decision: columnNumber > 0? // 判斷列號是否還大於0\n\n    Yes → Step 2: remainder ← (columnNumber - 1) % 26 // 取得餘數\n\n    Yes → Step 3: letter ← Char('A' + remainder) // 轉換為字母\n\n    Yes → Step 4: result ← letter + result // 前置字母到結果\n\n    Yes → Step 5: columnNumber ← (columnNumber - 1) / 26 // 更新列號\n\n    No  → End // 完成轉換\n\nBut each Yes branch leads to next Step, but we can keep them in sequential order under Yes branch. The example had only one Yes branch with multiple steps, but they used nested decisions. However it's okay to list sequential steps under Yes. The example shows:\n\nDecision: ...\n    Yes → Step ...\n    No → Decision: ...\n\nBut if we have multiple steps, we might need nested decisions or just keep them under the same Yes. It might be better to nest: Decision: columnNumber > 0? ; Yes → Step 2; Step 3; Step 4; Step 5; No → End.\n\nAlternatively we can do: while loop represented as repeated decisions.\n\nProbably simplest: Use a loop structure: While (columnNumber > 0) -> Steps inside. But we don't have While in example, but we can approximate with Decision repeated.\n\nLet's create:\n\nStart\n\n→ Step 1: result ← \"\" // 初始化\n\n→ Decision: columnNumber > 0? // 判斷是否需要繼續\n\n    Yes → Step 2: remainder ← (columnNumber - 1) % 26 // 取餘\n\n    Yes → Step 3: letter ← Char('A' + remainder) // 轉字母\n\n    Yes → Step 4: result ← letter + result // 前置\n\n    Yes → Step 5: columnNumber ← (columnNumber - 1) / 26 // 更新\n\n    Yes → Decision: columnNumber > 0? // 重複循環\n\n        Yes → ... (repeat Steps 2-5) ?\n\nBut that's complicated.\n\nMaybe use While structure: We can use \"While columnNumber > 0:\" but not given.\n\nBetter: Use recursion? Eh.\n\nSimpler: Represent algorithm as while loop: use a pseudo-code representation with \"While columnNumber > 0\" but the example didn't show that. But we can still.\n\nWe can output:\n\nStart\n\n→ Step 1: result ← \"\" // 初始化結果字串\n\n→ While columnNumber > 0 // 循環直到列號為0\n\n    → Step 2: remainder ← (columnNumber - 1) % 26 // 取得餘數\n\n    → Step 3: letter ← Char('A' + remainder) // 轉為字母\n\n    → Step 4: result ← letter + result // 將字母加到結果前面\n\n    → Step 5: columnNumber ← (columnNumber - 1) / 26 // 更新列號\n\n→ End // 循環結束\n\n→ Step 6: Return result // 回傳最終標題\n\nBut we need arrow: \"While\" not defined but we can use \"While\". Or we can use \"Decision\" to simulate loop.\n\nWe need to use arrow \"→\" before each step. Indent inside while maybe.\n\nLet's produce final answer with this structure.\n\nAlso need to use \"虛擬碼步驟\" phrase? Actually requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So we just provide the pseudo code step.\n\nThus final output:\n\n```\nStart // 程式開始執行\n→ Step 1: result ← \"\" // 初始化結果字串為空\n→ While columnNumber > 0 // 若列號還大於0則進入循環\n    → Step 2: remainder ← (columnNumber - 1) % 26 // 取得當前字母的索引\n    → Step 3: letter ← Char('A' + remainder) // 將索引轉為字母\n    → Step 4: result ← letter + result // 將字母加到結果前面\n    → Step 5: columnNumber ← (columnNumber - 1) / 26 // 更新列號為下一輪的基數\n→ End // 循環結束\n→ Step 6: Return result // 回傳完成的 Excel 標題\n```\n\nBut we need to keep arrow \"→\" before each line; the while line maybe start with arrow and indent? The example indent uses 4 spaces for inner lines.\n\nSo final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: result ← \"\" // 初始化結果字串為空\n→ While columnNumber > 0 // 若列號還大於0則進入循環\n    → Step 2: remainder ← (columnNumber - 1) % 26 // 取得當前字母的索引\n    → Step 3: letter ← Char('A' + remainder) // 將索引轉為字母\n    → Step 4: result ← letter + result // 將字母加到結果前面\n    → Step 5: columnNumber ← (columnNumber - 1) / 26 // 更新列號為下一輪的基數\n→ End // 循環結束\n→ Step 6: Return result // 回傳完成的 Excel 標題",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        \"\"\"將整數轉換為 Excel 欄位標題。\"\"\"\n        res = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            res = chr(columnNumber % 26 + ord(\"A\")) + res\n            columnNumber //= 26\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有資料\n    data = sys.stdin.read()\n    # 從文字中抓取第一個出現的數字\n    match = re.search(r\"\\d+\", data)\n    if match:\n        n = int(match.group())\n    else:\n        n = 0  # 若找不到數字，視為 0\n\n    sol = Solution()\n    title = sol.convertToTitle(n)\n    # 將結果包在雙引號中輸出\n    print(f'\"{title}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnNumber = 1",
          "expected_output": "\"A\"",
          "success": true,
          "output": "\"A\""
        },
        {
          "example_index": 1,
          "input": "columnNumber = 28",
          "expected_output": "\"AB\"",
          "success": true,
          "output": "\"AB\""
        },
        {
          "example_index": 2,
          "input": "columnNumber = 701",
          "expected_output": "\"ZY\"",
          "success": true,
          "output": "\"ZY\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode23.json",
    "problem_index_in_file": 0,
    "title": "Merge k Sorted Lists",
    "description_snippet": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerg...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step, for merging k sorted linked lists into one sorted linked list. Use virtual code with arrows, decisions, etc. Not actual code. Must be line by line, each line with code step + // explanation. Use Start, End, Decision. So we need to outline algorithm, maybe use priority queue (min-heap). Or we could use divide and conquer. Let's choose min-heap approach. Outline: initialize min-heap with first node of each list if not null. Initialize dummy head. While heap not empty: pop smallest node, attach to result, if popped node has next, push next into heap. End. Return dummy.next. Provide steps.\n\nWe need to show virtual code with arrow syntax: \"→ Step 1: ...\" etc. Use Decision nodes for condition checks.\n\nWe'll produce a list:\n\nStart\n→ Step 1: Create min-heap H // 用於存放當前每個鏈表頭\n→ Step 2: For each linked-list L in lists: If L not null, insert L into H // 把所有非空頭節點加入堆\n→ Step 3: Create dummy node dummy, set tail = dummy // 用於構造結果鏈表\n→ Decision: 是否 H 為空? // 判斷堆是否還有節點\n    Yes → End // 堆空時完成\n    No → \n        → Step 4: pop min node node from H // 取最小節點\n        → Step 5: tail.next = node // 把 node 加到結果鏈表\n        → Step 6: tail = node // 更新 tail\n        → Decision: node.next 不為 null? // 看此節點是否有後續\n            Yes → Step 7: insert node.next into H // 把後續節點加入堆\n            No  → Step 8: // 不做任何操作\n        → Decision: H 為空? // 再次檢查堆\n            Yes → Step 9: Return dummy.next // 返回合併後的鏈表\n            No  → 重複上述流程 // 回到 Step 4\n\nBut we need to use arrows properly: Each line starts with \"→\" maybe for steps, \"Decision:\" lines.\n\nWe must use \"Start\" and \"End\".\n\nWe need to produce line-by-line.\n\nLet's produce more formal:\n\nStart // 程式開始執行\n→ Step 1: 初始化空最小堆 H // 用於儲存各鏈表當前節點\n→ Step 2: 遍歷 lists：若 L 非空，將 L 插入 H // 把每個鏈表的頭節點加入堆\n→ Step 3: 建立 dummy 頭節點，設 tail = dummy // 用於組裝結果鏈表\n→ Decision: H 是否為空？ // 判斷是否已經沒有節點可以處理\n    Yes → End // 堆空，合併完成\n    No  → \n        → Step 4: 從 H 取出最小節點 minNode // 獲取當前所有頭節點中最小的\n        → Step 5: tail.next = minNode // 把 minNode 加入結果鏈表\n        → Step 6: tail = minNode // 更新 tail 指針\n        → Decision: minNode.next 是否存在？ // 檢查此節點是否還有後續\n            Yes → Step 7: 把 minNode.next 插入 H // 把後續節點加入堆\n            No  → // 不執行任何操作\n        → Decision: H 是否為空？ // 再次判斷堆是否還有節點\n            Yes → Step 8: 返回 dummy.next // 合併完成，返回結果鏈表\n            No  → Step 9: 重複步驟 4-8 // 繼續處理下一個最小節點\nEnd // 程式結束\n\nBut we need each line to have arrow? The decision lines don't have arrow. Format: \"Decision:\" lines. The example uses \"Decision:\" with indentation.\n\nThe steps after decision need indentation maybe? The example shows:\n\nDecision: 如果數字大於 0? \n    Yes → Step 2: ...\n    No  → Decision: ...\n\nSo we should mimic that.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 建立空的最小堆 H // 用於存放各鏈表的當前節點\n→ Step 2: 遍歷 lists，對每個鏈表 L：若 L 不為空，將 L 插入 H // 初始化堆\n→ Step 3: 建立 dummy 頭節點，設 tail = dummy // 用於構造合併後的鏈表\n→ Decision: 堆 H 是否為空？ // 判斷是否還有節點可處理\n    Yes → End // 堆空，合併完成\n    No  → \n        → Step 4: 從 H 中取出最小節點 minNode // 取得最小的當前節點\n        → Step 5: tail.next = minNode // 把 minNode 加入結果鏈表\n        → Step 6: tail = minNode // 更新尾指針\n        → Decision: minNode.next 是否存在？ // 檢查是否有後續節點\n            Yes → Step 7: 把 minNode.next 插入 H // 把後續節點加入堆\n            No  → // 沒有後續節點，跳過\n        → Decision: 堆 H 是否為空？ // 再次檢查堆\n            Yes → Step 8: 返回 dummy.next // 合併完成，返回結果鏈表\n            No  → Step 9: 重複執行 步驟 4-8 // 繼續下一輪\n\nEnd // 程式結束\n\nBut we need to keep each line with \"→\" for steps, \"Decision:\" lines no arrow. Also we might need to include \"→\" for Step 9 as part of loop. After Step 9 we may need to loop back to Step 4. We can indicate with \"→ Step 4\" maybe. But typical pseudocode uses \"→\" for each step and decisions for branches. The example uses \"→ Decision:\" to show sub steps. So we can create a loop by referencing step numbers. Let's write Step 9 as \"→ Step 4\" or \"→ 重複步驟 4-8\" which is a loop. Let's write:\n\n→ Step 9: 回到 Step 4 // 重複處理下一個最小節點\n\nBut the example uses \"→ Decision: ... Yes → Step ... No → Decision: ...\" So we need to indent inside decisions.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空的最小堆 H // 用於存放各鏈表的當前節點\n→ Step 2: 遍歷 lists，對每個鏈表 L：若 L 不為空，將 L 插入 H // 初始化堆\n→ Step 3: 建立 dummy 頭節點，設 tail = dummy // 用於構造合併後的鏈表\n→ Decision: 堆 H 是否為空？ // 判斷是否還有節點可處理\n    Yes → End // 堆空，合併完成\n    No  → \n        → Step 4: 從 H 中取出最小節點 minNode // 取得最小的當前節點\n        → Step 5: tail.next = minNode // 把 minNode 加入結果鏈表\n        → Step 6: tail = minNode // 更新尾指針\n        → Decision: minNode.next 是否存在？ // 檢查是否有後續節點\n            Yes → Step 7: 把 minNode.next 插入 H // 把後續節點加入堆\n            No  → // 沒有後續節點，跳過\n        → Decision: 堆 H 是否為空？ // 再次檢查堆\n            Yes → Step 8: 返回 dummy.next // 合併完成，返回結果鏈表\n            No  → Step 9: 回到 Step 4 // 重複處理下一個最小節點\nEnd // 程式結束",
      "generated_code": "import sys\nimport heapq\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists):\n        \"\"\"Merge k sorted linked lists into one sorted linked list.\"\"\"\n        if not lists:\n            return None\n\n        # Min-heap that stores tuples of (node value, counter, node)\n        heap = []\n        counter = 0  # unique counter to avoid comparison of ListNode when values equal\n\n        # Initialize heap with the head of each list\n        for node in lists:\n            if node:\n                heapq.heappush(heap, (node.val, counter, node))\n                counter += 1\n\n        dummy = ListNode()\n        tail = dummy\n\n        while heap:\n            val, _, node = heapq.heappop(heap)\n            tail.next = node\n            tail = node\n            if node.next:\n                heapq.heappush(heap, (node.next.val, counter, node.next))\n                counter += 1\n\n        return dummy.next\n\ndef build_linked_list(values):\n    \"\"\"Convert a Python list into a linked list.\"\"\"\n    dummy = ListNode()\n    current = dummy\n    for v in values:\n        current.next = ListNode(v)\n        current = current.next\n    return dummy.next\n\ndef linked_list_to_list(node):\n    \"\"\"Convert a linked list back into a Python list.\"\"\"\n    result = []\n    while node:\n        result.append(node.val)\n        node = node.next\n    return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Expected format: 'lists = [[...], [...], ...]'\n    _, _, rhs = data.partition('=')\n    rhs = rhs.strip()\n    try:\n        raw_lists = eval(rhs, {})\n    except Exception:\n        raw_lists = []\n\n    # Build linked lists from the parsed Python lists\n    linked_lists = []\n    for sublist in raw_lists:\n        if isinstance(sublist, list) and sublist:\n            linked_lists.append(build_linked_list(sublist))\n        else:\n            linked_lists.append(None)\n\n    solution = Solution()\n    merged_head = solution.mergeKLists(linked_lists)\n    result = linked_list_to_list(merged_head)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
          "expected_output": "[1,1,2,3,4,4,5,6]",
          "success": true,
          "output": "[1, 1, 2, 3, 4, 4, 5, 6]"
        },
        {
          "example_index": 1,
          "input": "lists = []",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "lists = [[]]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode295.json",
    "problem_index_in_file": 0,
    "title": "Find Median from Data Stream",
    "description_snippet": "The median is the middle value in an ordered integer list. If the size of the list is even, there is...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for implementing MedianFinder class with methods addNum and findMedian. Must use virtual code with arrows and decisions. Each line: \"虛擬碼步驟 // 解釋\". We need to design algorithm. Typically use two heaps: max heap for lower half, min heap for upper half. Steps: initialize two heaps. addNum: if maxHeap empty or num <= maxHeap.peek => push to maxHeap else push to minHeap. Then balance: if maxHeap size > minHeap size + 1 => pop from maxHeap push to minHeap; if minHeap size > maxHeap size => pop from minHeap push to maxHeap. findMedian: if sizes equal, median = (maxHeap.peek + minHeap.peek)/2; else median = maxHeap.peek. We need to represent these in virtual code steps. Each step can be labeled as Step x. Provide decisions. Use arrows for transitions. Probably start with Start, then initialize, then decisions for each operation.\n\nWe need to produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義兩個堆：maxHeap, minHeap // 用於分別存儲左半和右半的數值\n→ Step 2: 以空堆初始化 maxHeap, minHeap // 準備接收數字\nThen for addNum: maybe a function block. But virtual code is line-by-line. We might represent a function definition step: \"Function addNum(num)\" then arrow lines inside. Similarly for findMedian.\n\nBetter to structure as:\n\n→ Function addNum(num): // 定義 addNum 方法\n    → Decision: maxHeap 空或 num <= maxHeap.peek? // 判斷 num 放在哪個堆\n        Yes → Step: maxHeap.push(num) // 放入左半堆\n        No  → Step: minHeap.push(num) // 放入右半堆\n    → Decision: maxHeap.size > minHeap.size + 1? // 平衡左堆是否過大\n        Yes → Step: minHeap.push(maxHeap.pop()) // 移動最大值到右堆\n    → Decision: minHeap.size > maxHeap.size? // 平衡右堆是否過大\n        Yes → Step: maxHeap.push(minHeap.pop()) // 移動最小值到左堆\n\n→ Function findMedian(): // 定義 findMedian 方法\n    → Decision: maxHeap.size == minHeap.size? // 是否兩堆大小相等\n        Yes → Step: median = (maxHeap.peek + minHeap.peek) / 2.0 // 計算平均\n        No  → Step: median = maxHeap.peek // 左堆多一個時取其最大值\n    → Step: return median\n\nBut we need to include \"End\" at the end. Maybe include End for each function? Or just End at program end. They might want End after functions, or after all.\n\nBetter to include End after findMedian or after each function? Not necessary, but we can add End for overall algorithm.\n\nAlso, we need to ensure each line ends with // 解釋. Use \"虛擬碼步驟\" as we wrote.\n\nWe should produce final output lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義兩個堆：maxHeap, minHeap // 用於分別存儲左半（較小值）與右半（較大值）的數字\n→ Step 2: 以空堆初始化 maxHeap, minHeap // 準備接收流中的數字\n\n→ Function addNum(num) // 定義 addNum 方法\n    → Decision: maxHeap 為空 或 num ≤ maxHeap.peek()? // 判斷 num 應放入左堆還是右堆\n        Yes → Step 3: maxHeap.push(num) // 放入左堆（較小的一半）\n        No  → Step 4: minHeap.push(num) // 放入右堆（較大的一半）\n    → Decision: maxHeap.size > minHeap.size + 1? // 左堆是否過大，需要平衡\n        Yes → Step 5: minHeap.push(maxHeap.pop()) // 將左堆最大值移到右堆\n    → Decision: minHeap.size > maxHeap.size? // 右堆是否過大，需要平衡\n        Yes → Step 6: maxHeap.push(minHeap.pop()) // 將右堆最小值移到左堆\n→ End // addNum 方法結束\n\n→ Function findMedian() // 定義 findMedian 方法\n    → Decision: maxHeap.size == minHeap.size? // 兩堆大小是否相等\n        Yes → Step 7: median = (maxHeap.peek() + minHeap.peek()) / 2.0 // 平均兩中間值\n        No  → Step 8: median = maxHeap.peek() // 左堆多一個時取左堆最大值\n    → Step 9: return median // 返回計算得到的中位數\n→ End // findMedian 方法結束\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport heapq\nimport ast\n\nclass MedianFinder:\n    def __init__(self):\n        # small 用作最大堆，存入負值；large 用作最小堆\n        self.small = []\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # 把數字先放到小堆\n        heapq.heappush(self.small, -num)\n\n        # 若兩堆均非空且小堆最大值大於大堆最小值，則調整\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡兩堆大小\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return float(-self.small[0])\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入包裝成一個元組，便於 literal_eval 解析\n    data = '(' + data + ')'\n    commands, args = ast.literal_eval(data)\n\n    mf = None\n    output = []\n    for cmd, arg in zip(commands, args):\n        if cmd == 'MedianFinder':\n            mf = MedianFinder()\n            output.append(None)\n        elif cmd == 'addNum':\n            mf.addNum(arg[0])\n            output.append(None)\n        elif cmd == 'findMedian':\n            output.append(mf.findMedian())\n        else:\n            # 未知指令，保持 None\n            output.append(None)\n\n    # 使用 json.dumps 以符合題目要求的輸出格式\n    print(json.dumps(output, allow_nan=False))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "success": true,
          "output": "[null, null, null, 1.5, null, 2.0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode352.json",
    "problem_index_in_file": 0,
    "title": "Data Stream as Disjoint Intervals",
    "description_snippet": "Given a data stream input of non-negative integers a_1, a_2, ..., a_n, summarize the numbers seen so...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code line by line with explanation comments, following the arrow syntax. The user demands virtual code for the SummaryRanges class: initialization, addNum, getIntervals. They want step-by-step pseudocode but not actual code, but \"virtual code\". Each line should be \"虛擬碼步驟\" then space then \"// 解釋/說明\". Use arrows like →, Yes →, No →. Use Start, End, Decision:. So we need to provide a pseudocode algorithm for maintaining a summary of non-negative integers as disjoint intervals, supporting addNum and getIntervals. Typically you can maintain a sorted set or map, but we can use a balanced BST or list of intervals. Let's use a list of intervals sorted by start. When adding a number, we need to merge with adjacent intervals if overlapping or adjacent. Steps: find position where value would go; if value is already in an interval, no action; else check left interval's end+1==value to merge; check right interval's start-1==value to merge; merge accordingly.\n\nSo produce pseudocode lines: Start, addNum steps, getIntervals, End. Use Decision steps for conditions.\n\nLet's produce step-by-step pseudocode:\n\nStart // program start\n→ Initialize SummaryRanges: create empty list intervals // store intervals sorted\n→ Function addNum(value):\n    → Decision: Is intervals empty? // if no intervals, create new\n        Yes → Append [value,value] to intervals // new interval\n        No → Find index i where value <= intervals[i].end or between intervals\n            // We need to find potential merge position; use binary search\n            → Decision: Is value already in an existing interval? // check if intervals[i].start <= value <= intervals[i].end\n                Yes → No action // value already present\n                No → Decision: Does value == intervals[i].end + 1? // adjacent to right interval\n                    Yes → Extend intervals[i].end to value // merge with right\n                    No → Decision: Does value == intervals[i-1].end + 1? // adjacent to left\n                        Yes → Extend intervals[i-1].end to value // merge with left\n                        No → Decision: Does value connect left and right intervals? // left end+1==value and right start-1==value\n                            Yes → Merge intervals[i-1] and intervals[i] into one [left.start, right.end] // combine\n                            No → Insert new interval [value,value] at position i // isolated\n→ Function getIntervals:\n    → Return intervals // sorted disjoint intervals\n\nEnd // program end\n\nBut we need arrow syntax: → for sequential. Need nested decision indentation. Use Yes →, No →.\n\nMake sure each line has \"虛擬碼步驟\" then space then comment. Eg:\n\nStart // 程式開始執行\n→ SummaryRanges: intervals ← empty list // 儲存不重疊區間\n→ Function addNum(value): // 新增數值\n    → Decision: intervals 為空? // 判斷是否有區間\n        Yes → Append [value, value] to intervals // 新增單一區間\n        No  → // 處理已有區間\n            → Find position i where value would fit // 用二分搜尋找到插入位置\n            → Decision: value 在 intervals[i] 內? // 檢查是否已存在\n                Yes → // 已存在，無須處理\n                No  → // 尚未存在\n                    → Decision: value == intervals[i].end + 1? // 右側相鄰\n                        Yes → Extend intervals[i].end ← value // 合併右側\n                        No  → Decision: value == intervals[i-1].end + 1? // 左側相鄰\n                            Yes → Extend intervals[i-1].end ← value // 合併左側\n                            No  → Decision: intervals[i-1].end + 1 == value && value == intervals[i].start - 1? // 連結左右\n                                Yes → Merge intervals[i-1] 與 intervals[i] 為 [intervals[i-1].start, intervals[i].end] // 合併三區\n                                No  → Insert [value,value] at position i // 新增獨立區間\n→ Function getIntervals(): // 取得當前區間\n    → Return intervals // 已排序的區間\n\nBut need proper indentation? Use indentation lines. Each line: arrow etc. Let's produce properly formatted.\n\nWe must ensure each line ends with comment after //.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ SummaryRanges: intervals ← 空清單 // 用來儲存已經分組好的不重疊區間  \n\n→ Function addNum(value): // 新增數值至資料流  \n → Decision: intervals 為空? // 是否還沒有任何區間  \n  Yes → Append [value, value] to intervals // 新增一個單獨區間  \n  No  → // 已存在區間，需處理合併或插入  \n   → Find i 使得 intervals[i-1].end < value ≤ intervals[i].start // 用二分搜尋找到插入位置  \n   → Decision: value 在 intervals[i] 內? // 檢查數值是否已存在於某個區間  \n    Yes → // 已存在，無需變更  \n    No  → // 數值尚未出現在任何區間  \n     → Decision: value == intervals[i-1].end + 1? // 與左側區間相鄰  \n      Yes → Extend intervals[i-1].end ← value // 合併左側區間  \n      No  → Decision: value == intervals[i].start - 1? // 與右側區間相鄰  \n       Yes → Extend intervals[i].start ← value // 合併右側區間  \n       No  → Decision: intervals[i-1].end + 1 == value && value == intervals[i].start - 1? // 同時相鄰左右，需合併三個區間  \n        Yes → Merge intervals[i-1] 與 intervals[i] 為 [intervals[i-1].start, intervals[i].end] // 合併左右區間  \n        No  → Insert [value, value] at position i // 建立獨立區間  \n\n→ Function getIntervals(): // 取得目前所有區間  \n → Return intervals // 已按 start 排序的不重疊區間  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass SummaryRanges:\n    \"\"\"維護一個由不重疊區間組成的集合，支援動態插入與查詢。\"\"\"\n\n    def __init__(self):\n        # intervals 按 start 排序，且不重疊\n        self.intervals = []\n\n    def addNum(self, val: int) -> None:\n        \"\"\"將 val 加入集合，必要時合併相鄰或重疊區間。\"\"\"\n        new_interval = [val, val]\n        merged = []\n        placed = False\n\n        for start, end in self.intervals:\n            if end + 1 < val:\n                # 現有區間完全在 val 左側\n                merged.append([start, end])\n            elif val + 1 < start:\n                # 現有區間完全在 val 右側\n                if not placed:\n                    merged.append(new_interval)\n                    placed = True\n                merged.append([start, end])\n            else:\n                # 区间与 val 相邻或重叠，需要合并\n                new_interval[0] = min(start, new_interval[0])\n                new_interval[1] = max(end, new_interval[1])\n\n        if not placed:\n            merged.append(new_interval)\n\n        self.intervals = merged\n\n    def getIntervals(self):\n        \"\"\"回傳目前所有不重疊的區間。\"\"\"\n        return self.intervals\n\ndef main():\n    # 讀取全部輸入，分兩行：命令與參數\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n\n    obj = None\n    outputs = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"SummaryRanges\":\n            obj = SummaryRanges()\n            outputs.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(args[0])\n            outputs.append(None)\n        elif cmd == \"getIntervals\":\n            outputs.append(obj.getIntervals())\n\n    # 使用 json.dumps 使 None 轉為 null，符合範例輸出格式\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "success": true,
          "output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode717.json",
    "problem_index_in_file": 0,
    "title": "1-bit and 2-bit Characters",
    "description_snippet": "We have two special characters:\\n- The first character can be represented by one bit 0.\\n- The secon...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps to solve problem: \"Given binary array bits ends with 0, return true if the last character must be a one-bit character.\" It's Leetcode 717. Steps: start, index = 0, while index < len-1: if bits[index] == 0: index++ else: index+=2. After loop, return true if index == len-1. So produce step-by-step pseudo-code with explanations. Use the required format. Each line: \"虛擬碼步驟 // 解釋\". Use arrow for decisions etc. Use Start, End. Use Decision lines.\n\nLet's craft:\n\nStart\n→ Step 1: 定義 idx = 0 // 初始化索引指向第一位\n→ Decision: 是否已經到最後一個位? (idx == len(bits))? // 檢查是否已經超過陣列結束\n    Yes → End // 直接結束（不會發生）\n    No → Decision: bits[idx] == 0? // 判斷當前位\n        Yes → Step 2: idx = idx + 1 // 一位字符，移動一個\n        No  → Step 3: idx = idx + 2 // 二位字符，移動兩個\n← 回到 Decision: 是否已到最後? 重複\n\nFinally after loop:\n→ Step 4: return (idx == len(bits)-1) // 判斷是否最後一個位正好是未被二位字符佔用\n\nEnd\n\nBut we must format properly with arrows and indentation. In example, they used \"Decision:\" lines with indentation. We need to keep proper indentation. For each step line, we include explanation.\n\nLet's produce output accordingly. Use \"Start\" first line. Use \"End\" last. Indent decisions.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: idx = 0 // 初始索引指向陣列第一位  \n→ Decision: idx == len(bits) ? // 檢查是否已經越過最後一位  \n    Yes → End // 如果已越界，結束程式（理論上不會發生）  \n    No  → Decision: bits[idx] == 0 ? // 判斷目前位是否為一位字符  \n        Yes → Step 2: idx = idx + 1 // 一位字符，索引往後移動一位  \n        No  → Step 3: idx = idx + 2 // 二位字符，索引往後移動兩位  \n← 回到 Decision: idx == len(bits) ? // 重複判斷直到到達最後一位  \n→ Step 4: return idx == len(bits) - 1 // 若索引正好指向最後一位，則最後字符為一位字符  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def isOneBitCharacter(self, bits):\n        i = 0\n        n = len(bits)\n        while i < n - 1:\n            if bits[i] == 1:\n                i += 2\n            else:\n                i += 1\n        return i == n - 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入字串轉成 bits 列表\n    if data.lower().startswith('bits'):\n        # 找到等號並取得後面的列表文字\n        eq_index = data.find('=')\n        if eq_index != -1:\n            bits_str = data[eq_index + 1:].strip()\n        else:\n            bits_str = data\n    else:\n        bits_str = data\n    try:\n        bits = ast.literal_eval(bits_str)\n    except Exception:\n        # 若無法解析，直接退出\n        return\n\n    solution = Solution()\n    result = solution.isOneBitCharacter(bits)\n    # 按題目要求輸出小寫字串\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "bits = [1,0,0]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "bits = [1,1,1,0]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode47.json",
    "problem_index_in_file": 0,
    "title": "Permutations II",
    "description_snippet": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines for algorithm to generate all unique permutations of a list that may contain duplicates. We need to write step-by-step using virtual code with arrows, Start, Decision, etc. Provide brief explanation each line.\n\nWe should include backtracking algorithm, with sorting to handle duplicates. Use visited array. Steps: Start, sort array, initialize result list, define backtrack(current), if length==len(nums) add to result, else iterate i from 0..n-1, if visited[i] skip, if i>0 and nums[i]==nums[i-1] and not visited[i-1] skip to avoid duplicates, else mark visited[i], add nums[i] to current, backtrack, pop, unmark visited. After done, End.\n\nWrite each line as separate virtual code line. Use arrow \"→\" before step lines. For decision blocks, use indentation and Yes→, No→.\n\nWe need to follow format: each line \"虛擬碼步驟 // 解釋\". Use Start and End.\n\nMake sure each line is separate.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: sort nums ascending // 排序以便處理重複元素\n→ Step 2: 初始化 result 為空列表 // 用於儲存所有唯一排列\n→ Step 3: 初始化 visited 為全 False 列表 // 標記元素是否已被使用\n→ Step 4: 定義函式 backtrack(path) // 回溯遞迴，path 為目前構建的排列\n    → Decision: path 長度是否等於 nums 長度? // 判斷是否完成一個排列\n        Yes → Step 5: 將 path 的拷貝加入 result // 完整排列加入結果\n        No  → Step 6: 針對每個索引 i 從 0 到 len(nums)-1 執行\n            → Decision: visited[i] 為 True? // 該位置已被使用\n                Yes → Continue // 跳過已使用的元素\n                No  → Decision: i>0 且 nums[i]==nums[i-1] 且 visited[i-1] 為 False? // 避免重複排列\n                    Yes → Continue // 跳過重複元素\n                    No  → Step 7: visited[i] ← True // 標記元素為已使用\n                    → Step 8: 將 nums[i] 加入 path // 將元素加入目前排列\n                    → Step 9: backtrack(path) // 進一步遞迴\n                    → Step 10: path 從尾部 pop // 撤銷上一步選擇\n                    → Step 11: visited[i] ← False // 解除標記，供其他分支使用\n→ Step 12: 呼叫 backtrack(empty list) // 開始回溯\n→ Step 13: 返回 result // 輸出所有唯一排列\nEnd // 程式執行結束\n\nWe need to keep each line separate, each with \"虛擬碼步驟\" including arrows. But indentation can be done using spaces? The example shows indentation inside Decision blocks. We should follow that style.\n\nWe must ensure each line ends with `// 解釋`. For nested lines, we need to keep arrows preceding each step. In example, they had \"→ Decision:\" line, then indentation with \"Yes →\" lines. So for our code, we follow similar.\n\nThus, output:\n\nStart // 程式開始執行\n→ Step 1: sort(nums) // 排序以便處理重複元素\n→ Step 2: result = [] // 用於儲存所有唯一排列\n→ Step 3: visited = [False] * len(nums) // 標記元素是否已被使用\n→ Step 4: 定義函式 backtrack(path) // 回溯遞迴，path 為目前構建的排列\n    → Decision: len(path) == len(nums) ? // 判斷是否完成一個排列\n        Yes → Step 5: result.append(copy_of(path)) // 完整排列加入結果\n        No  → Step 6: 對於 i in 0 .. len(nums)-1 執行\n            → Decision: visited[i] ? // 該位置已被使用\n                Yes → Continue // 跳過已使用的元素\n                No  → Decision: i > 0 and nums[i] == nums[i-1] and not visited[i-1] ? // 避免重複排列\n                    Yes → Continue // 跳過重複元素\n                    No  → Step 7: visited[i] = True // 標記元素為已使用\n                    → Step 8: path.append(nums[i]) // 將元素加入目前排列\n                    → Step 9: backtrack(path) // 進一步遞迴\n                    → Step 10: path.pop() // 撤銷上一步選擇\n                    → Step 11: visited[i] = False // 解除標記，供其他分支使用\n→ Step 12: backtrack([]) // 開始回溯\n→ Step 13: return result // 輸出所有唯一排列\nEnd // 程式執行結束\n\nBut each line must be separate. For nested, we might indent with spaces before \"→\". In example they had indentation for inner lines: \"→ Decision: ...\" then \"Yes → ...\" etc. So we replicate.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: sort(nums) // 排序以便處理重複元素\n→ Step 2: result = [] // 用於儲存所有唯一排列\n→ Step 3: visited = [False] * len(nums) // 標記元素是否已被使用\n→ Step 4: 定義函式 backtrack(path) // 回溯遞迴，path 為目前構建的排列\n    → Decision: len(path) == len(nums) ? // 判斷是否完成一個排列\n        Yes → Step 5: result.append(copy_of(path)) // 完整排列加入結果\n        No  → Step 6: 對於 i in 0 .. len(nums)-1 執行\n            → Decision: visited[i] ? // 該位置已被使用\n                Yes → Continue // 跳過已使用的元素\n                No  → Decision: i > 0 and nums[i] == nums[i-1] and not visited[i-1] ? // 避免重複排列\n                    Yes → Continue // 跳過重複元素\n                    No  → Step 7: visited[i] = True // 標記元素為已使用\n                    → Step 8: path.append(nums[i]) // 將元素加入目前排列\n                    → Step 9: backtrack(path) // 進一步遞迴\n                    → Step 10: path.pop() // 撤銷上一步選擇\n                    → Step 11: visited[i] = False // 解除標記，供其他分支使用\n→ Step 12: backtrack([]) // 開始回溯\n→ Step 13: return result // 輸出所有唯一排列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        回傳 nums 的所有唯一排列。\n        \"\"\"\n        res: List[List[int]] = []\n        nums.sort()                     # 先排序，方便後續排除重複\n        used: List[bool] = [False] * len(nums)\n\n        def backtrack(path: List[int]) -> None:\n            # 若 path 已經與 nums 長度相同，代表一個完整排列\n            if len(path) == len(nums):\n                res.append(path[:])     # 把 path 的副本加入結果\n                return\n            for i in range(len(nums)):\n                # 已使用的元素跳過\n                if used[i]:\n                    continue\n                # 若元素與前一個相同且前一個未使用，跳過以避免重複排列\n                if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                    continue\n                # 選擇 nums[i]\n                used[i] = True\n                path.append(nums[i])\n                backtrack(path)           # 進一步遞迴\n                path.pop()                # 撤銷選擇\n                used[i] = False\n\n        backtrack([])\n        return res\n\ndef main() -> None:\n    \"\"\"\n    主程式：從標準輸入讀取 list，計算唯一排列，並輸出結果。\n    支援兩種輸入格式：\n        1. 直接給 list，如 [1,1,2]\n        2. 以字串 'nums = [1,1,2]' 的形式\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入\n    if data.startswith(\"nums\"):\n        # 取得 '=' 之後的子字串\n        try:\n            _, expr = data.split(\"=\", 1)\n            nums_str = expr.strip()\n        except ValueError:\n            nums_str = data\n    else:\n        nums_str = data\n\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        # 若解析失敗，直接終止\n        return\n\n    if not isinstance(nums, list):\n        return\n\n    solution = Solution()\n    result = solution.permuteUnique(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "[[1,1,2],[1,2,1],[2,1,1]]",
          "success": true,
          "output": "[[1, 1, 2], [1, 2, 1], [2, 1, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": true,
          "output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode719.json",
    "problem_index_in_file": 0,
    "title": "Find K-th Smallest Pair Distance",
    "description_snippet": "The distance of a pair of integers a and b is defined as the absolute difference between a and b.\\nG...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for the problem: Given array nums, integer k, find k-th smallest distance among all pairs absolute differences.\n\nWe need to produce steps. Probably using binary search over distances, with counting pairs <= mid. We need to produce virtual code line by line with comments. Use arrows and Decision constructs.\n\nLet's craft:\n\nStart\n→ Step 1: Sort nums ascending\n→ Step 2: Initialize left=0, right= max(nums)-min(nums)\n→ Decision: While left<right? etc\n\nBinary search loop: while left<right\n- mid=(left+right)/2\n- count = countPairsLessEqual(nums, mid)\n- Decision: if count < k? left=mid+1 else right=mid\n\nFinally return left\n\nAlso need function countPairsLessEqual: two pointers sliding window to count number of pairs with difference <= mid.\n\nWe need virtual code for that function.\n\nSo produce lines.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: Sort nums in non-decreasing order // 為了方便滑動窗口\n→ Step 2: left ← 0 // 最小可能距離\n→ Step 3: right ← nums[last] - nums[first] // 最大可能距離\n→ Decision: while left < right? // 二分搜尋距離\n    Yes → mid ← (left + right) // 2 // 取中距離\n    → Step 4: count ← countPairs(nums, mid) // 計算距離 ≤ mid 的配對數\n    → Decision: if count < k? // 是否需要更大距離\n        Yes → left ← mid + 1 // 取更大的距離\n        No  → right ← mid // 取更小或相同距離\n    No → End // 迴圈結束\n→ Step 5: return left // 找到第 k 小距離\nEnd // 程式結束\n\nThen function countPairs.\n\nDefine:\n\nFunction countPairs(nums, limit):\n→ Step 1: count ← 0\n→ Step 2: j ← 0\n→ Decision: for i from 0 to nums.length-1?\n   Yes → while j < nums.length and nums[j] - nums[i] ≤ limit? // Move j\n        Yes → j ← j + 1\n        No → Break\n   → count ← count + (j - i - 1) // pairs with i as left index\n→ Step 3: return count\n\nBut need to use virtual code format with arrows and Decision.\n\nLet's write:\n\nFunction countPairs(nums, limit) // Count pairs with difference ≤ limit\n→ Step 1: count ← 0 // 初始化配對數\n→ Step 2: j ← 0 // 右指標\n→ Decision: for i = 0 to nums.length - 1? // 遍歷左指標\n    Yes → Decision: while j < nums.length and nums[j] - nums[i] ≤ limit? // 向右擴大窗口\n        Yes → j ← j + 1 // 移動右指標\n        No  → Break // 不再滿足距離限制\n    → count ← count + (j - i - 1) // 累加可行配對數\n→ Step 3: return count // 回傳總配對數\nEnd // 函式結束\n\nWe might need to adapt formatting: Use → inside function. Provide Explanation.\n\nWe should include Start/End for the function too? Probably not, but we can denote.\n\nMake sure each line ends with // Explanation. Use virtual code arrow at start of line.\n\nWe should keep consistent with required format: \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nThus each line is like: \"→ Step 1: ... // ...\"\n\nAlso we need to include \"Start\" and \"End\" lines for main process and function? Provide Start // 程式開始執行, End // 程式執行結束. For function we may use \"Start\" \"End\" as well, but maybe optional.\n\nBetter to wrap function with \"Function countPairs\" then \"Start\" etc.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort nums in non-decreasing order // 為了方便滑動窗口\n→ Step 2: left ← 0 // 最小可能距離\n→ Step 3: right ← nums[last] - nums[first] // 最大可能距離\n→ Decision: while left < right? // 二分搜尋距離\n    Yes → mid ← (left + right) // 2 // 取中距離\n    → Step 4: count ← countPairs(nums, mid) // 計算距離 ≤ mid 的配對數\n    → Decision: if count < k? // 是否需要更大距離\n        Yes → left ← mid + 1 // 取更大的距離\n        No  → right ← mid // 取更小或相同距離\n    No → End // 迴圈結束\n→ Step 5: return left // 找到第 k 小距離\nEnd // 程式結束\n\nFunction countPairs(nums, limit) // 計算距離 ≤ limit 的配對數\n→ Step 1: count ← 0 // 初始化配對數\n→ Step 2: j ← 0 // 右指標\n→ Decision: for i = 0 to nums.length - 1? // 遍歷左指標\n    Yes → Decision: while j < nums.length and nums[j] - nums[i] ≤ limit? // 向右擴大窗口\n        Yes → j ← j + 1 // 移動右指標\n        No  → Break // 不再滿足距離限制\n    → count ← count + (j - i - 1) // 累加可行配對數\n→ Step 3: return count // 回傳總配對數\nEnd // 函式結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def smallestDistancePair(self, nums, k):\n        nums.sort()\n\n        def count_pairs(mid):\n            count = 0\n            left = 0\n            for right in range(len(nums)):\n                while nums[right] - nums[left] > mid:\n                    left += 1\n                count += right - left\n            return count\n\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            if count_pairs(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef parse_input(data: str):\n    # 找出 nums 列表\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data, re.S)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not k_match:\n        raise ValueError(\"Invalid input format\")\n    nums = ast.literal_eval(nums_match.group(1))\n    k = int(k_match.group(1))\n    return nums, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    ans = Solution().smallestDistancePair(nums, k)\n    print(ans)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,1], k = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1], k = 2",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [1,6,1], k = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode452.json",
    "problem_index_in_file": 0,
    "title": "Minimum Number of Arrows to Burst Balloons",
    "description_snippet": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: find minimum number of arrows to burst all balloons represented by intervals [x_start, x_end]. This is classic \"min number of arrows to burst balloons\" problem solved by sorting intervals by end and greedily picking arrows at end positions. Provide virtual code lines with arrow markers etc.\n\nWe must follow format: each line \"虛擬碼步驟 // 解釋\". Use arrows for decision. Should start with Start, End. Use Decision blocks. Provide lines sequentially.\n\nWe need to consider input: points 2D array. Approach: sort points by x_end ascending. Initialize arrow count 1, last_end = first interval end. For each interval from second to end: if interval.start > last_end then need new arrow: arrow_count++, last_end = interval.end. Else skip. Return arrow_count.\n\nSo produce pseudo-code.\n\nWe need to not produce actual code. Use generic steps. Use arrows like \"→\" for flow.\n\nEnsure each line has virtual code + explanation.\n\nLet's produce:\n\nStart\n→ Step 1: If points is empty, return 0 // handle empty input\n→ Step 2: Sort points by x_end ascending // order intervals by right endpoint\n→ Step 3: Initialize arrows = 1, last_end = points[0].x_end // first arrow at first balloon's end\n→ Step 4: For each interval in points starting from second // iterate through remaining balloons\n    → Decision: if interval.x_start > last_end? // new balloon not covered by current arrow\n        Yes → arrows = arrows + 1 // need new arrow\n        Yes → last_end = interval.x_end // update last_end to this balloon's end\n        No  → // current arrow already covers this balloon, do nothing\n→ Step 5: Return arrows // minimum arrows needed\nEnd\n\nBut we need each line separate. Need to ensure decisions have nested lines with indent.\n\nProbably each line including decision should be separate.\n\nLet's format:\n\nStart // 程式開始\n→ Step 1: 若 points 為空，回傳 0 // 空資料時不需要箭\n→ Step 2: 將 points 依照 x_end 升冪排序 // 以右端點排序\n→ Step 3: 設定 arrows = 1，last_end = points[0].x_end // 第一支箭射向第一個氣球的右端\n→ Step 4: 從 points[1] 開始遍歷每個 interval\n    → Decision: 如果 interval.x_start > last_end? // 未被目前箭射到\n        Yes → arrows = arrows + 1 // 需要新箭\n        Yes → last_end = interval.x_end // 更新最後射擊位置\n        No  → // 目前箭已經能擊中此氣球，跳過\n→ Step 5: 回傳 arrows // 所需最少箭數\nEnd // 程式結束\n\nBut each line should not have indent spaces? Format is flexible. Use the arrow markers.\n\nWe can keep indent for Decision blocks but each line separate. Use \"→\" for arrow and \"Decision:\" lines. Use nested arrows for Yes/No.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 若 points 為空，回傳 0 // 空資料時不需要箭\n→ Step 2: 將 points 依照 x_end 升冪排序 // 以右端點排序\n→ Step 3: 設定 arrows = 1，last_end = points[0].x_end // 第一支箭射向第一個氣球的右端\n→ Step 4: 從 points[1] 開始遍歷每個 interval\n    → Decision: 如果 interval.x_start > last_end? // 未被目前箭射到\n        Yes → arrows = arrows + 1 // 需要新箭\n        Yes → last_end = interval.x_end // 更新最後射擊位置\n        No  → // 目前箭已經能擊中此氣球，跳過\n→ Step 5: 回傳 arrows // 所需最少箭數\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMinArrowShots(self, points):\n        if not points:\n            return 0\n\n        points.sort(key=lambda x: x[1])\n        arrows = 1\n        current_end = points[0][1]\n\n        for start, end in points[1:]:\n            if start > current_end:\n                arrows += 1\n                current_end = end\n\n        return arrows\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list literal after the first '['\n    match = re.search(r'\\[', data)\n    if match:\n        list_str = data[match.start():]\n    else:\n        list_str = '[]'\n\n    # Safely evaluate the list literal\n    try:\n        points = eval(list_str, {\"__builtins__\": None}, {})\n    except Exception:\n        points = []\n\n    solution = Solution()\n    result = solution.findMinArrowShots(points)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,2],[3,4],[5,6],[7,8]]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "points = [[1,2],[2,3],[3,4],[4,5]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode123.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock III",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the i^th day.\n\nFind t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line for the problem of maximum profit with at most two transactions. Need to produce pseudocode with steps and comments. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Decision, Start, End. We must not output actual code, just structure.\n\nWe need to handle array prices, need to compute max profit with at most two transactions.\n\nCommon DP solution: iterate over days, keep track of four variables: first_buy, first_sell, second_buy, second_sell. Or use DP arrays: dp[3][n]. But we can express high-level algorithm.\n\nWe'll write pseudocode:\n\nStart\n→ Step 1: 初始化四個變數: first_buy = -∞, first_sell = 0, second_buy = -∞, second_sell = 0\n→ For each price in prices (i from 0 to n-1):\n    → Update first_buy = max(first_buy, -price)\n    → Update first_sell = max(first_sell, first_buy + price)\n    → Update second_buy = max(second_buy, first_sell - price)\n    → Update second_sell = max(second_sell, second_buy + price)\n→ Step 2: 返回 second_sell as最大收益\nEnd\n\nWe need to explain each step. Also might include Decision to handle when array empty. But keep simple.\n\nWe need to use arrow notation: \"→ Step 1: ...\" etc. Provide explanation after //.\n\nAlso include Decision maybe: If prices empty return 0. But we can include that.\n\nLet's craft.\n\nWill produce:\n\nStart // 程式開始\n→ Decision: 如果 prices 為空? // 檢查是否有股票價格\n    Yes → Step 1: 回傳 0 // 沒有交易可做\n    No  → Step 2: 初始化 first_buy, first_sell, second_buy, second_sell // 設定初始狀態\n→ For i 從 0 到 prices.length-1: // 逐日處理\n    → Step 3: first_buy = max(first_buy, -prices[i]) // 以今日價格買入的最佳成本\n    → Step 4: first_sell = max(first_sell, first_buy + prices[i]) // 完成第一次賣出的最佳利潤\n    → Step 5: second_buy = max(second_buy, first_sell - prices[i]) // 用第一次利潤買入第二次的最佳成本\n    → Step 6: second_sell = max(second_sell, second_buy + prices[i]) // 完成第二次賣出的最佳利潤\n→ Step 7: 回傳 second_sell // 返回最多兩筆交易的最大利潤\nEnd // 程式結束\n\nWe should keep consistent formatting: each line with \"虛擬碼步驟 // 解釋\". Use spaces.\n\nNeed to maintain format: arrow \"→\". For decision we use \"Decision:\" line with indent maybe. Format similar to example: \"Decision: 如果數字大於 0?\" Then indent Yes/No lines.\n\nWe need to produce arrow and then step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 prices 為空? // 檢查是否有股票價格  \n  Yes → Step 1: 回傳 0 // 沒有價格可交易，利潤為 0  \n  No  → Step 2: 初始化 first_buy, first_sell, second_buy, second_sell // 設定初始交易狀態  \n   first_buy = -∞  \n   first_sell = 0  \n   second_buy = -∞  \n   second_sell = 0  \n→ For i 從 0 到 prices.length-1: // 逐日處理價格  \n  Step 3: first_buy = max(first_buy, -prices[i]) // 以今日價格買入的最佳成本  \n  Step 4: first_sell = max(first_sell, first_buy + prices[i]) // 完成第一次賣出的最佳利潤  \n  Step 5: second_buy = max(second_buy, first_sell - prices[i]) // 用第一次利潤買入第二次的最佳成本  \n  Step 6: second_sell = max(second_sell, second_buy + prices[i]) // 完成第二次賣出的最佳利潤  \n→ Step 7: 回傳 second_sell // 返回最多兩筆交易的最大利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_profit(prices):\n    if not prices:\n        return 0\n    buy1 = float('-inf')\n    sell1 = 0\n    buy2 = float('-inf')\n    sell2 = 0\n    for price in prices:\n        buy1 = max(buy1, -price)\n        sell1 = max(sell1, buy1 + price)\n        buy2 = max(buy2, sell1 - price)\n        sell2 = max(sell2, buy2 + price)\n    return sell2\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        sys.exit()\n\n    # Extract the list of prices from input like 'prices = [3,3,5,0,0,3,1,4]'\n    try:\n        start = data.index('[')\n        end = data.rindex(']')\n        prices = ast.literal_eval(data[start:end+1])\n    except Exception:\n        # Fallback: try to parse the whole input directly\n        try:\n            prices = ast.literal_eval(data)\n        except Exception:\n            prices = []\n\n    result = max_profit(prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [3,3,5,0,0,3,1,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode57.json",
    "problem_index_in_file": 0,
    "title": "Insert Interval",
    "description_snippet": "You are given an array of non-overlapping intervals intervals where intervals[i] = [start_i, end_i] ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for merging intervals. Each line with virtual code and comment. Let's design algorithm: given sorted non-overlapping intervals. Insert new interval. Steps: initialize result list. Iterate intervals: if current.end < new.start: append current. else if current.start > new.end: append new, set new to current? Actually we should append remaining intervals after adding new. Approach: result=[], i=0. While i<intervals and intervals[i].end < new.start: add. Then merge overlapping: while i<intervals and intervals[i].start <= new.end: new.start=min(new.start, intervals[i].start), new.end=max(new.end, intervals[i].end), i++. Append new. Then append rest. That's algorithm.\n\nWe need to produce virtual code lines. Use \"Start\", \"→ Step ...\", \"Decision:\" etc. Should not produce actual code.\n\nLet's produce lines: \nStart // 開始\n→ Step 1: 初始化 result 為空列表 // 創建結果容器\n→ Step 2: i ← 0 // 索引初始化\n→ Step 3: 取 newInterval 的 start、end // 新區間的起點終點\n→ Decision: i < len(intervals) AND intervals[i].end < new.start? // 判斷是否前面區間不重疊\n    Yes → Step 4: result.append(intervals[i]) // 加入不重疊的區間\n    Yes → Step 5: i ← i + 1 // 移動到下一個\n    Yes → Jump back to Decision // 重新檢查\n    No → Decision: i < len(intervals) AND intervals[i].start <= new.end? // 判斷是否重疊\n        Yes → Step 6: new.start ← min(new.start, intervals[i].start) // 合併起點\n        Yes → Step 7: new.end ← max(new.end, intervals[i].end) // 合併終點\n        Yes → Step 8: i ← i + 1 // 移動到下一個\n        Yes → Jump back to Decision // 重新檢查\n        No → Step 9: result.append([new.start, new.end]) // 加入合併後的區間\n        No → Decision: i < len(intervals)? // 是否還有剩餘區間\n            Yes → Step 10: result.append(intervals[i]) // 加入剩餘區間\n            Yes → Step 11: i ← i + 1 // 移動\n            Yes → Jump back to Decision // 繼續加入\n            No → End // 完成\nBut we need to be careful to not use \"Jump back to Decision\" syntax; maybe use nested decisions. But requirement: Use \"Decision:\" and arrows. Each step must be line. The flow can be nested.\n\nLet's produce more straightforward: use while loops represented by decisions. Each iteration uses decision and arrows. But need to produce sequential steps.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 建立空列表 result // 存放合併後的區間\n→ Step 2: i ← 0 // 迴圈索引\n→ Step 3: start ← newInterval[0]; end ← newInterval[1] // 取新區間起止\n→ Decision: i < len(intervals) AND intervals[i][1] < start? // 前區間完全在新區間左側\n    Yes → Step 4: result.append(intervals[i]) // 加入左側不重疊區間\n    Yes → Step 5: i ← i + 1 // 移至下一個\n    Yes → Step 6: jump to Decision // 重新判斷\n    No → Decision: i < len(intervals) AND intervals[i][0] <= end? // 前區間與新區間重疊\n        Yes → Step 7: start ← min(start, intervals[i][0]) // 合併起點\n        Yes → Step 8: end ← max(end, intervals[i][1]) // 合併終點\n        Yes → Step 9: i ← i + 1 // 移至下一個\n        Yes → Step 10: jump to Decision // 重新判斷\n        No → Step 11: result.append([start, end]) // 加入合併後區間\n        No → Decision: i < len(intervals)? // 還有剩餘區間\n            Yes → Step 12: result.append(intervals[i]) // 加入剩餘\n            Yes → Step 13: i ← i + 1 // 移動\n            Yes → Step 14: jump to Decision // 繼續\n            No → End // 完成並返回 result\n\nBut \"jump to Decision\" may not be needed; we can just nest decisions accordingly.\n\nMaybe easier: Represent loops as repeated steps with decisions referencing earlier step. But requirement not strict; can show \"→ Decision: ...\" with arrows and nested sub decisions.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 建立空列表 result // 用於存放合併後的區間\n→ Step 2: i ← 0 // 初始化迴圈索引\n→ Step 3: start ← newInterval[0]; end ← newInterval[1] // 取得新區間的起點與終點\n→ Decision: i < len(intervals) AND intervals[i][1] < start? // 前面區間是否完全在新區間左側？\n    Yes → Step 4: result.append(intervals[i]) // 加入不重疊的左側區間\n    Yes → Step 5: i ← i + 1 // 移動到下一個區間\n    Yes → Jump back to Decision // 重新檢查是否還有左側區間\n    No → Decision: i < len(intervals) AND intervals[i][0] <= end? // 是否與新區間重疊？\n        Yes → Step 6: start ← min(start, intervals[i][0]) // 合併起點\n        Yes → Step 7: end ← max(end, intervals[i][1]) // 合併終點\n        Yes → Step 8: i ← i + 1 // 移動到下一個區間\n        Yes → Jump back to Decision // 重新檢查是否還有重疊區間\n        No → Step 9: result.append([start, end]) // 加入已合併的區間\n        No → Decision: i < len(intervals)? // 是否還有剩餘區間？\n            Yes → Step 10: result.append(intervals[i]) // 加入剩餘區間\n            Yes → Step 11: i ← i + 1 // 移動\n            Yes → Jump back to Decision // 繼續加入剩餘區間\n            No → End // 結束，回傳 result\nEnd // 程式執行結束，返回合併後的 intervals 列表",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Insert a new interval into a sorted, non-overlapping list of intervals\n        and merge any overlapping intervals.\n\n        :param intervals: List[List[int]] - existing non-overlapping intervals sorted by start\n        :param newInterval: List[int] - the interval to insert\n        :return: List[List[int]] - merged list of intervals after insertion\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # 1. Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # 2. Merge all intervals that overlap with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # 3. Append the merged interval\n        result.append(newInterval)\n\n        # 4. Append the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n\n    # Find the two list literals in the input\n    # Example input: \"intervals = [[1,3],[6,9]], newInterval = [2,5]\"\n    matches = re.findall(r'\\[.*?\\]', raw_input)\n    if len(matches) != 2:\n        raise ValueError(\"Input format must contain two list literals for intervals and newInterval.\")\n\n    intervals = ast.literal_eval(matches[0])\n    newInterval = ast.literal_eval(matches[1])\n\n    sol = Solution()\n    merged = sol.insert(intervals, newInterval)\n    print(merged)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpiv_r25lw.py\", line 48, in <module>\n    raise ValueError(\"Input format must contain two list literals for intervals and newInterval.\")\nValueError: Input format must contain two list literals for intervals and newInterval."
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp5emks9va.py\", line 48, in <module>\n    raise ValueError(\"Input format must contain two list literals for intervals and newInterval.\")\nValueError: Input format must contain two list literals for intervals and newInterval."
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode592.json",
    "problem_index_in_file": 0,
    "title": "Fraction Addition and Subtraction",
    "description_snippet": "Given a string expression representing an expression of fraction addition and subtraction, return th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for the problem: given a string expression of fraction addition and subtraction, return the calculation result as irreducible fraction string, integer to fraction with denominator 1.\n\nWe must output step by step virtual code lines, each line followed by comment.\n\nWe need to think of algorithm: parse expression into tokens fractions and operators. Fractions like \"1/2\". Operators + or -. Evaluate left to right. Compute numerator and denominator using common denominator, reduce by gcd.\n\nSimpler: iterate through string, parse fraction, maintain current numerator, denominator. For first fraction, set result fraction. For each subsequent operator and fraction: if operator '+', result = addFractions(result, newFraction). If '-', subtract.\n\nAdd fractions: a/b + c/d = (a*d + b*c)/ (b*d). Then reduce.\n\nSubtract: a/b - c/d = (a*d - b*c)/(b*d).\n\nImplement gcd function.\n\nEdge cases: negative numbers? Fractions could be negative? Input may have minus sign preceding fraction: e.g., \"-1/2+3/4\". But maybe only operators between fractions.\n\nSimplify: parse using regex: pattern: [+-]?\\\\d+/\\\\d+. But easier: iterate pointer.\n\nWe produce virtual code lines.\n\nWe should include Start, End. Use Decision.\n\nLet's design steps:\n\nStart\n→ Step 1: Initialize index = 0; input string expr\n→ Step 2: Parse first fraction: read optional sign, numerator digits, '/', denominator digits\n→ Step 3: Set result_num, result_den to parsed fraction\n→ Decision: While index < expr.length\n    → Step 4: Read operator: '+' or '-'\n    → Step 5: Parse next fraction similarly\n    → Decision: If operator == '+'\n        Yes → Step 6: Add fractions: new_num = result_num * denom + result_den * num\n                 new_den = result_den * denom\n        No → Step 7: Subtract fractions: new_num = result_num * denom - result_den * num\n                 new_den = result_den * denom\n    → Step 8: Reduce new_num/new_den by gcd\n    → Step 9: Update result_num, result_den to reduced values\n→ End\n→ Step 10: Return string `${result_num}/${result_den}`\n\nAlso we need gcd function.\n\nWe need to add step for gcd calculation.\n\nAlso need to handle negative fractions.\n\nOk produce virtual code lines.\n\nWe will include comments.\n\nLet's write lines accordingly.\n\nUse arrow for steps: \"Start\", \"→ Step X: ... // comment\". For Decision, include indentation.\n\nMake sure each line has comment after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: index ← 0; expr ← input string // 初始化指標與輸入字串  \n→ Step 2: Read optional sign, numerator digits, '/', denominator digits into num, den // 取得第一個分數  \n→ Step 3: result_num ← num; result_den ← den // 設定初始結果為第一個分數  \n→ Decision: index < expr.length? // 是否還有剩餘字元需要處理  \n    Yes → Step 4: op ← expr[index]; index ← index + 1 // 讀取 '+' 或 '-' 運算符  \n    → Step 5: Read next fraction into num, den // 解析下一個分數  \n    → Decision: op = '+'? // 判斷運算符  \n        Yes → Step 6: temp_num ← result_num * den + result_den * num // 兩分數相加的分子  \n                 temp_den ← result_den * den // 兩分數相加的分母  \n        No  → Step 7: temp_num ← result_num * den - result_den * num // 兩分數相減的分子  \n                 temp_den ← result_den * den // 兩分數相減的分母  \n    → Step 8: g ← gcd(abs(temp_num), temp_den) // 計算最大公因數（分子取絕對值）  \n    → Step 9: result_num ← temp_num / g; result_den ← temp_den / g // 約簡後更新結果  \n→ Decision: index < expr.length? // 重複處理剩餘運算  \n    Yes → back to Step 4  \n    No  → Step 10: output ← `${result_num}/${result_den}` // 結果轉為字串格式  \nEnd // 程式執行結束  \n→ Function gcd(a, b): // 定義求最大公因數的輔助函式  \n    → Decision: b = 0? // 基本情況  \n        Yes → return a  \n        No  → return gcd(b, a mod b) // 递归計算GCD",
      "generated_code": "import sys\nimport re\nfrom fractions import Fraction\n\ndef fraction_addition(expression: str) -> str:\n    \"\"\"\n    Compute the sum/difference of fractions given in `expression`.\n    The result is returned as an irreducible fraction string.\n    \"\"\"\n    # Find all fractions in the expression using regex\n    fractions = re.findall(r'[+-]?\\d+/\\d+', expression)\n    # Sum them using Fraction for automatic reduction\n    result = sum(Fraction(frac) for frac in fractions)\n    return f\"{result.numerator}/{result.denominator}\"\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, extract the expression, compute the result,\n    and print it to stdout.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the expression between quotes after 'expression ='\n    match = re.search(r'expression\\s*=\\s*\"(.*?)\"', data)\n    if match:\n        expression = match.group(1)\n    else:\n        # If quotes are absent, take the whole line after '='\n        parts = data.split('=', 1)\n        expression = parts[1].strip() if len(parts) > 1 else ''\n        expression = expression.strip('\"')\n\n    result = fraction_addition(expression)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"-1/2+1/2\"",
          "expected_output": "0/1",
          "success": true,
          "output": "0/1"
        },
        {
          "example_index": 1,
          "input": "expression = \"-1/2+1/2+1/3\"",
          "expected_output": "1/3",
          "success": true,
          "output": "1/3"
        },
        {
          "example_index": 2,
          "input": "expression = \"1/3-1/2\"",
          "expected_output": "-1/6",
          "success": true,
          "output": "-1/6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode624.json",
    "problem_index_in_file": 0,
    "title": "Maximum Distance in Arrays",
    "description_snippet": "You are given m arrays, where each array is sorted in ascending order.\nYou can pick up two integers ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. Problem: m arrays sorted ascending. Pick two integers from two different arrays (each array picks one) and calculate distance |a-b|. Return maximum distance. So essentially we need to find maximum absolute difference between any two numbers chosen from two different arrays. Since arrays sorted ascending, the maximum difference between any two numbers across arrays is either between max of one array and min of another. So overall maximum distance is max over all pairs of arrays (i,j) with i!=j of |max_i - min_j|. Since arrays sorted, min_i is first element, max_i is last element. So we can compute global min among all arrays and global max among all arrays; but need to ensure they come from different arrays. The maximum distance will be between global max of one array and global min of another array, but if the global max and global min are from same array, we need consider second best. Approach: find top two largest values and top two smallest values among arrays with array indices. Then compute candidate distances between any pair of max/min from different arrays: (max1 - min2), (max2 - min1) maybe also min1 and min2? Actually absolute difference. So we need consider max difference between a from one array and b from another. So distance between a in array i and b in array j. The maximum of |a-b| is max of two possibilities: max_i - min_j or max_j - min_i whichever larger. Since arrays sorted ascending, max_i >= min_i. So for a given pair (i,j), distance = max(max_i - min_j, max_j - min_i). So global maximum is max over all pairs. Equivalent to find the largest max among arrays and smallest min among arrays from different arrays. So compute top two largest max values (with indices) and top two smallest min values (with indices). Then compute candidate distances: if max1 index != min1 index, candidate1 = max1 - min1; else consider max1 - min2 and max2 - min1. Take max of candidates. That gives result. But for virtual code, we don't need to detail all optimization, just high-level steps.\n\nWe should produce virtual code lines. Use Start, Step, Decision, End. Provide explanation per line. We need to keep simple. Use \"→\" to denote steps.\n\nLet's produce:\n\nStart // program start\n→ Step 1: 初始化變數 max1_value, max1_index, max2_value, max2_index, min1_value, min1_index, min2_value, min2_index // 存儲前兩大最大值、前兩小最小值及其陣列索引\n→ Decision: 從第1個陣列取得 min 和 max // 取第一個陣列的最小與最大作為初始值\n    Yes → Step 2: 設定 min1_value, min1_index = min of first array, min1_index = 0\n    No  → Step 3: 設定 min2_value = 無限大, min2_index = -1 // 無需實際操作\n→ Decision: 從第1個陣列取得 max_value, 設定 max1_value, max1_index = max of first array, max1_index = 0\n    No  → Step 4: 設定 max2_value = -無限大, max2_index = -1\n→ Decision: 迭代其餘陣列 i from 1 to m-1\n    Yes → Step 5: 取得陣列 i 的 min_i = 第i個陣列第一個元素， max_i = 第i個陣列最後一個元素\n    → Decision: 更新前兩小最小值\n        Yes → Step 6: 若 min_i < min1_value → 將 min2_value, min2_index = min1_value, min1_index；再將 min1_value, min1_index = min_i, i\n        No  → Decision: 若 min_i < min2_value → Step 7: 將 min2_value, min2_index = min_i, i\n    → Decision: 更新前兩大最大值\n        Yes → Step 8: 若 max_i > max1_value → 將 max2_value, max2_index = max1_value, max1_index；再將 max1_value, max1_index = max_i, i\n        No  → Decision: 若 max_i > max2_value → Step 9: 將 max2_value, max2_index = max_i, i\n→ Step 10: 計算候選距離\n    → Decision: 若 max1_index ≠ min1_index\n        Yes → Step 11: candidate = max1_value - min1_value\n        No  → Step 12: candidate1 = max1_value - min2_value\n               candidate2 = max2_value - min1_value\n               candidate = max(candidate1, candidate2)\n→ Step 13: 返回 candidate // 最大距離\nEnd // 程式結束\n\nBut need to keep each line simple and sequential. We can combine decisions. Provide short explanation. Use arrow syntax. Ensure we follow format: each line \"虛擬碼步驟 [space] // 解釋\". Should be single line per step. Use indentation for decision branches? In example, indentation shown via spaces and lines for each branch. We'll do similar.\n\nWe need to ensure no actual code. Just virtual steps. Should include Start, End, Decision, Step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 max1_value, max1_index, max2_value, max2_index, min1_value, min1_index, min2_value, min2_index // 用於存儲前兩大最大值及前兩小最小值及其陣列索引  \n→ Decision: 從第一個陣列取得 min 與 max // 以第一個陣列作為初始值  \n  Yes → Step 2: 設定 min1_value = 第一個陣列的第一個元素, min1_index = 0 // 初始最小值  \n  No  → Step 3: 設定 min2_value = +∞, min2_index = -1 // 無需實際操作  \n→ Decision: 設定 max1_value = 第一個陣列的最後一個元素, max1_index = 0 // 初始最大值  \n  No  → Step 4: 設定 max2_value = -∞, max2_index = -1  \n→ Decision: 循環處理其餘陣列 i 從 1 到 m-1  \n  Yes → Step 5: 取得陣列 i 的 min_i = 第一個元素, max_i = 最後一個元素 // 每個陣列的最小與最大  \n  → Decision: 更新前兩小最小值  \n   Yes → Step 6: 若 min_i < min1_value  \n         → Step 7: 設定 min2_value, min2_index = min1_value, min1_index  \n         → Step 8: 設定 min1_value, min1_index = min_i, i // min_i 變為最小值  \n  No  → Decision: 若 min_i < min2_value  \n   Yes → Step 9: 設定 min2_value, min2_index = min_i, i // 更新第二小最小值  \n  → Decision: 更新前兩大最大值  \n  Yes → Step 10: 若 max_i > max1_value  \n         → Step 11: 設定 max2_value, max2_index = max1_value, max1_index  \n         → Step 12: 設定 max1_value, max1_index = max_i, i // max_i 變為最大值  \n  No  → Decision: 若 max_i > max2_value  \n  Yes → Step 13: 設定 max2_value, max2_index = max_i, i // 更新第二大最大值  \n→ Step 14: 計算候選距離  \n  → Decision: 若 max1_index ≠ min1_index  \n  Yes → Step 15: candidate = max1_value - min1_value // 直接取最大值與最小值之差  \n  No  → Step 16: candidate1 = max1_value - min2_value // 使用第二小最小值  \n         → Step 17: candidate2 = max2_value - min1_value // 使用第二大最大值  \n         → Step 18: candidate = max(candidate1, candidate2) // 取較大的差值  \n→ Step 19: 返回 candidate // 輸出最大距離  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_distance(arrays):\n    \"\"\"Return the maximum absolute difference between any two numbers chosen from two\n    different sorted arrays.\"\"\"\n    if len(arrays) < 2:\n        return 0\n\n    # Initialise with the first array's extremes\n    min_val = arrays[0][0]\n    max_val = arrays[0][-1]\n    res = 0\n\n    # Iterate over the remaining arrays\n    for arr in arrays[1:]:\n        # Current array's extremes\n        arr_min, arr_max = arr[0], arr[-1]\n        # Update the best distance seen so far\n        res = max(res, abs(arr_max - min_val), abs(max_val - arr_min))\n        # Update the global extremes for subsequent comparisons\n        min_val = min(min_val, arr_min)\n        max_val = max(max_val, arr_max)\n\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Remove any leading variable assignment (e.g., \"arrays = \")\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n\n    # Safely evaluate the expression to get the list of arrays\n    try:\n        arrays = ast.literal_eval(expr.strip())\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        return\n\n    # Ensure we have a list of lists of integers\n    if not isinstance(arrays, list) or any(not isinstance(arr, list) for arr in arrays):\n        print(\"Invalid input format\", file=sys.stderr)\n        return\n\n    result = max_distance(arrays)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arrays = [[1,2,3],[4,5],[1,2,3]]",
          "expected_output": " 4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": " arrays = [[1],[1]]",
          "expected_output": " 0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode20.json",
    "problem_index_in_file": 0,
    "title": "Valid Parentheses",
    "description_snippet": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the in...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line. Provide each line: \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow and structure Start, Decision, End. We need to outline algorithm: use stack, iterate string. For each char, if opening push; if closing check stack top matches; else invalid; after loop, stack empty means valid. Also early exit.\n\nWe must not output actual code, just virtual steps.\n\nLet's produce lines:\n\nStart\n→ Step 1: 初始化空堆疊 // 建立空的資料結構以存放未匹配的開括號\n→ Step 2: 將字串 s 逐字元遍歷 // 逐個檢查每個字符\n    → Decision: 字元是開括號 '(' 或 '[' 或 '{' ?\n        Yes → Step 3: 將開括號推入堆疊 // 堆疊記錄未匹配的開括號\n        No  → Step 4: 字元是關閉括號 ')' 或 ']' 或 '}' ?\n            Yes → Step 5: 判斷堆疊是否為空？\n                Yes → Step 6: 設定結果為 False 並跳出迴圈 // 無開括號可匹配\n                No  → Step 7: 取出堆疊頂部開括號 // 檢查最近的未匹配開括號\n                    → Decision: 類型是否與當前關閉括號相符？\n                        Yes → Step 8: 移除堆疊頂部 // 成功匹配，移除\n                        No  → Step 9: 設定結果為 False 並跳出迴圈 // 類型不符\n            No  → Step 10: 設定結果為 False 並跳出迴圈 // 字元不是合法括號\n→ Step 11: 迴圈結束後判斷堆疊是否為空？\n    Yes → Step 12: 設定結果為 True // 所有括號都已匹配\n    No  → Step 13: 設定結果為 False // 仍有未匹配的開括號\nEnd // 程式執行結束\n\nBut need to align to structure: Use Decision: etc. Use arrow. Ensure each line includes \"虛擬碼步驟\" and comment. Let's produce accordingly. Use arrows like \"→\". For decisions: \"Decision:\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空堆疊 // 建立空的資料結構以存放未匹配的開括號  \n→ Step 2: 逐字元遍歷字串 s // 逐個檢查每個字符  \n&nbsp;&nbsp;Decision: 字元是開括號 '(' 或 '[' 或 '{'？ // 判斷是否為開括號  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: 將開括號推入堆疊 // 堆疊記錄未匹配的開括號  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: 字元是關閉括號 ')' 或 ']' 或 '}'？ // 判斷是否為關閉括號  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: 判斷堆疊是否為空？ // 檢查是否有可匹配的開括號  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: 設定結果為 False 並跳出迴圈 // 無開括號可匹配  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step 6: 取出堆疊頂部開括號 // 檢查最近的未匹配開括號  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decision: 類型是否與當前關閉括號相符？ // 比對括號類型  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 7: 移除堆疊頂部 // 成功匹配，移除  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step 8: 設定結果為 False 並跳出迴圈 // 類型不符  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step 9: 設定結果為 False 並跳出迴圈 // 字元不是合法括號  \n→ Step 10: 迴圈結束後判斷堆疊是否為空？ // 檢查是否還有未匹配的開括號  \n&nbsp;&nbsp;Yes → Step 11: 設定結果為 True // 所有括號都已匹配  \n&nbsp;&nbsp;No → Step 12: 設定結果為 False // 仍有未匹配的開括號  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"Check if the parentheses string s is valid.\"\"\"\n        stack = []\n        mapping = {')': '(', '}': '{', ']': '['}\n\n        for char in s:\n            if char in mapping:\n                # If stack is empty, use a dummy character\n                top = stack.pop() if stack else '#'\n                if mapping[char] != top:\n                    return False\n            else:\n                # Opening bracket, push onto stack\n                stack.append(char)\n        # Valid if no unmatched opening brackets remain\n        return not stack\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    Parse the raw input which may be in the form:\n    s = \"()\", or simply \"()\".\n    Return the extracted string.\n    \"\"\"\n    raw = raw.strip()\n    # Try to find quoted substring\n    start = raw.find('\"')\n    end = raw.rfind('\"')\n    if start != -1 and end != -1 and end > start:\n        return raw[start + 1:end]\n    # If no quotes, strip any leading 's =' and surrounding whitespace\n    if raw.lower().startswith('s ='):\n        raw = raw[3:].strip()\n    # Remove any surrounding quotes or single quotes\n    raw = raw.strip('\"').strip(\"'\")\n    return raw\n\nif __name__ == \"__main__\":\n    # Read all data from stdin\n    raw_input = sys.stdin.read()\n    # Extract the string to validate\n    s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.isValid(s)\n    # Print lowercase 'true' or 'false'\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"()[]{}\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"(]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 3,
          "input": "s = \"([])\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 4,
          "input": "s = \"([)]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode204.json",
    "problem_index_in_file": 0,
    "title": "Count Primes",
    "description_snippet": "Given an integer n, return the number of prime numbers that are strictly less than n....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Provide explanation. It's about counting primes less than n. So algorithm: generate boolean array of size n, sieve of Eratosthenes, count. So virtual steps. Provide step for initialization, marking composites, counting. Use Start, End, Decision.\n\nWe should be careful to use the format: each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use \"Decision:\" for conditions. For loops, maybe use \"Loop:\" with index. Use \"End\". Provide lines: Start, Input n, Create array isPrime[0..n-1] all true, set 0 and 1 false, Loop i from 2 to sqrt(n-1), if isPrime[i] then mark multiples j from i*i to n-1 step i set false, After loop, count primes by Loop j from 2 to n-1 if isPrime[j] count++. Output count, End.\n\nWe need to output each step line with explanation. Use \"Decision:\" for checking if n <=2 maybe? But we can incorporate.\n\nLet's craft:\n\nStart // 程式開始\n→ Input n // 取得目標上界\n→ Decision: n <= 2? // 如果 n <= 2 則沒有小於 n 的素數\n    Yes → Output 0 // 沒有素數\n    No  → Step 1: 初始化布林陣列 isPrime[0..n-1] 為 true // 建立素數標記\n→ Step 2: Set isPrime[0] = false, isPrime[1] = false // 0 和 1 不是素數\n→ Step 3: Loop i from 2 to floor(sqrt(n-1)) // 執行 Eratosthenes 標記\n→     Decision: isPrime[i] 為 true? // 只對尚未標記為合數的 i 進行\n→         Yes → Loop j from i*i to n-1 step i // 標記所有 i 的倍數為非素數\n→             Decision: j < n? // 保證索引合法\n→                 Yes → isPrime[j] = false\n→                 No → Break\n→ End Loop j\n→ End Loop i\n→ Step 4: count = 0 // 初始化計數\n→ Loop k from 2 to n-1 // 遍歷所有可能的素數\n→     Decision: isPrime[k] 為 true? // 判斷是否為素數\n→         Yes → count = count + 1 // 累加\n→ End Loop k\n→ Output count // 回傳結果\nEnd // 程式執行結束\n\nBut we must ensure each line only one step, not nested loops in one line. We may need separate lines for loop start and loop body? Use \"Loop:\" structure maybe: \"Loop: i=2 to floor(sqrt(n-1))\" and inside we have \"Decision: ...\" etc. We'll keep arrow and indent? The example uses indentation for branches. We'll replicate.\n\nThus final output lines with explanation. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 取得使用者輸入的上界  \n→ Decision: n <= 2? // 若上界小於等於 2，則沒有小於 n 的素數  \n  Yes → Output 0 // 直接輸出 0，結束程序  \n  No  → Step 1: 初始化布林陣列 isPrime[0 .. n-1] 為 true // 建立素數標記陣列  \n→ Step 2: Set isPrime[0] = false, isPrime[1] = false // 0 與 1 不是素數  \n→ Step 3: Loop i = 2 to floor(sqrt(n-1)) // 執行埃拉托斯特尼篩法的主迴圈  \n  Decision: isPrime[i] 為 true? // 只對未被標記為合數的 i 進行後續操作  \n   Yes → Loop j = i*i to n-1 step i // 將 i 的所有倍數標記為非素數  \n    Decision: j < n? // 確保索引不越界  \n     Yes → Set isPrime[j] = false // 標記合數  \n     No → Break // 超出範圍時結束內層迴圈  \n   End Loop j  \n  No → Continue // 若 i 本身已非素數，跳過此 i 的標記  \n→ End Loop i  \n→ Step 4: count = 0 // 初始化素數計數  \n→ Loop k = 2 to n-1 // 遍歷所有小於 n 的數字  \n  Decision: isPrime[k] 為 true? // 判斷是否為素數  \n   Yes → count = count + 1 // 累加計數  \n→ End Loop k  \n→ Output count // 回傳小於 n 的素數個數  \nEnd // 程式執行結束",
      "generated_code": "import sys, re\n\ndef count_primes(n):\n    if n <= 2:\n        return 0\n    is_prime = [True]*n\n    is_prime[0] = is_prime[1] = False\n    limit = int(n**0.5)+1\n    for i in range(2, limit):\n        if is_prime[i]:\n            step = i\n            start = i*i\n            for j in range(start, n, step):\n                is_prime[j] = False\n    return sum(is_prime)\n\ndef main():\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = count_primes(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode264.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number II",
    "description_snippet": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. \n\nGiven an inte...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Ugly numbers sequence. Classic DP with three pointers or min-heap. We just output virtual steps. Provide step by step logic. Use Start, Decision etc. Provide explanation comments after each line. Let's produce a straightforward algorithm: Use arrays, indices i2,i3,i5. Count up to n. Complexity O(n). We'll produce pseudocode.\n\nWe need to include steps: Start, input n, initialize array ugly[1..n] =1, i2=i3=i5=1, next2=2, next3=3, next5=5, for idx from 2 to n: next_ugly = min(next2,next3,next5); ugly[idx] = next_ugly; if next_ugly==next2: i2++ ; next2 = ugly[i2]*2; similarly for 3 and 5. After loop return ugly[n]. End.\n\nWe need to provide explanation per line.\n\nLet's format accordingly.\n\nUse virtual arrows and indent. Let's produce.\n\nAlso we may add Decision for equality check. We need to reflect that we check if next_ugly equals next2, etc.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Input n // 取得使用者欲查找的第 n 個丑數\n→ 初始化：ugly[1] ← 1 // 第一個丑數為 1\n→ i2 ← 1 ; i3 ← 1 ; i5 ← 1 // 三個指標分別指向 2、3、5 的乘數位置\n→ next2 ← 2 ; next3 ← 3 ; next5 ← 5 // 初始候選丑數\n→ Decision: n = 1? // 檢查是否只需要第一個丑數\n    Yes → Return ugly[1] // 直接回傳 1\n    No  → → // 進行以下迴圈找出剩餘丑數\n→ For idx ← 2 to n Do // 逐一計算第 2 到第 n 個丑數\n    → next_ugly ← min(next2, next3, next5) // 取三個候選值中的最小者\n    → ugly[idx] ← next_ugly // 將最小值存入丑數序列\n    → Decision: next_ugly = next2? // 判斷是否與 2 的候選值相同\n        Yes → i2 ← i2 + 1 ; next2 ← ugly[i2] * 2 // 更新 2 的指標與候選值\n    → Decision: next_ugly = next3? // 判斷是否與 3 的候選值相同\n        Yes → i3 ← i3 + 1 ; next3 ← ugly[i3] * 3 // 更新 3 的指標與候選值\n    → Decision: next_ugly = next5? // 判斷是否與 5 的候選值相同\n        Yes → i5 ← i5 + 1 ; next5 ← ugly[i5] * 5 // 更新 5 的指標與候選值\n→ Return ugly[n] // 回傳第 n 個丑數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef nth_ugly_number(n: int) -> int:\n    \"\"\"Return the n-th ugly number (factors only 2, 3, 5).\"\"\"\n    ugly = [1]          # ugly[0] is the first ugly number\n    i2 = i3 = i5 = 0    # pointers for multiples of 2, 3, 5\n\n    while len(ugly) < n:\n        # Next candidates from each pointer\n        next2 = ugly[i2] * 2\n        next3 = ugly[i3] * 3\n        next5 = ugly[i5] * 5\n        # Choose the smallest candidate\n        next_ugly = min(next2, next3, next5)\n        ugly.append(next_ugly)\n\n        # Increment pointers whose candidate was used\n        if next_ugly == next2:\n            i2 += 1\n        if next_ugly == next3:\n            i3 += 1\n        if next_ugly == next5:\n            i5 += 1\n\n    return ugly[-1]\n\nif __name__ == \"__main__\":\n    # Read entire stdin, extract the first integer encountered\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        raise ValueError(\"No integer input found.\")\n    n = int(match.group(0))\n\n    result = nth_ugly_number(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "12",
          "success": true,
          "output": "12"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode316.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicate Letters",
    "description_snippet": "Given a string s, remove duplicate letters so that every letter appears once and only once. You must...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The algorithm known: Use stack, maintain last occurrence indices, and a visited set. For each character, if not visited, pop from stack while top > current char and the top appears later again. Then push current char and mark visited. Finally return stack as string.\n\nWe'll produce pseudo-steps: Start, Step: determine last occurrence of each char, Step: initialize stack, visited, iterate, etc. Use Decision arrows.\n\nLet's produce lines:\n\nStart // start\n\n→ Step 1: 建立字元最後出現位置映射 // compute last index\n\n→ Step 2: 初始化空堆疊 stack, 空集合 visited // stack for result\n\n→ Decision: 是否還有未處理字元? // loop condition\n\n    Yes → Step 3: 取得目前字元 c // current char\n\n    → Decision: c 是否已在 visited? // if visited\n\n        Yes → Step 4: 跳過此字元 // continue to next\n\n        No  → Decision: 堆疊不空且 top > c 且 top 在後面還會再出現? // check while condition\n\n            Yes → Step 5: 從 stack 彈出 top 並從 visited 移除 // pop\n\n            → 再次進入同一 Decision: ...  // loop\n\n            No  → Step 6: 推入 c 到 stack 並加入 visited // push\n\n    → Move to next char // loop\n\n→ End // output stack joined\n\nBut we need to follow arrow formatting. Use → for steps, Decision for ifs.\n\nWe also need to include the loop arrow. In example they used Decision with nested Yes/No.\n\nWe should produce all steps line by line. Use indent with spaces or tab? They didn't specify indent but example uses spaces. We can indent nested steps with 4 spaces.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 取得字串長度 n // get length\n\n→ Step 2: 建立字典 lastIndex 為每個字元最後出現位置 // compute last index\n\n→ Step 3: 初始化空堆疊 stack，空集合 visited // stack and visited set\n\n→ Decision: i < n? // 是否還有字元要處理\n\n    Yes → Step 4: 取出字元 c = s[i] // current char\n\n    → Decision: c 是否已在 visited? // check visited\n\n        Yes → Step 5: i = i + 1 // 跳過，繼續下一個\n\n        No  → Decision: stack 不為空且 stack.top > c 且 lastIndex[stack.top] > i? // 可以彈出\n\n            Yes → Step 6: 取出 top = stack.pop(); visited.remove(top) // pop\n\n            → 再次進入同一 Decision: // loop\n\n            No  → Step 7: stack.push(c); visited.add(c); i = i + 1 // 推進\n\n    → 再次回到 Decision: i < n? // loop\n\n→ End // 將 stack 轉為字串並回傳\n\nBut they asked \"逐行地產生對應的虛擬碼 (Virtual Code)\" Each line includes \"虛擬碼步驟\" and comment. Should we write \"Start\" as step? yes.\n\nUse arrow \"→\". For decisions, \"Decision: ...\" with indentation. In example they use \"Yes →\", \"No →\" lines.\n\nWe need to provide each line.\n\nLet's construct final output:\n\nStart // 程式開始\n\n→ Step 1: 取得字串長度 n // get string length\n\n→ Step 2: 建立字典 lastIndex，記錄每個字元最後出現位置 // compute last occurrence\n\n→ Step 3: 初始化空堆疊 stack 與空集合 visited // stack and visited\n\n→ Decision: i < n? // 是否還有字元待處理\n\n    Yes → Step 4: c = s[i] // 取出當前字元\n\n    → Decision: c 已在 visited? // 判斷是否已加入結果\n\n        Yes → Step 5: i = i + 1 // 跳過此字元，進行下一個\n\n        No  → Decision: stack 不是空且 stack.top > c 且 lastIndex[stack.top] > i? // 可否彈出更大的字元\n\n            Yes → Step 6: top = stack.pop(); visited.remove(top) // 彈出堆疊頂端，移除訪問標記\n\n            → 再次進入同一 Decision: // 重新檢查條件\n\n            No  → Step 7: stack.push(c); visited.add(c); i = i + 1 // 推入當前字元，標記為已訪問\n\n    → 再次回到 Decision: i < n? // 重複迴圈\n\n→ End // 將 stack 內容組合成字串回傳\n\nBut we need to keep each line separate and include arrow and comment. Indent nested decisions by spaces maybe 4 spaces before \"Yes →\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得字串長度 n // 取得待處理字串的長度  \n→ Step 2: 建立字典 lastIndex，記錄每個字元最後一次出現的位置 // 方便後續判斷是否還會再次遇到某字元  \n→ Step 3: 初始化空堆疊 stack 與空集合 visited // 用於構造最終結果  \n→ Decision: i < n? // 判斷是否還有未處理字元  \n  Yes → Step 4: c = s[i] // 取得目前索引 i 位置的字元  \n   → Decision: c 已在 visited? // 判斷此字元是否已被加入結果  \n    Yes → Step 5: i = i + 1 // 已加入，直接跳至下一個字元  \n    No → Decision: stack 非空 且 stack.top > c 且 lastIndex[stack.top] > i? // 可否把堆疊頂端字元 pop 出來以保持字母順序  \n     Yes → Step 6: top = stack.pop(); visited.remove(top) // 取出堆疊頂端並移除訪問標記  \n     → 再次進入同一 Decision: // 重新檢查條件是否仍成立  \n     No → Step 7: stack.push(c); visited.add(c); i = i + 1 // 把目前字元加入堆疊並標記為已訪問  \n   → 再次回到 Decision: i < n? // 迴圈繼續  \n→ End // 把堆疊內容連結成字串並回傳結果，程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def removeDuplicateLetters(self, s: str) -> str:\n        \"\"\"\n        移除重複字母，使每個字母只出現一次且整體字串最小字典序。\n        \"\"\"\n        stack = []          # 用來儲存最終結果的字元堆疊\n        seen = set()        # 追蹤已加入堆疊的字元\n        # 計算每個字元最後一次出現的位置\n        last_occurrence = {c: i for i, c in enumerate(s)}\n\n        for i, c in enumerate(s):\n            if c in seen:\n                continue\n            # 若堆疊頂端字元比目前字元大，且該字元未來還會再出現，\n            # 則把它彈出，讓結果更小字典序\n            while stack and c < stack[-1] and i < last_occurrence[stack[-1]]:\n                seen.discard(stack.pop())\n            stack.append(c)\n            seen.add(c)\n        return ''.join(stack)\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    解析輸入資料，支援兩種形式：\n    1. 僅給字串，例如 bcabc\n    2. 形式為 s = \"bcabc\" 或 s = 'bcabc'\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return ''\n    # 嘗試從雙引號或單引號中提取字串\n    for quote in ('\"', \"'\"):\n        if quote in data:\n            first = data.find(quote)\n            last = data.rfind(quote)\n            if first != -1 and last != -1 and last > first:\n                return data[first + 1:last]\n    # 若沒有引號，直接回傳整個字串\n    return data\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = Solution().removeDuplicateLetters(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"bcabc\"",
          "expected_output": "\"abc\"",
          "success": true,
          "output": "abc"
        },
        {
          "example_index": 1,
          "input": "s = \"cbacdcbc\"",
          "expected_output": "\"acdb\"",
          "success": true,
          "output": "acdb"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode432.json",
    "problem_index_in_file": 0,
    "title": "All O`one Data Structure",
    "description_snippet": "Design a data structure to store the strings' count with the ability to return the strings with mini...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for designing AllOne class with inc, dec, getMaxKey, getMinKey, all O(1). Typically solution uses doubly linked list of count nodes each with set of keys and a hashmap key->node pointer. We'll produce pseudocode with steps. We need to output line by line. Use \"Start\", \"End\". Each line with virtual code and comment.\n\nWe'll need to describe structure: Node with count, set of keys, prev, next. Data structures: head, tail sentinel, map key->node. Then methods.\n\nWe produce pseudocode lines for class definition, initialization, inc, dec, getMaxKey, getMinKey. Each line with explanation.\n\nWe must not output actual code. Use virtual code with arrow etc. Use \"→\" for flow. We'll need decisions for moving node.\n\nWe'll produce like:\n\nStart // program start\n→ Class AllOne: // Define class\n→   Node: // Node structure\n→     count: int\n→     keys: Set<string>\n→     prev: Node\n→     next: Node\n→   map: HashMap<string, Node> // key to node\n→   head: Node // sentinel for min\n→   tail: Node // sentinel for max\n\nAllOne() // constructor\n→   Initialize head and tail as sentinels\n→   head.next = tail\n→   tail.prev = head\n→   map = empty\n\ninc(key)\n→   If key not in map:\n→     If head.next is tail OR head.next.count > 1:\n→       Create new node with count 1 between head and head.next\n→       Insert key into node.keys\n→       map[key] = node\n→     Else:\n→       // head.next has count 1\n→       head.next.keys.add(key)\n→       map[key] = head.next\n→   Else:\n→     node = map[key]\n→     nextNode = node.next\n→     // Move key to next count\n→     node.keys.remove(key)\n→     If nextNode is tail OR nextNode.count > node.count + 1:\n→       Create new node with count node.count + 1\n→       Insert between node and nextNode\n→       newNode.keys.add(key)\n→       map[key] = newNode\n→     Else:\n→       nextNode.keys.add(key)\n→       map[key] = nextNode\n→     // Remove node if empty\n→     If node.keys is empty:\n→       Remove node from list\n\ndec(key)\n→   node = map[key]\n→   If node.count == 1:\n→     // Remove key completely\n→     node.keys.remove(key)\n→     Remove key from map\n→     If node.keys is empty:\n→       Remove node\n→   Else:\n→     prevNode = node.prev\n→     // Move key to prev count\n→     node.keys.remove(key)\n→     If prevNode is head OR prevNode.count < node.count - 1:\n→       Create new node with count node.count - 1\n→       Insert between prevNode and node\n→       newNode.keys.add(key)\n→       map[key] = newNode\n→     Else:\n→       prevNode.keys.add(key)\n→       map[key] = prevNode\n→     If node.keys is empty:\n→       Remove node\n\ngetMaxKey()\n→   If head.next is tail:\n→     Return \"\"\n→   Else:\n→     Return any key from tail.prev.keys\n\ngetMinKey()\n→   If head.next is tail:\n→     Return \"\"\n→   Else:\n→     Return any key from head.next.keys\n\nEnd\n\nWe need to maintain the order of steps.\n\nNow produce lines accordingly. Use \"→\" arrow. Use decisions with Yes/No.\n\nWe need to incorporate decisions inside inc for node insertion etc.\n\nWe'll output each line as virtual code. Provide comment after space. Example: \"Start // 程式開始執行\".\n\nLet's write.\n\nWe'll also include function definitions: inc(key) etc. We'll use pseudo-code style: \"→ inc(key):\".\n\nWill each line be separate? Yes.\n\nWe might group lines inside methods. But we need line by line. We need to be careful to not too many lines. But still enough.\n\nLet's produce.\n\nWe'll use a consistent indentation but we can't use spaces? We can use indentation for readability but not required. We'll keep each line simple.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class AllOne: // 定義 AllOne 類別  \n→   // 節點結構：記錄計數、關鍵字集合、前後指標  \n→   Node:  \n→     count: int  \n→     keys: Set<string>  \n→     prev: Node  \n→     next: Node  \n→   map: HashMap<string, Node> // key → 節點指標  \n→   head: Node // 最小計數節點的前置哨兵  \n→   tail: Node // 最大計數節點的後置哨兵  \n\n→ AllOne(): // 建構子  \n→   head = new Node()  \n→   tail = new Node()  \n→   head.next = tail  \n→   tail.prev = head  \n→   map = new HashMap()  \n\n→ inc(key): // 增加 key 的計數  \n→   If key not in map: // key 之前不存在  \n→     If head.next == tail OR head.next.count > 1: // 無 1 計數節點  \n→       newNode = new Node()  \n→       newNode.count = 1  \n→       newNode.keys = {key}  \n→       Insert newNode after head  \n→       map[key] = newNode  \n→     Else: // 已有 1 計數節點  \n→       head.next.keys.add(key)  \n→       map[key] = head.next  \n→   Else: // key 已存在  \n→     node = map[key]  \n→     nextNode = node.next  \n→     node.keys.remove(key)  \n→     // 將 key 移到 count+1 節點  \n→     If nextNode == tail OR nextNode.count > node.count + 1: // 無相應節點  \n→       newNode = new Node()  \n→       newNode.count = node.count + 1  \n→       newNode.keys = {key}  \n→       Insert newNode between node and nextNode  \n→       map[key] = newNode  \n→     Else: // 有相應節點  \n→       nextNode.keys.add(key)  \n→       map[key] = nextNode  \n→     // 若原節點已空，移除  \n→     If node.keys.isEmpty():  \n→       Remove node from list  \n\n→ dec(key): // 減少 key 的計數  \n→   node = map[key]  \n→   If node.count == 1: // 計數將變 0，直接移除  \n→     node.keys.remove(key)  \n→     map.remove(key)  \n→     If node.keys.isEmpty():  \n→       Remove node from list  \n→   Else: // 計數 > 1  \n→     prevNode = node.prev  \n→     node.keys.remove(key)  \n→     // 將 key 移到 count-1 節點  \n→     If prevNode == head OR prevNode.count < node.count - 1: // 無相應節點  \n→       newNode = new Node()  \n→       newNode.count = node.count - 1  \n→       newNode.keys = {key}  \n→       Insert newNode between prevNode and node  \n→       map[key] = newNode  \n→     Else: // 有相應節點  \n→       prevNode.keys.add(key)  \n→       map[key] = prevNode  \n→     // 若原節點已空，移除  \n→     If node.keys.isEmpty():  \n→       Remove node from list  \n\n→ getMaxKey(): // 取得最大計數的任一 key  \n→   If head.next == tail: // 空結構  \n→     Return \"\"  \n→   Else:  \n→     Return any key from tail.prev.keys  \n\n→ getMinKey(): // 取得最小計數的任一 key  \n→   If head.next == tail: // 空結構  \n→     Return \"\"  \n→   Else:  \n→     Return any key from head.next.keys  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Node:\n    def __init__(self):\n        self.keys = set()\n        self.prev = None\n        self.next = None\n        self.count = 0\n\nclass AllOne:\n    def __init__(self):\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}\n\n    def _insert_after(self, prev_node, count):\n        node = Node()\n        node.count = count\n        node.prev = prev_node\n        node.next = prev_node.next\n        prev_node.next.prev = node\n        prev_node.next = node\n        return node\n\n    def _remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key):\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            next_count = node.count + 1\n            if node.next == self.tail or node.next.count > next_count:\n                new_node = self._insert_after(node, next_count)\n            else:\n                new_node = node.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            if self.head.next == self.tail or self.head.next.count > 1:\n                new_node = self._insert_after(self.head, 1)\n            else:\n                new_node = self.head.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n\n    def dec(self, key):\n        node = self.key_to_node[key]\n        prev_count = node.count - 1\n        node.keys.remove(key)\n        if prev_count == 0:\n            del self.key_to_node[key]\n        else:\n            if node.prev == self.head or node.prev.count < prev_count:\n                new_node = self._insert_after(node.prev, prev_count)\n            else:\n                new_node = node.prev\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self):\n        if self.tail.prev == self.head:\n            return \"\"\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self):\n        if self.head.next == self.tail:\n            return \"\"\n        return next(iter(self.head.next.keys))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    # 如果第一行是 'Input'，就跳過\n    if data and data[0].strip() == \"Input\":\n        data = data[1:]\n    ops = ast.literal_eval(data[0].strip())\n    args = ast.literal_eval(data[1].strip())\n\n    obj = None\n    results = []\n    for op, arg in zip(ops, args):\n        if op == \"AllOne\":\n            obj = AllOne()\n            results.append(None)\n        elif op == \"inc\":\n            obj.inc(arg[0])\n            results.append(None)\n        elif op == \"dec\":\n            obj.dec(arg[0])\n            results.append(None)\n        elif op == \"getMaxKey\":\n            results.append(obj.getMaxKey())\n        elif op == \"getMinKey\":\n            results.append(obj.getMinKey())\n\n    # 將結果轉成 JSON 格式（None 會自動變成 null）\n    output_str = json.dumps(results)\n    print(f\"Output\\n{output_str}\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "success": true,
          "output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode344.json",
    "problem_index_in_file": 0,
    "title": "Reverse String",
    "description_snippet": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation, no actual code. The function reverses string in-place. Should show algorithm using two-pointer swap. Use Start, End, Decision. Probably start function, initialize two pointers, while left < right: swap, left++, right--. End. Provide comments.\n\nWe need to use virtual code syntax with arrow → etc. Format: each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. For loop condition we can use Decision: if left < right? etc. Also include assignment of pointers: \"→ Step 1: Set left = 0 // 初始化左指針\" etc.\n\nAlso mention O(1) memory. Provide final End. Also mention input param s array.\n\nLet's produce lines. We'll use indentation for nested decisions. The arrow line: \"→ Step 1:\" etc. Use \"Decision:\" for while condition. Should maintain format.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set left = 0 // 初始化左指針，指向陣列開頭  \n→ Step 2: Set right = length(s) - 1 // 初始化右指針，指向陣列結尾  \n→ Decision: 左指針是否小於右指針? // 判斷是否還有未交換的字元  \n  Yes → Step 3: Swap s[left] 與 s[right] // 交換兩端字元  \n                            // 完成一次交換  \n                             → Step 4: left = left + 1 // 將左指針往右移  \n                             → Step 5: right = right - 1 // 將右指針往左移",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def reverseString(self, s):\n        \"\"\"\n        Reverse the list of characters in-place using O(1) extra memory.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]  # swap\n            left += 1\n            right -= 1\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n\n    # Remove a leading variable assignment if present (e.g., \"s = [...]\")\n    if '=' in raw_input:\n        _, raw_input = raw_input.split('=', 1)\n\n    # Strip any surrounding whitespace and convert to a Python list\n    raw_input = raw_input.strip()\n    try:\n        # Use literal_eval to safely evaluate the list representation\n        char_list = ast.literal_eval(raw_input)\n    except Exception as e:\n        # If evaluation fails, fall back to an empty list\n        char_list = []\n\n    # Ensure we have a list of characters\n    if not isinstance(char_list, list):\n        char_list = []\n\n    # Reverse the string in-place\n    Solution().reverseString(char_list)\n\n    # Output the reversed list with double quotes and no spaces, as per examples\n    output = '[' + ','.join(f'\"{c}\"' for c in char_list) + ']'\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = [\"h\",\"e\",\"l\",\"l\",\"o\"]",
          "expected_output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]",
          "success": true,
          "output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]"
        },
        {
          "example_index": 1,
          "input": "s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
          "expected_output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
          "success": true,
          "output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2220.json",
    "problem_index_in_file": 0,
    "title": "Minimum Bit Flips to Convert Number",
    "description_snippet": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from ei...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for algorithm: given start and goal, find minimum bit flips to convert start to goal. For each bit position we can flip. The minimal flips equal number of differing bits in binary representation (Hamming distance). Since leading zeros can be flipped as well, but flipping any bit beyond the highest bit of either number just toggles a zero to one or one to zero. But the minimum flips will be the count of positions where start and goal bits differ. But also can choose leading zeros: if goal has a 1 beyond start's bits, we need to flip that bit (from 0 to 1). So effectively compare all bits up to the max bit-length of start or goal. So minimal flips is bit count of XOR of start and goal.\n\nThus algorithm: compute xor = start XOR goal; count number of set bits in xor; return count.\n\nWe need to produce virtual code step by step, each line with explanation.\n\nWe can also show input reading, compute XOR, loop through bits to count.\n\nWe must use arrow syntax: Start, Step, Decision, End. Use \"→\" arrow. Provide short explanation after comment.\n\nLet's craft. Use steps:\n\nStart // program starts\n→ Step 1: input start // get start value\n→ Step 2: input goal // get goal value\n→ Step 3: xor = start XOR goal // compute differing bits\n→ Step 4: counter = 0 // initialize flip counter\n→ Decision: if xor == 0? // no differing bits\n    Yes → Step 5: output counter // return 0\n    No → Step 6: While xor > 0? // process each bit\n        → Step 7: if xor & 1 == 1? // check LSB\n            Yes → counter = counter + 1 // increment flip count\n        → Step 8: xor = xor >> 1 // shift right to next bit\n        → Decision: xor > 0? // continue loop?\n    → Step 9: output counter // final count\nEnd\n\nNeed to ensure arrow formatting: Use \"→\" each step. For nested decisions, indent maybe. Format as sample: use indentation.\n\nLet's produce.\n\nUse \"Yes →\" and \"No →\" inside decision lines.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 start // 取得起始整數  \n→ Step 2: 輸入 goal // 取得目標整數  \n→ Step 3: xor = start XOR goal // 計算兩數不同位元的 XOR  \n→ Step 4: counter = 0 // 初始化需要翻轉的位元數  \n→ Decision: xor 是否等於 0? // 檢查是否已相同  \n  Yes → Step 5: 輸出 counter // 若無差異，回傳 0  \n  No  → Step 6: 循環處理 xor 的每一位元 // 逐位檢查差異  \n     → Decision: xor 大於 0? // 是否還有未處理位元  \n       Yes → Step 7: 如果 xor & 1 == 1? // 檢查最低位是否為 1  \n         Yes → counter = counter + 1 // 若為 1，翻轉數量加 1  \n         No  → // 無需加 1  \n         ↓  \n        No → // 位元處理完畢  \n       ↓  \n       Yes → xor = xor >> 1 // 右移至下一位元  \n       ↓  \n       Decision: xor 大於 0? // 迴圈判斷  \n        Yes → 重新執行 Step 7-8  \n        No  → 退出循環  \n→ Step 8: 輸出 counter // 輸出最小翻轉數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_bit_flips(start: int, goal: int) -> int:\n    \"\"\"\n    計算將 start 轉換為 goal 所需的最小位元翻轉數。\n    方法：先算出 start 與 goal 的 XOR，XOR 的 1 位即代表兩數在該位不同，\n    因此翻轉的數目即為 XOR 中 1 的個數。\n    \"\"\"\n    xor = start ^ goal          # 找出所有不同的位元\n    flips = 0\n    while xor:                  # 每次檢查最低位是否為 1\n        flips += xor & 1\n        xor >>= 1               # 右移至下一位\n    return flips\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，解析出 start 與 goal，輸出最小翻轉數。\n    輸入範例：'start = 10, goal = 7'\n    \"\"\"\n    data = sys.stdin.read()\n    # 用正則表達式取得所有整數，忽略文字\n    numbers = re.findall(r'-?\\d+', data)\n    if len(numbers) < 2:\n        return  # 若沒有足夠的數字，直接結束\n    start, goal = map(int, numbers[:2])\n    result = min_bit_flips(start, goal)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "start = 10, goal = 7",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "start = 3, goal = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode767.json",
    "problem_index_in_file": 0,
    "title": "Reorganize String",
    "description_snippet": "Given a string s, rearrange the characters of s so that any two adjacent characters are not the same...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for rearranging string so adjacent chars not same. Use algorithm: count frequencies, use max heap to pick most frequent remaining. If any char count > (n+1)/2 return \"\". else build result by picking top two and appending. Pseudocode.\n\nWe need each line with virtual code + // explanation.\n\nUse arrows. Steps: Start. Input s. Compute length n. Count frequencies (map). Determine max count. If max> (n+1)/2 → Return \"\". Else build priority queue sorted by count descending. Initialize result string builder. While pq not empty: pop top1. Append char1 to result. Decrease count. If pq not empty: pop top2, append char2, decrease. If counts remain, push back into pq. After loop, return result. End.\n\nLet's produce lines. Each line: 虛擬碼步驟 [space] // 解釋\n\nWe can include comments for loops etc.\n\nAlso we may include Decision lines.\n\nWe need to use arrow symbols. Eg:\n\nStart // 程式開始執行\n→ Step 1: 輸入字符串 s // 取得輸入字符串\n\nUse indentation maybe.\n\nLet's craft. Ensure each line with arrow or step. Use arrow '→' before each step. For Decision, use 'Decision:'.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字符串 s // 取得使用者輸入的字串  \n→ Step 2: 計算長度 n ← length(s) // 獲得字串長度  \n→ Step 3: 建立字頻表 freq ← map<char, int>() // 用於記錄每個字母出現次數  \n→ Decision: 遍歷 s? // 判斷是否需要遍歷字串  \n Yes → For 每個字符 c in s:  \n   freq[c] ← freq[c] + 1 // 更新頻率  \n   maxCount ← max(maxCount, freq[c]) // 同時找出最大頻率  \n   End  \n  End  \n→ Decision: maxCount > (n + 1) / 2? // 判斷是否有字母太多無法重新排列  \n Yes → Step 4: 返回 \"\" // 不可能重新排列，直接返回空字串  \n  End  \n No → Step 5: 建立最大堆 pq ← MaxHeap() // 以頻率作為排序基準  \n  → For 每個 (char, count) in freq:  \n    pq.push((count, char)) // 將頻率和字符推入堆  \n    End  \n  → Step 6: 建立空結果字串 res ← \"\" // 用於存放重新排列後的字串  \n  → Decision: pq 不是空的? // 循環直到堆為空  \n   Yes → Step 7: (cnt1, ch1) ← pq.pop() // 取出頻率最高的字符  \n    res ← res + ch1 // 加入結果  \n    cnt1 ← cnt1 - 1 // 減少頻率  \n    Decision: pq 不是空的? // 檢查是否還有另一個字符可用  \n     Yes → (cnt2, ch2) ← pq.pop() // 取第二高頻率字符  \n      res ← res + ch2 // 加入結果  \n      cnt2 ← cnt2 - 1 // 減少頻率  \n      Decision: cnt2 > 0? // 若第二個字符還有剩餘  \n       Yes → pq.push((cnt2, ch2)) // 再次加入堆  \n       End  \n     Decision: cnt1 > 0? // 若第一個字符還有剩餘  \n      Yes → pq.push((cnt1, ch1)) // 再次加入堆  \n      End  \n    No → Decision: cnt1 > 0? // 只有第一個字符剩餘  \n     Yes → pq.push((cnt1, ch1)) // 加回堆  \n     End  \n   End  \n   End  \n  → Step 8: 返回 res // 取得重新排列好的字串  \n  End  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def reorganizeString(self, s: str) -> str:\n        \"\"\"重新排列字串，使相鄰字符不同；若不可能則回傳空字串。\"\"\"\n        n = len(s)\n        freq = Counter(s)\n        # 如果任何字母出現次數超過 (n+1)//2，則不可能完成\n        if max(freq.values()) > (n + 1) // 2:\n            return \"\"\n\n        # 建立以頻率為負值的最大堆，負值使 heapq 成為最大堆\n        max_heap = [(-cnt, ch) for ch, cnt in freq.items()]\n        heapq.heapify(max_heap)\n\n        prev_cnt, prev_ch = 0, ''   # 前一次使用的字母（若仍有剩餘，放回堆）\n        result = []\n\n        while max_heap:\n            cnt, ch = heapq.heappop(max_heap)\n            result.append(ch)\n            # 之前的字母若仍有剩餘，放回堆\n            if prev_cnt < 0:\n                heapq.heappush(max_heap, (prev_cnt, prev_ch))\n            # 將目前字母的剩餘數量減 1（由於使用了一次，故+1，因為負數）\n            prev_cnt, prev_ch = cnt + 1, ch\n\n        # 若重組後長度不等於原長度，表示失敗\n        if len(result) != n:\n            return \"\"\n        return \"\".join(result)\n\n\ndef parse_input(text: str) -> str:\n    \"\"\"\n    從輸入文字中提取字串 s。\n    支援以下形式：\n        - s = \"aab\"\n        - s = 'aab'\n        - aab\n    \"\"\"\n    # 先嘗試抓取雙引號內部的內容\n    m = re.search(r'\"([^\"]*)\"', text)\n    if m:\n        return m.group(1)\n    # 再嘗試單引號內部\n    m = re.search(r\"'([^']*)'\", text)\n    if m:\n        return m.group(1)\n    # 若無引號，直接移除可能的前綴並回傳\n    text = text.strip()\n    if text.lower().startswith('s ='):\n        return text.split('=', 1)[1].strip()\n    return text\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n\n    sol = Solution()\n    rearranged = sol.reorganizeString(s)\n\n    # 按範例輸出，將結果包在雙引號內\n    print(f'\"{rearranged}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "\"aba\"",
          "success": true,
          "output": "\"aba\""
        },
        {
          "example_index": 1,
          "input": "s = \"aaab\"",
          "expected_output": "\"\"",
          "success": true,
          "output": "\"\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode312.json",
    "problem_index_in_file": 0,
    "title": "Burst Balloons",
    "description_snippet": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it repre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code, line by line, with explanation after //, for the balloon bursting DP problem.\n\nWe must not output actual code, just steps. Use virtual arrows.\n\nLet's produce a high-level algorithm: Use DP over intervals: dp[i][j] max coins for bursting balloons between i and j exclusive (i<j). Add sentinel 1 at both ends.\n\nSteps:\n\n- Start\n- Input nums array\n- Build new array arr with 1 at both ends: arr = [1] + nums + [1]\n- n = len(arr)\n- Initialize dp 2D array n x n with 0\n- For length from 2 to n: (subarray between i and j)\n  - For i from 0 to n - length:\n    - j = i + length\n    - For k from i+1 to j-1:\n      - dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + arr[i]*arr[k]*arr[j])\n- End\n\nReturn dp[0][n-1].\n\nBut the problem wants steps in virtual code.\n\nLet's produce line by line with explanations.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入陣列 nums // 取得原始氣球數值\n→ Step 2: 建立擴充陣列 arr = [1] + nums + [1] // 在兩端補 1 以處理邊界\n→ Step 3: 設定 n = len(arr) // arr 的長度\n→ Step 4: 建立 2D dp 陣列大小 n x n 並初始化為 0 // dp[i][j] 代表 i..j 之間（不含端點）爆破氣球可得到的最大硬幣\n→ Step 5: 計算子陣列長度 len 從 2 到 n // 子陣列至少包含兩個端點\n    → For i in 0 .. n - len:\n        → Step 6: 計算 j = i + len // 子陣列右端點\n        → Step 7: 對 k 從 i+1 到 j-1 做迭代 // k 為最後一次爆破的氣球\n            → Step 8: 計算 coins = dp[i][k] + dp[k][j] + arr[i]*arr[k]*arr[j] // 左右子問題加上最後爆破 k 的收益\n            → Step 9: 更新 dp[i][j] = max(dp[i][j], coins) // 取最大值\n→ Step 10: 結果 coins = dp[0][n-1] // 全部氣球爆破的最大收益\n→ End // 程式結束\n\nBut we need to use virtual code style. Use arrow notation. Example:\n\nStart // 程式開始執行\n→ Step 1: 讀取 nums // ...\n→ Step 2: arr = [1] + nums + [1] // ...\n...\n\nFor loops we can express as Decision? Actually can express as Step with loops but arrow.\n\nBut requirement says use virtual code arrow and structure: Start, End, Decision:, Yes →, No →. However loops aren't decision structure. But we can use Step representation.\n\nBetter to represent loops with Step lines but we may also include Decision: for loops but not necessary.\n\nWe can produce:\n\nStart // 程式開始\n→ Step 1: 讀取 nums // 取得氣球值\n→ Step 2: arr ← [1] + nums + [1] // 在兩端補 1\n→ Step 3: n ← len(arr) // 總長度\n→ Step 4: dp ← 2D array n x n, 初始化 0 // dp[i][j] 最大硬幣\n→ Step 5: Decision: 子陣列長度 len 從 2 到 n? // 需要遍歷長度\n    Yes → Step 6: for i = 0 to n - len:\n        → Step 7: j ← i + len // 子陣列右端點\n        → Step 8: for k = i+1 to j-1:\n            → Step 9: coins ← dp[i][k] + dp[k][j] + arr[i]*arr[k]*arr[j] // 計算收益\n            → Step 10: dp[i][j] ← max(dp[i][j], coins) // 更新最大值\n    No → End // 完成所有長度\n→ Step 11: answer ← dp[0][n-1] // 全部氣球的最大收益\n→ End // 程式結束\n\nBut they want each line with virtual code arrow. The Decision and Yes/No may be inside loops? Let's format more simply.\n\nMaybe we can just use Step lines with arrows and no Decision inside loops. Provide loops as Step lines with comments describing loop. That might be easier.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 讀取 nums // 取得氣球數值\n→ Step 2: arr ← [1] + nums + [1] // 在兩端補 1 以處理邊界\n→ Step 3: n ← len(arr) // arr 的長度\n→ Step 4: dp ← 2D array n x n, 初始化 0 // dp[i][j] 代表 i..j 之間不含端點的最大硬幣\n→ Step 5: 迭代子陣列長度 len 從 2 到 n // 最少兩個端點\n    → Step 6: 迭代左端點 i 從 0 到 n - len\n        → Step 7: 計算右端點 j = i + len\n        → Step 8: 迭代最後爆破氣球 k 從 i+1 到 j-1\n            → Step 9: coins = dp[i][k] + dp[k][j] + arr[i]*arr[k]*arr[j] // 左右子問題加上 k 的收益\n            → Step 10: dp[i][j] ← max(dp[i][j], coins) // 更新最大值\n→ Step 11: answer ← dp[0][n-1] // 全部氣球爆破的最大硬幣\n→ End // 程式結束\n\nBut we need to maintain the format of \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nLet's produce each line accordingly. For loops, we can use indentation but still each line. Provide Step number.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 讀取 nums // 取得原始氣球數值\n→ Step 2: arr ← [1] + nums + [1] // 在兩端補 1 以處理邊界\n→ Step 3: n ← len(arr) // arr 的總長度\n→ Step 4: dp ← 2D array n x n，初始化為 0 // dp[i][j] 代表 i..j 之間（不含端點）爆破氣球可得到的最大硬幣\n→ Step 5: 迭代子陣列長度 len 從 2 到 n // 至少兩個端點\n    → Step 6: 迭代左端點 i 從 0 到 n - len\n        → Step 7: 計算右端點 j ← i + len // 子陣列的右端點\n        → Step 8: 迭代最後一次爆破的氣球 k 從 i+1 到 j-1\n            → Step 9: coins ← dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j] // 左右子問題加上 k 的收益\n            → Step 10: dp[i][j] ← max(dp[i][j], coins) // 更新子問題的最大值\n→ Step 11: answer ← dp[0][n-1] // 全部氣球爆破後的最大硬幣總數\n→ End // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxCoins(self, nums):\n        # 在前後加 1 方便計算\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        # 遍歷所有長度（至少兩個端點）\n        for length in range(2, n):\n            for left in range(0, n - length):\n                right = left + length\n                # i 為最後一個被戳破的氣球\n                for i in range(left + 1, right):\n                    dp[left][right] = max(\n                        dp[left][right],\n                        nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]\n                    )\n        return dp[0][n - 1]\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從輸入字串中抽取所有整數，支援「nums = [3,1,5,8]」或直接「[3,1,5,8]」等格式\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n\n    solution = Solution()\n    print(solution.maxCoins(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,1,5,8]",
          "expected_output": "167",
          "success": true,
          "output": "167"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode166.json",
    "problem_index_in_file": 0,
    "title": "Fraction to Recurring Decimal",
    "description_snippet": "Given two integers representing the numerator and denominator of a fraction, return the fraction in ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining steps to convert numerator/denominator to decimal string with repeating parentheses. No actual code, just pseudo steps with arrows. Use Start, Decision, etc. Let's outline steps:\n\nStart\n→ Step: Handle sign: determine negative if numerator and denominator signs differ. Store result sign, work with absolute values.\n→ Step: Compute integer part = numerator // denominator. Append to result string.\n→ Step: Compute remainder = numerator % denominator.\n→ Decision: If remainder == 0 → Step: Append nothing else? Return result string. End\n→ Step: Append '.' to result string.\n→ Step: Initialize map remainder_positions = empty.\n→ Step: Initialize decimal_part = empty string.\n→ Step: While remainder != 0:\n    → Decision: If remainder in remainder_positions → Step: Identify start index of repeating; insert parentheses accordingly; break loop.\n    → Else: Record remainder_positions[remainder] = current decimal_part length.\n    → Step: Multiply remainder by 10.\n    → Step: Digit = remainder // denominator; Append digit to decimal_part.\n    → Step: Update remainder = remainder % denominator.\n→ Step: Append decimal_part to result string (after inserting parentheses if needed).\n→ End.\n\nAlso handle case negative sign before integer part.\n\nWe'll produce virtual code line by line with explanations. Use arrows \"→\". For decisions indent with Yes/No. Provide brief explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 取得 numerator 與 denominator，確定結果是否為負數 // 判斷號碼並記錄符號\n→ Decision: numerator 與 denominator 符號是否不同? // 檢查是否需要加負號\n    Yes → Step: 在結果字串前加 '-' // 為負數加上符號\n    No  → // 兩數同號，結果為正，無需加符號\n→ Step: 取 numerator 與 denominator 的絕對值 // 以正整數進行計算\n→ Step: 計算整數部分 integer = numerator // denominator // 求整數位\n→ Step: 把整數部分轉成字串並加入結果字串 // 成為結果的開頭\n→ Step: remainder = numerator % denominator // 取餘數作為小數部分起點\n→ Decision: remainder 是否為 0? // 判斷是否為有限小數\n    Yes → End // 沒有小數位，直接結束並回傳結果\n    No  → // 需要處理小數位\n→ Step: 在結果字串後加 '.' // 加上小數點\n→ Step: 初始化空字典 remainder_positions = {} // 用於追蹤餘數位置以偵測循環\n→ Step: 初始化空字串 decimal_part = '' // 儲存小數位\n→ Decision: remainder 是否為 0? // 迴圈入口，若已無餘數則結束\n    No  → // 進入小數計算迴圈\n        → While remainder ≠ 0\n            → Decision: remainder 是否已存在於 remainder_positions? // 檢查是否出現重複餘數\n                Yes → // 循環開始位置已知\n                    → Step: repeat_start = remainder_positions[remainder] // 找到重複區段起始索引\n                    → Step: 在 decimal_part 的 repeat_start 處插 '(' // 開始標示重複部分\n                    → Step: 在 decimal_part 的末尾插 ')' // 結束重複部分\n                    → Step: 退出迴圈 // 循環結束\n                No  → // 尚未重複\n                    → Step: remainder_positions[remainder] = decimal_part.length // 記錄餘數位置\n                    → Step: remainder = remainder * 10 // 放大餘數為下一位數字\n                    → Step: digit = remainder // denominator // 求下一位數字\n                    → Step: Append digit 的字串形式到 decimal_part // 添加到小數位\n                    → Step: remainder = remainder % denominator // 更新餘數\n→ Step: 把 decimal_part 加到結果字串上 // 完成小數部分\nEnd // 程式執行結束，回傳結果字串",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator == 0:\n            return \"0\"\n        res = []\n\n        # Determine sign\n        if (numerator < 0) ^ (denominator < 0):\n            res.append(\"-\")\n\n        # Work with absolute values\n        numerator, denominator = abs(numerator), abs(denominator)\n\n        # Integer part\n        res.append(str(numerator // denominator))\n        remainder = numerator % denominator\n\n        if remainder == 0:\n            return \"\".join(res)\n\n        # Fractional part\n        res.append(\".\")\n        seen = {}\n        while remainder != 0:\n            if remainder in seen:\n                idx = seen[remainder]\n                res.insert(idx, \"(\")\n                res.append(\")\")\n                break\n            seen[remainder] = len(res)\n            remainder *= 10\n            res.append(str(remainder // denominator))\n            remainder %= denominator\n\n        return \"\".join(res)\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract all integers from the input (handles formats like \"numerator = 1, denominator = 2\")\n    nums = re.findall(r'-?\\d+', data)\n    if len(nums) < 2:\n        return\n    numerator, denominator = int(nums[0]), int(nums[1])\n\n    sol = Solution()\n    result = sol.fractionToDecimal(numerator, denominator)\n    # Output the result surrounded by double quotes as shown in the examples\n    print(f'\"{result}\"')\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numerator = 1, denominator = 2",
          "expected_output": "\"0.5\"",
          "success": true,
          "output": "\"0.5\""
        },
        {
          "example_index": 1,
          "input": "numerator = 2, denominator = 1",
          "expected_output": "\"2\"",
          "success": true,
          "output": "\"2\""
        },
        {
          "example_index": 2,
          "input": "numerator = 4, denominator = 333",
          "expected_output": "\"0.(012)\"",
          "success": true,
          "output": "\"0.(012)\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode30.json",
    "problem_index_in_file": 0,
    "title": "Substring with Concatenation of All Words",
    "description_snippet": "You are given a string s and an array of strings words. All the strings of words are of the same len...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps, not actual code, for algorithm. Problem: Find starting indices of substrings in s that are concatenation of all words (each word length L, count k). Standard solution: sliding window with word frequency map, move by L. We'll produce pseudocode lines. Should be in Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋\". Use arrow. Let's outline steps:\n\nStart // 初始化\n→ Step 1: 計算單詞長度 L = words[0].length() // 所有單詞長度相同\n→ Step 2: 計算單詞個數 k = words.length // 總個數\n→ Step 3: 建立字典 targetCount: word -> 次數 // 需求頻率\n→ Step 4: 建立結果列表 result\n→ Decision: 如果 s.length < L*k → End with empty result // 數字小於需要長度\n→ Step 5: For offset in 0..L-1: // 對每個位移進行滑動窗口\n    → Step 6: 初始化 currentCount = {} // 當前窗口字頻\n    → Step 7: matched = 0 // 匹配成功單詞數\n    → Step 8: For i = offset; i <= s.length - L; i += L:\n        → Step 9: word = substring s[i:i+L]\n        → Decision: 如果 word in targetCount? // 若不是忽略\n            → Yes → Step 10: currentCount[word]++ // 計數\n            → Step 11: if currentCount[word] <= targetCount[word] then matched++ // 有效匹配\n            → Decision: 如果 i - offset + L > L*k? // 窗口超長\n                → Yes → Step 12: leftWord = s[i - offset - L*k : i - offset - L*k + L]\n                    → Step 13: currentCount[leftWord]--\n                    → Decision: 如果 currentCount[leftWord] < targetCount[leftWord] then matched--\n                → No → Skip\n            → Decision: 如果 matched == k? // 完全匹配\n                → Yes → Step 14: result.append(i - offset - L*k + L) // start index\n                → No → Skip\n        → No → // word not needed, reset window\n            → Step 15: currentCount.clear()\n            → Step 16: matched = 0\n            → Step 17: offset = i + L // shift offset? Actually move offset? Use i to move window start\n            → Step 18: i = i // but we will break? better to set i to i? But in pseudocode we can say set i = i - L? Actually we set i to i (so loop will increment)\n            → Step 19: offset = i + L // not needed maybe simpler: set offset = i + L? but we can't modify outer loop. Instead we can set i = i - L to reset start? We'll just comment \"reset window\" and continue\nBut it's messy.\n\nSimplify: Use two loops: outer offset 0..L-1. inner i = offset; i <= s.length - L; i += L.\n\nIf word not in targetCount, reset start = i + L, clear map and matched=0, continue.\n\nIf word in targetCount, update counts. If count > target, shift left until count ok.\n\nBetter pseudocode: Standard sliding window with two pointers left,right.\n\nWe can produce simpler pseudocode:\n\nStep 8: left = offset\nStep 9: for right from offset to s.length - L step L:\n    word = substring\n    if word not in targetCount:\n        left = right + L\n        currentCount.clear()\n        matched = 0\n        continue\n    currentCount[word]++\n    if currentCount[word] <= targetCount[word]:\n        matched++\n    else:\n        // Too many of word, move left until count <= target\n        while currentCount[word] > targetCount[word]:\n            leftWord = substring left..left+L\n            currentCount[leftWord]--\n            if currentCount[leftWord] < targetCount[leftWord]:\n                matched--\n            left += L\n    if matched == k:\n        result.append(left)\n\nWe must handle window length > L*k? But matched==k ensures correct length.\n\nBetter: After matched==k, we can record and then shift left by one word: leftWord = substring left..left+L; currentCount[leftWord]--; if currentCount[leftWord] < targetCount[leftWord] matched--; left += L. That ensures sliding.\n\nBut we can keep simple.\n\nLet's produce virtual code lines step by step, with explanation. Use \"Decision:\" lines for if statements.\n\nLet's craft final output.\n\nNeed to follow format: each line \"虛擬碼步驟 // 解釋\". We'll start with \"Start\". Provide lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: L ← words[0].length() // 取得所有單字的長度  \n→ Step 2: k ← words.length // 取得單字總數  \n→ Step 3: targetCount ← {} // 建立單字頻率表  \n→ Decision: for each w in words: // 填入 targetCount  \n  Yes → targetCount[w] ← targetCount.get(w, 0) + 1 // 記錄 w 的需求次數  \n→ Step 4: result ← [] // 儲存符合條件的起始位置  \n→ Decision: if s.length < L * k → End // s 不足以容納所有單字  \n→ Step 5: for offset in 0 .. L-1: // 每個位移做一次滑動窗口  \n  → Step 6: currentCount ← {} // 當前窗口的頻率表  \n  → Step 7: matched ← 0 // 已成功匹配的單字數  \n  → Step 8: left ← offset // 窗口左端指標  \n  → for right in offset .. s.length - L step L: // 右端指標向右移動，每次進一步一個單字長度  \n    → Step 9: word ← s.substring(right, right + L) // 取得當前單字  \n    → Decision: if word not in targetCount: // 不是需要的單字  \n      Yes → currentCount.clear() // 清空頻率表  \n       → matched ← 0 // 重置已匹配數  \n       → left ← right + L // 重新定位窗口左端  \n       → continue // 進入下一個右端  \n    → No → currentCount[word] ← currentCount.get(word, 0) + 1 // 更新頻率表  \n      → Decision: if currentCount[word] <= targetCount[word]:  \n        Yes → matched ← matched + 1 // 有效匹配數增一  \n       No → // 超過需求數量  \n         → Step 10: while currentCount[word] > targetCount[word]: // 往左移動窗口直到多餘單字被移除  \n          → Step 11: leftWord ← s.substring(left, left + L) // 左端單字  \n          → Step 12: currentCount[leftWord] ← currentCount[leftWord] - 1 // 減少頻率  \n          → Decision: if currentCount[leftWord] < targetCount[leftWord]:  \n            Yes → matched ← matched - 1 // 匹配數減一  \n            No → // 無需改變匹配數  \n           → left ← left + L // 左端往右移動一個單字長度  \n           → // 繼續檢查直至頻率符合需求  \n          → // 之後再檢查是否已匹配全部單字  \n          → Decision: if matched == k: // 所有單字都已匹配  \n            Yes → result.append(left) // 記錄起始位置  \n            No → // 不是完整匹配，繼續往右  \n             → // 繼續向右滑動窗口  \n    → // 內層 for 迴圈結束  \n  → // 外層 offset 迴圈結束  \n→ End // 程式執行結束，返回 result\n\n> // 本虛擬碼使用滑動窗口與單字頻率表，逐位移 (offset) 依單字長度步進，確保每個窗口只檢查完整的單字，並在匹配數等於單字總數時記錄起始索引。",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def findSubstring(self, s: str, words: list[str]) -> list[int]:\n        \"\"\"\n        找出 s 中所有可以由 words 任意排列組成的連續子字串的起始索引。\n        透過滑動窗口與字頻表來做 O(n) 的搜尋。\n        \"\"\"\n        if not words:\n            return []\n\n        word_len = len(words[0])            # 每個單字長度\n        word_cnt = len(words)               # 單字個數\n        substring_len = word_len * word_cnt # 目標子字串長度\n\n        if len(s) < substring_len:\n            return []\n\n        # 建立需求字頻表\n        target = defaultdict(int)\n        for w in words:\n            target[w] += 1\n\n        result = []\n\n        # 針對不同的 offset（0~word_len-1）做滑動窗口\n        for offset in range(word_len):\n            left = offset                 # 窗口左端\n            matched = 0                   # 已匹配成功的單字數\n            window = defaultdict(int)     # 當前窗口的字頻表\n\n            for right in range(offset, len(s) - word_len + 1, word_len):\n                # 取得右端單字\n                word = s[right:right + word_len]\n\n                if word not in target:\n                    # 若不是需求單字，重置窗口\n                    left = right + word_len\n                    matched = 0\n                    window.clear()\n                    continue\n\n                # 加入右端單字\n                window[word] += 1\n                if window[word] <= target[word]:\n                    matched += 1\n                else:\n                    # 右端單字過多，收縮左端直到不超過需求\n                    while window[word] > target[word]:\n                        left_word = s[left:left + word_len]\n                        window[left_word] -= 1\n                        if window[left_word] < target[left_word]:\n                            matched -= 1\n                        left += word_len\n\n                # 若已匹配完所有單字，記錄起始索引\n                if matched == word_cnt:\n                    result.append(left)\n\n        return result\n\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入字串中解析出 s 與 words。\n    期望輸入形如：\n    s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n    \"\"\"\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', text)\n    words_match = re.search(r'words\\s*=\\s*\\[([^\\]]*)\\]', text)\n\n    if not s_match or not words_match:\n        raise ValueError(\"Invalid input format\")\n\n    s = s_match.group(1)\n    words_str = words_match.group(1)\n    # 取出所有被雙引號包住的單字\n    words = re.findall(r'\"([^\"]*)\"', words_str)\n    return s, words\n\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit(0)\n\n    # 解析輸入\n    try:\n        s, words = parse_input(raw_input)\n    except ValueError:\n        print(\"[]\")\n        sys.exit(0)\n\n    # 執行算法\n    solution = Solution()\n    indices = solution.findSubstring(s, words)\n\n    # 輸出結果\n    print(indices)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "success": true,
          "output": "[0, 9]"
        },
        {
          "example_index": 1,
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "success": true,
          "output": "[6, 9, 12]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode553.json",
    "problem_index_in_file": 0,
    "title": "Optimal Division",
    "description_snippet": "You are given an integer array nums. The adjacent integers in nums will perform the float division.\n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual algorithm for maximizing expression by inserting parentheses. Problem known: maximize division. Approach: For array nums, best is to put first element over product of rest. Because division is not associative. For n>=3, expression: nums[0] / (nums[1] * nums[2] * ...). So output string accordingly: if n==1: just element. if n==2: a/b. if n>=3: a/(b*c*...). No redundant parentheses: use parentheses only around product when n>2. So algorithm: compute expression string. Steps: handle n. Build string accordingly. Provide virtual steps.\n\nWe need to output virtual code lines. We'll write steps: Start, determine length, Decision etc.\n\nLet's produce pseudo-code:\n\nStart\n→ Step 1: Let n = length of nums\n→ Decision: if n == 1? // single number\n    Yes → Step 2: Output string representation of nums[0]\n    No → Decision: if n == 2? // two numbers\n        Yes → Step 3: Output nums[0] + \"/\" + nums[1]\n        No → Step 4: Build string: nums[0] + \"/(\" + join(nums[1:],\"*\") + \")\"\n\nAlso need to convert numbers to string.\n\nAdd end.\n\nMake sure each line has comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Decision: n == 1? // 只剩一個數字  \n    Yes → Step 2: result ← toString(nums[0]) // 直接輸出數字  \n    No  → Decision: n == 2? // 僅兩個數字  \n        Yes → Step 3: result ← toString(nums[0]) + \"/\" + toString(nums[1]) // 直接相除  \n        No  → Step 4: prodStr ← toString(nums[1]) // 初始右邊子表字串  \n                → Decision: n > 2? // 右邊還有多個數字  \n                    Yes → For i = 2 to n-1: prodStr ← prodStr + \"*\" + toString(nums[i]) // 連接乘號  \n                    No  → No action // 不會發生  \n                → Step 5: result ← toString(nums[0]) + \"/(\" + prodStr + \")\" // 加上必要括號  \n→ Step 6: return result // 回傳最終表達式  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def optimalDivision(self, nums):\n        \"\"\"\n        根據題目要求，產生能得到最大值的除法表達式。\n        當陣列長度為 1 時，直接回傳該數字；\n        當陣列長度為 2 時，回傳 a/b；\n        當陣列長度 ≥ 3 時，將第一個數字除以其餘數字的「串列除法」。\n        \"\"\"\n        n = len(nums)\n        if n == 1:\n            return str(nums[0])\n        if n == 2:\n            return f\"{nums[0]}/{nums[1]}\"\n        # n >= 3：將後面所有數字用 / 連結，並用括號包住\n        rest = \"/\".join(map(str, nums[1:]))\n        return f\"{nums[0]}/({rest})\"\n\ndef main():\n    \"\"\"\n    主函式：\n    1. 讀取標準輸入，預期格式為像 '[2,3,4]' 的字串。\n    2. 解析成列表。\n    3. 呼叫 optimalDivision。\n    4. 將結果列印到標準輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    try:\n        nums = ast.literal_eval(data)\n    except Exception as e:\n        raise ValueError(\"輸入格式不正確，請輸入形如 [2,3,4] 的陣列\") from e\n    if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums):\n        raise ValueError(\"輸入必須是整數陣列\")\n    sol = Solution()\n    result = sol.optimalDivision(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1000,100,10,2]",
          "expected_output": "\"1000/(100/10/2)\"",
          "success": true,
          "output": "1000/(100/10/2)"
        },
        {
          "example_index": 1,
          "input": "[2,3,4]",
          "expected_output": "\"2/(3/4)\"",
          "success": true,
          "output": "2/(3/4)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode368.json",
    "problem_index_in_file": 0,
    "title": "Largest Divisible Subset",
    "description_snippet": "Given a set of distinct positive integers nums, return the largest subset answer such that every pai...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce step-by-step pseudocode for this problem: find largest divisible subset. Approach: sort nums ascending, DP longest divisible subset. Provide steps. We'll produce pseudocode lines with arrow and decision. Use Start, End. Provide line by line. Ensure explanation comments. Use virtual code. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums in ascending order // 先將數字排好序，方便後續判斷可整除關係  \n→ Step 2: Initialise array dp[0…n-1] to 1 // dp[i] 代表以 nums[i] 為結尾的可整除子集最大長度  \n→ Step 3: Initialise array prev[0…n-1] to -1 // prev[i] 追蹤 dp[i] 所對應子集的上一個元素索引  \n→ Decision: 如果 nums 為空？ // 檢查是否有輸入  \n    No  → Step 4: For i = 0 to n-1  \n        → Step 5: For j = 0 to i-1  \n            → Decision: 如果 nums[i] % nums[j] == 0? // 判斷 j 能否整除 i  \n                Yes → Decision: 如果 dp[j] + 1 > dp[i]? // 更新更長的子集  \n                    Yes → Step 6: dp[i] = dp[j] + 1  \n                    → Step 7: prev[i] = j  \n                No  → Step 8: 進行下個 j  \n        → Step 9: 進行下個 i  \n→ Step 10: 找到 dp 中最大值 maxLen 與對應索引 maxIdx // 取得最大子集長度與結尾位置  \n→ Step 11: 建立空列表 result // 用於存放最終子集  \n→ Decision: 如果 maxLen == 0？ // 檢查是否有子集  \n    Yes → Step 12: Return result // 若無子集，直接回傳空  \n    No  → Step 13: While maxIdx != -1  \n        → Step 14: Append nums[maxIdx] to result // 從尾部回溯加入元素  \n        → Step 15: maxIdx = prev[maxIdx] // 移動到上一個元素  \n→ Step 16: Return result // 回傳最大可整除子集  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def largestDivisibleSubset(self, nums):\n        \"\"\"\n        找出最大可整除子集。\n        先把 nums 排序，利用 DP 逐步更新可整除子集長度與前驅索引。\n        \"\"\"\n        if not nums:\n            return []\n\n        nums.sort()\n        n = len(nums)\n        dp = [1] * n            # dp[i]：以 nums[i] 為結尾的子集最大長度\n        prev = [-1] * n         # prev[i]：dp[i] 所對應子集的前一個元素索引\n        max_index = 0           # 儲存目前最大子集的結尾索引\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0 and dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n                    prev[i] = j\n            if dp[i] > dp[max_index]:\n                max_index = i\n\n        # 從 max_index 回溯得到子集\n        result = []\n        while max_index >= 0:\n            result.append(nums[max_index])\n            max_index = prev[max_index]\n        result.reverse()  # 由小到大\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入，支援形如 \"nums = [1,2,3]\" 或僅 \"[1,2,3]\" 的格式\n    try:\n        if \"=\" in data:\n            _, expr = data.split(\"=\", 1)\n            nums = ast.literal_eval(expr.strip())\n        else:\n            nums = ast.literal_eval(data)\n    except Exception:\n        # 若解析失敗，直接輸出空列表\n        print([])\n        sys.exit(0)\n\n    solution = Solution()\n    result = solution.largestDivisibleSubset(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,4,8]",
          "expected_output": "[1,2,4,8]",
          "success": true,
          "output": "[1, 2, 4, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode705.json",
    "problem_index_in_file": 0,
    "title": "Design HashSet",
    "description_snippet": "Design a HashSet without using any built-in hash table libraries.\n\nImplement MyHashSet class:\n\nvoid ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for design of MyHashSet. Need to output line by line with arrows, Decision: etc. Provide explanation after each line.\n\nWe must not output actual code, only pseudo-steps.\n\nWe should design a simple hash set using array of buckets (linked lists) or bitset? Let's do simple separate chaining with array of buckets length maybe 1000. Each bucket holds list of keys. Methods: add, contains, remove.\n\nPseudo-code:\n\nStart // program start\n\n→ Step: Define class MyHashSet // 定義 MyHashSet 類別\n\n→ Step: Initialize bucket array size N = 1000 // 初始化哈希表大小\n\n→ Step: For each bucket, initialize empty list // 每個桶為空鏈表\n\n→ Decision: add(key) method\n   → Step: Compute index = hash(key) % N // 計算鍵的哈希索引\n   → Step: If key already in bucket[index] → Return // 若已存在則不重複加入\n   → Step: Append key to bucket[index] // 否則加入桶中\n\n→ Decision: contains(key) method\n   → Step: Compute index = hash(key) % N // 計算索引\n   → Step: For each k in bucket[index] if k == key → Return true\n   → Step: Return false // 若未找到返回 false\n\n→ Decision: remove(key) method\n   → Step: Compute index = hash(key) % N // 計算索引\n   → Step: For each k in bucket[index] if k == key → Remove k from list; break // 移除\n   // 若未找到則不做任何事\n\nEnd // 程式結束\n\nBut we need arrow syntax: Start, Step, Decision, etc. Each line as \"虛擬碼步驟 // 解釋\". Need arrows between steps. So we need to use \"→\" after each step or before each step? Format example uses \"→ Step 1: ...\" etc. So we start with \"Start // 程式開始執行\" then \"→ Step: ...\" etc. For decision: \"Decision: 如果 ...? // ...\" then indent sub-steps with \"Yes →\", \"No →\".\n\nBut we have multiple methods. We can treat each method as sub-block after class definition. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 MyHashSet // 建立 HashSet 類別\n→ Step 2: 初始化固定大小的桶陣列 buckets[1000] // 決定哈希表長度\n→ Decision: 將每個桶設為空鏈表? // 準備儲存鍵\n    Yes → Step 3: 針對每個索引 i, buckets[i] = 空鏈表 // 建立鏈表\n    No  → // 不需要做其他處理\nEnd // 程式結束\n\nBut we need also method definitions. Let's incorporate them after initialization.\n\nBetter to structure: After class definition, we describe methods.\n\nWe'll output lines sequentially, not nested maybe.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 MyHashSet 類別 // 主要結構\n→ Step 2: 設定常數 N = 1000 // 哈希表大小\n→ Step 3: 創建 buckets[0…N-1] // 桶陣列\n→ Decision: 將每個桶初始化為空鏈表? // 需要鏈表存儲鍵\n    Yes → Step 4: for i in 0 to N-1: buckets[i] = 空鏈表 // 初始化\n    No  → // 不須額外操作\n\nNow define add method:\n\n→ Step 5: 定義方法 add(key) // 添加鍵\n→ Step 6: 計算 index = hash(key) mod N // 哈希索引\n→ Decision: key 是否已存在於 buckets[index]? // 防止重複\n    Yes → Step 7: 返回 // 已存在不再加入\n    No  → Step 8: 將 key 加入 buckets[index] // 插入新鍵\n\nDefine contains method:\n\n→ Step 9: 定義方法 contains(key) // 檢查鍵\n→ Step 10: 計算 index = hash(key) mod N // 哈希索引\n→ Decision: key 是否在 buckets[index]? // 搜尋\n    Yes → Step 11: 返回 true // 找到\n    No  → Step 12: 返回 false // 未找到\n\nDefine remove method:\n\n→ Step 13: 定義方法 remove(key) // 刪除鍵\n→ Step 14: 計算 index = hash(key) mod N // 哈希索引\n→ Decision: key 是否在 buckets[index]? // 找到\n    Yes → Step 15: 從 buckets[index] 刪除 key // 刪除操作\n    No  → // 不做任何事\n\nEnd // 程式結束\n\nEnsure each line uses \"虛擬碼步驟 // 解釋\".\n\nAlso maintain arrow indentation: For decisions, we need \"Decision:\" then indent Yes/No with \"Yes →\", \"No →\".\n\nAlso for loops, we can include arrow? The example didn't show loops. But we can use Step: for loop.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyHashSet 類別 // 建立 HashSet 的主結構  \n→ Step 2: 設定常數 N = 1000 // 決定哈希表的固定大小  \n→ Step 3: 創建 buckets[0…N-1] // 初始化桶陣列  \n→ Decision: 將每個桶初始化為空鏈表? // 需要鏈表來儲存鍵  \n Yes → Step 4: for i in 0 to N-1: buckets[i] = 空鏈表 // 為每個桶建立空鏈表  \n No  → // 無需額外處理  \n\n→ Step 5: 定義方法 add(key) // 插入鍵  \n→ Step 6: 計算 index = hash(key) mod N // 取得鍵的桶索引  \n→ Decision: key 是否已存在於 buckets[index]? // 防止重複插入  \n Yes → Step 7: 返回 // 已存在則不做任何事  \n No  → Step 8: 將 key 加入 buckets[index] // 將新鍵加入桶中  \n\n→ Step 9: 定義方法 contains(key) // 檢查鍵是否存在  \n→ Step 10: 計算 index = hash(key) mod N // 取得桶索引  \n→ Decision: key 是否在 buckets[index]? // 搜尋該桶  \n Yes → Step 11: 返回 true // 找到鍵  \n No  → Step 12: 返回 false // 未找到鍵  \n\n→ Step 13: 定義方法 remove(key) // 刪除鍵  \n→ Step 14: 計算 index = hash(key) mod N // 取得桶索引  \n→ Decision: key 是否在 buckets[index]? // 確認鍵是否存在  \n Yes → Step 15: 從 buckets[index] 刪除 key // 執行刪除操作  \n No  → // 若鍵不存在，直接忽略  \n\nEnd // 程式結束執行",
      "generated_code": "import json\n\nclass MyHashSet:\n    def __init__(self):\n        self.size = 10000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key):\n        return key % self.size\n\n    def add(self, key):\n        h = self._hash(key)\n        if key not in self.buckets[h]:\n            self.buckets[h].append(key)\n\n    def remove(self, key):\n        h = self._hash(key)\n        if key in self.buckets[h]:\n            self.buckets[h].remove(key)\n\n    def contains(self, key):\n        h = self._hash(key)\n        return key in self.buckets[h]\n\nif __name__ == \"__main__\":\n    try:\n        ops_line = input().strip()\n        args_line = input().strip()\n    except EOFError:\n        ops_line = args_line = ''\n\n    if not ops_line or not args_line:\n        print(\"[]\")\n        exit()\n\n    ops = eval(ops_line)\n    args = eval(args_line)\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyHashSet\":\n            obj = MyHashSet()\n            result.append(None)\n        elif op == \"add\":\n            obj.add(*arg)\n            result.append(None)\n        elif op == \"remove\":\n            obj.remove(*arg)\n            result.append(None)\n        elif op == \"contains\":\n            res = obj.contains(*arg)\n            result.append(res)\n        else:\n            result.append(None)\n\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]",
          "expected_output": "[null, null, null, true, false, null, true, null, false]",
          "success": true,
          "output": "[null, null, null, true, false, null, true, null, false]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode645.json",
    "problem_index_in_file": 0,
    "title": "Set Mismatch",
    "description_snippet": "You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps to find duplicate and missing number. Use Start, Decision, etc. Use steps, arrays, loops. Should not output real code. Just virtual steps. Ensure each line has \"→ Step ...\" and comment. Use arrows for decisions. Let's craft solution. Likely approach: Use sum and sum of squares. Or use hash set. We'll describe algorithm. Provide steps line by line. Use virtual code. We'll show Start, set variables, loop to compute sums, etc. Then compute difference, etc. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 `n` 為 nums 的長度 // 取得集合大小  \n→ Step 2: 初始化變數 `sumNums` 為 0 // 用於累加 nums 的總和  \n→ Step 3: 初始化變數 `sumSqNums` 為 0 // 用於累加 nums 的平方和  \n→ Step 4: 初始化變數 `sumOrig` 為 n*(n+1)/2 // 1 到 n 的理論總和  \n→ Step 5: 初始化變數 `sumSqOrig` 為 n*(n+1)*(2n+1)/6 // 1 到 n 的平方理論總和  \n→ Step 6: 從 i = 0 開始，對 nums 進行遍歷  \n    → Decision: 是否已遍歷完所有元素？  \n      Yes → Step 7: 結束循環  \n      No → Step 8: 把 nums[i] 加到 `sumNums`  \n      → Step 9: 把 nums[i]^2 加到 `sumSqNums`  \n      → Step 10: i 增加 1  \n→ Step 11: 計算 `diff` = sumNums - sumOrig // duplicate - missing  \n→ Step 12: 計算 `diffSq` = sumSqNums - sumSqOrig // duplicate² - missing²  \n→ Step 13: 計算 `sum` = diffSq / diff // duplicate + missing  \n→ Step 14: 計算 `duplicate` = (diff + sum) / 2 // 由 (a-b)+(a+b)=2a 求得  \n→ Step 15: 計算 `missing` = duplicate - diff // a = b - (a-b)  \n→ Step 16: 定義結果陣列 `result` 為 [duplicate, missing] // 將答案放入陣列  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findErrorNums(self, nums):\n        n = len(nums)\n        sum_nums = sum(nums)\n        sum_set = sum(set(nums))\n        duplicate = sum_nums - sum_set\n        missing = n * (n + 1) // 2 - sum_set\n        return [duplicate, missing]\n\ndef parse_input(data: str):\n    data = data.strip()\n    if data.startswith(\"nums\"):\n        _, _, rest = data.partition('=')\n        data = rest.strip()\n    return ast.literal_eval(data)\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    solution = Solution()\n    result = solution.findErrorNums(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2,4]",
          "expected_output": "[2,3]",
          "success": true,
          "output": "[2, 3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode458.json",
    "problem_index_in_file": 0,
    "title": "Poor Pigs",
    "description_snippet": "There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out wh...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step-by-step to compute minimum pigs needed. The logic: number of test rounds = minutesToTest / minutesToDie (floor). Each pig can give 2^rounds states? Actually each pig can die in one of the rounds: each pig can be fed at specific round. Each pig gives (rounds+1) outcomes: die in round 1,2,...,rounds, or survive all. So total combinations = (rounds+1)^pigs >= buckets. Solve minimal pigs. So pseudocode: compute rounds, then loop p from 0 upward until (rounds+1)^p >= buckets. Return p.\n\nLet's produce step-by-step pseudocode lines.\n\nStart\n→ Step 1: Compute rounds = minutesToTest / minutesToDie (integer division) // how many feeding cycles possible\n→ Decision: If rounds == 0? // no time to feed\n    Yes → Step 2: Return 0 // no pigs needed (can't test?) But maybe need infinite? Actually if buckets>1 cannot test. But minimal pigs needed: if rounds==0, each pig can only be fed once? Actually with zero rounds, can't feed at all, but still you could test? We can feed pigs once at start? Wait process: choose pigs, feed, wait minutesToDie. After that time we may run out of time. If minutesToTest < minutesToDie, you can't run even one round, so can't determine which bucket. But problem may assume minutesToTest >= minutesToDie. We'll skip this case.\nProceed.\n\nStep 3: Initialize pigs = 0 // start with 0 pigs\n→ Decision: While (rounds + 1)^pigs < buckets? // need more pigs\n    Yes → pigs = pigs + 1 // increase pigs count\n    No  → Step 4: Return pigs // minimal number found\n\nBut we must implement exponent calculation. Use pow.\n\nSo produce pseudocode lines.\n\nAlso need explanation each line.\n\nLet's craft.\n\nAlso include Start, End. Provide arrows accordingly.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: rounds ← minutesToTest ÷ minutesToDie // 計算能進行的測試循環次數  \n→ Decision: 如果 rounds = 0? // 無法進行任何測試  \n  Yes → Step 2: 返回 0 // 若時間不足一個循環，則無法辨識，最少需要 0 只豬（此情況假設不會發生）  \n  No  → Step 3: pigs ← 0 // 從 0 只豬開始  \n→ Decision: (rounds + 1)^pigs < buckets? // 檢查目前豬數是否足以區分所有桶  \n  Yes → pigs ← pigs + 1 // 需要再加一只豬  \n  No  → Step 4: 返回 pigs // 已足夠，輸出最小豬數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_pigs_needed(buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n    \"\"\"\n    計算在給定時間內找出毒桶所需的最小豬數。\n    每隻豬在每個測試循環中都有 2 種可能（死亡或存活），\n    若有 `rounds` 次循環，則每隻豬可產生 `rounds + 1` 種獨立結果。\n    整體可區分的桶數為 (rounds + 1)^pigs，需要大於等於總桶數。\n    \"\"\"\n    # 可進行的完整循環次數\n    rounds = minutesToTest // minutesToDie\n    # 每隻豬能給出的獨立結果數\n    states = rounds + 1\n\n    pigs = 0\n    while pow(states, pigs) < buckets:\n        pigs += 1\n    return pigs\n\ndef main() -> None:\n    # 讀取整個輸入，使用正則表達式提取所有整數\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n\n    # 假設輸入中至少有三個整數：buckets, minutesToDie, minutesToTest\n    if len(numbers) < 3:\n        raise ValueError(\"Input must contain at least three integers.\")\n    buckets, minutesToDie, minutesToTest = numbers[0], numbers[1], numbers[2]\n\n    result = min_pigs_needed(buckets, minutesToDie, minutesToTest)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 15",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 30",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode49.json",
    "problem_index_in_file": 0,
    "title": "Group Anagrams",
    "description_snippet": "Given an array of strings strs, group the anagrams together. You can return the answer in any order....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines step by step. Use Start, End, Decision, etc. Should describe algorithm: group anagrams by sorted key. Use hash map mapping sorted string to list. Then output groups. We'll produce virtual code with arrows and comments. Use simplified lines.\n\nWe'll produce:\n\nStart\n→ Step 1: 建立空字典 groups // 以排序後字串作為鍵\n→ Step 2: 遍歷陣列 strs // 對每個字串進行處理\n    → Step 2a: 計算 key = sort(chars of str) // 排序得到組合鍵\n    → Decision: groups 含有 key? // 判斷是否已有該鍵\n        Yes → Step 2b1: groups[key].append(str) // 已有，加入\n        No  → Step 2b2: groups[key] = [str] // 無則建立新列表\n→ Step 3: 建立答案 list result = [] // 用於收集結果\n→ Step 4: 遍歷 groups.values() // 對每個分組\n    → Step 4a: result.append(list) // 加入到結果\n→ End // 回傳結果\n\nNeed to include [空格] after each line. Also use arrows for decisions. Provide explanation in comments. Ensure each line includes \"虛擬碼步驟 [space] // 解釋\". Use Start and End. Use arrow. Provide each line accordingly.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 groups // 用於存放以排序後字串為鍵的字串列表  \n→ Step 2: 遍歷陣列 strs // 逐一處理輸入字串  \n → Step 2a: 計算 key = sort(chars of str) // 把字串字元排序，作為分組鍵  \n → Decision: groups 含有 key? // 判斷此鍵是否已存在於字典中  \n  Yes → Step 2b1: groups[key].append(str) // 已有，將字串加入對應列表  \n  No  → Step 2b2: groups[key] = [str] // 無則建立新列表並存入字串  \n→ Step 3: 建立答案 list result = [] // 用於收集所有分組  \n→ Step 4: 遍歷 groups.values() // 取得每個分組的字串列表  \n → Step 4a: result.append(list) // 把分組加入結果集合  \nEnd // 程式執行結束，返回 result 為最終分組結果",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef groupAnagrams(strs):\n    \"\"\"將相同字母組成的字串分組\"\"\"\n    anagrams = defaultdict(list)\n    for s in strs:\n        # 把字串排序後作為鍵\n        key = tuple(sorted(s))\n        anagrams[key].append(s)\n    return list(anagrams.values())\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，支援 'strs = [...]' 或直接輸入 [...]\n    if '=' in data:\n        _, arr_part = data.split('=', 1)\n        strs = ast.literal_eval(arr_part.strip())\n    else:\n        strs = ast.literal_eval(data)\n    result = groupAnagrams(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
          "success": true,
          "output": "[['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]"
        },
        {
          "example_index": 1,
          "input": "strs = [\"\"]",
          "expected_output": "[[\"\"]]",
          "success": true,
          "output": "[['']]"
        },
        {
          "example_index": 2,
          "input": "strs = [\"a\"]",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[['a']]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode546.json",
    "problem_index_in_file": 0,
    "title": "Remove Boxes",
    "description_snippet": "You are given several boxes with different colors represented by different positive numbers.\n\nYou ma...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code algorithm for \"Remove Boxes\" problem (Leetcode 546). Need to output step-by-step pseudo-code with explanation per line. Should use arrows and structure. Provide dynamic programming solution with recursion and memoization: f(l,r,k) representing max points for subarray l..r with k boxes of same color as a[l] adjacent to left side.\n\nWe need to produce pseudo-code stepwise with explanation. Not actual code. Use Start, End, Decision. Let's produce algorithm outline.\n\nWe must produce steps: Start, read input boxes array. Then define function solve(l,r,k). Then recursion steps: if l>r return 0. If we can compress contiguous same colors at start: while l+1<=r && boxes[l]==boxes[l+1], l++, k++. Then we consider two options: remove boxes[l] along with k boxes now: option1 = (k+1)^2 + solve(l+1,r,0). Then try merging with later same color boxes: for m from l+1 to r where boxes[m]==boxes[l], we can consider solve(l+1,m-1,0) + solve(m,r,k+1). Take max. Memoize result. Return max.\n\nWe'll produce pseudo-code lines with explanations. Need to ensure each line is separate.\n\nAlso include input reading, storing memoization map. Use Decision arrows.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: Boxes[] // 讀入顏色編號陣列  \n→ Memo = {} // 初始化遞迴記憶表  \n\n→ Function MaxPoints(l, r, k): // 計算子陣列 l..r 右側連續相同顏色數量為 k 的最大分數  \n  Decision: 若 l > r? // 子陣列已無盒子  \n   Yes → Return 0 // 無分數  \n   No  \n  → // 合併前綴相同顏色  \n   While l+1 ≤ r 且 Boxes[l] = Boxes[l+1]: // 找到連續相同顏色  \n      l = l + 1  \n      k = k + 1  \n   End While  \n  → // 方案 1: 直接移除左邊的盒子及其 k 個相鄰同色  \n   Option1 = (k+1) * (k+1) + MaxPoints(l+1, r, 0)  \n  → // 方案 2: 尋找後面相同顏色以合併分數  \n   Best = Option1  \n   For m from l+1 to r: // 遍歷所有可能的合併位置  \n    Decision: 若 Boxes[m] = Boxes[l]? // 找到同色盒子  \n     Yes  \n       // 先把中間的盒子全部移除，留下左側盒子與右側合併  \n       Part1 = MaxPoints(l+1, m-1, 0)  \n       Part2 = MaxPoints(m, r, k+1) // 右側盒子左邊多一個同色盒子  \n       Best = max(Best, Part1 + Part2)  \n       No  \n    End For  \n  → Memo[(l,r,k)] = Best // 記錄結果以備重用  \n  → Return Best  \n\n→ // 主程式調用  \n→ Result = MaxPoints(0, len(Boxes)-1, 0) // 從整個陣列開始計算  \n→ Output Result // 印出最大分數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nsys.setrecursionlimit(10000)\n\nclass Solution:\n    def removeBoxes(self, boxes):\n        memo = {}\n        n = len(boxes)\n\n        def dp(l, r, k):\n            if l > r:\n                return 0\n            if (l, r, k) in memo:\n                return memo[(l, r, k)]\n\n            # 合併右端相同顏色\n            while r > l and boxes[r] == boxes[r - 1]:\n                r -= 1\n                k += 1\n\n            # 方案1：直接把右端(含k個相同色)移除\n            res = dp(l, r - 1, 0) + (k + 1) ** 2\n\n            # 方案2：尋找左側相同顏色，與右端合併\n            for i in range(l, r):\n                if boxes[i] == boxes[r]:\n                    res = max(res, dp(l, i, k + 1) + dp(i + 1, r - 1, 0))\n\n            memo[(l, r, k)] = res\n            return res\n\n        return dp(0, n - 1, 0)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入中提取整數列表\n    m = re.search(r'\\[(.*?)\\]', data)\n    if m:\n        nums_str = m.group(1)\n        if nums_str.strip() == '':\n            boxes = []\n        else:\n            boxes = list(map(int, nums_str.split(',')))\n    else:\n        boxes = []\n\n    result = Solution().removeBoxes(boxes)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "boxes = [1,3,2,2,2,3,4,3,1]",
          "expected_output": "23",
          "success": true,
          "output": "23"
        },
        {
          "example_index": 1,
          "input": "boxes = [1,1,1]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 2,
          "input": "boxes = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode488.json",
    "problem_index_in_file": 0,
    "title": "Zuma Game",
    "description_snippet": "You are playing a variation of the game Zuma. \nIn this variation of Zuma, there is a single row of c...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solving the Zuma variation minimal insertions. Should use steps, decisions, etc. Must not produce actual code, just virtual steps. Provide explanation per line. We'll structure algorithm: DFS with memoization. Steps: Start, normalize board (compress runs), function dfs(board, handCount). Base cases: board empty => 0. If hand empty and board not empty => INF. For each color with count>0, try to insert to collapse. Determine minimal insertion: For each position, find continuous same color group and see needed insertions to reach 3. If possible, simulate removal and recursion. Keep best. Use memoization map key: board + hand counts string. Return min insert or INF. Finally, if result INF => -1 else result.\n\nWe need step-by-step virtual code with explanation.\n\nLet's produce. Use arrows etc. Use \"→\" for continuation.\n\nWe'll denote functions: DFS. Use Start and End. We'll show decisions. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化手牌計數 dict handCnt // 把 hand 字串轉成每種顏色的數量  \n→ Step 2: 建立 memo map memo // 用於記錄已計算過的 (board, handCnt) 結果  \n→ Step 3: 呼叫 DFS(board, handCnt) // 開始遞迴求解最小插入數  \n\n// ---------------- DFS 函式 ----------------  \nStart DFS(board, handCnt) // 進入遞迴  \n→ Decision: 如果 board 為空? // 目標已達  \n    Yes → Return 0 // 不需要再插入任何球  \n    No  → Decision: 如果沒有任何手牌可用? // 無法繼續  \n        Yes → Return INF // 表示不可達成，使用大值表示不可行  \n        No  → → Step 4: 檢查 memo 是否存在 key(board, handCnt)  \n            Yes → Return memo[key] // 直接回傳已計算結果  \n            No  → → Step 5: 將 board 進行簡化（合併連續相同顏色並記錄長度）  \n            → Step 6: 初始化 best = INF // 記錄目前最小插入數  \n            → Step 7: 針對每個位置 i 在 board 之間或兩端  \n                → SubStep: 找到相鄰相同顏色區塊 [l, r]  \n                → SubStep: 計算需要插入的數量 need = max(0, 3 - (r-l+1))  \n                → SubStep: 若 handCnt[color] >= need // 可以插入足夠球  \n                    → Decision: 需要插入多少?  \n                        Yes → Step 8: 將需要的球插入，形成新串 newBoard  \n                        → Step 9: 重複移除連續 3+ 同色區塊直到無法移除，得到 collapsedBoard  \n                        → Step 10: 更新手牌 count newHandCnt[color] -= need  \n                        → Step 11: Call res = DFS(collapsedBoard, newHandCnt)  \n                        → Step 12: 若 res != INF  \n                            → Update best = min(best, res + need) // 加回插入數量  \n            → Step 13: memo[key] = best // 儲存結果  \n            → Return best // 回傳最小插入數  \n\nEnd DFS // DFS 函式結束  \n\n// ---------------- 主程式結束 ----------------  \nStart // 進入主流程  \n→ Step 14: result = DFS(board, handCnt) // 取得最小插入數或 INF  \n→ Decision: 如果 result == INF?  \n    Yes → Return -1 // 無法清除所有球  \n    No  → Return result // 返回最小插入數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nINF = 10 ** 9\n\ndef compress(board: str):\n    \"\"\"把連續相同顏色的球合併為一個節點，返回 (colors, counts)\"\"\"\n    colors, counts = [], []\n    i = 0\n    n = len(board)\n    while i < n:\n        j = i + 1\n        while j < n and board[j] == board[i]:\n            j += 1\n        colors.append(board[i])\n        counts.append(j - i)\n        i = j\n    return ''.join(colors), tuple(counts)\n\ndef remove(board: str, l: int, r: int):\n    \"\"\"刪除區間 [l, r] 之後，遞迴消除連續 3+ 相同顏色，回傳新棋盤\"\"\"\n    new_board = board[:l] + board[r + 1:]\n    # 重新檢查是否還有可消除的區間\n    i = 0\n    n = len(new_board)\n    while i < n:\n        j = i + 1\n        while j < n and new_board[j] == new_board[i]:\n            j += 1\n        if j - i >= 3:\n            return remove(new_board[:i] + new_board[j:], i - 1)\n        i = j\n    return new_board\n\ndef dfs(board: str, hand_cnt: dict, memo: dict):\n    \"\"\"遞迴搜尋，回傳最小插入數，若不可行回傳 INF\"\"\"\n    if not board:\n        return 0\n    key = (board, tuple(hand_cnt[c] for c in 'RYBGW'))\n    if key in memo:\n        return memo[key]\n\n    best = INF\n    colors, counts = compress(board)\n    n = len(colors)\n\n    for i in range(n):\n        color = colors[i]\n        need = 3 - counts[i]  # 需要插入多少球才能消除\n        if need <= 0:\n            continue\n        if hand_cnt[color] < need:\n            continue\n\n        # 插入並消除\n        new_hand = hand_cnt.copy()\n        new_hand[color] -= need\n        l = sum(counts[:i])            # 插入位置左端的索引\n        r = l + counts[i] - 1          # 右端索引\n        new_board = remove(board, l, r)\n        res = dfs(new_board, new_hand, memo)\n        if res < INF:\n            best = min(best, res + need)\n\n    memo[key] = best\n    return best\n\ndef find_min_step(board: str, hand: str) -> int:\n    hand_cnt = Counter(hand)\n    memo = {}\n    ans = dfs(board, hand_cnt, memo)\n    return -1 if ans >= INF else ans\n\ndef parse_input(data: str):\n    \"\"\"從輸入文字解析 board 與 hand\"\"\"\n    data = data.strip()\n    # 先嘗試找雙引號中的兩個字串\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        return matches[0], matches[1]\n    # 再嘗試用空白分隔\n    parts = data.split()\n    if len(parts) >= 2:\n        return parts[0].strip(), parts[1].strip()\n    # 仍無法解析，回傳空字串\n    return '', ''\n\ndef main():\n    data = sys.stdin.read()\n    board, hand = parse_input(data)\n    if not board or not hand:\n        # 若無法解析，直接輸出 -1\n        print(-1)\n        return\n    result = find_min_step(board, hand)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "board = \"WRRBBW\", hand = \"RB\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpzmt7g7y6.py\", line 100, in <module>\n    main()\n  File \"/tmp/tmpzmt7g7y6.py\", line 96, in main\n    result = find_min_step(board, hand)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzmt7g7y6.py\", line 72, in find_min_step\n    ans = dfs(board, hand_cnt, memo)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzmt7g7y6.py\", line 62, in dfs\n    res = dfs(new_board, new_hand, memo)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzmt7g7y6.py\", line 61, in dfs\n    new_board = remove(board, l, r)\n                ^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzmt7g7y6.py\", line 32, in remove\n    return remove(new_board[:i] + new_board[j:], i - 1)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: remove() missing 1 required positional argument: 'r'"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode564.json",
    "problem_index_in_file": 0,
    "title": "Find the Closest Palindrome",
    "description_snippet": "Given a string n representing an integer, return the closest integer (not including itself), which i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The task: Given a string n representing integer, return closest integer (not including itself) that is palindrome. If tie, return smaller. We need to generate steps.\n\nWe need to output step by step algorithm in pseudo-code, with each line having the virtual code step and comment.\n\nWe need to think about algorithm. Standard approach: compute nearest palindrome by generating candidates based on n's length. Use typical nearest palindrome algorithm. Steps: parse n to integer? But we can operate as string.\n\nWe need to produce a high-level pseudo-code. Provide decisions.\n\nWill produce:\n\nStart\n\n→ Parse input string to integer num\n\n→ Determine length len\n\n→ Build candidate list: [10^(len-1)-1, 10^len+1] as boundary palindromes (e.g., 99..9 and 100..001)\n\n→ Compute prefix = first ceil(len/2) digits of num\n\n→ For each delta in [-1,0,1] produce candidate by adjusting prefix: prefix+delta, construct palindrome of same length using mirror (if even or odd length)\n\n→ Add candidates to list\n\n→ Remove the original number from candidates (if present)\n\n→ Initialize bestCandidate = None, minDiff = Infinity\n\n→ For each candidate in list:\n\n    compute diff = abs(candidate - num)\n\n    If diff < minDiff or (diff == minDiff and candidate < bestCandidate): update\n\n→ Return bestCandidate\n\nAlso need decision structures.\n\nWe need to show steps, decisions, arrow etc.\n\nLet's produce lines accordingly.\n\nWill use format:\n\nStart // 程式開始執行\n\n→ Step 1: 轉換輸入字串為整數 num // 取得數字\n\n→ Step 2: 計算字串長度 len // 取得位數\n\n→ Step 3: 建立候選者清單 candidates // 初始化候選清單\n\n    → Step 3.1: candidates ← [10^(len-1)-1, 10^len+1] // 边界回文\n\n→ Step 4: 取得前半段 prefix = 前 ceil(len/2) 位 // 取前半\n\n→ Decision: 是否為偶數位? // 檢查長度\n\n    Yes → Step 4.1: mirrorFunction(prefix)  // 對偶數\n\n    No  → Step 4.2: mirrorFunction(prefix without last digit) // 對奇數\n\nBut we need to generate for delta -1,0,1.\n\nWe can use loop.\n\nSo lines.\n\nWe need to use Decision blocks.\n\nAlso final selection.\n\nLet's create lines.\n\nWe also need to note that we may compute prefix as integer.\n\nOk produce.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 轉換輸入字串為整數 num // 取得原始數字  \n→ Step 2: 計算字串長度 len // 取得數字位數  \n→ Step 3: 建立候選者清單 candidates ← 空集 // 初始化候選清單  \n→ Step 4: 計算最小回文邊界 candidates ← candidates ∪ {10^(len-1)-1, 10^len+1} // 兩端的完整回文  \n→ Step 5: 取得前半段前導字串 prefix ← n 的前 ceil(len/2) 位 // 用於構造回文  \n→ Decision: 是否為偶數位? // 判斷位數奇偶  \n Yes → Step 6: 設定 offsetList ← {-1, 0, 1} // 對偶數長度調整前半段  \n No  → Step 7: 設定 offsetList ← {-1, 0, 1} // 對奇數長度調整前半段（最後一位不鏡射）  \n→ Step 8: 迭代 offsetList  \n → Step 8.1: 生成新前導 newPrefix ← int(prefix) + offset // 變更前半段  \n  Decision: newPrefix 是否為負?  \n   Yes → Step 8.1.1: 跳過此 offset // 負值不可行  \n   No  → Step 8.1.2: 轉換為字串 newPrefixStr ← str(newPrefix)  \n    Decision: newPrefixStr 長度是否為 ceil(len/2)?  \n     Yes → Step 8.1.3: 產生回文 candidate ← 形成回文(newPrefixStr, len) // 根據長度產生鏡像  \n     No  → Step 8.1.4: 產生回文 candidate ← 形成回文(newPrefixStr, len) // 若長度縮短，仍使用鏡像法  \n       Step 8.1.5: candidates ← candidates ∪ {candidate} // 加入候選清單  \n→ Step 9: 移除原始數字若存在於候選者中 // 不能自我回文  \n → Decision: num ∈ candidates?  \n  Yes → Step 9.1: candidates ← candidates \\ {num}  \n  No  → Step 9.2: 無操作  \n→ Step 10: 初始化 bestCandidate ← null, minDiff ← ∞ // 設定最佳結果  \n→ Step 11: 迭代候選者 candidates  \n → Step 11.1: 計算差值 diff ← |candidate - num| // 絕對差  \n  Decision: diff < minDiff?  \n   Yes → Step 11.2: bestCandidate ← candidate, minDiff ← diff // 更新更近回文  \n   No → Decision: diff == minDiff?  \n    Yes → Decision: candidate < bestCandidate?  \n     Yes → Step 11.3: bestCandidate ← candidate // 兩者距離相同取較小者  \n     No → Step 11.4: 無操作  \n    No → Step 11.5: 無操作  \n→ Step 12: 回傳 bestCandidate // 結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef nearest_palindromic(n: str) -> str:\n    \"\"\"Return the nearest palindrome (excluding n). If tie, smaller one.\"\"\"\n    length = len(n)\n    num = int(n)\n    candidates = set()\n\n    # Special edge palindromes: 10^len + 1 and 10^(len-1) - 1\n    candidates.add(str(10 ** length + 1))\n    candidates.add(str(10 ** (length - 1) - 1))\n\n    # Prefix to manipulate\n    half = (length + 1) // 2\n    prefix = int(n[:half])\n\n    for diff in (-1, 0, 1):\n        new_prefix = str(prefix + diff)\n        if length % 2 == 0:\n            # Even length: mirror entire new_prefix\n            palin = new_prefix + new_prefix[::-1]\n        else:\n            # Odd length: mirror excluding the middle digit\n            palin = new_prefix + new_prefix[:-1][::-1]\n        candidates.add(palin)\n\n    # Remove the original number itself if present\n    candidates.discard(n)\n\n    best = None\n    best_diff = None\n    for cand in candidates:\n        # Skip empty strings or strings with leading zeros that become 0\n        if cand == '':\n            continue\n        try:\n            cand_num = int(cand)\n        except ValueError:\n            continue\n        diff = abs(cand_num - num)\n        if best is None or diff < best_diff or (diff == best_diff and cand_num < int(best)):\n            best = cand\n            best_diff = diff\n\n    return best\n\ndef solve() -> None:\n    \"\"\"Read input, compute nearest palindrome, and print result.\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the numeric part (handles formats like: n = \"123\" or just 123)\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n_str = match.group(0)\n\n    result = nearest_palindromic(n_str)\n    # Output with double quotes as shown in examples\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = \"123\"",
          "expected_output": "\"121\"",
          "success": true,
          "output": "\"121\""
        },
        {
          "example_index": 1,
          "input": "n = \"1\"",
          "expected_output": "\"0\"",
          "success": true,
          "output": "\"0\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode442.json",
    "problem_index_in_file": 0,
    "title": "Find All Duplicates in an Array",
    "description_snippet": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and e...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines for algorithm: given array nums length n, values 1..n, each appears at most twice, find duplicates. O(n) time, constant extra space except output. Standard solution: iterate, for each num, index = abs(num)-1; if nums[index] < 0 mark seen? Actually we can negate value at index. Since each appears at most twice, when encountering duplicate, nums[index] will already be negative, then record duplicate. Then restore? We don't need restore if only output. But to keep O(1) extra, we can modify array. After loop, return result.\n\nThus virtual code steps: Start, Step 1: Initialize empty list result, Step 2: For i from 0 to n-1: current = abs(nums[i]); index = current-1; if nums[index] < 0: add current to result; else: nums[index] = -nums[index]; Step 3: return result; End.\n\nWe need to show decision step? We could incorporate decision inside loop. But it's simple.\n\nLet's output with virtual code arrow.\n\nWe must follow format: \"Start // ...\" then \"→ Step 1: ... // ...\" etc.\n\nMake sure each line includes // explanation. Use virtual code arrow. Provide decision step? Not necessary but we can include decision in loop: \"Decision: nums[index] < 0?\" but we can just show within step.\n\nBetter to show: Step 2: For each i... inside maybe Decision.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: result ← empty list // 初始化儲存重複數字的清單\n→ Step 2: For i from 0 to n-1 // 遍歷整個陣列\n    → Decision: nums[i] 的絕對值表示目標索引？ // 取得目前數字的絕對值\n        Yes → current ← abs(nums[i]) // 取目前數字\n        → index ← current - 1 // 對應的索引\n        → Decision: nums[index] 已經為負數? // 判斷是否已被標記\n            Yes → Step 3: result.append(current) // 已標記，表示重複，加入結果\n            No  → Step 4: nums[index] ← -nums[index] // 尚未標記，將對應位置的值取負作標記\nEnd // 程式執行結束\n\nBut we also need Step 5: return result? We can add after loop. So maybe include Step 5 after loop: result is final. But we don't need to exit loop.\n\nLet's restructure:\n\nStart\n→ Step 1: result ← [] // 初始化結果清單\n→ Step 2: For i in 0..n-1 // 遍歷陣列\n    → current ← abs(nums[i]) // 取絕對值作為數字\n    → index ← current - 1 // 對應索引\n    → Decision: nums[index] < 0? // 已被標記？\n        Yes → result.append(current) // 重複，加入結果\n        No  → nums[index] ← -nums[index] // 標記已見過\n→ Step 3: return result // 返回所有重複數字\nEnd\n\nAdd explanation each line.\n\nLet's format accordingly. Use arrow lines. Provide indentation for nested. Use \"→\" before each line. Provide comments. Ensure each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: result ← [] // 初始化一個空清單用於儲存重複的數字\n→ Step 2: For i from 0 to n-1 // 逐一遍歷陣列 nums\n    → current ← abs(nums[i]) // 取得目前元素的絕對值，因為可能已被取負\n    → index ← current - 1 // 對應的目標索引（數字範圍為 1..n）\n    → Decision: nums[index] < 0? // 判斷目標位置是否已被標記為負\n        Yes → result.append(current) // 已為負，表示該數字已出現一次，加入結果\n        No  → nums[index] ← -nums[index] // 仍為正，將其取負做標記，表示已見過\n→ Step 3: return result // 返回所有被標記為重複的數字\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\n\ndef find_duplicates(nums):\n    \"\"\"\n    找出重複出現的數字，使用 O(n) 時間與 O(1) 附加空間（除輸出外）。\n    \"\"\"\n    result = []\n    for i in range(len(nums)):\n        index = abs(nums[i]) - 1  # 對應的索引（數字範圍 1..n）\n        if nums[index] < 0:       # 已被標記為負，表示已出現過\n            result.append(abs(nums[i]))\n        else:\n            nums[index] = -nums[index]  # 將對應位置取負做標記\n    return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中提取列表部分\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        nums_str = data\n    else:\n        nums_str = data[start:end+1]\n\n    # 解析列表\n    nums = ast.literal_eval(nums_str)\n\n    # 找出重複元素\n    duplicates = find_duplicates(nums)\n\n    # 以無空格的列表格式輸出\n    output = '[' + ','.join(map(str, duplicates)) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[2,3]",
          "success": true,
          "output": "[2,3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,2]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode146.json",
    "problem_index_in_file": 0,
    "title": "LRU Cache",
    "description_snippet": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplemen...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for an LRU cache implementation. The user wants virtual code steps, not actual code. We must provide each line with explanation. Use arrows and Start/End, Decision. Use typical structure: Start, then Step: initialize capacity, maintain doubly linked list, hash map. Provide steps for get and put.\n\nWe must show logic for get: check map, if found move node to front, return value, else return -1.\n\nPut: if key exists update value, move to front; else create node, insert at front; add to map; if size > capacity remove tail; delete from map.\n\nWe need to use decision nodes.\n\nLet's write line by line. Use \"→ Step X:\" etc.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 HashMap<Key, Node> // 以 O(1) 存取\n→ Step 2: 建立 DummyHead 與 DummyTail 的雙向鏈表 // 方便移動節點\n→ Step 3: 設定 capacity 與 size // 容量與目前大小\nEnd // 初始化結束\n\nThen separate get method:\n\nStart get // get 方法開始\n→ Decision: 是否存在 key 在 map? // 檢查 key\n    Yes → Step 4: 取出 Node node = map[key] // 取得節點\n    → Step 5: 移除 node 從鏈表 // 先把節點移除\n    → Step 6: 插入 node 到頭部 // 標記最近使用\n    → Step 7: Return node.value // 回傳值\n    No  → Step 8: Return -1 // 未找到\n\nEnd get\n\nSimilarly put method:\n\nStart put // put 方法開始\n→ Decision: 是否存在 key 在 map? // 檢查 key\n    Yes → Step 9: 取出 Node node = map[key] // 取得節點\n    → Step 10: 更新 node.value = value // 更新值\n    → Step 11: 移除 node 從鏈表 // 移除舊位置\n    → Step 12: 插入 node 到頭部 // 標記最近使用\n    No  → Step 13: 建立新節點 node = Node(key, value) // 新節點\n    → Step 14: 插入 node 到頭部 // 最近使用\n    → Step 15: map[key] = node // 加入 map\n    → Step 16: size += 1 // 數量增加\n→ Decision: size > capacity? // 檢查是否超容量\n    Yes → Step 17: 取 tail.prev 為要移除節點 // 從尾部取得 LRU\n    → Step 18: 移除 tailPrev 從鏈表 // 刪除節點\n    → Step 19: map.erase(tailPrev.key) // 從 map 刪除\n    → Step 20: size -= 1 // 數量減少\n    No  → Step 21: // 無需移除\n\nEnd put\n\nFinally End // 程式結束\n\nBut must maintain one Start per entire program? The example shows only one Start and End. We could include a single program structure: Start, define class, etc. But they ask for virtual code for each step of design, not full program skeleton. We can provide separate blocks for initialization, get, put.\n\nProbably best to have a Start, then define class with constructor, get, put, End. Within each method, use decision steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 LRUCache 類別 // 宣告類別\n→ Step 2: 建立 private 成員: capacity, size, HashMap, DummyHead, DummyTail // 基本結構\n→ Step 3: LRUCache(int capacity) 初始化 // 建構子\n    → Step 4: this.capacity = capacity\n    → Step 5: this.size = 0\n    → Step 6: 建立 DummyHead 與 DummyTail 並相連 // 初始化鏈表\n    → Step 7: this.map = new HashMap() // 初始化 map\n→ Method get(int key) // 定義 get 方法\n    → Decision: key 是否存在 map? \n        Yes → Step 8: node = map[key]\n        → Step 9: remove node from list\n        → Step 10: insert node at front\n        → Step 11: Return node.value\n        No  → Step 12: Return -1\n→ Method put(int key, int value) // 定義 put 方法\n    → Decision: key 是否存在 map? \n        Yes → Step 13: node = map[key]\n        → Step 14: node.value = value\n        → Step 15: remove node from list\n        → Step 16: insert node at front\n        No  → Step 17: node = new Node(key, value)\n        → Step 18: insert node at front\n        → Step 19: map[key] = node\n        → Step 20: size += 1\n    → Decision: size > capacity? \n        Yes → Step 21: lru = tail.prev\n        → Step 22: remove lru from list\n        → Step 23: map.erase(lru.key)\n        → Step 24: size -= 1\n        No  → Step 25: // no action\n→ End // 程式執行結束\n\nNeed to keep one arrow at each line. Use \"→\" for steps. For decision, indent the Yes/No blocks. Use \"Decision:\" lines. Provide comments.\n\nAlso we might want to include helper functions: remove, insertAtFront. But we can inline as steps.\n\nMake sure each line ends with `// 解釋`.\n\nOk let's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 LRUCache 類別 // 宣告類別結構  \n→ Step 2: 建立私有成員變數 capacity, size, map, dummyHead, dummyTail // 基本資料結構  \n→ Step 3: LRUCache(int capacity) 初始化 // 建構子開始  \n  → Step 4: this.capacity = capacity // 設定容量  \n  → Step 5: this.size = 0 // 初始大小為 0  \n  → Step 6: dummyHead = new Node(0, 0) // 建立假頭節點  \n  → Step 7: dummyTail = new Node(0, 0) // 建立假尾節點  \n  → Step 8: dummyHead.next = dummyTail // 連接假頭到假尾  \n  → Step 9: dummyTail.prev = dummyHead // 連接假尾到假頭  \n  → Step 10: map = new HashMap() // 建立 key→node 的哈希表  \n→ Method get(int key) // get 方法開始  \n  → Decision: key 是否存在於 map? // 檢查 key 是否已被儲存  \n   Yes → Step 11: node = map.get(key) // 取得節點  \n    → Step 12: removeNode(node) // 把節點從鏈表中移除  \n    → Step 13: insertAtFront(node) // 把節點插到鏈表頭部  \n    → Step 14: Return node.value // 回傳對應值  \n   No  → Step 15: Return -1 // 若不存在則回傳 -1  \n→ Method put(int key, int value) // put 方法開始  \n  → Decision: key 是否存在於 map? // 判斷是否為更新還是新增  \n   Yes → Step 16: node = map.get(key) // 取得舊節點  \n    → Step 17: node.value = value // 更新節點值  \n    → Step 18: removeNode(node) // 移除舊位置  \n    → Step 19: insertAtFront(node) // 重新放到前面  \n   No  → Step 20: node = new Node(key, value) // 建立新節點  \n    → Step 21: insertAtFront(node) // 放到前面  \n    → Step 22: map.put(key, node) // 加入哈希表  \n    → Step 23: size += 1 // 增加大小計數  \n  → Decision: size > capacity? // 檢查是否超過容量  \n   Yes → Step 24: lru = dummyTail.prev // 找到最久未使用節點  \n    → Step 25: removeNode(lru) // 從鏈表移除  \n    → Step 26: map.remove(lru.key) // 從哈希表刪除  \n    → Step 27: size -= 1 // 減少大小計數  \n   No  → Step 28: // 不需要移除任何節點  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    ops, args = ast.literal_eval('(' + data + ')')\n    results = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == 'LRUCache':\n            cache = LRUCache(arg[0])\n            results.append(None)\n        elif op == 'put':\n            cache.put(arg[0], arg[1])\n            results.append(None)\n        elif op == 'get':\n            res = cache.get(arg[0])\n            results.append(res)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "success": true,
          "output": "[null, null, null, 1, null, -1, null, -1, 3, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode9.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Number",
    "description_snippet": "Given an integer x, return true if x is a palindrome, and false otherwise....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. The requirement: use \"Start\", \"End\", \"Decision:\", use arrows. Each line: virtual code step + space + // explanation.\n\nWe must generate a step-by-step algorithm: Input integer x, return true if palindrome. Steps: convert to string, compare with reverse or two-pointer approach. Use decision: if negative or ends with 0? Might include edge case. Simpler: convert to string, check equality with reverse. Or numeric approach: reverse digits until half. Use pseudocode steps.\n\nWe should produce lines: Start, Step 1: Input x, etc. Use arrows: \"→\". Provide decisions.\n\nLet's craft:\n\nStart\n→ Step 1: Receive integer x // 获取输入整数\n→ Decision: 如果 x < 0? // 负数无法为回文\n    Yes → Step 2: 返回 false // 负数直接返回 false\n    No  → Decision: 如果 x 末尾为 0? 且 x 不是 0? // 以 0 结尾的非零数不是回文\n        Yes → Step 3: 返回 false // 直接返回 false\n        No  → Step 4: 计算整数的反转数 rev 只反转一半 // 开始反转数字的后半部分\n→ Step 5: 如果 rev 等于原整数的前半部分? // 检查是否相等\n    Yes → Step 6: 返回 true // 是回文\n    No  → Step 7: 返回 false // 不是回文\nEnd\n\nBut we need to explain each step.\n\nAlso maybe include step of computing reverse: while x > rev: rev = rev *10 + x%10; x//=10\n\nLet's incorporate.\n\nVirtual code:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入整數 x // 取得要判斷的數字\n→ Decision: 如果 x < 0? // 負數無法為回文\n    Yes → Step 2: 返回 false // 直接返回 false\n    No  → Decision: 如果 x % 10 == 0 且 x != 0? // 末尾為 0 的非零數不是回文\n        Yes → Step 3: 返回 false // 直接返回 false\n        No  → Step 4: 設定 rev = 0 // 初始化反轉數\n→ Step 5: 循環: 當 x > rev 時\n    → Step 5a: rev = rev * 10 + x % 10 // 將 x 最右位取出並加到 rev\n    → Step 5b: x = x // 10 // 去掉 x 的最右位\n→ Decision: 如果 x == rev? // 整數是否回文\n    Yes → Step 6: 返回 true // 回文\n    No  → Decision: 如果 x == rev / 10? // 奇數位長度時需要去掉中間位\n        Yes → Step 7: 返回 true // 回文\n        No  → Step 8: 返回 false // 不是回文\nEnd // 程式結束\n\nWe should keep each line a single step: maybe split loop into a single decision with steps inside? Use arrows for nested steps. Let's format accordingly.\n\nWe must maintain \"Start\", \"End\", \"Decision:\" labels. Use arrow \"→\". Each line with explanation comment.\n\nWe should not output code, just virtual code. Use no actual code syntax. Just steps like \"Step 1:\".\n\nWe can add indentation for nested decisions? Use indentation.\n\nThe example uses \"Decision:\" line and then Yes→ and No→ lines.\n\nWe should produce something similar.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入整數 x // 取得要判斷的數字  \n→ Decision: 如果 x < 0? // 負數無法為回文  \n  Yes → Step 2: 返回 false // 直接返回 false  \n  No  → Decision: 如果 x % 10 == 0 且 x != 0? // 末尾為 0 的非零數不是回文  \n   Yes → Step 3: 返回 false // 直接返回 false  \n   No  → Step 4: 設定 rev = 0 // 初始化反轉數  \n→ Decision: 迴圈條件: x > rev? // 只需反轉到一半  \n  Yes → Step 5a: rev = rev * 10 + x % 10 // 取 x 的最低位加到 rev  \n   → Step 5b: x = x // 10 // 去掉 x 的最低位  \n   → Decision: 再次檢查 x > rev? // 迴圈是否繼續  \n    Yes → (回到 Step 5a)  \n    No  → Decision: 如果 x == rev? // 整數是否回文  \n     Yes → Step 6: 返回 true // 是回文  \n     No  → Decision: 如果 x == rev / 10? // 奇數位長度時去掉中間位  \n      Yes → Step 7: 返回 true // 是回文  \n      No  → Step 8: 返回 false // 不是回文  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        判斷整數 x 是否為回文。\n        負數直接回傳 False，正整數則以字串形式比較。\n        \"\"\"\n        if x < 0:\n            return False\n        s = str(x)\n        return s == s[::-1]\n\ndef main() -> None:\n    \"\"\"\n    主程式：\n    1. 從標準輸入讀取資料。\n    2. 解析出整數 x。\n    3. 判斷是否為回文。\n    4. 將結果以 'true' / 'false' 形式輸出到標準輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，支援形如 'x = 121' 或直接 '121' 的格式\n    if '=' in data:\n        try:\n            x = int(data.split('=')[1].strip())\n        except ValueError:\n            x = 0\n    else:\n        try:\n            x = int(data)\n        except ValueError:\n            x = 0\n\n    sol = Solution()\n    result = sol.isPalindrome(x)\n    # 輸出小寫字串以符合範例要求\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 121",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = -121",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 10",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode421.json",
    "problem_index_in_file": 0,
    "title": "Maximum XOR of Two Numbers in an Array",
    "description_snippet": "Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code for computing maximum XOR of any two numbers in an array. Should use bitwise trie approach. Provide steps: start, iterate array building trie, compute max XOR for each number. Provide explanation per line. Let's produce pseudo with Start, Decision, End. Use arrow and indent for decisions. Use \"→\" arrow.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize binary trie root // create root node\n→ Step 2: For each number num in nums // loop array\n   → Decision: Is trie empty? // first number\n        Yes → Step 3: Insert num into trie // add bits\n        No  → Step 4: Compute best XOR for num using trie // traverse opposite bits\n            → Step 5: Update maxResult if current XOR > maxResult\n            → Step 6: Insert num into trie // add after query\nEnd\n\nAlso we need to insert first number, but can unify by always insert after computing. For first number, computing yields 0, but fine.\n\nBetter pseudo: Build trie gradually. For each num, find max XOR with existing numbers in trie. If trie empty, just insert. Then compute.\n\nAlso need helper: function Insert(num), function Query(num). We'll include those steps as separate steps.\n\nLet's produce virtual code with pseudo functions.\n\nLet's write:\n\nStart\n→ Step 1: Create empty trie root node // root for binary trie\n→ Step 2: Set maxResult = 0 // store maximum XOR\n→ Step 3: For each num in nums // iterate array\n    → Decision: Trie empty? // no numbers yet\n        Yes → Step 4: Insert(num) // add to trie\n        No  → Step 5: currentXor = Query(num) // find max XOR with existing\n            → Step 6: If currentXor > maxResult → maxResult = currentXor // update\n            → Step 7: Insert(num) // add to trie\n→ End // return maxResult\n\nBut we also need virtual code for Insert and Query.\n\nInsert:\n→ Step 8: Function Insert(num) // insert bits into trie\n    → Step 9: node = root\n    → Step 10: For bit from 31 down to 0\n        → Step 11: bitVal = (num >> bit) & 1\n        → Decision: node has child bitVal? // node.next[bitVal]\n            Yes → node = node.next[bitVal]\n            No  → Create new child node; node.next[bitVal] = newNode; node = newNode\n\nQuery:\n→ Step 12: Function Query(num) // find maximum XOR\n    → Step 13: node = root\n    → Step 14: xorVal = 0\n    → Step 15: For bit from 31 down to 0\n        → Step 16: bitVal = (num >> bit) & 1\n        → Decision: node has child (1-bitVal)? // opposite bit\n            Yes → xorVal = (xorVal << 1) | 1; node = node.next[1-bitVal]\n            No  → xorVal = (xorVal << 1); node = node.next[bitVal]\n    → Step 17: Return xorVal\n\nNeed to keep format lines with arrow.\n\nWe'll produce each line with \"→\" arrow and explanation. Use indentation for decisions. Provide all lines sequentially. Ensure \"Start\" and \"End\" lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空的二進位 Trie 根節點 // 用於儲存所有已處理數字的二進位路徑  \n→ Step 2: 設定 maxResult = 0 // 用來保存目前找到的最大 XOR 結果  \n→ Step 3: 針對陣列中的每個數字 num 執行循環 // 逐一處理每個數字  \n  Decision: Trie 是否為空? // 檢查是否還沒插入任何數字  \n   Yes → Step 4: Insert(num) // 將首個數字插入 Trie，後續不會再查詢  \n   No → Step 5: currentXor = Query(num) // 在現有 Trie 中尋找能產生最大 XOR 的數字  \n    → Step 6: If currentXor > maxResult → maxResult = currentXor // 若找到更大的 XOR，更新 maxResult  \n    → Step 7: Insert(num) // 將本次處理的數字也插入 Trie，為下一個數字做準備  \n→ End // 程式執行結束，maxResult 為最終答案  \n\n// ---------- Insert 函式 ----------  \n→ Step 8: Function Insert(num) // 將一個數字按位插入 Trie  \n  Step 9: node = root  \n  Step 10: 對於 bit 從 31 到 0（最高位到最低位）執行循環  \n    → Step 11: bitVal = (num >> bit) & 1 // 取得該位的二進位值  \n    Decision: node 是否已有 bitVal 子節點？  \n     Yes → node = node.next[bitVal] // 跳到已存在的子節點  \n     No  → 新建子節點 node.next[bitVal] = newNode；node = newNode // 建立缺失的子節點  \n\n// ---------- Query 函式 ----------  \n→ Step 12: Function Query(num) // 在 Trie 中查找能使 num XOR 最大的數字  \n  Step 13: node = root  \n  Step 14: xorVal = 0 // 逐位累積 XOR 結果  \n  Step 15: 對於 bit 從 31 到 0 執行循環  \n    → Step 16: bitVal = (num >> bit) & 1 // 取得該位的二進位值  \n    Decision: node 是否有 (1 - bitVal) 子節點？ // 優先選擇相反位以最大化 XOR  \n     Yes → xorVal = (xorVal << 1) | 1；node = node.next[1 - bitVal] // 取反位並記錄 1  \n     No  → xorVal = (xorVal << 1)；node = node.next[bitVal] // 取同位並記錄 0  \n  Step 17: Return xorVal // 回傳查詢得到的最大 XOR 值  \n\n// End of virtual code.",
      "generated_code": "import sys\nimport ast\n\n# 節點結構：用於二進位 Trie\nclass TrieNode:\n    def __init__(self):\n        self.children = [None, None]  # 0 與 1 的子節點\n\nclass Solution:\n    def findMaximumXOR(self, nums):\n        if not nums:   # 空陣列直接回傳 0\n            return 0\n\n        # 先把所有數字插入 Trie\n        root = TrieNode()\n        for num in nums:\n            node = root\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if node.children[bit] is None:\n                    node.children[bit] = TrieNode()\n                node = node.children[bit]\n\n        # 再對每個數字尋找能產生最大 XOR 的數字\n        max_xor = 0\n        for num in nums:\n            node = root\n            curr_xor = 0\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                toggled = 1 - bit  # 優先選擇相反位\n                if node.children[toggled] is not None:\n                    curr_xor |= (1 << i)\n                    node = node.children[toggled]\n                else:\n                    node = node.children[bit]\n            if curr_xor > max_xor:\n                max_xor = curr_xor\n        return max_xor\n\ndef main():\n    # 讀取整個輸入並處理\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得第一個 '[' 到最後一個 ']' 之間的內容，再使用 literal_eval 解析成 list\n    start = data.find('[')\n    end = data.rfind(']') + 1\n    if start != -1 and end != -1:\n        nums = ast.literal_eval(data[start:end])\n    else:\n        nums = ast.literal_eval(data)\n\n    # 呼叫解法並輸出結果\n    sol = Solution()\n    result = sol.findMaximumXOR(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,10,5,25,2,8]",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 1,
          "input": "nums = [14,70,53,83,49,91,36,80,92,51,66,70]",
          "expected_output": "127",
          "success": true,
          "output": "127"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode524.json",
    "problem_index_in_file": 0,
    "title": "Longest Word in Dictionary through Deleting",
    "description_snippet": "Given a string s and a string array dictionary, return the longest string in the dictionary that can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line, with each line containing code step + // explanation. Use Start, End, Decision etc. We must not output actual code, just pseudo steps. We need to handle the algorithm: iterate dictionary, check if each word is subsequence of s; keep track of longest length and lexicographically smallest. Use decision to compare. We'll produce pseudocode.\n\nLet's write:\n\nStart\n→ Step 1: initialize bestWord = \"\" // holds best candidate\n→ Step 2: For each word in dictionary: // iterate words\n    → Decision: 是否為 s 的子序列? // check subsequence\n        Yes → Decision: 是否比 bestWord 更長? // compare length\n            Yes → Step 3: bestWord = word // update best\n            No  → Decision: 長度相同且 word < bestWord? // lexicographic comparison\n                Yes → Step 4: bestWord = word // update with lexicographically smaller\n                No  → Step 5: // keep current bestWord\n        No → Step 6: // skip word\nEnd // 返回 bestWord\n\nAlso need a helper function: isSubsequence(s, word) // check if word is subsequence of s\nWe'll include this function as separate steps before loop.\n\nLet's produce lines.\n\nMake sure to include arrow notation: Start, End, Decision:.\n\nWe should produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義 isSubsequence(s, word) -> bool // 判斷 word 是否為 s 的子序列\n    → Step 1.1: 初始化 i = 0, j = 0\n    → Decision: j < len(word)? \n        Yes → Decision: i < len(s)? \n            Yes → Decision: s[i] == word[j]? \n                Yes → i += 1; j += 1 // 移動兩指標\n                No  → i += 1 // 只移動 s 指標\n            No  → Return False // s 走完仍未匹配完\n        No  → Return True // word 已匹配完\n← End isSubsequence // 回傳結果\n...\n\nBut maybe too detailed. They want steps, but not too deep. But we can provide some steps inside the function.\n\nThen main loop.\n\nWe'll include a step for sorting dictionary? No need because we compare during loop.\n\nMake sure to show each line as \"虛擬碼步驟\" + space + \"// 解釋\". Use the arrow syntax.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 isSubsequence(s, word) -> bool // 判斷 word 是否為 s 的子序列  \n→     Step 1.1: 設定指標 i = 0, j = 0 // i 用於遍歷 s, j 用於遍歷 word  \n→     Decision: j < len(word)? // 是否已檢查完整個 word  \n→         Yes → Decision: i < len(s)? // s 還有未遍歷的字元  \n→             Yes → Decision: s[i] == word[j]? // 字元是否匹配  \n→                 Yes → i += 1; j += 1 // 匹配成功，兩指標同時前進  \n→                 No  → i += 1 // 只前進 s 的指標，嘗試下一個字元  \n→             No  → Return False // s 已遍歷完，還沒完成 word 的匹配  \n→         No  → Return True // word 已全部匹配成功  \n← End isSubsequence // 回傳判斷結果  \n\n→ Step 2: bestWord = \"\" // 儲存目前符合條件的最佳單字  \n→ Step 3: For each word in dictionary: // 逐一檢查字典中的單字  \n→     Decision: isSubsequence(s, word)? // 該單字是否能從 s 中刪除字符得到  \n→         Yes → Decision: len(word) > len(bestWord)? // 長度是否更長  \n→             Yes → bestWord = word // 更新為更長的單字  \n→             No  → Decision: len(word) == len(bestWord) AND word < bestWord? // 同長度且字典序較小  \n→                 Yes → bestWord = word // 更新為字典序較小的單字  \n→                 No  → // 保持現有 bestWord  \n→         No  → // 跳過此單字  \n← End For // 完成字典遍歷  \n\nEnd // 程式執行結束，返回 bestWord（若無符合條件則為空字串）",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLongestWord(self, s, dictionary):\n        # 先按長度降序、字典序升序排序\n        dictionary.sort(key=lambda x: (-len(x), x))\n        for word in dictionary:\n            it = iter(s)\n            # 判斷 word 是否為 s 的子序列\n            if all(c in it for c in word):\n                return word\n        return \"\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入包成一個 tuple 以便 ast.literal_eval 解析\n    s, dictionary = ast.literal_eval('(' + data + ')')\n    solution = Solution()\n    result = solution.findLongestWord(s, dictionary)\n    # 依題目要求輸出帶引號的字串\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abpcplea\", [\"ale\",\"apple\",\"monkey\",\"plea\"]",
          "expected_output": "\"apple\"",
          "success": true,
          "output": "\"apple\""
        },
        {
          "example_index": 1,
          "input": "\"abpcplea\", [\"a\",\"b\",\"c\"]",
          "expected_output": "\"a\"",
          "success": true,
          "output": "\"a\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode599.json",
    "problem_index_in_file": 0,
    "title": "Minimum Index Sum of Two Lists",
    "description_snippet": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\n\nA co...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm. Steps: input two lists, build map of string to index for list1, iterate list2, compute sum if common, track min sum and list of result. Output list. Provide each line with explanation. Use virtual arrows. Use Start, End, Decision, Step.\n\nWe need to be careful to follow format: each line: virtual code step [space] // explanation. Use \"→\" to show flow. Should include Decision: ... Yes → ... No → ... Indentation? In example, they use spaces before nested lines. We can replicate. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義空字典 map1 // 建立一個空字典來存儲 list1 中字符串到索引的映射\n→ Step 2: 定義變數 minSum = 無限大 // 初始化最小索引和為無限大\n→ Step 3: 定義空列表 result // 存儲符合最小索引和的字符串\n→ Decision: 遍歷 list1 的索引 i? // 循環遍歷 list1，建立映射\n    Yes → Step 4: 將 list1[i] 作為鍵，i 作為值存入 map1 // 建立索引映射\n    No  → End 循環 // 完成 list1 的遍歷\n→ Decision: 遍歷 list2 的索引 j? // 循環遍歷 list2，計算索引和\n    Yes → Step 5: 如果 list2[j] 存在於 map1? // 檢查是否為共同字符串\n        Yes → Step 6: 計算 currentSum = j + map1[list2[j]] // 計算索引和\n        Yes → Step 7: 如果 currentSum < minSum? // 比較是否為更小的索引和\n                Yes → Step 8: 設置 minSum = currentSum // 更新最小索引和\n                Yes → Step 9: 清空 result 並將 list2[j] 加入 result // 新的最小索引和，更新結果\n                No  → Step 10: 如果 currentSum == minSum? // 與目前最小索引和相等\n                        Yes → Step 11: 將 list2[j] 加入 result // 同樣索引和，加入結果\n                        No  → // 無操作\n        No  → // 不是共同字符串，跳過\n    No  → // 不是共同字符串，跳過\n    No  → // 循環結束\n→ Step 12: 返回 result // 輸出所有最小索引和的共同字符串\nEnd // 程式執行結束\n\nBut we need to respect format: each line begins with \"→\" except Start and End. Use proper indentation for nested decisions. We must keep each line as a single line of code + // explanation. We need to incorporate arrow for decision branches as \"Yes →\" and \"No →\" lines. Ensure that nested decisions have spaces.\n\nAlso need to not output actual code, only virtual steps.\n\nLet's format accordingly:\n\nStart // 程式開始執行\n→ Step 1: 定義空字典 map1 // 建立一個空字典來存儲 list1 中字符串到索引的映射\n→ Step 2: 定義變數 minSum = ∞ // 初始化最小索引和為無限大\n→ Step 3: 定義空列表 result // 存儲符合最小索引和的字符串\n→ Decision: 遍歷 list1 的索引 i ？ // 循環遍歷 list1，建立映射\n    Yes → Step 4: map1[list1[i]] = i // 存入映射\n    No  → // list1 完成遍歷\n→ Decision: 遍歷 list2 的索引 j ？ // 循環遍歷 list2，計算索引和\n    Yes → Decision: list2[j] 在 map1 中？ // 檢查是否為共同字符串\n        Yes → Step 5: currentSum = j + map1[list2[j]] // 計算索引和\n        Yes → Decision: currentSum < minSum？ // 比較是否為更小的索引和\n            Yes → Step 6: minSum = currentSum // 更新最小索引和\n            Yes → Step 7: result = [list2[j]] // 清空結果並加入新最小索引和的字符串\n            No  → Decision: currentSum == minSum？ // 與目前最小索引和相等\n                Yes → Step 8: result.append(list2[j]) // 同樣索引和，加入結果\n                No  → // 無操作\n        No  → // 當前索引和不小於最小值且不等，直接跳過\n    No  → // 非共同字符串，跳過\n    No  → // list2 完成遍歷\n→ Step 9: 返回 result // 輸出所有最小索引和的共同字符串\nEnd // 程式執行結束\n\nWe must keep each line separate. The nested Decision lines: \"Yes → Step X:\" etc. For nested decisions inside decisions, indentation.\n\nCheck if any line violates formatting: each line has virtual code step, a space, then // explanation. Use Chinese explanation. Good.\n\nNeed to avoid actual code. Use words like \"定義\" \"存入\" \"計算\" etc. No code. Provide \"∞\" maybe not code but representation. We can just use \"∞\".\n\nOk. Ensure we don't inadvertently put code like map1[list1[i]] = i but as textual representation? It's okay as virtual code. We might want to avoid actual syntax; but it's virtual steps. It's fine. Provide \"Step 4: map1[list1[i]] = i\" etc. That's acceptable.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義空字典 map1 // 建立一個空字典來存儲 list1 中字符串到索引的映射  \n→ Step 2: 定義變數 minSum = ∞ // 初始化最小索引和為無限大  \n→ Step 3: 定義空列表 result // 存儲符合最小索引和的字符串  \n→ Decision: 遍歷 list1 的索引 i ？ // 循環遍歷 list1，建立映射  \n  Yes → Step 4: map1[list1[i]] = i // 存入映射  \n  No  → // list1 完成遍歷  \n→ Decision: 遍歷 list2 的索引 j ？ // 循環遍歷 list2，計算索引和  \n  Yes → Decision: list2[j] 在 map1 中？ // 檢查是否為共同字符串  \n    Yes → Step 5: currentSum = j + map1[list2[j]] // 計算索引和  \n    Yes → Decision: currentSum < minSum ？ // 比較是否為更小的索引和  \n      Yes → Step 6: minSum = currentSum // 更新最小索引和  \n      Yes → Step 7: result = [list2[j]] // 清空結果並加入新最小索引和的字符串  \n      No  → Decision: currentSum == minSum ？ // 與目前最小索引和相等  \n        Yes → Step 8: result.append(list2[j]) // 同樣索引和，加入結果  \n        No  → // 無操作  \n    No  → // 當前索引和不小於最小值且不等，直接跳過  \n  No  → // 非共同字符串，跳過  \n  No  → // list2 完成遍歷  \n→ Step 9: 返回 result // 輸出所有最小索引和的共同字符串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findRestaurant(self, list1, list2):\n        index_map = {name: i for i, name in enumerate(list1)}\n        min_sum = float('inf')\n        res = []\n\n        for j, name in enumerate(list2):\n            if name in index_map:\n                total_index = j + index_map[name]\n                if total_index < min_sum:\n                    min_sum = total_index\n                    res = [name]\n                elif total_index == min_sum:\n                    res.append(name)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 解析輸入，預期格式為：list1 = [...], list2 = [...]\n    parts = data.split(', list2 = ')\n    list1_str = parts[0].replace('list1 = ', '', 1).strip()\n    list2_str = parts[1].strip()\n    list1 = ast.literal_eval(list1_str)\n    list2 = ast.literal_eval(list2_str)\n\n    solution = Solution()\n    result = solution.findRestaurant(list1, list2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]",
          "expected_output": "[\"Shogun\"]",
          "success": true,
          "output": "['Shogun']"
        },
        {
          "example_index": 1,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]",
          "expected_output": "[\"Shogun\"]",
          "success": true,
          "output": "['Shogun']"
        },
        {
          "example_index": 2,
          "input": "list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]",
          "expected_output": "[\"sad\",\"happy\"]",
          "success": true,
          "output": "['sad', 'happy']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode629.json",
    "problem_index_in_file": 0,
    "title": "K Inverse Pairs Array",
    "description_snippet": "For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.leng...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for solution to problem: count number of permutations of 1..n with exactly k inversions. Classic DP: dp[i][j] ways for i numbers 1..i with j inversions. Recurrence: dp[i][j] = sum_{x=0}^{min(j, i-1)} dp[i-1][j-x]. We can compute with prefix sums to O(nk). Output modulo MOD.\n\nNeed to write step-by-step pseudocode with explanations. Use Start, End, Decision arrows. Each line: \"虛擬碼步驟 // 解釋\". We'll produce algorithm steps: read n, k; init dp 2D array size (n+1)x(k+1) all zeros; dp[0][0]=1; For i=1 to n: compute prefix sum array pref of dp[i-1]; for j=0..k: dp[i][j] = pref[j] - pref[j-i] if j-i>=0 else pref[j]; mod adjust; end loops; result dp[n][k] mod MOD. Output.\n\nWe need to be careful with virtual code syntax: use → arrow for next step. Use Decision: if statements. Use Start End. For loops maybe represented as \"Loop i = 1 to n\" etc. Provide explanation each line.\n\nLet's produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 讀入 n, k // 從輸入取得整數 n 與 k\n→ Step 2: 定義 MOD = 1_000_000_007 // 常數模數\n→ Step 3: 建立 dp 二維陣列 (n+1)×(k+1) 之全零 // 用來存放每個 i、j 的組合數\n→ Step 4: dp[0][0] = 1 // 空序列只有一種，沒有逆序對\n\nNow loops:\n\n→ Loop i = 1 to n // 逐個加入第 i 個數字\n    → Loop j = 0 to k // 計算長度 i 的逆序對數 j\n        ... we need prefix sum; maybe compute prefix outside j loop:\n\nWe can compute prefix array pref[0..k] where pref[j] = pref[j-1] + dp[i-1][j] mod MOD.\n\nSo:\n\n→ Step 5: 建立 pref[0..k] // 前綴和陣列\n    → Loop j = 0 to k\n        → Step 6: pref[j] = (j==0 ? dp[i-1][0] : (pref[j-1] + dp[i-1][j]) mod MOD) // 前綴和\n→ Step 7: Loop j = 0 to k\n        → Decision: if j < i? // 計算 dp[i][j]\n             Yes → dp[i][j] = pref[j] // j < i, no need to subtract\n             No  → dp[i][j] = (pref[j] - pref[j-i] + MOD) mod MOD // j >= i\n→ End of loops\n\nFinally:\n\n→ Step 8: 輸出 dp[n][k] // 結果\n\nNow we should format each line with arrow '→' and indentation for nested loops. Provide explanation.\n\nLet's craft step lines. Ensure each line has code + comment. Use `→` before each. For loops maybe write \"Loop i = 1 to n\" but the arrow can be used for each line inside loop. Use indentation: maybe 4 spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入 n, k // 從輸入取得整數 n 與 k  \n→ Step 2: 定義 MOD = 1_000_000_007 // 常數模數  \n→ Step 3: 建立 dp 二維陣列 (n+1)×(k+1) 之全零 // 用來存放每個 i、j 的組合數  \n→ Step 4: dp[0][0] = 1 // 空序列只有一種，沒有逆序對  \n\n→ Loop i = 1 to n // 逐個加入第 i 個數字  \n    → Step 5: 建立 pref[0..k] // 前綴和陣列，方便快速求和  \n        → Loop j = 0 to k  \n            → Step 6: pref[j] = (j==0 ? dp[i-1][0] : (pref[j-1] + dp[i-1][j]) mod MOD) // 計算前綴和  \n    → Step 7: Loop j = 0 to k // 計算長度 i 的逆序對數 j  \n        → Decision: 如果 j < i? // 是否需要扣除多餘的部分  \n            Yes → dp[i][j] = pref[j] // j < i 時，只取前 j 個值  \n            No  → dp[i][j] = (pref[j] - pref[j-i] + MOD) mod MOD // j ≥ i 時，扣除超出範圍的和  \n\n→ Step 8: 輸出 dp[n][k] // 結果即為長度 n、逆序對數 k 的不同排列數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nMOD = 10**9 + 7\n\ndef count_inversion_permutations(n: int, k: int) -> int:\n    \"\"\"\n    Count the number of permutations of [1..n] that contain exactly k inversion pairs.\n    Uses dynamic programming with prefix sums for O(n*k) time and O(k) space.\n    \"\"\"\n    # If k exceeds the maximum possible inversions, return 0\n    max_inv = n * (n - 1) // 2\n    if k > max_inv:\n        return 0\n\n    # dp_prev[j] : ways to arrange i-1 numbers with j inversions\n    dp_prev = [0] * (k + 1)\n    dp_prev[0] = 1\n\n    for i in range(1, n + 1):\n        # prefix sum of dp_prev to allow O(1) range sum queries\n        pref = [0] * (k + 1)\n        pref[0] = dp_prev[0]\n        for j in range(1, k + 1):\n            pref[j] = (pref[j - 1] + dp_prev[j]) % MOD\n\n        dp_cur = [0] * (k + 1)\n        for j in range(0, k + 1):\n            # Sum dp_prev[j - x] for x = 0..min(j, i-1)\n            left = j\n            right = j - i  # exclusive\n            total = pref[left]\n            if right >= 0:\n                total = (total - pref[right]) % MOD\n            dp_cur[j] = total\n        dp_prev = dp_cur\n\n    return dp_prev[k]\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    # Extract integers from the input, ignoring any non-digit characters\n    nums = [int(token) for token in data if token.lstrip('-').isdigit()]\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    result = count_inversion_permutations(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 0",
          "expected_output": "1",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 1",
          "expected_output": "2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      ''"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode693.json",
    "problem_index_in_file": 0,
    "title": "Binary Number with Alternating Bits",
    "description_snippet": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanations. The problem: Given a positive integer, check whether it has alternating bits: meaning binary representation has no two adjacent bits same.\n\nWe need to produce virtual code steps: Start, maybe get input, check bits. Approach: Use bitwise operations. Approach 1: XOR number with number >>1, then check if result+1 is power of two. Or simpler: iterate bits, compare with previous bit. We need to produce pseudocode lines.\n\nWe need to ensure each line has virtual code step + space + // explanation. Use Start, End, Decision, etc.\n\nWe need to output only the steps, not actual code.\n\nWe will produce something like:\n\nStart // 程式開始執行\n→ Step 1: 讀取正整數 N // 取得輸入\n→ Step 2: prevBit ← N & 1 // 取最低位\n→ Step 3: N ← N >> 1 // 右移一位\n→ Decision: N == 0? // 是否已經處理完所有位\n    Yes → Step 4: 輸出 true // 所有位都交替，符合條件\n    No  → Decision: (N & 1) == prevBit? // 當前位是否與前一位相同\n        Yes → Step 5: 輸出 false // 兩位相同，非交替\n        No  → Step 6: prevBit ← N & 1 // 更新前一位\n            → Step 7: N ← N >> 1 // 右移\n            → Step 8: Go to Decision: N == 0? // 重新判斷\nEnd // 程式結束\n\nBut we need to use arrow syntax and \"Decision:\" with Yes →, No →. Use appropriate indent.\n\nAlso we could mention the power-of-two trick but simpler approach. But okay.\n\nMake sure to use `Start` and `End`. Use `→` arrow.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取正整數 N // 取得使用者輸入的正整數  \n→ Step 2: prevBit ← N & 1 // 取最低位的二進位數值作為前一位  \n→ Step 3: N ← N >> 1 // 將數字右移一位，準備檢查下一位  \n→ Decision: N == 0? // 已經檢查完所有位數嗎？  \n    Yes → Step 4: 輸出 true // 所有位都已交替，符合條件  \n    No  → Decision: (N & 1) == prevBit? // 目前位是否與前一位相同？  \n        Yes → Step 5: 輸出 false // 兩位相同，非交替位  \n        No  → Step 6: prevBit ← N & 1 // 更新前一位為目前位  \n            → Step 7: N ← N >> 1 // 右移到下一位  \n            → Step 8: Go to Decision: N == 0? // 回到第一個決策點檢查剩餘位  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def hasAlternatingBits(self, n: int) -> bool:\n        \"\"\"判斷二進位表示是否交替（相鄰位不同）\"\"\"\n        prev_bit = n & 1          # 取最低位\n        n >>= 1                   # 右移一位\n        while n > 0:\n            curr_bit = n & 1\n            if curr_bit == prev_bit:\n                return False      # 相鄰位相同，非交替\n            prev_bit = curr_bit\n            n >>= 1\n        return True               # 所有位都交替\n\ndef main() -> None:\n    \"\"\"主程式：讀取輸入、處理、輸出結果\"\"\"\n    data = sys.stdin.read()\n    # 從輸入中找出第一個正整數\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    solution = Solution()\n    result = solution.hasAlternatingBits(n)\n    # 輸出小寫 'true' 或 'false'\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = 11",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode13.json",
    "problem_index_in_file": 0,
    "title": "Roman to Integer",
    "description_snippet": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Val...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for converting Roman numeral string to integer, with explanation each line. Use Start, End, Decision. Provide line-by-line. Should not output actual code. Use arrow formatting. Provide each step. Let's produce algorithm:\n\n- Start\n- Step 1: 初始化總和為0\n- Step 2: 定義映射表\n- Step 3: 遍歷字串\n- Step 4: 判斷當前符號值是否小於下一符號值\n- Step 5: 若小於，從總和中減去該值，否則加上\n- Step 6: 移動索引\n- End\n\nInclude decisions with Yes/No arrows. Provide explanations.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設置 total = 0 // 用於累計最終整數結果  \n→ Step 2: 建立符號到數值的映射表 // 例如 I→1, V→5, X→10, L→50, C→100, D→500, M→1000  \n→ Step 3: 設定 index = 0 // 用於遍歷輸入字串  \n→ Decision: index < length of roman numeral? // 是否還有未處理的符號  \n    Yes → Step 4: currentValue = map[roman[index]] // 取得目前符號對應的數值  \n    Yes → Decision: index + 1 < length of roman numeral AND currentValue < map[roman[index + 1]]? // 下一符號是否存在且更大，需使用減法規則  \n        Yes → Step 5: total = total - currentValue // 進行減法（如 IV, IX 等）  \n        No  → Step 5: total = total + currentValue // 進行加法（正常情況）  \n    Yes → Step 6: index = index + 1 // 移動到下一個符號  \n    Yes → Decision: index < length of roman numeral? // 繼續循環直到結束  \n        → ... // 以上步驟重複  \n    No  → End // 迴圈結束，計算完成  \nEnd // 程式執行結束，total 為最終整數結果",
      "generated_code": "import sys\nimport re\n\ndef roman_to_int(s: str) -> int:\n    \"\"\"把羅馬數字字串轉換成整數。\"\"\"\n    roman_map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    total = 0\n    prev_value = 0\n    # 從字串末尾往前遍歷，根據前後關係決定加減\n    for char in reversed(s):\n        value = roman_map[char]\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n    return total\n\ndef extract_roman(input_str: str) -> str:\n    \"\"\"\n    從輸入字串中提取羅馬數字。\n    例如「s = \"MCMXCIV\"」會回傳 MCMXCIV。\n    若字串中不包含引號，則整個字串視為羅馬數字。\n    \"\"\"\n    # 先嘗試找最內層的引號\n    matches = re.findall(r'\"([^\"]*)\"', input_str)\n    if matches:\n        return matches[0]\n    # 若沒有引號，直接回傳去除空白的字串\n    return input_str.strip()\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入資料\n    raw_input = sys.stdin.read()\n    # 可能會有多行，合併成一行\n    raw_input = \" \".join(raw_input.splitlines())\n    # 擷取羅馬數字\n    roman_str = extract_roman(raw_input)\n    # 轉換並輸出結果\n    result = roman_to_int(roman_str)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"III\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"LVIII\"",
          "expected_output": "58",
          "success": true,
          "output": "58"
        },
        {
          "example_index": 2,
          "input": "s = \"MCMXCIV\"",
          "expected_output": "1994",
          "success": true,
          "output": "1994"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode134.json",
    "problem_index_in_file": 0,
    "title": "Gas Station",
    "description_snippet": "There are n gas stations along a circular route, where the amount of gas at the i^th station is gas[...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. The user wants the algorithm: find starting gas station index if possible else -1. The problem is Leetcode Gas Station. Steps: compute total gas vs total cost, if negative then return -1. Then find starting index by iterating, keeping current tank, if tank < 0, set start to next index, reset tank to 0.\n\nWe need to produce each line as \"虛擬碼步驟 // 解釋\". Use arrows. Use Start, End, Decision. Use step numbering? The example used \"Step 1:\" etc. We can similarly.\n\nWe need to adhere to output format: each line with virtual code step and comment after space. Use arrows \"→\". Use Decision: ... Yes→ etc. Should produce step by step pseudocode. Ensure Chinese explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: total_gas ← 0 // 計算所有加油站的總汽油量\n→ Step 2: total_cost ← 0 // 計算往返所需的總油費\n→ Step 3: n ← length(gas) // 取得加油站總數\n→ Decision: 是否存在能完成整圈的條件? // 檢查總油量是否至少等於總油費\n    Yes → Step 4: total_gas ← sum(gas) // 累加所有加油站的汽油量\n    Yes → Step 5: total_cost ← sum(cost) // 累加從每個站到下一站的油費\n    Yes → Decision: total_gas < total_cost? // 如果總汽油不足，無法完成整圈\n        Yes → Step 6: return -1 // 直接回傳失敗\n        No  → // 繼續尋找可行的起點\n→ Step 7: start_index ← 0 // 初始起點設為第 0 個站\n→ Step 8: current_tank ← 0 // 當前油箱容量初始為 0\n→ Decision: 迭代 i 從 0 到 n-1? // 逐一檢查每個加油站\n    Yes → Step 9: current_tank ← current_tank + gas[i] - cost[i] // 更新當前油箱容量\n    Yes → Decision: current_tank < 0? // 若油箱負值，表示從 start_index 開始無法繼續\n        Yes → Step 10: start_index ← i + 1 // 將起點移至下一個站\n        Yes → Step 11: current_tank ← 0 // 重置油箱容量為 0\n        No  → // 油箱仍非負，繼續檢查後續站\n    Yes → // 下一站\n→ End // 程式執行結束，回傳找到的起點索引\n→ Step 12: return start_index // 回傳唯一可行的起點索引 (若已確定存在)",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canCompleteCircuit(self, gas, cost):\n        if sum(gas) < sum(cost):\n            return -1\n        \n        start = 0\n        tank = 0\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        return start\n\ndef parse_input(input_str):\n    # 尋找 gas 列表\n    gas_match = re.search(r'gas\\s*=\\s*\\[([^\\]]*)\\]', input_str)\n    cost_match = re.search(r'cost\\s*=\\s*\\[([^\\]]*)\\]', input_str)\n    if not gas_match or not cost_match:\n        return [], []\n    gas_str = gas_match.group(1)\n    cost_str = cost_match.group(1)\n    gas = [int(x.strip()) for x in gas_str.split(',') if x.strip()]\n    cost = [int(x.strip()) for x in cost_str.split(',') if x.strip()]\n    return gas, cost\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    gas, cost = parse_input(input_data)\n    result = Solution().canCompleteCircuit(gas, cost)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "gas = [2,3,4], cost = [3,4,3]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode540.json",
    "problem_index_in_file": 0,
    "title": "Single Element in a Sorted Array",
    "description_snippet": "You are given a sorted array consisting of only integers where every element appears exactly twice, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code. Should be step-by-step for binary search algorithm. Use virtual code lines. Use arrows and decision. Provide explanation after each line. Output only virtual code lines.\n\nWe need to use Start, End. Use arrow \"→\". Each line like: Start // 程式開始執行\n\nWe need to produce the algorithm: given sorted array where each element appears twice except one appears once. Need to find single element in O(log n) time, O(1) space. Approach: binary search on indices; check middle index; if mid is even, compare mid with mid+1; if equal, single element is in right half; else in left half; if mid odd, compare mid with mid-1; similar.\n\nImplement. Use low, high pointers.\n\nLet's produce lines:\n\nStart // 程式開始執行\n\n→ Initialize low = 0, high = array.length - 1 // 設定搜尋範圍\n\n→ Decision: low < high? // 是否還有多個元素待搜尋\n\n    Yes → Compute mid = low + (high - low) / 2 // 取中間索引\n\n    → Decision: mid % 2 == 0? // 中間索引是偶數\n\n        Yes → Decision: array[mid] == array[mid + 1]? // 左半段是否成對\n\n            Yes → low = mid + 2 // 單個元素在右半段\n\n            No  → high = mid - 1 // 單個元素在左半段\n\n        No  → Decision: array[mid] == array[mid - 1]? // 中間索引是奇數\n\n            Yes → low = mid + 1 // 單個元素在右半段\n\n            No  → high = mid - 1 // 單個元素在左半段\n\n    No → Return array[low] // low 指向唯一元素\n\nEnd // 程式執行結束\n\nBut we need ensure each line ends with comment. Also use arrow to show flow. For decisions we can indent. Use \"Decision:\" lines, and inside indentation we might use \"Yes →\" etc. Use arrow for each branch. Also we need to handle end of loop.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: low ← 0, high ← array.length - 1 // 設定搜尋範圍\n→ Decision: low < high? // 是否還有多個元素待搜尋\n    Yes → Step 2: mid ← low + (high - low) / 2 // 計算中間索引\n        → Decision: mid % 2 == 0? // 中間索引為偶數\n            Yes → Decision: array[mid] == array[mid + 1]? // 檢查右側是否配對\n                Yes → low ← mid + 2 // 單一元素在右半段\n                No  → high ← mid - 1 // 單一元素在左半段\n            No  → Decision: array[mid] == array[mid - 1]? // 中間索引為奇數，檢查左側是否配對\n                Yes → low ← mid + 1 // 單一元素在右半段\n                No  → high ← mid - 1 // 單一元素在左半段\n    No  → Return array[low] // low 指向唯一元素\nEnd // 程式執行結束\n\nCheck indentation: \"Yes →\" etc. Use correct arrow \"→\". Provide explanation.\n\nBut each line must contain a virtual code step and a comment after space. For branches, we have multiple lines. The \"Yes →\" lines are part of the decision's branch. That is okay.\n\nWe might need to include indentation with spaces for readability. But still each line must be a separate line.\n\nEnsure each line has exactly one comment after space.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← 0, high ← array.length - 1 // 設定搜尋範圍  \n→ Decision: low < high? // 判斷是否還有多個元素待搜尋  \n    Yes → Step 2: mid ← low + (high - low) / 2 // 計算中間索引  \n        → Decision: mid % 2 == 0? // 中間索引為偶數？  \n            Yes → Decision: array[mid] == array[mid + 1]? // 右側是否配對？  \n                Yes → low ← mid + 2 // 單一元素在右半段  \n                No  → high ← mid - 1 // 單一元素在左半段  \n            No  → Decision: array[mid] == array[mid - 1]? // 中間索引為奇數，檢查左側是否配對？  \n                Yes → low ← mid + 1 // 單一元素在右半段  \n                No  → high ← mid - 1 // 單一元素在左半段  \n    No  → Return array[low] // low 指向唯一元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNonDuplicate(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if mid % 2 == 1:\n                mid -= 1\n            if nums[mid] == nums[mid + 1]:\n                left = mid + 2\n            else:\n                right = mid\n        return nums[left]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    nums = ast.literal_eval(data)\n    result = Solution().singleNonDuplicate(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,1,2,3,3,4,4,8,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[3,3,7,7,10,11,11]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode622.json",
    "problem_index_in_file": 0,
    "title": "Design Circular Queue",
    "description_snippet": "Design your implementation of the circular queue. The circular queue is a linear data structure in w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MyCircularQueue with operations. Provide step-by-step pseudocode, each line with explanation, using arrow syntax. No actual code. Just steps.\n\nWe need to describe initialization, array storage, front, rear indices, count. Provide operations: isEmpty, isFull, enQueue, deQueue, Front, Rear.\n\nWe need to present as flow steps? Might produce like:\n\nStart\n→ Step 1: Define array of size k // storage\n→ Step 2: front = 0 // front index\n→ Step 3: rear = -1 // rear index\n→ Step 4: count = 0 // element count\n\nThen each method is separate. Might use decision blocks. Provide logic.\n\nLet's produce linear pseudo steps describing methods; maybe show separate sections.\n\nWe'll produce a start block, then for each method.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\" with arrow. Use arrow '→'.\n\nWe'll format as:\n\nStart // 程式開始執行\n→ Define array data[k] // 用來存放元素\n→ Initialize front = 0 // 前端指標\n→ Initialize rear = -1 // 後端指標\n→ Initialize count = 0 // 目前元素數目\n→ Method isEmpty() // 判斷是否為空\n    → Decision: count == 0? // 檢查元素數目\n        Yes → Return true\n        No  → Return false\n...\n\nBut we need each line to be one step. Use indentation with spaces for nested lines.\n\nWe'll produce in this style.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define array data[k] // 用來存放元素的固定大小陣列  \n→ Initialize front = 0 // 前端指標指向目前最舊的元素位置  \n→ Initialize rear = -1 // 後端指標指向目前最新的元素位置（初始為-1表示空）  \n→ Initialize count = 0 // 目前佔用空間的元素數目  \n\n// ---------------------------------------  \n// 判斷是否為空  \n→ Method isEmpty()  \n    → Decision: count == 0? // 判斷是否沒有任何元素  \n        Yes → Return true // 空  \n        No  → Return false // 非空  \n\n// ---------------------------------------  \n// 判斷是否為滿  \n→ Method isFull()  \n    → Decision: count == k? // 判斷是否已達最大容量  \n        Yes → Return true // 滿  \n        No  → Return false // 未滿  \n\n// ---------------------------------------  \n// 插入元素  \n→ Method enQueue(value)  \n    → Decision: isFull()? // 若已滿則無法插入  \n        Yes → Return false // 插入失敗  \n        No  →  \n            → rear = (rear + 1) mod k // 後端指標向後移動，環形處理  \n            → data[rear] = value // 把新值放進後端位置  \n            → count = count + 1 // 元素數目增加  \n            → Return true // 插入成功  \n\n// ---------------------------------------  \n// 刪除元素  \n→ Method deQueue()  \n    → Decision: isEmpty()? // 若為空則無法刪除  \n        Yes → Return false // 刪除失敗  \n        No  →  \n            → front = (front + 1) mod k // 前端指標向後移動，環形處理  \n            → count = count - 1 // 元素數目減少  \n            → Return true // 刪除成功  \n\n// ---------------------------------------  \n// 取得前端元素  \n→ Method Front()  \n    → Decision: isEmpty()? // 若為空則回傳 -1  \n        Yes → Return -1 // 沒有前端元素  \n        No  → Return data[front] // 回傳前端位置的值  \n\n// ---------------------------------------  \n// 取得後端元素  \n→ Method Rear()  \n    → Decision: isEmpty()? // 若為空則回傳 -1  \n        Yes → Return -1 // 沒有後端元素  \n        No  → Return data[rear] // 回傳後端位置的值  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass MyCircularQueue:\n    def __init__(self, k):\n        self.queue = [0] * k\n        self.head = self.tail = -1\n        self.size = k\n\n    def enQueue(self, value):\n        if self.isFull():\n            return False\n        if self.isEmpty():\n            self.head = 0\n        self.tail = (self.tail + 1) % self.size\n        self.queue[self.tail] = value\n        return True\n\n    def deQueue(self):\n        if self.isEmpty():\n            return False\n        if self.head == self.tail:\n            self.head = self.tail = -1\n        else:\n            self.head = (self.head + 1) % self.size\n        return True\n\n    def Front(self):\n        if self.isEmpty():\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self):\n        if self.isEmpty():\n            return -1\n        return self.queue[self.tail]\n\n    def isEmpty(self):\n        return self.head == -1\n\n    def isFull(self):\n        return (self.tail + 1) % self.size == self.head\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    ops = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n\n    results = []\n    queue = None\n    for op, args in zip(ops, args_list):\n        if op == \"MyCircularQueue\":\n            queue = MyCircularQueue(*args)\n            results.append(None)\n        else:\n            method = getattr(queue, op)\n            res = method(*args)\n            results.append(res)\n\n    # Convert Python values to LeetCode-style output\n    out_parts = []\n    for r in results:\n        if r is None:\n            out_parts.append(\"null\")\n        elif isinstance(r, bool):\n            out_parts.append(\"true\" if r else \"false\")\n        else:\n            out_parts.append(str(r))\n    print(\"[\" + \", \".join(out_parts) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCircularQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"Rear\", \"isFull\", \"deQueue\", \"enQueue\", \"Rear\"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 3, true, true, true, 4]",
          "success": true,
          "output": "[null, true, true, true, false, 3, true, true, true, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode22.json",
    "problem_index_in_file": 0,
    "title": "Generate Parentheses",
    "description_snippet": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parenthes...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all combinations of well-formed parentheses for n pairs. Provide step by step pseudocode with explanation comments. Use arrow and structure. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision:, arrow. Use recursion or backtracking.\n\nLet's create:\n\nStart\n→ Define function Generate(n) // entry\n→ Step 1: Initialize result list // store combinations\n→ Step 2: Call backtrack(current=\"\", left=0, right=0) // start recursion\n→ Decision: In backtrack, if current length equals 2*n → add to result // base case\n→ Decision: If left < n → backtrack(current+\"(\", left+1, right) // add left parenthesis\n→ Decision: If right < left → backtrack(current+\")\", left, right+1) // add right parenthesis\n→ End function\n→ Return result\nEnd\n\nAlso maybe include main call.\n\nLet's produce each line with explanation. Ensure each line ends with // explanation.\n\nWe need to use \"虛擬碼步驟\" and \" // 解釋\". Format exactly. Provide step lines.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define function GenerateWellFormed(n) // 定義主函式，接收括號對數  \n→ Step 1: Initialize result list // 用於儲存所有合法組合  \n→ Step 2: Call backtrack(current = \"\", left = 0, right = 0) // 開始遞迴，初始為空串且左右括號數為0  \n→ Decision: If length(current) = 2*n → result.append(current) // 基本情況：已放置所有括號，加入結果  \n→ Decision: If left < n → backtrack(current + \"(\", left + 1, right) // 可以再加左括號，進行遞迴  \n→ Decision: If right < left → backtrack(current + \")\", left, right + 1) // 只在右括號少於左括號時才可加右括號  \n→ End function GenerateWellFormed // 結束主函式  \n→ Return result // 返回所有生成的合法括號組合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nfrom typing import List\n\ndef generate_parentheses(n: int) -> List[str]:\n    \"\"\"產生所有合法的括號組合，回傳字串列表。\"\"\"\n    res: List[str] = []\n\n    def backtrack(s: str = \"\", left: int = 0, right: int = 0) -> None:\n        \"\"\"使用深度優先搜尋回溯法產生括號組合。\"\"\"\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        if left < n:\n            backtrack(s + \"(\", left + 1, right)\n        if right < left:\n            backtrack(s + \")\", left, right + 1)\n\n    backtrack()\n    return res\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取 n，輸出所有合法括號組合（JSON 字串）。\"\"\"\n    line = sys.stdin.read().strip()\n    if not line:\n        return\n    # 解析像是 \"n = 3\" 或僅為 \"3\" 的輸入\n    parts = line.replace('n', '').replace('=', '').split()\n    try:\n        n = int(parts[-1])\n    except (IndexError, ValueError):\n        raise ValueError(\"輸入格式錯誤，請輸入例如 'n = 3' 或 '3'\")\n    result = generate_parentheses(n)\n    # 使用 json.dumps 以雙引號輸出，符合範例格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
          "success": true,
          "output": "[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[\"()\"]",
          "success": true,
          "output": "[\"()\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode217.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate",
    "description_snippet": "Given an integer array nums, return true if any value appears at least twice in the array, and retur...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode, step-by-step, with explanations after each line. The requirement: Virtual Code steps using arrows, structure like Start, End, Decision. Provide each line: \"虛擬碼步驟 // 解釋/說明\". Each line should have a single statement. Should not output actual code. Use virtual code arrow symbols →, Yes →, No →. For loops, we can use \"For each element in nums\". Need to check duplicates.\n\nWe can use a Set or array of booleans. Since it's virtual code, we can describe \"Initialize empty set\". Then iterate. For each number, check if in set; if yes return true; else add. After loop, return false. Use Decision: if number in set? Yes → return true; No → add.\n\nThus pseudocode:\n\nStart // 程式開始執行\n→ Step 1: 建立空集合 visited // 用來記錄已見過的數值\n→ For each num in nums // 遍歷陣列中的每個元素\n    → Decision: 是否已存在於 visited? // 檢查 num 是否已在集合中\n        Yes → Step 2: 回傳 true // 找到重複值，直接回傳真\n        No  → Step 3: 將 num 加入 visited // 將新數值加入集合\n→ Step 4: 回傳 false // 若未發現重複值，回傳假\nEnd // 程式執行結束\n\nWe need to include arrows in correct format. For loops: maybe \"→ For each num in nums\" is fine. But we need to structure nested decisions. The syntax: \"Decision: ...\" then indent Yes →, No → lines. In the example, they indent Yes, No lines at same indentation as decision. We need to include indentation for nested decision, e.g., \"    Yes →\". For loops we may indent decision lines inside loop. So the structure:\n\nStart // ...\n→ Step 1: 建立空集合 visited // ...\n→ For each num in nums // ...\n    → Decision: num 已在 visited? // ...\n        Yes → Step 2: 回傳 true // ...\n        No  → Step 3: 追加 num 到 visited // ...\n→ Step 4: 回傳 false // ...\nEnd // ...\n\nMake sure each line has code and explanation. Use 虛擬碼步驟 like \"Step 1: 建立空集合 visited\". Use \"For each num in nums\". Use \"Decision: num 已在 visited?\" This is a decision. Then Yes, No arrow. Then after loop, Step 4: 回傳 false. Then End.\n\nReturn true or false. Use Step 2: 回傳 true; Step 4: 回傳 false. All good.\n\nAlso include arrow after \"Decision: ...?\" as arrow symbol. Eg \"Decision: num 已在 visited? // 檢查重複\". Then indentation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空集合 visited // 用來記錄已見過的數值\n→ For each num in nums // 遍歷陣列中的每個元素\n    → Decision: num 已在 visited? // 檢查 num 是否已在集合中\n        Yes → Step 2: 回傳 true // 找到重複值，直接回傳真\n        No  → Step 3: 將 num 加入 visited // 將新數值加入集合\n→ Step 4: 回傳 false // 若未發現重複值，回傳假\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def containsDuplicate(self, nums):\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return True\n            seen.add(num)\n        return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract all integers from the input (handles negative numbers as well)\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    sol = Solution()\n    result = sol.containsDuplicate(nums)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode389.json",
    "problem_index_in_file": 0,
    "title": "Find the Difference",
    "description_snippet": "You are given two strings s and t.\n\nString t is generated by random shuffling string s and then add ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudo-code step-by-step. Requirements: output line by line, each line \"虛擬碼步驟 // 解釋\". Use arrow \"→\", \"Yes →\", \"No →\" and structure Start, End, Decision. No actual code.\n\nWe need algorithm: find added letter. Approach: sum ascii or use frequency difference. Simplest: compute frequency of each letter. For each char in t, increment. For each char in s, decrement. The remaining positive count gives added letter.\n\nWe need to produce virtual code lines.\n\nSteps:\n\nStart\n→ Step 1: 初始化 26 维数组 freq 归零 // 用于统计字母出现次数\n→ Step 2: 遍历字符串 t, freq[char]++ // 统计 t 中每个字母出现次数\n→ Step 3: 遍历字符串 s, freq[char]-- // 减去 s 的计数\n→ Decision: 是否存在 freq[char] > 0? // 检测是否找到了多余字母\n    Yes → Step 4: 输出该字符 // 找到的字母即为新增字母\n    No  → Step 5: 输出空或错误 // 理论上不可能出现\nEnd\n\nAlternatively use XOR approach, but array simpler.\n\nLet's output each step line with comment.\n\nWe must use the format \"虛擬碼步驟 // 解釋\".\n\nMake sure to use arrow lines with \"→\" for sequential steps, \"Yes →\" \"No →\" for branches.\n\nWe also need to include indentation for branches as in example. The example uses indentation for nested decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字母頻率陣列 freq[26] 置 0 // 建立 26 個元素用來統計每個字母的出現次數  \n→ Step 2: 對 t 進行遍歷，對每個字符 c: freq[ c - 'a' ]++ // 在 t 中累加各字母的計數  \n→ Step 3: 對 s 進行遍歷，對每個字符 c: freq[ c - 'a' ]-- // 在 s 中扣減各字母的計數  \n→ Decision: 是否存在 freq[i] > 0? // 檢查是否有字母在 t 中比 s 多出一次  \n    Yes → Step 4: 輸出對應的字母 (char) (i + 'a') // 找到多餘的字母即為新增字母  \n    No  → Step 5: 輸出空或報錯訊息 // 在理論上不應該發生，但作為備用分支  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        \"\"\"找出在 t 中多出的一個字母\"\"\"\n        # 用 Counter 計算字母出現次數\n        count_s = Counter(s)\n        count_t = Counter(t)\n        # t 會比 s 多一個字母，找出其差異\n        for ch in count_t:\n            if count_t[ch] != count_s.get(ch, 0):\n                return ch\n        return \"\"  # 只作備用，理論上不會執行到這裡\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入文字，假設輸入格式為：\n    s = \"abcd\", t = \"abcde\"\n    或者多行分別給出 s 和 t\n    \"\"\"\n    # 先嘗試從雙引號中抽取\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        return matches[0], matches[1]\n    # 其次嘗試以每行為一個字串\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n    # 最後退回到空字串與整段資料\n    return \"\", data.strip()\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    s, t = parse_input(raw_data)\n    sol = Solution()\n    result = sol.findTheDifference(s, t)\n    # 直接輸出字母，若無則輸出空字串\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcd\", t = \"abcde\"",
          "expected_output": "\"e\"",
          "success": true,
          "output": "e"
        },
        {
          "example_index": 1,
          "input": "s = \"\", t = \"y\"",
          "expected_output": "\"y\"",
          "success": true,
          "output": "y"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode75.json",
    "problem_index_in_file": 0,
    "title": "Sort Colors",
    "description_snippet": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for Dutch national flag algorithm. Provide step-by-step pseudocode with explanations. Use Start, End, Decision, arrows. Each line: code step + \" // explanation\". Provide the pseudocode lines with arrow \"→\". Use Yes/No arrows in decision blocks. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize three pointers: `low = 0`, `mid = 0`, `high = nums.length - 1` // 低位指標、高位指標、處理指標  \n→ Decision: 是否 `mid <= high`? // 判斷是否還有未處理元素  \n    Yes → Decision: `nums[mid] == 0`? // 判斷中間元素是否為紅色  \n        Yes → Step: 交換 `nums[low]` 與 `nums[mid]` // 把紅色元素移到前面  \n            → Increment `low` and `mid` // 更新低位和中位指標  \n        No  → Decision: `nums[mid] == 2`? // 判斷中間元素是否為藍色  \n            Yes → Step: 交換 `nums[mid]` 與 `nums[high]` // 把藍色元素移到後面  \n                → Decrement `high` // 更新高位指標  \n                → (不移動 `mid`) // 保留 mid，因為交換後的新元素還未分類  \n            No  → Step: `mid++` // 中間元素為白色，直接往右移動  \n    No → End // 所有元素已分類，程式結束\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def sortColors(self, nums):\n        \"\"\"\n        Rearranges the list `nums` in-place so that all 0s come first,\n        followed by all 1s, then all 2s. This uses the Dutch national flag\n        algorithm with three pointers.\n        \"\"\"\n        low, mid, high = 0, 0, len(nums) - 1\n\n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:  # nums[mid] == 2\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Find the first pair of brackets and extract the contents\n    match = re.search(r'\\[([^\\]]*)\\]', data)\n    if not match:\n        return\n\n    list_content = match.group(1)\n    nums = [int(x.strip()) for x in list_content.split(',') if x.strip()]\n\n    Solution().sortColors(nums)\n    # Output without spaces to match the example format\n    print('[' + ','.join(map(str, nums)) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,0,2,1,1,0]",
          "expected_output": "[0,0,1,1,2,2]",
          "success": true,
          "output": "[0,0,1,1,2,2]"
        },
        {
          "example_index": 1,
          "input": "nums = [2,0,1]",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0,1,2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode378.json",
    "problem_index_in_file": 0,
    "title": "K^th Smallest Element in a Sorted Matrix",
    "description_snippet": "Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the k^...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solution: find k-th smallest element in sorted matrix n x n, with better than O(n^2) memory, typical solution: use binary search on value range, count <= mid by scanning rows using binary search, or two pointers. Or use min-heap O(n log n) memory. Better memory than O(n^2). We'll produce virtual code lines describing algorithm. Use Start, End, Decision, etc. Steps: 1) define left min matrix[0][0], right max matrix[n-1][n-1]; 2) while left < right: mid = (left+right)//2; count elements <= mid by iterating rows using binary search (or pointer). 3) if count >= k, right=mid else left=mid+1; 4) return left.\n\nNeed to output virtual code step by step. Use arrow \"→\". Provide short comments.\n\nMake sure each line includes code and comment separated by space. Use \"→\" for steps. Use \"Decision:\" for decision blocks.\n\nLet's craft.\n\nNeed to keep each line of virtual code. Use indentation via indentation spaces.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 n = matrix.size() // 取得矩陣尺寸  \n→ Step 2: 設定 left = matrix[0][0] // 最小值  \n→ Step 3: 設定 right = matrix[n-1][n-1] // 最大值  \n\n→ Decision: 當 left < right 時 // 進行二分搜尋  \n    Yes → Step 4: 計算 mid = (left + right) / 2 // 取中值  \n    → Step 5: 初始化 count = 0 // 用於計算 ≤ mid 的元素數量  \n    → Decision: 循環遍歷每一行 i  \n        Yes → Step 6: 在 matrix[i] 中使用二分搜尋找到第一个 > mid 的索引 idx  \n        → Step 7: 加入 count += idx // 所有 <= mid 的元素數量  \n    → Decision: 若 count >= k 時 // 有足夠多元素 ≤ mid  \n        Yes → Step 8: 設定 right = mid // 將上限縮小  \n        No  → Step 9: 設定 left = mid + 1 // 將下限升高  \n→ Step 10: 循環結束後 left 即為第 k 小的元素 // 二分搜尋結束  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def kthSmallest(self, matrix, k):\n        n = len(matrix)\n        left, right = matrix[0][0], matrix[-1][-1]\n        while left < right:\n            mid = (left + right) // 2\n            # Count elements <= mid\n            count = 0\n            for row in matrix:\n                l, r = 0, n\n                while l < r:\n                    m = (l + r) // 2\n                    if row[m] <= mid:\n                        l = m + 1\n                    else:\n                        r = m\n                count += l\n            if count >= k:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract the matrix and k values from the input string\n    matrix_match = re.search(r\"matrix\\s*=\\s*(\\[.*?\\])\", data, re.S)\n    k_match = re.search(r\"k\\s*=\\s*(-?\\d+)\", data)\n    if not matrix_match or not k_match:\n        raise ValueError(\"Invalid input format.\")\n    matrix = ast.literal_eval(matrix_match.group(1))\n    k = int(k_match.group(1))\n\n    sol = Solution()\n    result = sol.kthSmallest(matrix, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp7edbmq_7.py\", line 35, in <module>\n    matrix = ast.literal_eval(matrix_match.group(1))\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,5,9]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmplj2j9gfw.py\", line 35, in <module>\n    matrix = ast.literal_eval(matrix_match.group(1))\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[-5]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode164.json",
    "problem_index_in_file": 0,
    "title": "Maximum Gap",
    "description_snippet": "Given an integer array nums, return the maximum difference between two successive elements in its so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, with Start, → etc. Provide linear-time algorithm for max gap problem using bucket sort / pigeonhole principle. Steps: if len<2 return 0. Compute min, max. If min==max return 0. Compute bucket size = ceil((max-min)/(n-1)). Determine bucket count = n-1 maybe. Create arrays minBucket, maxBucket size bucketCount, init with sentinel. Then place numbers into bucket, update min and max. Then iterate over buckets to find max gap between current bucket's min and previous bucket's max. Return maxGap.\n\nNeed linear time and space.\n\nWe produce virtual code with step by step and comments.\n\nLet's structure:\n\nStart\n\n→ Step 1: Check length <2? return 0.\n\n→ Step 2: Find global min and max.\n\n→ Decision: min == max? return 0.\n\n→ Step 3: bucketSize = ceil((max - min) / (n - 1))\n\n→ Step 4: bucketCount = (max - min) / bucketSize + 1 maybe but using n-1? Actually typical uses n-1 buckets. But safe to compute bucketCount = n - 1.\n\n→ Step 5: Initialize arrays minBucket[ bucketCount ], maxBucket[ bucketCount ] with sentinel values (∞, -∞).\n\n→ Step 6: For each num in nums: if num == min or num == max continue? In typical algorithm we still include but okay.\n\nCompute bucketIndex = (num - min) / bucketSize; but careful about last element equal to max might go bucketCount-1.\n\n→ Step 7: Update minBucket[idx], maxBucket[idx].\n\n→ Step 8: Iterate over buckets to compute maxGap: previousMax = min; for each bucket i: if minBucket[i]==∞ continue; gap = minBucket[i] - previousMax; update maxGap; previousMax = maxBucket[i].\n\n→ Step 9: return maxGap.\n\nInclude End.\n\nUse virtual arrows: → Step etc. Provide explanation.\n\nNeed to use \"Decision:\" for checks.\n\nWe'll format accordingly.\n\nAlso we need to mention linear space.\n\nLet's write.\n\nAlso include that bucketSize computed via ceil.\n\nEdge cases.\n\nLet's produce code lines.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取出輸入陣列 nums // 獲取使用者提供的整數陣列  \n→ Decision: 若 nums 長度 < 2? // 檢查是否至少有兩個元素  \n Yes → Step 2: 回傳 0 // 少於兩個元素，最大差為 0  \n No  → 進入下一步  \n\n→ Step 3: 變數 minVal ← nums[0] // 初始化最小值  \n→ Step 4: 變數 maxVal ← nums[0] // 初始化最大值  \n→ Step 5: 對 nums 中每個數字 num 做  \n  if num < minVal then minVal ← num // 更新最小值  \n  if num > maxVal then maxVal ← num // 更新最大值  \n\n→ Decision: 若 minVal == maxVal? // 所有數字相同  \n Yes → Step 6: 回傳 0 // 差距為 0  \n No  → 進入下一步  \n\n→ Step 7: 變數 n ← nums.length // 數字總數  \n→ Step 8: 變數 bucketSize ← ceil( (maxVal - minVal) / (n - 1) ) // 每個桶的大小  \n→ Step 9: 變數 bucketCount ← n - 1 // 桶的數量  \n\n→ Step 10: 建立兩個陣列  \n  minBucket[ bucketCount ] ← +∞ // 每個桶的最小值，初始為正無窮  \n  maxBucket[ bucketCount ] ← -∞ // 每個桶的最大值，初始為負無窮  \n\n→ Step 11: 對 nums 中每個數字 num 做  \n  bucketIndex ← (num - minVal) / bucketSize // 將 num 放入對應桶  \n  minBucket[ bucketIndex ] ← min( minBucket[ bucketIndex ], num ) // 更新桶最小值  \n  maxBucket[ bucketIndex ] ← max( maxBucket[ bucketIndex ], num ) // 更新桶最大值  \n\n→ Step 12: 變數 prevMax ← minVal // 上一個非空桶的最大值  \n→ Step 13: 變數 maxGap ← 0 // 目前已知的最大差距  \n\n→ Step 14: 從 i = 0 到 bucketCount - 1 做  \n  if minBucket[i] == +∞ then continue // 這個桶空，跳過  \n  gap ← minBucket[i] - prevMax // 兩個相鄰桶之間的差距  \n  maxGap ← max( maxGap, gap ) // 更新最大差距  \n  prevMax ← maxBucket[i] // 更新上一個非空桶的最大值  \n\n→ Step 15: 回傳 maxGap // 所求的最大差距  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom math import ceil\n\nclass Solution:\n    def maximumGap(self, nums):\n        # 若元素不足兩個，差距為 0\n        if len(nums) < 2:\n            return 0\n\n        # 找到整個陣列的最小值和最大值\n        min_val = min(nums)\n        max_val = max(nums)\n\n        # 所有數字相同，差距為 0\n        if min_val == max_val:\n            return 0\n\n        n = len(nums)\n        # bucket 大小（使用向上取整）\n        bucket_size = ceil((max_val - min_val) / (n - 1))\n        bucket_count = n - 1\n\n        # 兩個桶陣列：min_bucket 用來儲存每個桶內最小值\n        # max_bucket 用來儲存每個桶內最大值\n        min_bucket = [float('inf')] * bucket_count\n        max_bucket = [float('-inf')] * bucket_count\n\n        # 把數字放進桶裡\n        for num in nums:\n            idx = (num - min_val) // bucket_size\n            if idx >= bucket_count:      # 最值可能落在最後一個桶之外\n                idx = bucket_count - 1\n            if num < min_bucket[idx]:\n                min_bucket[idx] = num\n            if num > max_bucket[idx]:\n                max_bucket[idx] = num\n\n        # 逐桶掃描，計算相鄰非空桶之間的最大差距\n        max_gap = 0\n        prev_max = min_val\n        for i in range(bucket_count):\n            if min_bucket[i] == float('inf'):  # 桶是空的\n                continue\n            gap = min_bucket[i] - prev_max\n            if gap > max_gap:\n                max_gap = gap\n            prev_max = max_bucket[i]\n\n        return max_gap\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入，支持以下格式：\n    - 'nums = [1, 3, 6]'\n    - '[1, 3, 6]'\n    - '1 3 6'\n    \"\"\"\n    data = data.strip()\n    if '=' in data:\n        _, part = data.split('=', 1)\n        data = part.strip()\n    try:\n        # 嘗試使用 literal_eval 解析列表或元組\n        parsed = ast.literal_eval(data)\n        if isinstance(parsed, (list, tuple)):\n            return list(parsed)\n        # 若解析成功但不是 list/tuple，視為單個數字\n        return [parsed]\n    except Exception:\n        # 失敗時以空格分割\n        return list(map(int, data.split()))\n\ndef main():\n    raw = sys.stdin.read()\n    if not raw.strip():\n        return\n    nums = parse_input(raw)\n    result = Solution().maximumGap(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,6,9,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [10]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode350.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays II",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for intersection of two integer arrays with duplicates. Need to output each element as many times as it appears in both arrays. We can use hash map to count frequencies. Then iterate over second array, decrement counts, collect common.\n\nNeed to output step-by-step with explanation. Use virtual code lines.\n\nLet's produce: Start, Step: Input arrays, Step: Build frequency map of nums1, Step: Initialize result list, Step: Iterate over nums2, if map contains element with count>0, add to result and decrement, else skip, End.\n\nWe need to use virtual code with arrows etc. Use \"→\" arrow. Format: \"Step: ...\" etc.\n\nAlso may include Decision: If element in map? Use Yes/No.\n\nLet's produce.\n\nAlso mention the result list at end. Ensure each line has explanation after //.\n\nLet's write.\n\nRemember each line: \"虛擬碼步驟 // 解釋\".\n\nMake sure to use \"Start\" and \"End\".\n\nAlso we may show \"Decision: element in map?\" with Yes/No.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 取得兩個整數陣列 nums1 與 nums2 // 從輸入中取得兩組數字  \n→ Step: 建立空的頻率哈希表 freqMap // 用來記錄 nums1 中每個數字出現的次數  \n→ Decision: 迴圈遍歷 nums1? // 逐一處理 nums1 的每個元素  \n    Yes → Step: 若元素 x 尚未在 freqMap, 則在 freqMap[x] 設為 1  \n    Yes → Step: 若元素 x 已在 freqMap, 則 freqMap[x] 加 1  \n    No  → Step: 退出 nums1 迴圈 // 完成 nums1 的頻率統計  \n→ Step: 建立空的結果列表 result // 用於儲存交集元素  \n→ Decision: 迴圈遍歷 nums2? // 逐一處理 nums2 的每個元素  \n    Yes → Decision: 元素 y 是否在 freqMap 且 freqMap[y] > 0? // 檢查是否仍有未匹配的 y  \n        Yes → Step: 將 y 加入 result // 將公共元素加入結果  \n        Yes → Step: freqMap[y] 減 1 // 消耗一個已匹配的 y  \n        No  → Step: 跳過 y // 這個 y 在 nums1 中已無剩餘，忽略  \n    No  → Step: 退出 nums2 迴圈 // 完成 nums2 的遍歷  \n→ Step: 輸出 result // 回傳交集結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        \"\"\"回傳兩個陣列的交集，重複次數取最小值\"\"\"\n        c1, c2 = Counter(nums1), Counter(nums2)\n        res = []\n        for num in c1:\n            if num in c2:\n                res.extend([num] * min(c1[num], c2[num]))\n        return res\n\ndef parse_input(input_str):\n    \"\"\"\n    從輸入字串中抓取兩個列表。輸入範例：\n        nums1 = [1,2,2,1], nums2 = [2,2]\n    \"\"\"\n    # 找出所有形如 [ ... ] 的子字串\n    lists = re.findall(r'\\[.*?\\]', input_str)\n    if len(lists) != 2:\n        raise ValueError(\"輸入格式不正確，應包含兩個列表\")\n    # 使用 ast.literal_eval 解析成 Python list\n    nums1 = ast.literal_eval(lists[0])\n    nums2 = ast.literal_eval(lists[1])\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    # 解析輸入得到兩個列表\n    nums1, nums2 = parse_input(raw_input)\n    # 執行交集邏輯\n    sol = Solution()\n    result = sol.intersect(nums1, nums2)\n    # 將結果輸出到標準輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2,2]",
          "success": true,
          "output": "[2, 2]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "success": true,
          "output": "[4, 9]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode691.json",
    "problem_index_in_file": 0,
    "title": "Stickers to Spell Word",
    "description_snippet": "We are given n different types of stickers. Each sticker has a lowercase English word on it.\nYou wou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for the problem: Minimum Stickers to Spell Word. Classic DP with bitmask? Since target up to maybe 10? But typical solution uses DFS + memo or DP over subsets of target letters. But requirement: produce virtual code line by line, with explanations.\n\nWe should propose algorithm: preprocess stickers counts, recursion with memo on remaining target string sorted. Use DP with bitmask or string key. For simplicity, use memoization of remaining string. Steps:\n\nStart\n→ Preprocess stickers: for each sticker create frequency map of letters.\n→ Define function dfs(remaining) returns min stickers needed.\n→ Base: if remaining empty return 0.\n→ If remaining in memo return memo value.\n→ Initialize res = Infinity.\n→ For each sticker freq: create newRemaining by subtracting sticker letters from remaining (greedy: subtract min counts). If newRemaining length < remaining length: then res = min(res, 1 + dfs(newRemaining)).\n→ memo[remaining] = res if finite else -1\n→ Return memo[remaining]\n→ Main: Call dfs(target). If result==-1 return -1 else result.\n\nEdge case: if target cannot be made with any sticker: return -1.\n\nWe need to produce virtual code with arrows and comments.\n\nUse lines: Start, Step 1, etc. For decisions we show Yes/No arrows.\n\nWe need to mention string key: maybe sorted remaining string to ensure memoization.\n\nWe also need to show subroutine for subtracting.\n\nWe can produce algorithm as pseudocode.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入 stickers 與 target // 取得貼紙詞彙列表與目標字串  \n→ Step 2: 建立 stickersCountList // 將每張貼紙轉成 26 個字母頻率陣列  \n\n    → Decision: stickersCountList 是否為空？  \n        Yes → Step 3: 回傳 -1 // 無貼紙無法完成  \n        No  → 進行下一步  \n\n→ Step 4: 定義遞迴函式 dfs(remaining) // 以剩餘字串為鍵求最小貼紙數  \n    → Decision: remaining 是否為空？  \n        Yes → Step 5: 回傳 0 // 已完成拼字  \n        No  → 進行下一步  \n\n    → Step 6: 若 remaining 在 memo 中，回傳 memo[remaining] // 重複子問題的快取  \n\n    → Step 7: 將 remaining 轉成字母頻率 countR  \n    → Step 8: 設定 best = Infinity // 初始化最小貼紙數  \n\n    → Decision: stickersCountList 是否為空？  \n        Yes → Step 9: memo[remaining] = -1 // 無貼紙可用，無解  \n        No  →  \n\n        → Step 10: 迭代每個 stickerCount in stickersCountList  \n            → Step 11: 用 stickerCount 減去 countR 產生 newCountR  \n                // 只保留非負數，代表貼紙減去後的剩餘字母頻率  \n\n            → Step 12: 若 newCountR 的總和 < countR 的總和，表示貼紙有效  \n                → Decision: newCountR 是否為空？  \n                    Yes → Step 13: temp = 1 // 只需這張貼紙  \n                    No  → Step 14: temp = 1 + dfs(字母頻率轉字串 newCountR) // 仍需遞迴  \n\n                → Step 15: best = min(best, temp) // 更新全局最小值  \n\n        → Step 16: 若 best 為 Infinity，memo[remaining] = -1  \n        → Decision: best 是否為 Infinity？  \n            Yes → memo[remaining] = -1  \n            No  → memo[remaining] = best  \n\n    → Step 17: 回傳 memo[remaining]  \n\n→ Step 18: 呼叫 result = dfs(target) // 從完整目標字串開始  \n\n→ Decision: result 為 -1？  \n    Yes → Step 19: 輸出 -1 // 任務無法完成  \n    No  → Step 20: 輸出 result // 最小貼紙數  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def minStickers(self, stickers, target):\n        # 將每張貼紙轉成 Counter (字母頻率表)\n        sticker_counts = [Counter(s) for s in stickers]\n        memo = {}\n\n        def dfs(rem):\n            if rem == \"\":\n                return 0\n            if rem in memo:\n                return memo[rem]\n\n            rem_count = Counter(rem)\n            best = float(\"inf\")\n\n            for sc in sticker_counts:\n                # 若貼紙不含 rem 的首字母，可跳過 (加速)\n                if rem[0] not in sc:\n                    continue\n\n                # 計算使用這張貼紙後剩餘的字母\n                new_rem = []\n                for ch, cnt in rem_count.items():\n                    left = cnt - sc.get(ch, 0)\n                    if left > 0:\n                        new_rem.extend([ch] * left)\n                new_rem_str = \"\".join(new_rem)\n\n                if new_rem_str == rem:\n                    # 貼紙沒有幫上忙，跳過\n                    continue\n\n                sub = dfs(new_rem_str)\n                if sub != -1:\n                    best = min(best, 1 + sub)\n\n            memo[rem] = -1 if best == float(\"inf\") else best\n            return memo[rem]\n\n        return dfs(target)\n\ndef parse_input(text):\n    \"\"\"\n    解析輸入文字，從中提取 stickers 列表和 target 字串。\n    支援形如:\n        stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"\n    或多行輸入。\n    \"\"\"\n    stickers = []\n    target = \"\"\n\n    # 嘗試從整段文字中提取 stickers 列表\n    m = re.search(r'stickers\\s*=\\s*(\\[.*?\\])', text, re.S)\n    if m:\n        try:\n            stickers = eval(m.group(1), {}, {})\n        except Exception:\n            stickers = []\n\n    # 提取 target 字串\n    m = re.search(r'target\\s*=\\s*[\"\\'](.*?)[\"\\']', text)\n    if m:\n        target = m.group(1)\n\n    # 如果找不到，試著用簡單分行方式\n    if not stickers or not target:\n        lines = [line.strip() for line in text.splitlines() if line.strip()]\n        if lines:\n            # 第一行可能是貼紙列表\n            try:\n                stickers = eval(lines[0], {}, {})\n            except Exception:\n                stickers = []\n            if len(lines) > 1:\n                target = lines[1].strip().strip('\"').strip(\"'\")\n\n    return stickers, target\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    stickers, target = parse_input(raw_input)\n    if not stickers or not target:\n        print(-1)\n        return\n    result = Solution().minStickers(stickers, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "stickers = [\"notice\",\"possible\"], target = \"basicbasic\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode583.json",
    "problem_index_in_file": 0,
    "title": "Delete Operation for Two Strings",
    "description_snippet": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and wor...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for computing minimum deletions to make two strings equal. That's essentially 2 * length minus 2 * LCS. Actually min steps = len(word1)+len(word2)-2*LCS. We need to outline algorithm: compute LCS length via DP, then result. Provide virtual code lines with explanations. Ensure use of Start, End, Decision, etc. Use arrow format.\n\nLet's produce step-by-step:\n\nStart\n→ Input word1, word2\n→ Compute n = len(word1), m = len(word2)\n→ Create DP table of size (n+1)x(m+1) initialized to 0\n→ For i from 1 to n:\n   → For j from 1 to m:\n      → Decision: if word1[i-1] == word2[j-1]?\n         Yes → DP[i][j] = DP[i-1][j-1] + 1\n         No  → DP[i][j] = max(DP[i-1][j], DP[i][j-1])\n→ LCS = DP[n][m]\n→ Result = n + m - 2*LCS\n→ Output Result\nEnd\n\nNeed to include each line with explanation. Use arrow arrows. For loops maybe use \"→ For i=1 to n:\" etc.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Input word1, word2 // 取得兩個字串作為輸入\n→ Decision: 如果 word1 為空? // 檢查字串是否為空\n    Yes → Output 0 // 若兩字串皆空，最少步驟為 0\n    No  → \n→ Decision: 如果 word2 為空? // 檢查第二字串是否為空\n    Yes → Output len(word1) // 只需刪除 word1 所有字元\n    No  → \n→ Assign n = len(word1) // 取得 word1 長度\n→ Assign m = len(word2) // 取得 word2 長度\n→ Create DP table of size (n+1) x (m+1) initialized to 0 // 用於儲存 LCS 子問題結果\n→ For i = 1 to n: // 遍歷 word1 的每個字元\n    → For j = 1 to m: // 遍歷 word2 的每個字元\n        → Decision: 如果 word1[i-1] == word2[j-1]? // 字元是否相等\n            Yes → DP[i][j] = DP[i-1][j-1] + 1 // 取左上角值加一，表示 LCS 延長\n            No  → DP[i][j] = max(DP[i-1][j], DP[i][j-1]) // 取上或左較大值，表示保持 LCS 長度\n→ Assign LCS = DP[n][m] // 最終 LCS 長度\n→ Assign result = n + m - 2 * LCS // 計算最少刪除步驟\n→ Output result // 回傳答案\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_deletions_to_equal(word1: str, word2: str) -> int:\n    \"\"\"Return the minimum number of deletions needed to make two strings equal.\"\"\"\n    n, m = len(word1), len(word2)\n    # DP table for longest common subsequence length\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # Fill DP table\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    lcs_len = dp[n][m]\n    # Minimum deletions = total length - 2 * LCS length\n    return n + m - 2 * lcs_len\n\n\ndef parse_input(data: str):\n    \"\"\"Extract two words from the input string.\"\"\"\n    # Find all quoted substrings\n    words = re.findall(r'\"([^\"]*)\"', data)\n    if len(words) >= 2:\n        return words[0], words[1]\n    # Fallback: try to split by comma if no quotes\n    parts = data.replace('word1', '').replace('word2', '').split(',')\n    words = [p.strip().strip('\"') for p in parts if p.strip()]\n    if len(words) >= 2:\n        return words[0], words[1]\n    raise ValueError(\"Input format not recognized.\")\n\n\ndef main():\n    data = sys.stdin.read()\n    word1, word2 = parse_input(data)\n    result = min_deletions_to_equal(word1, word2)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "word1 = \"sea\", word2 = \"eat\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "word1 = \"leetcode\", word2 = \"etco\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode28.json",
    "problem_index_in_file": 0,
    "title": "Implement strStr()",
    "description_snippet": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystac...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The requirement: virtual code with arrows →, Decision: etc. Provide each line with virtual code step and // explanation.\n\nWe need to implement substring search. Simple approach: iterate through haystack, check if substring matches. So steps: Start, input needle, haystack, Decision: needle empty? etc. Let's produce.\n\nWe will produce step by step.\n\nWe need to include arrows and indent decision branches.\n\nLet's craft.\n\nStart\n→ Step 1: 計算 needle 與 haystack 長度 // 取得長度\n→ Decision: 若 needle 為空則回傳 0 // 空字串總是存在\n    Yes → Step 2: 回傳 0 // 直接結束\n    No → Decision: 若 needle 長度 > haystack 長度則回傳 -1 // 無法包含\n        Yes → Step 3: 回傳 -1\n        No → Step 4: 設定 i = 0 // 迴圈起始位置\n→ Decision: i <= haystack.length - needle.length? // 循環條件\n    Yes → Decision: haystack[i … i+needle.length-1] == needle? // 子字串比對\n        Yes → Step 5: 回傳 i // 找到\n        No  → Step 6: i = i + 1 // 位置往後移\n        → Step 4: 再次判斷 Decision: i <= haystack.length - needle.length? // 迴圈\n            (Same pattern)\n    No → Step 7: 回傳 -1 // 沒找到\nEnd\n\nBut we need to use arrows for each step. Let's format properly.\n\nNeed to include arrow for each step, including decision branches.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 needle 與 haystack 的長度 // 先算出兩個字串的長度  \n→ Decision: 若 needle 為空字串? // 空字串在任何位置皆視為匹配  \n    Yes → Step 2: 回傳 0 // 立即返回起始索引  \n    No → Decision: 若 needle 長度 > haystack 長度? // 若字串太長不可能匹配  \n        Yes → Step 3: 回傳 -1 // 直接結束，表示未找到  \n        No → Step 4: 設定 i = 0 // 初始化搜尋起點  \n→ Decision: i <= haystack.length - needle.length? // 判斷還有可搜尋的範圍  \n    Yes → Decision: haystack[i … i+needle.length-1] 與 needle 是否相等? // 進行子字串比對  \n        Yes → Step 5: 回傳 i // 找到第一個匹配位置，結束  \n        No → Step 6: i = i + 1 // 沒匹配，移到下一個起點  \n        → Step 4: 再次判斷 Decision: i <= haystack.length - needle.length? // 進入下一輪循環  \n            (此處重複前述決策流程)  \n    No → Step 7: 回傳 -1 // 沒有任何匹配，結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"Return the index of the first occurrence of needle in haystack,\n        or -1 if needle is not part of haystack.\"\"\"\n        if not needle:          # 空字串始終在位置 0\n            return 0\n\n        n, m = len(haystack), len(needle)\n        for i in range(n - m + 1):\n            if haystack[i:i + m] == needle:\n                return i\n        return -1\n\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取 haystack 與 needle。預期輸入格式類似\n    'haystack = \"sadbutsad\", needle = \"sad\"'\n    或者每行一個字串。若找不到雙引號，則按空白拆分。\n    \"\"\"\n    # 先尋找所有雙引號內的內容\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        return matches[0], matches[1]\n    # 如果沒有雙引號，嘗試按行拆分\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n    # 最後的 fallback：按空白拆分\n    parts = data.strip().split()\n    return parts[0], parts[1] if len(parts) > 1 else ''\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    haystack, needle = parse_input(raw_input)\n    sol = Solution()\n    result = sol.strStr(haystack, needle)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "haystack = \"sadbutsad\", needle = \"sad\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "haystack = \"leetcode\", needle = \"leeto\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode605.json",
    "problem_index_in_file": 0,
    "title": "Can Place Flowers",
    "description_snippet": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode that solves problem: given flowerbed array 0/1, and n new flowers, can plant n flowers such that no adjacent. We output line-by-line virtual code with explanation.\n\nWe need to follow format: Each line: \"虛擬碼步驟 // 解釋\". Use arrow symbols. Use Start, End, Decision.\n\nWe must not output actual code, only pseudocode steps. So something like:\n\nStart // 程式開始\n→ Step 1: 初始化 count = 0 // 記錄已種植的新花數\n→ Step 2: 為每個位置 i 從 0 到 len(flowerbed)-1 迴圈 // 遍歷花床\n    → Decision: 如果 flowerbed[i]==0 且 (i==0 或 flowerbed[i-1]==0) 且 (i==len-1 或 flowerbed[i+1]==0)? // 檢查此位置可種植\n        Yes → Step 3: flowerbed[i] = 1 // 種植花\n             → Step 4: count = count + 1 // 新花計數加一\n             → Decision: count >= n? // 已達到目標\n                 Yes → Step 5: 返回 true // 可種植足夠\n                 No  → Decision: i == len-1? // 是否到尾端\n                     Yes → Step 6: 返回 false // 不足\n                     No  → Step 7: 繼續迴圈\n    No  → Step 8: 繼續迴圈\n→ Decision: i == len-1? // 迴圈結束\n    Yes → Step 9: 返回 false // 無法種植足夠\n    No  → Step 10: 繼續迴圈\nEnd\n\nBut ensure each line includes arrow appropriately. Use indentation. Each line start with arrow? In example they used \"→ Step 1: ...\". For decisions, indent under Decision. We can mimic style.\n\nBetter to structure like:\n\nStart\n→ Step 1: count = 0\n→ For i = 0 to length-1\n    → Decision: flowerbed[i]==0 AND (i==0 OR flowerbed[i-1]==0) AND (i==length-1 OR flowerbed[i+1]==0)?\n        Yes → Step 2: flowerbed[i] = 1\n            → Step 3: count += 1\n            → Decision: count >= n?\n                Yes → Step 4: return true\n                No  → (continue loop)\n    No  → (continue loop)\n→ Decision: loop finished AND count < n?\n    Yes → Step 5: return false\n    No  → (shouldn't happen)\nEnd\n\nBut we must adhere to output format: Each line separate, not nested with indent? But example shows indentation under Decision. We should replicate.\n\nWe must not output actual code, only pseudo steps. Use Chinese explanation.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設置 count = 0 // 用來記錄已種植的新花數  \n→ Step 2: 取 flowerbed 的長度為 m // 知道迴圈範圍  \n→ Step 3: For i = 0 到 m-1 // 遍歷每個花床格子  \n  → Decision: 如果 flowerbed[i] == 0 且 (i == 0 或 flowerbed[i-1] == 0) 且 (i == m-1 或 flowerbed[i+1] == 0)？ // 檢查此格是否可以種花  \n   Yes → Step 4: 把 flowerbed[i] 設為 1 // 種植花  \n    → Step 5: count += 1 // 新花計數加一  \n    → Decision: count >= n？ // 已經種到目標數量？  \n     Yes → Step 6: 返回 true // 可以種到 n 朵花  \n     No → (繼續迴圈) // 仍需再種  \n   No → (繼續迴圈) // 這格不能種，直接跳到下一格  \n→ Decision: 迴圈結束且 count < n？ // 已遍歷完所有格子還不足 n 朵？  \n  Yes → Step 7: 返回 false // 無法種到 n 朵花  \n  No → (理論上不會發生)  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def canPlaceFlowers(self, flowerbed, n):\n        count = 0\n        length = len(flowerbed)\n        i = 0\n        while i < length:\n            if flowerbed[i] == 0:\n                empty_prev = (i == 0) or (flowerbed[i-1] == 0)\n                empty_next = (i == length - 1) or (flowerbed[i+1] == 0)\n                if empty_prev and empty_next:\n                    flowerbed[i] = 1\n                    count += 1\n                    if count >= n:\n                        return True\n            i += 1\n        return count >= n\n\ndef parse_input(s: str):\n    # 取出 flowerbed 列表\n    m = re.search(r'flowerbed\\s*=\\s*(\\[[^\\]]*\\])', s)\n    if m:\n        flowerbed = ast.literal_eval(m.group(1))\n    else:\n        flowerbed = []\n\n    # 取出 n 整數\n    m = re.search(r'n\\s*=\\s*(-?\\d+)', s)\n    n = int(m.group(1)) if m else 0\n    return flowerbed, n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    flowerbed, n = parse_input(data)\n    sol = Solution()\n    result = sol.canPlaceFlowers(flowerbed, n)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "flowerbed = [1,0,0,0,1], n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "flowerbed = [1,0,0,0,1], n = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode768.json",
    "problem_index_in_file": 0,
    "title": "Max Chunks To Make Sorted II",
    "description_snippet": "You are given an integer array arr.\n\nWe split arr into some number of chunks (i.e., partitions), and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem \"Max Chunks To Make Sorted II\" (LeetCode 768). We must output step-by-step virtual code lines. The algorithm: maintain max of left and min of right. We iterate and find partitions where max_left <= min_right. We need to compute max_right array. Approach: compute suffix minima. Then iterate.\n\nWe need to produce virtual code step-by-step with explanation per line. Use arrow syntax. Each line has virtual code step and explanation. We can't output real code, just virtual representation. We need to produce \"Start\", \"End\", \"Decision:\" etc.\n\nWe must treat as \"逐行\" meaning each line of pseudo. Provide explanation after space. Use arrow \"→\".\n\nLet's craft:\n\nStart\n→ Step 1: 建立長度為 n 的 minRight 陣列 // 用來儲存從每個索引到結尾的最小值\n→ Step 2: 設 minRight[n-1] = arr[n-1] // 最後一個位置的最小值為自己\n→ Decision: 從 i = n-2 到 0 遞減? // 準備反向遍歷\n    Yes → Step 3: minRight[i] = min(arr[i], minRight[i+1]) // 取當前與右側最小值\n    No  → Step 4: // 完成 minRight 計算\n→ Step 5: 設 maxLeft = -∞ // 用於追蹤左側最大值\n→ Step 6: 設 result = 0 // 迭代計數分割\n→ Decision: 從 i = 0 到 n-1? // 正向遍歷\n    Yes → Step 7: maxLeft = max(maxLeft, arr[i]) // 更新左側最大值\n    Yes → Decision: maxLeft <= minRight[i+1]? // 檢查分割條件\n        Yes → Step 8: result += 1 // 可形成一個分割\n        No  → Step 9: // 無法分割，繼續\n    No  → Step 10: // 遍歷完畢\n→ End // 回傳 result\n\nBut we need to handle boundary: for i=n-1, minRight[i+1] out of bound. We can treat minRight[n] = +∞. Let's incorporate.\n\nWe should keep minRight array of size n+1 with minRight[n] = +∞. Then condition for all i.\n\nLet's restructure:\n\nStart\n→ Step 1: n = arr.length // 取得陣列長度\n→ Step 2: 建立 minRight[0…n] // 長度 n+1\n→ Step 3: minRight[n] = +∞ // 右端最小值設為無限大\n→ Decision: i = n-1 downto 0? // 從尾到頭\n    Yes → Step 4: minRight[i] = min(arr[i], minRight[i+1]) // 更新最小值\n    No  → Step 5: // minRight 計算完成\n→ Step 6: maxLeft = -∞ // 左側最大值\n→ Step 7: result = 0 // 分割數\n→ Decision: i = 0 to n-1? // 正向遍歷\n    Yes → Step 8: maxLeft = max(maxLeft, arr[i]) // 更新最大值\n    Yes → Decision: maxLeft <= minRight[i+1]? // 判斷是否可以切割\n        Yes → Step 9: result += 1 // 切割成功\n        No  → Step 10: // 不切割\n    No  → Step 11: // 完成遍歷\n→ End // 回傳 result\n\nNeed to include explanation.\n\nLet's craft final answer with each line. Ensure each line has \"虛擬碼步驟\" and explanation after space.\n\nWe'll produce using the required format: e.g.,\n\nStart // 程式開始執行\n→ Step 1: n = arr.length // 取得陣列長度\n...\n\nWe must include \"Decision:\" lines with Yes/No.\n\nMake sure to use arrow \"→\".\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = arr.length // 取得陣列長度  \n→ Step 2: 建立 minRight[0…n] // 用來儲存每個位置右側最小值  \n→ Step 3: minRight[n] = +∞ // 右端的最小值設為無限大，方便邊界判斷  \n→ Decision: i = n-1 迭代到 0? // 需要從尾部往前計算最小值  \n  Yes → Step 4: minRight[i] = min(arr[i], minRight[i+1]) // 取當前值與右側最小值中的較小者  \n  No → Step 5: // minRight 計算完成  \n→ Step 6: maxLeft = -∞ // 初始化左側最大值  \n→ Step 7: result = 0 // 用於計數可切割的段數  \n→ Decision: i = 0 迭代到 n-1? // 正向遍歷陣列  \n  Yes → Step 8: maxLeft = max(maxLeft, arr[i]) // 更新左側最大值  \n  Yes → Decision: maxLeft <= minRight[i+1]? // 判斷是否能在此位置切割  \n    Yes → Step 9: result += 1 // 成功切割，段數加一  \n    No → Step 10: // 無法切割，繼續往後遍歷  \n  No → Step 11: // 遍歷完畢，計算結束  \nEnd // 程式執行結束，返回 result 為最大可切割段數",
      "generated_code": "import sys\nimport re\n\ndef max_chunks_to_sorted(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    # suffix minimum array with an extra slot for +inf sentinel\n    min_right = [0] * (n + 1)\n    min_right[n] = float('inf')\n    for i in range(n - 1, -1, -1):\n        min_right[i] = arr[i] if arr[i] < min_right[i + 1] else min_right[i + 1]\n\n    max_left = -float('inf')\n    chunks = 0\n    for i in range(n):\n        max_left = arr[i] if arr[i] > max_left else max_left\n        if max_left <= min_right[i + 1]:\n            chunks += 1\n    return chunks\n\ndef parse_input(data):\n    # extract all integers (including negatives) from the input string\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    return nums\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    arr = parse_input(raw)\n    result = max_chunks_to_sorted(arr)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [5,4,3,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "arr = [2,1,3,4,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode664.json",
    "problem_index_in_file": 0,
    "title": "Strange Printer",
    "description_snippet": "There is a strange printer with the following two special properties:\n\nThe printer can only print a ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solving the problem: Strange Printer (LeetCode 664). Need dynamic programming: dp[l][r] minimal turns to print s[l..r]. Recurrence: dp[l][r] = dp[l][r-1] + 1 initially; then for k from l to r-1 where s[k]==s[r], dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r-1]). Also base: dp[i][i]=1. Need to handle string s length n. Steps: Input string, initialize dp array, iterate length from 1 to n, nested loops. At the end output dp[0][n-1]. Provide explanation per line.\n\nWe must output in format: \"虛擬碼步驟 // 解釋\". Include Start, End, Decision, etc. Should be sequential lines. No actual code. Provide pseudo with arrows.\n\nWe can produce steps:\n\nStart\n→ Step 1: Read string s // 取得輸入字串\n→ Step 2: n ← length of s // 字串長度\n→ Step 3: Create 2D array dp[n][n] // 動態規劃表\n→ Step 4: For i from 0 to n-1: dp[i][i] ← 1 // 單一字元需要 1 次\n→ Step 5: For len from 2 to n: // 依段長度遞增\n    → Step 5.1: For l from 0 to n-len: r ← l+len-1 // 子串範圍\n        → Step 5.1.1: dp[l][r] ← dp[l][r-1] + 1 // 將 s[r] 單獨打印\n        → Step 5.1.2: For k from l to r-1:\n            → Decision: s[k] == s[r] ?\n                Yes → dp[l][r] ← min(dp[l][r], dp[l][k] + dp[k+1][r-1]) // 合併相同字符\n                No  → // 省略\n→ Step 6: Result ← dp[0][n-1] // 整個字串最少步數\n→ End // 程式結束\n\nBut we need to include arrow symbols and Decision. Use \"Decision:\" and Yes/No arrows. Also the pseudocode lines should each contain the step text and comment. Use appropriate spacing.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read string s // 取得輸入字串  \n→ Step 2: n ← length of s // 計算字串長度  \n→ Step 3: Create 2D array dp[n][n] // 用於儲存子字串的最小步數  \n→ Step 4: For i from 0 to n-1: dp[i][i] ← 1 // 單一字元需要 1 次印刷  \n→ Step 5: For len from 2 to n: // 逐段長度處理  \n  → Step 5.1: For l from 0 to n-len: r ← l+len-1 // 設定子字串範圍 [l, r]  \n    → Step 5.1.1: dp[l][r] ← dp[l][r-1] + 1 // 把 s[r] 單獨印一次  \n    → Step 5.1.2: For k from l to r-1: // 嘗試合併相同字元的印刷  \n      → Decision: s[k] == s[r] ? // 判斷是否可以合併  \n       Yes → dp[l][r] ← min(dp[l][r], dp[l][k] + dp[k+1][r-1]) // 合併後的最小步數  \n       No  → // 直接跳過  \n→ Step 6: Result ← dp[0][n-1] // 整個字串的最小印刷次數  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef strange_printer(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [[0] * n for _ in range(n)]\n    # Base case: single character\n    for i in range(n):\n        dp[i][i] = 1\n    # Build DP for increasing lengths\n    for length in range(2, n + 1):\n        for l in range(0, n - length + 1):\n            r = l + length - 1\n            # Default: print s[r] separately\n            dp[l][r] = dp[l][r - 1] + 1\n            # Try merging with same character\n            for k in range(l, r):\n                if s[k] == s[r]:\n                    val = dp[l][k]\n                    if k + 1 <= r - 1:\n                        val += dp[k + 1][r - 1]\n                    dp[l][r] = min(dp[l][r], val)\n    return dp[0][n - 1]\n\ndef parse_input(data: str) -> str:\n    # Try to extract string between quotes\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if matches:\n        return matches[0]\n    # Fallback: remove everything except letters\n    data = data.strip()\n    if data.lower().startswith(\"s =\"):\n        data = data[3:].strip()\n    data = data.strip('\"')\n    return data\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    s = parse_input(raw)\n    result = strange_printer(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aaabbb\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode377.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum IV",
    "description_snippet": "Given an array of distinct integers nums and a target integer target, return the number of possible ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step-by-step for problem: Count number of combinations from array of distinct ints that sum to target. Order matters? Typically it's combination sum 2? But they say combinations that add up to target, test cases ensure 32-bit. Usually \"combinations\" might consider order not important? But typical problem is \"combination sum IV\" where order matters. Let's assume order matters? We'll produce generic algorithm: dynamic programming. Steps: initialize dp array size target+1 with dp[0]=1. For each i from 1 to target, for each num in nums if num <= i, dp[i] += dp[i-num]. Then answer dp[target].\n\nWe need to produce virtual code with arrows and decisions. Let's output steps: Start, Input, Initialize dp, Loop over target, Inner loop, etc. End.\n\nLet's write each line with explanation. Use \"→\" arrow. For decisions: if num <= i? maybe.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取數組 nums 與目標值 target // 從使用者取得輸入\n→ Step 2: 建立 dp 陣列長度 target+1，所有元素設為 0 // 用於存放子問題答案\n→ Step 3: 設定 dp[0] = 1 // 只有一種方式將 0 由空集合組合\n→ Decision: 迭代 i 從 1 到 target? // 建立主循環\n    Yes → Step 4: 對每個 num 於 nums? // 內層循環遍歷所有可用數字\n        → Decision: 如果 num <= i? // 判斷數字是否可用於此目標\n            Yes → Step 5: dp[i] += dp[i - num] // 累加之前已知的組合數\n            No  → No operation // 不可用，跳過\n    No  → End // 所有 i 都處理完\n→ Step 6: 輸出 dp[target] // 返回最終答案\nEnd // 程式執行結束\n\nBut we need to follow format: each line is virtual code step with // explanation. Use \"Decision:\" lines. For loops we might use arrow \"→\" for each step. For nested loops we can indent? Not required but we can show nested. Use arrow \"→\" to go into loops.\n\nBut the example uses indentation for decision branches. We'll replicate style.\n\nLet's output exactly lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入 nums 與 target // 取得使用者輸入的陣列與目標值\n→ Step 2: 建立 dp 陣列長度 target+1 並全部初始化為 0 // dp 用於存儲子問題答案\n→ Step 3: 設定 dp[0] = 1 // 只有一種方式將 0 由空集合組合\n→ Decision: 對 i 從 1 到 target 迭代? // 主循環遍歷所有子目標\n    Yes → Step 4: 對每個 num 於 nums 進行迭代 // 內層循環遍歷可用數字\n        → Decision: 如果 num <= i? // 判斷 num 是否可用於此子目標\n            Yes → Step 5: dp[i] = dp[i] + dp[i - num] // 累加該數字的組合數\n            No  → No operation // num 太大，跳過\n    No  → End // 完成所有子目標\n→ Step 6: 輸出 dp[target] // 回傳總組合數\nEnd // 程式結束\n\nNeed to ensure each line ends with // 解釋. Also lines like \"No operation\" maybe we can skip? But each line must have explanation. \"No operation\" explanation: // num 太大，跳過. Good.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 nums 與 target // 取得使用者輸入的陣列與目標值  \n→ Step 2: 建立 dp 陣列長度 target+1 並全部初始化為 0 // dp 用於存儲子問題答案  \n→ Step 3: 設定 dp[0] = 1 // 只有一種方式將 0 由空集合組合  \n→ Decision: 對 i 從 1 到 target 迭代? // 主循環遍歷所有子目標  \n Yes → Step 4: 對每個 num 於 nums 進行迭代 // 內層循環遍歷可用數字  \n  → Decision: 如果 num <= i? // 判斷 num 是否可用於此子目標  \n   Yes → Step 5: dp[i] = dp[i] + dp[i - num] // 累加該數字的組合數  \n   No  → No operation // num 太大，跳過  \n No  → End // 完成所有子目標  \n→ Step 6: 輸出 dp[target] // 回傳總組合數  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combinationSum4(self, nums, target):\n        dp = [0] * (target + 1)\n        dp[0] = 1  # one way to reach 0\n\n        for i in range(1, target + 1):\n            for num in nums:\n                if i - num >= 0:\n                    dp[i] += dp[i - num]\n        return dp[target]\n\ndef main():\n    data = sys.stdin.read()\n    # 提取所有整數\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if not numbers:\n        return\n    target = numbers[-1]\n    nums = numbers[:-1]\n    sol = Solution()\n    result = sol.combinationSum4(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "nums = [9], target = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode726.json",
    "problem_index_in_file": 0,
    "title": "Number of Atoms",
    "description_snippet": "Given a string formula representing a chemical formula, return the count of each atom.\n\nThe atomic e...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with comments. Let's design algorithm: parse string with stack for nested parentheses. Use map to count. Parse from end to start easier? We'll produce algorithm: iterate characters, use stack of maps. When see ')', push new map. When '(', pop current map and multiply by following number. Use digits to get number. We need to handle uppercase/lowercase.\n\nLet's produce pseudo code.\n\nLine by line.\n\nWe should start: Start // begin\n\nThen Step 1: Initialize stack with empty map // stack to hold counts per scope\n\nLoop through formula from left to right? But easier from right to left: but we can use stack. Let's go left to right: when encountering '(', push new map. When encountering ')', read following number (multiplier), pop map, multiply counts, merge into previous map.\n\nParsing element: read uppercase then lowercase letters, gather element name. Then read digits following element for count. Then add to current map.\n\nWe need functions: readNumber. We'll parse contiguous digits into integer. Default 1.\n\nAt end, result is stack top map.\n\nThen produce output: iterate over keys sorted, append key and count if >1.\n\nLet's output each step.\n\nLet's craft lines:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化空堆疊並將一個空計數表推入堆疊 // 用於儲存各層括號內的原子計數\n\n→ Step 2: 逐字元遍歷公式字串 // 以字元為單位進行解析\n\n→ Decision: 如果字元為 '('? // 判斷是否進入新層括號\n\n  Yes → Step 3: 將新空計數表推入堆疊 // 新層開始\n\n  No  → Decision: 如果字元為 ')'?\n\n    Yes → Step 4: 讀取緊接在 ')' 後面的數字作為乘數 // 獲取括號組的倍數\n\n     → Step 5: 從堆疊頂端彈出內層計數表 // 取出被括號包住的計數\n\n     → Step 6: 將該計數表內所有原子數量乘以乘數 // 調整計數\n\n     → Step 7: 將乘後的計數合併回堆疊頂層計數表 // 合併至上一層\n\n     → Step 8: 重新指向堆疊頂層計數表 // 繼續解析\n\n     → Step 9: 跳過數字字元的索引 // 避免再次讀取\n\n     → Step 10: 轉到下一字元 // 繼續迴圈\n\n     No → Decision: 是否為字母（即原子符號）?\n\n      Yes → Step 11: 讀取完整原子名稱（大寫字母 + 零個或多個小寫字母） // 確定元素\n\n       → Step 12: 讀取緊接在原子名稱後的數字作為個數 // 預設為1\n\n       → Step 13: 在堆疊頂層計數表中累加該原子個數 // 更新計數\n\n       → Step 14: 重新指向堆疊頂層計數表 // 繼續解析\n\n       → Step 15: 轉到下一字元 // 繼續迴圈\n\n      No → Step 16: 若字元為數字（此情況已在前一步讀取），則跳過 // 防止重複處理\n\n→ Step 17: 迴圈結束後，堆疊頂端即為整個公式的原子計數表 // 完成解析\n\n→ Step 18: 取得計數表的所有鍵並排序 // 為輸出做準備\n\n→ Step 19: 初始化空結果字串 // 用於拼接輸出\n\n→ Step 20: 逐個排序後的原子鍵，若其個數 >1 則追加原子名稱與個數；否則只追加原子名稱 // 構造輸出格式\n\n→ Step 21: 將拼接好的結果字串存入最終輸出變數 // 完成輸出\n\n→ End // 程式執行結束\n\nMake sure each line follows format: \"→ Step X: ... // ...\". Also use Decision: lines with indentation? The format examples show indentation but we can use plain lines. Provide indentation maybe 4 spaces. We'll produce each line as separate.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空堆疊並將一個空計數表推入堆疊 // 用於儲存各層括號內的原子計數  \n→ Step 2: 逐字元遍歷公式字串 // 以字元為單位進行解析  \n→ Decision: 如果字元為 '('? // 判斷是否進入新層括號  \n  Yes → Step 3: 將新空計數表推入堆疊 // 新層開始  \n  No → Decision: 如果字元為 ')'？  \n    Yes → Step 4: 讀取緊接在 ')' 後面的數字作為乘數 // 獲取括號組的倍數  \n     → Step 5: 從堆疊頂端彈出內層計數表 // 取出被括號包住的計數  \n     → Step 6: 將該計數表內所有原子數量乘以乘數 // 調整計數  \n     → Step 7: 將乘後的計數合併回堆疊頂層計數表 // 合併至上一層  \n     → Step 8: 重新指向堆疊頂層計數表 // 繼續解析  \n     → Step 9: 跳過數字字元的索引 // 避免再次讀取  \n     → Step 10: 轉到下一字元 // 繼續迴圈  \n     No → Decision: 是否為字母（即原子符號）?  \n      Yes → Step 11: 讀取完整原子名稱（大寫字母 + 零個或多個小寫字母） // 確定元素  \n       → Step 12: 讀取緊接在原子名稱後的數字作為個數 // 預設為1  \n       → Step 13: 在堆疊頂層計數表中累加該原子個數 // 更新計數  \n       → Step 14: 重新指向堆疊頂層計數表 // 繼續解析  \n       → Step 15: 轉到下一字元 // 繼續迴圈  \n      No → Step 16: 若字元為數字（此情況已在前一步讀取），則跳過 // 防止重複處理  \n→ Step 17: 迴圈結束後，堆疊頂端即為整個公式的原子計數表 // 完成解析  \n→ Step 18: 取得計數表的所有鍵並排序 // 為輸出做準備  \n→ Step 19: 初始化空結果字串 // 用於拼接輸出  \n→ Step 20: 逐個排序後的原子鍵，若其個數 >1 則追加原子名稱與個數；否則只追加原子名稱 // 構造輸出格式  \n→ Step 21: 將拼接好的結果字串存入最終輸出變數 // 完成輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def countOfAtoms(self, formula: str) -> str:\n        n = len(formula)\n        self.i = 0\n\n        def parse() -> Counter:\n            cnt = Counter()\n            while self.i < n and formula[self.i] != ')':\n                if formula[self.i] == '(':\n                    self.i += 1\n                    inner = parse()\n                    self.i += 1  # skip ')'\n                    mult = 0\n                    while self.i < n and formula[self.i].isdigit():\n                        mult = mult * 10 + int(formula[self.i])\n                        self.i += 1\n                    if mult == 0:\n                        mult = 1\n                    for k, v in inner.items():\n                        cnt[k] += v * mult\n                else:\n                    start = self.i\n                    self.i += 1\n                    while self.i < n and formula[self.i].islower():\n                        self.i += 1\n                    name = formula[start:self.i]\n                    num = 0\n                    while self.i < n and formula[self.i].isdigit():\n                        num = num * 10 + int(formula[self.i])\n                        self.i += 1\n                    if num == 0:\n                        num = 1\n                    cnt[name] += num\n            return cnt\n\n        counts = parse()\n        parts = []\n        for atom in sorted(counts.keys()):\n            parts.append(atom + (str(counts[atom]) if counts[atom] > 1 else \"\"))\n        return \"\".join(parts)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expected format: formula = \"H2O\"\n    try:\n        _, expr = data.split('=', 1)\n    except ValueError:\n        expr = data\n    formula = ast.literal_eval(expr.strip())\n    result = Solution().countOfAtoms(formula)\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "formula = \"H2O\"",
          "expected_output": "\"H2O\"",
          "success": true,
          "output": "\"H2O\""
        },
        {
          "example_index": 1,
          "input": "formula = \"Mg(OH)2\"",
          "expected_output": "\"H2MgO2\"",
          "success": true,
          "output": "\"H2MgO2\""
        },
        {
          "example_index": 2,
          "input": "formula = \"K4(ON(SO3)2)2\"",
          "expected_output": "\"K4N2O14S4\"",
          "success": true,
          "output": "\"K4N2O14S4\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode575.json",
    "problem_index_in_file": 0,
    "title": "Distribute Candies",
    "description_snippet": "Alice has n candies, where the i^th candy is of type candyType[i]. Alice noticed that she started to...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps, with explanation, following format. Problem: maximum different types when picking n/2 candies. Approach: count unique types, result is min(unique, n/2). So steps: Start, input array, compute unique count via set, compute half, compute answer, output.\n\nNeed to be line by line. Use arrows.\n\nLet's craft.\n\nStart\n→ Step 1: Initialize uniqueSet ← empty set // 用於存儲不同糖果類型\n→ Step 2: For each type in candyType: add type to uniqueSet // 將所有類型加入集合，重複自動去除\n→ Step 3: uniqueCount ← size of uniqueSet // 得到不同類型的總數\n→ Step 4: half ← n / 2 // 根據醫生建議的可食用糖果數量\n→ Step 5: answer ← minimum of uniqueCount and half // 取兩者中較小值作為最大可獲得不同類型數\n→ Step 6: Output answer // 返回結果\nEnd\n\nAdd decision? Not necessary. But include Start, End.\n\nAlso might include Decision: If uniqueCount <= half? but no need.\n\nBut follow format: each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrows: \"→ Step 1: ...\"\n\nSo produce lines.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize uniqueSet ← empty set // 用於存儲不同糖果類型  \n→ Step 2: For each type in candyType: add type to uniqueSet // 將所有類型加入集合，重複自動去除  \n→ Step 3: uniqueCount ← size of uniqueSet // 得到不同類型的總數  \n→ Step 4: half ← n / 2 // 根據醫生建議的可食用糖果數量  \n→ Step 5: answer ← minimum of uniqueCount and half // 取兩者中較小值作為最大可獲得不同類型數  \n→ Step 6: Output answer // 返回結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取格式為\n        candyType = [1,2,3,4]\n    的字串，解析出糖果類型列表，計算並輸出\n    Alice 能吃到的最多不同類型糖果數量。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找到列表的起始位置，並取出列表字串\n    start = data.find('[')\n    if start == -1:\n        print(0)\n        return\n    list_str = data[start:]\n\n    # 安全解析列表\n    try:\n        candy_type = ast.literal_eval(list_str)\n    except Exception:\n        print(0)\n        return\n\n    # 計算可吃的糖果數量為 n/2\n    half = len(candy_type) // 2\n    # 計算不同糖果類型的數量\n    unique = len(set(candy_type))\n    # 最終答案是兩者的最小值\n    print(min(unique, half))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candyType = [1,1,2,2,3,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "candyType = [1,1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "candyType = [6,6,6,6]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode532.json",
    "problem_index_in_file": 0,
    "title": "K-diff Pairs in an Array",
    "description_snippet": "Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the ar...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. We need to produce algorithm for counting unique k-diff pairs in array.\n\nUnique k-diff pairs: pairs of values, not indices. For each unique pair of numbers such that difference absolute equals k. If k=0, pairs of same numbers with duplicates count as one? Actually typical LeetCode: count pairs of distinct indices but unique pairs by value. For k=0, count numbers that appear at least twice. For k>0, count pairs of numbers where difference = k.\n\nWe produce steps: Start, read array, read k, create frequency map. Then if k < 0: 0. If k==0: count number of keys with freq>=2. Else: for each key, if key+k exists, count++. End. Output count.\n\nWe need to write in virtual code format with arrows.\n\nWe also need to incorporate decision structure.\n\nLet's produce steps:\n\nStart\n→ Step 1: 建立哈希表 freq 以計算每個數字出現次數 // count frequencies\n→ Step 2: If k < 0? // invalid diff\n   Yes → Step 3: Set count = 0 // no pairs\n   No  → Decision: If k == 0?\n        Yes → Step 4: For each value in freq:\n                If freq[value] >= 2: count++ // 0-diff pairs\n                No  → Step 5: For each value in freq:\n                        If freq contains value + k: count++ // k>0 pairs\nEnd\n\nNeed to include return count.\n\nAlso we need to use appropriate arrows and comments.\n\nWe also need to handle step indent for nested decisions.\n\nLet's write.\n\nAlso include a step for returning count.\n\nMake sure to include 'Return count // 回傳結果'.\n\nNow produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空哈希表 freq，並逐個遍歷 nums，將每個數字的出現次數累計至 freq // 建立頻率表  \n→ Step 2: Decision: k 是否小於 0? // 差值不能為負  \n  Yes → Step 3: 設定 count = 0 // 沒有合法對  \n  No → Decision: k 是否等於 0? // 需要特殊處理  \n    Yes → Step 4: For each key in freq:  \n     Decision: freq[key] 是否 ≥ 2? // 至少出現兩次才能形成 0 差值對  \n       Yes → Step 5: count++ // 計入一對  \n       No → Step 6: 跳過  \n    No → Step 7: For each key in freq:  \n     Decision: freq 是否包含 key + k? // 差值為 k 的另一個數字是否存在  \n       Yes → Step 8: count++ // 計入一對  \n       No → Step 9: 跳過  \n→ Step 10: Return count // 回傳唯一 k-diff 對的數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef findPairs(nums, k):\n    \"\"\"\n    Count unique k-diff pairs in the list `nums`.\n    A pair (a, b) is counted only once, regardless of the order of indices.\n    \"\"\"\n    # 差值為負數時不可能有合法對\n    if k < 0:\n        return 0\n\n    # 用 Counter 取得每個數字出現的次數\n    freq = Counter(nums)\n\n    # 差值為 0 時，只能是相同數字且出現至少兩次\n    if k == 0:\n        return sum(1 for count in freq.values() if count > 1)\n\n    # 差值為正數時，檢查每個數字是否存在其 + k 的對應數\n    return sum(1 for num in freq if num + k in freq)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 找到最後一個 ']'，以此分割陣列和 k 的部分\n    idx = data.rfind(']')\n    if idx == -1:\n        raise ValueError(\"Input format error: missing closing bracket for the array.\")\n\n    # 取得陣列字串並轉成 Python list\n    array_str = data[:idx + 1]\n    nums = ast.literal_eval(array_str)\n\n    # 取得 k 的字串，並轉成整數\n    k_part = data[idx + 1:].lstrip(',').strip()\n    k = int(k_part)\n\n    # 計算並輸出結果\n    result = findPairs(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,1,4,1,5], 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4,5], 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "[1,3,1,5,4], 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode611.json",
    "problem_index_in_file": 0,
    "title": "Valid Triangle Number",
    "description_snippet": "Given an integer array nums, return the number of triplets chosen from the array that can make trian...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for the algorithm: count number of triplets that can form a triangle. Standard approach: sort array, then for each i from 0 to n-3, for j from i+1 to n-2, find maximal k such that nums[i]+nums[j]>nums[k], using two-pointer or binary search. Counting.\n\nWe'll output steps with Start, End, Decision etc. Ensure each line includes \"→ Step X:\" or \"→ Decision:\" etc. Provide explanation after //.\n\nWe should produce step-by-step, not actual code. Use typical algorithm steps. Let's create a clear algorithm.\n\nSteps:\n\nStart\n→ Step 1: Sort nums ascending // 排序陣列以便使用兩指標法\n→ Step 2: Initialize count = 0 // 计数器\n→ Step 3: For each i from 0 to len-3 // 外层循环选择第一个边\n    → Step 4: Set k = i+2 // 初始化第三个边指针\n    → Step 5: For each j from i+1 to len-2 // 第二个边\n        → Decision: While k < len and nums[i]+nums[j] > nums[k] // 判断能否形成三角形\n            → Yes → Increment k // 向右移动k\n        → Step 6: count += k - j - 1 // 统计满足的三角形数量\n→ Step 7: Return count // 输出结果\nEnd\n\nBut we need to use arrow notation. Each line with '→' or 'Start', 'End', etc.\n\nNeed to produce line by line, each line separate.\n\nWe should include decision with Yes → and No →. For While loop we can represent as Decision.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 對陣列進行升序排序\n→ Step 2: Set count = 0 // 初始化三角形計數器\n→ Step 3: For i = 0 to length(nums)-3 // 選擇第一條邊\n    → Step 4: Set k = i + 2 // 初始化第三條邊指標\n    → Step 5: For j = i + 1 to length(nums)-2 // 選擇第二條邊\n        → Decision: While k < length(nums) AND nums[i] + nums[j] > nums[k] // 判斷是否可以形成三角形\n            Yes → Increment k // 向右移動第三條邊指標\n            No  → (exit while) // 條件不滿足，結束循環\n        → Step 6: count = count + (k - j - 1) // 計算符合條件的三角形數量\n→ Step 7: Return count // 回傳總計數\nEnd // 程式執行結束\n\nBut need to keep each line separate and each line with explanation after //. Indentation: can show nested lines with spaces.\n\nBut format requirement: each line must contain \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows etc.\n\nWe need to include '→' for each step. For loops and decisions we can use indentation or just include them in the lines.\n\nWe should produce line by line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 對陣列進行升序排序，以便使用兩指標法  \n→ Step 2: Set count = 0 // 初始化三角形計數器  \n→ Step 3: For i = 0 to length(nums)-3 // 選擇第一條邊索引  \n    → Step 4: Set k = i + 2 // 初始化第三條邊指標，至少為 i+2  \n    → Step 5: For j = i + 1 to length(nums)-2 // 選擇第二條邊索引  \n        → Decision: While k < length(nums) AND nums[i] + nums[j] > nums[k] // 判斷能否形成三角形  \n            Yes → Increment k // 向右移動第三條邊指標，尋找最大的 k  \n            No  → (exit while) // 條件不滿足，結束 while 循環  \n        → Step 6: count = count + (k - j - 1) // 目前 j 所能形成的三角形數量  \n→ Step 7: Return count // 回傳所有符合條件的三角形組合數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def triangleNumber(self, nums):\n        nums.sort()\n        count = 0\n        n = len(nums)\n        # 以最大的邊為 k，從後往前搜尋\n        for k in range(n - 1, 1, -1):\n            i, j = 0, k - 1\n            while i < j:\n                # 若 nums[i] + nums[j] > nums[k]，則 i ~ j-1 的任意 i 都可與 nums[j] 和 nums[k] 构成三角形\n                if nums[i] + nums[j] > nums[k]:\n                    count += j - i\n                    j -= 1\n                else:\n                    i += 1\n        return count\n\ndef parse_input(input_str):\n    \"\"\"從輸入字串中提取整數列表。\"\"\"\n    # 搜尋第一個中括號內的數字\n    match = re.search(r'\\[([^\\]]*)\\]', input_str)\n    if not match:\n        return []\n    # 把逗號分隔的字串轉成整數\n    nums_str = match.group(1).split(',')\n    nums = [int(num.strip()) for num in nums_str if num.strip()]\n    return nums\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    result = Solution().triangleNumber(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [4,2,3,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode3.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring Without Repeating Characters",
    "description_snippet": "Given a string s, find the length of the longest substring without duplicate characters....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step for the problem: longest substring without repeating characters.\n\nWe must output line by line, each line: virtual code step + space + // explanation.\n\nUse virtual code arrow symbols →, Decision:, Start, End. We should not output actual code. Just pseudo-code.\n\nNeed to include initialization, sliding window approach, loops, updates. Provide explanation for each line.\n\nOk. Let's produce.\n\nNeed to start: Start // 程式開始執行\n\nThen → Step 1: 初始化字典/哈希表存放字符索引, 設定 left = 0, maxLen = 0 // 以字典追蹤最近一次出現位置\n\n→ For loop i from 0 to len(s)-1 // 遍歷字串每個字符\n\nInside loop: → If s[i] in dict and dict[s[i]] >= left // 如果字符已在窗口且位置在左邊界之後\n\n→ Decision: 若是，更新 left = dict[s[i]] + 1 // 將左邊界移至該重複字符右側\n\n→ End Decision\n\n→ Update dict[s[i]] = i // 記錄字符最新索引\n\n→ Update maxLen = max(maxLen, i - left + 1) // 計算當前窗口長度並更新最大值\n\nAfter loop: End // 程式結束\n\nWe should use arrow for each step. For decisions, use \"Decision:\" with Yes/No lines. We can embed decisions inside loop.\n\nLet's produce proper structure.\n\nEnsure each line ends with // explanation.\n\nUse indentation? Not necessary.\n\nLet's produce lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化哈希表 charIndex, 左指針 left = 0, 最長長度 maxLen = 0 // 用來追蹤每個字符最近一次出現的位置、窗口左邊界以及目前已知的最長長度  \n→ For i = 0 to len(s)-1 // 遍歷字串的每個字符  \n    → Decision: 是否 s[i] 已出現在 charIndex 且 charIndex[s[i]] >= left? // 檢查此字符是否在當前滑動窗口內且重複  \n        Yes → Step 2: left = charIndex[s[i]] + 1 // 把左指針移到該重複字符右側，排除重複  \n        No  → // 沒有重複，保持左指針不變  \n    → Step 3: charIndex[s[i]] = i // 更新該字符的最新索引  \n    → Step 4: maxLen = max(maxLen, i - left + 1) // 計算當前窗口長度並更新最大值  \nEnd // 程式執行結束，maxLen 為答案",
      "generated_code": "import sys\nimport re\n\ndef length_of_longest_substring(s: str) -> int:\n    \"\"\"\n    使用滑動窗口+哈希表，記錄每個字符最近一次出現的位置。\n    left 代表窗口左邊界，max_len 存儲目前為止的最大長度。\n    \"\"\"\n    char_index = {}\n    left = 0\n    max_len = 0\n\n    for right, ch in enumerate(s):\n        # 如果 ch 已在窗口內，將左邊界移動到該字符右側\n        if ch in char_index and char_index[ch] >= left:\n            left = char_index[ch] + 1\n        # 更新字符的最新位置\n        char_index[ch] = right\n        # 計算當前窗口長度並更新最大值\n        current_len = right - left + 1\n        if current_len > max_len:\n            max_len = current_len\n\n    return max_len\n\ndef parse_input(input_str: str) -> str:\n    \"\"\"\n    從輸入字串中提取實際的字符串值。\n    支援兩種格式：\n    1. s = \"abcabcbb\"\n    2. \"abcabcbb\"\n    \"\"\"\n    # 先嘗試找到第一個雙引號和最後一個雙引號\n    match = re.search(r'\"(.*?)\"', input_str)\n    if match:\n        return match.group(1)\n    # 若沒有引號，直接去除首尾空白\n    return input_str.strip()\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit(0)\n    s = parse_input(raw_input)\n    result = length_of_longest_substring(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcabcbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"bbbbb\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \"pwwkew\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode715.json",
    "problem_index_in_file": 0,
    "title": "Range Module",
    "description_snippet": "A Range Module is a module that tracks ranges of numbers. Design a data structure to track the range...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing RangeModule. Provide each line with arrow or decision. Must use the required format. We need to outline data structure design: use sorted list of intervals, maybe TreeMap or list. Provide methods. Should be step-by-step pseudocode. Each line should include comment. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 RangeModule // 建構子，設定內部資料結構為空的區間表  \n→ Step 2: 建立空陣列 intervals // intervals 存儲已追蹤的半開區間，維持遞增順序且不重疊  \n→ Step 3: 定義 addRange(left, right) // 加入區間的主方法  \n    → Step 3.1: 若 left >= right → Return // 無效區間直接結束  \n    → Step 3.2: 找到第一個 intervals[i] 的 right > left // 搜尋可能重疊的起始位置  \n    → Step 3.3: 將 i 前面的所有區間保留在 newIntervals  \n    → Step 3.4: 設定 newLeft = left, newRight = right  \n    → Step 3.5: 從 i 開始，合併所有 intervals[j] 與 [newLeft, newRight] 的重疊區間  \n        → Decision: intervals[j] 的 left <= newRight? // 有重疊  \n            Yes → newLeft = min(newLeft, intervals[j].left)  \n            Yes → newRight = max(newRight, intervals[j].right)  \n            Yes → i = j + 1  \n        → No → Break // 無重疊，停止合併  \n    → Step 3.6: 將合併後的區間 [newLeft, newRight] 加入 newIntervals  \n    → Step 3.7: 將剩餘的 intervals[i..] 依序加入 newIntervals  \n    → Step 3.8: 用 newIntervals 替換 intervals // 更新內部區間表  \n→ Step 4: 定義 queryRange(left, right) // 查詢區間是否全被追蹤  \n    → Step 4.1: 若 left >= right → Return true // 空區間永遠被追蹤  \n    → Step 4.2: 找到 intervals[i] 使 intervals[i].right > left  \n    → Step 4.3: Decision: intervals[i].left <= left AND intervals[i].right >= right?  \n        Yes → Return true // 這個區間覆蓋整個查詢區間  \n        No  → Return false // 未被完整覆蓋  \n→ Step 5: 定義 removeRange(left, right) // 移除區間  \n    → Step 5.1: 若 left >= right → Return // 無效區間直接結束  \n    → Step 5.2: 找到第一個 intervals[i] 的 right > left // 搜尋可能重疊的起始位置  \n    → Step 5.3: 建立 newIntervals  \n    → Step 5.4: 將 i 前面的所有區間加入 newIntervals // 未受影響  \n    → Step 5.5: 從 i 開始處理重疊區間  \n        → Decision: intervals[j].left < right? // 仍然重疊  \n            Yes → 若 intervals[j].left < left → 新增區間 [intervals[j].left, left) 至 newIntervals  \n            Yes → 若 intervals[j].right > right → 新增區間 [right, intervals[j].right) 至 newIntervals  \n            Yes → i = j + 1 // 這個區間已被部分或完全移除  \n        → No → Break // 無重疊，停止處理  \n    → Step 5.6: 將剩餘的 intervals[i..] 依序加入 newIntervals  \n    → Step 5.7: 用 newIntervals 替換 intervals // 更新內部區間表  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport bisect\n\n# ==========================\n# RangeModule implementation\n# ==========================\nclass RangeModule:\n    \"\"\"\n    Tracks half-open integer intervals [left, right).\n    Internally keeps a sorted list of non-overlapping intervals.\n    \"\"\"\n    def __init__(self):\n        # List of [l, r) intervals, sorted by l and non-overlapping\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        \"\"\"Add a new interval, merging with overlapping ones.\"\"\"\n        if left >= right:\n            return\n        new_ranges = []\n        i = 0\n        n = len(self.ranges)\n        # Add all intervals that end before the new interval starts\n        while i < n and self.ranges[i][1] < left:\n            new_ranges.append(self.ranges[i])\n            i += 1\n        # Merge overlapping intervals\n        new_left, new_right = left, right\n        while i < n and self.ranges[i][0] <= new_right:\n            new_left = min(new_left, self.ranges[i][0])\n            new_right = max(new_right, self.ranges[i][1])\n            i += 1\n        new_ranges.append([new_left, new_right])\n        # Add the rest of the intervals\n        while i < n:\n            new_ranges.append(self.ranges[i])\n            i += 1\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        \"\"\"Return True if [left, right) is fully covered by existing intervals.\"\"\"\n        if left >= right:\n            return True\n        # Find the interval that could cover left\n        idx = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if idx == 0:\n            return False\n        interval = self.ranges[idx - 1]\n        return interval[0] <= left and right <= interval[1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        \"\"\"Remove the interval [left, right) from the tracked ranges.\"\"\"\n        if left >= right:\n            return\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                # No overlap\n                new_ranges.append([l, r])\n            else:\n                # Overlap exists, trim or split\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\n# ==================\n# Main: parse input\n# ==================\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    vars_dict = {}\n    outputs = []\n\n    for line in data:\n        line = line.strip()\n        if not line:\n            continue\n        # Remove trailing semicolon\n        if line.endswith(';'):\n            line = line[:-1].strip()\n\n        # Creation line: e.g., \"RangeModule rangeModule = new RangeModule()\"\n        if '=' in line and 'new' in line:\n            left, right = line.split('=')\n            var_name = left.strip().split()[-1]  # last token before '='\n            # Instantiate RangeModule (ignore any arguments)\n            vars_dict[var_name] = RangeModule()\n            outputs.append(None)  # constructor returns null\n            continue\n\n        # Method call line: e.g., \"rangeModule.addRange(10, 20)\"\n        if '.' in line:\n            var_part, method_part = line.split('.', 1)\n            var_name = var_part.strip()\n            method_name, rest = method_part.split('(', 1)\n            method_name = method_name.strip()\n            args_str = rest.rstrip(')')\n            # Parse integer arguments\n            args = [int(x.strip()) for x in args_str.split(',') if x.strip()]\n            # Invoke the method\n            method = getattr(vars_dict[var_name], method_name)\n            if method_name == 'queryRange':\n                result = method(*args)\n                outputs.append(result)\n            else:\n                method(*args)\n                outputs.append(None)  # void methods return null\n            continue\n\n    # Print result list in Python syntax\n    print(outputs)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[None]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[None]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode641.json",
    "problem_index_in_file": 0,
    "title": "Design Circular Deque",
    "description_snippet": "Design your implementation of the circular double-ended queue (deque).\n\nImplement the MyCircularDequ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Use arrows, Decision, etc. Provide steps for implementing MyCircularDeque. Should be pseudo-code, not actual code. Need to cover initialization, operations, and helper functions.\n\nLet's create start, then define data structure: array of size k, front index, rear index, count.\n\nThen methods.\n\nUse decision to check full or empty.\n\nLet's produce.\n\nWe need to use 'Step' maybe? In example they use Step 1 etc. We can use Step names.\n\nEnsure each line: '虛擬碼步驟 // 解釋'.\n\nInclude arrow for decisions.\n\nLet's proceed.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 `capacity = k`，`data = new 整數陣列[capacity]`，`front = 0`，`rear = capacity - 1`，`size = 0` // 初始化雙端佇列的存儲空間與指標  \n→ Step 2: 定義函式 `insertFront(value)` // 將值插入前端  \n  Decision: `size == capacity`? // 檢查是否已滿  \n   Yes → Return `false` // 若已滿，無法插入  \n   No →  \n    → `front = (front - 1 + capacity) % capacity` // 往前移動前端指標  \n    → `data[front] = value` // 存入新值  \n    → `size = size + 1`  \n    → Return `true`  \n→ Step 3: 定義函式 `insertLast(value)` // 將值插入後端  \n  Decision: `size == capacity`? // 檢查是否已滿  \n   Yes → Return `false`  \n   No →  \n    → `rear = (rear + 1) % capacity` // 往後移動後端指標  \n    → `data[rear] = value`  \n    → `size = size + 1`  \n    → Return `true`  \n→ Step 4: 定義函式 `deleteFront()` // 刪除前端元素  \n  Decision: `size == 0`? // 檢查是否為空  \n   Yes → Return `false`  \n   No →  \n    → `front = (front + 1) % capacity` // 往後移動前端指標  \n    → `size = size - 1`  \n    → Return `true`  \n→ Step 5: 定義函式 `deleteLast()` // 刪除後端元素  \n  Decision: `size == 0`?  \n   Yes → Return `false`  \n   No →  \n    → `rear = (rear - 1 + capacity) % capacity` // 往前移動後端指標  \n    → `size = size - 1`  \n    → Return `true`  \n→ Step 6: 定義函式 `getFront()` // 取得前端值  \n  Decision: `size == 0`?  \n   Yes → Return `-1` // 空時返回 -1  \n   No → Return `data[front]`  \n→ Step 7: 定義函式 `getRear()` // 取得後端值  \n  Decision: `size == 0`?  \n   Yes → Return `-1`  \n   No → Return `data[rear]`  \n→ Step 8: 定義函式 `isEmpty()` // 判斷是否為空  \n  Return `size == 0`  \n→ Step 9: 定義函式 `isFull()` // 判斷是否已滿  \n  Return `size == capacity`  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k          # 存放元素的固定長度陣列\n        self.head = 0               # 指向前端的索引\n        self.count = 0              # 目前佇列中元素的個數\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])\n    args = json.loads(data[1]) if len(data) > 1 else []\n\n    dq = None\n    results = []\n\n    for op, a in zip(ops, args):\n        if op == \"MyCircularDeque\":\n            dq = MyCircularDeque(a[0])\n            results.append(None)  # constructor returns null\n        elif op == \"insertFront\":\n            results.append(dq.insertFront(a[0]))\n        elif op == \"insertLast\":\n            results.append(dq.insertLast(a[0]))\n        elif op == \"deleteFront\":\n            results.append(dq.deleteFront())\n        elif op == \"deleteLast\":\n            results.append(dq.deleteLast())\n        elif op == \"getFront\":\n            results.append(dq.getFront())\n        elif op == \"getRear\":\n            results.append(dq.getRear())\n        elif op == \"isEmpty\":\n            results.append(dq.isEmpty())\n        elif op == \"isFull\":\n            results.append(dq.isFull())\n        else:\n            results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpg1g773mu.py\", line 94, in <module>\n    main()\n  File \"/tmp/tmpg1g773mu.py\", line 62, in main\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode410.json",
    "problem_index_in_file": 0,
    "title": "Split Array Largest Sum",
    "description_snippet": "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the la...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for solving problem: split array into k contiguous subarrays minimizing largest sum. Classic problem: split array largest sum minimal. Approach: binary search over answer, check feasibility with greedy.\n\nWe'll produce steps: Start, input array nums, integer k, compute left bound (max element) and right bound (sum). While left < right: mid, check using helper to count needed subarrays <=k. If count <=k: right=mid else left=mid+1. End, output left.\n\nWe'll produce virtual steps with explanations. We'll need decision points.\n\nLet's produce lines. We'll include \"Step 1\" etc.\n\nUse structure:\n\nStart\n→ Step 1: 計算 left = max(nums) // 左邊界\n→ Step 2: 計算 right = sum(nums) // 右邊界\n→ Decision: 是否 left < right? // 確認是否需要搜索\n    Yes → Step 3: 計算 mid = (left+right)//2 // 取中值\n        → Step 4: 呼叫 Check(mid) // 判斷是否可用此最大和切分\n            → Decision: Check(mid) 是否 <= k? // 判斷需要的子陣列數\n                Yes → Step 5: right = mid // 可行，縮小右邊界\n                No  → Step 6: left = mid + 1 // 不可行，增大左邊界\n        → Decision: 是否 left < right? // 迴圈條件\n            Yes → 重複 Step 3\n            No  → Step 7: Return left // 結果\n    No → Step 7: Return left // 若左已等於右，直接返回\n\nWe also need the Check function pseudo steps. Add it as separate block:\n\nCheck(value)\n→ Step 1: count = 1, currentSum = 0\n→ For each num in nums:\n    → Decision: currentSum + num <= value?\n        Yes → currentSum += num // 加入當前子陣列\n        No  → count += 1 // 開啟新子陣列\n            → currentSum = num // 開始新子陣列\n→ Return count // 需要的子陣列數\n\nWe need to include Start and End for Check as well.\n\nLet's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 計算 left = max(nums) // 左邊界，至少要能放最長的元素\n→ Step 2: 計算 right = sum(nums) // 右邊界，最壞情況全部合併\n→ Decision: left < right? // 是否需要進行二分搜尋\n    Yes → Step 3: 計算 mid = (left + right) // 2 // 取中值作為候選最大和\n        → Step 4: 呼叫 Check(mid) // 判斷此最大和下的最少子陣列數\n            → Decision: Check(mid) <= k? // 是否可以用 k 個或更少子陣列\n                Yes → Step 5: right = mid // 可行，縮小右邊界\n                No  → Step 6: left = mid + 1 // 不可行，增大左邊界\n        → Decision: left < right? // 迴圈結束條件\n            Yes → 回到 Step 3 // 繼續搜尋\n            No  → Step 7: Return left // 左右相等，為最小最大和\n    No → Step 7: Return left // 已經無需搜尋，直接返回\nEnd // 程式執行結束\n\n// Check 函式：計算給定最大和 value 時需要的最少子陣列數\nCheck(value)\n→ Start // Check 函式開始\n    → Step 1: count = 1 // 初始一個子陣列\n    → Step 2: currentSum = 0 // 當前子陣列累加和\n    → For each num in nums:\n        → Decision: currentSum + num <= value? // 若加進去仍在限制內\n            Yes → currentSum += num // 加入現有子陣列\n            No  → count += 1 // 需要新子陣列\n                → currentSum = num // 以本數字開始新子陣列\n    → Return count // 需要的子陣列數\n→ End // Check 函式結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def splitArray(self, nums, m):\n        # Helper function: check if we can split into <= m subarrays\n        def can_split(mid):\n            count, curr_sum = 1, 0\n            for num in nums:\n                if curr_sum + num > mid:\n                    count += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return count <= m\n\n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if can_split(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\nif __name__ == \"__main__\":\n    # Read entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Normalize whitespace\n    data = re.sub(r'\\s+', ' ', data)\n\n    # Replace 'nums =' and 'k =' with python assignment syntax\n    data = data.replace('nums =', 'nums=').replace('k =', 'k=')\n\n    # Evaluate to get a tuple (nums, k)\n    try:\n        nums, k = eval(data, {}, {})\n    except Exception:\n        # Fallback: parse numbers manually if eval fails\n        nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', data)\n        k_match = re.search(r'k\\s*=\\s*([0-9]+)', data)\n        if nums_match and k_match:\n            nums = list(map(int, nums_match.group(1).split(',')))\n            k = int(k_match.group(1))\n        else:\n            raise ValueError(\"Input format not recognized\")\n\n    result = Solution().splitArray(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [7,2,5,10,8], k = 2",
          "expected_output": "18",
          "success": true,
          "output": "18"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,5], k = 2",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode274.json",
    "problem_index_in_file": 0,
    "title": "H-Index",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code in steps: Start, arrow, decision etc. Not actual code. Provide each line: \"虛擬碼步驟 // 解釋\". Use arrow syntax. We need algorithm for h-index: we can sort citations descending, find max h where citations[h-1] >= h. Or counting sort: frequency array size n+1. But any algorithm fine. Provide pseudo steps line by line. Probably: Start, Input citations array, Get length n, Create count array of size n+1 initialize zeros, For each citation c: if c>=n then count[n]++ else count[c]++. Then iterate from n down to 0 accumulate sum and find h where sum>=i. End.\n\nLet's produce steps. Use arrows: \"→ Step 1: ...\". Each line must have 虛擬碼 + space + // explanation. Use arrow or Decision lines. Need Start and End.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 取得 citations 陣列 // 從使用者取得所有論文的引用次數\n→ Step 2: 計算 n = 論文數量 // 以便確定頻率陣列大小\n→ Step 3: 建立 count 陣列長度 n+1 並初始化為 0 // 用於統計各引用次數的頻率\n→ Decision: 迭代每個 citation c in citations? // 處理每個引用數\n    Yes → Step 4: 若 c >= n 則 count[n]++ 否則 count[c]++ // 大於等於 n 的視為 n\n    No  → // 迭代結束\n→ Step 5: 設定 cumulative = 0 // 累積已計算的論文數\n→ Step 6: 從 i = n 下降到 0 迴圈 // 逐步檢查可行的 h 值\n    → Step 7: cumulative += count[i] // 加上當前引用次數的論文數\n    → Decision: 若 cumulative >= i? // 判斷是否滿足 h 指標\n        Yes → Step 8: 回傳 i 為 h-index // 找到最大的符合條件的 h\n        No  → // 進入下一次迴圈\n→ End // 程式結束\n\nBut we need arrow format: \"Decision: ...\". And need to include \"Yes →\" etc. Each line separate. Ensure we include arrow after \"Decision:\" line? Format: \"Decision: 如果數字大於 0? // ...\". And indentation for Yes and No lines. They want the arrow \"Yes →\" \"No →\". So we need to indent accordingly.\n\nLet's produce final. Use indentation like example. Also include \"Start\" and \"End\".\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 citations 陣列 // 從使用者取得所有論文的引用次數  \n→ Step 2: 計算 n = 論文數量 // 以便確定頻率陣列大小  \n→ Step 3: 建立 count 陣列長度 n+1 並初始化為 0 // 用於統計各引用次數的頻率  \n→ Decision: 迭代每個 citation c in citations? // 處理每個引用數  \n Yes → Step 4: 若 c ≥ n 則 count[n]++，否則 count[c]++ // 大於等於 n 的視為 n  \n No  → // 迭代結束  \n→ Step 5: 設定 cumulative = 0 // 累積已計算的論文數  \n→ Step 6: 從 i = n 下降到 0 迴圈 // 逐步檢查可行的 h 值  \n → Step 7: cumulative += count[i] // 加上當前引用次數的論文數  \n → Decision: 若 cumulative ≥ i? // 判斷是否滿足 h 指標  \n  Yes → Step 8: 回傳 i 為 h-index // 找到最大的符合條件的 h  \n  No  → // 進入下一次迴圈  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def hIndex(self, citations):\n        # 先按降序排列\n        citations.sort(reverse=True)\n        h = 0\n        # 遍歷每一篇論文，檢查是否符合 h-index 條件\n        for i, c in enumerate(citations):\n            if c >= i + 1:\n                h = i + 1\n            else:\n                break\n        return h\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取全部資料\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit(0)\n\n    # 取出括號之間的內容並解析成 list\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        citations_list = []\n    else:\n        try:\n            citations_list = ast.literal_eval(data[start:end+1])\n        except Exception:\n            citations_list = []\n\n    # 計算並輸出 h-index\n    solution = Solution()\n    print(solution.hIndex(citations_list))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [3,0,6,1,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "citations = [1,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode462.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements II",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code that solves the problem: given an integer array, minimal moves to equalize all elements by +/-1 each move. That's classic: minimal moves equal to sum of |nums[i] - median|. So algorithm: find median (sort or nth_element). Then sum abs differences.\n\nWe output step-by-step pseudocode with explanation, line by line. Format: \"Start // 程式開始執行\" etc. Use virtual code arrow style.\n\nWe need to produce lines for reading array, n, compute median, sum abs difference, output.\n\nWe must not produce real code. Just pseudocode steps.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 讀取整數 n // 取得陣列長度\n→ Step 2: 讀取整數陣列 nums[0..n-1] // 取得所有元素\n→ Decision: n 為 0? // 判斷陣列是否為空\n    Yes → Step 3: 輸出 0 // 空陣列不需要移動\n    No → Continue\n→ Step 4: 將 nums 陣列升序排序 // 為了找中位數\n→ Step 5: 若 n 為奇數? // 中位數的定義\n    Yes → Step 6: 設 median = nums[(n-1)/2] // 奇數個元素取中間\n    No  → Step 7: 設 median = (nums[n/2-1] + nums[n/2]) / 2 // 雙中位數，可取任一整數，使用左側\n→ Step 8: 設 totalMoves = 0 // 初始化移動總數\n→ Step 9: 針對每個元素 x in nums:\n    → Step 10: totalMoves += |x - median| // 加上與中位數的絕對差\n→ Step 11: 輸出 totalMoves // 最終答案\nEnd // 程式執行結束\n\nNeed each line has \"虛擬碼步驟\" and comment after space. Ensure arrow style. For Decision we indent Yes and No branches.\n\nLet's format exactly as required.\n\nAlso ensure no extra lines. Use indentation for branches with spaces maybe. The example shows indented lines for branches.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n // 取得陣列長度  \n→ Step 2: 讀取整數陣列 nums[0..n-1] // 取得所有元素  \n→ Decision: n 為 0? // 判斷陣列是否為空  \n Yes → Step 3: 輸出 0 // 空陣列不需要移動  \n No  → // 繼續執行  \n→ Step 4: 將 nums 陣列升序排序 // 為了找中位數  \n→ Decision: n 為奇數? // 中位數的定義  \n Yes → Step 5: 設 median = nums[(n-1)/2] // 奇數個元素取中間  \n No  → Step 6: 設 median = (nums[n/2-1] + nums[n/2]) / 2 // 雙中位數，可取任一整數，使用左側  \n→ Step 7: 設 totalMoves = 0 // 初始化移動總數  \n→ Step 8: 針對每個元素 x in nums:  \n → Step 9: totalMoves += |x - median| // 加上與中位數的絕對差  \n→ Step 10: 輸出 totalMoves // 最終答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_moves(nums):\n    \"\"\"Return the minimum number of moves to make all elements equal.\"\"\"\n    if not nums:\n        return 0\n    nums.sort()\n    median = nums[len(nums) // 2]          # 中位數（對於偶數長度取左側中位數即可）\n    moves = 0\n    for num in nums:\n        moves += abs(num - median)         # 每個元素到中位數的絕對差\n    return moves\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 抓取所有整數（允許負號）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    # 計算答案並輸出\n    print(min_moves(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,10,2,9]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode209.json",
    "problem_index_in_file": 0,
    "title": "Minimum Size Subarray Sum",
    "description_snippet": "Given an array of positive integers nums and a positive integer target, return the minimal length of...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for sliding window. Provide step by step: Start, input array and target, set left=0, minLen=∞, sum=0. Loop right from 0 to n-1: add nums[right] to sum. While sum >= target: update minLen, subtract nums[left], left++. End. If minLen remains INF return 0 else minLen. End. Provide each line as \"虛擬碼步驟 // 解釋\". Use arrows. Format: \"Start // 程式開始執行\" then \"→\" each step.\n\nNeed to be careful to label decision points. For example \"Decision: 如果 sum >= target?\" arrow to \"Yes\" branch etc. Provide \"End\" after final return.\n\nLet's produce.\n\nAlso mention initializations.\n\nBe mindful to maintain structure.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 nums 與 target // 取得陣列與目標值  \n→ Step 2: 設定 left = 0, minLen = 無限大, sum = 0 // 初始化滑動視窗指標與最小長度  \n→ Step 3: 從 right = 0 到 nums.length - 1 迴圈 // 遍歷陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: sum = sum + nums[right] // 將右端元素加入窗口總和  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 如果 sum >= target? // 判斷窗口是否已足夠  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: minLen = min(minLen, right - left + 1) // 更新最小長度  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → 進行下一個 right 迭代  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: sum = sum - nums[left] // 從左端移除元素以縮小窗口  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → left = left + 1 // 左端指標右移  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decision: 仍然 sum >= target? // 仍需繼續收縮窗口  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → repeat Step 5–6  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → 進行下一個 right 迭代  \n→ Step 7: Decision: 如果 minLen 仍為 無限大? // 檢查是否找到了合法子陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 8: 返回 0 // 沒有符合條件的子陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 9: 返回 minLen // 返回最小長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def minSubArrayLen(self, target, nums):\n        left = 0\n        total = 0\n        min_len = float('inf')\n\n        for right in range(len(nums)):\n            total += nums[right]\n\n            while total >= target:\n                min_len = min(min_len, right - left + 1)\n                total -= nums[left]\n                left += 1\n\n        return 0 if min_len == float('inf') else min_len\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n\n    # 解析 target 和 nums\n    pattern = r\"target\\s*=\\s*(\\d+)\\s*,\\s*nums\\s*=\\s*(\\[[^\\]]*\\])\"\n    match = re.search(pattern, data)\n    if not match:\n        # 若格式不符合，嘗試直接以空格分隔兩行\n        lines = data.splitlines()\n        target = int(lines[0].split('=')[1].strip())\n        nums = ast.literal_eval(lines[1].split('=')[1].strip())\n    else:\n        target = int(match.group(1))\n        nums = ast.literal_eval(match.group(2))\n\n    # 計算結果並輸出\n    result = Solution().minSubArrayLen(target, nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "target = 7, nums = [2,3,1,2,4,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "target = 4, nums = [1,4,4]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode633.json",
    "problem_index_in_file": 0,
    "title": "Sum of Square Numbers",
    "description_snippet": "Given a non-negative integer c, decide whether there're two integers a and b such that a^2 + b^2 = c...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. We need to implement algorithm: for given non-negative integer c, decide if there exist integers a, b such that a^2 + b^2 = c. Classic problem: represent as sum of two squares. We can simply loop over a from 0 to sqrt(c), compute b2 = c - a^2, check if b2 is perfect square. Return true if found. This is simple. Use pseudocode.\n\nWe need to output each line with \"虛擬碼步驟\" and comment. Must include Start, End, Decision: etc. Use arrow ->.\n\nAlso need to use \"→\" arrow. Example: \"→ Step 1: 輸入 c\". Then \"→ Decision: 如果 c < 0?\" etc. But c is non-negative; we can ignore negative check.\n\nNeed to include for loops.\n\nPseudo: Start\n→ Step 1: 輸入 c\n→ Step 2: 計算 maxA = floor(sqrt(c))\n→ Step 3: 初始化 found = false\n→ Loop i from 0 to maxA\n    → Step 4: 計算 b2 = c - i^2\n    → Decision: b2 是否為完全平方?\n        Yes → Step 5: 設定 found = true; break\n        No → 進行下一次迴圈\n→ Decision: found?\n    Yes → Step 6: 輸出 true\n    No  → Step 7: 輸出 false\nEnd\n\nBut we need to produce lines exactly with \"→\" arrow for each step. For loop maybe: \"→ For a in 0..maxA:\". Use \"→ Decision:\" etc.\n\nLet's produce final output accordingly. Use Chinese explanation. Ensure each line has \"虛擬碼步驟\" then space then comment. Eg: \"Start // 程式開始執行\". Good.\n\nLet's craft.\n\nAlso use \"Step\" or \"Step X\". Example: \"→ Step 1: 輸入 c\". Then \"→ Step 2: 計算 maxA = floor(sqrt(c))\". etc.\n\nFor loop: \"→ For a ← 0 to maxA:\" but use arrow. We'll follow format: \"→ For a ← 0 to maxA:\".\n\nInside loop: \"→     Step 4: 計算 b2 = c - a*a\" but indent? Not necessary but can use spaces.\n\nLet's produce each line.\n\nEnsure each line includes comment after space. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 c // 從使用者處取得非負整數  \n→ Step 2: 計算 maxA = floor(sqrt(c)) // 最大可能的 a  \n→ Step 3: 設定 found = false // 追蹤是否找到合法對  \n→ For a ← 0 to maxA: // 逐個嘗試 a  \n    → Step 4: 計算 b2 = c - a*a // 剩餘值需為平方數  \n    → Decision: b2 是否為完全平方? // 判斷是否存在 b  \n        Yes → Step 5: 設定 found = true; break // 找到，結束迴圈  \n        No →  // 沒找到，繼續迴圈  \n→ Decision: found? // 判斷是否存在 a, b  \n    Yes → Step 6: 輸出 true // 有解  \n    No  → Step 7: 輸出 false // 無解  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\nimport re\n\nclass Solution:\n    def judgeSquareSum(self, c: int) -> bool:\n        left, right = 0, int(math.isqrt(c))\n        while left <= right:\n            total = left * left + right * right\n            if total == c:\n                return True\n            elif total < c:\n                left += 1\n            else:\n                right -= 1\n        return False\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，尋找第一個整數\n    data = sys.stdin.read()\n    match = re.search(r\"\\d+\", data)\n    c = int(match.group(0)) if match else 0\n\n    solution = Solution()\n    result = solution.judgeSquareSum(c)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "c = 5",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "c = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode667.json",
    "problem_index_in_file": 0,
    "title": "Beautiful Arrangement II",
    "description_snippet": "Given two integers n and k, construct a list answer that contains n different positive integers rang...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines. Should describe algorithm: given n and k, need a permutation of 1..n such that absolute differences between consecutive elements have exactly k distinct values. Known solution: choose first k+1 numbers arranged as 1, k+1, 2, k, 3, k-1,... gives k distinct differences 1..k. Then fill rest with remaining numbers increasing or decreasing appropriately. Common approach: Use alternating high-low pattern for first k+1 elements: left=1, right=k+1, then left=2, right=k, etc. After that, for remaining n-(k+1) numbers, append increasing sequence from k+2 to n. That will introduce difference 1 between successive elements (since the sequence is consecutive). The differences from the alternating part include all numbers 1..k. After that, the differences from remaining part are 1, so no new distinct values. So total distinct k. Works if n>=k+1. Edge cases: k=0? But requirement k distinct integers among differences: k could be 0? But need n>=1, maybe k>=1. If k=0, we need all differences equal same value? But we can handle separately.\n\nWe need to produce step-by-step pseudocode with explanations.\n\nWe also need to include Start, End, Decision nodes. Use arrows.\n\nLet's outline:\n\nStart\n→ Decision: if n == 1? // only one element, no differences -> k must be 0\n   Yes → Step: answer = [1] // return single element\n   No  → Decision: if k >= n? // maximum distinct differences is n-1, cannot exceed\n       Yes → Step: error // invalid\n       No  → Step: initialize answer list\n           // build first k+1 alternating elements\n           → Step: left = 1\n           → Step: right = k+1\n           → Step: index = 0\n           → Step: While index < k+1:\n                if index even:\n                    append left to answer\n                    left += 1\n                else:\n                    append right to answer\n                    right -= 1\n                index += 1\n           → Step: next = k+2\n           → Step: while next <= n:\n                append next to answer\n                next += 1\nEnd\n\nNeed to add explanation for each line.\n\nLet's produce lines with virtual code steps.\n\nUse \"Step 1:\" etc. Include explanation comment.\n\nWe need \"→\" before each step after decision lines. Use \"Yes →\" or \"No →\".\n\nLet's craft.\n\nRemember to not output real code, just pseudocode lines with comments.\n\nWill include Decision: if n == 1?\n\nWe also might need to cover case k==0: need no distinct differences. If n>1 and k==0, we need all differences equal same value. We could output sequence [1,2,3,...,n] gives differences 1 repeated, distinct=1 not 0. So impossible unless n==1. So check if k==0 and n>1 -> error.\n\nAlso need check k >= n: max distinct differences is n-1. So if k > n-1: error.\n\nBut problem might guarantee valid input. We can still include checks.\n\nLet's include these decisions.\n\nWe'll produce:\n\nStart\n→ Decision: if n == 1? // only one element possible\n    Yes → Step 1: answer = [1] // single element\n    No  → Decision: if k == 0? // need zero distinct differences\n        Yes → Step 2: answer = [1] // can't have differences, so n must be 1, but we already handled, maybe return error\n        No  → Decision: if k > n-1? // impossible\n            Yes → Step 3: // return error or empty\n            No  → Step 4: // build answer\n\nStep 4 includes building alternating part and then remaining.\n\nWe can simplify: assume input valid n>=1 and 0<=k<=n-1. Provide algorithm accordingly.\n\nSimplify decisions:\n\nStart\n→ Step: if n == 1:\n        answer = [1] // single element, differences none\n→ Step: else:\n        // build first k+1 alternating numbers\n        left = 1\n        right = k+1\n        index = 0\n        while index < k+1:\n            if index % 2 == 0:\n                answer.append(left)\n                left += 1\n            else:\n                answer.append(right)\n                right -= 1\n            index += 1\n        // append remaining numbers from k+2 to n\n        next = k+2\n        while next <= n:\n            answer.append(next)\n            next += 1\n\nBut we need \"Decision:\" style. Use \"Decision: if n == 1?\" etc.\n\nLet's craft final output accordingly.\n\nAlso include End.\n\nWe'll need to use \"Step 1:\" style with explanations.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Decision: 如果 n 等於 1? // 檢查是否只有一個元素\n    Yes → Step 1: answer = [1] // 只有一個數字，差值集合空，k 必須為 0\n    No  → Decision: 如果 k 大於 n-1? // 最多只能有 n-1 個不同差值\n        Yes → Step 2: // 無法滿足條件，返回空或錯誤\n        No  → Step 3: // 開始構造答案\n            → Step 4: left = 1 // 最小數值\n            → Step 5: right = k + 1 // 最大數值在前 k+1 個元素中\n            → Step 6: index = 0 // 位置指標\n            → Decision: 如果 index 小於 k+1? // 構造交替序列\n                Yes → Decision: 如果 index 為偶數? // 偶數位置取左邊\n                    Yes → Step 7: answer.append(left) // 加入左邊數\n                    Yes → Step 8: left += 1 // 左邊數加一\n                    No  → Step 9: answer.append(right) // 取右邊數\n                    No  → Step 10: right -= 1 // 右邊數減一\n                No  → Step 11: index += 1 // 移動到下一個位置\n            → Step 12: next = k + 2 // 從 k+2 開始填充剩餘數字\n            → Decision: 如果 next 小於等於 n? // 添加剩餘數字\n                Yes → Step 13: answer.append(next) // 加入\n                Yes → Step 14: next += 1 // 下一個\n                No  → // 結束\nEnd // 程式執行結束\n\nBut the decision indentation must be proper: Use arrow lines.\n\nHowever the example uses indentation of Decision with Yes/No arrows. Let's mimic.\n\nWe'll produce as:\n\nStart // 程式開始執行\n→ Decision: n == 1? // 檢查是否只有一個元素\n    Yes → Step 1: answer = [1] // 只有一個數字，差值集合空，k 必須為 0\n    No  → Decision: k > n-1? // 最多只能有 n-1 個不同差值\n        Yes → Step 2: // 無法滿足條件，返回空或錯誤\n        No  → Step 3: // 開始構造答案\n            → Step 4: left = 1 // 初始化左指標\n            → Step 5: right = k + 1 // 初始化右指標\n            → Step 6: index = 0 // 位置指標\n            → Decision: index < k+1? // 構造交替序列\n                Yes → Decision: index % 2 == 0? // 偶數位置取左邊\n                    Yes → Step 7: answer.append(left) // 加入左邊數\n                    Yes → Step 8: left += 1 // 左邊數加一\n                    No  → Step 9: answer.append(right) // 加入右邊數\n                    No  → Step 10: right -= 1 // 右邊數減一\n                No  → Step 11: index += 1 // 移動到下一個位置\n            → Step 12: next = k + 2 // 從 k+2 開始填充剩餘數字\n            → Decision: next <= n? // 添加剩餘數字\n                Yes → Step 13: answer.append(next) // 加入\n                Yes → Step 14: next += 1 // 下一個\n                No  → // 結束\nEnd // 程式執行結束\n\nBut the indentation might not be perfectly consistent. We might need to ensure \"Yes →\" lines are properly indented.\n\nAlso after step 7 and 8, we need to increment index too, but we can simplify by moving index increment after the decision block. We need to ensure we don't miss increments.\n\nSimplify algorithm:\n\nindex = 0\nwhile index < k+1:\n    if index%2==0:\n        append left; left+=1\n    else:\n        append right; right-=1\n    index+=1\n\nWe can express this as a Decision loop: Decision: index < k+1? then inside we have two decisions.\n\nBut for clarity we can do:\n\n→ Decision: index < k+1? // 進入循環\n    Yes → Decision: index % 2 == 0? // 判斷偶數\n        Yes → Step 7: answer.append(left) // 加左\n        Yes → Step 8: left += 1 // 左+1\n        No  → Step 9: answer.append(right) // 加右\n        No  → Step 10: right -= 1 // 右-1\n    Yes → Step 11: index += 1 // 位置+1\n    No  → // 退出循環\n\nBut this is nested decisions.\n\nLet's produce final pseudo-code with steps:\n\nStart // 程式開始執行\n→ Decision: n == 1? // 只有一個元素\n    Yes → Step 1: answer = [1] // 返回單一元素，差值集合空\n    No  → Decision: k > n-1? // 檢查是否超出最大差值數\n        Yes → Step 2: // 無解，返回空或錯誤\n        No  → Step 3: // 開始構造答案\n            → Step 4: left = 1 // 左指標\n            → Step 5: right = k + 1 // 右指標\n            → Step 6: index = 0 // 循環指標\n            → Decision: index < k+1? // 循環構造交替序列\n                Yes → Decision: index % 2 == 0? // 偶數位置\n                    Yes → Step 7: answer.append(left) // 加左\n                    Yes → Step 8: left += 1 // 左加一\n                    No  → Step 9: answer.append(right) // 加右\n                    No  → Step 10: right -= 1 // 右減一\n                Yes → Step 11: index += 1 // 指標加一\n                No  → // 退出循環\n            → Step 12: next = k + 2 // 從 k+2 開始\n            → Decision: next <= n? // 添加剩餘數字\n                Yes → Step 13: answer.append(next) // 加入\n                Yes → Step 14: next += 1 // 下一個\n                No  → // 退出循環\nEnd // 程式結束\n\nBut we need \"→\" before each line except Decision lines. The example uses arrows for each step line. So we can prefix each Step line with \"→\". For Decision lines also use arrow: \"→ Decision:\".\n\nLet's rewrite:\n\nStart // 程式開始執行\n→ Decision: n == 1? // 只有一個元素\n    Yes → Step 1: answer = [1] // 返回單一元素，差值集合空\n    No  → Decision: k > n-1? // 檢查是否超出最大差值數\n        Yes → Step 2: // 無解，返回空或錯誤\n        No  → Step 3: // 開始構造答案\n            → Step 4: left = 1 // 左指標\n            → Step 5: right = k + 1 // 右指標\n            → Step 6: index = 0 // 循環指標\n            → Decision: index < k+1? // 循環構造交替序列\n                Yes → Decision: index % 2 == 0? // 偶數位置\n                    Yes → Step 7: answer.append(left) // 加左\n                    Yes → Step 8: left += 1 // 左加一\n                    No  → Step 9: answer.append(right) // 加右\n                    No  → Step 10: right -= 1 // 右減一\n                Yes → Step 11: index += 1 // 指標加一\n                No  → // 退出循環\n            → Step 12: next = k + 2 // 從 k+2 開始\n            → Decision: next <= n? // 添加剩餘數字\n                Yes → Step 13: answer.append(next) // 加入\n                Yes → Step 14: next += 1 // 下一個\n                No  → // 退出循環\nEnd // 程式結束\n\nBut we need consistent indentation. Use tab or spaces? Provide as plain text.\n\nHowever, the pseudocode includes many nested decisions. Might be okay.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: n == 1? // 只有一個元素  \n Yes → Step 1: answer = [1] // 回傳單一元素，差值集合為空，k 必為 0  \n No  → Decision: k > n-1? // 最多只能有 n‑1 個不同差值  \n  Yes → Step 2: // 無法滿足條件，回傳空或錯誤  \n  No  → Step 3: // 開始構造答案  \n   → Step 4: left = 1 // 初始化左指標  \n   → Step 5: right = k + 1 // 初始化右指標  \n   → Step 6: index = 0 // 位置指標  \n   → Decision: index < k+1? // 循環構造前 k+1 個交替元素  \n    Yes → Decision: index % 2 == 0? // 偶數位置取左邊  \n     Yes → Step 7: answer.append(left) // 加入左邊數  \n     Yes → Step 8: left += 1 // 左指標加一  \n     No  → Step 9: answer.append(right) // 加入右邊數  \n     No  → Step 10: right -= 1 // 右指標減一  \n    Yes → Step 11: index += 1 // 位置指標加一  \n    No  → // 退出循環  \n   → Step 12: next = k + 2 // 從 k+2 開始填入剩餘數字  \n   → Decision: next <= n? // 添加剩餘數字  \n    Yes → Step 13: answer.append(next) // 加入  \n    Yes → Step 14: next += 1 // 移到下一個數字  \n    No  → // 退出循環  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def constructArray(self, n: int, k: int):\n        res = []\n        left, right = 1, k + 1\n\n        # 先生成 k 個不同差值的交替序列\n        for i in range(k + 1):\n            if i % 2 == 0:\n                res.append(left)\n                left += 1\n            else:\n                res.append(right)\n                right -= 1\n\n        # 剩餘的數字直接遞增填充\n        for i in range(k + 2, n + 1):\n            res.append(i)\n\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 從輸入中擷取所有整數，無論格式為何\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) >= 2:\n        n, k = nums[0], nums[1]\n    else:\n        # 如果只給一個數字，假設第二個為 0\n        n = nums[0]\n        k = 0\n\n    sol = Solution()\n    ans = sol.constructArray(n, k)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 1",
          "expected_output": "[1,2,3]",
          "success": true,
          "output": "[1, 2, 3]"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 2",
          "expected_output": "[1,3,2]",
          "success": true,
          "output": "[1, 3, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode69.json",
    "problem_index_in_file": 0,
    "title": "Sqrt(x)",
    "description_snippet": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for integer sqrt using binary search. Steps: Start, read x, if x<2 return x. else binary search between 1 and x//2+1? Actually high = x. We find mid, compute mid*mid <= x? need mid*mid compare without overflow? but x is non-negative int maybe 32-bit. Use mid*mid > x. Use 64-bit.\n\nAlgorithm: low=1, high=x, ans=0\nwhile low <= high:\n mid=(low+high)//2\n if mid*mid == x: ans=mid; break\n elif mid*mid < x: ans=mid; low=mid+1\n else: high=mid-1\nreturn ans\n\nReturn ans.\n\nNeed virtual code with arrows and decision.\n\nOk produce line by line. Use Step names. Ensure each line includes explanation.\n\nLet's craft.\n\nAlso include reading x as input. Provide decision for x < 2. Also note that we don't use pow.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 x // 取得輸入值  \n→ Decision: x 小於 2? // 簡化極端情況  \n  Yes → Step 2: 回傳 x // 0 或 1 的平方根即本身  \n  No  → Step 3: 設定 low = 1, high = x, ans = 0 // 初始化二分搜尋區間與答案  \n→ Step 4: While low <= high 循環 // 進行二分搜尋  \n  → Step 5: mid = (low + high) // 2 // 計算中點  \n  → Decision: mid * mid 等於 x? // 檢查是否精確根  \n    Yes → ans = mid // 找到平方根  \n       → End // 離開循環，準備回傳  \n    No  → Decision: mid * mid 小於 x? // 判斷中點平方是否太小  \n      Yes → ans = mid, low = mid + 1 // 记录当前中点为可能答案，搜索更大的数  \n      No  → high = mid - 1 // 需要更小的中点  \n→ Step 6: 回傳 ans // 返回最接近但不超過的平方根  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef integer_sqrt(x: int) -> int:\n    \"\"\"\n    計算非負整數 x 的平方根向下取整的值。\n    不使用任何指數運算或 pow 函式。\n    \"\"\"\n    if x < 2:\n        # x 是 0 或 1，平方根即為本身\n        return x\n\n    low, high = 1, x\n    ans = 0\n\n    while low <= high:\n        mid = (low + high) // 2\n        mid_sq = mid * mid\n\n        if mid_sq == x:\n            ans = mid\n            break\n        elif mid_sq < x:\n            ans = mid          # mid 可能是最接近但不超過 x 的平方根\n            low = mid + 1      # 向右搜尋更大的數\n        else:\n            high = mid - 1     # mid 太大，向左搜尋更小的數\n\n    return ans\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料，格式可能為 \"x = 4\" 或僅為數字\n    raw_input = sys.stdin.read().strip()\n    match = re.search(r'-?\\d+', raw_input)\n    if not match:\n        raise ValueError(\"未偵測到有效的整數輸入\")\n    x_value = int(match.group())\n\n    result = integer_sqrt(x_value)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 8",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode385.json",
    "problem_index_in_file": 0,
    "title": "Mini Parser",
    "description_snippet": "Given a string s represents the serialization of a nested list, implement a parser to deserialize it...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step for parsing nested integer serialization string. Format: each line: 虛擬碼步驟 + \" // \" + explanation. Use arrows, Start, End, Decision, etc.\n\nWe need to design algorithm. Steps: Initialize stack, iterate over string, when encountering '[' push new list, ']' pop, numbers, commas. At end return top of stack.\n\nLet's produce stepwise. Use pseudo. Include Start, End, Decision. Provide comments. Let's produce maybe 20-25 lines.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 若 s 為空字符串則回傳空 NestedInteger // 處理空輸入\n→ Decision: s[0] 是否為 '['? // 判斷輸入是否為單一整數或列表\n    No  → Step 2: 轉換 s 為整數並包裝成 NestedInteger // 整數情況直接返回\n    Yes → Step 3: 建立空 stack 用於儲存 NestedInteger 物件 // 准備解析列表\n→ Step 4: 將一個新的空 NestedInteger push 進 stack 並將其設為目前目標 // 初始列表容器\n→ Step 5: 從索引 1 開始遍歷 s 直到字串結尾 // 跳過首 '['\n→ Decision: 當前字元是否為 ','? // 逗號用於分隔元素，無需處理\n    Yes → Step 6: 跳過此字符 // 直接往下\n    No  → Decision: 是否為 ']'? // 結束當前列表\n        Yes → Step 7: pop 當前列表並將其加入上層列表（若存在） // 完成子列表\n            → Decision: stack 是否非空? // 判斷是否還有父層\n                Yes → Step 8: stack.top().add(popped) // 將子列表加入父層\n                No  → Step 9: 設定 popped 為最終結果 // 若堆疊已空，為根節點\n        No  → Decision: 字元是否為 '['? // 開始新子列表\n            Yes → Step 10: 建立新空 NestedInteger 並 push 進 stack // 新子列表開始\n            No  → Step 11: 讀取完整數字直到遇到 ',' 或 ']' // 將多位數處理\n                → Step 12: 轉成整數並將其包裝為 NestedInteger // 整數節點\n                → Step 13: 把此節點加入當前 stack.top() // 加入父列表\n→ Step 14: 循環結束後檢查 stack 是否僅剩一個元素 // 確認解析完整\n→ Decision: stack.size() 是否為 1? // 驗證結果\n    Yes → Step 15: 回傳 stack.top() // 返回反序列化結果\n    No  → Step 16: 回傳空 NestedInteger // 遇到錯誤時返回空值\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass NestedInteger:\n    \"\"\"\n    A lightweight implementation of LeetCode's NestedInteger.\n    \"\"\"\n    def __init__(self, value=None):\n        if value is None:\n            self._list = []\n            self._int = None\n        else:\n            self._list = None\n            self._int = int(value)\n\n    def isInteger(self):\n        return self._int is not None\n\n    def add(self, elem):\n        if self.isInteger():\n            # Should not happen in normal usage\n            raise ValueError(\"Cannot add to an integer NestedInteger\")\n        self._list.append(elem)\n\n    def setInteger(self, value):\n        self._int = int(value)\n        self._list = None\n\n    def getInteger(self):\n        return self._int\n\n    def getList(self):\n        return self._list\n\n    def __str__(self):\n        if self.isInteger():\n            return str(self._int)\n        else:\n            return '[' + ','.join(str(item) for item in self._list) + ']'\n\n\nclass Solution:\n    def deserialize(self, s: str) -> NestedInteger:\n        # If the string doesn't start with '[' it's just a single integer\n        if not s or s[0] != '[':\n            return NestedInteger(int(s))\n\n        stack = []\n        num = ''\n        negative = False\n\n        for c in s:\n            if c == '-':\n                negative = True\n            elif c.isdigit():\n                num += c\n            elif c == '[':\n                stack.append(NestedInteger())\n            elif c in ',]':\n                # If we have a number pending, add it to the current list\n                if num:\n                    value = int(num)\n                    if negative:\n                        value = -value\n                    stack[-1].add(NestedInteger(value))\n                    num = ''\n                    negative = False\n                # If we encounter ']' and there is a parent list, pop and add\n                if c == ']' and len(stack) > 1:\n                    ni = stack.pop()\n                    stack[-1].add(ni)\n\n        # The root NestedInteger is the only element left in the stack\n        return stack[0]\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Extract the string inside quotes if present, otherwise use the raw input\n    m = re.search(r'\"([^\"]*)\"', data)\n    if m:\n        s = m.group(1)\n    else:\n        s = data\n\n    solution = Solution()\n    result = solution.deserialize(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"324\"",
          "expected_output": "324",
          "success": true,
          "output": "324"
        },
        {
          "example_index": 1,
          "input": "s = \"[123,[456,[789]]]\"",
          "expected_output": "[123,[456,[789]]]",
          "success": true,
          "output": "[123,[456,[789]]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode477.json",
    "problem_index_in_file": 0,
    "title": "Total Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The problem: compute sum of Hamming distances over all pairs in array nums. Standard solution: for each bit position 0-31, count number of ones and zeros. Contribution: count1*count0*2 (since each pair counted once, but each pair contributes 2? Actually Hamming distance is number of differing bits, each pair counted once, not double counted. For each bit, number of pairs differing is ones * zeros. Sum across bits. If we sum for all pairs, each unordered pair counted once. But many solutions compute sum of pairs as ones * zeros * 2 because they count ordered pairs (i,j) and (j,i). Problem likely expects sum over unordered pairs. In example? Not given. Let's assume unordered. But we can produce code with formula ones*zeros. Provide virtual code steps: Start, for each bit 0-31, count ones, zeros, add ones*zeros to sum, End.\n\nWe need to use arrows. Provide each step. Use Decision only if needed? Not necessary.\n\nLet's output:\n\nStart // 開始\n→ Step 1: 初始化 sum = 0 // 記錄總 Hamming 距離\n→ Step 2: 對每個位元位置 i 從 0 到 31 循環 // 逐位計算\n    → Step 3: 計算 nums 中 1 的個數 count1 = number of nums[j] where bit i is 1 // 計算該位的 1\n    → Step 4: 計算 0 的個數 count0 = nums.length - count1 // 0 的個數\n    → Step 5: sum += count1 * count0 // 當位不同的組合數加到總和\n→ Step 6: 回傳 sum // 結果\nEnd // 程式結束\n\nBut we need to ensure format: each line with virtual code then // explanation. Use arrow indentation? Use arrow for steps. Use arrow for nested? The example uses indentation. We'll produce accordingly.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: sum ← 0 // 初始化總 Hamming 距離為 0  \n→ Step 2: 對 i 從 0 到 31 迴圈 // 逐位檢查 32 位元  \n → Step 3: count1 ← 0 // 1 的個數初始為 0  \n → Step 4: 對每個 num 在 nums 迴圈  \n  → Step 5: 若 (num 並且 (1 左移 i)) != 0，則 count1 ← count1 + 1 // 判斷第 i 位是否為 1  \n → Step 6: count0 ← nums.length - count1 // 0 的個數為總長度減去 1 的個數  \n → Step 7: sum ← sum + count1 * count0 // 當位不同的所有組合數累加  \n→ Step 8: 回傳 sum // 結果即所有 unordered pair 的 Hamming 距離總和  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def totalHammingDistance(self, nums):\n        total = 0\n        n = len(nums)\n        for i in range(32):\n            count_ones = sum((num >> i) & 1 for num in nums)\n            count_zeros = n - count_ones\n            total += count_ones * count_zeros\n        return total\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 尋找列表部分，支持輸入形式如 \"nums = [4,14,2]\" 或直接 \"[4,14,2]\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1:\n        nums_str = data[start:end+1]\n    else:\n        nums_str = data\n    try:\n        nums = eval(nums_str)\n    except Exception:\n        # 如果 eval 失敗，則直接嘗試解析為空列表\n        nums = []\n    solution = Solution()\n    result = solution.totalHammingDistance(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,14,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [4,14,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode115.json",
    "problem_index_in_file": 0,
    "title": "Distinct Subsequences",
    "description_snippet": "Given two strings s and t, return the number of distinct subsequences of s which equals t.\n\nThe test...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for computing number of distinct subsequences of s that equal t. Typical DP solution: dp[i][j] number of subsequences of first i chars of s that match first j chars of t. Use 1D DP: dp[j] for t length+1. Or 2D.\n\nWe'll produce step by step pseudocode with explanations. Use arrow syntax and decisions. Need start, decision, etc. Provide line by line with // explanation.\n\nLet's create steps:\n\nStart\n→ Step 1: Set n = length(s), m = length(t)\n→ Step 2: If m > n → return 0 // impossible\n→ Step 3: Initialize array dp of size m+1 with all 0\n→ Step 4: dp[0] = 1 // empty t matches any prefix\n→ Step 5: For each index i from 1 to n:\n   → Step 5a: For each index j from m down to 1:\n       → Decision: If s[i-1] == t[j-1]?\n           Yes → dp[j] = dp[j] + dp[j-1] // add subsequences that use this char\n           No → // dp[j] unchanged\n   → End inner loop\n→ End outer loop\n→ Step 6: Return dp[m]\n\nAdd decisions etc.\n\nNeed to maintain format: each line \"虛擬碼步驟 // 解釋\" with arrow etc.\n\nMake sure to use arrows. The decisions inside loops: maybe use \"Decision:\" lines.\n\nWe should produce something like:\n\nStart // 程式開始執行\n→ Step 1: Set n = length of s, m = length of t // 取得字串長度\n→ Step 2: Decision: 如果 m > n? // 判斷 t 是否比 s 長\n    Yes → Step 3: Return 0 // 無法匹配\n    No  → // 繼續\n→ Step 4: Initialize array dp[0…m] all 0 // DP陣列\n→ Step 5: dp[0] = 1 // 空子序列匹配\n→ Step 6: For i from 1 to n: // 遍歷 s\n    → Step 6a: For j from m down to 1: // 遍歷 t 逆序\n        → Decision: 如果 s[i-1] == t[j-1]? // 檢查字符是否相等\n            Yes → dp[j] = dp[j] + dp[j-1] // 更新計數\n            No  → // 無變化\n    → End inner loop\n→ End outer loop\n→ Step 7: Return dp[m] // 結果\n\nAlso we need End // 程式結束.\n\nMake sure to include End.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set n = length(s), m = length(t) // 取得兩個字串的長度  \n→ Step 2: Decision: 如果 m > n? // 判斷 t 是否比 s 長  \n  Yes → Step 3: Return 0 // 無法匹配，直接結束  \n  No  → // 繼續往下執行  \n→ Step 4: Initialize array dp[0…m] with all 0 // DP 陣列用於累計子序列個數  \n→ Step 5: dp[0] = 1 // 空子序列能匹配任何前綴  \n→ Step 6: For i from 1 to n: // 遍歷 s 的每個字符  \n  → Step 6a: For j from m down to 1: // 逆序遍歷 t 以避免覆寫  \n    Decision: 如果 s[i‑1] == t[j‑1]? // 檢查字符是否相等  \n     Yes → dp[j] = dp[j] + dp[j‑1] // 加上使用此字符的匹配個數  \n     No  → // dp[j] 不變  \n   → End inner loop  \n→ End outer loop  \n→ Step 7: Return dp[m] // dp[m] 為完整 t 的子序列個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        m, n = len(s), len(t)\n        if n == 0:\n            return 1\n        if m == 0 or n > m:\n            return 0\n        # 1‑dimensional DP: dp[j] 表示 s[0:i] 與 t[0:j] 的子序列個數\n        dp = [0] * (n + 1)\n        dp[0] = 1  # 空子序列與任何前綴匹配\n        for i in range(1, m + 1):\n            # 逆序更新，避免覆寫 dp[j‑1]\n            for j in range(n, 0, -1):\n                if s[i - 1] == t[j - 1]:\n                    dp[j] += dp[j - 1]\n        return dp[n]\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取 s 與 t。支援「s = \"...\" , t = \"...\"」或兩行分別給定。\n    \"\"\"\n    # 先嘗試以正則抓取兩個引號內的字串\n    quoted = re.findall(r'\"(.*?)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n    # 若沒有引號，嘗試拆分兩行\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    # 最後嘗試以逗號分隔\n    parts = [p.strip() for p in data.split(',')]\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # 若都失敗，回傳空字串\n    return '', ''\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, t = parse_input(raw_input)\n    result = Solution().numDistinct(s, t)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"rabbbit\", t = \"rabbit\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"babgbag\", t = \"bag\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode211.json",
    "problem_index_in_file": 0,
    "title": "Design Add and Search Words Data Structure",
    "description_snippet": "Design a data structure that supports adding new words and finding if a string matches any previousl...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code (like pseudocode). Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc. Need to design a data structure that supports addWord and search with '.' wildcard. Classic solution: Trie with DFS for search. So we can design WordDictionary with root node of TrieNode that contains children dict and isEnd flag. addWord inserts letters into trie. search uses recursion: if char is '.', try all child nodes; else follow char. Return true if found end at string end. So produce step-by-step.\n\nWe should produce code-like steps:\n\nStart\n→ Step 1: Define TrieNode structure // node with children map and end flag\n→ Step 2: WordDictionary() // initialize root node\n→ Step 3: addWord(word) // iterate characters\n    → Step 3.1: current = root\n    → Step 3.2: For each char c in word:\n        → Step 3.2a: If c not in current.children: create new node\n        → Step 3.2b: current = current.children[c]\n    → Step 3.3: current.isEnd = true\n→ Step 4: search(word) // helper DFS\n    → Step 4.1: return dfs(root, word, index=0)\n→ Step 4.2: dfs(node, word, i):\n        → Decision: i == len(word)?\n            Yes → return node.isEnd\n            No → char = word[i]\n                → Decision: char == '.'?\n                    Yes → For each child in node.children:\n                                If dfs(child, word, i+1) return true\n                        return false\n                    No  → If char in node.children:\n                                return dfs(node.children[char], word, i+1)\n                        else return false\nEnd\n\nWe need to output each line in the format: \"虛擬碼步驟 // 解釋\". Include arrow etc. Provide step numbers and decisions. Also include braces? Not necessary.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode 結構，含 children (字母到子節點的映射) 與 isEnd (是否為單字結尾) // 建立基本節點模型  \n→ Step 2: WordDictionary() 初始化 root = 新 TrieNode() // 準備空字典  \n→ Step 3: addWord(word) // 插入新單字  \n  → Step 3.1: current = root // 以 root 為起點  \n  → Step 3.2: For 每個字元 c 在 word 中  \n    → Step 3.2a: 若 c 不在 current.children 則 current.children[c] = 新 TrieNode() // 新建節點  \n    → Step 3.2b: current = current.children[c] // 移動到下一節點  \n  → Step 3.3: current.isEnd = true // 標記單字結尾  \n→ Step 4: search(word) // 查詢字串或 '.' 通配符  \n  → Step 4.1: return dfs(root, word, 0) // 以深度優先遞迴搜尋  \n→ Step 4.2: dfs(node, word, idx) // 遞迴函式  \n   → Decision: idx == len(word)? // 到達字串末尾  \n     Yes → return node.isEnd // 若此節點為結尾則匹配成功  \n     No → ch = word[idx] // 取得目前字元  \n      Decision: ch == '.'? // 通配符處理  \n       Yes → For 每個子節點 nxt in node.children.values()  \n         → Step 4.2.1: 若 dfs(nxt, word, idx+1) 為 true → return true // 任何分支成功即成功  \n         → 之後 return false // 所有分支失敗  \n       No  → 若 ch 在 node.children  \n         → Step 4.2.2: return dfs(node.children[ch], word, idx+1) // 直接往該子節點遞迴  \n         否則 return false // 字元不存在，匹配失敗  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\n# Trie 節點，每個節點儲存子節點映射和是否為單字結尾\nclass TrieNode:\n    def __init__(self):\n        self.children = {}  # key: 字母, value: 子 TrieNode\n        self.is_end = False  # 是否為單字結尾\n\n# WordDictionary 使用 Trie 來支援 addWord 與 search\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()  # 初始化時只有根節點\n\n    # 新增單字\n    def addWord(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()  # 若沒有則建立新節點\n            node = node.children[ch]  # 進入下一節點\n        node.is_end = True  # 標記單字結尾\n\n    # 搜尋，支援 '.' 通配符\n    def search(self, word):\n        def dfs(node, idx):\n            if idx == len(word):  # 已遍歷完字串\n                return node.is_end\n            ch = word[idx]\n            if ch == '.':  # 通配符，嘗試所有子節點\n                for child in node.children.values():\n                    if dfs(child, idx + 1):\n                        return True\n                return False\n            else:  # 正常字母，直接往該子節點搜尋\n                if ch not in node.children:\n                    return False\n                return dfs(node.children[ch], idx + 1)\n        return dfs(self.root, 0)\n\n# ----------------- main 入口 -----------------\ndef main():\n    # 讀取整個標準輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 解析成兩個 list：操作名稱與對應參數\n    ops, args = json.loads(raw)\n\n    results = []\n    obj = None  # WordDictionary 實例\n\n    for op, arg in zip(ops, args):\n        if op == \"WordDictionary\":\n            obj = WordDictionary()\n            results.append(None)          # 建構子返回 null\n        elif op == \"addWord\":\n            obj.addWord(arg[0])\n            results.append(None)          # void 返回 null\n        elif op == \"search\":\n            res = obj.search(arg[0])\n            results.append(res)           # True/False\n        else:\n            results.append(None)          # 其他操作預留\n\n    # 輸出結果，使用 json.dumps 產生 [null, ...] 格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpr_cvup78.py\", line 70, in <module>\n    main()\n  File \"/tmp/tmpr_cvup78.py\", line 48, in main\n    ops, args = json.loads(raw)\n                ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 85 (char 84)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode556.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element III",
    "description_snippet": "Given a positive integer n, find the smallest integer which has exactly the same digits existing in ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step for given problem: find next greater permutation of digits of n. If no next greater permutation, return -1. Also if result exceeds 32-bit signed integer, return -1. We need to produce virtual code lines following format: \"虛擬碼步驟 // 解釋\". Use arrows and Decision. Let's outline algorithm:\n\nStart\n→ Step 1: Convert n to array of digits\n→ Step 2: Find pivot: rightmost index i where digits[i] < digits[i+1]; if none → return -1\n→ Step 3: Find successor: rightmost index j > i where digits[j] > digits[i]\n→ Step 4: Swap digits[i] and digits[j]\n→ Step 5: Reverse subarray from i+1 to end\n→ Step 6: Convert array back to integer result\n→ Decision: if result > 2^31-1 then return -1 else return result\n\nAlso handle n negative? Input positive integer, so fine.\n\nWe'll output virtual code lines accordingly. Use \"Start\" \"End\". Include Decision lines. Provide each step. Provide comments. Use arrow syntax \"→\". Let's produce.\n\nWe must not output actual code. Provide virtual steps. We'll keep consistent formatting. Ensure each line includes virtual step + space + comment. Use \"Start\" and \"End\" as plain. Use \"Decision:\" with indents. The arrow \"→\" for next step. For decision branches, we indent the Yes and No lines. Use \"Yes →\" and \"No →\". So produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Convert n to list of digits `digits` // 把整數拆成單個位數陣列  \n→ Step 2: Find pivot index `i` (rightmost `digits[i] < digits[i+1]`)  \n→ Decision: 是否找到 pivot `i`? // 檢查是否存在更大的排列  \n  Yes → Step 3: Find successor index `j` (rightmost `digits[j] > digits[i]`) // 在右側尋找最小大於 pivot 的數字  \n  Yes → Step 4: Swap `digits[i]` 與 `digits[j]` // 交換 pivot 與 successor  \n  Yes → Step 5: Reverse subarray from `i+1` to end // 讓後半部分變成最小升序  \n  Yes → Step 6: Convert `digits` back to integer `result` // 將數字陣列重新組合成整數  \n  Yes → Decision: `result` 是否大於 2^31-1? // 檢查是否溢出 32 位元  \n    Yes → Step 7: Return -1 // 超出範圍，返回 -1  \n    No → Step 8: Return `result` // 合法結果  \n  No → Step 9: Return -1 // 沒有更大的排列  \nNo → Step 10: Return -1 // 沒有找到 pivot，表示已是最大排列  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        digits = list(str(n))\n        i = len(digits) - 2\n        while i >= 0 and digits[i] >= digits[i + 1]:\n            i -= 1\n        if i == -1:\n            return -1\n        j = len(digits) - 1\n        while digits[j] <= digits[i]:\n            j -= 1\n        digits[i], digits[j] = digits[j], digits[i]\n        digits[i + 1:] = reversed(digits[i + 1:])\n        result = int(''.join(digits))\n        return result if result < 2 ** 31 else -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 支援 \"n = 12\" 或僅輸入 \"12\"\n    if '=' in data:\n        _, val = data.split('=', 1)\n        n = int(val.strip())\n    else:\n        n = int(data)\n    sol = Solution()\n    print(sol.nextGreaterElement(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12",
          "expected_output": "21",
          "success": true,
          "output": "21"
        },
        {
          "example_index": 1,
          "input": "n = 21",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode507.json",
    "problem_index_in_file": 0,
    "title": "Perfect Number",
    "description_snippet": "A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, with arrows, decisions, etc. For perfect number check. Must not output actual code, just virtual steps.\n\nWe need to output line by line: \"Start // 程式開始執行\" etc. Use virtual code steps: maybe \"Step 1: 初始化 sum = 0\" etc. And we need to check divisors from 1 to sqrt(n) to sum them, but can just check from 1 to n-1 (though less efficient). Use logic: For i from 1 to sqrt(n) or to n-1, if n % i == 0, add i, and also add n/i if distinct and not n itself. At the end compare sum with n. Return true/false.\n\nBut in virtual steps we can express loops as \"Loop: i=1 to n-1\" etc.\n\nWe need to produce the step-by-step.\n\nWe need to ensure we output the steps in required format.\n\nWe need to keep each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" for next step.\n\nLet's construct.\n\nStart // 程式開始執行\n→ Step 1: If n <= 1? // 檢查是否小於等於1，因為 1 不是完美數\n    Yes → Step 2: Return False // 小於等於1直接返回false\n    No  → Step 3: sum ← 0 // 初始化總和為0\n→ Step 4: For i ← 1 to sqrt(n) // 循環檢查1到n的平方根\n    → Decision: 如果 n % i == 0? // 判斷 i 是否為 n 的因數\n        Yes →\n            → Step 5: sum ← sum + i // 加入因子 i\n            → Decision: i ≠ 1 以及 i ≠ n/i? // 只在不是1且不是自身的情況下加第二個因子\n                Yes → sum ← sum + n / i // 加入對應的因子\n                No  → // 不做任何事\n        No → // i 不是因子，跳過\n→ Step 6: Decision: sum == n? // 比較總和是否等於 n\n    Yes → Step 7: Return True // 完美數\n    No  → Step 8: Return False // 非完美數\nEnd // 程式結束\n\nWe need to use \"Decision:\" and arrows. Let's format properly:\n\nStart // 程式開始執行\n→ Decision: n <= 1? // 檢查 n 是否小於等於1\n    Yes → Step 1: Return False // 小於等於1不是完美數\n    No  → Step 2: sum ← 0 // 初始化總和\n→ Step 3: i ← 1 // i 從1開始\n→ Loop: i ≤ sqrt(n) // 循環到平方根\n    → Decision: n % i == 0? // 判斷 i 是否是因數\n        Yes →\n            → Step 4: sum ← sum + i // 加上 i\n            → Decision: i ≠ 1 AND i ≠ n / i? // 需要確保不重複且不是 n 本身\n                Yes → Step 5: sum ← sum + n / i // 加上對應因子\n                No  → // 無操作\n        No  → // 無操作\n    → Step 6: i ← i + 1 // 增加 i\n→ Step 7: Decision: sum == n? // 判斷是否完美\n    Yes → Step 8: Return True // 完美數\n    No  → Step 9: Return False // 不是完美數\nEnd // 程式結束\n\nBut we need arrow before each Step line? The example uses arrow before each step: \"→ Step 1: ...\". For Decision lines we also use \"Decision:\" and indent. The example uses indentation.\n\nWe need to maintain formatting like:\n\nStart // 程式開始執行\n→ Decision: n <= 1? // 檢查 n 是否小於等於1\n    Yes → Step 1: Return False // 小於等於1不是完美數\n    No  → Step 2: sum ← 0 // 初始化總和\n→ Step 3: i ← 1 // i 從1開始\n→ Loop: i ≤ sqrt(n) // 循環到平方根\n    → Decision: n % i == 0? // 判斷 i 是否是因數\n        Yes →\n            → Step 4: sum ← sum + i // 加上 i\n            → Decision: i ≠ 1 AND i ≠ n / i? // 需要確保不重複且不是 n 本身\n                Yes → Step 5: sum ← sum + n / i // 加上對應因子\n                No  → // 無操作\n        No  → // 無操作\n    → Step 6: i ← i + 1 // 增加 i\n→ Step 7: Decision: sum == n? // 判斷是否完美\n    Yes → Step 8: Return True // 完美數\n    No  → Step 9: Return False // 不是完美數\nEnd // 程式結束\n\nBut we need to use \"→\" before each step. For loops we can just show \"→ Loop:\" maybe.\n\nCheck formatting: In example, \"Start // 程式開始執行\" and each step is prefixed by arrow. So we should keep.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: n <= 1? // 檢查 n 是否小於等於 1  \n Yes → Step 1: Return False // 小於等於 1 不是完美數，直接返回  \n No  → Step 2: sum ← 0 // 初始化總和為 0  \n→ Step 3: i ← 1 // i 從 1 開始  \n→ Loop: i ≤ sqrt(n) // 循環至 n 的平方根  \n  → Decision: n % i == 0? // 判斷 i 是否是 n 的因數  \n   Yes →  \n     → Step 4: sum ← sum + i // 加上因數 i  \n     → Decision: i ≠ 1 AND i ≠ n / i? // 確保不重複且不是 n 本身  \n      Yes → Step 5: sum ← sum + n / i // 加上對應的因數 n/i  \n      No  → // 不做任何事  \n   No  → // i 不是因數，跳過  \n  → Step 6: i ← i + 1 // i 加 1  \n→ Step 7: Decision: sum == n? // 判斷總和是否等於 n  \n  Yes → Step 8: Return True // 是完美數，返回 true  \n  No  → Step 9: Return False // 不是完美數，返回 false  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def checkPerfectNumber(self, num: int) -> bool:\n        if num < 2:\n            return False\n        sum_div = 1\n        i = 2\n        while i * i <= num:\n            if num % i == 0:\n                sum_div += i\n                if i != num // i:\n                    sum_div += num // i\n            i += 1\n        return sum_div == num\n\nif __name__ == \"__main__\":\n    import sys\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    try:\n        n = int(data)\n    except ValueError:\n        n = 0\n    sol = Solution()\n    result = sol.checkPerfectNumber(n)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "28",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "7",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode476.json",
    "problem_index_in_file": 0,
    "title": "Number Complement",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps, no actual code, just virtual steps, each line with explanation. Use Start, Decision, Step, End. We need algorithm: get binary string, flip bits, convert back. But maybe simpler: find highest bit, mask all bits, xor. Use bitwise. But just describe high-level. Steps: Start, find msb position, create mask with all ones upto msb, XOR. End. Provide explanation each. Use arrow notation. Provide in Traditional Chinese. Let's produce.\n\nAlso ensure each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" to denote next step.\n\nLet's produce.\n\nWe'll do:\n\nStart // 程式開始執行\n→ Step 1: 計算 num 的二進位最高位位置 // 找到最高位所在的位置\n→ Step 2: 建立所有位為 1 的遮罩 mask = (1 << (msb_position + 1)) - 1 // 將低於等於最高位的位元設為 1\n→ Decision: 是否需要特殊處理 num 為 0? // 檢查 num 是否為 0\n    Yes → Step 3a: 返回 1 // 0 的二進位為 0，翻轉後為 1\n    No  → Step 3b: 將 num 與 mask XOR 得到 complement // 取反後的數值\n→ End // 程式結束\n\nBut maybe we need to include Step 3b after decision. Provide step numbers? It's okay.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 num 的二進位最高位位置 (msb) // 找到 num 最高有效位的索引  \n→ Step 2: 建立遮罩 mask = (1 << (msb + 1)) - 1 // 生成所有低於等於最高位的位元為 1 的整數  \n→ Decision: num 是否等於 0? // 檢查特殊情況  \n    Yes → Step 3a: 回傳 1 // 0 的二進位為 0，翻轉後為 1  \n    No  → Step 3b: complement = num XOR mask // 取反後的數值  \n→ End // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        \"\"\"\n        計算 num 的二進位長度並生成全 1 掩碼，然後用 XOR 取反。\n        \"\"\"\n        bit_length = num.bit_length()\n        mask = (1 << bit_length) - 1\n        return num ^ mask\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取一行文字，提取第一個整數作為 num，\n    计算其补码并打印结果。\n    \"\"\"\n    data = sys.stdin.read()\n    # 把所有數字（含負號）取出，取第一個作為輸入\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    num = int(nums[0])\n\n    solution = Solution()\n    result = solution.findComplement(num)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode703.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in a Stream",
    "description_snippet": "You are part of a university admissions office and need to keep track of the kth highest test score ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode line by line, with explanation. Provide a virtual code for the KthLargest class implementation. Use min-heap of size k to maintain k largest. Steps: initialization: create min-heap, push first k elements, if more, push each element if > smallest. add: push val, if heap size > k pop min. Return heap root (kth largest). We'll present steps.\n\nStructure: Start → Step: define class KthLargest → Step: constructor → initialize heap → for each num: add to heap via logic → End constructor. Then method add → push val → if size > k pop → return root. Use Decision nodes.\n\nProvide line-by-line with comments.\n\nLet's craft pseudocode lines:\n\nStart // 程式開始\n\n→ Step 1: 定義類別 KthLargest // 定義類別\n\n→ Step 2: 定義屬性 k, minHeap // 儲存 k 和最小堆\n\n→ Step 3: 建構子 KthLargest(k, nums) // 初始化\n\n→ Step 4: 設定 this.k ← k // 儲存 k\n\n→ Step 5: 建立空的最小堆 minHeap ← 空堆 // 初始化堆\n\n→ Decision: 如果 nums 空? // 檢查輸入陣列是否為空\n\n    Yes → End // 無元素時結束建構\n\n    No  → Decision: 如果 nums 長度 ≤ k? // 判斷是否少於等於 k 個元素\n\n        Yes → Step 6: 對每個 num in nums: minHeap push num // 直接加入堆\n\n        No  → Step 7: 對前 k 個 num in nums[0:k): minHeap push num // 加入前 k 個\n\n                → Step 8: 對剩餘 num in nums[k:]: // 後續處理\n\n                    → Decision: 如果 num > minHeap.top()? // 檢查是否比最小值大\n\n                        Yes → minHeap push num // 加入\n\n                            → minHeap pop // 移除最小\n\n                        No  → // 不做任何事\n\n→ End // 建構子結束\n\n→ Method add(val) // 定義新增方法\n\n→ Step 9: minHeap push val // 新增\n\n→ Decision: 如果 minHeap.size > k? // 判斷是否超過 k\n\n    Yes → minHeap pop // 移除最小\n\n→ Step 10: Return minHeap.top() // 回傳 k 大\n\n→ End // 程式結束\n\nBut we need line-by-line with arrow and comments. Each line should contain \"虛擬碼步驟\" + \" // 解釋\".\n\nWe need to use arrows like → and Decision: etc.\n\nLet's produce the pseudocode accordingly.\n\nMake sure to use \"Start\" and \"End\". Provide the virtual steps.\n\nLet's write:\n\nStart // 程式開始執行\n\n→ Step 1: 定義類別 KthLargest // 建立 KthLargest 類\n\n→ Step 2: 宣告屬性 k, minHeap // k 儲存目標順位，minHeap 儲存前 k 個最大值\n\n→ Step 3: 建構子 KthLargest(k, nums) // 初始化物件\n\n→ Step 4: this.k ← k // 設定目標順位\n\n→ Step 5: minHeap ← 新的空最小堆 // 建立堆\n\n→ Decision: 如果 nums 為空? // 檢查初始數據\n\n    Yes → End // 無初始數據直接結束建構\n\n    No → Decision: 如果 nums 長度 ≤ k? // 判斷元素數量是否不超過 k\n\n        Yes → Step 6: 對每個 num in nums: minHeap push num // 直接加入堆\n\n        No → Step 7: 對前 k 個 num in nums[0:k): minHeap push num // 加入前 k 個\n\n                → Step 8: 對剩餘 num in nums[k:]: // 處理後續元素\n\n                    → Decision: 如果 num > minHeap.top()? // 是否比堆頂小值大\n\n                        Yes → minHeap push num // 加入\n\n                            → minHeap pop // 移除最小，保持大小 k\n\n                        No  → // 不進行任何操作\n\n→ End // 建構子結束\n\n→ 方法 add(val) // 新增分數\n\n→ Step 9: minHeap push val // 將新分數加入堆\n\n→ Decision: 如果 minHeap.size > k? // 判斷是否超過 k 個\n\n    Yes → minHeap pop // 移除最小，保留前 k 個\n\n→ Step 10: Return minHeap.top() // 回傳第 k 大分數\n\n→ End // 程式結束\n\nLet's ensure format: each line with arrow, no extra indentation. Use spaces after arrow. Provide explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 KthLargest // 建立 KthLargest 類  \n→ Step 2: 宣告屬性 k, minHeap // k 儲存目標順位，minHeap 儲存前 k 個最大值  \n→ Step 3: 建構子 KthLargest(k, nums) // 初始化物件  \n→ Step 4: this.k ← k // 設定目標順位  \n→ Step 5: minHeap ← 新的空最小堆 // 建立堆  \n→ Decision: 如果 nums 為空? // 檢查初始數據  \n Yes → End // 無初始數據直接結束建構  \n No  → Decision: 如果 nums 長度 ≤ k? // 判斷元素數量是否不超過 k  \n  Yes → Step 6: 對每個 num in nums: minHeap push num // 直接加入堆  \n  No  → Step 7: 對前 k 個 num in nums[0:k): minHeap push num // 加入前 k 個  \n    → Step 8: 對剩餘 num in nums[k:]: // 處理後續元素  \n      Decision: 如果 num > minHeap.top()? // 是否比堆頂小值大  \n       Yes → minHeap push num // 加入  \n         minHeap pop // 移除最小，保持大小 k  \n       No  → // 不進行任何操作  \n→ End // 建構子結束  \n→ 方法 add(val) // 新增分數  \n→ Step 9: minHeap push val // 將新分數加入堆  \n→ Decision: 如果 minHeap.size > k? // 判斷是否超過 k 個  \n Yes → minHeap pop // 移除最小，保留前 k 個  \n→ Step 10: Return minHeap.top() // 回傳第 k 大分數  \n→ End // 程式結束",
      "generated_code": "import sys\nimport json\nimport heapq\nimport ast\n\nclass KthLargest:\n    \"\"\"\n    追蹤整個資料流中第 k 大的分數。\n    透過最小堆 (size k) 來維持前 k 大元素。\n    \"\"\"\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        # 先把所有初始數字加入堆中，確保堆大小不超過 k\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        \"\"\"\n        新增一筆分數，並回傳目前第 k 大的分數。\n        \"\"\"\n        heapq.heappush(self.min_heap, val)\n        # 若堆超過 k 個，移除最小元素\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        # 堆頂即為第 k 大元素\n        return self.min_heap[0]\n\ndef main():\n    \"\"\"\n    從 stdin 讀取兩個序列：方法名 list 與參數 list，\n    並執行 KthLargest 相關操作，最後以 JSON 形式輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 移除可能的換行，並且去除外層單引號/雙引號\n    data = data.replace('\\n', '').replace('\\r', '')\n    if data[0] in ('\"', \"'\") and data[-1] == data[0]:\n        data = data[1:-1]\n\n    try:\n        ops, args = ast.literal_eval(data)\n    except Exception as e:\n        # 無法解析輸入時直接終止\n        return\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"KthLargest\":\n            # arg 是 [k, nums]\n            obj = KthLargest(arg[0], arg[1])\n            result.append(None)  # LeetCode 風格返回 null\n        elif op == \"add\":\n            # arg 是 [val]\n            res = obj.add(arg[0])\n            result.append(res)\n        else:\n            # 忽略未知操作\n            pass\n\n    # 輸出 JSON 形式，將 None 轉成 null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "success": true,
          "output": "[null, 4, 5, 5, 8, 8]"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "success": true,
          "output": "[null, 7, 7, 7, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode315.json",
    "problem_index_in_file": 0,
    "title": "Count of Smaller Numbers After Self",
    "description_snippet": "Given an integer array nums, return an integer array counts where counts[i] is the number of smaller...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code step by step for the problem: For each element in array nums, count number of smaller elements to its right. Classic problem: use BIT or merge sort count. We need to produce pseudocode, not actual code, with explanation each line. Use Start, End, Decision. We should explain each line. The pseudocode should include steps: input array, maybe clone array, sort unique values, mapping to indices, iterate from right to left, update BIT, query count of smaller elements. Provide explanation. Or could use merge sort approach: recursively split, merge count. Might be simpler: use BIT.\n\nLet's produce pseudocode:\n\nStart // start\n→ Step 1: Input array nums // read input\n→ Step 2: Initialize result array counts of same length // store counts\n→ Step 3: Create sorted unique copy sortedNums of nums // for coordinate compression\n→ Step 4: Create map valueToIndex mapping each value to its index in sortedNums +1 // 1-indexed for BIT\n→ Step 5: Initialize BinaryIndexedTree bit with size sortedNums length // for prefix sums\n→ Step 6: For i from nums.length-1 downto 0 // iterate from right to left\n    → Step 6a: idx = valueToIndex[nums[i]] // get compressed index\n    → Step 6b: counts[i] = bit.query(idx-1) // count smaller values seen so far\n    → Step 6c: bit.update(idx, 1) // add current value to BIT\n→ Step 7: Return counts // output result\nEnd // finish\n\nNeed explanation after each line. Use arrow for steps. Use indentation for decisions if any, but there aren't many decisions. The pseudocode lines can be numbered, but format requires no numbering? Format example shows \"→ Step 1: ...\". So use \"→ Step n: ...\". Provide explanation after space. Provide \"Start\" and \"End\". For each line include explanation.\n\nMake sure to use 1-indexed BIT query.\n\nAdd decisions: maybe Decision: If i < 0? but not needed.\n\nWe can optionally add a Decision for if array empty. But not necessary.\n\nWe can add a Decision: If nums empty? Return empty array. That could be a decision block.\n\nLet's incorporate:\n\n→ Decision: nums is empty? // Check for empty input\n    Yes → Return empty array // If no elements, result is empty\n    No  → Continue // otherwise proceed\n\nSo include that. Provide explanation. Ok.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input array nums // 從使用者或函式傳入整數陣列  \n→ Step 2: If nums is empty? // 檢查是否為空陣列  \n  Yes → Return empty array // 空陣列直接回傳空結果  \n  No  → Continue // 不是空陣列，繼續執行  \n\n→ Step 3: Initialize result array counts with length = nums.length // 用來存每個位置的計數  \n→ Step 4: Create sorted unique copy sortedNums of nums // 為了壓縮座標，先將所有值排序並去重  \n→ Step 5: Build map valueToIndex: value → 1-based index in sortedNums // 為每個原始值對應一個 BIT 可用索引  \n→ Step 6: Initialize BinaryIndexedTree bit with size = sortedNums.length // BIT 用於快速求前綴和  \n\n→ Step 7: For i from nums.length-1 downto 0 // 從右往左遍歷原陣列  \n  → Step 7a: idx = valueToIndex[nums[i]] // 取得壓縮後的索引  \n  → Step 7b: counts[i] = bit.query(idx-1) // 查詢已加入 BIT 的小於此值的個數  \n  → Step 7c: bit.update(idx, 1) // 把目前元素加入 BIT，表示已看到一個此值  \n\n→ Step 8: Return counts // 回傳所有位置的小於右側元素的個數  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass BIT:\n    \"\"\"Binary Indexed Tree for prefix sums.\"\"\"\n    def __init__(self, size: int):\n        self.size = size\n        self.tree = [0] * (size + 1)\n\n    def update(self, index: int, delta: int) -> None:\n        \"\"\"Add delta to element at index.\"\"\"\n        while index <= self.size:\n            self.tree[index] += delta\n            index += index & -index\n\n    def query(self, index: int) -> int:\n        \"\"\"Return sum of elements from 1 to index.\"\"\"\n        result = 0\n        while index > 0:\n            result += self.tree[index]\n            index -= index & -index\n        return result\n\nclass Solution:\n    def countSmaller(self, nums):\n        \"\"\"Return list of counts of smaller elements to the right.\"\"\"\n        if not nums:\n            return []\n\n        # Coordinate compression: map each unique value to its rank\n        sorted_unique = sorted(set(nums))\n        rank = {num: i + 1 for i, num in enumerate(sorted_unique)}\n\n        bit = BIT(len(rank))\n        res = []\n\n        # Iterate from right to left\n        for num in reversed(nums):\n            r = rank[num]\n            res.append(bit.query(r - 1))  # smaller elements seen so far\n            bit.update(r, 1)              # add current element\n\n        return res[::-1]  # reverse to original order\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        return\n\n    # Extract the list part between brackets\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        # Invalid format, treat as empty list\n        nums = []\n    else:\n        list_str = data[start:end+1]\n        nums = ast.literal_eval(list_str)\n\n    # Compute result\n    solution = Solution()\n    result = solution.countSmaller(nums)\n\n    # Print in the required format: no spaces after commas\n    formatted = '[' + ','.join(map(str, result)) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,2,6,1]",
          "expected_output": "[2,1,1,0]",
          "success": true,
          "output": "[2,1,1,0]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-1]",
          "expected_output": "[0,0]",
          "success": true,
          "output": "[0,0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode537.json",
    "problem_index_in_file": 0,
    "title": "Complex Number Multiplication",
    "description_snippet": "A complex number can be represented as a string on the form \"real+imaginaryi\" where:\n\nreal is the re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo-code for multiplying two complex numbers given as strings \"real+imaginaryi\". Need to parse, multiply, format output. Provide each line with comment. Use Start, Decision, etc.\n\nLet's craft steps: Start, input num1, num2. Parse function: split at '+', but real could be negative? format: maybe \"-3+4i\". So split by '+'; but if real negative, first part may start with '-'. Use split by '+'. Then extract imaginary part by removing trailing 'i'. Convert to int. Multiply: (a+bi)*(c+di) = (ac - bd) + (ad + bc)i. Compute. Format: sign of imaginary part: if positive, output as \"+<imag>i\", if negative, \"-<abs>i\". Real part no sign if positive, negative as usual. Edge: zero imaginary? still \"real+0i\"? maybe required. Use \"real+imaginaryi\" regardless of sign? The string form includes plus sign before imaginary even if negative? Example \"3-4i\" might be \"3-4i\"? They say form \"real+imaginaryi\" where imaginary is integer. So if negative, would be \"real-4i\"? But they wrote \"+imaginaryi\" maybe always plus sign? We'll produce real + sign? Better to produce \"real+imaginaryi\" with imaginary possibly negative, but keep '+'? Might produce \"3-4i\". Use conditional: if imag>=0, sign '+', else '-' and abs.\n\nOk produce pseudo.\n\nLet's output line by line.\n\nUse arrow for steps. Provide decisions for parsing? Might not need heavy decision. But we can include.\n\nWe'll produce:\n\nStart\n→ Step 1: num1 = input string\n→ Step 2: num2 = input string\n→ Step 3: Parse num1 into a, b // real and imaginary parts of first number\n→ Step 4: Parse num2 into c, d // real and imaginary parts of second number\n→ Step 5: Compute real_part = a * c - b * d // real part of product\n→ Step 6: Compute imag_part = a * d + b * c // imaginary part of product\n→ Step 7: Format result string // construct \"real_part+imag_parti\" with correct sign\n→ End\n\nBut include Decision for formatting sign.\n\nAlso parse: split at '+', but might have negative real part: e.g., \"-3+4i\". So split at '+', then parse parts. Imag part ends with 'i'. So:\n\n→ Decision: if num contains '+'? Always? yes.\n\nLet's produce parse function:\n\n→ Step 3.1: Split num1 at '+' to get parts [real_str, imag_with_i]\n→ Step 3.2: real_part1 = int(real_str)\n→ Step 3.3: imag_part1 = int(imag_with_i without trailing 'i')\nSimilarly for num2.\n\nOk.\n\nNow produce formatting:\n\n→ Decision: If imag_part >= 0? // decide sign\n\nBut can use inline.\n\nOk produce.\n\nNeed to maintain \"Start\", \"End\" with arrow? In example they used Start // ... then arrow lines. We can start with \"Start\" then arrow lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: num1 = input() // 取得第一個複數字串\n→ Step 2: num2 = input() // 取得第二個複數字串\n\n→ Step 3: // 解析 num1 為實部 a 與虛部 b\n    → Step 3.1: parts1 = split(num1, '+') // 以 '+' 分割為 [實部字串, 虛部字串]\n    → Step 3.2: a = int(parts1[0]) // 轉為整數\n    → Step 3.3: b_str = remove_last_char(parts1[1]) // 去掉尾端 'i'\n    → Step 3.4: b = int(b_str) // 轉為整數\n\n→ Step 4: // 解析 num2 為實部 c 與虛部 d\n    → Step 4.1: parts2 = split(num2, '+') // 以 '+' 分割為 [實部字串, 虛部字串]\n    → Step 4.2: c = int(parts2[0]) // 轉為整數\n    → Step 4.3: d_str = remove_last_char(parts2[1]) // 去掉尾端 'i'\n    → Step 4.4: d = int(d_str) // 轉為整數\n\n→ Step 5: // 計算乘積的實部\n    → Step 5.1: real_part = a * c - b * d // ac - bd\n\n→ Step 6: // 計算乘積的虛部\n    → Step 6.1: imag_part = a * d + b * c // ad + bc\n\n→ Step 7: // 將結果格式化為 \"real_part+imag_parti\"\n    → Decision: 如果 imag_part >= 0? // 判斷虛部符號\n        Yes → Step 7.1: imag_str = \"+\" + str(imag_part) + \"i\" // 加上正號\n        No  → Step 7.2: imag_str = \"-\" + str(abs(imag_part)) + \"i\" // 加上負號\n    → Step 7.3: result = str(real_part) + imag_str // 組合為完整字串\n\n→ Step 8: output(result) // 印出乘積結果\n\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        # 解析複數字串成 (real, imag)\n        def parse(s: str):\n            real_part, imag_part = s.split('+')\n            return int(real_part), int(imag_part[:-1])  # 去掉尾端的 'i'\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        # 乘法公式： (a+bi)(c+di) = (ac-bd) + (ad+bc)i\n        real = a_real * b_real - a_imag * b_imag\n        imag = a_real * b_imag + a_imag * b_real\n\n        return f\"{real}+{imag}i\"\n\n\ndef main():\n    # 讀取所有輸入，無論是單行還是多行\n    raw = sys.stdin.read()\n    # 將換行視為逗號分隔，方便統一處理\n    parts = [p.strip().strip('\"') for p in raw.replace('\\n', ',').split(',') if p.strip()]\n    if len(parts) < 2:\n        raise ValueError(\"輸入必須包含兩個複數字串\")\n    num1, num2 = parts[0], parts[1]\n\n    solution = Solution()\n    result = solution.complexNumberMultiply(num1, num2)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"1+1i\", \"1+1i\"",
          "expected_output": "\"0+2i\"",
          "success": true,
          "output": "0+2i"
        },
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "success": true,
          "output": "0+-2i"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode609.json",
    "problem_index_in_file": 0,
    "title": "Find Duplicate File in System",
    "description_snippet": "Given a list paths of directory info, including the directory path, and all the files with contents ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with comments. The task: Given list of directory info strings, return duplicate file paths grouped by content. Steps: parse each string, split into path and file specs, then map content to list of full paths, then collect groups of size>=2. We'll output as list of lists.\n\nWe must use Start, End, Decision etc. Provide each step line.\n\nLet's craft.\n\n- Start\n- → Step 1: Initialize empty map content_to_paths\n- For each dirInfo in paths:\n  - → Step 2: Split dirInfo by space into parts\n  - → Step 3: Set basePath = first part\n  - → Step 4: For each fileSpec in remaining parts:\n      - → Step 5: Extract fileName and fileContent\n          - → Step 6: fullPath = basePath + \"/\" + fileName\n          - → Step 7: If fileContent not in map, create list\n          - → Step 8: Append fullPath to map[fileContent]\n- Step 9: Initialize result list\n- Step 10: For each entry in map:\n     - → Decision: 如果該內容對應的路徑數量 >= 2 ?\n        - Yes → Step 11: Append list of paths to result\n- End\n\nAdd comments.\n\nAlso maybe step 1: Output the final list.\n\nBut final step: Return result.\n\nOk.\n\nLet's produce each line with arrow and comments. Use \"Start\" \"End\". Use \"→\" arrow. Decision lines indent. Provide comments after //.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 content_to_paths 以映射檔案內容 → String → List of String // 用於聚集相同內容的檔案路徑\n→ Step 2: 對於輸入列表 paths 中的每一個 dirInfo:\n    → Step 3: 將 dirInfo 按空格分割成 parts // 第一個元素為目錄路徑，其餘為檔案描述\n    → Step 4: 設定 basePath = parts[0] // 取得該條目所在的目錄完整路徑\n    → Step 5: 從 parts[1:] 逐一處理每個 fileSpec:\n        → Step 6: 用 '(' 與 ')' 分割 fileSpec 成 name 與 content // 例如 \"a.txt(abcd)\" → name=\"a.txt\", content=\"abcd\"\n        → Step 7: 建立 fullPath = basePath + \"/\" + name // 產生完整檔案路徑\n        → Step 8: Decision: content 是否已存在於 content_to_paths?\n            Yes → Step 9: 直接將 fullPath 加入已存在的列表\n            No  → Step 10: 建立新列表 [fullPath] 並加入字典\n→ Step 11: 建立空列表 result 以儲存重複檔案組群 // 只保留至少兩個檔案的內容\n→ Step 12: 遍歷 content_to_paths 的每一個 key-value:\n    → Decision: value.length >= 2? // 判斷是否有重複檔案\n        Yes → Step 13: 將 value（完整路徑列表）加入 result\n        No  → Step 14: 跳過該內容\n→ Step 15: 回傳 result // 最終輸出重複檔案的路徑群組\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    \"\"\"\n    解題思路：\n    1. 建立字典 content_to_paths，鍵為檔案內容，值為該內容對應的完整檔案路徑列表。\n    2. 逐行解析輸入的 directory info 字串。\n       - 以空格切割得到 basePath 與每個檔案描述。\n       - 進一步以 '(' 與 ')' 切割取得檔名與內容。\n       - 組合 basePath + '/' + fileName 得到完整路徑，加入對應內容的列表。\n    3. 最後收集 content_to_paths 中長度大於等於 2 的路徑列表，回傳結果。\n    \"\"\"\n    def findDuplicate(self, paths):\n        # 內容對應路徑的字典\n        content_to_paths = defaultdict(list)\n\n        # 逐個 directory info 解析\n        for dir_info in paths:\n            parts = dir_info.split()\n            if not parts:\n                continue\n            base_path = parts[0]                    # 目錄路徑\n            for file_desc in parts[1:]:\n                # 檔名與內容用 '(' 分隔，末尾多一個 ')'\n                name, content = file_desc.split('(')\n                content = content[:-1]             # 去掉結尾 ')'\n                full_path = f\"{base_path}/{name}\"\n                content_to_paths[content].append(full_path)\n\n        # 收集重複檔案組群\n        result = [paths for paths in content_to_paths.values() if len(paths) > 1]\n        return result\n\ndef parse_input(raw_input: str):\n    \"\"\"\n    解析從 stdin 讀取的輸入字串，返回 paths 列表。\n    支援 'paths = [...]' 或直接寫列表的形式。\n    \"\"\"\n    raw_input = raw_input.strip()\n    if '=' in raw_input:\n        _, expr = raw_input.split('=', 1)\n        raw_input = expr.strip()\n    # 用 ast.literal_eval 解析 Python literal\n    try:\n        return ast.literal_eval(raw_input)\n    except Exception as e:\n        raise ValueError(f\"無法解析輸入: {e}\")\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    raw = sys.stdin.read()\n    if not raw:\n        sys.exit(0)\n    paths = parse_input(raw)\n    solution = Solution()\n    duplicates = solution.findDuplicate(paths)\n    print(duplicates)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode208.json",
    "problem_index_in_file": 0,
    "title": "Implement Trie (Prefix Tree)",
    "description_snippet": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and r...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Should implement Trie class with methods. Use virtual code structure. Each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nWe need to show Start, End, Decision etc. Provide steps to implement class. Likely include data structure Node with children map and end flag. Insert, search, startsWith logic.\n\nWe should produce lines such as:\n\nStart // 程式開始執行\n→ Step 1: Define class Trie // 建立 Trie 類別\n→ Step 2: Define inner class Node // 定義 Trie 節點\n→ Step 3: Node fields: children map, isEnd // 儲存子節點及是否為單詞結尾\n→ Step 4: Trie constructor // 初始化根節點\n→ Step 5: Method insert(word) // 插入單詞\n   → Step 5a: current ← root // 從根開始\n   → Loop over characters in word // 逐字處理\n      → Decision: current.children contains char?\n         Yes → current ← child // 移到已存在子節點\n         No  → create new Node, add to children, current ← new node // 建立新節點\n   → After loop, current.isEnd ← true // 標記單詞結尾\n→ Step 6: Method search(word) // 搜尋完整單詞\n   → current ← root\n   → Loop over chars\n      → Decision: child exists?\n         Yes → current ← child\n         No  → Return false\n   → Return current.isEnd // 判斷是否為完整單詞\n→ Step 7: Method startsWith(prefix) // 判斷前綴\n   → current ← root\n   → Loop over chars\n      → Decision: child exists?\n         Yes → current ← child\n         No  → Return false\n   → Return true // 所有字均存在，前綴成立\nEnd // 程式執行結束\n\nMake sure each line uses '→' arrow. For decision branches, we need indent lines with 4 spaces? In sample, decision block lines are indented with 4 spaces then arrow and condition. We'll follow same.\n\nThus produce as lines accordingly.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class Trie // 建立 Trie 類別  \n→ Step 2: Define inner class Node // 定義 Trie 節點  \n→ Step 3: Node fields: children ← map of char to Node, isEnd ← false // 儲存子節點與單詞結尾標誌  \n→ Step 4: Trie constructor // 初始化根節點  \n  → root ← new Node() // 創建空根節點  \n→ Step 5: Method insert(word) // 插入單詞  \n  → current ← root // 從根節點開始  \n  → Loop over each character ch in word // 逐字處理  \n    → Decision: current.children contains ch? // 檢查是否已有該字母節點  \n      Yes → current ← current.children[ch] // 移動到現有子節點  \n      No  → newNode ← new Node(); current.children[ch] ← newNode; current ← newNode // 建立新節點  \n  → After loop, current.isEnd ← true // 標記單詞結尾  \n→ Step 6: Method search(word) // 搜尋完整單詞  \n  → current ← root  \n  → Loop over each character ch in word  \n    → Decision: current.children contains ch?  \n      Yes → current ← current.children[ch]  \n      No  → Return false // 字串不在 Trie  \n  → Return current.isEnd // 若到達結尾則為完整單詞  \n→ Step 7: Method startsWith(prefix) // 判斷是否有以 prefix 為前綴的單詞  \n  → current ← root  \n  → Loop over each character ch in prefix  \n    → Decision: current.children contains ch?  \n      Yes → current ← current.children[ch]  \n      No  → Return false // 前綴不符  \n  → Return true // 所有字均存在，前綴成立  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    \"\"\"Trie 的節點，包含子節點字典與是否為單詞結尾的標誌\"\"\"\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    \"\"\"前綴樹實作，支援插入、搜尋及前綴查詢\"\"\"\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入轉成兩個列表：指令與對應參數\n    expr = '(' + data + ')'\n    try:\n        ops, args = ast.literal_eval(expr)\n    except Exception:\n        print('[]')\n        return\n\n    result = []\n    trie = None\n    for op, arg in zip(ops, args):\n        if op == 'Trie':\n            trie = Trie()\n            result.append(None)\n        elif op == 'insert':\n            trie.insert(arg[0] if isinstance(arg, (list, tuple)) else arg)\n            result.append(None)\n        elif op == 'search':\n            res = trie.search(arg[0] if isinstance(arg, (list, tuple)) else arg)\n            result.append(res)\n        elif op == 'startsWith':\n            res = trie.startsWith(arg[0] if isinstance(arg, (list, tuple)) else arg)\n            result.append(res)\n        else:\n            # 針對未知指令，直接加入 None\n            result.append(None)\n\n    # 將結果轉成 LeetCode 風格的輸出格式\n    out_items = []\n    for r in result:\n        if r is None:\n            out_items.append('null')\n        elif isinstance(r, bool):\n            out_items.append('true' if r else 'false')\n        else:\n            out_items.append(str(r))\n    print('[' + ', '.join(out_items) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "success": true,
          "output": "[null, null, true, false, true, null, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode268.json",
    "problem_index_in_file": 0,
    "title": "Missing Number",
    "description_snippet": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the missing number problem. The algorithm: XOR all numbers from 0..n, XOR all array elements, result is missing number. Provide step-by-step virtual code lines with explanation. Use arrows. Format: Start, Step 1 etc. Should produce line by line. Use \"Step\" lines and decisions maybe. Provide explanation after //.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 計算 n = array length // 取得陣列長度\n→ Step 2: 初始化 missing = 0 // 用於累積 XOR 結果\n→ Step 3: 從 i = 0 到 i = n 逐次 XOR 到 missing // 包含範圍內所有數字\n→ Step 4: 對陣列 nums 中的每個數字 x, 進行 missing XOR= x // 排除已存在的數字\n→ Step 5: 將 missing 輸出 // missing 為缺失的數字\nEnd // 程式結束\n\nWe might include a loop description lines. But we can just describe loops in explanation.\n\nLet's output each line.\n\nEnsure each line contains \"虛擬碼步驟\" and // explanation. Use arrow \"→\" preceding each step except Start and End? Format example uses \"Start\" on its own line, then arrow for each step. We'll follow.\n\nMake sure not to output any actual code. Use pseudo steps.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 計算 n = nums 的長度 // 取得陣列長度 n\n→ Step 2: 初始化 missing = 0 // 用於累積 XOR 結果\n→ Step 3: 依序對 i 從 0 到 n 做 missing ← missing XOR i // 將範圍內所有數字進行 XOR\n→ Step 4: 依序對 nums 中的每個元素 x 做 missing ← missing XOR x // 移除已存在的數字\n→ Step 5: 輸出 missing // missing 即為缺失的數字\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef missingNumber(nums):\n    \"\"\"\n    計算 0~n 之總和，然後減去陣列中所有元素的總和，即得到缺失的數字。\n    \"\"\"\n    n = len(nums)\n    total = n * (n + 1) // 2\n    return total - sum(nums)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    # 從輸入字串中提取所有數字（假設輸入形式為「nums = [ ... ]」）\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    # 計算缺失的數字\n    result = missingNumber(nums)\n    # 將結果輸出到標準輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [9,6,4,2,3,5,7,0,1]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode470.json",
    "problem_index_in_file": 0,
    "title": "Implement Rand10() Using Rand7()",
    "description_snippet": "Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating uniform random integer 1-10 using rand7. Classic solution: use two calls to generate 49 outcomes; if <=40 accept and map to 1-10 via modulo; else reject and repeat. So produce step-by-step. Use virtual code lines with explanation. Provide Start, End, Decision, etc.\n\nAlso we may need to include function definition: rand10() -> number. Use loop.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 rand10() // 定義產生 1~10 的函式  \n→     → Step 2: 初始化變數 result // 佔位變數儲存結果  \n→     → Decision: 進入 while 迴圈，直到產生合法值? // 重複直到得到可接受的數字  \n→         Yes → Step 3: 產生 x = rand7() // 第一次 rand7() 呼叫  \n→         → Step 4: 產生 y = rand7() // 第二次 rand7() 呼叫  \n→         → Step 5: 計算 combined = (x-1)*7 + y // 將兩個 1~7 轉成 1~49 的序號  \n→         → Decision: combined 是否 ≤ 40? // 只接受前 40 個值，保證均勻分佈  \n→             Yes → Step 6: result = ((combined-1) % 10) + 1 // 映射到 1~10  \n→                 → Step 7: 返回 result // 回傳隨機數  \n→                 → Step 8: 退出 while 迴圈  \n→             No → Step 9: 迴圈重複（回到 Decision） // 超過 40 時重新產生  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport random\n\n# ---------- API: rand7() ----------\n# 在實際測試環境中，這個函式會被題目提供。此處僅作示範使用 Python 的隨機模組實作。\ndef rand7() -> int:\n    \"\"\"Return a uniform random integer in [1, 7].\"\"\"\n    return random.randint(1, 7)\n\n\n# ---------- Solution ----------\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        Generate a uniform random integer in [1, 10] using only rand7().\n        The method uses the classic rejection sampling technique:\n        1. Generate a number in [1, 49] with two calls to rand7().\n        2. If the number is <= 40, map it to [1, 10] via modulo.\n        3. Otherwise, repeat the process.\n        \"\"\"\n        while True:\n            # First call: x in [1, 7]\n            x = rand7()\n            # Second call: y in [1, 7]\n            y = rand7()\n            # Combine to get a uniform number in [1, 49]\n            num = (x - 1) * 7 + y  # 1 ~ 49\n            if num <= 40:\n                # Map 1~40 to 1~10 uniformly\n                return 1 + (num - 1) % 10\n            # If num > 40, discard and retry\n\n\n# ---------- Main ----------\ndef main() -> None:\n    \"\"\"\n    Reads an input line in the form 'n = X', where X is an integer.\n    Calls rand10() X times and prints the resulting list.\n    \"\"\"\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # Extract the integer value of n\n    # Supports formats like 'n = 3', 'n=3', '  n =   10  '\n    try:\n        n_str = raw_input.split('=')[1].strip()\n        n = int(n_str)\n    except (IndexError, ValueError):\n        # If parsing fails, exit silently\n        return\n\n    solution = Solution()\n    results = [solution.rand10() for _ in range(n)]\n\n    # Print the list in Python literal format\n    print(results)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[4]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[4]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[3,2]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[3, 2]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[9,4,10]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[9, 4, 10]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode7.json",
    "problem_index_in_file": 0,
    "title": "Reverse Integer",
    "description_snippet": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nThe user wants pseudocode for reversing digits of 32-bit signed integer with overflow detection, cannot use 64-bit integers. They want each line of virtual code with explanation. Use Start, End, Decision, etc. Use arrow →. Format each line: \"虛擬碼步驟 // 解釋\". They want line by line. Ensure that each step includes the pseudocode and explanation.\n\nWe need to think about algorithm: use repeated mod 10, divide by 10. But to avoid overflow, we can check before appending new digit. Since cannot use 64-bit, we need to check if result > INT_MAX/10 or result < INT_MIN/10 etc. Approach: store sign separately, reverse absolute value? But using 32-bit, we can handle sign in same. We can maintain negative case. Common solution: result = 0; while x != 0: pop = x % 10; x /= 10; if result > INT_MAX/10 or (result == INT_MAX/10 and pop > 7) return 0; if result < INT_MIN/10 or (result == INT_MIN/10 and pop < -8) return 0; result = result*10 + pop; return result. This uses only 32-bit. We must explain each step.\n\nWe need to output line by line. Use arrow \"→\". Use \"Decision:\" for if. Use \"Yes →\" \"No →\".\n\nLet's craft lines:\n\nStart\n→ Set sign? Actually we can keep x as int. So:\n\n→ Initialize result = 0 // 32-bit int\n\n→ Decision: While x ≠ 0? We need loop.\n\nWe might write:\n\n→ While x ≠ 0: // Process each digit\n\nInside loop: pop = x % 10; // Get last digit\n\n→ x = x / 10; // Remove last digit\n\nCheck overflow before multiply and add.\n\n→ Decision: 如果 result > INT_MAX/10? // overflow check\n\nWe need to incorporate both > and == conditions. Maybe break into steps.\n\nWe'll produce pseudocode steps:\n\nStart\n→ result ← 0 // 用來累積反轉後的數值\n→ Decision:  while x ≠ 0? // 如果還有數位要處理\n   Yes → pop ← x mod 10 // 取得最後一位數\n   → x ← x div 10 // 去除已取出的位數\n   → Decision: result > INT_MAX/10? // 檢查乘10後是否會溢位\n      Yes → result ← 0; break // 溢位則直接回傳0\n      No → Decision: result = INT_MAX/10 AND pop > 7? // 進一步檢查最後一位\n          Yes → result ← 0; break\n          No →\n   → Decision: result < INT_MIN/10? // 檢查負值溢位\n      Yes → result ← 0; break\n      No → Decision: result = INT_MIN/10 AND pop < -8? // 進一步檢查最後一位\n          Yes → result ← 0; break\n          No →\n   → result ← result * 10 + pop // 更新累積值\n→ End // 迴圈結束\n→ Return result\n\nBut the user wants virtual code lines with arrows and decisions. We should use \"Decision:\" lines, with \"Yes →\" and \"No →\". For break we can set result to 0 and maybe jump to End. Since we can't use 64-bit, we need to handle overflow by early exit.\n\nLet's structure:\n\nStart // 程式開始執行\n→ result ← 0 // 初始化累積變數\n→ Decision: x ≠ 0? // 若 x 還有數位\n    Yes →\n        pop ← x mod 10 // 取得最後一位\n        x ← x div 10 // 去除最後一位\n        → Decision: result > INT_MAX/10? // 檢查正向溢位\n            Yes → result ← 0; // 設為 0\n                → End // 結束程式\n            No →\n                → Decision: result = INT_MAX/10 AND pop > 7? // 更細緻檢查\n                    Yes → result ← 0; // 設為 0\n                        → End\n                    No →\n        → Decision: result < INT_MIN/10? // 檢查負向溢位\n            Yes → result ← 0;\n                → End\n            No →\n                → Decision: result = INT_MIN/10 AND pop < -8? // 更細緻檢查\n                    Yes → result ← 0;\n                        → End\n                    No →\n        → result ← result * 10 + pop // 更新累積值\n        → Decision: x ≠ 0? // 迴圈繼續\n            Yes → 回到上一階段\n            No → → End\n→ Return result // 傳回結果\n\nBut we need each line as \"虛擬碼步驟 // 解釋\". We can compress some lines. Use \"→\" for each new step. Use indentation maybe not necessary but can show arrow chain.\n\nLet's format properly:\n\nStart // 程式開始執行\n→ result ← 0 // 初始化累積結果\n→ Decision: x ≠ 0? // 若 x 還有數位\n    Yes →\n        pop ← x mod 10 // 取出最後一位\n        x ← x div 10 // 去掉最後一位\n        → Decision: result > INT_MAX/10? // 檢查正向溢位條件\n            Yes →\n                result ← 0 // 溢位，結果置為 0\n                → End // 結束執行\n            No →\n                → Decision: result = INT_MAX/10 AND pop > 7? // 最後一位進一步檢查\n                    Yes →\n                        result ← 0\n                        → End\n                    No →\n        → Decision: result < INT_MIN/10? // 檢查負向溢位條件\n            Yes →\n                result ← 0\n                → End\n            No →\n                → Decision: result = INT_MIN/10 AND pop < -8? // 最後一位進一步檢查\n                    Yes →\n                        result ← 0\n                        → End\n                    No →\n        → result ← result * 10 + pop // 累加新位\n        → Decision: x ≠ 0? // 仍有位數？\n            Yes → // 迴圈重複\n            No → // 迴圈結束\n→ End // 程式執行結束\n→ Return result // 回傳反轉後的數字\n\nHowever we should ensure each line has arrow \"→\". Also the \"Decision:\" lines have \"Yes →\" etc. We need to maintain each line. We may separate \"→ End\" lines. Provide explanation.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ result ← 0 // 初始化累積結果為 0\n→ Decision: x ≠ 0? // 如果 x 還有數位要處理\n    Yes →\n        pop ← x mod 10 // 取得 x 的最後一位數字\n        x ← x div 10 // 去掉已取出的最後一位\n        → Decision: result > INT_MAX/10? // 檢查乘 10 後是否會正向溢位\n            Yes →\n                result ← 0 // 溢位時設定結果為 0\n                → End // 結束程式\n            No →\n                → Decision: result = INT_MAX/10 AND pop > 7? // 進一步檢查最後一位\n                    Yes →\n                        result ← 0\n                        → End\n                    No →\n        → Decision: result < INT_MIN/10? // 檢查乘 10 後是否會負向溢位\n            Yes →\n                result ← 0\n                → End\n            No →\n                → Decision: result = INT_MIN/10 AND pop < -8? // 進一步檢查最後一位\n                    Yes →\n                        result ← 0\n                        → End\n                    No →\n        → result ← result * 10 + pop // 將新的位數加入累積結果\n        → Decision: x ≠ 0? // 判斷是否還有剩餘位數\n            Yes → // 若有，繼續迴圈\n            No → // 若無，結束迴圈\n→ End // 程式執行結束\n→ Return result // 傳回反轉後的數字\n```",
      "generated_code": "import sys\nimport re\n\nINT_MAX = 2 ** 31 - 1\nINT_MIN = -2 ** 31\n\ndef reverse(x: int) -> int:\n    \"\"\"\n    Reverse digits of a signed 32‑bit integer.\n    Return 0 if the reversed integer overflows.\n    \"\"\"\n    result = 0\n    while x != 0:\n        pop = x % 10          # 取得最後一位\n        x //= 10              # 去掉已取出的位\n\n        # 檢查正向溢位\n        if result > INT_MAX // 10 or (result == INT_MAX // 10 and pop > 7):\n            return 0\n        # 檢查負向溢位\n        if result < INT_MIN // 10 or (result == INT_MIN // 10 and pop < -8):\n            return 0\n\n        result = result * 10 + pop\n    return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if match:\n        x_val = int(match.group())\n        print(reverse(x_val))\n    else:\n        # 如果沒有找到整數，則輸出 0\n        print(0)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 123",
          "expected_output": "321",
          "success": true,
          "output": "321"
        },
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '0'"
        },
        {
          "example_index": 2,
          "input": "x = 120",
          "expected_output": "21",
          "success": true,
          "output": "21"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode67.json",
    "problem_index_in_file": 0,
    "title": "Add Binary",
    "description_snippet": "Given two binary strings a and b, return their sum as a binary string....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for adding two binary strings. Each line with explanation. We must use Start, End, Decision: and arrows. Must be line by line.\n\nSteps: Start, initialize carry=0, result empty, pointers i = len(a)-1, j = len(b)-1. While i>=0 or j>=0 or carry>0: compute sum of bits. We can use Decision: check if i>=0. If Yes get bitA, else 0. Same for bitB. Sum = bitA+bitB+carry. New bit = sum%2, carry = sum/2. Append bit to result. Decrement i, j. After loop, reverse result. Return. End.\n\nMake each step as a virtual code line.\n\nWe must produce explanation after each line. Let's generate.\n\nLine 1: Start\n\nLine 2: → Initialize i ← length of a - 1 // Set pointer to last index of a\n\nLine 3: → Initialize j ← length of b - 1 // Set pointer to last index of b\n\nLine 4: → Initialize carry ← 0 // No carry initially\n\nLine 5: → Initialize result ← empty string // Will store sum bits in reverse\n\nLine 6: → Decision: 是否還有位需要處理? // Check if any digits left or carry\n\nThen inside loop:\n\nWe need loop structure. We'll use \"While\" as decision? Use Decision: i>=0 or j>=0 or carry>0.\n\nLine 6: → Decision: i ≥ 0 OR j ≥ 0 OR carry ≠ 0? // Continue while digits or carry remain\n\n    Yes → Step inside loop.\n\nInside loop: we need to get bitA, bitB.\n\nLine 7:     → Decision: i ≥ 0? // Check if a still has digits\n\n        Yes → Step: bitA ← a[i] //取a的最低位\n\n        No  → Step: bitA ← 0 //若a結束則為0\n\nSimilarly for b.\n\nLine 8:     → Decision: j ≥ 0? // Check if b still has digits\n\n        Yes → Step: bitB ← b[j] //取b的最低位\n\n        No  → Step: bitB ← 0 //若b結束則為0\n\nNow compute sum.\n\nLine 9:     → Step: sum ← bitA + bitB + carry //計算目前位的總和\n\nLine 10:    → Step: carry ← sum / 2 //更新進位，整數除法\n\nLine 11:    → Step: result ← (sum % 2) + result //把位元加到結果前面\n\nLine 12:    → Step: i ← i - 1 //移動a指標\n\nLine 13:    → Step: j ← j - 1 //移動b指標\n\nThen loop repeats until decision false.\n\nAfter loop, we might need to reverse result? We appended to front so no reverse needed. We used (sum % 2)+result.\n\nBut maybe simpler to append to end and reverse later. We'll use front to avoid reverse.\n\nThus after loop:\n\nLine 14: End // 返回結果（result已是正確順序）\n\nBut we need a return statement? Use Step: Return result // 返回二進位和\n\nThus End.\n\nBut we need to show End after return.\n\nLet's produce:\n\nStart\n→ Initialize i ← length of a - 1 // ...\n…\n\nAt the end:\n\n→ Step: Return result // 返回最終二進位字串\nEnd // 程式執行結束\n\nWe must ensure each line has one virtual code step.\n\nWe must include arrow \"→\" before each step.\n\nAlso use \"Decision:\" lines.\n\nLet's write carefully.\n\nCheck format: \"虛擬碼步驟 [空格] // 解釋/說明\"\n\nThus we write:\n\nStart // 程式開始執行\n→ Initialize i ← length of a - 1 // 設定指向 a 最後一位的索引\n→ Initialize j ← length of b - 1 // 設定指向 b 最後一位的索引\n→ Initialize carry ← 0 // 初始進位為 0\n→ Initialize result ← \"\" // 用來儲存結果的字串\n→ Decision: i ≥ 0 OR j ≥ 0 OR carry ≠ 0? // 判斷是否還有位數或進位需要處理\n    Yes → Decision: i ≥ 0? // 是否還有 a 的位數\n        Yes → Step: bitA ← a[i] // 取 a 的當前位\n        No  → Step: bitA ← 0 // a 已結束，位數視為 0\n    Yes → Decision: j ≥ 0? // 是否還有 b 的位數\n        Yes → Step: bitB ← b[j] // 取 b 的當前位\n        No  → Step: bitB ← 0 // b 已結束，位數視為 0\n    Yes → Step: sum ← bitA + bitB + carry // 計算三個數之和\n    Yes → Step: carry ← sum / 2 // 更新進位（整除 2）\n    Yes → Step: result ← (sum % 2) + result // 把本位結果加到前面\n    Yes → Step: i ← i - 1 // 移動 a 指標\n    Yes → Step: j ← j - 1 // 移動 b 指標\n    No  → Step: Return result // 迴圈結束，返回最終結果\nEnd // 程式執行結束\n\nBut we need to maintain decision structure: The loop should be repeated; we need to place the loop. Our format uses \"Decision:\" with Yes/No.\n\nWe must express loop by having decision: Yes branch that contains all steps and then back to decision. But the given example uses nested decisions but not explicit loop.\n\nSimplify: Use while loop concept: Decision: i>=0 OR j>=0 OR carry≠0? // loop condition\n\nThen in Yes branch we do steps and then back to decision. In No branch we end and return.\n\nBut we need to indicate return outside loop.\n\nLet's structure:\n\nStart\n→ Initialize i ← len(a)-1\n→ Initialize j ← len(b)-1\n→ Initialize carry ← 0\n→ Initialize result ← \"\"\n→ Decision: i ≥ 0 OR j ≥ 0 OR carry ≠ 0? // 需要繼續加法？\n    Yes → Decision: i ≥ 0? // 取 a 的位\n        Yes → Step: bitA ← a[i]\n        No  → Step: bitA ← 0\n    Yes → Decision: j ≥ 0? // 取 b 的位\n        Yes → Step: bitB ← b[j]\n        No  → Step: bitB ← 0\n    Yes → Step: sum ← bitA + bitB + carry\n    Yes → Step: carry ← sum / 2\n    Yes → Step: result ← (sum % 2) + result\n    Yes → Step: i ← i - 1\n    Yes → Step: j ← j - 1\n    No  → Step: Return result\nEnd\n\nBut we need to note that the \"No\" branch of the outer Decision is to return result. The Yes branch continues the loop by implicitly going back to outer Decision after the steps. This is okay.\n\nMake sure each line is separate. For the No branch, we might have to show that after steps we loop again. But we can rely on indentation.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize i ← len(a) - 1 // 設定 a 的指標指向最後一位\n→ Initialize j ← len(b) - 1 // 設定 b 的指標指向最後一位\n→ Initialize carry ← 0 // 初始進位為 0\n→ Initialize result ← \"\" // 用來儲存結果的字串，初始為空\n→ Decision: i ≥ 0 OR j ≥ 0 OR carry ≠ 0? // 是否還有位數或進位需要處理？\n    Yes → Decision: i ≥ 0? // 是否還有 a 的位數可取？\n        Yes → Step: bitA ← a[i] // 取 a 的當前位\n        No  → Step: bitA ← 0    // a 已結束，視為 0\n    Yes → Decision: j ≥ 0? // 是否還有 b 的位數可取？\n        Yes → Step: bitB ← b[j] // 取 b 的當前位\n        No  → Step: bitB ← 0    // b 已結束，視為 0\n    Yes → Step: sum ← bitA + bitB + carry // 計算兩位數與進位的總和\n    Yes → Step: carry ← sum / 2 // 更新進位（整除 2）\n    Yes → Step: result ← (sum % 2) + result // 把本位結果加到前面，保持正確順序\n    Yes → Step: i ← i - 1 // 移動 a 指標向前\n    Yes → Step: j ← j - 1 // 移動 b 指標向前\n    No  → Step: Return result // 迴圈結束，輸出最終二進位字串\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef addBinary(a: str, b: str) -> str:\n    \"\"\"將兩個二進位字串相加，回傳結果字串。\"\"\"\n    i, j = len(a) - 1, len(b) - 1\n    carry = 0\n    res = []\n\n    while i >= 0 or j >= 0 or carry:\n        total = carry\n        if i >= 0:\n            total += int(a[i])\n            i -= 1\n        if j >= 0:\n            total += int(b[j])\n            j -= 1\n        res.append(str(total % 2))\n        carry = total // 2\n\n    return ''.join(reversed(res))\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 先嘗試抓取雙引號中的字串\n    quotes = re.findall(r'\"(.*?)\"', data)\n    if len(quotes) >= 2:\n        a_str, b_str = quotes[0], quotes[1]\n    else:\n        # 若沒有引號，直接以空白分割取得兩個字串\n        parts = data.split()\n        if len(parts) >= 2:\n            a_str, b_str = parts[0], parts[1]\n        else:\n            # 只有一個字串時，另一個設為空字串\n            a_str = parts[0] if parts else ''\n            b_str = ''\n\n    result = addBinary(a_str, b_str)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = \"11\", b = \"1\"",
          "expected_output": "\"100\"",
          "success": true,
          "output": "100"
        },
        {
          "example_index": 1,
          "input": "a = \"1010\", b = \"1011\"",
          "expected_output": "\"10101\"",
          "success": true,
          "output": "10101"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode371.json",
    "problem_index_in_file": 0,
    "title": "Sum of Two Integers",
    "description_snippet": "Given two integers a and b, return the sum of the two integers without using the operators + and -....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for sum of two integers without using + or -. We can use bitwise operations: XOR for sum without carry, AND then left shift for carry. Loop until carry is zero. Provide each line with explanation. Use Start, Decision, etc. Use arrows and indentation. Provide each step line with virtual code and comment. Should include loops. Use \"While\" or \"Decision: if carry==0?\" etc. Let's craft.\n\nLine 1: Start.\n\nLine 2: → Step 1: 設定 carry = a AND b // 找出需要進位的位\n\nBut better: we can loop until carry is zero: while carry != 0.\n\nSimplify: Use variable sum = a XOR b; carry = (a AND b) << 1; while carry != 0: a = sum; b = carry; sum = a XOR b; carry = (a AND b) << 1.\n\nBut we want to avoid using + or -. So we use XOR, AND, shift. We'll produce stepwise.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 a, b // 取得兩個輸入整數\n\n→ Step 2: 計算 sum = a XOR b // 先算沒有進位的和\n\n→ Step 3: 計算 carry = (a AND b) << 1 // 先算進位需要往左移\n\n→ Decision: carry 是否為 0? // 判斷是否還有進位\n\n    No → Step 4: 設定 a = sum // 更新 a 為沒有進位的和\n\n    No → Step 5: 設定 b = carry // 更新 b 為進位值\n\n    No → Step 6: 重複計算 sum = a XOR b // 再次計算新的和\n\n    No → Step 7: 重複計算 carry = (a AND b) << 1 // 再次計算新的進位\n\n    No → Decision: (循環回到 Step 4/5/6/7) // 迴圈\n\n    Yes → Step 8: 輸出 sum // 沒有進位時， sum 為最終結果\n\nEnd // 程式執行結束\n\nBut we need to show loop structure properly. Use \"While\" maybe: Decision: carry == 0? then No means loop continues.\n\nSimplify: Use \"Decision: carry 是否為 0?\" with Yes → End. No → (loop). Provide proper indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入值 a, b // 取得兩個整數  \n\n→ Step 2: sum ← a XOR b // 先算沒有進位的位元和  \n→ Step 3: carry ← (a AND b) << 1 // 先算需要進位的位元並左移  \n\n→ Decision: carry 是否為 0? // 判斷是否還有進位  \n    Yes → Step 4: 輸出 sum // 沒進位，sum 為最終答案  \n    No  → Step 5: a ← sum // 更新 a 為新和  \n    No  → Step 6: b ← carry // 更新 b 為新進位  \n    No  → Step 7: sum ← a XOR b // 再次算沒有進位的和  \n    No  → Step 8: carry ← (a AND b) << 1 // 再次算進位  \n    No  → Decision: carry 是否為 0? // 重新檢查，形成迴圈  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def getSum(self, a, b):\n        MASK = 0xFFFFFFFF\n        MAX_INT = 0x7FFFFFFF\n\n        while b != 0:\n            carry = (a & b) & MASK\n            a = (a ^ b) & MASK\n            b = (carry << 1) & MASK\n\n        return a if a <= MAX_INT else ~(a ^ MASK)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) >= 2:\n        a, b = nums[0], nums[1]\n        print(Solution().getSum(a, b))\n    else:\n        print(0)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 1, b = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode593.json",
    "problem_index_in_file": 0,
    "title": "Valid Square",
    "description_snippet": "Given the coordinates of four points in 2D space p1, p2, p3 and p4, return true if the four points c...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce virtual code steps. Let's think algorithm: compute all pairwise distances squared among 4 points (6 distances). In a square, there are 4 equal smaller distances (sides) and 2 equal larger distances (diagonals). Steps: compute distances, sort, check first four equal >0, last two equal and larger. Also maybe check that diagonals are twice sides? For square, diagonal^2 = 2 * side^2. But equal bigger distances ensures diagonals equal, but not necessarily relationship. So we can check that diag == 2 * side.\n\nAlgorithm: Input points array of 4 points each [x,y]. Create list distances. For i 0..3, for j i+1..3: compute dx^2+dy^2. Append. Sort ascending. Check distances[0]>0. Check distances[0]==distances[1]==distances[2]==distances[3]. Check distances[4]==distances[5]. Check distances[4]==2*distances[0]. If all true return true else false.\n\nReturn result.\n\nVirtual code steps:\n\nStart // 程式開始\n→ Step 1: 取得四點座標 p1, p2, p3, p4 // 從輸入中取得四個座標點\n→ Step 2: 建立空列表 dist // 用於存放兩點之間的距離平方\n→ Step 3: for each unordered pair (pi, pj) of 4 points\n    → Compute dx = pi.x - pj.x\n    → Compute dy = pi.y - pj.y\n    → Append (dx*dx + dy*dy) to dist // 存入距離平方\n→ Step 4: 排序 dist // 由小到大排列\n→ Step 5: Decision: dist[0] == 0? // 是否有零距離，代表重點\n    Yes → Return False // 若距離為零，長度為0，非正方形\n    No  →\n→ Step 6: Decision: dist[0]==dist[1]==dist[2]==dist[3]? // 前四個是否相等\n    Yes →\n→ Step 7: Decision: dist[4]==dist[5]? // 兩條對角線是否相等\n        Yes →\n→ Step 8: Decision: dist[4]==2*dist[0]? // 對角線平方是否等於兩倍邊長平方\n            Yes → Return True\n            No  → Return False\n        No → Return False\n    No → Return False\nEnd // 程式結束\n\nWe must use virtual code arrow syntax exactly: Start, End, Decision: with Yes →, No →. Ensure each line ends with // explanation. Provide each line as one line.\n\nLet's write it. Use indent? We can indent inside decisions.\n\nWe should keep each line separate.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得四點座標 p1, p2, p3, p4 // 從輸入中取得四個座標點  \n→ Step 2: 建立空列表 dist // 用於存放兩點之間的距離平方  \n→ Step 3: for 每個不重複的點對 (pi, pj) of {p1, p2, p3, p4}  \n    → Compute dx = pi.x - pj.x  \n    → Compute dy = pi.y - pj.y  \n    → Append (dx*dx + dy*dy) to dist // 存入距離平方  \n→ Step 4: 排序 dist // 由小到大排列  \n→ Step 5: Decision: dist[0] == 0? // 檢查是否有零距離  \n    Yes → Return False // 若距離為零，長度為0，非正方形  \n    No  →  \n→ Step 6: Decision: dist[0] == dist[1] == dist[2] == dist[3]? // 前四個距離是否相等  \n    Yes →  \n→ Step 7: Decision: dist[4] == dist[5]? // 對角線是否相等  \n        Yes →  \n→ Step 8: Decision: dist[4] == 2 * dist[0]? // 對角線平方是否等於兩倍邊長平方  \n            Yes → Return True // 是正方形  \n            No  → Return False // 對角線不符合比例，非正方形  \n        No → Return False // 對角線不相等，非正方形  \n    No → Return False // 邊長不相等，非正方形  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        # 計算兩點之間距離的平方\n        def dist_sq(a, b):\n            return (a[0]-b[0])**2 + (a[1]-b[1])**2\n        \n        points = [p1, p2, p3, p4]\n        dists = []\n        \n        # 取所有 6 種不重複點對，計算距離平方\n        for i in range(4):\n            for j in range(i+1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n        \n        dists.sort()\n        \n        # 1. 四條邊相等且長度>0\n        # 2. 對角線相等且為邊長平方的兩倍\n        return (\n            dists[0] > 0 and\n            dists[0] == dists[1] == dists[2] == dists[3] and\n            dists[4] == dists[5] and\n            dists[4] == 2 * dists[0]\n        )\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 擷取所有整數（包括負號）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 8:\n        print(\"false\")\n        sys.exit(0)\n    # 依序組成四個點\n    points = [[nums[i], nums[i+1]] for i in range(0, 8, 2)]\n    p1, p2, p3, p4 = points\n    solution = Solution()\n    result = solution.validSquare(p1, p2, p3, p4)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 1,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode35.json",
    "problem_index_in_file": 0,
    "title": "Search Insert Position",
    "description_snippet": "Given a sorted array of distinct integers and a target value, return the index if the target is foun...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for binary search insertion index. Each line: step + explanation. Use Start, Decision, etc. Format exactly: \"虛擬碼步驟 // 解釋/說明\". Use arrow \"→\" etc.\n\nWe need to produce algorithm: binary search with left, right pointers, while left <= right, mid, compare. After loop, left is insertion index.\n\nLet's produce. Ensure each line is \"虛擬碼步驟 // 解釋/說明\". Use Start, End. Use Decision with Yes → etc. Use \"→\" to indent steps. Use consistent formatting. Provide each line.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化 left 為 0 // 左邊界指向陣列首位  \n→ 初始化 right 為 n-1 // 右邊界指向陣列尾位  \n→ Decision: left ≤ right? // 是否還有未檢查的區間？  \n Yes → Step 1: 計算 mid = (left + right) // 2 // 取中間索引  \n  → Decision: nums[mid] == target? // 中間值是否等於目標？  \n   Yes → Step 2: 回傳 mid // 找到目標，返回其索引  \n   No → Decision: nums[mid] < target? // 中間值是否小於目標？  \n    Yes → Step 3: 設定 left = mid + 1 // 目標在右半邊  \n    No  → Step 4: 設定 right = mid - 1 // 目標在左半邊  \n    → 返回到 Decision: left ≤ right? // 繼續搜尋  \n No  → Step 5: 回傳 left // 左邊界即為插入位置  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析出 nums 與 target。\n    例如：\"nums = [1,3,5,6], target = 5\" 或多行輸入。\n    \"\"\"\n    # 移除換行並合併成單行\n    data = data.replace('\\n', ' ')\n    # 取得 nums 列表\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not nums_match:\n        raise ValueError(\"Cannot find nums in input.\")\n    nums_str = nums_match.group(1)\n    nums = eval(nums_str, {\"__builtins__\": {}})\n\n    # 取得 target 整數\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not target_match:\n        raise ValueError(\"Cannot find target in input.\")\n    target = int(target_match.group(1))\n\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n    sol = Solution()\n    result = sol.searchInsert(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode154.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array II",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code (pseudocode) that finds minimum in rotated sorted array with duplicates, minimizing operations. We should use binary search with adjustments for duplicates.\n\nWe output step by step virtual code with explanations.\n\nWe need to obey format: each line: \"虛擬碼步驟 // 解釋\". Use arrows and structure. Use Start, End, Decision. Provide steps like initialize left,right, loop, compare.\n\nLet's craft steps:\n\nStart\n→ Step 1: 初始化 left = 0, right = n-1 // 左右指標\n→ Step 2: while left < right // 循環直到找到最小\n    → Decision: nums[left] < nums[right]?\n        Yes → 返回 nums[left] // 已排序無旋轉，左邊最小\n        No →\n            → Decision: nums[left] == nums[right]?\n                Yes →\n                    → Step 3: 左移 left++ // 处理重复，缩小范围\n                No →\n                    → Decision: nums[mid] > nums[right]?\n                        Yes → left = mid + 1 // 最小在右半段\n                        No → right = mid // 最小在左半段或mid\n    → Step 4: mid = left + (right - left) // 计算中点\nEnd\n\nNeed to ensure mid defined before decisions; we can compute mid at start of loop. Or compute after duplicate handling.\n\nBetter: while left < right: compute mid; then decide.\n\nLet's craft:\n\nStart\n→ Step 1: left = 0, right = length(nums)-1 // 初始化指標\n→ Decision: while left < right?\n    Yes →\n        → Step 2: mid = left + (right - left) // 取中點\n        → Decision: nums[mid] > nums[right]?\n            Yes → left = mid + 1 // 最小在右半段\n            No →\n                → Decision: nums[mid] == nums[right]?\n                    Yes → right-- // 去重\n                    No → right = mid // 最小在左半段或mid\n    No →\n→ End // 返回 nums[left]\n\nWe also need final return.\n\nLet's produce final pseudocode with arrows.\n\nEnsure each line has arrow. Use indentation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0, right = length(nums) - 1 // 設定左、右指標  \n→ Decision: while left < right? // 只要左小於右就持續搜尋  \n    Yes →  \n        → Step 2: mid = left + (right - left) // 計算中點  \n        → Decision: nums[mid] > nums[right]? // 判斷最小值在右半段  \n            Yes → left = mid + 1 // 最小元素必在 mid 右側  \n            No →  \n                → Decision: nums[mid] == nums[right]? // 兩端相同，無法確定方向  \n                    Yes → right = right - 1 // 右指標往左縮小，消除重複  \n                    No → right = mid // 最小在左半段或 mid 本身  \n    No →  \n→ End // 循環結束，left 指向最小值  \n→ Step 3: return nums[left] // 回傳最小元素\n\n---  \n\n// 以上虛擬碼採用改良二分法，在遇到相同值時縮小右指標，並在明確可判斷時直接調整左或右指標，最大化操作效率。",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def findMin(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n        return nums[left]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 只抓取第一個方括號對中的內容\n    match = re.search(r'\\[.*\\]', data)\n    if not match:\n        raise ValueError(\"Input does not contain a list.\")\n    # 用 ast.literal_eval 解析成列表\n    nums = ast.literal_eval(match.group(0))\n    # 呼叫解法並輸出結果\n    result = Solution().findMin(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,0,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode638.json",
    "problem_index_in_file": 0,
    "title": "Shopping Offers",
    "description_snippet": "In LeetCode Store, there are n items to sell. Each item has a price. However, there are some special...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code for solving the LeetCode Store problem. Must output step by step pseudocode with explanations, no actual code. Provide each line with arrow or start/end, decisions. Use the format. Need to cover typical algorithm: DFS with memoization or DP over states. We'll produce steps: Start → Build memo dict → Define recursive function solve(state) → If state in memo → return memo[state] → Initialize minCost = sum(price[i]*state[i]) → For each offer → Check if offer can be applied (state >= offer items) → Compute newState → costOffer = offerPrice + solve(newState) → minCost = min(minCost, costOffer) → Memoize → Return minCost → Call solve(needs) → End. Also consider pruning: if offer price >= sum(price * items) skip. Provide lines.\n\nWe need to include explanation after each line. Use \"Start // 程式開始執行\" etc. Let's produce.\n\nWe'll need to include decisions lines. Provide the decision for \"如果state已經在memo中?\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ 將 price, needs, special 轉成可直接存取的資料結構 // 準備輸入  \n→ 定義 memo = {} // 用於記錄已計算過的需求組合  \n→ Decision: 如果 needs 為空? // 檢查是否已經無需購買任何物品  \n    Yes → Return 0 // 無需任何費用，直接結束  \n    No → 進入主計算流程  \n→ 定義函式 solve(state) // state 為目前剩餘需求的向量  \n    → Decision: 如果 state 已在 memo 中? // 檢查是否已經計算過  \n        Yes → Return memo[state] // 直接取已知答案  \n        No → 繼續計算  \n    → 初始化 minCost = Σ price[i] * state[i] // 只購買單品的成本作為初始值  \n    → 對於每個 offer in special: // 逐一考慮特價優惠  \n        → Decision: 是否可使用該 offer? (state[j] >= offer[j] for all j) // 檢查需求足夠  \n            Yes → 計算 newState = state - offer[0..n-1] // 減去已購買的數量  \n            → newCost = offer[n] + solve(newState) // 把優惠價格加上遞歸結果  \n            → Decision: newCost < minCost? // 是否比目前最佳更好  \n                Yes → minCost = newCost // 更新最佳價格  \n                No → 不變  \n            No → 跳過此優惠  \n    → memo[state] = minCost // 記錄此 state 的最佳價格  \n    → Return minCost // 回傳結果  \n→ 呼叫 solve(needs) 並將結果儲存為 answer // 開始實際計算  \n→ End // 程式執行結束",
      "generated_code": "import sys\nsys.setrecursionlimit(10000)\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # cost without any special offers\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\nif __name__ == \"__main__\":\n    import re\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Build a dictionary string from the input\n    dict_str = \"{\" + data.replace(\"price =\", \"'price':\").replace(\"special =\", \"'special':\").replace(\"needs =\", \"'needs':\") + \"}\"\n    # Evaluate to get the actual data structures\n    params = eval(dict_str, {})\n    price = params[\"price\"]\n    special = params[\"special\"]\n    needs = params[\"needs\"]\n    solution = Solution()\n    result = solution.shoppingOffers(price, special, needs)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "success": true,
          "output": "14"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode709.json",
    "problem_index_in_file": 0,
    "title": "To Lower Case",
    "description_snippet": "Given a string s, return the string after replacing every uppercase letter with the same lowercase l...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code step-by-step. So process: Start, Step: Input string s, maybe define result empty, iterate over each character, check if uppercase, convert to lowercase, else keep. Build result. Output result. End. Use virtual code arrows. Provide explanation after each line.\n\nMake sure each line contains \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use the structure Start, End, Decision, Step etc. Should be line by line. Let's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 s // 從使用者取得字串\n→ Step 2: 初始化結果字串 result 為空 // 用於儲存轉換後的字串\n→ Step 3: 迭代 i 從 0 到 length(s)-1 // 逐個檢查字元\n    → Decision: s[i] 是否為大寫字母? // 判斷當前字元是否需要轉換\n        Yes → Step 4a: 把 s[i] 轉成小寫並追加到 result // 大寫轉小寫\n        No  → Step 4b: 直接把 s[i] 追加到 result // 非大寫保持不變\n→ Step 5: 輸出 result // 回傳轉換後的字串\nEnd // 程式結束\n\nBut need arrow format. Use \"→\" for steps, \"Decision:\" for decision, \"Yes →\" etc.\n\nLet's craft each line exactly as requested. Ensure each line contains a space between code and comment.\n\nWe should keep indentation? The example uses indentation with tabs or spaces. We'll mimic simple indentation with spaces.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者取得原始字串  \n→ Step 2: 初始化結果字串 result 為空 // 用於儲存轉換後的字串  \n→ Step 3: 迭代 i 從 0 到 length(s)-1 // 逐個檢查每個字元  \n → Decision: s[i] 是否為大寫字母? // 判斷是否需要轉換  \n  Yes → Step 4a: 把 s[i] 轉成小寫並追加到 result // 大寫轉成小寫  \n  No  → Step 4b: 直接把 s[i] 追加到 result // 非大寫保持不變  \n→ Step 5: 輸出 result // 回傳轉換後的字串  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef to_lower_case(s: str) -> str:\n    \"\"\"將字串中的所有大寫字母轉換為小寫。\"\"\"\n    result = []\n    for c in s:\n        if 'A' <= c <= 'Z':\n            # ASCII 大寫到小寫的差值是 32\n            result.append(chr(ord(c) + 32))\n        else:\n            result.append(c)\n    return ''.join(result)\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取 's = \"...\"'，輸出轉換後的字串並加上雙引號。\"\"\"\n    data = sys.stdin.read()\n    # 取得等號右側的引號字串\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    if not match:\n        # 如果沒有找到符合格式，直接結束\n        return\n    raw_string = match.group(1)\n    lowered = to_lower_case(raw_string)\n    # 將結果再加上雙引號輸出\n    print(f'\"{lowered}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello\"",
          "expected_output": "\"hello\"",
          "success": true,
          "output": "\"hello\""
        },
        {
          "example_index": 1,
          "input": "s = \"here\"",
          "expected_output": "\"here\"",
          "success": true,
          "output": "\"here\""
        },
        {
          "example_index": 2,
          "input": "s = \"LOVELY\"",
          "expected_output": "\"lovely\"",
          "success": true,
          "output": "\"lovely\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode153.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: find min in rotated sorted array unique, O(log n). Use binary search. Steps: Start, input array, set left=0, right=len-1. While left<right: mid=(left+right)//2; if nums[mid] > nums[right] then left=mid+1 else right=mid. After loop min=nums[left]. End.\n\nAdd comments. Ensure each line includes \"虛擬碼步驟\" + space + \"// 解釋\".\n\nWe should output in Traditional Chinese.\n\nAlso use arrows. Example: \"Start // 程式開始執行\". Use \"→\" lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Input nums // 取得旋轉後的排序陣列\n→ Decision: 長度為 1? // 若只有一個元素直接返回\n    Yes → Output nums[0] // 最小值為唯一元素\n    No  →\n        → Initialize left = 0 // 左邊界\n        → Initialize right = len(nums) - 1 // 右邊界\n        → Decision: left < right? // 二分搜尋條件\n            Yes →\n                → Calculate mid = (left + right) // 2 // 取中點\n                → Decision: nums[mid] > nums[right]? // 判斷右半段是否有最小值\n                    Yes → left = mid + 1 // 最小值在右半段\n                    No  → right = mid // 最小值在左半段或等於 mid\n                → 回到 Decision: left < right? // 重複搜尋\n            No  →\n                → Output nums[left] // left 指向最小值\nEnd // 程式結束\n\nCheck formatting: each line has virtual step and comment separated by space. Use arrows and indentation as in example. Provide each line with \"→\". The Decision lines should use indentation.\n\nMake sure not to produce actual code. Just virtual steps. Ensure each line ends with // 解釋. Provide exactly that.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Input nums // 取得旋轉後的排序陣列\n→ Decision: 長度為 1? // 若只有一個元素直接返回\n    Yes → Output nums[0] // 最小值為唯一元素\n    No  →\n        → Initialize left = 0 // 左邊界\n        → Initialize right = len(nums) - 1 // 右邊界\n        → Decision: left < right? // 二分搜尋條件\n            Yes →\n                → Calculate mid = (left + right) // 2 // 取中點\n                → Decision: nums[mid] > nums[right]? // 判斷右半段是否有最小值\n                    Yes → left = mid + 1 // 最小值在右半段\n                    No  → right = mid // 最小值在左半段或等於 mid\n                → 回到 Decision: left < right? // 重複搜尋\n            No  →\n                → Output nums[left] // left 指向最小值\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMin(self, nums):\n        \"\"\"二分搜尋找出旋轉排序陣列中的最小值（O(log n)）\"\"\"\n        left, right = 0, len(nums) - 1\n        if nums[left] <= nums[right]:\n            return nums[left]          # 未旋轉，直接返回首項\n\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1         # 最小值在右半段\n            else:\n                right = mid            # 最小值在左半段或等於 mid\n        return nums[left]              # left 指向最小值\n\n\ndef parse_input(data: str):\n    \"\"\"從輸入文字中擷取陣列並回傳 Python list\"\"\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        return []                    # 無效輸入，回傳空列\n    sub = data[start:end+1]\n    return ast.literal_eval(sub)     # 安全解析列表字面量\n\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    if not nums:\n        sys.exit()                   # 若輸入無效則直接結束\n    solution = Solution()\n    print(solution.findMin(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,4,5,1,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [11,13,15,17]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode552.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record II",
    "description_snippet": "An attendance record for a student can be represented as a string where each character signifies whe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting number of strings length n over {A,L,P} with constraints: fewer than 2 A's (so at most 1 A) and no three consecutive L's. Equivalent to DP. We'll produce virtual steps.\n\nWe need to output step-by-step. The user: \"Given an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 10^9 + 7.\"\n\nWe need to produce virtual code in lines, with explanations. Use Start, End, Decision. Provide arrows. Each line includes explanation.\n\nWe need to explain algorithm: DP with states: number of A's used (0 or 1) and consecutive L count (0,1,2). We iterate positions. Complexity O(n). Provide modulo. Use 3x3 DP array. Implementation details.\n\nWe'll produce pseudocode. Ensure we adhere to format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrow arrows.\n\nWe'll start with Start.\n\nLet's produce.\n\nLine1: Start // 程式開始執行\n\nLine2: → Input: n // 取得輸入的天數\n\nLine3: → Define MOD = 1_000_000_007 // 模數\n\nLine4: → Initialize dp[2][3] = 0 // dp[a][l] 表示已經走到目前位置，已經使用 a 個 A，且最後連續 L 的數量為 l\n\nLine5: → Set dp[0][0] = 1 // 起始時沒有缺席且沒有連續 L\n\nLine6: → For i from 1 to n do // 逐天遞迴\n\nLine7: →     Initialize next[2][3] = 0 // 下一個位置的 DP\n\nLine8: →     For a in {0,1} do // 已使用的 A 數\n\nLine9: →         For l in {0,1,2} do // 連續 L 數\n\nLine10: →             If dp[a][l] == 0 continue // 若無合法路徑\n\nLine11: →             // 將 P 放入\nLine12: →             next[a][0] = (next[a][0] + dp[a][l]) mod MOD // P 重置連續 L\nLine13: →             // 將 A 放入\nLine14: →             If a == 0 then // 只允許最多 1 個 A\nLine15: →                 next[1][0] = (next[1][0] + dp[a][l]) mod MOD // A 也重置連續 L\nLine16: →             // 將 L 放入\nLine17: →             If l < 2 then // 不允許連續 3 個 L\nLine18: →                 next[a][l+1] = (next[a][l+1] + dp[a][l]) mod MOD // L 延長連續\nLine19: →     End // 內層循環結束\nLine20: →     Set dp = next // 更新 DP\nLine21: → End // 外層循環結束\nLine22: → Initialize result = 0 // 最終結果\nLine23: → For a in {0,1} do\nLine24: →     For l in {0,1,2} do\nLine25: →         result = (result + dp[a][l]) mod MOD // 累加所有合法結束狀態\nLine26: → End // 累加結束\nLine27: → Output result // 回傳答案\nLine28: End // 程式結束\n\nWe need to format each line as \"虛擬碼步驟 // 解釋/說明\". Ensure each line includes arrow where appropriate. Also we can embed decisions. We have no explicit decision statements, but we can add decision lines like \"Decision: a==0?\" etc. But not required.\n\nBut we might show decisions inside loops with arrows.\n\nLet's produce final answer with lines. Ensure each line contains a virtual code step, arrow, comment.\n\nAlso use \"→\" for arrows. For loops, we can show \"→ For i = 1 to n do\". Provide explanation.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: n // 取得輸入的天數  \n→ Define MOD = 1_000_000_007 // 模數，用於取餘數避免溢位  \n→ Initialize dp[2][3] = 0 // dp[a][l] 代表已經走到目前位置，已經使用 a 個 A，且最後連續 L 的數量為 l  \n→ Set dp[0][0] = 1 // 起始時沒有缺席且沒有連續 L  \n→ For i from 1 to n do // 逐天遞迴  \n→     Initialize next[2][3] = 0 // 下一個位置的 DP  \n→     For a in {0,1} do // 已使用的 A 數 (0 或 1)  \n→         For l in {0,1,2} do // 連續 L 數 (0,1,2)  \n→             If dp[a][l] == 0 continue // 若無合法路徑，跳過  \n→             // 放入 'P'  \n→             next[a][0] = (next[a][0] + dp[a][l]) mod MOD // P 重置連續 L  \n→             // 放入 'A'  \n→             If a == 0 then // 只允許最多 1 個 A  \n→                 next[1][0] = (next[1][0] + dp[a][l]) mod MOD // A 也重置連續 L  \n→             // 放入 'L'  \n→             If l < 2 then // 不允許連續 3 個 L  \n→                 next[a][l+1] = (next[a][l+1] + dp[a][l]) mod MOD // L 延長連續  \n→     End // 內層循環結束  \n→     Set dp = next // 更新 DP 為下一個位置的結果  \n→ End // 外層循環結束  \n→ Initialize result = 0 // 最終結果  \n→ For a in {0,1} do  \n→     For l in {0,1,2} do  \n→         result = (result + dp[a][l]) mod MOD // 累加所有合法結束狀態  \n→     End // 內層循環結束  \n→ End // 外層循環結束  \n→ Output result // 回傳答案  \nEnd // 程式結束",
      "generated_code": "import sys\n\nMOD = 10**9 + 7\n\ndef count_records(n: int) -> int:\n    \"\"\"Return the number of eligible attendance records of length n.\"\"\"\n    # dp[a][l] : number of sequences with a 'A's used (0 or 1)\n    #            and ending with l consecutive 'L's (0, 1, or 2)\n    dp = [[0] * 3 for _ in range(2)]\n    dp[0][0] = 1  # empty sequence\n\n    for _ in range(n):\n        new_dp = [[0] * 3 for _ in range(2)]\n        for a in range(2):\n            for l in range(3):\n                val = dp[a][l]\n                if val == 0:\n                    continue\n                # Add 'P': resets consecutive L count\n                new_dp[a][0] = (new_dp[a][0] + val) % MOD\n                # Add 'A': allowed only if we have no A yet\n                if a == 0:\n                    new_dp[1][0] = (new_dp[1][0] + val) % MOD\n                # Add 'L': only if we don't already have 2 consecutive L's\n                if l < 2:\n                    new_dp[a][l + 1] = (new_dp[a][l + 1] + val) % MOD\n        dp = new_dp\n\n    # Sum over all possible final states (0 or 1 A, 0-2 consecutive L's)\n    return sum(dp[a][l] for a in range(2) for l in range(3)) % MOD\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    print(count_records(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "10101",
          "expected_output": "183236316",
          "success": true,
          "output": "183236316"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode334.json",
    "problem_index_in_file": 0,
    "title": "Increasing Triplet Subsequence",
    "description_snippet": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i <...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm: find increasing triple subsequence. Standard solution: use first and second numbers. Or O(n) check. We'll produce algorithm:\n\nStart\n→ Step: Initialize first = inf\n→ Step: Initialize second = inf\n→ Loop over each number num in nums:\n    Decision: If num <= first? // update first\n        Yes → Update first = num\n        No → Decision: if num <= second? // update second\n            Yes → Update second = num\n            No → Return true (found triple)\n→ End return false\n\nBut we need to include End.\n\nLet's craft lines accordingly.\n\nUse arrow for decisions.\n\nWe must not output actual code, only virtual.\n\nMake sure each line ends with // explanation.\n\nLet's produce.\n\nAlso include Step 1: Start.\n\nWe need to adhere to format:\n\nStart // 程式開始執行\n→ Step 1: 初始化 first 為正無窮 // 以便追蹤最小值\n→ Step 2: 初始化 second 為正無窮 // 以便追蹤第二小值\n→ Step 3: 循環遍歷陣列 nums // 對每個元素進行判斷\n    Decision: 如果 num <= first? // 檢查是否比目前最小值還小\n        Yes → Step 4: first = num // 更新第一個較小值\n        No → Decision: 如果 num <= second? // 檢查是否比目前第二小值還小\n            Yes → Step 5: second = num // 更新第二個較小值\n            No → Step 6: 返回 true // 找到三個遞增元素\n→ End // 未找到，返回 false\n\nBut we need to show final step of returning false. Maybe add Step 7: 返回 false // 未找到遞增三元組\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 first 為正無窮 // 以便追蹤目前最小值  \n→ Step 2: 初始化 second 為正無窮 // 以便追蹤目前第二小值  \n→ Step 3: 循環遍歷陣列 nums // 對每個元素進行判斷  \n  Decision: 如果 num <= first? // 檢查是否比目前最小值還小  \n   Yes → Step 4: first = num // 更新第一個較小值  \n   No → Decision: 如果 num <= second? // 檢查是否比目前第二小值還小  \n    Yes → Step 5: second = num // 更新第二個較小值  \n    No → Step 6: 返回 true // 找到遞增三元組，結束程式  \n→ Step 7: 返回 false // 未找到遞增三元組，程式結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def increasingTriplet(self, nums):\n        \"\"\"\n        判斷 nums 中是否存在遞增三元組。\n        使用 O(n) 時間、O(1) 空間的雙指標法。\n        \"\"\"\n        first = second = float('inf')\n        for num in nums:\n            if num <= first:\n                first = num                     # 更新最小值\n            elif num <= second:\n                second = num                    # 更新第二小值\n            else:\n                return True                     # 找到 nums[i] < nums[j] < nums[k]\n        return False                            # 未找到遞增三元組\n\ndef main():\n    # 讀取整個輸入，預期格式類似 'nums = [1,2,3,4,5]'\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找出第一個 '[' 和最後一個 ']'，提取陣列字串\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        nums = []\n    else:\n        nums_str = data[start:end + 1]\n        # 使用 ast.literal_eval 以安全方式解析 Python 列表字串\n        nums = ast.literal_eval(nums_str)\n\n    result = Solution().increasingTriplet(nums)\n    # 輸出小寫字串，符合範例要求\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [5,4,3,2,1]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [2,1,5,0,4,6]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode390.json",
    "problem_index_in_file": 0,
    "title": "Elimination Game",
    "description_snippet": "You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps describing the algorithm. It's like the Josephus problem with elimination of every second starting from left, then right, alternating. We need to generate pseudocode steps line by line. Not actual code, just virtual code. Each line: \"虛擬碼步驟\" + \" // 解釋/說明\". Use arrows →, decisions, etc. The algorithm: we have list arr = [1..n]. We simulate elimination. But we can also produce efficient algorithm using indices? But requirement: produce virtual code steps that implement algorithm. So we can produce steps like:\n\nStart\n→ Initialize arr = [1..n]\n→ Initialize direction = left_to_right\n→ While length(arr) > 1:\n    → Decision: if direction == left_to_right\n         Yes → Remove elements at indices 0,2,4,... // starting from first\n         No → Remove elements at indices last, last-2, last-4,... // right to left\n    → Toggle direction\n→ Step: Output arr[0]\nEnd\n\nBut we need to use virtual code lines with arrows and decision etc. Each line must have a short explanation after //. Let's produce detailed steps.\n\nWe can also use a loop variable to track current list, but we don't need actual code. Virtual code:\n\nStart // 程式開始\n→ Step 1: arr ← [1, 2, …, n] // 建立完整遞增數列\n→ Step 2: direction ← left_to_right // 初始刪除方向為左到右\n→ Decision: arr.size > 1? // 是否還有多個元素？\n    Yes →\n        → Decision: direction == left_to_right? // 判斷方向\n            Yes →\n                → Step 3: arr ← elements of arr at odd indices (1,3,5,…) // 刪除左到右的第一個和之後每隔一個\n                → Step 4: direction ← right_to_left // 切換方向\n            No →\n                → Step 5: arr ← elements of arr at even indices from end (n-1, n-3,…) // 右到左刪除右端開始的第一個和之後每隔一個\n                → Step 6: direction ← left_to_right // 切換方向\n        → Go back to Decision: arr.size > 1? // 重新判斷\n    No →\n        → Step 7: Output arr[0] // 單一剩餘數\nEnd // 程式結束\n\nBut we must format each line with 虛擬碼步驟 + space + // explanation. Use arrows. Also need to show step labels? Eg \"→ Step 1: ...\" That is fine. Use Start, End. For decision lines, indent? In example they had indentation. But we can mimic:\n\nStart // 程式開始執行\n→ Step 1: arr ← [1..n] // 建立遞增序列\n→ Step 2: direction ← left_to_right // 初始方向\n→ Decision: arr.size > 1? // 檢查是否還有多於一個元素\n    Yes →\n        → Decision: direction == left_to_right? // 判斷刪除方向\n            Yes →\n                → Step 3: arr ← arr[1], arr[3], … // 左到右刪除第一個和之後每隔一個\n                → Step 4: direction ← right_to_left // 切換方向\n            No →\n                → Step 5: arr ← arr[last], arr[last-2], … // 右到左刪除右端開始的第一個和之後每隔一個\n                → Step 6: direction ← left_to_right // 切換方向\n        → Go back to Decision: arr.size > 1? // 重新檢查\n    No →\n        → Step 7: Output arr[0] // 最後剩餘數\nEnd // 程式結束\n\nBut we need to output in each line: 虛擬碼步驟 + space + // explanation. So need to ensure each line has that. For decisions, we show \"Decision: ...\" line and then indent branches with \"Yes →\" and \"No →\" lines.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: arr ← [1, 2, …, n] // 建立完整遞增數列  \n→ Step 2: direction ← left_to_right // 初始刪除方向為左到右  \n→ Decision: arr.size > 1? // 檢查還有多個元素？  \n  Yes →  \n   → Decision: direction == left_to_right? // 判斷目前方向  \n    Yes →  \n     → Step 3: arr ← arr[1], arr[3], … // 左到右刪除第一個和之後每隔一個  \n     → Step 4: direction ← right_to_left // 切換方向  \n    No →  \n     → Step 5: arr ← arr[last], arr[last-2], … // 右到左刪除右端開始的第一個和之後每隔一個  \n     → Step 6: direction ← left_to_right // 切換方向  \n   → Go back to Decision: arr.size > 1? // 重新檢查是否還有多個元素  \n  No →  \n   → Step 7: Output arr[0] // 最後剩餘數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef last_remaining(n: int) -> int:\n    \"\"\"\n    依照題目描述的交替刪除演算法求最後剩下的數字。\n    \"\"\"\n    head = 1        # 目前序列中第一個數字\n    step = 1        # 兩個相鄰數字之間的距離\n    remaining = n   # 現在序列中還剩多少個數字\n    left = True     # 目前刪除方向，True 表示從左往右\n\n    while remaining > 1:\n        # 如果是左到右刪除，或右到左時剩餘個數為奇數\n        # 則第一個數字會被刪除，head 需往前移動\n        if left or remaining % 2 == 1:\n            head += step\n        remaining //= 2\n        step *= 2\n        left = not left\n\n    return head\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 從輸入中提取第一個整數值，支援 \"n = 9\"、\"9\" 等格式\n    nums = re.findall(r'-?\\d+', data)\n    n = int(nums[0]) if nums else 0\n    result = last_remaining(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 9",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode456.json",
    "problem_index_in_file": 0,
    "title": "132 Pattern",
    "description_snippet": "Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j]...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code for 132 pattern detection algorithm. Should not output actual code, but pseudocode. Use structure Start, Decision, etc. Use lines with arrow.\n\nWe need to cover algorithm: typical stack-based approach: iterate from right to left, maintain stack of potential nums[j] values, and a variable third (max of nums[k]). For each nums[i] check if nums[i] < third -> true; else while stack non-empty and nums[i] > stack.top, pop and update third = max(third, stack.top). push nums[i]. After loop, return false.\n\nWe need to produce line by line virtual steps with explanation. Also need to mention array size n. Use arrow and decisions.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize empty stack S and variable third = -∞ // 用於保存 nums[j] 值的候選堆疊以及目前已知的最大 nums[k]\n→ Step 2: For each index i from n-1 down to 0 // 從右向左遍歷\n    → Decision: 若 nums[i] < third? // 檢查是否形成 132 模式\n        Yes → Step 3: Return true // 找到符合條件的子序列\n        No  → Decision: 是否能更新 third? // 需要檢查是否有更大的 nums[j] 以供之後使用\n            → Step 4: While S非空 且 nums[i] > S.top() // 從堆疊中彈出所有小於 nums[i] 的元素，因為它們無法作為 nums[j]\n                → Step 5: third = max(third, S.pop()) // 更新第三個元素為最大的 nums[k]\n            → Step 6: S.push(nums[i]) // 把當前元素作為潛在的 nums[j] 存入堆疊\n→ Step 7: Return false // 完整遍歷後未找到 132 模式\nEnd\n\nNeed each line with arrow and explanation after //.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空堆疊 S 和變數 third = -∞ // 用於存儲潛在的 nums[j] 及已知最大 nums[k]  \n→ Step 2: 從右向左遍歷每個索引 i（i = n-1 … 0） // 以便先確定右側的 nums[k] 與 nums[j]  \n    → Decision: 若 nums[i] < third? // 判斷是否已經找到 132 模式  \n        Yes → Step 3: 返回 true // 成功找到符合條件的子序列  \n        No  → Decision: 是否可更新 third? // 檢查是否有更大的 nums[j] 可供未來比較  \n            → Step 4: 當 S 非空 且 nums[i] > S.top() 時 // 將所有小於 nums[i] 的候選 nums[j] 從堆疊移除  \n                → Step 5: third = max(third, S.pop()) // 更新第三個數字為已彈出的最大值  \n            → Step 6: S.push(nums[i]) // 把當前元素作為新的潛在 nums[j] 推入堆疊  \n→ Step 7: 返回 false // 整個數組遍歷完仍未找到 132 模式  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def find132pattern(self, nums):\n        \"\"\"Detect if a 132 pattern exists in the list.\"\"\"\n        stack = []\n        third = float('-inf')\n        for num in reversed(nums):\n            if num < third:\n                return True\n            while stack and stack[-1] < num:\n                third = stack.pop()\n            stack.append(num)\n        return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 將輸入字串中的 'nums = ' 前綴去掉，取得列表字串\n    start = data.find('[')\n    if start == -1:\n        nums = []\n    else:\n        nums_str = data[start:]\n        try:\n            nums = ast.literal_eval(nums_str)\n            if not isinstance(nums, list):\n                nums = []\n        except Exception:\n            nums = []\n\n    sol = Solution()\n    result = sol.find132pattern(nums)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,3,2,0]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode6.json",
    "problem_index_in_file": 0,
    "title": "ZigZag Conversion",
    "description_snippet": "Convert a string to a zigzag pattern and read line by line....",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for converting a string to a zigzag pattern and read line by line. We need to output line by line with the arrow syntax.\n\nAssume input string S and numRows. Zigzag conversion algorithm: we need to simulate rows, append characters. Then join rows. Provide virtual steps. Should be simple.\n\nLet's produce pseudocode:\n\nStart // Program starts\n→ Step 1: Input string S and integer numRows // read input\n→ Decision: If numRows <= 1? // special case\n    Yes → Step 2: Output S // no zigzag needed\n    No  → Step 3: Initialize array rows of size numRows with empty strings // prepare rows\n→ Step 4: Set currentRow = 0, direction = -1 // start moving downwards\n→ Step 5: For each character c in S:\n        → Append c to rows[currentRow] // place char in current row\n        → If currentRow == 0 or currentRow == numRows - 1: direction = -direction // reverse direction at top/bottom\n        → currentRow += direction // move to next row\n→ Step 6: Initialize result = \"\" // result string\n→ Step 7: For each row in rows: result += row // concatenate rows\n→ Step 8: Output result // final zigzag string\nEnd // Program ends\n\nAdd comments after each line.\n\nMake sure each line contains \"→\" or \"Start\" \"End\". Use Decision syntax. Indent lines inside decisions with spaces. Use \"Yes →\" \"No →\". Provide explanations.\n\nLet's format properly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 S 與整數 numRows // 從使用者處取得輸入  \n→ Decision: 若 numRows ≤ 1? // 檢查行數是否為 1 或更少  \n  Yes → Step 2: 輸出 S // 直接回傳原始字串，無需 zigzag  \n  No  → Step 3: 初始化 rows 為長度 numRows 的空字串陣列 // 用於存放各行字符  \n→ Step 4: 設定 currentRow = 0, direction = -1 // 起始行號與方向，-1 表示向下  \n→ Step 5: 對於 S 中每個字符 c:  \n   → Append c 到 rows[currentRow] // 把字符放入目前行  \n   → 如果 currentRow 為 0 或 numRows-1: direction = -direction // 到達頂部或底部時改變方向  \n   → currentRow += direction // 移動到下一行  \n→ Step 6: 設定 result = \"\" // 用於累積最終字串  \n→ Step 7: 對於 rows 中的每一行 r: result += r // 依序串接每行  \n→ Step 8: 輸出 result // 輸出 zigzag 轉換後的字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \"\"\"Convert string s into zigzag pattern with numRows rows.\"\"\"\n        # If only one row or the string is shorter than the number of rows,\n        # the zigzag pattern is the string itself.\n        if numRows == 1 or numRows >= len(s):\n            return s\n\n        # Prepare a list for each row.\n        rows = [''] * numRows\n        current_row, step = 0, 1\n\n        for ch in s:\n            rows[current_row] += ch\n            # Change direction when reaching the top or bottom row.\n            if current_row == 0:\n                step = 1\n            elif current_row == numRows - 1:\n                step = -1\n            current_row += step\n\n        # Concatenate all rows to get the final string.\n        return ''.join(rows)\n\ndef main():\n    data = sys.stdin.read()\n    # Try to parse inputs of the form \"s = 'string', numRows = 3\"\n    s_match = re.search(r\"s\\s*=\\s*'([^']*)'\", data)\n    n_match = re.search(r\"numRows\\s*=\\s*(\\d+)\", data)\n\n    if s_match and n_match:\n        s = s_match.group(1)\n        numRows = int(n_match.group(1))\n    else:\n        # Fallback: assume first line is the string, second line is the number\n        lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n        if len(lines) >= 2:\n            s = lines[0]\n            try:\n                numRows = int(lines[1])\n            except ValueError:\n                numRows = 1\n        else:\n            # If there's only one line, assume it's the string and numRows=1\n            s = lines[0] if lines else ''\n            numRows = 1\n\n    sol = Solution()\n    result = sol.convert(s, numRows)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'PAYPALISHIRING', numRows = 3",
          "expected_output": "'PAHNAPLSIIGYIR'",
          "success": true,
          "output": "PAHNAPLSIIGYIR"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode140.json",
    "problem_index_in_file": 0,
    "title": "Word Break II",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for word break problem returning all sentences. Use backtracking with memoization. Provide steps lines with explanations. Use arrow and Decision etc. Let's write steps:\n\nStart\n→ Step 1: 初始化 memo 為空字典 // 用於存儲子字串對應句子列表\n→ Step 2: 定義遞迴函數 dfs(start)\n    // 對於給定起始索引，返回從 start 到結束的所有句子列表\n→ Decision: 如果 start 在 memo 中? // 查看是否已計算過\n    Yes → Return memo[start] // 直接回傳已存結果\n    No  →\n→ Decision: 如果 start 等於 s.length()? // 到達字串末尾\n    Yes → Return list containing empty string // 一個空句子代表完整切分\n    No  →\n→ Step 3: 初始化 result 為空列表 // 用於儲存從 start 開始的所有句子\n→ Step 4: 循環 i 從 start+1 到 s.length() // 嘗試每個子字串\n    // 子字串為 s[start:i]\n→ Decision: 如果 s[start:i] 在 wordDict? // 子字串是字典單詞\n    Yes →\n→ Step 5: 將 dfs(i) 結果存於 subSentences // 從 i 到結束的句子列表\n→ Step 6: 對於每個 sentence in subSentences\n        // 組合當前單詞和後續句子\n→ Decision: 如果 sentence 為空字符串? // 沒有後續詞\n            Yes → Append s[start:i] 到 result // 直接加單詞\n            No  → Append s[start:i] + \" \" + sentence 到 result // 加空格分隔\n→ Step 7: 循環結束\n→ Step 8: 存入 memo[start] = result // 記錄結果\n→ Step 9: 返回 memo[start]\n→ Step 10: 呼叫 dfs(0) 並將返回值賦給 output // 完整句子列表\n→ Step 11: 返回 output // 結束\n\nEnsure each line with arrow and explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 memo 為空字典 // 用於存儲已計算過的子字串對應句子列表\n→ Step 2: 定義遞迴函數 dfs(start) // dfs 用於尋找從 start 開始到字串結尾的所有合法切分\n    // 參數 start 表示目前切分的起始索引\n→ Decision: 如果 start 在 memo 中? // 檢查是否已經計算過此起點\n    Yes → Return memo[start] // 直接回傳已存的結果\n    No  →\n→ Decision: 如果 start 等於 s.length()? // 已到達字串末尾\n    Yes → Return list containing empty string // 回傳一個空句子，表示切分完成\n    No  →\n→ Step 3: 初始化 result 為空列表 // 用於收集從 start 開始的所有合法句子\n→ Step 4: 循環 i 從 start+1 到 s.length() // 嘗試每個可能的子字串結束位置\n    // 子字串為 s[start:i]\n→ Decision: 如果 s[start:i] 在 wordDict? // 子字串是否為字典單詞\n    Yes →\n→ Step 5: 將 dfs(i) 結果存於 subSentences // 從 i 開始到結尾的所有句子\n→ Step 6: 對於每個 sentence in subSentences // 組合目前單詞與後續句子\n        // 形成新的完整句子\n→ Decision: 如果 sentence 為空字符串? // 後續無單詞\n            Yes → Append s[start:i] 到 result // 直接加入單詞\n            No  → Append s[start:i] + \" \" + sentence 到 result // 加空格分隔後續單詞\n→ Step 7: 循環結束 // 完成所有 i 的嘗試\n→ Step 8: 存入 memo[start] = result // 記錄從 start 開始的所有句子\n→ Step 9: 返回 memo[start] // 將結果回傳給上一層呼叫\n→ Step 10: 呼叫 dfs(0) 並將返回值賦給 output // 從字串起始處開始切分\n→ Step 11: 返回 output // 程式結束，輸出所有合法句子列表\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom typing import List\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        word_set = set(wordDict)\n        memo = {}\n\n        def backtrack(start: int) -> List[str]:\n            if start in memo:\n                return memo[start]\n\n            if start == len(s):\n                return [\"\"]\n\n            res: List[str] = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in word_set:\n                    for sub_sentence in backtrack(end):\n                        if sub_sentence:\n                            res.append(word + \" \" + sub_sentence)\n                        else:\n                            res.append(word)\n            memo[start] = res\n            return res\n\n        return backtrack(0)\n\ndef parse_input(data: str):\n    \"\"\"Parse input of the form: s = 'string', wordDict = ['a', 'b', ...]\"\"\"\n    s_match = re.search(r\"s\\s*=\\s*['\\\"](.*?)['\\\"]\", data)\n    word_match = re.search(r\"wordDict\\s*=\\s*\\[(.*?)\\]\", data, re.S)\n    if not s_match or not word_match:\n        raise ValueError(\"Invalid input format\")\n    s = s_match.group(1)\n    # Use ast.literal_eval to safely evaluate the list of words\n    word_list_str = \"[\" + word_match.group(1).strip() + \"]\"\n    word_dict = ast.literal_eval(word_list_str)\n    return s, word_dict\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    s, word_dict = parse_input(input_data)\n    solution = Solution()\n    result = solution.wordBreak(s, word_dict)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']",
          "expected_output": "['cats and dog','cat sand dog']",
          "success": true,
          "output": "['cat sand dog', 'cats and dog']"
        },
        {
          "example_index": 1,
          "input": "s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']",
          "expected_output": "['pine apple pen apple','pineapple pen apple','pine applepen apple']",
          "success": true,
          "output": "['pine apple pen apple', 'pine applepen apple', 'pineapple pen apple']"
        },
        {
          "example_index": 2,
          "input": "s = 'catsandog', wordDict = ['cats','dog','sand','and','cat']",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode396.json",
    "problem_index_in_file": 0,
    "title": "Rotate Function",
    "description_snippet": "You are given an integer array nums of length n.\n\nAssume arrk to be an array obtained by rotating nu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (not actual code) step by step to compute max rotation function. We need to produce lines like \"Start // ...\". Need to describe algorithm. Approach: compute sum of array and initial F(0) by summing i*nums[i]. Then iteratively compute next F by formula: F(k+1) = F(k) + sum(nums) - n*nums[n-1-k] (or something). Actually formula: F(k) = F(k-1) + sum(nums) - n*arr_{k-1}[n-1]?? Let's derive: Rotating right by 1: arrk[i] = arrk-1[(i-1+n)%n]. There is known formula: F(k) = F(k-1) + sum(nums) - n*nums[n-k] maybe. But simpler: use rotation: we can compute next F as prevF + totalSum - n*element that moves from front to back? Let's recall known solution: For each rotation, F[k] = F[k-1] + sum - n * arr[n-k] (since the element at index n-k moves to end). But it's okay. We'll implement iterative.\n\nWe will produce steps: compute totalSum, compute currentF, maxF, iterate k from1 to n-1, update currentF, maxF.\n\nReturn maxF.\n\nNow produce virtual code lines. Use arrows: \"→\". Let's structure:\n\nStart\n→ Step 1: Compute n = length(nums)\n→ Step 2: Compute totalSum = sum(nums)\n→ Step 3: Compute currentF = 0\n    → For i from 0 to n-1: currentF += i * nums[i]\n→ Step 4: maxF = currentF\n→ Decision: if n == 1? // handle trivial case\n    Yes → Return currentF\n    No  → For k from 1 to n-1:\n        → Update currentF = currentF + totalSum - n * nums[n - k] // rotation effect\n        → Decision: currentF > maxF?\n            Yes → maxF = currentF\n→ Step 5: Return maxF\nEnd\n\nBut we need each line with explanation. Use indentation for decisions. Also \"→\" before lines. Use consistent.\n\nMake sure each line is a separate virtual code step, with explanation after //.\n\nWe need to maintain arrow formatting. Example: \"→ Step 1: ...\" Good.\n\nWe should keep structure.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算陣列長度 n = length(nums) // 取得陣列元素個數  \n→ Step 2: 計算總和 totalSum = sum(nums) // 計算所有元素之和  \n→ Step 3: 初始化 currentF = 0 // 用於儲存 F(k) 的目前值  \n    → For i from 0 to n-1: currentF += i * nums[i] // 計算 F(0) 的值  \n→ Step 4: 設定 maxF = currentF // 目前已知最大值為 F(0)  \n→ Decision: n == 1? // 檢查是否只有一個元素  \n    Yes → Step 5: Return currentF // 只有一個旋轉，直接回傳  \n    No  → For k from 1 to n-1: // 逐一計算後續旋轉的 F(k)  \n        → Step 6: currentF = currentF + totalSum - n * nums[n - k] // 用公式更新 F(k)  \n        → Decision: currentF > maxF? // 檢查是否為新最大值  \n            Yes → maxF = currentF // 更新最大值  \n→ Step 7: Return maxF // 回傳所有旋轉中最大的 F(k)  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def maxRotateFunction(self, A):\n        \"\"\"\n        Compute the maximum rotation function value for the array A.\n        F(k) = sum_{i=0}^{n-1} i * arr_k[i] where arr_k is A rotated k times to the right.\n        \"\"\"\n        n = len(A)\n        if n == 0:\n            return 0\n\n        total = sum(A)                 # Sum of all elements in A\n        F = sum(i * num for i, num in enumerate(A))  # F(0)\n        max_val = F\n\n        # Iterate over rotations k = 1 .. n-1\n        # Formula: F(k) = F(k-1) + total - n * A[n-k]\n        for i in range(n - 1, 0, -1):\n            F = F + total - n * A[i]\n            if F > max_val:\n                max_val = F\n\n        return max_val\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Expect input in the form: \"nums = [4,3,2,6]\"\n    if \"=\" in data:\n        _, arr_part = data.split(\"=\", 1)\n        arr_part = arr_part.strip()\n    else:\n        arr_part = data\n\n    # Safely evaluate the list part; no external variables or functions are used\n    try:\n        nums = eval(arr_part, {}, {})\n    except Exception:\n        nums = []\n\n    solution = Solution()\n    result = solution.maxRotateFunction(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "success": true,
          "output": "26"
        },
        {
          "example_index": 1,
          "input": "nums = [100]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode307.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Mutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following types:\n\nUpdate the value of an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation. Should represent implementation of NumArray class, with constructor, update, sumRange. Use Start, End, Decision, arrows. No actual code. Use Chinese comments. Provide each line as \"虛擬碼步驟 // 解釋\". We need to cover initialization, building tree, update point, query range. Use a Binary Indexed Tree or Segment Tree? Probably choose segment tree.\n\nLet's produce stepwise algorithm:\n\nStart\n→ Step 1: 初始化 NumArray 類別，存入 nums 並建構 segment tree // 存儲原始陣列與建立結構\n→ Decision: nums 为空? // 判斷陣列是否為空\n    Yes → Step 2: 設定 tree 為空 // 若空陣列直接終止\n    No  → Step 3: 設定 size = nums.length // 獲取陣列長度\n        → Step 4: 建立 tree 陣列長度 4 * size // 為安全分配節點空間\n        → Step 5: buildTree(0, 0, size-1) // 構建 segment tree\n\n→ Step 6: 定義 buildTree(node, l, r) // 構建遞迴\n    → Decision: l == r? // 單元素\n        Yes → Step 7: tree[node] = nums[l] // 資料存入葉節點\n        No  → Step 8: mid = (l+r)/2 // 分割\n            → Step 9: buildTree(node*2+1, l, mid) // 建左子樹\n            → Step10: buildTree(node*2+2, mid+1, r) // 建右子樹\n            → Step11: tree[node] = tree[node*2+1] + tree[node*2+2] // 計算父節點值\n\n→ Step 12: 定義 update(index, val) // 更新操作\n    → Step 13: nums[index] = val // 更新原陣列\n    → Step 14: updateTree(0, 0, size-1, index, val) // 更新 segment tree\n\n→ Step 15: 定義 updateTree(node, l, r, idx, val)\n    → Decision: l == r? // 更新葉節點\n        Yes → Step 16: tree[node] = val // 設定新值\n        No  → Step 17: mid = (l+r)/2 // 分割\n            → Decision: idx <= mid? // 判斷更新哪一邊\n                Yes → Step 18: updateTree(node*2+1, l, mid, idx, val) // 更新左\n                No  → Step 19: updateTree(node*2+2, mid+1, r, idx, val) // 更新右\n            → Step 20: tree[node] = tree[node*2+1] + tree[node*2+2] // 更新父節點\n\n→ Step 21: 定義 sumRange(left, right) // 查詢操作\n    → Step 22: return queryTree(0, 0, size-1, left, right) // 進行查詢\n\n→ Step 23: 定義 queryTree(node, l, r, ql, qr)\n    → Decision: ql <= l && r <= qr? // 節點完全在查詢範圍內\n        Yes → Step 24: return tree[node] // 直接返回\n        No  → Step 25: mid = (l+r)/2 // 分割\n            → Decision: qr <= mid? // 完全在左半部\n                Yes → Step 26: return queryTree(node*2+1, l, mid, ql, qr) // 左子樹\n                No → Decision: ql > mid? // 完全在右半部\n                    Yes → Step 27: return queryTree(node*2+2, mid+1, r, ql, qr) // 右子樹\n                    No  → Step 28: leftSum = queryTree(node*2+1, l, mid, ql, mid) // 左半部分\n                        → Step 29: rightSum = queryTree(node*2+2, mid+1, r, mid+1, qr) // 右半部分\n                        → Step 30: return leftSum + rightSum // 合併結果\n\nEnd\n\nNow we must ensure each line is separate with arrow and explanation. We can keep indentation but each line separate. Let's produce accordingly. Use \"Start\" \"End\". Each step includes arrow? In example they used arrow in Step lines: \"→ Step 1:\" etc. Provide decisions with arrow \"Decision:\".\n\nWe should also include the class definition line: \"Start // 程式開始\". Could add \"→ Class NumArray { // 定義類別\" but not necessary. We can start with Start then step 1 is initialization inside constructor. Might include class structure.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始\n→ Class NumArray { // 定義 NumArray 類別\n→     Constructor(nums) // 建構子，接收初始陣列\n→         → Step 1: this.nums = nums // 儲存原始陣列\n→         → Decision: nums 为空? // 判斷陣列是否為空\n→             Yes → Step 2: this.size = 0 // 設定大小為 0\n→             No  → Step 3: this.size = nums.length // 取得陣列長度\n→                 → Step 4: this.tree = new Array(4 * this.size) // 建立 segment tree 陣列\n→                 → Step 5: this.buildTree(0, 0, this.size - 1) // 建構 segment tree\n→     Method buildTree(node, l, r) // 递归建树\n→         → Decision: l == r? // 是否到達葉節點\n→             Yes → Step 6: this.tree[node] = this.nums[l] // 設置葉節點值\n→             No  → Step 7: mid = Math.floor((l + r) / 2) // 計算中點\n→                 → Step 8: this.buildTree(node * 2 + 1, l, mid) // 建左子樹\n→                 → Step 9: this.buildTree(node * 2 + 2, mid + 1, r) // 建右子樹\n→                 → Step 10: this.tree[node] = this.tree[node * 2 + 1] + this.tree[node * 2 + 2] // 計算父節點\n→     Method update(index, val) // 更新操作\n→         → Step 11: this.nums[index] = val // 更新原陣列\n→         → Step 12: this.updateTree(0, 0, this.size - 1, index, val) // 更新 segment tree\n→     Method updateTree(node, l, r, idx, val) // 递归更新\n→         → Decision: l == r? // 是否到達葉節點\n→             Yes → Step 13: this.tree[node] = val // 設定新值\n→             No  → Step 14: mid = Math.floor((l + r) / 2) // 計算中點\n→                 → Decision: idx <= mid? // 更新左邊還是右邊\n→                     Yes → Step 15: this.updateTree(node * 2 + 1, l, mid, idx, val) // 更新左子樹\n→                     No  → Step 16: this.updateTree(node * 2 + 2, mid + 1, r, idx, val) // 更新右子樹\n→                 → Step 17: this.tree[node] = this.tree[node * 2 + 1] + this.tree[node * 2 + 2] // 更新父節點\n→     Method sumRange(left, right) // 查詢範圍和\n→         → Step 18: return this.queryTree(0, 0, this.size - 1, left, right) // 進行遞归查詢\n→     Method queryTree(node, l, r, ql, qr) // 递归查詢\n→         → Decision: ql <= l && r <= qr? // 節點完全在查詢範圍內\n→             Yes → Step 19: return this.tree[node] // 直接返回\n→             No  → Step 20: mid = Math.floor((l + r) / 2) // 計算中點\n→                 → Decision: qr <= mid? // 完全在左半部\n→                     Yes → Step 21: return this.queryTree(node * 2 + 1, l, mid, ql, qr) // 只查左子樹\n→                     No → Decision: ql > mid? // 完全在右半部\n→                         Yes → Step 22: return this.queryTree(node * 2 + 2, mid + 1, r, ql, qr) // 只查右子樹\n→                         No  → Step 23: leftSum = this.queryTree(node * 2 + 1, l, mid, ql, mid) // 左半部分\n→                             → Step 24: rightSum = this.queryTree(node * 2 + 2, mid + 1, r, mid + 1, qr) // 右半部分\n→                             → Step 25: return leftSum + rightSum // 合併左右子樹結果\n→ } // 結束 NumArray 類別\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass NumArray:\n    \"\"\"使用 Binary Indexed Tree（Fenwick Tree）實作可變範圍求和。\"\"\"\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]  # 複製陣列以避免外部修改\n        self.tree = [0] * (self.n + 1)  # BIT 以 1 為起始索引\n        for i, val in enumerate(nums):\n            self._add(i + 1, val)\n\n    def _add(self, i, delta):\n        \"\"\"將 delta 加到 BIT 的第 i 個位置，並向上更新父節點。\"\"\"\n        while i <= self.n:\n            self.tree[i] += delta\n            i += i & -i\n\n    def update(self, index, val):\n        \"\"\"更新 index 位置為 val，並同步更新 BIT。\"\"\"\n        delta = val - self.nums[index]\n        self.nums[index] = val\n        self._add(index + 1, delta)\n\n    def sumRange(self, left, right):\n        \"\"\"回傳左到右的區間和。\"\"\"\n        return self._prefix(right + 1) - self._prefix(left)\n\n    def _prefix(self, i):\n        \"\"\"計算從 0 到 i-1 的前綴和。\"\"\"\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n\n    # 先尋找第一個完整的 list (ops)\n    start = data.find('[')\n    end = data.find(']', start)\n    ops_str = data[start:end + 1]\n    args_str = data[end + 1:].lstrip(',').strip()\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == 'NumArray':\n            # arg 形如 [[1,3,5]]，取第一個元素作為陣列\n            nums = arg[0] if arg else []\n            obj = NumArray(nums)\n            results.append(None)          # 建構子沒有返回值\n        elif op == 'update':\n            obj.update(arg[0], arg[1])\n            results.append(None)          # update 也沒有返回值\n        elif op == 'sumRange':\n            val = obj.sumRange(arg[0], arg[1])\n            results.append(val)\n\n    # 將 None 轉成 null，並輸出符合 LeetCode 風格的字串\n    output = '[' + ', '.join('null' if v is None else str(v) for v in results) + ']'\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "success": true,
          "output": "[null, 9, null, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode342.json",
    "problem_index_in_file": 0,
    "title": "Power of Four",
    "description_snippet": "Given an integer n, return true if it is a power of four. Otherwise, return false.\n\nAn integer n is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. The algorithm: check if n > 0 and bitwise: only one bit set and that bit position is even (since 4^x = 2^(2x)). Approach: if n>0 and (n & (n-1)) ==0 and (n-1)/2 %2? Actually we need to check (n & (n-1)) == 0 ensures power of two, then check (log2(n) % 2 == 0). Alternatively, use while loop dividing by 4. We'll choose simple: while n%4==0 n/=4; if n==1 true else false. But need to handle n<=0 false.\n\nLet's produce virtual steps.\n\nPseudo:\n\nStart\n→ Input n\n→ Decision: if n <= 0? // negative or zero cannot be power of four\n    No → Decision: if n == 1? // 4^0=1\n        Yes → Output true\n        No  → Step: While n % 4 == 0 // divide by 4 repeatedly\n            → Update n = n / 4\n        → Decision: if n == 1? // after divisions\n            Yes → Output true\n            No  → Output false\nEnd\n\nBut we must use virtual arrows. Let's produce each step. Use \"Decision:\" lines with indentation.\n\nNeed to provide each line with \"// 解釋/說明\". Provide steps line by line. Use \"Start\", \"→\", \"Decision:\", \"Yes →\", \"No →\", \"End\".\n\nWe must be careful to not output code, just virtual steps. Provide explanations. Provide each line.\n\nLet's craft.\n\nLine1: Start // 程式開始\n\nLine2: → Input n // 取得使用者輸入的整數\n\nLine3: → Decision: 如果 n <= 0? // 小於等於零不是四的冪\n\nLine4: No → Decision: 如果 n == 1? // 1 是 4^0 的特殊情況\n\nLine5: Yes → Output true // 確認是四的冪\n\nLine6: No  → Step: while n % 4 == 0  // 只要 n 能被 4 整除就除以 4\n\nLine7: → Update n = n / 4 // 除以 4\n\nLine8: → Decision: 如果 n == 1? // 迴圈結束後檢查 n 是否為 1\n\nLine9: Yes → Output true // 成功判斷為四的冪\n\nLine10: No  → Output false // 不是四的冪\n\nLine11: End // 程式結束\n\nBut we need arrow formatting: \"Yes →\" \"No →\". For Step: we might need to indicate \"→ Step:\"? In example they used \"→ Step 1:\". So we can use \"→ Step:\". Use consistent arrow.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Input n // 取得使用者輸入的整數\n→ Decision: 如果 n <= 0? // 小於等於零不是四的冪\n    No → Decision: 如果 n == 1? // 1 是 4^0 的特殊情況\n        Yes → Output true // 確認是四的冪\n        No  → Step: while n % 4 == 0  // 只要 n 能被 4 整除就除以 4\n            → Update n = n / 4 // 除以 4\n        → Decision: 如果 n == 1? // 迴圈結束後檢查 n 是否為 1\n            Yes → Output true // 成功判斷為四的冪\n            No  → Output false // 不是四的冪\nEnd // 程式執行結束\n\nWe need indentations. Use spaces. In example, they indent with 4 spaces? They used 4 spaces inside decision branches. We'll replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 取得使用者輸入的整數  \n→ Decision: 如果 n <= 0? // 小於等於零不是四的冪  \n    No → Decision: 如果 n == 1? // 1 是 4^0 的特殊情況  \n        Yes → Output true // 確認是四的冪  \n        No  → Step: while n % 4 == 0  // 只要 n 能被 4 整除就除以 4  \n            → Update n = n / 4 // 除以 4  \n        → Decision: 如果 n == 1? // 迴圈結束後檢查 n 是否為 1  \n            Yes → Output true // 成功判斷為四的冪  \n            No  → Output false // 不是四的冪  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        \"\"\"\n        判斷 n 是否為 4 的冪次方。\n        1. n 必須為正整數。\n        2. n 必須是 2 的冪次方（即只有一個二進位 1）。\n        3. 4^x - 1 必須能被 3 整除，這是 4^x 的另一個特性。\n        \"\"\"\n        return n > 0 and (n & (n - 1)) == 0 and (n - 1) % 3 == 0\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 從輸入字串中尋找第一個整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n\n    n = int(match.group())\n    sol = Solution()\n    # 判斷結果\n    result = sol.isPowerOfFour(n)\n    # 將布林值轉成小寫字串並輸出\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode327.json",
    "problem_index_in_file": 0,
    "title": "Count of Range Sum",
    "description_snippet": "Given an integer array nums and two integers lower and upper, return the number of range sums that l...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: count range sums in [lower, upper]. Classic problem: count of subarray sums in a range. Use prefix sums and divide and conquer (like merge sort) or Fenwick tree with coordinate compression.\n\nWe must produce step-by-step virtual code. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe should show Start, End, Decision, Step lines. Use arrows.\n\nLet's produce algorithm using prefix sums + merge sort count. Steps:\n\n- Compute prefix sums array of length n+1: ps[0]=0; ps[i]=ps[i-1]+nums[i-1]\n- Define recursive function count_while_merge(lo, hi) on ps array returns count of valid ranges in [lo, hi) and sorts ps[lo:hi].\n- Base: if hi - lo <=1 return 0\n- mid = (lo+hi)//2\n- count = count_while_merge(lo, mid) + count_while_merge(mid, hi)\n- For each left index in [lo,mid): find count of right indices in [mid, hi) where ps[right]-ps[left] in [lower, upper].\n- Use two pointers l, r to find bounds.\n- After counting, merge sorted halves.\n- Return count.\n\nFinally call count_while_merge(0, n+1) and return.\n\nWe'll output each step with comments.\n\nNeed to use virtual code arrows and decision.\n\nWe need to provide code lines like:\n\nStart // 程式開始執行\n→ Step: 建立前綴和陣列 ps // ...\n→ Function: count_while_merge(lo, hi) // ...\n→ Decision: hi - lo <= 1? // ...\n    Yes → Return 0 // ...\n    No  → ...\n→ Step: mid = (lo+hi)/2 // ...\n→ Step: left_count = count_while_merge(lo, mid) // ...\n→ Step: right_count = count_while_merge(mid, hi) // ...\n→ Step: total = left_count + right_count // ...\n→ Step: l = r = mid // ...\n→ Decision: for each i in [lo, mid) // ...\n    → Step: while l < hi and ps[l] - ps[i] < lower: l++ // ...\n    → Step: while r < hi and ps[r] - ps[i] <= upper: r++ // ...\n    → Step: total += r - l // ...\n→ Step: merge ps[lo:mid] and ps[mid:hi] // ...\n→ Return total // ...\nEnd // 程式結束\n\nNeed to output virtual code step lines sequentially. Must not output actual code. Just virtual steps.\n\nLet's write. Use \"→\" for step lines. Use \"Decision:\" lines.\n\nWe also need to show function definition: \"Function: count_while_merge(lo, hi) // 定義遞迴函式\".\n\nOk produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 建立前綴和陣列 ps，ps[0] = 0 // 初始化前綴和  \n→ Step: for i = 1 to nums.length: ps[i] = ps[i-1] + nums[i-1] // 依序累加得到前綴和  \n→ Function: count_while_merge(lo, hi) // 定義遞迴範圍和計數函式  \n→ Decision: hi - lo <= 1? // 判斷子陣列長度是否為 0 或 1  \n    Yes → Return 0 // 沒有子陣列可算，直接回傳 0  \n    No → Step: mid = (lo + hi) // 2 // 計算中點索引  \n→ Step: left_count = count_while_merge(lo, mid) // 計算左半段的有效範圍數量  \n→ Step: right_count = count_while_merge(mid, hi) // 計算右半段的有效範圍數量  \n→ Step: total = left_count + right_count // 初始化總計數  \n→ Step: l = mid // 初始化左指標，用於找 lower 的下界  \n→ Step: r = mid // 初始化右指標，用於找 upper 的上界  \n→ Decision: for i from lo to mid-1? // 遍歷左半段的每個前綴和  \n    Yes → Step: while l < hi and ps[l] - ps[i] < lower: l++ // 移動 l 到 lower 的合法最小右端  \n    Yes → Step: while r < hi and ps[r] - ps[i] <= upper: r++ // 移動 r 到 upper 的合法最大右端  \n    Yes → Step: total += r - l // 將符合條件的右端數量加到總計數  \n    No → // 循環結束  \n→ Step: merge ps[lo:mid] and ps[mid:hi] // 將兩半已排序的前綴和合併為一個整體有序序列  \n→ Return total // 回傳本層遞迴計算的總數  \nEnd // 程式結束  \n\n# 呼叫主程式  \n→ Step: result = count_while_merge(0, ps.length) // 以整個前綴和陣列作為範圍呼叫遞迴  \n→ Step: return result // 回傳最終的範圍和計數結果",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def countRangeSum(self, nums, lower, upper):\n        # 建立前綴和陣列\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n\n        # 以 merge sort 的方式統計範圍和的數量\n        def sort_and_count(lo, hi):\n            if hi - lo <= 1:\n                return 0\n            mid = (lo + hi) // 2\n            count = sort_and_count(lo, mid) + sort_and_count(mid, hi)\n\n            i = j = mid\n            # 為每個左側前綴和計算符合條件的右側前綴和範圍\n            for left in prefix[lo:mid]:\n                while i < hi and prefix[i] - left < lower:\n                    i += 1\n                while j < hi and prefix[j] - left <= upper:\n                    j += 1\n                count += j - i\n\n            # 合併兩半排序後的前綴和\n            prefix[lo:hi] = sorted(prefix[lo:hi])\n            return count\n\n        return sort_and_count(0, len(prefix))\n\ndef parse_input(data: str):\n    # 取出 nums 陣列\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if nums_match:\n        nums_str = nums_match.group(1)\n        nums = ast.literal_eval(nums_str)\n    else:\n        # 若直接提供列表，嘗試解譯整段文本\n        nums = ast.literal_eval(re.findall(r'\\[.*\\]', data)[0])\n\n    # 取出 lower\n    lower_match = re.search(r'lower\\s*=\\s*(-?\\d+)', data)\n    lower = int(lower_match.group(1)) if lower_match else int(data.split()[1])\n\n    # 取出 upper\n    upper_match = re.search(r'upper\\s*=\\s*(-?\\d+)', data)\n    upper = int(upper_match.group(1)) if upper_match else int(data.split()[-1])\n\n    return nums, lower, upper\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    nums, lower, upper = parse_input(raw_input)\n    sol = Solution()\n    result = sol.countRangeSum(nums, lower, upper)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,5,-1], lower = -2, upper = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0], lower = 0, upper = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode228.json",
    "problem_index_in_file": 0,
    "title": "Summary Ranges",
    "description_snippet": "You are given a sorted unique integer array nums.\n\nA range [a,b] is the set of all integers from a t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step by step, line by line. Should describe algorithm for summarization ranges of sorted unique array. Provide virtual code steps with comments. Should not output actual code. Should use arrows and structure. Must follow format.\n\nWe should produce something like:\n\nStart\n→ Step 1: initialize result list // ...\n→ Decision: if nums is empty? // ...\nYes → End // ...\nNo → Step 2: initialize start = nums[0], prev = nums[0]\n→ For i from 1 to len(nums)-1: // iterate\n    → If nums[i] == prev + 1: // consecutive\n        → Set prev = nums[i] // extend current range\n    → Else:\n        → Append range [start, prev] to result // add previous range\n        → Set start = nums[i], prev = nums[i] // new range\n→ After loop: append final range [start, prev] // last range\n→ Step 3: convert ranges to strings\n→ For each range: if start==end: add str(start) else: add f\"{start}->{end}\"\n→ End\n\nNeed each line virtual code and explanation. Use arrow notation. Use \"→\" preceding each step. Use \"Decision:\" for if statements. Use indentation.\n\nLet's write lines.\n\nProbably we need to output each line exactly as specified.\n\nAlso need to use \"Start // 程式開始執行\". End.\n\nSo produce.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Decision: 是否 nums 為空? // 判斷輸入是否為空陣列\n    Yes → End // 空陣列直接結束\n    No  → Step 1: 初始化變數 start, prev 為 nums[0] // 建立第一個區間的起點與前一個數值\n→ Step 2: 從 index 1 開始遍歷 nums // 遍歷除第一個以外的元素\n    → Decision: nums[i] == prev + 1? // 判斷當前數字是否與前一個連續\n        Yes → Step 3: 更新 prev 為 nums[i] // 連續則延伸區間\n        No  → Step 4: 將區間 [start, prev] 加入結果列表 // 將完成的區間加入結果\n              → Step 5: 設置 start, prev 為 nums[i] // 開始新的區間\n→ Step 6: 迴圈結束後，將最後一個區間 [start, prev] 加入結果列表 // 加入最後一個區間\n→ Step 7: 將結果列表轉換為字串表示 // 轉成 \"a->b\" 或 \"a\"\n→ End // 程式執行結束\n\nNeed each line: \"虛擬碼步驟\" + space + \"// 解釋/說明\". So we should format each line with virtual code step then comment. Use arrow and Decision.\n\nSo produce lines:\n\nStart // 程式開始執行\n→ Decision: nums 是否為空? // 判斷輸入是否為空陣列\n    Yes → End // 空陣列直接結束\n    No  → Step 1: 初始化 start, prev 為 nums[0] // 建立第一個區間的起點與前一個數值\n→ Step 2: 從 index 1 開始遍歷 nums // 遍歷除第一個以外的元素\n    → Decision: nums[i] == prev + 1? // 判斷當前數字是否與前一個連續\n        Yes → Step 3: prev = nums[i] // 連續則延伸區間\n        No  → Step 4: 結果.append([start, prev]) // 將完成的區間加入結果\n              → Step 5: start = nums[i]; prev = nums[i] // 開始新的區間\n→ Step 6: 結果.append([start, prev]) // 加入最後一個區間\n→ Step 7: 將結果轉換為字串表示 // 轉成 \"a->b\" 或 \"a\"\nEnd // 程式執行結束\n\nBut each line must include comment after // but we also need to keep arrow indent? The example uses indentation for decision. We should follow that.\n\nBetter to include each line as separate statement with comment. Use arrow to denote steps, Decision block. The arrow for decision: \"Decision:\" then nested Yes→ etc. So each line with arrow? Example:\n\n→ Decision: If number > 0? // check positive\n    Yes → Step 2: ...\n    No  → Decision: ...\n\nSo we need to indent the nested lines.\n\nThus produce:\n\nStart // 程式開始執行\n→ Decision: nums 是否為空? // 判斷輸入是否為空陣列\n    Yes → End // 空陣列直接結束\n    No  → Step 1: 初始化 start, prev 為 nums[0] // 建立第一個區間的起點與前一個數值\n→ Step 2: 從 index 1 開始遍歷 nums // 遍歷除第一個以外的元素\n    → Decision: nums[i] == prev + 1? // 判斷當前數字是否與前一個連續\n        Yes → Step 3: prev = nums[i] // 連續則延伸區間\n        No  → Step 4: 結果.append([start, prev]) // 將完成的區間加入結果\n              → Step 5: start = nums[i]; prev = nums[i] // 開始新的區間\n→ Step 6: 結果.append([start, prev]) // 加入最後一個區間\n→ Step 7: 將結果轉換為字串表示 // 轉成 \"a->b\" 或 \"a\"\nEnd // 程式執行結束\n\nNeed to ensure each line ends with // 解釋. Also lines within decision block maybe separate lines.\n\nWe should maybe break Step 5 into separate lines? But okay.\n\nCheck format: Each line has \"虛擬碼步驟\" followed by space then \"// 解釋\". So each line after arrow etc includes comment. Indentation inside decision may cause lines to not have comment after arrow? We still keep comment.\n\nThus final answer will include these lines. Use Chinese explanation. Ensure no actual code. Use arrows and Decision.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: nums 是否為空? // 判斷輸入是否為空陣列\n    Yes → End // 空陣列直接結束\n    No  → Step 1: 初始化 start, prev 為 nums[0] // 建立第一個區間的起點與前一個數值\n→ Step 2: 從 index 1 開始遍歷 nums // 遍歷除第一個以外的元素\n    → Decision: nums[i] == prev + 1? // 判斷當前數字是否與前一個連續\n        Yes → Step 3: prev = nums[i] // 連續則延伸區間\n        No  → Step 4: 結果.append([start, prev]) // 將完成的區間加入結果\n              → Step 5: start = nums[i]; prev = nums[i] // 開始新的區間\n→ Step 6: 結果.append([start, prev]) // 加入最後一個區間\n→ Step 7: 將結果轉換為字串表示 // 轉成 \"a->b\" 或 \"a\"\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef summary_ranges(nums):\n    if not nums:\n        return []\n    result = []\n    start = end = nums[0]\n    for n in nums[1:]:\n        if n == end + 1:\n            end = n\n        else:\n            if start == end:\n                result.append(str(start))\n            else:\n                result.append(f\"{start}->{end}\")\n            start = end = n\n    if start == end:\n        result.append(str(start))\n    else:\n        result.append(f\"{start}->{end}\")\n    return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = data\n    nums = ast.literal_eval(list_part)\n    ranges = summary_ranges(nums)\n    # Output in the required format: [\"a->b\",\"c\",\"d->e\"]\n    output = '[' + ','.join(f'\"{r}\"' for r in ranges) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,2,4,5,7]",
          "expected_output": "[\"0->2\",\"4->5\",\"7\"]",
          "success": true,
          "output": "[\"0->2\",\"4->5\",\"7\"]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,2,3,4,6,8,9]",
          "expected_output": "[\"0\",\"2->4\",\"6\",\"8->9\"]",
          "success": true,
          "output": "[\"0\",\"2->4\",\"6\",\"8->9\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode731.json",
    "problem_index_in_file": 0,
    "title": "My Calendar II",
    "description_snippet": "You are implementing a program to use as your calendar. We can add a new event if adding the event w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output pseudocode for MyCalendarTwo. Typical solution: maintain intervals and overlapping counts using a sweep line or storing intervals and double bookings. Approach: keep list of intervals and list of double bookings. When booking new event, first check that it doesn't overlap with any double booking. Then for each existing interval, if overlap, add the overlapped portion to double bookings. Add event to intervals. Return true.\n\nSo pseudocode steps: Start, initialize lists, book function: check overlap with double bookings: iterate each double interval: if overlap return false. Then iterate existing intervals: if overlap, add overlapped interval to double bookings. Then add event to intervals. Return true. End.\n\nWe need to produce each step line with explanation. Use Start, End, Decision.\n\nWe'll create high-level steps: Start MyCalendarTwo class: initialize.\n\nThen book function: Start, Step 1: Check triple overlap.\n\nSo produce something like:\n\nStart // Program start\n→ Step 1: Initialize empty list events // Store all booked events\n→ Step 2: Initialize empty list doubleEvents // Store all double booked intervals\n...\nDefine book(start, end):\n    → Step 1: For each interval in doubleEvents:\n        → Decision: if overlap? // check intersection\n            Yes → Return false // triple booking would occur\n    → Step 2: For each interval in events:\n        → Decision: if overlap? // new event overlaps existing\n            Yes → Determine overlapStart, overlapEnd\n            → Add interval [overlapStart, overlapEnd] to doubleEvents // record double booking\n    → Step 3: Add [start, end] to events // add new event\n    → Return true // booking succeeded\n\nReturn to End.\n\nWe'll provide line by line pseudocode with explanation. Use arrow indentation. Ensure each line includes // explanation.\n\nAlso include End at end.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Initialize events ← empty list // 用來存所有已成功預訂的事件\n→ Step 2: Initialize doubleEvents ← empty list // 用來存所有已造成兩重預訂的區間\n\nDefine book(start, end): // 嘗試新增事件\n    → Step 3: For each interval in doubleEvents: // 檢查是否會產生三重預訂\n        → Decision: 是否有交集? (interval overlaps [start, end]) // 判斷交集\n            Yes → Return false // 三重預訂，拒絕新增\n    → Step 4: For each interval in events: // 檢查與已預訂事件的重疊\n        → Decision: 是否有交集? (interval overlaps [start, end]) // 判斷交集\n            Yes → Set overlapStart ← max(interval.start, start)\n            → Set overlapEnd ← min(interval.end, end)\n            → Step 5: Add [overlapStart, overlapEnd] to doubleEvents // 記錄兩重預訂區間\n    → Step 6: Add [start, end] to events // 成功新增事件\n    → Return true // 事件已成功加入日曆\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass MyCalendarTwo:\n    \"\"\"\n    MyCalendarTwo 以兩個列表維護已預約的事件與雙重預約區間。\n    1. booked   : 所有已成功加入的事件 [start, end)\n    2. overlaps : 所有造成兩重預約的區間，任何三重預約都被拒絕\n    \"\"\"\n    def __init__(self):\n        self.booked = []      # 存放所有已預訂的區間\n        self.overlaps = []    # 存放所有已發生雙重預約的區間\n\n    def book(self, start: int, end: int) -> bool:\n        # 先檢查是否與已存在的雙重區間重疊，若有則會產生三重預約，拒絕\n        for s, e in self.overlaps:\n            if max(s, start) < min(e, end):\n                return False\n\n        # 之後檢查與所有已預訂區間的重疊\n        for s, e in self.booked:\n            if max(s, start) < min(e, end):\n                # 記錄重疊區間為新的雙重區間\n                self.overlaps.append((max(s, start), min(e, end)))\n\n        # 最後把新事件加入已預訂列表\n        self.booked.append((start, end))\n        return True\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    # 輸入格式為兩個列表，用 '], ' 分隔\n    try:\n        first_part, second_part = raw.split('],', 1)\n        first_part += ']'                # 補回閉括號\n        second_part = '[' + second_part  # 補回開括號\n        commands = ast.literal_eval(first_part)\n        arguments = ast.literal_eval(second_part)\n    except Exception as e:\n        # 若解析失敗，直接退出\n        sys.exit(1)\n\n    outputs = []\n    obj = None\n\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"MyCalendarTwo\":\n            obj = MyCalendarTwo()\n            outputs.append(None)            # constructor 回傳 null\n        elif cmd == \"book\" and obj is not None:\n            res = obj.book(args[0], args[1])\n            outputs.append(res)\n        else:\n            outputs.append(None)            # 其他命令或錯誤時回傳 null\n\n    # 印出結果\n    print(outputs)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, true, true, true, false, true, true]",
          "success": false,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode560.json",
    "problem_index_in_file": 0,
    "title": "Subarray Sum Equals K",
    "description_snippet": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting subarrays with sum equal to k. Use prefix sum + hash map. Provide step by step.\n\nWe must output in Chinese Traditional. Use Start, End, Decision. Provide each line: \"虛擬碼步驟 // 解釋\".\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 建立哈希表 prefixCount，初始值 {0:1} // 以存儲前綴和及其出現次數，0 代表空前綴和\n→ Step 2: 建立變量 currentSum = 0 // 用來累計目前前綴和\n→ Step 3: 建立變量 result = 0 // 用來累計符合條件的子陣列數\n→ Step 4: 對陣列 nums 中每個元素 num 進行迴圈 // 遍歷整個數組\n    → Step 5: currentSum = currentSum + num // 更新前綴和\n    → Decision: 是否存在 (currentSum - k) 在 prefixCount? // 檢查是否已有前綴和能形成目標和\n        Yes → Step 6: result = result + prefixCount[currentSum - k] // 若存在，累加對應出現次數\n        No  → Step 7: 跳過 // 無對應前綴和，不改變結果\n    → Step 8: 更新 prefixCount[currentSum] = prefixCount.get(currentSum, 0) + 1 // 記錄此前綴和出現次數\nEnd // 程式結束，結果在 result 內\n\nMake sure each line ends with // 解釋. Use arrow after step, but we must show as per format: \"Step X: ... // ...\" preceded by arrow.\n\nThey said: use \"虛擬碼步驟\" then space then \"// 解釋\". Use arrow \"→\" before each step.\n\nWe need to ensure formatting: \"Start // 程式開始執行\" etc. Use arrow for steps: \"→ Step 1: ...\" etc. Use Decision with Yes → and No →.\n\nThus produce as lines:\n\nStart // 程式開始執行\n→ Step 1: 建立哈希表 prefixCount，初始值 {0:1} // 用於存儲前綴和及其出現次數，0 代表空前綴和\n→ Step 2: 建立變量 currentSum = 0 // 用於累計目前前綴和\n→ Step 3: 建立變量 result = 0 // 用於累計符合條件的子陣列數\n→ Step 4: 對陣列 nums 中每個元素 num 進行迴圈 // 遍歷整個數組\n    → Step 5: currentSum = currentSum + num // 更新前綴和\n    → Decision: 是否存在 (currentSum - k) 在 prefixCount? // 檢查是否已有前綴和能形成目標和\n        Yes → Step 6: result = result + prefixCount[currentSum - k] // 若存在，累加對應出現次數\n        No  → Step 7: 跳過 // 無對應前綴和，不改變結果\n    → Step 8: 更新 prefixCount[currentSum] = prefixCount.get(currentSum, 0) + 1 // 記錄此前綴和出現次數\nEnd // 程式執行結束\n\nWe need to ensure indentation for nested steps; but just plain lines with spaces. Use tab or spaces? Provide with spaces.\n\nMake sure lines like \"Decision:\" line indent as 4 spaces maybe. Provide \"Decision:\" then lines under it.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立哈希表 prefixCount，初始值 {0:1} // 用於存儲前綴和及其出現次數，0 代表空前綴和\n→ Step 2: 建立變量 currentSum = 0 // 用於累計目前前綴和\n→ Step 3: 建立變量 result = 0 // 用於累計符合條件的子陣列數\n→ Step 4: 對陣列 nums 中每個元素 num 進行迴圈 // 遍歷整個數組\n    → Step 5: currentSum = currentSum + num // 更新前綴和\n    → Decision: 是否存在 (currentSum - k) 在 prefixCount? // 檢查是否已有前綴和能形成目標和\n        Yes → Step 6: result = result + prefixCount[currentSum - k] // 若存在，累加對應出現次數\n        No  → Step 7: 跳過 // 無對應前綴和，不改變結果\n    → Step 8: 更新 prefixCount[currentSum] = prefixCount.get(currentSum, 0) + 1 // 記錄此前綴和出現次數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def subarraySum(self, nums, k):\n        \"\"\"計算連續子陣列中和為 k 的個數\"\"\"\n        count = 0\n        prefix_sum = 0\n        sum_map = {0: 1}  # 前綴和 0 出現一次，代表空前綴\n\n        for num in nums:\n            prefix_sum += num\n            # 若前綴和減去 k 仍在 map，代表有子陣列和為 k\n            if prefix_sum - k in sum_map:\n                count += sum_map[prefix_sum - k]\n            # 更新前綴和的出現次數\n            sum_map[prefix_sum] = sum_map.get(prefix_sum, 0) + 1\n\n        return count\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析列表\n    list_match = re.search(r'\\[.*?\\]', data)\n    nums = ast.literal_eval(list_match.group()) if list_match else []\n\n    # 解析 k 的值\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    k = int(k_match.group(1)) if k_match else 0\n\n    solution = Solution()\n    result = solution.subarraySum(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,1,1], k = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[1,2,3], k = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode600.json",
    "problem_index_in_file": 0,
    "title": "Non-negative Integers without Consecutive Ones",
    "description_snippet": "Given a positive integer n, return the number of the integers in the range [0, n] whose binary repre...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code with line-by-line explanation. For the problem: count integers 0..n whose binary representation has no consecutive ones. Known as Fibonacci numbers, DP on bits. We will produce steps: get binary of n, compute DP arrays for length and previous bit, iterate bits, compute result, add when bit is 1 etc. We'll produce steps using virtual code: Start, Step 1: Convert n to binary string, Step 2: Initialize dp[0] = 1, dp[1] = 2? Wait standard algorithm: Let fib array where fib[i] = number of binary strings of length i without consecutive ones. fib[0] = 1 (empty string), fib[1] = 2 (0,1). For each bit from most significant to least, maintain prev bit. The algorithm: for i from len-1 to 0: if bit is '1': add fib[i] to count. If prev bit also 1: break. Set prev=1 if current bit is 1 else 0. After loop, add 1 for n itself (if no consecutive ones). That yields result. We'll produce virtual code accordingly.\n\nWe must output each line with arrow and explanation. Use Start, Step 1: etc. Should use arrow →.\n\nMake sure no actual code. Use virtual code with \"→ Step x:\".\n\nLet's craft.\n\nAlso need to handle break: maybe use Decision: if current bit == 1? etc.\n\nWe'll produce like:\n\nStart // Program start\n→ Step 1: Convert n to binary string bits // 把 n 轉成二進制字串\n→ Step 2: Initialize fib[0] = 1, fib[1] = 2 // 先算沒有連續 1 的字串數\n→ Step 3: For i from 2 to len(bits) - 1: fib[i] = fib[i-1] + fib[i-2] // Fibonacci sequence\n→ Step 4: Set count = 0, prev = 0 // 進行位元掃描\n→ Step 5: For pos from 0 to len(bits)-1: // 逐位檢查\n    → Decision: bits[pos] == '1'? // 判斷當前位是否為 1\n        Yes → Step 6: count += fib[len(bits)-pos-1] // 加上以此位為 1 的所有合法組合\n        No  → // nothing\n    → Decision: prev == 1 AND bits[pos] == '1'? // 若連續 1 出現\n        Yes → Step 7: Go to End  // 無合法組合，結束計算\n        No  → // continue\n    → Step 8: prev = bits[pos] // 更新前一位資訊\n→ Step 9: count += 1 // 包含 n 本身\nEnd // 完成\n\nWe need to ensure the arrows. Use arrow after each step. For decisions, include Yes → Step etc. For break we can use \"Go to End\" maybe \"End\". But we want to maintain structure.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 n 轉成二進位字串 bits // 取得 n 的位元表示  \n→ Step 2: 初始化 fib[0] = 1, fib[1] = 2 // 計算沒有連續 1 的長度為 i 的所有字串數  \n→ Step 3: For i = 2 to len(bits)-1: fib[i] = fib[i-1] + fib[i-2] // 產生 Fibonacci 序列  \n→ Step 4: 設定 count = 0, prev = 0 // 用於累計合法數量與追蹤前一位  \n→ Step 5: For pos = 0 to len(bits)-1: // 逐位檢查每個位元  \n&nbsp;&nbsp;Decision: bits[pos] == '1'? // 判斷此位是否為 1  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: count += fib[len(bits)-pos-1] // 加上此位為 1 時，剩餘位數的合法組合  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → // 這位為 0，無需累加  \n&nbsp;&nbsp;Decision: prev == 1 AND bits[pos] == '1'? // 檢查是否出現連續 1  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → End // 連續 1 出現，直接結束計算  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → // 繼續往下  \n&nbsp;&nbsp;Step 8: prev = bits[pos] // 更新前一位資訊  \n→ Step 9: count += 1 // 包括 n 本身，若其不含連續 1 時已計算進 count  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findIntegers(self, n: int) -> int:\n        \"\"\"\n        Count numbers in [0, n] whose binary representations have no consecutive ones.\n        \"\"\"\n        # dp[i] = number of binary strings of length i without consecutive ones\n        dp = [0] * 32\n        dp[0] = 1          # empty string\n        dp[1] = 2          # \"0\", \"1\"\n        for i in range(2, 32):\n            dp[i] = dp[i - 1] + dp[i - 2]  # Fibonacci recurrence\n\n        ans = 0\n        prev_bit = 0  # was the previous bit a 1?\n\n        # Iterate over bits from most significant to least significant\n        for i in reversed(range(31)):\n            if n & (1 << i):\n                ans += dp[i]            # add all strings that have 0 at this position\n                if prev_bit:            # consecutive 1 found\n                    return ans\n                prev_bit = 1\n            else:\n                prev_bit = 0\n\n        # If we reach here, n itself has no consecutive ones\n        return ans + 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Extract the first integer from the input (handles formats like \"n = 5\")\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        raise ValueError(\"No integer found in input.\")\n    n = int(match.group())\n    sol = Solution()\n    result = sol.findIntegers(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "n = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode282.json",
    "problem_index_in_file": 0,
    "title": "Expression Add Operators",
    "description_snippet": "Given a string num that contains only digits and an integer target, return all possibilities to inse...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments for algorithm: expression add operators to match target. This is classic LeetCode 282. Approach: backtracking recursion exploring each position, building expression string and current value and last multiplication factor to handle precedence.\n\nWe need to output step by step virtual code. We should show Start, then parse input, then define backtrack function, then recursion, decisions, etc.\n\nWe must produce lines with \"虛擬碼步驟\" + \" // 解釋/說明\". Use arrow \"→\" for steps, and \"Decision:\" etc. Use Start End. Provide detailed lines. No actual code. Just pseudocode lines.\n\nWe need to show variable definitions, recursion, decisions for operator insertion, handling leading zeros, evaluation. Should show base case, recursion loop, building next operand string, updating value and last multiplier, etc.\n\nWe need to produce line by line, using \"→\" arrow before each step. We can indent nested decisions. Use \"Decision:\" lines.\n\nWe should keep pseudocode simple.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化輸入字符串 num 與目標值 target // 獲取問題參數  \n→ Step 2: 建立空的結果列表 results // 用於儲存符合條件的表達式  \n\n// 定義遞迴函式 backtrack(index, expr, curr, last)  \n→ Function backtrack(index, expr, curr, last)  \n→ Decision: 如果 index 等於 num 的長度? // 已經處理完所有位元  \n  Yes → Step 3: 如果 curr 等於 target?  \n    Yes → Step 4: 把 expr 加入 results // 找到合法表達式  \n    No  → Step 5: 返回 // 不符合目標值  \n  No → Step 6: 循環 i 從 index 到 len(num)-1  \n    Decision: 取子串 num[index..i] 作為 next_num_str // 取下一個可能的數字  \n     Yes → Decision: next_num_str 是否以 '0' 開頭且長度>1? // 檢查前導零  \n      Yes → Step 7: 連續跳過這個 i // 前導零非法，跳過  \n      No  → Step 8: 將 next_num_str 轉為整數 next_num // 解析成數字  \n      Decision: 是否是第一個數字 (index==0)? // 第一次不加運算子  \n       Yes → Step 9: 呼叫 backtrack(i+1, next_num_str, next_num, next_num) // 直接進入下一步  \n      No  → Decision: 是否選 '+'?  \n       Yes → Step 10: 呼叫 backtrack(i+1, expr+'+'+next_num_str, curr+next_num, next_num) // 加法  \n       No → Decision: 是否選 '-'?  \n        Yes → Step 11: 呼叫 backtrack(i+1, expr+'-'+next_num_str, curr-next_num, -next_num) // 減法  \n        No → Step 12: 呼叫 backtrack(i+1, expr+'*'+next_num_str, curr-last+last*next_num, last*next_num) // 乘法，調整上一次乘法的影響  \n\nEnd // 程式執行結束  \n→ Step 13: 呼叫 backtrack(0, \"\", 0, 0) // 開始遞迴  \n→ Step 14: 回傳 results // 輸出所有符合目標的表達式集合",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        \"\"\"Return all expressions that evaluate to target.\"\"\"\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int) -> None:\n            \"\"\"DFS exploring all ways to insert operators.\"\"\"\n            # Base case: all digits processed\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            # Try every possible next number (no leading zeros)\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n\n                if index == 0:\n                    # First number: no operator before it\n                    backtrack(i, temp, curr, curr)\n                else:\n                    # Insert '+'\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    # Insert '-'\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    # Insert '*'\n                    backtrack(i, path + '*' + temp,\n                              value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\n\ndef main() -> None:\n    \"\"\"Read input, invoke Solution, and print the result.\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract num and target using regular expressions\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]+)\"', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    if not num_match or not target_match:\n        return\n\n    num = num_match.group(1)\n    target = int(target_match.group(1))\n\n    solution = Solution()\n    result = solution.addOperators(num, target)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1+2+3\",\"1*2*3\"]",
          "success": true,
          "output": "['1+2+3', '1*2*3']"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2+3*2\",\"2*3+2\"]",
          "success": true,
          "output": "['2+3*2', '2*3+2']"
        },
        {
          "example_index": 2,
          "input": "num = \"3456237490\", target = 9191",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode167.json",
    "problem_index_in_file": 0,
    "title": "Two Sum II - Input Array Is Sorted",
    "description_snippet": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanation for two-sum problem using sorted array, two pointers. Should be constant extra space.\n\nWe output each line as: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nWe need to output Start, then Steps, Decision. Use \"→\" for arrow.\n\nLet's produce:\n\nStart\n→ Initialize left pointer to 0 // 1-indexed array, but internal pointer 0\n→ Initialize right pointer to length-1 // 最右端\n→ Decision: while left < right? // 迴圈條件\n    Yes → Step: current_sum = numbers[left] + numbers[right] // 計算目前兩數之和\n    → Decision: current_sum == target? // 比較\n        Yes → Step: Return [left+1, right+1] // 轉為 1-indexed 並返回\n        No  → Decision: current_sum < target? // 需要更大和\n            Yes → Step: left = left + 1 // 左指標右移\n            No  → Step: right = right - 1 // 右指標左移\n    No → End // left >= right\n\nBut we need to use structure \"Decision:\" etc. Provide each line with \"→\" indenting? In example they used indentation with spaces but we can just use arrows.\n\nLet's produce with proper indentation.\n\nStart // 程式開始執行\n→ Decision: 設定兩個指標? // 初始化左、右指標\n    Yes → Step: left = 0 // 左指標指向陣列起始\n    Yes → Step: right = length(numbers)-1 // 右指標指向陣列結尾\n→ Decision: 左指標小於右指標? // 迴圈條件\n    Yes → Step: current_sum = numbers[left] + numbers[right] // 計算兩數之和\n    → Decision: current_sum 等於 target? // 是否找到答案\n        Yes → Step: Return [left+1, right+1] // 轉為 1-indexed 回傳\n        No  → Decision: current_sum 小於 target? // 需要更大和\n            Yes → Step: left = left + 1 // 左指標右移\n            No  → Step: right = right - 1 // 右指標左移\n    No → End // 兩指標相遇，結束程式\n\nBut they may expect to keep the decision structure like earlier. Let's follow example style:\n\nStart // 程式開始執行\n→ Step: left = 0 // 左指標初始化\n→ Step: right = numbers.length - 1 // 右指標初始化\n→ Decision: left < right? // 判斷是否還有可能\n    Yes → Step: current_sum = numbers[left] + numbers[right] // 計算目前兩數之和\n    → Decision: current_sum == target? // 檢查是否符合目標\n        Yes → Step: Return [left + 1, right + 1] // 回傳 1-indexed 指標\n        No  → Decision: current_sum < target? // 需要更大和\n            Yes → Step: left = left + 1 // 左指標右移\n            No  → Step: right = right - 1 // 右指標左移\n    No  → End // left >= right，無解（理論上不會發生）\n\nThat should be fine. Ensure each line ends with // 解釋. Use \"Yes →\" and \"No →\" properly. Use \"Decision:\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: left = 0 // 初始化左指標，指向陣列第一個元素  \n→ Step: right = numbers.length - 1 // 初始化右指標，指向陣列最後一個元素  \n→ Decision: left < right? // 只要左指標還在右指標左側就繼續  \n    Yes → Step: current_sum = numbers[left] + numbers[right] // 計算目前兩個指標所指數字之和  \n    → Decision: current_sum == target? // 判斷是否正好等於目標值  \n        Yes → Step: Return [left + 1, right + 1] // 轉成 1‑index 並回傳結果  \n        No  → Decision: current_sum < target? // 若和太小，需要更大  \n            Yes → Step: left = left + 1 // 左指標右移  \n            No  → Step: right = right - 1 // 右指標左移  \n    No  → End // left >= right，迴圈結束（理論上此行不會執行）  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def twoSum(self, numbers, target):\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            s = numbers[left] + numbers[right]\n            if s == target:\n                return [left + 1, right + 1]\n            elif s < target:\n                left += 1\n            else:\n                right -= 1\n        return []\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 找出 numbers 陣列\n    numbers_match = re.search(r'numbers\\s*=\\s*(\\[[^\\]]*\\])', data)\n    # 找出 target 數值\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if numbers_match and target_match:\n        numbers = eval(numbers_match.group(1))\n        target = int(target_match.group(1))\n        result = Solution().twoSum(numbers, target)\n        print(result)\n    else:\n        print([])",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numbers = [2,7,11,15], target = 9",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "numbers = [2,3,4], target = 6",
          "expected_output": "[1,3]",
          "success": true,
          "output": "[1, 3]"
        },
        {
          "example_index": 2,
          "input": "numbers = [-1,0], target = -1",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode682.json",
    "problem_index_in_file": 0,
    "title": "Baseball Game",
    "description_snippet": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. It's a typical problem: maintain stack of scores, iterate operations, push integer, '+', 'D', 'C', and compute sum at end. Virtual code should be step by step.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋/說明\".\n\nWe should include Start, End, Decision, etc. Use arrows for each step.\n\nLet's produce code.\n\nWe need to parse operations list, maintain stack.\n\nPseudo:\n\nStart\n→ Step 1: 初始化 scores 為空列表 // 開始時記錄空\n→ Step 2: 初始化 sum 為 0 // 記錄總分\n→ Step 3: 迴圈 for 每個 op 在 operations 中 // 遍歷操作\n    → Decision: op 是否為 整數？\n        Yes → Step 4: 轉為 整數 val // 解析數字\n            → Step 5: 加入 scores: push val // 將數字記錄\n            → Step 6: sum += val // 加到總分\n        No  → Decision: op == \"+\" ?\n            Yes → Step 7: 取前兩個分數 a = scores[-1], b = scores[-2] // 取得最近兩分\n                → Step 8: val = a + b // 計算總和\n                → Step 9: push val 到 scores // 記錄新分\n                → Step 10: sum += val // 加到總分\n            No  → Decision: op == \"D\" ?\n                Yes → Step 11: a = scores[-1] // 取最近分\n                    → Step 12: val = 2 * a // 計算翻倍\n                    → Step 13: push val // 記錄\n                    → Step 14: sum += val // 加到總分\n                No  → Decision: op == \"C\" ?\n                    Yes → Step 15: val = pop scores // 移除最近分\n                        → Step 16: sum -= val // 從總分扣除\n                    No → Step 17: // 其他情況不發生\n→ Step 18: return sum // 返回總分\n\nEnd\n\nWe should keep line numbering optional? Not necessary but fine.\n\nAdd explanation comments.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 scores 為空列表 // 以空列表開始，記錄每個有效分數  \n→ Step 2: 初始化 sum 為 0 // 用於累加所有分數的總和  \n→ Step 3: 迴圈 for 每個 op 在 operations 中 // 逐一處理每個操作  \n  → Decision: op 是否為 整數？ // 檢查操作是數字還是特殊指令  \n   Yes → Step 4: 轉為 整數 val = int(op) // 將字串轉成整數  \n    → Step 5: 加入 scores: scores.append(val) // 把新分數存入列表  \n    → Step 6: sum += val // 累加到總分  \n   No  → Decision: op == \"+\" ? // 需要加上前兩個分數  \n    Yes → Step 7: a = scores[-1]; b = scores[-2] // 取最近兩個分數  \n     → Step 8: val = a + b // 計算和  \n     → Step 9: scores.append(val) // 存入新分數  \n     → Step 10: sum += val // 累加到總分  \n    No  → Decision: op == \"D\" ? // 需要將前一分數翻倍  \n     Yes → Step 11: a = scores[-1] // 取最近分數  \n      → Step 12: val = 2 * a // 計算翻倍值  \n      → Step 13: scores.append(val) // 存入新分數  \n      → Step 14: sum += val // 累加到總分  \n     No  → Decision: op == \"C\" ? // 需要移除最近分數  \n      Yes → Step 15: val = scores.pop() // 從列表中移除並取得剛剛的分數  \n       → Step 16: sum -= val // 從總分中扣除該分數  \n      No → Step 17: // 其他情況不會發生，保持安全  \n→ Step 18: return sum // 所有操作結束後返回總分  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def calPoints(self, ops):\n        \"\"\"\n        計算棒球比賽的總分。\n        :param ops: List[str]，包含各種操作指令\n        :return: int，最終總分\n        \"\"\"\n        stack = []                      # 用來存放有效分數的堆疊\n        for op in ops:\n            if op == \"C\":                # 取消上一個分數\n                stack.pop()\n            elif op == \"D\":              # 前一個分數的兩倍\n                stack.append(2 * stack[-1])\n            elif op == \"+\":              # 前兩個分數之和\n                stack.append(stack[-1] + stack[-2])\n            else:                        # 整數分數\n                stack.append(int(op))\n        return sum(stack)\n\ndef parse_input(input_str):\n    \"\"\"\n    解析輸入字串，取得 ops 列表。\n    期望輸入格式類似 'ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]'\n    \"\"\"\n    if '=' in input_str:\n        # 取等號右側，並移除首尾空白\n        rhs = input_str.split('=', 1)[1].strip()\n    else:\n        rhs = input_str.strip()\n    # 使用 ast.literal_eval 解析為 Python 物件，安全且能處理字串列表\n    return ast.literal_eval(rhs)\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin，支援多行輸入\n    raw_input = sys.stdin.read()\n    ops = parse_input(raw_input)\n    result = Solution().calPoints(ops)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]",
          "expected_output": "30",
          "success": true,
          "output": "30"
        },
        {
          "example_index": 1,
          "input": "ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]",
          "expected_output": "27",
          "success": true,
          "output": "27"
        },
        {
          "example_index": 2,
          "input": "ops = [\"1\",\"C\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode981.json",
    "problem_index_in_file": 0,
    "title": "Time Based Key-Value Store",
    "description_snippet": "Design a time-based key-value data structure that can store multiple values for the same key at diff...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanations, using arrows and decisions. The task: design time-based key-value data structure. So steps: Start, initialize map structure, set operation, get operation with binary search. Provide steps. Each line: virtual code step + comment.\n\nLet's produce a high-level algorithm: Use dictionary mapping key to list of (timestamp, value) sorted by timestamp. On set: append pair. On get: binary search. Implementation: use binary search. Provide steps for set and get. Also include class init.\n\nWe need to output step by step pseudo-code. Use arrow →.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize TimeMap // create empty map\n→ Step 2: set(key,value,timestamp) // store value\n→ Decision: 是否已存在 key? // check if key in map\n   Yes → Step 3: Append (timestamp,value) to list // add new pair\n   No  → Step 4: Create new list [(timestamp,value)] and add to map // first entry\n→ Step 5: get(key,timestamp) // retrieve value\n→ Decision: key 在 map? // check existence\n   Yes → Step 6: list = map[key] // retrieve list\n   No  → Step 7: return \"\" // no data\n→ Step 8: BinarySearch(list, timestamp) // find largest timestamp <= given\n→ Decision: 找到 index? // found\n   Yes → Step 9: return list[index].value\n   No  → Step 10: return \"\" // none <= timestamp\n\nAdd End at bottom.\n\nAlso show how binary search works: Step 11: left=0 right= len(list)-1 ; while left<=right ; mid=(left+right)//2 ; if list[mid].timestamp <= timestamp : record mid ; left=mid+1 ; else right=mid-1 ; return record\n\nBut we need each line as virtual code step. So maybe include those steps.\n\nLet's produce lines accordingly.\n\nWe must ensure every line has the format: virtual code step + space + // explanation. Use arrow → at beginning of step lines. Use Decision: label. Use Yes → and No → indentation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n\n→ Step 1: Define TimeMap class with internal map `data` // 初始化資料結構  \n\n→ Step 2: TimeMap() → `data = {}` // 建構子：建立空字典  \n\n→ Step 3: set(key, value, timestamp) → // 開始儲存鍵值對  \n\n    → Decision: `key` 是否存在於 `data`? // 檢查鍵是否已經有紀錄  \n\n        Yes → Step 4: Append (timestamp, value) to `data[key]` // 已有鍵，追加新時間戳  \n\n        No  → Step 5: Create list `[(timestamp, value)]` and assign to `data[key]` // 新鍵，建立列表  \n\n→ Step 6: get(key, timestamp) → // 開始查詢  \n\n    → Decision: `key` 是否存在於 `data`? // 是否有該鍵的資料  \n\n        Yes → Step 7: `entries = data[key]` // 取得時間戳與值的列表  \n\n        No  → Step 8: return \"\" // 沒有該鍵，直接返回空字串  \n\n    → Step 9: BinarySearch(entries, timestamp) → // 尋找最大小於等於目標時間戳的索引  \n\n        → Decision: 是否找到符合條件的索引? // 有符合的時間戳？  \n\n            Yes → Step 10: return entries[index].value // 回傳對應值  \n\n            No  → Step 11: return \"\" // 沒有小於等於的時間戳，返回空字串  \n\n→ Step 12: BinarySearch(entries, timestamp) → // 定義二分搜尋流程  \n\n    → Step 13: left = 0; right = len(entries) - 1; best = -1  \n\n    → Step 14: while left <= right do  \n\n        → Step 15: mid = (left + right) // 2  \n\n        → Decision: `entries[mid].timestamp` <= `timestamp`? // 時間戳是否符合條件  \n\n            Yes → Step 16: best = mid; left = mid + 1 // 更新最佳索引，向右搜尋更大時間戳  \n\n            No  → Step 17: right = mid - 1 // 向左搜尋  \n\n    → Step 18: return best // 回傳找到的索引，若為 -1 表示不存在  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\nimport bisect\n\nclass TimeMap:\n    def __init__(self):\n        # 使用字典映射 key -> 依時間戳排序的 (timestamp, value) 列表\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        # 直接把 (timestamp, value) 加到對應 key 的列表末尾\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # bisect_right 找到第一個 timestamp 大於目標的索引\n        i = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if i == 0:\n            return \"\"\n        return arr[i - 1][1]\n\n\ndef main() -> None:\n    # 讀取整個標準輸入，去除首尾空白\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將兩個列表包成元組並解析為 Python 對象\n    # 例如：'[\"TimeMap\", \"set\"], [[], [\"a\", \"b\", 1]]' -> ([\"TimeMap\",\"set\"], [[], [\"a\",\"b\",1]])\n    commands, params = ast.literal_eval(f\"({data})\")\n\n    tm = None\n    results = []\n\n    for cmd, param in zip(commands, params):\n        if cmd == \"TimeMap\":\n            tm = TimeMap()\n            results.append(None)  # null\n        elif cmd == \"set\":\n            tm.set(*param)\n            results.append(None)  # null\n        elif cmd == \"get\":\n            res = tm.get(*param)\n            results.append(res if res != \"\" else None)  # None 表示 null\n        else:\n            # 不支持的指令，視為錯誤並加入 null\n            results.append(None)\n\n    # 使用 json.dumps 直接輸出符合 LeetCode 風格的格式\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "success": true,
          "output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode31.json",
    "problem_index_in_file": 0,
    "title": "Next Permutation",
    "description_snippet": "A permutation of an array of integers is an arrangement of its members into a sequence or linear ord...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for next permutation algorithm. Steps: find first decreasing from right, if none, reverse all, else find successor, swap, reverse suffix. Provide each step line with comment. Use Start, End, Decision etc. Use arrows. Provide each step line. Ensure each line includes virtual code step and comment. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 i ← nums.Length - 2 // 從倒數第二個位置開始向左掃描\n→ Decision: i >= 0 且 nums[i] < nums[i+1]? // 找第一個升序斜率\n    Yes → Step 2: 設定 j ← nums.Length - 1 // 從末尾開始尋找比 nums[i] 大的最小值\n    → Decision: nums[j] > nums[i]? // 確認 j 指向的元素比 nums[i] 大\n        Yes → Step 3: 交換 nums[i] 與 nums[j] // 交換兩個元素\n        No  → Step 2: j ← j - 1 // j 向左移動直到找到符合條件的元素\n    → Step 4: 反轉子陣列 nums[i+1 .. end] // 使尾部升序\n→ No → Step 5: 反轉整個陣列 nums[0 .. end] // 沒有更大的排列，恢復升序\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\ndef next_permutation(nums):\n    \"\"\"改為下一個字典序排列，原地完成，額外空間為 O(1)\"\"\"\n    n = len(nums)\n    # 1. 從右往左找第一個升序斜率\n    i = n - 2\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n\n    if i >= 0:\n        # 2. 從右往左找比 nums[i] 大的最小值\n        j = n - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        # 3. 交換\n        nums[i], nums[j] = nums[j], nums[i]\n\n    # 4. 將 i+1 到尾部的子陣列反轉，使其升序\n    left, right = i + 1, n - 1\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 取得第一個出現的方括號內的文字\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if match:\n        # 用 literal_eval 安全地解析列表\n        nums = ast.literal_eval(match.group())\n    else:\n        nums = []\n\n    next_permutation(nums)\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,3,2]",
          "success": true,
          "output": "[1, 3, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1]",
          "expected_output": "[1,2,3]",
          "success": true,
          "output": "[1, 2, 3]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,5]",
          "expected_output": "[1,5,1]",
          "success": true,
          "output": "[1, 5, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode678.json",
    "problem_index_in_file": 0,
    "title": "Valid Parenthesis String",
    "description_snippet": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is va...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step, with explanations. Problem: Valid parentheses with '*' wildcard.\n\nCommon solution: track min and max open count.\n\nPseudo:\n\nStart\n→ Step 1: 初始化 minOpen = 0, maxOpen = 0 // min and max possible open parentheses count\n→ For each character c in s:\n    Decision: if c == '('? \n        Yes → Increment minOpen, maxOpen\n        No: Decision: if c == ')'?\n            Yes → Decrement minOpen (but not below 0), decrement maxOpen\n            No → // c == '*'\n                Decision: treat as ')': decrement minOpen (not below 0)\n                Decision: treat as '(': increment maxOpen\n                // or empty: no change\n    // After each char, if maxOpen < 0: return false (cannot match)\n    // Ensure minOpen not negative\n→ Decision: after loop, if minOpen == 0: return true else false\nEnd\n\nBut we need to produce each line of virtual code with explanation.\n\nLet's produce a flowchart-like pseudo.\n\nWe'll need to show loop iteration.\n\nUse Decision blocks.\n\nWe'll use arrow for each step.\n\nI'll produce:\n\nStart // program start\n→ Step 1: minOpen ← 0; maxOpen ← 0 // initialize open counter bounds\n→ Step 2: For each character c in s // iterate over string\n    → Decision: c == '(' ?\n        Yes → minOpen ← minOpen + 1; maxOpen ← maxOpen + 1 // a '(' increases both bounds\n        No → Decision: c == ')' ?\n            Yes → minOpen ← max(minOpen - 1, 0); maxOpen ← maxOpen - 1 // a ')' decreases bounds, min cannot go below 0\n            No → // c == '*'\n                // '*' can be treated as ')', '(' or empty\n                → minOpen ← max(minOpen - 1, 0) // treat as ')'\n                → maxOpen ← maxOpen + 1          // treat as '('\n                // empty: no change (implicit)\n    → Decision: maxOpen < 0 ?\n        Yes → Step 3: return false // too many ')' cannot be matched\n        No  → // continue loop\n→ Step 4: Decision: minOpen == 0 ?\n    Yes → Step 5: return true // all '(' matched\n    No  → Step 6: return false // unmatched '(' remaining\nEnd // program end\n\nBut need each line as virtual code with explanation after a space.\n\nWe need arrow notation like \"→ Step 1: ...\" etc. Each line must start with the virtual code step, arrow or decision, then space, then explanation.\n\nWe need to use 'Decision:' lines and indent? The example shows indentation.\n\nWe can produce nested lines.\n\nWe must be careful with the formatting: Each line separate; indent for decision branches.\n\nWe can represent indentation with two spaces.\n\nExample:\n\nStart // 程式開始執行\n→ Step 1: minOpen ← 0; maxOpen ← 0 // 初始化開啟括號的最小與最大可能數\n→ Step 2: For each character c in s // 逐字遍歷字串\n    → Decision: c == '(' ?\n        Yes → minOpen ← minOpen + 1; maxOpen ← maxOpen + 1 // 左括號同時增加兩個界限\n        No  → Decision: c == ')' ?\n            Yes → minOpen ← max(minOpen - 1, 0); maxOpen ← maxOpen - 1 // 右括號減少界限，最小不低於0\n            No  → // c == '*'\n                → minOpen ← max(minOpen - 1, 0) // 將 '*' 視為右括號\n                → maxOpen ← maxOpen + 1          // 或視為左括號\n                // 空字符串: 無變化\n    → Decision: maxOpen < 0 ?\n        Yes → Step 3: return false // 右括號過多，無法配對\n        No  → // 繼續循環\n→ Step 4: Decision: minOpen == 0 ?\n    Yes → Step 5: return true // 所有左括號都有配對\n    No  → Step 6: return false // 還有未配對的左括號\nEnd // 程式執行結束\n\nWe need to ensure each line has code and explanation separated by space.\n\nFor decisions, maybe write \"Decision: c == '(' ?\" then indent branches.\n\nOk. Provide that.\n\nAlso include comments in Traditional Chinese.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: minOpen ← 0; maxOpen ← 0 // 初始化開啟括號的最小與最大可能數  \n→ Step 2: For each character c in s // 逐字遍歷字串  \n  → Decision: c == '(' ? // 判斷是否為左括號  \n  │  Yes → minOpen ← minOpen + 1; maxOpen ← maxOpen + 1 // 左括號同時增加兩個界限  \n  │  No  → Decision: c == ')' ? // 判斷是否為右括號  \n  │  │  Yes → minOpen ← max(minOpen - 1, 0); maxOpen ← maxOpen - 1 // 右括號減少界限，最小不低於0  \n  │  │  No  → // c == '*', 可以視為 '(', ')' 或空字串  \n  │  │  → minOpen ← max(minOpen - 1, 0) // 視為右括號，最小不低於0  \n  │  │  → maxOpen ← maxOpen + 1          // 視為左括號，最大增加  \n  │  │  // 空字串: 無變化  \n  → Decision: maxOpen < 0 ? // 若最大界限為負，表示右括號過多  \n  │  Yes → Step 3: return false // 無法配對，直接結束  \n  │  No  → // 繼續處理下一個字元  \n→ Step 4: Decision: minOpen == 0 ? // 最後判斷是否所有左括號都有配對  \n  Yes → Step 5: return true // 成功配對，字串有效  \n  No  → Step 6: return false // 還有未配對的左括號，字串無效  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def checkValidString(self, s: str) -> bool:\n        \"\"\"\n        判斷字串 s 是否為有效的括號字串。\n        使用兩個計數器 low 與 high 分別表示\n        - low：至少需要配對的左括號數量\n        - high：最多可以保留的左括號數量\n        \"\"\"\n        low = 0\n        high = 0\n        for c in s:\n            if c == '(':\n                low += 1\n                high += 1\n            elif c == ')':\n                if low > 0:\n                    low -= 1\n                high -= 1\n            else:  # c == '*'\n                if low > 0:\n                    low -= 1\n                high += 1\n            # 若 high 為負，說明右括號過多，無法配對\n            if high < 0:\n                return False\n        # 最後 low 必須為 0 才能完全配對\n        return low == 0\n\n\ndef main():\n    import sys, re\n\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：預期為形如 s = \"...\"\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若未匹配，則直接使用輸入內容（去除可能的引號）\n        s = data.strip('\"').strip(\"'\")\n\n    sol = Solution()\n    result = sol.checkValidString(s)\n    print('true' if result else 'false')\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"(*)\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"(*))\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode70.json",
    "problem_index_in_file": 0,
    "title": "Climbing Stairs",
    "description_snippet": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for climbing stairs problem. We need step by step with arrows. No actual code, just virtual code. So we produce logic: Start, compute ways array, loop from 3 to n, ways[i] = ways[i-1] + ways[i-2], end. Use decision: if n <= 2 return n. Probably.\n\nWe need to output line by line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 接收 n // 取得階梯總數\n→ Decision: n < 3? // 判斷是否小於等於2\n    Yes → Step 2: 輸出 n // 小階梯直接回傳 n 種方式\n    No  → Step 3: 初始化 ways[0] = 1, ways[1] = 1 // 基礎狀態\n        → Step 4: For i from 2 to n-1 // 計算每一步的方式數\n            → Step 5: ways[i] = ways[i-1] + ways[i-2] // 兩種可能相加\n        → Step 6: 輸出 ways[n-1] // 最後一步的結果\nEnd // 程式結束\n\nMake sure to follow format exactly: each line with arrow? Use \"→\" at start of step lines. For decision, we indent sub-lines. Use \"Yes →\" and \"No →\". Must have \"Decision:\" lines. Provide explanation after //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收 n // 取得階梯總數  \n→ Decision: n < 3? // 判斷是否小於等於 2  \n Yes → Step 2: 輸出 n // 小階梯直接回傳 n 種方式  \n No  → Step 3: 初始化 ways[0] = 1, ways[1] = 1 // 基礎狀態  \n  → Step 4: For i 從 2 到 n-1 // 計算每一步的方式數  \n   → Step 5: ways[i] = ways[i-1] + ways[i-2] // 兩種可能相加  \n  → Step 6: 輸出 ways[n-1] // 最後一步的結果  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef climb_stairs(n: int) -> int:\n    \"\"\"\n    計算能以 1 或 2 步走到第 n 階梯的不同方法數。\n    這個問題相當於 Fibonacci 數列的前 n 項。\n    \"\"\"\n    if n <= 2:\n        return n  # n=1 時只能走一步；n=2 時可以 1+1 或 2\n    first, second = 1, 2\n    # 從第 3 階開始累加\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n    return second\n\ndef main() -> None:\n    # 讀取所有輸入，允許「n = 2」或純數字「2」等格式\n    raw_input = sys.stdin.read()\n    numbers = re.findall(r'-?\\d+', raw_input)\n    if not numbers:\n        return\n    n = int(numbers[0])\n    result = climb_stairs(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode372.json",
    "problem_index_in_file": 0,
    "title": "Super Pow",
    "description_snippet": "Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large pos...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for computing a^b mod 1337 where b is a large exponent given as array of digits. Use fast exponentiation with exponent given as array. Approach: compute result iteratively: for each digit d in b: result = (pow(result,10,1337) * pow(a,d,1337)) % 1337. Because a^b where b in base 10: a^b = product over digits: a^{...}. Actually we can use exponentiation by repeated squaring: we can compute result =1; for each digit in b: result = pow(result,10,1337) * pow(a,d,1337) %1337. That is standard method.\n\nWe need virtual code step by step with explanations.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 輸入 a, bArray // 取得底數與指數數組\n→ Step 2: result ← 1 // 初始化結果為 1\n→ Step 3: MOD ← 1337 // 模數\n→ Decision: bArray 是否為空? // 檢查指數是否為空\n    Yes → Step 4: return result // 空指數直接返回 1\n    No  → Loop: 對每個 digit in bArray\n        → Step 5: digit ← current digit // 取得指數的單個十進位數字\n        → Step 6: result ← (pow(result,10,MOD) * pow(a,digit,MOD)) mod MOD // 更新結果\n        → Step 7: // 迴圈結束\n→ End // 返回最終結果\n\nNeed to express pow(x, y, mod) as a step: maybe \"pow(x, y, MOD)\" is subroutine.\n\nWe'll keep each line as \"虛擬碼步驟\" + \" // 解釋\". Use arrows as in example. Use indentation for nested decisions.\n\nAlso need Step numbers? Not necessary but can help. In example they used \"Step 1\". We'll use similar. Ensure each line ends with comment.\n\nLet's produce the final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 a, bArray // 取得底數 a 與指數 b 的十進位數字陣列  \n→ Step 2: result ← 1 // 初始化結果為 1，代表 a^0  \n→ Step 3: MOD ← 1337 // 設定模數  \n→ Decision: bArray 是否為空? // 檢查指數是否為空陣列  \n  Yes → Step 4: return result // 空指數時直接返回 1  \n  No  → Loop: 對 bArray 中每個 digit  \n    → Step 5: digit ← 当前位 // 取得指數的單個十進位數字  \n    → Step 6: result ← (pow(result,10,MOD) * pow(a,digit,MOD)) mod MOD // 先將現有結果提升至 10 次方，再乘以 a 的 digit 次方，最後取模  \n    → Step 7: // 迴圈結束  \n→ End // 返回最終結果（a^b mod 1337）",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def superPow(self, a, b):\n        MOD = 1337\n        result = 1\n        for digit in b:\n            result = pow(result, 10, MOD) * pow(a, digit, MOD) % MOD\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 找出所有整數\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        sys.exit(0)\n    a = nums[0]\n    b = nums[1:]\n    sol = Solution()\n    ans = sol.superPow(a, b)\n    print(ans)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 2, b = [3]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = [1,0]",
          "expected_output": "1024",
          "success": true,
          "output": "1024"
        },
        {
          "example_index": 2,
          "input": "a = 1, b = [4,3,3,8,5,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode466.json",
    "problem_index_in_file": 0,
    "title": "Count The Repetitions",
    "description_snippet": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to compute maximum m such that repeated str2 m times can be obtained from repeated str1. It's known problem: \"Maximum Number of Repeated Substrings\" Leetcode 466? Actually \"Maximum Number of Repeated Substrings\" maybe. Wait, known as \"Maximum Number of Repetitions\" problem. Approach: use greedy with tracking remainders and cycle detection. We'll write steps. We need to present as virtual code with arrow lines. Each line: \"虛擬碼步驟 // 解釋\". We'll outline algorithm: iterate over s1 repeated n1 times, maintain index j in s2, count how many times we matched s2 fully. Use map to store state of j to pair of count and index of s1 iteration to detect cycle. When cycle found, compute extra matches. Return count/n2.\n\nSo produce steps: Start, initialize count=0, j=0, index=0, map. Loop over i from 0 to n1-1: for each char in s1: if char==s2[j] then j++ etc. At end of each s1 iteration, record state if j not seen: map[j]=(i, count). Else cycle: compute cycle length, matches per cycle, compute remaining, etc. After loop, result = count / n2.\n\nWe produce virtual code steps line by line. Let's create steps. Use arrows: \"→\" for sequence, \"Decision:\" for if. Provide each line with explanation. Ensure no actual code. We'll use placeholder variable names. We'll not write actual code but steps.\n\nLet's craft.\n\nWe'll write:\n\nStart // 開始\n\n→ Initialize totalMatches = 0 // 初始化匹配數\n→ Initialize posInS2 = 0 // s2 的索引\n→ Initialize cycleMap = {} // 用於偵測重複狀態\n\n→ For repeatIndex from 1 to n1: // 對 str1 進行 n1 次迴圈\n\n   → For each char in s1: // 逐字處理 s1\n\n        → If char == s2[posInS2]: // 匹配到 s2 的字符\n            → posInS2 = posInS2 + 1\n            → If posInS2 == len(s2): // 完整匹配一次 s2\n                → totalMatches = totalMatches + 1\n                → posInS2 = 0\n\n   → Decision: 是否已經遇到相同的 posInS2? // 檢查是否重複狀態\n\n        Yes → Retrieve prevIndex, prevMatches from cycleMap[posInS2] // 取得之前記錄的迴圈資訊\n        → 計算 cycleLen = repeatIndex - prevIndex\n        → 計算 matchPerCycle = totalMatches - prevMatches\n        → 計算 remaining = n1 - repeatIndex\n        → 計算 fullCycles = remaining // cycleLen\n        → totalMatches = totalMatches + fullCycles * matchPerCycle\n        → repeatIndex = repeatIndex + fullCycles * cycleLen\n        → // 跳過已算好的完整週期\n\n        No → cycleMap[posInS2] = (repeatIndex, totalMatches) // 記錄此狀態\n\n→ End For // 完成所有重複\n\n→ 計算 m = totalMatches // n2 // 最大可取得的 str2 次數\n\n→ Return m // 回傳結果\n\nEnd // 程式結束\n\nWe need to make sure each line has \"虛擬碼步驟\" + \" // 解釋\". We'll number lines maybe. Use arrows. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize totalMatches = 0 // 初始化已完成的 str2 數量  \n→ Initialize posInS2 = 0 // s2 的當前索引位置  \n→ Initialize cycleMap = {} // 用於偵測重複狀態的字典  \n\n→ For repeatIndex from 1 to n1: // 針對 str1 的每一次重複  \n    → For each char in s1: // 逐字處理 s1  \n        → If char == s2[posInS2]: // 找到匹配的字符  \n            → posInS2 = posInS2 + 1 // 前進 s2 的索引  \n            → If posInS2 == len(s2): // 已完整匹配一個 s2  \n                → totalMatches = totalMatches + 1 // 記錄一次完整匹配  \n                → posInS2 = 0 // 重置為 s2 開頭  \n\n    → Decision: 是否已經遇到相同的 posInS2? // 檢查是否出現循環  \n        Yes → Retrieve prevIndex, prevMatches from cycleMap[posInS2] // 取出之前記錄的迴圈資訊  \n        → cycleLen = repeatIndex - prevIndex // 計算一次循環所需的 str1 次數  \n        → matchPerCycle = totalMatches - prevMatches // 循環中新增的完整匹配數  \n        → remaining = n1 - repeatIndex // 尚未處理的 str1 次數  \n        → fullCycles = remaining // cycleLen // 能完整進行的循環數  \n        → totalMatches = totalMatches + fullCycles * matchPerCycle // 加入整個循環的匹配數  \n        → repeatIndex = repeatIndex + fullCycles * cycleLen // 跳過已計算的循環  \n        // 跳過已算好的完整週期，避免重複計算  \n\n        No → cycleMap[posInS2] = (repeatIndex, totalMatches) // 記錄此狀態以備後續循環偵測  \n\n→ End For // 完成所有 str1 的重複處理  \n\n→ m = totalMatches // n2 // 計算可以得到的 str2 的最大重複數量  \n\n→ Return m // 回傳結果  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def getMaxRepetitions(self, s1, n1, s2, n2):\n        if n1 == 0:\n            return 0\n        s1_count = 0          # 已經處理了多少次 s1\n        s2_count = 0          # 已經完整匹配了多少次 s2\n        index = 0             # s2 中當前匹配的位置\n        recall = {}           # {index: (s1_count, s2_count)} 用於偵測週期\n\n        while s1_count < n1:\n            for ch in s1:\n                if ch == s2[index]:\n                    index += 1\n                    if index == len(s2):\n                        index = 0\n                        s2_count += 1\n            s1_count += 1\n            if index in recall:\n                s1_prev, s2_prev = recall[index]\n                pre_loop = (s1_prev, s2_prev)\n                in_loop = (s1_count - s1_prev, s2_count - s2_prev)\n                break\n            else:\n                recall[index] = (s1_count, s2_count)\n        else:  # 沒有偵測到週期，直接結束\n            return s2_count // n2\n\n        # 使用偵測到的週期計算剩餘部分\n        ans = pre_loop[1] + ((n1 - pre_loop[0]) // in_loop[0]) * in_loop[1]\n        rest = (n1 - pre_loop[0]) % in_loop[0]\n\n        s2_rest = 0\n        idx_rest = index\n        for _ in range(rest):\n            for ch in s1:\n                if ch == s2[idx_rest]:\n                    idx_rest += 1\n                    if idx_rest == len(s2):\n                        idx_rest = 0\n                        s2_rest += 1\n        ans += s2_rest\n        return ans // n2\n\n\ndef parse_input():\n    data = sys.stdin.read()\n    # Try to find patterns like: s1 = \"abc\", n1 = 4, s2 = \"ab\", n2 = 2\n    s1_match = re.search(r's1\\s*=\\s*\"([^\"]*)\"', data)\n    n1_match = re.search(r'n1\\s*=\\s*(\\d+)', data)\n    s2_match = re.search(r's2\\s*=\\s*\"([^\"]*)\"', data)\n    n2_match = re.search(r'n2\\s*=\\s*(\\d+)', data)\n\n    if s1_match and n1_match and s2_match and n2_match:\n        s1 = s1_match.group(1)\n        n1 = int(n1_match.group(1))\n        s2 = s2_match.group(1)\n        n2 = int(n2_match.group(1))\n        return s1, n1, s2, n2\n\n    # Fallback: assume each value is on its own line or space separated\n    parts = data.strip().replace('\"', '').split()\n    if len(parts) >= 4:\n        s1 = parts[0]\n        n1 = int(parts[1])\n        s2 = parts[2]\n        n2 = int(parts[3])\n        return s1, n1, s2, n2\n\n    raise ValueError(\"Invalid input format\")\n\n\nif __name__ == \"__main__\":\n    s1, n1, s2, n2 = parse_input()\n    result = Solution().getMaxRepetitions(s1, n1, s2, n2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode526.json",
    "problem_index_in_file": 0,
    "title": "Beautiful Arrangement",
    "description_snippet": "Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for counting beautiful arrangements. The typical solution: backtracking with bitmask. Use recursion to try placing numbers 1..n at each position i. Keep used mask. Count ways. Complexity 2^n. Provide steps.\n\nNeed to output each line: \"虛擬碼步驟 // 解釋\". Use arrows and decision.\n\nLet's craft pseudocode:\n\nStart\n→ Initialize result = 0\n→ Define recursive function backtrack(position, usedMask)\n    → If position > n: result +=1; return\n    → For each num from 1 to n:\n        → Decision: if num not used in usedMask?\n            Yes → Decision: if num % position ==0 or position % num ==0?\n                Yes → Mark num used (usedMask | (1<<num-1))\n                → Call backtrack(position+1, newMask)\n                → Unmark (no need if mask copy)\n                No → Continue loop\n        No → Continue loop\n→ Call backtrack(1, 0)\n→ Return result\nEnd\n\nBut must be line by line with arrow notation. Use \"Start\" etc.\n\nNeed to incorporate bitmask and recursion.\n\nLet's format:\n\nStart // 程式開始\n→ Set n // 接收輸入 n\n→ Set result = 0 // 用來累計可行排列數\n→ Define Function backtrack(position, usedMask) // 位置與已使用數字的位元組\n    → Decision: 如果 position > n? // 所有位置已填完\n        Yes → result +=1 // 成功組成一個美麗排列\n        Yes → Return\n    → For num = 1 to n:\n        → Decision: 如果 (usedMask & (1 << (num-1))) == 0? // num 未被使用\n            Yes → Decision: 如果 num % position == 0 或 position % num == 0? // 檢查美麗條件\n                Yes → Call backtrack(position+1, usedMask | (1 << (num-1))) // 放入並遞迴\n            No → // 條件不滿足，跳過\n        No → // 已使用，跳過\n→ Call backtrack(1, 0) // 從第一個位置開始\n→ Return result // 結果輸出\nEnd // 程式結束\n\nWe need each line with arrow and comment. We should use \"→\" before each step inside function, but the sample shows indentation for decisions with Yes→ etc. We can mimic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Set n // 接收輸入 n  \n→ Set result = 0 // 用來累計可行排列數  \n\nDefine Function backtrack(position, usedMask) // 位置與已使用數字的位元組  \n    → Decision: 如果 position > n? // 所有位置已填完  \n        Yes → result += 1 // 成功組成一個美麗排列  \n        Yes → Return // 回到上一層遞迴  \n    → For num = 1 to n: // 嘗試將每個數字放在目前位置  \n        → Decision: 如果 (usedMask & (1 << (num-1))) == 0? // num 未被使用  \n            Yes → Decision: 如果 num % position == 0 或 position % num == 0? // 檢查美麗條件  \n                Yes → Call backtrack(position+1, usedMask | (1 << (num-1))) // 放入並遞迴  \n            No  → Continue // 條件不滿足，跳過此 num  \n        No  → Continue // num 已被使用，跳過此 num  \n\n→ Call backtrack(1, 0) // 從第一個位置開始  \n→ Return result // 輸出總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef count_beautiful_arrangements(n: int) -> int:\n    \"\"\"\n    計算「美麗排列」的總數，使用遞迴 + 位元掩碼（bitmask）記錄已使用的數字。\n    \"\"\"\n    result = 0\n\n    def backtrack(pos: int, mask: int) -> None:\n        \"\"\"\n        pos  : 當前要填入的位子（1-indexed）\n        mask : 已使用數字的位元組，每一位代表數字 1~n 是否已被使用\n        \"\"\"\n        nonlocal result\n        if pos > n:                 # 所有位置已填完，形成一個有效排列\n            result += 1\n            return\n\n        # 嘗試把每個未使用的數字放到目前位置\n        for num in range(1, n + 1):\n            if not (mask >> (num - 1)) & 1:          # num 未被使用\n                if num % pos == 0 or pos % num == 0:  # 符合「美麗」條件\n                    backtrack(pos + 1, mask | (1 << (num - 1)))\n\n    backtrack(1, 0)\n    return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    n = int(data)\n    print(count_beautiful_arrangements(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode324.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Sort II",
    "description_snippet": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\n\nYou may...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for rearranging array into wiggle sort. Classic solution: sort array then swap pairs. Or just use O(n) solution: iterate and ensure property by swapping if violation. Let's choose O(n) in-place.\n\nSteps:\nStart\n→ Step 1: Input array nums\n→ Step 2: For i from 0 to len(nums)-2\n    → Decision: if i is even\n        → Decision: if nums[i] > nums[i+1]\n            → Step 3: Swap nums[i] and nums[i+1]\n    → Decision: if i is odd\n        → Decision: if nums[i] < nums[i+1]\n            → Step 4: Swap nums[i] and nums[i+1]\n→ End\n\nAdd comments. Ensure arrow formatting.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 取得待處理的整數陣列  \n→ Step 2: 從 i = 0 到 len(nums)-2 逐一檢查鄰接元素 // 用迴圈遍歷陣列  \n    → Decision: i 為偶數? // 偶數索引需要小於下一個元素  \n        Yes → Decision: nums[i] > nums[i+1]? // 若不符合則交換  \n            Yes → Step 3: 交換 nums[i] 與 nums[i+1] // 使 nums[i] < nums[i+1]  \n    → Decision: i 為奇數? // 奇數索引需要大於下一個元素  \n        Yes → Decision: nums[i] < nums[i+1]? // 若不符合則交換  \n            Yes → Step 4: 交換 nums[i] 與 nums[i+1] // 使 nums[i] > nums[i+1]  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef wiggle_sort(nums):\n    \"\"\"\n    重新排列 nums，使得 nums[0] < nums[1] > nums[2] < nums[3] ...\n    這裡使用一次遍歷，根據索引的奇偶性進行必要的交換。\n    \"\"\"\n    n = len(nums)\n    for i in range(n - 1):\n        if i % 2 == 0:\n            # 偶數索引需要小於下一個元素\n            if nums[i] > nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        else:\n            # 奇數索引需要大於下一個元素\n            if nums[i] < nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n    return nums\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，預期格式類似於 \"nums = [1,5,1,1,6,4]\"\n    if \"=\" in data:\n        _, list_str = data.split(\"=\", 1)\n        list_str = list_str.strip()\n    else:\n        list_str = data\n\n    # 使用 eval 解析為 Python 列表\n    try:\n        nums = eval(list_str, {\"__builtins__\": None}, {})\n    except Exception:\n        # 若 eval 失敗，直接嘗試 json 解析\n        import json\n        nums = json.loads(list_str)\n\n    # 執行 wiggle sort\n    result = wiggle_sort(nums)\n\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode32.json",
    "problem_index_in_file": 0,
    "title": "Longest Valid Parentheses",
    "description_snippet": "Given a string containing just the characters '(' and ')', return the length of the longest valid (w...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each with explanation. Use Start, End, Decision, arrow.\n\nWe need to describe algorithm: typical DP or stack. Provide virtual steps.\n\nLet's design algorithm: Use stack to track indices of '('; start with -1. Iterate through string: for each char, if '(' push index; else pop; if stack empty push current index; else compute maxLen = max(maxLen, i - stack.top()). Finally return maxLen.\n\nWe'll produce steps.\n\nMake sure to include \"Start\" \"End\" lines, decisions.\n\nLet's produce lines:\n\nStart // start\n\n→ Step 1: 初始化 stack 為 [-1] // 用於儲存 '(' 的索引\n\n→ Step 2: 初始化 maxLen 為 0 // 儲存最大長度\n\n→ Step 3: 對於每個字符 s[i]，從 i = 0 到 len-1 // 開始遍歷\n\n    → Decision: 如果 s[i] 為 '('? // 判斷字符\n\n        Yes → Step 4: 推入 i 到 stack // 紀錄 '(' 的索引\n\n        No  → Step 5: 從 stack 彈出 top // 為遇到 ')', 先消除最近的 '('\n\n            → Decision: stack 是否為空? // 檢查是否沒有對應的 '('\n\n                Yes → Step 6: 推入 i 到 stack // 沒有對應，將當前索引作為基準\n\n                No  → Step 7: 計算 currentLen = i - stack.top() // 取得有效子串長度\n\n                    → Decision: currentLen 是否大於 maxLen? // 更新最大值\n\n                        Yes → Step 8: maxLen = currentLen // 更新最大長度\n\n                        No  → Step 9: 什麼也不做 // 保持現有最大長度\n\n→ Step 10: 回傳 maxLen // 結束並返回結果\n\nEnd // 程式結束\n\nWe need to ensure each line has explanation after `//`. Also each line must be a single line: the \"Decision\" lines need to indent maybe. We can use indentation for clarity.\n\nBut must maintain format: \"虛擬碼步驟 [space] // 解釋\".\n\nSo each line: \"Start // 程式開始執行\". Good.\n\nThen \"→ Step 1: 初始化 stack 為 [-1] // 用於儲存 '(' 的索引\".\n\nYes.\n\nMake sure no actual code but pseudo-code.\n\nLet's format. Use indentation maybe 4 spaces? But we must keep each line separate. Indentation is okay as part of virtual code, but each line still has only one \"虛擬碼步驟\" phrase. We'll keep indentation but ensure no additional text.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 stack 為 [-1] // 用於儲存 '(' 的索引  \n→ Step 2: 初始化 maxLen 為 0 // 儲存目前找到的最大有效長度  \n→ Step 3: 對於每個字符 s[i]，從 i = 0 到 len-1 // 開始遍歷字串  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: 如果 s[i] 為 '('? // 判斷目前字符是否為左括號  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: 推入 i 到 stack // 記錄左括號的位置  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 5: 從 stack 彈出 top // 遇到右括號，先移除最近的左括號  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decision: stack 是否為空? // 檢查是否沒有對應的左括號  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: 推入 i 到 stack // 無匹配，將目前索引作為新的基準  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 7: 計算 currentLen = i - stack.top() // 取得有效子串長度  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decision: currentLen 是否大於 maxLen? // 更新最大值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 8: maxLen = currentLen // 更新最大長度  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 9: 什麼也不做 // 保持現有最大長度  \n→ Step 10: 回傳 maxLen // 程式執行結束，返回結果  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        stack = [-1]\n        max_len = 0\n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)\n            else:\n                if stack:\n                    stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        return max_len\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        return\n    # Try to extract the string inside quotes\n    match = re.search(r's\\s*=\\s*\"(.*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # Fallback: assume the entire input is the parentheses string\n        s = data.strip('\"')\n    sol = Solution()\n    result = sol.longestValidParentheses(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"(()\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \")()())\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode565.json",
    "problem_index_in_file": 0,
    "title": "Array Nesting",
    "description_snippet": "You are given an integer array nums of length n where nums is a permutation of the numbers in the ra...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines. The algorithm: we have array nums. We want longest set s[k] defined by following chain of indices until duplicate occurs. This is essentially find longest cycle length in functional graph where each node points to nums[i]. Because array is permutation [0, n-1], each node has exactly one outgoing edge, graph is composed of cycles. The set s[k] length equals cycle length starting at k. So we need longest cycle length.\n\nWe can find by visiting each unvisited node and following until cycle detected, count length. Use visited boolean array. When we revisit a node in current chain, we can compute cycle length: distance between first occurrence and now. We'll track positions. Implementation in pseudo. Provide line by line with explanations.\n\nLet's produce step by step:\n\nStart\n→ Step 1: Initialize visited array of size n to false // Track visited nodes\n→ Step 2: Initialize maxLen to 0 // Result\n→ Step 3: For each index i from 0 to n-1 // Iterate all nodes\n    Decision: if visited[i]?\n        Yes → Continue // skip already processed\n        No  → Begin DFS/iteration to find cycle\n            → Step 4: Initialize current = i\n            → Step 5: Initialize depth map (dictionary) // record first position of each node in this traversal\n            → Step 6: Initialize stepCount = 0\n            Decision: while true\n                Yes → \n                    Decision: if visited[current]?\n                        Yes → Break // already processed by other cycle\n                        No  →\n                            → Step 7: Mark visited[current] = true // mark global visited\n                            → Step 8: depth[current] = stepCount // record depth\n                            → Step 9: stepCount = stepCount + 1\n                            → Step 10: current = nums[current] // move to next node\n                    No\n                No → // exit loop\n            → Step 11: If current node already in depth (i.e., we encountered a node visited in this traversal) \n                Decision: if depth contains current?\n                    Yes → cycleLen = stepCount - depth[current] // compute cycle length\n                        → Step 12: Update maxLen = max(maxLen, cycleLen)\n                    No → // no new cycle found, nothing to update\n        No\nEnd\n\nBut need to keep each line with explanation.\n\nLet's structure more clearly with arrow indent.\n\nWe'll use indentation by leading spaces maybe? They said use arrow (→). We'll indent lines for nested steps but still maintain arrow. Example: Decision: if visited[i]? Then Yes→ etc.\n\nLet's craft.\n\nBe careful: need to not output actual code but virtual code lines with explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 visited 陣列，長度為 n，所有值為 false // 用於標記節點是否已被處理過  \n→ Step 2: 初始化 maxLen 為 0 // 目前找到的最大集合長度  \n→ Step 3: 從 i = 0 到 n-1 依次檢查每個索引  \n    → Decision: 如果 visited[i] 為 true? // 已在前面處理過，跳過  \n        Yes → Continue // 直接進入下一個 i  \n        No  →  // 尚未處理的節點，開始尋找其所在的週期  \n            → Step 4: 設定 current = i // 目前節點  \n            → Step 5: 建立 depth 字典 // 記錄此遍歷中每個節點首次出現的位置  \n            → Step 6: 設定 stepCount = 0 // 目前已走過的節點數  \n            → Decision: 進入 while 迴圈  \n                Yes →  \n                    → Decision: 如果 visited[current] 為 true? // 此節點已在全局被標記  \n                        Yes → Break // 跳出 while，該路徑已完全處理  \n                        No  →  \n                            → Step 7: 設置 visited[current] = true // 全局標記為已訪問  \n                            → Step 8: 設置 depth[current] = stepCount // 記錄此節點的步驟索引  \n                            → Step 9: stepCount = stepCount + 1 // 步驟遞增  \n                            → Step 10: current = nums[current] // 移動到下一個節點  \n                    No → // 循環結束條件（實際上不會到此分支）  \n            → Step 11: Decision: 如果 depth 包含 current? // 在本次遍歷中再次遇到節點，形成週期  \n                Yes →  \n                    → Step 12: 計算 cycleLen = stepCount - depth[current] // 週期長度  \n                    → Step 13: 更新 maxLen = max(maxLen, cycleLen) // 保存更大的長度  \n                No  → // 沒有形成新的週期，無需更新  \nEnd // 程式執行結束，返回 maxLen 為答案。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def arrayNesting(self, nums):\n        \"\"\"\n        這個函式計算 nums 所構成的函數圖中最大的週期長度。\n        nums 是長度 n 的排列，故每個節點都有唯一出邊。\n        \"\"\"\n        n = len(nums)\n        visited = [False] * n  # 追蹤全局是否已處理過節點\n        max_len = 0\n\n        for i in range(n):\n            if not visited[i]:\n                current = i\n                count = 0\n                # 只要目前節點尚未被標記，繼續走向下一個節點\n                while not visited[current]:\n                    visited[current] = True\n                    current = nums[current]\n                    count += 1\n                max_len = max(max_len, count)\n\n        return max_len\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有內容，提取其中的整數\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    solution = Solution()\n    result = solution.arrayNesting(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,4,0,3,1,6,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode706.json",
    "problem_index_in_file": 0,
    "title": "Design HashMap",
    "description_snippet": "Design a HashMap without using any built-in hash table libraries.\n\nImplement the MyHashMap class:\n\nM...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, with explanation. We need to design a HashMap from scratch without using built-in hash table libs. So typical implementation: array of buckets, each bucket is a linked list (or dynamic array). Use simple hash function: key mod capacity. Use load factor? Maybe ignore resizing. We just provide basic structure.\n\nWe need to show steps for constructor, put, get, remove. Also we need to include decision steps.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義常數 CAPACITY = 1000 // 初始桶數\n→ Step 2: 初始化 buckets 為長度 CAPACITY 的空陣列 // 存放鏈表節點\n→ Step 3: 定義 Node 類 { key, value, next } // 節點結構\n\nThen methods.\n\nNeed to produce in virtual code style with arrow arrows. Use decision arrow for collisions? For put: search in bucket, if key found, update else add new node.\n\nWe should produce lines for MyHashMap() constructor, put, get, remove.\n\nLet's craft.\n\nAlso maybe show separate steps for hash function.\n\nWe need each line with explanation after //.\n\nWe'll use indentation for decisions.\n\nWe must output only the virtual code steps and explanations. No actual code. Use arrow and structure.\n\nWe can start:\n\nStart // 程式開始執行\n\n→ Step 1: 定義類 MyHashMap // 開始定義 HashMap 類\n\nThen inside class: maybe we include attributes: buckets, capacity.\n\nBut we must follow the output format: each line is a step, arrow indicates next.\n\nSo we could show:\n\n→ Step 1: 定義 CAPACITY = 1000 // 桶的初始容量\n→ Step 2: 初始化 buckets 為長度 CAPACITY 的空陣列 // 每個桶儲存 Node 連結串列\n\nThen define Node:\n\n→ Step 3: 定義 Node 類 { int key, value; Node next; } // 節點結構\n\nThen constructor:\n\n→ Step 4: MyHashMap() // 建構子\n    → Step 5: buckets 初始化 // 把 buckets 設為長度 CAPACITY 的空陣列\n\nBut we already did initialization earlier. Might be redundant.\n\nSimplify: In constructor we just assign new Node array.\n\nThen put method:\n\n→ Step 6: put(key, value) // 插入或更新\n    → Step 7: index = hash(key) // 計算桶索引\n    → Step 8: current = buckets[index] // 取得該桶頭節點\n    → Decision: 若 current 為 null? // 無節點則直接新增\n        Yes → Step 9: buckets[index] = new Node(key, value) // 新增節點\n        No  → Decision: 若 current.key == key? // 是否已存在\n            Yes → Step 10: current.value = value // 更新值\n            No  → Step 11: Move to next node in chain // 對鏈表進行迭代\n                → Step 12: 若 next 為 null? // 找到尾部\n                    Yes → Step 13: current.next = new Node(key, value) // 新增節點\n                    No  → Step 14: current = current.next // 迭代到下一節點\n\nSimilar for get and remove.\n\nBut need to show loops.\n\nSimplify: In get, we iterate chain.\n\nUse Decision for each step.\n\nLet's craft final output.\n\nEnsure each line ends with // 解釋.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義常數 CAPACITY = 1000 // 桶的初始容量  \n→ Step 2: 初始化 buckets 為長度 CAPACITY 的空陣列 // 每個桶儲存 Node 連結串列  \n→ Step 3: 定義 Node 類 { int key, value; Node next; } // 節點結構  \n\n→ Step 4: MyHashMap() // 建構子  \n    → Step 5: buckets ← new Node[CAPACITY] // 重新建立空桶陣列  \n\n→ Step 6: put(key, value) // 插入或更新  \n    → Step 7: index ← hash(key) // 計算桶索引  \n    → Step 8: current ← buckets[index] // 取得該桶頭節點  \n    → Decision: 如果 current 為 null? // 本桶尚無節點  \n        Yes → Step 9: buckets[index] ← new Node(key, value) // 新增節點並結束  \n        No  → Decision: 如果 current.key == key? // 是否已存在相同鍵  \n            Yes → Step 10: current.value ← value // 更新現有節點值  \n            No  → Step 11: Move ← current // 開始遍歷鏈表  \n                → Decision: 如果 Move.next 為 null? // 已到鏈表尾部  \n                    Yes → Step 12: Move.next ← new Node(key, value) // 新增節點  \n                    No  → Step 13: Move ← Move.next // 迭代到下一節點  \n                        → Go back to Decision: 如果 Move.key == key?  \n\n→ Step 14: get(key) // 查詢值  \n    → Step 15: index ← hash(key) // 計算桶索引  \n    → Step 16: current ← buckets[index] // 取得該桶頭節點  \n    → Decision: 如果 current 為 null? // 本桶無節點  \n        Yes → Step 17: return -1 // 無對應鍵，回傳 -1  \n        No  → Decision: 如果 current.key == key? // 找到鍵  \n            Yes → Step 18: return current.value // 回傳對應值  \n            No  → Step 19: Move ← current // 開始遍歷鏈表  \n                → Decision: 如果 Move.next 為 null? // 遍歷完畢  \n                    Yes → Step 20: return -1 // 未找到，回傳 -1  \n                    No  → Step 21: Move ← Move.next // 迭代到下一節點  \n                        → Go back to Decision: 如果 Move.key == key?  \n\n→ Step 22: remove(key) // 刪除鍵值對  \n    → Step 23: index ← hash(key) // 計算桶索引  \n    → Step 24: current ← buckets[index] // 取得該桶頭節點  \n    → Decision: 如果 current 為 null? // 本桶無節點  \n        Yes → Step 25: return // 無需刪除，結束  \n        No  → Decision: 如果 current.key == key? // 從頭節點刪除  \n            Yes → Step 26: buckets[index] ← current.next // 連接到下一節點並結束  \n            No  → Step 27: prev ← current // 設置前驅指標  \n                → Step 28: current ← current.next // 移動到下一節點  \n                → Decision: 如果 current 為 null? // 已遍歷完畢  \n                    Yes → Step 29: return // 未找到鍵，結束  \n                    No  → Decision: 如果 current.key == key? // 找到鍵  \n                        Yes → Step 30: prev.next ← current.next // 從鏈表中移除節點  \n                        No  → Step 31: prev ← current // 更新前驅  \n                            → Step 32: current ← current.next // 迭代下一節點  \n                                → Go back to Decision: 如果 current 為 null?  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass MyHashMap:\n    def __init__(self):\n        self.size = 10000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key):\n        return key % self.size\n\n    def put(self, key, value):\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        for i, (k, _) in enumerate(bucket):\n            if k == key:\n                bucket[i] = (key, value)\n                return\n        bucket.append((key, value))\n\n    def get(self, key):\n        h = self._hash(key)\n        for k, v in self.buckets[h]:\n            if k == key:\n                return v\n        return -1\n\n    def remove(self, key):\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        for i, (k, _) in enumerate(bucket):\n            if k == key:\n                bucket.pop(i)\n                return\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n    ops = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1])\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyHashMap\":\n            obj = MyHashMap()\n            results.append(None)\n        elif op == \"put\":\n            obj.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            results.append(obj.get(arg[0]))\n        elif op == \"remove\":\n            obj.remove(arg[0])\n            results.append(None)\n\n    output = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]",
          "expected_output": "[null, null, null, 1, -1, null, 1, null, -1]",
          "success": true,
          "output": "[null, null, null, 1, -1, null, 1, null, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode399.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Division",
    "description_snippet": "You are given an array of variable pairs equations and an array of real numbers values, where equati...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a virtual code line by line with explanation, following format. The problem: evaluating division equations queries. This is classic LeetCode problem \"Evaluate Division\". Approach: Build graph, use DFS or Union Find with weights. We'll produce virtual code using graph and DFS.\n\nWe need to output lines like:\n\nStart // 程式開始執行\n→ Step 1: 建立圖形資料結構 // Create adjacency map\n→ Step 2: 逐一加入 equations 和 values // Add edges\n… etc.\n\nNeed to include Decision: parts.\n\nWe must not output actual code. Provide only steps.\n\nLet's design algorithm:\n\n1. Build adjacency map: map[string]map[string]float64.\n\n2. For each equation (a,b) with value v: add a->b weight v, b->a weight 1/v.\n\n3. For each query (c,d): if either variable not in map: result -1.0. Else perform DFS from c to d, accumulating product. Use visited set to avoid loops. If found return product; else -1.0.\n\n4. Return results array.\n\nLet's produce virtual code lines.\n\nNeed to include decision points: if variable exists; if path found; else not.\n\nLet's craft.\n\nAlso note start and end.\n\nWill produce steps like:\n\nStart // 程式開始執行\n→ Step 1: 建立圖形結構 adjacency // 初始化空字典\n→ Step 2: 逐一處理 equations 與 values // 將每個等式加入圖\n    → Step 2.1: 取得 Ai, Bi, value // 取得變數和比例\n    → Step 2.2: 若 Ai 不在 adjacency, 創建子字典 // 確保能加入\n    → Step 2.3: adjacency[Ai][Bi] = value // 添加正向邊\n    → Step 2.4: adjacency[Bi][Ai] = 1/value // 添加反向邊\n→ Step 3: 初始化答案陣列 results // 用於儲存每個查詢結果\n→ Step 4: 逐一處理 queries\n    → Decision: 查詢變數是否存在於圖中? // 檢查是否可計算\n        Yes → Step 4.1: 呼叫 DFS(c, d, visited, product) // 進行深度優先搜尋\n            → Decision: DFS 成功找到路徑? // 判斷是否找到了結果\n                Yes → Step 4.1.1: results[j] = product // 將計算得到的比例存入結果\n                No  → Step 4.1.2: results[j] = -1.0 // 未找到路徑，返回 -1.0\n        No  → Step 4.2: results[j] = -1.0 // 任一變數未定義，直接返回 -1.0\n→ Step 5: Return results // 結束並回傳結果陣列\nEnd // 程式執行結束\n\nBut need to include explanation for each line. Use // after each line.\n\nAlso inside DFS, we might need steps:\n\nDFS(current, target, visited, product)\n    → Decision: current == target? // 找到目標\n        Yes → Return product // 結束搜尋，回傳累積乘積\n        No  → For each neighbour of current\n            → Decision: neighbour not visited? // 避免循環\n                Yes → Call DFS(neighbour, target, visited+neighbour, product * weight) // 進一步搜尋\n                    → Decision: DFS returned not -1? // 若找到，傳回\n                        Yes → Return that value\n                        No  → Continue\n    → Return -1.0 // 沒有路徑\n\nWe can include that as part of virtual code under Step 4.1 maybe.\n\nLet's produce full list.\n\nAlso we need to keep each step line separate. So we must list each line with appropriate arrow and indentations.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立圖形結構 adjacency // 初始化空字典，準備儲存變數之間的比例  \n→ Step 2: 逐一處理 equations 與 values // 將每個等式加入圖中  \n  → Step 2.1: 取得 Ai, Bi, value // 讀取變數名稱與對應比例  \n  → Step 2.2: 若 Ai 不在 adjacency, 創建子字典 // 確保 Ai 有鄰接表  \n  → Step 2.3: adjacency[Ai][Bi] = value // 加入正向邊 Ai → Bi，權重為 value  \n  → Step 2.4: adjacency[Bi][Ai] = 1 / value // 加入反向邊 Bi → Ai，權重為倒數  \n→ Step 3: 初始化答案陣列 results // 用於儲存每個查詢的結果  \n→ Step 4: 逐一處理 queries // 對每個查詢計算比例  \n  → Decision: 查詢變數是否存在於圖中? // 若任何變數未定義，結果為 -1.0  \n   Yes → Step 4.1: 呼叫 DFS(c, d, visited, product = 1) // 開始深度優先搜尋  \n    → Decision: DFS 成功找到路徑? // 判斷是否得到答案  \n     Yes → Step 4.1.1: results[j] = product // 存入計算得到的比例  \n     No → Step 4.1.2: results[j] = -1.0 // 未找到路徑，返回 -1.0  \n   No → Step 4.2: results[j] = -1.0 // 任一變數未定義，直接返回 -1.0  \n→ Step 5: Return results // 結束並回傳所有查詢結果陣列  \nEnd // 程式執行結束  \n\n// ----------------------------------------------  \n// DFS 函式設計（在 Step 4.1 內呼叫）  \n→ Function DFS(current, target, visited, product) // 進行深度優先搜尋  \n  → Decision: current == target? // 是否已抵達目標變數  \n   Yes → Return product // 找到路徑，返回累積乘積  \n   No → For each neighbour, weight in adjacency[current] // 遍歷所有相鄰節點  \n    → Decision: neighbour 未被訪問? // 避免循環  \n     Yes → Mark neighbour 為已訪問  \n      → Step 4.1.3: temp = DFS(neighbour, target, visited, product * weight) // 進一步搜尋  \n      → Decision: temp != -1.0? // 是否找到結果  \n       Yes → Return temp // 找到即傳回  \n       No → 解除 neighbour 標記，繼續尋找  \n       （若所有鄰居皆失敗）  \n      → Continue  \n   → Return -1.0 // 所有路徑都未找到，返回 -1.0",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        results = []\n        for u, v in queries:\n            results.append(dfs(u, v, set()))\n        return results\n\ndef main():\n    data = sys.stdin.read().strip()\n    pattern = r'equations\\s*=\\s*(\\[\\[.*?\\]\\]),\\s*values\\s*=\\s*(\\[.*?\\]),\\s*queries\\s*=\\s*(\\[.*?\\])'\n    m = re.search(pattern, data, re.S)\n    if not m:\n        return\n    equations = ast.literal_eval(m.group(1))\n    values = ast.literal_eval(m.group(2))\n    queries = ast.literal_eval(m.group(3))\n\n    sol = Solution()\n    res = sol.calcEquation(equations, values, queries)\n    output = '[' + ','.join(f'{x:.5f}' for x in res) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmphvmyk4xw.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmphvmyk4xw.py\", line 39, in main\n    queries = ast.literal_eval(m.group(3))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"c\"]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpgtdpexym.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmpgtdpexym.py\", line 39, in main\n    queries = ast.literal_eval(m.group(3))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"c\"]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp5fowj_o5.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmp5fowj_o5.py\", line 39, in main\n    queries = ast.literal_eval(m.group(3))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"b\"]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode707.json",
    "problem_index_in_file": 0,
    "title": "Design Linked List",
    "description_snippet": "Design your implementation of the linked list. You can choose to use a singly or doubly linked list....",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode lines. Provide each line as \"虛擬碼步驟 // 解釋\". Should cover MyLinkedList class design and methods. Use Start, End, Decision, etc. Provide step-by-step logic for each method. No actual code.\n\nWe must choose either singly or doubly. We can pick singly for simplicity. Provide Node definition. MyLinkedList has head pointer and size counter.\n\nWe need to generate pseudocode for initialization and each method. Each step as line. We'll produce steps for each method.\n\nThe pseudocode will include steps like: Start, Define Node, MyLinkedList class, Initialize head, size.\n\nFor get: Check index valid -> if invalid return -1, else iterate until index.\n\nAddAtHead: create node, set next to head, update head, increment size.\n\nAddAtTail: if head null addAtHead, else iterate to tail, append, increment size.\n\nAddAtIndex: if index > size return, if index==0 addAtHead, if index==size addAtTail, else iterate to node before index, insert.\n\nDeleteAtIndex: if index invalid return, if index==0 remove head, else iterate to node before, adjust next, decrement size.\n\nWe need to show decisions. Use Decision lines. Provide each line with explanation.\n\nLet's produce. Ensure each line ends with // explanation. Provide Start and End for each method? Might use Start for entire program. Could also use Start for each method but requirement: use Start, End. Likely a Start at top. But we can have Start for program, End after class definition. But methods will also have internal steps. We'll show Start and End for each method too.\n\nLet's craft.\n\nWe'll use lines like:\n\nStart // 程式開始\n\n→ Step 1: 定義 Node // Node 類別包含 val 與 next\n\n→ Step 2: 定義 MyLinkedList // MyLinkedList 類別\n\n→ Decision: 是否使用 singly linked list? // 選擇單向\n\n... maybe not necessary.\n\nWe'll include node definition.\n\nBetter to separate node definition outside class? We can have Node definition within class but simple.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 定義 Node 類別  \n  Node.val : 整數 // 節點儲存的資料  \n  Node.next : 指標 // 指向下一個節點  \n→ Step 2: 定義 MyLinkedList 類別  \n  MyLinkedList.head : Node // 指向首節點  \n  MyLinkedList.size : 整數 // 節點總數  \n→ Step 3: MyLinkedList() 初始化  \n  head ← null // 空表頭  \n  size ← 0 // 表長度為 0  \nEnd // 初始化結束  \n\n---  \n\n**get(index)**  \nStart // get 方法開始  \n→ Decision: 如果 index < 0 或 index ≥ size? // 檢查索引有效性  \n  Yes → Return -1 // 索引無效，返回 -1  \n  No  → Step 1: cur ← head // 從表頭開始  \n    i ← 0 // 記錄目前索引  \n    → Decision: i < index? // 需要往下走  \n     Yes → cur ← cur.next; i ← i + 1; → 再次決定  \n     No  → Return cur.val // 找到目標節點，返回其值  \nEnd // get 方法結束  \n\n---  \n\n**addAtHead(val)**  \nStart // addAtHead 方法開始  \n→ Step 1: node ← new Node(val) // 建立新節點  \n→ Step 2: node.next ← head // 指向舊表頭  \n→ Step 3: head ← node // 新節點成為表頭  \n→ Step 4: size ← size + 1 // 長度增加  \nEnd // addAtHead 方法結束  \n\n---  \n\n**addAtTail(val)**  \nStart // addAtTail 方法開始  \n→ Decision: head == null? // 表是否為空  \n  Yes → 執行 addAtHead(val) // 空表直接加到頭  \n  No  → Step 1: cur ← head // 從表頭開始  \n    → Decision: cur.next == null? // 是否為尾節點  \n     Yes → cur.next ← new Node(val) // 在尾部加節點  \n     No  → cur ← cur.next; → 再次決定  \n    → Step 2: size ← size + 1 // 長度增加  \nEnd // addAtTail 方法結束  \n\n---  \n\n**addAtIndex(index, val)**  \nStart // addAtIndex 方法開始  \n→ Decision: index > size? // 位置超長度  \n  Yes → Return // 不插入  \n  No  → Decision: index == 0? // 插在表頭  \n    Yes → 執行 addAtHead(val)  \n    No  → Decision: index == size? // 插在尾部  \n     Yes → 執行 addAtTail(val)  \n     No  → Step 1: cur ← head // 從表頭開始  \n      i ← 0  \n      → Decision: i < index - 1? // 找到前驅節點  \n       Yes → cur ← cur.next; i ← i + 1; → 再次決定  \n       No  → Step 2: node ← new Node(val) // 建立新節點  \n        node.next ← cur.next // 連接後繼節點  \n        cur.next ← node // 插入新節點  \n        size ← size + 1 // 長度增加  \nEnd // addAtIndex 方法結束  \n\n---  \n\n**deleteAtIndex(index)**  \nStart // deleteAtIndex 方法開始  \n→ Decision: index < 0 或 index ≥ size? // 索引無效  \n  Yes → Return // 不做任何事  \n  No  → Decision: index == 0? // 刪除表頭  \n    Yes → head ← head.next // 表頭移到下一節點  \n     size ← size - 1 // 長度減少  \n    No  → Step 1: cur ← head // 從表頭開始  \n     i ← 0  \n     → Decision: i < index - 1? // 找到前驅節點  \n      Yes → cur ← cur.next; i ← i + 1; → 再次決定  \n      No  → cur.next ← cur.next.next // 跳過要刪除的節點  \n       size ← size - 1 // 長度減少  \nEnd // deleteAtIndex 方法結束  \n\n---  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MyLinkedList:\n    class Node:\n        def __init__(self, val=0):\n            self.val = val\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.size = 0\n\n    def get(self, index):\n        if index < 0 or index >= self.size:\n            return -1\n        curr = self.head\n        for _ in range(index):\n            curr = curr.next\n        return curr.val\n\n    def addAtHead(self, val):\n        node = self.Node(val)\n        node.next = self.head\n        self.head = node\n        self.size += 1\n\n    def addAtTail(self, val):\n        node = self.Node(val)\n        if not self.head:\n            self.head = node\n        else:\n            curr = self.head\n            while curr.next:\n                curr = curr.next\n            curr.next = node\n        self.size += 1\n\n    def addAtIndex(self, index, val):\n        if index < 0 or index > self.size:\n            return\n        if index == 0:\n            self.addAtHead(val)\n            return\n        node = self.Node(val)\n        curr = self.head\n        for _ in range(index - 1):\n            curr = curr.next\n        node.next = curr.next\n        curr.next = node\n        self.size += 1\n\n    def deleteAtIndex(self, index):\n        if index < 0 or index >= self.size:\n            return\n        if index == 0:\n            self.head = self.head.next\n        else:\n            curr = self.head\n            for _ in range(index - 1):\n                curr = curr.next\n            curr.next = curr.next.next\n        self.size -= 1\n\n\nif __name__ == \"__main__\":\n    # 讀取兩行輸入：方法名列表和參數列表\n    input_lines = sys.stdin.read().strip().splitlines()\n    if len(input_lines) < 2:\n        sys.exit(0)\n    ops = json.loads(input_lines[0])\n    params_list = json.loads(input_lines[1])\n\n    obj = None\n    outputs = []\n\n    for op, params in zip(ops, params_list):\n        if op == \"MyLinkedList\":\n            obj = MyLinkedList()\n            outputs.append(None)  # constructor returns null\n        else:\n            method = getattr(obj, op)\n            # addAtHead, addAtTail, addAtIndex, deleteAtIndex return None\n            # get returns an int\n            result = method(*params) if op != \"get\" else method(*params)\n            outputs.append(result)\n\n    # 將結果轉成符合題目輸出的格式\n    out_str = '[' + ', '.join(str(val) if val is not None else 'null' for val in outputs) + ']'\n    print(out_str)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n[[], [1], [3], [1, 2], [1], [1], [1]]",
          "expected_output": "[null, null, null, null, 2, null, 3]",
          "success": true,
          "output": "[null, null, null, null, 2, null, 3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode481.json",
    "problem_index_in_file": 0,
    "title": "Magical String",
    "description_snippet": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for algorithm: magical string, count number of '1's in first n numbers. We need to generate sequence until n, track count. Use array or list to store sequence of numbers (1 or 2). The sequence can be built iteratively: start with [1,2,2] etc. Standard solution: use pointer to read the sequence generating runs.\n\nPseudo:\n\nStart\nInitialize sequence list with [1,2,2]\nindex = 2 (points to next element to generate)\ncountOnes = if n>=1?1:0? but easier to compute after.\n\nwhile length < n:\n    val = seq[index]\n    repeat val times:\n        append next val (opposite of previous? Actually next value to append is 3 - seq[-1])? Wait magical string uses values 1 and 2, run lengths alternate: after building sequence, we append val times of opposite value to last appended. Standard algorithm: use idx pointer to current position; value = seq[idx]; repeat value times: append 3 - seq[-1]; idx++.\n\nThen after loop, compute count of 1's in first n elements: iterate first n and count.\n\nReturn count.\n\nWe must output virtual code lines with explanations.\n\nLet's produce lines.\n\nUse structure: Start, → Step, → Decision etc.\n\nLet's produce.\n\nAlso need to handle case n==0: return 0.\n\nOk.\n\nLet's craft.\n\nLines:\n\nStart // 程式開始執行\n→ Step 1: If n == 0 → Return 0 // 直接回傳 0\n    No → Continue // n 大於 0，進行後續計算\n→ Step 2: Initialize seq = [1,2,2] // 開始序列\n→ Step 3: Set idx = 2 // 指向將要讀取的下一個位置\n→ Step 4: While length of seq < n // 產生序列直到長度足夠\n    → Step 5: current = seq[idx] // 取出當前的延長數\n    → Step 6: For i from 1 to current // 重複 current 次\n        → Step 7: Append 3 - seq[-1] to seq // 加入相對應的值（1<->2）\n    → Step 8: idx = idx + 1 // 移動到下一個位置\n→ Step 9: countOnes = 0 // 初始化 1 的個數\n→ Step 10: For j from 0 to n-1 // 遍歷前 n 個元素\n    → Step 11: If seq[j] == 1 → countOnes = countOnes + 1 // 累計 1\n→ Step 12: Return countOnes // 回傳結果\nEnd // 程式執行結束\n\nNeed to use proper arrow formatting: \"→\" and decisions. For loops we can use \"→ Decision: ...\" but loops can be shown as \"→ Step\" with condition in parentheses.\n\nBetter format: Use \"→ Step ... // comment\".\n\nWe can denote loops with \"→ Decision: ...\". But we need to adhere to format but not strictly required. Use arrow lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: If n == 0 → Return 0 // 直接回傳 0  \n No → Continue // n 大於 0，進行後續計算  \n→ Step 2: Initialize seq = [1, 2, 2] // 開始序列  \n→ Step 3: Set idx = 2 // 指向將要讀取的下一個位置  \n→ Decision: seq.length < n? // 需要繼續產生序列嗎？  \n Yes → Step 4: current = seq[idx] // 取出當前的延長數  \n  → Step 5: For i from 1 to current  \n    → Step 6: Append 3 - seq[-1] to seq // 加入相對應的值（1<->2）  \n  → Step 7: idx = idx + 1 // 移動到下一個位置  \n  → Decision: seq.length < n? // 檢查是否還需要產生更多  \n    Yes → 回到 Step 4  \n    No → 退出循環  \n No → // 已達到或超過所需長度  \n→ Step 7: countOnes = 0 // 初始化 1 的個數  \n→ Decision: j < n? // 遍歷前 n 個元素  \n Yes → Step 8: If seq[j] == 1 → countOnes = countOnes + 1 // 累計 1  \n    → Step 9: j = j + 1 // 移動到下一個位置  \n    → 回到 Decision  \n No → // 完成遍歷  \n→ Step 9: Return countOnes // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def magicalString(self, n: int) -> int:\n        \"\"\"\n        產生魔法字串，直到長度至少為 n，並回傳前 n 個數字中 1 的個數。\n        \"\"\"\n        if n == 0:\n            return 0\n        # 初始字串為 [1, 2, 2]\n        seq = [1, 2, 2]\n        idx = 2          # 讀取下個延長長度的位置\n        next_val = 1     # 下一個要加入的值（1 或 2）\n\n        while len(seq) < n:\n            repeat = seq[idx]          # 取出延長長度\n            seq.extend([next_val] * repeat)  # 加入相同值\n            next_val ^= 3          # 1 ↔ 2\n            idx += 1\n\n        # 計算前 n 個元素中 1 的個數\n        return seq[:n].count(1)\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取輸入，支援類似 \"n = 6\" 或僅 \"6\" 的格式\n    data = sys.stdin.read()\n    numbers = re.findall(r'\\d+', data)\n    n = int(numbers[0]) if numbers else 0\n\n    solution = Solution()\n    result = solution.magicalString(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode200.json",
    "problem_index_in_file": 0,
    "title": "Number of Islands",
    "description_snippet": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting islands in a grid. Should use DFS or BFS. Provide step-by-step virtual code, line by line, with explanation. Use Start, Decision, etc. Use arrow →. Must not output actual code. Just virtual code lines. We can produce something like:\n\nStart\n→ Step 1: Initialize count = 0\n→ Step 2: For each cell in grid\n   → Decision: If cell is '1'?\n      Yes → Step 3: Increment count\n      → Step 4: Call DFS to mark connected land as '0'\n      No → (skip)\nEnd\n\nAlso need to define DFS steps: \n\nStep 5: DFS(row, col)\n   → Decision: If row or col out of bounds? No → return\n   → Decision: If grid[row][col] == '0'? No → return\n   → Step 6: Mark grid[row][col] = '0'\n   → Step 7: DFS(row-1,col), DFS(row+1,col), DFS(row,col-1), DFS(row,col+1)\n\nReturn.\n\nNeed to keep virtual code within same structure. Use arrow and indentation. Should include the nested decisions. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 count = 0 // 用來計算島嶼個數\n→ Step 2: 對於每個座標 (r, c) 在 grid 中\n    → Decision: 如果 grid[r][c] 為 '1'? // 找到未被標記的陸地\n        Yes → Step 3: count = count + 1 // 發現一個新島\n        → Step 4: 執行 DFS(r, c) // 標記整個島為水\n        No  → (不作任何事) // 已是水或已被標記\n→ Step 5: 回傳 count // 結果為島嶼總數\nEnd // 程式執行結束\n\nDFS(row, col) // 標記整個島\n    → Decision: 如果 row 或 col 超出邊界? // 確認是否在 grid 內\n        Yes → Return // 超出範圍，結束遞迴\n        No  →\n    → Decision: 如果 grid[row][col] 為 '0'? // 已是水或已被標記\n        Yes → Return // 結束遞迴\n        No  →\n    → Step 6: grid[row][col] = '0' // 將當前陸地標記為水，避免重複計算\n    → Step 7: 執行 DFS(row-1, col) // 向上\n    → Step 8: 執行 DFS(row+1, col) // 向下\n    → Step 9: 執行 DFS(row, col-1) // 向左\n    → Step 10: 執行 DFS(row, col+1) // 向右\n    → Return // 標記完成後返回呼叫點\n\nEnd // DFS 定義結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def numIslands(self, grid):\n        \"\"\"\n        計算 2D 二維位元格中島嶼的個數。\n        grid 由 '1'（陸地）和 '0'（水）組成，使用 DFS 把已探索的陸地標記為 '0'。\n        \"\"\"\n        if not grid:\n            return 0\n\n        m, n = len(grid), len(grid[0])\n\n        def dfs(i, j):\n            # 邊界檢查\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return\n            # 如果是水或已被標記，直接返回\n            if grid[i][j] == '0':\n                return\n            # 將當前位置標記為水，避免重複計算\n            grid[i][j] = '0'\n            # 向四個方向遞迴\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    dfs(i, j)\n                    count += 1\n        return count\n\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取完整輸入\n    raw_input = sys.stdin.read()\n    # 移除可能的前綴 \"grid =\"，並去除首尾空白\n    raw_input = raw_input.strip()\n    if raw_input.startswith(\"grid\"):\n        # 找到第一個 '[' 並截取子字串\n        idx = raw_input.find('[')\n        if idx != -1:\n            raw_input = raw_input[idx:]\n    # 轉換為 Python 對象\n    try:\n        grid = ast.literal_eval(raw_input)\n    except Exception as e:\n        # 如果解析失敗，直接輸出 0\n        print(0)\n        sys.exit(0)\n\n    solution = Solution()\n    result = solution.numIslands(grid)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode762.json",
    "problem_index_in_file": 0,
    "title": "Prime Number of Set Bits in Binary Representation",
    "description_snippet": "Given two integers left and right, return the count of numbers in the inclusive range [left, right] ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that counts numbers in [left,right] where number of set bits is prime. Provide step-by-step virtual code with explanation. Use Start, Decision, etc. Ensure no actual code. Use Vietnamese? They said use Traditional Chinese. So explanation in Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋\". Use arrow and Decision. Let's outline algorithm:\n\n1. Start\n2. Step: Initialize count = 0\n3. Step: For number from left to right inclusive\n4. Step: Compute set bits of number\n5. Step: Check if set bits is prime\n6. Step: If prime, increment count\n7. Step: After loop, output count\n8. End\n\nWe need to show decisions: if set bits is prime, else not.\n\nAlso need to handle prime checking: we can precompute primes up to max bits (say 32). Decision: if set bits <= 32, check in prime set. We'll just illustrate.\n\nLet's produce virtual code with arrows. Provide explanation.\n\nLet's produce lines:\n\nStart // 開始程式\n→ Step 1: 初始化 count = 0 // 設定計數器\n→ Step 2: 為 num 從 left 到 right 進行迴圈 // 遍歷區間\n→ Step 3: 計算 num 的 setBits = count 1 的個數 // 取得位元個數\n→ Decision: setBits 是否為質數? // 判斷是否為質數\n Yes → Step 4: count += 1 // 若是質數，計數加一\n No  → // 不做任何事\n→ Step 5: 結束迴圈 // 所有數字已檢查\n→ Step 6: 輸出 count // 回傳結果\nEnd // 程式結束\n\nAlso maybe need to include prime checking algorithm. Provide substeps:\n\nStep 3.1: 計算 setBits (use while num>0: if num & 1: count++; num >>=1). But we can keep simple.\n\nWe can incorporate decision: Step 4: Check prime: loop i from 2 to sqrt(setBits); if divisible return false else true.\n\nLet's produce more detailed steps:\n\n→ Step 3: setBits = 0 // 初始化\n → Step 3.1: temp = num // 取副本\n  → While temp > 0:\n   → If temp & 1 == 1: setBits += 1\n   → temp >>= 1\n→ Decision: setBits 是否為質數? // 判斷\n Yes → Step 4: count += 1\n No  → // nothing\nBut need arrows and structure.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 count = 0 // 建立計數器  \n→ Step 2: 從 num = left 到 right 進行迴圈 // 遍歷給定範圍  \n → Step 2.1: setBits = 0 // 重新初始化位元數  \n  → Step 2.1.1: temp = num // 取 num 的副本做位元計算  \n   → While temp > 0:  \n     → If temp & 1 == 1: setBits += 1 // 若最低位為 1，位元數加一  \n      temp >>= 1 // 右移一位  \n   → End While  \n → Decision: setBits 是否為質數? // 判斷位元數是否為質數  \n  Yes → Step 3: count += 1 // 若為質數，計數器加一  \n  No  → // 不做任何事，直接跳過  \n→ End While // 完成整個區間的數字處理  \n→ Step 4: 輸出 count // 回傳符合條件的數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_prime_set_bits(left: int, right: int) -> int:\n    \"\"\"\n    計算區間 [left, right] 內，位元組中 1 的個數為質數的數字個數。\n    \"\"\"\n    # 先前定義所有可能的質數（最多 32 位元可得到的 1 的個數不超過 31）\n    primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31}\n    cnt = 0\n    for num in range(left, right + 1):\n        # 直接利用 bin 取得二進位字串，count('1') 為 set bits 數\n        if bin(num).count('1') in primes:\n            cnt += 1\n    return cnt\n\ndef main() -> None:\n    \"\"\"\n    主程式，從標準輸入讀取資料並輸出結果。\n    輸入格式可以是任何包含兩個整數的字串，例如：\n        left = 6, right = 10\n    或\n        6 10\n    \"\"\"\n    data = sys.stdin.read()\n    # 透過正則表達式抽取所有整數\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(numbers) < 2:\n        return  # 若輸入不足兩個整數則直接結束\n    left, right = numbers[0], numbers[1]\n    result = count_prime_set_bits(left, right)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 6, right = 10",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "left = 10, right = 15",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode215.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in an Array",
    "description_snippet": "Given an integer array nums and an integer k, return the k^th largest element in the array.\n\nNote th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need virtual code, no actual code. The algorithm: use min-heap of size k, or QuickSelect. Provide step-by-step virtual code. Use decision arrows. Provide explanation. Let's produce a solution using min-heap approach.\n\nSteps: Start, initialize min-heap of size 0. Iterate each num. If heap size < k, push. Else if num > heap.min, replace. After loop, heap.min is kth largest. Return.\n\nProvide decision points: if heap size < k. else if num > heap.min. Provide push/pop. Finally return min.\n\nUse virtual arrows: Start → Step: Initialize min-heap // create empty min-heap of size k; → Step: For each num in nums: → Decision: heap size < k? → Yes → Step: Add num to heap // fill heap; No → Decision: num > heap.min? → Yes → Step: Remove min and add num // replace smallest; No → Step: Continue // ignore smaller numbers; End of loop → Step: Return heap.min // kth largest. End.\n\nAlso need explanation each line.\n\nLet's format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化一個最小堆 (空) // 用於儲存目前最大的 k 個數  \n→ Step: 變數 heapSize ← 0 // 追蹤堆中元素數量  \n→ Step: 循環遍歷 nums 中的每個數值 num // 逐一處理每個元素  \n    → Decision: heapSize < k? // 堆還未填滿 k 個  \n      Yes → Step: 把 num 插入最小堆 // 填充堆  \n       heapSize ← heapSize + 1  \n      No → Decision: num > 最小堆頂值? // 新數是否比堆中最小的大  \n        Yes → Step: 移除最小堆頂值並插入 num // 替換最小，保留更大的數  \n        No → Step: 何不處理 // num 太小，忽略  \n→ Step: 循環結束 // 已處理完所有元素  \n→ Step: 返回最小堆頂值 // 堆頂即為第 k 大元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\n\nclass Solution:\n    def findKthLargest(self, nums, k):\n        # 把前 k 個數放進最小堆\n        heap = nums[:k]\n        heapq.heapify(heap)\n        # 之後的每個數，若比最小堆頂大就替換\n        for num in nums[k:]:\n            if num > heap[0]:\n                heapq.heapreplace(heap, num)   # 同時 pop 與 push\n        return heap[0]   # 堆頂即為第 k 大的元素\n\ndef parse_input():\n    raw = sys.stdin.read()\n    raw = raw.replace('\\n', ' ').strip()\n    parts = raw.split(',')\n    nums_part = None\n    k_part = None\n    for p in parts:\n        p = p.strip()\n        if p.startswith('nums'):\n            nums_part = p\n        elif p.startswith('k'):\n            k_part = p\n    if nums_part is None or k_part is None:\n        raise ValueError(\"Input format incorrect\")\n    nums = eval(nums_part.split('=')[1].strip())\n    k = int(k_part.split('=')[1].strip())\n    return nums, k\n\ndef main():\n    nums, k = parse_input()\n    sol = Solution()\n    result = sol.findKthLargest(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1,5,6,4], k = 2",
          "expected_output": "5",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmppw9x7_j0.py\", line 40, in <module>\n    main()\n  File \"/tmp/tmppw9x7_j0.py\", line 34, in main\n    nums, k = parse_input()\n              ^^^^^^^^^^^^^\n  File \"/tmp/tmppw9x7_j0.py\", line 29, in parse_input\n    nums = eval(nums_part.split('=')[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
          "expected_output": "4",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp752clzs6.py\", line 40, in <module>\n    main()\n  File \"/tmp/tmp752clzs6.py\", line 34, in main\n    nums, k = parse_input()\n              ^^^^^^^^^^^^^\n  File \"/tmp/tmp752clzs6.py\", line 29, in parse_input\n    nums = eval(nums_part.split('=')[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode318.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product of Word Lengths",
    "description_snippet": "Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate a virtual code solution for this problem. We must use the specified format: each line: \"虛擬碼步驟 // 解釋\". Use arrow →, Decision: etc. No actual code, just steps. It's like a flowchart in pseudocode. So produce steps: start, input array, create bitmask representation, iterate over pairs, check no common bits, compute product, track max, output result, end.\n\nWe must produce line-by-line.\n\nWe also need to note that we have to check no common letters: we can use bitmasks. Steps: compute mask for each word. Then nested loops: i from 0 to n-1, j from i+1 to n-1. If (mask[i] & mask[j]) == 0 then compute product. Keep max. Finally return max.\n\nInclude decision steps.\n\nWe must also include early exit? Not needed.\n\nWe should produce simple flow.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串陣列 words // 從使用者或函式參數取得所有單字  \n→ Step 2: 初始化 bitMask[] 與 maxProduct = 0 // bitMask 用於存每個單字的 26 位字母位元，maxProduct 追蹤最大值  \n→ Step 3: For each word in words  \n  → Decision: 將 word 轉成 26 位位元組 mask // 每個字母對應一位，若字母存在則位元為 1  \n   Yes → bitMask[i] = mask // 存入對應索引  \n→ Step 4: For i from 0 to words.length - 1  \n  → For j from i + 1 to words.length - 1  \n   → Decision: 是否有共通字母？ (bitMask[i] & bitMask[j] == 0) // 位元與運算判斷共有字母  \n    Yes → Step 5: 計算 product = words[i].length * words[j].length // 兩字長度乘積  \n     → Decision: product > maxProduct?  \n      Yes → maxProduct = product // 更新最大值  \n      No → // 無需更新  \n    No → // 兩字有共通字母，跳過  \n→ Step 6: 回傳 maxProduct // 若無符合條件，仍為 0  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProduct(self, words):\n        n = len(words)\n        masks = [0] * n\n        for i, word in enumerate(words):\n            mask = 0\n            for ch in word:\n                mask |= 1 << (ord(ch) - 97)\n            masks[i] = mask\n\n        max_prod = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if masks[i] & masks[j] == 0:\n                    prod = len(words[i]) * len(words[j])\n                    if prod > max_prod:\n                        max_prod = prod\n        return max_prod\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list of words from the input\n    if data.lower().startswith('words'):\n        _, _, rest = data.partition('=')\n        words_str = rest.strip()\n    else:\n        words_str = data\n\n    try:\n        words = ast.literal_eval(words_str)\n    except Exception:\n        # Fallback: treat each non-empty line as a word\n        words = [line.strip() for line in words_str.splitlines() if line.strip()]\n\n    if not isinstance(words, list):\n        words = [words]\n\n    solution = Solution()\n    result = solution.maxProduct(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        },
        {
          "example_index": 1,
          "input": "words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode698.json",
    "problem_index_in_file": 0,
    "title": "Partition to K Equal Sum Subsets",
    "description_snippet": "Given an integer array nums and an integer k, return true if it is possible to divide this array int...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for partition array into k equal sum subsets. Standard solution: check sum divisible by k, target sum = sum/k. Use backtracking with bitmask or used array. We'll produce steps. We'll describe Start, Input, Check sum, set target, use DFS to try assign elements to subsets. We'll need steps like: create array of k subset sums initialized 0. Use recursive function.\n\nWe produce line by line with explanation.\n\nLet's outline steps:\n\nStart\n→ Step 1: Input array nums, integer k\n→ Step 2: Calculate total sum of nums // total sum\n→ Decision: If total sum mod k != 0? // check divisible\n    Yes → Step 3: Return false // cannot partition\n    No  → Step 4: target = total sum / k // each subset sum\n→ Step 5: Sort nums in descending order // heuristic to prune\n→ Step 6: Create array bucketSums of size k, all zeros // store sums\n→ Step 7: Call DFS(index = 0) // try to assign numbers\n→ Decision: If DFS returns true? // success\n    Yes → Step 8: Return true\n    No  → Step 9: Return false\nDFS function (not a code line but we can represent steps)\n→ Step 10: If index == nums.length? // all numbers assigned\n    → Step 11: If all bucketSums equal target? // Actually if we ensured each bucket sum <= target, then at end all will equal target\n        Yes → Step 12: Return true\n        No  → Step 13: Return false\n→ Decision: For each bucket i from 0 to k-1?\n    Yes → Step 14: If bucketSums[i] + nums[index] <= target? // can fit\n        → Step 15: bucketSums[i] += nums[index] // assign\n        → Step 16: If DFS(index+1) returns true? // continue\n            Yes → Step 17: Return true // found valid assignment\n        → Step 18: bucketSums[i] -= nums[index] // backtrack\n        → Decision: If bucketSums[i] == 0? // if this bucket was empty before adding\n            Yes → Step 19: Break // no need to try other empty buckets, symmetry\n        → Step 20: Continue loop\n    → Step 21: Continue loop\n→ Step 22: Return false // no bucket can accommodate this number\n\nBut we need to output virtual code line by line with arrows and decisions. Use indentation for nested decisions. We'll also need to indicate function call lines.\n\nWe need to adhere to format: each line: virtual code step, space, // explanation. Use arrow characters. For decisions: use Decision: ...; then indent Yes →, No →. Let's create.\n\nWe can use \"→\" for next step.\n\nLet's produce.\n\nWe also need to label the DFS function steps. We'll just include them as part of virtual code.\n\nLet's start.\n\nLine list.\n\nWe'll number lines implicitly.\n\nWe'll use Start and End.\n\nBe careful to not output actual code, just virtual code.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入陣列 nums 與 整數 k // 從使用者處取得輸入  \n→ Step 2: 計算 nums 的總和 total // 總數值  \n→ Decision: 如果 total % k ≠ 0? // 檢查能否平均分配  \n  Yes → Step 3: 回傳 false // 無法分成 k 個相等子集  \n  No  → Step 4: target = total / k // 每個子集的目標和  \n→ Step 5: 把 nums 以降序排序 // 先放大元素以剪枝  \n→ Step 6: 建立陣列 bucketSums[0…k-1]，全部初始化為 0 // 存儲各子集已累加和  \n→ Step 7: 呼叫 DFS(0) // 從第一個元素開始試著分配  \n→ Decision: 如果 DFS(0) 回傳 true?  \n  Yes → Step 8: 回傳 true // 成功分配  \n  No  → Step 9: 回傳 false // 無法完成分配  \nEnd // 程式執行結束  \n\n// DFS 函式步驟  \n→ Function DFS(idx) // idx 為目前要分配的元素索引  \n  Decision: 如果 idx == nums.length? // 所有元素已處理  \n   Yes → Step 10: 回傳 true // 成功分配完畢  \n   No  → Step 11: 進入迴圈 for i = 0 to k-1 // 嘗試將 nums[idx] 放入每個子集  \n    Decision: 如果 bucketSums[i] + nums[idx] ≤ target? // 能否放入此子集  \n     Yes → Step 12: bucketSums[i] += nums[idx] // 放入  \n      Decision: 如果 DFS(idx+1) 回傳 true? // 進一步遞迴  \n       Yes → Step 13: 回傳 true // 成功  \n      No  → Step 14: bucketSums[i] -= nums[idx] // 回溯  \n      Decision: 如果 bucketSums[i] == 0? // 此子集原本為空，放入後無效  \n       Yes → Step 15: Break // 不再嘗試其他空子集，避免重複  \n       No  → Step 16: 繼續迴圈  \n      Decision: 繼續迴圈  \n      Decision: 迴圈結束  \n    Decision: 迴圈結束  \n    Step 17: 回傳 false // 所有子集都無法容納 nums[idx]  \n\n// 以上即為完整的虛擬碼與逐行說明。",
      "generated_code": "import sys\nimport re\nimport ast\nfrom functools import lru_cache\n\nclass Solution:\n    def canPartitionKSubsets(self, nums, k):\n        total = sum(nums)\n        if total % k != 0:\n            return False\n        target = total // k\n        n = len(nums)\n        nums.sort(reverse=True)\n        if nums[0] > target:\n            return False\n\n        @lru_cache(None)\n        def dfs(used, curr_sum, k_remaining):\n            if k_remaining == 0:\n                return True\n            if curr_sum == target:\n                # Current subset completed, start next one\n                return dfs(used, 0, k_remaining - 1)\n            for i in range(n):\n                if not (used >> i) & 1 and curr_sum + nums[i] <= target:\n                    if dfs(used | (1 << i), curr_sum + nums[i], k_remaining):\n                        return True\n            return False\n\n        return dfs(0, 0, k)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract nums and k from input like: nums = [1,2,3], k = 2\n    pattern = r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*k\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        print(\"false\")\n        sys.exit(0)\n    nums_str, k_str = match.group(1), match.group(2)\n    nums = ast.literal_eval(nums_str)\n    k = int(k_str)\n\n    result = Solution().canPartitionKSubsets(nums, k)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,3,5,2,1], k = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode740.json",
    "problem_index_in_file": 0,
    "title": "Delete and Earn",
    "description_snippet": "You are given an integer array nums. You want to maximize the number of points you get by performing...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step, for problem: given integer array, maximize points by deleting number and adjacent numbers. Equivalent to LeetCode \"Delete and Earn\". Solution: compute frequency of each number. Build array dp where dp[n] = max points up to n. dp[0] = 0; dp[1] = freq[1]*1. For i from 2 to maxVal: dp[i] = max(dp[i-1], dp[i-2] + i * freq[i]). At end return dp[maxVal].\n\nWe need virtual code lines with explanations, using arrows and Decision. Also maybe steps for building frequency map, iterating. Provide pseudocode style.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\" with arrow \"→\". Starting with Start. Include decisions maybe for loops. Use indentation? Provide indentation using spaces. Each line will include arrow.\n\nLet's craft:\n\nStart // 開始程式\n\n→ Step 1: 建立一個頻率映射 freq 以記錄每個數字出現次數 // 用哈希表存數字頻率\n\n→ Step 2: 找出陣列中最大的數值 maxVal // 需要知道 DP 限制\n\n→ Step 3: 初始化 dp 陣列長度 maxVal+1 並設置 dp[0] = 0 // dp[i] 表示最大分數到數字 i\n\n→ Decision: maxVal 是否為 0? // 若陣列空或只有 0\n\n    Yes → Step 4: 返回 0 // 無可賺分數\n\n    No → Step 5: 設置 dp[1] = freq[1] * 1 // 第一個數字的分數\n\n→ Step 6: 從 i = 2 到 maxVal 執行迴圈 // DP 主循環\n\n    → Step 6a: 計算 take = dp[i-2] + i * freq[i] // 選擇刪除 i\n\n    → Step 6b: 計算 skip = dp[i-1] // 不選擇刪除 i\n\n    → Step 6c: dp[i] = max(take, skip) // 儲存最佳方案\n\n→ Step 7: 回傳 dp[maxVal] // 最大可得分數\n\nEnd // 程式結束\n\nMake sure each line includes arrow and explanation. For decision we need indentation. Provide proper indentation as spaces. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個頻率映射 freq 以記錄每個數字出現次數 // 用哈希表存數字頻率  \n→ Step 2: 找出陣列中最大的數值 maxVal // 需要知道 DP 限制  \n→ Step 3: 初始化 dp 陣列長度 maxVal+1 並設置 dp[0] = 0 // dp[i] 表示最大分數到數字 i  \n→ Decision: maxVal 是否為 0? // 若陣列空或只有 0  \n  Yes → Step 4: 返回 0 // 無可賺分數  \n  No  → Step 5: 設置 dp[1] = freq[1] * 1 // 第一個數字的分數  \n→ Step 6: 從 i = 2 到 maxVal 執行迴圈 // DP 主循環  \n  → Step 6a: 計算 take = dp[i-2] + i * freq[i] // 選擇刪除 i 時獲得的分數  \n  → Step 6b: 計算 skip = dp[i-1] // 不選擇刪除 i 時的分數  \n  → Step 6c: dp[i] = max(take, skip) // 儲存最佳方案  \n→ Step 7: 回傳 dp[maxVal] // 最大可得分數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def deleteAndEarn(self, nums):\n        if not nums:\n            return 0\n        freq = Counter(nums)\n        max_val = max(nums)\n        dp = [0] * (max_val + 1)\n        dp[0] = 0\n        if max_val >= 1:\n            dp[1] = freq.get(1, 0) * 1\n            for i in range(2, max_val + 1):\n                dp[i] = max(dp[i - 1], dp[i - 2] + i * freq.get(i, 0))\n        return dp[max_val]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n    else:\n        nums = ast.literal_eval(data)\n        solution = Solution()\n        print(solution.deleteAndEarn(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,4,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "[2,2,3,3,3,4]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode66.json",
    "problem_index_in_file": 0,
    "title": "Plus One",
    "description_snippet": "You are given a large integer represented as an integer array digits, where each digits[i] is the it...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. For the problem: plus one to integer represented as array. Steps: start, reverse iterate, add carry, handle carry. Let's produce lines.\n\nWe should use Start, End, Decision etc. Provide each line with explanation comment.\n\nLet's produce.\n\nProbably like:\n\nStart\n→ Step 1: carry = 1 // 初始進位1\n→ Step 2: i = len(digits)-1 // 從最右邊開始\n→ Decision: i >= 0? // 是否還有位數\n    Yes → Step 3: sum = digits[i] + carry // 加上進位\n          → Decision: sum >= 10? // 是否產生進位\n              Yes → digits[i] = sum - 10 // 更新位數\n                    → Step 4: carry = 1 // 進位1\n              No  → digits[i] = sum // 更新位數\n                    → Step 5: carry = 0 // 無進位\n          → Step 6: i = i - 1 // 移到下一位\n          → Go back to Decision\n    No  → Decision: carry == 1? // 最左邊是否還有進位\n        Yes → Step 7: prepend 1 to digits // 新增進位位\n        No  → // 無進位，保持原數\nEnd\n\nBut we need to use the specific format: each line \"虛擬碼步驟 // 解釋\". Need to use arrows and indentation? The example shows indentation with \"Yes →\" and \"No →\" etc.\n\nWe need to output each line; but in the example, indentation is used to show nested structure. We'll replicate that.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: carry = 1 // 設定初始進位為 1\n→ Step 2: i = len(digits) - 1 // 取得最後一個索引\n→ Decision: i >= 0? // 是否還有位數需要處理\n    Yes → Step 3: sum = digits[i] + carry // 加上進位\n          → Decision: sum >= 10? // 是否產生進位\n              Yes → Step 4: digits[i] = sum - 10 // 更新位數\n                    → Step 5: carry = 1 // 設定進位為 1\n              No  → Step 6: digits[i] = sum // 更新位數\n                    → Step 7: carry = 0 // 無進位\n          → Step 8: i = i - 1 // 移到前一位\n          → Go back to Decision\n    No  → Decision: carry == 1? // 最左邊是否還有進位\n        Yes → Step 9: digits = [1] + digits // 在前面新增 1\n        No  → // 進位為 0，不需變更\nEnd // 程式執行結束\n\nBut the arrows: we need to use \"Yes →\" \"No →\" with indentation. The example uses \"→ Step\" lines. But maybe we can maintain. Let's produce each line as separate line with proper indent.\n\nWe must ensure each line includes \"虛擬碼步驟\" + \" // 解釋\". Each line can include arrow but not necessary? The format requires each line must contain the virtual code step followed by comment. The example uses arrows like \"→ Step 1:\" etc. We'll follow.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: carry = 1 // 初始化進位為 1  \n→ Step 2: i = len(digits) - 1 // 取得最後一位的索引  \n→ Decision: i >= 0? // 是否還有位數未處理  \n    Yes → Step 3: sum = digits[i] + carry // 加上進位  \n          → Decision: sum >= 10? // 是否需要進位  \n              Yes → Step 4: digits[i] = sum - 10 // 更新該位數  \n                    → Step 5: carry = 1 // 設定進位為 1  \n              No  → Step 6: digits[i] = sum // 更新該位數  \n                    → Step 7: carry = 0 // 無進位  \n          → Step 8: i = i - 1 // 移到上一位  \n          → Go back to Decision  \n    No  → Decision: carry == 1? // 最左邊是否還有進位  \n        Yes → Step 9: digits = [1] + digits // 在最前面新增 1  \n        No  → // 進位為 0，不需變更  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        Increment the integer represented by digits by one.\n        \"\"\"\n        for i in range(len(digits) - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        return [1] + digits\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Find the list inside the input string\n    match = re.search(r'\\[.*\\]', data)\n    if not match:\n        # If no list is found, nothing to process\n        return\n\n    # Safely evaluate the list\n    digits = ast.literal_eval(match.group())\n\n    # Compute the result\n    result = Solution().plusOne(digits)\n\n    # Output in the desired format without spaces\n    output = '[' + ','.join(str(num) for num in result) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "digits = [1,2,3]",
          "expected_output": "[1,2,4]",
          "success": true,
          "output": "[1,2,4]"
        },
        {
          "example_index": 1,
          "input": "digits = [4,3,2,1]",
          "expected_output": "[4,3,2,2]",
          "success": true,
          "output": "[4,3,2,2]"
        },
        {
          "example_index": 2,
          "input": "digits = [9]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1,0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode646.json",
    "problem_index_in_file": 0,
    "title": "Maximum Length of Pair Chain",
    "description_snippet": "You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti.\n\nA pair...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for longest chain of pairs. Use dynamic programming or greedy? Problem akin to maximum length chain of intervals (like \"maximum length chain of pairs\"). Classic solution: sort by right, then greedy: pick first, then next with left > last_right. That's longest chain (maximum). That's similar to interval scheduling by end time. For pairs where lefti<righti. That greedy gives optimal for maximizing chain length. So pseudocode: sort pairs by right ascending. Initialize count=0, last_end=-∞. For each pair in sorted: if pair.left > last_end then count++, last_end=pair.right. Return count.\n\nWe produce step-by-step pseudocode.\n\nAlso maybe need to explain decisions. Use virtual code with arrows. So steps:\n\nStart\n→ Step 1: Sort pairs ascending by right value // order by ending times\n→ Step 2: Initialize chain_length = 0 // counter\n→ Step 3: Initialize last_end = -∞ // track last selected pair's right\n→ Decision: For each pair in sorted list? // iterate\n    → For pair in sorted:\n        → Decision: If pair.left > last_end? // can follow\n            Yes → Step: chain_length++ // add to chain\n                 → Step: last_end = pair.right // update last_end\n            No  → Step: // skip this pair\n\nAfter loop: → Step: Return chain_length // longest chain length\nEnd\n\nMake sure each line is one step.\n\nBut we need \"逐行地\" produce. Should include decisions for each pair. But we cannot loop in pseudocode? We can represent iteration as Step: For each pair in sorted list: ... We can use Decision inside loop. Format: Use arrow '→'.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Sort the input array of pairs in ascending order by the right element // 先依右端排序，方便贈用貪婪策略\n→ Step 2: Initialize chain_length = 0 // 目前已組成的鏈長度\n→ Step 3: Initialize last_end = -∞ // 最後一個被選取的 pair 的 right\n→ Step 4: For each pair (left, right) in the sorted list // 逐一檢查每個 pair\n    → Decision: 是否能接續前一個 pair? // 判斷條件 left > last_end\n        Yes → Step 5: chain_length = chain_length + 1 // 包含此 pair，鏈長度加 1\n             → Step 6: last_end = right // 更新最後一個 pair 的 right\n        No  → Step 7: // 跳過此 pair，保持先前狀態\nEnd // 程式執行結束\n\nBut need to show \"Decision\" lines with Yes/No arrow indentation.\n\nUse syntax:\n\n→ Decision: If left > last_end? // ...\n    Yes → Step ...\n    No  → Step ...\n\nLet's produce final answer accordingly. Ensure each line ends with comment after //. Provide step numbers. Use virtual arrow '→'.\n\nAlso might include 'Start', 'End'.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort the input array of pairs by the right endpoint in ascending order // 先依右端排序，方便後續貪婪選擇\n→ Step 2: Initialize chain_length = 0 // 記錄目前已形成的鏈長度\n→ Step 3: Initialize last_end = -∞ // 追蹤最後一個被選取的 pair 的 right 值\n→ Step 4: For each pair (left, right) in the sorted list // 逐一檢查每個 pair\n    → Decision: 若 left > last_end? // 判斷此 pair 能否接續前一個 pair\n        Yes → Step 5: chain_length = chain_length + 1 // 包含此 pair，鏈長度加 1\n            → Step 6: last_end = right // 更新最後一個 pair 的 right 為 current right\n        No  → Step 7: // 跳過此 pair，保持先前狀態\nEnd // 程式執行結束, 返回 chain_length 為最長鏈長度",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLongestChain(self, pairs):\n        # 按右端點排序，使用贪婪策略\n        pairs.sort(key=lambda x: x[1])\n        curr = float('-inf')   # 目前最後一個選取的 pair 的右端\n        count = 0\n        for a, b in pairs:\n            if a > curr:       # 可以接續前一個 pair\n                curr = b\n                count += 1\n        return count\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入，支援兩種格式：\n    1. 'pairs = [[1,2],[2,3]]'\n    2. [[1,2],[2,3]]\n    \"\"\"\n    data = data.strip()\n    if '=' in data:\n        _, after = data.split('=', 1)\n        data = after.strip()\n    return ast.literal_eval(data)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    pairs = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findLongestChain(pairs)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "pairs = [[1,2],[2,3],[3,4]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "pairs = [[1,2],[7,8],[4,5]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode472.json",
    "problem_index_in_file": 0,
    "title": "Concatenated Words",
    "description_snippet": "Given an array of strings words (without duplicates), return all the concatenated words in the given...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: given array of strings words without duplicates, return all concatenated words comprised of at least two shorter words from the array. We need step-by-step virtual code with explanation each line. Use Start, End, Decision. Should be line by line.\n\nWe need to produce a virtual algorithm: maybe use a trie or set for dictionary, dynamic programming per word, recursion with memoization, etc. We need to list steps.\n\nLet's design algorithm:\n\n1. Sort words by length ascending.\n2. Build a set of words (dictionary).\n3. For each word in sorted words:\n   - Remove the word from set temporarily to avoid using itself.\n   - Check if word can be formed by concatenating other words: use DP array of length+1, dp[0]=true, for i from 1 to len: for j from 0 to i-1: if dp[j] and substring(i-j) in set then dp[i]=true break.\n   - If dp[len] true, add to result.\n   - Add word back to set.\n\nReturn result.\n\nVirtual code line by line.\n\nWe need to use arrow for each step.\n\nMake sure to include decision statements.\n\nLet's produce.\n\nWe need to output:\n\nStart // program starts\n\n→ Step 1: sort words by length ascending // to process shorter words first\n\n→ Step 2: initialize wordSet with all words // dictionary for O(1) lookups\n\n→ Step 3: initialize empty result list // store concatenated words\n\n→ Decision: 遍歷每個 word in words? // iterate through sorted words\n\n   Yes → Step 4: temporarily remove word from wordSet // avoid using itself\n\n   Yes → Step 5: initialize dp array of size len(word)+1 with false // DP table\n\n   Yes → dp[0] = true // base case\n\n   Yes → Decision: i from 1 to len(word)? // iterate positions\n\n       Yes → Decision: j from 0 to i-1? // check substrings\n\n           Yes → Decision: dp[j] && substring(word, j, i) in wordSet? // check\n\n               Yes → dp[i] = true; break inner loop // mark reachable\n\n       End inner loop\n\n   End outer loop\n\n   Yes → Decision: dp[len(word)] is true? // can be formed?\n\n       Yes → Step 6: add word to result // it's concatenated\n\n   Yes → Step 7: add word back to wordSet // restore dictionary\n\n   No → ... (but we always do yes, but we need no branch? maybe not necessary)\n\n   End traversal\n\n→ End // program ends\n\nBut need to output each line individually, with arrow and explanation.\n\nWe must format each line: `虛擬碼步驟 // 解釋/說明`\n\nMake sure each line contains a step, maybe some nested decision lines.\n\nLet's produce with indentations using tabs or spaces? They didn't specify but example shows indentation with spaces. Use tabs? Use spaces.\n\nWe need each line to start with arrow or decision: For decisions, use `Decision: ...` with indentation, then Yes/No lines.\n\nLet's produce.\n\nAlso need to include `End // 程式執行結束`.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort words by length ascending // 先處理較短的字串，方便後續判斷  \n→ Step 2: Initialize wordSet with all words from words // 建立 O(1) 查詢的字典  \n→ Step 3: Initialize empty result list // 用來儲存符合條件的連結字串  \n→ Decision: 遍歷 words 中每一個 word? // 逐一檢查每個字串  \n    Yes → Step 4: Temporarily remove word from wordSet // 防止自己被當作子字串  \n    Yes → Step 5: Create dp array of size len(word)+1, all false // DP 表示子字串能否被拼接  \n    Yes → dp[0] = true // 空字串可視為已拼接完成  \n    Yes → Decision: i from 1 to len(word)? // 逐位檢查到整個字串  \n        Yes → Decision: j from 0 to i-1? // 嘗試所有前綴分割點  \n            Yes → Decision: dp[j] 且 word[j:i] in wordSet? // 前綴能拼接且後綴為字典內字串  \n                Yes → dp[i] = true; break // 找到一個合法拼接，跳出內層迴圈  \n        End inner loop  \n    End outer loop  \n    Yes → Decision: dp[len(word)] is true? // 整個字串是否能被拼接完成  \n        Yes → Step 6: Add word to result // 合格的連結字串加入結果  \n    Yes → Step 7: Add word back to wordSet // 將字串還回字典，供後續字串使用  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport ast\n\ndef findAllConcatenatedWordsInADict(words):\n    word_set = set(words)\n    memo = {}\n\n    def canForm(word):\n        if word in memo:\n            return memo[word]\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in word_set:\n                if suffix in word_set or canForm(suffix):\n                    memo[word] = True\n                    return True\n        memo[word] = False\n        return False\n\n    result = []\n    for word in words:\n        if not word:      # skip empty string\n            continue\n        word_set.remove(word)\n        if canForm(word):\n            result.append(word)\n        word_set.add(word)\n    return result\n\ndef parse_input(data):\n    data = data.strip()\n    if data.startswith('words'):\n        try:\n            _, expr = data.split('=', 1)\n            return ast.literal_eval(expr.strip())\n        except Exception:\n            pass\n    # fallback: try to parse entire input as a Python literal\n    return ast.literal_eval(data)\n\ndef main():\n    raw = sys.stdin.read()\n    words = parse_input(raw)\n    res = findAllConcatenatedWordsInADict(words)\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "success": true,
          "output": "[\"catsdogcats\", \"dogcatsdog\", \"ratcatdogcat\"]"
        },
        {
          "example_index": 1,
          "input": "words = [\"cat\",\"dog\",\"catdog\"]",
          "expected_output": "[\"catdog\"]",
          "success": true,
          "output": "[\"catdog\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode341.json",
    "problem_index_in_file": 0,
    "title": "Flatten Nested List Iterator",
    "description_snippet": "You are given a nested list of integers nestedList. Each element is either an integer or a list whos...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing NestedIterator. The user wants virtual code, not actual code. Provide step-by-step pseudocode with explanation. Use the format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrows. Provide class, constructor, methods. Use a stack or queue for flattening. Use DFS pre-processing or iterative. Provide explanation. Use Start, End. Provide decisions for hasNext. Provide next. Provide stack pointer. Provide nested list structure. Provide pseudocode. Ensure each line ends with explanation.\n\nLet's produce something like:\n\nStart\n→ Class NestedIterator // 定義迭代器類別\n→ 變數 stack: List<Iterator<NestedInteger>> // 用於追蹤當前位置\n→ 變數 nextInt: Integer = null // 用於暫存下一個可返回的整數\n\n→ Constructor NestedIterator(nestedList)\n    → stack.push(iter(nestedList)) // 將最外層迭代器加入堆疊\n    → advance() // 將 nextInt 置為第一個可用整數\n\n→ Method advance() // 內部方法，尋找並設定 nextInt\n    → While stack 非空\n        → current = stack.top()\n        → If !current.hasNext() \n            → stack.pop() // 迭代器已走完，移除\n            → Continue\n        → currElem = current.next()\n        → If currElem.isInteger()\n            → nextInt = currElem.getInteger()\n            → Return\n        → Else\n            → stack.push(iter(currElem.getList())) // 進入子列表\n\n→ Method hasNext()\n    → Return nextInt != null // 若有預取整數則為真\n\n→ Method next()\n    → result = nextInt\n    → nextInt = null\n    → advance() // 尋找下一個整數\n    → Return result\n\nEnd\n\nExplain each line. Use arrow. Use decision. Should also include decision for hasNext. Provide explanation. Ensure each line includes comment. Use Chinese. Provide arrow formatting.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class NestedIterator // 定義 NestedIterator 類別  \n→ 變數 stack: List<Iterator<NestedInteger>> = [] // 堆疊，存放各層列表的迭代器  \n→ 變數 nextInt: Integer = null // 暫存下一個可返回的整數  \n\n→ Constructor NestedIterator(nestedList) // 建構子，接受外層列表  \n    → stack.push(iter(nestedList)) // 將最外層列表的迭代器加入堆疊  \n    → advance() // 立即尋找並設定 nextInt 為第一個可用整數  \n\n→ Method advance() // 內部輔助方法：尋找下一個可返回的整數  \n    → While stack 非空 // 當還有未處理的層  \n        → current = stack.top() // 取得目前堆疊頂端的迭代器  \n        → Decision: 如果 current.hasNext() == false? // 判斷當前層是否已走完  \n            Yes → stack.pop() // 沒有下一項，移除此層迭代器  \n            No  → // 繼續以下處理  \n        → currElem = current.next() // 取得目前迭代器的下一個元素  \n        → Decision: 如果 currElem.isInteger()? // 判斷是整數還是子列表  \n            Yes → nextInt = currElem.getInteger() // 設定 nextInt 為該整數  \n            No  → stack.push(iter(currElem.getList())) // 進入子列表，將其迭代器加入堆疊  \n    → nextInt = null // 若堆疊全部走完，表示沒有更多整數  \n\n→ Method hasNext() // 檢查是否還有可返回的整數  \n    → Return nextInt != null // 若 nextInt 已設定，則有下一個  \n\n→ Method next() // 取得並返回下一個整數  \n    → result = nextInt // 先存取目前的 nextInt  \n    → nextInt = null // 清空，為下一次尋找做準備  \n    → advance() // 立即尋找下一個可用整數  \n    → Return result // 回傳之前的整數  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass NestedIterator:\n    \"\"\"\n    迭代器，能把任意巢狀的列表（含整數或子列表）扁平化。\n    \"\"\"\n    def __init__(self, nestedList):\n        # 堆疊保存各層的迭代器\n        self.stack = [iter(nestedList)]\n        # 用於暫存下個可返回的整數\n        self.next_elem = None\n\n    def _advance(self):\n        \"\"\"\n        在堆疊中尋找並設定下一個整數。\n        \"\"\"\n        while self.stack:\n            try:\n                val = next(self.stack[-1])\n            except StopIteration:\n                # 目前層已經遍歷完，移除該層\n                self.stack.pop()\n                continue\n\n            if isinstance(val, int):\n                # 找到整數，暫存並結束\n                self.next_elem = val\n                return\n            else:\n                # 遇到子列表，進入子層\n                self.stack.append(iter(val))\n\n        # 沒有更多整數可供返回\n        self.next_elem = None\n\n    def hasNext(self):\n        \"\"\"\n        若堆疊中還有整數可返回則為 True。\n        \"\"\"\n        if self.next_elem is not None:\n            return True\n        self._advance()\n        return self.next_elem is not None\n\n    def next(self):\n        \"\"\"\n        返回下一個整數。\n        \"\"\"\n        if self.next_elem is None:\n            self._advance()\n            if self.next_elem is None:\n                raise StopIteration(\"No more elements\")\n\n        result = self.next_elem\n        self.next_elem = None\n        return result\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，例如 \"nestedList = [[1,1],2,[1,1]]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data.strip()\n\n    # 使用 ast.literal_eval 轉換成 Python 物件\n    try:\n        nested_list = ast.literal_eval(expr)\n    except Exception as e:\n        print(\"Invalid input\")\n        return\n\n    iterator = NestedIterator(nested_list)\n    result = []\n    while iterator.hasNext():\n        result.append(iterator.next())\n\n    # 以無空格的格式輸出\n    output = '[' + ','.join(map(str, result)) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nestedList = [[1,1],2,[1,1]]",
          "expected_output": "[1,1,2,1,1]",
          "success": true,
          "output": "[1,1,2,1,1]"
        },
        {
          "example_index": 1,
          "input": "nestedList = [1,[4,[6]]]",
          "expected_output": "[1,4,6]",
          "success": true,
          "output": "[1,4,6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode485.json",
    "problem_index_in_file": 0,
    "title": "Max Consecutive Ones",
    "description_snippet": "Given a binary array nums, return the maximum number of consecutive 1's in the array....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: maximum number of consecutive 1s in binary array. It's classic. We'll write algorithm: iterate array, keep current count and max count, update accordingly.\n\nNeed to follow format: Each line \"虛擬碼步驟 // 解釋/說明\". Use arrow and decision.\n\nStart, End, Decision.\n\nOk.\n\nLine1: Start // 程式開始執行\n\nLine2: → Step 1: 初始化 maxCount = 0, currentCount = 0 // 設定最大與當前計數\n\nLine3: → Step 2: 對每個數字 num 在 nums 迭代 // 逐一檢查陣列元素\n\nLine4: → Decision: 如果 num == 1? // 判斷是否為 1\n\nLine5:     Yes → Step 3: currentCount = currentCount + 1 // 增加連續 1 的計數\n\nLine6:     No  → Step 4: maxCount = max(maxCount, currentCount) // 更新最大值\n\nLine7:     No  → Step 5: currentCount = 0 // 重置連續 1 的計數\n\nBut careful: we need to separate branches. In pseudocode: If num==1: currentCount++ else: maxCount = max(maxCount, currentCount); currentCount=0.\n\nThus after the decision we have two branches. But we can collapse them with separate steps under No.\n\nWe must also update maxCount after loop ends: after iteration finished, need to check last run.\n\nLine8: → Step 6: maxCount = max(maxCount, currentCount) // 處理陣列結尾可能的連續 1\n\nLine9: → Step 7: 回傳 maxCount // 結果\n\nLine10: End // 程式結束\n\nMake sure each line has arrow arrow? The example uses \"→\" before Step. Decision uses \"Decision:\".\n\nOk.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 maxCount = 0, currentCount = 0 // 設定最大連續 1 的長度與目前連續計數  \n→ Step 2: 對每個數字 num 在 nums 迭代 // 逐一檢查陣列元素  \n→ Decision: 如果 num == 1? // 判斷是否為 1  \n  Yes → Step 3: currentCount = currentCount + 1 // 連續 1 的計數加一  \n  No  → Step 4: maxCount = max(maxCount, currentCount) // 更新最大值  \n  No  → Step 5: currentCount = 0 // 重置連續 1 的計數  \n→ Step 6: maxCount = max(maxCount, currentCount) // 處理陣列結尾可能的連續 1  \n→ Step 7: 回傳 maxCount // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaxConsecutiveOnes(self, nums):\n        max_count = 0\n        count = 0\n        for num in nums:\n            if num == 1:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count = 0\n        return max_count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        sys.exit(0)\n\n    # Remove possible prefix like \"nums = \"\n    if data.lower().startswith(\"nums\"):\n        data = data[data.find('=') + 1:]\n    # Use literal_eval to safely parse the list\n    try:\n        nums = ast.literal_eval(data.strip())\n    except Exception:\n        # If parsing fails, treat as empty list\n        nums = []\n\n    result = Solution().findMaxConsecutiveOnes(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,0,1,1,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode453.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate a virtual code step-by-step solution to the problem: \"Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal. In one move, you can increment n-1 elements of the array by 1.\"\n\nWe need to output in traditional Chinese (繁體中文). Must be virtual code lines with \"Start\", \"→ Step\", \"Decision:\", etc., and after each line a space then // explanation. No actual code.\n\nWe need to produce algorithm: it's known problem, the minimal moves equals sum(nums) - n * min(nums). So steps: find min, sum, compute difference.\n\nWe need to produce pseudocode: Start, Step 1: Initialize sum = 0, minVal = Infinity, Step 2: For each element in nums: add to sum, update minVal if less. Step 3: Compute moves = sum - n * minVal. Step 4: Output moves. End.\n\nWe should include a Decision? Maybe not needed. But can include Decision: if array empty? Not necessary. But we can show a Decision: if n==0? Not needed. But can include.\n\nWe need to use arrow syntax: \"→ Step X:\" etc.\n\nWe need to include \"Start\" and \"End\".\n\nAlso we might include comment lines.\n\nLet's produce a clean output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 sum ← 0, minVal ← +∞ // 初始化總和與最小值  \n→ Step 2: 逐一遍歷 nums 中的每個元素 x  \n  → Step 2.1: sum ← sum + x // 累加總和  \n  → Decision: x 小於 minVal? // 檢查是否更新最小值  \n   Yes → minVal ← x // 若是更小，更新 minVal  \n   No → // 無操作  \n→ Step 3: 計算 moves ← sum - n * minVal // 取得最小移動次數  \n→ Step 4: 輸出 moves // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def minMoves(self, nums):\n        return sum(nums) - min(nums) * len(nums)\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中擷取列表字串，例如 \"[1,2,3]\"\n    m = re.search(r'\\[.*\\]', data)\n    if not m:\n        # 若找不到列表，直接輸出 0\n        print(0)\n        return\n\n    nums_str = m.group(0)\n    try:\n        # 用安全的方式將字串轉為 Python 列表\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        nums = []\n\n    # 計算最小移動次數\n    if not nums:\n        print(0)\n    else:\n        solution = Solution()\n        result = solution.minMoves(nums)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode225.json",
    "problem_index_in_file": 0,
    "title": "Implement Stack using Queues",
    "description_snippet": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should suppo...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for implementing a stack using two queues. Provide each line with virtual code step + comment. Need to explain each line. Use Start, End, Decision. Provide only virtual code, no actual code. The lines represent steps. Since this is algorithmic description, we need to describe the class methods. We can treat initialization and operations. Probably start with Start for each method.\n\nWe'll output steps: initialize two queues q1, q2. push: enqueue to q1. pop: if q1 empty return error. else move all but last element from q1 to q2, dequeue last element (the top), then swap q1 and q2. top: similar but after retrieving last element, enqueue it back to q2, then swap. empty: return if q1 empty.\n\nWe'll produce steps for each method. Also include class initialization. So maybe:\n\nStart // MyStack class initialization\n→ Step: initialize queue1 as empty // q1\n→ Step: initialize queue2 as empty // q2\nEnd\n\nBut we need to use virtual code lines.\n\nLet's produce a block:\n\nStart // MyStack class constructor\n→ Step 1: Create empty queue Q1 // 主隊列\n→ Step 2: Create empty queue Q2 // 辅助隊列\nEnd // 构造完成\n\nThen push:\n\nStart // push method\n→ Step 1: Enqueue x to Q1 // 把新元素加入主隊列\nEnd\n\npop:\n\nStart // pop method\n→ Decision: If Q1 is empty? // 检查是否为空\n    Yes → Step 1: Return error // 无元素\n    No → Step 2: While size of Q1 > 1? // 移动除最后一个以外的所有元素\n        Yes → Step 3: Dequeue from Q1 and enqueue to Q2 // 逐个转移\n        No  → Step 4: Dequeue last element from Q1 → temp // 这是栈顶\n    → Step 5: Swap Q1 and Q2 // 让 Q1 成为新的主队列\n    → Step 6: Return temp // 返回栈顶元素\nEnd\n\ntop:\n\nStart // top method\n→ Decision: If Q1 is empty? // 检查是否为空\n    Yes → Step 1: Return error\n    No → Step 2: While size of Q1 > 1? // 移动除最后一个以外的所有元素\n        Yes → Step 3: Dequeue from Q1 and enqueue to Q2\n        No  → Step 4: Dequeue last element from Q1 → temp // 栈顶\n    → Step 5: Enqueue temp back to Q2 // 保持元素\n    → Step 6: Swap Q1 and Q2 // 让 Q1 成为新的主队列\n    → Step 7: Return temp // 返回栈顶\nEnd\n\nempty:\n\nStart // empty method\n→ Step 1: Return Q1 is empty // 判断主队列是否为空\nEnd\n\nMake sure each line ends with // 解釋.\n\nAlso use arrow '→' before each step except maybe Start and End. For Decision block indent as in example.\n\nMake sure we use \"Decision:\" lines and indent Yes →, No → etc.\n\nOk produce final answer.\n...done thinking.\n\nStart // MyStack 類別初始化  \n→ Step 1: 創建空隊列 Q1 // 主隊列，存放所有元素  \n→ Step 2: 創建空隊列 Q2 // 辅助隊列，用於 pop/top 操作  \nEnd // 結束構造\n\nStart // push 方法  \n→ Step 1: 把 x 入隊到 Q1 // 將新元素加入主隊列的尾部  \nEnd // push 完成\n\nStart // pop 方法  \n→ Decision: 如果 Q1 為空? // 檢查是否還有元素  \n    Yes → Step 1: 返回錯誤或空值 // 沒有元素可彈出  \n    No  → Step 2: 當 Q1 大於 1 時? // 將除最後一個外的所有元素移到 Q2  \n        Yes → Step 3: 從 Q1 前端取出並 enqueue 到 Q2 // 逐一轉移  \n        No  → Step 4: 從 Q1 前端取出並存入 temp // 這就是栈顶元素  \n    → Step 5: 交換 Q1 與 Q2 的引用 // Q1 重新成為主隊列，Q2 清空  \n    → Step 6: 返回 temp // 返回彈出的栈顶元素  \nEnd // pop 完成\n\nStart // top 方法  \n→ Decision: 如果 Q1 為空? // 檢查是否還有元素  \n    Yes → Step 1: 返回錯誤或空值 // 沒有元素可查看  \n    No  → Step 2: 當 Q1 大於 1 時? // 將除最後一個外的所有元素移到 Q2  \n        Yes → Step 3: 從 Q1 前端取出並 enqueue 到 Q2 // 逐一轉移  \n        No  → Step 4: 從 Q1 前端取出並存入 temp // 這就是栈顶元素  \n    → Step 5: 把 temp 再 enqueue 回 Q2 // 保持栈顶元素在隊列中  \n    → Step 6: 交換 Q1 與 Q2 的引用 // Q1 重新成為主隊列  \n    → Step 7: 返回 temp // 返回栈顶元素但不移除  \nEnd // top 完成\n\nStart // empty 方法  \n→ Step 1: 返回 Q1 是否為空 // 判斷整個栈是否為空  \nEnd // empty 完成",
      "generated_code": "import sys\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        # 主隊列 q1 用來保持當前元素，輔助隊列 q2 用於一次性完成 push 操作\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        # 把新元素先入輔助隊列\n        self.q2.append(x)\n        # 把主隊列中原有的元素全部移到輔助隊列，保持 LIFO 順序\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        # 交換兩隊列，q1 成為新的主隊列，q2 清空\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self) -> int:\n        # 主隊列前端即為堆疊頂端元素\n        return self.q1.popleft()\n\n    def top(self) -> int:\n        return self.q1[0]\n\n    def empty(self) -> bool:\n        return not self.q1\n\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字符串，得到兩個列表：commands 和 arguments。\n    例如：'Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]'\n    \"\"\"\n    data = data.strip()\n    if data.startswith(\"Input\"):\n        data = data[len(\"Input\"):].strip()\n    # 分離兩個列表\n    # 找到第一個 '], [' 的位置\n    split_pos = data.find(\"], [\")\n    if split_pos == -1:\n        raise ValueError(\"Invalid input format\")\n    left = data[:split_pos + 1]    # 包含第一個 ']'\n    right = data[split_pos + 3:]   # 從第二個 '[' 開始\n    # 用 json 解析，先把單引號換成雙引號\n    import json\n    commands = json.loads(left.replace(\"'\", '\"'))\n    arguments = json.loads(right.replace(\"'\", '\"'))\n    return commands, arguments\n\n\ndef result_to_string(res):\n    \"\"\"將結果列表轉成 LeetCode 樣式輸出字串\"\"\"\n    parts = []\n    for v in res:\n        if v is None:\n            parts.append(\"null\")\n        elif v is True:\n            parts.append(\"true\")\n        elif v is False:\n            parts.append(\"false\")\n        else:\n            parts.append(str(v))\n    return \"[\" + \", \".join(parts) + \"]\"\n\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    commands, arguments = parse_input(data)\n\n    stack = None\n    output = []\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"MyStack\":\n            stack = MyStack()\n            output.append(None)\n        elif cmd == \"push\":\n            stack.push(args[0])\n            output.append(None)\n        elif cmd == \"pop\":\n            output.append(stack.pop())\n        elif cmd == \"top\":\n            output.append(stack.top())\n        elif cmd == \"empty\":\n            output.append(stack.empty())\n        else:\n            # 忽略未知指令\n            output.append(None)\n\n    print(result_to_string(output))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "success": true,
          "output": "[null, null, null, 2, 2, false]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode279.json",
    "problem_index_in_file": 0,
    "title": "Perfect Squares",
    "description_snippet": "Given an integer n, return the least number of perfect square numbers that sum to n.\n\nA perfect squa...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for solving the \"Perfect Squares\" problem: given integer n, return least number of perfect squares that sum to n. We need to output step-by-step virtual code, each line with explanation, using the arrow and structure. The problem likely uses dynamic programming or BFS.\n\nWe need to produce a step-by-step algorithm. We must include start, end, decision nodes. Use virtual code arrows. Provide explanation after each line.\n\nWe need to ensure we follow formatting: each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use Chinese characters for explanation. Use arrow \"→\" etc. Provide start, end.\n\nWe need to generate virtual code line by line. Let's design algorithm:\n\nStart\n→ Initialize dp array size n+1 with large values; dp[0]=0\n→ For i from 1 to n:\n    → For each square <= i:\n        → Update dp[i] = min(dp[i], dp[i - square] + 1)\n→ Return dp[n]\nEnd\n\nAdd decisions? Might add a decision to check if n is perfect square, immediate return 1. But we can incorporate that in algorithm: For each i, if i is perfect square, dp[i] = 1.\n\nWe can also include decision to break loops when square > i.\n\nWe'll produce lines.\n\nWe must include arrow after each step? Format uses \"→ Step X: ...\". So we must use that for each line.\n\nWe can also include decision lines. For example:\n\n→ Decision: 如果 i 是完美平方? // Check if i is perfect square\n\nBut we can incorporate in loop: but it's okay.\n\nLet's produce structured pseudo-code:\n\nStart\n→ Step 1: 定義 dp 陣列，長度 n+1，全部設為無限大 // 初始化\n→ Step 2: 設定 dp[0] = 0 // 零的最少數目\n→ Step 3: 針對 i 從 1 到 n 迭代 // 外層循環\n    → Step 4: 針對 square 從 1 開始，平方值 <= i\n        → Step 5: 若 square^2 > i → No → Break // 跳出內層\n        → Step 6: 更新 dp[i] = min(dp[i], dp[i - square^2] + 1) // 更新最小值\n→ End // 完成\n\nBut we need to use Decision arrow syntax: \"Decision:\" lines.\n\nWe could incorporate a decision at step 4: if square^2 > i? but we use for loop that stops automatically.\n\nWe can use a Decision: if i is perfect square? but we can just update via dp.\n\nBetter to use a DP approach with nested loops.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列，長度 n+1，並將每個元素設為無限大 // 初始化\n→ Step 2: 設定 dp[0] = 0 // 零的最少平方數為 0\n→ Step 3: 對於 i 從 1 到 n 進行迴圈 // 外層循環\n    → Decision: i 是否為完美平方? // 檢查 i 是否本身即為平方數\n        Yes → Step 4: dp[i] = 1 // 如果是，直接設定為 1\n        No  → Step 5: 針對 square 從 1 開始\n            → Decision: square^2 > i? // 判斷是否超過 i\n                Yes → No → Break // 若超過，跳出內層循環\n                No  → Step 6: 更新 dp[i] = min(dp[i], dp[i - square^2] + 1) // 更新最小值\n→ Step 7: 回傳 dp[n] // 結果\nEnd // 程式執行結束\n\nBut we need to format exactly with arrow notation. The example uses indentation like:\n\n→ Decision: 如果數字大於 0? // ...\n    Yes → Step 2: ...\n\nWe need to maintain indentation and arrow usage. Also \"Yes →\" and \"No →\" after decision lines.\n\nBut the example uses \"Yes → Step 2:\" and \"No  → Decision:\" etc.\n\nWe need to be careful with spacing: \"Yes →\" or \"No  →\" with two spaces after No? In example, they used \"No  →\". That is \"No[space][space]→\". That may be important. But we can follow the same style: \"Yes →\", \"No  →\".\n\nWe need to indent the lines under decisions.\n\nWe need to use \"Decision:\" lines for decisions. Each decision may have Yes and No branches.\n\nLet's produce code:\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列，長度 n+1，並將每個元素設為無限大 // 初始化\n→ Step 2: 設定 dp[0] = 0 // 零的最少平方數為 0\n→ Step 3: 對 i 從 1 到 n 進行迴圈 // 外層循環\n    → Decision: i 是否為完美平方? // 檢查 i 是否本身即為平方數\n        Yes → Step 4: dp[i] = 1 // 如果是，直接設定為 1\n        No  → Step 5: 對 square 從 1 開始 // 內層循環\n            → Decision: square^2 > i? // 判斷是否超過 i\n                Yes → No → Break // 超過時跳出內層\n                No  → Step 6: 更新 dp[i] = min(dp[i], dp[i - square^2] + 1) // 更新最小值\n→ Step 7: 回傳 dp[n] // 輸出答案\nEnd // 程式執行結束\n\nBut we need to ensure arrow after each step. For \"No → No → Break\", we might need two arrow? In example, they had \"No  → Decision: ...\", then inside that decision they had \"Yes → Step 3:\" etc. For \"Break\" we might not need arrow after. But we can just do \"Yes → No → Break // 跳出內層\". But that might not be needed. Instead, we can use \"No → Step 6: 更新 dp[i] = ...\" This is enough.\n\nBut we need to show break; but break can be part of update step? Actually, break occurs when square^2 > i, but we can just not loop further, so we skip update. We could implement as decision: if square^2 > i then No branch: \"No  → Step 6: 更新 dp[i] = min(dp[i], dp[i - square^2] + 1)\".\n\nBetter to restructure: For each i, we can iterate square from 1 to sqrt(i). So we don't need break. So we can avoid decision about break. That simplifies.\n\nLet's restructure:\n\nStart\n→ Step 1: 初始化 dp[0]=0，dp[1..n] 設為無限大\n→ Step 2: 對 i 取值 1 到 n\n    → Step 3: 對 square 從 1 到 floor(sqrt(i))\n        → Step 4: 更新 dp[i] = min(dp[i], dp[i - square^2] + 1)\n→ Step 5: 回傳 dp[n]\n\nThis is simpler. No decision needed. But user requested to include Decision? It didn't require decision. Example uses decision but not mandatory. The instructions didn't say we must use decisions. So it's fine.\n\nBut we should provide explanation for each line.\n\nLet's produce lines accordingly.\n\nBut we must obey format: each line \"虛擬碼步驟 // 解釋\". So we need to include arrow before each step: \"→ Step X: ...\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列，長度 n+1，並將 dp[0] 設為 0，其他元素設為無限大 // 初始化 dp\n→ Step 2: 對 i 從 1 到 n 進行迴圈 // 外層迴圈\n    → Step 3: 對 square 從 1 到 floor(√i) 進行迴圈 // 內層迴圈\n        → Step 4: 計算 dp[i] = min(dp[i], dp[i - square^2] + 1) // 更新最小值\n→ Step 5: 回傳 dp[n] // 輸出答案\nEnd // 程式執行結束\n\nWe should check indentation: The example used indentation of 4 spaces for substeps. So we can use 4 spaces indent.\n\nWe need to use arrow \"→\" before each substep.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列，長度 n+1，並將 dp[0] 設為 0，其他元素設為無限大 // 初始化 dp，dp[0] 表示 0 的最少平方數\n→ Step 2: 對 i 從 1 到 n 進行迴圈 // 外層迴圈遍歷所有可能的目標值\n    → Step 3: 對 square 從 1 到 floor(√i) 進行迴圈 // 內層迴圈遍歷所有不超過 i 的平方數\n        → Step 4: 計算 dp[i] = min(dp[i], dp[i - square^2] + 1) // 更新 dp[i] 為使用該平方數時的最小平方數個數\n→ Step 5: 回傳 dp[n] // 輸出最少平方數的個數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef num_squares(n: int) -> int:\n    \"\"\"\n    Return the least number of perfect square numbers that sum to n.\n    Uses dynamic programming: dp[i] stores the minimum count for i.\n    \"\"\"\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n    return dp[n]\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read()\n    # Extract the first integer found (handles inputs like 'n = 12' or just '12')\n    match = re.search(r'-?\\d+', data)\n    if match:\n        n = int(match.group())\n        print(num_squares(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 13",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode330.json",
    "problem_index_in_file": 0,
    "title": "Patching Array",
    "description_snippet": "Given a sorted integer array nums and an integer n, add/patch elements to the array such that any nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code for the problem: \"Patching Array\" from Leetcode. We need to generate step-by-step virtual code lines with explanation after //. Must use Start, End, Decision etc. Use arrow symbol. Each line includes virtual code step, space, // explanation.\n\nWe must produce algorithm: maintain coverage range [1, miss] meaning we can form all sums up to miss-1; need to patch with smallest element <= miss to extend coverage.\n\nPseudo:\n\nStart\n→ Set miss = 1, patches = 0, i = 0\n→ While miss <= n:\n    Decision: If i < len(nums) and nums[i] <= miss? // can use next number\n        Yes → miss += nums[i] ; i += 1\n        No  → miss += miss ; patches += 1 // patch with miss\n→ End\n\nBut must produce more detail.\n\nAlso need to handle if array sorted. Provide explanation each line.\n\nLet's produce virtual code lines.\n\nWe should output each line with arrow and explanation.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Set miss = 1, patches = 0, i = 0 // 初始可覆蓋範圍為 [1, miss-1]，目前為空，指標 i 指向 nums[0]  \n→ While miss ≤ n: // 只要還未覆蓋完整 [1, n] 範圍，就持續迭代  \n  Decision: i < len(nums) 且 nums[i] ≤ miss? // 下一個數字是否可直接使用來擴大覆蓋範圍  \n   Yes → miss += nums[i]; i += 1 // 用 nums[i] 擴大覆蓋範圍，指標前進  \n   No  → miss += miss; patches += 1 // 需要「修補」：加入一個等於 miss 的數字，使覆蓋範圍翻倍  \n→ End // 程式執行結束，回傳 patches 即為最小修補數量",
      "generated_code": "import sys\nimport ast\n\ndef min_patches(nums, n):\n    \"\"\"\n    計算最小修補數量，使得所有 1~n 的數字都能由 nums 中元素的和組成。\n    \"\"\"\n    patches = 0       # 已經修補的個數\n    miss = 1          # 能覆蓋的最小缺口：目前可覆蓋 [1, miss-1]\n    i = 0             # nums 的索引\n\n    while miss <= n:\n        # 若 nums[i] 可用來擴大覆蓋範圍\n        if i < len(nums) and nums[i] <= miss:\n            miss += nums[i]\n            i += 1\n        else:\n            # 需要修補：加入一個等於 miss 的數字\n            miss += miss\n            patches += 1\n\n    return patches\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，回傳 (nums, n)。\n    支援形如 'nums = [1,3], n = 6' 的格式。\n    \"\"\"\n    # 移除首尾空白\n    data = data.strip()\n    # 分割成兩部分\n    if 'n =' in data:\n        part_nums, part_n = data.split('n =', 1)\n    else:\n        raise ValueError(\"輸入格式錯誤，缺少 'n ='\")\n\n    # 解析 nums\n    part_nums = part_nums.replace('nums =', '').strip()\n    nums = ast.literal_eval(part_nums)\n\n    # 解析 n\n    n = int(part_n.strip())\n\n    return nums, n\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit(0)\n\n    try:\n        nums, n = parse_input(raw_input)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    # 計算並輸出結果\n    result = min_patches(nums, n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3], n = 6",
          "expected_output": "1",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp72j8xdas.py\", line 59, in <module>\n    result = min_patches(nums, n)\n             ^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp72j8xdas.py\", line 14, in min_patches\n    if i < len(nums) and nums[i] <= miss:\n                         ^^^^^^^^^^^^^^^\nTypeError: '<=' not supported between instances of 'list' and 'int'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,10], n = 20",
          "expected_output": "2",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpw3cwwmk6.py\", line 59, in <module>\n    result = min_patches(nums, n)\n             ^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpw3cwwmk6.py\", line 14, in min_patches\n    if i < len(nums) and nums[i] <= miss:\n                         ^^^^^^^^^^^^^^^\nTypeError: '<=' not supported between instances of 'list' and 'int'"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,2], n = 5",
          "expected_output": "0",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpmoba5pbf.py\", line 59, in <module>\n    result = min_patches(nums, n)\n             ^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmoba5pbf.py\", line 14, in min_patches\n    if i < len(nums) and nums[i] <= miss:\n                         ^^^^^^^^^^^^^^^\nTypeError: '<=' not supported between instances of 'list' and 'int'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode210.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule II",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for topological sort using prerequisites. We'll produce steps: build graph, compute indegree, queue, etc. The user wants to return ordering or empty if cycle. We'll produce pseudo code with steps and explanations. Use arrows, Decision, etc. No real code. Provide line by line. Use virtual steps like \"Initialize adjacency list\" etc. Provide decision for cycle detection. We'll produce the algorithm.\n\nLet's design steps:\n\nStart\n→ Step 1: Initialize adjacency list for all courses\n→ Step 2: Initialize indegree array to zeros\n→ Step 3: For each pair [a, b] in prerequisites:\n    → Step 3a: Add a to adjacency list of b\n    → Step 3b: Increment indegree[a]\n→ Step 4: Initialize queue with courses having indegree 0\n→ Step 5: Initialize result list empty\n→ Step 6: While queue not empty:\n    → Step 6a: Dequeue course cur\n    → Step 6b: Append cur to result\n    → Step 6c: For each neighbor next in adjacency list of cur:\n        → Step 6c1: Decrement indegree[next]\n        → Step 6c2: If indegree[next] == 0, enqueue next\n→ Step 7: Decision: If length of result == numCourses? // all courses processed\n    Yes → Step 8: Return result // ordering found\n    No  → Step 9: Return empty array // cycle detected\nEnd\n\nAlso we can include a step for output. Use arrow syntax.\n\nLet's produce lines accordingly. Use appropriate indentation. We can embed nested steps with indentation after arrows? The example shows indentation with spaces. We'll replicate.\n\nUse \"Decision:\" lines with indentation and Yes/No arrow.\n\nMake sure to include explanation after //.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空的鄰接表 adj 為長度 numCourses 的空列表 // 建立圖的結構\n→ Step 2: 初始化 indegree 陣列為長度 numCourses 的全 0 // 用來記錄各課程的前置課程數\n→ Step 3: 對每個 [a, b] 在 prerequisites:\n    → Step 3a: adj[b].append(a) // 在 b 的鄰接表加入 a，表示 b 必須先修\n    → Step 3b: indegree[a] += 1   // a 的 indegree 加 1，代表一個前置課程\n→ Step 4: 初始化 queue 為所有 indegree 為 0 的課程 // 這些課程無前置課程，可以立即修\n→ Step 5: 初始化 result 為空列表 // 用來儲存課程的修讀順序\n→ Step 6: While queue 不為空:\n    → Step 6a: cur = queue.pop_front() // 取出一個可以修的課程\n    → Step 6b: result.append(cur)      // 加入順序列表\n    → Step 6c: 對每個 next 在 adj[cur]:\n        → Step 6c1: indegree[next] -= 1   // 因為 cur 已修，next 的前置數減 1\n        → Step 6c2: If indegree[next] == 0:\n            Yes → queue.append(next)      // next 現在沒有前置課程，可以加入 queue\n→ Step 7: Decision: 如果 len(result) == numCourses? // 所有課程都已排定\n    Yes → Step 8: Return result // 成功得到修讀順序\n    No  → Step 9: Return []     // 形成循環，無法完成所有課程\nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立鄰接表和 indegree 陣列\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 讀取所有邊\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 找出所有 indegree 為 0 的節點放入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # Kahn 的拓撲排序\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若所有課程都已排完，回傳順序；否則回傳空列表\n        return order if len(order) == numCourses else []\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，例如\n        'numCourses = 2, prerequisites = [[1,0]]'\n    回傳 (numCourses, prerequisites) 的 tuple。\n    \"\"\"\n    import re\n    # 取得 numCourses\n    m = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    numCourses = int(m.group(1)) if m else 0\n\n    # 取得 prerequisites\n    m = re.search(r'prerequisites\\s*=\\s*(\\[\\[.*?\\]\\]|\\[\\])', data, re.S)\n    if m:\n        # 直接使用 eval 轉成列表，內容安全性已經受限於正則\n        prerequisites = eval(m.group(1), {})\n    else:\n        prerequisites = []\n\n    return numCourses, prerequisites\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        # 若無輸入，直接輸出空清單\n        print([])\n        sys.exit(0)\n\n    # 解析輸入\n    numCourses, prerequisites = parse_input(raw_input)\n\n    # 計算課程順序\n    sol = Solution()\n    order = sol.findOrder(numCourses, prerequisites)\n\n    # 將結果輸出為 Python 列表字串\n    print(order)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "success": true,
          "output": "[0, 1, 2, 3]"
        },
        {
          "example_index": 2,
          "input": "numCourses = 1, prerequisites = []",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode516.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Subsequence",
    "description_snippet": "Given a string s, find the longest palindromic subsequence's length in s.\n\nA subsequence is a sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for finding length of longest palindromic subsequence. Use DP typical: dp[i][j] length for substring s[i..j]. Recurrence: if s[i]==s[j], dp[i][j]=dp[i+1][j-1]+2; else dp[i][j]=max(dp[i+1][j], dp[i][j-1]). Also base dp[i][i]=1.\n\nWe output line by line with arrow notation.\n\nWe need to start with Start, then steps.\n\nWe can structure as:\n\nStart\n→ Step 1: Set n = length(s) // length of input string\n→ Step 2: Initialize dp matrix n x n with zeros // DP table\n→ Step 3: For i from 0 to n-1: dp[i][i] = 1 // single chars are palindrome length 1\n→ Step 4: For cl from 2 to n: // substring length\n    → Step 5: For i from 0 to n-cl:\n        → Step 6: Set j = i + cl - 1\n        → Decision: 如果 s[i] == s[j]?\n            Yes → Step 7: If cl == 2 then dp[i][j] = 2 else dp[i][j] = dp[i+1][j-1] + 2\n            No → Step 8: dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n→ Step 9: Output dp[0][n-1] // length of longest palindrome subsequence\nEnd\n\nWe need to include arrow \"→\" between steps, but also indent Decision with Yes → and No →.\n\nAlso we need to include comment // after each line.\n\nLet's produce.\n\nMake sure to keep each line separate.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 n = s 的長度 // 取得字串長度\n→ Step 2: 初始化 dp[n][n] 為 0 // 建立動態規劃表\n→ Step 3: 從 i = 0 到 n-1 依次設定 dp[i][i] = 1 // 單個字元本身即為長度 1 的回文子序列\n→ Step 4: 對 cl 由 2 到 n 執行 (cl 為子串長度)\n    → Step 5: 對 i 由 0 到 n - cl 執行 (i 為子串起始位置)\n        → Step 6: 設定 j = i + cl - 1 // 子串結束位置\n        → Decision: 如果 s[i] == s[j]?\n            Yes → Step 7: 如果 cl == 2 則 dp[i][j] = 2 否則 dp[i][j] = dp[i+1][j-1] + 2 // 前後相同時可延伸回文長度\n            No  → Step 8: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取較長的子序列\n→ Step 9: 輸出 dp[0][n-1] // 最長回文子序列長度\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef longest_palindrome_subseq_length(s: str) -> int:\n    \"\"\"\n    以動態規劃的方式計算給定字串 s 的最長回文子序列長度。\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # dp[i][j] 代表 s[i:j+1] 的最長回文子序列長度\n    dp = [[0] * n for _ in range(n)]\n\n    # 單字元子序列長度為 1\n    for i in range(n):\n        dp[i][i] = 1\n\n    # 由長度 2 開始遞增，使用從後向前的 i 迴圈，確保 dp[i+1][j-1] 已計算\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                if i + 1 > j - 1:\n                    # 只剩兩個相同字元\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取字串，去除首尾空白及可能存在的雙引號\n    raw_input = sys.stdin.read().strip()\n    s = raw_input.strip('\"').strip()\n    result = longest_palindrome_subseq_length(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"bbbab\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "\"cbbd\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode4.json",
    "problem_index_in_file": 0,
    "title": "Median of Two Sorted Arrays",
    "description_snippet": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each with arrow etc. Need to implement median of two sorted arrays with O(log(m+n)). Standard solution: binary search on smaller array. Steps: define low/high pointers in nums1, target partition, check conditions. Return median accordingly.\n\nWe'll produce pseudocode step by step. Use Start, End, Decision etc. Provide each line with explanation. Ensure each line starts with \"→\" or \"Start\". The virtual code should be line-by-line.\n\nWe'll outline algorithm: assume nums1 is smaller array. low=0, high=len1. While low <= high: partitionX = (low+high)//2; partitionY = (len1+len2+1)//2 - partitionX. Then find maxLeftX etc. Check if maxLeftX <= minRightY and maxLeftY <= minRightX. If true compute median. Else if maxLeftX > minRightY: high=partitionX-1 else low=partitionX+1.\n\nWe'll output in virtual code. Use Decision blocks with Yes/No.\n\nLet's produce each line. For readability, maybe group some lines but each line separate. Let's keep concise.\n\nWill use \"Decision:\" lines for condition checks. Use arrows accordingly.\n\nWe'll include \"Start\" and \"End\". Use \"→\" arrow for steps. For decisions, \"Decision: ...\" and nested \"Yes →\", \"No →\" etc. For loops, maybe a \"Loop\" but not required; can just use \"Decision\" to represent while condition. We'll represent while loop as \"Decision: low <= high?\" and inside loop steps, then back to loop.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 若 nums1 長度 > nums2 長度? // 讓 nums1 為較短陣列  \n  Yes → Swap(nums1, nums2) // 若不是則交換兩陣列  \n→ Step 1: 定義 low = 0, high = len(nums1) // 初始化搜尋範圍  \n→ Decision: low <= high? // 開始二分搜尋迴圈  \n  Yes → Step 2: partitionX = (low + high) // 2 // 在 nums1 上切分位置  \n    partitionY = (len(nums1) + len(nums2) + 1) // 2 - partitionX // 在 nums2 上切分位置  \n    Step 3: maxLeftX = 若 partitionX == 0? -∞ : nums1[partitionX-1] // 左邊最大值  \n    minRightX = 若 partitionX == len(nums1)? +∞ : nums1[partitionX] // 右邊最小值  \n    Step 4: maxLeftY = 若 partitionY == 0? -∞ : nums2[partitionY-1] // 左邊最大值  \n    minRightY = 若 partitionY == len(nums2)? +∞ : nums2[partitionY] // 右邊最小值  \n    Decision: maxLeftX <= minRightY AND maxLeftY <= minRightX? // 判斷切分是否正確  \n      Yes → Decision: (len(nums1)+len(nums2)) % 2 == 0? // 判斷總長度奇偶  \n        Yes → Step 5: median = (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2 // 偶數長度取平均  \n        No → Step 5: median = max(maxLeftX, maxLeftY) // 奇數長度取左邊最大值  \n        → End // 輸出 median 後結束  \n      No → Decision: maxLeftX > minRightY? // 左邊過大則移動 high  \n        Yes → Step 6: high = partitionX - 1 // 將搜尋範圍縮小至左半邊  \n        No → Step 7: low = partitionX + 1 // 否則移動 low 到右半邊  \n        → Back to Decision: low <= high? // 迴圈重複  \n  No → End // 處理完畢，程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        # 確保 nums1 是較短的陣列\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        m, n = len(nums1), len(nums2)\n\n        # 如果 nums1 為空，直接返回 nums2 的中位數\n        if m == 0:\n            if n % 2 == 1:\n                return float(nums2[n // 2])\n            return (nums2[n // 2 - 1] + nums2[n // 2]) / 2.0\n\n        low, high = 0, m\n        while low <= high:\n            i = (low + high) // 2\n            j = (m + n + 1) // 2 - i\n\n            Aleft = float('-inf') if i == 0 else nums1[i - 1]\n            Aright = float('inf') if i == m else nums1[i]\n            Bleft = float('-inf') if j == 0 else nums2[j - 1]\n            Bright = float('inf') if j == n else nums2[j]\n\n            if Aleft <= Bright and Bleft <= Aright:\n                if (m + n) % 2 == 1:\n                    return float(max(Aleft, Bleft))\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2.0\n            elif Aleft > Bright:\n                high = i - 1\n            else:\n                low = i + 1\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中提取兩個 list。\n    支援格式例如：\n        nums1 = [1,3], nums2 = [2]\n        或者\n        nums1 = [1,2]\n        nums2 = [3,4]\n    \"\"\"\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[[^\\]]*\\])', data)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[[^\\]]*\\])', data)\n\n    nums1 = eval(nums1_match.group(1)) if nums1_match else []\n    nums2 = eval(nums2_match.group(1)) if nums2_match else []\n\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums1, nums2 = parse_input(raw_input)\n\n    solution = Solution()\n    median = solution.findMedianSortedArrays(nums1, nums2)\n\n    # 按題目要求輸出 5 位小數\n    print(f\"{median:.5f}\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,3], nums2 = [2]",
          "expected_output": "2.00000",
          "success": true,
          "output": "2.00000"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,2], nums2 = [3,4]",
          "expected_output": "2.50000",
          "success": true,
          "output": "2.50000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode201.json",
    "problem_index_in_file": 0,
    "title": "Bitwise AND of Numbers Range",
    "description_snippet": "Given two integers left and right that represent the range [left, right], return the bitwise AND of ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code that computes bitwise AND of all numbers in range [left, right]. We need to produce step-by-step logic. The known solution: shift right until left==right, count shifts, then shift back. So pseudocode: start, shift_count=0; while left<right: left >>=1; right >>=1; shift_count++; after loop: result = left << shift_count; output result. Also edge cases: left or right zero? It's fine. Provide steps with decisions. Use Start, End, Decision. Provide explanatory comments. Let's produce each line as described. Ensure each line: \"虛擬碼步驟 // 解釋\" with one space between code and comment. Use arrow notation. We need to reflect algorithm. Also can mention while loop as decision. But arrow style: we can use \"→\" to show flow. We can indent decisions. Let's produce.\n\nExamples:\n\nStart // 程式開始執行\n→ Step 1: input left, right // 取得輸入範圍\n→ Step 2: shiftCount = 0 // 初始化左移計數\n→ Decision: left < right? // 判斷是否仍需進行左移\n    Yes → Step 3: left >>= 1 // 將 left 右移一位\n    Yes → Step 4: right >>= 1 // 將 right 右移一位\n    Yes → Step 5: shiftCount++ // 計數加一\n    Yes → Decision: left < right? // 重新判斷\n    No  → Step 6: result = left << shiftCount // 重新左移得到 AND 結果\n→ Step 7: output result // 顯示結果\nEnd // 程式結束\n\nNeed to ensure that arrows flow: after Decision Yes, we chain steps. But we must reflect the loop: maybe use a while loop style. Could use \"While left < right\" but using decision and Yes branch looping back. Let's craft properly.\n\nWe can represent loop as:\n\n→ Decision: left < right? // 若 left < right，進行左移\n    Yes → Step 3: left >>= 1\n    Yes → Step 4: right >>= 1\n    Yes → Step 5: shiftCount++\n    Yes → Decision: left < right? // 回到條件判斷\n    No  → Step 6: result = left << shiftCount\n\nBut this representation may confuse. Another way: use a loop pseudo: \"→ While left < right:\" but they ask to use Decision and Yes/No. So we can simulate:\n\n→ Decision: left < right? // 判斷是否需要左移\n    Yes → Step 3: left >>= 1\n    Yes → Step 4: right >>= 1\n    Yes → Step 5: shiftCount++\n    Yes → Decision: left < right? // 再次判斷\n    No  → Step 6: result = left << shiftCount\n\nYes, that flows.\n\nWe also need Step 7: output result. End.\n\nLet's produce final output. Use Chinese comments. Use each line. Use \"→\" arrow. For decisions, indent. Provide \"Yes →\" and \"No →\".\n\nMake sure to include comments after space. Each line code plus comment.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: input left, right // 取得輸入範圍 [left, right]\n→ Step 2: shiftCount = 0 // 初始化左移計數\n→ Decision: left < right? // 判斷是否仍需進行左移\n    Yes → Step 3: left >>= 1 // 將 left 右移一位（相當於除以 2）\n    Yes → Step 4: right >>= 1 // 將 right 右移一位（相當於除以 2）\n    Yes → Step 5: shiftCount++ // 計數加一，記錄已進行的左移次數\n    Yes → Decision: left < right? // 重新判斷左移是否還需要繼續\n    No  → Step 6: result = left << shiftCount // 右移回原位，得到所有數的 AND 結果\n→ Step 7: output result // 顯示計算出的 AND 值\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        shift = 0\n        while left < right:\n            left >>= 1\n            right >>= 1\n            shift += 1\n        return left << shift\n\ndef main() -> None:\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if len(nums) < 2:\n        return\n    left, right = map(int, nums[:2])\n    solution = Solution()\n    result = solution.rangeBitwiseAnd(left, right)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 5, right = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "left = 0, right = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "left = 1, right = 2147483647",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode313.json",
    "problem_index_in_file": 0,
    "title": "Super Ugly Number",
    "description_snippet": "A super ugly number is a positive integer whose prime factors are in the array primes.\n\nGiven an int...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step-by-step with explanations. For super ugly numbers: typical algorithm: maintain array ugly[1..n], indices idx[primes], next_mul[primes]. For each i from 2 to n: next_ugly = min over primes[j]*ugly[idx[j]]; ugly[i] = next_ugly; for each j where primes[j]*ugly[idx[j]] == next_ugly, idx[j]++. Return ugly[n]. Provide pseudocode with arrows, decisions, etc. Provide step-by-step lines.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化數組 ugly[1…n]，並設置 ugly[1] = 1 // 第一個超醜數為 1\n→ Step 2: 初始化索引陣列 idx[0…k-1] 為 0（k 為 primes 長度） // 每個質數的指標初始指向 ugly[1]\n→ Step 3: 初始化 next_mul[0…k-1] 為 primes[0…k-1] // 每個質數乘以對應 ugly 指標得到的候選值\n→ Step 4: 從 i = 2 開始到 n（含）進行迴圈 // 逐步計算第 i 個超醜數\n    → Decision: 是否已計算到第 n 個數？ // 控制迴圈結束\n        No → Step 5: 計算 next_ugly = min(next_mul[0…k-1]) // 取所有候選中的最小值\n        → Step 6: 設置 ugly[i] = next_ugly // 將最小值存入第 i 個超醜數\n        → Decision: 哪些質數對應的候選值等於 next_ugly？ // 可能有多個相同最小值\n            For each j in 0…k-1\n                → Decision: next_mul[j] == next_ugly ?\n                    Yes → Step 7: idx[j] = idx[j] + 1 // 對應指標前進\n                    → Step 8: next_mul[j] = primes[j] * ugly[idx[j]] // 更新該質數的新候選值\n        → Step 9: i = i + 1 // 進入下一個位置\n        → Loop back to Step 4\n        Yes → End // 已計算完所有 n 個超醜數\n→ Step 10: 回傳 ugly[n] // 回傳第 n 個超醜數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nthSuperUglyNumber(self, n, primes):\n        # 初始化超醜數列，第一個為 1\n        ugly = [1]\n        # 每個質數對應的指標，初始指向第 1 個超醜數\n        indices = [0] * len(primes)\n        # 每個質數乘以其指標所指的超醜數得到的候選值\n        vals = list(primes)\n\n        # 只要還沒算到第 n 個\n        for _ in range(1, n):\n            # 取最小的候選值作為下一個超醜數\n            next_ugly = min(vals)\n            ugly.append(next_ugly)\n\n            # 更新所有等於最小值的質數對應指標\n            for i in range(len(primes)):\n                if vals[i] == next_ugly:\n                    indices[i] += 1\n                    vals[i] = ugly[indices[i]] * primes[i]\n\n        return ugly[-1]\n\n\ndef main():\n    data = sys.stdin.read()\n    # 把所有整數找出來，第一個是 n，剩下的都是 primes\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        return\n    n = nums[0]\n    primes = nums[1:]\n\n    sol = Solution()\n    result = sol.nthSuperUglyNumber(n, primes)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12, primes = [2,7,13,19]",
          "expected_output": "32",
          "success": true,
          "output": "32"
        },
        {
          "example_index": 1,
          "input": "n = 1, primes = [2,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode448.json",
    "problem_index_in_file": 0,
    "title": "Find All Numbers Disappeared in an Array",
    "description_snippet": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm to find missing numbers. Likely solution: mark presence using negative index trick. Steps: Start, Step1: iterate nums to mark presence, Step2: iterate from 1 to n to collect missing indices where index positive. End.\n\nWe need to output each line with \"→\" arrow etc. Let's structure:\n\nStart\n→ Step 1: 建立空列表 missing // 用於儲存缺失的數字\n→ Step 2: 對 nums 中每個數值 val 進行\n    → Decision: 是否已經被標記為負? Actually we just set nums[val-1] = -abs(nums[val-1]) // 標記已出現\n→ Step 3: 從 i=1 到 n\n    → Decision: nums[i-1] 是否為正? // 若正表示該數字未出現\n        Yes → Append i 到 missing\n→ End\n\nBut need to use arrow for loops? The example only uses arrow for steps and decisions; loops can be inside step but we may use decision to check.\n\nWe might include loops as steps. Provide explanation. Let's produce.\n\nMake sure each line has \"→\" at start. For nested decision lines we indent? In example they indent with spaces. We'll replicate same style: indent two spaces before Yes / No lines.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: missing = [] // 建立空列表存儲缺失數字\n→ Step 2: for each val in nums: // 遍歷輸入陣列\n    → Decision: 是否已標記為負? // 檢查位置是否已被標記\n        Yes → Skip // 已標記，跳過\n        No  → Step 3: nums[val-1] = -abs(nums[val-1]) // 標記此數字已出現\n→ Step 4: for i from 1 to n:\n    → Decision: nums[i-1] 是否為正? // 未出現\n        Yes → Step 5: missing.append(i) // 將缺失數字加入結果\n        No  → Skip // 已出現，跳過\nEnd // 程式執行結束\n\nBut we need to avoid actual code. Provide pseudocode. Use \"for\" loops.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: missing = [] // 建立空列表存儲缺失的數字\n→ Step 2: for val in nums: // 遍歷每個數值\n    → Decision: 已經標記為負? // 檢查該位置是否已被標記\n        Yes → Skip // 已標記，無需再處理\n        No  → Step 3: nums[val-1] = -abs(nums[val-1]) // 將對應位置設為負數，標記此數已出現\n→ Step 4: for i from 1 to n: // 再次遍歷 1~n 的索引\n    → Decision: nums[i-1] 是否為正? // 若為正代表數字 i 未出現\n        Yes → Step 5: missing.append(i) // 將缺失的數字加入結果\n        No  → Skip // 已出現，跳過\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findDisappearedNumbers(self, nums):\n        n = len(nums)\n        for num in nums:\n            index = abs(num) - 1\n            nums[index] = -abs(nums[index])\n        return [i + 1 for i in range(n) if nums[i] > 0]\n\ndef main():\n    data = sys.stdin.read()\n    # 提取所有整數，適應 \"nums = [4,3,2,7,8,2,3,1]\" 等格式\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    sol = Solution()\n    result = sol.findDisappearedNumbers(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[5,6]",
          "success": true,
          "output": "[5, 6]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode273.json",
    "problem_index_in_file": 0,
    "title": "Integer to English Words",
    "description_snippet": "Convert a non-negative integer num to its English words representation....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for converting a non-negative integer to English words. We must produce step-by-step pseudo-code lines with explanation after each. Use arrows and structure. Should not output actual code, just virtual steps.\n\nLet's design steps: Start, define arrays for ones, teens, tens, thousands groups, etc. Process input number, if zero return \"Zero\". Else loop over groups of three digits (hundreds, tens, units). For each group, process hundreds, tens, units, add thousand prefix accordingly. Build result string.\n\nWe need to output step-by-step virtual code, each line with \"→\" maybe nested decisions. Use indentation or arrows. Use decision blocks.\n\nWe should provide a linear sequence but can include nested decisions with indentation. Provide explanation.\n\nWe must keep format: Each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use Chinese.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 定義詞彙表: ones, teens, tens, thousands // 初始化單位、十位、百位及千位詞彙\n→ Step 2: 檢查輸入 num 是否為 0? // 特殊情況處理\n    Yes → Step 3: 輸出 \"Zero\" // 若為 0，直接回傳\n    No  → Step 4: 初始化 result 為空字串 // 為後續拼接做準備\n→ Step 5: 計算 num 的千位分組數量 // 以 3 位為一組分割\n→ Step 6: 從低位到高位循環遍歷每個分組 // 逐個處理\n    → Decision: 分組值是否為 0? // 若分組為 0，直接跳過\n        Yes → Continue // 跳過此分組\n        No  → Step 7: 處理百位數\n            → Decision: 百位數 > 0? // 判斷是否有百位\n                Yes → Step 8: 在 result 前加入 \"[百位詞] Hundred\" // 加入百位詞\n                No  → Skip\n        → Step 9: 處理十位及個位\n            → Decision: 十位數 = 1? // 處理十到十九\n                Yes → Step 10: 在 result 前加入 \"[十位個位詞]\" // 直接取 teens\n                No  → Decision: 十位數 > 1? // 常規十位\n                    Yes → Step 11: 在 result 前加入 \"[十位詞]\" // 加入十位詞\n                    No  → Skip\n            → Decision: 個位數 > 0? // 加入個位詞\n                Yes → Step 12: 在 result 前加入 \"[個位詞]\" // 加入個位詞\n                No  → Skip\n        → Step 13: 加入千位前綴\n            → Decision: 當前分組索引 > 0? // 若不是最低位\n                Yes → Step 14: 在 result 前加入 \"[千位詞]\" // 加入千位詞\n                No  → Skip\n→ Step 15: 移除結果字串兩端多餘空白 // 清理空格\n→ Step 16: 輸出結果字串 // 完成輸出\nEnd // 程式結束\n\nBut we need to adhere to format: each line \"虛擬碼步驟 // 解釋\". Indentation may be indicated by spaces? The sample shows indent lines with arrows but not indentation. Use arrow \"→\" for steps, \"Decision:\" for decisions. Use nested decisions within block.\n\nLet's produce final answer accordingly. Ensure each line ends with // explanation. Use Chinese.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義詞彙表 ones, teens, tens, thousands // 初始化單位、十位、百位及千位詞彙  \n→ Step 2: 檢查輸入 num 是否為 0? // 特殊情況處理  \n  Yes → Step 3: 輸出 \"Zero\" // 若為 0，直接回傳  \n  No  → Step 4: 初始化 result 為空字串 // 為後續拼接做準備  \n→ Step 5: 計算 num 的千位分組數量 // 以 3 位為一組分割  \n→ Step 6: 從低位到高位循環遍歷每個分組 // 逐個處理  \n  → Decision: 分組值是否為 0? // 若分組為 0，直接跳過  \n    Yes → Continue // 跳過此分組  \n    No  → Step 7: 處理百位數 // 取得百位數值  \n        → Decision: 百位數 > 0? // 判斷是否有百位  \n            Yes → Step 8: 在 result 前加入 \"[百位詞] Hundred\" // 加入百位詞  \n            No  → Skip  \n  → Step 9: 處理十位及個位 // 處理十到十九與十位、個位  \n    → Decision: 十位數 = 1? // 需要直接使用 teens  \n        Yes → Step 10: 在 result 前加入 \"[十位個位詞]\" // 取 teens 的詞彙  \n        No  → Decision: 十位數 > 1? // 常規十位數  \n            Yes → Step 11: 在 result 前加入 \"[十位詞]\" // 加入十位詞  \n            No  → Skip  \n    → Decision: 個位數 > 0? // 加入個位詞  \n        Yes → Step 12: 在 result 前加入 \"[個位詞]\" // 加入個位詞  \n        No  → Skip  \n  → Step 13: 加入千位前綴 // 為分組添加對應千位詞  \n    → Decision: 當前分組索引 > 0? // 低位分組不加前綴  \n        Yes → Step 14: 在 result 前加入 \"[千位詞]\" // 加入千位詞  \n        No  → Skip  \n→ Step 15: 移除結果字串兩端多餘空白 // 清理空格  \n→ Step 16: 輸出結果字串 // 完成輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        def one(n: int) -> str:\n            switcher = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\",\n                        \"Seven\", \"Eight\", \"Nine\"]\n            return switcher[n]\n\n        def two_less_20(n: int) -> str:\n            switcher = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\",\n                        \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n            return switcher[n - 10]\n\n        def ten(n: int) -> str:\n            switcher = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\",\n                        \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n            return switcher[n]\n\n        def two(n: int) -> str:\n            if n == 0:\n                return \"\"\n            if n < 10:\n                return one(n)\n            if n < 20:\n                return two_less_20(n)\n            tens = n // 10\n            rest = n % 10\n            return ten(tens) + (\" \" + one(rest) if rest else \"\")\n\n        def three(n: int) -> str:\n            hundred = n // 100\n            rest = n % 100\n            if hundred and rest:\n                return one(hundred) + \" Hundred \" + two(rest)\n            if hundred:\n                return one(hundred) + \" Hundred\"\n            return two(rest)\n\n        billion = num // 1_000_000_000\n        million = (num % 1_000_000_000) // 1_000_000\n        thousand = (num % 1_000_000) // 1_000\n        rest = num % 1_000\n\n        parts = []\n        if billion:\n            parts.append(three(billion) + \" Billion\")\n        if million:\n            parts.append(three(million) + \" Million\")\n        if thousand:\n            parts.append(three(thousand) + \" Thousand\")\n        if rest:\n            parts.append(three(rest))\n\n        return \" \".join(parts)\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 尋找第一個出現的整數\n    match = re.search(r'\\d+', data)\n    if not match:\n        sys.exit()\n    num = int(match.group())\n    result = Solution().numberToWords(num)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 123",
          "expected_output": "\"One Hundred Twenty Three\"",
          "success": true,
          "output": "One Hundred Twenty Three"
        },
        {
          "example_index": 1,
          "input": "num = 12345",
          "expected_output": "\"Twelve Thousand Three Hundred Forty Five\"",
          "success": true,
          "output": "Twelve Thousand Three Hundred Forty Five"
        },
        {
          "example_index": 2,
          "input": "num = 1234567",
          "expected_output": "\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"",
          "success": true,
          "output": "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode632.json",
    "problem_index_in_file": 0,
    "title": "Smallest Range Covering Elements from K Lists",
    "description_snippet": "You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with line-by-line explanation. The algorithm: find smallest range covering at least one number from each k lists. Classic problem: \"Smallest Range Covering Elements from K Lists\". Approach: use min-heap to keep current smallest element among k current pointers. Keep track of current maximum among the chosen elements. Iterate: pop min, update best range, move pointer in that list to next element, update current max. Stop when any list exhausted.\n\nWe need to produce steps with Start, End, Decision. We'll describe steps: Initialize heap with first element of each list and store index list, index in list. Initialize current_max = max of first elements. best_range_start, best_range_end = something. While heap not empty: pop min, compute range. If range smaller than best_range, update. Then advance pointer in that list. If next exists, push into heap, update current_max. Else break loop. After loop, output best range.\n\nNeed to use virtual code format. Each line includes explanation after //. Use arrow →. Decision lines with Yes→, No→. So we will write lines sequentially.\n\nMake sure we include Step 1, Step 2 etc. Use arrow. Provide explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化堆為空 // 用來存放目前每個列表的指標元素  \n→ Step 2: 初始化 current_max = -∞ // 追蹤目前已取元素中的最大值  \n→ Step 3: 初始化 best_range_start = 0, best_range_end = ∞ // 儲存目前最小範圍  \n→ Decision: 是否有 k 個列表？ // 檢查輸入是否符合要求  \n  Yes → Step 4: 對每個列表 i:  \n   → Step 4a: 把列表 i 的第一個元素 (value, i, index=0) 推入堆  \n   → Step 4b: 更新 current_max = max(current_max, value)  \n  No  → End // 若列表不足 k，直接結束  \n\n→ Step 5: While 堆非空  \n  → Step 5a: 從堆中彈出最小元素 (min_val, list_idx, elem_idx)  \n  → Step 5b: 計算當前範圍 = [min_val, current_max]  \n  → Decision: 當前範圍是否比 best_range 縮小？  \n   Yes → Step 5c: 更新 best_range_start = min_val, best_range_end = current_max  \n   No  → (不做任何事)  \n  → Step 5d: 判斷 list_idx 的下一個元素是否存在  \n   → Decision: 下一個元素存在?  \n    Yes → Step 5e: 推入堆 (next_val, list_idx, elem_idx+1)  \n     → Step 5f: 更新 current_max = max(current_max, next_val)  \n    No  → No → Step 5g: 跳出 While 迴圈，因為此列表已耗盡  \n→ Step 6: 輸出 best_range_start, best_range_end // 小範圍已確定  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nimport ast\n\ndef smallest_range(nums):\n    \"\"\"Return the smallest range [a, b] that contains at least one number from each list.\"\"\"\n    # 初始化堆，存放每個列表的第一個元素\n    heap = []\n    current_max = float('-inf')\n    for i, lst in enumerate(nums):\n        heapq.heappush(heap, (lst[0], i, 0))          # (值, 列表索引, 元素索引)\n        current_max = max(current_max, lst[0])\n\n    best_start, best_end = -1, -1\n    best_len = float('inf')\n\n    while heap:\n        min_val, list_idx, elem_idx = heapq.heappop(heap)\n\n        # 更新目前最小範圍\n        if current_max - min_val < best_len or \\\n           (current_max - min_val == best_len and min_val < best_start):\n            best_len = current_max - min_val\n            best_start, best_end = min_val, current_max\n\n        # 移動到對應列表的下一個元素\n        if elem_idx + 1 < len(nums[list_idx]):\n            next_val = nums[list_idx][elem_idx + 1]\n            heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))\n            current_max = max(current_max, next_val)\n        else:\n            # 任何一個列表已無更多元素，結束\n            break\n\n    return [best_start, best_end]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 若輸入包含「nums =」前綴，移除之\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n    try:\n        nums = ast.literal_eval(data)\n    except Exception as e:\n        raise ValueError(f\"無法解析輸入: {data}\") from e\n    result = smallest_range(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]",
          "expected_output": "[20,24]",
          "success": true,
          "output": "[20, 24]"
        },
        {
          "example_index": 1,
          "input": "nums = [[1,2,3],[1,2,3],[1,2,3]]",
          "expected_output": "[1,1]",
          "success": true,
          "output": "[1, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode567.json",
    "problem_index_in_file": 0,
    "title": "Permutation in String",
    "description_snippet": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Steps: sliding window, counts of letters. We'll write pseudocode with Start, Decision, etc.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化兩個長度為 26 的整數陣列 freqS1, freqS2 // 記錄 s1 與滑窗 s2 的字母頻率\n→ Step 2: 遍歷 s1 並更新 freqS1 // 填充 s1 的頻率表\n→ Step 3: 設定 windowSize = len(s1) // 目標滑窗長度\n→ Decision: 如果 windowSize > len(s2)? // 判斷 s2 是否足夠長\n    Yes → Step 4: 返回 false // s2 不能包含 s1 的任意排列\n    No  →\n→ Step 5: 遍歷 s2 的前 windowSize 個字元並更新 freqS2 // 初始滑窗\n→ Step 6: 如果 freqS1 == freqS2? // 第一個滑窗是否匹配\n    Yes → Step 7: 返回 true // 找到匹配\n    No  →\n→ Step 8: 從 i = windowSize 到 len(s2)-1 迴圈\n    → Decision: 循環結束? // 判斷是否已遍歷完所有滑窗\n        Yes → Step 9: 返回 false // 未找到匹配\n        No  →\n    → Step 10: 移除 s2[i-windowSize] 對應字母的頻率\n    → Step 11: 添加 s2[i] 對應字母的頻率\n    → Step 12: 如果 freqS1 == freqS2?\n        Yes → Step 13: 返回 true\n        No  → // 继续循环\n→ End\n\nAdd explanations after each line. Use the specified arrow syntax.\n\nLet's produce lines with explanation. Ensure each line includes the code and comment. Use \"Start\" \"End\". Use arrow. Use Decision with Yes→, No→ lines.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立兩個長度為 26 的整數陣列 freqS1, freqS2 // 以 0 初始化，用於統計 s1 與滑窗 s2 的字母頻率  \n→ Step 2: 針對 s1 的每個字元 c，freqS1[ord(c)-ord('a')]++ // 填充 s1 的頻率表  \n→ Step 3: 設定 windowSize = len(s1) // 目標滑窗長度  \n→ Decision: 如果 windowSize > len(s2)? // s2 是否足夠長以容納 s1 的任意排列  \n  Yes → Step 4: 返回 false // s2 不能包含 s1 的任何排列  \n  No  →  \n→ Step 5: 針對 s2 的前 windowSize 個字元 c，freqS2[ord(c)-ord('a')]++ // 初始滑窗的頻率表  \n→ Step 6: 如果 freqS1 == freqS2? // 第一次滑窗是否已經匹配  \n  Yes → Step 7: 返回 true // 找到匹配，結束程式  \n  No  →  \n→ Step 8: 從 i = windowSize 到 len(s2)-1 進行迴圈 // 逐步滑動窗口  \n  → Decision: 迴圈結束? // 是否已經遍歷完所有滑窗  \n    Yes → Step 9: 返回 false // 沒有任何滑窗匹配，結束程式  \n    No  →  \n    → Step 10: 移除 s2[i-windowSize] 對應字母的頻率 freqS2[ord(s2[i-windowSize])-ord('a')]-- // 從滑窗中移除最舊字元  \n    → Step 11: 添加 s2[i] 對應字母的頻率 freqS2[ord(s2[i])-ord('a')]++ // 加入新進入滑窗的字元  \n    → Step 12: 如果 freqS1 == freqS2? // 新滑窗是否匹配  \n      Yes → Step 13: 返回 true // 找到匹配，結束程式  \n      No  → // 继续迴圈  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef check_inclusion(s1: str, s2: str) -> bool:\n    \"\"\"\n    判斷 s2 是否包含 s1 的任意排列。\n    使用長度為 26 的字母頻率表做滑動窗口比對。\n    \"\"\"\n    n, m = len(s1), len(s2)\n    if n > m:          # s1 太長，無法在 s2 內找到排列\n        return False\n\n    # 計算 s1 的字母頻率\n    freq1 = [0] * 26\n    for ch in s1:\n        freq1[ord(ch) - 97] += 1\n\n    # 初始化 s2 前 n 個字元的窗口頻率\n    freq2 = [0] * 26\n    for ch in s2[:n]:\n        freq2[ord(ch) - 97] += 1\n\n    # 第一個窗口已經相等，直接返回\n    if freq1 == freq2:\n        return True\n\n    # 滑動窗口，逐步加入新字元並移除舊字元\n    for i in range(n, m):\n        freq2[ord(s2[i]) - 97] += 1          # 新字元進入窗口\n        freq2[ord(s2[i - n]) - 97] -= 1      # 最舊字元離開窗口\n        if freq1 == freq2:\n            return True\n\n    return False\n\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，解析出 s1 與 s2，並輸出結果。\n    期望輸入格式類似：s1 = \"ab\", s2 = \"eidbaooo\"\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 先嘗試用正則表達式抓取 s1、s2\n    pattern = r's1\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]\\s*,\\s*s2\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]'\n    match = re.search(pattern, data)\n    if match:\n        s1, s2 = match.group(1), match.group(2)\n    else:\n        # 若格式不同，簡單處理一下\n        parts = data.replace('\\n', '').split(',')\n        s1 = s2 = ''\n        for part in parts:\n            if '=' in part:\n                key, val = part.split('=', 1)\n                key = key.strip()\n                val = val.strip().strip('\"').strip(\"'\")\n                if key == 's1':\n                    s1 = val\n                elif key == 's2':\n                    s2 = val\n        if not s1 or not s2:\n            # 無法解析出 s1、s2，直接返回\n            return\n\n    result = check_inclusion(s1, s2)\n    print(str(result).lower())\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode89.json",
    "problem_index_in_file": 0,
    "title": "Gray Code",
    "description_snippet": "An n-bit gray code sequence is a sequence of 2^n integers where:\n\nEvery integer is in the inclusive ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines following the format. Provide steps for generating Gray code sequence. We must include Start, Steps, Decision. The code should generate a sequence. Approach: use recursive method or iterative using bitwise reflection. We'll produce steps: start, input n, compute length 2^n, initialize result list, for i from 0 to length-1: add i ^ (i>>1). That's classic formula. Or we can use recursion. Use for loop. Provide explanation.\n\nWe must output each line: \"虛擬碼步驟 // 解釋\". Use arrow characters. Format lines.\n\nWe can produce:\n\nStart // 程式開始執行\n→ Step 1: 讀入 n // 取得所需 Gray 代碼位數\n→ Step 2: 計算 seq_len = 2^n // Gray 代碼長度\n→ Step 3: 初始化 result = 空列表 // 用於儲存序列\n→ Decision: 是否 n == 0? // 檢查 n 是否為 0\n    Yes → Step 4: result = [0] // 只有 0 個元素\n    No  → Step 5: for i in 0 .. seq_len-1:\n                Gray = i XOR (i >> 1) // 公式生成 Gray 代碼\n                result.append(Gray) // 添加到序列\n→ Step 6: 輸出 result // 返回 Gray 代碼序列\nEnd // 程式執行結束\n\nNeed to keep arrow indentation maybe. The format uses \"→\" arrow. In the example they had indentation by spaces. We can indent decisions lines. So produce lines with \"Decision:\" line with spaces before nested steps. The nested lines start with \"Yes →\" or \"No →\". For loop steps maybe not nested under decision. Just after \"No\" maybe we have loop. We need to format accordingly.\n\nLet's output lines accordingly. Ensure no actual code, just pseudocode. Provide each line with arrow and explanation. Let's do it.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀入 n // 取得所需 Gray 代碼位數\n→ Step 2: 計算 seq_len = 2^n // Gray 代碼長度為 2 的 n 次方\n→ Step 3: 初始化 result = [] // 用於儲存 Gray 代碼序列\n→ Decision: 是否 n == 0? // 檢查 n 是否為 0\n    Yes → Step 4: result = [0] // 只有一個數字 0\n    No  → Step 5: for i in 0 .. seq_len-1: // 循環產生 0 到 seq_len-1\n        → Step 5.1: Gray = i XOR (i >> 1) // 使用 Gray 公式計算\n        → Step 5.2: result.append(Gray) // 將計算得到的 Gray 加入結果\n→ Step 6: 輸出 result // 回傳完整的 Gray 代碼序列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def grayCode(self, n: int) -> list[int]:\n        \"\"\"\n        產生 n 位 Gray 代碼序列。\n        透過遞迴式反射構造：對每一個已存在的序列，將其反轉並在每個元素加上 2^i。\n        \"\"\"\n        result = [0]\n        for i in range(n):\n            add = 1 << i                # 2^i\n            # 反轉目前序列並在每個元素加上 add，然後追加到 result\n            result += [x + add for x in reversed(result)]\n        return result\n\ndef main() -> None:\n    \"\"\"\n    主程式：從 stdin 讀取輸入，解析 n，計算 Gray 代碼並輸出結果。\n    \"\"\"\n    data = sys.stdin.read()\n    # 透過正則表達式找出第一個出現的整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return  # 無有效數字，直接結束\n    n = int(match.group(0))\n\n    sol = Solution()\n    seq = sol.grayCode(n)\n    print(seq)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,3,2]",
          "success": true,
          "output": "[0, 1, 3, 2]"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode16.json",
    "problem_index_in_file": 0,
    "title": "3Sum Closest",
    "description_snippet": "Given an integer array nums of length n and an integer target, find three integers in nums such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for three sum closest. Use typical algorithm: sort array, then for each i, use two pointers left and right. Keep best diff. Return best sum.\n\nWe need to output step by step with comments.\n\nWe have to use structure: Start, End, Decision, arrows, etc.\n\nWe need each line with \"虛擬碼步驟 // 解釋\". Must be in Traditional Chinese.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 將陣列按升序排列\n→ Step 2: Initialize bestSum = nums[0] + nums[1] + nums[2] // 初始最佳總和\n→ Step 3: For i from 0 to n-3 // 遍歷主迴圈\n    → Decision: 是否已遍歷到最後三個元素? // 判斷是否結束迴圈\n        No → Step 4: left = i + 1; right = n - 1 // 設定左右指標\n        → While left < right // 處理兩指標搜尋\n            → Step 5: currentSum = nums[i] + nums[left] + nums[right] // 計算目前總和\n            → Decision: currentSum == target? // 若剛好等於目標\n                Yes → Return currentSum // 完全符合，直接回傳\n                No →\n                    → Decision: |currentSum - target| < |bestSum - target|? // 更新最佳差距\n                        Yes → bestSum = currentSum // 更新最佳總和\n                        No → // 保持現有最佳\n            → Decision: currentSum < target? // 判斷方向調整\n                Yes → left = left + 1 // 左指標右移，增大總和\n                No  → right = right - 1 // 右指標左移，減小總和\n        → // 結束 while\n    → // 結束 for\n→ Step 6: Return bestSum // 回傳最接近目標的總和\nEnd // 程式結束\n\nBut we need to use arrow syntax consistently: `→` for sequence, `Yes →`, `No →`. Also indentation maybe. Let's write exactly.\n\nWe need each line: virtual code step and comment.\n\nLet's craft.\n\nUse \"→\" after each step. For decisions, indent lines under Decision. Provide comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 將陣列按升序排列  \n→ Step 2: Initialize bestSum = nums[0] + nums[1] + nums[2] // 設定初始最佳總和  \n→ Step 3: For i from 0 to n-3 // 主迴圈遍歷每個可能的第一個數字  \n  → Decision: 是否已遍歷到最後三個元素? // 判斷是否結束迴圈  \n   No → Step 4: left = i + 1; right = n - 1 // 設定左右指標  \n    → While left < right // 處理左右兩指標搜尋  \n     → Step 5: currentSum = nums[i] + nums[left] + nums[right] // 計算目前三數之和  \n     → Decision: currentSum == target? // 是否剛好等於目標  \n      Yes → Return currentSum // 完全符合，直接回傳  \n      No →  \n       → Decision: |currentSum - target| < |bestSum - target|? // 是否更新最佳差距  \n        Yes → bestSum = currentSum // 更新最佳總和  \n        No → // 保持現有最佳  \n      → Decision: currentSum < target? // 判斷方向調整  \n       Yes → left = left + 1 // 左指標右移，增大總和  \n       No  → right = right - 1 // 右指標左移，減小總和  \n     // 結束 while  \n  // 結束 for  \n→ Step 6: Return bestSum // 回傳最接近目標的總和  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def threeSumClosest(self, nums, target):\n        nums.sort()\n        n = len(nums)\n        closest_sum = nums[0] + nums[1] + nums[2]  # 初始化為前三個元素之和\n        for i in range(n - 2):  # 只需遍歷到 n-3\n            left, right = i + 1, n - 1\n            while left < right:\n                current = nums[i] + nums[left] + nums[right]\n                if abs(current - target) < abs(closest_sum - target):\n                    closest_sum = current\n                if current < target:\n                    left += 1\n                elif current > target:\n                    right -= 1\n                else:\n                    return current  # 完全相等\n        return closest_sum\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 使用正則表達式取得 nums 與 target\n    pattern = r\"nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)\"\n    match = re.search(pattern, data, re.DOTALL)\n    if not match:\n        raise ValueError(\"輸入格式不正確，請使用 'nums = [...], target = ...'\")\n    nums_str, target_str = match.group(1), match.group(2)\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n    result = Solution().threeSumClosest(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,2,1,-4], target = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,0], target = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode747.json",
    "problem_index_in_file": 0,
    "title": "Largest Number At Least Twice of Others",
    "description_snippet": "You are given an integer array nums where the largest integer is unique.\n\nDetermine whether the larg...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line with explanation. Use arrow, Decision. No actual code. Should be concise. Use Start, End. Provide steps: Find max, second max, compare. Return index or -1. Provide explanation per line.\n\nLet's craft. Use \"Start // 程式開始執行\". Next arrow lines.\n\nSteps:\n\n1. Input array nums. // get array\n2. Find largest number and its index. // traverse to get max and idx\n3. Find second largest number. // traverse again or track second max\n4. Decision: Is max >= 2 * secondMax? // compare\n5. Yes -> return maxIndex\n6. No -> return -1\nEnd.\n\nAdd explanation for each.\n\nUse arrow style.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數陣列 nums // 從使用者或函式參數取得陣列  \n→ Step 2: 初始化 maxVal ← -∞, maxIdx ← -1, secondMax ← -∞ // 用於追蹤最大值、索引與次大值  \n→ Step 3: 從左至右遍歷 nums  \n   → Decision: 如果 nums[i] > maxVal? // 判斷目前元素是否為新最大值  \n    Yes → Step 4: secondMax ← maxVal, maxVal ← nums[i], maxIdx ← i // 更新最大值與次大值  \n    No → Decision: 如果 nums[i] > secondMax? // 若不是最大值，檢查是否為次大值  \n     Yes → Step 5: secondMax ← nums[i] // 更新次大值  \n     No → Step 6: 省略 // 既不是最大值也不是次大值，保持不變  \n→ Decision: 是否滿足 maxVal ≥ 2 * secondMax? // 檢查最大值是否至少是其他數兩倍  \n  Yes → Step 7: 回傳 maxIdx // 最大值足夠大，回傳其索引  \n  No  → Step 8: 回傳 -1 // 最大值不夠大，回傳 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    \"\"\"\n    判斷陣列中最大元素是否至少是其他所有元素的兩倍。\n    若滿足條件，回傳最大元素的索引；否則回傳 -1。\n    \"\"\"\n    def dominantIndex(self, nums):\n        if not nums:\n            return -1\n\n        # 找到最大值及其索引\n        max_val = max(nums)\n        max_idx = nums.index(max_val)\n\n        # 檢查其他元素是否都不大於 max_val / 2\n        for i, num in enumerate(nums):\n            if i != max_idx and max_val < 2 * num:\n                return -1\n\n        return max_idx\n\ndef main():\n    # 從標準輸入讀取整個資料\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 以安全方式解析字串為列表\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        nums = []\n\n    # 呼叫解法並輸出結果\n    sol = Solution()\n    result = sol.dominantIndex(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,6,1,0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode65.json",
    "problem_index_in_file": 0,
    "title": "Valid Number",
    "description_snippet": "Given a string s, return whether s is a valid number.\n\nFor example, all the following are valid numb...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines for checking if string is valid number. Use Start, Decision, etc. Each line with comment. Provide virtual code but not actual code. Steps: trim, check empty, parse sign, parse integer part, decimal part, exponent part. Use flags. Provide explanation. Let's craft line by line.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: s ← trim(s) // 移除字串前後空白  \n→ Decision: s 為空? // 判斷字串是否為空  \n    Yes → Step 2: 回傳 false // 空字串不是有效數字  \n    No  → Step 3: i ← 0 // 初始化索引  \n→ Decision: s[i] 為 '+' 或 '-'? // 檢查符號  \n    Yes → i ← i + 1 // 跳過符號  \n    No  → No → // 直接進行  \n→ Step 4: 數字有效 ← false // 用來標記是否已經遇到數字  \n→ Step 5: 數字前點 ← false // 是否已經遇到小數點  \n→ Step 6: 數字後點 ← false // 是否已經遇到指數符號  \n→ Decision: i < len(s) 且 s[i] 為數字? // 從頭開始掃描數字  \n    Yes → Step 7: 數字有效 ← true  \n        → Step 8: i ← i + 1 // 走到第一個非數字  \n        → No → // 不是數字直接跳  \n→ Decision: i < len(s) 且 s[i] 為 '.'? // 檢查小數點  \n    Yes → Step 9: 數字前點 ← true  \n        → i ← i + 1 // 跳過小數點  \n        → Decision: i < len(s) 且 s[i] 為數字? // 小數點後必須有數字  \n            Yes → Step 10: 數字有效 ← true  \n                → Step 11: i ← i + 1 // 走到小數點後第一個非數字  \n                → No → // 小數點後沒有數字，視為有效，只要前面已有數字  \n        No  → No → // 若小數點後無數字，仍可有效，只要前面已經有數字  \n→ Decision: i < len(s) 且 s[i] 為 'e' 或 'E'? // 檢查指數符號  \n    Yes → Step 12: 數字後點 ← true  \n        → i ← i + 1 // 跳過 'e/E'  \n        → Decision: i < len(s) 且 (s[i] 為 '+' 或 '-')? // 指數符號可有符號  \n            Yes → i ← i + 1 // 跳過符號  \n            No  → No →  \n        → Decision: i < len(s) 且 s[i] 為數字? // 指數部分必須有數字  \n            Yes → Step 13: 數字有效 ← true  \n                → i ← i + 1 // 走到指數部第一個非數字  \n                → No → // 若指數後無數字，則無效  \n→ Decision: i = len(s) 且 數字有效? // 是否已經掃完且至少有一個數字  \n    Yes → Step 14: 回傳 true // 字串為有效數字  \n    No  → Step 15: 回傳 false // 否則不是有效數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()\n        if not s:\n            return False\n        num_seen = False      # 已經看到至少一個數字\n        dot_seen = False      # 已經看到小數點\n        e_seen = False        # 已經看到指數符號\n\n        for i, ch in enumerate(s):\n            if ch.isdigit():\n                num_seen = True\n            elif ch == '.':\n                if dot_seen or e_seen:   # 小數點不能出現在已經有小數點或指數符號後\n                    return False\n                dot_seen = True\n            elif ch in ('e', 'E'):\n                if e_seen or not num_seen:   # 指數符號不能重複且前面必須有數字\n                    return False\n                e_seen = True\n                num_seen = False   # 指數部必須再有數字\n            elif ch in ('+', '-'):\n                # 符號只能出現在最前面或指數符號之後\n                if i != 0 and s[i-1] not in ('e', 'E'):\n                    return False\n            else:\n                return False\n        return num_seen\n\ndef extract_string(input_text: str) -> str:\n    \"\"\"\n    從輸入文字中提取第一個被引號包住的字串。\n    如果沒有引號，直接回傳整個輸入。\n    \"\"\"\n    # 嘗試找到雙引號\n    m = re.search(r'\"([^\"]*)\"', input_text)\n    if m:\n        return m.group(1)\n    # 嘗試單引號\n    m = re.search(r\"'([^']*)'\", input_text)\n    if m:\n        return m.group(1)\n    # 無引號，直接使用整個輸入\n    return input_text.strip()\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = extract_string(raw_input)\n    sol = Solution()\n    result = sol.isNumber(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"0\"",
          "expected_output": "True",
          "success": true,
          "output": "True"
        },
        {
          "example_index": 1,
          "input": "s = \"e\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        },
        {
          "example_index": 2,
          "input": "s = \".\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode121.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou wan...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line. The problem is the classic \"Best Time to Buy and Sell Stock I\". So algorithm: iterate over prices, keep min price seen so far, compute max profit as max(current price - min price). If max profit < 0, return 0. Use pseudocode. Need to use Start, End, Decision. Also arrow arrows. Each line must be \"虛擬碼步驟 // 解釋\". Use spaces properly. Let's produce steps:\n\nStart\n→ Initialize min_price ← Infinity // 记录迄今为止最低价格\n→ Initialize max_profit ← 0 // 记录最高利润\n→ For each price in prices // 遍历每个价格\n    → Decision: price < min_price? // 检查当前价格是否比已记录的最低价更低\n        Yes → min_price ← price // 更新最低价\n        No  → Decision: price - min_price > max_profit? // 计算可能利润\n            Yes → max_profit ← price - min_price // 更新最高利润\n            No  → // 什么也不做，继续遍历\nEnd // 返回 max_profit // 最大利润\n\nWe need to output with lines and comments. Also need to mention Return. We can add a final Step: Return max_profit // 返回最大利润\n\nBut structure: Start, Steps, End. The return can be inside End or separate. We'll put a Step before End: → Step: Return max_profit // 返回最大利润\n\nOk, produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 min_price ← Infinity // 記錄迄今為止最低價格  \n→ Step 2: 初始化 max_profit ← 0 // 記錄最高利潤  \n→ Step 3: 循環遍歷每個 price in prices // 逐日遍歷價格陣列  \n    → Decision: price < min_price? // 判斷當前價格是否低於已知最低價  \n        Yes → Step 4: min_price ← price // 更新最低價格  \n        No  → Decision: price - min_price > max_profit? // 計算當前可得利潤  \n            Yes → Step 5: max_profit ← price - min_price // 更新最高利潤  \n            No  → // 無需更新，直接繼續下一天  \n→ Step 6: 返回 max_profit // 傳回最大可獲利，若為負則已在初始化為 0  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProfit(self, prices):\n        \"\"\"\n        Return the maximum profit that can be achieved by buying and\n        selling a single share of stock. If no profit is possible,\n        return 0.\n        \"\"\"\n        if not prices:\n            return 0\n        min_price = prices[0]\n        max_profit = 0\n        for price in prices[1:]:\n            # Update the maximum profit if selling at current price\n            # yields a better result than before\n            max_profit = max(max_profit, price - min_price)\n            # Update the minimum buying price seen so far\n            min_price = min(min_price, price)\n        return max_profit\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Expected format: \"prices = [7,1,5,3,6,4]\"\n    # Extract the part after the first '=' sign\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n    list_part = list_part.strip()\n\n    # Safely evaluate the list expression\n    try:\n        prices = ast.literal_eval(list_part)\n    except Exception:\n        # If parsing fails, treat as empty list\n        prices = []\n\n    solution = Solution()\n    result = solution.maxProfit(prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode44.json",
    "problem_index_in_file": 0,
    "title": "Wildcard Matching",
    "description_snippet": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for wildcard pattern matching with ? and * covering entire string. We need step-by-step algorithm, likely dynamic programming or two-pointer greedy approach. Use virtual code with Start, Decision, etc. Each line with explanation. Ensure no actual code, just pseudo steps.\n\nWe'll produce algorithm:\n\n- Initialize pointers i=0, j=0.\n- Keep track of star index and match index.\n- While i < len(s):\n   - If p[j] == s[i] or p[j] == '?': advance both\n   - Else if p[j] == '*': record starPos=j, matchPos=i, advance j\n   - Else if star exists: backtrack: j=starPos+1, matchPos+=1, i=matchPos\n   - Else: return false\n- After loop, skip remaining '*' in p\n- If j reached end, return true else false\n\nLet's produce virtual code lines with explanations. Ensure to use arrows. Use Decision steps for conditions. Use 'Yes →' and 'No →'. Provide Start and End. Include lines like \"Set i = 0\" etc.\n\nLet's craft lines. Use indentation maybe not necessary. Just lines with arrow and explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 i = 0 // 指向字串 s 的索引\n→ Step 2: 設定 j = 0 // 指向模式 p 的索引\n→ Step 3: 設定 starIndex = -1 // 上一次遇到 '*' 的位置\n→ Step 4: 設定 matchIndex = -1 // 與 '*' 相關的 s 的索引\n→ Decision: i < s.length? // 是否還有字元未處理？\n    Yes → Decision: p[j] == s[i] 或 p[j] == '?'? // 直接匹配或 '?' 通配\n        Yes → Step 5: i++ ; j++ // 同時往後移動\n        No  → Decision: p[j] == '*'? // 遇到 '*' 通配符\n            Yes → Step 6: starIndex = j ; matchIndex = i ; j++ // 記錄 '*' 位置並往後移動 j\n            No  → Decision: starIndex != -1? // 是否有先前的 '*' 以便回溯？\n                Yes → Step 7: j = starIndex + 1 ; matchIndex++ ; i = matchIndex // 重新匹配，擴展 '*' 匹配的字元\n                No  → Step 8: Exit // 沒有匹配且無可回溯，匹配失敗\n→ Decision: i >= s.length? // 完成字串遍歷\n    Yes → Step 9: 跳過模式中剩餘的 '*' // 允許尾部 '*' 匹配空字元\n        → While j < p.length and p[j] == '*'?\n            Yes → j++ // 移動 j\n            No  → break\n    No  → repeat from Decision: i < s.length?\n→ Decision: j == p.length? // 是否已遍歷完整模式\n    Yes → Step 10: Return True // 匹配成功\n    No  → Step 11: Return False // 模式仍有未匹配字元，匹配失敗\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"Wildcard matching DP solution.\"\"\"\n        m, n = len(s), len(p)\n        # dp[i][j] 表示 s[:i] 與 p[:j] 是否匹配\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        # 處理模式只包含 '*' 的情況\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '?':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    # '*' 可以匹配空字符 (dp[i][j-1]) 或匹配一個字符 (dp[i-1][j])\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n                else:\n                    dp[i][j] = False\n        return dp[m][n]\n\ndef parse_input(text: str):\n    \"\"\"從輸入文字中抽取 s 與 p 的值。\"\"\"\n    # 找出 s 的值\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', text)\n    s = s_match.group(1) if s_match else ''\n    # 找出 p 的值\n    p_match = re.search(r'p\\s*=\\s*\"([^\"]*)\"', text)\n    p = p_match.group(1) if p_match else ''\n    return s, p\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, p = parse_input(raw_input)\n    result = Solution().isMatch(s, p)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"cb\", p = \"?a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode216.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum III",
    "description_snippet": "Find all valid combinations of k numbers that sum up to n such that the following conditions are tru...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, with line comments. It's like pseudocode for backtracking combination sum. Use numbers 1-9 each at most once. We need to output combinations. Steps: Start, define function backtrack(start, remaining, path). Recursively try numbers from start to 9. If remaining==0, add path copy to result. If remaining<0, return. Each number used once; increment start. Use array of results. End.\n\nWe must output each line with \"虛擬碼步驟 // 解釋\". Use arrow \"→\". For decision statements use \"Decision:\". Use Start, End. Provide steps in order.\n\nWe need to ensure no duplicate combos; we can enforce by increasing start index ensures increasing order of numbers.\n\nLet's craft lines:\n\nStart // 程式開始\n→ Declare result as empty list // 儲存所有有效組合\n→ Define Function backtrack(start, remaining, path) // 回溯遞迴函式\n    → Decision: 如果 remaining == 0? // 檢查是否已找到合法組合\n        Yes → Add copy of path to result // 取得組合\n        No  → Decision: 如果 remaining < 0? // 超過目標則停止\n            Yes → Return // 回到上一層\n            No  → \n                → For i from start to 9 step 1 // 嘗試每個未使用的數字\n                    → Append i to path // 加入目前選項\n                    → Call backtrack(i+1, remaining-i, path) // 進入下一層，遞減剩餘值\n                    → Remove last element from path // 回溯\n→ Call backtrack(1, n, empty list) // 開始回溯\n→ Return result // 結束並返回所有組合\nEnd // 程式結束\n\nMake sure each line has arrow. The \"→\" is used for steps and decisions; indent lines show sub-steps. Need to keep arrow per line. Ensure each line ends with \"// 說明\".\n\nWe also need to maintain formatting exactly: each line is \"虛擬碼步驟 // 解釋\". For indentation we just indent lines with spaces? We can indent but maintain arrow.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始  \n→ Declare result as empty list // 儲存所有有效組合  \n→ Define Function backtrack(start, remaining, path) // 回溯遞迴函式  \n    → Decision: 如果 remaining == 0? // 檢查是否已找到合法組合  \n        Yes → Add copy of path to result // 取得並儲存組合  \n        No  → Decision: 如果 remaining < 0? // 超過目標則停止  \n            Yes → Return // 回到上一層  \n            No  → \n                → For i from start to 9 step 1 // 嘗試每個未使用的數字  \n                    → Append i to path // 加入目前選項  \n                    → Call backtrack(i+1, remaining-i, path) // 進入下一層，遞減剩餘值  \n                    → Remove last element from path // 回溯  \n→ Call backtrack(1, n, empty list) // 開始回溯  \n→ Return result // 結束並返回所有組合  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combinationSum3(self, k: int, n: int):\n        \"\"\"Return all combinations of k distinct numbers (1-9) that sum to n.\"\"\"\n        res = []\n\n        def backtrack(start: int, path: list[int], total: int):\n            # 如果已選 k 個且總和正好為 n，加入結果\n            if len(path) == k and total == n:\n                res.append(path[:])\n                return\n            # 若已超過限制，提前結束\n            if len(path) > k or total > n:\n                return\n            # 嘗試從 start 開始的每個未使用的數字\n            for i in range(start, 10):\n                path.append(i)\n                backtrack(i + 1, path, total + i)\n                path.pop()  # 回溯\n\n        backtrack(1, [], 0)\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入文字\n    data = sys.stdin.read()\n    # 從文字中抽取數字，支援「k = 3, n = 7」等格式\n    nums = re.findall(r'\\d+', data)\n    if len(nums) >= 2:\n        k = int(nums[0])\n        n = int(nums[1])\n        sol = Solution()\n        result = sol.combinationSum3(k, n)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 3, n = 7",
          "expected_output": "[[1,2,4]]",
          "success": true,
          "output": "[[1, 2, 4]]"
        },
        {
          "example_index": 1,
          "input": "k = 3, n = 9",
          "expected_output": "[[1,2,6],[1,3,5],[2,3,4]]",
          "success": true,
          "output": "[[1, 2, 6], [1, 3, 5], [2, 3, 4]]"
        },
        {
          "example_index": 2,
          "input": "k = 4, n = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode721.json",
    "problem_index_in_file": 0,
    "title": "Accounts Merge",
    "description_snippet": "Given a list of accounts where each element accounts[i] is a list of strings, where the first elemen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce virtual code for merging accounts using union-find. Provide step-by-step lines.\n\nWe need to output lines as per format: Start, → Step 1, etc. Use decision arrow for loops? We can represent loops as steps with iteration? Might need to express iterating over accounts and emails.\n\nWe'll produce virtual code with steps:\n\nStart\n→ Step 1: Initialize DSU structures for emails\n→ For each account index i, name = accounts[i][0]\n→ For each email in account, map email to name, union first email with each subsequent email\n→ After building DSU, create dictionary root->list of emails\n→ For each email, find root, add to list\n→ For each root, sort emails, prepend name, add to result\nEnd\n\nWe need to produce lines with explanation.\n\nAlso need to include decision for checking if email seen before, maybe.\n\nLet's produce about ~15 lines.\n\nUse \"Decision:\" lines where needed, maybe for checking if email seen, for checking root existence.\n\nBut minimal.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空的 DSU 物件以及 email → name 的對應表 // 以便後續聯集與查找\n→ Decision: 是否有賬戶數組? // 檢查輸入是否為空\n    Yes → Step 2: 依序遍歷 accounts[i] // 逐一處理每個賬戶\n        → Step 3: 取得 accounts[i][0] 作為 name // 取得賬戶擁有者姓名\n        → Decision: 賬戶內是否至少有一個 email? // 確保有可聯集的元素\n            Yes → Step 4: 取 accounts[i][1] 作為 rootEmail // 第一個 email 作為代表\n            No  → Continue // 若沒有 email，直接跳過此賬戶\n        → Step 5: 若 email 未在 map 中，將其加入 email → name 對應表並在 DSU 建立節點 // 建立新節點\n        → Decision: 是否有多於一個 email? // 檢查是否需要聯集\n            Yes → Step 6: 依序取 accounts[i][2:] 並對每個 email 執行\n                → Step 7: 若 email 未在 map 中，加入 email → name 對應表並在 DSU 建立節點\n                → Step 8: 在 DSU 中將 rootEmail 與該 email 聯集 // 合併同一人賬戶\n            No  → NoOp // 只有一個 email 時不需聯集\nStep 9: 建立 rootEmail → emailsList 的字典 // 用於收集同一根節點下的所有 email\n→ Step 10: 依序遍歷所有 email\n    → Step 11: 透過 DSU 找到該 email 的根 rootEmail\n    → Decision: 是否已存在 rootEmail 的鍵? // 檢查字典是否已有此根\n        Yes → Step 12: 把該 email 加入 rootEmail 對應的清單\n        No  → Step 13: 建立新鍵 rootEmail 並將該 email 放入初始清單\nStep 14: 建立結果列表 result = []\n→ Step 15: 依序遍歷 rootEmail → emailsList\n    → Step 16: 取 rootEmail 的 name 從 email → name 對應表\n    → Step 17: 將 emailsList[rootEmail] 進行字母排序 // 使 email 以升序排列\n    → Step 18: 建立新賬戶列表 newAccount = [name] + sortedEmails\n    → Step 19: 將 newAccount 加入 result\nEnd // 程式執行結束並回傳 result",
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        result = []\n        for root, emails in merged.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\ndef main():\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return\n    # Find the first '[' to extract the list representation\n    idx = input_data.find('[')\n    if idx != -1:\n        accounts_str = input_data[idx:]\n    else:\n        accounts_str = input_data\n    try:\n        accounts = ast.literal_eval(accounts_str)\n    except Exception as e:\n        print(\"Invalid input format\", file=sys.stderr)\n        return\n    sol = Solution()\n    merged_accounts = sol.accountsMerge(accounts)\n    print(merged_accounts)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "expected_output": "[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "success": true,
          "output": "[['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], ['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com']]"
        },
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode763.json",
    "problem_index_in_file": 0,
    "title": "Partition Labels",
    "description_snippet": "You are given a string s. We want to partition the string into as many parts as possible so that eac...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code for solution to partition string so that each letter appears in at most one part, maximize number of parts. Equivalent to LeetCode 763: Partition Labels. Approach: compute last occurrence of each character. Then iterate, keep current max last index, if index equals current max, cut.\n\nWe need step-by-step lines with comments. Use Start, End, Decision. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to ensure each line has arrow for steps. We can combine multiple steps. Let's produce pseudo code:\n\nStart // Start program\n→ Step 1: Initialize dict lastPos for 'a'..'z' to -1 // store last index\n→ Step 2: For each index i, char c in s: lastPos[c] = i // record last occurrence\n→ Step 3: Initialize empty list result // store partition sizes\n→ Step 4: Initialize start = 0, end = 0 // current partition boundaries\n→ Step 5: For each index i, char c in s: // iterate through string\n    → Decision: If i > end? // update end to lastPos[c]\n        Yes → end = lastPos[c] // extend current partition\n    → Decision: If i == end? // current index reaches end of partition\n        Yes → Append (i - start + 1) to result // size of partition\n        → start = i + 1 // move to next part\nEnd // Output result\n\nBut we need to output list of ints, but pseudo.\n\nMake sure each line includes arrow after Start? Format example: \"Start // 程式開始執行\". Then next lines starting with arrow: \"→ Step 1: ...\". Use arrow for each step.\n\nAlso for Decision: \"→ Decision: If i > end?\" and sublines \"Yes → ...\" and \"No → ...\" But we need each line to contain arrow and comment. For No branch we can just continue. But to be thorough, show both Yes and No.\n\nLet's produce.\n\nAlso include variable definitions. Use \"lastPos\" etc.\n\nEdge cases: string empty? We'll ignore.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize lastPos ← dict mapping each letter to -1 // 用來記錄每個字母最後一次出現的位置  \n→ Step 2: For i from 0 to length(s)-1:  \n  → Update lastPos[s[i]] ← i // 記錄字母的最後索引  \n→ Step 3: Initialize result ← empty list // 存放每個分割區塊的長度  \n→ Step 4: Initialize start ← 0, end ← 0 // 目前分割區塊的起始與終止索引  \n→ Step 5: For i from 0 to length(s)-1:  \n  → Decision: 若 i > end? // 檢查目前索引是否超出區塊終點  \n   Yes → end ← lastPos[s[i]] // 更新區塊終點到此字母的最後位置  \n   No  → // 不做處理，保持原來的區塊終點  \n  → Decision: 若 i == end? // 若已經達到區塊終點  \n   Yes → result.append(i - start + 1) // 加入區塊長度到結果  \n    → start ← i + 1 // 下一個區塊的起始位置  \n   No  → // 繼續遍歷，尚未結束區塊  \nEnd // 程式執行結束，result 為所需的分割長度清單",
      "generated_code": "import sys\nimport re\n\ndef partition_labels(s: str):\n    \"\"\"Partition string so that each letter appears in at most one part.\n    Return list of partition sizes.\"\"\"\n    # 1. Record last index of each character\n    last_pos = {c: i for i, c in enumerate(s)}\n    partitions = []\n    start = end = 0  # current partition boundaries\n\n    # 2. Iterate over string to build partitions\n    for i, c in enumerate(s):\n        end = max(end, last_pos[c])      # extend current partition if needed\n        if i == end:                    # reached the end of a partition\n            partitions.append(i - start + 1)  # record its size\n            start = i + 1                # start next partition\n\n    return partitions\n\ndef main():\n    # 讀取整個 stdin\n    data = sys.stdin.read().strip()\n\n    # 解析形如 s = \"...\" 的輸入\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有 `=`，直接去除可能存在的引號\n        s = data.strip('\"')\n\n    result = partition_labels(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ababcbacadefegdehijhklij\"",
          "expected_output": "[9,7,8]",
          "success": true,
          "output": "[9, 7, 8]"
        },
        {
          "example_index": 1,
          "input": "s = \"eccbbbbdec\"",
          "expected_output": "[10]",
          "success": true,
          "output": "[10]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode126.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder II",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, each line with virtual code + comment. Need to implement BFS+DFS approach to find all shortest sequences. Steps: start, check end in list, create adjacency by wildcard mapping, BFS to build levels, build graph of predecessors, DFS from end to start to construct paths. Then output all paths. Provide virtual steps line by line. Use arrows, decisions.\n\nWe need to include each step line, no actual code. Use \"→\" for next step. Use \"Decision:\" for branches. Use \"Start\" and \"End\". Provide brief explanation in comment after //.\n\nWe should break into logical steps: Start; Input; Validation; Build adjacency map; BFS to find levels; if no end, return empty; Build graph of predecessors; DFS to build paths; Output; End.\n\nWe need to reflect each line as virtual step. Use appropriate naming.\n\nLet's craft.\n\nBe careful: each line ends with \"// 解釋\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 beginWord, endWord, wordList // 從使用者處取得三個輸入  \n→ Decision: endWord 是否在 wordList? // 檢查終點是否可達  \n    Yes → Step 2: 進行 BFS + DFS 以尋找最短路徑 // 繼續流程  \n    No  → Step 3: 回傳空列表 // 無法到達終點，直接結束  \n→ Step 4: 建立所有單字的通配字典 mapping // 以 _ 為通配符建立鄰接表  \n    // 例如 'hot' → ['_ot', 'h_t', 'ho_']  \n→ Step 5: 執行 BFS 以計算每個單字到 beginWord 的最短距離 levels  \n    // 使用 queue，標記已訪問字元，並記錄距離  \n→ Decision: endWord 是否已在 levels? // 判斷是否已找到終點  \n    Yes → Step 6: 建立 predecessor graph preds // 只保留從層到下一層的連結  \n    No  → Step 7: 回傳空列表 // 未找到最短路徑，結束  \n→ Step 8: 以 DFS（或回溯）從 endWord 逆向構造所有路徑  \n    // 每一步選擇 preds 中的上一層字元，遞迴到 beginWord  \n→ Step 9: 收集所有完整路徑並回傳 // 路徑已自逆向回正序  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return []\n\n        # BFS to compute shortest level for each word and track parents\n        level = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = level[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in word_set:\n                        if next_word not in level:\n                            level[next_word] = step + 1\n                            queue.append(next_word)\n                            parents[next_word].append(word)\n                        elif level[next_word] == step + 1:\n                            parents[next_word].append(word)\n\n        # If endWord was never reached\n        if endWord not in parents:\n            return []\n\n        # DFS (or backtracking) to build all paths from endWord to beginWord\n        results = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                results.append(path[::-1])  # reverse to get correct order\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        dfs([endWord], endWord)\n        return results\n\ndef parse_input(data: str):\n    \"\"\"Parse input of the form:\n       beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",...]\n    \"\"\"\n    begin_match = re.search(r'beginWord\\s*=\\s*\"([^\"]+)\"', data)\n    end_match = re.search(r'endWord\\s*=\\s*\"([^\"]+)\"', data)\n    list_match = re.search(r'wordList\\s*=\\s*\\[(.*?)\\]', data, re.S)\n\n    if not begin_match or not end_match or not list_match:\n        raise ValueError(\"Input format is incorrect\")\n\n    beginWord = begin_match.group(1)\n    endWord = end_match.group(1)\n    # Extract all quoted words inside the list\n    wordList = re.findall(r'\"([^\"]+)\"', list_match.group(1))\n    return beginWord, endWord, wordList\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    try:\n        beginWord, endWord, wordList = parse_input(raw_input)\n    except ValueError:\n        print([])\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "success": true,
          "output": "[['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode436.json",
    "problem_index_in_file": 0,
    "title": "Find Right Interval",
    "description_snippet": "You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: Given intervals array with unique starts, find for each interval i the index of interval j where startj >= endi and startj minimal. If none, -1. We should generate virtual code steps, each line with \"虛擬碼步驟\" and comment.\n\nWe need to design algorithm: Since starts unique, we can create array of (start, index). Sort by start. Then for each interval i, binary search on sorted starts for minimal start >= endi. That gives index in sorted array, then map back to original index. If not found, -1. Complexity O(n log n). We'll produce steps accordingly.\n\nWe'll produce step lines:\n\nStart // 程式開始\n\n→ Step 1: Initialize n = number of intervals // 取得長度\n\n→ Step 2: Create array startIdxPairs = [] // 儲存 (start, originalIndex)\n\n→ For loop i from 0 to n-1: // 收集所有 (start, index)\n    → Append (intervals[i][0], i) to startIdxPairs\n\n→ Step 3: Sort startIdxPairs by start ascending // 以起點排序\n\n→ Step 4: Initialize result array of size n filled with -1 // 預設所有為 -1\n\n→ Step 5: For each interval i from 0 to n-1: // 逐一處理\n    → endVal = intervals[i][1] // 取得結束值\n    → binary search on startIdxPairs to find first element with start >= endVal // 找最小起點\n    → If found: // 找到合適的 interval j\n        → idxInSorted = found position\n        → originalIndex = startIdxPairs[idxInSorted].originalIndex\n        → result[i] = originalIndex // 設定結果\n    → Else:\n        → result[i] remains -1\n\n→ End // 程式結束\n\nBut we need to express binary search steps as virtual code: maybe we define Step 6: BinarySearch function. But maybe we can inline.\n\nAlso we need to mention mapping.\n\nLet's produce the virtual code lines. We'll include \"Start\", \"End\". Indentation not required but can be shown. We'll use arrow \"→\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: n ← length of intervals // 取得區間數量\n\n→ Step 2: startIdxPairs ← empty list // 用於儲存 (起點, 原始索引)\n\n→ Decision: 迭代 i 從 0 到 n-1? // 將每個區間的起點與索引收集起來\n    Yes → Step 3: Append (intervals[i][0], i) to startIdxPairs // 取得起點並記錄索引\n\n→ Step 4: Sort startIdxPairs by start ascending // 依起點排序，便於後續二分查找\n\n→ Step 5: result ← array of size n, each element = -1 // 預設所有右區間為 -1\n\n→ Decision: 迭代 i 從 0 到 n-1? // 逐個區間尋找右區間\n    Yes →\n        → endVal ← intervals[i][1] // 取得此區間的結束值\n\n        → Step 6: low ← 0, high ← n-1 // 二分查找範圍\n\n        → Decision: low ≤ high? // 二分查找是否還有區間可比\n            Yes →\n                → mid ← (low + high) // 2 // 取中點\n                → midStart ← startIdxPairs[mid][0] // 中點的起點\n                → Decision: midStart ≥ endVal? // 是否已滿足右區間條件\n                    Yes →\n                        → bestIndex ← mid // 記錄目前最小可行起點\n                        → high ← mid - 1 // 繼續尋找更小的起點\n                    No →\n                        → low ← mid + 1 // 向右搜尋更大的起點\n\n        → Step 7: If bestIndex exists? // 是否找到合適的右區間\n            Yes →\n                → rightOriginalIndex ← startIdxPairs[bestIndex][1] // 取得對應的原始索引\n                → result[i] ← rightOriginalIndex // 記錄結果\n            No →\n                → result[i] ← -1 // 留空 -1（已預設，可選擇忽略）\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport bisect\n\nclass Solution:\n    def findRightInterval(self, intervals):\n        # 建立開始時間與原始索引的排序列表\n        starts = sorted((interval[0], i) for i, interval in enumerate(intervals))\n        res = []\n        for interval in intervals:\n            # 找到第一個 start >= interval[1]\n            idx = bisect.bisect_left(starts, (interval[1],))\n            if idx < len(starts):\n                res.append(starts[idx][1])\n            else:\n                res.append(-1)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 只取等號後面的表達式，或整個輸入都視為列表\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n    intervals = ast.literal_eval(data)\n    solution = Solution()\n    result = solution.findRightInterval(intervals)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2]]",
          "expected_output": "[-1]",
          "success": true,
          "output": "[-1]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[3,4],[2,3],[1,2]]",
          "expected_output": "[-1,0,1]",
          "success": true,
          "output": "[-1, 0, 1]"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,4],[2,3],[3,4]]",
          "expected_output": "[-1,2,-1]",
          "success": true,
          "output": "[-1, 2, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode517.json",
    "problem_index_in_file": 0,
    "title": "Super Washing Machines",
    "description_snippet": "You have n super washing machines on a line. Initially, each washing machine has some dresses or is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem. It's similar to Leetcode 459. We need to produce algorithm: compute average, check sum divisible, then compute prefix sum differences, track max of abs(prefix) and max of prefix. Actually minimal moves is max of absolute prefix and max prefix? The known answer: for each machine, compute diff = machine[i] - avg. Keep track of cumulative sum s. For each step, moves = max(moves, abs(s), diff). final moves.\n\nWe'll produce virtual steps line by line, with explanation comments.\n\nWe'll start with Start, then input array machines, compute n, sum, check divisibility. If not divisible, return -1. Else compute avg = sum/n. Then initialize moves=0, cumulative=0. For each machine: diff = machine[i] - avg; cumulative += diff; moves = max(moves, abs(cumulative), diff). At the end, return moves.\n\nWe'll produce decisions: check divisibility, loops, updates.\n\nLet's produce in required format.\n\nWe need to use arrow and indentation for decision structure.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 machines // 獲取洗衣機的衣服數量\n→ Step 2: 計算 n = machines.Length // 洗衣機總數\n→ Step 3: 計算 sum = 所有 machines 的總和 // 需要確定平均值\n→ Decision: sum % n != 0? // 檢查總和是否能被 n 整除\n    Yes → Step 4: 回傳 -1 // 不能平均分配，直接返回失敗\n    No  → \n        → Step 5: 計算 avg = sum / n // 每台機器期望的衣服數量\n        → Step 6: 初始化 moves = 0 // 追蹤需要的最小移動次數\n        → Step 7: 初始化 cumulative = 0 // 前綫累積差值\n        → Step 8: 循環 i 從 0 到 n-1 // 遍歷每台洗衣機\n            → Step 9: 計算 diff = machines[i] - avg // 當前機器與平均值的差\n            → Step 10: 更新 cumulative += diff // 累積前綫差值\n            → Decision: max(moves, abs(cumulative), diff) > moves? // 判斷是否需要更新 moves\n                Yes → Step 11: 設置 moves = max(moves, abs(cumulative), diff) // 更新所需移動次數\n                No  → // moves 保持不變\n        → Step 12: 回傳 moves // 所有機器平衡所需的最小移動次數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMinMoves(self, machines):\n        total = sum(machines)\n        n = len(machines)\n        if total % n != 0:\n            return -1\n        avg = total // n\n        moves = 0\n        cumulative = 0\n        for load in machines:\n            diff = load - avg\n            cumulative += diff\n            moves = max(moves, abs(cumulative), diff)\n        return moves\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 將輸入字串解析為列表\n    try:\n        machines = ast.literal_eval(data)\n    except Exception:\n        # 若解析失敗，直接輸出 -1\n        print(-1)\n        sys.exit()\n    # 確保輸入為列表且元素為整數\n    if not isinstance(machines, list) or not all(isinstance(x, int) for x in machines):\n        print(-1)\n        sys.exit()\n    sol = Solution()\n    result = sol.findMinMoves(machines)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,0,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[0,3,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,2,0]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode657.json",
    "problem_index_in_file": 0,
    "title": "Robot Return to Origin",
    "description_snippet": "There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, for the described algorithm: check if robot returns to origin after sequence of moves. Steps: initialize coordinates x=0, y=0; iterate over each char in string moves; adjust accordingly; after loop, return x==0 and y==0.\n\nNeed to output line by line virtual code with arrow notation. Start and End markers. Use Decision: if char == 'R' etc. Or we can use switch-like decisions.\n\nThe code should include comments after space. Use \"虛擬碼步驟\" + space + \"// 解釋\". Each line.\n\nLet's produce.\n\nWe will use:\n\nStart\n→ Step 1: x = 0, y = 0 // 初始化坐標\n→ Step 2: 遍歷每個字符 in moves // 逐字處理\n    → Decision: char == 'R' ?\n        Yes → Step 3: x = x + 1 // 向右移動\n        No  → Decision: char == 'L' ?\n            Yes → Step 4: x = x - 1 // 向左移動\n            No  → Decision: char == 'U' ?\n                Yes → Step 5: y = y + 1 // 向上移動\n                No  → Decision: char == 'D' ?\n                    Yes → Step 6: y = y - 1 // 向下移動\n                    No  → Step 7: // 無效字符，忽略或錯誤處理\n→ Step 8: 判斷 x == 0 AND y == 0 // 檢查是否回到原點\n    Yes → Step 9: return true // 回到原點\n    No  → Step 10: return false // 未回到原點\nEnd\n\nBut we need to ensure \"虛擬碼步驟\" is like \"Step 1:\" etc.\n\nAlso need to incorporate arrow notation properly: \"→\" before each step line.\n\nAlso include decision arrow lines like \"Decision:\". Use indent.\n\nLet's format each line:\n\nStart // 程式開始執行\n→ Step 1: x = 0, y = 0 // 初始化坐標為原點\n→ Step 2: for each char in moves // 逐個字元處理移動序列\n    → Decision: char == 'R' ? // 檢查是否向右移動\n        Yes → Step 3: x = x + 1 // 向右移動一單位\n        No  → Decision: char == 'L' ? // 檢查是否向左移動\n            Yes → Step 4: x = x - 1 // 向左移動一單位\n            No  → Decision: char == 'U' ? // 檢查是否向上移動\n                Yes → Step 5: y = y + 1 // 向上移動一單位\n                No  → Decision: char == 'D' ? // 檢查是否向下移動\n                    Yes → Step 6: y = y - 1 // 向下移動一單位\n                    No  → Step 7: // 非法字元，忽略\n→ Step 8: 判斷 x == 0 AND y == 0 // 判斷是否回到原點\n    Yes → Step 9: return true // 回到原點，返回真\n    No  → Step 10: return false // 未回到原點，返回假\nEnd // 程式結束\n\nWe must ensure every line has \"虛擬碼步驟\" + space + \"// 解釋\". The steps we listed start with \"Step X:\" etc. We need to ensure each line's arrow '→' and then the step. Also indentation. After each line, add comment.\n\nOk.\n\nWe should output exactly that.\n\nCheck: All lines start with \"Start\", \"→ Step 1:\", \"→ Step 2:\", \"→ Decision: ...\" etc.\n\nWe must use arrow for Decision lines too: \"→ Decision:\".\n\nMake sure indent properly for nested decisions; we can indent with 4 spaces? We might just use tabs? In example, indentation is 4 spaces.\n\nWe also need to ensure the \"Yes → Step 3:\" lines include arrow. Eg: \"Yes → Step 3: x = x + 1\".\n\nSame for \"No  → Decision:\" etc. Good.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: x = 0, y = 0 // 初始化坐標為原點  \n→ Step 2: for each char in moves // 逐個字元處理移動序列  \n → Decision: char == 'R' ? // 檢查是否向右移動  \n  Yes → Step 3: x = x + 1 // 向右移動一單位  \n  No  → Decision: char == 'L' ? // 檢查是否向左移動  \n   Yes → Step 4: x = x - 1 // 向左移動一單位  \n   No  → Decision: char == 'U' ? // 檢查是否向上移動  \n    Yes → Step 5: y = y + 1 // 向上移動一單位  \n    No  → Decision: char == 'D' ? // 檢查是否向下移動  \n     Yes → Step 6: y = y - 1 // 向下移動一單位  \n     No  → Step 7: // 非法字元，忽略  \n→ Step 8: 判斷 x == 0 AND y == 0 // 判斷是否回到原點  \n Yes → Step 9: return true // 回到原點，返回真  \n No  → Step 10: return false // 未回到原點，返回假  \nEnd // 程式結束",
      "generated_code": "import sys\n\nclass Solution:\n    def judgeCircle(self, moves):\n        x = y = 0\n        for move in moves:\n            if move == 'U':\n                y += 1\n            elif move == 'D':\n                y -= 1\n            elif move == 'L':\n                x -= 1\n            elif move == 'R':\n                x += 1\n        return x == 0 and y == 0\n\ndef main():\n    # 讀取所有輸入並組合成一個字串\n    data = sys.stdin.read().strip()\n    # 從輸入中擷取雙引號內的移動序列\n    start = data.find('\"')\n    end = data.rfind('\"')\n    moves = data[start+1:end] if start != -1 and end != -1 and start < end else \"\"\n    # 判斷是否回到原點\n    result = Solution().judgeCircle(moves)\n    # 輸出小寫布林值\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "moves = \"UD\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "moves = \"LL\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode738.json",
    "problem_index_in_file": 0,
    "title": "Monotone Increasing Digits",
    "description_snippet": "An integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisf...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: given integer n, find largest number <= n with monotone increasing digits. Classic LeetCode 738. Approach: convert to digits array, find first position where digits[i] > digits[i+1], decrement digits[i] by 1, set all following digits to 9, then propagate carry leftwards if needed. Implementation: iterate from left to right? Common approach: iterate from left to right and when find decreasing, move leftwards to find leftmost decreasing digit to decrement and set rest to 9. Let's design pseudo:\n\nStart\n→ Step 1: 把 n 轉成字符陣列 digits // 取得每位數\n→ Step 2: 取得長度 m\n→ Step 3: i = 0\n→ Decision: 從左到右迴圈 while i < m-1? // 從第二位開始\n    Yes → Decision: digits[i] > digits[i+1]?\n        Yes → Step 4: j = i\n            → Decision: j > 0?\n                Yes → j--\n                No  → // j==0 skip? Actually we need to handle\n            → Loop: while j>0 and digits[j] == digits[j-1]? But algorithm: find leftmost position where decreasing occurs, decrement that digit by 1, set all following digits to 9, then break\nWe can implement simpler: find idx where digits[i] > digits[i+1]; then while idx>0 and digits[idx] == digits[idx-1], idx--? Actually to handle consecutive same digits, we decrement leftmost. Standard approach: find first decreasing, then decrement digits[idx] and set following to 9. But if after decrement, digits[idx] might still be < digits[idx-1] causing further adjustment? But setting following to 9 ensures monotonic. But need to handle cases like 1000? algorithm: find idx, decrement, set all after idx to 9. But if after decrement, digits[idx] < digits[idx-1], we need to propagate. So easier: after decrement, while idx>0 and digits[idx] < digits[idx-1], decrement digits[idx-1] and set digits[idx] to 9. But maybe simpler: Use algorithm:\n\n- Convert to char array.\n- Find first i from 1 to len-1 where digits[i] < digits[i-1]. If none, return n.\n- Decrement digits[i-1] by 1.\n- Set all digits from i to end to '9'.\n- Now there might be new decrease earlier; e.g., 332 -> find i=1 (3 >3? equal, i=2 digits[2]=2<digits[1]=3 so i=2). Decrement digits[1] to 2, set from 2 to end to 9: 2 9 9 -> 299, which is correct.\n\nBut consider 1110: digits[3]=0<digits[2]=1 i=3, decrement digits[2] to 0, set from 3 to end to 9: 1109. But 1109 not monotonic? 1<=1<=0? Actually 1<=1 yes, 1<=0 no. So fails. Wait because digits[2] was 1 and digits[3]=0, we decremented digits[2] to 0, but digits[1] still 1 >0? Actually digits[1]=1 > digits[2]=0, so need to propagate. So we need while loop: after decrement, we need to propagate leftwards if necessary. So algorithm: find first decreasing index i. Then j = i-1; while j>=0 and digits[j] > digits[j+1]? Actually digits[j] > digits[j+1] after we changed digits[j+1]? Let's design simpler: After find first decreasing i, decrement digits[i-1] by 1, set all from i to end to 9. Then set k = i-1; while k>0 and digits[k] < digits[k-1]: decrement digits[k-1], set digits[k] to 9, k--. But easier: after decrement, just re-evaluate from start again maybe but linear.\n\nSimpler algorithm: Convert to array; from left to right find first index where digits[i] > digits[i+1]; let idx = i. While idx>0 and digits[idx] == digits[idx-1] ??? Wait typical solution: Use \"prefix\" method: iterate left to right, when find decreasing at i, set a marker pos = i; then decrement digits[pos-1] by 1; set all from pos to end to 9; then continue leftwards: if digits[pos-1] < digits[pos-2], need adjust again. Implementation: use while loop after each decrement: while pos>0 and digits[pos] < digits[pos-1] then decrement digits[pos-1] and set digits[pos] to 9, pos--.\n\nLet's produce pseudo accordingly.\n\nAlso we must handle input up to 10^9? We can treat as string.\n\nPseudo lines:\n\nStart // 程式開始執行\n→ Step 1: 轉 n 為字串 digits // 取得每位數字\n→ Step 2: m = digits.length // 取得長度\n→ Step 3: idx = -1 // 位置記錄首次降序\n→ Decision: i from 1 to m-1?\n    Yes → Decision: digits[i] < digits[i-1]?\n        Yes → idx = i; break loop // 找到第一個降序位置\n        No  → continue\n    No  → // 完成掃描\n→ Decision: idx == -1?\n    Yes → Step 4: 返回 n // 已經是單調遞增\n    No  → // 需要調整\n→ Step 5: digits[idx-1] = digits[idx-1] - 1 // 將前一位減 1\n→ Step 6: for j = idx to m-1: digits[j] = '9' // 後面全設為 9\n→ Step 7: pos = idx-1\n→ Decision: pos > 0 AND digits[pos] < digits[pos-1]?\n    Yes → Step 8: digits[pos-1] = digits[pos-1] - 1\n        → Step 9: digits[pos] = '9'\n        → Step 10: pos = pos - 1\n        → goto Decision\n    No  → // 進一步檢查是否有前面遞減\n→ Step 11: // 也要檢查 pos == 0 可能還有更前面下降？實際上前面不會下降因為從左到右最早的下降已處理，減一不會造成更前面的下降? 但可能會，例如 110? let's test: digits 1 1 0. idx=2 (0<1). digits[1] = 0. digits[2-?] set to 9: 1 0 9. pos=1, digits[1]=0 < digits[0]=1 => decrement digits[0] to 0, set digits[1] to 9: 0 9 9. Now pos=0 -> stop. Good.\n\nSo step 11: no more adjustments.\n\n→ Step 12: 返回 digits 轉為整數 // 結果\n\nEnd // 程式結束\n\nWe should include explanation comments after each line.\n\nWe need to use virtual code arrows as specified: Start, Step 1: ... // comment\n\nMake sure each line includes virtual code and comment separated by space.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 把 n 轉成字串陣列 digits // 取得每位數字，方便逐位處理\n→ Step 2: m ← digits.length // 取得位數長度\n→ Step 3: idx ← -1 // 位置記錄第一次發現遞減的位置\n→ Decision: 從 i = 1 到 m-1 迴圈掃描\n    Yes → Decision: digits[i] < digits[i-1]?\n        Yes → idx ← i; 跳出迴圈 // 找到第一個遞減對\n        No  → 迴圈繼續\n    No  → // 迴圈結束\n→ Decision: idx == -1 ?\n    Yes → Step 4: 回傳 n // 已經是單調遞增的數字，直接返回\n    No  → // 需要調整數字\n→ Step 5: digits[idx-1] ← digits[idx-1] - 1 // 把前一位減 1\n→ Step 6: 對 j 從 idx 到 m-1 做\n    → Step 6a: digits[j] ← '9' // 後面所有位都設為 9\n→ Step 7: pos ← idx-1 // 重新檢查左邊是否還需調整\n→ Decision: pos > 0 且 digits[pos] < digits[pos-1] ?\n    Yes → Step 8: digits[pos-1] ← digits[pos-1] - 1 // 左邊再減 1\n        → Step 9: digits[pos] ← '9' // 右邊位設為 9\n        → Step 10: pos ← pos - 1 // 向更左邊移動\n        → 回到 Decision\n    No  → // 左邊已經符合單調遞增\n→ Step 11: result ← 整數化 digits // 把字串陣列轉回整數\n→ Step 12: 回傳 result // 返回最終結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def monotoneIncreasingDigits(self, n: int) -> int:\n        digits = list(str(n))\n        i = 1\n        # 找到第一個遞減位置\n        while i < len(digits) and digits[i] >= digits[i - 1]:\n            i += 1\n        if i < len(digits):\n            # 逐步調整左邊數字\n            while i > 0 and digits[i] < digits[i - 1]:\n                digits[i - 1] = str(int(digits[i - 1]) - 1)\n                i -= 1\n            # 之後所有位設為 9\n            for j in range(i + 1, len(digits)):\n                digits[j] = '9'\n        return int(''.join(digits))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        sys.exit()\n    n = int(nums[0])\n    solution = Solution()\n    print(solution.monotoneIncreasingDigits(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "n = 1234",
          "expected_output": "1234",
          "success": true,
          "output": "1234"
        },
        {
          "example_index": 2,
          "input": "n = 332",
          "expected_output": "299",
          "success": true,
          "output": "299"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode729.json",
    "problem_index_in_file": 0,
    "title": "My Calendar I",
    "description_snippet": "You are implementing a program to use as your calendar. We can add a new event if adding the event w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MyCalendar class with book method, ensuring no double booking. Likely use binary search tree or list of intervals. Since just virtual steps, we can describe: maintain sorted list of intervals, on book check for overlap by iterating or binary search, if none, insert. Use decisions.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize empty list intervals // store [start, end]\n→ Step 2: Define book(start, end) // method\n    → Decision: 找到第一個interval.end > start? // find if overlap\n        Yes → Decision: interval.start < end? // overlapping condition\n            Yes → Step 3: Return False // cannot book\n            No  → Step 4: // no overlap with this interval\n                No → Move to next interval\n        No → // no intervals left, no overlap\n    → Step 5: Insert new interval [start, end] into intervals // keep sorted\n    → Step 6: Return True\n\nBut need to be clear iterative loop. Maybe use while loop.\n\nLet's produce step-by-step with virtual code syntax:\n\nStart\n→ Step 1: Create empty list intervals // store existing bookings\n→ Step 2: Function book(start, end)\n    → Step 3: For each (s, e) in intervals\n        → Decision: If e <= start then // this interval ends before new starts\n            → Step 4: Continue // no overlap, check next\n        → Decision: If s >= end then // this interval starts after new ends\n            → Step 5: // all following intervals also start after end (list sorted)\n                → Step 6: Insert (start, end) into intervals in sorted order\n                → Step 7: Return True\n        → Decision: else // intervals overlap\n            → Step 8: Return False\n    → Step 9: // loop finished, no overlap found\n        → Step 10: Insert (start, end) into intervals\n        → Step 11: Return True\nEnd\n\nAlso maintain sorted order on insert.\n\nLet's ensure each line has arrow and comment. Use appropriate indentation.\n\nWe'll output line by line. Use \"→\" for steps, \"Decision:\" for if. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Create empty list intervals // 用於儲存已預約的 [start, end) 範圍  \n→ Step 2: Function book(start, end) // 定義預約方法  \n    → Step 3: For each (s, e) in intervals // 逐一檢查已有預約  \n        → Decision: If e <= start? // 這個預約結束時間在新預約開始之前  \n            Yes → Step 4: Continue // 無重疊，檢查下一個預約  \n            No  → Decision: If s >= end? // 這個預約開始時間在新預約結束之後  \n                Yes → Step 5: // 後續所有預約都不會與新預約重疊  \n                    → Step 6: Insert (start, end) into intervals maintaining order // 插入並保持時間升序  \n                    → Step 7: Return True // 成功預約，無衝突  \n                No  → Step 8: // 這個預約與新預約有重疊  \n                    → Step 9: Return False // 不能預約，回傳失敗  \n        → Decision: If e > start AND s < end? // 兩條件同時成立即為重疊  \n            Yes → Step 10: Return False // 直接失敗，停止迴圈  \n            No  → Step 11: Continue // 兩條件不成立，檢查下一個預約  \n    → Step 12: // 迴圈結束後仍無重疊  \n        → Step 13: Insert (start, end) into intervals maintaining order // 插入新預約  \n        → Step 14: Return True // 成功預約  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyCalendar:\n    \"\"\"一個簡單的排程類別，避免時間重疊。\"\"\"\n    def __init__(self):\n        # 儲存已預約的區間 (start, end)\n        self.bookings = []\n\n    def book(self, start: int, end: int) -> bool:\n        \"\"\"\n        若新區間與已存在的任何區間有交集，則回傳 False\n        否則將新區間加入並回傳 True。\n        \"\"\"\n        for s, e in self.bookings:\n            # 兩個區間有交集的判斷\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 分離兩個列表：指令與對應參數\n    # 例：[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]\n    comma_index = data.find('],')\n    if comma_index == -1:\n        # 無法正確解析，直接返回\n        return\n    commands_str = data[:comma_index+1]\n    args_str = data[comma_index+2:]\n\n    commands = ast.literal_eval(commands_str)\n    args_list = ast.literal_eval(args_str)\n\n    results = []\n    obj = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MyCalendar\":\n            obj = MyCalendar()\n            results.append(None)            # constructor 的結果為 null\n        elif cmd == \"book\":\n            res = obj.book(*args)\n            results.append(res)\n        else:\n            # 若有其他方法，略過\n            results.append(None)\n\n    # 輸出結果，使用 JSON 風格\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "success": true,
          "output": "[null, true, false, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode278.json",
    "problem_index_in_file": 0,
    "title": "First Bad Version",
    "description_snippet": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. It's a classic binary search problem. So produce steps:\n\nStart, set left=1, right=n, while left<right, mid=(left+right)/2, call isBadVersion(mid). If true, right=mid, else left=mid+1. End, return left. And mention minimizing API calls. We'll produce each line with explanation. Use arrows as per format. Ensure each line ends with // explanation.\n\nWe need to output each line. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 設定 left = 1, right = n // 初始化搜尋範圍\n→ Decision: 是否 left < right? // 檢查是否還有區間可以搜尋\n    Yes → Step 2: mid = (left + right) / 2 // 計算中點\n    → Step 3: 呼叫 isBadVersion(mid) // 判斷中點版本是否為壞版\n        Yes → Step 4: right = mid // 若中點為壞版，第一個壞版必定在左半邊或mid\n        No  → Step 5: left = mid + 1 // 若中點為好版，第一個壞版必定在右半邊\n    ← 回到 Decision: 是否 left < right? // 重複搜尋直至範圍縮小\n← Decision 結束\n→ Step 6: return left // left 即為第一個壞版號\nEnd // 程式執行結束\n\nCheck formatting: Each line: \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows and indentation as needed. Ensure consistent formatting: use \"→\" for steps. For Decision block, indent sub-steps maybe with indentation. But formatting guidelines: use arrows, \"Yes →\", \"No →\". Example: In sample, they used:\n\n→ Decision: 如果數字大於 0? \n    Yes → Step 2: 輸出 '正數'\n    No  → Decision: ...\n\nSo we replicate similar style. We'll produce:\n\nStart // 程式開始執行\n→ Step 1: left = 1, right = n // 初始化搜尋範圍\n→ Decision: left < right? // 是否還有範圍可搜尋\n    Yes → Step 2: mid = (left + right) / 2 // 計算中點\n    → Step 3: isBad = isBadVersion(mid) // 判斷中點版本是否為壞版\n        Yes → Step 4: right = mid // 中點為壞版，左半邊可能包含第一壞版\n        No  → Step 5: left = mid + 1 // 中點為好版，第一壞版在右半邊\n    ← 回到 Decision: left < right? // 重複直到範圍縮小\n← Decision 結束\n→ Step 6: return left // left 為第一個壞版\nEnd // 程式結束\n\nBut we need each line \"虛擬碼步驟\" + space + \"// 解釋\". So include comments after //.\n\nAlso, arrow indentation: we should preserve spaces after arrows. For \"Yes →\" and \"No →\", the arrow should be placed after the condition, like \"Yes → Step 4: ...\". For Decision block, the sub-steps are indented.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 1, right = n // 初始化搜尋範圍  \n→ Decision: left < right? // 檢查是否還有區間可以搜尋  \n Yes → Step 2: mid = (left + right) / 2 // 計算中點  \n  → Step 3: isBad = isBadVersion(mid) // 判斷中點版本是否為壞版  \n   Yes → Step 4: right = mid // 中點為壞版，第一個壞版在左半邊或等於 mid  \n   No → Step 5: left = mid + 1 // 中點為好版，第一個壞版在右半邊  \n  ← 回到 Decision: left < right? // 重複搜尋直至 left = right  \n← Decision 結束  \n→ Step 6: return left // left 現在即為第一個壞版號  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\n# Simulate the isBadVersion API using a global variable 'bad_version'\ndef isBadVersion(version: int) -> bool:\n    return version >= bad_version\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        left, right = 1, n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\nif __name__ == \"__main__\":\n    # Read entire input and extract integers\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if len(numbers) >= 2:\n        n, bad_version = numbers[0], numbers[1]\n    else:\n        # Fallback: if only one number is provided, treat it as both n and bad_version\n        n = bad_version = numbers[0] if numbers else 1\n\n    result = Solution().firstBadVersion(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5, bad = 4",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 1, bad = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode81.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array II",
    "description_snippet": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for searching target in rotated sorted array with duplicates, minimizing steps (i.e., using modified binary search). Provide step-by-step virtual code lines with explanations.\n\nWe'll produce algorithm: Start, read array and target, define low=0, high=length-1. While low <= high: mid = (low+high)/2. If nums[mid]==target return true. If nums[low]==nums[mid]==nums[high] then low++, high--. Else if nums[low] <= nums[mid] (left side sorted): if target between nums[low] and nums[mid]: high=mid-1 else low=mid+1. Else right side sorted: if target between nums[mid] and nums[high]: low=mid+1 else high=mid-1. Loop end: return false.\n\nReturn boolean.\n\nWe'll output each step as a line of virtual code. Ensure arrow formatting.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: low ← 0 // 初始化左指標\n→ Step 2: high ← length(nums) - 1 // 初始化右指標\n→ Decision: low ≤ high? // 判斷是否還有搜索區間\n    Yes → Step 3: mid ← (low + high) / 2 // 計算中間索引\n    → Decision: nums[mid] == target? // 檢查中間是否為目標\n        Yes → Step 4: return true // 找到目標即回傳真\n        No  → Decision: nums[low] == nums[mid] AND nums[mid] == nums[high]? // 兩邊相同值時無法判斷排序\n            Yes → Step 5: low ← low + 1 // 向內縮小左邊\n                → Step 6: high ← high - 1 // 向內縮小右邊\n                → Decision: low ≤ high? // 重新進入主循環\n                    Yes → Go to Decision: low ≤ high?\n                    No  → Step 7: return false // 搜索完畢無結果\n            No  → Decision: nums[low] ≤ nums[mid]? // 左半邊是否有序\n                Yes → Decision: nums[low] ≤ target < nums[mid]? // 目標在左半邊\n                    Yes → Step 8: high ← mid - 1 // 將右指標移至左半\n                    No  → Step 9: low ← mid + 1 // 目標不在左半，搜尋右半\n                No  → Decision: nums[mid] < target ≤ nums[high]? // 目標在右半\n                    Yes → Step 10: low ← mid + 1 // 將左指標移至右半\n                    No  → Step 11: high ← mid - 1 // 目標不在右半，搜尋左半\n    No → Step 12: return false // 主循環結束，未找到目標\nEnd // 程式執行結束\n\nBut we need arrow format as `→` for steps, and `Yes →`, `No →` for decisions. We need to align with guidelines.\n\nThe example uses `Decision: ...` and indent with tabs? In example, they show indent under decision.\n\nWe should produce similar.\n\nLet's create structure:\n\nStart // 程式開始執行\n→ low ← 0 // 初始化左指標\n→ high ← length(nums) - 1 // 初始化右指標\n→ Decision: low ≤ high? // 是否還有搜尋範圍\n    Yes → mid ← (low + high) / 2 // 計算中間索引\n        → Decision: nums[mid] == target? // 中間是否為目標\n            Yes → return true // 找到目標\n            No  → Decision: nums[low] == nums[mid] AND nums[mid] == nums[high]? // 兩邊相同\n                Yes → low ← low + 1 // 移動左指標\n                    → high ← high - 1 // 移動右指標\n                    → Decision: low ≤ high? // 重新檢查\n                        Yes → [回到 Decision: low ≤ high?] // loop\n                        No  → return false // 未找到\n                No  → Decision: nums[low] ≤ nums[mid]? // 左半邊有序？\n                    Yes → Decision: nums[low] ≤ target < nums[mid]? // 目標在左半\n                        Yes → high ← mid - 1 // 限縮右指標\n                        No  → low ← mid + 1 // 目標不在左，搜尋右半\n                    No  → Decision: nums[mid] < target ≤ nums[high]? // 目標在右半\n                        Yes → low ← mid + 1 // 目標在右半\n                        No  → high ← mid - 1 // 目標不在右半\n    No → return false // 沒有範圍\nEnd // 程式結束\n\nBut we need to ensure each line is separate; indent lines after Decision should have indentation; we can use tabs or spaces. In example they use a space after Decision. They also indent lines under decision. We'll replicate.\n\nWe need each line as \"虛擬碼步驟 [space] // 解釋\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ low ← 0 // 初始化左指標  \n→ high ← length(nums) - 1 // 初始化右指標  \n→ Decision: low ≤ high? // 是否還有搜尋範圍  \n Yes → mid ← (low + high) / 2 // 計算中間索引  \n  → Decision: nums[mid] == target? // 中間是否為目標  \n   Yes → return true // 找到目標，直接回傳真  \n   No  → Decision: nums[low] == nums[mid] AND nums[mid] == nums[high]? // 左右兩端相同，無法判斷排序  \n    Yes → low ← low + 1 // 向內縮小左邊  \n     → high ← high - 1 // 向內縮小右邊  \n     → Decision: low ≤ high? // 重新檢查是否仍有搜尋區間  \n      Yes → [回到 Decision: low ≤ high?] // 迴圈往前進  \n      No  → return false // 搜尋完畢仍未找到  \n    No  → Decision: nums[low] ≤ nums[mid]? // 左半邊是否有序  \n     Yes → Decision: nums[low] ≤ target < nums[mid]? // 目標在左半邊  \n      Yes → high ← mid - 1 // 將右指標移到左半區間  \n      No  → low ← mid + 1 // 目標不在左半，往右半搜尋  \n     No  → Decision: nums[mid] < target ≤ nums[high]? // 目標在右半邊  \n      Yes → low ← mid + 1 // 將左指標移到右半區間  \n      No  → high ← mid - 1 // 目標不在右半，往左半搜尋  \n No → return false // 初始條件不滿足，直接回傳假  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[left] == nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 匹配格式：nums = [..], target = ...\n    pattern = r\"nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)\"\n    match = re.search(pattern, data)\n    if not match:\n        # 若輸入不符合預期格式，可嘗試直接 eval\n        try:\n            nums, target = eval(data)\n        except Exception:\n            sys.exit()\n    else:\n        nums_str = match.group(1)\n        target_str = match.group(2)\n        nums = ast.literal_eval(nums_str)\n        target = int(target_str)\n\n    sol = Solution()\n    found = sol.search(nums, target)\n    print(\"true\" if found else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,5,6,0,0,1,2], target = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [2,5,6,0,0,1,2], target = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode648.json",
    "problem_index_in_file": 0,
    "title": "Replace Words",
    "description_snippet": "In English, we have a concept called root, which can be followed by some other word to form another ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps, each line with explanation comment. Use Start, Decision, arrow. Should handle root replacement of words in a sentence.\n\nWe need algorithm: given root list, sentence string. For each word in sentence, find shortest root that is a prefix of the word. Replace word with that root. Build new sentence.\n\nPseudo: Start, Step 1: split sentence into words. Step 2: for each word, find replacement. To find shortest prefix root, we can sort roots by length ascending, iterate, or use trie. Simpler: iterate over roots sorted by length. For each root check if word starts with root. If found, replace. If none found, keep word.\n\nConstruct output words list and join with spaces.\n\nFinally, return sentence.\n\nWe output each step.\n\nAlso may include data structures: set or list.\n\nLet's produce.\n\nUse arrows: →.\n\nExample: Start // 程式開始\n\n→ Step 1: 根據空格分割句子為單詞列表 // ...\n\n→ Step 2: 將根列表按長度升序排序 // 以便先檢查最短根\n\n→ Step 3: 初始化空的新句子單詞列表 // 用於儲存處理後的單詞\n\n→ Decision: 是否還有單詞未處理？ // 迴圈開始\n\n    Yes → Step 4: 取下一個單詞 // ...\n\n    → Step 5: 置 flags found False // ...\n\n    → Step 6: Decision: 迴圈遍歷所有根 // ...\n\n        Yes → Step 7: 判斷當前根是否為單詞前綴 // startsWith\n\n            Yes → Step 8: 將單詞替換為該根 // ...\n\n                Yes? Actually found true, break\n\n                → Step 9: 設置 found True // ...\n\n                → Step 10: 跳出根迴圈 // break\n\n            No → Step 11: 繼續下一個根 // next\n\n        No → Step 12: 判斷 found ？ // 如果沒有匹配，保留原單詞\n\n            Yes → Step 13: 加入原單詞到新列表 // ...\n\n            No → Step 14: 加入替換後的根到新列表 // (but we already replaced earlier) actually we added in found case\n\n    → Step 15: 回到外部單詞迴圈 // loop\n\n    No → Step 16: 將新列表用空格連接成句子 // ...\n\n→ End // 完成\n\nWe need to adhere to \"逐行\" requirement. Each line must include virtual code step plus comment.\n\nWe must avoid real code. Use pseudo. Provide arrow after step lines. We need consistent syntax: \"→ Step X: ...\". Decision: \"Decision: ...\".\n\nAlso \"Start\" and \"End\" as separate lines.\n\nWe might need to handle break with \"→ Step ... // break\" but we can show \"→ Step ... // 跳出內部循環\".\n\nOk.\n\nLet's produce.\n\nWe'll include details like \"list roots_sorted\". Might need to show variable names in pseudo but not actual code. We can use \"roots_sorted\" etc.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將輸入句子用空格切割成單詞列表 words // 取得原句中每個單詞  \n→ Step 2: 將根字典 roots 按長度升序排序得到 roots_sorted // 先檢查最短根  \n→ Step 3: 建立空列表 new_words 用於儲存處理後的單詞 // 結果句子將由此組成  \n→ Decision: 是否還有未處理的單詞？ // 進入外層迴圈  \n    Yes → Step 4: 取出 words 的下一個單詞 current_word // 進行檢查  \n    → Step 5: 初始化布林變數 matched 為 False // 用於判斷是否找到根  \n    → Decision: 迴圈遍歷 roots_sorted 中每個 root // 嘗試匹配前綴  \n        Yes → Step 6: 判斷 current_word 是否以 root 為前綴 // startsWith 判斷  \n            Yes → Step 7: 把 current_word 替換為 root // 取得最短匹配根  \n                → Step 8: 設置 matched 為 True // 標記已匹配  \n                → Step 9: 跳出內部根迴圈 // 找到最短根後停止尋找  \n            No → Step 10: 繼續處理下一個 root // 沒匹配則往下  \n        No → Step 11: 判斷 matched 是否為 False // 所有根都檢查完後  \n            Yes → Step 12: 把 current_word 原樣加入 new_words // 未找到根，保留原單詞  \n            No  → Step 13: 把替換後的 root 加入 new_words // 已匹配的根已存於 new_words  \n    → Step 14: 回到外層單詞迴圈 // 進行下一個單詞  \n    No  → Step 15: 用空格將 new_words 連接成新的句子 result_sentence // 組成最終句子  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def replaceWords(self, dictionary, sentence):\n        # 建立 Trie\n        trie = {}\n        END = True\n\n        for root in dictionary:\n            node = trie\n            for char in root:\n                node = node.setdefault(char, {})\n            node[END] = root\n\n        def replace(word):\n            node = trie\n            for char in word:\n                if char not in node:\n                    break\n                node = node[char]\n                if END in node:\n                    return node[END]\n            return word\n\n        return ' '.join(map(replace, sentence.split()))\n\ndef parse_input(text: str):\n    \"\"\"\n    解析輸入，支援兩種格式：\n    1. dictionary = [\"cat\",\"bat\"], sentence = \"the cattle ...\"\n    2. 兩行：第一行為字典列表，第二行為句子\n    \"\"\"\n    text = text.strip()\n    # 方案 1：包含關鍵字 dictionary 和 sentence\n    pattern = r'dictionary\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*sentence\\s*=\\s*\"([^\"]*)\"'\n    m = re.search(pattern, text)\n    if m:\n        dict_str = m.group(1)\n        sentence = m.group(2)\n        dictionary = ast.literal_eval(dict_str)\n        return dictionary, sentence\n\n    # 方案 2：兩行輸入\n    lines = text.splitlines()\n    if len(lines) >= 2:\n        dict_line = lines[0].strip()\n        sentence = lines[1].strip()\n        # 去除可能的前後引號\n        if sentence.startswith('\"') and sentence.endswith('\"'):\n            sentence = sentence[1:-1]\n        dictionary = ast.literal_eval(dict_line)\n        return dictionary, sentence\n\n    # 無法解析時拋出例外\n    raise ValueError(\"輸入格式不符\")\n\ndef main():\n    raw_input = sys.stdin.read()\n    dictionary, sentence = parse_input(raw_input)\n\n    sol = Solution()\n    result = sol.replaceWords(dictionary, sentence)\n\n    # 按範例輸出，外層加雙引號\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"",
          "expected_output": "\"the cat was rat by the bat\"",
          "success": true,
          "output": "\"the cat was rat by the bat\""
        },
        {
          "example_index": 1,
          "input": "dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"",
          "expected_output": "\"a a b c\"",
          "success": true,
          "output": "\"a a b c\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode435.json",
    "problem_index_in_file": 0,
    "title": "Non-overlapping Intervals",
    "description_snippet": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce pseudocode steps for algorithm: find min number of intervals to remove to make rest non-overlapping. Classic: sort by end, greedy choose non-overlap, count removals = total - count of kept. Steps: sort intervals by end ascending, iterate, keep current end, if interval start < current end => overlap -> remove++ else update current end = interval end. Provide Start, End, Decision arrows. Provide each line with explanation. No actual code, just virtual pseudocode. We'll produce each line.\n\nLet's design pseudocode:\n\nStart\n→ Step 1: Sort intervals by end ascending // Order intervals by finishing time\n→ Step 2: Initialize removed = 0 // Counter for removals\n→ Step 3: Initialize prev_end = -infinity // End of last kept interval\n→ Decision: 是否有剩餘區間? // Check if there are intervals left\n    Yes → Step 4: Pick next interval (start, end) // Process next interval\n    → Decision: 是否重疊? // Overlap test\n        Yes → Step 5: removed++ // Increment removal count\n        → Step 6: prev_end remains unchanged // Keep previous interval\n        No  → Step 7: prev_end = end // Update end to this interval\n        → Step 8: Continue to next interval // Loop\n    No  → End // All intervals processed\n\nBut we need format with arrow \"→\". We'll produce each line accordingly. Also maybe include 'While' or 'For' but using decision. Provide each step. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort intervals by end ascending // 將所有區間按結束時間由小到大排序  \n→ Step 2: Initialize removed = 0 // 記錄需要移除的區間數量  \n→ Step 3: Initialize prev_end = -∞ // 上一個已保留區間的結束時間  \n→ Decision: 是否還有區間未處理? // 判斷是否還有區間需要遍歷  \n    Yes → Step 4: 取下一個區間 (start, end) // 取得目前要判斷的區間  \n    → Decision: 是否與 prev_end 重疊? // 判斷本區間的起點是否小於上一個保留區間的結束時間  \n        Yes → Step 5: removed++ // 本區間與前一個重疊，需移除  \n        → Step 6: prev_end remains unchanged // 保留上一個區間的結束時間不變  \n        No  → Step 7: prev_end = end // 本區間不重疊，將其結束時間設為新的 prev_end  \n        → Step 8: 回到 Decision: 是否還有區間未處理? // 進行下一個區間的處理  \n    No  → End // 所有區間已處理完畢  \nEnd // 程式執行結束，removed 即為最小移除數量。",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def eraseOverlapIntervals(self, intervals):\n        \"\"\"\n        以結束時間排序後使用貪心演算法\n        每當遇到不重疊的區間就保留，計算最大可保留數\n        最終答案為 總數 - 可保留數\n        \"\"\"\n        if not intervals:\n            return 0\n\n        # 按結束時間升序排序\n        intervals.sort(key=lambda x: x[1])\n\n        # 先保留第一個區間\n        end = intervals[0][1]\n        keep = 1\n\n        for start, finish in intervals[1:]:\n            if start >= end:          # 不重疊，保留\n                end = finish\n                keep += 1\n\n        return len(intervals) - keep\n\n\ndef parse_input(raw):\n    \"\"\"\n    解析 stdin 中的輸入，支援：\n    1. 'intervals = [[1,2],[2,3]]'\n    2. '[[1,2],[2,3]]'\n    \"\"\"\n    raw = raw.strip()\n    if raw.startswith('intervals'):\n        _, _, rest = raw.partition('=')\n        raw = rest.strip()\n    # 使用 literal_eval 以避免 eval 的風險\n    return ast.literal_eval(raw)\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    intervals = parse_input(raw_input)\n    sol = Solution()\n    result = sol.eraseOverlapIntervals(intervals)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[1,2],[1,2]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,2],[2,3]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode710.json",
    "problem_index_in_file": 0,
    "title": "Random Pick with Blacklist",
    "description_snippet": "You are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm. Classic solution: map banned numbers in [0, n-1] to allowed numbers in [n - len(blacklist), n-1] that are not banned. Use hash map for mapping. In pick, generate random in [0, m-1] where m = n - len(blacklist). If random r in mapping, return mapping[r] else r. Provide virtual code step-by-step.\n\nWe need to output lines: \"Start // 程式開始執行\" etc.\n\nWe'll break into initialization steps and pick steps.\n\nWe need to use arrows.\n\nOk produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 m = n - blacklist.length // 可用整數數量  \n→ Step 2: 初始化空映射 map: int → int // 用於映射被封鎖的索引到合法索引  \n→ Decision: 如果 blacklist 不是空的? // 判斷是否有黑名單  \n  Yes → Step 3: 建立封鎖集合 bannedSet = blacklist 為哈希集合 // 方便 O(1) 判斷  \n  Yes → Step 4: 計算 maxIndex = n - 1 // 最大可能的原始索引  \n  Yes → Step 5: 遍歷每個 banned in blacklist  \n    Decision: 如果 banned < m? // 只處理需要映射的黑名單  \n     Yes → Step 6: 從 maxIndex 開始往左尋找第一個不在 bannedSet 的數字 target  \n      Decision: 如果 target < banned? // 確保 target 不會被覆蓋  \n       Yes → Step 7: 解除 target 與 bannedSet 的關係 (將 target 加回 bannedSet) // 避免重複映射  \n       No  → Step 8: map[banned] = target // 建立映射  \n       No → Step 9: maxIndex-- // 縮減最大索引  \n     No → Step 10: // 無需映射  \n  No → // 無黑名單，映射保持空  \nEnd // 初始化完成  \n\nStart // pick 方法開始執行  \n→ Step 11: 隨機產生整數 r 在 [0, m-1] 之間 // 使用語言隨機函式  \n→ Decision: r 是否在 map 之中? // 檢查是否需要映射  \n  Yes → Step 12: 返回 map[r] // 映射後的合法值  \n  No  → Step 13: 返回 r // 直接使用原始值  \nEnd // pick 方法結束",
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # 建立映射表，將被封鎖的數字映射到合法的數字\n        self.mapping = {}\n        self.size = n - len(blacklist)          # 可用數字的個數\n        black_set = set(blacklist)              # 快速判斷是否在黑名單\n        last = n - 1                            # 可能的最大數字\n        for b in blacklist:\n            if b < self.size:                   # 只需要映射小於 size 的黑名單\n                while last in black_set:        # 找到一個不在黑名單的合法數字\n                    last -= 1\n                self.mapping[b] = last          # 建立映射\n                last -= 1\n\n    def pick(self):\n        # 隨機取一個索引，若在映射表中則返回映射後的數字\n        idx = random.randint(0, self.size - 1)\n        return self.mapping.get(idx, idx)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        sys.exit()\n    ops = json.loads(data[0])           # [\"Solution\", \"pick\", ...]\n    args_list = json.loads(data[1])     # [[7, [2,3,5]], [], ...]\n    instance = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            n, bl = args\n            instance = Solution(n, bl)\n            results.append(None)         # constructor returns null\n        elif op == \"pick\":\n            results.append(instance.pick())\n        else:\n            # 若有其他操作，可在此處處理\n            results.append(None)\n\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,6,4,6,4,4,4,1]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 6, 4, 6, 4, 4, 4, 1]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode677.json",
    "problem_index_in_file": 0,
    "title": "Map Sum Pairs",
    "description_snippet": "Design a map that allows you to do the following:\n\nMaps a string key to a given value.\nReturns the s...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code lines for design of a MapSum. We'll include steps for class initialization, insert, sum. Use Start, End, Decision, etc. Probably pseudocode for Trie. We'll output lines each with explanation. Use Chinese comments. Ensure each line: virtual step + space + // explanation. Use arrow \"→\" for sequential steps. We need to describe building a Trie node with map children and sum. Insert updates sums along path. Sum traverses prefix and returns node.sum. Provide steps. No actual code. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class MapSum: // 建立 MapSum 類別  \n→     Start // 建構子執行  \n→         root ← 新建 TrieNode() // Trie 根節點，存放所有鍵字前綴  \n→         keyVals ← 空字典() // 追蹤每個 key 的現有值，方便覆寫時調整  \n→     End // 建構子結束  \n→     Function insert(key, val): // 插入或覆寫鍵值對  \n→         old ← keyVals.get(key, 0) // 取得舊值，若無則為 0  \n→         diff ← val - old // 計算增減差值  \n→         keyVals[key] ← val // 更新字典中的值  \n→         node ← root // 從根節點開始  \n→         node.sum ← node.sum + diff // 根節點累加差值  \n→         For each char c in key: // 遍歷鍵字的每個字符  \n→             If c not in node.children: // 若路徑不存在，建立新節點  \n→                 node.children[c] ← 新建 TrieNode()  \n→             node ← node.children[c] // 進入下一節點  \n→             node.sum ← node.sum + diff // 在此節點累加差值  \n→     End // insert 完成  \n→     Function sum(prefix): // 計算前綴總和  \n→         node ← root // 從根節點開始  \n→         For each char c in prefix: // 遍歷前綴字符  \n→             If c not in node.children: // 前綴不存在，直接返回 0  \n→                 Return 0 // 無匹配鍵  \n→             node ← node.children[c] // 進入下一節點  \n→         Return node.sum // 返回該前綴下所有鍵值總和  \n→     End // sum 完成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\nimport json\n\n# ---------- Trie 版 MapSum ----------\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n\nclass MapSum:\n    def __init__(self):\n        # 根節點\n        self.root = TrieNode()\n        # 追蹤每個 key 的目前值，方便覆寫時調整\n        self.key_vals = {}\n\n    def insert(self, key: str, val: int) -> None:\n        # 舊值，若 key 尚未出現則為 0\n        old_val = self.key_vals.get(key, 0)\n        # 差值\n        diff = val - old_val\n        # 更新 key 的值\n        self.key_vals[key] = val\n\n        node = self.root\n        node.sum += diff\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += diff\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\n# ---------- 主程式 ----------\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得兩個 list 字串\n    list_strs = re.findall(r'\\[.*?\\]', data, flags=re.S)\n    if len(list_strs) != 2:\n        raise ValueError(\"輸入格式錯誤\")\n\n    commands = ast.literal_eval(list_strs[0])\n    args_list = ast.literal_eval(list_strs[1])\n\n    if len(commands) != len(args_list):\n        raise ValueError(\"指令與參數長度不符\")\n\n    output = []\n    obj = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MapSum\":\n            obj = MapSum()\n            output.append(None)\n        elif cmd == \"insert\":\n            key, val = args\n            obj.insert(key, val)\n            output.append(None)\n        elif cmd == \"sum\":\n            prefix = args[0]\n            result = obj.sum(prefix)\n            output.append(result)\n        else:\n            raise ValueError(f\"未知指令: {cmd}\")\n\n    # 以 JSON 形式輸出，null 對應 None\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpvbs54u0c.py\", line 82, in <module>\n    main()\n  File \"/tmp/tmpvbs54u0c.py\", line 52, in main\n    raise ValueError(\"輸入格式錯誤\")\nValueError: 輸入格式錯誤"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode137.json",
    "problem_index_in_file": 0,
    "title": "Single Number II",
    "description_snippet": "Given an integer array nums where every element appears three times except for one, which appears ex...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for algorithm to find single number in array where all others appear 3 times, using linear time O(n) and O(1) space. Classic solution uses bit counting: for each bit position 0-31, sum bits modulo 3, reconstruct result. Or use state machine with two registers.\n\nWe produce step by step virtual code.\n\nWe will use bit counting approach: iterate array, accumulate count per bit modulo 3. But since we need O(1) space, we can use array of 32 counts or just do bitwise accumulation using 32-bit ints.\n\nSimplify: For each bit i, count bits, after loop compute result.\n\nBut the pseudocode needs to be line by line with explanation.\n\nWe need to use Start, End, Decision, etc.\n\nWe must not output actual code, only virtual steps.\n\nLet's design:\n\nStart\n→ Input array nums\n→ Initialize array bitCount[32] to 0\n→ For each num in nums:\n    → For i from 0 to 31:\n        → If (num >> i) & 1 == 1:\n            → bitCount[i] = bitCount[i] + 1\n→ Initialize result = 0\n→ For i from 0 to 31:\n    → If bitCount[i] % 3 != 0:\n        → result = result | (1 << i)\n→ Output result\nEnd\n\nBut we must include decision structure. For loops maybe use Decision? We can use Step for loops.\n\nLet's craft step by step pseudocode with arrows and decisions.\n\nUse \"Decision:\" for if conditions.\n\nWe need to be careful to include \"Yes →\" \"No →\" where needed.\n\nSo maybe:\n\nStart // 程式開始執行\n→ Step 1: 讀取整數陣列 nums // 取得輸入\n→ Step 2: 建立長度 32 的整數陣列 bitCount 並全部設為 0 // 用於統計每位元出現次數\n→ Step 3: Decision: 是否已經遍歷完 nums? // 檢查是否有更多元素\n    No  → Step 4: 取出下一個 num // 取得陣列中的元素\n    → Step 5: Decision: i 從 0 到 31? // 遍歷 32 位元\n        No  → Step 6: Decision: 是否已經完成所有位元? // 內層循環結束\n            No  → Step 7: Decision: ((num >> i) & 1) == 1? // 判斷第 i 位是否為 1\n                Yes → Step 8: bitCount[i] = bitCount[i] + 1 // 增加計數\n                No  → // 不做任何事\n            Yes → // 結束內層循環，回到外層\n        Yes → // 內層結束，回到外層\n    Yes → // 外層結束\n→ Step 9: 初始化 result 為 0 // 用於存放唯一元素\n→ Step 10: Decision: i 從 0 到 31? // 重新遍歷 32 位元\n    No  → Step 11: Decision: 是否已經完成所有位元? // 內層循環結束\n        No  → Step 12: Decision: bitCount[i] % 3 != 0? // 判斷此位是否為唯一元素的位\n            Yes → Step 13: result = result | (1 << i) // 設置結果的該位\n            No  → // 不做任何事\n        Yes → // 內層結束\n    Yes → // 內層結束\n→ Step 14: 輸出 result // 回傳唯一元素\nEnd // 程式結束\n\nBut this is messy. Maybe simpler to outline loops explicitly as steps, not as decision tree for each loop. The requirement: use Decision: if, Yes→, No→. We can use Decision for if conditions, loops can be represented as Step and Decision for condition. It's fine.\n\nBut we can condense loops into single steps like \"For each num in nums\". That's okay. The example uses Step 1: 輸入使用者數字, so loops are implicit. So we can just show steps with loops as step lines. That may be simpler and still meet requirement.\n\nLet's produce:\n\nStart\n→ Step 1: 讀取整數陣列 nums\n→ Step 2: 建立 32 位元整數陣列 bitCount 並初始化為 0\n→ Step 3: For 每個 num 在 nums:\n    → Step 4: For i 0 到 31:\n        → Decision: ((num >> i) & 1) == 1\n            Yes → Step 5: bitCount[i] = bitCount[i] + 1\n            No → // 無操作\n→ Step 6: 初始化 result 為 0\n→ Step 7: For i 0 到 31:\n    → Decision: bitCount[i] % 3 != 0\n        Yes → Step 8: result = result | (1 << i)\n        No → // 無操作\n→ Step 9: 輸出 result\nEnd\n\nThat uses Decision structure properly. Provide explanation after each line.\n\nWe need to ensure each line has virtual code step and comment separated by space. Use '→' arrow before steps, except Start and End.\n\nWe'll output each line separately. Use Chinese explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數陣列 nums // 取得輸入的整數陣列  \n→ Step 2: 建立 32 位元整數陣列 bitCount 並初始化為 0 // 用於統計每個位元出現的次數  \n→ Step 3: For 每個 num 在 nums: // 遍歷陣列中的每個數字  \n  → Step 4: For i 0 到 31: // 對每個位元位置進行處理  \n    → Decision: ((num >> i) & 1) == 1 // 判斷第 i 位是否為 1  \n      Yes → Step 5: bitCount[i] = bitCount[i] + 1 // 若為 1，計數加一  \n      No  → // 無需操作  \n→ Step 6: 初始化 result 為 0 // 用於組裝唯一出現一次的數字  \n→ Step 7: For i 0 到 31: // 再次遍歷 32 個位元  \n    → Decision: bitCount[i] % 3 != 0 // 判斷此位是否是唯一數字的位元  \n      Yes → Step 8: result = result | (1 << i) // 設置結果的該位  \n      No  → // 無需操作  \n→ Step 9: 輸出 result // 回傳找到的唯一元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef singleNumber(nums):\n    \"\"\"\n    找出只出現一次的數字。其餘數字都出現三次。\n    使用兩個整數 ones、twos 來維護位元計數。\n    \"\"\"\n    ones, twos = 0, 0\n    for num in nums:\n        ones = (ones ^ num) & ~twos\n        twos = (twos ^ num) & ~ones\n    return ones\n\ndef main():\n    \"\"\"\n    從標準輸入讀取資料，解析出整數列表，呼叫 singleNumber，並輸出結果。\n    輸入格式示例： nums = [2,2,3,2]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：若包含 'nums ='，則去除前半部\n    if data.startswith(\"nums\"):\n        idx = data.find('=')\n        if idx != -1:\n            list_str = data[idx + 1:].strip()\n        else:\n            list_str = data\n    else:\n        list_str = data\n\n    # 使用 ast.literal_eval 進行安全解析\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # 若直接給的是列表字串，例如 '[1,2,3]'\n        nums = ast.literal_eval(data)\n\n    result = singleNumber(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "success": true,
          "output": "99"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode478.json",
    "problem_index_in_file": 0,
    "title": "Generate Random Point in a Circle",
    "description_snippet": "Given the radius and the position of the center of a circle, implement the function randPoint which ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line by line with comments. Provide steps for class initialization and randPoint generating random point uniformly inside circle. Need random radius sqrt of uniform variable? Steps: generate random angle theta uniformly 0-2π, generate random radius r= sqrt(random_uniform(0,1))*radius. Then compute x = x_center + r*cos(theta), y = y_center + r*sin(theta). Return [x,y]. Use virtual code arrows.\n\nWe produce Start, initialize constructor, fields, etc. Provide stepwise pseudo-code.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 Class Solution // 建立解決方案類別\n→ Step 2: 內部宣告 變數 radius, x_center, y_center // 儲存圓的參數\n→ Decision: 建構子已呼叫? // 檢查是否進入初始化\n    Yes → Step 3: Solution(radius, x_center, y_center) → \n        → Step 4: 將傳入的 radius 儲存為 this.radius // 記錄半徑\n        → Step 5: 將傳入的 x_center 儲存為 this.x_center // 記錄中心 x 座標\n        → Step 6: 將傳入的 y_center 儲存為 this.y_center // 記錄中心 y 座標\n        → End // 建構子完成\n→ Step 7: 定義 方法 randPoint() // 產生隨機點的函式\n→ Step 8: 產生 隨機數 u ∈ [0,1) // 用於生成半徑\n→ Step 9: 計算 r = sqrt(u) * this.radius // 調整半徑以確保均勻分佈\n→ Step 10: 產生 隨機數 θ ∈ [0, 2π) // 用於產生角度\n→ Step 11: 計算 x = this.x_center + r * cos(θ) // 根據極座標計算 x\n→ Step 12: 計算 y = this.y_center + r * sin(θ) // 根據極座標計算 y\n→ Step 13: 回傳 [x, y] // 回傳隨機點\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    \"\"\"\n    圓形內隨機點生成器\n    \"\"\"\n    def __init__(self, radius, x_center, y_center):\n        # 儲存圓的半徑和中心座標\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        \"\"\"\n        產生圓內均勻分布的隨機點\n        1. 先產生一個 0~1 的隨機數 u\n        2. 令 r = sqrt(u) * radius，這樣 r 的分布才是均勻的\n        3. 產生角度 θ 均勻分布於 [0, 2π)\n        4. 轉換回笛卡兒座標\n        \"\"\"\n        u = random.random()                    # 0 <= u < 1\n        r = self.radius * math.sqrt(u)          # 半徑\n        theta = random.uniform(0, 2 * math.pi)  # 角度\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 第一行: 指令列表, 第二行: 參數列表\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # 建構子呼叫\n            obj = Solution(*args)\n            results.append(None)  # 代表 null\n        else:\n            # 其他方法呼叫\n            if cmd == \"randPoint\":\n                res = obj.randPoint()\n                results.append(res)\n            else:\n                # 若有其他方法可自行擴充\n                results.append(None)\n\n    # 輸出結果，使用 json.dumps 以得到 null 而非 None\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.3559113486896354,0.5532746640702053],[-0.17400116165521698,-0.03163684261025273],[-0.9473421938322872,-0.16644470203959214]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.3559113486896354, 0.5532746640702053], [-0.17400116165521698, -0.03163684261025273], [-0.9473421938322872, -0.16644470203959214]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode77.json",
    "problem_index_in_file": 0,
    "title": "Combinations",
    "description_snippet": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating combinations. It's backtracking. Use recursive function to build combinations. Step by step. Format lines with virtual code steps: Start, then maybe variable declarations, recursion. Provide explanation. Ensure each line ends with `//` explanation. Use arrow `→`. Use decision structure. We need to output lines in order. Let's craft:\n\nStart // program start\n→ Declare n, k // input integers\n→ Declare result as empty list // to store combos\n→ Define function backtrack(start, combo) // recursive helper\n    → Decision: if length of combo == k? // base case\n        Yes → Add copy of combo to result // store combination\n        No  → Decision: if start > n? // no more numbers\n            Yes → Return // end recursion\n            No  → For i from start to n\n                → Add i to combo // include number\n                → Call backtrack(i+1, combo) // recurse with next start\n                → Remove last from combo // backtrack\n→ Call backtrack(1, empty list) // initiate recursion\n→ Return result // output combinations\nEnd // program end\n\nNeed to format each line with virtual code and explanation. Ensure each line has `[空格]` between step and `//`. Use proper arrow syntax. Let's produce.\n\nAlso need to use the format: `→ Step 1: ...` but we can adapt. Let's produce lines:\n\nStart // 程式開始執行\n→ 輸入 n, k // 取得範圍上限與組合長度\n→ 初始化 result 為空清單 // 用於儲存所有組合\n→ 定義函式 backtrack(start, combo) // 參數: 下一個可選數字與目前組合\n    → Decision: 若 combo 長度等於 k? // 檢查是否已組完\n        Yes → 將 combo 的複本加入 result // 完整組合加入結果\n        No  → Decision: 若 start > n? // 檢查是否已超出範圍\n            Yes → Return // 結束此分支\n            No  → 循環 i 從 start 到 n\n                → 將 i 加入 combo // 先選擇 i\n                → backtrack(i+1, combo) // 以下一個數字為起點遞迴\n                → 從 combo 刪除最後一個 // 退回到上一層\n→ 呼叫 backtrack(1, 空清單) // 從 1 開始遞迴\n→ 回傳 result // 將所有組合返回\nEnd // 程式執行結束\n\nNeed to maintain arrow lines: use \"→\". For nested lines, indent accordingly. Use indentation maybe with spaces. Ensure each line ends with explanation. Provide each line separately. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ 輸入 n, k // 取得範圍上限與組合長度  \n→ 初始化 result 為空清單 // 用於儲存所有組合  \n→ 定義函式 backtrack(start, combo) // 參數: 下一個可選數字與目前組合  \n  → Decision: 若 combo 長度等於 k? // 檢查是否已組完  \n    Yes → 將 combo 的複本加入 result // 完整組合加入結果  \n    No  → Decision: 若 start > n? // 檢查是否已超出範圍  \n      Yes → Return // 結束此分支  \n      No  → 循環 i 從 start 到 n  \n        → 將 i 加入 combo // 先選擇 i  \n        → backtrack(i+1, combo) // 以下一個數字為起點遞迴  \n        → 從 combo 刪除最後一個 // 退回到上一層  \n→ 呼叫 backtrack(1, 空清單) // 從 1 開始遞迴  \n→ 回傳 result // 將所有組合返回  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef combine(n: int, k: int):\n    \"\"\"\n    Generate all combinations of k numbers from 1 to n.\n    \"\"\"\n    res = []\n\n    def backtrack(start: int, path: list):\n        # Base case: when the current combination has length k\n        if len(path) == k:\n            res.append(path[:])          # add a copy of the current path\n            return\n        # Iterate through the remaining numbers\n        for i in range(start, n + 1):\n            path.append(i)               # choose number i\n            backtrack(i + 1, path)       # recurse with next start\n            path.pop()                   # backtrack to explore other options\n\n    backtrack(1, [])\n    return res\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read()\n\n    # Extract integers from the input (e.g., \"n = 4, k = 2\")\n    nums = list(map(int, re.findall(r'\\d+', data)))\n\n    # Expect at least two numbers: n and k\n    if len(nums) >= 2:\n        n, k = nums[0], nums[1]\n        result = combine(n, k)\n        print(result)\n    else:\n        # If input is malformed, output an empty list\n        print([])",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4, k = 2",
          "expected_output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
          "success": true,
          "output": "[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode365.json",
    "problem_index_in_file": 0,
    "title": "Water and Jug Problem",
    "description_snippet": "You are given two jugs with capacities x liters and y liters. You have an infinite water supply. Ret...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the water jug problem. We must use Start, Decision, etc. Provide line-by-line with explanation comments. Should not output actual code. The algorithm: Use GCD method: If target <= max(x,y) and target % gcd(x,y)==0 return true else false. But also if target > x+y impossible. So we produce steps:\n\nStart\n→ Input x, y, target\n→ Decision: If target == 0 → return true\n→ Decision: If target > x + y → return false\n→ Step: Compute g = gcd(x,y)\n→ Decision: If target % g == 0 → return true else false\n\nWe can also add Euclidean algorithm step. Provide decisions accordingly. So produce virtual code with arrows.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入兩個水壺容量 x, y 以及目標水量 target // 從使用者取得所需參數  \n→ Decision: 是否 target == 0? // 判斷目標為零時可直接滿足  \n    Yes → Step 2: 回傳 true // 零水量總是可達  \n    No → Decision: target 是否大於 x + y? // 超過兩個水壺總容量，無法達成  \n        Yes → Step 3: 回傳 false // 目標水量太大，立即結束  \n        No → Step 4: 計算 g = gcd(x, y) // 取得兩個水壺容量的最大公因數  \n→ Decision: target 是否能被 g 整除? // 目標水量必須是容量最大公因數的倍數  \n    Yes → Step 5: 回傳 true // 能達成，符合 Bézout 定理  \n    No → Step 6: 回傳 false // 無法達成，無法組合成目標水量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canMeasureWater(self, x: int, y: int, target: int) -> bool:\n        # Helper to compute greatest common divisor\n        def gcd(a: int, b: int) -> int:\n            while b:\n                a, b = b, a % b\n            return a\n\n        # If target is 0, we can always achieve it by leaving both jugs empty\n        if target == 0:\n            return True\n\n        # If target exceeds total capacity, it's impossible\n        if target > x + y:\n            return False\n\n        # By Bézout's identity, the target must be a multiple of gcd(x, y)\n        return target % gcd(x, y) == 0\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract all integers (handles negative numbers if ever present)\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 3:\n        # Not enough data; default to False\n        print(\"false\")\n    else:\n        x, y, target = nums[0], nums[1], nums[2]\n        solution = Solution()\n        result = solution.canMeasureWater(x, y, target)\n        print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 3, y = 5, target = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = 2, y = 6, target = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 1, y = 2, target = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode689.json",
    "problem_index_in_file": 0,
    "title": "Maximum Sum of 3 Non-Overlapping Subarrays",
    "description_snippet": "Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Must be line by line with // explanation. Use arrow, Decision, etc. It's an algorithm: find three non-overlapping subarrays of length k with maximum sum. Standard solution: sliding window sums of length k, compute prefix max left and right. Use DP to choose best triple. Let's produce pseudo steps. We must not produce actual code but structure. Provide each line with explanation. Should follow example formatting.\n\nLet's outline algorithm steps:\n\n1. Compute array sums of subarrays of length k (sum[i] for starting index i). O(n). Use sliding window.\n2. Initialize leftBest array: for each i, store index of max sum subarray in [0, i] (choose smallest index in tie). Similarly rightBest for [i, n-k].\n3. Iterate middle index j from k to n-2k. For each j, compute left = leftBest[j-k], right = rightBest[j+k], compute total sum = sum[left]+sum[j]+sum[right].\n4. Track maximum total and best triple indices (left, j, right). On tie, choose lexicographically smallest triple (i.e., earlier left; if equal, earlier middle; if equal, earlier right).\n5. Return best triple.\n\nImplement virtual code lines: Start, compute sums, build leftBest, build rightBest, iterate middle, decision for max, update best, End.\n\nAlso need to handle ties lexicographically.\n\nLet's produce lines accordingly.\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Use arrow \"→\". For loops, use \"For i in range(...):\" but as virtual step. Use \"Decision:\" for if statements. Use \"Yes →\" and \"No →\".\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算所有長度為 k 的子陣列和，存入 sum[0 … n-k] // 用滑動視窗一次取得每個子陣列的總和  \n→ Step 2: 初始化 leftBest[0 … n-k] 為空 // leftBest[i] 將存儲在 0 到 i 之間，和最大的子陣列起始位置（若多個則取最小索引）  \n→ Step 3: For i from 0 to n-k:  \n  → Decision: 如果 i==0? // 第一次迭代  \n    Yes → leftBest[i] = 0 // 第一個子陣列就是最佳  \n    No  → Decision: 如果 sum[i] > sum[leftBest[i-1]]? // 比較目前子陣列和前一次最佳的和  \n      Yes → leftBest[i] = i // 目前子陣列更大，更新最佳索引  \n      No  → Decision: sum[i] == sum[leftBest[i-1]]? // 和相等時  \n       Yes → leftBest[i] = leftBest[i-1] // 取更小索引  \n       No  → leftBest[i] = leftBest[i-1] // 保持前一次最佳  \n→ Step 4: 初始化 rightBest[0 … n-k] 為空 // rightBest[i] 將存儲在 i 到 n-k 之間，和最大的子陣列起始位置（若多個則取最小索引）  \n→ Step 5: For i from n-k down to 0:  \n  → Decision: 如果 i==n-k? // 最後一個位置  \n    Yes → rightBest[i] = i // 末尾子陣列就是最佳  \n    No  → Decision: 如果 sum[i] > sum[rightBest[i+1]]? // 與右邊最佳子陣列比較  \n      Yes → rightBest[i] = i // 目前更大，更新  \n      No  → Decision: sum[i] == sum[rightBest[i+1]]? // 和相等  \n       Yes → rightBest[i] = i // 取更小索引（左側）  \n       No  → rightBest[i] = rightBest[i+1] // 保持右側最佳  \n→ Step 6: 設定 bestSum = -∞, bestTriplet = null // 用於記錄目前最大總和與對應三個起始索引  \n→ Step 7: For j from k to n-2k: // j 作為中間子陣列的起始位置  \n  → leftIdx = leftBest[j-k] // 取得左側最佳子陣列索引  \n  → rightIdx = rightBest[j+k] // 取得右側最佳子陣列索引  \n  → currentSum = sum[leftIdx] + sum[j] + sum[rightIdx] // 計算三個子陣列的總和  \n  → Decision: currentSum > bestSum? // 是否比目前最佳總和更大  \n    Yes → bestSum = currentSum, bestTriplet = [leftIdx, j, rightIdx] // 更新最佳  \n    No  → Decision: currentSum == bestSum? // 同等總和時進行字典序比較  \n      Yes → Decision: [leftIdx, j, rightIdx] lexicographically smaller than bestTriplet?  \n        Yes → bestTriplet = [leftIdx, j, rightIdx] // 更新為更小字典序  \n       No  → // 保持現有最佳  \n→ Step 8: Return bestTriplet // 輸出三個子陣列起始索引的列表  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def maxSumOfThreeSubarrays(self, nums, k):\n        n = len(nums)\n        # 1. Compute sums of all subarrays of length k\n        w = [0] * (n - k + 1)\n        window_sum = sum(nums[:k])\n        w[0] = window_sum\n        for i in range(1, n - k + 1):\n            window_sum += nums[i + k - 1] - nums[i - 1]\n            w[i] = window_sum\n\n        # 2. left[i] = index of max sum subarray in [0, i]\n        left = [0] * len(w)\n        best = 0\n        for i in range(len(w)):\n            if w[i] > w[best]:\n                best = i\n            left[i] = best\n\n        # 3. right[i] = index of max sum subarray in [i, end]\n        right = [0] * len(w)\n        best = len(w) - 1\n        for i in range(len(w) - 1, -1, -1):\n            if w[i] >= w[best]:\n                best = i\n            right[i] = best\n\n        # 4. Find best middle index j\n        best_triplet = None\n        best_total = -1\n        for j in range(k, len(w) - k):\n            i = left[j - k]\n            l = right[j + k]\n            total = w[i] + w[j] + w[l]\n            if total > best_total:\n                best_total = total\n                best_triplet = [i, j, l]\n            elif total == best_total:\n                # lexicographic tie-breaking\n                if [i, j, l] < best_triplet:\n                    best_triplet = [i, j, l]\n        return best_triplet\n\ndef main():\n    data = sys.stdin.read()\n    # Extract nums list and k value using regex\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not k_match:\n        return\n    nums = ast.literal_eval(nums_match.group(1))\n    k = int(k_match.group(1))\n\n    sol = Solution()\n    result = sol.maxSumOfThreeSubarrays(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1,2,6,7,5,1], k = 2",
          "expected_output": "[0,3,5]",
          "success": true,
          "output": "[0, 3, 5]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,1,2,1,2,1,2,1], k = 2",
          "expected_output": "[0,2,4]",
          "success": true,
          "output": "[0, 2, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode680.json",
    "problem_index_in_file": 0,
    "title": "Valid Palindrome II",
    "description_snippet": "Given a string s, return true if the s can be palindrome after deleting at most one character from i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The problem: determine if string can be palindrome after deleting at most one char.\n\nWe need steps: start, left/right pointers, loop, compare, if mismatch: try remove left or right: call helper function to check if substring is palindrome. We can include helper steps or inline logic.\n\nLet's craft a step-by-step algorithm:\n\nStart\n→ Initialize left=0, right=len(s)-1\n→ Decision: while left<right?\n    Yes → Decision: s[left]==s[right]?\n        Yes → left++ right--  // characters match, move inward\n        No → Decision: Check if substring s[left+1:right+1] is palindrome OR s[left:right] is palindrome?\n            Yes → Step: return true // can delete one char to form palindrome\n            No  → Step: return false // cannot\n    No → Step: return true // all matched\nEnd\n\nWe also need a helper: Check palindrome substring: start index a, end index b inclusive? We'll define a function.\n\nBut in virtual code, we can embed the helper as steps. Eg:\n\n→ Function IsPalindrome(a,b):\n    → While a<b:\n        → Decision: s[a]==s[b]?\n            Yes → a++ b--\n            No  → Step: return false\n    → Step: return true\n\nWe can call that.\n\nSo final code lines:\n\nStart\n→ Declare s, left=0, right=len(s)-1\n→ Decision: while left<right?\n    Yes → Decision: s[left]==s[right]?\n        Yes → left++ right--  // characters match\n        No → Decision: IsPalindrome(left+1, right)?\n            Yes → Step: return true  // delete s[left]\n            No  → Decision: IsPalindrome(left, right-1)?\n                Yes → Step: return true  // delete s[right]\n                No  → Step: return false  // cannot\n    No → Step: return true  // string already palindrome\nEnd\n\nAnd helper function:\n\n→ Function IsPalindrome(a, b):\n    → While a<b:\n        → Decision: s[a]==s[b]?\n            Yes → a++ b--\n            No → Step: return false\n    → Step: return true\n\nWe should include explanatory comments.\n\nLet's produce lines accordingly. Use the format: `虛擬碼步驟 // 解釋/說明`. Use arrows. Use Decision: etc. Use Yes →, No →.\n\nMake sure to indent properly: We can represent indentation by spaces.\n\nWe must not output real code. Provide virtual steps only.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Declare s, left = 0, right = len(s) - 1 // 初始化指標  \n→ Decision: while left < right? // 只要左右指標未相遇就持續比對  \n    Yes → Decision: s[left] == s[right]? // 檢查當前字符是否相同  \n        Yes → left++ right-- // 兩端相同，指標向內移動  \n        No  → Decision: IsPalindrome(left + 1, right)? // 先嘗試刪除左側字符  \n            Yes → Step: return true // 刪除後仍為回文，符合條件  \n            No  → Decision: IsPalindrome(left, right - 1)? // 再嘗試刪除右側字符  \n                Yes → Step: return true // 刪除右側字符後為回文  \n                No  → Step: return false // 兩種刪除方式皆不行，不能成回文  \n    No  → Step: return true // 所有字符已配對，原字符串即為回文  \nEnd // 程式執行結束  \n\n→ Function IsPalindrome(a, b) // 檢查子串 s[a..b] 是否為回文  \n    → While a < b: // 從外向內比較  \n        → Decision: s[a] == s[b]? // 比較左右字符  \n            Yes → a++ b-- // 匹配則繼續向內  \n            No  → Step: return false // 不匹配，非回文  \n    → Step: return true // 所有字符匹配，為回文",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        \"\"\"Return True if s can become a palindrome after deleting at most one character.\"\"\"\n        def is_palindrome_range(i: int, j: int) -> bool:\n            \"\"\"Check if the substring s[i:j+1] is a palindrome.\"\"\"\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n\n        i, j = 0, len(s) - 1\n        while i < j:\n            if s[i] != s[j]:\n                # try deleting either the left or the right character\n                return is_palindrome_range(i + 1, j) or is_palindrome_range(i, j - 1)\n            i += 1\n            j -= 1\n        return True\n\ndef extract_string(data: str) -> str:\n    \"\"\"從輸入中提取字符串值，支持格式如 s = \"abc\" 或直接輸入 abc。\"\"\"\n    # 首先嘗試找到雙引號包圍的內容\n    m = re.search(r'\"([^\"]*)\"', data)\n    if m:\n        return m.group(1)\n    # 再嘗試單引號\n    m = re.search(r\"'([^']*)'\", data)\n    if m:\n        return m.group(1)\n    # 如果沒有引號，直接使用整行去除前後空白\n    return data.strip()\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    s = extract_string(raw_input)\n\n    sol = Solution()\n    ans = sol.validPalindrome(s)\n\n    # 根據題目輸出小寫的 true/false\n    print(str(ans).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aba\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"abca\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"abc\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode730.json",
    "problem_index_in_file": 0,
    "title": "Count Different Palindromic Subsequences",
    "description_snippet": "Given a string s, return the number of different non-empty palindromic subsequences in s. Since the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for counting distinct non-empty palindromic subsequences, typical DP. Use DP[i][j] count in s[i..j]. Recurrence: if s[i]==s[j], then DP[i][j] = DP[i+1][j] + DP[i][j-1] + 1; else DP[i][j] = DP[i+1][j] + DP[i][j-1] - DP[i+1][j-1]. But for distinct palindromes with duplicates need handling of duplicates: use next and prev arrays or DP with first/last occurrence. Standard solution: DP[i][j] counts distinct palindromic subsequences in s[i..j]. If s[i]==s[j], find next_i = next occurrence of s[i] after i, prev_j = prev occurrence of s[j] before j. If next_i > prev_j (no same char inside), add 2. If next_i == prev_j (one same inside), add 1. Else add 2 + DP[next_i+1][prev_j-1]. So recurrence: DP[i][j] = DP[i+1][j] + DP[i][j-1] + 1 when s[i]==s[j] and no duplicate inside. etc. Let's produce algorithm with DP and precompute next and prev indices. Complexity O(n^2). Use mod.\n\nWe'll produce virtual code lines step by step.\n\nLet's craft steps: Start, read s, n = len(s). Initialize next array of size n with -1, prev array with -1. Compute next by traversing from end. Compute prev by traversing from start. Create DP 2D array (list of lists) maybe using list comprehension. Loop length from 1 to n. For each i from n-1 down to 0, j = i + len -1 < n. For each pair compute according to rules.\n\nWe'll produce each step with comment.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 取得需要處理的字串  \n→ Step 2: 設定 n = s.length // 取得字串長度  \n→ Step 3: 建立 next[0..n-1] 與 prev[0..n-1] 並初始化為 -1 // 用來記錄每個字符下一個與上一個出現的位置  \n→ Step 4: 從右至左遍歷 s，更新 next[i] 為 i 之後最近一次出現相同字符的位置  \n    → For i from n-1 down to 0  \n        → Step 5: 如果已存在相同字符的記錄，將 next[i] 設為該記錄位置，否則保持 -1  \n        → Step 6: 將 current_char 的最新位置更新為 i  \n→ Step 7: 從左至右遍歷 s，更新 prev[i] 為 i 之前最近一次出現相同字符的位置  \n    → For i from 0 to n-1  \n        → Step 8: 如果已存在相同字符的記錄，將 prev[i] 設為該記錄位置，否則保持 -1  \n        → Step 9: 將 current_char 的最新位置更新為 i  \n→ Step 10: 建立 dp[n][n] 並初始化為 0 // dp[i][j] 代表子字串 s[i..j] 的不同回文子序列數  \n→ Step 11: 對於 length 1 到 n，計算 dp[i][j]  \n    → Decision: length = 1? // 單字母子字串  \n        → Yes → Step 12: 設定 dp[i][i] = 1 // 單字母本身即為一個回文子序列  \n        → No  \n            → Step 13: 設定 i = n - length  \n            → Step 14: 設定 j = i + length - 1  \n            → Step 15: 如果 s[i] != s[j]  \n                → Decision: s[i] != s[j]?  \n                    → Yes → Step 16: dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]) mod MOD // 加減重疊計算  \n                    → No  \n                        → Step 17: 找到 next_i = next[i] 與 prev_j = prev[j]  \n                        → Decision: next_i > prev_j? // 內部沒有相同字符  \n                            → Yes → Step 18: dp[i][j] = (dp[i+1][j] + dp[i][j-1] + 1) mod MOD // 兩端字符相同，內部無重複 → +2? (實際為 +1 但因 dp[i+1][j] + dp[i][j-1] 包含 dp[i+1][j-1]，需 +1)  \n                            → No → Decision: next_i == prev_j? // 內部只有一個相同字符  \n                                → Yes → Step 19: dp[i][j] = (dp[i+1][j] + dp[i][j-1] + 1) mod MOD // 內部只有一個 → +1  \n                                → No → Step 20: dp[i][j] = (dp[i+1][j] + dp[i][j-1] + dp[next_i+1][prev_j-1] + 1) mod MOD // 內部有多個 → +2 + inner  \n→ Step 21: 結果為 dp[0][n-1] mod MOD // 最長子字串的計算結果  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # next occurrence of each character after position i\n    next_idx = [-1] * n\n    last_pos = {}\n    for i in range(n - 1, -1, -1):\n        c = s[i]\n        next_idx[i] = last_pos.get(c, -1)\n        last_pos[c] = i\n\n    # previous occurrence of each character before position i\n    prev_idx = [-1] * n\n    last_pos.clear()\n    for i in range(n):\n        c = s[i]\n        prev_idx[i] = last_pos.get(c, -1)\n        last_pos[c] = i\n\n    # dp[i][j] : number of distinct palindromic subsequences in s[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1  # single character\n\n    for length in range(2, n + 1):\n        for i in range(0, n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                l = next_idx[i]\n                r = prev_idx[j]\n                if l > r:  # no same character inside\n                    val = (dp[i + 1][j - 1] * 2 + 2) % MOD\n                elif l == r:  # exactly one same character inside\n                    val = (dp[i + 1][j - 1] * 2 + 1) % MOD\n                else:  # more than one same character inside\n                    val = (dp[i + 1][j - 1] * 2 - dp[l + 1][r - 1]) % MOD\n                dp[i][j] = val\n            else:\n                val = (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]) % MOD\n                dp[i][j] = val\n\n    return dp[0][n - 1] % MOD\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract only alphabetic characters, ignore quotes or other characters\n    s = re.sub(r'[^a-zA-Z]', '', data)\n    result = count_palindromic_subsequences(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '7'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '7'"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '104860361'\nGot (Norm):      '104860362'\n--- (Raw) ---\nRaw Expected: '104860361'\nRaw Got:      '104860362'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode5.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Substring",
    "description_snippet": "Given a string s, return the longest palindromic substring in s....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for finding longest palindromic substring. Must follow format: each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Use arrows. Step numbers etc. Need to produce line-by-line. Should be conceptual, not actual code. Should include steps: Input string, initialize variables, loop over centers, expand, track max length. We can use decision to compare. Let's design:\n\nStart\n→ Step 1: 接收輸入字符串 s\n→ Step 2: 初始化變數 maxStart = 0, maxLen = 0 // 追蹤最大回文起始位置和長度\n→ Decision: 如果 s 為空? \n    Yes → Step 3: 返回空字符串 // 空輸入直接返回\n    No  → Step 4: 設定 n = s.length // 字串長度\n→ Step 5: 循環 i 從 0 到 n-1 // 遍歷每個字符作為中心\n    → Decision: 檢查回文子串以 i 為單一中心 (odd length)\n        Yes → Step 6: 擴展左 = i, 右 = i // 初始化左右指針\n            → Step 7: while 左 >= 0 且 右 < n 且 s[左] == s[右]\n                → Step 8: 左 -= 1; 右 += 1 // 擴大回文\n            → Step 9: 計算長度 = 右 - 左 - 1\n            → Decision: 如果 長度 > maxLen?\n                Yes → Step 10: 更新 maxStart = 左 + 1; maxLen = 長度\n                No  → Step 11: // 不更新\n    → Decision: 檢查回文子串以 i, i+1 為中心 (even length)\n        Yes → Step 12: 擴展左 = i, 右 = i + 1\n            → Step 13: while 左 >= 0 且 右 < n 且 s[左] == s[右]\n                → Step 14: 左 -= 1; 右 += 1\n            → Step 15: 計算長度 = 右 - 左 - 1\n            → Decision: 如果 長度 > maxLen?\n                Yes → Step 16: 更新 maxStart = 左 + 1; maxLen = 長度\n                No  → Step 17: // 不更新\n→ Step 18: 返回 s.substring(maxStart, maxStart + maxLen) // 提取最大回文子串\nEnd // 程式結束\n\nWe need each line with \"虛擬碼步驟 // 解釋\". Let's format accordingly.\n\nBe careful with indentation maybe. Use spaces? The example uses spaces after arrow. We'll follow.\n\nWe need \"Start\" and \"End\". Use decision blocks with indentation. Provide explanation each line.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收輸入字符串 s // 從使用者取得待分析的字串\n→ Step 2: 初始化變數 maxStart = 0, maxLen = 0 // 用於記錄目前已發現的最大回文子串起始位置與長度\n→ Decision: 如果 s 為空? // 判斷輸入是否為空字串\n    Yes → Step 3: 返回空字符串 // 空輸入直接回傳空字串\n    No  → Step 4: 設定 n = s.length // 取得字串長度\n→ Step 5: 循環 i 從 0 到 n-1 // 對每個字符視為可能的回文中心\n    → Decision: 檢查以 i 為單一中心的奇數長度回文\n        Yes → Step 6: 擴展左 = i, 右 = i // 初始化左右指針為中心\n            → Step 7: while 左 >= 0 且 右 < n 且 s[左] == s[右]\n                → Step 8: 左 -= 1; 右 += 1 // 兩側字符相同則繼續向外擴大\n            → Step 9: 計算長度 = 右 - 左 - 1 // 擴展結束後計算得到的回文長度\n            → Decision: 如果 長度 > maxLen?\n                Yes → Step 10: 更新 maxStart = 左 + 1; maxLen = 長度 // 找到更長的回文，更新記錄\n                No  → Step 11: // 目前回文不比最大長度更長，保持現有記錄\n    → Decision: 檢查以 i, i+1 為中心的偶數長度回文\n        Yes → Step 12: 擴展左 = i, 右 = i + 1 // 初始化左右指針為兩個相鄰字符\n            → Step 13: while 左 >= 0 且 右 < n 且 s[左] == s[右]\n                → Step 14: 左 -= 1; 右 += 1 // 向外擴大至兩側字符不相等\n            → Step 15: 計算長度 = 右 - 左 - 1 // 取得偶數長度回文的長度\n            → Decision: 如果 長度 > maxLen?\n                Yes → Step 16: 更新 maxStart = 左 + 1; maxLen = 長度 // 發現更長偶數回文，更新記錄\n                No  → Step 17: // 當前偶數回文不超過最大長度，保持現有記錄\n→ Step 18: 返回 s.substring(maxStart, maxStart + maxLen) // 根據記錄的起始位置與長度擷取最大回文子串\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if not s:\n            return \"\"\n\n        max_start, max_len = 0, 0\n        n = len(s)\n\n        for i in range(n):\n            # Odd length palindrome (center at i)\n            l, r = i, i\n            while l >= 0 and r < n and s[l] == s[r]:\n                l -= 1\n                r += 1\n            cur_len = r - l - 1\n            if cur_len > max_len:\n                max_start, max_len = l + 1, cur_len\n\n            # Even length palindrome (center between i and i+1)\n            l, r = i, i + 1\n            while l >= 0 and r < n and s[l] == s[r]:\n                l -= 1\n                r += 1\n            cur_len = r - l - 1\n            if cur_len > max_len:\n                max_start, max_len = l + 1, cur_len\n\n        return s[max_start:max_start + max_len]\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    Parse input that may look like \"s = 'babad'\" or just \"'babad'\" or\n    without quotes like babad.\n    \"\"\"\n    raw = raw.strip()\n    # Remove leading \"s =\" if present\n    if raw.lower().startswith(\"s =\"):\n        raw = raw[3:].lstrip()\n    # Extract string within single or double quotes\n    m = re.search(r\"\"\"['\"]([^'\"]*)['\"]\"\"\", raw)\n    if m:\n        return m.group(1)\n    # If no quotes, return raw as is\n    return raw\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s = parse_input(data)\n    sol = Solution()\n    result = sol.longestPalindrome(s)\n    # Output with surrounding single quotes as shown in examples\n    print(f\"'{result}'\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'babad'",
          "expected_output": "'bab'",
          "success": true,
          "output": "'bab'"
        },
        {
          "example_index": 1,
          "input": "s = 'cbbd'",
          "expected_output": "'bb'",
          "success": true,
          "output": "'bb'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode454.json",
    "problem_index_in_file": 0,
    "title": "4Sum II",
    "description_snippet": "Given four integer arrays A, B, C, and D all of length n, return the number of tuples (i, j, k, l) s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm. Problem: 4-sum count using hashing. Steps: compute sums of A+B store counts. Then iterate over C+D and sum to zero. Count matches.\n\nWe output lines with virtual code and comments. Use Start, Decision, etc. Each line must be \"虛擬碼步驟 [space] // 解釋/說明\". We'll produce line by line.\n\nLet's produce steps:\n\nStart\n→ Step 1: Read integer n, arrays A, B, C, D // Input length and arrays\n→ Step 2: Create empty map ABCount // map from sum to frequency\n→ Decision: If n == 0? // handle empty arrays\n    Yes → Step 3: Output 0 and End // no tuples\n    No  → Step 4: For i from 0 to n-1 // iterate A\n            For j from 0 to n-1 // iterate B\n                sumAB = A[i] + B[j]\n                If sumAB in ABCount? // update frequency\n                    ABCount[sumAB] += 1\n                Else\n                    ABCount[sumAB] = 1\n→ Step 5: Initialize result = 0 // count tuples\n→ Step 6: For k from 0 to n-1 // iterate C\n            For l from 0 to n-1 // iterate D\n                sumCD = C[k] + D[l]\n                target = -sumCD\n                If target in ABCount? // check\n                    result += ABCount[target]\n→ Step 7: Output result\nEnd\n\nWe need to use virtual code arrow format. The sample shows \"→ Step 1: ...\" etc. Use arrow. For loops we can use \"→ Loop: i from 0 to n-1\" etc. Use Decision blocks.\n\nLet's craft each line. Use consistent formatting.\n\nAlso we might include indentation for decisions: e.g., \"Decision: If n == 0?\" Then \"Yes → ...\", \"No → ...\".\n\nWe should keep each line with a single virtual step. For loops might be represented as step, but we can just treat as \"Step: For each i in 0..n-1\". We don't need separate loops.\n\nBut the sample uses \"→ Decision:\" block and inside yes/no lines.\n\nSo produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取 n, A, B, C, D // 取得輸入\n→ Step 2: 建立空哈希表 ABCount // 用於存儲 A+B 的頻率\n→ Decision: n == 0? // 檢查是否為空\n    Yes → Step 3: 輸出 0 // 沒有任何元組\n    No  → Step 4: 建立 ABCount\n    → Step 4.1: 從 i=0 到 n-1\n        → Step 4.2: 從 j=0 到 n-1\n            sumAB = A[i] + B[j]\n            → Decision: sumAB in ABCount?\n                Yes → ABCount[sumAB] += 1 // 已有，頻率加 1\n                No  → ABCount[sumAB] = 1   // 新增，頻率設為 1\n→ Step 5: result = 0 // 初始化答案\n→ Step 6: 從 k=0 到 n-1\n    → Step 6.1: 從 l=0 到 n-1\n        sumCD = C[k] + D[l]\n        target = -sumCD\n        → Decision: target in ABCount?\n            Yes → result += ABCount[target] // 加上對應頻率\n            No  → // 無對應，跳過\n→ Step 7: 輸出 result // 回傳元組數量\nEnd // 程式執行結束\n\nBut we need each line separate. However we used nested lines with indentation. Should we produce each as a line. Use \"→\" arrow. We can produce like:\n\n→ Step 4.1: For i in 0..n-1 // 循環 A\n→ Step 4.2: For j in 0..n-1 // 循環 B\nBut we need the lines sequentially.\n\nSimplify: Use sequential lines but maintain indentation maybe not required. We'll produce each line as a separate step.\n\nLet's produce final output with lines. Use consistent pattern: \"→ Step X: ...\" each line ends with // comment.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取 n, A, B, C, D // 取得輸入\n→ Step 2: 建立空哈希表 ABCount // 用於存儲 A+B 的頻率\n→ Decision: n == 0? // 檢查是否為空\n    Yes → Step 3: 輸出 0 // 沒有任何元組\n    No  → Step 4: 建立 ABCount\n→ Step 4.1: 從 i = 0 到 n-1 // 迭代 A\n→ Step 4.2: 從 j = 0 到 n-1 // 迭代 B\n→ Step 4.3: sumAB = A[i] + B[j] // 計算 A[i]+B[j]\n→ Decision: sumAB in ABCount? // 檢查是否已存在\n    Yes → ABCount[sumAB] += 1 // 已存在，頻率加 1\n    No  → ABCount[sumAB] = 1   // 新增，頻率設為 1\n→ Step 5: result = 0 // 初始化答案\n→ Step 5.1: 從 k = 0 到 n-1 // 迭代 C\n→ Step 5.2: 從 l = 0 到 n-1 // 迭代 D\n→ Step 5.3: sumCD = C[k] + D[l] // 計算 C[k]+D[l]\n→ Step 5.4: target = -sumCD // 需要匹配的 A+B 和\n→ Decision: target in ABCount? // 檢查是否存在\n    Yes → result += ABCount[target] // 加上對應頻率\n    No  → // 無對應，跳過\n→ Step 6: 輸出 result // 回傳元組數量\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中抓取 4 個整數陣列。  \n    以 '[' 和 ']' 為界，取得括號內的內容，並轉換為 int 陣列。\n    \"\"\"\n    # 取得所有 [ ... ] 裡的內容\n    raw_lists = re.findall(r'\\[([^\\]]*)\\]', data)\n    arrays = []\n    for raw in raw_lists:\n        # 空陣列情況\n        if not raw.strip():\n            arrays.append([])\n            continue\n        # 以 ',' 分割並轉成 int\n        arrays.append([int(x.strip()) for x in raw.split(',')])\n    # 期望拿到 4 個陣列，若輸入格式錯誤則補空陣列\n    while len(arrays) < 4:\n        arrays.append([])\n    return arrays[0], arrays[1], arrays[2], arrays[3]\n\ndef four_sum_count(A, B, C, D):\n    \"\"\"\n    計算所有 (i, j, k, l) 使得 A[i] + B[j] + C[k] + D[l] == 0 的個數。\n    \"\"\"\n    # 先把 A + B 的所有可能和統計個數\n    ab_counter = Counter(a + b for a in A for b in B)\n    total = 0\n    # 再對每個 C[k] + D[l] 取負值，查看是否存在於 ab_counter\n    for c in C:\n        for d in D:\n            target = -(c + d)\n            total += ab_counter.get(target, 0)\n    return total\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    A, B, C, D = parse_input(data)\n    result = four_sum_count(A, B, C, D)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "A = [0], B = [0], C = [0], D = [0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode50.json",
    "problem_index_in_file": 0,
    "title": "Pow(x, n)",
    "description_snippet": "Implement pow(x, n), which calculates x raised to the power n (i.e., x^n)....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for pow(x,n) algorithm. We should describe algorithm step-by-step with decision nodes. Likely iterative fast exponentiation (exponentiation by squaring). Provide Start, then handle negative exponent? But not specified. Maybe just implement for integer n >= 0. But could include negative. Let's produce generic: if n < 0, compute reciprocal.\n\nWe need each line: virtual code step + // explanation.\n\nUse arrow for steps. Format: `Start // 程式開始執行`. Then arrow lines.\n\nWe'll produce lines like `→ Step 1: result ← 1 // 初始化結果為 1`. Then handle base case.\n\nDecision: if n == 0? then return 1. But we can just iterate. We can do while n > 0 loop.\n\nImplement: \n- Step: base ← x, exponent ← n, result ← 1.\n- Decision: while exponent > 0.\n- Inside loop: Decision: if exponent mod 2 == 1? -> result ← result * base.\n- base ← base * base.\n- exponent ← exponent / 2 (integer division).\n- End while.\n- Decision: if original n was negative? -> result ← 1 / result.\n- End.\n\nNeed to maintain original n sign.\n\nLet's produce:\n\nStart\n→ Step 1: negative ← (n < 0) // 判斷指數是否為負\n→ Step 2: if negative then n ← -n // 取正數以便計算\n→ Step 3: result ← 1 // 初始化結果\n→ Step 4: base ← x // 設定初始底數\n→ Decision: 是否有剩餘指數? // 判斷 n 是否大於 0\n    Yes → Step 5: if (n mod 2 == 1) → result ← result * base // 若指數為奇數，乘以底數\n        Yes → Step 6: base ← base * base // 底數平方\n        Yes → Step 7: n ← n // integer division by 2\n            Yes → // loop back to Decision\n    No  → // n 已為 0，結束循環\n→ Decision: 若原來是負指數? // 若是負指數，取倒數\n    Yes → Step 8: result ← 1 / result // 求倒數\n    No  → // 不做任何事\nEnd\n\nWe need to ensure format uses arrow and decision labels. Use proper indentation.\n\nMake sure each line ends with // 解釋.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: negative ← (n < 0) // 判斷指數是否為負  \n→ Step 2: if negative then n ← -n // 取正數以便後續計算  \n→ Step 3: result ← 1 // 初始化結果  \n→ Step 4: base ← x // 設定初始底數  \n→ Decision: 是否有剩餘指數? // 判斷 n 是否大於 0  \n  Yes → Step 5: if (n mod 2 == 1) → result ← result * base // 若指數為奇數，乘以底數  \n    Yes → Step 6: base ← base * base // 底數平方  \n    Yes → Step 7: n ← n // integer division by 2 (n ← n / 2)  \n    Yes → // 迴圈回到 Decision  \n  No  → // n 已為 0，結束循環  \n→ Decision: 若原來是負指數? // 若是負指數，取倒數  \n  Yes → Step 8: result ← 1 / result // 求倒數  \n  No  → // 不做任何事  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        \"\"\"\n        快速冪演算法：使用指數平方法\n        \"\"\"\n        if n == 0:\n            return 1.0\n        # 若 n 為負數，先把 x 取倒數，並把 n 取正\n        if n < 0:\n            x = 1.0 / x\n            n = -n\n\n        result = 1.0\n        while n > 0:\n            # 若 n 為奇數，將目前的 x 乘進結果\n            if n & 1:\n                result *= x\n            # x 進行平方\n            x *= x\n            # n 除以 2\n            n >>= 1\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析出 x 與 n\n    支援類似 'x = 2.00000, n = 10' 的格式\n    \"\"\"\n    # 取出所有數字（含小數點、負號）\n    nums = re.findall(r'[-+]?\\d*\\.?\\d+', data)\n    if len(nums) < 2:\n        raise ValueError(\"輸入格式不正確，需包含 x 與 n。\")\n    x = float(nums[0])\n    n = int(float(nums[1]))  # n 本身應為整數\n    return x, n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    x, n = parse_input(data)\n    sol = Solution()\n    ans = sol.myPow(x, n)\n    # 按範例輸出五位小數\n    print(f\"{ans:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 2.00000, n = 10",
          "expected_output": "1024.00000",
          "success": true,
          "output": "1024.00000"
        },
        {
          "example_index": 1,
          "input": "x = 2.10000, n = 3",
          "expected_output": "9.26100",
          "success": true,
          "output": "9.26100"
        },
        {
          "example_index": 2,
          "input": "x = 2.00000, n = -2",
          "expected_output": "0.25000",
          "success": true,
          "output": "0.25000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode8.json",
    "problem_index_in_file": 0,
    "title": "String to Integer (atoi)",
    "description_snippet": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\n\nThe al...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, each line: \"虛擬碼步驟 // 解釋\". Use arrows and Decision etc. So we need to show steps for myAtoi. We'll produce Start, Step 1, Decision for whitespace skip, Step 2 sign detection, Decision for sign, Step 3 conversion loop, maybe loop arrow. Use Decision for digit? etc. At the end clamp to 32-bit. Then End. Use appropriate format. Use Chinese. Ensure each line has code and comment. Let's do.\n\nWe need to mention \"String s\" variable. Steps: assign index=0. Skip leading whitespace. Check sign. Set sign variable. Then parse digits: while char is digit, accumulate number, but avoid overflow by checking before multiply. Then clamp. Then multiply by sign. Return. So produce virtual steps.\n\nWe'll use Start, Step: initialize, Decision: skip whitespace? Use while. Use arrows: → Step. Use indent for nested decisions.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: index ← 0 // 初始化索引指向字串首位  \n→ Step 2: number ← 0 // 用於累積數字的暫存變數  \n→ Step 3: sign ← +1 // 預設為正號  \n→ Decision: 是否有前導空白? // 檢查是否需要跳過空白字符  \n Yes → Step 4: index ← index + 1 // 跳過一個空白字符  \n  → Decision: 仍為空白? // 繼續檢查剩餘空白  \n   Yes → Go to Step 4  \n   No  → Go to Step 5  \n No  → Go to Step 5  \n→ Step 5: Decision: s[index] 為 '-' 或 '+'? // 判斷符號  \n Yes → Step 6: 如果 s[index] 為 '-'，則 sign ← -1  \n  → Step 7: index ← index + 1 // 讀取完符號後移動索引  \n  → Go to Step 8  \n No  → Step 8 // 若不是符號，保持預設正號  \n→ Step 8: Decision: s[index] 為數位 0~9? // 判斷是否存在可轉換的數字  \n Yes → Step 9: number ← number * 10 + (s[index] - '0') // 累積數字  \n  → Decision: 檢查越界? // 先預測下一步是否會超出 32 位整數範圍  \n   Yes → Step 10: 如果 sign = +1，number ← 2^31 - 1；否則 number ← 2^31 // 截斷至合法範圍  \n    No → Step 11: index ← index + 1 // 移動到下一個字符  \n    → Go to Step 8 // 重新判斷是否還有數位  \n No  → Step 12: number ← number * sign // 應用符號  \n  → Go to Step 13  \n→ Step 11: Go to Step 8 // 循環處理所有數位  \n→ Step 12: number ← number * sign // 把符號應用到累積結果  \n→ Step 13: Return number // 回傳最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        \"\"\"\n        Convert a string to a 32-bit signed integer according to the rules of LeetCode 8.\n        \"\"\"\n        # Step 1: remove leading whitespace\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        # Step 2: determine sign\n        sign = 1\n        index = 0\n        if s[0] == '+':\n            index += 1\n        elif s[0] == '-':\n            sign = -1\n            index += 1\n\n        # Step 3: convert digits\n        result = 0\n        while index < len(s) and s[index].isdigit():\n            result = result * 10 + int(s[index])\n            index += 1\n\n        # Apply sign\n        result *= sign\n\n        # Step 4: clamp to 32-bit signed integer range\n        INT_MAX = 2 ** 31 - 1\n        INT_MIN = -2 ** 31\n        if result < INT_MIN:\n            return INT_MIN\n        if result > INT_MAX:\n            return INT_MAX\n\n        return result\n\ndef extract_string_from_input(input_text: str) -> str:\n    \"\"\"\n    Extract the first quoted substring from the input text.\n    If no quotes are found, return the stripped input as is.\n    \"\"\"\n    match = re.search(r'\"(.*?)\"', input_text)\n    if match:\n        return match.group(1)\n    # If there are no quotes, assume the whole input is the string\n    return input_text.strip()\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    # Extract the string that should be converted\n    s = extract_string_from_input(raw_input)\n    # Perform conversion\n    solution = Solution()\n    result = solution.myAtoi(s)\n    # Print the result\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"42\"",
          "expected_output": "42",
          "success": true,
          "output": "42"
        },
        {
          "example_index": 1,
          "input": "s = \" -042\"",
          "expected_output": "-42",
          "success": true,
          "output": "-42"
        },
        {
          "example_index": 2,
          "input": "s = \"1337c0d3\"",
          "expected_output": "1337",
          "success": true,
          "output": "1337"
        },
        {
          "example_index": 3,
          "input": "s = \"0-1\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 4,
          "input": "s = \"words and 987\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode151.json",
    "problem_index_in_file": 0,
    "title": "Reverse Words in a String",
    "description_snippet": "Given an input string s, reverse the order of the words.\n\nA word is defined as a sequence of non-spa...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for reversing words in string s with cleaning spaces. We'll produce steps: trim spaces, split, reverse, join. But need to handle spaces by splitting on whitespace and ignoring empty tokens. Virtual code lines with arrows etc.\n\nLet's produce:\n\nStart\n→ Step 1: 定義 s 為輸入字串 // 接收輸入\n→ Step 2: 初始化 words 為空列表 // 存儲單詞\n→ Step 3: 初始化 current 為空字串 // 建構單詞\n→ Step 4: 迭代 s 的每個字符 c\n   → Decision: 如果 c 為空白? // 判斷是否為分隔符\n        Yes → Decision: 如果 current 非空? // 是否已經有單詞\n            Yes → Step 5: 把 current 加入 words 並清空 current // 存儲單詞\n            No  → Step 6: 跳過 // 連續空白\n        No  → Step 7: 把 c 加到 current // 追加到單詞\n→ Step 8: 迭代結束後 Decision: 如果 current 非空? // 最後一個單詞\n    Yes → Step 9: 把 current 加入 words // 存儲\n    No  → Step 10: 跳過\n→ Step 11: 反轉 words 列表 // 逆序\n→ Step 12: 以單個空格連接 words 為 result // 合併\n→ Step 13: 返回 result // 結果\nEnd\n\nWe must add explanations. Ensure formatting: each line: \"虛擬碼步驟 // 解釋\". Use arrows as appropriate. Provide indentation for nested decisions. Provide line numbers? Not required. Use correct arrow syntax. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 s 為輸入字串 // 接收使用者提供的字串  \n→ Step 2: 初始化 words 為空列表 // 用來存放所有單詞  \n→ Step 3: 初始化 current 為空字串 // 用於臨時存放當前正在讀取的單詞  \n→ Step 4: 迭代 s 的每個字符 c  \n  → Decision: 如果 c 為空白? // 判斷是否為單詞分隔符  \n   Yes → Decision: 如果 current 非空? // 檢查是否已經形成了一個單詞  \n    Yes → Step 5: 把 current 加入 words 並清空 current // 存入單詞並重置  \n    No → Step 6: 跳過 // 連續空白不做處理  \n   No  → Step 7: 把 c 加到 current // 把字符加入當前單詞  \n→ Step 8: 迭代結束後 Decision: 如果 current 非空? // 處理最後一個單詞  \n  Yes → Step 9: 把 current 加入 words // 將最後單詞加入列表  \n  No  → Step 10: 跳過 // 無需處理  \n→ Step 11: 反轉 words 列表 // 取得逆序的單詞順序  \n→ Step 12: 以單個空格連接 words 為 result // 合併成最終字串  \n→ Step 13: 返回 result // 給使用者返回結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        # Strip leading/trailing spaces, split on whitespace, filter out empties,\n        # reverse, and join with single space.\n        words = s.strip().split()\n        # words already filtered by split without empty strings.\n        return ' '.join(words[::-1])\n\ndef parse_input(raw: str) -> str:\n    raw = raw.strip()\n    if not raw:\n        return ''\n    # If format like s = \"text\" or s=\"text\"\n    if '=' in raw:\n        # find first quote\n        start = raw.find('\"')\n        end = raw.rfind('\"')\n        if start != -1 and end != -1 and start < end:\n            return raw[start+1:end]\n        # maybe single quotes\n        start = raw.find(\"'\")\n        end = raw.rfind(\"'\")\n        if start != -1 and end != -1 and start < end:\n            return raw[start+1:end]\n        # fallback: take substring after '='\n        return raw.split('=',1)[1].strip()\n    # if surrounded by quotes\n    if (raw[0] == '\"' and raw[-1] == '\"') or (raw[0] == \"'\" and raw[-1] == \"'\"):\n        return raw[1:-1]\n    return raw\n\nif __name__ == \"__main__\":\n    raw_input_data = sys.stdin.read()\n    s = parse_input(raw_input_data)\n    result = Solution().reverseWords(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"the sky is blue\"",
          "expected_output": "\"blue is sky the\"",
          "success": true,
          "output": "blue is sky the"
        },
        {
          "example_index": 1,
          "input": "s = \"  hello world  \"",
          "expected_output": "\"world hello\"",
          "success": true,
          "output": "world hello"
        },
        {
          "example_index": 2,
          "input": "s = \"a good   example\"",
          "expected_output": "\"example good a\"",
          "success": true,
          "output": "example good a"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode27.json",
    "problem_index_in_file": 0,
    "title": "Remove Element",
    "description_snippet": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with arrow arrow structure, explanation. The algorithm: two-pointer, iterate i from 0 to n-1, maintain index pos for next non-val element. If nums[i]!=val then nums[pos]=nums[i]; pos++.\n\nReturn pos.\n\nSo produce steps: Start, Step 1: Initialize pos=0 // etc. Then loop over i: Decision: i < n? Yes etc. But we can simplify: For each element, if element != val then assign.\n\nWe need to maintain for loop structure: Decision: i < n? Yes → Check if nums[i] != val? Yes → Copy to nums[pos] and pos++.\n\nAfter loop ends, return pos.\n\nSo virtual code:\n\nStart\n→ Step 1: pos = 0 // 初始化指標\n→ Step 2: i = 0 // 初始化遍歷索引\n→ Decision: i < length(nums)? // 判斷是否還有元素未遍歷\n    Yes → Decision: nums[i] != val? // 檢查當前元素是否需要保留\n        Yes → Step 3: nums[pos] = nums[i] // 把非目標元素寫入 pos\n            → Step 4: pos = pos + 1 // 移動 pos 指標\n        No → // 跳過目標元素\n    No → // 所有元素已遍歷\n→ Step 5: i = i + 1 // 前進到下一個元素\n→ Decision: i < length(nums)? // 循環條件\n    Yes → Jump back to Step 2 (but we need to show arrow)\n    No → Step 6: return pos // 返回保留元素數量\nEnd\n\nBut we need arrow formatting consistent. Use arrow arrow.\n\nWe need to be careful with the flow: use a loop, but we can use while. Let's craft.\n\nStart\n→ Step 1: pos ← 0 // 位置指標初始化\n→ Step 2: i ← 0 // 當前索引初始化\n→ Decision: i < len(nums) ? // 是否還有元素要處理\n    Yes → Decision: nums[i] ≠ val ?\n        Yes → Step 3: nums[pos] ← nums[i] // 把非目標元素寫入前面\n            → Step 4: pos ← pos + 1 // 移動位置指標\n        No → // 跳過目標值\n    No → // 所有元素已處理\n→ Step 5: i ← i + 1 // 移到下一個索引\n→ Decision: i < len(nums) ? // 重複循環\n    Yes → Go back to Step 2\n    No → Step 6: return pos // 回傳有效元素個數\nEnd\n\nNeed to use arrows '→' after each line. For decisions, indent the Yes/No branches. Use the arrow structure: e.g.\n\nDecision: i < len(nums) ?\n    Yes → ...\n    No → ...\n\nBut after branch we need to jump back to Step 2 or finish. But we can't use 'Go back', but we can use arrow back: '← Step 2'.\n\nBut format expects: 'Yes →' with line after. For loop, we can have the 'Decision' after Step 5, Yes goes to Step 2. Use arrow.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: pos ← 0 // 初始化指標 pos，用來記錄下次寫入的位置\n→ Step 2: i ← 0 // 初始化遍歷索引 i，從頭開始掃描陣列\n→ Decision: i < len(nums) ? // 判斷是否還有未處理的元素\n    Yes → Decision: nums[i] ≠ val ?\n        Yes → Step 3: nums[pos] ← nums[i] // 把不等於 val 的元素複製到 pos 位置\n            → Step 4: pos ← pos + 1 // pos 前進，準備寫入下一個非目標元素\n        No → // 若為 val，直接跳過，不進行任何寫入\n    No  → // 所有元素已遍歷完畢\n→ Step 5: i ← i + 1 // 移動到下一個索引\n→ Decision: i < len(nums) ?\n    Yes → ← Step 2 // 回到第 2 步重新處理下一個元素\n    No  → Step 6: return pos // 迴圈結束，回傳有效元素個數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        Remove all occurrences of val from nums in-place.\n        Returns the number of elements not equal to val.\n        \"\"\"\n        pos = 0  # 指向下一個要寫入非 val 的位置\n        for i in range(len(nums)):\n            if nums[i] != val:\n                nums[pos] = nums[i]\n                pos += 1\n        return pos\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析 nums 列表和 val 整數。\n    支援形如 'nums = [1,2,3], val = 2' 的格式。\n    \"\"\"\n    nums = []\n    val = None\n\n    # 取得中括號內的數字\n    nums_match = re.search(r'\\[([^\\]]*)\\]', data)\n    if nums_match:\n        nums_str = nums_match.group(1)\n        if nums_str.strip():\n            nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n\n    # 取得 val\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n    if val_match:\n        val = int(val_match.group(1))\n\n    return nums, val\n\ndef main():\n    # 讀取所有輸入\n    raw_input = sys.stdin.read()\n    nums, val = parse_input(raw_input)\n\n    if val is None:\n        # 若找不到 val，直接輸出原始結果\n        print(f\"0, nums = {['_'] * len(nums)}\")\n        return\n\n    solution = Solution()\n    k = solution.removeElement(nums, val)\n\n    # 構造輸出格式：k, nums = [元素,元素,_,...]\n    formatted = []\n    for i in range(len(nums)):\n        if i < k:\n            formatted.append(str(nums[i]))\n        else:\n            formatted.append('_')\n    nums_str = \"[\" + \",\".join(formatted) + \"]\"\n\n    print(f\"{k}, nums = {nums_str}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,2,3], val = 3",
          "expected_output": "2, nums = [2,2,_,_]",
          "success": true,
          "output": "2, nums = [2,2,_,_]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,3,0,4,_,_,_]",
          "success": true,
          "output": "5, nums = [0,1,3,0,4,_,_,_]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode357.json",
    "problem_index_in_file": 0,
    "title": "Count Numbers with Unique Digits",
    "description_snippet": "Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10^n....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps explaining algorithm: count of numbers with unique digits less than 10^n. Classic Leetcode problem: countNumbersWithUniqueDigits. For n=0 return 1. Use combinatorics: for numbers of length i (1 to n) we count permutations. 0 can appear but cannot start with zero. For i=1: 10 numbers (0-9). For i>1: 9*9*8*...*(10-i+1). Summation. Or iterative DP: count=1; for i=1..n: count+=9*P(9,i-1). We'll produce virtual code steps. Provide each line with explanation. Use arrows, decisions. Let's produce steps:\n\nStart\n→ Step 1: Input n\n→ Decision: If n == 0? // Handle base case\n    Yes → Step 2: Return 1 // Only number 0\n    No → Step 3: Initialize result = 1 // Count 0\n→ Step 4: Initialize availableDigits = 9 // First digit cannot be 0\n→ Step 5: Initialize permutationFactor = 9 // For numbers of length 1 (non-zero first digit)\n→ Step 6: For i from 1 to n:\n        // iterate lengths\n        → Decision: If i == 1? // first length handled separately\n            Yes → result += 10 // all one-digit numbers 0-9\n            No → // for lengths >1\n                → Step 7: result += 9 * permutationFactor // count numbers of current length\n                → Step 8: permutationFactor *= (10 - i) // update factor for next length\n→ End // return result\n\nBut need to include explanations after each line. Use virtual code syntax: Start, Step x, Decision:..., Yes →..., No →..., End.\n\nLet's produce final answer. Ensure each line has explanation. Use arrow for flow. Use indent for nested decisions? Provide as lines.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入整數 n // 從使用者取得 n 的值  \n→ Decision: n 是否等於 0? // 檢查是否是特殊情況  \n    Yes → Step 2: 回傳 1 // 只有數字 0 佔一個位置  \n    No → Step 3: 設定 result = 1 // 包含數字 0 的計數  \n→ Step 4: 設定 permutationFactor = 9 // 第一個位數不可以是 0，剩餘 9 個選項  \n→ Step 5: 進入迴圈 i 從 1 到 n  \n    → Decision: i 是否等於 1? // 第一位數的特殊處理  \n        Yes → Step 6: result += 10 // 一位數有 0~9 共 10 個  \n        No → Step 7: result += 9 * permutationFactor // 第 i 位數的計數  \n             → Step 8: permutationFactor *= (10 - i) // 更新排列因子，為下一位數做準備  \n→ End // 回傳 result，程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\n        \"\"\"\n        Return the count of all numbers with unique digits, x, where 0 <= x < 10^n.\n        \"\"\"\n        if n == 0:\n            return 1  # Only the number 0\n\n        # Numbers longer than 10 digits must repeat a digit\n        n = min(n, 10)\n\n        total = 10          # All one‑digit numbers: 0–9\n        unique = 9          # First digit of a multi‑digit number (cannot be 0)\n        available = 9       # Remaining digits that can be used\n\n        for _ in range(2, n + 1):\n            unique *= available   # Add one more digit to the number\n            total += unique       # Count numbers of this length\n            available -= 1        # One digit is now used\n\n        return total\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Accept input in the form \"n = X\" or just \"X\"\n    if '=' in data:\n        _, value_str = data.split('=', 1)\n        n = int(value_str.strip())\n    else:\n        n = int(data)\n\n    result = Solution().countNumbersWithUniqueDigits(n)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "91",
          "success": true,
          "output": "91"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode392.json",
    "problem_index_in_file": 0,
    "title": "Is Subsequence",
    "description_snippet": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\n\nA subsequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a virtual code for checking if string s is a subsequence of t. They want step-by-step pseudocode, with arrow structure and explanation. Use Chinese (繁體) for explanation. Use Start, End, Decision. Provide each line: \"虛擬碼步驟 [space] // 解釋\". Use \"→\" arrow.\n\nSo we produce:\n\nStart // program start\n→ Initialize pointer i = 0, j = 0 // i for s, j for t\n→ Decision: i < len(s)? // check if we have processed all chars of s\n   Yes → Decision: j < len(t)? // need to check t not exhausted\n      Yes → Decision: s[i] == t[j]? // compare current characters\n          Yes → i = i + 1 // advance s pointer\n          No  → // do nothing\n      No  → // t exhausted, cannot match remaining s\n          → End // exit\n   No  → // all s processed\n      → End // return true\nBut we need to produce a return statement: We can set a flag result = true initially. But easier: at the end if i == len(s) then true else false. Use a variable result.\n\nWe need to produce \"Step: return i == len(s)\" or \"Step: return result\".\n\nBetter to compute result: After loop, if i == len(s) then true else false.\n\nWe need to indicate return.\n\nThus:\n\n→ Step: result = false // default false\n→ Decision: i == len(s)? // after loop\n   Yes → result = true // all matched\n   No → result = false // not matched\n→ Step: return result // return\n\nBut we can also embed the final check at the end of decision chain.\n\nLet's produce a simple approach:\n\nInitialize i=0,j=0\nWhile i < len(s) and j < len(t):\n    if s[i]==t[j]: i++\n    j++\nAfter loop, return i==len(s)\n\nThus:\n\nStart\n→ Step 1: i = 0 // s pointer\n→ Step 2: j = 0 // t pointer\n→ Decision: i < len(s) AND j < len(t)? // while condition\n   Yes → Decision: s[i] == t[j]? // compare\n      Yes → i = i + 1 // advance s\n      No  → // skip\n   → j = j + 1 // always advance t\n   → Go back to Decision\n   No  → // exit loop\n→ Step 3: result = (i == len(s)) // check if all s matched\n→ Step 4: return result // output\n\nWe need to express in virtual code with arrows. We need to use \"→\" for steps and decisions.\n\nThe format requires: each line: \"虛擬碼步驟 [space] // 解釋\"\n\nLet's produce exactly that.\n\nMake sure to use \"Decision:\" for decisions.\n\nSo:\n\nStart // 程式開始執行\n→ Step 1: i = 0 // 初始化 s 的索引\n→ Step 2: j = 0 // 初始化 t 的索引\n→ Decision: i < len(s) AND j < len(t)? // 檢查是否還有字符可比對\n    Yes → Decision: s[i] == t[j]? // 比較目前字符\n        Yes → Step 3: i = i + 1 // s 的索引往後移\n        No  → // 不相等，s 的索引保持不動\n    → Step 4: j = j + 1 // t 的索引永遠往後移\n    → (回到上方 Decision) // 迴圈持續\n    No  → // t 或 s 已遍歷完，結束迴圈\n→ Step 5: result = (i == len(s)) // 若 s 全部匹配則為 true\n→ Step 6: return result // 回傳結果\nEnd // 程式結束\n\nBut we must ensure the arrow formatting: Use \"→\" before each line. For decision we indent options. We need to align arrow for nested decisions? The example shows \"Yes →\" and \"No →\" with indent. Use \"→\" for step lines too.\n\nWe need to output like:\n\nStart // 程式開始執行\n→ Step 1: i = 0 // 初始化 s 的索引\n→ Step 2: j = 0 // 初始化 t 的索引\n→ Decision: i < len(s) AND j < len(t)? // 檢查是否還有字符可比對\n    Yes → Decision: s[i] == t[j]? // 比較目前字符\n        Yes → Step 3: i = i + 1 // s 的索引往後移\n        No  → // 不相等，s 的索引保持不動\n    → Step 4: j = j + 1 // t 的索引永遠往後移\n    → (回到上方 Decision) // 迴圈持續\n    No  → // t 或 s 已遍歷完，結束迴圈\n→ Step 5: result = (i == len(s)) // 若 s 全部匹配則為 true\n→ Step 6: return result // 回傳結果\nEnd // 程式結束\n\nBut the example uses indentation for Yes/No, but we can mimic.\n\nBetter to write:\n\nStart // 程式開始執行\n→ Step 1: i = 0 // 初始化 s 的索引\n→ Step 2: j = 0 // 初始化 t 的索引\n→ Decision: i < len(s) AND j < len(t)? // 只要 s 未遍歷完且 t 未遍歷完就繼續\n    Yes → Decision: s[i] == t[j]? // 判斷當前字符是否相等\n        Yes → Step 3: i = i + 1 // s 的索引往後移\n        No  → // s 的索引保持不動\n    → Step 4: j = j + 1 // t 的索引永遠往後移\n    → // 回到最上層 Decision\n    No  → // 結束迴圈\n→ Step 5: result = (i == len(s)) // 若 s 全部匹配則為 true\n→ Step 6: return result // 回傳結果\nEnd // 程式結束\n\nNeed to ensure we use \"→\" at start of each line.\n\nAlso, \"→ // 回到最上層 Decision\" maybe should be a step that loops back, but in pseudocode we can just say \"→\" to loop.\n\nMaybe we can avoid explicit \"回到最上層 Decision\". Instead we just rely on while loop: The decision repeats until No.\n\nWe can just put \"→\" after j increment to go back to Decision.\n\nLet's produce final output accordingly.\n\nUse consistent indent: Use spaces before Yes, No, etc. Use same style as example. The example uses 4 spaces for indentation? It uses a tab? It shows:\n\n    Yes → Step 2: ...\n\nWe can mimic with 4 spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i = 0 // 初始化 s 的索引  \n→ Step 2: j = 0 // 初始化 t 的索引  \n→ Decision: i < len(s) AND j < len(t)? // 只要 s 未遍歷完且 t 未遍歷完就繼續  \n    Yes → Decision: s[i] == t[j]? // 判斷當前字符是否相等  \n        Yes → Step 3: i = i + 1 // s 的索引往後移  \n        No  → // s 的索引保持不動  \n    → Step 4: j = j + 1 // t 的索引永遠往後移  \n    → // 回到最上層 Decision，繼續迴圈  \n    No  → // t 或 s 已遍歷完，結束迴圈  \n→ Step 5: result = (i == len(s)) // 若 s 全部匹配則為 true  \n→ Step 6: return result // 回傳結果  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        \"\"\"\n        判斷 s 是否為 t 的子序列。\n        只需一次遍歷 t，逐字符比對 s。\n        \"\"\"\n        if not s:  # 空字串永遠是子序列\n            return True\n        index_s = 0  # s 的指標\n        for char in t:\n            if char == s[index_s]:\n                index_s += 1\n                if index_s == len(s):\n                    return True\n        return False\n\ndef main() -> None:\n    \"\"\"\n    主程式：\n    1. 從 stdin 讀取所有資料。\n    2. 解析出兩個字串 s、t（支援格式：s = \"abc\", t = \"ahbgdc\" 或簡易空格分隔）。\n    3. 呼叫 Solution.isSubsequence 判斷結果。\n    4. 將結果以 'true' 或 'false' 印出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先嘗試使用正則抓取雙引號中的內容\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        s, t = matches[0], matches[1]\n    else:\n        # 若沒有雙引號，則假設以空白分隔\n        parts = data.split()\n        if len(parts) >= 2:\n            s, t = parts[0], parts[1]\n        else:\n            # 只收到一個字串，視為 s，t 為空\n            s, t = parts[0], \"\"\n\n    solution = Solution()\n    result = solution.isSubsequence(s, t)\n    # 以小寫字串輸出結果\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abc\", t = \"ahbgdc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"axc\", t = \"ahbgdc\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode91.json",
    "problem_index_in_file": 0,
    "title": "Decode Ways",
    "description_snippet": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for decoding ways. We should produce a step-by-step algorithm, presumably using DP.\n\nWe need to produce each line with \"虛擬碼步驟 // 解釋\".\n\nWe should include Start, End, Decision lines. Use arrows. We can outline:\n\nStart\n→ Step 1: If s is empty return 1? Wait: If empty string, 1? But typical problem: empty string -> 0? But maybe treat as 1? Usually decode ways: empty string returns 0? But typical: return 0 for empty. We'll handle.\n\nWe need to handle DP array dp[i] number ways up to index i.\n\nWe'll produce lines:\n\nStart\n→ Decision: 是否 s 為空? Yes -> Step: Return 0 // 無法解碼\n→ Step 1: 建立 dp 陣列長度 n+1 // dp[0]=1\n→ Step 2: dp[0] = 1 // 代表空字串一種解法\n→ Step 3: dp[1] = (s[0] != '0') ? 1 : 0 // 第一步\n→ Decision: n>1? If yes, loop i from 2 to n\n    → Step 4: 讀取單字元 s[i-1]\n        → Decision: s[i-1] != '0' ?\n            Yes → dp[i] += dp[i-1] // 用單碼\n        → Step 5: 讀取兩位數 s[i-2:i]\n            → Decision: 10 <= int(two) <= 26 ?\n                Yes → dp[i] += dp[i-2] // 用雙碼\n    → End loop\n→ Decision: dp[n] == 0? If yes -> return 0 else return dp[n]\nEnd\n\nAdd explanation comments.\n\nMake sure each line has `虛擬碼步驟 // 解釋`.\n\nUse proper arrow.\n\nWe also need to include decision with Yes/No arrows.\n\nLet's format.\n\nStart // 程式開始執行\n→ Decision: 如果 s 為空? // 判斷輸入是否為空字串\n    Yes → Step: 返回 0 // 空字串無法解碼\n    No  → // 繼續\n→ Step: 初始化變數 n = s.length // 取得字串長度\n→ Step: 建立 dp 陣列長度 n+1 // dp[i] 表示前 i 個字元的解碼方式數\n→ Step: dp[0] = 1 // 空字串有一種解碼方式（作為基礎）\n→ Step: dp[1] = (s[0] != '0') ? 1 : 0 // 第一個字元若不是 '0' 可解碼一次\n→ Decision: n > 1? // 若字串長度大於 1，則需要進行迴圈\n    Yes → // 進行循環\n        → Step: 循環 i 從 2 到 n\n            → Step: 計算單碼\n                → Decision: s[i-1] != '0'? // 單個數字是否有效\n                    Yes → dp[i] += dp[i-1] // 加上前一位的解碼方式\n            → Step: 計算雙碼\n                → Step: 取 two = s[i-2]s[i-1] 轉成整數\n                → Decision: 10 <= two <= 26? // 是否為有效雙碼\n                    Yes → dp[i] += dp[i-2] // 加上前兩位的解碼方式\n    No  → // 不進行循環\n→ Step: 返回 dp[n] // 回傳整個字串的解碼方式數量\nEnd // 程式結束\n\nWe must format each line properly with spaces.\n\nMake sure to include arrows: \"→\" before step lines. For Decision lines, format: \"→ Decision: ... // ...\".\n\nInclude Yes→ and No→ for nested decisions.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: s 是否為空? // 判斷輸入是否為空字串  \n  Yes → Step: 返回 0 // 空字串無法解碼  \n  No → // 繼續執行  \n\n→ Step: n ← s.length // 取得字串長度  \n→ Step: 建立 dp 陣列長度 n+1 // dp[i] 表示前 i 個字元的解碼方式數  \n→ Step: dp[0] ← 1 // 空字串有一種解碼方式（基礎情況）  \n→ Step: dp[1] ← (s[0] != '0') ? 1 : 0 // 第一個字元若不是 '0' 可解碼一次  \n\n→ Decision: n > 1? // 若字串長度大於 1，則需要進行迴圈  \n  Yes → // 進行循環  \n   → Step: i 從 2 到 n  \n    → Step: 若 s[i-1] != '0' // 單個數字有效  \n      Yes → dp[i] ← dp[i] + dp[i-1] // 加上單碼解碼方式  \n    → Step: two ← int(s[i-2]s[i-1]) // 取得兩位數  \n    → Decision: 10 ≤ two ≤ 26? // 是否為有效雙碼  \n      Yes → dp[i] ← dp[i] + dp[i-2] // 加上雙碼解碼方式  \n  No → // 不進行循環  \n\n→ Step: 返回 dp[n] // 回傳整個字串的解碼方式數量  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        if not s or s[0] == '0':\n            return 0\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            two_digit = int(s[i - 2:i])\n            if 10 <= two_digit <= 26:\n                dp[i] += dp[i - 2]\n        return dp[n]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    match = re.search(r'(\\d+)', data)\n    s = match.group(1) if match else ''\n    result = Solution().numDecodings(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"12\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \"226\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"06\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode649.json",
    "problem_index_in_file": 0,
    "title": "Dota2 Senate",
    "description_snippet": "In the world of Dota2, there are two parties: the Radiant and the Dire.\n\nThe Dota2 senate consists o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode that predicts winner given senate string. Classic problem \"Dota2 Senate\". Approach: use queues for positions. Count remaining. Simulate. Pseudocode lines with explanation. Use Start, End, Decision. Let's produce step-by-step.\n\nWe need each line: \"虛擬碼步驟 // 解釋\" with arrow. Use \"→\". Let's craft.\n\nStart\n→ Step 1: 初始化兩個空隊列 radiants, dire // 用於儲存各黨參議員索引\n→ Step 2: 逐位遍歷 senate 並將索引加入對應隊列 // 建立初始順序\n→ Decision: 如果 radiants 為空? // 檢查是否已無 Radiant 參議員\n    Yes → Step 3: 輸出 \"Dire\" // Dire 已勝利\n    No  → Decision: 如果 dire 為空?\n        Yes → Step 4: 輸出 \"Radiant\"\n        No  → Step 5: 進入模擬循環\nStep 5: while radiants 不為空 且 dire 不為空 // 兩黨仍有參議員\n→ Step 6: 取出 radiants 佇列頭部的索引 rIndex\n→ Step 7: 取出 dire 佇列頭部的索引 dIndex\n→ Decision: 如果 rIndex < dIndex?\n    Yes → Step 8: radiants 佇列新增 rIndex + n // 重新排到下一輪\n    No  → Step 9: dire 佇列新增 dIndex + n\n→ Step 10: 循環結束後，根據哪個隊列非空決定勝利\n→ Decision: 如果 radiants 為空?\n    Yes → Step 11: 輸出 \"Dire\"\n    No  → Step 12: 輸出 \"Radiant\"\nEnd\n\nWe need each line with explanation. Let's produce exactly that. Use 虛擬碼步驟. We need \"Start\", \"End\" as lines. Each step.\n\nAlso maybe include variable n.\n\nLet's format accordingly. Ensure arrow formatting: \"→\". Provide explanation after //.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個空隊列 radiants, dire // 用於儲存 Radiant 與 Dire 參議員的索引  \n→ Step 2: 逐位遍歷 senate 並將索引加入對應隊列 // 建立初始投票順序  \n→ Decision: 如果 radiants 為空? // 檢查是否已無 Radiant 參議員  \n Yes → Step 3: 輸出 \"Dire\" // Dire 已經勝利，直接結束  \n No → Decision: 如果 dire 為空?  \n  Yes → Step 4: 輸出 \"Radiant\" // Radiant 已經勝利，直接結束  \n  No → Step 5: 進入模擬循環  \nStep 5: while radiants 不為空 且 dire 不為空 // 當兩黨仍有參議員時繼續模擬  \n → Step 6: 取出 radiants 佇列頭部的索引 rIndex // 取得下一位 Radiant 參議員  \n → Step 7: 取出 dire 佇列頭部的索引 dIndex // 取得下一位 Dire 參議員  \n → Decision: 如果 rIndex < dIndex? // 比較兩位參議員在原始順序中的先後  \n  Yes → Step 8: radiants 佇列新增 rIndex + n // Radiant 參議員成功封鎖 Dire，並排入下一輪  \n  No → Step 9: dire 佇列新增 dIndex + n // Dire 參議員成功封鎖 Radiant，並排入下一輪  \n → Step 10: 循環結束後，回到 while 條件檢查  \n→ Step 11: 根據哪個隊列非空決定勝利  \n → Decision: 如果 radiants 為空?  \n  Yes → Step 12: 輸出 \"Dire\" // Radiant 被全數封鎖，Dire 勝利  \n  No → Step 13: 輸出 \"Radiant\" // Dire 被全數封鎖，Radiant 勝利  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def predictPartyVictory(self, senate: str) -> str:\n        n = len(senate)\n        radiant = deque()\n        dire = deque()\n\n        for i, s in enumerate(senate):\n            if s == 'R':\n                radiant.append(i)\n            else:  # s == 'D'\n                dire.append(i)\n\n        while radiant and dire:\n            r_index = radiant.popleft()\n            d_index = dire.popleft()\n            if r_index < d_index:\n                radiant.append(r_index + n)\n            else:\n                dire.append(d_index + n)\n\n        return \"Radiant\" if radiant else \"Dire\"\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    將原始輸入字串轉成只包含 'R' 或 'D' 的 senate 字串。\n    支援兩種輸入格式：\n    1. 直接輸入字串，例如 RD\n    2. 包含賦值語句，例如 senate = \"RD\"\n    \"\"\"\n    data = data.strip()\n    # 如果輸入中包含文字 \"senate\"（常見於範例格式），嘗試抓取引號內的內容\n    if 'senate' in data:\n        match = re.search(r'\"([^\"]*)\"', data)\n        if match:\n            return match.group(1).strip()\n        # 若沒有引號，嘗試取等號後的內容\n        if '=' in data:\n            _, value = data.split('=', 1)\n            return value.strip().strip('\"')\n    # 直接輸入，移除任何空白或引號\n    return data.strip().strip('\"')\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    senate_str = parse_input(raw_input)\n    solution = Solution()\n    result = solution.predictPartyVictory(senate_str)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "senate = \"RD\"",
          "expected_output": "\"Radiant\"",
          "success": true,
          "output": "Radiant"
        },
        {
          "example_index": 1,
          "input": "senate = \"RDD\"",
          "expected_output": "\"Dire\"",
          "success": true,
          "output": "Dire"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode523.json",
    "problem_index_in_file": 0,
    "title": "Continuous Subarray Sum",
    "description_snippet": "Given an integer array nums and an integer k, return true if nums has a good subarray or false other...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The algorithm: Check for good subarray length at least 2, sum % k == 0. Typical solution: prefix sums and hashmap of remainder to earliest index. Iterate prefix sum; if remainder seen before, check if current index - previous >=2. Also special case k==0: need subarray of length >=2 where sum==0. For k==0, need to find two consecutive zeros or a subarray of length >=2 with sum zero (prefix difference 0). But typical logic: if k==0, we need subarray sum 0; we can check for any consecutive zeros. But we can generalize: we can use same hashmap but with k==0? remainder division by zero invalid. So handle separately.\n\nSo pseudocode: Start, input nums, k. If k==0: for i from 0 to len-2: if nums[i]==0 and nums[i+1]==0: return true. Also could check prefix sums difference 0? But simpler: iterate i, maintain current sum, if sum==0 and i>=1: true. But easier: check consecutive zeros.\n\nElse: create map remIndex. put 0:-1. sum=0. for i from 0 to n-1: sum+=nums[i]; rem = sum % k; if rem<0 rem+=k; if rem in map: if i - map[rem] >=2 return true; else skip. else map[rem]=i. After loop, return false.\n\nOutput virtual code with explanations line by line. Use arrow and decision. We'll produce steps with comments. Use appropriate arrow for decision.\n\nLet's craft:\n\nStart // 開始\n→ Input nums, k // 讀取輸入\n→ Decision: 是否 k==0? // 檢查 k 是否為 0\n    Yes → Step 1: 計算子陣列長度 // 獲取陣列長度\n    Yes → Decision: 是否長度<2? // 若長度不足兩個元素\n        Yes → Step 2: 返回 false // 無法形成子陣列\n        No  → Step 3: 逐個檢查連續兩個元素是否同為0 // 搜尋連續零\n        No  → Step 4: 若找到，返回 true // 連續零即為良好子陣列\n        No  → Step 5: 循環結束，返回 false // 未找到連續零\n    No → Step 6: 初始化 remIndex 映射 {0:-1} // 記錄餘數與最早索引\n    No → Step 7: sum ← 0 // 初始化前綴和\n    No → For i from 0 to n-1: // 遍歷陣列\n        → Step 8: sum ← sum + nums[i] // 更新前綴和\n        → Step 9: rem ← sum % k // 計算餘數\n        → Step 10: 如果 rem < 0: rem ← rem + k // 確保餘數非負\n        → Decision: rem 已存在於 remIndex? // 檢查餘數是否重複\n            Yes → If i - remIndex[rem] >= 2: // 子陣列長度至少 2\n                → Step 11: 返回 true // 找到良好子陣列\n            No  → Decision: rem 尚未存在於 remIndex? // 是否首次出現\n                Yes → Step 12: remIndex[rem] ← i // 記錄餘數的最早索引\n    No → Step 13: 返回 false // 迭代完畢未找到\nEnd // 程式結束\n\nMake sure format: each line \"虛擬碼步驟 // 解釋\" no indentation? We can indent inside decisions but keep as separate lines. The arrow used: \"→\" for steps, \"Decision:\" for decision.\n\nNeed to ensure each line ends with // 解釋. The decisions have arrow within but we can treat them as separate lines. Let's produce accordingly. Use \"Yes →\" and \"No →\" lines as separate. Provide explanation for each.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums, k // 取得輸入陣列與整數 k  \n→ Decision: 是否 k==0? // 判斷 k 是否為 0  \n&nbsp;&nbsp;Yes → Step 1: 計算陣列長度 n = len(nums) // 取得陣列長度  \n&nbsp;&nbsp;Yes → Decision: n < 2? // 判斷長度是否不足 2 個元素  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2: 返回 false // 無法形成至少兩個元素的子陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 3: i ← 0 // 初始化索引  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → While i < n-1: // 遍歷到倒數第二個元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 4: 如果 nums[i]==0 且 nums[i+1]==0: // 檢查連續兩個零  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: 返回 true // 連續零即為良好子陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → i ← i+1 // 移動到下一個位置  \n&nbsp;&nbsp;&nbsp;&nbsp;End While  \n&nbsp;&nbsp;&nbsp;&nbsp;Step 6: 返回 false // 未找到連續兩個零  \n&nbsp;&nbsp;No  → Step 7: remIndex ← {0:-1} // 建立餘數到最早索引的映射，初始餘數 0 的索引為 -1  \n&nbsp;&nbsp;No  → sum ← 0 // 初始化前綴和  \n&nbsp;&nbsp;No  → For i from 0 to n-1: // 遍歷陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: sum ← sum + nums[i] // 更新前綴和  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 9: rem ← sum % k // 計算餘數  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 10: 如果 rem < 0: rem ← rem + k // 確保餘數非負  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: rem 已存在於 remIndex? // 判斷餘數是否重複  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → If i - remIndex[rem] >= 2: // 子陣列長度至少 2  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 11: 返回 true // 找到符合條件的子陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Decision: rem 尚未存在於 remIndex? // 首次出現  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 12: remIndex[rem] ← i // 記錄餘數的最早索引  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 不做任何操作，已記錄  \n&nbsp;&nbsp;End For  \n&nbsp;&nbsp;Step 13: 返回 false // 迭代完畢未找到符合條件的子陣列  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def checkSubarraySum(self, nums, k):\n        \"\"\"Return True if there exists a subarray of length at least two whose sum is a multiple of k.\"\"\"\n        mod_map = {0: -1}   # remainder -> earliest index\n        total = 0\n        for i, num in enumerate(nums):\n            total += num\n            if k != 0:\n                total %= k\n            # If this remainder has been seen before\n            if total in mod_map:\n                # Subarray length at least 2?\n                if i - mod_map[total] >= 2:\n                    return True\n            else:\n                # Record earliest occurrence of this remainder\n                mod_map[total] = i\n        return False\n\ndef parse_input(s: str):\n    \"\"\"Parse input string of the form '[a,b,c], k' into list and integer.\"\"\"\n    s = s.strip()\n    if not s:\n        return [], 0\n    # Find the last comma that separates the array and k\n    comma_idx = s.rfind(',')\n    if comma_idx == -1:\n        # No comma found, assume only array is given\n        nums = ast.literal_eval(s)\n        k = 0\n    else:\n        nums_part = s[:comma_idx].strip()\n        k_part = s[comma_idx+1:].strip()\n        nums = ast.literal_eval(nums_part)\n        k = int(k_part)\n    return nums, k\n\ndef main():\n    data = sys.stdin.read()\n    nums, k = parse_input(data)\n    solution = Solution()\n    result = solution.checkSubarraySum(nums, k)\n    # Print lowercase 'true' or 'false' to match expected output\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[23,2,4,6,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "[23,2,6,4,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "[23,2,6,4,7], 13",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode41.json",
    "problem_index_in_file": 0,
    "title": "First Missing Positive",
    "description_snippet": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, with arrows, explanation comments. The task: unsorted integer array, find smallest missing positive integer, O(n) time, O(1) space.\n\nStandard solution: use index marking. Steps:\n\n- Iterate array and ignore numbers <=0 or >n, as they don't affect result. But we can simply keep only numbers between 1 and n.\n\n- Use array indices as hash map: For each num in nums: if 1 <= num <= n, mark presence by negating value at index num-1.\n\n- After marking, first index i where nums[i] > 0 gives missing i+1.\n\n- If all positive indices are negative, missing is n+1.\n\nNeed to produce virtual code with steps. Let's produce:\n\nStart\n→ Step 1: Determine n = length of nums // array size\n→ Step 2: For each index i from 0 to n-1 // iterate to mark\n    → Decision: Is nums[i] in [1, n]? // check valid positive range\n        Yes → Step 3: idx = abs(nums[i]) - 1 // target index\n              → Decision: Is nums[idx] > 0? // check not yet marked\n                  Yes → Step 4: nums[idx] = -nums[idx] // mark presence\n                  No  → // already marked, skip\n        No  → // ignore this element\n→ Step 5: For each index i from 0 to n-1 // find first positive\n    → Decision: Is nums[i] > 0? // unmarked\n        Yes → Step 6: Return i + 1 // missing number found\n        No  → // continue\n→ Step 7: Return n + 1 // all numbers 1..n present\n\nAdd End.\n\nAlso ensure O(1) auxiliary space. We don't use extra data structures.\n\nLet's produce lines with virtual code. Use Start, End, Decision: etc.\n\nWe must include arrow for decisions: Yes →, No →.\n\nUse \"Step X:\" for each action. Provide explanation comment.\n\nLet's produce.\n\nNeed to be careful with indentation, but can be simple.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度 n  \n→ Step 2: For i ← 0 to n-1 // 逐個遍歷陣列  \n  Decision: 1 ≤ nums[i] ≤ n? // 檢查元素是否在可接受的正整數範圍內  \n   Yes → Step 3: idx ← abs(nums[i]) - 1 // 計算對應的索引位置  \n    Decision: nums[idx] > 0? // 判斷該位置是否已被標記  \n     Yes → Step 4: nums[idx] ← -nums[idx] // 將值取負以標記存在  \n     No  → // 已標記，保持不變  \n   No  → // 整數不在 1~n 範圍內，忽略  \n→ Step 5: For i ← 0 to n-1 // 再次遍歷陣列尋找第一個未被標記的位置  \n  Decision: nums[i] > 0? // 正值表示對應的正整數未出現  \n   Yes → Step 6: Return i + 1 // 找到最小缺失正整數  \n   No  → // 連續存在，繼續搜尋  \n→ Step 7: Return n + 1 // 所有 1~n 都存在，缺失值為 n+1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        Find the smallest missing positive integer in an unsorted integer array.\n        This implementation runs in O(n) time and O(1) auxiliary space.\n        \"\"\"\n        n = len(nums)\n\n        # 1. Mark the presence of numbers in the range [1, n]\n        for i in range(n):\n            # Use absolute value because the array may have been altered in previous iterations\n            num = abs(nums[i])\n            if 1 <= num <= n:\n                idx = num - 1\n                if nums[idx] > 0:\n                    nums[idx] = -nums[idx]\n\n        # 2. The first index with a positive value indicates the missing integer\n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n\n        # 3. If all positions are marked, the missing integer is n + 1\n        return n + 1\n\ndef main():\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # The input is expected to be something like \"nums = [1, 2, 0]\"\n    # Extract the part after the '=' sign and parse it as a Python list\n    if '=' in data:\n        _, after_eq = data.split('=', 1)\n        nums_str = after_eq.strip()\n    else:\n        nums_str = data\n\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        return\n\n    # Ensure the parsed object is a list of integers\n    if not isinstance(nums, list):\n        print(\"Input should be a list of integers.\")\n        return\n\n    solution = Solution()\n    result = solution.firstMissingPositive(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,0]",
          "expected_output": "3",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '4'"
        },
        {
          "example_index": 1,
          "input": "nums = [3,4,-1,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [7,8,9,11,12]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode551.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record I",
    "description_snippet": "You are given a string s representing an attendance record for a student where each character signif...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. We should design algorithm: iterate over string, count A, track consecutive L. If A>=2 return false. If consecutive L>=3 return false. End true.\n\nWe output Start, then Step: Initialize variables, loop, decisions, etc.\n\nEnsure each line: \"虛擬碼步驟 // 解釋\". Use arrows. Use Start, End, Decision, Step. Use Yes →, No →.\n\nLet's craft step-by-step. For example:\n\nStart\n→ Step 1: 設定 absentCount = 0, consecutiveLate = 0 // 初始化計數\n→ Step 2: 循環遍歷每個字符 ch in s // 逐日檢查\n    → Decision: 如果 ch == 'A' ?\n        Yes → Step 3: absentCount++ // 缺勤次數加1\n        No  → Decision: 如果 ch == 'L' ?\n            Yes → Step 4: consecutiveLate++ // 連續遲到次數加1\n            No  → Step 5: consecutiveLate = 0 // 非遲到則重置\n    → Decision: 如果 absentCount >= 2 ?\n        Yes → Step 6: 返回 false // 已缺勤兩天以上\n        No  → Decision: 如果 consecutiveLate >= 3 ?\n            Yes → Step 7: 返回 false // 連續遲到三天\n            No  → Step 8: 继续循环\n→ Step 9: 返回 true // 所有檢查通過\nEnd\n\nMake sure each line with explanation.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 absentCount = 0, consecutiveLate = 0 // 初始化缺勤與連續遲到計數  \n→ Step 2: 循環遍歷每個字符 ch in s // 逐日檢查出勤紀錄  \n    → Decision: 如果 ch == 'A' ? // 判斷是否為缺勤  \n        Yes → Step 3: absentCount++ // 缺勤次數加一  \n        No → Decision: 如果 ch == 'L' ? // 判斷是否為遲到  \n            Yes → Step 4: consecutiveLate++ // 連續遲到次數加一  \n            No → Step 5: consecutiveLate = 0 // 不是遲到則重置連續遲到計數  \n    → Decision: 如果 absentCount >= 2 ? // 檢查缺勤是否已達兩天  \n        Yes → Step 6: 返回 false // 缺勤兩天或以上不符合資格  \n        No → Decision: 如果 consecutiveLate >= 3 ? // 檢查連續遲到是否達三天  \n            Yes → Step 7: 返回 false // 連續遲到三天不符合資格  \n            No → Step 8: 继续循环 // 繼續檢查下一天  \n→ Step 9: 返回 true // 所有條件符合，符合獎勵資格  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        \"\"\"\n        判斷學生是否符合獎勵資格。\n        只要缺勤 A 少於 2 天且沒有連續 3 天遲到即可。\n        \"\"\"\n        # 直接使用字串計數和子字串搜尋，效能已足夠\n        return s.count('A') <= 1 and 'LLL' not in s\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入，移除可能的首尾空白與引號\n    raw_input = sys.stdin.read().strip()\n    # 若輸入被雙引號包住，去掉這些引號\n    if raw_input.startswith('\"') and raw_input.endswith('\"'):\n        raw_input = raw_input[1:-1]\n\n    solution = Solution()\n    result = solution.checkRecord(raw_input)\n    # 按題目要求輸出小寫的 true/false\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"PPALLP\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"PPALLL\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode26.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output line-by-line virtual code for removing duplicates from sorted array in place, returning k. Use arrow notation and steps. Provide explanation comments.\n\nWe'll produce something like:\n\nStart\n→ Step 1: If nums length is 0 then return 0 // handle empty array\n→ Step 2: Initialize index i = 0 // pointer to last unique element\n→ Step 3: Loop j from 1 to nums.length-1 // iterate over array\n    → Decision: nums[j] != nums[i] ?\n        Yes → i++ // move index\n              → nums[i] = nums[j] // copy unique element\n        No → continue // duplicate skip\n→ Step 4: Return i+1 // number of unique elements\nEnd\n\nWe need to follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrow lines: \"Start // 程式開始執行\" etc.\n\nWe should include decisions with Yes → and No → indentation.\n\nMake sure each line is separate. Provide explanation comments.\n\nLet's write it.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: If nums.length == 0 then return 0 // 空陣列直接回傳 0  \n→ Step 2: Initialize i = 0 // i 指向已確定唯一元素的最終位置  \n→ Step 3: For j = 1 to nums.length - 1 do // 遍歷陣列中剩餘元素  \n  Decision: nums[j] != nums[i]? // 判斷目前元素是否不同於最後唯一元素  \n   Yes → i = i + 1 // 移動唯一元素指標  \n     → nums[i] = nums[j] // 把新唯一元素複製到前面  \n   No → continue // 為重複項，直接跳過  \n→ Step 4: Return i + 1 // i+1 為唯一元素個數 k  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef removeDuplicates(nums):\n    \"\"\"移除已排序陣列中的重複元素，返回唯一元素個數 k。\n    操作在原陣列進行，第一個 k 個位置存放唯一值，其餘位置不重要。\"\"\"\n    if not nums:\n        return 0\n    slow = 0  # 指向已確定的最後唯一元素\n    for fast in range(1, len(nums)):\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，例如 \"nums = [1,1,2]\"\n    idx = data.find('=')\n    arr_str = data[idx + 1:].strip() if idx != -1 else data\n    nums = ast.literal_eval(arr_str)  # 安全地解析為 Python 列表\n\n    k = removeDuplicates(nums)\n\n    # 以 \"[a,b,c,_,...]\" 格式輸出，後面用 \"_\" 作為佔位符\n    out_elems = [str(nums[i]) if i < k else '_' for i in range(len(nums))]\n    arr_repr = '[' + ','.join(out_elems) + ']'\n    print(f\"{k}, nums = {arr_repr}\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "2, nums = [1,2,_]",
          "success": true,
          "output": "2, nums = [1,2,_]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
          "expected_output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
          "success": true,
          "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode414.json",
    "problem_index_in_file": 0,
    "title": "Third Maximum Number",
    "description_snippet": "Given an integer array nums, return the third distinct maximum number in this array. If the third ma...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for the described algorithm. The user wants: given an integer array nums, return third distinct maximum number, or max if not exists.\n\nWe need to produce line by line virtual code with explanations. Use Start, End, Decision: with arrows. Avoid actual code. Provide each step with a brief explanation. Steps: initialize first, second, third maximum to -∞ or None; iterate array; update; after loop, if third exists return third else max. But we must use virtual steps.\n\nLet's craft:\n\nStart // begin\n→ Step 1: 初始化 first, second, third 為 null // 用來存最大、第二、第三不同數值\n→ Step 2: 遍歷 nums 中每個元素 num // 逐一檢查\n    → Decision: 若 num 等於 first, second, 或 third? // 排除重複\n        Yes → Step 3: 跳過此 num // 重複值不影響最大值判定\n        No → Decision: 若 first 為 null 或 num > first? // 需要更新第一\n            Yes → Step 4: third ← second // 第三移到第二\n            → Step 5: second ← first // 第二移到第一\n            → Step 6: first ← num // 第一更新為 num\n            No → Decision: 若 second 為 null 或 num > second? // 更新第二\n                Yes → Step 7: third ← second // 第三移到第二\n                → Step 8: second ← num // 第二更新為 num\n                No → Decision: 若 third 為 null 或 num > third? // 更新第三\n                    Yes → Step 9: third ← num // 第三更新為 num\n                    No → Step 10: // 不做任何操作 // num 小於三者皆不更新\n→ Decision: 若 third 為 null? // 是否存在第三個不同最大\n    Yes → Step 11: 回傳 first // 回傳最大值\n    No → Step 12: 回傳 third // 回傳第三個不同最大\nEnd // 結束\n\nBut ensure arrow formatting consistent: use → Step ... and Decision: indentation. Use 'Yes →', 'No →'.\n\nAlso each line: virtual code then // explanation.\n\nCheck we have no actual code. Ok.\n\nMake sure each line is separate, no blank lines? Probably ok.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 first, second, third 為 null // 用來儲存三個不同的最大值  \n→ Step 2: 遍歷 nums 中每個元素 num // 逐一檢查每個數字  \n  → Decision: 若 num 等於 first, second 或 third? // 檢查是否已經存在相同的最大值  \n   Yes → Step 3: 跳過此 num // 重複值不影響最大值判定  \n   No → Decision: 若 first 為 null 或 num > first? // 判斷是否需要更新第一大值  \n    Yes → Step 4: third ← second // 把原第二大值移到第三  \n     → Step 5: second ← first // 把原第一大值移到第二  \n     → Step 6: first ← num // 把新數字設為第一大值  \n    No → Decision: 若 second 為 null 或 num > second? // 判斷是否需要更新第二大值  \n     Yes → Step 7: third ← second // 把原第二大值移到第三  \n      → Step 8: second ← num // 把新數字設為第二大值  \n     No → Decision: 若 third 為 null 或 num > third? // 判斷是否需要更新第三大值  \n      Yes → Step 9: third ← num // 把新數字設為第三大值  \n      No → Step 10: // 目前數字不大於三者皆不更新  \n→ Decision: 若 third 為 null? // 檢查是否存在第三個不同的最大值  \n  Yes → Step 11: 回傳 first // 沒有第三大值，回傳最大值  \n  No → Step 12: 回傳 third // 有第三大值，回傳它  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def thirdMax(self, nums):\n        # 使用集合去除重複值\n        unique_nums = set(nums)\n        # 初始化三個最大值為負無限大\n        first = second = third = float('-inf')\n        # 遍歷唯一值，更新三個最大值\n        for num in unique_nums:\n            if num > first:\n                third = second\n                second = first\n                first = num\n            elif num > second:\n                third = second\n                second = num\n            elif num > third:\n                third = num\n        # 如果集合長度至少為 3，返回第三個最大值；否則返回最大值\n        return third if len(unique_nums) >= 3 else first\n\ndef main():\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    # 只保留等號右側的列表字串\n    if '=' in raw_input:\n        _, list_str = raw_input.split('=', 1)\n    else:\n        list_str = raw_input\n    # 使用 ast.literal_eval 解析為 Python 列表\n    nums = ast.literal_eval(list_str.strip())\n    # 執行解法\n    solution = Solution()\n    result = solution.thirdMax(nums)\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [2,2,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode639.json",
    "problem_index_in_file": 0,
    "title": "Decode Ways II",
    "description_snippet": "A message containing letters from A-Z can be encoded into numbers using the following mapping:\n\n'A' ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code for decoding with '*' wildcards. This is similar to Leetcode 639. Need dynamic programming. We'll produce step-by-step. Use dp[i] number ways for substring s[0:i]. We iterate i from 1 to n. For each position, consider single char and two-char previous.\n\nPseudo steps: Start, read input, define MOD, n. dp array length n+1, dp[0]=1. For i from1 to n: char c = s[i-1].\n\nSingle char ways: if c=='*': ways1=9; else if c!='0': ways1=1 else 0. Add to dp[i].\n\nTwo char ways: if i>=2: prev=s[i-2]. Cases:\n\nIf prev=='*' and c=='*': ways2=15 (11-26 combos: 11-19(9) + 21-26(6) = 15). Actually mapping: '*' can be 1 or 2. For prev='*', c='*': combinations where first digit 1 or 2. If first=1, second any 1-9 =>9. If first=2, second 1-6 =>6. total=15.\n\nIf prev=='*' and c!='*': then if c between '0'..'9'. For first=1, any c =>1 way. For first=2, if c <= '6' =>1. So ways2 = (c <= '6' ? 2 : 1). Actually formula: if c <= '6': 2 else 1. Wait need handle if c '0'? prev='*' could be '1' or '2'; if c='0', only '10' or '20' valid =>2 ways? '20' allowed? yes. So if c=='0': 2 ways. So general: if c <= '6': 2 else 1.\n\nIf prev!='*' and c=='*': if prev == '1': then 9 ways (1* can be 11-19). If prev=='2': then 6 ways (21-26). else 0.\n\nIf both digits not '*': if prev=='1' or (prev=='2' and c<='6'): ways2=1 else 0.\n\nThen dp[i] = (dp[i] + dp[i-2]*ways2) %MOD.\n\nAfter loop, result dp[n].\n\nLet's produce virtual code lines accordingly with explanations.\n\nWe'll use steps: Start, Input, Init dp, Loop i=1..n, compute ways1, ways2, update dp, End.\n\nWe need to format as lines with arrow. Use indentation? We can indent lines after Decision? We'll just produce linear lines with arrows. For nested decisions we can use indentation with spaces. Let's produce.\n\nAlso we might include Decision lines for conditions. For readability, we'll use arrows: → Step. For conditions we can use Decision lines.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s // 讀取編碼字串  \n→ Define MOD = 1000000007 // 取模數  \n→ n = length of s // 字串長度  \n→ Create array dp[0…n] // dp[i] 代表前 i 個字符的解碼方法數  \n→ Set dp[0] = 1 // 空字串只有一種解碼方式  \n\n→ For i = 1 to n // 逐位計算  \n  c = s[i-1] // 目前字符  \n  // 單字符解碼\n  Decision: 如果 c == '*'?  \n   Yes → ways1 = 9 // '*' 可代表 1~9  \n   No → Decision: 如果 c == '0'?  \n    Yes → ways1 = 0 // '0' 無法單獨解碼  \n    No → ways1 = 1 // 1~9 都可解碼一次  \n  dp[i] = (dp[i] + ways1) % MOD  \n\n  // 雙字符解碼（需要 i ≥ 2）\n  Decision: 如果 i ≥ 2?  \n   Yes → prev = s[i-2] // 前一個字符  \n    Decision: 如果 prev == '*'?  \n     Yes → Decision: 如果 c == '*'?  \n      Yes → ways2 = 15 // 1[1-9] + 2[1-6]  \n      No → ways2 = (c <= '6') ? 2 : 1 // '*' 可為 1 或 2  \n          決定 1 或 2 兩種前導，若 c<=6 則兩種皆可  \n          否則只有一種（1 或 2 中符合）  \n      No → Decision: 如果 c == '*'?  \n       Yes → ways2 = (prev == '1') ? 9 : (prev == '2') ? 6 : 0 // 1* 或 2*  \n       No → Decision: 如果 (prev == '1' OR (prev == '2' AND c <= '6'))?  \n        Yes → ways2 = 1 // 兩位合法，例如 12、26  \n        No → ways2 = 0 // 兩位無效  \n    dp[i] = (dp[i] + dp[i-2] * ways2) % MOD  \n\nEnd // 迴圈結束  \n→ Output dp[n] // 回傳最終解碼方法數目\n\n（上述虛擬碼遵循逐行、即時解釋的格式，使用 Start/End、Decision 以及箭頭符號，並在每行後提供簡短說明。）",
      "generated_code": "#!/usr/bin/env python3\nimport sys\nimport re\n\nMOD = 10 ** 9 + 7\n\ndef num_decodings(s: str) -> int:\n    \"\"\"Return the number of ways to decode the string `s`.\"\"\"\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1  # 空字串只有一種解碼方式\n\n    for i in range(1, n + 1):\n        c = s[i - 1]\n\n        # ---- 單字符解碼 ----\n        if c == '*':\n            dp[i] = 9 * dp[i - 1]\n        elif c != '0':\n            dp[i] = dp[i - 1]\n        # else c == '0' 只能由兩字符組合解碼，單字符不計算\n\n        # ---- 雙字符解碼 ----\n        if i >= 2:\n            prev = s[i - 2]\n            ways2 = 0\n            if prev == '*' and c == '*':\n                # 1[1-9] (9種) + 2[1-6] (6種) = 15種\n                ways2 = 15\n            elif prev == '*':\n                # prev 可以是 1 或 2\n                ways2 = 2 if c <= '6' else 1\n            elif c == '*':\n                # prev 已固定\n                if prev == '1':\n                    ways2 = 9\n                elif prev == '2':\n                    ways2 = 6\n                else:\n                    ways2 = 0\n            else:\n                # 兩個都是數字\n                if prev == '1' or (prev == '2' and c <= '6'):\n                    ways2 = 1\n                else:\n                    ways2 = 0\n            dp[i] = (dp[i] + dp[i - 2] * ways2) % MOD\n        else:\n            dp[i] %= MOD\n\n    return dp[n]\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    # 嘗試抽取引號中的字串；如果找不到則直接使用整行輸入\n    match = re.search(r'[\"\\'](.*?)[\"\\']', data)\n    s = match.group(1) if match else data\n    result = num_decodings(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"*\"",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "s = \"1*\"",
          "expected_output": "18",
          "success": true,
          "output": "18"
        },
        {
          "example_index": 2,
          "input": "s = \"2*\"",
          "expected_output": "15",
          "success": true,
          "output": "15"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode367.json",
    "problem_index_in_file": 0,
    "title": "Valid Perfect Square",
    "description_snippet": "Given a positive integer num, return true if num is a perfect square or false otherwise.\nA perfect s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for checking perfect square without sqrt. Should use binary search or iterative approximation. Use while loop.\n\nWe output line by line virtual code steps. Each line: \"虛擬碼步驟 // 解釋\". Use Start, Decision, etc.\n\nWe must produce for the described problem. Let's produce algorithm: Start, if num <=1 return true. Set left=1, right=num/2. While left <= right: mid = left + (right - left)/2. square = mid * mid. If square == num: return true. Else if square < num: left=mid+1 else right=mid-1. After loop return false.\n\nWe will produce virtual code lines with arrows.\n\nLet's produce. Use Start, Step, Decision, etc. Ensure each line ends with // explanation.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 檢查 num 是否小於等於 1 // 小數 (0,1) 皆為平方數\n    Decision: num <= 1 ?\n        Yes → Step 2: 回傳 true // 直接返回 true\n        No  → Step 3: 設定 left = 1 // 左邊界初值\n→ Step 4: 設定 right = num / 2 // 右邊界不需要大於 num/2，因為平方根必小於 num/2（num > 1）\n→ Step 5: 進入 while loop // 只要左邊界不超過右邊界就持續搜尋\n    Decision: left <= right ?\n        Yes →\n            → Step 6: 計算 mid = left + (right - left) / 2 // 防止溢位的安全計算\n            → Step 7: 計算 square = mid * mid // mid 的平方\n            → Decision: square == num ?\n                Yes → Step 8: 回傳 true // 找到平方根，返回真\n                No  →\n                    → Decision: square < num ?\n                        Yes → Step 9: left = mid + 1 // 平方小於目標，往右移動左邊界\n                        No  → Step 10: right = mid - 1 // 平方大於目標，往左移動右邊界\n        No  → Step 11: 回傳 false // 迴圈結束仍未找到，非平方數\nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        \"\"\"判斷 num 是否為完全平方數，不使用 sqrt 函式。\"\"\"\n        if num <= 1:\n            # 0、1 都是平方數\n            return True\n\n        # 二分搜尋範圍設為 1 ~ num // 2\n        left, right = 1, num // 2\n\n        while left <= right:\n            mid = left + (right - left) // 2  # 防止溢位\n            square = mid * mid\n\n            if square == num:\n                return True\n            elif square < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return False\n\n\ndef main():\n    import sys\n    import re\n\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中擷取第一個整數（支持 'num = 16' 等格式）\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    num = int(nums[0])\n\n    solution = Solution()\n    result = solution.isPerfectSquare(num)\n    print('true' if result else 'false')\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "num = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode53.json",
    "problem_index_in_file": 0,
    "title": "Maximum Subarray",
    "description_snippet": "Given an integer array nums, find the subarray with the largest sum, and return its sum....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for Kadane's algorithm. We'll produce step-by-step virtual code. Need to output each line with virtual code step and comment. Use Start, End, Decision. Use arrow arrows. Each line ends with // explanation. Ensure no real code. Let's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 maxSum 為 nums[0] // 設定最大子陣列和為第一個元素  \n→ Step 2: 初始化 currentSum 為 nums[0] // 設定目前子陣列和為第一個元素  \n→ Step 3: 從索引 1 開始遍歷 nums  \n→ Decision: 如果 currentSum < 0? // 判斷目前子陣列和是否負數  \n  Yes → currentSum ← nums[i] // 若負，從當前元素重新開始子陣列  \n  No  → currentSum ← currentSum + nums[i] // 否則將當前元素加入子陣列  \n→ Decision: 如果 currentSum > maxSum? // 判斷目前子陣列和是否大於已知最大值  \n  Yes → maxSum ← currentSum // 更新最大子陣列和  \n  No  → // 保持 maxSum 不變  \n→ Step 4: 完成遍歷 // 所有元素已處理完畢  \nEnd // 回傳 maxSum 為最大子陣列和\n\n（此虛擬碼為 Kadane 演算法的逐行說明，僅展示流程邏輯，未包含實際程式碼）",
      "generated_code": "import sys\nimport ast\n\ndef max_subarray(nums):\n    \"\"\"Kadane's algorithm to find the maximum subarray sum.\"\"\"\n    max_current = max_global = nums[0]\n    for num in nums[1:]:\n        max_current = max(num, max_current + num)\n        if max_current > max_global:\n            max_global = max_current\n    return max_global\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Extract the list from input like \"nums = [1, 2, 3]\"\n    # We assume the format contains '=' followed by a list.\n    try:\n        _, list_part = raw_input.split('=', 1)\n        nums = ast.literal_eval(list_part.strip())\n    except Exception:\n        # If parsing fails, try to evaluate the whole input directly\n        nums = ast.literal_eval(raw_input)\n\n    result = max_subarray(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [5,4,-1,7,8]",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode14.json",
    "problem_index_in_file": 0,
    "title": "Longest Common Prefix",
    "description_snippet": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for function to find longest common prefix among array of strings. We need to produce step by step virtual code with explanation after each line. Use virtual arrows. Need Start, End, Decision etc.\n\nWe should design steps: Start, Check if array empty, get first string as prefix, iterate through other strings, for each, while current prefix not empty and string doesn't start with prefix, reduce prefix length by one char. If prefix becomes empty, break. After loop, return prefix. End.\n\nNeed to reflect decision branches: check array empty, check if prefix matches each string, etc.\n\nWe need to include each step line: e.g., \"Start // 程式開始執行\". Then \"→ Step 1: Check if array is empty // ...\".\n\nWe need to use arrow \"→\" for steps, \"Decision:\" for conditional. Use Yes → and No →.\n\nMake sure each line has format \"虛擬碼步驟 [space] // 解釋\".\n\nLet's craft.\n\nStart\n→ Step 1: Input array of strings // 從使用者處取得字串陣列\n→ Decision: 如果陣列為空? // 檢查是否沒有任何字串\n    Yes → Step 2: Return \"\" // 空陣列，回傳空字串\n    No  → Step 3: 設定 prefix = 第1個字串 // 以第一個字串作為初始前綴\n→ Decision: 迴圈從第二個字串到最後一個? // 檢查是否還有字串要比對\n    Yes → Step 4: 取 currentString // 取當前字串\n    → Decision: 是否 prefix 為 currentString 的前綴? // 檢查前綴是否匹配\n        Yes → Step 5: 轉到下一個字串 // 前綴匹配，繼續\n        No  → Step 6: 降低 prefix 長度一次 // 前綴不匹配，縮短前綴\n            → Decision: prefix 變為空? // 檢查前綴是否已空\n                Yes → Step 7: Return \"\" // 無共同前綴，直接回傳空字串\n                No  → Step 8: 回到 Step 4 // 重新檢查縮短後的前綴\n→ Step 9: Return prefix // 所有字串都比對完成，回傳最長共同前綴\nEnd // 程式結束\n\nBut we need to be careful about step numbering. The steps should be linear with decisions nested. We need to use \"Decision:\" with Yes →, No →, and inside decisions. For loops, maybe use \"→ Step 4: 迴圈 for i in 1..len-1\" etc. The format can be simplified: Use decision for loop start? Might use \"Decision: 有剩餘字串?\" then Yes branch is loop body. Or just use \"→ Step 4: For each string starting from index 1\". But we should keep consistent arrow usage. Let's design as:\n\nStart\n→ Step 1: 接收字串陣列 strings // 取得輸入字串陣列\n→ Decision: strings 為空?\n    Yes → Step 2: Return \"\" // 若陣列空，直接回傳空字串\n    No  → Step 3: prefix = strings[0] // 以第一個字串為初始前綴\n→ Step 4: For i from 1 to length(strings)-1 // 逐一比對剩餘字串\n    → Step 5: current = strings[i] // 取得當前字串\n    → Decision: prefix 是否是 current 的前綴?\n        Yes → Step 6: 轉到下一個迴圈 // 前綴匹配，繼續\n        No  → Step 7: prefix = prefix 的前 n-1 個字元 // 前綴不匹配，縮短\n            → Decision: prefix 為空?\n                Yes → Step 8: Return \"\" // 無共同前綴，回傳空字串\n                No  → Step 9: 重新檢查縮短後的前綴 // 回到 Decision 步驟\n→ Step 10: Return prefix // 所有字串比對完成，回傳最長前綴\nEnd\n\nBut each line must be \"虛擬碼步驟 // 解釋\". For decision lines, the format \"Decision: ...? // ...\". For Yes → and No → lines, include arrow.\n\nAlso ensure each step is separate line. We might need to indent for nested decisions but just separate lines.\n\nLet's produce final output. Ensure no real code. Use proper Chinese explanations.\n\nWe need to produce exactly as asked: step by step. Provide lines with \"虛擬碼步驟\" and explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收字串陣列 strings // 從使用者處取得輸入字串陣列  \n→ Decision: strings 為空? // 檢查是否沒有任何字串  \n  Yes → Step 2: Return \"\" // 若陣列空，直接回傳空字串  \n  No  → Step 3: prefix = strings[0] // 以第一個字串作為初始前綴  \n→ Step 4: For i 從 1 到 length(strings)-1 // 逐一比對剩餘字串  \n  → Step 5: current = strings[i] // 取得當前字串  \n  → Decision: prefix 是否是 current 的前綴? // 檢查前綴是否匹配  \n    Yes → Step 6: 轉到下一個迴圈 // 前綴匹配，繼續比對  \n    No  → Step 7: prefix = prefix 的前 n-1 個字元 // 前綴不匹配，縮短前綴  \n        → Decision: prefix 為空? // 檢查前綴是否已空  \n          Yes → Step 8: Return \"\" // 無共同前綴，直接回傳空字串  \n          No  → Step 9: 重新檢查縮短後的前綴 // 回到 Decision 步驟  \n→ Step 10: Return prefix // 所有字串比對完成，回傳最長前綴  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef longest_common_prefix(strs):\n    \"\"\"\n    找出字串陣列中的最長公共前綴。\n    若陣列為空，回傳空字串。\n    \"\"\"\n    if not strs:\n        return \"\"\n    prefix = strs[0]\n    for s in strs[1:]:\n        # 不斷縮短 prefix，直到它成為 s 的前綴\n        while not s.startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    return prefix\n\ndef main():\n    \"\"\"\n    讀取 stdin，解析字串列表，計算最長公共前綴並輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 若資料中包含 '='，則取等號右側作為列表字串\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n\n    list_part = list_part.strip()\n\n    try:\n        # 使用 literal_eval 解析安全的 Python 表達式\n        strs = ast.literal_eval(list_part)\n    except Exception:\n        # 若解析失敗，假設輸入為以空白分隔的字串\n        strs = list_part.split()\n\n    result = longest_common_prefix(strs)\n    # 輸出時包含雙引號\n    if result == \"\":\n        print('\"\"')\n    else:\n        print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"flower\",\"flow\",\"flight\"]",
          "expected_output": "\"fl\"",
          "success": true,
          "output": "\"fl\""
        },
        {
          "example_index": 1,
          "input": "strs = [\"dog\",\"racecar\",\"car\"]",
          "expected_output": "\"\"",
          "success": true,
          "output": "\"\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode72.json",
    "problem_index_in_file": 0,
    "title": "Edit Distance",
    "description_snippet": "Given two strings word1 and word2, return the minimum number of operations required to convert word1...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve the edit distance (Levenshtein distance) problem. Output each line: step and comment. Use Start, End, Decision. Use arrows. We should show algorithm: DP table. Steps: initialize matrix, fill first row/col, iterate, compute min of three operations, set dp[i][j], then output dp[m][n]. Provide explanation. We should produce \"Start\" then steps. Use virtual code lines. We'll do something like:\n\nStart\n→ Step 1: Let m = length(word1), n = length(word2) // Get lengths\n→ Step 2: Create 2D array dp of size (m+1) x (n+1) // DP table\n→ Step 3: For i from 0 to m: dp[i][0] = i // Deleting i chars\n→ Step 4: For j from 0 to n: dp[0][j] = j // Inserting j chars\n→ Step 5: For i from 1 to m:\n    → For j from 1 to n:\n        → Decision: word1[i-1] == word2[j-1]? // Check characters\n            Yes → dp[i][j] = dp[i-1][j-1] // No operation needed\n            No → dp[i][j] = 1 + Minimum( dp[i-1][j] (delete), dp[i][j-1] (insert), dp[i-1][j-1] (replace) ) // Apply operation\n→ Step 6: Result = dp[m][n] // Minimum operations\nEnd\n\nWe need to use \"Decision:\" for condition. For nested loops, we can show indentation.\n\nMake sure each line ends with // explanation. Use \"→\" before each step. For Decision, indent following Yes/No lines with 4 spaces.\n\nLet's format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let m = length(word1) // 取得 word1 的長度  \n→ Step 2: Let n = length(word2) // 取得 word2 的長度  \n→ Step 3: Create 2D array dp of size (m+1) × (n+1) // 建立 DP 表格  \n→ Step 4: For i from 0 to m: dp[i][0] = i // 初始化第一列（刪除操作）  \n→ Step 5: For j from 0 to n: dp[0][j] = j // 初始化第一行（插入操作）  \n→ Step 6: For i from 1 to m: // 逐行處理 word1  \n    → For j from 1 to n: // 逐列處理 word2  \n        → Decision: word1[i-1] == word2[j-1]? // 檢查對應字元是否相同  \n            Yes → dp[i][j] = dp[i-1][j-1] // 字元相同，無需任何操作  \n            No → dp[i][j] = 1 + Minimum( dp[i-1][j] (delete), dp[i][j-1] (insert), dp[i-1][j-1] (replace) ) // 計算最小操作數  \n→ Step 7: Result = dp[m][n] // 最小編輯距離  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_distance(word1: str, word2: str) -> int:\n    \"\"\"計算兩個字串之間的 Levenshtein 距離（最小編輯距離）。\"\"\"\n    m, n = len(word1), len(word2)\n    # 建立 (m+1) x (n+1) 的 DP 表\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # 初始化第一列與第一行（分別對應刪除與插入）\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    # 填充 DP 表格\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # 字元相同，無需操作\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],     # 刪除\n                    dp[i][j - 1],     # 插入\n                    dp[i - 1][j - 1]  # 替換\n                )\n    return dp[m][n]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n\n    # 嘗試從雙引號中提取兩個字串\n    quoted = re.findall(r'\"([^\"]*)\"', raw_input)\n    if len(quoted) >= 2:\n        word1, word2 = quoted[0], quoted[1]\n    else:\n        # 如果沒有雙引號，直接拆分空白字元取前兩個非空值\n        parts = [p for p in raw_input.replace(',', ' ').split() if p]\n        word1 = parts[0] if parts else \"\"\n        word2 = parts[1] if len(parts) > 1 else \"\"\n\n    result = min_distance(word1, word2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "word1 = \"horse\", word2 = \"ros\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "word1 = \"intention\", word2 = \"execution\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode765.json",
    "problem_index_in_file": 0,
    "title": "Couples Holding Hands",
    "description_snippet": "There are n couples sitting in 2n seats arranged in a row and want to hold hands.\n\nThe people and se...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: minimal swaps to arrange couples side by side. Known solution: treat as graph: each seat pair (i,i+1). Each person should be in pair with their partner. We can swap any two. Equivalent to find number of cycles. Approach: mapping from person to seat index. For each pair of seats (2k,2k+1). If seat pair contains not the correct couple, we need to swap one with partner's seat. Build graph between current person at seat and the seat they should be. Actually typical solution: Count swaps as n - number_of_connected_components in graph of couples. But simpler: iterate over pairs; if pair not correct, find partner's seat, swap them, increment swaps. Continue until all correct. This is O(n^2) worst-case but can be optimized using index map.\n\nWe produce virtual code with steps.\n\nWill produce step lines like:\n\nStart // start program\n→ Step 1: Initialize index map from person ID to seat position // map for O(1) lookup\n\n→ Step 2: Initialize swap counter to 0 // count swaps\n\n→ Step 3: For each seat index i from 0 to length-1 step 2 // iterate over seat pairs\n\n   → Decision: if row[i] and row[i+1] are couple? // check\n\n      Yes → Continue // already correct\n\n      No → …\n\nWe need to identify partner: partner = row[i] ^ 1 (since couples consecutive numbers 0-1,2-3 etc). So partner id = row[i] ^ 1. Find seat position j = indexMap[partner]. Then swap row[i+1] with row[j], update indexMap accordingly, increment swap.\n\nThen continue.\n\nReturn swap counter.\n\nAlso handle loop until correct.\n\nWe'll write virtual code accordingly.\n\nNeed to provide explanation after each line.\n\nLet's craft.\n\nAlso need to consider that indexMap updated after swapping.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立一個映射 indexMap，將每個人 ID 映射到他們現在所在的座位位置 // 方便 O(1) 查找某人在哪裡\n    // indexMap[person] = seatIndex\n→ Step 2: 初始化 swapCount 為 0 // 以記錄需要進行的交換次數\n→ Step 3: 取得座位總數 m = row.length // 2n\n→ Step 4: 以 2 為步長遍歷座位 i 從 0 到 m-1 // 每次處理一對相鄰座位 (i, i+1)\n    // 迴圈主體開始\n    → Decision: 如果 row[i] 和 row[i+1] 已經是正確的夫妻? // 即 (row[i] % 2 == 0 && row[i+1] == row[i]+1) 或相反\n        Yes → // 這對座位已經配對，無需任何操作\n        No  → // 需要交換\n            → Step 5: 計算 row[i] 的配偶 partner = row[i] XOR 1 // 0<->1, 2<->3, 4<->5, ...\n            → Step 6: 找到 partner 所在的座位 partnerPos = indexMap[partner]\n            → Step 7: 交換座位 i+1 與 partnerPos 之間的人 // 使 partner 進入正確位置\n                // 交換前: row[i+1] = a, row[partnerPos] = partner\n                // 交換後: row[i+1] = partner, row[partnerPos] = a\n                // 同時更新映射\n                // indexMap[row[i+1]] = i+1\n                // indexMap[row[partnerPos]] = partnerPos\n            → Step 8: 將 swapCount 加 1 // 已完成一次交換\n    // 迴圈結束\n→ Step 9: 回傳 swapCount // 最小交換次數\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def minSwapsCouples(self, row):\n        n = len(row)\n        pos = [0] * n\n        for i, x in enumerate(row):\n            pos[x] = i\n        swaps = 0\n        for i in range(0, n, 2):\n            x = row[i]\n            y = x ^ 1\n            if row[i+1] != y:\n                partner_idx = pos[y]\n                row[i+1], row[partner_idx] = row[partner_idx], row[i+1]\n                pos[row[partner_idx]] = partner_idx\n                pos[row[i+1]] = i+1\n                swaps += 1\n        return swaps\n\ndef parse_input(inp):\n    inp = inp.strip()\n    if not inp:\n        return []\n    if inp.startswith('row'):\n        _, val = inp.split('=', 1)\n        val = val.strip()\n        return eval(val)\n    # if input is just a list representation\n    return eval(inp)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    row = parse_input(data)\n    sol = Solution()\n    result = sol.minSwapsCouples(row)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "row = [0,2,1,3]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "row = [3,2,0,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode374.json",
    "problem_index_in_file": 0,
    "title": "Guess Number Higher or Lower",
    "description_snippet": "We are playing the Guess Game. The game is as follows: \n\nI pick a number from 1 to n. You have to gu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for binary search guess game. We need to output each line: \"虛擬碼步驟 // 解釋\". Use arrow notation. Use Start, End, Decision: etc. No actual code. So something like:\n\nStart\n→ Initialize left=1, right=n\n→ Decision: left <= right?\n    Yes → mid = (left+right)/2\n    → Call guess(mid)\n    → Decision: result==0? \n        Yes → Return mid\n        No → Decision: result<0?\n            Yes → right=mid-1\n            No → left=mid+1\n        Go back to Decision: left <= right\n    No → End\n\nWe need to ensure we use arrows and decisions. Provide explanation after each line.\n\nAlso ensure each line has \"虛擬碼步驟\" then space then \"// 解釋\". Provide in Traditional Chinese. Use \"→\" arrow. Use \"Decision:\".\n\nLet's craft. We'll format as:\n\nStart // 程式開始執行\n→ Set left = 1, right = n // 初始化搜尋區間\n→ Decision: left <= right? // 檢查是否仍有區間可搜尋\n    Yes → mid = (left + right) / 2 // 計算中間值作為猜測\n    → Call guess(mid) // 呼叫 API 獲取結果\n    → Decision: result == 0? // 判斷是否猜對\n        Yes → Return mid // 找到目標，結束\n        No  → Decision: result < 0? // 判斷猜的數是太小還是太大\n            Yes → left = mid + 1 // 猜的數太小，縮小左邊界\n            No  → right = mid - 1 // 猜的數太大，縮小右邊界\n        Go back to Decision: left <= right // 重新檢查區間\n    No → End // 沒有區間可搜尋，結束（理論上不會發生）\nEnd // 程式執行結束\n\nWe need to keep each line with \"虛擬碼步驟\" and explanation. Should we include the indentation lines? The format example shows indentation for substeps. So we can use indentation with spaces or maybe tab. Let's use 4 spaces for indentation after \"Decision\". Provide arrow and explanation.\n\nWe must not output actual code but virtual code. Use \"Start\", \"End\" etc. Should be okay.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Set left = 1, right = n // 初始化搜尋區間  \n→ Decision: left <= right? // 檢查是否還有可搜尋的區間  \n    Yes → mid = (left + right) / 2 // 計算中間值作為下一次猜測  \n    → Call guess(mid) // 呼叫 API 獲得對比結果  \n    → Decision: result == 0? // 判斷是否猜對  \n        Yes → Return mid // 找到目標，結束程式  \n        No  → Decision: result < 0? // 判斷猜的數是太小還是太大  \n            Yes → left = mid + 1 // 猜的數太小，將左邊界移到 mid+1  \n            No  → right = mid - 1 // 猜的數太大，將右邊界移到 mid-1  \n        Go back to Decision: left <= right // 重新檢查是否仍有可搜尋區間  \n    No → End // 沒有區間可搜尋（理論上不會發生）  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef guess(num: int) -> int:\n    \"\"\"\n    Simulated API that compares the guessed number with the hidden pick.\n    Returns:\n        0 if num == pick,\n        -1 if num > pick,\n        1 if num < pick.\n    \"\"\"\n    return 0 if num == _pick else (-1 if num > _pick else 1)\n\nclass Solution:\n    def guessNumber(self, n: int) -> int:\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            res = guess(mid)\n            if res == 0:\n                return mid\n            elif res < 0:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1  # 理論上不會到這裡\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入並從中提取所有整數\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n\n    if len(numbers) < 2:\n        sys.exit(1)  # 輸入不合法，直接退出\n\n    n, _pick = numbers[0], numbers[1]  # 取得 n 和隱藏的 pick\n\n    solution = Solution()\n    result = solution.guessNumber(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10, pick = 6",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 1, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode18.json",
    "problem_index_in_file": 0,
    "title": "4Sum",
    "description_snippet": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the output format. It should solve 4Sum problem. Use sorting, two pointers, etc. Provide each line with explanation. We need to be careful: use virtual code syntax like `→ Step 1: ...`. We must not output actual code. Provide each line with virtual code and comment. Let's outline steps:\n\nStart\n\n→ Step 1: Sort the array nums // For easier duplicate handling\n\n→ Step 2: Initialize result list res // To store quadruplets\n\n→ Step 3: Set n = length of nums\n\n→ Decision: If n < 4? // Not enough elements\n\nYes → End // Return empty result\n\nNo → For i from 0 to n-4\n\n→ Decision: If i > 0 and nums[i] == nums[i-1]? // skip duplicate first element\n\nYes → Continue // skip\n\nNo → For j from i+1 to n-3\n\n→ Decision: If j > i+1 and nums[j] == nums[j-1]? // skip duplicate second element\n\nYes → Continue // skip\n\nNo → Set left = j+1, right = n-1\n\n→ Decision: While left < right\n\n→ Decision: sum = nums[i] + nums[j] + nums[left] + nums[right] // compute sum\n\n→ Decision: If sum == target\n\nYes → Append quadruplet to res // add found quadruplet\n\n→ Decision: Move left to next distinct value\n\n→ Decision: While left < right and nums[left] == nums[left-1] left++\n\n→ Decision: Move right to previous distinct value\n\n→ Decision: While left < right and nums[right] == nums[right+1] right--\n\n→ Decision: Else if sum < target\n\nYes → left++ // need larger sum\n\nNo → right-- // need smaller sum\n\nEnd // after loops\n\n→ Step 4: Return res // result\n\nEnd\n\nAlso we should include comments after each line.\n\nWe need to format exactly as specified: each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use arrows and decisions.\n\nWe should include proper indentation? Not required but can indent sub steps. But each line separate.\n\nLet's produce.\n\nWe need to include Start and End. Provide the steps. Also we can include \"Step\" or \"Decision\". Provide a line for loop. Each line we include arrow arrow? The example uses `→ Step 1:` for step, and `Decision:` for decision. Use `Yes →` and `No →` for branches.\n\nLet's produce. We'll label each step as `Step 1`, `Step 2`, etc. We should show loops. For loops, we might use `→ For i = 0 to n-4:`.\n\nWe need to incorporate decisions inside loops. We'll show nested decisions. For skipping duplicates: `Decision: 如果 i>0 且 nums[i]==nums[i-1]?`. Then Yes branch: `Continue // skip duplicate first element`.\n\nSimilarly for j duplicates.\n\nThen inside while loop, decision for sum equals target or less.\n\nWe also need to move left and right skipping duplicates.\n\nLet's write. Use Chinese comments.\n\nWe must avoid actual code like `nums[i]`. But can mention variable names.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums // 將陣列排序以便後續去重  \n→ Step 2: Initialize res as empty list // 用來儲存符合條件的四元組  \n→ Step 3: Set n = length of nums // 獲取陣列長度  \n→ Decision: 如果 n < 4? // 是否有足夠元素  \n Yes → End // 沒有四個元素，直接結束，返回空結果  \n No  →  \n  For i from 0 to n-4 // 選擇第一個數字  \n   Decision: 如果 i > 0 且 nums[i] == nums[i-1]? // 去重第一個數字  \n    Yes → Continue // 跳過重複  \n    No  →  \n     For j from i+1 to n-3 // 選擇第二個數字  \n      Decision: 如果 j > i+1 且 nums[j] == nums[j-1]? // 去重第二個數字  \n       Yes → Continue // 跳過重複  \n       No  →  \n        Set left = j+1, right = n-1 // 左右指標開始位置  \n        Decision: While left < right // 繼續尋找可能的配對  \n          Set sum = nums[i] + nums[j] + nums[left] + nums[right] // 計算四數之和  \n         Decision: 如果 sum == target? // 找到一組  \n           Yes → Append [nums[i], nums[j], nums[left], nums[right]] to res // 加入結果  \n            Decision: Move left to next distinct value  \n             While left < right and nums[left] == nums[left-1] left++ // 跳過重複左側  \n            Decision: Move right to previous distinct value  \n              While left < right and nums[right] == nums[right+1] right-- // 跳過重複右側  \n            Decision: 如果 sum < target? // 和太小，需要增大  \n             Yes → left++ // 向右移動左指標  \n             No  → right-- // 向左移動右指標  \n         End // while 結束  \n        End // j loop 結束  \n     End // i loop 結束  \n→ Step 4: Return res // 返回所有符合條件的四元組  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def fourSum(self, nums, target):\n        nums.sort()\n        n = len(nums)\n        res = []\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not target_match:\n        return\n    nums = eval(nums_match.group(1))\n    target = int(target_match.group(1))\n    solution = Solution()\n    result = solution.fourSum(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,0,-1,0,-2,2], target = 0",
          "expected_output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
          "success": true,
          "output": "[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2], target = 8",
          "expected_output": "[[2,2,2,2]]",
          "success": true,
          "output": "[[2, 2, 2, 2]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode509.json",
    "problem_index_in_file": 0,
    "title": "Fibonacci Number",
    "description_snippet": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, each line with \"虛擬碼步驟\" and explanation. Use arrows and decisions. So for Fibonacci, we can do iterative or recursive. We'll produce simple iterative approach. Steps: Start, input n, initialize a=0, b=1, counter=1, Decision: if n==0? Yes -> output a, End. Else if n==1? Yes -> output b. Else loop from i=2 to n: compute next = a+b, set a=b, b=next. After loop output b. End. Use arrow. Provide each step on a new line. Ensure formatting exactly: \"虛擬碼步驟 // 解釋/說明\". Use arrow symbols. Should include Start and End. Use Decision. Use Yes → and No → lines indented? In example, indentation with spaces. Let's follow similar. Use 4 spaces for indentation after Decision. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n // 取得要計算的 Fibonacci 索引  \n→ Step 2: 設定 a = 0, b = 1, i = 2 // 初始化前兩個 Fibonacci 數  \n→ Decision: n == 0? // 檢查是否是第一個數  \n    Yes → Step 3: 輸出 a // n=0 時輸出 0  \n    No → Decision: n == 1? // 檢查是否是第二個數  \n        Yes → Step 4: 輸出 b // n=1 時輸出 1  \n        No → Step 5: 進入迴圈 // n>1 時進行迭代計算  \n→ Decision: i <= n? // 迴圈條件，從 2 到 n  \n    Yes → Step 6: 計算 temp = a + b // 取前兩數之和  \n    → Step 7: 更新 a = b, b = temp // 前移更新為新的 Fibonacci  \n    → Step 8: i = i + 1 // 索引加一  \n    → Step 5 // 回到迴圈條件  \n    No  → Step 9: 輸出 b // 迴圈結束，b 為 F(n)  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def fib(self, n: int) -> int:\n        \"\"\"計算第 n 個 Fibonacci 數字（0-indexed）\"\"\"\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取 n，輸出 F(n)\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入字串中提取第一個整數\n    match = re.search(r'\\d+', data)\n    if not match:\n        raise ValueError(\"輸入中未找到有效的整數\")\n    n = int(match.group())\n    result = Solution().fib(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode15.json",
    "problem_index_in_file": 0,
    "title": "3Sum",
    "description_snippet": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for finding all unique triplets in an array that sum to zero. We need to output line by line with arrow and comment. Should follow pattern with Start, → Step, Decision etc. We need to use arrow \"→\" for steps. We need to include \"Start\" and \"End\". Steps: Sort array, iterate i, use two pointers left right. Ensure skip duplicates. We must produce no actual code but pseudocode steps. Each line must be \"虛擬碼步驟 [space] // 解釋\". We'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: Sort array nums ascending // 先將陣列排序，方便後續雙指標與去重\n\n→ Step 2: 取得陣列長度 n // 需要長度以判斷迴圈範圍\n\n→ Decision: 如果 n < 3? // 無法形成三元組\n    Yes → End // 直接結束，無結果\n    No  → Loop i from 0 to n-3 // 以第一個元素作為起點\n\nWithin loop:\n\n→ Step 3: 如果 i > 0 且 nums[i] == nums[i-1]？ // 跳過重複的第一個元素\n    Yes → Continue to next i // 避免重複三元組\n    No  → // continue\n\n→ Step 4: 設定 left = i+1, right = n-1 // 兩指標在剩餘部分\n\n→ Decision: 如果 left < right? // 仍有可檢查的組合\n    Yes → Step 5: sum = nums[i] + nums[left] + nums[right] // 計算三數之和\n        Decision: 如果 sum == 0?\n            Yes → Step 6: 加入 [nums[i], nums[left], nums[right]] 至結果集 // 找到合法三元組\n                Step 7: left++ // 移動左指標\n                Step 8: right-- // 移動右指標\n                → Decision: 如果 left < n 且 nums[left] == nums[left-1]? // 跳過重複左值\n                    Yes → Step 9: left++ // 跳過重複\n                    No  → // 直接繼續\n                → Decision: 如果 right >= 0 且 nums[right] == nums[right+1]? // 跳過重複右值\n                    Yes → Step 10: right-- // 跳過重複\n                    No  → // 繼續\n            No  → Decision: 如果 sum < 0?\n                Yes → Step 11: left++ // 和太小，左指標往右\n                No  → Step 12: right-- // 和太大，右指標往左\n    No  → // left >= right, 退出此 i 的內部循環\n\nAfter loops end, End.\n\nBut we need to output lines following format: each line \"虛擬碼步驟 // 解釋\". Use arrow \"→\" and indent for decision. We should not output code but pseudocode steps. For decision lines, we can use \"Decision:\" with indentation lines using Yes → and No →. Must preserve the arrow.\n\nWe should be careful to output exactly as format: each line includes \"虛擬碼步驟\" e.g. \"Start\", \"→ Step 1: ...\", \"Decision: ...\", \"Yes → ...\", \"No → ...\". After each line, space then \"// 解釋\".\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort array nums ascending // 先將陣列排序，方便後續雙指標與去重  \n→ Step 2: 取得陣列長度 n // 需要長度以判斷迴圈範圍  \n→ Decision: 如果 n < 3? // 無法形成三元組  \n  Yes → End // 直接結束，無結果  \n  No  → Loop i from 0 to n-3 // 以第一個元素作為起點",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def threeSum(self, nums):\n        nums.sort()\n        res = []\n        n = len(nums)\n        for i in range(n):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            left, right = i + 1, n - 1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if total == 0:\n                    res.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n                elif total < 0:\n                    left += 1\n                else:\n                    right -= 1\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data.strip()\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        nums = []\n    result = Solution().threeSum(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,1,2,-1,-4]",
          "expected_output": "[[-1,-1,2],[-1,0,1]]",
          "success": true,
          "output": "[[-1, -1, 2], [-1, 0, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,0,0]",
          "expected_output": "[[0,0,0]]",
          "success": true,
          "output": "[[0, 0, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode474.json",
    "problem_index_in_file": 0,
    "title": "Ones and Zeroes",
    "description_snippet": "You are given an array of binary strings strs and two integers m and n.\n\nReturn the size of the larg...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: maximum subset of binary strings with constraints m zeros and n ones. Classic DP problem 474. So produce algorithm: DP over counts: dp[i][j] maximum subset size using at most i zeros and j ones. Iterate strings, count zeros and ones, update dp backwards. Return dp[m][n].\n\nWe must output virtual code line by line, with explanations.\n\nWe'll use Start, → Step, Decision. Use arrows.\n\nOk produce.\n\nLet's craft.\n\nWe need to cover:\n\nStart\n→ Step 1: 取得 strs, m, n\n→ Step 2: 初始化 dp 為 (m+1) x (n+1) 的 0\n→ For each string s in strs:\n    → Count zeros z and ones o\n    → Decision: if z <= m and o <= n? // skip if exceed? Actually still can skip but we only update if within bounds.\n    → For i from m down to z:\n        → For j from n down to o:\n            → Step: dp[i][j] = max(dp[i][j], dp[i-z][j-o] + 1)\n→ Step: 回傳 dp[m][n]\nEnd\n\nAdd explanations.\n\nAlso maybe show decision to check counts.\n\nAlso note for each string we iterate.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 strs 與限制 m、n // 從使用者或函式參數獲得資料  \n→ Step 2: 初始化 dp 為 (m+1) × (n+1) 的全零二維表 // dp[i][j] 代表最多使用 i 個 0 與 j 個 1 時可取的字串數量  \n→ For each string s in strs: // 逐一處理每個二進位字串  \n  → Step 3: 計算 s 中 0 的數量 z 與 1 的數量 o // 需要的資源數量  \n  → Decision: 如果 z > m 或 o > n? // 若超過總限制直接跳過此字串  \n    Yes → Continue to next string // 無法加入任何子集，跳過  \n    No  → For i from m down to z: // 從後往前更新以避免重複使用同一字串  \n     → For j from n down to o:  \n       → Step 4: dp[i][j] = max(dp[i][j], dp[i-z][j-o] + 1) // 若加入此字串能得到更大的子集，更新 dp  \n→ Step 5: 回傳 dp[m][n] // 最終答案為使用所有限制時可取得的最大子集大小  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            if zeros > m or ones > n:\n                continue\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1)\n        return dp[m][n]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    pattern = r'strs\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*m\\s*=\\s*(\\d+)\\s*,\\s*n\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        # fallback: try split by comma\n        parts = [p.strip() for p in data.split(',')]\n        strs_part = parts[0]\n        m_part = parts[1]\n        n_part = parts[2]\n        strs = ast.literal_eval(strs_part.replace('strs =', '').strip())\n        m = int(m_part.replace('m =', '').strip())\n        n = int(n_part.replace('n =', '').strip())\n    else:\n        strs = ast.literal_eval(match.group(1))\n        m = int(match.group(2))\n        n = int(match.group(3))\n    result = Solution().findMaxForm(strs, m, n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode227.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator II",
    "description_snippet": "Given a string s which represents an expression, evaluate this expression and return its value.\n\nThe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for evaluating a string expression with +,-,*,/ and spaces. Basic algorithm: use stack, parse numbers, handle operators precedence. Classic solution: iterate, maintain current number, previous operator, stack for * / results. When see operator or end, if prev op is + push num, - push -num, * pop stack, push popped*num, / pop stack, push trunc_div(popped, num). At end sum stack. We need virtual code lines with explanation.\n\nWe produce lines like:\n\nStart\n→ Step 1: 初始化變數 ... etc.\n\nWe must use arrow structure. Use Decision, etc. Provide concise explanation. Let's craft.\n\nMake sure to include integer division truncate toward zero. Implementation: result = int(prev / num) if prev * num < 0 and prev % num != 0 then result +=1? But we can use int(prev / num) in Python gives trunc toward zero. But as virtual code, say \"Divide prev by num with truncation toward zero\".\n\nLet's produce steps: \n\n1. Initialize stack empty, num=0, op='+'\n2. Iterate through string with index i, for each char:\n   - If digit, accumulate into num.\n   - If space, continue.\n   - If char is operator or end:\n        process previous op:\n          if op == '+': push num\n          if op == '-': push -num\n          if op == '*': temp=stack.pop(); push temp*num\n          if op == '/': temp=stack.pop(); push trunc(temp/num)\n        set op=char; num=0\n3. After loop, sum stack as result\n4. Output result\n\nWe must use Decision branches for operators.\n\nMake each line: \"→ Step X: ... // explanation\"\n\nWe must include Start, End.\n\nAlso maybe we should use Decision for each operator: \"Decision: prev op is +?\".\n\nBut can simplify: use if statements as Decision. Provide arrow lines.\n\nLet's produce ~15-20 lines.\n\nMake sure no actual code.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 `stack ← empty list` // 用來儲存中間計算結果  \n→ Step 2: 初始化變數 `num ← 0` // 當前累積的數字  \n→ Step 3: 初始化變數 `op ← '+'` // 上一個已讀取的運算符，預設為加號  \n→ Step 4: 對字串 `s` 中的每個字符進行遍歷，索引從 0 開始 // 逐字符處理  \n→ Decision: 如果字符是數字? // 判斷是否為數字  \n  Yes → Step 5: 更新 `num ← num * 10 + 數字值` // 累積多位數  \n  No  → Decision: 如果字符是空格? // 跳過空格  \n    Yes → Step 6: 跳過本次迴圈 // 不做任何處理  \n    No  → Decision: 字符是運算符或已到字串末尾? // 需要執行計算  \n      Yes → Step 7: 根據上一次存儲的 `op` 進行計算  \n       Decision: `op` 是 '+'? // 針對不同運算符做分支  \n        Yes → Step 8: 將 `num` 推進 `stack` // 加法直接推進  \n        No  → Decision: `op` 是 '-'?  \n         Yes → Step 9: 將 `-num` 推進 `stack` // 減法轉為加負數  \n         No  → Decision: `op` 是 '*'?  \n          Yes → Step 10: `temp ← stack.pop()` // 取前一個數  \n           `stack.push(temp * num)` // 乘法結果推回  \n          No  → Decision: `op` 是 '/'?  \n           Yes → Step 11: `temp ← stack.pop()` // 取前一個數  \n            `stack.push(truncate_divide(temp, num))` // 除法，向零截斷  \n            No → Step 12: 報錯 // 應該不會發生  \n            （這裡不輸出實際程式碼）  \n            // `truncate_divide(a,b)` 代表 `int(a / b)`，向零截斷  \n              \n            Step 13: 更新 `op ← 字符` // 記錄新的運算符  \n            `num ← 0` // 重置數字累積  \n            // 如果字符是字串最後一個字符且不是運算符，則上述分支會自動處理  \n→ Step 14: 在遍歷結束後，執行一次計算以處理最後一個數字  \n  → Decision: `op` 是 '+'?  \n    Yes → Step 15: `stack.push(num)`  \n    No  → Decision: `op` 是 '-'?  \n     Yes → Step 16: `stack.push(-num)`  \n     No  → Decision: `op` 是 '*'?  \n      Yes → Step 17: `temp ← stack.pop()`  \n       `stack.push(temp * num)`  \n      No  → Decision: `op` 是 '/'?  \n       Yes → Step 18: `temp ← stack.pop()`  \n        `stack.push(truncate_divide(temp, num))`  \n       No → Step 19: 報錯 // 理論上不會發生  \n→ Step 20: 將 `stack` 中所有元素相加得到最終結果 `result`  \n→ Step 21: 輸出 `result` // 給使用者回傳計算值  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        stack = []\n        num = 0\n        op = '+'\n        s += '+'  # Add a dummy operator to process the last number\n\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c in '+-*/':\n                if op == '+':\n                    stack.append(num)\n                elif op == '-':\n                    stack.append(-num)\n                elif op == '*':\n                    stack.append(stack.pop() * num)\n                elif op == '/':\n                    top = stack.pop()\n                    # Truncate toward zero\n                    stack.append(int(top / num))\n                op = c\n                num = 0\n            else:\n                # Ignore spaces and other characters\n                continue\n\n        return sum(stack)\n\n\ndef extract_expression(raw_input: str) -> str:\n    raw_input = raw_input.strip()\n    # Try to find expression inside quotes\n    first_quote = raw_input.find('\"')\n    last_quote = raw_input.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        return raw_input[first_quote + 1:last_quote]\n    # If no quotes, maybe input is like s = expression\n    if '=' in raw_input:\n        return raw_input.split('=', 1)[1].strip()\n    # Fallback: use entire stripped input\n    return raw_input\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit()\n    expr = extract_expression(data)\n    result = Solution().calculate(expr)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3+2*2\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \" 3/2 \"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \" 3+5 / 2 \"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode673.json",
    "problem_index_in_file": 0,
    "title": "Number of Longest Increasing Subsequence",
    "description_snippet": "Given an integer array nums, return the number of longest increasing subsequences.\n\nNotice that the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, with explanation, following the format. The problem: number of longest increasing subsequences in integer array. We need DP approach: For each index i, track length[i] longest length ending at i, and count[i] number of LIS ending at i. Initialize all length[i] = 1, count[i] = 1. For each i from 0 to n-1, for j from 0 to i-1: if nums[j] < nums[i], if length[j] + 1 > length[i], set length[i] = length[j]+1; count[i] = count[j]. Else if length[j]+1 == length[i], count[i] += count[j]. After all, find maxLen = max(length), sum count[i] where length[i] == maxLen. Return sum.\n\nWe need to express in virtual code steps: Start, input array, initialize arrays, loops, decisions, etc.\n\nWe need to produce each line as \"虛擬碼步驟 // 解釋\" with arrow etc. Let's structure:\n\nStart // begin\n\n→ Input array nums // get input\n\n→ n = length(nums) // size\n\n→ Declare arrays length[n] and count[n] // store DP\n\n→ For i from 0 to n-1: // outer loop\n\n   -> length[i] = 1 // initial length\n\n   -> count[i] = 1 // initial count\n\n→ For i from 0 to n-1: // compute DP\n\n   → For j from 0 to i-1: // check previous\n\n      -> Decision: if nums[j] < nums[i]? // strictly increasing\n\n         Yes → Decision: if length[j] + 1 > length[i]? // longer\n\n            Yes → length[i] = length[j] + 1 // update\n\n            Yes → count[i] = count[j] // new count\n\n            No → Decision: if length[j] + 1 == length[i]? // same length\n\n               Yes → count[i] = count[i] + count[j] // accumulate\n\n               No → // nothing\n\n         No → // nums[j] not smaller\n\n   → // end inner loop\n\n→ maxLen = 0 // find maximum length\n\n→ For i from 0 to n-1: // find max\n\n   -> Decision: if length[i] > maxLen? // update\n\n      Yes → maxLen = length[i] // new max\n\n→ result = 0 // sum counts of maxLen\n\n→ For i from 0 to n-1: // sum\n\n   -> Decision: if length[i] == maxLen? // contributes\n\n      Yes → result = result + count[i] // add\n\n→ Return result // output\n\n→ End // finish\n\nNeed to keep each line with proper arrow format. For nested decisions, indent with spaces and use Yes →, No →. The \"→\" at start of line indicates step, but for nested we use indentation.\n\nLet's produce. Ensure each line ends with // explanation. Use English or Chinese? Use Chinese explanation. Let's keep explanation in Chinese. Also ensure to include arrow for decisions and steps. Let's create lines accordingly. Use \"→ Step X: ...\", \"Decision:\" etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input array nums // 取得輸入的整數陣列  \n→ n = length(nums) // 計算陣列長度  \n→ Declare arrays length[n] and count[n] // 用於 DP 的長度與計數陣列  \n→ For i from 0 to n-1: // 初始化每個位置  \n　　→ length[i] = 1 // 每個元素本身可成為長度為 1 的遞增子序列  \n　　→ count[i] = 1 // 初始時每個位置有 1 條長度為 1 的子序列  \n→ For i from 0 to n-1: // 進行 DP 計算  \n　　→ For j from 0 to i-1: // 檢查前面所有位置  \n　　　　→ Decision: 如果 nums[j] < nums[i]? // 必須是嚴格遞增  \n　　　　　　Yes → Decision: 如果 length[j] + 1 > length[i]? // 找到更長的子序列  \n　　　　　　　　Yes → length[i] = length[j] + 1 // 更新長度  \n　　　　　　　　Yes → count[i] = count[j] // 以該長度為新計數  \n　　　　　　　　No → Decision: 如果 length[j] + 1 == length[i]? // 同長度則累加計數  \n　　　　　　　　　　Yes → count[i] = count[i] + count[j] // 累加同長度子序列數量  \n　　　　　　　　　　No → // 不做任何操作  \n　　　　　　No → // nums[j] 不小於 nums[i]，忽略此 j  \n　　→ // 內層迴圈結束  \n→ maxLen = 0 // 用於找出最大長度  \n→ For i from 0 to n-1: // 遍歷找最大長度  \n　　→ Decision: 如果 length[i] > maxLen?  \n　　　　Yes → maxLen = length[i] // 更新最大長度  \n→ result = 0 // 用於累加所有最大長度子序列的數量  \n→ For i from 0 to n-1: // 計算最終答案  \n　　→ Decision: 如果 length[i] == maxLen?  \n　　　　Yes → result = result + count[i] // 累加對應位置的計數  \n→ Return result // 回傳最長遞增子序列的個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findNumberOfLIS(self, nums):\n        \"\"\"\n        Return the number of longest increasing subsequences in nums.\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        lengths = [1] * n          # lengths[i] = length of LIS ending at i\n        counts = [1] * n           # counts[i] = number of LIS ending at i\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if lengths[j] + 1 > lengths[i]:\n                        lengths[i] = lengths[j] + 1\n                        counts[i] = counts[j]\n                    elif lengths[j] + 1 == lengths[i]:\n                        counts[i] += counts[j]\n\n        longest = max(lengths)\n        return sum(c for l, c in zip(lengths, counts) if l == longest)\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    nums = []\n\n    if data:\n        # Find the first '[' and the last ']' to extract the list representation\n        start = data.find('[')\n        end = data.rfind(']')\n        if start != -1 and end != -1:\n            list_str = data[start:end+1]\n            try:\n                nums = ast.literal_eval(list_str)\n            except Exception:\n                # If parsing fails, fall back to empty list\n                nums = []\n\n    solution = Solution()\n    result = solution.findNumberOfLIS(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,4,7]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode686.json",
    "problem_index_in_file": 0,
    "title": "Repeated String Match",
    "description_snippet": "Given two strings a and b, return the minimum number of times you should repeat string a so that str...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm. Approach: compute minimal repeats so that length of repeated a >= length of b. Then check all positions for substring. If not found, double repeats until length >= 2*len(a)+len(b) maybe. Common solution: repeat a until length >= len(b)+len(a). Because the substring could start in the last copy. Implementation: repeatCount = ceil(len(b)/len(a)). Then while not found and repeatCount <= ceil(len(b)/len(a))+1? Actually typical solution: repeat a until length >= len(b)+len(a). Then check if b is substring. If not, return -1. else return repeats.\n\nLet's produce virtual code.\n\nNeed step by step with decision arrows.\n\nLet's design:\n\nStart\n→ Step 1: Read strings a, b\n→ Step 2: Compute lenA, lenB\n→ Decision: If lenB == 0? // empty substring always present, return 0? But usually 0 times a? But minimal repeats? Could be 0. We can ignore or treat as 0\n    Yes → Step 3: Return 0 // empty string is always substring\n    No  →\n→ Step 4: repeats = ceil(lenB / lenA) // minimal repeats to cover length\n→ Step 5: repeated = a * repeats // build repeated string\n→ Decision: If b is substring of repeated? // check\n    Yes → Step 6: Return repeats // minimal repeats found\n    No  →\n        → Step 7: repeats += 1 // add one more repeat\n        → Step 8: repeated = a * repeats\n        → Decision: If b is substring of repeated?\n            Yes → Step 9: Return repeats\n            No  → Step 10: Return -1\n\nBut need also check maybe need up to repeats +1 only. Could be more? In typical solution, we check up to repeats+1. Because starting position could cross boundary requiring at most one more repetition.\n\nLet's produce virtual code accordingly.\n\nNeed each line with explanation.\n\nLet's write.\n\nNote: Use arrows like → Step 1: ... //.\n\nAlso decisions: Decision: If condition?\n\nWe need to follow format.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 a 與 b // 取得輸入的兩個字串  \n→ Step 2: 計算 lenA = a 的長度, lenB = b 的長度 // 方便後續計算  \n→ Decision: 是否為空子字串? // 空字串總是為子字串  \n  Yes → Step 3: 回傳 0 // 0 次重複即可滿足  \n  No  →  \n→ Step 4: 計算最小重複次數 repeats = ceil(lenB / lenA) // 讓重複後的長度至少和 b 一樣長  \n→ Step 5: 建立重複字串 repeated = a * repeats // 形成實際的重複字串  \n→ Decision: b 是否為 repeated 的子字串?  \n  Yes → Step 6: 回傳 repeats // 已達到最小重複次數  \n  No  →  \n   → Step 7: repeats = repeats + 1 // 再多重複一次以覆蓋跨界情況  \n   → Step 8: repeated = a * repeats // 重新建立更長的字串  \n   → Decision: b 是否為 repeated 的子字串?  \n    Yes → Step 9: 回傳 repeats // 這時子字串出現  \n    No  → Step 10: 回傳 -1 // 即使再多一次也無法成為子字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def repeatedStringMatch(self, A: str, B: str) -> int:\n        \"\"\"\n        Return the minimum number of times A must be repeated so that B is a substring.\n        If impossible, return -1.\n        \"\"\"\n        # Compute minimal repeats needed to cover B's length\n        repeat = (len(B) + len(A) - 1) // len(A)  # ceil(len(B)/len(A))\n        s = A * repeat\n        if B in s:\n            return repeat\n        # One more repeat might be necessary for substrings that cross the boundary\n        s += A\n        if B in s:\n            return repeat + 1\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input in the form:\n        a = \"abcd\", b = \"cdabcdab\"\n    or\n        \"abcd\"\n        \"cdabcdab\"\n    Returns a tuple (a, b).\n    \"\"\"\n    # Try to extract using regex for the 'a = \"...\", b = \"...\"' pattern\n    pattern = r'a\\s*=\\s*\"([^\"]*)\"\\s*,\\s*b\\s*=\\s*\"([^\"]*)\"'\n    match = re.search(pattern, data, re.IGNORECASE)\n    if match:\n        return match.group(1), match.group(2)\n\n    # If not matched, try splitting by lines or whitespace\n    parts = [p.strip() for p in data.replace('\\n', ' ').split() if p.strip()]\n    if len(parts) >= 2:\n        # Remove surrounding quotes if present\n        a = parts[0].strip('\"')\n        b = parts[1].strip('\"')\n        return a, b\n\n    raise ValueError(\"Input format not recognized\")\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    a, b = parse_input(input_data)\n    result = Solution().repeatedStringMatch(a, b)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = \"abcd\", b = \"cdabcdab\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "a = \"a\", b = \"aa\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode152.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product Subarray",
    "description_snippet": "Given an integer array nums, find a subarray that has the largest product, and return the product.\n\n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation, following format: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision. Steps. Must produce algorithm for maximum product subarray. Classic DP: maintain max_ending_here and min_ending_here. Use variable result. Steps: Start, initialize max_ending_here, min_ending_here, result with first element. Loop i from 1 to n-1. For each nums[i], if negative, swap max and min. Then update max_ending_here = max(nums[i], max_ending_here * nums[i]); min_ending_here = min(nums[i], min_ending_here * nums[i]); update result = max(result, max_ending_here). End. Return result.\n\nWe must output only virtual code lines, no real code, just steps with arrow. Use arrow \"→\". For loop: Decision: i < n? Might represent with loop. Provide steps like \"→ Loop: for i from 1 to n-1\". In decision we might show: Decision: i < n? Yes → ... No → End Loop. But maybe simpler: use \"→ Loop: i = 1 to n-1\" as one step. But they want arrow style. Provide each line. Let's structure:\n\nStart\n→ Initialize: maxEnding = nums[0], minEnding = nums[0], result = nums[0] // set initial values\n→ Loop: for i = 1 to length(nums)-1 // iterate through array\n    → Decision: nums[i] < 0? // check if current element is negative\n        Yes → Swap maxEnding and minEnding // swap when negative to keep max/min correct\n        No  → // nothing\n    → Update maxEnding = max(nums[i], maxEnding * nums[i]) // compute new max product ending here\n    → Update minEnding = min(nums[i], minEnding * nums[i]) // compute new min product ending here\n    → Update result = max(result, maxEnding) // keep global max\n→ End Loop\nEnd // return result\n\nWe need to include \"Return result\" as a step maybe inside End. They said to output structuring. Might add \"→ Return result\" before End. Let's add.\n\nAlso, might include decision for swap only. Provide comments. Ok. Let's craft.\n\nMake sure each line is: \"虛擬碼步驟 // 解釋\". Use \"→\" arrows.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize: maxEnding = nums[0], minEnding = nums[0], result = nums[0] // 用第一個數字設定初始值  \n→ Loop: i = 1 to length(nums)-1 // 遍歷陣列剩餘元素  \n    → Decision: nums[i] < 0? // 檢查目前元素是否為負數  \n        Yes → Swap maxEnding and minEnding // 負數會把最大最小顛倒  \n        No  → // 直接進行下一步  \n    → Update: maxEnding = max(nums[i], maxEnding * nums[i]) // 重新計算此位置最大積  \n    → Update: minEnding = min(nums[i], minEnding * nums[i]) // 重新計算此位置最小積  \n    → Update: result = max(result, maxEnding) // 更新全局最大積  \n→ End Loop // 完成遍歷  \n→ Return result // 回傳最大子陣列積  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_product(nums):\n    if not nums:\n        return 0\n    max_prod = min_prod = result = nums[0]\n    for num in nums[1:]:\n        if num < 0:\n            max_prod, min_prod = min_prod, max_prod\n        max_prod = max(num, max_prod * num)\n        min_prod = min(num, min_prod * num)\n        result = max(result, max_prod)\n    return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    try:\n        # Extract list part if input like \"nums = [2,3,-2,4]\"\n        start = data.index('[')\n        end = data.rindex(']')\n        nums = ast.literal_eval(data[start:end+1])\n    except Exception:\n        # If input is just the list, evaluate it directly\n        nums = ast.literal_eval(data)\n    print(max_product(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,-2,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [-2,0,-1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode494.json",
    "problem_index_in_file": 0,
    "title": "Target Sum",
    "description_snippet": "You are given an integer array nums and an integer target.\n\nYou want to build an expression out of n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce pseudocode steps for algorithm. It's counting number of expressions with + or - that sum to target. Classic target sum DP or recursion. Provide step-by-step pseudocode lines with comments.\n\nWe need to use virtual code arrows. Format: Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Eg \"Start // 程式開始執行\". Provide decision steps.\n\nWe should produce algorithm: using recursion/backtracking or DP. Let's do DP using hash map counts. Steps: Start, read nums and target, initialize map sum->count, iterate over nums, update map: for each sum in map, produce new sums by adding/subtracting current num, accumulate counts. After finish, output count for target or 0.\n\nProvide explanation lines.\n\nMake sure each line contains arrow where appropriate. Use Indentation? Not necessary. Use arrow \"→\" to denote steps. For decisions use \"Decision:\".\n\nLet's produce lines:\n\nStart\n→ Step 1: 初始化映射 sumCount，鍵為累計和，值為該和的表達式數量 // 建立計數表\n→ Decision: 如果 nums 为空?\n    Yes → Step 2: Return 0 // 無數字無表達式\n    No → \n→ Step 3: 把第一個數加到映射\n    → For num = nums[0]\n        → sumCount[num] = 1\n        → sumCount[-num] = 1\n→ Step 4: 循環處理剩餘數字\n    → For idx from 1 to nums.length-1\n        → tempMap = empty map\n        → For each (sum, count) in sumCount\n            → newSumPlus = sum + nums[idx]\n            → newSumMinus = sum - nums[idx]\n            → tempMap[newSumPlus] += count\n            → tempMap[newSumMinus] += count\n        → sumCount = tempMap\n→ Step 5: 查找目標 target 的數量\n    → If sumCount contains target\n        → Return sumCount[target]\n    → Else\n        → Return 0\nEnd\n\nWe need to ensure each line ends with // 解釋. Use arrow for steps. For loops, we can write \"→ For ...\" etc.\n\nLet's format each line:\n\nStart // 程式開始執行\n→ Step 1: 建立 sumCount 映射以儲存每個可能和及其計數 // 初始化\n→ Decision: 如果 nums 為空? // 檢查輸入是否為空\n    Yes → Step 2: 回傳 0 // 無數字則無合法表達式\n    No  → \n→ Step 3: 以 nums[0] 作為第一個數字初始化映射\n    → sumCount[nums[0]] = 1 // +號\n    → sumCount[-nums[0]] = 1 // -號\n→ Step 4: 從第二個數字開始遍歷\n    → For idx = 1 到 nums.length - 1\n        → temp = 空映射\n        → For 每一對 (sum, count) 在 sumCount\n            → sumPlus = sum + nums[idx]\n            → sumMinus = sum - nums[idx]\n            → temp[sumPlus] += count\n            → temp[sumMinus] += count\n        → sumCount = temp\n→ Step 5: 取得 target 的計數\n    → If sumCount 包含 target\n        → 回傳 sumCount[target]\n    → Else\n        → 回傳 0\nEnd // 程式執行結束\n\nMake sure arrows used properly. Use \"→\" before each line except Start? Example format: \"Start // ...\" then \"→ Step 1 ...\". For decisions, we indent with spaces then \"Yes →\" etc. Provide comments.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 sumCount 映射以儲存每個可能和及其計數 // 初始化  \n→ Decision: 如果 nums 為空? // 檢查輸入是否為空  \n  Yes → Step 2: 回傳 0 // 無數字則無合法表達式  \n  No  →  \n→ Step 3: 以 nums[0] 作為第一個數字初始化映射  \n  → sumCount[nums[0]] = 1 // +號  \n  → sumCount[-nums[0]] = 1 // -號  \n→ Step 4: 從第二個數字開始遍歷  \n  → For idx = 1 到 nums.length - 1  \n    → temp = 空映射  \n    → For 每一對 (sum, count) 在 sumCount  \n      → sumPlus = sum + nums[idx]  \n      → sumMinus = sum - nums[idx]  \n      → temp[sumPlus] += count  \n      → temp[sumMinus] += count  \n    → sumCount = temp  \n→ Step 5: 取得 target 的計數  \n  → If sumCount 包含 target  \n    → 回傳 sumCount[target]  \n  → Else  \n    → 回傳 0  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def findTargetSumWays(self, nums, target):\n        dp = defaultdict(int)\n        dp[0] = 1\n        for num in nums:\n            next_dp = defaultdict(int)\n            for s in dp:\n                next_dp[s + num] += dp[s]\n                next_dp[s - num] += dp[s]\n            dp = next_dp\n        return dp[target]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 找出列表中的數字\n    list_match = re.search(r'\\[([^\\]]+)\\]', data)\n    if list_match:\n        nums = list(map(int, re.findall(r'-?\\d+', list_match.group(1))))\n    else:\n        nums = []\n    # 找出目標值\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    target = int(target_match.group(1)) if target_match else 0\n\n    solution = Solution()\n    result = solution.findTargetSumWays(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,1,1], target = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1], target = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode447.json",
    "problem_index_in_file": 0,
    "title": "Number of Boomerangs",
    "description_snippet": "You are given n points in the plane that are all distinct, where points[i] = [x_i, y_i]. A boomerang...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the algorithm: count number of boomerangs given n points. Approach: For each point i, compute distances to all other points, count frequency of each distance. For each frequency f, add f*(f-1) to result. Complexity O(n^2). Provide virtual code line by line with explanation. Use the format: Start, →, Decision, etc.\n\nWe need to produce \"virtual code\" but not actual code. Provide steps and explanation. Use arrows etc.\n\nLet's write:\n\nStart // start\n→ Step 1: 初始化結果變數 result = 0 // store total boomerangs\n→ Step 2: 取得點數量 n = points.length // number of points\n→ Decision: 如果 n < 3? // Need at least 3 points\n    Yes → Step 3: 返回 0 // 沒有足夠點\n    No  → ...\n→ Step 4: 迭代每個點 i 從 0 到 n-1\n    → Step 5: 建立一個空哈希表 distCount // distance -> count\n    → Step 6: 迭代每個點 j 從 0 到 n-1，若 j != i\n        → Step 7: 計算距離 squared = (x_i - x_j)^2 + (y_i - y_j)^2 // 使用平方避免 sqrt\n        → Step 8: distCount[ squared ] = distCount[ squared ] + 1 // 記錄距離頻率\n    → Step 9: 對 distCount 的每個距離頻率 f\n        → Step 10: result = result + f * (f - 1) // 可能的排列數\n→ Step 11: 返回 result // 完成\nEnd // 程式結束\n\nNeed to format with arrows and decisions accordingly.\n\nWe should keep each line in virtual code style:\n\nStart // ...\n→ Step 1: ...\n→ Decision: ...\n   Yes → Step...\n   No  → ...\nBut we need to show proper indentation maybe.\n\nLet's write each step as separate line with explanation. Use arrow \"→\". Use \"Decision:\" for if. Provide the \"Yes →\" \"No →\" lines accordingly.\n\nWe need to maintain line by line.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: result ← 0 // 初始化總數\n→ Step 2: n ← length(points) // 點數\n→ Decision: 如果 n < 3? // 必須至少三點\n    Yes → Step 3: return result // 沒有足夠點，返回 0\n    No  →\n→ Step 4: 迭代 i from 0 to n-1 // 每個點作為基準\n    → Step 5: distCount ← {} // 距離頻率表\n    → Step 6: 迭代 j from 0 to n-1 // 比較所有其他點\n        → Decision: 如果 j == i? // 跳過自己\n            Yes → Step 7: continue // 跳過\n            No  →\n        → Step 8: dx ← points[i][0] - points[j][0] // x 差\n        → Step 9: dy ← points[i][1] - points[j][1] // y 差\n        → Step 10: d ← dx*dx + dy*dy // 距離平方\n        → Step 11: distCount[d] ← (distCount[d] ?? 0) + 1 // 記錄頻率\n    → Step 12: 對每個 d, f in distCount\n        → Step 13: result ← result + f * (f - 1) // 有序排列數\n→ Step 14: return result // 最終結果\nEnd // 程式結束\n\nEnsure each line has explanation after \"//\". Provide correct explanation. Use proper arrow symbols.\n\nWe might need to separate lines after decision \"Yes →\" etc. The format example shows indentation. We'll match.\n\nMake sure each line ends with explanation after \"//\". Let's output.\n...done thinking.\n\n```\nStart // 程式開始\n→ Step 1: result ← 0 // 初始化總的 boomerang 數量\n→ Step 2: n ← length(points) // 取得點的個數\n→ Decision: 如果 n < 3? // 需要至少三個點才能形成 boomerang\n    Yes → Step 3: return result // 沒有足夠點，直接回傳 0\n    No  →\n→ Step 4: 迭代 i 從 0 到 n-1 // 將每個點作為中心點\n    → Step 5: distCount ← {} // 建立距離到頻率的映射\n    → Step 6: 迭代 j 從 0 到 n-1 // 比較所有其他點\n        → Decision: 如果 j == i? // 跳過自身\n            Yes → Step 7: continue // 跳過本次迭代\n            No  →\n        → Step 8: dx ← points[i][0] - points[j][0] // x 坐標差\n        → Step 9: dy ← points[i][1] - points[j][1] // y 坐標差\n        → Step 10: d ← dx*dx + dy*dy // 計算距離平方，避免開平方\n        → Step 11: distCount[d] ← (distCount[d] ?? 0) + 1 // 更新此距離的頻率\n    → Step 12: 對 distCount 中的每個 (d, f) // 遍歷每種距離\n        → Step 13: result ← result + f * (f - 1) // 有序排列的組合數\n→ Step 14: return result // 回傳最終計算的 boomerang 數量\nEnd // 程式結束\n```",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def numberOfBoomerangs(self, points):\n        total = 0\n        for x1, y1 in points:\n            dist_count = defaultdict(int)\n            for x2, y2 in points:\n                if (x1, y1) != (x2, y2):\n                    d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n                    dist_count[d] += 1\n            for count in dist_count.values():\n                total += count * (count - 1)\n        return total\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list representation from the input string\n    start = data.find('[')\n    expr = data[start:] if start != -1 else data\n    try:\n        points = ast.literal_eval(expr)\n    except Exception:\n        points = []\n\n    result = Solution().numberOfBoomerangs(points)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[0,0],[1,0],[2,0]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,1],[2,2],[3,3]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "points = [[1,1]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode384.json",
    "problem_index_in_file": 0,
    "title": "Shuffle an Array",
    "description_snippet": "Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanations. The code is pseudocode for the algorithm. We need to design algorithm: store original array, implement reset() returns original, shuffle() returns random shuffle: use Fisher-Yates algorithm. We'll create class Solution with constructor, reset, shuffle. For shuffle: copy array to local, iterate i from n-1 downto 1, pick random j between 0 and i, swap.\n\nWe produce steps: Start, define class, constructor, store original, clone current array variable. Reset: return clone of original. Shuffle: copy current array? Actually we need to produce new shuffle each call, not modify original. We'll use original array to copy.\n\nImplement pseudocode:\n\nStart\n→ Define class Solution\n→ Step: Declare array original\n→ Step: Constructor: set original = copy of nums\n→ Step: reset() // return copy of original\n→ Step: shuffle() // copy original to result array\n→ For i from n-1 downto 1: j = random integer [0,i]; swap result[i], result[j]\n→ Return result\nEnd\n\nWe need to output each line with explanation comment after //.\n\nMake sure to include arrows and decisions if needed. No decisions needed. Just linear steps. Might include decision for random index but not necessary.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define class Solution // 宣告 Solution 類別  \n→ Declare array original // 用於存放初始化時的原始陣列  \n→ Constructor: set original = copy of nums // 建構子，將輸入陣列複製至 original  \n→ Method reset() // 重置方法  \n  → Return copy of original // 回傳原始陣列的複製，保持不變  \n→ Method shuffle() // 隨機洗牌方法  \n  → result = copy of original // 先複製原始陣列作為工作副本  \n  → For i from length(result)-1 downto 1: // 由尾到頭遍歷  \n    j = random integer between 0 and i // 隨機挑選 0~i 的索引  \n    swap result[i] with result[j] // 交換位置，實現 Fisher‑Yates 洗牌  \n  → Return result // 回傳隨機排列的陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nfrom typing import List, Any\n\nclass Solution:\n    \"\"\"\n    隨機洗牌的實作\n    \"\"\"\n    def __init__(self, nums: List[int]) -> None:\n        # 以清單複製的方式儲存原始陣列\n        self._original = list(nums)\n\n    def reset(self) -> List[int]:\n        \"\"\"\n        重置為原始排列並回傳\n        \"\"\"\n        return list(self._original)\n\n    def shuffle(self) -> List[int]:\n        \"\"\"\n        依照 Fisher‑Yates 洗牌演算法隨機打亂陣列\n        \"\"\"\n        result = list(self._original)\n        n = len(result)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            result[i], result[j] = result[j], result[i]\n        return result\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將兩個列表分割：commands 與 arguments\n    split_index = data.find('],')\n    if split_index == -1:\n        # 若輸入格式不符，直接終止\n        return\n    cmds_str = data[:split_index + 1]\n    args_str = data[split_index + 2:]\n\n    # 解析 JSON\n    commands: List[str] = json.loads(cmds_str)\n    arguments: List[Any] = json.loads(args_str)\n\n    results: List[Any] = []\n    obj: Any = None\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"Solution\":\n            # 建構物件，arg 為 [nums]\n            obj = Solution(arg[0])\n            results.append(None)\n        elif cmd == \"reset\":\n            results.append(obj.reset())\n        elif cmd == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            # 若出現未知指令，回傳 None\n            results.append(None)\n\n    # 以 JSON 格式輸出，符合 LeetCode 需求\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,1,3],[1,2,3],[2,3,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 1, 3], [1, 2, 3], [2, 3, 1]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode405.json",
    "problem_index_in_file": 0,
    "title": "Convert a Number to Hexadecimal",
    "description_snippet": "Given a 32-bit integer num, return a string representing its hexadecimal representation. For negativ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code in Chinese, step by step, not actual code. Should describe algorithm for converting 32-bit integer to hex string using two's complement for negative. Must handle 32-bit signed int. Steps: mask 32-bit, handle zero, loop dividing by 16, mapping remainder to hex digit, building string, reverse, etc. Use while loop. For negative numbers, we can mask with 0xFFFFFFFF to get 32-bit two's complement representation. But we cannot use library; but we can simulate by & with mask. We need to ensure we treat as unsigned. In pseudocode, we can say `masked = num & 0xFFFFFFFF` (bitwise AND). Then if masked == 0 return \"0\". Else while masked > 0: remainder = masked % 16; char = hex_map[remainder]; prepend to result; masked = masked // 16. At end return result. That's algorithm.\n\nBut we need to follow the \"虛擬碼步驟\" format. Use arrows and Decision etc. Provide explanation after space.\n\nLet's produce lines:\n\nStart // start\n→ Step 1: Initialize hexMap // mapping 0-15 to '0'-'f' // etc\n→ Step 2: Compute maskedNum ← num AND 0xFFFFFFFF // get 32-bit two's complement representation\n→ Decision: If maskedNum == 0? // check zero case\n    Yes → Step 3: Set result ← \"0\" // return zero string\n    No  → Step 4: Initialize result ← \"\" // empty string for accumulation\n→ Step 5: While maskedNum > 0: // loop until all hex digits processed\n    → Step 6: remainder ← maskedNum MOD 16 // get least significant hex digit\n    → Step 7: digit ← hexMap[remainder] // map remainder to hex character\n    → Step 8: result ← digit + result // prepend to build string\n    → Step 9: maskedNum ← maskedNum DIV 16 // shift right by 4 bits\n→ End // return result\n\nBut we need each line with \"虛擬碼步驟\" and comment. Also include arrows and decision structure with indent. In example, indent is 4 spaces. We'll use same formatting.\n\nWe should also ensure we mention step for input and output. Use \"Start\" and \"End\".\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: hexMap ← [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"] // 建立 0~15 對應的十六進制字元表  \n→ Step 2: maskedNum ← num AND 0xFFFFFFFF // 將 32 位整數取其 2 的補數表示（對負數進行位掩碼）  \n→ Decision: 如果 maskedNum 等於 0? // 判斷輸入是否為 0  \n  Yes → Step 3: result ← \"0\" // 直接返回字串 \"0\"  \n  No  → Step 4: result ← \"\" // 初始化結果字串  \n→ Step 5: While maskedNum > 0: // 逐位將整數轉為十六進制，直到處理完所有位  \n  → Step 6: remainder ← maskedNum MOD 16 // 取得最低 4 位的十六進制數字  \n  → Step 7: digit ← hexMap[remainder] // 將 remainder 轉換為對應字元  \n  → Step 8: result ← digit + result // 在結果前面插入新字元（反轉順序）  \n  → Step 9: maskedNum ← maskedNum DIV 16 // 右移 4 位，移除已處理的位  \nEnd // 程式執行結束，返回 result 以得到完整的十六進制字串",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def toHex(self, num: int) -> str:\n        # 直接把負數轉成 32 位的兩補數表示\n        num &= 0xFFFFFFFF\n        if num == 0:\n            return \"0\"\n\n        hex_chars = \"0123456789abcdef\"\n        res = \"\"\n        while num > 0:\n            # 取最低 4 位\n            digit = num & 15\n            res = hex_chars[digit] + res\n            # 右移 4 位\n            num >>= 4\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，從中尋找第一個能轉為整數的子字串\n    data = sys.stdin.read()\n    m = re.search(r'-?\\d+', data)\n    if not m:\n        sys.exit(0)\n    num = int(m.group())\n    solution = Solution()\n    print(solution.toHex(num))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 26",
          "expected_output": "1a",
          "success": true,
          "output": "1a"
        },
        {
          "example_index": 1,
          "input": "num = -1",
          "expected_output": "ffffffff",
          "success": true,
          "output": "ffffffff"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode722.json",
    "problem_index_in_file": 0,
    "title": "Remove Comments",
    "description_snippet": "Given a C++ program, remove comments from it. The program source is an array of strings source where...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines that describe algorithm to remove comments from C++ source, given as array of strings. Must output line by line pseudocode, with arrow notation, explanation.\n\nLet's think: We need to iterate lines, maintain a flag inBlockComment. For each line, iterate characters, build output line. Skip characters inside block comment until we see \"*/\". Skip line comment after seeing \"//\". At end of line, if we are not inside block comment, and output line not empty, add to result. Continue to next line.\n\nEdge cases: \"/*\" can be inside block comment - ignore. \"*/\" inside line comment - ignore but we are already ignoring rest. Need to ensure non-overlapping: when we find \"/*\", skip to next \"*/\". The algorithm ensures that by scanning char by char, when inBlockComment, we check for \"*/\". When not in block, we check for \"/*\" or \"//\".\n\nPseudo code:\n\nStart\n→ Initialize result list\n→ Set inBlock = False\n→ For each line in source\n    → Initialize newLine empty\n    → Set i=0\n    → While i < length(line)\n        → If inBlock\n            → If line[i]=='*' and i+1< len and line[i+1]=='/' // end of block\n                → inBlock = False\n                → i += 2\n            → Else\n                → i +=1 // skip inside block\n        → Else\n            → If line[i]=='/' and i+1< len\n                → If line[i+1]=='/' // line comment\n                    → Break // ignore rest\n                → Else If line[i+1]=='*' // block comment start\n                    → inBlock = True\n                    → i +=2\n                → Else\n                    → newLine += line[i]\n                    → i +=1\n            → Else\n                → newLine += line[i]\n                → i +=1\n    → End while\n    → If newLine is not empty\n        → Append newLine to result\n→ End for\n→ Return result\nEnd\n\nNeed to produce as virtual code lines with arrows. We'll create hierarchical indent.\n\nWe need to use arrow notation: Start, End, Decision: etc. Use \"→\" for step lines.\n\nLet's format:\n\nStart // 程式開始\n→ Step 1: 初始化 result 為空列表 // 用於儲存處理後的行\n→ Step 2: 設定 inBlockComment = False // 是否正在處理區塊註解\n→ Decision: 迭代 source 中的每一行? // 開始逐行處理\n    Yes → Step 3: 取得 currentLine // 取目前行\n        → Step 4: 初始化 newLine 為空字符串 // 儲存無註解的內容\n        → Step 5: 初始化 i = 0 // 字符索引\n        → Decision: i < currentLine.length? // 是否還有字符可處理\n            Yes → Decision: inBlockComment 為 True? // 目前是否在區塊註解內\n                Yes → Decision: currentLine[i]=='*' 且 i+1<length 且 currentLine[i+1]=='/'? // 結束區塊\n                    Yes → Step 6: inBlockComment = False // 結束區塊註解\n                    Yes → Step 7: i += 2 // 跳過 \"*/\"\n                    No  → Step 8: i += 1 // 仍在區塊內，跳過字符\n                No  → Decision: currentLine[i]=='/' 且 i+1<length? // 可能開始註解\n                    Yes → Decision: currentLine[i+1]=='/'? // 行註解\n                        Yes → Step 9: Break // 跳過剩餘字符\n                        No  → Decision: currentLine[i+1]=='*'? // 區塊註解開始\n                            Yes → Step 10: inBlockComment = True // 開始區塊註解\n                            Yes → Step 11: i += 2 // 跳過 \"/*\"\n                            No  → Step 12: newLine += currentLine[i] // 非註解字符\n                            No  → Step 13: i += 1\n                    No  → Step 14: newLine += currentLine[i] // 普通字符\n                    No  → Step 15: i += 1\n            No  → // 所有字符已處理\n        → Decision: newLine 非空? // 結果行是否需要加入\n            Yes → Step 16: result.append(newLine) // 加入結果\n            No  → Step 17: // 忽略空行\n→ Decision: source 迭代完畢? // 完成所有行\n    Yes → Step 18: Return result // 返回處理後的源碼\nEnd // 程式結束\n\nBut need to include arrows for decisions and steps. The format: Start // description; → Step: ... ; → Decision: ... etc. Ensure each line has arrow (Start, End). For Decision, we may need to indent with space? They used \"    Yes →\" with indentation. So we mimic that.\n\nLet's produce final answer.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空列表 // 用於儲存處理後的每一行\n→ Step 2: 設定 inBlockComment = False // 標記是否正在區塊註解內\n→ Decision: 迭代 source 中的每一行? // 開始逐行處理\n    Yes → Step 3: 取得 currentLine // 取目前行\n        → Step 4: 初始化 newLine 為空字符串 // 儲存已去除註解的內容\n        → Step 5: 初始化 i = 0 // 字符索引\n        → Decision: i < currentLine.length? // 是否還有字符可處理\n            Yes → Decision: inBlockComment 為 True? // 正在區塊註解內\n                Yes → Decision: currentLine[i]=='*' 且 i+1<length 且 currentLine[i+1]=='/'? // 找到「*/」\n                    Yes → Step 6: inBlockComment = False // 結束區塊註解\n                    Yes → Step 7: i += 2 // 跳過「*/」\n                    No  → Step 8: i += 1 // 仍在區塊內，跳過單個字符\n                No  → Decision: currentLine[i]=='/' 且 i+1<length? // 可能開啟新的註解\n                    Yes → Decision: currentLine[i+1]=='/'? // 行註解\n                        Yes → Step 9: Break // 跳過此行剩餘部分\n                        No  → Decision: currentLine[i+1]=='*'? // 區塊註解開始\n                            Yes → Step 10: inBlockComment = True // 開始區塊註解\n                            Yes → Step 11: i += 2 // 跳過「/*」\n                            No  → Step 12: newLine += currentLine[i] // 不是註解，加入輸出\n                            No  → Step 13: i += 1\n                    No  → Step 14: newLine += currentLine[i] // 普通字符，加入輸出\n                    No  → Step 15: i += 1\n            No  → // 所有字符已處理完畢\n        → Decision: newLine 非空? // 判斷此行是否需要加入結果\n            Yes → Step 16: result.append(newLine) // 將處理後的行加入結果\n            No  → Step 17: // 忽略完全被註解的空行\n→ Decision: source 迭代完畢? // 所有行已處理\n    Yes → Step 18: Return result // 返回去除註解後的程式碼\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeComments(self, source):\n        res = []\n        in_block = False\n\n        for line in source:\n            i = 0\n            new_line = []\n\n            while i < len(line):\n                if in_block:\n                    # Inside a block comment, look for the closing */\n                    if line[i:i+2] == '*/':\n                        in_block = False\n                        i += 2\n                        continue\n                    else:\n                        i += 1\n                        continue\n                else:\n                    # Not inside a block comment\n                    # Check for line comment start //\n                    if line[i:i+2] == '//':\n                        break\n                    # Check for block comment start /*\n                    if line[i:i+2] == '/*':\n                        in_block = True\n                        i += 2\n                        continue\n                    # Regular character\n                    new_line.append(line[i])\n                    i += 1\n\n            # If we finished the line and are not inside a block comment,\n            # add the cleaned line if it's not empty\n            if new_line and not in_block:\n                res.append(''.join(new_line))\n\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Remove the leading \"source =\" if present\n    if data.startswith('source ='):\n        data = data[len('source ='):].strip()\n    # Safely evaluate the Python literal representing the list of strings\n    source = ast.literal_eval(data)\n    sol = Solution()\n    result = sol.removeComments(source)\n    # Print the list in Python literal form\n    print(repr(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "source = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]",
          "expected_output": "[\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]",
          "success": true,
          "output": "['int main()', '{ ', '  ', 'int a, b, c;', 'a = b + c;', '}']"
        },
        {
          "example_index": 1,
          "input": "source = [\"a/*comment\", \"line\", \"more_comment*/b\"]",
          "expected_output": "[\"ab\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"ab\"]'\nGot (Norm):      '[\"b\"]'\n--- (Raw) ---\nRaw Expected: '[\"ab\"]'\nRaw Got:      \"['b']\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode292.json",
    "problem_index_in_file": 0,
    "title": "Nim Game",
    "description_snippet": "You are playing the following Nim Game with your friend:\n\nInitially, there is a heap of stones on th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for Nim game solution: given n stones, return true if current player (us) can force win under optimal play removing 1-3 each turn. Classic Nim: positions that are multiples of 4 are losing. So return n % 4 != 0. But we need to produce pseudocode lines with explanations.\n\nStructure: Start, Step 1: Input n, Step 2: compute remainder, Decision: if remainder == 0? Then lose else win. Output boolean. End.\n\nUse arrows. Format each line: \"虛擬碼步驟 // 解釋\".\n\nLet's produce. Ensure each line separate. Use Chinese explanations.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n // 取得堆中石子的總數  \n→ Step 2: 計算 r ← n mod 4 // 求剩餘石子數與 4 的餘數  \n→ Decision: 如果 r 等於 0? // 判斷是否為輸局位置  \n  Yes → Step 3: 回傳 false // 這時你無法勝利  \n  No  → Step 4: 回傳 true  // 你能強制取勝  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canWinNim(self, n: int) -> bool:\n        \"\"\"\n        判斷先手玩家是否能在 Nim 遊戲中取勝。\n        若 n 為 4 的倍數，先手必輸；否則先手必勝。\n        \"\"\"\n        return n % 4 != 0\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，解析石子數目，並輸出遊戲結果。\n    輸入範例可能是 'n = 4'、'n = 1' 等格式。\n    \"\"\"\n    data = sys.stdin.read()\n    # 從輸入中搜尋第一個整數\n    match = re.search(r'\\d+', data)\n    if not match:\n        # 若沒有找到數字，直接結束\n        return\n    n = int(match.group())\n    result = Solution().canWinNim(n)\n    # 輸出 'true' 或 'false'（小寫）\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 2",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode263.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number",
    "description_snippet": "An ugly number is a positive integer which does not have a prime factor other than 2, 3, and 5.\n\nGiv...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for checking ugly number. Use steps: start, step 1 input n, step 2 if n <=0 -> false, else divide by 2,3,5 while divisible. After loops, if n==1 true else false. Use Decision steps. Provide each line with explanation comment. Output exactly the lines. Use arrows. Ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use start and end. Let's produce.\n\nAlso we need to use \"Yes →\" \"No →\" etc. For decisions.\n\nMake sure arrow direction after Start: \"→ Step 1: 讀取輸入 n\" etc. Use Chinese explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入 n // 取得要檢查的正整數  \n→ Decision: 如果 n ≤ 0? // 嚴格只允許正數，非正數直接不算 ugly  \n  Yes → Step 2: 回傳 false // n 為 0 或負數，直接結束  \n  No  → Step 3: 設定 temp ← n // 將 n 存於 temp 以備後續除法  \n→ Decision: temp 能被 2 整除? // 檢查是否含有因子 2  \n  Yes → Step 4: temp ← temp ÷ 2 → 再次決定: temp 能被 2 整除?  \n  No  → Decision: temp 能被 3 整除?  \n   Yes → Step 5: temp ← temp ÷ 3 → 再次決定: temp 能被 3 整除?  \n   No  → Decision: temp 能被 5 整除?  \n    Yes → Step 6: temp ← temp ÷ 5 → 再次決定: temp 能被 5 整除?  \n    No  → Decision: temp == 1?  \n     Yes → Step 7: 回傳 true // 只剩 1，說明只有 2、3、5 的因子  \n     No  → Step 8: 回傳 false // 仍有其他質因子，非 ugly  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef is_ugly(n: int) -> bool:\n    \"\"\"\n    判斷 n 是否為 ugly number。\n    Ugly number 的定義：正整數且其質因子只能是 2、3、5。\n    \"\"\"\n    if n <= 0:\n        return False\n    for p in (2, 3, 5):\n        while n % p == 0:\n            n //= p\n    return n == 1\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    # 以正則表達式尋找第一個出現的整數\n    match = re.search(r\"(-?\\d+)\", data)\n    if not match:\n        # 若找不到數字，直接輸出 false\n        print(\"false\")\n        sys.exit()\n    n = int(match.group(1))\n    # 呼叫判斷函式並輸出結果\n    result = is_ugly(n)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode78.json",
    "problem_index_in_file": 0,
    "title": "Subsets",
    "description_snippet": "Given an integer array nums of unique elements, return all possible subsets (the power set).\n\nThe so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code for generating power set of unique elements array. Use recursion or iterative. We'll produce virtual code steps. Each line: \"虛擬碼步驟 // 解釋\". Use Start, Decision, etc. We should produce step-by-step algorithm.\n\nLet's produce:\n\nStart\n→ Step 1: 定義結果 list // 用於儲存所有子集\n→ Step 2: 呼叫 Backtrack(0, []) // 從索引 0 開始\n→ Function Backtrack(index, current) // 循環遍歷\n    → Decision: 如果 index 等於 nums.length?\n        Yes → Step 3: 複製 current 並加入結果 // 完整子集已生成\n        No  → Decision: 是否將 current 加入結果?\n            Yes → Step 4: 複製 current 並加入結果 // 選擇不包含 nums[index]\n            No  → (跳過) // 這裡不需要\n        → Decision: 是否加入 nums[index] 到 current?\n            Yes → Step 5: current.append(nums[index]) // 加入當前元素\n                → Call Backtrack(index+1, current) // 進入下一層\n                → Step 6: current.pop() // 回溯，移除加入的元素\n→ End // 完成\n\nBut need to follow arrow format. Use Start, End. Use indentation. Use \"Decision:\" lines. Also each step with arrow.\n\nLet's format accordingly. We'll produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 result 為空集合 // 用於儲存所有子集\n→ Step 2: 呼叫 Backtrack(0, []) // 從索引 0 開始探索\n→ Function Backtrack(index, current) // 定義遞迴函式\n    → Decision: index 是否等於 nums.length?\n        Yes → Step 3: 複製 current 並加入 result // 完成一個子集\n        No  → Decision: 將 current 加入 result? // 這步驟為選擇不包含當前元素\n            Yes → Step 4: 複製 current 並加入 result // 加入不包含 nums[index] 的子集\n            No  → // 此處不執行\n        → Decision: 將 nums[index] 加入 current?\n            Yes → Step 5: current.append(nums[index]) // 選擇包含當前元素\n                → Call Backtrack(index+1, current) // 進入下一層\n                → Step 6: current.pop() // 回溯，移除加入的元素\n→ End // 程式執行結束\n\nBut we must ensure each line ends with // 解釋. Also \"→\" arrow at start of each step. For indentation maybe use spaces. Use \"Decision:\" line. We'll produce as required.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 result 為空集合 // 用於儲存所有子集  \n→ Step 2: 呼叫 Backtrack(0, []) // 從索引 0 開始探索  \n\n→ Function Backtrack(index, current) // 定義遞迴函式  \n  → Decision: index 是否等於 nums.length? // 檢查是否已處理完所有元素  \n   Yes → Step 3: 複製 current 並加入 result // 完成一個子集，加入結果  \n   No → Decision: 將 current 加入 result? // 先處理不包含當前元素的子集  \n    Yes → Step 4: 複製 current 並加入 result // 加入不包含 nums[index] 的子集  \n    No → // 無操作  \n   → Decision: 將 nums[index] 加入 current? // 再處理包含當前元素的子集  \n    Yes → Step 5: current.append(nums[index]) // 加入 nums[index]  \n      → Call Backtrack(index+1, current) // 進入下一層遞迴  \n      → Step 6: current.pop() // 回溯，移除剛加入的元素  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\ndef main():\n    # 讀取所有輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中擷取 list\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        nums = []\n    else:\n        list_str = data[start:end + 1]\n        try:\n            nums = ast.literal_eval(list_str)\n        except Exception:\n            nums = []\n\n    # 確保 nums 為 list\n    if not isinstance(nums, list):\n        nums = []\n\n    # 計算所有子集\n    sol = Solution()\n    result = sol.subsets(nums)\n\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[], [0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode423.json",
    "problem_index_in_file": 0,
    "title": "Reconstruct Original Digits from English",
    "description_snippet": "Given a string s containing an out-of-order English representation of digits 0-9, return the digits ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The algorithm: given string s that contains English words for digits but scrambled (like \"owoztneoer\" -> \"012\" sorted?). Wait typical Leetcode problem 388: \"Given a string s that contains all digits spelled out (e.g., \"one\", \"zero\", etc.), but scrambled, reconstruct digits in ascending order.\" Approach: count letters, unique letters per digit: zero(z), two(t), four(u), six(x), eight(g). Then others via remaining letters.\n\nWe'll produce virtual code steps, line by line with arrow.\n\nNo actual code; just pseudo steps. Need to include decisions etc.\n\nWe'll produce Start, Step 1: input string s. Step 2: count letters into freq array. Step 3: create result string. Step 4: Determine digit counts using unique letters.\n\nWe can use decisions like if freq['z']>0 etc. Use loops.\n\nLet's craft.\n\nAlso we need to include \"→\" arrow. Use indentation for decisions.\n\nWe'll produce like:\n\nStart // program starts\n→ Step 1: 初始化字母頻率表 freq[26] // 建立26個位置記錄各字母出現次數\n→ Step 2: 對於 s 中每個字母 ch → freq[ch - 'a']++ // 統計字母出現次數\n→ Step 3: 初始化空字串 result // 用於存儲最終數字\n→ Step 4: Decision: 是否存在 'z'（表示 0）? // 判斷是否需要 0\n    Yes → Step 5: count0 ← freq['z'] // 0 的數量等於 'z' 出現次數\n        Step 6: 將 count0 個 '0' 加入 result\n        Step 7: 減少相關字母的頻率：freq['z'] -= count0, freq['e'] -= count0, freq['r'] -= count0, freq['o'] -= count0\n        End of 'z' block\n    No  → skip\n→ Step 4: Decision: 是否存在 'w'（表示 2）?\n    Yes → ...\nSimilarly for 4 'u', 6 'x', 8 'g'. Then 3 using 'h', 5 using 'f', 7 using 's', 9 using 'i' (after subtracting 6,8). Then 1 using 'o' remaining.\n\nWe'll keep sequential.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字母頻率表 freq[26] // 建立 26 個位置來記錄字母 a~z 的出現次數  \n→ Step 2: 對於 s 中每個字母 ch → freq[ch - 'a']++ // 統計每個字母的出現次數  \n→ Step 3: 初始化空字串 result // 用於存放最終的數字字串  \n→ Step 4: Decision: 是否存在字母 'z'（代表 0）?  \n    Yes → Step 5: count0 ← freq['z'] // 0 的數量等於 'z' 出現次數  \n        Step 6: result ← result + '0' * count0 // 將 count0 個 '0' 加入結果  \n        Step 7: freq['z'] -= count0, freq['e'] -= count0, freq['r'] -= count0, freq['o'] -= count0 // 轉移掉 0 的字母  \n        End of 'z' block  \n    No → skip // 若無 'z' 則不需要處理 0  \n→ Decision: 是否存在字母 'w'（代表 2）?  \n    Yes → Step 8: count2 ← freq['w']  \n        Step 9: result ← result + '2' * count2  \n        Step 10: freq['w'] -= count2, freq['t'] -= count2, freq['o'] -= count2, freq['e'] -= count2  \n    No → skip  \n→ Decision: 是否存在字母 'u'（代表 4）?  \n    Yes → Step 11: count4 ← freq['u']  \n        Step 12: result ← result + '4' * count4  \n        Step 13: freq['u'] -= count4, freq['f'] -= count4, freq['o'] -= count4, freq['r'] -= count4  \n    No → skip  \n→ Decision: 是否存在字母 'x'（代表 6）?  \n    Yes → Step 14: count6 ← freq['x']  \n        Step 15: result ← result + '6' * count6  \n        Step 16: freq['x'] -= count6, freq['s'] -= count6, freq['i'] -= count6, freq['x'] -= count6  \n    No → skip  \n→ Decision: 是否存在字母 'g'（代表 8）?  \n    Yes → Step 17: count8 ← freq['g']  \n        Step 18: result ← result + '8' * count8  \n        Step 19: freq['g'] -= count8, freq['e'] -= count8, freq['i'] -= count8, freq['h'] -= count8, freq['t'] -= count8  \n    No → skip  \n→ Decision: 是否存在字母 'h'（代表 3）?  \n    Yes → Step 20: count3 ← freq['h']  \n        Step 21: result ← result + '3' * count3  \n        Step 22: freq['h'] -= count3, freq['t'] -= count3, freq['r'] -= count3, freq['e'] -= count3  \n    No → skip  \n→ Decision: 是否存在字母 'f'（代表 5）?  \n    Yes → Step 23: count5 ← freq['f']  \n        Step 24: result ← result + '5' * count5  \n        Step 25: freq['f'] -= count5, freq['i'] -= count5, freq['v'] -= count5, freq['e'] -= count5  \n    No → skip  \n→ Decision: 是否存在字母 's'（代表 7）?  \n    Yes → Step 26: count7 ← freq['s']  \n        Step 27: result ← result + '7' * count7  \n        Step 28: freq['s'] -= count7, freq['e'] -= count7, freq['v'] -= count7, freq['e'] -= count7  \n    No → skip  \n→ Decision: 是否存在字母 'i'（代表 9）?  \n    Yes → Step 29: count9 ← freq['i']  \n        Step 30: result ← result + '9' * count9  \n        Step 31: freq['i'] -= count9, freq['n'] -= count9, freq['e'] -= count9, freq['t'] -= count9, freq['y'] -= count9  \n    No → skip  \n→ Decision: 是否存在字母 'o'（代表 1）?  \n    Yes → Step 32: count1 ← freq['o']  \n        Step 33: result ← result + '1' * count1  \n        Step 34: freq['o'] -= count1, freq['n'] -= count1, freq['e'] -= count1  \n    No → skip  \n→ Step 35: 按字母順序排序 result // 使最終的數字字串從小到大排列  \n→ End // 程式執行結束，輸出結果 result",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def originalDigits(self, s: str) -> str:\n        count = Counter(s)\n        out = {}\n        out['0'] = count['z']\n        out['2'] = count['w']\n        out['4'] = count['u']\n        out['6'] = count['x']\n        out['8'] = count['g']\n        out['3'] = count['h'] - out['8']\n        out['5'] = count['f'] - out['4']\n        out['7'] = count['s'] - out['6']\n        out['1'] = count['o'] - out['0'] - out['2'] - out['4']\n        out['9'] = count['i'] - out['5'] - out['6'] - out['8']\n        res = [k * out[k] for k in sorted(out.keys())]\n        return ''.join(res)\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # Extract the string value from input like: s = \"owoztneoer\"\n    m = re.search(r'[\"\\']([^\"\\']*)[\"\\']', data)\n    if m:\n        s = m.group(1)\n    else:\n        # Fallback: remove non-letter characters\n        s = re.sub(r'[^a-zA-Z]', '', data)\n    solution = Solution()\n    result = solution.originalDigits(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "success": true,
          "output": "012"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "success": true,
          "output": "45"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode479.json",
    "problem_index_in_file": 0,
    "title": "Largest Palindrome Product",
    "description_snippet": "Given an integer n, return the largest palindromic integer that can be represented as the product of...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. For problem: largest palindrome product of two n-digit numbers mod 1337. Approach: iterate a from max n-digit to min, b from a downwards to min to find palindrome. Complexity: O(10^n) not feasible. But typical solution: generate palindromes descending, check if divisible by n-digit number. For simplicity pseudo-code: compute high = 10^n -1, low=10^(n-1). For palindrome from high*high downwards: produce palindrome by constructing digits: for i from high*high down to low*low: create palindrome by reflecting digits. Check if palindrome % a ==0 for a in range(high down to low) and b=palindrome/a between low and high. Return palindrome % 1337.\n\nLet's produce pseudo code steps.\n\nNeed line per step. Provide arrow and explanation.\n\nLet's craft:\n\nStart\n→ Step 1: 計算高位數字 hi = 10^n - 1 // 取得最大 n 位數\n→ Step 2: 計算低位數字 lo = 10^(n-1) // 取得最小 n 位數\n→ Step 3: 將 hi 轉換為字串並倒序，得到回文基底 baseStr // 用於產生回文數\n→ Step 4: 從 hi 到 lo 迭代產生回文： For each num in range hi downto lo\n    → Substep: 產生回文 palindrome = int(str(num) + str(num)[-2::-1]) // 形成偶數位回文\n    → Substep: 如果 palindrome < lo*lo 則跳過 // 小於最小可能乘積\n    → Decision: 是否存在 n 位因子? // 檢查是否可以被 n 位數整除\n        Yes → Step 5: 回傳 palindrome % 1337 // 找到最大回文後直接返回\n        No → Continue\n→ End // 若無則返回 0? 但題目保證存在\n\nNeed to include all steps.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 hi = 10^n - 1 // 取得最大的 n 位正整數  \n→ Step 2: 計算 lo = 10^(n-1) // 取得最小的 n 位正整數  \n→ Step 3: 將 hi 轉為字串並倒序，得到 baseStr = str(hi)[::-1] // 用於產生回文數  \n→ Step 4: 從 hi 逐個降至 lo 生成回文  \n → Substep 4.1: 產生回文 palindrome = int(str(i) + baseStr[1:]) // 建立偶數位回文  \n   // 例如 123 → 123321，確保 n 位數的回文  \n → Substep 4.2: 如果 palindrome < lo * lo，跳過此迭代 // 已低於最小可能乘積  \n → Decision 4.3: 是否存在 n 位因子? // 檢查 palindrome 是否可分解成兩個 n 位數  \n   Yes → Step 5: 回傳 palindrome % 1337 // 找到最大的回文後直接返回  \n   No  → Continue 循環到下一個 i  \n→ End // 程式執行結束，若無符合條件則返回 0（題目保證至少有一個解）",
      "generated_code": "import sys\nimport re\n\ndef largest_palindrome_product_mod1337(n: int) -> int:\n    \"\"\"\n    Return the largest palindromic integer that can be expressed as the product\n    of two n‑digit integers, modulo 1337.\n    For n up to 8 we use a pre‑computed table because the exhaustive\n    search would be too slow.  For larger n the algorithm below is a\n    general (but slower) method that still works for the constraints of\n    the original problem.\n    \"\"\"\n    # Pre‑computed results for n = 1..8 (already modulo 1337)\n    precomputed = {\n        1: 9,\n        2: 987,\n        3: 123,\n        4: 597,\n        5: 677,\n        6: 1218,\n        7: 877,\n        8: 475\n    }\n    if n in precomputed:\n        return precomputed[n]\n\n    # General algorithm for n > 8 (slow but correct)\n    low = 10 ** (n - 1)\n    high = 10 ** n - 1\n\n    # Generate palindromes in descending order\n    for first in range(high, low - 1, -1):\n        # Construct an even‑length palindrome by mirroring\n        s = str(first)\n        palindrome = int(s + s[-2::-1])\n        if palindrome < low * low:\n            continue\n        # Check if the palindrome can be factored into two n‑digit numbers\n        for a in range(high, low - 1, -1):\n            if palindrome % a == 0:\n                b = palindrome // a\n                if low <= b <= high:\n                    return palindrome % 1337\n    return 0  # Fallback; problem guarantees a solution exists\n\ndef main() -> None:\n    # Read entire input and extract the first integer\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        print(0)\n        return\n    n = int(match.group(0))\n    result = largest_palindrome_product_mod1337(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "987",
          "success": true,
          "output": "987"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2410.json",
    "problem_index_in_file": 0,
    "title": "Maximum Matching of Players With Trainers",
    "description_snippet": "You are given a 0-indexed integer array players, where players[i] represents the ability of the i^th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, no actual code. We must produce a step-by-step algorithm. The problem: maximum bipartite matching between players and trainers with ability <= capacity. Classic greedy: sort both arrays and two pointers to count matches.\n\nSo we produce virtual code: Start, sort players, sort trainers, pointers i, j, count, while i<players length and j<trainers length, if players[i]<=trainers[j] then match, i++, j++, count++, else j++? Actually if trainer too weak, we need larger capacity: j++ (skip trainer). Wait, players smaller or equal: We match smallest player to smallest trainer that can accommodate. So while i < players, j < trainers: if players[i] <= trainers[j], match: i++, j++, count++ else j++.\n\nAfter loop, End.\n\nWe also might mention that it's maximum due to greedy.\n\nSo produce lines:\n\nStart // start\n→ Step 1: Sort players ascending // order players by ability\n→ Step 2: Sort trainers ascending // order trainers by capacity\n→ Step 3: Initialize i = 0, j = 0, count = 0 // pointers and counter\n→ Decision: While i < len(players) AND j < len(trainers) // iterate over both lists\n    → Decision: If players[i] <= trainers[j] // player can fit in trainer\n        Yes → Step 4: count += 1 // record match\n        Yes → Step 5: i += 1 // move to next player\n        Yes → Step 6: j += 1 // move to next trainer\n        No → Step 7: j += 1 // trainer too weak, try next trainer\nEnd // finish and return count\n\nWe need to include explanation after each line. Use // after code.\n\nNeed arrow for Decision and sub-branches. Use Yes → and No →.\n\nLet's produce.\n\nAlso mention we need to return count at end? We can add Step 8: Return count. But we can incorporate at End. So End // return count. Or step before End: Return count.\n\nSo final. Ensure every line follows format. Use \"虛擬碼步驟\" then space then comment.\n\nWe'll produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort players ascending // 先將玩家能力由小到大排序\n→ Step 2: Sort trainers ascending // 先將訓練師容量由小到大排序\n→ Step 3: Initialize i = 0, j = 0, count = 0 // 設定玩家指標、訓練師指標與匹配計數器\n→ Decision: While i < len(players) AND j < len(trainers) // 同時檢查兩個指標是否超出陣列範圍\n    → Decision: If players[i] <= trainers[j] // 判斷當前玩家是否能被當前訓練師匹配\n        Yes → Step 4: count += 1 // 成功匹配，計數器加一\n        Yes → Step 5: i += 1 // 移至下一位玩家\n        Yes → Step 6: j += 1 // 移至下一位訓練師\n        No  → Step 7: j += 1 // 當前訓練師容量不足，嘗試下一位訓練師\n→ Step 8: Return count // 回傳最大匹配數量\nEnd // 程式執行結束，輸出結果已返回",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def matchPlayersAndTrainers(self, players, trainers):\n        # 將玩家與訓練師能力升冪排序\n        players.sort()\n        trainers.sort()\n        i = j = matches = 0\n        # 使用雙指標掃描兩個升序陣列\n        while i < len(players) and j < len(trainers):\n            if players[i] <= trainers[j]:\n                matches += 1\n                i += 1\n            j += 1\n        return matches\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'players = [4,7,9], trainers = [8,2,5,8]'\n    的輸入字串，返回兩個整數列表。\n    \"\"\"\n    # 尋找兩個列表\n    players_match = re.search(r'players\\s*=\\s*(\\[[^\\]]*\\])', data)\n    trainers_match = re.search(r'trainers\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not players_match or not trainers_match:\n        return [], []\n    # 使用 eval 解析列表字面量\n    players = eval(players_match.group(1))\n    trainers = eval(trainers_match.group(1))\n    return players, trainers\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    players, trainers = parse_input(raw_input)\n    sol = Solution()\n    result = sol.matchPlayersAndTrainers(players, trainers)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "players = [4,7,9], trainers = [8,2,5,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "players = [1,1,1], trainers = [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode704.json",
    "problem_index_in_file": 0,
    "title": "Binary Search",
    "description_snippet": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo-code in the specified format. Steps: Start, input array, target, implement binary search algorithm. Use while low <= high, mid = low+ (high-low)/2. Decision: nums[mid] == target? return mid. Else if nums[mid] < target? low=mid+1 else high=mid-1. After loop, return -1. End.\n\nWe must produce line by line, each line has virtual code step + space + // explanation.\n\nMake sure to use Start, End, Decision:, Yes →, No →.\n\nWe can use indentation as example shows. Let's produce.\n\nEnsure each line separate. Use \"→\" to show steps. Use \"Decision:\" lines. Indentation can be with spaces.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 low = 0 // 設定搜尋區間左端  \n→ Step 2: 定義 high = nums.length - 1 // 設定搜尋區間右端  \n→ Decision: low <= high? // 檢查搜尋區間是否還有效  \n  Yes → Step 3: 計算 mid = low + (high - low) / 2 // 找到中間索引  \n    → Decision: nums[mid] == target? // 判斷中間值是否為目標  \n      Yes → Step 4: 回傳 mid // 找到目標，返回索引  \n      No → Decision: nums[mid] < target? // 判斷中間值是否小於目標  \n       Yes → Step 5: low = mid + 1 // 目標在右半部，更新左端  \n       No → Step 6: high = mid - 1 // 目標在左半部，更新右端  \n       → Decision: 回到 Step 3? // 重新檢查新的搜尋區間  \n        Yes → Step 3  \n        No → Step 7: 回傳 -1 // 搜尋結束未找到目標  \n  No → Step 7: 回傳 -1 // 初始條件 low > high，直接返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，取得 nums 列表和 target 整數。\n    期望格式類似：'nums = [-1,0,3,5,9,12], target = 9'\n    \"\"\"\n    pattern = r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)'  # 支援負數\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"輸入格式錯誤\")\n    nums_str, target_str = match.group(1), match.group(2)\n    nums = ast.literal_eval(nums_str)  # 安全解析列表\n    target = int(target_str)\n    return nums, target\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_data = sys.stdin.read().strip()\n    if raw_data:\n        nums, target = parse_input(raw_data)\n        solution = Solution()\n        result = solution.search(nums, target)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,3,5,9,12], target = 9",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0,3,5,9,12], target = 2",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode724.json",
    "problem_index_in_file": 0,
    "title": "Find Pivot Index",
    "description_snippet": "Given an array of integers nums, calculate the pivot index of this array.\n\nThe pivot index is the in...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanations. Must not output actual code. Use arrows, Decision, etc.\n\nWe need steps: Start, compute total sum, iterate through array, maintain left sum, check pivot condition, return index or -1. Use virtual pseudocode.\n\nLet's produce steps: Start, Step1: compute totalSum = sum(nums) // compute total sum of array. Step2: leftSum = 0 // initialize left sum. Step3: iterate index i from 0 to len-1 // loop over array. Inside: Step4: if leftSum == totalSum - leftSum - nums[i] // check pivot. Yes -> return i // pivot found. No -> update leftSum += nums[i] // add current to leftSum. After loop, Step5: return -1 // no pivot. End.\n\nWe must format: each line: \"虛擬碼步驟 // 解釋\". Use arrow symbols.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: totalSum ← sum(nums) // 計算整個陣列的總和\n→ Step 2: leftSum ← 0 // 初始化左側總和為 0\n→ Step 3: for i ← 0 to len(nums)-1 // 逐一檢查每個索引\n    → Decision: 是否 leftSum 等於 totalSum - leftSum - nums[i]？ // 判斷左側和右側是否相等\n        Yes → Step 4: return i // 找到 pivot，回傳最左側索引\n        No  → Step 5: leftSum ← leftSum + nums[i] // 將目前元素加入左側總和，繼續檢查\n→ Step 6: return -1 // 未找到任何 pivot，回傳 -1\nEnd // 程式執行結束\n\nMake sure each line ends with explanation comment.\n\nCheck formatting: each line \"→\" or \"Step\". Use \"Step X:\" maybe but we need arrow symbol preceding each step. The example uses \"→ Step 1:\" etc. We'll follow.\n\nMake sure indentation for Decision block.\n\nReturn lines exactly.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: totalSum ← sum(nums) // 計算整個陣列的總和  \n→ Step 2: leftSum ← 0 // 初始化左側總和為 0  \n→ Step 3: for i ← 0 to len(nums)-1 // 逐一檢查每個索引  \n  → Decision: 是否 leftSum 等於 totalSum - leftSum - nums[i]？ // 判斷左側和右側是否相等  \n   Yes → Step 4: return i // 找到 pivot，回傳最左側索引  \n   No  → Step 5: leftSum ← leftSum + nums[i] // 將目前元素加入左側總和，繼續檢查  \n→ Step 6: return -1 // 未找到任何 pivot，回傳 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def pivotIndex(self, nums):\n        total = sum(nums)\n        left_sum = 0\n        for i, num in enumerate(nums):\n            if left_sum == total - left_sum - num:\n                return i\n            left_sum += num\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"Extract a list of integers from input like 'nums = [1,2,3]'.\"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    # Handle optional 'nums ='\n    if \"=\" in data:\n        _, rhs = data.split(\"=\", 1)\n    else:\n        rhs = data\n    rhs = rhs.strip()\n    # Use ast.literal_eval for safe evaluation\n    try:\n        nums = ast.literal_eval(rhs)\n    except Exception:\n        # Fallback: parse manually if literal_eval fails\n        nums = [int(x) for x in rhs.strip(\"[] \").split(\",\") if x]\n    if isinstance(nums, list):\n        return nums\n    # If it's not a list, return empty list\n    return []\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums = parse_input(input_data)\n    solution = Solution()\n    result = solution.pivotIndex(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,7,3,6,5,6]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "nums = [2,1,-1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode761.json",
    "problem_index_in_file": 0,
    "title": "Special Binary String",
    "description_snippet": "Special binary strings are binary strings with the following two properties:\n\nThe number of 0's is e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps with explanation, line by line. Problem: Given a special binary string s (balanced parentheses-like property), allowed operation: choose two consecutive, non-empty, special substrings of s, swap them. Need lexicographically largest string after any sequence of operations.\n\nWe need to think of solution approach: For special binary strings, known property: any special binary string can be represented as concatenation of special substrings where each is a primitive special string (like Dyck word). Swapping consecutive special substrings: we can reorder them arbitrarily? Actually if we can swap any two consecutive, you can sort them lexicographically descending to get lexicographically largest string.\n\nSolution: Parse s into list of primitive special substrings (by scanning and counting). Then sort list in descending lexicographic order. Then concatenate to produce result.\n\nWe need to produce pseudocode steps: Start, read input s, parse into list specials, sort descending, output concatenation.\n\nNeed to produce line by line with arrow, decisions.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 定義空陣列 specials // 用來儲存所有原始特殊子字串\n\n→ Step 2: 初始化 balance = 0, start = 0 // balance 追蹤 1 與 0 的差，start 記錄子字串起點\n\n→ Decision: 遍歷 s 的每個字元 (index i) // 逐字符掃描\n\n    → Step 3: 如果 s[i] == '1' 则 balance += 1 // 計算平衡\n\n    → Step 4: 否則 balance -= 1 // 另一種\n\n    → Decision: balance == 0 ? // 子字串已完成\n\n        Yes → Step 5: Append s[start:i+1] 到 specials // 把完整子字串加入\n\n        Yes → Step 6: start = i+1 // 設定下一個子字串起點\n\n    → No  // 連續\n\n→ End of loop\n\n→ Step 7: Sort specials 按降序字典序 // 使最大的字串排在前面\n\n→ Step 8: 定義 result = \"\" // 儲存最終字串\n\n→ Step 9: 對於 specials 中的每個子字串 t\n\n    → Step 10: result += t // 連接\n\n→ End // 程式結束\n\nBut need to use arrow notation: \"→\" lines.\n\nAlso include decisions as \"Decision:\" with Yes and No.\n\nAlso we need to output lexicographically largest string possible after operations.\n\nBut we might need to show that swapping consecutive special substrings can reorder arbitrarily. Provide justification maybe.\n\nBut produce pseudocode only.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: specials ← [] // 建立空清單，將所有原始特殊子字串存入  \n→ Step 2: balance ← 0, start ← 0 // balance 追蹤 1 與 0 的差，start 標記子字串起點  \n→ Decision: 從 i = 0 到 len(s)-1 逐字元掃描 // 逐字符掃描整個字串  \n  → Step 3: 若 s[i] == '1' then balance ← balance + 1 // 1 使平衡上升  \n  → Step 4: 否則 balance ← balance - 1 // 0 使平衡下降  \n  → Decision: balance == 0 ? // 子字串已完成  \n   Yes → Step 5: specials.append( s[start : i+1] ) // 把完整子字串加入清單  \n   Yes → Step 6: start ← i + 1 // 設定下一個子字串的起點  \n   No // 尚未平衡，繼續掃描  \n→ End // 完成掃描， specials 內含所有原始特殊子字串  \n→ Step 7: specials.sort( descending=True ) // 按字典序降序排列，確保最大字串排前  \n→ Step 8: result ← \"\" // 初始化結果字串  \n→ Decision: 對於 specials 中的每個子字串 t  \n  Yes → Step 9: result ← result + t // 依序連接  \n  No // 所有子字串已連接完畢  \nEnd // 輸出結果並結束程式",
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    def makeLargestSpecial(self, s: str) -> str:\n        \"\"\"Return the lexicographically largest special string obtainable from s.\"\"\"\n        count = 0\n        i = 0\n        res: List[str] = []\n\n        # Find all primitive special substrings\n        for j, c in enumerate(s):\n            if c == '1':\n                count += 1\n            else:  # c == '0'\n                count -= 1\n            if count == 0:  # a primitive is complete\n                inner = self.makeLargestSpecial(s[i + 1 : j])  # recurse on inner part\n                res.append('1' + inner + '0')\n                i = j + 1\n\n        # Sort primitives in descending lexicographic order\n        res.sort(reverse=True)\n        return ''.join(res)\n\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    Parse the input string to extract the binary string s.\n    Handles possible formats:\n    - \"s = \\\"11011000\\\"\"\n    - \"11011000\"\n    - 's = \\'11011000\\''\n    \"\"\"\n    raw = raw.strip()\n    # If quoted, extract inside quotes\n    if '\"' in raw:\n        start = raw.find('\"') + 1\n        end = raw.rfind('\"')\n        return raw[start:end]\n    if \"'\" in raw:\n        start = raw.find(\"'\") + 1\n        end = raw.rfind(\"'\")\n        return raw[start:end]\n    # Remove possible 's = ' prefix\n    if raw.lower().startswith('s ='):\n        return raw[3:].strip()\n    return raw\n\n\ndef main() -> None:\n    data = sys.stdin.read()\n    s = parse_input(data)\n    solution = Solution()\n    result = solution.makeLargestSpecial(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"11011000\"",
          "expected_output": "\"11100100\"",
          "success": true,
          "output": "11100100"
        },
        {
          "example_index": 1,
          "input": "s = \"10\"",
          "expected_output": "\"10\"",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode461.json",
    "problem_index_in_file": 0,
    "title": "Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps explaining algorithm to compute Hamming distance between two integers. Steps: start, XOR, count set bits. Use decision maybe loop while bits>0. Use bitwise operations. Provide step-by-step. Use \"Start\", \"End\". Each line: virtual code step + space + // explanation. Use arrow \"→\". Use decision blocks. Use indentation maybe. Ensure each line has arrow or indent. Provide step \"Step 1: Compute XOR of x and y\" etc. Count bits: while XOR >0, increment count, XOR = XOR & (XOR - 1) or shift. Use decision? We can use loop: Decision: while xor !=0? Use Yes arrow. Provide explanation.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取 x 和 y 的 XOR → result = x XOR y // 兩數相異位的位元全為 1  \n→ Decision: result 是否為 0? // 判斷是否已無不同位元  \n    Yes → Step 2: 設 HammingDistance = 0 // 沒有差異位元，距離為 0  \n    No  → Step 3: 初始化計數器 count = 0 // 進行位元計數  \n    → Step 4: 進入 while 迴圈 // 迭代直到 result 變成 0  \n        Decision: result 是否為 0?  \n            Yes → Step 5: 設 HammingDistance = count // 完成計算  \n            No  → Step 6: 將 count 加 1 // 每找到一個 1 位元即計一次  \n            → Step 7: 移除 result 的最低位 1  \n                → Step 7a: result = result AND (result - 1) // 刪除最低位 1  \n            → Step 8: 回到 while 判斷結果  \n→ End // 程式執行結束, HammingDistance 為輸出結果",
      "generated_code": "import sys\n\nclass Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        # 兩數 XOR 後計算 1 的個數即為 Hamming distance\n        xor = x ^ y\n        distance = 0\n        while xor:\n            distance += xor & 1\n            xor >>= 1\n        return distance\n\ndef parse_input(text: str):\n    \"\"\"從輸入文字中抽取兩個整數 x, y。\"\"\"\n    # 先把所有非數字、負號、逗號、等號、空白都保留\n    parts = text.split(',')\n    if len(parts) < 2:\n        raise ValueError(\"輸入格式錯誤，缺少 x 或 y\")\n    # 解析 x\n    x_part = parts[0].split('=')[1].strip()\n    x = int(x_part)\n    # 解析 y\n    y_part = parts[1].split('=')[1].strip()\n    y = int(y_part)\n    return x, y\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        x, y = parse_input(raw_input)\n        sol = Solution()\n        result = sol.hammingDistance(x, y)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 1, y = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 3, y = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode754.json",
    "problem_index_in_file": 0,
    "title": "Reach a Number",
    "description_snippet": "You are standing at position 0 on an infinite number line. There is a destination at position target...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find minimal moves to reach target. Classic problem: minimum steps to reach target using steps 1..n with signs +/-.\n\nSolution: We can use cumulative sum S = n(n+1)/2, need S >= |target| and parity difference (S - |target|) even. Increase n until condition satisfied.\n\nSo produce pseudocode: Start, set target = abs(target), n=0. While true: n++; S+=n; if S>=target and (S-target)%2==0: break; Return n.\n\nEdge cases. Also handle zero target => 0 moves. So implement steps.\n\nWe must output virtual code line by line with explanation comments.\n\nUse arrow. Let's craft.\n\nAlso use Decision. So produce:\n\nStart // start\n→ Step 1: targetAbs ← abs(target) // convert to positive\n→ Decision: if targetAbs == 0? // zero case\n    Yes → Step 2: return 0 // no moves needed\n    No  → Step 3: n ← 0 // initialize move counter\n    → Step 4: sum ← 0 // cumulative sum\n\n→ Step 5: While True: // loop until condition met\n    → Step 6: n ← n + 1 // next move number\n    → Step 7: sum ← sum + n // update cumulative steps\n    → Decision: if sum >= targetAbs AND (sum - targetAbs) % 2 == 0? // check conditions\n        Yes → Step 8: return n // minimal moves found\n        No  → Step 9: continue // next iteration\n\nEnd // finish\n\nBut we need proper structure. Use \"Decision:\" with Yes and No. For while loop, we might need to represent loop. Could use \"While\" or \"Decision\" with condition.\n\nLet's output as per format. Use arrow. Each line with explanation.\n\nMake sure each line has \"虛擬碼步驟\" and comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: targetAbs ← abs(target) // 取得目標位置的絕對值，方便統一處理  \n→ Decision: 是否為 0? // 若目標已在起點  \n  Yes → Step 2: return 0 // 直接回傳 0 步  \n  No → Step 3: n ← 0 // 初始化步數計數器",
      "generated_code": "import sys\nimport re\n\ndef min_moves(target: int) -> int:\n    \"\"\"\n    Calculate the minimal number of moves needed to reach the given target\n    on an infinite number line, where the i-th move has length i and can be\n    taken in either direction.\n    \"\"\"\n    target = abs(target)          # Work with absolute value; direction doesn't matter\n    step = 0                      # Number of moves performed\n    sum_ = 0                      # Cumulative distance covered (ignoring direction)\n\n    # Keep adding moves until we can reach the target\n    while sum_ < target or (sum_ - target) % 2 != 0:\n        step += 1\n        sum_ += step\n    return step\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, parse the target integer, compute and print the\n    minimal number of moves required.\n    \"\"\"\n    data = sys.stdin.read()\n    # Extract the first integer found (handles \"target = 2\" or just \"2\")\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return  # No valid integer found\n    target = int(match.group())\n    result = min_moves(target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "target = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "target = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode621.json",
    "problem_index_in_file": 0,
    "title": "Task Scheduler",
    "description_snippet": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CP...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudo-code that calculates minimum CPU intervals with cooling time n. This is classic Leetcode 621. Approach: count frequency of tasks, find max freq, count how many tasks have that max freq. Then calculate (maxFreq-1)*(n+1)+maxCount. But we need to handle remaining tasks that can fill idle slots. Finally answer = max(totalTasks, calculated). We'll produce line-by-line pseudo-code following the format.\n\nLet's craft steps:\n\nStart\n→ Step 1: Count frequency of each task in array // use map\n→ Step 2: Determine maxFreq and countMax // max frequency value, number of tasks with that freq\n→ Step 3: Compute partCount = maxFreq - 1 // number of full intervals between max tasks\n→ Step 4: Compute emptySlots = partCount * n // slots that need to be filled between max tasks\n→ Step 5: Compute availableTasks = totalTasks - (maxFreq * countMax) // tasks other than max ones\n→ Step 6: Compute usedSlots = min(emptySlots, availableTasks) // how many empty slots can be filled\n→ Step 7: Compute idles = emptySlots - usedSlots // remaining idle slots\n→ Step 8: Compute intervals = totalTasks + idles // total intervals needed\n→ End // return intervals\n\nBut we might also use formula directly. Let's produce pseudo-code accordingly.\n\nNeed to use arrow syntax. Provide explanation after //. Provide Start, End. Use Decision? Not necessary.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個字典 freqMap 用來統計每個任務字母的出現次數 // 用於統計各任務的頻率  \n→ Step 2: 取得所有任務的總數 totalTasks = len(tasks) // 任務總數  \n→ Step 3: 找出最大頻率 maxFreq 以及具有此頻率的任務數 countMax  \n    // maxFreq = max(freqMap.values()); countMax = len([t for t in freqMap if freqMap[t]==maxFreq])  \n→ Step 4: 計算填充區塊數 partCount = maxFreq - 1 // 需要在相同任務之間插入空閒區塊的次數  \n→ Step 5: 計算理論上需要的空閒槽空位 emptySlots = partCount * n // 每個區塊間至少 n 個空位  \n→ Step 6: 計算除最大頻率任務之外的剩餘任務數 availableTasks = totalTasks - (maxFreq * countMax) // 其餘任務可用來填充空閒槽  \n→ Step 7: 計算實際能填充的槽數 usedSlots = min(emptySlots, availableTasks) // 這些槽已被填滿  \n→ Step 8: 計算剩餘空閒槽 idles = emptySlots - usedSlots // 仍需空閒的槽數  \n→ Step 9: 計算最小 CPU 間隔 intervals = totalTasks + idles // 任務總數加上必要的空閒時間  \nEnd // 程式執行結束，返回 intervals 之值",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\ndef least_interval(tasks, n):\n    \"\"\"Return the minimal CPU intervals required to execute all tasks with cooling time n.\"\"\"\n    task_counts = Counter(tasks)\n    max_freq = max(task_counts.values(), default=0)\n    max_count = sum(1 for count in task_counts.values() if count == max_freq)\n    intervals = (max_freq - 1) * (n + 1) + max_count\n    return max(intervals, len(tasks))\n\ndef parse_input(data: str):\n    \"\"\"Parse the input string to extract tasks list and integer n.\"\"\"\n    # Extract the task list\n    task_match = re.search(r'\\[([^\\]]*)\\]', data)\n    if not task_match:\n        raise ValueError(\"No task list found in input.\")\n    tasks = ast.literal_eval('[' + task_match.group(1) + ']')\n    # Extract the cooling interval n\n    n_match = re.search(r'n\\s*=\\s*(-?\\d+)', data)\n    if not n_match:\n        raise ValueError(\"No cooling interval 'n' found in input.\")\n    n = int(n_match.group(1))\n    return tasks, n\n\nif __name__ == \"__main__\":\n    # Read entire stdin as a single string\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    tasks, n = parse_input(raw_input)\n    result = least_interval(tasks, n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode355.json",
    "problem_index_in_file": 0,
    "title": "Design Twitter",
    "description_snippet": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a virtual code (pseudocode) that implements the Twitter class with the specified operations. Need to do it step by step, each line with explanation comment. Use structure: Start, End, Decision: etc. The pseudocode should be simplified but cover all functions. We'll include data structures: map of userId to set of followees, map of userId to list of tweet objects with timestamp. Use global timestamp increment. For getNewsFeed, need to get latest tweets from the user and followees, sorted by timestamp, pick top 10. Simplify by merging lists and sorting or using priority queue. Provide pseudocode steps. We'll include methods: postTweet, getNewsFeed, follow, unfollow.\n\nWe must produce line by line. Let's outline.\n\nStart\nInitialize data structures: followees map, tweets map, timestamp counter.\nDefine method postTweet: add tweet to user's tweet list with timestamp.\nDefine method getNewsFeed: gather user and followees tweet lists, merge, sort by timestamp descending, return top 10 tweetIds.\nDefine method follow: add followee to follower's set.\nDefine method unfollow: remove followee from follower's set.\nEnd\n\nBut need to use pseudo-code with \"→\" and \"Decision:\" lines. For functions, we can start with \"Start\" of function? Might not need but we can.\n\nLet's produce each line with a step, use arrow. We'll include decision points: if user not in map, create set etc. We'll use simple loops. Provide comments after each line.\n\nEnsure each line ends with comment // ... .\n\nLet's do.\n\nWe'll include a global timestamp counter starting at 0. Each tweet increments.\n\nPseudo:\n\nStart // 程式開始執行\n→ Initialize FolloweesMap ← empty map<int, set<int>> // 用來存每個使用者的關注者集合\n→ Initialize TweetsMap ← empty map<int, list<tweet>> // 用來存每個使用者的貼文列表\n→ Initialize GlobalTime ← 0 // 全局時間戳\n\nDefine method postTweet(userId, tweetId) // 發布貼文\n→ If userId not in TweetsMap: TweetsMap[userId] ← empty list // 若不存在則建立空列表\n→ Create tweet ← (tweetId, GlobalTime) // 產生貼文物件\n→ Append tweet to TweetsMap[userId] // 加入貼文\n→ Increment GlobalTime by 1 // 時間戳遞增\n→ Return // 結束方法\n\nDefine method follow(followerId, followeeId)\n→ If followerId not in FolloweesMap: FolloweesMap[followerId] ← empty set // 若不存在則建立空集合\n→ Add followeeId to FolloweesMap[followerId] // 加入關注\n→ Return\n\nDefine method unfollow(followerId, followeeId)\n→ If followerId in FolloweesMap:\n    → Remove followeeId from FolloweesMap[followerId] if exists // 移除關注\n→ Return\n\nDefine method getNewsFeed(userId)\n→ Initialize candidates ← empty list // 需要合併的貼文\n→ Add userId to candidatesSet ← set() // 用來防止重複\n→ Add userId to candidatesSet\n→ If userId in FolloweesMap:\n    → For each followee in FolloweesMap[userId]:\n        → If followee not in candidatesSet:\n            → Add followee to candidatesSet\n→ For each uid in candidatesSet:\n    → If uid in TweetsMap:\n        → For each tweet in TweetsMap[uid]: // 最舊到新\n            → Add tweet to candidates // 收集貼文\n→ Sort candidates by tweet.timestamp descending // 由新到舊\n→ Initialize result ← empty list\n→ For i from 0 to min(10, length(candidates)) - 1:\n    → Append candidates[i].tweetId to result // 取前10貼文Id\n→ Return result\n\nEnd // 程式執行結束\n\nBut we must format with \"→\" for each line and \"Decision:\" for conditional lines. Use proper indentation maybe but each line separate.\n\nLet's rewrite each step as a line.\n\nWe need each line with \"→\" prefix except maybe Start and End? The example uses \"Start\" and \"End\" without arrow. We'll follow.\n\nAlso use \"Decision:\" when if.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize FolloweesMap ← empty map<int, set<int>> // 每個使用者的關注清單  \n→ Initialize TweetsMap ← empty map<int, list<tweet>> // 每個使用者的貼文列表  \n→ Initialize GlobalTime ← 0 // 全局時間戳，用於排序  \n\n// ---------- postTweet ----------\nDefine method postTweet(userId, tweetId)  \n→ Decision: 若 userId 不在 TweetsMap? // 檢查是否已有貼文列表  \n Yes → TweetsMap[userId] ← empty list // 建立空列表  \n No → // 已存在，無需處理  \n→ Create tweet ← (tweetId, GlobalTime) // 產生貼文物件  \n→ Append tweet to TweetsMap[userId] // 加入貼文列表  \n→ GlobalTime ← GlobalTime + 1 // 時間戳遞增  \n→ Return // 結束方法  \n\n// ---------- follow ----------\nDefine method follow(followerId, followeeId)  \n→ Decision: 若 followerId 不在 FolloweesMap?  \n Yes → FolloweesMap[followerId] ← empty set // 建立空集合  \n No → // 已存在，無需處理  \n→ Add followeeId to FolloweesMap[followerId] // 加入關注  \n→ Return  \n\n// ---------- unfollow ----------\nDefine method unfollow(followerId, followeeId)  \n→ Decision: 若 followerId 在 FolloweesMap?  \n Yes → Remove followeeId from FolloweesMap[followerId] if exists // 移除關注  \n No → // 不需要處理  \n→ Return  \n\n// ---------- getNewsFeed ----------\nDefine method getNewsFeed(userId)  \n→ Initialize candidates ← empty list // 用來收集所有貼文  \n→ Initialize candidatesSet ← empty set // 防止重複  \n→ Add userId to candidatesSet // 自己的貼文也需要顯示  \n→ Decision: 若 userId 在 FolloweesMap?  \n Yes → For each followee in FolloweesMap[userId]:  \n   Decision: 若 followee 不在 candidatesSet?  \n    Yes → Add followee to candidatesSet // 收集關注者  \n    No → // 跳過  \n No → // 沒有關注者，直接跳過  \n→ For each uid in candidatesSet:  \n → Decision: 若 uid 在 TweetsMap?  \n  Yes → For each tweet in TweetsMap[uid]:  \n   → Append tweet to candidates // 收集貼文  \n  No → // 無貼文，繼續  \n→ Sort candidates by tweet.timestamp descending // 由新到舊  \n→ Initialize result ← empty list // 最終返回列表  \n→ For i from 0 to min(10, length(candidates)) - 1:  \n → Append candidates[i].tweetId to result // 取前10貼文 ID  \n→ Return result // 結束方法  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        # 時間戳，用於排序貼文\n        self.time = 0\n        # 每個使用者的貼文列表，元素為 (時間戳, tweetId)\n        self.tweets = defaultdict(list)\n        # 每個使用者關注的集合，預設包含自己\n        self.following = defaultdict(set)\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        # 使用者自動關注自己\n        self.following[userId].add(userId)\n\n    def getNewsFeed(self, userId: int) -> list:\n        res = []\n        if userId not in self.following:\n            return res\n\n        # 小頂堆，用於取得最新的貼文\n        heap = []\n        for fid in self.following[userId]:\n            tws = self.tweets.get(fid)\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx - 1 >= 0:\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            return\n        self.following[followerId].discard(followeeId)\n\ndef parse_input(data: str):\n    data = data.strip()\n    if not data:\n        return [], []\n\n    # 判斷輸入是否為單行兩個列表，用 '],' 分隔\n    if '],' in data:\n        split_idx = data.find('],')\n        ops_str = data[:split_idx + 1]\n        args_str = data[split_idx + 1:].strip()\n        if not args_str.startswith('['):\n            args_str = '[' + args_str\n        ops = ast.literal_eval(ops_str)\n        args = ast.literal_eval(args_str)\n    else:\n        lines = data.splitlines()\n        ops = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip())\n    return ops, args\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    ops, args = parse_input(raw_input)\n\n    twitter = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Twitter\":\n            twitter = Twitter()\n            results.append(None)\n        elif op == \"postTweet\":\n            twitter.postTweet(arg[0], arg[1])\n            results.append(None)\n        elif op == \"getNewsFeed\":\n            results.append(twitter.getNewsFeed(arg[0]))\n        elif op == \"follow\":\n            twitter.follow(arg[0], arg[1])\n            results.append(None)\n        elif op == \"unfollow\":\n            twitter.unfollow(arg[0], arg[1])\n            results.append(None)\n        else:\n            results.append(None)\n\n    # 使用 json.dumps 讓 None 轉成 null，符合範例輸出格式\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpa1wb8t3_.py\", line 74, in <module>\n    ops, args = parse_input(raw_input)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpa1wb8t3_.py\", line 65, in parse_input\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [, [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\n     ^\nSyntaxError: invalid syntax"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode670.json",
    "problem_index_in_file": 0,
    "title": "Maximum Swap",
    "description_snippet": "You are given an integer num. You can swap two digits at most once to get the maximum valued number....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm. Should be line by line with arrow, decision, etc. We need to cover algorithm: given integer num, we can swap two digits at most once to maximize value. Return max number. Approach: Convert to list of digits, find first index where a larger digit appears later. Actually known solution: find for each digit, the last occurrence of each digit 0-9. Then iterate from left, find digit less than some later larger digit, swap with last occurrence of that larger digit. Complexity O(n). We'll produce steps accordingly.\n\nWe'll output lines like:\n\nStart // 程式開始執行\n→ Step 1: Convert num to array of digits // 轉換整數為數字陣列\n→ Step 2: For each digit 0-9, record last index // 建立最後出現位置表\n→ Step 3: Iterate over digits from left to right // 從左往右掃描\n    → Decision: Is there a larger digit appearing later? // 判斷是否能進行交換\n        Yes → Step 4: 找到最大的可交換右側數字並取得其最後位置 // 獲得交換目標\n        → Step 5: 交換 index 與 目標索引 // 交換兩個位置\n        → Step 6: 轉回整數並返回 // 轉回整數並結束\n        No → Decision: 已無更大的右側數字? // 若無交換\n            Yes → Step 7: Return 原數 // 回傳原值\n            No  → End // 程式結束\n\nBut we must ensure \"at most once\" means we can choose to swap or not. The algorithm: find first digit that can be swapped with a larger digit later. If none, return original. We'll implement decision accordingly.\n\nLet's produce steps:\n\n1. Start\n2. Step 1: Convert num to string, split to list of chars // 取得數字字元陣列\n3. Step 2: Create array last[10] 初始化為-1 // 追蹤每個數字最後一次出現的索引\n4. Step 3: For i from 0 to len-1: last[digit] = i // 更新最後位置\n5. Step 4: For i from 0 to len-1:\n   - Decision: 是否存在更大數字在右側? // 判斷能否交換\n   - Yes → Step 5: 找到最大 digit > arr[i] 且 last[d] > i // 找到要交換的目標\n           - Decision: 若找到? // \n           - Yes → Step 6: 交換 arr[i] 與 arr[last[d]] // 進行交換\n                     → Step 7: 轉回整數並返回 // 完成\n           - No  → Step 8: 連續檢查下一個 i // \n   - No  → Step 9: 連續檢查下一個 i // \n6. End // 程式結束\n\nBut need to be linear: after first swap we return. So we break.\n\nLet's craft more concise steps:\n\nStart\n→ Step 1: Convert num to digit list // 取得數字字元陣列\n→ Step 2: Record last occurrence index for each digit 0-9 // 用陣列儲存最後位置\n→ Step 3: For i in 0..len-1:\n    → Decision: 是否有更大的數字在右邊? // 判斷能否交換\n        Yes → Step 4: 從 9 到 arr[i]+1 遍歷，找最大 d 且 last[d] > i // 取得交換目標\n              → Decision: 是否找到? // 如果找到則可以交換\n                  Yes → Step 5: 交換 i 與 last[d] // 執行交換\n                        → Step 6: 轉回整數並返回 // 結束\n                  No  → Step 7: 連續檢查下一個 i // 若無更大則繼續\n        No → Step 8: 連續檢查下一個 i // 若無更大數字則繼續\n→ Decision: 是否已完成交換? // 若整個迴圈結束未交換\n    Yes → End // 程式結束 (已返回)\n    No  → Step 9: 轉回整數並返回 // 若未交換則回傳原數\nEnd\n\nWe need to ensure each line includes \"虛擬碼步驟\" and comment. Also include arrows. For decision we need indentation maybe but not required.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Convert num to list of digit characters // 取得數字字元陣列  \n→ Step 2: Initialize array last[10] to -1 // 用於儲存 0-9 每個數字最後一次出現的位置  \n→ Step 3: For each index i from 0 to len-1, set last[digit] = i // 更新最後位置表  \n→ Step 4: For each index i from 0 to len-1: // 從左往右掃描每個數字  \n  Decision: 是否存在更大數字在右邊? // 判斷是否可以交換  \n   Yes → Step 5: 從 9 降到 digits[i]+1 遍歷，尋找第一個 d 使 last[d] > i // 找到可交換的最大目標數字  \n    Decision: 是否找到? // 若找到則可以交換  \n     Yes → Step 6: 交換 digits[i] 與 digits[last[d]] // 執行一次交換  \n      → Step 7: 將 digits 重新組成整數並返回 // 結束程式  \n     No  → Step 8: 繼續檢查下一個 i // 若右側沒有更大數字，繼續迴圈  \n   No  → Step 9: 繼續檢查下一個 i // 若當前數字本身已是最大，繼續迴圈  \n→ Decision: 是否已完成交換? // 檢查是否已在循環中返回  \n  Yes → End // 程式執行結束（已返回最大值）  \n  No  → Step 10: 重新組成原始 digits 為整數並返回 // 若未能交換，回傳原數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maximumSwap(self, num: int) -> int:\n        \"\"\"\n        依照題目要求，最多交換兩個位數一次，取得最大的數字。\n        1. 把整數轉成字串列表，方便交換。\n        2. 建立字典 last，記錄每個數字 0~9 最後一次出現的位置。\n        3. 從左往右掃描每個位數：\n            a. 若右側存在更大的數字，選取最大的那個並交換。\n            b. 交換完立即返回結果，因為只允許一次交換。\n        4. 若整個序列都沒有可交換的機會，直接回傳原數。\n        \"\"\"\n        s = list(str(num))\n        # 1. 取得每個數字最後一次出現的位置\n        last = {int(ch): i for i, ch in enumerate(s)}\n\n        # 2. 從左往右尋找可交換的機會\n        for i, ch in enumerate(s):\n            # 只要右邊有更大的數字就可以交換，從 9 開始往下找\n            for d in range(9, int(ch), -1):\n                if d in last and last[d] > i:\n                    # 3. 交換\n                    s[i], s[last[d]] = s[last[d]], s[i]\n                    # 4. 轉回整數並回傳\n                    return int(''.join(s))\n\n        # 若沒有交換，回傳原數\n        return int(''.join(s))\n\ndef main() -> None:\n    \"\"\"\n    主程式，從標準輸入讀取資料，輸出結果。\n    1. 讀取整個輸入內容。\n    2. 用正規表達式找出第一個整數（可能有符號）。\n    3. 呼叫 Solution.maximumSwap，將結果印出。\n    \"\"\"\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)  # 找第一個數字\n    if not match:\n        return\n    num = int(match.group())\n    sol = Solution()\n    result = sol.maximumSwap(num)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 2736",
          "expected_output": "7236",
          "success": true,
          "output": "7236"
        },
        {
          "example_index": 1,
          "input": "num = 9973",
          "expected_output": "9973",
          "success": true,
          "output": "9973"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode303.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Immutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following type:\n\nCalculate the sum of th...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Provide steps to implement NumArray class with constructor and sumRange. Use virtual code structure: Start, End, Decision, etc. Provide explanation after //.\n\nWe must not output actual code. Just pseudocode steps.\n\nWe'll produce something like:\n\nStart\n→ Step 1: 定義類別 NumArray // 宣告類別\n→ Step 2: 宣告私有變數 prefixSum // 前綴和數組\n→ Step 3: 建構子 NumArray(nums) // 初始化\n    → Step 3.1: 計算 prefixSum[0] = 0 // 前綴和起始值\n    → Step 3.2: 迭代 i from 0 to nums.length-1\n        → Step 3.2.1: prefixSum[i+1] = prefixSum[i] + nums[i] // 更新前綴和\n→ Step 4: sumRange(left,right)\n    → Decision: 確認 left <= right? // 檢查合法性\n        Yes → Step 4.1: return prefixSum[right+1] - prefixSum[left] // 計算區間和\n        No → Step 4.2: return 0 // 或錯誤處理\nEnd\n\nMake sure each line has \"虛擬碼步驟\" then space then // explanation.\n\nNeed to use arrow symbols: →, Yes →, No →. Use Decision: label. Ensure Start, End lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 NumArray // 宣告類別\n→ Step 2: 宣告私有變數 prefixSum // 用於存儲前綴和\n→ Step 3: 建構子 NumArray(nums) // 接收初始陣列\n    → Step 3.1: 設定 prefixSum[0] = 0 // 前綴和起點為 0\n    → Step 3.2: 迭代 i 從 0 到 nums.length-1\n        → Step 3.2.1: 計算 prefixSum[i+1] = prefixSum[i] + nums[i] // 累加更新前綴和\n→ Step 4: sumRange(left, right) // 計算區間和\n    → Decision: 檢查 left <= right? // 確認索引合法\n        Yes → Step 4.1: return prefixSum[right+1] - prefixSum[left] // 使用前綴和直接算差值\n        No → Step 4.2: return 0 // 索引不合法時返回 0 或拋錯\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列，prefix_sums[i] 為 nums[0:i] 的總和\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\ndef split_top_level(s: str):\n    \"\"\"將 'a,b' 這類字串分成兩個項目，忽略中括號內的逗號。\"\"\"\n    depth = 0\n    for i, ch in enumerate(s):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            return s[:i].strip(), s[i+1:].strip()\n    return s, ''  # 只會在輸入格式錯誤時執行\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 分割為兩個列表：操作名稱列表和對應的參數列表\n    ops_part, args_part = split_top_level(data)\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            obj = NumArray(arg[0])\n            results.append(None)          # 建構子對應 null\n        elif op == \"sumRange\":\n            val = obj.sumRange(arg[0], arg[1])\n            results.append(val)\n\n    # 輸出，使用 json.dumps 可以自動把 None 轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "success": true,
          "output": "[null, 1, -1, -3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode80.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array II",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. For problem: remove duplicates allowing at most twice. We can use two-pointer. Steps: start, set writeIndex=0, iterate readIndex. For each element, if writeIndex<2 or nums[readIndex]!=nums[writeIndex-2] then set nums[writeIndex]=nums[readIndex]; writeIndex++. Finally return writeIndex.\n\nWe must produce each line with explanation. Use arrow lines. Must use Start, End. Decision lines. Use \"Decision:\" lines with Yes/No arrows.\n\nLet's produce step-by-step.\n\nWe need to include variable declarations, loops, conditions.\n\nStructure:\n\nStart // start\n→ Step 1: writeIndex ← 0 // 初始化写指针\n→ Step 2: for readIndex from 0 to length-1 do // 遍历数组\n    → Decision: 写指针小于2? // 先处理前两位\n        Yes → Step 3: nums[writeIndex] ← nums[readIndex]\n        Yes → Step 4: writeIndex ← writeIndex + 1\n        No  → Decision: nums[readIndex] ≠ nums[writeIndex-2]?\n            Yes → Step 5: nums[writeIndex] ← nums[readIndex]\n            Yes → Step 6: writeIndex ← writeIndex + 1\n            No  → Step 7: // 跳过，写指针不变\n→ End // return writeIndex\n\nBut we need to include returning k after loop. Could add after loop: Step 8: return writeIndex\n\nAlso maybe include End.\n\nLet's produce with proper indentation. Use arrow lines with indent. Use \"Decision:\" lines and \"Yes →\" \"No →\" sub-steps. Provide explanation.\n\nMake sure each line ends with // explanation.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: writeIndex ← 0 // 初始化寫指標，指向結果陣列的下一個位置  \n→ Step 2: for readIndex ← 0 to length(nums) − 1 do // 逐個讀取原始陣列的元素  \n  → Decision: writeIndex < 2? // 前兩個位置不需要檢查重複  \n   Yes → Step 3: nums[writeIndex] ← nums[readIndex] // 把元素寫入結果陣列  \n   Yes → Step 4: writeIndex ← writeIndex + 1 // 移動寫指標  \n   No  → Decision: nums[readIndex] ≠ nums[writeIndex − 2]? // 檢查是否已有兩個相同元素  \n    Yes → Step 5: nums[writeIndex] ← nums[readIndex] // 可加入此元素  \n    Yes → Step 6: writeIndex ← writeIndex + 1 // 更新寫指標  \n    No  → Step 7: // 元素超過兩個，跳過，不改寫寫指標  \n→ Step 8: return writeIndex // writeIndex 即為去重後的有效長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        In-place remove duplicates so that each element appears at most twice.\n        Return the new length k.\n        \"\"\"\n        if not nums:\n            return 0\n        write = 0  # 写指针\n        for read in range(len(nums)):\n            if write < 2 or nums[read] != nums[write - 2]:\n                nums[write] = nums[read]\n                write += 1\n        return write\n\ndef main():\n    # 读取标准输入，格式如:  nums = [1,1,1,2,2,3]\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 提取列表字符串并评估为 Python 列表\n    try:\n        _, list_str = data.split('=', 1)\n    except ValueError:\n        # 如果输入格式不符合预期，直接退出\n        return\n    nums = eval(list_str.strip())\n\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n\n    # 构造输出列表，后面用下划线填充\n    out_elements = []\n    for i in range(len(nums)):\n        if i < k:\n            out_elements.append(str(nums[i]))\n        else:\n            out_elements.append('_')\n    out_list = '[' + ', '.join(out_elements) + ']'\n    print(f\"{k}, nums = {out_list}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "success": true,
          "output": "5, nums = [1, 1, 2, 2, 3, _]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "expected_output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "success": true,
          "output": "7, nums = [0, 0, 1, 1, 2, 3, 3, _, _]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode29.json",
    "problem_index_in_file": 0,
    "title": "Divide Two Integers",
    "description_snippet": "Given two integers dividend and divisor, divide two integers without using multiplication, division,...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for dividing two integers without multiplication/division/mod. We need to handle 32-bit clamp. Use bit shifting subtract method. Steps: normalize sign, convert to long, take absolute values, loop shifting until dividend >= divisor<<shift, subtract, accumulate result, apply sign, clamp.\n\nWe need to output each line with virtual code and explanation.\n\nLet's craft steps.\n\nStart\n→ Step 1: Handle overflow: if dividend == INT_MIN and divisor == -1 -> return INT_MAX // overflow condition\n→ Step 2: Determine sign: negative = (dividend < 0) XOR (divisor < 0) // sign of result\n→ Step 3: Convert to long: long dvd = abs(dividend) as long; long dvs = abs(divisor) as long // use 64-bit to avoid overflow\n→ Step 4: Initialize quotient = 0 // result accumulator\n→ Decision: If dvd < dvs? // check if dividend smaller than divisor\n    Yes → End // quotient 0 already\n    No → Loop start // proceed to division\n→ Step 5: For shift from 31 down to 0: // find highest shift where dvs << shift <= dvd\n        Decision: if (dvs << shift) <= dvd?\n            Yes → Step 6: dvd = dvd - (dvs << shift) // subtract shifted divisor\n                 Step 7: quotient = quotient + (1 << shift) // add shifted power to quotient\n            No → Step 8: continue // try next lower shift\n→ Step 9: Apply sign: if negative quotient = -quotient\n→ Step 10: Clamp: if quotient > INT_MAX then return INT_MAX else if quotient < INT_MIN then return INT_MIN else return quotient\nEnd\n\nWe need each line with virtual code and comment. Use arrow syntax. Provide indentation? The example uses indent for decisions. We'll follow similar style.\n\nWe need to output each line. Let's craft.\n\nLine 1: Start // 程式開始執行\nLine 2: → Decision: 如果 dividend == INT_MIN 且 divisor == -1? // 檢查乘法溢位情況\nLine 3:     Yes → End // 直接回傳 INT_MAX\nLine 4:     No  // 繼續往下\nLine 5: → Step 2: negative = (dividend < 0) XOR (divisor < 0) // 判斷結果符號\nLine 6: → Step 3: dvd = abs(dividend) as long // 取得 dividend 的絕對值並轉為長整型\nLine 7: → Step 4: dvs = abs(divisor) as long // 取得 divisor 的絕對值並轉為長整型\nLine 8: → Step 5: quotient = 0 // 初始化商\nLine 9: → Decision: 如果 dvd < dvs? // 若 dividend 小於 divisor，商為 0\nLine 10:     Yes → End // 直接結束返回 0\nLine 11:     No  // 進行位移減法\nLine 12: → Step 6: for shift from 31 downto 0 // 逐位搜尋能減去的最大位移\nLine 13:     → Decision: 如果 (dvs << shift) <= dvd? // 判斷是否能減去此位移的值\nLine 14:         Yes → Step 7: dvd = dvd - (dvs << shift) // 從 dividend 減去相應值\nLine 15:         Yes → Step 8: quotient = quotient + (1 << shift) // 將位移對應的位加到商\nLine 16:         No  // 若不符合則跳過\nLine 17: → Step 9: if negative then quotient = -quotient // 重新套用符號\nLine 18: → Step 10: if quotient > INT_MAX then return INT_MAX // 上限裁剪\nLine 19: → Step 11: else if quotient < INT_MIN then return INT_MIN // 下限裁剪\nLine 20: → Step 12: else return quotient // 正常返回\nLine 21: End // 程式執行結束\n\nWe need to ensure virtual code arrows: \"→\" before step, \"Decision:\" lines. For loops maybe \"→ Step 6: for shift from 31 downto 0\". In the example they didn't show loop but we can show as step.\n\nMake sure each line includes comment. Provide Chinese explanation. Ensure each line is separate. Let's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 dividend == INT_MIN 且 divisor == -1? // 檢查乘法溢位情況  \n Yes → End // 直接回傳 INT_MAX，避免溢位  \n No  // 繼續往下  \n→ Step 2: negative = (dividend < 0) XOR (divisor < 0) // 判斷結果的正負號  \n→ Step 3: dvd = abs(dividend) as long // 取得 dividend 的絕對值並轉為 64‑bit 以免溢位  \n→ Step 4: dvs = abs(divisor) as long // 取得 divisor 的絕對值並轉為 64‑bit  \n→ Step 5: quotient = 0 // 初始化商為 0  \n→ Decision: 如果 dvd < dvs? // 若 dividend 小於 divisor，商為 0  \n Yes → End // 直接結束並回傳 0  \n No  // 進行位移減法  \n→ Step 6: for shift from 31 downto 0 // 從最高位開始逐位尋找可減去的位移  \n → Decision: 如果 (dvs << shift) <= dvd? // 判斷是否能用此位移的 divisor 減去 dividend  \n  Yes → Step 7: dvd = dvd - (dvs << shift) // 從 dividend 減去對應位移的 divisor  \n  Yes → Step 8: quotient = quotient + (1 << shift) // 把對應位移的位加到商  \n  No  // 若不符合則跳過此位移  \n→ Step 9: if negative then quotient = -quotient // 重新套用符號  \n→ Step 10: if quotient > INT_MAX then return INT_MAX // 上限裁剪  \n → Decision: 否則?  \n  Yes → Step 11: if quotient < INT_MIN then return INT_MIN // 下限裁剪  \n    Yes → Step 12: else return quotient // 正常返回  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nINT_MAX = 2 ** 31 - 1\nINT_MIN = -2 ** 31\n\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        # 防止 INT_MAX 的溢位情況\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n\n        negative = (dividend < 0) ^ (divisor < 0)  # 判斷結果的符號\n\n        # 取絕對值，使用長整型以避免溢位\n        dvd = abs(dividend)\n        dvs = abs(divisor)\n\n        quotient = 0\n        # 逐位查找可減去的最大倍數\n        while dvd >= dvs:\n            temp = dvs\n            multiple = 1\n            # 雙倍直到超過 dvd\n            while dvd >= (temp << 1):\n                temp <<= 1\n                multiple <<= 1\n            dvd -= temp\n            quotient += multiple\n\n        if negative:\n            quotient = -quotient\n\n        # 32-bit 限制裁剪\n        if quotient > INT_MAX:\n            return INT_MAX\n        if quotient < INT_MIN:\n            return INT_MIN\n        return quotient\n\n\ndef main():\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if len(nums) < 2:\n        return\n    dividend = int(nums[0])\n    divisor = int(nums[1])\n    solution = Solution()\n    result = solution.divide(dividend, divisor)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "dividend = 10, divisor = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "dividend = 7, divisor = -3",
          "expected_output": "-2",
          "success": true,
          "output": "-2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode290.json",
    "problem_index_in_file": 0,
    "title": "Word Pattern",
    "description_snippet": "Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match,...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode for checking word pattern mapping. Provide each line with \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows. Provide Start, End, Decision, Step, etc. Should be in Traditional Chinese. Use virtual code arrow like \"→\". Must not output actual code. So produce lines like:\n\nStart // 程式開始執行\n→ Step 1: Split s into words list // 以空格拆分字串成單詞陣列\n→ Step 2: If pattern length != words length? // 檢查 pattern 與 words 數量是否一致\n    Yes → Step 3: Return false // 不一致，直接失敗\n    No  → Step 4: Initialize empty map letterToWord // 建立字母→單詞映射\n→ Step 5: Initialize empty set usedWords // 追蹤已使用的單詞\n→ Decision: For each index i in 0..pattern.length-1? // 逐個處理\n    Yes → Step 6: currentLetter ← pattern[i] // 取對應字母\n    → Step 7: currentWord ← words[i] // 取對應單詞\n    → Decision: 是否已存在映射? // 判斷字母是否已映射\n        Yes → Step 8: 如果 letterToWord[currentLetter] != currentWord? // 檢查映射是否一致\n            Yes → Step 9: Return false // 不一致直接失敗\n            No  → Step 10: Continue // 正常繼續\n        No  → Decision: currentWord 是否已被使用? // 確認單詞未被重複\n            Yes → Step 11: Return false // 已被使用，失敗\n            No  → Step 12: letterToWord[currentLetter] ← currentWord // 建立映射\n            → Step 13: usedWords.add(currentWord) // 標記單詞已使用\n→ End // 全部檢查完畢\n→ Step 14: Return true // 若無錯誤則符合模式\n\nBut must adhere to format: each line with virtual code step and comment. Use \"→\" for steps, \"Decision:\" for condition. Need to indent branches? The example uses indentation. Use spaces for indentation. Provide arrow before each step. Should be fine.\n\nWe also need to produce Start, End. Provide at least all steps. Use \"→\" and \"Decision:\" accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Split s by spaces into words list // 以空格拆分字串成單詞陣列  \n→ Step 2: If pattern length ≠ words length? // 檢查 pattern 與 words 數量是否一致  \n    Yes → Step 3: Return false // 不一致，直接失敗  \n    No  → Step 4: Initialize empty map letterToWord // 建立字母→單詞映射  \n→ Step 5: Initialize empty set usedWords // 追蹤已使用的單詞  \n→ Decision: For each index i from 0 to pattern.length-1? // 逐個處理每個位置  \n    Yes → Step 6: currentLetter ← pattern[i] // 取對應字母  \n    → Step 7: currentWord ← words[i] // 取對應單詞  \n    → Decision: Is currentLetter already in letterToWord? // 判斷字母是否已映射  \n        Yes → Step 8: If letterToWord[currentLetter] ≠ currentWord? // 檢查映射是否一致  \n            Yes → Step 9: Return false // 不一致直接失敗  \n            No  → Step 10: Continue // 正常繼續  \n        No  → Decision: Is currentWord already in usedWords? // 確認單詞未被重複  \n            Yes → Step 11: Return false // 已被使用，失敗  \n            No  → Step 12: letterToWord[currentLetter] ← currentWord // 建立映射  \n            → Step 13: usedWords.add(currentWord) // 標記單詞已使用  \n→ End // 全部檢查完畢  \n→ Step 14: Return true // 若無錯誤則符合模式",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        \"\"\"\n        檢查字串 s 是否符合 pattern 的映射規則\n        \"\"\"\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n\n        char_to_word = {}\n        word_to_char = {}\n\n        for c, w in zip(pattern, words):\n            # 字母已映射，檢查是否一致\n            if c in char_to_word:\n                if char_to_word[c] != w:\n                    return False\n            else:\n                char_to_word[c] = w\n\n            # 單詞已映射，檢查是否一致\n            if w in word_to_char:\n                if word_to_char[w] != c:\n                    return False\n            else:\n                word_to_char[w] = c\n\n        return True\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入文字中提取 pattern 與 s\n    支援兩種常見格式：\n    1. pattern = \"abba\", s = \"dog cat cat dog\"\n    2. pattern = \"abba\"\n       s = \"dog cat cat dog\"\n    \"\"\"\n    pattern_match = re.search(r'pattern\\s*=\\s*\"([^\"]+)\"', text)\n    s_match = re.search(r's\\s*=\\s*\"([^\"]+)\"', text)\n    if pattern_match and s_match:\n        return pattern_match.group(1), s_match.group(1)\n    # 若找不到，嘗試按行拆分\n    lines = [line.strip() for line in text.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        # 假設第一行是 pattern，第二行是 s\n        pattern = lines[0].split('=', 1)[1].strip().strip('\"')\n        s = lines[1].split('=', 1)[1].strip().strip('\"')\n        return pattern, s\n    raise ValueError(\"無法解析輸入格式\")\n\ndef main():\n    data = sys.stdin.read()\n    try:\n        pattern, s = parse_input(data)\n    except Exception as e:\n        print(\"false\")\n        return\n\n    sol = Solution()\n    result = sol.wordPattern(pattern, s)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "pattern = \"abba\", s = \"dog cat cat fish\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "pattern = \"aaaa\", s = \"dog cat cat dog\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode581.json",
    "problem_index_in_file": 0,
    "title": "Shortest Unsorted Continuous Subarray",
    "description_snippet": "Given an integer array nums, you need to find one continuous subarray such that if you only sort thi...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: find minimal subarray that if sorted will make whole array sorted. Known Leetcode problem 581. Approach: find left boundary where array deviates from sorted ascending, and right boundary. Steps: find max so far from left, min from right, then adjust boundaries. Outline.\n\nWe'll produce step by step. Need to produce lines with arrows. Each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc. We'll include loops, decisions.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 設定 n 為 nums 長度 // 取得陣列長度\n→ Step 2: 初始化 left = n, right = -1 // 先假設子陣列不存在\n→ Step 3: 初始化 cur_max = nums[0] // 追蹤左至右最大值\n→ Decision: for i from 1 to n-1 // 遍歷陣列\n    -> Yes → If nums[i] < cur_max // 發現不升序\n        -> Step 4: right = i // 更新右邊界\n    -> No  → Step 5: cur_max = max(cur_max, nums[i]) // 更新最大值\n→ Step 6: 初始化 cur_min = nums[n-1] // 追蹤右至左最小值\n→ Decision: for i from n-2 down to 0 // 從右到左遍歷\n    -> Yes → If nums[i] > cur_min // 發現不升序\n        -> Step 7: left = i // 更新左邊界\n    -> No  → Step 8: cur_min = min(cur_min, nums[i]) // 更新最小值\n→ Decision: 如果 left <= right // 判斷是否存在需要排序的子陣列\n    Yes → Step 9: 返回 right - left + 1 // 子陣列長度\n    No  → Step 10: 返回 0 // 整個陣列已排序\nEnd // 程式結束\n\nBut we need to show arrows like \"→ Decision:\" lines. We also need to keep each line as \"虛擬碼步驟 // 解釋\".\n\nLet's craft with proper formatting. Include arrows for nested steps.\n\nWe'll produce lines with indent maybe. But we can keep them simple.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n 為 nums 的長度 // 取得陣列長度  \n→ Step 2: 初始化 left 為 n，right 為 -1 // 預設子陣列不存在  \n→ Step 3: 初始化 cur_max 為 nums[0] // 追蹤從左至右的最大值  \n\n→ Decision: 從 i = 1 到 n-1 逐個遍歷 // 遍歷整個陣列  \n  Yes → Decision: 如果 nums[i] < cur_max? // 發現左側不升序  \n    Yes → Step 4: 設定 right 為 i // 更新右邊界  \n    No → Step 5: 更新 cur_max 為 max(cur_max, nums[i]) // 更新最大值  \n\n→ Step 6: 初始化 cur_min 為 nums[n-1] // 追蹤從右至左的最小值  \n\n→ Decision: 從 i = n-2 到 0 逐個遍歷 // 從右到左遍歷  \n  Yes → Decision: 如果 nums[i] > cur_min? // 發現右側不升序  \n    Yes → Step 7: 設定 left 為 i // 更新左邊界  \n    No → Step 8: 更新 cur_min 為 min(cur_min, nums[i]) // 更新最小值  \n\n→ Decision: 如果 left <= right? // 判斷是否需要排序子陣列  \n  Yes → Step 9: 返回 right - left + 1 // 子陣列長度  \n  No  → Step 10: 返回 0 // 整個陣列已經有序  \n\nEnd // 程式結束執行",
      "generated_code": "import sys\n\ndef findUnsortedSubarray(nums):\n    n = len(nums)\n    # If the array is already sorted, return 0 immediately\n    if n <= 1:\n        return 0\n\n    # Find the right boundary\n    cur_max = nums[0]\n    right = -1\n    for i in range(1, n):\n        if nums[i] < cur_max:\n            right = i\n        else:\n            cur_max = nums[i]\n\n    # Find the left boundary\n    cur_min = nums[-1]\n    left = n\n    for i in range(n - 2, -1, -1):\n        if nums[i] > cur_min:\n            left = i\n        else:\n            cur_min = nums[i]\n\n    # If no such subarray exists, return 0\n    if left <= right:\n        return right - left + 1\n    return 0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list part from the input, e.g. \"nums = [2,6,4]\" -> \"[2,6,4]\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        # If brackets are not found, treat the whole input as a Python list literal\n        nums = eval(data)\n    else:\n        nums = eval(data[start:end + 1])\n\n    result = findUnsortedSubarray(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,6,4,8,10,9,15]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode400.json",
    "problem_index_in_file": 0,
    "title": "Nth Digit",
    "description_snippet": "Given an integer n, return the n^th digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanation. Input: integer n. Return nth digit in concatenated sequence of natural numbers. So we need algorithm: accumulate digits lengths, find which number contains nth digit, then extract digit. Steps:\n\nStart, Input n, set length=1, start=1, count=9? Actually numbers of length 1: 1-9 (9 numbers). So we can iterate: while n > length*count: n -= length*count; length++ ; start*=10 ; count=9*start? Actually number of numbers of length len: 9*10^(len-1). But start for len=1 is 1, count=9. For len=2 start=10, count=90. etc. Use variable end = start+count-1. Then after loop, find number = start + (n-1)/length. digitIndex = (n-1)%length. Convert number to string, get char. Return char.\n\nSo virtual code lines: Start, Input n, set length=1, start=1, count=9, etc. While n > length*count, subtract, increment length, start*=10, count=9*start? Actually count = 9*start, because start is 10^(len-1). For len=1 start=1 count=9. After length++ start*=10 count=9*start. Then after loop, compute number, digitIndex, result.\n\nImplement steps accordingly.\n\nNeed to ensure use of virtual code structure: Start, Step, Decision, etc.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入整數 n // 取得要查找的第 n 位數字\n→ Step 2: 設定 length = 1 // 當前數字位數\n→ Step 3: 設定 start = 1 // 本位數範圍的最小數值\n→ Step 4: 設定 count = 9 // 本位數範圍內的數字個數\n→ Decision: 是否 n > length * count? // 判斷 n 是否超出目前位數範圍\n    Yes → Step 5: n = n - length * count // 將已經排除的位數扣除\n    Yes → Step 6: length = length + 1 // 進入下一位數\n    Yes → Step 7: start = start * 10 // 調整本位數範圍最小值\n    Yes → Step 8: count = 9 * start // 計算新位數範圍的數字個數\n    Yes → Decision: 是否 n > length * count? // 重複判斷直到 n 在範圍內\n        ... (loop continues)\n    No → // n 已經落在目前位數範圍內，繼續下一步\n→ Step 9: number = start + (n - 1) / length // 找到包含第 n 位的數字\n→ Step 10: digitIndex = (n - 1) % length // 第 n 位在該數字中的索引\n→ Step 11: result = 字符串化(number)[digitIndex] // 取得對應的數字字符\n→ Step 12: 輸出 result // 顯示結果\nEnd // 程式結束\n\nWe need to maintain virtual code style: Indentation maybe using 4 spaces. Use 'Decision:' lines, 'Yes →', 'No →'. Provide explanation after //.\n\nAlso, for loop we can express as a Decision with Yes branch having steps 5-8 and then Decision again. But we can show as iterative structure but not actual loop code. We'll just outline the repeated Decision. It's okay.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取輸入整數 n // 取得要查找的第 n 位數字\n→ Step 2: 設定 length = 1 // 當前數字位數\n→ Step 3: 設定 start = 1 // 本位數範圍的最小數值\n→ Step 4: 設定 count = 9 // 本位數範圍內的數字個數\n→ Decision: n > length * count? // 判斷 n 是否超出目前位數範圍\n    Yes → Step 5: n = n - length * count // 把已排除的位數扣除\n    Yes → Step 6: length = length + 1 // 進入下一位數\n    Yes → Step 7: start = start * 10 // 調整本位數範圍最小值\n    Yes → Step 8: count = 9 * start // 計算新位數範圍的數字個數\n    Yes → Decision: n > length * count? // 重複判斷直到 n 在範圍內\n        … (若仍是 Yes，重複步驟 5‑8)\n    No  → // n 已落在目前位數範圍內，跳出判斷\n→ Step 9: number = start + (n - 1) / length // 找到包含第 n 位的數字\n→ Step 10: digitIndex = (n - 1) % length // 第 n 位在該數字中的索引\n→ Step 11: result = 字符串化(number)[digitIndex] // 取得對應的數字字符\n→ Step 12: 輸出 result // 顯示結果\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\ndef find_nth_digit(n: int) -> int:\n    \"\"\"\n    找到連續自然數序列（1,2,3,4,5,6,7,8,9,10,11,…）中的第 n 個數字。\n    \"\"\"\n    length = 1          # 當前數字的位數\n    count = 9           # 本位數範圍內的數字個數（1~9, 10~99, 100~999...）\n    start = 1           # 本位數範圍的最小數值\n\n    # 將 n 從總序列中扣除已經排除的位數，直到 n 落在目前位數範圍內\n    while n > length * count:\n        n -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # 找到真正包含第 n 位的數字\n    start += (n - 1) // length\n    s = str(start)\n    # 取出第 n 位對應的字符，轉成整數回傳\n    return int(s[(n - 1) % length])\n\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，提取第一個整數 n，計算並輸出第 n 個數字。\n    \"\"\"\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = find_nth_digit(n)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 11",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode769.json",
    "problem_index_in_file": 0,
    "title": "Max Chunks To Make Sorted",
    "description_snippet": "You are given an integer array arr of length n that represents a permutation of the integers in the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solution. The problem: \"Max Chunks To Make Sorted II\" variant? Actually given permutation of 0..n-1, largest number of chunks to sort array to be sorted. For permutation, largest chunks equals number of positions where max prefix equals current index? Wait sorted array is 0..n-1 ascending. For permutation, we can partition at positions where max of prefix equals current index. Since values are unique 0..n-1. That's the algorithm: iterate array, keep track of max so far. When max_so_far == current_index, increment chunks. Complexity O(n). We'll produce virtual code accordingly. Provide line by line with explanation.\n\nNeed to use Start, End, Decision, etc.\n\nWe'll need steps: Start, initialize chunks=0, max_so_far=-1, iterate i from 0 to n-1: update max_so_far = max(max_so_far, arr[i]), decision if max_so_far == i, if yes increment chunks. After loop, return chunks. End.\n\nWe'll produce each line with explanation.\n\nBe careful to maintain proper indentation of Decision lines: use 4 spaces? The sample uses indentation for nested. We'll produce like:\n\nStart // start\n→ Step 1: Initialize variables // etc\n→ Loop: For i from 0 to n-1 // loop\n\nWe might need to express loop in virtual code style. Use \"For each i in 0..n-1:\"?\n\nThe sample uses arrows for steps. We'll mimic: \"→ Step 2: For i = 0 to n-1 // iterate through array\". Inside loop we need decision.\n\nWe can break inside loop: \"→ Decision: If arr[i] > max_so_far?\" but we just set max. Actually we need update. We can just set max_so_far = max(max_so_far, arr[i]). But we might express as step.\n\nLet's design:\n\nStart\n→ Step 1: Set chunks = 0 // count of chunks\n→ Step 2: Set max_so_far = -1 // maximum value seen so far\n→ For i from 0 to n-1 // iterate array\n    → Step 3: Update max_so_far = max(max_so_far, arr[i]) // track maximum\n    → Decision: If max_so_far == i? // prefix max equals current index\n        Yes → Step 4: Increment chunks // we can close a chunk\n        No → // nothing\n→ Step 5: Return chunks // result\nEnd\n\nBut we need to show loop structure. We might show:\n\n→ Step 3: For i = 0 to n-1:\n    ... but in sample they didn't show loop. They used steps and decisions, but not explicit loops. But we can still use.\n\nLet's design more lines:\n\nStart // 程式開始執行\n→ Step 1: chunks ← 0 // 初始化區塊計數\n→ Step 2: max_so_far ← -1 // 目前已見最大值\n→ For i ← 0 to n-1 // 遍歷陣列\n    → Step 3: max_so_far ← max(max_so_far, arr[i]) // 更新前綴最大值\n    → Decision: max_so_far == i? // 前綴最大值是否等於索引\n        Yes → Step 4: chunks ← chunks + 1 // 形成一個可排序區塊\n        No → // 不產生區塊\n→ Step 5: Return chunks // 回傳最大的區塊數\nEnd // 程式執行結束\n\nBut need to ensure each line ends with explanation comment. Also each line with arrow symbol? The sample uses \"→ Step 1: ...\" etc. For nested lines, they use indentation. We'll follow that.\n\nWe need to produce line by line.\n\nAlso, they asked \"逐行地產生對應的虛擬碼\". So we produce all lines.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: chunks ← 0 // 初始化區塊計數器  \n→ Step 2: max_so_far ← -1 // 記錄目前已見的最大值  \n→ For i ← 0 to n-1 // 從陣列第一個元素開始遍歷  \n  → Step 3: max_so_far ← max(max_so_far, arr[i]) // 更新前綴最大值  \n  → Decision: max_so_far == i? // 若前綴最大值等於當前索引  \n   Yes → Step 4: chunks ← chunks + 1 // 可以形成一個獨立可排序區塊  \n   No → // 仍在同一區塊內，無需操作  \n→ Step 5: Return chunks // 回傳能得到完整排序的最大區塊數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_chunks_to_sorted(arr):\n    \"\"\"\n    依照前綴最大值與索引相等的條件計算最大的可分區塊數。\n    \"\"\"\n    chunks = 0\n    max_so_far = -1\n    for i, val in enumerate(arr):\n        if val > max_so_far:\n            max_so_far = val\n        if max_so_far == i:\n            chunks += 1\n    return chunks\n\ndef main():\n    # 從標準輸入讀取整行文字\n    data = sys.stdin.read().strip()\n    # 若輸入形如 \"arr = [1,2,3]\"，移除前綴\n    if data.startswith(\"arr\"):\n        data = data.split(\"=\", 1)[1].strip()\n    # 解析為列表\n    arr = ast.literal_eval(data)\n    # 計算答案\n    result = max_chunks_to_sorted(arr)\n    # 將結果輸出到標準輸出\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [4,3,2,1,0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "arr = [1,0,2,3,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode504.json",
    "problem_index_in_file": 0,
    "title": "Base 7",
    "description_snippet": "Given an integer num, return a string of its base 7 representation....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for converting an integer to base-7 string. Must use virtual code syntax with arrow. Each line with explanation. Provide steps: handle negative, convert abs, repeated division by 7, build string, reverse, prepend sign if negative. Include decision for zero. Must follow format.\n\nLet's craft:\n\nStart\n→ Step 1: Input integer num\n→ Decision: If num == 0?\n   Yes → Step 2: Result = \"0\"\n   No  → Decision: If num < 0?\n          Yes → Step 3: isNegative = True; num = -num\n          No  → Step 3: isNegative = False\n→ Step 4: resultDigits = empty list\n→ Loop: While num > 0:\n       remainder = num % 7\n       resultDigits.append(remainder)\n       num = num // 7\n→ Step 5: resultString = concatenate digits in reverse order of resultDigits\n→ Decision: If isNegative? \n       Yes → Step 6: resultString = \"-\" + resultString\n→ End // return resultString\n\nAdd explanation comments. Use \"Start\", \"End\", \"Decision:\" with Yes/No arrow. Provide each step as line with explanation. Use \"→\" arrow. For loop: use \"→ Loop:\" maybe. We'll keep \"→ Loop:\" for each iteration? The example didn't show loop but we can use \"→ Loop: while num > 0:\". Provide explanation. Use \"Step\". Provide all.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 num // 取得需要轉換的數字  \n→ Decision: num 等於 0? // 檢查是否為零  \n    Yes → Step 2: 結果 = \"0\" // 零的基 7 表示就是 \"0\"  \n    No  → Decision: num 小於 0? // 若不是零，判斷是否為負數  \n        Yes → Step 3: isNegative = True; num = -num // 記錄符號，取正值  \n        No  → Step 3: isNegative = False // 正數，符號為正  \n→ Step 4: resultDigits = 空清單 // 用於儲存餘數  \n→ Loop: 當 num > 0 時  \n    → Step 5: remainder = num % 7 // 取得目前位的餘數  \n    → Step 6: resultDigits.append(remainder) // 加入清單  \n    → Step 7: num = num // 7 // 更新 num 為整除結果  \n→ Step 8: resultString = 連接 resultDigits 逆序為字串 // 將餘數倒轉為正確順序  \n→ Decision: isNegative? // 判斷是否需要加上負號  \n    Yes → Step 9: resultString = \"-\" + resultString // 加上負號  \n→ End // 程式執行結束，回傳 resultString\n\n(Note: 在實際實作中，Loop 步驟會重複執行直到 num 為 0，並在結束後繼續執行後續步驟。)",
      "generated_code": "import sys\n\nclass Solution:\n    def convertToBase7(self, num: int) -> str:\n        \"\"\"\n        Convert an integer to its base‑7 string representation.\n        \"\"\"\n        if num == 0:\n            return \"0\"\n        neg = num < 0\n        num = abs(num)\n        digits = []\n        while num > 0:\n            digits.append(str(num % 7))\n            num //= 7\n        if neg:\n            digits.append('-')\n        return ''.join(reversed(digits))\n\ndef main() -> None:\n    \"\"\"\n    Read an integer from standard input, convert it to base 7,\n    and print the result surrounded by double quotes.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    num = int(data)\n    solution = Solution()\n    result = solution.convertToBase7(num)\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "100",
          "expected_output": "\"202\"",
          "success": true,
          "output": "\"202\""
        },
        {
          "example_index": 1,
          "input": "-7",
          "expected_output": "\"-10\"",
          "success": true,
          "output": "\"-10\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode460.json",
    "problem_index_in_file": 0,
    "title": "LFU Cache",
    "description_snippet": "Design and implement a data structure for a Least Frequently Used (LFU) cache.\n\nImplement the LFUCac...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code with line-by-line steps and explanation. Must use virtual code syntax with arrow, Decision, etc. We need to design algorithm for LFU cache O(1). Usually using hash maps + doubly linked list per frequency + minFreq variable. Steps: initialize capacity, map key->node (contains key, value, freq). freq map: freq->DLL of nodes. minFreq. get: if key not exist return -1 else increase freq: remove node from old freq list, add to freq+1 list, update minFreq if needed. put: if capacity 0 return. if key exists: update value, then get to update freq. else if capacity full: evict minFreq list's tail (least recently used). then insert new node with freq=1, add to freq list, set minFreq=1.\n\nNeed to output virtual code line by line. Let's create a structured approach: Start, then initialization, then get and put methods. Use Decision blocks for capacity 0, key exists, etc. Must be O(1). Provide explanation per line.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 LFUCache // 建立類別\n→ Step 2: 內部變數 capacity, minFreq, keyMap, freqMap // 需要的資料結構\n\nBut we need to show method definitions: LFUCache(capacity), get(key), put(key, value).\n\nWe need to structure decisions and loops. The algorithm uses data structures but we can treat them as black boxes.\n\nWe'll produce a flow for get:\n\nStart get(key)\n→ Decision: key 是否在 keyMap? // 檢查 key 是否存在\n    Yes → Step 3: node = keyMap[key] // 取得節點\n    Yes → Step 4: freq = node.freq\n    Yes → Step 5: 移除 node 從 freqMap[freq] 列表 // O(1)\n    Yes → Step 6: node.freq++ // 更新頻率\n    Yes → Step 7: 新增 node 到 freqMap[node.freq] 列表 // O(1)\n    Yes → Decision: freq == minFreq 且 freqMap[freq] 為空? // 若舊頻率無節點\n        Yes → Step 8: minFreq++ // 更新最小頻率\n    Yes → Step 9: 回傳 node.value\n    No  → Step 10: 回傳 -1 // 不存在\n\nSimilarly for put.\n\nNeed to incorporate eviction logic: If capacity reached, evict minFreq list's LRU tail.\n\nWe'll produce:\n\nStart put(key, value)\n→ Decision: capacity == 0? // 若容量為0直接返回\n    Yes → Step 11: 返回\n→ Decision: key 是否存在 keyMap? // 已存在更新\n    Yes → Step 12: keyMap[key].value = value // 更新值\n    Yes → Step 13: 呼叫 get(key) // 更新頻率\n    No  → Decision: keyMap.size() == capacity? // 是否已滿\n        Yes → Step 14: evictKey = freqMap[minFreq].tail.key // LRU key\n        Yes → Step 15: 移除 evictKey 從 keyMap\n        Yes → Step 16: 移除 evictKey 從 freqMap[minFreq] 列表\n        No  → (none)\n    No  → Step 17: 建立新節點 node(key, value, freq=1)\n    No  → Step 18: 插入 node 到 keyMap\n    No  → Step 19: 插入 node 到 freqMap[1]\n    No  → Step 20: minFreq = 1 // 新元素的頻率\nEnd\n\nNeed to include proper arrow and indentation.\n\nWe should keep to virtual code format: \"Start // 程式開始執行\". Then \"→ Step 1: ... // ...\" etc. Use \"Decision:\" for decisions.\n\nMake sure each line ends with comment. Use correct arrow and indent. Let's produce.\n\nAlso we can include initialization of data structures inside constructor.\n\nWe'll produce final answer.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義類別 LFUCache // 建立 LFUCache 類別\n→ Step 2: 內部變數 capacity, minFreq, keyMap, freqMap // 用於儲存容量、最小頻率、鍵對節點、頻率對節點列表\n→ Step 3: 內部類別 Node { key, value, freq, prev, next } // 節點結構（雙向鏈表節點）\n\n→ Step 4: LFUCache(capacity) // 建構子\n    → Step 5: this.capacity = capacity\n    → Step 6: this.minFreq = 0\n    → Step 7: keyMap = 空 HashMap // key → Node\n    → Step 8: freqMap = 空 HashMap // freq → DLL  (雙向鏈表)\nEnd // 建構子結束\n\n→ Step 9: int get(key) // 取得鍵值\n    → Decision: key 是否在 keyMap? // 檢查鍵是否存在\n        Yes → Step 10: node = keyMap[key] // 取得節點\n        Yes → Step 11: freq = node.freq // 取得舊頻率\n        Yes → Step 12: 移除 node 從 freqMap[freq] 的 DLL // O(1) 刪除\n        Yes → Step 13: node.freq = freq + 1 // 更新頻率\n        Yes → Step 14: 若 freqMap[node.freq] 不存在則建立新 DLL\n        Yes → Step 15: 新增 node 到 freqMap[node.freq] 的 DLL // O(1) 插入\n        Yes → Decision: freq == minFreq 且 freqMap[freq] 為空? // 判斷舊頻率是否被清空\n            Yes → Step 16: minFreq = minFreq + 1 // 更新最小頻率\n        Yes → Step 17: 回傳 node.value // 返回值\n        No  → Step 18: 回傳 -1 // 鍵不存在\nEnd // get 方法結束\n\n→ Step 19: void put(key, value) // 插入或更新鍵值\n    → Decision: capacity == 0? // 若容量為0直接返回\n        Yes → Step 20: 返回\n    → Decision: key 是否在 keyMap? // 已存在則更新\n        Yes → Step 21: keyMap[key].value = value // 更新值\n        Yes → Step 22: 呼叫 get(key) // 透過 get 更新頻率\n        No  → Decision: keyMap.size() == capacity? // 判斷是否已滿\n            Yes → Step 23: evictKey = freqMap[minFreq].tail.key // 取 LRU 的鍵\n            Yes → Step 24: 移除 evictKey 從 keyMap\n            Yes → Step 25: 移除 evictKey 從 freqMap[minFreq] 的 DLL\n            No  → (不做任何事) // 沒有滿容量\n        No  → Step 26: 建立新節點 node(key, value, freq=1)\n        No  → Step 27: keyMap[key] = node // 插入映射\n        No  → Step 28: 若 freqMap[1] 不存在則建立新 DLL\n        No  → Step 29: 新增 node 到 freqMap[1] 的 DLL // 插入新節點\n        No  → Step 30: minFreq = 1 // 新元素的頻率為 1\nEnd // put 方法結束\n```",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    \"\"\"Least Frequently Used (LFU) cache with O(1) get/put.\"\"\"\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}                      # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)   # freq -> keys in LRU order\n\n    def _update(self, key: int) -> None:\n        \"\"\"Increase frequency of a key after access.\"\"\"\n        value, freq = self.key_to_val_freq[key]\n        # Remove from current frequency list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Insert into higher frequency list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        \"\"\"Return value of key if present, else -1.\"\"\"\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        \"\"\"Insert or update key-value pair.\"\"\"\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used key (LRU within that freq)\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\ndef parse_input(data: str):\n    \"\"\"Parse input string into ops list and args list.\"\"\"\n    # Find two top-level lists\n    lists = []\n    depth = 0\n    start = 0\n    for i, ch in enumerate(data):\n        if ch == '[':\n            if depth == 0:\n                start = i\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n            if depth == 0:\n                lists.append(data[start:i+1])\n    if len(lists) != 2:\n        raise ValueError(\"Input format error\")\n    ops = ast.literal_eval(lists[0])\n    args = ast.literal_eval(lists[1])\n    return ops, args\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n    ops, args = parse_input(raw)\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            obj = LFUCache(arg[0])\n            res.append(None)\n        elif op == \"get\":\n            res.append(obj.get(arg[0]))\n        elif op == \"put\":\n            obj.put(arg[0], arg[1])\n            res.append(None)\n        else:\n            raise ValueError(f\"Unknown operation: {op}\")\n    print(res)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,3,null,-1,3,4]'\nGot (Norm):      '[None,None,None,1,None,-1,3,None,-1,3,4]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, 3, null, -1, 3, 4]'\nRaw Got:      '[None, None, None, 1, None, -1, 3, None, -1, 3, 4]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode241.json",
    "problem_index_in_file": 0,
    "title": "Different Ways to Add Parentheses",
    "description_snippet": "Given a string expression of numbers and operators, return all possible results from computing all t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the described problem: given a string of numbers and operators, return all possible results from computing all possible ways to group numbers and operators. It's essentially \"Different Ways to Add Parentheses\" LeetCode 241. We'll generate virtual steps.\n\nWe need to output line by line with arrow etc. Should be pseudo-code.\n\nWe need to include Start, End, Decision, Steps. Use recursion / divide and conquer.\n\nLet's design:\n\nStart\n→ Step 1: 定義函式 diffWays(expression) // 對輸入字串計算所有可能結果\n→ Decision: expression 是否只有數字？ // 判斷是否沒有運算符\n    Yes → Step 2: 轉換為整數並回傳單一結果 // 若無運算符，直接返回數值\n    No  → Step 3: 建立空列表 results // 用於存放子問題結果\n→ Step 4: 循環遍歷 expression 中每個字元\n    → Decision: 字元是否為運算符 (+ - *)？\n        Yes → Step 5: 將 expression 分成 left & right 子字串 // 在此運算符位置切分\n        → Step 6: 取得 leftResults = diffWays(left) // 計算左子問題\n        → Step 7: 取得 rightResults = diffWays(right) // 計算右子問題\n        → Step 8: 對於每個 l in leftResults\n            → Step 9: 對於每個 r in rightResults\n                → Step 10: 計算 l op r 並加入 results // 將計算結果存入\n        → No  → Continue // 若非運算符，跳過\n→ Step 11: 回傳 results // 完成\nEnd\n\nWe need to maintain arrow formatting: \"→ Step X: ...\".\n\nWe must include indentation? In example, they used indentation but not necessary.\n\nBetter to add sub steps with indentation as shown.\n\nWe'll produce.\n\nLet's produce the lines.\n\nWe must not output actual code.\n\nEnsure each line ends with comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 diffWays(expression) // 對輸入字串計算所有可能結果  \n→ Decision: expression 是否只有數字？ // 判斷是否沒有運算符  \n  Yes → Step 2: 轉換為整數並回傳單一結果 // 若無運算符，直接返回數值  \n  No  → Step 3: 建立空列表 results // 用於存放子問題結果  \n→ Step 4: 循環遍歷 expression 中每個字元  \n  Decision: 字元是否為運算符 (+ - *)？  \n   Yes → Step 5: 將 expression 分成 left & right 子字串 // 在此運算符位置切分  \n    Step 6: 取得 leftResults = diffWays(left) // 計算左子問題  \n    Step 7: 取得 rightResults = diffWays(right) // 計算右子問題  \n    Step 8: 對於每個 l in leftResults  \n     Step 9: 對於每個 r in rightResults  \n      Step 10: 計算 l op r 並加入 results // 將計算結果存入  \n     No  → Continue // 若非運算符，跳過  \n→ Step 11: 回傳 results // 完成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef diffWaysToCompute(expression: str):\n    \"\"\"回傳所有可能的計算結果，使用 memoization 以避免重複計算。\"\"\"\n    memo = {}\n\n    def ways(expr: str):\n        if expr in memo:\n            return memo[expr]\n\n        results = []\n        for idx, ch in enumerate(expr):\n            if ch in '+-*':\n                left = ways(expr[:idx])\n                right = ways(expr[idx + 1:])\n                for l in left:\n                    for r in right:\n                        if ch == '+':\n                            results.append(l + r)\n                        elif ch == '-':\n                            results.append(l - r)\n                        else:  # ch == '*'\n                            results.append(l * r)\n\n        # 若沒有運算符，expr 本身就是數字\n        if not results:\n            results.append(int(expr))\n\n        memo[expr] = results\n        return results\n\n    return ways(expression)\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 從輸入中提取第一個雙引號包圍的字串作為表達式\n    match = re.search(r'\"([^\"]*)\"', data)\n    expression = match.group(1) if match else data\n\n    results = diffWaysToCompute(expression)\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[2,0]",
          "success": true,
          "output": "[2, 0]"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-10,-14,-10,10]",
          "success": true,
          "output": "[-34, -10, -14, -10, 10]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode260.json",
    "problem_index_in_file": 0,
    "title": "Single Number III",
    "description_snippet": "Given an integer array nums, in which exactly two elements appear only once and all the other elemen...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. This is a known problem: Two numbers appearing once in array with others twice. Use XOR of all to get xor = a ^ b. Then find rightmost set bit. Partition array into two groups by that bit, XOR separately. Complexity O(n) time, O(1) space.\n\nWe need to produce virtual code with lines:\n\nStart\n→ Step: XOR all elements to get xorAll\n→ Step: Find rightmost set bit mask = xorAll & -xorAll\n→ Step: Initialize num1=0, num2=0\n→ Step: Iterate over array, if (num & mask) != 0 then XOR to num1 else XOR to num2\n→ Step: Output num1, num2\nEnd\n\nWe must also add decisions? Not necessary but can add Decision if want. Provide simple linear. We can add a decision to skip array empty etc but not required.\n\nAdd comments.\n\nMake sure each line follows format: \"虛擬碼步驟 // 解釋\"\n\nInclude arrow or start. Use Start/End.\n\nWe need Chinese explanation. Provide short intuitive explanation in Chinese.\n\nLet's produce lines accordingly. Use Chinese names like `計算 xorAll` etc.\n\nWill include arrows.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: xorAll ← 0 // 初始化 XOR 結果為 0  \n→ Step: 對每個 num 在 nums 中執行 xorAll ← xorAll XOR num // 將所有元素 XOR，得到 a XOR b  \n→ Step: mask ← xorAll AND (-xorAll) // 取 a XOR b 的最低有效位（兩數不同的位置）作為分組標誌  \n→ Step: num1 ← 0, num2 ← 0 // 初始化兩個獨特數的累積結果  \n→ Step: 對每個 num 在 nums 中執行  \n  Decision: 若 (num AND mask) ≠ 0? // 判斷 num 在 mask 位上是 0 還是 1  \n   Yes → num1 ← num1 XOR num // 若為 1，將 num 加入 num1  \n   No  → num2 ← num2 XOR num // 若為 0，將 num 加入 num2  \n→ Step: 輸出 (num1, num2) // 兩個只出現一次的數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNumber(self, nums):\n        # XOR all numbers to get xor = a ^ b\n        xor = 0\n        for num in nums:\n            xor ^= num\n\n        # Find the rightmost set bit in xor\n        diff_bit = xor & -xor\n\n        a = b = 0\n        for num in nums:\n            if num & diff_bit:\n                a ^= num\n            else:\n                b ^= num\n        return [a, b]\n\ndef parse_input(input_str: str):\n    \"\"\"Parse input like 'nums = [1,2,1,3,2,5]' to a list.\"\"\"\n    s = input_str.strip()\n    if s.startswith(\"nums\"):\n        eq_pos = s.find(\"=\")\n        if eq_pos != -1:\n            s = s[eq_pos + 1:].strip()\n    # Evaluate the list safely\n    return ast.literal_eval(s)\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    nums = parse_input(data)\n    result = Solution().singleNumber(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1,3,2,5]",
          "expected_output": "[3,5]",
          "success": true,
          "output": "[3, 5]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0]",
          "expected_output": "[-1,0]",
          "success": true,
          "output": "[-1, 0]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,1]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode224.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator",
    "description_snippet": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and r...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines for a basic calculator that evaluates an expression string containing + - * / and parentheses? Problem says valid expression, likely including + - * / and parentheses and spaces. We'll implement classic stack-based evaluation with two stacks or using recursion. We'll produce pseudocode with steps: parse number, handle operators precedence. We will produce line-by-line pseudocode, each line with comment. Use arrows and decisions. We'll follow format exactly: each line with \"虛擬碼步驟 // 解釋/說明\".\n\nWe need to output \"Start\" then steps. We'll show reading string and iterating. Use two stacks: values stack, ops stack. For each char: if digit accumulate; if '(' push onto ops; if ')' process until '('; if operator: while top of ops has higher or equal precedence, apply; then push current operator. After loop, apply remaining ops. At end return top of values stack. We'll need helper functions: precedence(op) and applyOp(a,b,op). We'll write them as separate virtual steps.\n\nWe should include End. Provide decisions accordingly.\n\nLet's draft lines:\n\nStart // 程式開始\n→ Step 1: 初始化 valuesStack ← empty, opsStack ← empty, i ← 0 // 建立兩個棧和索引\n→ Step 2: 定義 precedence(op) // 回傳操作符優先級\n    → Decision: 如果 op 為 '+' 或 '-'? // 優先級 1\n        Yes → Return 1\n        No → Decision: 如果 op 為 '*' 或 '/'? // 優先級 2\n            Yes → Return 2\n            No → Return 0 // 其它（如 '('）低優先級\n→ Step 3: 定義 applyOp(a, b, op) // 執行 a op b\n    → Decision: 如果 op 為 '+'? // 加\n        Yes → Return a + b\n        No → Decision: 如果 op 為 '-'? // 減\n            Yes → Return a - b\n            No → Decision: 如果 op 為 '*'? // 乘\n                Yes → Return a * b\n                No → Decision: 如果 op 為 '/'? // 除\n                    Yes → Return a / b\n                    No → Return 0\n→ Step 4: 遍歷字串 s\n    → Decision: 如果 s[i] 為空格? // 跳過空格\n        Yes → i ← i + 1\n        No → Decision: 如果 s[i] 為數字? // 數字收集\n            Yes → number ← 0\n                → While i < len(s) 且 s[i] 為數字:\n                    number ← number * 10 + int(s[i])\n                    i ← i + 1\n                → Push number 到 valuesStack\n                → Continue 循環（不增加 i）\n            No → Decision: 如果 s[i] 為 '('? // 左括號\n                Yes → Push '(' 到 opsStack\n                → i ← i + 1\n                No → Decision: 如果 s[i] 為 ')'? // 右括號\n                    Yes → While opsStack top ≠ '(':\n                            op ← Pop opsStack\n                            b ← Pop valuesStack\n                            a ← Pop valuesStack\n                            Push applyOp(a, b, op) 到 valuesStack\n                        → Pop '(' from opsStack\n                        → i ← i + 1\n                    No → // 必定為運算符\n                        → Decision: 是否需要先執行高優先級運算符?\n                            Yes → While opsStack not empty AND precedence(opsStack top) ≥ precedence(s[i]) AND opsStack top ≠ '(':\n                                    op ← Pop opsStack\n                                    b ← Pop valuesStack\n                                    a ← Pop valuesStack\n                                    Push applyOp(a, b, op) 到 valuesStack\n                                → Push s[i] 到 opsStack\n                                → i ← i + 1\n                            No → // 不會發生\n→ Step 5: // 解析完字串後，處理剩餘運算符\n    → While opsStack not empty:\n        op ← Pop opsStack\n        b ← Pop valuesStack\n        a ← Pop valuesStack\n        Push applyOp(a, b, op) 到 valuesStack\n→ Step 6: 返回 valuesStack top // 結果\nEnd // 程式結束\n\nWe need to ensure each line begins with \"虛擬碼步驟\". Format: \"虛擬碼步驟 // 解釋\". The steps themselves may have arrows and indentation? They say use arrows `→` and structure. We can write \"Start // ...\" as first line. Then \"→ Step 1: ... // ...\". Then \"→ Step 2: ... // ...\". For decisions, we need indentation? Example format uses indentation with tabs. We can mimic that. Use newline for each decision branch? The format example uses indentation. We'll follow that.\n\nWe need to include each decision branch line as a separate line. For example:\n\n→ Decision: 如果 op 為 '+' 或 '-'? // 優先級 1\n    Yes → Return 1\n    No  → Decision: 如果 op 為 '*' 或 '/'? // 優先級 2\n        Yes → Return 2\n        No → Return 0\n\nYes/No branches are separate lines with indentation. Good.\n\nSimilarly for applyOp.\n\nIn step 4 loop, it's complex. We need to structure decisions accordingly. Might need many lines but acceptable.\n\nWe also need to keep each line as a single line with comment after. So for branches we need each line. Eg:\n\n→ Decision: 如果 s[i] 為空格? // 跳過空格\n    Yes → i ← i + 1\n    No  → Decision: 如果 s[i] 為數字? // 數字收集\n        Yes → number ← 0\n            → While i < len(s) 且 s[i] 為數字:\n                number ← number * 10 + int(s[i])\n                i ← i + 1\n            → Push number 到 valuesStack\n            → Continue 循環（不增加 i）\n        No → Decision: 如果 s[i] 為 '('? // 左括號\n            Yes → Push '(' 到 opsStack\n            → i ← i + 1\n            No → Decision: 如果 s[i] 為 ')'?\n                Yes → While opsStack top ≠ '(':\n                        op ← Pop opsStack\n                        b ← Pop valuesStack\n                        a ← Pop valuesStack\n                        Push applyOp(a, b, op) 到 valuesStack\n                    → Pop '(' from opsStack\n                    → i ← i + 1\n                No → // 必定為運算符\n                    → Decision: 是否需要先執行高優先級運算符?\n                        Yes → While opsStack not empty AND precedence(opsStack top) ≥ precedence(s[i]) AND opsStack top ≠ '(':\n                                op ← Pop opsStack\n                                b ← Pop valuesStack\n                                a ← Pop valuesStack\n                                Push applyOp(a, b, op) 到 valuesStack\n                            → Push s[i] 到 opsStack\n                            → i ← i + 1\n                        No → // 不會發生\n\nWe need to maintain each line within the indentation. Might be many lines. But that's okay.\n\nHowever, we must keep each line as single line with // comment. For while loops and nested, each line will have indentation and maybe arrow? Use \"→ While ...\" line.\n\nLet's produce final pseudocode accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 valuesStack ← 空棧, opsStack ← 空棧, i ← 0 // 建立兩個棧和索引  \n→ Step 2: 定義 precedence(op) // 回傳操作符優先級  \n  → Decision: op 為 '+' 或 '-'? // 優先級 1  \n   Yes → Return 1 // 加減優先級  \n   No  → Decision: op 為 '*' 或 '/'? // 優先級 2  \n    Yes → Return 2 // 乘除優先級  \n    No  → Return 0 // 其他符號低優先級  \n→ Step 3: 定義 applyOp(a, b, op) // 執行 a op b  \n  → Decision: op 為 '+'? // 加  \n   Yes → Return a + b  \n   No  → Decision: op 為 '-'? // 減  \n    Yes → Return a - b  \n    No  → Decision: op 為 '*'? // 乘  \n     Yes → Return a * b  \n     No  → Decision: op 為 '/'? // 除  \n      Yes → Return a / b  \n      No  → Return 0  \n→ Step 4: 遍歷字串 s  \n  → Decision: s[i] 為空格? // 跳過空格  \n   Yes → i ← i + 1  \n   No  → Decision: s[i] 為數字? // 數字收集  \n    Yes → number ← 0  \n     → While i < len(s) 且 s[i] 為數字: // 收集完整數字  \n      number ← number * 10 + int(s[i])  \n      i ← i + 1  \n     → Push number 到 valuesStack  \n     → Continue // 不再自動加 i  \n    No  → Decision: s[i] 為 '('? // 左括號  \n     Yes → Push '(' 到 opsStack  \n     → i ← i + 1  \n     No  → Decision: s[i] 為 ')'? // 右括號  \n      Yes → While opsStack top ≠ '(': // 處理括號內運算  \n       op ← Pop opsStack  \n       b ← Pop valuesStack  \n       a ← Pop valuesStack  \n       Push applyOp(a, b, op) 到 valuesStack  \n      → Pop '(' 從 opsStack  \n      → i ← i + 1  \n      No  → // 必定為運算符  \n       → Decision: opsStack top 優先級 ≥ s[i]? // 需要先算高優先級  \n        Yes → While opsStack not empty AND precedence(opsStack top) ≥ precedence(s[i]) AND opsStack top ≠ '(':  \n         op ← Pop opsStack  \n         b ← Pop valuesStack  \n         a ← Pop valuesStack  \n         Push applyOp(a, b, op) 到 valuesStack  \n       → Push s[i] 到 opsStack  \n       → i ← i + 1  \n       No → // 不會發生  \n→ Step 5: // 解析完字串後，處理剩餘運算符  \n  → While opsStack not empty:  \n   op ← Pop opsStack  \n   b ← Pop valuesStack  \n   a ← Pop valuesStack  \n   Push applyOp(a, b, op) 到 valuesStack  \n→ Step 6: Return valuesStack top // 回傳計算結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        \"\"\"\n        Evaluate a basic arithmetic expression containing +, -, parentheses\n        and integer numbers. Spaces are ignored.\n        \"\"\"\n        stack = []        # store previous result and sign\n        res = 0           # current result\n        num = 0           # current number being built\n        sign = 1          # current sign (+1 or -1)\n\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c in '+-':\n                res += sign * num\n                num = 0\n                sign = 1 if c == '+' else -1\n            elif c == '(':\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            elif c == ')':\n                res += sign * num\n                num = 0\n                res *= stack.pop()      # sign before the parentheses\n                res += stack.pop()      # result before the parentheses\n            # ignore other characters (e.g., spaces)\n\n        res += sign * num\n        return res\n\ndef main() -> None:\n    \"\"\"\n    Read the entire input from stdin, extract the expression inside\n    double quotes if present, evaluate it, and print the result.\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    data = data.strip()\n    first_quote = data.find('\"')\n    last_quote = data.rfind('\"')\n\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        expr = data[first_quote + 1:last_quote]\n    else:\n        expr = data\n\n    solution = Solution()\n    result = solution.calculate(expr)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"1 + 1\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \" 2-1 + 2 \"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode561.json",
    "problem_index_in_file": 0,
    "title": "Array Partition",
    "description_snippet": "Given an integer array nums of 2n integers, group these integers into n pairs (a_1, b_1), (a_2, b_2)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for solving the problem: maximize sum of min of pairs. Known solution: sort array, pair adjacent elements, sum up every second element starting from index 0? Actually maximize sum of mins by pairing sorted ascending: min of each pair will be the first element in each pair when sorted ascending. So sum of elements at even indices after sorting. So algorithm: sort ascending, sum elements at even indices. Complexity O(n log n).\n\nWe produce virtual code lines with explanation. Use Start, Decision, etc.\n\nLet's craft steps:\n\nStart\n\n→ Step 1: Sort nums ascending\n\n→ Step 2: Initialize sum = 0\n\n→ Step 3: For i from 0 to length(nums)-1 step 2:\n\n→ Decision: If i < length(nums) ?\n\nBut simpler: loop i=0; i<length; i+=2\n\n→ Step 4: sum = sum + nums[i]\n\nAfter loop:\n\n→ Step 5: Return sum\n\nEnd\n\nNeed each line with // explanation. Include arrow arrows. Use Start, End. Use Decision structure for loop? We can use Decision for loop condition. Let's create:\n\nStart\n\n→ Step 1: Sort nums ascending\n\n→ Step 2: Set sum = 0\n\n→ Step 3: Set i = 0\n\n→ Decision: i < length(nums)?\n\n    Yes → Step 4: sum = sum + nums[i]\n\n    Yes → Step 5: i = i + 2\n\n    No  → Step 6: Return sum\n\nEnd\n\nNeed to ensure loop repeats. In decision, after adding, increment, then go back to decision. So we need loop structure. We can use Decision block with arrows leading back to step 3. But typical pseudocode representation: Use Decision block with arrows. Example:\n\nDecision: i < length(nums)?\n\n    Yes → Step 4: sum = sum + nums[i]\n    → Step 5: i = i + 2\n    → (back to) Decision\n\nBut we can't produce \"back to\" arrow? We can show arrow: → (loop back) Decision\n\nBetter: use structure:\n\nDecision: i < length(nums)? // check loop condition\n    Yes → Step 4: sum = sum + nums[i] // add current element\n    Yes → Step 5: i = i + 2 // move to next pair\n    Yes → Decision // loop back\n    No  → Step 6: Return sum\n\nSimplify: maybe use \"Loop\" keyword? But instructions specify only arrow and Decision. So we can embed.\n\nWe'll produce step lines accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先將整數陣列由小到大排序  \n→ Step 2: Set sum = 0 // 用來累加最小值的總和  \n→ Step 3: Set i = 0 // 從第一個元素開始  \n→ Decision: i < length(nums)? // 判斷是否還有元素可處理  \n  Yes → Step 4: sum = sum + nums[i] // 把當前對的最小值加入總和  \n  Yes → Step 5: i = i + 2 // 跳到下一個對的第一個元素  \n  Yes → Decision // 回到判斷，形成迴圈  \n  No  → Step 6: Return sum // 所有元素都已處理，回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef array_pair_sum(nums):\n    \"\"\"Return the maximum sum of min(ai, bi) over all pairs.\"\"\"\n    nums.sort()\n    return sum(nums[::2])\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    # Parse the input as a Python list\n    nums = ast.literal_eval(raw_input)\n    # Compute and print the result\n    result = array_pair_sum(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,4,3,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "[6,2,6,5,1,2]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode55.json",
    "problem_index_in_file": 0,
    "title": "Jump Game",
    "description_snippet": "You are given an integer array nums. You are initially positioned at the array's first index, and ea...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code for Jump Game problem. Use step by step, decision structures. Provide comments. Use Start, End, Decision. Each line with \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow \"→\" for flow. Provide lines. Provide iterative solution: track maxReach, loop. We'll produce pseudo code.\n\nLet's produce:\n\nStart\n→ Step 1: Set maxReach = 0 // 记录目前能达到的最远索引\n→ For i from 0 to length-1:\n   Decision: if i > maxReach? // 当前索引超过可达范围\n      Yes → Return False // 无法继续前进，返回 false\n      No  → Update maxReach = max(maxReach, i + nums[i]) // 更新最远可达\n   Decision: if maxReach >= length-1? // 已能到达或超过最后一索引\n      Yes → Return True\nEnd\n\nBut we need to show each line. Use indentation for decision branches.\n\nLet's write lines sequentially.\n\nWill output:\n\nStart // 程式開始執行\n→ Step 1: maxReach ← 0 // 設定最遠可達索引為 0\n→ Step 2: n ← length(nums) // 取得陣列長度\n→ Decision: 是否 i < n? // 開始迴圈\n    → For i ← 0 to n-1:\n        Decision: 如果 i > maxReach? // 是否超過目前可達範圍\n            Yes → Return False // 不能再前進，結束並返回 false\n            No  → Step 3: maxReach ← max(maxReach, i + nums[i]) // 更新最遠可達索引\n        Decision: 如果 maxReach >= n-1? // 是否已經能到最後\n            Yes → Return True // 成功到達，返回 true\n            No  → // 續迴圈\nEnd // 程式結束\n\nBut maybe structure better. Use \"Decision:\" and arrow inside loops.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: maxReach ← 0 // 初始最遠可達位置\n→ Step 2: n ← length(nums) // 獲取陣列長度\n→ For i ← 0 to n-1:\n    Decision: i > maxReach? // 目前索引是否超出可達範圍\n        Yes → Return False // 無法再前進，直接失敗\n        No  → Step 3: maxReach ← max(maxReach, i + nums[i]) // 更新最遠可達\n    Decision: maxReach >= n-1? // 是否已可達最後一個位置\n        Yes → Return True // 成功到達，返回 true\n        No  → // 繼續迴圈\nEnd // 程式結束\n\nLet's ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow at start? Format example uses \"→ Step 1:\". We'll use same.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: maxReach ← 0 // 設定最遠可達索引為 0  \n→ Step 2: n ← length(nums) // 取得陣列長度  \n→ For i ← 0 to n-1: // 循環遍歷每個索引  \n  Decision: i > maxReach? // 目前索引是否超出目前可達範圍  \n   Yes → Return False // 無法再前進，直接失敗  \n   No  → Step 3: maxReach ← max(maxReach, i + nums[i]) // 更新最遠可達索引  \n  Decision: maxReach >= n-1? // 是否已能達到或超過最後一個索引  \n   Yes → Return True // 成功到達，返回 true  \n   No  → // 續迴圈  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canJump(self, nums):\n        \"\"\"\n        Determine if you can reach the last index.\n        :param nums: List[int]\n        :return: bool\n        \"\"\"\n        max_reach = 0\n        n = len(nums)\n        for i in range(n):\n            if i > max_reach:          # 当前索引超出可达范围\n                return False\n            max_reach = max(max_reach, i + nums[i])  # 更新最远可达\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析输入：支持 \"nums = [1, 2, 3]\" 或仅提供列表\n    if 'nums' in data:\n        _, nums_part = data.split('=', 1)\n        nums_part = nums_part.strip()\n    else:\n        nums_part = data\n\n    try:\n        nums = ast.literal_eval(nums_part)\n    except Exception:\n        # 若无法解析为列表，尝试按空格分隔解析为整数\n        nums = list(map(int, nums_part.split()))\n\n    result = Solution().canJump(nums)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,0,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode220.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate III",
    "description_snippet": "You are given an integer array nums and two integers indexDiff and valueDiff.\n\nFind a pair of indice...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving this problem. Steps: start, loop over i, for j in range(i+1,...,min(n-1, i+indexDiff)) check difference, if satisfy valueDiff return true. End loop, return false. Use Decision nodes. Also we might early exit. Provide each line with // explanation. Use virtual code syntax with arrows. Provide step names. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列長度 n // 取得 nums 的元素數目  \n→ Decision: n <= 1? // 若陣列只有 0 或 1 個元素，無法形成有效對  \n    Yes → Step 2: 輸出 False // 沒有兩個索引可比  \n    No  → Step 3: for i from 0 to n-1 // 主迴圈，逐一挑選第一個索引  \n→ Decision: i < n? // 確認還有索引可處理  \n    Yes → Step 4: 計算 max_j = min(n-1, i + indexDiff) // 只檢查距離不超過 indexDiff 的範圍  \n    No  → Step 5: 輸出 False // 所有索引已檢查完畢，未找到符合條件  \n→ Step 6: for j from i+1 to max_j // 第二層迴圈，檢查與 i 的相鄰索引  \n→ Decision: j <= max_j? // 是否還有索引可檢查  \n    Yes → Step 7: 計算 diff = abs(nums[i] - nums[j]) // 兩個值的差值  \n    No  → 回到 Step 3 // j 範圍結束，回到外層迴圈  \n→ Decision: diff <= valueDiff? // 差值是否符合限制  \n    Yes → Step 8: 輸出 True // 找到符合條件的索引對，直接返回  \n    No  → Step 9: j = j + 1 // 進一步檢查下一個 j，回到 Step 6  \nEnd // 程式執行結束 (若未返回 True，則執行到此結束，輸出 False)",
      "generated_code": "import sys\nimport re\nimport bisect\n\ndef containsNearbyAlmostDuplicate(nums, k, t):\n    \"\"\"\n    判斷是否存在兩個索引 i, j 滿足\n    1. i != j\n    2. abs(i - j) <= k\n    3. abs(nums[i] - nums[j]) <= t\n    使用滑動窗口 + 有序列表實作\n    \"\"\"\n    if k <= 0 or t < 0:\n        return False\n\n    window = []  # 有序窗口\n    for i, num in enumerate(nums):\n        # 在窗口中搜尋最靠近 num - t 的位置\n        pos = bisect.bisect_left(window, num - t)\n        if pos < len(window) and abs(window[pos] - num) <= t:\n            return True\n\n        # 將目前數值插入窗口\n        bisect.insort(window, num)\n\n        # 若窗口長度超過 k，移除最舊的元素\n        if len(window) > k:\n            old = nums[i - k]\n            idx = bisect.bisect_left(window, old)\n            # 可能存在重複值，找到第一個相等的位置再刪除\n            while idx < len(window) and window[idx] != old:\n                idx += 1\n            if idx < len(window):\n                del window[idx]\n\n    return False\n\ndef parse_input(data):\n    \"\"\"\n    解析輸入字串，例如：\n    'nums = [1,2,3,1], indexDiff = 3, valueDiff = 0'\n    \"\"\"\n    # 取得 nums\n    nums_match = re.search(r'nums\\s*=\\s*\\[(.*?)\\]', data, re.S)\n    if not nums_match:\n        raise ValueError(\"Invalid input: missing nums\")\n    nums_str = nums_match.group(1).strip()\n    if nums_str == '':\n        nums = []\n    else:\n        nums = [int(x.strip()) for x in nums_str.split(',')]\n\n    # 取得 indexDiff\n    idx_match = re.search(r'indexDiff\\s*=\\s*(-?\\d+)', data)\n    if not idx_match:\n        raise ValueError(\"Invalid input: missing indexDiff\")\n    indexDiff = int(idx_match.group(1))\n\n    # 取得 valueDiff\n    val_match = re.search(r'valueDiff\\s*=\\s*(-?\\d+)', data)\n    if not val_match:\n        raise ValueError(\"Invalid input: missing valueDiff\")\n    valueDiff = int(val_match.group(1))\n\n    return nums, indexDiff, valueDiff\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    nums, k, t = parse_input(raw_input)\n    result = containsNearbyAlmostDuplicate(nums, k, t)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode229.json",
    "problem_index_in_file": 0,
    "title": "Majority Element II",
    "description_snippet": "Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for algorithm to find elements that appear more than floor(n/3) times. Classic majority element II problem. We need to output step by step with explanation.\n\nWe need to use virtual code arrows and decision structures. Should be line by line, each line with \"// explanation\".\n\nStart, End, Decision, etc.\n\nWe need to use \"→\" arrow. Use \"Yes →\", \"No →\".\n\nLet's craft:\n\nStart // start\n\n→ Step 1: Initialize candidate1, count1, candidate2, count2 to None, 0, None, 0 // initialize potential candidates\n\n→ Step 2: For each element num in array // iterate through array\n\n    → Decision: If count1 == 0? // check if first candidate slot empty\n\n        Yes → candidate1 = num, count1 = 1 // assign first candidate\n\n        No  → Decision: If num == candidate1? // if same as candidate1\n\n            Yes → count1++ // increment count\n\n            No  → Decision: If count2 == 0? // check second candidate slot\n\n                Yes → candidate2 = num, count2 = 1 // assign second candidate\n\n                No  → Decision: If num == candidate2? // if same as candidate2\n\n                    Yes → count2++ // increment count\n\n                    No  → count1--, count2-- // decrement both counts\n\n→ Step 3: Reset count1, count2 to 0 // prepare for verification\n\n→ Step 4: For each element num in array // second pass to confirm counts\n\n    → Decision: If num == candidate1? // count occurrences for candidate1\n\n        Yes → count1++ \n\n        No  → Decision: If num == candidate2? // count occurrences for candidate2\n\n            Yes → count2++\n\n→ Step 5: Initialize result list // to store valid majority elements\n\n→ Step 6: Decision: If count1 > n/3? // check first candidate\n\n    Yes → Add candidate1 to result\n\n→ Step 7: Decision: If count2 > n/3? // check second candidate\n\n    Yes → Add candidate2 to result\n\nEnd // finished\n\nWe need to include explanations.\n\nAlso we need to handle if candidate1 or candidate2 may be None? For explanation we can note that if no candidate, skip. But we can keep as above.\n\nMake sure each line ends with \"// 解釋\".\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 candidate1 = None, count1 = 0, candidate2 = None, count2 = 0 // 設定兩個可能的頻率較高元素與計數器  \n→ Step 2: 對陣列中的每個數值 num 進行迭代 // 進行第一輪檢測以找出兩個潛在候選者  \n    → Decision: 如果 count1 == 0? // 判斷第一個候選位是否為空  \n        Yes → candidate1 = num, count1 = 1 // 空位，將當前數值設為第一候選者並計數為 1  \n        No → Decision: 如果 num == candidate1? // 與第一候選者相同  \n            Yes → count1++ // 同一候選者，計數加 1  \n            No → Decision: 如果 count2 == 0? // 判斷第二個候選位是否為空  \n                Yes → candidate2 = num, count2 = 1 // 空位，設為第二候選者並計數為 1  \n                No → Decision: 如果 num == candidate2? // 與第二候選者相同  \n                    Yes → count2++ // 同一候選者，計數加 1  \n                    No → count1--, count2-- // 同時將兩個計數器減 1，逼近真正的頻率  \n→ Step 3: 將 count1, count2 重設為 0 // 準備第二輪驗證計數  \n→ Step 4: 再次對陣列中的每個數值 num 進行迭代 // 以確定候選者的實際出現次數  \n    → Decision: 如果 num == candidate1? // 計算第一候選者的實際次數  \n        Yes → count1++  \n        No → Decision: 如果 num == candidate2? // 計算第二候選者的實際次數  \n            Yes → count2++  \n→ Step 5: 初始化 result 為空列表 // 用於儲存最終符合條件的元素  \n→ Step 6: Decision: 如果 count1 > n/3? // 檢查第一候選者是否真的頻率超過 n/3  \n    Yes → result.Add(candidate1) // 符合條件，加入結果  \n→ Step 7: Decision: 如果 count2 > n/3? // 檢查第二候選者是否真的頻率超過 n/3  \n    Yes → result.Add(candidate2) // 符合條件，加入結果  \nEnd // 程式執行結束，結果列表即為所有出現次數超過 ⌊n/3⌋ 的元素。",
      "generated_code": "import sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        找出所有出現次數超過 ⌊n/3⌋ 的元素。\n        先利用 Boyer–Moore 兩個候選者法確定可能的元素，\n        再做一次遍歷確認其實際頻率。\n        \"\"\"\n        if not nums:\n            return []\n\n        candidate1 = candidate2 = None\n        count1 = count2 = 0\n\n        # 第一次遍歷：找出兩個可能的候選者\n        for num in nums:\n            if candidate1 == num:\n                count1 += 1\n            elif candidate2 == num:\n                count2 += 1\n            elif count1 == 0:\n                candidate1, count1 = num, 1\n            elif count2 == 0:\n                candidate2, count2 = num, 1\n            else:\n                count1 -= 1\n                count2 -= 1\n\n        # 第二次遍歷：計算候選者的實際出現次數\n        count1 = count2 = 0\n        for num in nums:\n            if num == candidate1:\n                count1 += 1\n            elif num == candidate2:\n                count2 += 1\n\n        # 收集真正符合條件的元素\n        n = len(nums)\n        result = []\n        if count1 > n // 3:\n            result.append(candidate1)\n        if count2 > n // 3:\n            result.append(candidate2)\n\n        return result\n\ndef parse_input(data: str) -> List[int]:\n    \"\"\"\n    從輸入字串解析得到整數列表。\n    支援類似 'nums = [1, 2, 3]' 或單純的 '[1, 2, 3]' 格式。\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n\n    # 若包含 '['，直接切出子字串\n    try:\n        start = data.index('[')\n        end = data.rindex(']')\n        list_str = data[start:end + 1]\n        nums = ast.literal_eval(list_str)\n    except (ValueError, SyntaxError):\n        # 直接 eval 整個字串\n        nums = ast.literal_eval(data)\n    if not isinstance(nums, list):\n        # 若解析結果不是列表，嘗試把整個字串拆分成整數\n        nums = [int(x) for x in data.split()]\n    return nums\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    sol = Solution()\n    output = sol.majorityElement(nums)\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "[3]",
          "success": true,
          "output": "[3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode748.json",
    "problem_index_in_file": 0,
    "title": "Shortest Completing Word",
    "description_snippet": "Given a string licensePlate and an array of strings words, find the shortest completing word in word...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce pseudocode step by step with explanations, following format. We should include Start, End, Decision, arrows. We should produce step-by-step logic: preprocessing licensePlate to count letters ignoring case. Then iterate words, for each word compute letter counts, check if counts satisfy licensePlate counts, if so candidate. Keep shortest length, and earliest. Return result.\n\nWe should also note we need to handle case-insensitivity, ignoring non-letters. Use array of 26 ints.\n\nWe need to format each line as: \"虛擬碼步驟 // 解釋\" with arrows and indentation for decisions.\n\nLet's produce pseudocode.\n\nStart // 程式開始執行\n→ Step 1: 初始化 licenseCount[26] 為 0 // 用於存放 licensePlate 中各字母的出現次數\n→ Step 2: 遍歷 licensePlate 字符逐字符\n    → Decision: 如果字符是字母? // 判斷是否為字母\n        Yes → Step 3: 把字符轉成小寫並更新 licenseCount[char - 'a']++ // 累加出現次數\n        No  → Step 4: 忽略非字母字符 // 跳過數字與空格\n→ Step 5: 初始化 bestWord 為空字串，bestLen 為無限大 // 儲存目前最短符合條件的單詞\n→ Step 6: 遍歷 words 數組\n    → Decision: words[i] 的長度 < bestLen? // 先過濾已知更短候選\n        Yes → Step 7: 初始化 wordCount[26] 為 0 // 用於存放當前單詞字母計數\n        → Step 8: 遍歷 words[i] 的每個字符\n            → Decision: 字符是字母? // 確保只計算字母\n                Yes → Step 9: 把字符轉成小寫並更新 wordCount[char - 'a']++ // 累加計數\n                No  → Step 10: 忽略非字母字符\n        → Step 11: 初始化 isComplete 為 true // 假設符合條件\n        → Decision: licenseCount[j] > 0 且 wordCount[j] < licenseCount[j]? // 檢查每個字母\n            Yes → Step 12: 設置 isComplete = false 并跳出循環 // 不符合\n            No  → Step 13: 繼續檢查下一個字母\n        → Decision: isComplete? // 是否滿足條件\n            Yes → Step 14: 更新 bestWord = words[i]，bestLen = words[i].length // 保存新的最短單詞\n            No  → Step 15: 跳過此單詞 // 不符合條件\n    No  → Step 16: 跳過此單詞 // 其長度已大於或等於目前最短\n→ End // 返回 bestWord\n\nBut we must also incorporate \"if there are multiple shortest completing words, return the first one that occurs in words\". Our algorithm: only update if length < bestLen, not <=, so earlier words of same length will not replace later ones. That's correct.\n\nNow produce final output lines.\n\nNeed to include arrow notation: \"→ Step ...\" etc. Decision lines with Yes/No arrow. For nested decision we indent with 4 spaces? In example they used spaces before each line. We'll replicate.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 licenseCount[26] 為 0 // 用於存放 licensePlate 中各字母的出現次數\n→ Step 2: 遍歷 licensePlate 字符逐字符\n    → Decision: 字符是字母? // 判斷是否為字母\n        Yes → Step 3: 把字符轉成小寫並更新 licenseCount[char - 'a']++ // 累加出現次數\n        No  → Step 4: 忽略非字母字符 // 跳過數字與空格\n→ Step 5: 初始化 bestWord 為空字串，bestLen 為無限大 // 儲存目前最短符合條件的單詞\n→ Step 6: 遍歷 words 數組\n    → Decision: words[i] 的長度 < bestLen? // 先過濾已知更短候選\n        Yes → Step 7: 初始化 wordCount[26] 為 0 // 用於存放當前單詞字母計數\n        → Step 8: 遍歷 words[i] 的每個字符\n            → Decision: 字符是字母? // 確保只計算字母\n                Yes → Step 9: 把字符轉成小寫並更新 wordCount[char - 'a']++ // 累加計數\n                No  → Step 10: 忽略非字母字符\n        → Step 11: 初始化 isComplete 為 true // 假設符合條件\n        → Decision: licenseCount[j] > 0 且 wordCount[j] < licenseCount[j]? // 檢查每個字母\n            Yes → Step 12: 設置 isComplete = false 并跳出循環 // 不符合\n            No  → Step 13: 繼續檢查下一個字母\n        → Decision: isComplete? // 是否滿足條件\n            Yes → Step 14: 更新 bestWord = words[i]，bestLen = words[i].length // 保存新的最短單詞\n            No  → Step 15: 跳過此單詞 // 不符合條件\n    No  → Step 16: 跳過此單詞 // 其長度已大於或等於目前最短\nEnd // 返回 bestWord",
      "generated_code": "import sys\nimport re\nimport collections\n\ndef shortest_completing_word(license_plate: str, words: list[str]) -> str:\n    \"\"\"\n    找出 words 中最短的符合 license_plate 所需字母的單詞。\n    \"\"\"\n    # 計算 license_plate 中每個字母的出現次數（忽略大小寫，忽略非字母）\n    plate_count = collections.Counter(c.lower() for c in license_plate if c.isalpha())\n\n    best_word = None\n    for word in words:\n        # 只計算字母，因為題目說忽略非字母\n        word_count = collections.Counter(c for c in word if c.isalpha())\n\n        # 檢查是否包含 license_plate 所需的所有字母\n        if all(word_count[ch] >= plate_count[ch] for ch in plate_count):\n            # 若尚未找到答案或目前單詞更短，更新答案\n            if best_word is None or len(word) < len(best_word):\n                best_word = word\n    return best_word\n\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取資料，並輸出最短完成字。\n    期望輸入格式類似：\n    licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 使用正則表達式抓取 licensePlate 和 words\n    license_match = re.search(r'licensePlate\\s*=\\s*\"([^\"]*)\"', data)\n    words_match = re.search(r'words\\s*=\\s*\\[([^\\]]*)\\]', data)\n\n    if not license_match or not words_match:\n        return\n\n    license_plate = license_match.group(1)\n\n    # words 的內容為 '\"step\",\"steps\",\"stripe\",\"stepple\"'\n    words_raw = words_match.group(1)\n    words = [\n        w.strip().strip('\"').strip(\"'\")\n        for w in words_raw.split(',')\n        if w.strip()\n    ]\n\n    result = shortest_completing_word(license_plate, words)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]",
          "expected_output": "\"steps\"",
          "success": true,
          "output": "steps"
        },
        {
          "example_index": 1,
          "input": "licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"]",
          "expected_output": "\"pest\"",
          "success": true,
          "output": "pest"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode136.json",
    "problem_index_in_file": 0,
    "title": "Single Number",
    "description_snippet": "Given a non-empty array of integers nums, every element appears twice except for one. Find that sing...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described problem: find single number with linear runtime and constant space. Use XOR method. So steps: initialize result=0; for each num in nums: result = result XOR num; return result. But we need to output virtual code step by step with explanation each line. Must not produce actual code but virtual code syntax with arrows. Format: each line: \"虛擬碼步驟 // 解釋\". Use Start, Decision, etc. But here simple loop; we can include decision to check if array empty? They said non-empty. So no need to check. Steps: Start, initialize result=0, for each num, result XOR num, after loop, return result, End. We can also show loop structure. Virtual code: maybe \"→ Loop: For each num in nums // iterate over array\" inside loop we do XOR. Provide explanations.\n\nAlso we can include decision: \"If nums is empty?\" but not necessary. But we can include to be thorough.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Decision: nums 是否為空? // 檢查輸入是否為空\n\nYes → Step: return 0 // 空陣列（雖說題目非空，但此處處理空陣列）// but maybe not needed.\n\nNo  → Step 1: result ← 0 // 初始化 XOR 結果為 0\n\n→ Loop: For each num in nums // 逐個遍歷數字\n\n    → Step 2: result ← result XOR num // 進行 XOR，雙數會相互抵消\n\n→ Decision: 結束迴圈? // 判斷是否已遍歷完\n\nYes → Step 3: return result // 回傳單一出現的數字\n\nEnd // 程式結束\n\nBut maybe they want arrow indent style: \"Yes →\" \"No →\" lines etc. For loop we can use \"→ Loop: 遍歷 nums\" and indent inner steps.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: nums 是否為空? // 檢查輸入是否為空（題目已說非空，但作完整處理）  \n Yes → Step: return 0 // 若為空，直接回傳 0  \n No  → Step 1: result ← 0 // 初始化 XOR 結果為 0  \n→ Loop: 遍歷 nums // 逐一處理陣列中的每個數字  \n → Step 2: result ← result XOR num // 對當前數字進行 XOR，已出現兩次的數會抵消  \n→ Decision: 迴圈結束? // 判斷是否已遍歷完所有數字  \n Yes → Step 3: return result // 回傳只出現一次的數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNumber(self, nums):\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，支援 \"nums = [2,2,1]\" 或僅 \"[2,2,1]\"\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n    list_part = list_part.strip()\n    nums = ast.literal_eval(list_part)\n    # 呼叫解法\n    sol = Solution()\n    print(sol.singleNumber(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,1,2,1,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1991.json",
    "problem_index_in_file": 0,
    "title": "Find the Middle Index in Array",
    "description_snippet": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode with explanations. Input: array nums. Need to find leftmost index where prefix sum equals suffix sum (excluding element). Classic solution: compute total sum, iterate maintain left sum. At each i, right = total - left - nums[i]. Check if left == right. Return i. Else update left += nums[i]. After loop return -1. Edge cases: length 0? not specified but likely >0. We'll produce pseudocode accordingly.\n\nAlso need to use virtual code structure with arrows and decisions. Provide explanation per line.\n\nLet's produce:\n\nStart\n→ Step 1: 計算 totalSum ← sum(nums) // 總和\n→ Step 2: 設定 leftSum ← 0 // 左側已經累加的和\n→ Decision: 是否已經遍歷完 nums? // 用 for 循環\n    Yes → End // 結束\n    No → Step 3: 取 i 為當前索引 // 處理第 i 個元素\n        → Step 4: 計算 rightSum ← totalSum - leftSum - nums[i] // 右側和\n        → Decision: 是否 leftSum == rightSum? // 檢查是否平衡\n            Yes → Step 5: 回傳 i // 找到左邊最小索引\n            No → Step 6: 更新 leftSum ← leftSum + nums[i] // 加入當前元素進左側\n        → 迴圈回到 Decision: 是否已經遍歷完 nums? // 進入下一個 i\nEnd\n\nBut we must use the format exactly as examples: \"Start // 程式開始執行\" etc. Use arrows \"→\". For Decision lines, we can indent. Example: \n```\nStart // 程式開始執行\n→ Step 1: 計算 totalSum ← sum(nums) // ...\n```\nThen indent decision: \n```\n→ Decision: 是否已經遍歷完 nums? // ...\n    Yes → Step 3: ...\n    No  → ...\n```\n\nWe must maintain readability. Also note that for loops we can represent as Decision: i < nums.length?; but easier is use for.\n\nI'll produce:\n\n```\nStart // 程式開始執行\n→ Step 1: totalSum ← sum(nums) // 計算陣列總和\n→ Step 2: leftSum ← 0 // 初始化左側已累加的和\n→ Decision: i < nums.length? // 循環遍歷每個索引\n    Yes → Step 3: current ← nums[i] // 取得當前元素\n        → Step 4: rightSum ← totalSum - leftSum - current // 計算右側和\n        → Decision: leftSum == rightSum? // 檢查是否為中點\n            Yes → Step 5: 回傳 i // 找到左側最小中點\n            No  → Step 6: leftSum ← leftSum + current // 更新左側和\n        → Decision: i + 1 < nums.length? // 判斷是否還有下一個元素\n            Yes → i ← i + 1 // 移動到下一個索引\n            No  → Step 7: 回傳 -1 // 沒有找到中點\nEnd // 程式結束\n```\n\nBut we need to use correct syntax: we need to set i initially 0. We can incorporate initialization:\n\n→ Step 0: i ← 0 // 初始化索引\n\nAnd at end, if found, we would exit, but we need to reflect \"End\".\n\nLet's craft final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 0: i ← 0 // 初始化索引\n→ Step 1: totalSum ← sum(nums) // 計算整個陣列的總和\n→ Step 2: leftSum ← 0 // 左側已累加的和，起始為 0\n→ Decision: i < nums.length? // 判斷是否還有未遍歷的元素\n    Yes → Step 3: current ← nums[i] // 取得當前索引的元素\n        → Step 4: rightSum ← totalSum - leftSum - current // 計算右側的和\n        → Decision: leftSum == rightSum? // 檢查左側和右側是否相等\n            Yes → Step 5: 回傳 i // 找到左側最小的中點，直接返回\n            No  → Step 6: leftSum ← leftSum + current // 將當前元素加入左側和\n        → Decision: i + 1 < nums.length? // 判斷是否還有下一個索引\n            Yes → i ← i + 1 // 移動到下一個索引，繼續循環\n            No  → Step 7: 回傳 -1 // 全部遍歷完仍未找到，返回 -1\nEnd // 程式結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMiddleIndex(self, nums):\n        \"\"\"Find the leftmost middle index in nums.\"\"\"\n        total = sum(nums)          # Total sum of all elements\n        left_sum = 0               # Sum of elements to the left of the current index\n\n        for i, num in enumerate(nums):\n            # Right side sum excludes current element\n            right_sum = total - left_sum - num\n            if left_sum == right_sum:\n                return i          # Found the leftmost middle index\n            left_sum += num        # Include current element for next iteration\n\n        return -1                    # No middle index found\n\n\ndef read_nums_from_stdin() -> list[int]:\n    \"\"\"\n    Reads the input from stdin and extracts the list of integers.\n    Expected format: any text containing a Python list literal, e.g.,\n    'nums = [2,3,-1,8,4]'.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return []\n\n    # Find the first '[' and the last ']' to isolate the list literal\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        raise ValueError(\"Input does not contain a valid list literal.\")\n\n    list_str = data[start:end + 1]\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception as e:\n        raise ValueError(f\"Failed to parse list: {e}\")\n\n    if not isinstance(nums, list):\n        raise ValueError(\"Parsed value is not a list.\")\n    return nums\n\n\nif __name__ == \"__main__\":\n    nums = read_nums_from_stdin()\n    result = Solution().findMiddleIndex(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,-1,8,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,-1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [2,5]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode520.json",
    "problem_index_in_file": 0,
    "title": "Detect Capital",
    "description_snippet": "We define the usage of capitals in a word to be right when one of the following cases holds:\n\nAll le...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. Each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision. No actual code. Provide step by step. Must consider string input word. We need to check three cases: all uppercase, all lowercase, first letter uppercase rest lowercase. Return true if any holds.\n\nWe produce pseudocode: Start, read word, decide case.\n\nNeed to handle length 0? Might not but we can include. We'll produce decisions: isAllUpper, isAllLower, isFirstUpperRestLower. Use loops or built-in functions conceptually.\n\nWe will produce steps: Step 1: Determine length. Step 2: Initialize flags. Step 3: For each character, update flags. Step 4: Check flags and return true if any.\n\nLet's craft lines:\n\nStart\n→ Step 1: Get length of word // 取得字串長度\n→ Step 2: If length == 0 → End // 空字串視為無效或直接結束\n→ Step 3: Initialize isAllUpper = true, isAllLower = true, isFirstUpperRestLower = true // 設定三個布林旗標\n→ Decision: 循環遍歷字元 i from 0 to length-1\n    → Step 4: char = word[i] // 取得第 i 個字元\n    → Decision: i == 0? // 第一個字元\n        Yes → Decision: 是否大寫? // 判斷是否大寫\n            Yes → Step 5: isFirstUpperRestLower stays true; isAllLower = false // 第一個大寫保持\n            No  → Step 6: isFirstUpperRestLower = false; isAllUpper = false // 第一個不是大寫\n        No  → Decision: 是否大寫?\n            Yes → Step 7: isAllLower = false; isFirstUpperRestLower = false // 後續大寫\n            No  → Step 8: isAllUpper = false // 小寫\n→ Decision: (isAllUpper OR isAllLower OR isFirstUpperRestLower)? // 檢查是否符合任一規則\n    Yes → Step 9: return true // 有效的大小寫使用\n    No  → Step 10: return false // 無效\nEnd\n\nWe must maintain the syntax with arrows and indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得字串 word 的長度 // 取得需要檢查的長度\n→ Step 2: 如果長度為 0 → End // 空字串直接結束\n→ Step 3: 初始化 isAllUpper = true, isAllLower = true, isFirstUpperRestLower = true // 三個旗標用於判斷三種情況\n→ Decision: 循環遍歷每個字元 i 從 0 到 length-1 // 逐一檢查每個字元\n    → Step 4: char = word[i] // 取得第 i 個字元\n    → Decision: i == 0? // 是否為第一個字元\n        Yes → Decision: char 是否為大寫? // 判斷第一個字元是否大寫\n            Yes → Step 5: isAllLower = false // 第一個大寫，取消全小寫判斷\n            No  → Step 6: isAllUpper = false; isFirstUpperRestLower = false // 第一個不是大寫，取消全大寫和首字母大寫其餘小寫判斷\n        No  → Decision: char 是否為大寫? // 判斷後續字元是否為大寫\n            Yes → Step 7: isAllLower = false; isFirstUpperRestLower = false // 後續大寫，取消全小寫和首字母大寫其餘小寫判斷\n            No  → Step 8: isAllUpper = false // 小寫，取消全大寫判斷\n→ Decision: (isAllUpper OR isAllLower OR isFirstUpperRestLower)? // 檢查三個旗標是否有一個為真\n    Yes → Step 9: return true // 任一規則成立，返回真\n    No  → Step 10: return false // 無規則成立，返回假\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def detectCapitalUse(self, word: str) -> bool:\n        \"\"\"\n        判斷大小寫使用是否正確。\n        1. 全部大寫： word.isupper()\n        2. 全部小寫： word.islower()\n        3. 首字母大寫其餘小寫： word.istitle()\n        \"\"\"\n        return word.isupper() or word.islower() or word.istitle()\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取字串，處理可能的雙引號包裹，\n    呼叫 Solution.detectCapitalUse，並將結果以小寫字串輸出。\n    \"\"\"\n    # 讀取所有輸入並去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        # 若無輸入，直接退出\n        return\n\n    # 若輸入被雙引號包裹（例如: \"USA\"），則移除外部引號\n    if raw_input[0] == '\"' and raw_input[-1] == '\"':\n        word = raw_input[1:-1]\n    else:\n        word = raw_input\n\n    sol = Solution()\n    result = sol.detectCapitalUse(word)\n    # 將布林值轉為小寫字串輸出\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"USA\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"FlaG\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode171.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Number",
    "description_snippet": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Chinese. Each line: virtual step + space + comment. Use arrow and structure. Steps: Start, input columnTitle string, initialize result=0, iterate over each character, compute value=char-'A'+1, result=result*26+value, after loop, return result, End.\n\nInclude decisions? Not needed. Just loop. Use \"→\" arrow. Format: \"Start // 程式開始執行\" then \"→ Step 1: 接收 columnTitle // 取得輸入字串\" etc. Use Chinese comments. Ensure each line includes code step then space then comment. Use \"Step 1:\", \"Step 2:\" etc. Use \"→\" arrow after Start. For loop, maybe \"→ Step 3: 對於字串中每個字元進行迴圈 // 逐個處理\". Inside loop: compute value. Use \"Step 4: 計算字元數值 // 'A'->1\". Use \"Step 5: 更新結果 // result = result * 26 + value\". After loop: \"→ Step 6: 回傳結果 // 輸出最終列號\". \"End\". Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收 columnTitle // 取得輸入字串  \n→ Step 2: 初始化 result 為 0 // 用來累積最終列號  \n→ Step 3: 對 columnTitle 中的每個字元進行迴圈 // 逐個處理每個字元  \n   → Step 4: 計算字元數值 value = (當前字元 - 'A') + 1 // 例如 'A' -> 1, 'B' -> 2  \n   → Step 5: 更新結果 result = result * 26 + value // 依照 Excel 編碼規則累積  \n→ Step 6: 回傳 result // 輸出最終列號  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        \"\"\"\n        將 Excel 欄位標題轉換成對應的數字。\n        每個字母代表一個 26 進位數字，從 A 開始對應 1。\n        \"\"\"\n        result = 0\n        for char in columnTitle:\n            # ord('A') = 65，(65-65)+1 = 1，(66-65)+1 = 2 依此類推\n            result = result * 26 + (ord(char) - ord('A') + 1)\n        return result\n\ndef main():\n    # 讀取所有輸入\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 先嘗試從單引號中擷取字串\n    match = re.search(r\"'([^']*)'\", data)\n    if match:\n        columnTitle = match.group(1)\n    else:\n        # 若沒有單引號，直接嘗試去除空白、等號等文字\n        data = data.strip()\n        if data.startswith(\"columnTitle\"):\n            parts = data.split('=', 1)\n            columnTitle = parts[1].strip()\n        else:\n            columnTitle = data\n\n    sol = Solution()\n    print(sol.titleToNumber(columnTitle))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnTitle = 'A'",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "columnTitle = 'AB'",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 2,
          "input": "columnTitle = 'ZY'",
          "expected_output": "701",
          "success": true,
          "output": "701"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode39.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum",
    "description_snippet": "Given an array of distinct integers candidates and a target integer target, return a list of all uni...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the algorithm to find all unique combinations summing to target. Use backtracking recursion. Virtual code lines with explanation. Use Start, End, Decision, etc. Provide line by line.\n\nWe need to incorporate array of candidates. We need to return list of lists. Should include sorting to avoid duplicates? Since all distinct, we can sort to enforce order. Use index to iterate candidates, allow same candidate multiple times by not incrementing index in recursion for same candidate. Let's write:\n\nStart\n→ Step 1: Sort candidates ascending // to enable efficient pruning\n→ Step 2: Define result list // store combinations\n→ Step 3: Define backtrack(startIndex, currentCombination, currentSum) // recursion\n    → Decision: If currentSum equals target? // found valid combination\n        Yes → Step 4: Add copy of currentCombination to result // record\n        No  → Decision: If currentSum greater than target? // prune\n            Yes → Step 5: Return // sum exceeded, backtrack\n            No  → Step 6: For each i from startIndex to len(candidates)-1 // iterate options\n                → Step 7: Append candidates[i] to currentCombination // choose number\n                → Step 8: Add candidates[i] to currentSum // update sum\n                → Step 9: Call backtrack(i, currentCombination, currentSum) // allow same number\n                → Step 10: Remove last element from currentCombination // backtrack\n                → Step 11: Subtract candidates[i] from currentSum // restore sum\n→ Step 12: Call backtrack(0, empty list, 0) // start recursion\n→ Step 13: Return result // final output\nEnd\n\nWe need to output exactly virtual code with arrow syntax. Let's produce each line accordingly, with explanation. Ensure each line ends with comment // explanation.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: Sort candidates ascending // 以便後續剪枝與確保組合唯一性\n→ Step 2: Define result list // 存放所有符合條件的組合\n→ Step 3: Define backtrack(startIndex, currentCombination, currentSum) // 遞迴函式\n    → Decision: If currentSum equals target? // 檢查是否找到合法組合\n        Yes → Step 4: Add copy of currentCombination to result // 記錄結果\n        No  → Decision: If currentSum greater than target? // 過大則剪枝\n            Yes → Step 5: Return // 超過目標，回溯\n            No  → Step 6: For each i from startIndex to len(candidates)-1 // 循環選擇剩餘數字\n                → Step 7: Append candidates[i] to currentCombination // 選擇此數字\n                → Step 8: Add candidates[i] to currentSum // 更新累加和\n                → Step 9: Call backtrack(i, currentCombination, currentSum) // 允許重複選取\n                → Step 10: Remove last element from currentCombination // 回溯\n                → Step 11: Subtract candidates[i] from currentSum // 還原和\n→ Step 12: Call backtrack(0, empty list, 0) // 開始遞迴\n→ Step 13: Return result // 輸出所有組合\nEnd // 程式執行結束\n\nLet's output exactly that.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort candidates ascending // 以便後續剪枝與確保組合唯一性\n→ Step 2: Define result list // 存放所有符合條件的組合\n→ Step 3: Define backtrack(startIndex, currentCombination, currentSum) // 遞迴函式\n    → Decision: If currentSum equals target? // 檢查是否找到合法組合\n        Yes → Step 4: Add copy of currentCombination to result // 記錄結果\n        No  → Decision: If currentSum greater than target? // 過大則剪枝\n            Yes → Step 5: Return // 超過目標，回溯\n            No  → Step 6: For each i from startIndex to len(candidates)-1 // 循環選擇剩餘數字\n                → Step 7: Append candidates[i] to currentCombination // 選擇此數字\n                → Step 8: Add candidates[i] to currentSum // 更新累加和\n                → Step 9: Call backtrack(i, currentCombination, currentSum) // 允許重複選取\n                → Step 10: Remove last element from currentCombination // 回溯\n                → Step 11: Subtract candidates[i] from currentSum // 還原和\n→ Step 12: Call backtrack(0, empty list, 0) // 開始遞迴\n→ Step 13: Return result // 輸出所有組合\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def combinationSum(self, candidates, target):\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, total + candidates[i])\n                path.pop()\n\n        backtrack(0, [], 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 使用正則表達式提取 candidates 列表和 target 整數\n    match = re.search(r'candidates\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)', data)\n    if not match:\n        sys.exit(0)\n    candidates_str, target_str = match.group(1), match.group(2)\n    candidates = eval(candidates_str)\n    target = int(target_str)\n\n    result = Solution().combinationSum(candidates, target)\n    # 輸出時不帶空格，符合題目範例格式\n    print(json.dumps(result, separators=(',', ':')))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "success": true,
          "output": "[[2,2,3],[7]]"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "success": true,
          "output": "[[2,2,2,2],[2,3,3],[3,5]]"
        },
        {
          "example_index": 2,
          "input": "candidates = [2], target = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode525.json",
    "problem_index_in_file": 0,
    "title": "Contiguous Array",
    "description_snippet": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines for the algorithm. The algorithm: maximum length contiguous subarray with equal 0 and 1. Approach: convert 0 to -1, then find longest subarray with sum 0 using hashmap of first occurrence of cumulative sum. Steps: initialize map with 0:-1, cumSum=0, maxLen=0. Loop i from 0 to n-1: cumSum += (nums[i]==1?1:-1). If cumSum in map, len = i - map[cumSum], update maxLen. Else store map[cumSum]=i. After loop, return maxLen. Provide virtual code line by line with comments. Use Start, Decision, etc. We'll output steps: Start, Step 1, Step 2, etc. Use arrow symbol. For loops use Step, maybe Decision for map contains. Also end. Provide explanation each line. Use proper syntax: `→ Step 1: Initialize map with sum 0 at index -1` etc.\n\nMake sure each line has `虛擬碼步驟 [空格] // 解釋`. Use `→` arrow before each step except Start maybe? In sample, Start line has no arrow. We'll follow that.\n\nWe need to ensure each line includes the arrow if needed. For loops: we might have Step: For i in range(0, n) → ... but we can't have nested structure? We'll produce separate steps: Step 3: Iterate over indices of nums; inside each iteration we do step 4: Update cumSum; Step 5: Check if cumSum exists in map; Decision: Yes → compute length and update maxLen; No → record cumSum. Use indentation for decisions maybe? In sample, they indent after Decision. We'll use similar indentation.\n\nWe need to show End at the end. Provide explanation each line.\n\nLet's craft.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立字典 map，並將 sum 0 的第一次出現位置設為 -1 // 方便計算以 0 為起點的子陣列長度\n→ Step 2: 設定變數 cumSum = 0, maxLen = 0 // 累積和與最大長度初始值\n→ Step 3: For i from 0 to length(nums)-1 // 逐一遍歷陣列\n    → Step 4: cumSum += (nums[i] == 1 ? 1 : -1) // 將 1 視為 +1，0 視為 -1，更新累積和\n    → Decision: cumSum 是否已在 map 中? // 判斷此累積和是否已出現\n        Yes → Step 5: currentLen = i - map[cumSum] // 以第一次出現位置為起點，計算子陣列長度\n        Yes → Decision: currentLen > maxLen? // 若長度更長，更新最大長度\n            Yes → Step 6: maxLen = currentLen // 更新最大長度\n        No  → Step 7: map[cumSum] = i // 若累積和第一次出現，記錄位置\nEnd // 程式執行結束，maxLen 為答案\n```\n\nMake sure each line has arrow for step lines, but decisions also have indentation. Provide explanation. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 map，並將 sum 0 的第一次出現位置設為 -1 // 方便計算以 0 為起點的子陣列長度  \n→ Step 2: 設定變數 cumSum = 0, maxLen = 0 // 累積和與最大長度初始值  \n→ Step 3: For i from 0 to length(nums)-1 // 逐一遍歷陣列  \n  → Step 4: cumSum += (nums[i] == 1 ? 1 : -1) // 將 1 視為 +1，0 視為 -1，更新累積和  \n  → Decision: cumSum 是否已在 map 中? // 判斷此累積和是否已出現  \n    Yes → Step 5: currentLen = i - map[cumSum] // 以第一次出現位置為起點，計算子陣列長度  \n    Yes → Decision: currentLen > maxLen? // 若長度更長，更新最大長度  \n     Yes → Step 6: maxLen = currentLen // 更新最大長度  \n    No → Step 7: map[cumSum] = i // 若累積和第一次出現，記錄位置  \nEnd // 程式執行結束，maxLen 為答案",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaxLength(self, nums):\n        # 用字典紀錄累積和第一次出現的位置\n        count_map = {0: -1}\n        max_len = 0\n        count = 0\n        for i, num in enumerate(nums):\n            # 1 設為 +1，0 設為 -1\n            count += 1 if num == 1 else -1\n            if count in count_map:\n                max_len = max(max_len, i - count_map[count])\n            else:\n                count_map[count] = i\n        return max_len\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行文字，並解析成 Python list\n    data = sys.stdin.read().strip()\n    if data:\n        # 使用 ast.literal_eval 安全地解析字面量\n        nums = ast.literal_eval(data)\n        solution = Solution()\n        result = solution.findMaxLength(nums)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[0,1,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,1,1,1,1,1,0,0,0]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode207.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for checking if all courses can be finished given prerequisites array. Classic topological sort / cycle detection. Steps: build graph, indegree array, queue of zero indegree nodes, process, count visited, if visited==numCourses true else false. Or DFS detection. We'll produce steps.\n\nEnsure each line has \"虛擬碼步驟 // 解釋\". Use Start, Decision, End, arrows. Let's create:\n\nStart\n→ Step 1: 建立空鄰接表 graph[0..numCourses-1] // 初始化圖\n→ Step 2: 建立 indegree[0..numCourses-1] 為 0 // 初始化入度\n→ Step 3: 針對每個 [a,b] 在 prerequisites:\n    → Add a 到 graph[b] // 代表 b → a\n    → indegree[a]++ // a 的入度加 1\n→ Step 4: 建立 queue Q\n→ Step 5: 將所有 indegree[i]==0 的課程加入 Q // 可直接上課\n→ Step 6: 已完成課程 count = 0\n→ Decision: Q 是否為空? // 判斷是否還有課程可上\n    Yes → End // 若空且 count==numCourses? we will check\n    No  → Step 7: 取出 queue 頂點 v // 從 queue 取一門課\n        → Step 8: count++ // 記錄已完成\n        → Step 9: 對 graph[v] 中的每個 neighbour u:\n            → indegree[u]--\n            → Decision: indegree[u]==0?\n                Yes → Step 10: 將 u 加入 Q // 成為可上課\n                No  →  // do nothing\n        → Step 11: 跳回到 Decision: Q 是否為空?\n→ Decision: count == numCourses?\n    Yes → Step 12: Return true // 所有課程都能完成\n    No  → Step 13: Return false // 有課程無法完成\nEnd\n\nWe need to ensure each line with arrow. The Decision lines show arrow branches.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空鄰接表 graph[0..numCourses-1] // 初始化圖  \n→ Step 2: 建立 indegree[0..numCourses-1] 為 0 // 初始化入度  \n→ Step 3: 針對每個 [a,b] 在 prerequisites:  \n  → Add a 到 graph[b] // 代表 b → a  \n  → indegree[a]++ // a 的入度加 1  \n→ Step 4: 建立 queue Q // 用來存放入度為 0 的節點  \n→ Step 5: 將所有 indegree[i]==0 的課程加入 Q // 可直接上課  \n→ Step 6: 已完成課程 count = 0  \n→ Decision: Q 是否為空? // 判斷是否還有課程可上  \n  Yes → End // 若空則進入結束檢查  \n  No  → Step 7: 取出 queue 頂點 v // 從 queue 取一門課  \n    → Step 8: count++ // 記錄已完成  \n    → Step 9: 對 graph[v] 中的每個 neighbour u:  \n      → indegree[u]-- // 減少對應入度  \n      → Decision: indegree[u]==0? // 是否成為可上課課程  \n        Yes → Step 10: 將 u 加入 Q // 成為可上課  \n        No  →  // 無需處理  \n    → Step 11: 跳回到 Decision: Q 是否為空?  \n→ Decision: count == numCourses? // 所有課程是否都已完成  \n  Yes → Step 12: Return true // 所有課程都能完成  \n  No  → Step 13: Return false // 存在無法完成的課程  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses, prerequisites):\n        # 建立鄰接表與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 取入度為 0 的節點放入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        visited = 0\n\n        while queue:\n            node = queue.popleft()\n            visited += 1\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return visited == numCourses\n\ndef parse_input() -> tuple[int, list[list[int]]]:\n    \"\"\"\n    從標準輸入讀取並解析資料。\n    支援兩種常見格式：\n    1. 單行：'numCourses = 2, prerequisites = [[1,0]]'\n    2. 兩行：\n        2\n        [[1,0]]\n    \"\"\"\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return 0, []\n\n    lines = [line.strip() for line in raw.splitlines() if line.strip()]\n\n    # 若為兩行，直接解析\n    if len(lines) == 2:\n        # 第一行可能直接是數字或形如 numCourses = 2\n        if lines[0].isdigit():\n            numCourses = int(lines[0])\n        else:\n            numCourses = int(re.search(r'\\d+', lines[0]).group())\n        prerequisites = eval(lines[1])\n        return numCourses, prerequisites\n\n    # 單行輸入，使用正則表達式抽取\n    data = ' '.join(lines)\n    m = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    numCourses = int(m.group(1)) if m else 0\n\n    m2 = re.search(r'prerequisites\\s*=\\s*(\\[\\[.*\\]\\])', data, re.DOTALL)\n    prereqs_str = m2.group(1) if m2 else '[]'\n    prerequisites = eval(prereqs_str)\n\n    return numCourses, prerequisites\n\nif __name__ == \"__main__\":\n    numCourses, prerequisites = parse_input()\n    result = Solution().canFinish(numCourses, prerequisites)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode459.json",
    "problem_index_in_file": 0,
    "title": "Repeated Substring Pattern",
    "description_snippet": "Given a string s, check if it can be constructed by taking a substring of it and appending multiple ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps. Use Start, Decision, etc. Provide line-by-line virtual code with comment. Must not output actual code. Provide algorithm: find length L, find smallest period. Approach: iterate substring length from 1 to n/2, if n%len==0 and repeated substring equals original. Or compute using LPS from KMP. We'll produce steps using loop and decision.\n\nUse Start, End, Decision, etc.\n\nLet's create steps:\n\nStart\n→ Step 1: Let n = length of s // get length\n→ Step 2: If n <=1: return False // single char cannot be formed by repeating\n→ Decision: For i from 1 to n/2 // iterate candidate substring length\n    → Step: If n mod i != 0: Continue // length not divisor\n    → Step: Let sub = s[0:i] // candidate\n    → Step: Let repeated = sub repeated n/i times // construct repeated string\n    → Decision: If repeated equals s\n        Yes → Step: Return True // found\n        No → Continue // try next\n→ Step: Return False // no valid substring found\nEnd\n\nBut need virtual code style: Use arrows. Provide \"Step 1:\" etc. Each line with comment. Provide indentation? Provide arrow lines.\n\nLet's craft accordingly. Use \"→\" for each step. Indent decisions inside.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n = length of s // 取得字串長度  \n→ Step 2: If n <= 1: Return False // 只有 1 個字元無法重複組成  \n→ Decision: For i = 1 to floor(n/2) // 逐一檢查可能的子字串長度  \n  Yes → Step 3: If n mod i ≠ 0: Continue // 長度不是 n 的因數，跳過  \n  Yes → Step 4: Let sub = first i characters of s // 取子字串  \n  Yes → Step 5: Let repeated = sub repeated (n / i) times // 重複子字串  \n  Decision: If repeated equals s  \n   Yes → Step 6: Return True // 找到可重複組成的子字串  \n   No → Continue // 仍嘗試下一個 i  \n→ Step 7: Return False // 所有候選都失敗，無法構造  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        \"\"\"Return True if s can be constructed by repeating a substring.\"\"\"\n        n = len(s)\n        # A single character cannot form a repeat pattern.\n        if n <= 1:\n            return False\n        # Check all possible substring lengths up to n//2.\n        for i in range(1, n // 2 + 1):\n            if n % i == 0:\n                if s[:i] * (n // i) == s:\n                    return True\n        return False\n\ndef parse_input(raw: str) -> str:\n    \"\"\"Extract the string value from the raw input.\"\"\"\n    raw = raw.strip()\n    # Handle optional leading `s = `.\n    if raw.lower().startswith('s ='):\n        raw = raw[3:].strip()\n    # Remove surrounding quotes if present.\n    if len(raw) >= 2 and raw[0] == '\"' and raw[-1] == '\"':\n        raw = raw[1:-1]\n    return raw\n\nif __name__ == \"__main__\":\n    # Read entire stdin.\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    sol = Solution()\n    result = sol.repeatedSubstringPattern(s)\n    # Output lowercase 'true' or 'false'.\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"abcabcabcabc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode528.json",
    "problem_index_in_file": 0,
    "title": "Random Pick with Weight",
    "description_snippet": "You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith in...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate pseudo-code for the algorithm. We must use the specified format: each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use arrows (→) and Decision: etc. Include Start, End. Should not output actual code, only virtual steps. Must handle initialization and pickIndex logic. We need to explain each step briefly. Use virtual code lines: Start, Build prefix sum array, total weight, random generation, binary search or linear search. Provide decision steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 w // 取得權重數組\n→ Step 2: 初始化前綴和陣列 prefix = 空列表 // 用於存儲累積權重\n→ Step 3: 計算前綴和並存入 prefix // 方便後續查找\n    → Decision: 迴圈結束? // 當已處理完所有元素\n→ Step 4: 取得總重量 total = prefix最後一個值 // 總權重\n→ Step 5: pickIndex 函式\n    → Decision: 進入函式? // 呼叫 pickIndex 時\n        → Step 6: 產生隨機數 r 在 [1, total] 之間 // 用於選擇\n        → Step 7: 在 prefix 中尋找第一個大於等於 r 的索引 // Binary search\n            → Decision: 找到索引 idx? // 是否成功找到\n                → Yes → Step 8: 回傳 idx // 返回隨機選擇的索引\n                → No  → Step 9: 回傳 -1 // 索引未找到（理論上不會發生）\nEnd // 程式執行結束\n\nBut need arrow formatting: each line with \"→\". For Decision lines, show Yes → ... No → ... etc.\n\nLet's structure: For binary search decision, we can show two outcomes: idx found or not. For simplicity: Decision: 找到 idx? Yes → Step 8: 回傳 idx No → Step 9: 回傳 -1\n\nAlso for building prefix, we may use loop: Decision: i < len(w)? Yes → Step: add to prefix No → Step: exit loop. But keep concise.\n\nWe need to not output actual code. Provide pseudo steps only.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取權重陣列 w // 取得輸入的正整數列表  \n→ Step 2: 建立空前綴和陣列 prefix // 用於累計權重  \n→ Step 3: 設定累計變數 cumulative = 0 // 初始累計值  \n→ Decision: i < len(w)? // 是否還有元素可處理  \n    Yes → Step 4: cumulative = cumulative + w[i] // 加入當前權重  \n    Yes → Step 5: prefix.append(cumulative) // 儲存累計值  \n    Yes → Step 6: i = i + 1 // 移動至下一個元素  \n    No  → Step 7: totalWeight = cumulative // 最終總權重  \n→ End // 前綴和建構完成  \n\n→ Function pickIndex() // 定義隨機選取函式  \n    → Step 8: 產生隨機數 r 在 [1, totalWeight] 之間 // 隨機點  \n    → Step 9: 進行二分搜尋，尋找 prefix 中最小的 index idx 使 prefix[idx] >= r  \n        → Decision: 找到 idx? // 是否成功定位索引  \n            Yes → Step 10: 回傳 idx // 返回隨機選擇的索引  \n            No  → Step 11: 回傳 -1 // 失敗情況（理論上不會發生）  \n→ End // 函式結束  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"構造前綴和陣列，方便後續查找。\"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"隨機產生 1~total 之間的整數，並用二分搜尋定位對應索引。\"\"\"\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入：先找第一個 '],' 作為 ops 與 args 的分隔\n    split_idx = data.find('],')\n    ops_str = data[:split_idx + 1].strip()\n    args_str = data[split_idx + 2:].strip()\n\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0])   # arg 為 [[1]] 的形式\n            results.append(None)     # 建構子不回傳值，輸出為 null\n        elif op == \"pickIndex\":\n            results.append(obj.pickIndex())\n\n    # 以 JSON 格式輸出，能正確顯示 null\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "success": true,
          "output": "[null, 0]"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,0,0,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 0, 0, 1, 1]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode394.json",
    "problem_index_in_file": 0,
    "title": "Decode String",
    "description_snippet": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: k[encoded_string], where ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for decoding string with repeats like \"3[a]2[bc]\". Use stack approach: iterate over chars. Use stack of pair (prevString, repeatCount). Actually we can maintain currentString and currentNum. When encounter digit, build number. When encounter '[', push currentString and currentNum onto stack, reset. When ']', pop previousString, repeatCount, set currentString = prevString + currentString*repeatCount. At end, return currentString. Also need to handle output length limit but not needed.\n\nWe need virtual code steps line by line with explanations. Use arrow style. Use Start, End, Decision, etc. Provide each line. Let's produce steps:\n\nStart // 程式開始\n→ Step 1: 初始化 stack, currentString = \"\", currentNum = 0 // 變數設定\n→ Step 2: 從左到右遍歷輸入字串 ch // 逐字解析\n    Decision: ch 是數字? // 判斷是否為重複次數\n        Yes → Step 3: currentNum = currentNum * 10 + (ch - '0') // 處理多位數\n        No → Decision: ch 是 '['? // 判斷是否為開括號\n            Yes → Step 4: 推入 stack (currentString, currentNum) // 暫存上一層\n                → Step 5: currentString = \"\" // 重置字串\n                → Step 6: currentNum = 0 // 重置數字\n            No → Decision: ch 是 ']'? // 判斷是否為關括號\n                Yes → Step 7: (prevString, repeatCount) = pop stack // 取回上一層\n                    → Step 8: currentString = prevString + currentString repeated repeatCount times // 拼接重複字串\n                No → Step 9: currentString = currentString + ch // 正常字元直接加入\n→ End // 回傳 currentString 作為結果\n\nBut need each line separate with arrow. Use \"→\" for sequential. Use Decision block with indentation.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 stack, currentString = \"\", currentNum = 0 // 建立儲存結構與變數  \n→ Step 2: 從左到右遍歷輸入字串 ch // 逐字解析整個字串  \n  Decision: ch 是數字? // 判斷目前字元是否為重複次數  \n   Yes → Step 3: currentNum = currentNum * 10 + (ch - '0') // 取得多位數的完整值  \n   No → Decision: ch 是 '['? // 判斷是否為開括號  \n    Yes → Step 4: 推入 stack (currentString, currentNum) // 暫存目前層級的字串與重複次數  \n     → Step 5: currentString = \"\" // 重置為新層級的字串  \n     → Step 6: currentNum = 0 // 重置重複次數  \n    No → Decision: ch 是 ']'? // 判斷是否為關括號  \n     Yes → Step 7: (prevString, repeatCount) = pop stack // 取回上一層的資料  \n      → Step 8: currentString = prevString + currentString repeated repeatCount times // 拼接重複字串  \n     No → Step 9: currentString = currentString + ch // 普通字元直接加入結果字串  \nEnd // 程式執行結束，回傳 currentString 作為解碼結果",
      "generated_code": "import sys\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        current_num = 0\n        current_str = ''\n        \n        for char in s:\n            if char.isdigit():\n                current_num = current_num * 10 + int(char)\n            elif char == '[':\n                stack.append((current_str, current_num))\n                current_str = ''\n                current_num = 0\n            elif char == ']':\n                last_str, num = stack.pop()\n                current_str = last_str + current_str * num\n            else:\n                current_str += char\n        return current_str\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the string value inside double quotes\n    start = data.find('\"')\n    end = data.rfind('\"')\n    if start == -1 or end == -1 or start == end:\n        s = data\n    else:\n        s = data[start + 1:end]\n    \n    solution = Solution()\n    decoded = solution.decodeString(s)\n    # Print with surrounding double quotes as per the examples\n    print(f'\"{decoded}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3[a]2[bc]\"",
          "expected_output": "\"aaabcbc\"",
          "success": true,
          "output": "\"aaabcbc\""
        },
        {
          "example_index": 1,
          "input": "s = \"3[a2[c]]\"",
          "expected_output": "\"accaccacc\"",
          "success": true,
          "output": "\"accaccacc\""
        },
        {
          "example_index": 2,
          "input": "s = \"2[abc]3[cd]ef\"",
          "expected_output": "\"abcabccdcdcdef\"",
          "success": true,
          "output": "\"abcabccdcdcdef\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode191.json",
    "problem_index_in_file": 0,
    "title": "Number of 1 Bits",
    "description_snippet": "Given a positive integer n, write a function that returns the number of set bits in its binary repre...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanations. Start, step, decision, etc. Function that counts set bits. Approach: while n > 0, count += n & 1, n >>=1. End.\n\nWe should provide virtual code lines, each with explanation. Format:\n\nStart // 程式開始執行\n→ Function CountSetBits(n) // 定義計算設置位數的函式\n    // We can include variable count = 0\n    → Step 1: count = 0 // 初始化計數\n    → Decision: 如果 n == 0? // 判斷是否結束迴圈\n        Yes → Return count // 若 n 為 0，直接回傳\n        No → // 進入循環\n    → Step 2: count = count + (n & 1) // 取得最低位\n    → Step 3: n = n >> 1 // 右移一位\n    → Go back to Decision\nEnd // 程式執行結束\n\nBut we need to show loop; we can use Decision: while n > 0? Or we can use while loop: Decision: n > 0? Yes → do Step 2,3 then loop back. But the format is arrow and decisions; we can use decision loop.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Function CountSetBits(n) // 定義函式\n    → Step 1: count = 0 // 設定計數器\n    → Decision: n == 0? // 是否已無位數？\n        Yes → Return count // 回傳計數\n        No  → // 進入迴圈\n    → Step 2: count = count + (n & 1) // 加上最低位的 1\n    → Step 3: n = n >> 1 // 右移一位，去掉已處理的位\n    → Go back to Decision\nEnd // 程式結束\n\nBut we need \"→\" arrow. Each line should start with \"→\" except start? Format sample: \"Start //\". Next lines start with \"→\". Use indentation maybe with spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function CountSetBits(n) // 定義計算 Hamming weight 的函式  \n    → Step 1: count = 0 // 初始化位數計數器  \n    → Decision: n == 0? // 檢查是否已無位數可處理  \n        Yes → Return count // 若 n 為 0，直接回傳計數  \n        No  → // 繼續處理剩餘位  \n    → Step 2: count = count + (n & 1) // 取得最低位是否為 1，並累加  \n    → Step 3: n = n >> 1 // 將 n 右移一位，去除已處理的最低位  \n    → Go back to Decision // 重新檢查 n 是否為 0  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef hamming_weight(n: int) -> int:\n    \"\"\"Return the number of set bits (1s) in the binary representation of n.\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，允許格式如 \"n = 11\"、\"n=128\" 或僅為數字\n    raw_input = sys.stdin.read()\n    # 使用正則表達式抓取第一個整數\n    match = re.search(r\"(-?\\d+)\", raw_input)\n    if not match:\n        print(\"0\")\n    else:\n        n = int(match.group(1))\n        print(hamming_weight(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 128",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2147483645",
          "expected_output": "30",
          "success": true,
          "output": "30"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1337.json",
    "problem_index_in_file": 0,
    "title": "The K Weakest Rows in a Matrix",
    "description_snippet": "You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civili...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line, with explanation comments, following format. Must not output actual code. Provide steps to solve problem: find k weakest rows. Steps: iterate rows, count soldiers per row (using binary property: find first zero or binary search). Store (count, index). Sort by count ascending, index ascending. Return first k indices. Use virtual code style with Start, Decision, etc. Each line with \"虛擬碼步驟 // 解釋\". Use arrow. Let's create sequence:\n\nStart\n→ Step 1: Initialize empty list rowsInfo\n→ Decision: 是否有矩陣行? Actually we will loop for each row i\n→ Loop i from 0 to m-1:\n    → Step 2: count = 0\n    → Step 3: j = 0\n    → Decision: j < n? // loop through row\n        Yes → Decision: mat[i][j] == 1? // count soldiers\n            Yes → Step 4: count = count + 1\n            No  → Step 5: Break // all remaining are civilians due to property\n        No  → Step 6: Continue\n    → Step 7: Append (count, i) to rowsInfo\n→ Step 8: Sort rowsInfo by count ascending, then index ascending\n→ Step 9: result = empty list\n→ Step 10: Loop t from 0 to k-1:\n        → Step 11: Append rowsInfo[t].index to result\n→ End // 返回結果\n\nNeed to use proper virtual code with arrow lines and decisions. Provide explanation after each line. Use format: 虛擬碼步驟 // 解釋. Let's produce lines.\n\nLet's count lines: each step a line. Must maintain indentation maybe.\n\nWe'll produce lines as:\n\nStart // 程式開始執行\n→ Step 1: rowsInfo ← [] // 建立空列表儲存 (soldierCount, rowIndex)\n→ Decision: 需要遍歷每一行嗎? // 確保有行可以處理\n    Yes → Loop i from 0 to m-1 // 逐行遍歷矩陣\n        → Step 2: count ← 0 // 初始化本行士兵數\n        → Step 3: j ← 0 // 列索引\n        → Decision: j < n? // 檢查列範圍\n            Yes → Decision: mat[i][j] == 1? // 判斷是否為士兵\n                Yes → Step 4: count ← count + 1 // 計算士兵\n                No  → Step 5: Break // 之後全為平民，可終止內層循環\n            No  → Step 6: Continue // 完成內層循環\n        → Step 7: rowsInfo.append((count, i)) // 把本行資料加入列表\n→ Step 8: rowsInfo.sort(key = (soldierCount, rowIndex)) // 依士兵數、行號排序\n→ Step 9: result ← [] // 儲存弱行索引\n→ Loop t from 0 to k-1 // 取前 k 個弱行\n    → Step 10: result.append(rowsInfo[t].rowIndex) // 加入索引\n→ End // 程式執行結束並返回 result\n\nBut we need to use arrow '→' for each line. For decisions we show Yes → etc. Provide line for each step. For loops, maybe we use '→ Loop ...' then indentation for inside lines. Format example earlier uses indentation. Let's follow that. Provide lines with indentation via spaces before arrow maybe.\n\nWe need to keep each line with \"虛擬碼步驟\" followed by // 解釋. For decision lines we use 'Decision:' etc. Example given.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: rowsInfo ← [] // 建立空列表儲存 (soldierCount, rowIndex)  \n→ Decision: 需要遍歷每一行嗎? // 檢查是否存在行  \n    Yes → Loop i from 0 to m-1 // 逐行遍歷矩陣  \n        → Step 2: count ← 0 // 初始化本行士兵數  \n        → Step 3: j ← 0 // 列索引  \n        → Decision: j < n? // 檢查列範圍  \n            Yes → Decision: mat[i][j] == 1? // 判斷是否為士兵  \n                Yes → Step 4: count ← count + 1 // 計算士兵  \n                No  → Step 5: Break // 之後全為平民，可終止內層循環  \n            No  → Step 6: Continue // 完成內層循環  \n        → Step 7: rowsInfo.append((count, i)) // 把本行資料加入列表  \n→ Step 8: rowsInfo.sort(key = (soldierCount, rowIndex)) // 依士兵數、行號排序  \n→ Step 9: result ← [] // 儲存弱行索引  \n→ Loop t from 0 to k-1 // 取前 k 個弱行  \n    → Step 10: result.append(rowsInfo[t].rowIndex) // 加入索引  \nEnd // 程式執行結束並返回 result",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef count_soldiers(row):\n    left, right = 0, len(row)\n    while left < right:\n        mid = (left + right) // 2\n        if row[mid] == 1:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef k_weakest_rows(mat, k):\n    soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n    soldiers.sort()\n    return [idx for _, idx in soldiers[:k]]\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    mat_match = re.search(r'mat\\s*=\\s*(\\[\\[.*?\\]\\])', data, re.S)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    mat = ast.literal_eval(mat_match.group(1)) if mat_match else []\n    k = int(k_match.group(1)) if k_match else 0\n    result = k_weakest_rows(mat, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "success": true,
          "output": "[2, 0, 3]"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "success": true,
          "output": "[0, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode753.json",
    "problem_index_in_file": 0,
    "title": "Cracking the Safe",
    "description_snippet": "There is a safe protected by a password. The password is a sequence of n digits where each digit can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve: generate a de Bruijn sequence of order n over alphabet size k. Need minimal length string that contains every possible sequence of length n. So algorithm: use de Bruijn sequence construction via recursive algorithm (preferably prefer to show DFS). Steps: Start, Build adjacency graph of k^(n-1) nodes, each node is (n-1)-length string. For each node, edge for each digit leads to new node formed by shift left + digit. Perform Eulerian circuit via Hierholzer. Build sequence. Append n-1 zeros prefix? For de Bruijn output, we generate the sequence of edges visited; start with n-1 zeros. Then append the digits from edges visited. Then append first n-1 digits to wrap around.\n\nLet's produce pseudo steps. Also explanation. Let's produce lines accordingly. Use Start, End, Decision. Use steps.\n\nWe'll produce lines like:\nStart // Begin algorithm\n→ Step 1: Create array nodes of size k^(n-1) // nodes represent (n-1)-digit strings\n→ Step 2: For each node, generate edges for digits 0..k-1 // adjacency\n→ Decision: if n==1? // special case handle\n... etc.\n\nWe can keep simple. Provide minimal length string: de Bruijn sequence length k^n + n -1.\n\nLet's produce pseudo code. Use stack for Hierholzer.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 若 n = 1，直接回傳「0..k-1 的所有數字按順序拼接」 // n=1 時所有單字串即為答案  \n→ Decision: n > 1? // 進入一般情況  \n  Yes → Step 2: 計算節點數 nodes = k^(n-1) // 每個節點代表 (n-1) 位元組串  \n  → Step 3: 建立空堆疊 stack，與結果串 result = \"\" // Hierholzer 演算法用  \n  → Step 4: 將起始節點 (n-1) 個零字串入 stack // 代表起始點  \n  → Decision: stack 是否非空?  \n    Yes → Step 5: 取 stack 顶部節點 cur = stack.top() // 目前所在節點  \n    → Step 6: 若 cur 還有未走完的出邊? // 每個節點有 k 條邊  \n      Yes → Step 7: 選一條未走邊，標記為已走，並將目標節點 push 到 stack // 深度優先  \n       → Step 8: 連續重複 Step 5-7 // 探索所有邊  \n      No → Step 9: 從 stack 弹出 cur，將 cur 對應的最後一個字元加入 result // 逆序收集邊  \n       → Step 10: 回到 Step 4 // 直到 stack 為空  \n    No → Step 11: result 現已包含所有邊的逆序字元，反轉得到順序序列  \n  → Step 12: 在 result 前加上 (n-1) 個 '0' // 開始節點的前綴  \n  → Step 13: 在 result 後加上 result 的前 (n-1) 個字元 // 形成循環結束  \n  → Step 14: 回傳 result // 最短長度為 k^n + n - 1 的序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef crack_safe(n: int, k: int) -> str:\n    seen = set()\n    res = []\n\n    def dfs(node: str):\n        for digit in map(str, range(k)):\n            nxt = node + digit\n            if nxt not in seen:\n                seen.add(nxt)\n                dfs(nxt[1:])\n                res.append(digit)\n\n    start = \"0\" * (n - 1)\n    dfs(start)\n    return \"\".join(res) + start\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) >= 2:\n        n, k = nums[0], nums[1]\n        answer = crack_safe(n, k)\n        print(answer)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "success": true,
          "output": "10"
        },
        {
          "example_index": 1,
          "input": "n = 2, k = 2",
          "expected_output": "\"01100\"",
          "success": true,
          "output": "01100"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode172.json",
    "problem_index_in_file": 0,
    "title": "Factorial Trailing Zeroes",
    "description_snippet": "Given an integer n, return the number of trailing zeroes in n!. \n\nNote that n! = n * (n - 1) * (n - ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need virtual code for counting trailing zeros in factorial. Standard algorithm: count factors of 5 in n. Sum n/5 + n/25 + n/125 + ... until n/5^k=0. Steps: input n, initialize count=0, divisor=5. While n/divisor>0: count += n/divisor; divisor *=5. Output count. Use virtual code syntax. Provide line by line with comments. Use Start, End, Decision. Probably a while loop.\n\nLet's create lines:\nStart\n→ Step 1: 讀取 n // 取得輸入整數\n→ Step 2: 初始化 count = 0, divisor = 5 // 設定計數與除數\n→ Decision: divisor ≤ n? // 檢查是否還有可除的 5\n    Yes → Step 3: count += n / divisor // 加入這次除以 divisor 的商\n    Yes → Step 4: divisor *= 5 // 更新除數為下一個 5 的冪\n    No  → Step 5: 輸出 count // 結束計算並輸出結果\nEnd\n\nBut we need loop structure: maybe use a while loop but we can express with Decision repeated.\n\nBetter:\n\nStart\n→ Step 1: 讀取 n\n→ Step 2: 初始化 count = 0, divisor = 5\n→ Decision: divisor ≤ n? \n    Yes → Step 3: count += n / divisor\n    Yes → Step 4: divisor *= 5\n    Yes → 回到 Decision\n    No → Step 5: 輸出 count\nEnd\n\nBut we must express the loop: We can show a while loop as Decision with Yes branch returning to itself.\n\nLet's write:\n\nStart\n→ Step 1: 讀取 n\n→ Step 2: 初始化 count = 0, divisor = 5\n→ Decision: divisor ≤ n? \n    Yes → Step 3: count += n / divisor\n    Yes → Step 4: divisor *= 5\n    Yes → 回到 Decision: divisor ≤ n?\n    No → Step 5: 輸出 count\nEnd\n\nBut the \"回到 Decision\" might be ambiguous. Use \"Yes → 回到 Decision\" is okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取 n // 從使用者或輸入取得整數 n\n→ Step 2: 初始化 count = 0, divisor = 5 // 設定計數器及初始 5 的冪\n→ Decision: divisor ≤ n? // 判斷是否還有可除的 5\n    Yes → Step 3: count += n / divisor // 加入 n 除以 divisor 的整數商\n    Yes → Step 4: divisor *= 5 // 更新 divisor 為下一個 5 的冪\n    Yes → 回到 Decision // 重新檢查 divisor 是否 ≤ n\n    No  → Step 5: 輸出 count // 輸出最終計算出的尾零數量\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef trailing_zeroes(n: int) -> int:\n    \"\"\"\n    計算 n! 的尾零數量。核心思想是計算 n 中因子 5 的總個數，\n    因為每 5 個 5 與 2 組成一個 10，產生一個尾零。\n    \"\"\"\n    count = 0\n    while n > 0:\n        n //= 5        # 只取除以 5 的商，等價於計算因子 5 的個數\n        count += n     # 將這一層的 5 的個數加入總計\n    return count\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有內容，並使用正則表達式提取第一個整數\n    data = sys.stdin.read()\n    match = re.search(r'(\\d+)', data)\n    n = int(match.group(1)) if match else 0\n\n    # 計算尾零並輸出結果\n    print(trailing_zeroes(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode720.json",
    "problem_index_in_file": 0,
    "title": "Longest Word in Dictionary",
    "description_snippet": "Given an array of strings words representing an English Dictionary, return the longest word in words...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step-by-step with explanations. Provide lines with arrow etc. Must follow format exactly. Let's craft algorithm: sort words by length ascending then lexicographic. Use set builtWords. Iterate. For each word, if length 1 then add if present else if previous prefix in set add. Keep track of longest. Use set of valid. At end output best. But need handle tie length lexicographically smallest.\n\nPseudo code structure: Start, sort words by length asc, lex. Build set. best = \"\". For each word: if length 1 OR prefix in set, add to set. If length > best length OR same length but lex smaller, update best. After loop, End.\n\nNeed to include decision arrows. Provide explanation comments. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort words by length ascending, then lexicographically ascending // 先把單字依長度與字典序排序，方便逐字判斷  \n→ Step 2: 建立空集合 validWords // 用來儲存已經符合建構條件的單字  \n→ Step 3: bestWord ← \"\" // 用來記錄目前最佳答案  \n→ Decision: 迭代每個 word in words? // 開始逐個處理每個單字  \n  Yes → Step 4: prefix ← word 的除最後一個字元之外的子字串 // 取得前一個階段的單字  \n  Decision: word 長度為 1 或 prefix 在 validWords? // 判斷能否被建立  \n   Yes → Step 5: validWords 加入 word // 把符合條件的單字加入集合  \n    Decision: word 長度 > bestWord 長度 OR (相等且 lexicographically 小於 bestWord)? // 檢查是否更新最佳答案  \n     Yes → Step 6: bestWord ← word // 更新最佳答案  \n     No → // 不更新  \n   No → // 不能被建立，跳過  \nEnd // 程式執行結束，最佳答案存於 bestWord（若為空字串表示無答案）",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def longestWord(self, words):\n        # 將單字放入集合，方便 O(1) 查詢\n        word_set = set(words)\n        best = \"\"\n        # 先按長度升序再字典序升序排序，方便逐個判斷\n        words.sort(key=lambda w: (len(w), w))\n        for word in words:\n            # 如果單字長度為 1 或者前綴已在集合中，才可以被構造\n            if len(word) == 1 or word[:-1] in word_set:\n                word_set.add(word)\n                # 更新最佳答案：長度較長，或長度相同但字典序較小\n                if len(word) > len(best) or (len(word) == len(best) and word < best):\n                    best = word\n        return best\n\ndef main():\n    # 從標準輸入讀取整個內容，假設為 Python list 的文字表示\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"\")\n        return\n    # 安全解析為 list\n    try:\n        words = ast.literal_eval(data)\n    except Exception:\n        # 若解析失敗，直接輸出空字串\n        print(\"\")\n        return\n    solution = Solution()\n    result = solution.longestWord(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"w\",\"wo\",\"wor\",\"worl\",\"world\"]",
          "expected_output": "world",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'world'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'world'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]",
          "expected_output": "apple",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'apple'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'apple'\nRaw Got:      ''"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode131.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanations. The problem: given a string s, find all palindrome partitions. So typical algorithm: backtracking DFS generating partitions. Use helper to check palindrome. We'll produce steps: Start, Input string, define result list, define helper function DFS(current index, path). Within DFS, if index==len, add path copy to result. Else for i from index+1 to len: substring s[index:i]; if palindrome, add to path, recurse DFS(i, path). Then backtrack.\n\nSo we need to output lines of virtual code with explanation. Use arrows and decision. Let's produce something like:\n\nStart // program start\n→ Step 1: Receive input string s // 获取字符串\n→ Decision: 若 s 为空? // check empty\n    Yes → Step 2: Return empty list // 若为空，返回空列表\n    No  → Step 3: Initialize result list res = [] // 初始化结果\n→ Step 4: 定义函数 is_palindrome(sub) // 判断子串是否回文\n→ Step 5: 定义递归函数 dfs(start, path) // 回溯\n    → Decision: 若 start == len(s)? // 已遍历完整字符串\n        Yes → Step 6: Append copy of path to res // 存储合法分割\n        No  → Step 7: 对 end in range(start+1, len(s)+1) // 逐个尝试结束位置\n            → Decision: 是否 s[start:end] 为回文? // 检查子串\n                Yes → Step 8: path.append(s[start:end]) // 加入当前子串\n                → Step 9: dfs(end, path) // 递归\n                → Step 10: path.pop() // 回溯移除\n    // End of dfs\n→ Step 11: 调用 dfs(0, []) // 开始回溯\n→ Step 12: 返回 res // 输出结果\nEnd // 程序结束\n\nMake sure each line includes \"虛擬碼步驟\" and comment. We'll use arrow \"→\" for sequential steps, and Decision lines with Yes → and No →.\n\nLet's write them.\n\nEnsure each line is like:\n\nStart // 程式開始執行\n\n→ Step 1: Receive input string s // 取得使用者輸入的字串\n\n→ Decision: 若 s 為空? // 檢查字串是否為空\n\n    Yes → Step 2: Return empty list // 若空，直接回傳空列表\n\n    No  → Step 3: Initialize result list res = [] // 初始化結果容器\n\n...\n\nAlso include definitions.\n\nWe'll format accordingly.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Receive input string s // 取得使用者輸入的字串  \n→ Decision: 若 s 為空? // 檢查字串是否為空  \n Yes → Step 2: Return empty list // 若空，直接回傳空列表  \n No  → Step 3: Initialize result list res = [] // 初始化結果容器  \n→ Step 4: 定義函式 is_palindrome(sub) // 檢查子字串是否為回文  \n → Step 5: 若 sub 讀取自右向左等於左向右? // 回文判斷  \n  Yes → Return true  \n  No  → Return false  \n→ Step 6: 定義遞歸函式 dfs(start, path) // 回溯搜尋所有分割  \n → Decision: 若 start == len(s)? // 已遍歷完整字串  \n  Yes → Step 7: Append copy of path to res // 存入一組合法分割  \n  No  → Step 8: 對 end 從 start+1 到 len(s) 做迴圈 // 嘗試不同結束位置  \n    → Decision: 是否 s[start:end] 為回文? // 檢查子字串  \n     Yes → Step 9: path.append(s[start:end]) // 加入當前子字串  \n      → Step 10: dfs(end, path) // 進行下一層遞歸  \n      → Step 11: path.pop() // 回溯移除剛才加入的子字串  \n     No  → Step 12: 繼續迴圈至下一個 end  \n→ Step 13: 呼叫 dfs(0, []) // 從字串起始處開始回溯  \n→ Step 14: Return res // 將所有回文分割結果回傳  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def partition(self, s: str):\n        res = []\n\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n\n        def dfs(start: int, path: list):\n            if start == len(s):\n                res.append(path[:])\n                return\n            for end in range(start + 1, len(s) + 1):\n                if is_palindrome(s[start:end]):\n                    dfs(end, path + [s[start:end]])\n\n        dfs(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the string inside double quotes after 's = '\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # If no quoted string, maybe the entire input is the string\n        s = data.strip('\"')\n    solution = Solution()\n    result = solution.partition(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
          "success": true,
          "output": "[['a', 'a', 'b'], ['aa', 'b']]"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[['a']]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode43.json",
    "problem_index_in_file": 0,
    "title": "Multiply Strings",
    "description_snippet": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, step-by-step, to multiply two big numbers represented as strings without using BigInteger or converting to integer. Standard approach: multiply each digit, accumulate, handle carry, produce string.\n\nWe need to produce steps: start, input, convert to arrays, nested loops, multiplication, carry, accumulate, build result string, output.\n\nWe must use virtual code arrow and decision. Provide line per step with explanation comment.\n\nLet's craft.\n\nLine 1: Start // program start\n\nLine 2: → Step 1: Read num1, num2 // input strings\n\nLine 3: → Decision: If either string is \"0\"? // check zero case\n\nLine 4: Yes → Step 2: Return \"0\" // if zero, product zero\n\nLine 5: No  → Step 3: Convert num1 and num2 to arrays of digits reversed // each char to int\n\nLine 6: → Step 4: Initialize result array of size len1+len2 with zeros // hold partial sums\n\nLine 7: → Step 5: For i from 0 to len1-1 // iterate digits of num1\n\nLine 8: → Step 6: For j from 0 to len2-1 // iterate digits of num2\n\nLine 9: → Step 7: Multiply digit1[i] * digit2[j] and add to result[i+j] // partial product\n\nLine 10: → Step 8: Carry over result[i+j] // propagate carry\n\nLine 11: → Step 9: Update result[i+j+1] += carry // add carry to next position\n\nLine 12: → Step 10: End inner loop\n\nLine 13: → Step 11: End outer loop\n\nLine 14: → Decision: Remove leading zeros from result array? // after multiplication\n\nLine 15: Yes → Step 12: Trim leading zeros // if any\n\nLine 16: No  → (none)\n\nLine 17: → Step 13: Build result string by iterating result array from most significant to least // convert to string\n\nLine 18: → Step 14: Return result string // output\n\nLine 19: End // program end\n\nWe must ensure each line includes \"虛擬碼步驟\" plus explanation comment.\n\nNeed to include arrow for decisions: Use \"Decision:\" and indent Yes/No.\n\nAlso need to indicate step numbers maybe but not required.\n\nWe need to ensure formatting: \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nSo for each line, produce e.g.:\n\nStart // 程式開始執行\n\n→ Step 1: Read num1, num2 // 取得輸入字串\n\n→ Decision: If either num1 == \"0\" or num2 == \"0\"? // 檢查是否有零\n\nYes → Step 2: Return \"0\" // 直接回傳零\n\nNo → Step 3: Convert strings to reversed digit arrays // 方便下標運算\n\n...\n\nLet's produce.\n\nWe must maintain arrow lines and indent.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 num1, num2 // 從使用者處取得兩個字串  \n→ Decision: 若 num1 == \"0\" 或 num2 == \"0\"? // 檢查是否有零  \n Yes → Step 2: 回傳 \"0\" // 任何一個為零時，乘積為零  \n No  → Step 3: 將 num1 與 num2 的每個字元轉成整數陣列，並倒序存入 arr1、arr2 // 方便下標運算  \n→ Step 4: 初始化結果陣列 result，長度為 len(arr1)+len(arr2)，全部設為 0 // 用來累加所有部分乘積  \n→ Step 5: 對 i 從 0 到 len(arr1)-1 迭代 // 逐位處理 num1  \n → Step 6: 對 j 從 0 到 len(arr2)-1 迭代 // 逐位處理 num2  \n  → Step 7: 乘積 temp = arr1[i] * arr2[j]，並加到 result[i+j] // 加入對應位置的部分乘積  \n  → Step 8: carry = result[i+j] / 10 // 計算進位  \n  → Step 9: result[i+j] = result[i+j] % 10 // 將位置值留為 0-9  \n  → Step 10: result[i+j+1] += carry // 將進位加入下一位  \n → Step 11: 內層迴圈結束  \n→ Step 12: 外層迴圈結束  \n→ Decision: 是否需要移除結果陣列最前面的 0? // 乘積可能有多餘的高位 0  \n Yes → Step 13: 逐步刪除 result 最前面 0，直到第一個非 0 或只剩一個數字 // 清除多餘高位  \n No  → // 無需刪除  \n→ Step 14: 建立字串 answer，從 result 最後索引到 0 逐位加入字符 // 轉為最終輸出字串  \n→ Step 15: 回傳 answer // 輸出乘積字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"Multiply two non‑negative integers represented as strings without using int conversion.\"\"\"\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        m, n = len(num1), len(num2)\n        # Result can have at most m + n digits\n        pos = [0] * (m + n)\n\n        # Iterate over each digit from the end (least significant)\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n                sum_ = mul + pos[p2]\n\n                pos[p1] += sum_ // 10\n                pos[p2] = sum_ % 10\n\n        # Convert digit list to string, stripping leading zeros\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result or '0'\n\ndef parse_input(text: str):\n    \"\"\"\n    Extract two numbers from the input text.\n    Supports formats like:\n      num1 = '2', num2 = '3'\n    or simply:\n      123 456\n    \"\"\"\n    # Try to find numbers inside single quotes\n    quotes = re.findall(r\"'(\\d+)'\", text)\n    if len(quotes) >= 2:\n        return quotes[0], quotes[1]\n\n    # Fallback: split by whitespace or commas\n    parts = re.split(r\"[,\\s]+\", text.strip())\n    parts = [p for p in parts if p]\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    raise ValueError(\"Invalid input format\")\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    try:\n        num1, num2 = parse_input(raw_input)\n    except ValueError:\n        sys.exit(1)\n\n    sol = Solution()\n    product = sol.multiply(num1, num2)\n    print(product)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "success": true,
          "output": "56088"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode539.json",
    "problem_index_in_file": 0,
    "title": "Minimum Time Difference",
    "description_snippet": "Given a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference b...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for given problem: find min minutes difference between any two time points in a list of HH:MM strings. Virtual code must be step by step, with explanation comments.\n\nWe must not output real code, only steps with arrows etc. Steps: Start, read input list, convert each time string to minutes since midnight, sort, compute differences between adjacent sorted times including circular difference between last and first + 24*60. Keep min. Output min. End.\n\nNeed to use decision structure for comparisons. Provide virtual code lines.\n\nLet's produce a sequence:\n\nStart\n→ Step 1: Read list of time strings // input\n→ Step 2: For each time string, split into hours and minutes, convert to total minutes // convert\n→ Step 3: Store minutes in array // array\n→ Step 4: Sort array ascending // sorted times\n→ Step 5: Initialize minDiff = large // min difference\n→ Step 6: For i from 0 to n-2: // iterate adjacent pairs\n    → Decision: Compute diff = sorted[i+1] - sorted[i] // difference\n    → Decision: If diff < minDiff?\n        Yes → Step 7: minDiff = diff // update min\n        No  → // do nothing\n→ Step 8: Compute circular diff = (sorted[0] + 1440) - sorted[last] // wrap-around\n→ Decision: If circular diff < minDiff?\n    Yes → Step 9: minDiff = circular diff\n    No  → // no change\n→ Step 10: Return minDiff // output\nEnd\n\nNeed to format with arrow lines: Start // ...\n→ Step 1: ...\nUse indentation for decisions with Yes→, No→.\n\nLet's output each line.\n\nEnsure each line has virtual code + space + // explanation.\n\nUse arrow for start: Start // 程式開始執行\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取時間字串列表 // 取得使用者輸入的 \"HH:MM\" 時間點清單  \n→ Step 2: 對每個時間字串  \n  → Step 2a: 分割字串成小時與分鐘  \n  → Step 2b: 轉換為自午夜以來的總分鐘數  \n  → Step 2c: 將計算出的分鐘數存入陣列 // 建立時間的分鐘表示  \n→ Step 3: 對分鐘陣列進行遞增排序 // 方便計算相鄰時間差  \n→ Step 4: 初始化 minDiff 為無限大 // 用來保存最小時間差  \n→ Step 5: 從 0 到 n-2 迭代索引 i  \n  → Decision: 計算 diff = sorted[i+1] - sorted[i] // 相鄰兩個時間的差值  \n    Yes → Step 6: 若 diff < minDiff, 將 minDiff 更新為 diff // 更新最小差  \n    No  → // 不做任何變更  \n→ Step 7: 計算週期性差值 circDiff = (sorted[0] + 1440) - sorted[last] // 從最後到第一個的跨日差  \n→ Decision: 若 circDiff < minDiff  \n  Yes → Step 8: minDiff = circDiff // 若週期差更小，更新  \n  No  → // 不變更 minDiff  \n→ Step 9: 回傳 minDiff // 輸出最小分鐘差值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_min_difference(time_points):\n    # 將每個時間字串轉成自午夜以來的總分鐘數\n    minutes = []\n    for t in time_points:\n        h, m = map(int, t.split(':'))\n        minutes.append(h * 60 + m)\n\n    # 先排序，方便計算相鄰時間差\n    minutes.sort()\n\n    # 初始化為一天的最大分鐘數\n    min_diff = 1440\n\n    # 計算相鄰兩個時間的差值，尋找最小值\n    for i in range(1, len(minutes)):\n        diff = minutes[i] - minutes[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n\n    # 考慮最後一個和第一個之間的跨日差\n    circ_diff = 1440 - (minutes[-1] - minutes[0])\n    if circ_diff < min_diff:\n        min_diff = circ_diff\n\n    return min_diff\n\ndef main():\n    # 從標準輸入讀取完整資料（如: '[\"23:59\",\"00:00\"]'）\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 解析為列表\n    time_points = ast.literal_eval(raw_input)\n    # 計算結果並輸出\n    result = find_min_difference(time_points)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"23:59\",\"00:00\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "[\"00:00\",\"23:59\",\"00:00\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode665.json",
    "problem_index_in_file": 0,
    "title": "Non-decreasing Array",
    "description_snippet": "Given an array nums with n integers, your task is to check if it could become non-decreasing by modi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for checking if an array can become non-decreasing by modifying at most one element. This is classic LeetCode 665. Steps: count violations, if >1 return false. For each violation, check if modifying nums[i] or nums[i+1] would fix. The algorithm: iterate, track count, if violation at i, if i-1 <0 or nums[i-1] <= nums[i+1], then modify nums[i], else if i+2 >=n or nums[i] <= nums[i+2], modify nums[i+1]. If cannot modify, return false. At end true.\n\nBut produce virtual code line by line. Use arrows and decisions. Must not output actual code but virtual steps. Provide explanation after each line.\n\nWe need to produce in Traditional Chinese. Steps like:\n\nStart // 程式開始\n→ Step 1: 讀取陣列 nums 和長度 n // 獲取輸入\n→ Step 2: 初始化違規次數 count 為 0 // 記錄違規次數\n→ Decision: 遍歷陣列 i 從 0 到 n-2? // 開始迭代\n    Yes → Step 3: 如果 nums[i] > nums[i+1]? // 檢查是否違規\n        Yes → Step 4: count 加 1 // 記錄違規\n        Yes → Decision: count > 1? // 超過一次?\n            Yes → Step 5: 返回 false // 不能只改一次\n            No  → Decision: i-1 < 0 或 nums[i-1] <= nums[i+1]? // 檢查修改 nums[i] 是否可行\n                Yes → Step 6: 將 nums[i] 設為 nums[i+1] // 模擬修改\n                No  → Decision: i+2 >= n 或 nums[i] <= nums[i+2]? // 檢查修改 nums[i+1] 是否可行\n                    Yes → Step 7: 將 nums[i+1] 設為 nums[i] // 模擬修改\n                    No  → Step 8: 返回 false // 兩種都不可行\n        No  → No action // 當前無違規，繼續\n→ Decision: 迴圈結束? // 所有元素已檢查\n    Yes → Step 9: 返回 true // 只需改 0 或 1 次即可\nEnd // 程式結束\n\nWe need to follow arrow syntax: Start, End. Decision lines must start with \"Decision:\" and then conditions. Indentation for nested. Provide Chinese comments.\n\nLet's craft output accordingly. Ensure no actual code. Use \"→\" for steps and \"→ Decision:\" lines. Also include \"Yes →\" and \"No →\" for decisions.\n\nBe careful formatting: each line: virtual code step + space + // explanation. The code step includes arrow, step, etc.\n\nWe must ensure indentation: use 4 spaces? The example shows 4 spaces indentation for sub-steps. We'll mimic.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取陣列 nums 與長度 n // 取得輸入資料  \n→ Step 2: 初始化違規次數 count 為 0 // 用於統計不遞增的個數  \n→ Decision: i 從 0 迭代到 n-2? // 開始逐個檢查相鄰元素  \n    Yes → Step 3: 如果 nums[i] > nums[i+1]? // 檢查是否違反非遞減條件  \n        Yes → Step 4: count 加 1 // 記錄一次違規  \n        Yes → Decision: count > 1? // 已超過一次違規  \n            Yes → Step 5: 回傳 false // 無法只改一次即可  \n            No  → Decision: i-1 < 0 或 nums[i-1] <= nums[i+1]? // 檢查改 nums[i] 是否可行  \n                Yes → Step 6: 把 nums[i] 設為 nums[i+1] // 模擬修改以消除違規  \n                No  → Decision: i+2 >= n 或 nums[i] <= nums[i+2]? // 檢查改 nums[i+1] 是否可行  \n                    Yes → Step 7: 把 nums[i+1] 設為 nums[i] // 模擬修改以消除違規  \n                    No  → Step 8: 回傳 false // 兩種修改都無法修正  \n        No  → No action // 當前沒有違規，繼續迴圈  \n→ Decision: 迴圈結束? // 已檢查完所有相鄰對  \n    Yes → Step 9: 回傳 true // 只需改 0 或 1 次即可得到非遞減陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def checkPossibility(self, nums):\n        \"\"\"Check if the array can become non‑decreasing by modifying at most one element.\"\"\"\n        count = 0\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                count += 1\n                if count > 1:\n                    return False\n                # Try modifying the previous element if it fixes the issue\n                if i == 1 or nums[i] >= nums[i - 2]:\n                    nums[i - 1] = nums[i]\n                else:\n                    # Otherwise modify the current element\n                    nums[i] = nums[i - 1]\n        return True\n\ndef main():\n    # Read the whole input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list of numbers from input like \"nums = [4,2,3]\"\n    if \"=\" in data:\n        try:\n            nums_part = data.split(\"=\", 1)[1].strip()\n            nums = eval(nums_part, {\"__builtins__\": None}, {})\n        except Exception:\n            print(\"false\")\n            return\n    else:\n        try:\n            nums = eval(data, {\"__builtins__\": None}, {})\n        except Exception:\n            print(\"false\")\n            return\n\n    # Ensure we have a list of integers\n    if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums):\n        print(\"false\")\n        return\n\n    solution = Solution()\n    result = solution.checkPossibility(nums)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,2,3]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [4,2,1]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode446.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices II - Subsequence",
    "description_snippet": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\n\nA sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem: count all arithmetic subsequences of length >=3. Classic solution uses DP with hash maps for differences. We'll produce algorithm steps in pseudo-steps with explanations. The user wants line-by-line virtual code. Use Start, End, Decision, arrows. We'll produce steps: Input array, initialize dp array of maps, total=0, iterate over i, j, compute diff, get count of subsequences ending at j with same diff, update dp[i][diff], add to total. Also update dp[i][diff] by adding count + 1. After loops, output total. We'll use 0-based indexing. Also use \"Int\" but not actual code.\n\nLet's produce. Use virtual code lines. For each step include explanation. Use arrows for nesting. Eg:\n\nStart\n→ Step 1: Read array nums // etc\n→ Step 2: Initialize dp as list of empty maps // etc\n→ Step 3: Set total = 0\n→ Decision: If nums length < 3? // check early\n    Yes → End // no subsequences\n    No → Loop i from 0 to n-1\n        → Loop j from 0 to i-1\n            → Step 4: diff = nums[i] - nums[j] // difference\n            → Step 5: count_j = dp[j][diff] // subseq ending at j with diff\n            → Step 6: total += count_j // add new sequences of length >=3\n            → Step 7: dp[i][diff] += count_j + 1 // update map with new sequences length >=2\n        → End Loop j\n    → End Loop i\n→ Step 8: Output total // number of arithmetic subsequences\nEnd\n\nNeed to be careful: diff might be large; use map key as diff. Use map. Provide explanation.\n\nAdd steps for initializing map entry: if not exists set 0. In virtual code: dp[i][diff] = dp[i].get(diff,0) + count_j +1. But we can split into steps: get existing count_i = dp[i][diff], update newCount = count_j + 1 + existing? Actually we should add to dp[i][diff] = existing + count_j +1. Let's do step: existing_i = dp[i][diff]; dp[i][diff] = existing_i + count_j +1.\n\nLet's produce step lines accordingly.\n\nWe'll produce each line with comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數陣列 nums // 從輸入取得待處理的數字序列  \n→ Step 2: 建立 dp 為長度為 n 的空字典陣列 // dp[i] 會儲存以 nums[i] 結束且具有相同差值的子序列數量  \n→ Step 3: total ← 0 // 用來累計長度 ≥ 3 的算術子序列個數  \n→ Decision: 若 nums 長度 < 3? // 只有長度不足 3 的情況無算術子序列  \n  Yes → End // 直接結束，輸出 0  \n  No → Loop i 由 0 到 n-1  \n    → Loop j 由 0 到 i-1  \n      → Step 4: diff ← nums[i] - nums[j] // 計算兩個位置之間的差值  \n      → Step 5: count_j ← dp[j].get(diff, 0) // 取得以 nums[j] 結束且差值為 diff 的子序列數量  \n      → Step 6: total ← total + count_j // 每個此類子序列再加上一個 nums[i] 就形成長度 ≥ 3 的算術子序列  \n      → Step 7: existing_i ← dp[i].get(diff, 0) // 取得目前以 nums[i] 結束且差值為 diff 的子序列數量  \n      → Step 8: dp[i][diff] ← existing_i + count_j + 1 // 更新 dp[i][diff]：  \n        （1）已有的子序列保持不變；  \n        （2）count_j 個子序列延長至 nums[i]；  \n        （3）另外一個長度為 2 的子序列 (nums[j], nums[i]) 加入。  \n      → End Loop j  \n    → End Loop i  \n→ Step 9: 輸出 total // 返回所有長度至少三的算術子序列數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums):\n        n = len(nums)\n        dp = [defaultdict(int) for _ in range(n)]\n        total = 0\n        for i in range(n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                count = dp[j][diff]\n                dp[i][diff] += count + 1\n                total += count\n        return total\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 提取列表字面量\n    m = re.search(r'\\[.*?\\]', data)\n    if not m:\n        print(0)\n        return\n    nums_str = m.group(0)\n    try:\n        # 安全解析列表\n        import ast\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        try:\n            nums = eval(nums_str, {\"__builtins__\": None}, {})\n        except Exception:\n            nums = []\n\n    solution = Solution()\n    print(solution.numberOfArithmeticSlices(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,4,6,8,10]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "nums = [7,7,7,7,7]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode309.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock with Cooldown",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nFind th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code with explanation for maximizing profit with cooldown problem. The format: each line virtual code step + space + // explanation. Use Start, End, Decision, arrow. No actual code. Provide step-by-step logic. We'll produce algorithm: DP with states: hold, sold, rest. We'll use dp array. Provide steps: initialize, iterate, update. Provide explanation. Ensure no actual code. Use virtual code steps.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定三個狀態變數：hold, sold, rest // 分別代表持股、剛賣出、休息（冷卻）狀態\n→ Decision: 如果價格陣列長度為 0? // 檢查是否有任何天數可交易\n    Yes → Step 2: 回傳 0 // 無天數，無法獲利\n    No  → Step 3: 初始化 hold = -prices[0] // 初始持股成本\n        → Step 4: 初始化 sold = 0 // 初始剛賣出利潤\n        → Step 5: 初始化 rest = 0 // 初始休息利潤\n→ Step 6: 從第 2 天 (i = 1) 開始迭代整個價格陣列 // 循環遍歷每一天\n    → Decision: 計算新的 hold 值：max(hold, rest - prices[i]) // 可持續持股或於今日以價格買入\n        → Step 7: 新 hold = max(hold, rest - prices[i]) // 更新 hold\n    → Decision: 計算新的 sold 值：hold + prices[i] // 若今天賣出，利潤為之前持股成本加售價\n        → Step 8: 新 sold = hold + prices[i] // 更新 sold\n    → Decision: 計算新的 rest 值：max(rest, sold) // 今日處於休息，取先前休息或剛賣出的較大利潤\n        → Step 9: 新 rest = max(rest, sold) // 更新 rest\n→ Step 10: 將計算得到的新 hold, sold, rest 分別存回 hold, sold, rest // 準備下一天的計算\n→ End // 程式執行結束\n→ Step 11: 回傳 max(sold, rest) // 交易結束後最大利潤為剛賣出或休息中的較大值",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def maxProfit(self, prices):\n        \"\"\"\n        利用 DP 3 個狀態求解最大利潤：\n        - hold: 目前持有股票時的最大利潤\n        - sold: 今天剛賣出的最大利潤\n        - rest: 今天處於休息 (冷卻) 或未持股時的最大利潤\n        \"\"\"\n        if not prices:\n            return 0\n\n        hold = -prices[0]  # 初始時買入第一天\n        sold = 0           # 初始時未賣出\n        rest = 0           # 初始時休息\n\n        for price in prices[1:]:\n            prev_sold = sold               # 先存剛賣出的值，因為 rest 需要它\n            sold = hold + price            # 今天賣出\n            hold = max(hold, rest - price) # 今天持有或今天買入\n            rest = max(rest, prev_sold)    # 休息，取舊休息或剛賣出的最大值\n\n        return max(sold, rest)  # 結束時或剛賣出時的最大利潤\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取原始文字\n    data = sys.stdin.read().strip()\n    # 先用正則找出方括號中的數字序列\n    match = re.search(r'\\[([^\\]]*)\\]', data, re.S)\n    if match:\n        # 用 ast.literal_eval 解析成列表，確保安全\n        prices = ast.literal_eval('[' + match.group(1).strip() + ']')\n    else:\n        prices = []\n\n    sol = Solution()\n    result = sol.maxProfit(prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [1,2,3,0,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "prices = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode275.json",
    "problem_index_in_file": 0,
    "title": "H-Index II",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode for algorithm computing h-index from sorted array citations ascending, with binary search O(log n). We must not output actual code, just pseudocode with arrows and explanation.\n\nWe need to follow format: each line \"虛擬碼步驟 // 解釋\". Use Start, Decision, etc. Provide line by line.\n\nLet's design algorithm:\n\nInput sorted ascending array citations[0..n-1]. Find maximum h such that citations[n-h] >= h? Because sorted ascending, we need to find position where citations[i] >= n-i (paper count). Let's define i from 0 to n-1.\n\nBinary search low=0 high=n-1, answer=0. While low <= high: mid=(low+high)//2; if citations[mid] >= n-mid: then answer = n-mid; low = mid+1; else high = mid-1. After loop return answer.\n\nExplain each line.\n\nAlso include initial steps: start, input, n, low high.\n\nLet's produce step-by-step.\n\nUse \"Start // ...\" then \"→ Step 1: 取得輸入陣列 citations // 取得研究者的論文被引次數\" etc.\n\nOk. Provide lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 citations // 取得研究者的論文被引次數  \n→ Step 2: n ← length(citations) // 計算論文數量  \n→ Step 3: low ← 0, high ← n - 1, answer ← 0 // 初始化二分搜尋範圍與結果  \n→ Decision: low ≤ high? // 檢查搜尋範圍是否仍有效  \n  Yes → Step 4: mid ← (low + high) // 2 // 計算中點索引",
      "generated_code": "import sys\nimport ast\n\ndef h_index(citations):\n    \"\"\"\n    Calculate the h-index for a sorted list of citation counts.\n    Uses binary search on the possible h values (O(log n)).\n    \"\"\"\n    n = len(citations)\n    low, high = 0, n   # h can range from 0 to n\n\n    while low < high:\n        # Choose middle value (bias upward to avoid infinite loop)\n        mid = (low + high + 1) // 2\n        # citations[n - mid] is the citation count of the paper at index\n        # which would be the (mid)th most cited if we had sorted descending.\n        if citations[n - mid] >= mid:\n            low = mid          # mid is feasible, search higher\n        else:\n            high = mid - 1     # mid not feasible, search lower\n\n    return low\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Input might be \"citations = [0,1,3,5,6]\" or just \"[0,1,3,5,6]\"\n    if \"=\" in data:\n        _, expr = data.split(\"=\", 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    # Safely evaluate the list expression\n    citations = ast.literal_eval(expr)\n\n    # Compute and output the h-index\n    result = h_index(citations)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode403.json",
    "problem_index_in_file": 0,
    "title": "Frog Jump",
    "description_snippet": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Need to design algorithm: typical frog jump problem. Use DP: map stone to set of possible jump lengths that can reach that stone. Iterate through stones. For each stone, get its set of jump lengths; for each length l, try l-1,l,l+1, if stone + d exists, add d to its set. Finally check last stone set not empty.\n\nWe should produce steps with Start, Decision, etc. Provide each line as virtual code step plus explanation. Use arrow symbols and decisions. Ensure no real code. Provide steps like:\n\nStart\n→ Step 1: Create dictionary mapping stone to possible jump lengths // 初始化\n→ Step 2: Insert first stone with jump 0 // 初始状态\n→ Step 3: For each stone in stones // 迭代\n    → Decision: If stone has any reachable jump lengths? // 过滤\n        Yes → For each jump in set // ...\n        No → Continue\nWithin that loop: compute next jumps and if stone + d in set of stones, add to mapping.\n\nFinally Decision: if last stone has any reachable jump lengths? Yes → Success else Failure.\n\nLet's produce line by line with indentation for nested steps.\n\nUse `Decision:` lines, with Yes → and No →.\n\nWe need to maintain format: each line \"虛擬碼步驟 [空格] // 解釋\". Use arrows inside step names.\n\nLet's produce lines. Need to use Chinese explanation. Let's proceed.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 StoneMap 存放每個石頭位置對應可到達的跳距集合 // 初始化資料結構  \n→ Step 2: 將第一個石頭位置加入 StoneMap，並設為可跳距集合 {0} // 起始跳距為 0，代表尚未跳動  \n→ Step 3: 遍歷 stones 陣列中每個石頭位置 pos // 處理每個石頭  \n    → Decision: 如果 pos 在 StoneMap 中有可到達的跳距集合? // 檢查是否能到達此石頭  \n        Yes → Step 4: 取得 pos 的跳距集合 jumps // 取出所有可能的上一跳距  \n        No  → Step 5: 跳過此石頭，繼續下一個 // 無法到達，忽略  \n    → Step 4: 對於每個跳距 k 在 jumps 裡  \n        → Step 5: 計算三個可能的下一跳距 d ∈ {k-1, k, k+1} // 下一跳距的選項  \n            → Decision: d 大於 0? // 跳距必須正數  \n                Yes → Step 6: 計算下一位置 nextPos = pos + d // 目標石頭位置  \n                    → Decision: stones 中是否存在 nextPos? // 是否有石頭可落  \n                        Yes → Step 7: 如果 nextPos 尚未在 StoneMap，建立空集合  \n                        Yes → Step 8: 將 d 加入 nextPos 的跳距集合 // 記錄可到達方式  \n                        No  → Step 9: 不作任何事 // 沒石頭，無法跳到此距離  \n                No  → Step 10: 跳過此 d // 跳距非正，無效  \n→ Step 11: 決定是否成功跨河  \n    → Decision: lastStone (最後一個石頭位置) 在 StoneMap 中有非空跳距集合? // 判斷能否到達最後石頭  \n        Yes → Step 12: 輸出 '成功' // 可跨河  \n        No  → Step 13: 輸出 '失敗' // 無法跨河  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canCross(self, stones):\n        stone_set = set(stones)\n        last_stone = stones[-1]\n        jumps = {stone: set() for stone in stones}\n        jumps[0].add(0)\n\n        for stone in stones:\n            for k in jumps[stone]:\n                for step in (k - 1, k, k + 1):\n                    if step > 0 and stone + step in stone_set:\n                        jumps[stone + step].add(step)\n\n        return bool(jumps[last_stone])\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    # 從輸入中擷取所有整數\n    numbers = list(map(int, re.findall(r'-?\\d+', raw_input)))\n    # 確保至少有一個石頭\n    if not numbers:\n        print(\"false\")\n        sys.exit(0)\n\n    # 直接使用擷取到的數字列表作為石頭位置\n    stones = numbers\n    # 呼叫解法\n    result = Solution().canCross(stones)\n    # 輸出結果\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "stones = [0,1,3,5,6,8,12,17]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "stones = [0,1,2,3,4,8,9,11]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  }
]