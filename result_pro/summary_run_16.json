{
  "run_index": 16,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 389,
  "generation_or_validation_failure_count": 50,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 先讀入 stdin，確保程式不會因為等待輸入而停住\n    sys.stdin.read()\n    \n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n        # 輸出總行數，格式為「檔案共有 X 行」\n        print('檔案共有', len(lines), '行')\n    except FileNotFoundError:\n        # 檔案不存在時顯示錯誤訊息\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations, no actual code. Use Start, End, Decision. Steps: Start, try block, with open, read lines, count lines, print count, except FileNotFoundError: print message. Ensure arrow arrows and indentation. Use \"with\" structure but as virtual code, just denote Step: with open. Let's produce. Use line numbers? Not required. Just each line. Include arrows and explanation. Use \"Decision:\" for try? We can have Decision: If file exists? But use try-except structure: Step: try, Decision: if no error? Actually try block encloses with open. So:\n\nStart\n→ Step 1: try // 進入 try 區塊\n    → Step 2: with open('data.txt', 'r') as f // 開啟檔案\n        → Step 3: lines = f.readlines() // 讀取所有行\n        → Step 4: line_count = len(lines) // 計算行數\n        → Step 5: print(line_count) // 輸出行數\n    → Decision: 是否出現 FileNotFoundError? // 檢查是否拋出例外\n        No → End // 正常結束\n        Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nBut the structure: Decision: if error? But we can have Decision after try? Instead, use try/except representation:\n\n→ Step 1: try // 進入 try 區塊\n    → Step 2: with open('data.txt', 'r') as f // 打開檔案\n        → Step 3: lines = f.readlines() // 讀取所有行\n        → Step 4: line_count = len(lines) // 計算行數\n        → Step 5: print(line_count) // 輸出行數\n→ Decision: 是否發生 FileNotFoundError? // 檢查是否拋出例外\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\n    No → End // 程式結束\n\nBut that is confusing. We can mimic pseudo: \n\nStart\n→ Step 1: try // 開始嘗試打開檔案\n    → Step 2: with open('data.txt', 'r') as f // 使用 with 進行檔案開啟\n        → Step 3: lines = f.readlines() // 讀取所有行\n        → Step 4: line_count = len(lines) // 計算行數\n        → Step 5: print(line_count) // 輸出行數\n→ Decision: 是否捕捉到 FileNotFoundError? // 判斷是否發生例外\n    Yes → Step 6: print('找不到檔案！') // 顯示找不到檔案訊息\n    No → End // 程式結束\n\nBut typical representation: \"except FileNotFoundError:\" maybe as Step. But we can show Step: except FileNotFoundError: // 處理例外. Inside that step we print message. Then End.\n\nLet's produce final output with each line. Use arrow arrow? For lines under try, we need indent representation: \"→ Step\" for each. For nested we indent with more arrow? The example uses indentation. Let's mimic:\n\nStart\n→ Step 1: try // 進入 try 區塊\n    → Step 2: with open('data.txt', 'r') as f // 開啟檔案\n        → Step 3: lines = f.readlines() // 讀取所有行\n        → Step 4: line_count = len(lines) // 計算行數\n        → Step 5: print(line_count) // 輸出行數\n→ Decision: 是否捕捉到 FileNotFoundError? // 檢查是否有例外\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\n    No  → End // 程式結束\n\nHowever \"Decision\" after try is odd but acceptable. Alternatively, use \"except FileNotFoundError:\" as Step. Let's do:\n\nStart\n→ Step 1: try // 進入 try 區塊\n    → Step 2: with open('data.txt', 'r') as f // 使用 with 開啟檔案\n        → Step 3: lines = f.readlines() // 讀取所有行\n        → Step 4: line_count = len(lines) // 計算行數\n        → Step 5: print(line_count) // 輸出行數\n→ Step 6: except FileNotFoundError // 捕捉檔案不存在的例外\n    → Step 7: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nYes, that's clearer.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: try // 進入 try 區塊，嘗試執行以下程式碼\n    → Step 2: with open('data.txt', 'r') as f // 使用 with 語法開啟檔案\n        → Step 3: lines = f.readlines() // 讀取檔案中的所有行\n        → Step 4: line_count = len(lines) // 計算行數\n        → Step 5: print(line_count) // 輸出總行數\n→ Step 6: except FileNotFoundError // 捕捉檔案不存在的例外\n    → Step 7: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式執行結束\n```"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[5,3,5,1,4]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[5, 3, 5, 1, 4]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"擲 n 次六面骰，回傳結果串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    code = sys.stdin.read()\n    if code.strip():  # 若輸入不為空\n        # 執行讀入的程式碼，讓 roll_dice 可以被使用\n        exec(code, {\"roll_dice\": roll_dice})",
      "virtual_code": "Thinking...\nWe need to produce virtual code with each line: step + comment. Use Start, End, Decision. The function roll_dice(n). We need to import random, define function, loop n times, use random.randint(1,6), append to list, return list. Use virtual code. Use arrow →. Provide comments. Ensure no real code, only virtual code. Provide per line. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 引入 random 模組 // 用來產生隨機數  \n→ Step 2: 定義函數 roll_dice(n) // 接受擲骰次數 n  \n→ Step 3: 初始化 empty_results 為空串列 // 用於儲存每次擲骰的結果  \n→ Step 4: 從 1 到 n 進行迴圈 // 模擬擲 n 次骰子  \n  → Step 5: 產生隨機數 1~6 並存入 roll_value // 隨機擲骰結果  \n  → Step 6: 將 roll_value 加入 empty_results // 收集結果  \n→ Step 7: 回傳 empty_results // 回傳所有擲骰結果的串列  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量 func 執行所需的秒數，並回傳經四捨五入到小數點 3 位的結果。\n    \"\"\"\n    start = time.perf_counter()\n    func(*args)\n    end = time.perf_counter()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個程式碼，並以全域命名空間執行\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, with arrow, and explanation in Chinese. Use Start, End, Decision, etc. Provide function measure_time(func,*args). Use time module. Steps: import time, define function, record start time, call func with args, record end, compute elapsed, round to 3 decimals, return. Also maybe return result? The requirement: measure time and return result? It says return result (四捨五入). Probably return elapsed time? Actually measure_time(func,*args) used to measure function execution time, return time. So just return elapsed time. Provide virtual code.\n\nLet's produce:\n\nStart\n→ Step 1: import time // 導入 time 模組\n→ Step 2: 定義函數 measure_time(func, *args) // 定義測量時間的函數\n→ Step 3: 設置 start_time = time.perf_counter() // 紀錄開始時間\n→ Step 4: 執行 func(*args) 並忽略返回值 // 執行目標函數\n→ Step 5: 設置 end_time = time.perf_counter() // 紀錄結束時間\n→ Step 6: 計算 elapsed = end_time - start_time // 計算耗時\n→ Step 7: 將 elapsed 四捨五入到小數點 3 位 → elapsed_rounded = round(elapsed, 3) // 四捨五入\n→ Step 8: 回傳 elapsed_rounded // 回傳經過時間\nEnd\n\nAlso maybe include decision? Not necessary. But they want Decision structure maybe optional. We'll keep simple.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: import time // 導入時間模組\n→ Step 2: 定義函數 measure_time(func, *args) // 宣告測量時間的函數\n→ Step 3: start_time = time.perf_counter() // 紀錄執行前的高精度時間戳\n→ Step 4: 執行 func(*args) // 呼叫傳入的函數，並傳遞所有參數\n→ Step 5: end_time = time.perf_counter() // 紀錄執行後的時間戳\n→ Step 6: elapsed = end_time - start_time // 計算兩次時間戳之差，即執行時間\n→ Step 7: elapsed_rounded = round(elapsed, 3) // 將耗時四捨五入到小數點 3 位\n→ Step 8: 回傳 elapsed_rounded // 返回計算得到的秒數\nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"melon\",\"grape\",\"apple\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'melon', 'grape', 'apple', 'orange'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取所有輸入（如果有輸入），但本程式不使用它們\n    sys.stdin.read()\n\n    # 初始集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update({'grape', 'melon'})\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'，不會拋錯誤\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines step by step. The user says: create a set fruits = {'apple', 'banana'}; then add 'orange'; update with 'grape' and 'melon'; remove 'banana'; discard 'pineapple'; then output the set. Need to follow format: each line: 虛擬碼步驟 + space + // 解釋/說明. Use Start, End, Decision if needed. Not actual code but virtual code. Just the steps.\n\nWe must be careful: \"虛擬碼步驟\" is like \"Start\", \"→ Step 1: ...\", etc. No actual code. So:\n\nStart // 程式開始執行\n→ Step 1: 初始化集合 fruits 為 {'apple', 'banana'} // 建立初始集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 同時新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'，不拋錯誤\n→ Step 6: 輸出 fruits // 顯示最終集合\nEnd // 程式結束\n\nWe need arrow \"→\" for each step. Use \"Start\" and \"End\". Use spaces. No actual code. Provide explanation after //.\n\nOk. Provide final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化集合 fruits 為 {'apple', 'banana'} // 建立初始集合  \n→ Step 2: fruits.add('orange') // 新增 'orange' 到集合  \n→ Step 3: fruits.update({'grape', 'melon'}) // 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 從集合中移除 'banana'，若不存在則拋錯誤  \n→ Step 5: fruits.discard('pineapple') // 嘗試移除 'pineapple'，不存在時不拋錯誤  \n→ Step 6: 輸出 fruits // 顯示最終集合  \nEnd // 程式結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.71TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.71 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef get_rate() -> float | None:\n    \"\"\"\n    從 exchangerate-api 取得 USD 對 TWD 的匯率。\n    若發生任何錯誤則回傳 None。\n    \"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n        data = resp.json()\n        return data['rates']['TWD']\n    except Exception:\n        return None\n\ndef update_label(label: tk.Label) -> None:\n    \"\"\"\n    更新給定的 Label 內容為最新匯率。\n    \"\"\"\n    rate = get_rate()\n    if rate is not None:\n        label.config(text=f'目前美元匯率：約 {rate} TWD')\n    else:\n        label.config(text='更新失敗，請檢查網路連線')\n\ndef main() -> None:\n    \"\"\"\n    主程式入口：\n    1. 從標準輸入讀取指令。\n    2. 若指令包含「更新匯率」關鍵字，則取得匯率並輸出到標準輸出。\n    3. 若指令不包含上述關鍵字，則啟動 GUI 介面。\n    \"\"\"\n    # 讀取整行輸入\n    input_line = sys.stdin.read().strip()\n    if not input_line:\n        return\n\n    # 文字指令判斷\n    if '更新匯率' in input_line:\n        rate = get_rate()\n        if rate is not None:\n            print(f'目前美元匯率：約 {rate} TWD')\n        else:\n            print('更新失敗，請檢查網路連線')\n        return\n\n    # 不是指令則啟動 GUI\n    root = tk.Tk()\n    root.title('匯率查詢')\n    label = tk.Label(root, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n    tk.Button(root, text='更新匯率', command=lambda: update_label(label)).pack(pady=5)\n    root.mainloop()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code snippet step-by-step, each line with \"虛擬碼步驟\" and explanation after //.\n\nWe need to cover: import requests, import tkinter, define function to fetch rate, create Tk window, add label, button, callback updates label. Start, End, Decision maybe not needed, but can include. Need to use arrow →.\n\nWe need to output only virtual code lines, not actual code. Each line \"虛擬碼步驟 // 解釋\". Use Chinese. Use arrow symbols. Use Start and End. Should include steps to call API, parse JSON, get TWD rate, set label text.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nThen we need steps.\n\nI will structure:\n\n- Step: Import requests\n- Step: Import tkinter\n- Step: 定義函式 fetch_rate() // 取得匯率\n- Step: Inside fetch_rate() → 呼叫 requests.get(...) // 發送 GET\n- Step: Decision: 如果請求成功? → Yes → Parse JSON, get TWD rate, return rate; No → Return None\n\n- Step: 定義函式 update_label() // 更新 label\n- Step: Inside update_label() → rate = fetch_rate()\n- Step: Decision: 如果 rate 不是 None? → Yes → 更新 label文字為 rate; No → 設定 label文字為錯誤訊息\n\n- Step: 建立 Tk() 視窗\n- Step: 建立 Label widget\n- Step: 建立 Button widget，command 指向 update_label\n- Step: 初始更新 label\n- Step: 進入 mainloop\n\n- End\n\nWe need to format each line: \"虛擬碼步驟 // 解釋\".\n\nNeed to include arrow after \"→\" each step.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import requests // 載入 HTTP 請求模組  \n→ Import tkinter as tk // 載入圖形界面模組  \n→ Define fetch_rate() // 定義取得匯率的函式  \n    → response = requests.get('https://api.exchangerate-api.com/v4/latest/USD') // 送出 GET 請求  \n    → Decision: 如果 response.status_code 為 200? // 檢查請求是否成功  \n        Yes → data = response.json() // 解析回傳的 JSON  \n        Yes → rate = data['rates']['TWD'] // 取得台幣匯率  \n        Yes → Return rate // 回傳匯率值  \n        No  → Return None // 請求失敗時回傳空值  \n→ Define update_label() // 定義更新 Label 文字的函式  \n    → rate = fetch_rate() // 取得最新匯率  \n    → Decision: 如果 rate 不是 None? // 檢查是否成功取得匯率  \n        Yes → label.config(text=f'USD/TWD: {rate}') // 顯示匯率  \n        No  → label.config(text='無法取得匯率') // 顯示錯誤訊息  \n→ root = tk.Tk() // 建立主視窗  \n→ root.title('美元兌台幣匯率') // 設定視窗標題  \n→ label = tk.Label(root, text='匯率載入中…', font=('Arial', 14)) // 建立顯示匯率的 Label  \n→ label.pack(pady=20) // 放置 Label  \n→ button = tk.Button(root, text='更新匯率', command=update_label, font=('Arial', 12)) // 建立按鈕，點擊時執行 update_label  \n→ button.pack(pady=10) // 放置按鈕  \n→ update_label() // 初始載入匯率  \n→ root.mainloop() // 進入 Tkinter 事件循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbk0z4o91.py\", line 62, in <module>\n    main()\n  File \"/tmp/tmpbk0z4o91.py\", line 41, in main\n    commands = ast.literal_eval(commands_str)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport re\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val):\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        if val not in self.val_to_index:\n            return False\n        index = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[index] = last_val\n        self.val_to_index[last_val] = index\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.values)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split into two lists: commands and arguments\n    parts = re.split(r'\\],\\s*\\[', data)\n    commands_str = '[' + parts[0] + ']'\n    args_str = '[' + parts[1] + ']'\n    commands = ast.literal_eval(commands_str)\n    args_list = ast.literal_eval(args_str)\n\n    outputs = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"RandomizedSet\":\n            obj = RandomizedSet()\n            outputs.append(None)\n        elif cmd == \"insert\":\n            outputs.append(obj.insert(*args))\n        elif cmd == \"remove\":\n            outputs.append(obj.remove(*args))\n        elif cmd == \"getRandom\":\n            outputs.append(obj.getRandom())\n        else:\n            outputs.append(None)\n\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, with explanation, using arrows and structure. The task: Implement RandomizedSet with operations insert, remove, getRandom. In O(1). Classic solution: use array/list for values and hash map from val to index. In virtual code, we can outline steps for each method.\n\nWe need to produce virtual code lines, each with \"虛擬碼步驟\" + \" // 解釋\". Use arrow \"→\", \"Decision:\" etc. Use Start, End.\n\nWe need to output for the whole class? Probably yes: show initialization, insert, remove, getRandom.\n\nWe should produce multiple sections: Start // Program start. But maybe show separate methods. The example shows Start, Step 1, Decision, etc. We need to adapt to class design.\n\nWe'll present pseudo code: Start // Program start. Then define class RandomizedSet. Inside, we define constructor, then each method.\n\nWe should keep each line as a step, not entire code block.\n\nWe need to produce a sequential step for each method, but not actual code lines, just pseudo operations. Use \"Step\" for method operations. Use \"Decision:\" for if conditions. Use \"Yes →\" \"No →\" branches.\n\nWe'll show:\n\nStart // 程式開始\n\n→ Step 1: 定義 RandomizedSet 類別 // 開始定義類別\n\nInside class:\n\n→ Step 2: 初始化 values_list 為空陣列 // 用來儲存元素\n→ Step 3: 初始化 val_to_index 為空字典 // 位置映射\n\nThen methods:\n\nInsert(val):\n→ Step 4: Decision: val 是否已存在於 val_to_index? // 檢查元素是否已存在\n    Yes → Step 5: 返回 false // 已存在，無法插入\n    No → Step 6: 把 val 添加到 values_list 末尾 // 加入值\n        → Step 7: 設置 val_to_index[val] = values_list 的最後一個索引 // 更新映射\n        → Step 8: 返回 true // 插入成功\n\nRemove(val):\n→ Step 9: Decision: val 是否存在於 val_to_index? // 檢查是否可移除\n    Yes → Step 10: 取得 index_to_remove = val_to_index[val] // 取得索引\n        → Step 11: 取得 last_val = values_list 的最後一個元素 // 取得最後元素\n        → Step 12: Decision: index_to_remove 不是最後一個索引? // 如果不是最後元素需要交換\n            Yes → Step 13: 把 last_val 放到 values_list[index_to_remove] // 覆蓋位置\n                → Step 14: 更新 val_to_index[last_val] = index_to_remove // 更新映射\n            No → Step 15: // 只需要刪除最後元素，不需要交換\n        → Step 16: 從 values_list 刪除最後一個元素 // 移除元素\n        → Step 17: 從 val_to_index 刪除 val // 移除映射\n        → Step 18: 返回 true // 移除成功\n    No → Step 19: 返回 false // 沒有此元素\n\nGetRandom():\n→ Step 20: 生成 random_index = 隨機數在 [0, values_list 長度-1] // 隨機索引\n→ Step 21: 返回 values_list[random_index] // 回傳隨機元素\n\nEnd // 程式結束\n\nWe need to use arrow \"→\" at each step.\n\nLet's format each line accordingly.\n\nAlso need to use \"Decision:\" for decisions.\n\nAlso we need to include \"Start\" and \"End\".\n\nLet's produce lines accordingly. Use Chinese comments.\n\nAlso need to include that each operation is O(1) on average.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 RandomizedSet 類別 // 開始定義類別  \n→ Step 2: 初始化 values_list 為空陣列 // 用來儲存所有元素  \n→ Step 3: 初始化 val_to_index 為空字典 // 儲存元素到其索引的映射  \n\n→ Step 4: 定義 insert(val) 方法 // 插入操作  \n    → Decision: 若 val 已存在於 val_to_index? // 檢查是否已存在  \n        Yes → Step 5: 返回 false // 插入失敗，元素已存在  \n        No  → Step 6: 將 val 添加到 values_list 末尾 // 加入新元素  \n            → Step 7: 設置 val_to_index[val] = values_list 的最後一個索引 // 更新映射  \n            → Step 8: 返回 true // 插入成功  \n\n→ Step 9: 定義 remove(val) 方法 // 刪除操作  \n    → Decision: 若 val 存在於 val_to_index? // 檢查是否可刪除  \n        Yes → Step 10: 取得 index_to_remove = val_to_index[val] // 取得要刪除的索引  \n            → Step 11: 取得 last_val = values_list 的最後一個元素 // 取最後元素  \n            → Decision: 若 index_to_remove 不是最後一個索引? // 需要交換位置  \n                Yes → Step 12: 把 last_val 放到 values_list[index_to_remove] // 覆蓋要刪除的位置  \n                    → Step 13: 更新 val_to_index[last_val] = index_to_remove // 更新映射  \n                No  → Step 14: // 不需要交換，只刪除最後元素  \n            → Step 15: 從 values_list 刪除最後一個元素 // 真正刪除元素  \n            → Step 16: 從 val_to_index 刪除 val // 刪除映射條目  \n            → Step 17: 返回 true // 刪除成功  \n        No  → Step 18: 返回 false // 沒有該元素，刪除失敗  \n\n→ Step 19: 定義 getRandom() 方法 // 取得隨機元素  \n    → Step 20: 生成 random_index = 隨機數在 [0, values_list 長度-1] // 隨機索引  \n    → Step 21: 返回 values_list[random_index] // 回傳隨機元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[1,0],[2,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [1, 0], [2, 0], null, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n          # remaining zeros\n        self.map = {}               # mapping for random sampling\n\n    def flip(self):\n        # 隨機選取 0~self.total-1\n        r = random.randint(0, self.total - 1)\n        # 取得實際索引\n        idx = self.map.get(r, r)\n        # 减少剩餘可翻轉格子\n        self.total -= 1\n        # 更新映射，保持映射表完整\n        self.map[r] = self.map.get(self.total, self.total)\n        # 轉換回 2D 座標\n        return [idx // self.n, idx % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.map.clear()\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 分割兩個 list\n    parts = data.split('],', 1)\n    ops_str = parts[0] + ']'\n    args_str = parts[1].strip()\n    if args_str.startswith('['):\n        args_str = args_str\n    else:\n        args_str = '[' + args_str\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            res.append(None)\n        elif op == \"flip\":\n            res.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            res.append(None)\n\n    # 格式化輸出，將 None 改為 null\n    out = '['\n    for i, val in enumerate(res):\n        if val is None:\n            out += 'null'\n        else:\n            out += str(val)\n        if i != len(res) - 1:\n            out += ', '\n    out += ']'\n    print(out)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code lines. Need to design algorithm: basically reservoir-like random sampling with tracking of available positions. Known LeetCode problem: Random Flip Matrix. Approach: maintain map of index mapping. Use random index between 0 and remaining-1. If mapping has that index, use mapped value; else value itself. Then swap with last available index: mapping[randomIndex] = mapping[remaining-1] if exists else remaining-1. Decrease remaining. For reset, clear map and set remaining = m*n.\n\nWe produce steps for class Solution with constructor, flip, reset.\n\nWe need to output virtual code lines each with explanation. Provide steps inside methods. Use arrow notation. Provide Start and End. Use Decision maybe for empty? Not necessary.\n\nLet's produce structure:\n\nStart\n→ Initialize: m, n, total = m*n, remaining = total, map = empty // store mapping\n→ Constructor // ...\n→ flip() method\n    → Check remaining == 0? maybe not needed\n    → Generate rand = random(0, remaining-1) // random int\n    → Get index = map[rand] if exists else rand // actual index in flattened\n    → remaining -= 1\n    → Update map: map[rand] = map[remaining] if exists else remaining\n    → Compute i = index / n, j = index % n\n    → Return [i, j]\n→ reset()\n    → Clear map\n    → remaining = total\nEnd\n\nAdd Start and End around class maybe. Use comments. Provide each line. Use arrow for steps inside methods. Provide explanation after //.\n\nWe should produce \"虛擬碼步驟\" maybe as \"→\" lines. For each line, we produce \"虛擬碼步驟\" e.g., \"→ Step 1: 初始化變數\" etc. Provide explanation.\n\nLet's craft.\n\nAlso include Decision? Not necessary.\n\nMake sure each line ends with // 解釋.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Class Solution // 定義 Solution 類別\n    → Constructor: Solution(int m, int n) // 建構子初始化\n        → Set this.m = m // 儲存行數\n        → Set this.n = n // 儲存列數\n        → Set this.total = m * n // 總格數\n        → Set this.remaining = this.total // 仍未翻轉的格子數\n        → Set this.map = EmptyMap() // 映射表，用於隨機索引映射\n    → Method: int[] flip() // 隨機翻轉一個 0 為 1\n        → Generate rand = RandomInt(0, this.remaining - 1) // 產生 0~remaining-1 的隨機整數\n        → If this.map contains key rand? // 判斷映射表中是否已有對應\n            Yes → Set index = this.map[rand] // 若有，取得映射值\n            No  → Set index = rand // 若無，直接使用 rand\n        → Decrease this.remaining by 1 // 已翻轉一格\n        → If this.map contains key this.remaining? // 更新映射表以維持映射關係\n            Yes → Set this.map[rand] = this.map[this.remaining] // 把最後一個可用位置映射到 rand\n            No  → Set this.map[rand] = this.remaining // 若最後位置無映射，直接設定\n        → Compute i = index / this.n // 轉換為行索引\n        → Compute j = index % this.n // 轉換為列索引\n        → Return [i, j] // 回傳被翻轉的格子座標\n    → Method: void reset() // 重置矩陣\n        → Clear this.map // 清空映射表\n        → Set this.remaining = this.total // 重新設定可翻轉格子數\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6hkwnziy.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmp6hkwnziy.py\", line 51, in main\n    obj.buildDict(args[i])\n  File \"/tmp/tmp6hkwnziy.py\", line 10, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\ndef parse_input(data):\n    \"\"\"Parse the input into methods list and arguments list.\"\"\"\n    data = data.strip()\n    if not data:\n        return [], []\n\n    # If the data contains two lines, parse each line separately\n    lines = [line for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2 and not data.startswith('['):\n        methods = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip())\n        return methods, args\n\n    # Otherwise, assume a single line containing two lists separated by '], ['.\n    # Wrap the whole string in brackets to make it a list of two lists.\n    wrapped = '[' + data + ']'\n    methods, args = ast.literal_eval(wrapped)\n    return methods, args\n\ndef main():\n    data = sys.stdin.read()\n    methods, args = parse_input(data)\n\n    obj = None\n    results = []\n    for i, method in enumerate(methods):\n        if method == \"MagicDictionary\":\n            obj = MagicDictionary()\n            results.append(None)\n        elif method == \"buildDict\":\n            obj.buildDict(args[i])\n            results.append(None)\n        elif method == \"search\":\n            results.append(obj.search(args[i]))\n        else:\n            # Unsupported method; append None\n            results.append(None)\n\n    # Output results in JSON format to match LeetCode's expected output\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanations, following the formatting.\n\nWe need to design a data structure: MagicDictionary. We need to implement buildDict and search.\n\nWe need to produce steps: Start, BuildDict: store words; maybe store set; search: for each word of same length, check if exactly one mismatch. Complexity O(N * L) maybe.\n\nWe need to use Decision and arrow formatting. Provide each line: virtual step + space + // explanation.\n\nOk.\n\nWe need to produce step lines: Start, etc. Each step is one action. Should we include loops? We can show Decision for loops.\n\nLet's produce.\n\nLines:\n\nStart // 程式開始執行\n→ MagicDictionary class definition // 定義 MagicDictionary 類別\n→ Constructor: 初始化空集合 wordsSet // 建立空集合儲存字典\n→ buildDict(dictionary): // 建立字典\n    → Store all words in wordsSet // 將所有字串加入集合\n→ search(searchWord): // 搜尋函式\n    → For each word in wordsSet: // 遍歷所有已存字串\n        → Decision: 若字串長度 ≠ searchWord長度? // 不同長度無法匹配\n            No → Proceed // 長度相同，繼續\n            Yes → Continue next word // 跳過此字串\n        → Initialize mismatchCount = 0 // 計算不同字元數\n        → For i from 0 to length-1: // 比較每個位置\n            → Decision: 若 searchWord[i] ≠ word[i]? // 字元不一致\n                Yes → mismatchCount += 1 // 增加不一致數\n                No  → No action // 字元一致\n        → Decision: 若 mismatchCount == 1? // 只差一個字元\n            Yes → Return true // 找到符合條件的字串\n            No  → Continue next word // 否則繼續\n    → Return false // 沒有符合條件的字串\nEnd // 程式執行結束\n\nBut we need each line with arrow \"→\" at start. For nested loops, we may use indentation? The formatting examples show indentation for nested decisions. We need to reflect.\n\nWe should provide each line with arrow and explanation. Use proper indentation for nested decisions? The example used indentation with arrow for each line inside decisions. We'll replicate.\n\nBetter to indent nested actions with an arrow, maybe not necessary but okay.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Class MagicDictionary // 定義 MagicDictionary 類別\n→ Constructor MagicDictionary() // 初始化構造器\n    → wordsSet = new Set() // 建立空集合以存放字典\n→ Method buildDict(dictionary) // 建立字典\n    → For each word in dictionary:\n        → wordsSet.add(word) // 將字串加入集合\n→ Method search(searchWord) // 搜尋功能\n    → For each word in wordsSet:\n        → Decision: 若 word.length ≠ searchWord.length?\n            Yes → Continue // 長度不同，跳過此字串\n            No  →\n                → mismatchCount = 0 // 初始化不匹配數\n                → For i = 0 to word.length-1:\n                    → Decision: 若 searchWord[i] ≠ word[i]?\n                        Yes → mismatchCount += 1 // 字元不同\n                        No  →\n                → Decision: 若 mismatchCount == 1?\n                    Yes → Return true // 找到符合條件的字串\n                    No  → Continue // 不是，只差一個字元\n    → Return false // 沒有符合條件的字串\nEnd // 程式執行結束\n\nWe need to ensure each line ends with // explanation. We also need to include the arrow for nested decisions? The example shows indentation and arrow for each line. Let's produce as above but ensuring each line ends with // explanation.\n\nAlso need to note that lines like \"→ For each word in wordsSet:\" and \"→ Decision:\" etc.\n\nMake sure each line uses arrow or indentation? The example uses arrow for each line, but nested lines may just be indented with arrow and indent.\n\nThus we need:\n\nStart // 程式開始執行\n→ Class MagicDictionary // 定義 MagicDictionary 類別\n→ Constructor MagicDictionary() // 初始化構造器\n    → wordsSet = new Set() // 建立空集合以存放字典\n→ Method buildDict(dictionary) // 建立字典\n    → For each word in dictionary:\n        → wordsSet.add(word) // 將字串加入集合\n→ Method search(searchWord) // 搜尋功能\n    → For each word in wordsSet:\n        → Decision: 若 word.length ≠ searchWord.length?\n            Yes → Continue // 長度不同，跳過此字串\n            No  →\n                → mismatchCount = 0 // 初始化不匹配數\n                → For i = 0 to word.length-1:\n                    → Decision: 若 searchWord[i] ≠ word[i]?\n                        Yes → mismatchCount += 1 // 字元不同\n                        No  →\n                → Decision: 若 mismatchCount == 1?\n                    Yes → Return true // 找到符合條件的字串\n                    No  → Continue // 不是，只差一個字元\n    → Return false // 沒有符合條件的字串\nEnd // 程式執行結束\n\nBut each line must have \"虛擬碼步驟 [空格] // 解釋/說明\". The lines with \"Continue\" or \"Return\" need explanation too.\n\nWe need to include \"Continue\" as part of code. But maybe we can just have \"Continue\" arrow? The example uses \"Continue\" inside decisions. For our code, we might need to denote Continue or Return. Use \"→ Continue\" with explanation. However the example shows \"Continue\" not as a separate line but part of Decision branch. We can use arrow but explanation.\n\nWe need to ensure each line ends with explanation. So lines like \"→ Continue // 跳過此字串\" and \"→ Return true // 找到符合條件的字串\".\n\nAlso nested lines need indentation. We'll maintain indentation by spaces.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Class MagicDictionary // 定義 MagicDictionary 類別  \n→ Constructor MagicDictionary() // 初始化構造器  \n    → wordsSet = new Set() // 建立空集合以存放字典  \n→ Method buildDict(dictionary) // 建立字典  \n    → For each word in dictionary: // 遍歷輸入字典  \n        → wordsSet.add(word) // 將字串加入集合  \n→ Method search(searchWord) // 搜尋功能  \n    → For each word in wordsSet: // 遍歷所有已存字串  \n        → Decision: 若 word.length ≠ searchWord.length? // 不同長度無法匹配  \n            Yes → Continue // 跳過此字串  \n            No  →  \n                → mismatchCount = 0 // 初始化不匹配字元數  \n                → For i = 0 to word.length-1: // 比較每個位置  \n                    → Decision: 若 searchWord[i] ≠ word[i]? // 字元不一致  \n                        Yes → mismatchCount += 1 // 字元不同，計數+1  \n                        No  → // 字元一致，無變動  \n                → Decision: 若 mismatchCount == 1? // 只差一個字元  \n                    Yes → Return true // 找到符合條件的字串  \n                    No  → Continue // 不是，只差一個字元  \n    → Return false // 沒有符合條件的字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4o4en57w.py\", line 37, in <module>\n    main()\n  File \"/tmp/tmp4o4en57w.py\", line 33, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4o4en57w.py\", line 11, in __init__\n    self.lookup[(word[:i], word[j:])] = weight\n    ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    def __init__(self, words):\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):\n                for j in range(L + 1):\n                    self.lookup[(word[:i], word[j:])] = weight\n\n    def f(self, prefix, suffix):\n        return self.lookup.get((prefix, suffix), -1)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the input into words list and query list\n    parts = data.split('], ', 1)\n    if len(parts) != 2:\n        # In case the input format is different, try a generic split by comma\n        parts = data.split(',', 1)\n    words_part = parts[0] + ']'  # close the outer list\n    query_part = parts[1]\n    words = ast.literal_eval(words_part)\n    query = ast.literal_eval(query_part)\n    if not isinstance(query, (list, tuple)) or len(query) != 2:\n        print(-1)\n        return\n    prefix, suffix = query[0], query[1]\n    wf = WordFilter(words)\n    print(wf.f(prefix, suffix))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code that implements WordFilter class with prefix and suffix search. Must be step-by-step with explanations.\n\nWe need to design an efficient algorithm: typical solution uses trie for prefix and suffix or hash mapping of combined key. Approach: Build dictionary of words; store mapping from combined key (prefix#suffix) to max index. We can generate all prefix-suffix combinations for each word. Complexity: O(total characters^2). For simplicity, produce pseudo-code using maps.\n\nWe need to produce per-line steps: Start, steps for constructor building, step for f method. Use arrow.\n\nLet's draft:\n\nStart\n→ Step 1: WordFilter(words) // constructor receives word list\n→ Step 2: 初始化 map<Key, int> dict // store best index for each prefix-suffix pair\n→ Decision: For each word in words, with index i\n    → Step 3: 生成所有前綴 strings pre\n    → Step 4: 生成所有後綴 strings suf\n    → Step 5: dict[pre + \"#\" + suf] = i // store latest index\n→ End // constructor finished\n\nf(pref, suff)\n→ Step 6: key = pref + \"#\" + suff\n→ Step 7: 若 key in dict\n    → Step 8: return dict[key] // return stored index\n    → No → Step 9: return -1 // not found\n\nNeed to explain each step.\n\nAlso need to include Start/End for f method? Might not. But we can have Start/End for each method.\n\nBetter produce:\n\nStart // WordFilter constructor\n...\nEnd // constructor finished\n\nSimilarly for f.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // WordFilter 建構子開始\n→ Step 1: WordFilter(words) // 取得字串陣列\n→ Step 2: 初始化 map<Key, int> dict // 用來儲存「前綴#後綴」對應的最大索引\n→ Decision: 對於每個 word 以及其索引 i in words\n    → Step 3: 產生所有前綴 pre (從空字串到整個 word)\n    → Step 4: 產生所有後綴 suf (從整個 word 到空字串)\n    → Step 5: dict[pre + \"#\" + suf] ← i // 存入或更新索引，因為迴圈後 i 越大越被覆蓋，保持最大值\nEnd // WordFilter 建構子結束\n\nStart // f 方法開始\n→ Step 6: key ← pref + \"#\" + suff // 組合查詢鍵\n→ Decision: key 在 dict 中嗎?\n    Yes → Step 7: return dict[key] // 回傳對應索引\n    No  → Step 8: return -1 // 無符合條件的單字\nEnd // f 方法結束\n```"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      \"['()()()', '(())()']\""
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      \"['(a)()()', '(a())()']\""
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"Return all unique valid strings with minimal removals.\"\"\"\n        def is_valid(string: str) -> bool:\n            count = 0\n            for ch in string:\n                if ch == '(':\n                    count += 1\n                elif ch == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        visited = {s}\n        queue = deque([s])\n        found_level = None\n        results = set()\n\n        while queue:\n            level_size = len(queue)\n            for _ in range(level_size):\n                curr = queue.popleft()\n                if is_valid(curr):\n                    results.add(curr)\n                    found_level = found_level or 0  # mark found\n                if found_level is not None:\n                    # If we already found valid strings at this level,\n                    # skip generating children to keep minimal removals\n                    continue\n                for i, ch in enumerate(curr):\n                    if ch in ('(', ')'):\n                        nxt = curr[:i] + curr[i+1:]\n                        if nxt not in visited:\n                            visited.add(nxt)\n                            queue.append(nxt)\n            if found_level is not None:\n                break  # stop after processing the level with valid strings\n\n        return list(results)\n\ndef parse_input(raw: str) -> str:\n    \"\"\"Extract the string value from the raw input.\"\"\"\n    raw = raw.strip()\n    # Remove leading assignment if present\n    if raw.lower().startswith('s'):\n        parts = raw.split('=', 1)\n        if len(parts) == 2:\n            raw = parts[1].strip()\n    # Remove surrounding quotes if any\n    if (raw.startswith('\"') and raw.endswith('\"')) or (raw.startswith(\"'\") and raw.endswith(\"'\")):\n        raw = raw[1:-1]\n    return raw\n\ndef main():\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    ans = solution.removeInvalidParentheses(s)\n    # Print the result as a Python list representation\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudocode lines. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow. For algorithm: typical solution: BFS level removal until valid. Steps: compute max removals? Or BFS queue. We'll produce pseudocode: Start; Step: initialize queue, visited set; enqueue original string; flag found = False; results = set(); while queue not empty: pop; if string is valid: add to results; found = True; if found: continue to next level; else generate neighbors by removing one char if it's parenthesis; push unvisited neighbors. After loop, return results as list.\n\nNeed explain each line. Use arrow for substeps: For Decision, use Yes/No. Use Start/End. Let's produce lines.\n\nAlso explain BFS concept. Each step.\n\nOk. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 queue ← [s] // 將原始字串放入佇列  \n→ Step 2: 初始化 visited ← {s} // 追蹤已處理的字串  \n→ Step 3: 初始化 results ← ∅ // 用來存放符合條件的有效字串  \n→ Step 4: 初始化 found ← False // 標記是否已找到最小刪除量的有效字串  \n\n→ Decision: 若 queue 為空? // 檢查是否還有待處理的字串  \n    No  → Step 5: 取出 queue 頭部字串 curr // 取下一個待測字串  \n    → Decision: curr 是否為有效字串? // 判斷是否為合法括號排列  \n        Yes → Step 6: 加入 results ← results ∪ {curr} // 存入有效結果  \n        → Step 7: 設置 found ← True // 已找到最小刪除量的字串  \n        No  → Decision: found 為 False? // 是否還未找到最小刪除量的有效字串  \n            Yes → Step 8: 產生所有候選字串 // 從 curr 逐一刪除一個括號  \n                → For i 在 0..len(curr)-1  \n                    → Decision: curr[i] 為 '(' 或 ')'？ // 只考慮括號  \n                        Yes → Step 9: new ← curr[0:i] + curr[i+1:] // 刪除第 i 個括號  \n                        → Decision: new 不在 visited?  \n                            Yes → Step 10: 將 new 加入 queue 與 visited // 新字串進行處理  \n                            No → Skip // 已處理過的字串不再加入  \n            No  → Skip // 若已找到最小刪除量，僅處理同層級字串  \n→ Decision: found 為 False? // 若仍未找到有效字串，則繼續循環  \n    Yes → 循環到 Step 5  \n    No  → End // 已完成所有等級的搜尋  \n\nEnd // 程式執行結束，返回 results 作為最小刪除量的有效字串集合。"
    },
    {
      "title": "License Key Formatting",
      "source_file": "Leetcode/leetcode482.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"5F3Z-2e-9-w\", k = 4",
          "expected_output": " \"5F3Z-2E9W\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5F3Z-2E9W'\nGot (Norm):      'S=\"-5F3Z-2E9W-\",K='\n--- (Raw) ---\nRaw Expected: ' \"5F3Z-2E9W\"'\nRaw Got:      'S=\"-5F3Z-2E9W-\",K='"
        },
        {
          "example_index": 1,
          "input": "s = \"2-5g-3-J\", k = 2",
          "expected_output": "\"2-5G-3J\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2-5G-3J'\nGot (Norm):      'S=-\"2-5G-3J-\",-K='\n--- (Raw) ---\nRaw Expected: '\"2-5G-3J\"'\nRaw Got:      'S=-\"2-5G-3J-\",-K='"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\n        # 移除所有 '-' 並轉為大寫\n        S = S.replace('-', '').upper()\n        n = len(S)\n        if n == 0:\n            return \"\"\n        # 第一組長度：若能整除 K 則為 K，否則為 n % K\n        first_group_len = n % K or K\n        res = [S[:first_group_len]]\n        for i in range(first_group_len, n, K):\n            res.append(S[i:i+K])\n        return '-'.join(res)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 嘗試分行讀取：第一行為字串，第二行為整數\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        s = lines[0].strip()\n        k_line = lines[1].strip()\n        try:\n            k = int(k_line)\n        except ValueError:\n            # 若第二行不是純數字，嘗試從整行中取最後一個整數\n            parts = k_line.split()\n            k = int(parts[-1]) if parts else 0\n    else:\n        # 單行輸入：最後一個整數為 K，其餘為字串\n        tokens = data.split()\n        try:\n            k = int(tokens[-1])\n            s = \"\".join(tokens[:-1])\n        except ValueError:\n            # 如果整數不在最後，直接嘗試解析\n            k = 0\n            s = data\n\n    # 移除可能的引號\n    if s.startswith('\"') and s.endswith('\"'):\n        s = s[1:-1]\n    if s.startswith(\"'\") and s.endswith(\"'\"):\n        s = s[1:-1]\n\n    solution = Solution()\n    result = solution.licenseKeyFormatting(s, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem: reformat license key string. Steps: remove dashes, uppercase, then split into groups of k from end, etc.\n\nNeed to output line by line with // explanation. Use Start, End, Decision, etc.\n\nOk.\n\nLet's craft steps:\n\nStart\n\n→ Step 1: 初始化空字符串 cleaned // 用於存儲去除破折號且大寫的字符\n\n→ Step 2: 對 s 的每個字符進行遍歷\n\n    If char != '-' Then\n        → Step 3: Append char.toUpperCase() 到 cleaned // 去掉破折號並轉大寫\n\n→ Step 3: 計算 cleaned.length\n\n→ Step 4: 計算 firstGroupSize = cleaned.length % k\n\n→ Decision: 如果 firstGroupSize == 0 且 cleaned.length > 0? // 若除不整，則首組長度為 k\n\n    Yes → Set firstGroupSize = k // 這種情況首組大小為 k\n\n    No  → // 保持原值\n\n→ Step 5: 創建結果列表 parts\n\n→ Decision: 如果 firstGroupSize > 0? // 需要先添加首組\n\n    Yes → Step 6: parts.append( cleaned.substring(0, firstGroupSize) ) // 添加首組\n\n→ Step 7: 從 cleaned 開始 index = firstGroupSize\n\n→ Decision: while index < cleaned.length? // 遍歷剩餘字符\n\n    Yes → Step 8: parts.append( cleaned.substring(index, index + k) ) // 添加下一組\n\n        → Step 9: index += k\n\n        → 回到 Decision\n\n    No  → // 完成\n\n→ Step 10: 返回 parts.join('-') // 用破折號連接\n\nEnd\n\nAdd explanations.\n\nEnsure arrow and spaces. Use Start, End. Provide lines with proper formatting.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字串 cleaned // 用於存放去除破折號並轉為大寫的字符  \n→ Step 2: 對 s 的每個字符進行遍歷  \n  → Decision: 如果 char ≠ '-'? // 檢查是否為破折號  \n   Yes → Step 3: Append char.toUpperCase() 到 cleaned // 去除破折號並轉為大寫  \n   No  → // 忽略破折號  \n→ Step 4: 計算 cleaned.length // 取得清理後字串長度  \n→ Step 5: 計算 firstGroupSize = cleaned.length % k // 取得首組可能的不足長度  \n→ Decision: 如果 firstGroupSize == 0 且 cleaned.length > 0? // 若能整除，首組長度預設為 k  \n  Yes → Step 6: Set firstGroupSize = k // 首組為 k 個字符  \n  No  → // 保持原 firstGroupSize  \n→ Step 7: 建立空列表 parts // 用於存放各個分組  \n→ Decision: 如果 firstGroupSize > 0? // 是否需要首組  \n  Yes → Step 8: parts.append( cleaned.substring(0, firstGroupSize) ) // 加入首組  \n→ Step 9: 初始化 index = firstGroupSize // 設定從哪個位置開始處理剩餘字符  \n→ Decision: while index < cleaned.length? // 仍有未處理字符  \n  Yes → Step 10: parts.append( cleaned.substring(index, index + k) ) // 加入下一個 k 個字符的分組  \n   → Step 11: index += k // 更新索引位置  \n   → 回到 Decision  \n  No  → // 所有字符已分組完成  \n→ Step 12: Return parts.join('-') // 用破折號連接所有分組生成最終字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Merge Sorted Array",
      "source_file": "Leetcode/leetcode88.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "expected_output": "[1,2,2,3,5,6]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpidnwoxag.py\", line 35, in <module>\n    data = eval('{' + raw_input + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3}\n     ^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
          "expected_output": "[1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphw6hp27k.py\", line 35, in <module>\n    data = eval('{' + raw_input + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {nums1 = [1], m = 1, nums2 = [], n = 0}\n     ^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
          "expected_output": "[1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3xtwiw4a.py\", line 35, in <module>\n    data = eval('{' + raw_input + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {nums1 = [0], m = 0, nums2 = [1], n = 1}\n     ^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        Merge nums2 into nums1 in-place.\n        \"\"\"\n        i = m - 1          # 指向 nums1 的最後一個有效元素\n        j = n - 1          # 指向 nums2 的最後一個元素\n        k = m + n - 1      # 指向 nums1 最後一個空位\n\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n\n        # 若 nums2 還有剩餘元素，直接複製過來\n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n\nif __name__ == \"__main__\":\n    # 讀取整行輸入，例如\n    # nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 轉換為 Python dict 方便取得各項值\n    data = eval('{' + raw_input + '}')\n\n    nums1 = data['nums1']\n    m = data['m']\n    nums2 = data['nums2']\n    n = data['n']\n\n    Solution().merge(nums1, m, nums2, n)\n    print(nums1)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, each line with explanation. Need to merge two sorted arrays in-place into nums1, typical Leetcode problem. We should produce a step-by-step pseudocode. Let's produce starting from Start, steps: set i = m-1, j = n-1, k = m+n-1, then loop while i>=0 and j>=0, compare nums1[i] and nums2[j], set nums1[k] accordingly, decrement pointers, after loop if j>=0, copy remaining nums2 into nums1. End. Provide explanation for each line. Use arrow lines, Decision lines. Use \"Start\", \"End\". Also use \"Yes →\", \"No →\". Format exactly. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 i = m - 1 // i 指向 nums1 的最後一個有效元素  \n→ Step 2: 設定 j = n - 1 // j 指向 nums2 的最後一個元素  \n→ Step 3: 設定 k = m + n - 1 // k 指向 nums1 最後一個空位  \n\n→ Decision: 是否還有元素可比較? i >= 0 且 j >= 0? // 判斷是否同時存在未處理的元素  \n    Yes → Decision: nums1[i] 是否大於 nums2[j]?  \n        Yes → Step 4: nums1[k] = nums1[i] // 把較大的元素放到最後  \n            → Step 5: i = i - 1 // 移動 i 指標  \n            → Step 6: k = k - 1 // 移動 k 指標  \n        No  → Step 7: nums1[k] = nums2[j] // 把 nums2 的元素放到最後  \n            → Step 8: j = j - 1 // 移動 j 指標  \n            → Step 9: k = k - 1 // 移動 k 指標  \n    No  → Decision: j 是否還有剩餘? j >= 0? // 確認是否還有 nums2 的元素  \n        Yes → Step 10: nums1[k] = nums2[j] // 將剩餘的 nums2 元素複製到 nums1  \n            → Step 11: j = j - 1 // 移動 j 指標  \n            → Step 12: k = k - 1 // 移動 k 指標  \n            → Repeat Step 10-12 until j < 0  \n        No  → End // 所有元素已合併，結束程式  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Assign Cookies",
      "source_file": "Leetcode/leetcode455.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "g = [1,2,3], s = [1,1]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxg_7tv1j.py\", line 40, in <module>\n    g_list, s_list = parse_input(raw)\n                     ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpxg_7tv1j.py\", line 29, in parse_input\n    g = eval(expr.strip())\n        ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "g = [1,2], s = [1,2,3]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqsggkvy8.py\", line 40, in <module>\n    g_list, s_list = parse_input(raw)\n                     ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqsggkvy8.py\", line 29, in parse_input\n    g = eval(expr.strip())\n        ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findContentChildren(self, g, s):\n        # 先將需求與餅乾大小各自排序\n        g.sort()\n        s.sort()\n        i = j = 0\n        # i: 目前要滿足的孩子索引，j: 目前可考慮的餅乾索引\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                # 這塊餅乾足夠滿足第 i 個孩子，計數加一\n                i += 1\n            # 無論是否滿足，下一塊餅乾都要考慮\n            j += 1\n        # i 代表已滿足的孩子數\n        return i\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'g = [1,2,3], s = [1,1]' 的輸入字串。\n    返回兩個 list: g, s。\n    \"\"\"\n    g = s = None\n    parts = [p.strip() for p in data.split(',')]\n    for part in parts:\n        if part.startswith('g'):\n            _, expr = part.split('=', 1)\n            g = eval(expr.strip())\n        elif part.startswith('s'):\n            _, expr = part.split('=', 1)\n            s = eval(expr.strip())\n    return g, s\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n    g_list, s_list = parse_input(raw)\n    # 呼叫解法並輸出結果\n    result = Solution().findContentChildren(g_list, s_list)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with arrow, decision etc. Provide simple algorithm: sort greed and sizes, two pointers. We must output maximum number.\n\nWe need to output as per format. Let's craft.\n\nStart\n→ Step 1: Sort greed array g in non-decreasing order\n→ Step 2: Sort cookie sizes array s in non-decreasing order\n→ Step 3: Initialize pointers i=0 (child index), j=0 (cookie index), count=0\n→ Decision: If i < len(g) and j < len(s)? // still children and cookies left\n    Yes → Decision: If s[j] >= g[i]? // cookie big enough for child\n        Yes → Step 4: Assign cookie j to child i // child satisfied\n            → Increment count by 1\n            → Increment i and j by 1\n        No  → Step 5: Increment j by 1 // cookie too small, try next cookie\n    No  → End loop\n→ Step 6: Output count // maximum content children\n\nBut need arrow format: \"Decision: ...\" lines, and arrow lines.\n\nLet's format accordingly.\n\nAlso include End at end.\n\nLet's produce output lines with arrow indenting as needed.\n\nWe need to ensure each line: Virtual code step + space + // explanation.\n\nLet's output:\n\nStart // 程式開始執行\n→ Decision: 若 g 及 s 為空? // 檢查輸入是否有孩子與餅乾\n    Yes → End // 沒有輸入則結束\n    No  → Step 1: 將 g 按遞增排序 // 讓最小需求先處理\n→ Step 2: 將 s 按遞增排序 // 讓最小尺寸先使用\n→ Step 3: 設定 i = 0, j = 0, count = 0 // 初始化索引與計數\n→ Decision: i < len(g) 與 j < len(s)？ // 還有孩子和餅乾未處理\n    Yes → Decision: s[j] >= g[i]？ // 目前餅乾是否足夠滿足孩子\n        Yes → Step 4: count++ // 讓孩子滿足\n            → i++ // 移到下一個孩子\n            → j++ // 移到下一個餅乾\n        No  → Step 5: j++ // 餅乾太小，嘗試下一個餅乾\n    No  → End // 所有孩子或餅乾處理完\n→ Step 6: 輸出 count // 最大滿足孩子數\n\nBut we should maybe maintain same style as example: Use arrow lines for steps, decisions. After each step or decision, include comment.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 若 g 與 s 為空? // 檢查輸入是否有孩子與餅乾  \n  Yes → End // 沒有輸入則結束  \n  No  → Step 1: 將 g 按遞增排序 // 讓最小需求先處理  \n→ Step 2: 將 s 按遞增排序 // 讓最小尺寸先使用  \n→ Step 3: 設定 i = 0, j = 0, count = 0 // 初始化索引與計數  \n→ Decision: i < len(g) 與 j < len(s)？ // 還有孩子與餅乾未處理  \n  Yes → Decision: s[j] >= g[i]？ // 目前餅乾是否足夠滿足孩子  \n    Yes → Step 4: count++ // 讓孩子滿足  \n     → i++ // 移到下一個孩子  \n     → j++ // 移到下一個餅乾  \n    No  → Step 5: j++ // 餅乾太小，嘗試下一個餅乾  \n  No  → End // 所有孩子或餅乾處理完  \n→ Step 6: 輸出 count // 最大滿足孩子數  \nEnd // 程式執行結束"
    },
    {
      "title": "Compare Version Numbers",
      "source_file": "Leetcode/leetcode165.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "version1 = \"1.01\", version2 = \"1.001\"",
          "expected_output": "0",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '0'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        v1 = [int(x) for x in version1.split('.')]\n        v2 = [int(x) for x in version2.split('.')]\n        for i in range(max(len(v1), len(v2))):\n            num1 = v1[i] if i < len(v1) else 0\n            num2 = v2[i] if i < len(v2) else 0\n            if num1 < num2:\n                return -1\n            if num1 > num2:\n                return 1\n        return 0\n\ndef main():\n    data = sys.stdin.read()\n    # 尋找所有以點分隔的數字串，通常即為版本號\n    versions = re.findall(r'[\\d\\.]+', data)\n    if len(versions) < 2:\n        # 若找不到足夠版本號，直接退出\n        return\n    version1, version2 = versions[0], versions[1]\n    sol = Solution()\n    result = sol.compareVersion(version1, version2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce step-by-step pseudocode. Provide each line with explanation. Must use Start, End, Decision. Use arrow notation. Must not output actual code. Provide virtual steps.\n\nLet's think of steps:\n\n1. Start.\n2. Split version1 by '.' into list rev1.\n3. Split version2 by '.' into list rev2.\n4. Determine max length = max(len(rev1), len(rev2)).\n5. Loop i from 0 to maxLen-1:\n   - val1 = int(rev1[i]) if i < len(rev1) else 0\n   - val2 = int(rev2[i]) if i < len(rev2) else 0\n   - Decision: if val1 < val2? Yes → Return -1\n              No → if val1 > val2? Yes → Return 1\n   - else continue loop\n6. After loop, Return 0.\n7. End.\n\nWe should produce each step line with explanation. Also decisions have nested yes no. Use indentation.\n\nLet's craft.\n\nWe should produce lines like:\n\nStart // 程式開始執行\n→ Step 1: Split version1 by '.' into list rev1 // 取得 version1 的所有修訂版號\n→ Step 2: Split version2 by '.' into list rev2 // 取得 version2 的所有修訂版號\n→ Step 3: maxLen ← max(length of rev1, length of rev2) // 取較長修訂版號的長度\n→ Decision: 是否需要迴圈? // 檢查是否有修訂版號需要比較\n    Yes → For i = 0 to maxLen-1: // 從最左邊開始逐一比較\n        → Step 4: val1 ← (i < length of rev1) ? integer of rev1[i] : 0 // 取得第 i 個修訂值或 0\n        → Step 5: val2 ← (i < length of rev2) ? integer of rev2[i] : 0 // 取得第 i 個修訂值或 0\n        → Decision: if val1 < val2? // 比較兩個修訂值\n            Yes → Return -1 // version1 小於 version2\n            No  → Decision: if val1 > val2? // 仍需比較\n                Yes → Return 1 // version1 大於 version2\n                No  → // 兩個修訂值相同，繼續下一個迴圈\n    No  → // 兩個版本沒有任何修訂值，直接相等\n→ Step 6: Return 0 // 所有修訂值相同，版本相等\nEnd // 程式執行結束\n\nBut need to format each line with \"→ Step\" maybe not necessary for For loop. Could use Step 6 etc. Use indentation for nested decisions.\n\nBetter produce something like:\n\nStart // 程式開始執行\n→ Step 1: rev1 ← split version1 by '.' // 取得 version1 的修訂版號清單\n→ Step 2: rev2 ← split version2 by '.' // 取得 version2 的修訂版號清單\n→ Step 3: maxLen ← max(length(rev1), length(rev2)) // 取較長的修訂版號長度\n→ Decision: 是否有修訂版號需要比較? // 若 maxLen > 0 才進入迴圈\n    Yes → For i = 0 to maxLen-1: // 逐個修訂版號進行比較\n        → Step 4: v1 ← (i < length(rev1)) ? integer(rev1[i]) : 0 // 取 rev1 的第 i 個修訂值，缺失時為 0\n        → Step 5: v2 ← (i < length(rev2)) ? integer(rev2[i]) : 0 // 取 rev2 的第 i 個修訂值，缺失時為 0\n        → Decision: if v1 < v2? // 判斷哪個版本較小\n            Yes → Return -1 // version1 小於 version2\n            No  → Decision: if v1 > v2? // 判斷哪個版本較大\n                Yes → Return 1 // version1 大於 version2\n                No  → // v1 == v2，繼續迴圈\n    No  → // maxLen 為 0，兩個版本都沒有修訂版號\n→ Step 6: Return 0 // 所有修訂版號相等，返回 0\nEnd // 程式執行結束\n\nWe need to ensure each line is single line with \"→\" or other. The For loop may be represented as a Step that includes loop. We can break into separate Step for For loop.\n\nBut requirement: \"逐行輸出\" each line must contain 虛擬碼步驟 + '//' explanation. Use arrow syntax. The example shows each line starting with \"→ Step X:\" etc. For decisions, nested Yes No lines.\n\nWe should produce lines like:\n\nStart // 程式開始執行\n→ Step 1: rev1 ← split(version1, '.') // 取得 version1 的修訂版號清單\n→ Step 2: rev2 ← split(version2, '.') // 取得 version2 的修訂版號清單\n→ Step 3: maxLen ← max(length(rev1), length(rev2)) // 取較長修訂版號長度\n→ Decision: maxLen > 0? // 是否需要比較修訂版號\n    Yes → For i = 0 to maxLen-1: // 從最左邊開始逐一比較\n        → Step 4: v1 ← (i < length(rev1)) ? int(rev1[i]) : 0 // 取第 i 個修訂值，缺失時為 0\n        → Step 5: v2 ← (i < length(rev2)) ? int(rev2[i]) : 0 // 取第 i 個修訂值，缺失時為 0\n        → Decision: v1 < v2? // 判斷哪個版本較小\n            Yes → Return -1 // version1 小於 version2\n            No  → Decision: v1 > v2? // 判斷哪個版本較大\n                Yes → Return 1 // version1 大於 version2\n                No  → // v1 == v2，繼續比較下一個修訂版號\n    No  → // maxLen 為 0，兩個版本都沒有修訂版號\n→ Step 6: Return 0 // 所有修訂版號相等，返回 0\nEnd // 程式執行結束\n\nMake sure each line has '//' after. Provide explanation in Chinese.\n\nWe need to output exactly lines, no extra formatting. Use indentation? The example uses indentation with spaces. We'll follow same style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: rev1 ← split(version1, '.') // 取得 version1 的修訂版號清單  \n→ Step 2: rev2 ← split(version2, '.') // 取得 version2 的修訂版號清單  \n→ Step 3: maxLen ← max(length(rev1), length(rev2)) // 取較長修訂版號長度  \n→ Decision: maxLen > 0? // 是否需要比較修訂版號  \n Yes → For i = 0 to maxLen-1: // 從最左邊開始逐一比較  \n  → Step 4: v1 ← (i < length(rev1)) ? int(rev1[i]) : 0 // 取第 i 個修訂值，缺失時為 0  \n  → Step 5: v2 ← (i < length(rev2)) ? int(rev2[i]) : 0 // 取第 i 個修訂值，缺失時為 0  \n  → Decision: v1 < v2? // 判斷哪個版本較小  \n   Yes → Return -1 // version1 小於 version2  \n   No  → Decision: v1 > v2? // 判斷哪個版本較大  \n    Yes → Return 1 // version1 大於 version2  \n    No  → // v1 == v2，繼續比較下一個修訂版號  \n No  → // maxLen 為 0，兩個版本都沒有修訂版號  \n→ Step 6: Return 0 // 所有修訂版號相等，返回 0  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[], [1], [2], [1, 2], [2, 2], [1, 2, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        nums.sort()\n        result = [[]]  # start with empty subset\n        for num in nums:\n            new_subsets = []\n            for subset in result:\n                new_subsets.append(subset + [num])\n            result += new_subsets\n        # remove duplicate subsets\n        unique = []\n        seen = set()\n        for subset in result:\n            t = tuple(subset)\n            if t not in seen:\n                seen.add(t)\n                unique.append(subset)\n        return unique\n\ndef parse_input(data):\n    \"\"\"Parse input that may look like 'nums = [1,2,2]' or just '[1,2,2]'.\"\"\"\n    data = data.strip()\n    if data.lower().startswith('nums'):\n        eq_index = data.find('=')\n        if eq_index != -1:\n            expr = data[eq_index + 1:].strip()\n        else:\n            expr = data\n    else:\n        expr = data\n    return ast.literal_eval(expr)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit()\n    nums = parse_input(raw_input)\n    solution = Solution()\n    subsets = solution.subsetsWithDup(nums)\n    print(subsets)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, each line with explanation. Problem: subsets with duplicates: typical backtracking with sorting and skipping duplicates. Output all subsets. Need to produce steps. So steps: Start, sort nums, define result list, backtrack function. For i in range(start, len(nums)): if i>start and nums[i]==nums[i-1] skip. Append nums[i], backtrack(i+1), pop. Also need to include initial empty subset. So produce steps accordingly. Each line in virtual code with explanation. Use arrow formatting. Let's craft.\n\nRemember to use virtual code arrows: Start, End, Decision, etc.\n\nLet's produce step by step.\n\nAlso need to include '→ Step X:' etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort the array `nums` in non‑decreasing order // 先排序，方便後續跳過重複元素  \n→ Step 2: Initialize `result` as an empty list // 存放所有子集的結果  \n→ Step 3: Add the empty subset `[]` to `result` // 空集必為合法子集  \n→ Step 4: Define recursive function `backtrack(start, current)` // 從 index `start` 開始選取元素，`current` 是目前已選的子集  \n\n  → Step 4.1: Add a copy of `current` to `result` // 每次進入回溯時都把當前子集加入結果  \n  → Decision: 循環從 `i = start` 到 `len(nums)-1` // 嘗試把每個可用元素加入子集  \n     Yes → Step 4.2: If `i > start` AND `nums[i] == nums[i-1]` THEN  \n       → Decision: 跳過重複元素? // 為避免重複子集  \n         Yes → Continue // 跳過此迴圈，執行下一個 i  \n         No → No action  \n       End  \n         \n       → Step 4.3: Append `nums[i]` to `current` // 選取當前元素  \n       → Step 4.4: Call `backtrack(i+1, current)` // 深入下一層  \n       → Step 4.5: Remove the last element from `current` // 回溯，撤銷選擇  \n\n→ End // 程式執行結束，`result` 即為所有不重複的子集集合\n\n**說明**  \n1. `Start` 開始執行。  \n2. `Sort` 方便後續跳過重複元素。  \n3. `result` 存儲所有子集。  \n4. 空集作為初始子集加入。  \n5. `backtrack` 以遞歸方式構造子集。  \n6. 每次進入遞歸時先把目前子集加入結果。  \n7. 循環選取可用元素，若前一個元素相同且位置不在起點，則跳過，防止重複子集。  \n8. 進入遞歸時把元素加入 `current`，遞歸完成後移除，實現回溯。  \n9. `End` 結束程式，`result` 為最終答案。"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,4,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 4, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立每個數字對應的索引列表\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機選擇一個符合 target 的索引\n        return random.choice(self.indices[target])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入格式：[\"Solution\", \"pick\", ...], [[[...]], ...]\n    # 將第一個列表與第二個列表分開\n    first_part, second_part = data.split('],', 1)\n    commands = ast.literal_eval(first_part + ']')\n    args_list = ast.literal_eval(second_part)\n\n    results = []\n    obj = None\n    for i, cmd in enumerate(commands):\n        args = args_list[i]\n        if cmd == \"Solution\":\n            # 初始化物件\n            obj = Solution(args[0])\n            results.append(None)\n        elif cmd == \"pick\":\n            # 執行 pick，args 為 [target]\n            res = obj.pick(args[0])\n            results.append(res)\n\n    # 輸出結果，使用 json.dumps 以得到 null 而非 \"null\"\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, with explanation comment. We need to design algorithm: On initialization store mapping from target to list of indices, or use reservoir sampling each call. The common solution: store map target -> list indices for O(1) pick. We'll produce virtual code accordingly.\n\nAlso must follow format: each line `虛擬碼步驟 // 解釋`. Use arrow symbols, Start, End, Decision: etc.\n\nWe must provide virtual code lines that represent algorithm. Not actual code, just steps.\n\nWe need to show: Start -> initialize data structure, mapping etc. Step 1: Constructor: iterate array and map each number to list of indices. Then Step 2: pick function: get list, generate random int between 0 and len-1, return that index.\n\nAlso maybe include Decision: check if map has target etc. but given assumption, we can skip check.\n\nWe need to use arrow symbols.\n\nLet's craft.\n\nLine 1: Start // 程式開始\n\nLine 2: → Step 1: 定義 Solution 類別，包含 map: 數字 → 其所有索引列表 // 初始化資料結構\n\nLine 3: → Step 2: Constructor(Solution) → 逐一遍歷 nums，將每個索引加入對應數字的索引列表 // 構建索引映射\n\nWe need sub-steps for iteration maybe:\n\n→ Decision: if map 里沒有 key nums[i]? but we can just add to list.\n\nBut we can skip decision.\n\nLine 4: → Step 3: pick(target) → 從 map 取 target 對應的索引列表 // 取得所有可能索引\n\nLine 5: → Step 4: 產生隨機整數 r 在 [0, list長度-1] 之間 // 隨機選取一個索引\n\nLine 6: → Step 5: 返回 list[r] // 回傳隨機索引\n\nLine 7: End // 程式結束\n\nBut the requirement: use Decision: maybe to illustrate randomness. Use Yes/No? Not necessary. But maybe we show Decision: random r < length? Actually random r always valid.\n\nWe can also show Decision: if target exists? But assumption ensures existence.\n\nBut maybe we can show Decision: if list 空? But not.\n\nWe can show Decision: if list empty? No.\n\nLet's just keep simple.\n\nWe need to use arrow for each step. Each line should contain \"虛擬碼步驟 [space] // 解釋\".\n\nWe'll use \"Start\" and \"End\" with // explanation. Use arrow for subsequent steps: \"→\".\n\nWe also may use \"Decision:\" for any if.\n\nBut there are no if needed. But we could use Decision to indicate \"如果 map 里沒有 key\" but we can skip.\n\nHowever to satisfy style, maybe we can include Decision in constructor to handle map creation. But not necessary.\n\nWe can just produce straightforward steps.\n\nAlso maybe show that pick uses reservoir sampling? But mapping is simpler.\n\nLet's produce:\n\n```\nStart // 程式開始執行\n→ Step 1: 定義 Solution 類別並初始化一個空的字典 map // 用於儲存每個數字對應的索引列表\n→ Step 2: Constructor(nums) → 迭代 nums，對於每個索引 i：\n    → Decision: map 是否已包含 nums[i]？\n        Yes → 將 i 加入 map[nums[i]] 的列表中 // 已有索引列表，追加新索引\n        No  → 建立新列表 [i] 並賦值給 map[nums[i]] // 首次遇到該數字，創建列表\n→ Step 3: pick(target) → 從 map 取得 target 對應的索引列表 indices // 獲取所有符合的索引\n→ Step 4: 產生隨機整數 r 在 0 到 indices 長度-1 之間 // 隨機挑選其中一個索引\n→ Step 5: 回傳 indices[r] // 回傳隨機索引\nEnd // 程式執行結束\n```\n\nMake sure each line has arrow and explanation. The decision block lines also need to be separate lines.\n\nThus produce as required.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義 Solution 類別並初始化一個空的字典 map // 用於儲存每個數字對應的索引列表\n→ Step 2: Constructor(nums) → 迭代 nums，對於每個索引 i：\n    → Decision: map 是否已包含 nums[i]？\n        Yes → 將 i 加入 map[nums[i]] 的列表中 // 已有索引列表，追加新索引\n        No  → 建立新列表 [i] 並賦值給 map[nums[i]] // 首次遇到該數字，創建列表\n→ Step 3: pick(target) → 從 map 取得 target 對應的索引列表 indices // 獲取所有符合的索引\n→ Step 4: 產生隨機整數 r 在 0 到 indices 長度-1 之間 // 隨機挑選其中一個索引\n→ Step 5: 回傳 indices[r] // 回傳隨機索引\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[0,1],[1,0],[2,3],[4,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[0, 1], [1, 0], [2, 3], [4, 2]]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立字串到索引的映射\n        word_to_idx = {w: i for i, w in enumerate(words)}\n        res = []\n        seen = set()\n\n        # 處理空字串的特殊情況\n        if \"\" in word_to_idx:\n            empty_idx = word_to_idx[\"\"]\n            for i, w in enumerate(words):\n                if i == empty_idx:\n                    continue\n                if w == w[::-1]:\n                    pair1 = (empty_idx, i)\n                    pair2 = (i, empty_idx)\n                    if pair1 not in seen:\n                        res.append([pair1[0], pair1[1]])\n                        seen.add(pair1)\n                    if pair2 not in seen:\n                        res.append([pair2[0], pair2[1]])\n                        seen.add(pair2)\n\n        # 對每個字串檢查所有切分點\n        for i, word in enumerate(words):\n            # 跳過空字串已處理\n            if word == \"\":\n                continue\n            n = len(word)\n            for cut in range(n + 1):\n                prefix = word[:cut]\n                suffix = word[cut:]\n\n                # 如果前綴是回文，檢查反轉後的後綴是否存在\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    j = word_to_idx.get(rev_suffix)\n                    if j is not None and j != i:\n                        pair = (i, j)\n                        if pair not in seen:\n                            res.append([pair[0], pair[1]])\n                            seen.add(pair)\n\n                # 如果後綴是回文且 cut != n（避免重複）\n                if suffix == suffix[::-1] and cut != n:\n                    rev_prefix = prefix[::-1]\n                    j = word_to_idx.get(rev_prefix)\n                    if j is not None and j != i:\n                        pair = (j, i)\n                        if pair not in seen:\n                            res.append([pair[0], pair[1]])\n                            seen.add(pair)\n\n        return res\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print([])\n        return\n\n    # 如果輸入像 \"words = [...]\"，去掉 \"words = \"\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n\n    # 用 ast.literal_eval 解析為 Python 資料結構\n    try:\n        words = ast.literal_eval(data)\n    except Exception:\n        # 若解析失敗，直接輸出空列表\n        print([])\n        return\n\n    if not isinstance(words, list):\n        print([])\n        return\n\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation. The algorithm is known: for each word, we reverse it, use hash map of word to index, and check splits. Complexity linear sum of lengths. Steps: build map of word->index. For each word at index i, for each split position k from 0 to len, check prefix and suffix. If prefix is palindrome, find reverse of suffix and if exists j != i, add (j,i). Similarly if suffix palindrome, find reverse of prefix and add (i,j). Also handle empty string special. Also duplicates? unique strings.\n\nWe produce virtual code with arrows. We must be concise. Each line of virtual code plus explanation.\n\nWe produce start, steps, decisions, loops.\n\nWe cannot output actual code but virtual pseudocode.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 hashMap，key 為 words[i]，value 為 i // 用來快速查找反轉字串的索引  \n→ Decision: 若 words[i] 為空字串? // 空字串需要特殊處理  \n  Yes → Step 2: 對所有非空索引 j, 輸出 (i,j) 與 (j,i) // 空字串與任何字串皆為回文對  \n  No → Step 3: 進入常規處理 // 進一步檢查每個字串  \n→ For i in 0 .. words.length-1: // 遍歷所有字串  \n  → Step 4: 將 words[i] 設為 currentWord  \n  → For splitPos in 0 .. currentWord.length: // 逐字檢查所有切分點  \n    → Step 5: 定義 prefix = currentWord[0:splitPos], suffix = currentWord[splitPos:]  \n    → Decision: prefix 是否為回文? // 判斷左半邊是否為回文  \n      Yes → Step 6: reverseSuffix = Reverse(suffix)  \n      → Decision: reverseSuffix 在 hashMap?  \n        Yes → Step 7: 若 index != i, 輸出 (index, i) // 逆序後的字串加上當前字串為回文  \n        No → 何也不做  \n      No → 何也不做  \n    → Decision: suffix 是否為回文? // 判斷右半邊是否為回文  \n      Yes → Step 8: reversePrefix = Reverse(prefix)  \n      → Decision: reversePrefix 在 hashMap?  \n        Yes → Step 9: 若 index != i, 輸出 (i, index) // 當前字串加上逆序後的字串為回文  \n        No → 何也不做  \n      No → 何也不做  \n→ End // 程式執行結束, 回傳所有已輸出的回文對列表"
    },
    {
      "title": "Regular Expression Matching",
      "source_file": "Leetcode/leetcode10.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "actual_output_or_error": "File \"/tmp/tmpp0tior1x.py\", line 31\n    \"\"\"Parse input like: s = \"aa\", p = \"a\"\"\"\"\n                                            ^\nSyntaxError: unterminated string literal (detected at line 31)"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"a*\"",
          "expected_output": "true",
          "actual_output_or_error": "File \"/tmp/tmp37t7ooqi.py\", line 31\n    \"\"\"Parse input like: s = \"aa\", p = \"a\"\"\"\"\n                                            ^\nSyntaxError: unterminated string literal (detected at line 31)"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\", p = \".*\"",
          "expected_output": "true",
          "actual_output_or_error": "File \"/tmp/tmp5x7gs6rt.py\", line 31\n    \"\"\"Parse input like: s = \"aa\", p = \"a\"\"\"\"\n                                            ^\nSyntaxError: unterminated string literal (detected at line 31)"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        # Handle patterns that can match an empty string\n        for j in range(2, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    # Zero occurrence of the element before '*'\n                    dp[i][j] = dp[i][j - 2]\n                    # One or more occurrences if the preceding element matches s[i-1]\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n                else:\n                    # Match current characters\n                    if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                        dp[i][j] = dp[i - 1][j - 1]\n\n        return dp[m][n]\n\ndef parse_input(data: str):\n    \"\"\"Parse input like: s = \"aa\", p = \"a\"\"\"\"\n    pattern = r's\\s*=\\s*\"([^\"]*)\",\\s*p\\s*=\\s*\"([^\"]*)\"'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"Input format incorrect\")\n    return match.group(1), match.group(2)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    s, p = parse_input(raw_input)\n    sol = Solution()\n    result = sol.isMatch(s, p)\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for regular expression matching with '.' and '*', covering entire string. So typical DP solution. The virtual code will be step by step: Start, read s and p, define DP table dp[i][j] etc. Use recursion? Provide steps.\n\nWe need to produce lines with arrow and explanation. We'll produce a high-level algorithm.\n\nLet's design: Start, read s,p. Let m=length(s), n=length(p). Create 2D array dp (m+1) x (n+1) bool. Initialize dp[0][0] = true. Then loop i from 0 to m; inside loop j from 1 to n. For each j, if p[j-1] == '*', then dp[i][j] = dp[i][j-2] OR (i>0 AND matches(s[i-1], p[j-2]) AND dp[i-1][j]). Else dp[i][j] = i>0 AND matches(s[i-1], p[j-1]) AND dp[i-1][j-1]. Finally return dp[m][n].\n\nWe'll output virtual code lines.\n\nAlso need decision lines.\n\nLet's produce step by step. Use \"Decision:\" for branching.\n\nWe'll include steps for matches function.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 s 與模式 p // 取得要比對的字串與正則表達式\n→ Step 2: 設定 m = 長度(s), n = 長度(p) // 方便後續迴圈使用\n→ Step 3: 建立二維布林表 dp[0..m][0..n] 並全部初始化為 false // dp[i][j] 代表 s[0..i-1] 與 p[0..j-1] 是否匹配\n→ Step 4: 設定 dp[0][0] = true // 空字串與空模式相匹配\n→ Decision: 是否存在任何可匹配的模式開始位置? // 檢查 p 中以 '*' 作為結尾的子模式是否能匹配空字串\n    Yes → Step 5: 對 j 從 1 到 n:\n        → Decision: p[j-1] 是否為 '*'? // 若是 '*', 前一個字符可為零次\n            Yes → Step 6: 設定 dp[0][j] = dp[0][j-2] // 去掉前兩個字符後檢查是否已匹配\n            No  → Step 7: 設定 dp[0][j] = false // 其它情況下空字串無法匹配\n→ Step 8: 迴圈 i 從 1 到 m:\n    → Step 9: 迴圈 j 從 1 到 n:\n        → Decision: p[j-1] 是否為 '*'? // '*' 需要考慮前兩個字符\n            Yes → Step 10: \n                → Decision: i > 0 AND match(s[i-1], p[j-2])? // 前一字符與 p[j-2] 是否相符\n                    Yes → Step 11: 設定 dp[i][j] = dp[i][j-2] OR (dp[i-1][j] AND match(s[i-1], p[j-2])) // 零次或多次匹配\n                    No  → Step 12: 設定 dp[i][j] = dp[i][j-2] // 只能為零次\n            No  → Step 13: \n                → Decision: i > 0 AND match(s[i-1], p[j-1])? // 普通字符或 '.'\n                    Yes → Step 14: 設定 dp[i][j] = dp[i-1][j-1] // 需要前一個位置已匹配\n                    No  → Step 15: 設定 dp[i][j] = false // 不匹配\n→ Step 16: 回傳 dp[m][n] // 若整個字串與模式都匹配則為 true\n→ End // 程式執行結束\n\n// 下面是 match 函式的虛擬碼，檢查單個字符是否相符\nStart // match 函式開始\n→ Step 1: 定義函式 match(a, b) // a 是 s 的字符，b 是 p 的字符\n→ Decision: b 是否為 '.'? // '.' 代表任何字符\n    Yes → Step 2: 回傳 true // 任何字符都匹配\n    No  → Step 3: 回傳 a == b // 直接比較字元\nEnd // match 函式結束"
    },
    {
      "title": "Implement Queue using Stacks",
      "source_file": "Leetcode/leetcode232.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdg86_xxc.py\", line 31, in <module>\n    ops = json.loads(data[0])          # 例如 [\"MyQueue\",\"push\",\"push\",\"peek\",\"pop\",\"empty\"]\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 355, in raw_decode\n    raise JSONDecodeError(\"Expecting value\", s, err.value) from None\njson.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        self.peek()\n        return self.stack_out.pop()\n\n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self):\n        return not self.stack_in and not self.stack_out\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入，預期兩行：操作名稱列表與對應參數列表\n    data = sys.stdin.read().strip().splitlines()\n    if not data or len(data) < 2:\n        sys.exit(0)\n\n    ops = json.loads(data[0])          # 例如 [\"MyQueue\",\"push\",\"push\",\"peek\",\"pop\",\"empty\"]\n    args = json.loads(data[1])         # 例如 [[],[1],[2],[],[],[]]\n\n    q = MyQueue()\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"push\":\n            # push 的參數是單個值，包在列表中\n            q.push(arg[0] if isinstance(arg, list) else arg)\n            results.append(None)  # push 返回 None，對應 JSON 中的 null\n        elif op == \"pop\":\n            results.append(q.pop())\n        elif op == \"peek\":\n            results.append(q.peek())\n        elif op == \"empty\":\n            results.append(q.empty())\n        else:\n            # 若遇到未知操作，可忽略或處理錯誤\n            results.append(None)\n\n    # 輸出符合 JSON 格式的結果，true/false/ null 將以小寫呈現\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. No real code. Only steps. Need to implement queue with two stacks, push, pop, peek, empty.\n\nWe must use virtual code lines: Start, Step, Decision, etc. We need to produce pseudo-code, but not actual code. Use arrows and decisions. Provide explanation comments after each line.\n\nWe'll need to show initialization: stack1, stack2. For push, push onto stack1. For pop, if stack2 empty, transfer all from stack1 to stack2. Then pop from stack2. For peek similar. For empty, check both stacks empty.\n\nWe should structure each method as separate sections? The virtual code should probably show entire class and methods. We'll output lines like:\n\nStart // 程式開始執行\n→ Step 1: Initialize stack1 // stack1 用於存入\n→ Step 2: Initialize stack2 // stack2 用於出隊\n\nThen method definitions. For push(x):\n→ Method push(x): // 定義 push\n    → Step push: stack1.push(x) // 把元素入 stack1\n\nFor pop:\n→ Method pop(): // 定義 pop\n    → Decision: 是否 stack2 非空? // 檢查是否已有待出元素\n        Yes → Step pop: return stack2.pop() // 直接出\n        No  → Step transfer: while stack1 非空: stack2.push(stack1.pop()) // 移動\n        → Step pop: return stack2.pop() // 之後出\n\nSimilar for peek: check stack2, else transfer then peek.\n\nFor empty: Decision: stack1.empty AND stack2.empty? return true else false.\n\nWe need to maintain each line with arrow. Use arrows for decisions. Provide explanation after //.\n\nLet's create each line accordingly.\n\nImportant: Provide virtual code only; no actual code like class MyQueue. Use generic lines.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Initialize stack1 // 用於存入元素\n→ Initialize stack2 // 用於出隊\n\n→ Define push(x) // push 方法\n    → stack1.push(x) // 將元素推入 stack1\n\n→ Define pop() // pop 方法\n    → Decision: stack2 非空? // 判斷 stack2 是否已有元素\n        Yes → stack2.pop() // 直接從 stack2 彈出\n        No  → Decision: stack1 非空? // 若 stack2 為空，檢查 stack1\n            Yes → While stack1 非空: stack2.push(stack1.pop()) // 轉移\n            No  → // queue 仍空，根據需求可處理錯誤\n        → stack2.pop() // 轉移後彈出\n\nBut need to maintain format: each line begins with arrow or Start or End. For decisions, indent? The example shows indentation inside decisions. We can indent lines after decision with spaces or tabs. Use two spaces indent? Example uses four spaces maybe. We'll mimic example.\n\nLet's produce.\n\nAlso End after all methods. Might be at End // 程式執行結束\n\nLet's create.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Initialize stack1 // 用來存入\n→ Initialize stack2 // 用來取出\n\n→ Define push(x) // push 方法\n    → stack1.push(x) // 把元素推進 stack1\n\n→ Define pop() // pop 方法\n    → Decision: stack2 非空? // 檢查是否已有待取元素\n        Yes → stack2.pop() // 直接彈出\n        No  → Decision: stack1 非空? // 若 stack2 為空，檢查 stack1\n            Yes → While stack1 非空: stack2.push(stack1.pop()) // 移動元素\n            No  → // 堆疊都空，視情況回傳錯誤或空值\n        → stack2.pop() // 轉移後彈出\n\n→ Define peek() // peek 方法\n    → Decision: stack2 非空? // 是否已經有前端元素\n        Yes → stack2.peek() // 直接返回\n        No  → Decision: stack1 非空? // 若 stack2 空，檢查 stack1\n            Yes → While stack1 非空: stack2.push(stack1.pop()) // 移動\n            No  → // 堆疊皆空，返回錯誤或空值\n        → stack2.peek() // 轉移後返回\n\n→ Define empty() // empty 方法\n    → Decision: stack1.empty() AND stack2.empty()? // 檢查兩個堆疊是否皆空\n        Yes → true // queue 空\n        No  → false // 有元素\n\nEnd // 程式執行結束\n\nBut we must maintain correct formatting: each line with arrow. For nested blocks, indent. In example, they use arrow to indicate step and indent with spaces and tabs inside decision. We can mimic.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Initialize stack1 // 用於存入元素\n→ Initialize stack2 // 用於出隊\n\n→ Define push(x) // push 方法\n    → stack1.push(x) // 把元素推進 stack1\n\n→ Define pop() // pop 方法\n    → Decision: stack2 非空? // 檢查 stack2 是否已有待取元素\n        Yes → stack2.pop() // 直接彈出\n        No  → Decision: stack1 非空? // 若 stack2 為空，檢查 stack1\n            Yes → While stack1 非空: stack2.push(stack1.pop()) // 轉移元素\n            No  → // 堆疊都空，視情況回傳錯誤或空值\n        → stack2.pop() // 轉移後彈出\n\n→ Define peek() // peek 方法\n    → Decision: stack2 非空? // 是否已有前端元素\n        Yes → stack2.peek() // 直接返回\n        No  → Decision: stack1 非空? // 若 stack2 空，檢查 stack1\n            Yes → While stack1 非空: stack2.push(stack1.pop()) // 轉移\n            No  → // 堆疊皆空，返回錯誤或空值\n        → stack2.peek() // 轉移後返回\n\n→ Define empty() // empty 方法\n    → Decision: stack1.empty() AND stack2.empty()? // 檢查兩個堆疊是否皆空\n        Yes → true // queue 空\n        No  → false // 有元素\n\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        Return the length of the longest uncommon subsequence among the strings.\n        If none exists, return -1.\n        \"\"\"\n        # Count frequency of each string\n        freq = Counter(strs)\n\n        # Find the maximum length among strings that appear exactly once\n        longest_unique = max(\n            (len(s) for s, count in freq.items() if count == 1),\n            default=-1\n        )\n        return longest_unique\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    # Parse the input as a JSON array of strings\n    try:\n        strs = json.loads(raw_input)\n    except json.JSONDecodeError:\n        # If input is not valid JSON, treat it as an empty list\n        strs = []\n\n    # Instantiate the solution and compute the result\n    solution = Solution()\n    result = solution.findLUSlength(strs)\n\n    # Print the result to stdout\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code with explanations, no actual code. Need to interpret the problem: longest uncommon subsequence between strings array. Standard solution: If there is any string that is not equal to another string, then answer is length of the longest string that is unique. Because any string that is not repeated is an uncommon subsequence of itself (since it's subsequence of itself but not of other identical ones). Actually we need longest uncommon subsequence. Known solution: If all strings equal, return -1. Else, find the longest string that is unique (no duplicates). Return its length. Because any other string of same length might not be subsequence of others. The reasoning: For two strings, the longest uncommon subsequence is the longest string that doesn't have a duplicate. But if there are duplicates but also some string longer, we return its length.\n\nSo algorithm: Count frequencies. Find max length of strings whose count==1. If none, return -1 else that length.\n\nVirtual code steps: Start, Input strs. Compute frequencies map. Decision: If all frequencies 1? Actually we need to find unique ones. So Step: Build frequency. Step: Determine longest unique length. Decision: If longest_unique_length>0 then output it else -1. End.\n\nAlso maybe consider case when there are duplicates but also longer unique string. So logic stands.\n\nWe need to produce each step with explanation. Use arrows and decisions.\n\nLet's craft:\n\nStart // 程式開始\n\n→ Step 1: 建立字串頻率表 map // 迭代 strs 計算每個字串出現次數\n\n→ Step 2: 初始化 longestUnique = -1 // 用於記錄唯一字串的最大長度\n\n→ Step 3: 針對每個 (key, count) 在 map 中\n    → Decision: 是否 count == 1?\n        Yes → Step 4: 計算 key 的長度 len\n            → Decision: len > longestUnique ?\n                Yes → Step 5: 將 longestUnique 設為 len\n                No  → No action\n        No  → No action\n\n→ Step 6: Decision: 是否 longestUnique == -1?\n    Yes → Step 7: 輸出 -1 // 沒有唯一字串\n    No  → Step 8: 輸出 longestUnique // 最大唯一字串長度\n\nEnd // 程式結束\n\nBut we might need to include array iteration etc. Provide explanations accordingly.\n\nMake sure each line includes //.\n\nWe must use arrows: Start, → Step etc. Provide decision indentations. Use proper syntax.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 建立字串頻率表 map // 迭代 strs，計算每個字串的出現次數\n→ Step 2: 初始化 longestUnique = -1 // 用於記錄唯一字串的最大長度\n→ Step 3: 針對 map 中的每個 (key, count)\n    → Decision: 如果 count == 1? // 檢查此字串是否唯一\n        Yes → Step 4: 計算 key 的長度 len // 取得此字串的字元數\n            → Decision: 如果 len > longestUnique? // 比較是否為目前最大的唯一字串\n                Yes → Step 5: 將 longestUnique 設為 len // 更新最大長度\n                No  → No action // 留在原值\n        No  → No action // 重複字串不考慮\n→ Step 6: Decision: 是否 longestUnique == -1? // 判斷是否存在唯一字串\n    Yes → Step 7: 輸出 -1 // 沒有唯一字串，長度不存在\n    No  → Step 8: 輸出 longestUnique // 輸出最大的唯一字串長度\nEnd // 程式結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        產生 nums 的所有排列。\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # 若已經選完所有位置，將目前排列加入結果\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            # 從 start 開始的每個位置嘗試交換\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]   # 交換\n                backtrack(start + 1)                          # 進行下一層遞迴\n                nums[start], nums[i] = nums[i], nums[start]   # 交換回原位，回溯\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入，並取出陣列字串\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 只保留等號右邊的部分\n    if '=' in data:\n        list_str = data.split('=', 1)[1].strip()\n    else:\n        list_str = data\n\n    # 轉換成 Python list\n    nums = ast.literal_eval(list_str)\n\n    # 計算排列\n    solution = Solution()\n    result = solution.permute(nums)\n\n    # 以無空格格式輸出，符合範例輸出風格\n    print(json.dumps(result, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to generate virtual code for generating all permutations of array of distinct integers. Provide step-by-step pseudocode with arrows and explanation. Each line: virtual code step + // explanation. Use structure Start, End, Decision, etc.\n\nLet's craft algorithm: Use backtracking.\n\nOutline:\n\nStart // program start\n→ Input array nums // get array\n→ Initialize result list // store permutations\n→ Define recursive function backtrack(path, used) // path current permutation, used set of indices\n    → Decision: If length of path equals length of nums?\n        Yes → Add copy of path to result // full permutation found\n        No → For each i in 0..len(nums)-1\n              → Decision: If i not in used?\n                  Yes → Add nums[i] to path, mark used\n                        → backtrack(path, used)\n                        → Remove last from path, unmark used\nEnd // program end\n\nBut we need to use structure like \"Decision:\" lines with Yes/No arrows.\n\nNeed to output each line individually.\n\nLet's write:\n\nStart // 程式開始執行\n→ Input: nums // 取得輸入陣列\n→ Initialize: result = [] // 存放所有排列\n→ Define: backtrack(path, used) // 回溯函式，path為目前排列，used為已選取索引\n    → Decision: path length == nums length? // 檢查是否已完成一個排列\n        Yes → Append copy of path to result // 將完整排列加入結果\n        No → For i from 0 to nums length - 1\n              → Decision: i in used? // 判斷此元素是否已被使用\n                  No  → Append nums[i] to path // 選取元素\n                         → Mark i as used // 標記已使用\n                         → backtrack(path, used) // 深入遞迴\n                         → Unmark i as used // 解除標記\n                         → Remove last element from path // 回溯\nEnd // 程式執行結束\n\nBut we need to use arrow \"→\" before each step line. For nested steps, we may indent or maintain same arrow? In example they used indentation for nested steps. We'll follow similar.\n\nNeed to output each line as separate. Use \"→\" for each step, and \"Decision:\" lines.\n\nFor \"backtrack\" define, we can use \"→ Function: backtrack(path, used)\". Then indent inside function. Use \"Decision:\" lines.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: nums // 取得輸入陣列  \n→ Initialize: result = [] // 存放所有排列  \n→ Function: backtrack(path, used) // 回溯函式，path為目前排列，used為已選取索引  \n  → Decision: path length == nums length? // 檢查是否已完成一個排列  \n    Yes → Append copy of path to result // 將完整排列加入結果  \n    No → For i from 0 to nums length - 1  \n      → Decision: i in used? // 判斷此元素是否已被使用  \n       No  → Append nums[i] to path // 選取元素  \n        → Mark i as used // 標記已使用  \n        → backtrack(path, used) // 深入遞迴  \n        → Unmark i as used // 解除標記  \n        → Remove last element from path // 回溯  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 存放所有元素的列表\n        self.data = []\n        # value -> set of indices in self.data\n        self.idx_map = defaultdict(set)\n\n    def insert(self, val):\n        \"\"\"Insert val into collection. Return True if val was not present before.\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val):\n        \"\"\"Remove one occurrence of val. Return True if val existed.\"\"\"\n        if not self.idx_map[val]:\n            return False\n        # 任意取出一個索引\n        remove_idx = self.idx_map[val].pop()\n        last_idx = len(self.data) - 1\n        last_val = self.data[last_idx]\n        # 如果不是最後一個，交換位置\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            # 更新 last_val 的索引集合\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n        # 刪除最後一個元素\n        self.data.pop()\n        return True\n\n    def getRandom(self):\n        \"\"\"Return a random element from the collection.\"\"\"\n        return random.choice(self.data)\n\ndef main():\n    input_str = sys.stdin.read().strip()\n    if not input_str:\n        return\n    # LeetCode 的輸入形式通常是兩個列表，用逗號分隔\n    # 例如: [\"RandomizedCollection\", \"insert\", ...], [[], [1], ...]\n    # 我們將整個字串包裝成一個 JSON 陣列以方便解析\n    try:\n        commands, args = json.loads('[' + input_str + ']')\n    except json.JSONDecodeError:\n        # 若輸入格式不符合，直接退出\n        return\n\n    rc = None\n    output = []\n    for cmd, arg in zip(commands, args):\n        if cmd == \"RandomizedCollection\":\n            rc = RandomizedCollection()\n            output.append(None)\n        elif cmd == \"insert\":\n            res = rc.insert(arg[0])\n            output.append(res)\n        elif cmd == \"remove\":\n            res = rc.remove(arg[0])\n            output.append(res)\n        elif cmd == \"getRandom\":\n            res = rc.getRandom()\n            output.append(res)\n        else:\n            # 其他未知命令忽略\n            output.append(None)\n\n    # 將結果轉換成 LeetCode 所需的字串格式\n    def format_val(v):\n        if v is None:\n            return \"null\"\n        if isinstance(v, bool):\n            return \"true\" if v else \"false\"\n        return str(v)\n\n    print('[' + ', '.join(format_val(v) for v in output) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, each line with explanation. Use Start, End, Decision. Provide algorithm for RandomizedCollection. Data structures: vector list of values, unordered_map<int, unordered_set<int>> map from value to indices. Insertion: push to list, add index to set; return true if set size 1 else false. Removal: if not present return false; else get an index from set, swap with last element in list, update indices sets, pop last; adjust map. getRandom: random index into list. Complexity O(1). We'll produce virtual steps for each function.\n\nWe need to produce the virtual code for the whole class? It says \"Implement the RandomizedCollection class\" but we produce pseudocode for the methods. So we can produce Start, then Step: initialize data structures; Step: insert; Step: remove; Step: getRandom; End. We'll include explanation.\n\nLet's produce each method step by step. We need to be careful to use virtual code arrows.\n\nLet's output: Start // 程式開始執行\n→ Step 1: 初始化 vector elements, map indices // 初始化空集合\n... Then each function. We can structure as pseudo-classes.\n\nLet's produce: \"RandomizedCollection()\" then steps. Use Decision for if val present.\n\nWe'll produce a flowchart style for insert, remove, getRandom.\n\nWe'll include each line with explanation. Use \"Decision:\" lines for condition checks.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 vector elements 以儲存所有元素 // 動態陣列存放所有值\n→ Step 2: 定義 map indices (key: 整數 val, value: set of 索引) 以追蹤每個值在 elements 中的所有位置 // 哈希表對應集合\n\n// -------------------- RandomizedCollection() --------------------\n→ Step 3: RandomizedCollection() // 建構子\n    → Step 4: elements ← 空 vector // 初始空陣列\n    → Step 5: indices ← 空 map // 初始空哈希表\n→ End // 建構子完成\n\n// -------------------- insert(val) --------------------\n→ Step 6: insert(val)\n    → Decision: 若 indices[val] 為空? // 判斷此值是否首次出現\n        Yes → Step 7: 插入 val 進 elements 並將其索引加入 indices[val] // 新增索引\n            → Step 8: 回傳 true // 第一次插入，返回 true\n        No  → Step 9: 插入 val 進 elements 並將其索引加入 indices[val] // 再次插入\n            → Step 10: 回傳 false // 已存在，返回 false\n→ End\n\n// -------------------- remove(val) --------------------\n→ Step 11: remove(val)\n    → Decision: 若 indices[val] 為空? // 判斷值是否存在\n        Yes → Step 12: 回傳 false // 沒有該值，無法移除\n        No  → Step 13: 取 indices[val] 中任一索引 idxToRemove // 隨機挑一個要刪除的位置\n            → Step 14: lastIdx ← elements.size() - 1 // 取得最後元素索引\n            → Decision: 若 idxToRemove 與 lastIdx 不同? // 若刪除的位置不是最後一個\n                Yes → Step 15: lastVal ← elements[lastIdx] // 取得最後元素值\n                → Step 16: elements[idxToRemove] ← lastVal // 用最後元素覆蓋待刪除位置\n                → Step 17: 更新 indices[lastVal]：移除 lastIdx，加入 idxToRemove // 更新索引集合\n                → Step 18: 移除 indices[val] 中的 idxToRemove // 刪除原來的索引\n                → Step 19: elements.pop_back() // 刪除最後元素\n                → Step 20: 回傳 true // 移除成功\n                No  → Step 21: elements.pop_back() // 直接刪除最後元素\n                → Step 22: 移除 indices[val] 中的 idxToRemove // 刪除索引\n                → Step 23: 若 indices[val] 為空，則刪除 indices[val] 鍵 // 清理空集合\n                → Step 24: 回傳 true // 移除成功\n→ End\n\n// -------------------- getRandom() --------------------\n→ Step 25: getRandom()\n    → Step 26: randIdx ← 亂數 0 .. elements.size() - 1 // 隨機選取索引\n    → Step 27: 返回 elements[randIdx] // 回傳對應值\n→ End\n\nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '-1'"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list[str]) -> int:\n        # 若終點不在銀行中，直接返回 -1\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n\n            # 逐位嘗試所有可能的突變\n            for i in range(len(current)):\n                for g in genes:\n                    if g == current[i]:\n                        continue\n                    mutation = current[:i] + g + current[i+1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n\n        # 若無法達成終點，返回 -1\n        return -1\n\ndef parse_input() -> tuple[str, str, list[str]]:\n    \"\"\"\n    讀取整個標準輸入並解析為 startGene、endGene、bank。\n    假設輸入格式為：\n    startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n    \"\"\"\n    data_str = sys.stdin.read().strip()\n    # 如果輸入為空直接返回空值\n    if not data_str:\n        return \"\", \"\", []\n    # 用字典語法包裝，使 eval 可以解析\n    try:\n        data = eval(\"{\" + data_str + \"}\")\n    except Exception:\n        # 若解析失敗，回傳空值以避免程式崩潰\n        return \"\", \"\", []\n    start = data.get(\"startGene\", \"\")\n    end = data.get(\"endGene\", \"\")\n    bank = data.get(\"bank\", [])\n    return start, end, bank\n\ndef main() -> None:\n    start, end, bank = parse_input()\n    solution = Solution()\n    result = solution.minMutation(start, end, bank)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations, for BFS solution. Steps: check endGene in bank, BFS queue, visited set, level count, for each gene generate mutations by changing each position to each of 4 bases, check in bank and not visited, push to queue, etc. Use Start, End, Decision. Provide line by line.\n\nMake sure to include Start, End. Use arrow → for each step. Provide short explanation after //.\n\nLet's produce code:\n\nStart\n→ Step 1: If endGene not in bank → Decision\n   Yes → Step 2: Return -1\n   No → Continue\n\nBut BFS starts with queue containing startGene and level 0. Use visited set with startGene.\n\nProceed BFS loop: while queue not empty:\n   Dequeue gene, level\n   If gene == endGene -> Return level\n   For i in 0..7:\n       For each base in ['A','C','G','T']:\n           If base == gene[i] continue\n           newGene = gene[0:i] + base + gene[i+1:]\n           If newGene in bank and not visited:\n               Mark visited\n               Enqueue newGene with level+1\n\nIf loop ends -> return -1.\n\nWe need to use virtual code structure. Represent queue, visited. We might denote data structures as Step lines.\n\nLet's produce.\n\nEnsure each line has `虛擬碼步驟` + ` // 解釋`.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: endGene 是否在 bank 內? // 確認終點基因是否為合法基因  \n    Yes → Step 1: Return -1 // 無法達到終點，直接結束  \n    No  → Step 2: 初始化 queue ← [(startGene, 0)] // 以起始基因與初始突變數 0 開始  \n→ Step 3: 初始化 visited ← {startGene} // 標記已訪問的基因  \n→ Decision: queue 是否為空? // 檢查是否還有待處理基因  \n    Yes → Step 4: Return -1 // 所有可能都已嘗試，仍未找到終點  \n    No  → Step 5: 從 queue 取出 (current, steps) // 取出下一個基因與已突變數  \n→ Decision: current 是否等於 endGene? // 判斷是否已到達終點  \n    Yes → Step 6: Return steps // 找到最短突變數，結束程式  \n    No  → Step 7: 為每個位置 i 從 0 到 7 迭代 // 逐位產生新基因  \n→ Step 8:    For 每個字母 base 在 ['A','C','G','T'] 迭代 // 可能的突變字母  \n→ Decision: base 是否等於 current[i]? // 若相同則不變  \n        Yes → Step 9: 繼續迴圈 // 跳過此種變化  \n        No  → Step 10: newGene ← current[0:i] + base + current[i+1:] // 生成新基因  \n→ Decision: newGene 是否在 bank 且未訪問? // 確保合法且未重複  \n        Yes → Step 11: visited ← visited ∪ {newGene} // 標記已訪問  \n               → Step 12: queue ← queue ∪ [(newGene, steps+1)] // 加入隊列，步驟加 1  \n        No  → Step 13: 繼續迴圈 // 不符合條件，跳過  \n→ Step 14: 回到 Decision: queue 是否為空? // 重複 BFS 循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass MedianFinder:\n    \"\"\"\n    用兩個堆來維持中位數的查詢:\n    - max_heap 存儲較小半部分（用負值實現大根堆）\n    - min_heap 存儲較大半部分（小根堆）\n    \"\"\"\n    def __init__(self):\n        self.small = []  # 大根堆（以負數存放）\n        self.large = []  # 小根堆\n\n    def addNum(self, num: int) -> None:\n        # 把新數字先加到 small\n        heapq.heappush(self.small, -num)\n        # 若兩堆中有數字，且 small 的最大值大於 large 的最小值\n        # 需要交換以維持堆之間的大小關係\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # 調整大小：small 允許比 large 大多一個元素\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入：分離操作與參數兩個列表\n    idx = data.find('],')\n    if idx == -1:\n        # 若沒有逗號分隔，直接按逗號分割\n        ops_part, args_part = data.split(',', 1)\n    else:\n        ops_part = data[:idx+1]\n        args_part = data[idx+2:]\n    ops = ast.literal_eval(ops_part.strip())\n    args = ast.literal_eval(args_part.strip())\n    res = []\n    mf = None\n    for op, arg in zip(ops, args):\n        if op == 'MedianFinder':\n            mf = MedianFinder()\n            res.append(None)\n        elif op == 'addNum':\n            mf.addNum(arg[0])\n            res.append(None)\n        elif op == 'findMedian':\n            median = mf.findMedian()\n            res.append(median)\n    # 將結果輸出為符合範例的列表格式\n    output = '[' + ', '.join('null' if v is None else str(v) for v in res) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code line-by-line for implementing MedianFinder with addNum and findMedian. Likely using two heaps approach: max heap for lower half, min heap for upper half. Steps: init heaps, addNum: push to max or min accordingly, balance sizes, findMedian: if sizes equal, average tops, else top of larger heap. Provide virtual code with arrows.\n\nWe must not output actual code but pseudo steps. We'll output lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化兩個堆: maxHeap, minHeap // 用於儲存較小半部分和較大半部分\n\n→ Decision: addNum 步驟...\n\nNeed to include the class structure? We'll produce pseudo for the class. The requirement: \"Implement the MedianFinder class\" so virtual code steps describing the methods.\n\nWe produce steps: Start, Step: create class, constructor, addNum, findMedian.\n\nMake each line: \"Step: ...\" with arrow.\n\nLet's craft.\n\nWe might include:\n\nStart\n→ Step 1: 定義 MedianFinder 類\n→ Step 2: 在構造函數中初始化 maxHeap, minHeap\n→ Step 3: 定義 addNum 方法\n→ Step 4: addNum: 如果 maxHeap 為空 或 num ≤ maxHeap.top() → push to maxHeap\n→ Step 5: Else → push to minHeap\n→ Step 6: 決定平衡：若 maxHeap.size() > minHeap.size()+1 → pop maxHeap.top() push to minHeap\n→ Step 7: 若 minHeap.size() > maxHeap.size() → pop minHeap.top() push to maxHeap\n→ Step 8: 定義 findMedian 方法\n→ Step 9: 若 maxHeap.size() == minHeap.size() → median = (maxHeap.top() + minHeap.top()) / 2.0\n→ Step 10: 否則 → median = maxHeap.top()\n→ End\n\nBut also include each line with explanation. Also include arrow lines like Decision: if condition.\n\nLet's format with `→ Decision: 如果 ...` etc.\n\nWe need to be careful: each line has \"虛擬碼步驟 [空格] // 解釋/說明\". Use arrows.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MedianFinder 類 // 建立類別骨架  \n→ Step 2: 在構造函數中初始化兩個堆  \n  → maxHeap // 儲存較小半部分，使用大根堆  \n  → minHeap // 儲存較大半部分，使用小根堆  \n→ Step 3: 定義 addNum 方法 // 接收新數字並更新結構  \n  → Decision: maxHeap 為空 或 num ≤ maxHeap.top()? // 判斷將數字放入哪個堆  \n   Yes → Step 4: maxHeap.push(num) // 新數字屬於較小半部分  \n   No  → Step 5: minHeap.push(num) // 新數字屬於較大半部分  \n  → Decision: maxHeap.size() > minHeap.size() + 1? // 檢查最大堆過大  \n   Yes → Step 6: temp = maxHeap.top(); maxHeap.pop(); minHeap.push(temp) // 平衡堆大小  \n   No → Decision: minHeap.size() > maxHeap.size()? // 檢查最小堆過大  \n    Yes → Step 7: temp = minHeap.top(); minHeap.pop(); maxHeap.push(temp) // 平衡堆大小  \n    No → Step 8: // 堆已平衡，無需操作  \n→ Step 9: 定義 findMedian 方法 // 回傳目前資料的中位數  \n  → Decision: maxHeap.size() == minHeap.size()? // 判斷兩堆是否同樣大小  \n   Yes → Step 10: median = (maxHeap.top() + minHeap.top()) / 2.0 // 偶數個元素，取兩中位數平均  \n   No → Step 11: median = maxHeap.top() // 奇數個元素，最大堆頂即為中位數  \n→ End // 程式執行結束"
    },
    {
      "title": "All O`one Data Structure",
      "source_file": "Leetcode/leetcode432.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfzhy_7zn.py\", line 122, in <module>\n    main()\n  File \"/tmp/tmpfzhy_7zn.py\", line 93, in main\n    ops = ast.literal_eval(data[0])\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x762ffe024d90>"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Node:\n    \"\"\"雙向鏈結串列節點，儲存同一計數的所有 key。\"\"\"\n    def __init__(self, count=0):\n        self.count = count\n        self.keys = set()\n        self.prev = None\n        self.next = None\n\nclass AllOne:\n    \"\"\"AllOne 資料結構，支持 O(1) 平均時間的增減、取得最大/最小 key。\"\"\"\n    def __init__(self):\n        # 偽節點，head.count < 所有真節點 < tail.count\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}          # key -> Node\n\n    def _insert_after(self, prev_node, count):\n        \"\"\"在 prev_node 之後插入新節點並返回該節點。\"\"\"\n        new_node = Node(count)\n        new_node.prev = prev_node\n        new_node.next = prev_node.next\n        prev_node.next.prev = new_node\n        prev_node.next = new_node\n        return new_node\n\n    def _remove(self, node):\n        \"\"\"移除節點 node。\"\"\"\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key):\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            next_count = node.count + 1\n            # 若下一節點不存在或 count 不對應，插入新節點\n            if node.next == self.tail or node.next.count > next_count:\n                new_node = self._insert_after(node, next_count)\n            else:\n                new_node = node.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            # 新 key，計數 1\n            if self.head.next == self.tail or self.head.next.count > 1:\n                node1 = self._insert_after(self.head, 1)\n            else:\n                node1 = self.head.next\n            node1.keys.add(key)\n            self.key_to_node[key] = node1\n\n    def dec(self, key):\n        node = self.key_to_node[key]\n        prev_count = node.count - 1\n        node.keys.remove(key)\n        if prev_count == 0:\n            del self.key_to_node[key]\n        else:\n            if node.prev == self.head or node.prev.count < prev_count:\n                new_node = self._insert_after(node.prev, prev_count)\n            else:\n                new_node = node.prev\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self):\n        if self.tail.prev == self.head:\n            return \"\"\n        # 任意返回 max 節點的 key\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self):\n        if self.head.next == self.tail:\n            return \"\"\n        # 任意返回 min 節點的 key\n        return next(iter(self.head.next.keys))\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 解析輸入，預期兩行：操作列表、參數列表\n    ops = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1]) if len(data) > 1 else []\n\n    ao = AllOne()\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"AllOne\":\n            ao = AllOne()\n            results.append(None)\n        elif op == \"inc\":\n            ao.inc(*args)\n            results.append(None)\n        elif op == \"dec\":\n            ao.dec(*args)\n            results.append(None)\n        elif op == \"getMaxKey\":\n            results.append(ao.getMaxKey())\n        elif op == \"getMinKey\":\n            results.append(ao.getMinKey())\n        else:\n            # 其它未知操作，忽略\n            results.append(None)\n\n    # 轉成 JSON 以得到 null 形式\n    json_results = json.dumps(results)\n    print(json_results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for AllOne data structure. Provide line by line with explanation. Should design using doubly linked list of count nodes, each node has set of keys. Map key->node. All operations O(1). We'll outline steps: Start, init, inc, dec, getMaxKey, getMinKey, End.\n\nProvide each step line. Use \"AllOne\" maybe. We'll produce each method as virtual code lines. Use arrows. Provide explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: AllOne() // 建構 AllOne 物件\n    → Step 2: 初始化空的雙向鏈結串列頭尾偽節點 head, tail\n    → Step 3: 建立 keyToNode 映射表，儲存 key → CountNode\n    → Step 4: 完成初始化\n\n→ Step 5: inc(String key) // 增加 key 的計數\n    → Decision: key 是否已存在於 keyToNode?\n        Yes → Step 6: 找到現有 node = keyToNode[key]\n            → Step 7: 目標計數 nextCount = node.count + 1\n            → Decision: node.next 是否為 nextCount 節點?\n                Yes → Step 8: targetNode = node.next\n                No  → Step 9: 建立新節點 newNode(count=nextCount) 並插入 node 之後\n                    → Step 10: targetNode = newNode\n            → Step 11: 將 key 從 node.keySet 移除\n            → Step 12: 將 key 加入 targetNode.keySet\n            → Step 13: 更新 keyToNode[key] = targetNode\n            → Step 14: 如果 node.keySet 為空, 刪除 node 並釋放\n        No  → Step 15: key 尚不存在\n            → Step 16: 決定是否已存在 count=1 節點 node1\n                Yes → Step 17: node1 = node1\n                No  → Step 18: 建立 node1(count=1) 並插入 head 後\n            → Step 19: 將 key 加入 node1.keySet\n            → Step 20: keyToNode[key] = node1\n\n→ Step 21: dec(String key) // 減少 key 的計數\n    → Step 22: 找到 node = keyToNode[key]\n    → Step 23: 目標計數 prevCount = node.count - 1\n    → Step 24: 從 node.keySet 移除 key\n    → Decision: prevCount == 0?\n        Yes → Step 25: 刪除 keyToNode[key]，不再插入任何節點\n        No  → Decision: node.prev 是否為 prevCount 節點?\n            Yes → Step 26: prevNode = node.prev\n            No  → Step 27: 建立新節點 newNode(count=prevCount) 並插入 node 前面\n                → Step 28: prevNode = newNode\n            → Step 29: 將 key 加入 prevNode.keySet\n            → Step 30: keyToNode[key] = prevNode\n    → Decision: node.keySet 是否為空?\n        Yes → Step 31: 刪除 node 並釋放\n        No  → Step 32: 保留 node\n\n→ Step 33: getMaxKey() // 取得計數最高的 key\n    → Decision: head.next == tail?\n        Yes → Step 34: 回傳空字串 \"\"\n        No  → Step 35: 回傳 head.next.keySet 任意一個 key\n\n→ Step 36: getMinKey() // 取得計數最低的 key\n    → Decision: tail.prev == head?\n        Yes → Step 37: 回傳空字串 \"\"\n        No  → Step 38: 回傳 tail.prev.keySet 任意一個 key\n\nEnd // 程式執行結束"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom functools import lru_cache\n\n# ---------- Helper: collapse consecutive groups of 3 or more ----------\ndef collapse(s: str) -> str:\n    \"\"\"Recursively remove groups of 3 or more identical consecutive chars.\"\"\"\n    i = 0\n    n = len(s)\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == s[i]:\n            j += 1\n        if j - i >= 3:                # found a group to remove\n            # remove the group and restart scanning\n            return collapse(s[:i] + s[j:])\n        i = j\n    return s                         # no group left\n\n# ---------- Main solver ----------\nclass ZumaSolver:\n    COLORS = ['R', 'Y', 'B', 'G', 'W']\n\n    def __init__(self, board: str, hand: str):\n        self.board0 = board\n        # hand count per color index\n        hand_cnt = [0] * len(self.COLORS)\n        for c in hand:\n            hand_cnt[self.COLORS.index(c)] += 1\n        self.hand0 = tuple(hand_cnt)\n\n    @lru_cache(maxsize=None)\n    def solve(self, board: str, hand: tuple) -> int:\n        \"\"\"Return minimal insertions needed to clear `board` with given `hand`.\"\"\"\n        if not board:\n            return 0\n        if all(h == 0 for h in hand):\n            return float('inf')          # cannot clear without more balls\n\n        best = float('inf')\n        n = len(board)\n        # Precompute left and right run lengths for each position\n        for pos in range(n + 1):          # insertion positions: 0..n\n            # count same-color run to the left of pos\n            left_len = 0\n            left_color = None\n            if pos > 0:\n                left_color = board[pos - 1]\n                i = pos - 1\n                while i >= 0 and board[i] == left_color:\n                    left_len += 1\n                    i -= 1\n\n            # count same-color run to the right of pos\n            right_len = 0\n            right_color = None\n            if pos < n:\n                right_color = board[pos]\n                i = pos\n                while i < n and board[i] == right_color:\n                    right_len += 1\n                    i += 1\n\n            # try inserting each color that is available\n            for idx, cnt in enumerate(hand):\n                if cnt == 0:\n                    continue\n                c = self.COLORS[idx]\n                # decide if inserting c at pos can create a removable group\n                if left_color == c and right_color == c:\n                    total = left_len + right_len + 1\n                elif left_color == c:\n                    total = left_len + 1\n                elif right_color == c:\n                    total = right_len + 1\n                else:\n                    continue\n                if total < 3:\n                    continue  # cannot form a group\n\n                # Build new board after insertion\n                new_board = board[:pos] + c + board[pos:]\n                collapsed = collapse(new_board)\n\n                # Update hand count\n                new_hand = list(hand)\n                new_hand[idx] -= 1\n                new_hand = tuple(new_hand)\n\n                res = self.solve(collapsed, new_hand)\n                if res != float('inf'):\n                    best = min(best, 1 + res)\n\n        return best\n\n    def minimum_insertions(self) -> int:\n        ans = self.solve(self.board0, self.hand0)\n        return -1 if ans == float('inf') else ans\n\n# ---------- I/O handling ----------\ndef parse_input(data: str):\n    # Try to extract quoted strings\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        board, hand = quoted[0], quoted[1]\n    else:\n        # fallback: split by whitespace or newline\n        parts = data.strip().split()\n        board = parts[0] if parts else ''\n        hand = parts[1] if len(parts) > 1 else ''\n    return board, hand\n\ndef main():\n    raw = sys.stdin.read()\n    board, hand = parse_input(raw)\n    solver = ZumaSolver(board, hand)\n    print(solver.minimum_insertions())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm steps to solve the Zuma-like problem: minimum insertions to clear board. Known solution: DFS/backtracking with state (board string, hand counts). Use pruning: when hand empty return -1; if board empty return 0. Use recursion. Use memoization. Steps: define function minInsertions(board, handCounts). At each step, iterate over board positions where insertion could reduce; for each color in hand, try inserting at each valid position where adjacent colors form group; compute new board after removal. Recurse. Keep min. If no solution return INF -> -1.\n\nWe need to produce virtual code lines, each with explanation. Use arrow and decisions. Should produce algorithmic outline, not full code. Provide steps like Start, define function, etc.\n\nLet's produce. Use pseudo steps.\n\nWe'll need some helper functions: compress removal. Use iterative removal loop: while find group >=3 remove.\n\nIn pseudo: function removeGroups(s) → return cleaned string.\n\nUse decision: if board empty return 0; if hand empty return INF.\n\nWe need to maintain counts of hand. Represent as dict or array of 5 colors. Use map color to index.\n\nWe'll produce step list. Provide variable names. Provide loops.\n\nWe need to output each line of virtual code with comment.\n\nOk.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n\n→ Step 1: 定義顏色索引映射 `colors = ['R','Y','B','G','W']` // 方便把手中的球數量轉成陣列  \n\n→ Step 2: 把 `hand` 轉成 `handCnt[5]`，計算每種顏色球的數量 // 方便後續減少球數  \n\n→ Decision: 如果 `handCnt` 全為 0? // 檢查手中是否有球  \n  Yes → End // 沒球就直接結束  \n\n→ Step 3: 定義遞迴函式 `minInsert(board, handCnt)` // 取得清空球所需最少插入數  \n\n→ Step 4: Inside `minInsert`  \n  → Decision: 如果 `board` 為空?  \n   Yes → Return 0 // 已清空，無需再插球  \n   No  → Decision: 如果所有 `handCnt` 為 0?  \n    Yes → Return INF // 手中無球且還有球在板上，無法完成  \n\n→ Step 5: 初始化 `minRes = INF` // 儲存目前找到的最小插入數  \n\n→ Step 6: 循環遍歷板上每個位置 `i`（包括兩端插入）  \n  → 取得左側顏色 `left = board[i-1]`（若 i==0 則無左側）  \n  → 取得右側顏色 `right = board[i]`（若 i==len(board) 則無右側）  \n\n→ Decision: 如果 `left == right` 且不是空? // 只有當左右顏色相同才有可能形成 3 個  \n   Yes → 目標顏色 `c = left`  \n   No → 連續判斷每種顏色 `c`，如果 `handCnt[c] > 0` 就進一步嘗試插入  \n\n→ Step 7: 對於每個可插入顏色 `c`，如果 `handCnt[c] > 0`  \n  → Step 8: 在位置 `i` 插入一顆 `c`，得到新串 `newBoard = board[:i] + c + board[i:]` // 形成暫時球列  \n\n→ Step 8a: 調用 `compress(newBoard)` 來移除所有連續 3 或以上相同顏色的群組，直到不再有  \n  → Step 8b: 取得壓縮後的 `cleanBoard`  \n\n→ Step 9: 將 `handCnt[c]` 減 1，得到 `newHandCnt`  \n\n→ Step 10: Recursively計算 `subRes = minInsert(cleanBoard, newHandCnt)`  \n\n→ Decision: 如果 `subRes` 不是 INF?  \n  Yes → 更新 `minRes = min(minRes, 1 + subRes)` // 加上此次插入的球  \n\n→ Step 11: 之後還原 `handCnt[c]`（回溯）  \n\n→ Step 12: 結束循環  \n\n→ Step 13: Return `minRes` // 回傳目前路徑的最小插入數  \n\n→ Step 14: 在主程序中調用 `ans = minInsert(board, handCnt)`  \n\n→ Decision: 如果 `ans == INF`?  \n  Yes → Output -1 // 無法清空  \n  No  → Output `ans` // 最小插入數  \n\nEnd // 程式執行結束  \n\n**輔助函式說明**  \n\n→ Step 15: 定義 `compress(str)`  \n  → Step 15a: 置入空串 `result`  \n  → Step 15b: 用兩指針遍歷 `str`，找出連續相同顏色段  \n  → Step 15c: 如果段長 < 3，將該段加入 `result`；否則跳過（即移除）  \n  → Step 15d: 重複以上直到 `str` 無更改  \n  → Return `result` // 返回最終壓縮後的球列  \n\nEnd // 虛擬碼結束"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,null,-1,3,4]'\nGot (Norm):      '[None,None,None,1,None,-1,None,-1,3,4]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, null, -1, 3, 4]'\nRaw Got:      '[None, None, None, 1, None, -1, None, -1, 3, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache[key]\n        # Move to end to mark as most recently used\n        del self.cache[key]\n        self.cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            # Pop least recently used (first item)\n            self.cache.popitem(last=False)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Wrap in parentheses so ast.literal_eval can parse two lists as a tuple\n    try:\n        ops, args = ast.literal_eval(f'({data})')\n    except Exception as e:\n        # In case input is not exactly two lists, try splitting manually\n        parts = data.split('], [')\n        if len(parts) == 2:\n            ops = ast.literal_eval(parts[0] + ']')\n            args = ast.literal_eval('[' + parts[1])\n        else:\n            raise e\n\n    results = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == 'LRUCache':\n            cache = LRUCache(arg[0])\n            results.append(None)\n        elif op == 'put':\n            cache.put(arg[0], arg[1])\n            results.append(None)\n        elif op == 'get':\n            results.append(cache.get(arg[0]))\n        else:\n            # Unknown operation; skip or raise error\n            results.append(None)\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing LRU cache with O(1) operations. Use typical data structure: doubly linked list + hash map. Steps: Start, initialize capacity, create map and dummy head tail nodes. get: if key not found return -1 else move node to front, return value. put: if key exists update value and move to front. else create new node, add to map and front. If size > capacity remove tail.prev node and delete from map. End.\n\nWe need to produce each line as \"虛擬碼步驟 // 解釋\". Use arrows and decisions. Provide step-by-step. Use pseudocode style. Let's produce a clear stepwise description.\n\nWe'll incorporate decisions for get: if key present; put: if key exists else. Use Decision nodes. Use arrow indent.\n\nLet's write.\n\nEnsure each line ends with // Explanation. Use arrow lines like \"→\". Use indentation for nested.\n\nWe need to include Start and End.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 LRUCache 類別，並宣告容量 capacity、HashMap map、雙向鏈表 dummyHead、dummyTail 以及大小 size // 初始化基本資料結構  \n→ Step 2: 初始化 dummyHead 和 dummyTail 並相互連結，將 size 設為 0 // 建立雙向鏈表的哨兵節點，方便後續操作  \n\n→ Step 3: get(int key) // 定義 get 方法  \n→ Decision: 如果 key 不在 map? // 檢查 key 是否存在  \n  No  → Return -1 // 不存在則回傳 -1  \n  Yes → Step 4: 取得 node = map[key] // 取得對應節點  \n   → Step 5: removeNode(node) // 從鏈表中移除該節點  \n   → Step 6: addToFront(node) // 重新插入到頭部，表示最近使用  \n   → Return node.value // 回傳對應的值  \n\n→ Step 7: put(int key, int value) // 定義 put 方法  \n→ Decision: 如果 key 在 map? // 檢查 key 是否已存在  \n  Yes → Step 8: node = map[key]  \n    → node.value = value // 更新值  \n    → removeNode(node) // 移除舊位置  \n    → addToFront(node) // 插入到頭部  \n    → End // 完成更新  \n  No  → Step 9: node = new Node(key, value) // 創建新節點  \n    → map[key] = node // 加入 map  \n    → addToFront(node) // 插入頭部  \n    → size += 1 // 更新大小  \n    → Decision: 如果 size > capacity? // 檢查是否超過容量  \n      Yes → Step 10: lru = dummyTail.prev // 找到最舊節點  \n       → removeNode(lru) // 從鏈表移除  \n       → delete map[lru.key] // 從 map 刪除  \n       → size -= 1 // 更新大小  \n      No → End // 不超過容量，直接結束  \n\n→ Step 11: removeNode(node) // 移除節點的輔助方法  \n  → node.prev.next = node.next  \n  → node.next.prev = node.prev  \n\n→ Step 12: addToFront(node) // 插入節點到頭部的輔助方法  \n  → node.next = dummyHead.next  \n  → node.prev = dummyHead  \n  → dummyHead.next.prev = node  \n  → dummyHead.next = node  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Index Sum of Two Lists",
      "source_file": "Leetcode/leetcode599.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]",
          "expected_output": "[\"Shogun\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfa_7jl4x.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmpfa_7jl4x.py\", line 43, in main\n    result = sol.findRestaurant(list1, list2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfa_7jl4x.py\", line 8, in findRestaurant\n    index_map = {name: i for i, name in enumerate(list1)}\n                 ^^^^^^^\nTypeError: unhashable type: 'list'"
        },
        {
          "example_index": 1,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]",
          "expected_output": "[\"Shogun\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6acv5t9y.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmp6acv5t9y.py\", line 43, in main\n    result = sol.findRestaurant(list1, list2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6acv5t9y.py\", line 8, in findRestaurant\n    index_map = {name: i for i, name in enumerate(list1)}\n                 ^^^^^^^\nTypeError: unhashable type: 'list'"
        },
        {
          "example_index": 2,
          "input": "list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]",
          "expected_output": "[\"sad\",\"happy\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9246zn9k.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmp9246zn9k.py\", line 43, in main\n    result = sol.findRestaurant(list1, list2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9246zn9k.py\", line 8, in findRestaurant\n    index_map = {name: i for i, name in enumerate(list1)}\n                 ^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def findRestaurant(self, list1, list2):\n        # 建立 list1 中每個字串到其索引的映射\n        index_map = {name: i for i, name in enumerate(list1)}\n        min_sum = float('inf')\n        res = []\n\n        # 遍歷 list2，計算索引和並更新答案\n        for j, name in enumerate(list2):\n            if name in index_map:\n                total_index = j + index_map[name]\n                if total_index < min_sum:\n                    min_sum = total_index\n                    res = [name]\n                elif total_index == min_sum:\n                    res.append(name)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找出 list1 和 list2 的文字描述\n    prefix1 = 'list1 ='\n    prefix2 = 'list2 ='\n    idx1 = data.find(prefix1)\n    idx2 = data.find(prefix2)\n\n    list1_str = data[idx1 + len(prefix1):idx2].strip()\n    list2_str = data[idx2 + len(prefix2):].strip()\n\n    # 轉成真正的 Python list\n    list1 = ast.literal_eval(list1_str)\n    list2 = ast.literal_eval(list2_str)\n\n    # 呼叫解法並輸出結果\n    sol = Solution()\n    result = sol.findRestaurant(list1, list2)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrow symbols. The user wants to solve the problem. So we need to produce steps: Start, build map of list1 indices, iterate list2, compute sums, track min sum and result list. Finally output.\n\nLet's structure:\n\nStart\n→ Build map1: for each string in list1 with index i\n    → Add to dict: key string, value i\n→ Initialize minSum = Infinity\n→ Initialize result = empty list\n→ For each string in list2 with index j\n    → Decision: if string exists in map1?\n        Yes →\n            → Compute sum = map1[string] + j\n            → Decision: if sum < minSum?\n                Yes →\n                    → minSum = sum\n                    → result = [string]  // reset\n                No  →\n                    → Decision: if sum == minSum?\n                        Yes →\n                            → Append string to result\n                        No → (do nothing)\n        No → (do nothing)\nEnd\n\nAdd comments accordingly.\n\nAlso note that we need to output result. Maybe add final step: Output result.\n\nAdd step: → Output result // 返回結果\n\nEnsure proper indentation.\n\nAlso note we need \"Decision:\" with arrow, then indent Yes, No.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ BuildMap: 建立字串到索引的映射 // 建構 list1 的索引表\n    → For each i, str in list1\n        → Map[str] = i // 存儲索引\n→ Initialize minSum = Infinity // 設置初始最小索引和\n→ Initialize result = empty list // 儲存答案\n→ Iterate list2 with index j\n    → Decision: 若 str 在 Map 中?\n        Yes →\n            → sum = Map[str] + j // 計算索引和\n            → Decision: sum < minSum?\n                Yes →\n                    → minSum = sum // 更新最小值\n                    → result = [str] // 重置答案\n                No →\n                    → Decision: sum == minSum?\n                        Yes →\n                            → result.append(str) // 加入答案\n                        No →\n                            → // 無需處理\n        No → // 忽略非共通字串\n→ Output result // 回傳所有最小索引和的共通字串\nEnd // 程式執行結束\n\nMake sure each line ends with // 解釋.\n\nLet's produce exactly.\n...done thinking.\n\nStart // 程式開始執行  \n→ BuildMap: 建立字串到索引的映射 // 建構 list1 的索引表  \n → For each i, str in list1  \n  → Map[str] = i // 存儲索引  \n→ Initialize minSum = Infinity // 設置初始最小索引和  \n→ Initialize result = empty list // 儲存答案  \n→ Iterate list2 with index j  \n → Decision: 若 str 在 Map 中? // 檢查是否為共通字串  \n  Yes →  \n   → sum = Map[str] + j // 計算索引和  \n   → Decision: sum < minSum? // 是否更新最小值  \n    Yes →  \n     → minSum = sum // 更新最小索引和  \n     → result = [str] // 重置答案  \n    No →  \n     → Decision: sum == minSum? // 是否等於目前最小值  \n      Yes →  \n       → result.append(str) // 加入答案  \n      No →  \n       → // 無需處理  \n  No → // 忽略非共通字串  \n→ Output result // 回傳所有最小索引和的共通字串  \nEnd // 程式執行結束"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpb6i1mkcp.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpb6i1mkcp.py\", line 49, in main\n    result = kth_smallest(matrix, k)\n             ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpb6i1mkcp.py\", line 9, in kth_smallest\n    mid = (left + right) // 2\n          ~~~~~~~~~~~~~~~^^~~\nTypeError: unsupported operand type(s) for //: 'list' and 'int'"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-5'\nGot (Norm):      '[-5]'\n--- (Raw) ---\nRaw Expected: '-5'\nRaw Got:      '[-5]'"
        }
      ],
      "generated_code": "import sys\n\ndef kth_smallest(matrix, k):\n    \"\"\"Return the k-th smallest element in a sorted matrix.\"\"\"\n    n = len(matrix)\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left < right:\n        mid = (left + right) // 2\n\n        # Count elements <= mid\n        count = 0\n        row, col = n - 1, 0\n        while row >= 0 and col < n:\n            if matrix[row][col] <= mid:\n                count += row + 1  # all elements above in this column are <= mid\n                col += 1\n            else:\n                row -= 1\n\n        if count >= k:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\ndef parse_input():\n    \"\"\"Parse matrix and k from stdin. Handles both single-line and two-line inputs.\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Try single-line format: \"matrix = [...], k = ...\"\n    if 'k =' in data:\n        mat_part, k_part = data.split('k =', 1)\n        mat_part = mat_part.replace('matrix =', '').strip()\n        matrix = eval(mat_part)\n        k = int(k_part.strip())\n    else:\n        # Assume two separate lines: first matrix, second k\n        lines = data.splitlines()\n        matrix = eval(lines[0].strip())\n        k = int(lines[1].strip())\n    return matrix, k\n\ndef main():\n    matrix, k = parse_input()\n    result = kth_smallest(matrix, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate a virtual code step by step for the problem: find kth smallest element in sorted matrix (each row and column ascending). Must be memory better than O(n^2). Typically solution uses binary search on value range or min-heap. We'll choose binary search on value range with count of <= mid. That uses O(1) memory. We'll produce step-by-step pseudo code with arrow and explanations.\n\nWe need to output lines:\n\nStart // ...\n→ Step ... etc\n\nWe should produce steps: initialize left, right, while left < right: mid, count <= mid by iterating rows, counting elements <= mid. Then adjust left/right accordingly. Finally output left. Then End.\n\nAlso we might include a function to count <= mid using row traversal starting from bottom-left or top-right. Provide explanation. Use Decision nodes. Let's produce.\n\nMake sure each line: \"虛擬碼步驟 [space] // 解釋/說明\"\n\nLet's produce.\n\nAlso might include input reading and validation. But minimal.\n\nWe'll include:\n\nStart // 開始程式\n→ Step 1: 獲取矩陣大小 n, k // 讀取輸入\n→ Step 2: 設定 left = matrix[0][0], right = matrix[n-1][n-1] // 確定搜尋範圍\n→ Decision: 如果 left == right? // 檢查是否已確定答案\n    Yes → Step 3: 輸出 left // 若只有一個可能值，直接回傳\n    No  → Step 4: 進入主迴圈 while left < right // 進行二分搜尋\n        → Step 5: mid = floor((left + right) / 2) // 計算中值\n        → Step 6: count = CountLessOrEqual(matrix, mid) // 取得小於等於 mid 的元素數量\n        → Decision: 如果 count >= k? // 檢查是否足夠小\n            Yes → Step 7: right = mid // 將右端縮小到 mid\n            No  → Step 8: left = mid + 1 // 將左端移至 mid+1\n        → Step 9: 重複迴圈直到 left == right\n→ Step 10: 輸出 left // 左右端合併即為第 k 小的數\nEnd // 程式結束\n\nAlso we need the function CountLessOrEqual: We'll add as separate block.\n\nWe'll include:\n\n→ Function CountLessOrEqual(matrix, target):\n    → Step ... ?\n\nBut the spec: produce virtual code lines. Might add function header as separate step. Let's include:\n\n→ Function CountLessOrEqual(matrix, target) // 計算 ≤ target 的個數\n    → Step ... // loops.\n\nBut we need arrow? We'll use \"→ Step\" for internal lines. We'll produce function block.\n\nWe can embed inside the main block, but easier: create separate block after main steps.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 獲取矩陣大小 n, k // 讀取輸入，確定矩陣維度與需要的第 k 小元素  \n→ Step 2: 設定 left = matrix[0][0], right = matrix[n-1][n-1] // 由於矩陣行列已排序，左上角是最小值，右下角是最大值  \n→ Decision: 如果 left == right? // 檢查是否已確定答案（矩陣只有一個可能值）  \n    Yes → Step 3: 輸出 left // 直接回傳答案  \n    No  → Step 4: 進入主迴圈 while left < right // 開始二分搜尋  \n        → Step 5: mid = floor((left + right) / 2) // 計算中值，用於分割搜尋範圍  \n        → Step 6: count = CountLessOrEqual(matrix, mid) // 計算 ≤ mid 的元素個數  \n        → Decision: 如果 count >= k? // 判斷是否還需要更小的數  \n            Yes → Step 7: right = mid // 若 count 大於等於 k，則第 k 小一定在左半邊，縮小右端  \n            No  → Step 8: left = mid + 1 // 否則第 k 小在右半邊，移動左端  \n        → Step 9: 重複迴圈直到 left == right // 搜尋範圍縮為單一值  \n→ Step 10: 輸出 left // left == right 時即為第 k 小的元素  \nEnd // 程式執行結束  \n\n→ Function CountLessOrEqual(matrix, target) // 計算矩陣中 ≤ target 的元素個數  \n    → Step 11: n = matrix size // 取得矩陣維度  \n    → Step 12: count = 0 // 初始化計數  \n    → Step 13: row = n - 1, col = 0 // 從最左下角開始遍歷  \n    → Decision: 當 row >= 0 且 col < n 時? // 仍在矩陣範圍內  \n        Yes → Decision: 如果 matrix[row][col] <= target? // 当前元素是否小於等於目標  \n            Yes → Step 14: count = count + 1 // 计数加一  \n            No  → Step 15: row = row - 1 // 向上移動，排除大於 target 的元素  \n            → Step 16: col = col + 1 // 移動到下一列，尋找更大的元素  \n        No  → Step 17: 返回 count // 當行列越界時，返回累積的計數  \n    → End // 函式結束"
    },
    {
      "title": "Combination Sum IV",
      "source_file": "Leetcode/leetcode377.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkpcks76w.py\", line 36, in <module>\n    main()\n  File \"/tmp/tmpkpcks76w.py\", line 27, in main\n    data = ast.literal_eval(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {nums= [1,2,3], target= 4}\n     ^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums = [9], target = 3",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7y4uf03t.py\", line 36, in <module>\n    main()\n  File \"/tmp/tmp7y4uf03t.py\", line 27, in main\n    data = ast.literal_eval(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {nums= [9], target= 3}\n     ^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def combinationSum4(self, nums, target):\n        \"\"\"計算所有排列組合的個數（順序重要）\"\"\"\n        dp = [0] * (target + 1)\n        dp[0] = 1  # 基本情況：目標為 0 時只有一種組合（空組合）\n\n        for i in range(1, target + 1):\n            for num in nums:\n                if i - num >= 0:\n                    dp[i] += dp[i - num]\n        return dp[target]\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 轉換成可以 eval 的字典字串\n    # 將 \"nums = \"、\"target = \" 改成 \"nums=\"、\"target=\"\n    raw_input = raw_input.replace(\"nums =\", \"nums=\").replace(\"target =\", \"target=\")\n    raw_input = \"{\" + raw_input + \"}\"\n    # 使用 ast.literal_eval 解析字典\n    data = ast.literal_eval(raw_input)\n    nums = data['nums']\n    target = data['target']\n\n    solution = Solution()\n    result = solution.combinationSum4(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for counting number of combinations (order matters?) The problem \"number of combinations that add up to target\" with distinct integers in array. Usually this is \"combination sum IV\" problem: number of possible combinations where order matters. Use DP: dp[0] = 1; for i from 1 to target: for num in nums: if i >= num: dp[i] += dp[i-num]. Return dp[target]. We'll produce pseudocode steps line by line, with explanation. No actual code. Use Start, End, Decision, etc. Provide each line with arrow → and explanation. Must not output actual code, but pseudo steps. Use virtual code format.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化 dp 數組長度 target+1，所有元素設為 0 // 記錄每個子目標的組合數\n→ Step 2: 設定 dp[0] = 1 // 0 目標只有一種組合：不選任何數字\n→ Step 3: 循環目標值 i 從 1 到 target // 計算所有子目標\n    → Step 4: 循環遍歷每個 num 在 nums 中 // 每個數字作為最後一個組合元素\n        → Decision: 如果 i >= num? // 是否能用 num 作為組合的最後一個數字\n            Yes → Step 5: dp[i] += dp[i - num] // 加上以 num 結束的所有組合\n            No → Step 6: 繼續到下一個 num // num 太大，跳過\n→ Step 7: 返回 dp[target] // 最終目標的組合數\nEnd\n\nAlso ensure each line has \"虛擬碼步驟\" and comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 dp 數組長度 target+1，所有元素設為 0 // 建立 DP 陣列以存儲子目標的組合數  \n→ Step 2: 設定 dp[0] = 1 // 目標為 0 時只有一種組合：不選任何數字  \n→ Step 3: 循環目標值 i 從 1 到 target // 逐步計算每個子目標的組合數  \n  → Step 4: 循環遍歷每個 num 在 nums 中 // 將每個可用數字視為組合的最後一個元素  \n    → Decision: 如果 i >= num? // 檢查 num 是否能作為最後一項加入組合  \n      Yes → Step 5: dp[i] += dp[i - num] // 加上以 num 結束的所有組合數  \n      No → Step 6: 繼續到下一個 num // num 太大，跳過  \n→ Step 7: 返回 dp[target] // 回傳目標值的所有可能組合數  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left, right):\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left, right):\n        # binary search to find interval that may cover left\n        lo, hi = 0, len(self.ranges)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if self.ranges[mid][0] <= left:\n                lo = mid + 1\n            else:\n                hi = mid\n        i = lo - 1\n        if i >= 0 and self.ranges[i][0] <= left and right <= self.ranges[i][1]:\n            return True\n        return False\n\n    def removeRange(self, left, right):\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main():\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    rm = None\n    outputs = []\n    for line in lines:\n        if line.startswith('RangeModule'):\n            rm = RangeModule()\n            outputs.append(None)\n        elif 'addRange' in line:\n            start = line.find('(')\n            end = line.find(')')\n            args = line[start + 1:end].split(',')\n            left, right = map(int, [a.strip() for a in args])\n            rm.addRange(left, right)\n            outputs.append(None)\n        elif 'removeRange' in line:\n            start = line.find('(')\n            end = line.find(')')\n            args = line[start + 1:end].split(',')\n            left, right = map(int, [a.strip() for a in args])\n            rm.removeRange(left, right)\n            outputs.append(None)\n        elif 'queryRange' in line:\n            start = line.find('(')\n            end = line.find(')')\n            args = line[start + 1:end].split(',')\n            left, right = map(int, [a.strip() for a in args])\n            res = rm.queryRange(left, right)\n            outputs.append(res)\n    formatted = '[' + ', '.join('null' if o is None else ('true' if o else 'false') for o in outputs) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with arrow and explanation comments. It's a design for a RangeModule data structure. Likely we use something like a sorted list of intervals or a tree map to manage disjoint intervals. The algorithm: addRange: merge with existing overlapping intervals; queryRange: check if [l, r) fully covered by any intervals; removeRange: split intervals, remove overlapping portion.\n\nWe need to produce pseudocode with Start, End, Decision blocks.\n\nWe must include every step line by line.\n\nProbably structure:\n\nStart\n→ Step 1: Initialize data structure: maybe an ordered list or tree map\n→ Decision: None\n\nImplement methods: addRange, queryRange, removeRange. We'll write steps for each method.\n\nWe need to produce pseudocode steps, not actual code. Use arrows for indentation.\n\nWe need to include line numbers? Not necessary.\n\nWe need to follow the format exactly: Each line has \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nWe need to include arrows for decision paths. Use \"→\" for next step.\n\nWe need to use \"Decision:\" for conditions.\n\nWe need to use \"Yes →\", \"No →\" for branches.\n\nWe need to produce a single structured pseudocode describing the class and its methods, maybe in a linear flow, not nested inside methods? We can show the class with its methods. But each line must be a step.\n\nWe need to avoid actual code, so we avoid syntax like class RangeModule or function definitions, but we can indicate steps conceptually: \"Method: RangeModule()\" etc.\n\nWe need to output everything line by line, with explanation comments.\n\nOk, let's design.\n\nOutline:\n\nStart\n→ Initialize data structure: intervals list sorted by start, non-overlapping\n\nDefine method addRange(left, right):\n→ Find position to insert or merge intervals overlapping [left, right)\n→ Iterate over intervals that overlap\n→ Merge them, updating left and right to cover all overlapping\n→ Remove overlapped intervals from list\n→ Insert merged interval\n\nDefine method queryRange(left, right):\n→ Find interval that could cover left\n→ If found and its end >= right: return true else false\n\nDefine method removeRange(left, right):\n→ Find intervals overlapping\n→ For each overlapping interval, handle three cases:\n   - interval fully inside [left,right): remove it\n   - interval partially overlaps left side: truncate end to left\n   - interval partially overlaps right side: truncate start to right\n→ After processing, the remaining intervals cover non-removed parts\n\nEnd\n\nWe need to convert to pseudo steps with arrows and decisions.\n\nProbably we need to show high-level steps; for loops, decisions, etc.\n\nLet's produce.\n\nWe must show each line: e.g., \"Start // 程式開始執行\".\n\nWe need to handle the internal loops: use Decision: if condition? Yes → ... No → ...\n\nWe need to include steps for each method separately; we may label them.\n\nLet's produce.\n\nAlso, the class definition: \"Method: RangeModule()\" then steps.\n\nOk.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義空列表 intervals // 用來存放已追蹤的不重疊半開區間  \n→ Step 2: 定義方法 RangeModule() // 建構子，初始化 intervals 為空  \n  → End // 建構子完成  \n\n→ Step 3: 定義方法 addRange(left, right) // 新增區間  \n  → Decision: intervals 是否為空?  \n   Yes → Step 4: 插入區間 [left, right) 到 intervals  \n    End // 新增完成  \n   No → Step 5: 設定 newLeft = left, newRight = right  \n    → Step 6: 迴圈遍歷 intervals，尋找與 [left, right) 重疊的區間  \n     → Decision: 當前區間 start <= newRight AND end >= newLeft?  \n      Yes → Step 7: newLeft = min(newLeft, start)  \n       Step 8: newRight = max(newRight, end)  \n       Step 9: 標記此區間待刪除  \n      No → Step 10: 若 start > newRight 則結束遍歷（因為已排序）  \n    → End // 完成重疊區間合併  \n    → Step 11: 刪除所有被標記的重疊區間  \n    → Step 12: 插入合併後的新區間 [newLeft, newRight)  \n     End // addRange 完成  \n\n→ Step 13: 定義方法 queryRange(left, right) // 查詢區間  \n  → Step 14: 找到 intervals 中第一個 start <= left 的區間  \n   → Decision: 這個區間存在且 end >= right?  \n    Yes → Step 15: 返回 true // 整個區間被追蹤  \n    No → Step 16: 返回 false // 不是完整追蹤  \n     End // queryRange 完成  \n\n→ Step 17: 定義方法 removeRange(left, right) // 移除區間  \n  → Step 18: 迴圈遍歷 intervals，尋找與 [left, right) 重疊的區間  \n    → Decision: 當前區間 start < right AND end > left?  \n     Yes → Step 19: 判斷重疊情況  \n      → Decision: 整個區間被 [left, right) 包含?  \n       Yes → Step 20: 標記此區間待刪除  \n       No → Step 21: 判斷左側部分仍需保留?  \n        → Decision: start < left?  \n         Yes → Step 22: 創建左側區間 [start, left)  \n         No → Step 23: 省略左側創建  \n          End  \n         判斷右側部分仍需保留?  \n         → Decision: end > right?  \n          Yes → Step 24: 創建右側區間 [right, end)  \n          No → Step 25: 省略右側創建  \n          End  \n         將左側與右側區間（如存在）加入 intervals  \n         將原始區間標記待刪除  \n       No → Step 26: 若不重疊則不處理  \n         End  \n    → End // 完成所有重疊區間的處理  \n   → Step 27: 刪除所有被標記待刪除的區間  \n   → End // removeRange 完成  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjsnzb45p.py\", line 81, in <module>\n    main()\n  File \"/tmp/tmpjsnzb45p.py\", line 62, in main\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0\n        self.count = 0\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 第一行是方法名列表，第二行是對應的參數列表\n    ops = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    obj = None\n    outputs = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(*args)\n            outputs.append(None)          # constructor returns null\n        else:\n            func = getattr(obj, op)\n            result = func(*args) if args else func()\n            outputs.append(result)\n\n    # 使用 json.dumps 讓輸出格式與題目要求一致\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for implementing circular deque. Each line with virtual code and comment. Use Start, End, Decision. Use arrows. Provide step-by-step pseudocode. Not actual code.\n\nWe must include the constructor, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.\n\nWe'll produce pseudocode with steps and decisions.\n\nLet's produce:\n\nStart\n→ Step: Define class MyCircularDeque // declare class\n→ Step: Define attributes: array data of size k, int front, rear, int size // store deque\n→ Step: Constructor: initialize array, front=0, rear=-1, size=0 // set empty state\n→ Step: Method insertFront(x)\n→ Decision: if isFull? // check full\n    Yes → Step: return false // cannot insert\n    No  → Step: front = (front - 1 + k) mod k // move front backward\n         → Step: data[front] = x // insert\n         → Step: size++ // increment size\n         → Step: return true // success\n...\nContinue similarly.\n\nWe'll produce each step line.\n\nWe must use \"→\" arrow before each step. Indentation for decisions.\n\nLet's craft full virtual code. Use variable names like k for capacity, front, rear, size. For simplicity.\n\nNeed to produce each step with comment after //.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 宣告類別 MyCircularDeque // 建立循環雙端佇列類別\n→ Step: 定義屬性: 數組 data[capacity] // 儲存元素的固定長度陣列\n→ Step: 定義屬性: 整數 front = 0 // 前端指標\n→ Step: 定義屬性: 整數 rear = -1 // 後端指標\n→ Step: 定義屬性: 整數 size = 0 // 當前元素數量\n\n→ Step: 建構子 MyCircularDeque(capacity) // 初始化佇列\n    → Step: data ← new 數組 of length capacity // 分配儲存空間\n    → Step: front ← 0 // 前端初值\n    → Step: rear ← -1 // 後端初值\n    → Step: size ← 0 // 空佇列\n\n→ Step: 方法 boolean insertFront(value) // 從前端插入\n    → Decision: 如果 isFull()? // 檢查是否已滿\n        Yes → Step: return false // 插入失敗\n        No  → Step: front ← (front - 1 + capacity) mod capacity // 往前移動指標\n             → Step: data[front] ← value // 放入元素\n             → Step: size ← size + 1 // 元素數量加一\n             → Step: return true // 成功\n\n→ Step: 方法 boolean insertLast(value) // 從後端插入\n    → Decision: 如果 isFull()? // 檢查是否已滿\n        Yes → Step: return false // 插入失敗\n        No  → Step: rear ← (rear + 1) mod capacity // 往後移動指標\n             → Step: data[rear] ← value // 放入元素\n             → Step: size ← size + 1 // 元素數量加一\n             → Step: return true // 成功\n\n→ Step: 方法 boolean deleteFront() // 從前端刪除\n    → Decision: 如果 isEmpty()? // 檢查是否為空\n        Yes → Step: return false // 刪除失敗\n        No  → Step: front ← (front + 1) mod capacity // 往後移動前端指標\n             → Step: size ← size - 1 // 元素數量減一\n             → Step: return true // 成功\n\n→ Step: 方法 boolean deleteLast() // 從後端刪除\n    → Decision: 如果 isEmpty()? // 檢查是否為空\n        Yes → Step: return false // 刪除失敗\n        No  → Step: rear ← (rear - 1 + capacity) mod capacity // 往前移動後端指標\n             → Step: size ← size - 1 // 元素數量減一\n             → Step: return true // 成功\n\n→ Step: 方法 int getFront() // 取得前端元素\n    → Decision: 如果 isEmpty()? // 若佇列為空\n        Yes → Step: return -1 // 無元素返回 -1\n        No  → Step: return data[front] // 回傳前端值\n\n→ Step: 方法 int getRear() // 取得後端元素\n    → Decision: 如果 isEmpty()? // 若佇列為空\n        Yes → Step: return -1 // 無元素返回 -1\n        No  → Step: return data[rear] // 回傳後端值\n\n→ Step: 方法 boolean isEmpty() // 判斷是否為空\n    → Step: return size == 0 // 若元素數量為零即為空\n\n→ Step: 方法 boolean isFull() // 判斷是否已滿\n    → Step: return size == capacity // 若元素數量等於容量即已滿\n\nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo2ou6crg.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpo2ou6crg.py\", line 41, in main\n    result = solution.complexNumberMultiply(a, b)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpo2ou6crg.py\", line 22, in complexNumberMultiply\n    a_real, a_imag = parse(a)\n                     ^^^^^^^^\n  File \"/tmp/tmpo2ou6crg.py\", line 19, in parse\n    imag_part = int(s[sep_index:])\n                ^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '+-1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        def parse(s: str):\n            # Remove the trailing 'i'\n            s = s.rstrip('i')\n            # Find the separator between real and imaginary part\n            # It is the first '+' or '-' after the first character\n            sep_index = -1\n            for i in range(1, len(s)):\n                if s[i] in '+-':\n                    sep_index = i\n                    break\n            if sep_index == -1:\n                raise ValueError(f\"Invalid complex number format: {s}\")\n            real_part = int(s[:sep_index])\n            imag_part = int(s[sep_index:])\n            return real_part, imag_part\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        real_part = a_real * b_real - a_imag * b_imag\n        imag_part = a_real * b_imag + a_imag * b_real\n\n        return f\"{real_part}+{imag_part}i\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # The input format is something like: \"1+1i\", \"1+1i\"\n    parts = data.split(',')\n    if len(parts) != 2:\n        raise ValueError(\"Input must contain two complex numbers separated by a comma.\")\n    a = parts[0].strip().strip('\"').strip(\"'\")\n    b = parts[1].strip().strip('\"').strip(\"'\")\n    solution = Solution()\n    result = solution.complexNumberMultiply(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for multiplication of two complex numbers given as strings, produce result string. We need to follow the format. Use virtual code with Start, Step, Decision, End. Provide explanation after each line. Need to parse strings, extract real and imaginary parts. Compute product: (a+bi)(c+di) = (ac - bd) + (ad + bc)i. Then construct string.\n\nWe need to use arrow \"→\" for steps. For decisions, use \"Decision:\". And arrow Yes → and No →.\n\nLet's produce steps:\n\nStart\n→ Step 1: Parse num1 to (a, b) // Extract real and imaginary from first string\n→ Step 2: Parse num2 to (c, d) // Extract real and imaginary from second string\n→ Step 3: Compute real part = a * c - b * d // Using formula\n→ Step 4: Compute imaginary part = a * d + b * c // Using formula\n→ Step 5: Format result as \"real+imaginaryi\" // Build string representation\nEnd\n\nBut we may want to include parsing details: split by '+' or '-'? Use Decision to determine sign of imaginary part? But maybe just assume format \"real+imaginaryi\" with real part possibly negative, imaginary part possibly negative, like \"-3+-2i\" or \"-3-2i\"? Actually format given: \"real+imaginaryi\" where imaginary part integer, may be negative. So representation might include negative sign in imaginary part preceded by +? Eg \"3-2i\". So we parse accordingly. We'll include step: Step 1a: Find index of '+' or '-' between real and imaginary. But can be easier: replace \"i\" and split. We'll just say parse. Might include decision: if string contains '-' after real part etc. But keep simple.\n\nLet's produce more detailed steps:\n\nStart\n→ Step 1: Remove trailing 'i' from num1 and num2 // Strip imaginary unit\n→ Step 2: Split each string into real and imaginary parts using last '+' or '-' separator // Find separator between real and imaginary\n→ Decision: If separator is '+'? // Determine sign\n    Yes → Step 3a: real1 = integer before separator, imag1 = integer after separator\n    No  → Step 3b: real1 = integer before separator, imag1 = - integer after separator\nSimilarly for num2\nBut we can condense. For brevity maybe skip decision and assume parsing yields real and imaginary correctly.\n\nOk produce code accordingly.\n\nLet's output each line with explanation.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 移除 num1 與 num2 末尾的 'i' // 把 \"3+2i\" 變成 \"3+2\"  \n→ Step 2: 在 num1 與 num2 內尋找最後一個 '+' 或 '-' 作為實部與虛部的分隔符 // 方便分離兩部分  \n→ Decision: 分隔符是 '+'? // 判斷虛部符號  \n  Yes → Step 3: real1 = 整數(分隔符前部分) , imag1 = 整數(分隔符後部分) // 虛部正  \n  No  → Step 3: real1 = 整數(分隔符前部分) , imag1 = -整數(分隔符後部分) // 虛部負  \n→ Decision: 同樣處理 num2，得到 real2 與 imag2  \n  Yes → Step 4: real2 = 整數(分隔符前部分) , imag2 = 整數(分隔符後部分)  \n  No  → Step 4: real2 = 整數(分隔符前部分) , imag2 = -整數(分隔符後部分)  \n→ Step 5: 計算乘積的實部 = real1 * real2 - imag1 * imag2 // (a+bi)(c+di) 的實部公式  \n→ Step 6: 計算乘積的虛部 = real1 * imag2 + imag1 * real2 // (a+bi)(c+di) 的虛部公式  \n→ Step 7: 將結果格式化為字串 \"real+imaginaryi\" // 若虛部為負，會自動產生 \"-2i\"  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"\n        找出檔案內容重複的檔案，並回傳每組重複檔案的完整路徑。\n        :param paths: List[str] 目錄資訊字串\n        :return: List[List[str]] 重複檔案路徑清單\n        \"\"\"\n        content_map = defaultdict(list)  # content -> list of full paths\n\n        for path_info in paths:\n            # 先把字串以空白分割，第一段是目錄路徑，其餘為檔案資訊\n            parts = path_info.split()\n            root = parts[0]                      # 目錄路徑\n            for file_info in parts[1:]:          # 每個檔案資訊為 \"name(content)\"\n                name, content = file_info.split('(')\n                content = content[:-1]           # 去掉最後的 ')'\n                full_path = f\"{root}/{name}\"    # 組成完整路徑\n                content_map[content].append(full_path)\n\n        # 只取出至少有兩個檔案的內容對應的路徑清單\n        return [paths for paths in content_map.values() if len(paths) > 1]\n\ndef main():\n    # 讀取整個 stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 若輸入包含 \"paths =\"，先移除前綴\n    if data.startswith('paths'):\n        data = data.split('=', 1)[1].strip()\n\n    try:\n        # 使用 literal_eval 解析安全的 Python 字面量\n        paths = ast.literal_eval(data)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        return\n\n    sol = Solution()\n    result = sol.findDuplicate(paths)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code for the problem: given list of directory info strings, parse to find duplicate files by content. Output groups. The virtual code steps.\n\nWe need to produce step-by-step, each line with virtual code and comment.\n\nUse Start, End, Decision. Use arrow for steps.\n\nWe need include data structures: map content -> list of paths.\n\nAlso need to parse string: split by spaces, first element is path, rest are files.\n\nFor each file, split by '(' to get name and content, strip ')'.\n\nAdd full path = directory + \"/\" + file.\n\nIf content not in map, add list.\n\nAfter processing all, filter map values with size >1.\n\nReturn list of lists.\n\nOk produce steps.\n\nLet's produce.\n\nWe need lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 content_to_paths 映射 // 建立內容到路徑的映射表\n→ Step 2: 對於每個 directoryInfo 在 paths 列表中進行迴圈 // 逐個處理每個目錄資訊字串\n\nWithin loop, parse.\n\nUse Decision for splitting.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空的字典 content_to_paths 來存放內容對應的檔案路徑清單 // 用於紀錄每個檔案內容所對應的所有路徑  \n→ Step 2: 對於每一個 directoryInfo 字串進行迴圈 // 逐行處理輸入列表  \n  → Decision: 取得 directoryInfo 的第一個空格前部份作為 directoryPath // 分離目錄路徑與檔案資訊  \n   Yes → Step 3: 取 directoryPath 為目前的目錄路徑 // 這是所有檔案的共同前綴  \n   No  → Step 4: 跳過此行 // 不可能發生，但保留結構  \n  → Step 5: 取得 directoryInfo 中空格後的所有子字串作為 filesInfo 列表 // 每個子字串為 \"fileName(content)\"  \n   → Decision: filesInfo 是否為空？ // 檢查是否有檔案資訊  \n    Yes → Step 6: 進入下一個 directoryInfo // 跳過空目錄  \n    No  \n     → For every fileInfo in filesInfo  \n      → Step 7: 用 '(' 分割 fileInfo 取得 fileName 與 contentPart // 取得檔名與內容  \n       → Step 8: 從 contentPart 去掉最後的 ')' 得到純內容 content // 取得真正的檔案內容  \n       → Step 9: 組成 fullPath = directoryPath + \"/\" + fileName // 產生完整路徑  \n       → Step 10: 如果 content 不在 content_to_paths 中，建立一個新的空清單 // 初始化存放此內容的路徑清單  \n       → Step 11: 把 fullPath 加入 content_to_paths[content] 的清單 // 記錄此檔案路徑  \n→ Step 12: 建立結果列表 duplicates = [] // 用於存放重複檔案組  \n→ Step 13: 對於每一個 content, pathsList 在 content_to_paths.items()  \n  → Decision: pathsList 長度大於 1？ // 只有多於一個檔案才是重複組  \n   Yes → Step 14: 把 pathsList 加入 duplicates // 收錄此重複組  \n   No  → Step 15: 跳過此 content // 不是重複檔案  \n→ End // 程式執行結束，duplicates 為所需的輸出結果"
    },
    {
      "title": "Implement Trie (Prefix Tree)",
      "source_file": "Leetcode/leetcode208.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8o739vin.py\", line 58, in <module>\n    method = getattr(trie, method_name)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\nAttributeError: 'Trie' object has no attribute 'Trie'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass TrieNode:\n    \"\"\"節點類別：包含子節點字典與是否為單詞結尾的標記\"\"\"\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    \"\"\"前綴樹（Trie）實作\"\"\"\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 為了能使用 literal_eval，將輸入包在小括號內，形成一個 tuple\n    data_str = f\"({raw_input})\"\n    try:\n        methods, args = ast.literal_eval(data_str)\n    except Exception as e:\n        # 若解析失敗，直接結束\n        sys.exit()\n\n    trie = Trie()\n    results = [None]  # 第一個 null 對應於 Trie() 的呼叫\n\n    for method_name, arg_list in zip(methods, args):\n        method = getattr(trie, method_name)\n        # 方法可能需要 0 個或多個參數\n        result = method(*arg_list)\n        results.append(result)\n\n    # 將結果輸出為 JSON 格式（null、true、false）\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation in Traditional Chinese. The code is a virtual pseudocode representation of a Trie class with methods: constructor, insert, search, startsWith. Should be line-by-line. Use Start, End, Decision. Provide each line with virtual code and comment. No actual code. Should use arrow \"→\". For each method we produce steps. Might also create a Node structure inside. Virtual code steps. Let's design:\n\nStart // program start\n→ Step 1: 定義 Trie 類別 // define class\n    → Step 2: 初始化根節點 root → Node // create root node\n    → Step 3: 設置 root.children 為空映射 // empty map\n    → Step 4: 設置 root.isEnd 為 false // end marker\nEnd // done class definition? We may show methods separately.\n\nAlternatively produce a flow for each method.\n\nProbably produce each method separately with steps. Use Decision: etc.\n\nLet's craft:\n\nStart // 初始化 Trie\n→ Step 1: 建立 Node 結構 // node with children map and isEnd flag\n→ Step 2: 在 Trie 建構子內建立根節點 root\nEnd // 完成 Trie 建構\n\nThen methods:\n\nStart // insert 方法\n→ Step 1: 設置 current 指向 root\n→ Step 2: 迭代每個字母 ch in word\n    → Step 3: 如果 current.children 沒有 ch\n        → Step 4: 創建新 Node 並加入 children[ch]\n    → Step 5: 更新 current = current.children[ch]\n→ Step 6: 設置 current.isEnd 為 true // 標記單詞結尾\nEnd // insert 結束\n\nStart // search 方法\n→ Step 1: 設置 current 指向 root\n→ Step 2: 迭代每個字母 ch in word\n    → Step 3: 如果 current.children 沒有 ch\n        → Step 4: 回傳 false // 未找到\n    → Step 5: 更新 current = current.children[ch]\n→ Step 6: Decision: current.isEnd?\n    Yes → 回傳 true\n    No  → 回傳 false\nEnd // search 結束\n\nStart // startsWith 方法\n→ Step 1: 設置 current 指向 root\n→ Step 2: 迭代每個字母 ch in prefix\n    → Step 3: 如果 current.children 沒有 ch\n        → Step 4: 回傳 false // 前綴不存在\n    → Step 5: 更新 current = current.children[ch]\n→ Step 6: 回傳 true // 前綴存在\nEnd // startsWith 結束\n\nAdd comments.\n\nMake sure each line ends with // 解釋. Use Traditional Chinese. Use arrow \"→\". Use Decision: . Provide indentation maybe but not necessary. Provide line numbers? Not needed.\n\nMake sure to include Start and End at overall program start? Might not require global Start. But sample uses Start at top. We'll provide Start for each method. Ok.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 建立 Trie 類別\n→ Step 1: 定義 Node 結構 // 每個節點含有 children (字典) 與 isEnd (布林)\n→ Step 2: 在 Trie 建構子內建立根節點 root // root.children 為空映射，root.isEnd 為 false\nEnd // Trie 類別結束初始化\n\nStart // insert 方法\n→ Step 1: 設置 current 指向 root // 從根節點開始\n→ Step 2: 逐字母遍歷 word\n    → Step 3: 如果 current.children 沒有此字母 ch\n        → Step 4: 創建新 Node 並加入 current.children[ch] // 新增子節點\n    → Step 5: current ← current.children[ch] // 移動到子節點\n→ Step 6: current.isEnd ← true // 標記單詞結尾\nEnd // insert 方法結束\n\nStart // search 方法\n→ Step 1: 設置 current 指向 root\n→ Step 2: 逐字母遍歷 word\n    → Step 3: 如果 current.children 沒有此字母 ch\n        → Step 4: 回傳 false // 詞不存在\n    → Step 5: current ← current.children[ch]\n→ Step 6: Decision: current.isEnd?\n    Yes → 回傳 true // 完整匹配\n    No  → 回傳 false // 不是完整單詞\nEnd // search 方法結束\n\nStart // startsWith 方法\n→ Step 1: 設置 current 指向 root\n→ Step 2: 逐字母遍歷 prefix\n    → Step 3: 如果 current.children 沒有此字母 ch\n        → Step 4: 回傳 false // 前綴不存在\n    → Step 5: current ← current.children[ch]\n→ Step 6: 回傳 true // 任何字串以此前綴開始\nEnd // startsWith 方法結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[10]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[10]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[6,8]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[6, 8]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[1,9,7]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[1, 9, 7]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport re\n\ndef rand7():\n    \"\"\"API that returns a uniform random integer in [1, 7].\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        \"\"\"\n        Generates a uniform random integer in [1, 10] using only rand7().\n        Uses rejection sampling with two calls to rand7() to get a uniform\n        distribution over 1~49, then discards values > 40 to maintain\n        uniformity over 1~10.\n        \"\"\"\n        while True:\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\ndef main():\n    \"\"\"\n    Reads input from stdin, which contains an expression like 'n = 3'.\n    Parses the integer n, generates n random numbers using rand10(),\n    and prints the list of results to stdout.\n    \"\"\"\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating rand10 from rand7. Standard solution: use two calls to get 49 outcomes, discard >40, map 1-40 to 1-10 by modulo. Or use rejection sampling with 7*7=49.\n\nWe need to write step-by-step pseudocode with explanation comments. Each line: \"虛擬碼步驟\" + \" // 解釋/說明\". Use Start, End, Decision, Yes →, No →, etc.\n\nWe need to produce step-by-step algorithm.\n\nLet's outline steps:\n\nStart\n\n→ Step 1: repeat\n   → Step 2: call rand7() → a\n   → Step 3: call rand7() → b\n   → Step 4: compute index = (a-1)*7 + b // gives 1-49\n   → Decision: if index <= 40?\n      Yes → Step 5: return (index-1) mod 10 + 1\n      No → Step 6: go back to Step 1 (repeat)\nEnd\n\nWe need to include loops? Use \"Repeat\" or \"Loop\".\n\nBetter to have a Loop: \"Repeat:\"\n\nBut format: Use arrow and indentation.\n\nWe can use \"→ Step 1: repeat\" but maybe use \"Loop:\".\n\nLet's propose:\n\nStart // 程式開始執行\n→ Loop: // 進入重複區塊\n    → Step 1: a ← rand7() // 取得 1-7 的隨機數\n    → Step 2: b ← rand7() // 再次取得 1-7 的隨機數\n    → Step 3: index ← (a-1)*7 + b // 組合成 1-49 的索引\n    → Decision: 如果 index ≤ 40? // 只保留前 40 個可映射值\n        Yes → Step 4: result ← (index-1) mod 10 + 1 // 轉成 1-10\n        Yes → Return result // 結束 rand10()\n        No  → Continue // 跳回 Loop 重新嘗試\nEnd // 程式結束\n\nBut we need to follow arrow format precisely: \"Decision:\" line with indent. And Yes → lines. The 'Continue' or 'Go to start of loop' should be expressed. We could use \"No → Step 1: repeat\"? But we have to stay inside loop.\n\nMaybe:\n\n→ Decision: 如果 index ≤ 40? \n    Yes → Step 4: result ← (index-1) mod 10 + 1\n    Yes → Step 5: Return result\n    No  → Go to Step 1 // 重新嘗試\n\nBut we need to ensure we don't call other APIs.\n\nAlso, we need to consider explanation.\n\nLet's produce final output accordingly.\n\nCheck formatting: Each line: \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use Start, End, Decision. Use arrow →, Yes →, No →.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Loop: // 進入重複區塊以嘗試產生 1-10 的隨機數\n    → Step 1: a ← rand7() // 取得第一個 1-7 的隨機數\n    → Step 2: b ← rand7() // 取得第二個 1-7 的隨機數\n    → Step 3: index ← (a-1) * 7 + b // 轉換成 1-49 的索引\n    → Decision: 如果 index ≤ 40? // 只保留可映射到 1-10 的 40 個值\n        Yes → Step 4: result ← (index-1) mod 10 + 1 // 轉成 1-10\n        Yes → Step 5: Return result // 給定 rand10() 的結果\n        No  → Go to Step 1 // 超過 40，重新嘗試\nEnd // 程式執行結束\n\nCheck each line has \"虛擬碼步驟\" + \" // 解釋\".\n\nBut we need to avoid \"Go to Step 1\" maybe \"Repeat\" but acceptable.\n\nWe need to ensure indentation and arrow signs.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Loop: // 進入重複區塊以嘗試產生 1-10 的隨機數  \n    → Step 1: a ← rand7() // 取得第一個 1-7 的隨機數  \n    → Step 2: b ← rand7() // 取得第二個 1-7 的隨機數  \n    → Step 3: index ← (a-1) * 7 + b // 轉換成 1-49 的索引  \n    → Decision: 如果 index ≤ 40? // 只保留可映射到 1-10 的 40 個值  \n        Yes → Step 4: result ← (index-1) mod 10 + 1 // 轉成 1-10  \n        Yes → Step 5: Return result // 給定 rand10() 的結果  \n        No  → Go to Step 1 // 超過 40，重新嘗試  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkqz_nv16.py\", line 45, in <module>\n    price, special, needs = parse_input(raw_input)\n                            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkqz_nv16.py\", line 38, in parse_input\n    special = ast.literal_eval(special_pat.group(1))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[3,0,5]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxtn3j0d1.py\", line 45, in <module>\n    price, special, needs = parse_input(raw_input)\n                            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpxtn3j0d1.py\", line 38, in parse_input\n    special = ast.literal_eval(special_pat.group(1))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,4]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # 基本價格：直接按單價購買\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            # 嘗試每個優惠\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef parse_input(text):\n    # 找出 price, special, needs 的列表字串\n    price_pat = re.search(r'price\\s*=\\s*(\\[[^\\]]*\\])', text)\n    special_pat = re.search(r'special\\s*=\\s*(\\[[^\\]]*\\])', text)\n    needs_pat = re.search(r'needs\\s*=\\s*(\\[[^\\]]*\\])', text)\n    if not price_pat or not special_pat or not needs_pat:\n        raise ValueError(\"Input format incorrect\")\n    price = ast.literal_eval(price_pat.group(1))\n    special = ast.literal_eval(special_pat.group(1))\n    needs = ast.literal_eval(needs_pat.group(1))\n    return price, special, needs\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    price, special, needs = parse_input(raw_input)\n    result = Solution().shoppingOffers(price, special, needs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code (pseudo-code) solving the LeetCode \"Shopping Offers\" problem. Provide step by step virtual code lines with explanation. Should handle input arrays price, needs, special. The algorithm: use DFS with memoization (DP) to compute minimal cost for given needs. Also include handling of special offers: check if offer is applicable (not exceeding needs). Recursively compute cost.\n\nWe need to produce lines: Start, then steps: e.g., \"→ Step 1: 定義遞迴函式 DFS(需求列表)\" etc.\n\nWe need to output each line with arrow or \"Start\"/\"End\" etc. Ensure the format: each line: virtual code step + space + `// 解釋/說明`. Use arrow and Decision. Must not output actual code.\n\nWe should produce pseudo code lines like:\n\nStart // 程式開始執行\n→ Step 1: 建立 memoization 映射 map // 用來記錄已計算的需求組合最小價格\n→ Step 2: 定義遞迴函式 DFS(目前需求) // 計算此需求的最小價格\n→ Decision: 如果需求已在 memo 中? // 查詢是否已計算過\n    Yes → Step 3: 回傳 memo[需求] // 直接回傳\n    No → Step 4: 計算基礎價格 = sum(需求[i] * price[i]) // 直接買\n→ Step 5: 設定 minPrice = 基礎價格 // 初始化最小價格\n→ For each special offer in special:\n    → Decision: 該優惠是否可用? // 檢查每件不超過需求\n        Yes → Step 6: 建立新需求 = 需求 - offerQuantities\n               → Step 7: 獲取 offerPrice = offerCost + DFS(新需求) // 用優惠 + 其餘最小價格\n               → Decision: offerPrice < minPrice? // 比較\n                   Yes → Step 8: minPrice = offerPrice // 更新\n    End For\n→ Step 9: memo[需求] = minPrice // 記錄結果\n→ Step 10: 回傳 minPrice\n→ Step 11: 呼叫 DFS(needs) // 開始計算\n→ End // 程式結束\n\nNeed to add arrow formatting: for loops maybe \"→ For each special offer in special:\" etc.\n\nLet's produce in Chinese.\n\nWe need to follow format exactly: each line \"虛擬碼步驟 [space] // 解釋\". Use arrow `→` before each step, and use `Decision:` lines with Yes → and No →.\n\nMake sure lines are sequential.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 memoization 映射 Map // 用於記錄已計算需求組合的最小價格  \n→ Step 2: 定義遞迴函式 DFS(需求陣列 currentNeeds) // 計算此需求的最小價格  \n→ Decision: 若 currentNeeds 已在 memo 中? // 判斷是否已有結果  \n    Yes → Step 3: 回傳 memo[currentNeeds] // 直接回傳已計算的價格  \n    No → Step 4: 計算基礎價格 basePrice = Σ(currentNeeds[i] * price[i]) // 直接購買不使用優惠的價格  \n→ Step 5: 初始化 minPrice = basePrice // 設定目前最小價格為直接購買價格  \n→ For each special offer offer in special: // 遍歷所有優惠  \n    → Decision: 該優惠是否可用? // 檢查每種商品的數量是否不超過 currentNeeds  \n        Yes → Step 6: 建立 newNeeds[i] = currentNeeds[i] - offer[i] // 計算使用此優惠後剩餘需求  \n               → Step 7: 取得 offerPrice = offer[n] + DFS(newNeeds) // 優惠價格加上剩餘需求的最小價格  \n               → Decision: offerPrice < minPrice? // 與目前最小價格比較  \n                 Yes → Step 8: minPrice = offerPrice // 更新最小價格  \n    End For  \n→ Step 9: memo[currentNeeds] = minPrice // 將結果記錄進 memo 以備重複使用  \n→ Step 10: 回傳 minPrice // 返回此需求的最小價格  \n→ Step 11: 呼叫 DFS(needs) // 開始計算給定的需求  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpyanb1toc.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpyanb1toc.py\", line 38, in main\n    args_list = json.loads(data[idx + 4:])\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 12 (char 11)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]\n        self.tree = [0] * (self.n + 1)\n        for i in range(self.n):\n            self._update_tree(i + 1, nums[i])\n\n    def _update_tree(self, i, val):\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, i):\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\ndef main():\n    data = sys.stdin.read().strip().replace('\\n', '')\n    if not data:\n        return\n    idx = data.find('], [')\n    methods = json.loads(data[:idx + 1])\n    args_list = json.loads(data[idx + 4:])\n    results = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"NumArray\":\n            obj = NumArray(args[0])\n            results.append(None)\n        elif method == \"update\":\n            obj.update(*args)\n            results.append(None)\n        elif method == \"sumRange\":\n            res = obj.sumRange(*args)\n            results.append(res)\n    out = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the implementation of NumArray with update and sumRange using likely a Fenwick tree or segment tree. Provide line-by-line steps with explanations. Use arrow notation. Provide start, end. Should not output actual code. Should output \"虛擬碼步驟 // 解釋\". We must handle multiple queries: update and sumRange. Probably implement with Binary Indexed Tree. Provide steps: initialization, building tree, update operation, prefix sum, sumRange. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收整數陣列 nums 並儲存為內部屬性 // 初始化物件，備存原始數列  \n→ Step 2: 建立長度為 n 的 Binary Indexed Tree (BIT) 陣列 tree，初始全為 0 // 準備前綴和結構  \n→ Decision: 若 nums 非空? // 判斷是否需要初始化樹  \n    Yes → Step 3: 逐個索引 i 從 0 到 n-1  \n        → Step 4: 呼叫 updateBIT(i, nums[i]) // 以差值方式構建 BIT，累積每個元素  \n        → Step 5: End of Step 3 // 完成 BIT 建構  \n    No → Step 6: End of Decision // 空陣列，直接跳過建構  \n→ Step 7: 完成 NumArray 建構 // 建構階段結束  \n\n// ------------------- Update Operation -------------------  \n→ Step 8: 定義方法 update(index, val)  \n    → Decision: 確認 index 在合法範圍內? // 防止越界  \n        Yes → Step 9: 計算 diff = val - nums[index] // 差值  \n        → Step 10: nums[index] = val // 更新原始陣列  \n        → Step 11: 呼叫 updateBIT(index, diff) // 在 BIT 中調整差值  \n        → Step 12: End of Step 8 // 更新完成  \n        No → Step 13: Return // 無效索引，直接返回  \n\n// ------------------- Sum Range Operation -------------------  \n→ Step 14: 定義方法 sumRange(left, right)  \n    → Decision: 檢查 left 與 right 的合法性且 left ≤ right?  \n        Yes → Step 15: sumR = prefixSum(right) // 取得 [0, right] 的和  \n        → Step 16: sumL = prefixSum(left - 1) // 取得 [0, left-1] 的和  \n        → Step 17: Return sumR - sumL // 兩者差即為 [left, right] 的和  \n        No → Step 18: Return 0 // 無效區間，返回 0  \n    End of Step 14 // sumRange 完成  \n\n// ------------------- Helper Functions -------------------  \n→ Step 19: 定義 helper 函數 prefixSum(idx)  \n    → Decision: idx < 0?  \n        Yes → Step 20: Return 0 // 索引負值代表無元素  \n        No → Step 21: 初始化 sum = 0, i = idx + 1  \n            → Step 22: While i > 0: sum += tree[i]; i -= i & -i // BIT 累加  \n            → Step 23: Return sum // 返回前綴和  \n    End of Step 19 // prefixSum 完成  \n\n→ Step 24: 定義 helper 函數 updateBIT(idx, delta)  \n    → Step 25: i = idx + 1  \n        → While i ≤ n: tree[i] += delta; i += i & -i // BIT 更新  \n    → End of Step 24 // updateBIT 完成  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Next Permutation",
      "source_file": "Leetcode/leetcode31.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,3,2]",
          "actual_output_or_error": "File \"/tmp/tmpbu9w55ui.py\", line 22\n    nums[i], nums[j] = nums[j], nums[i       \n                                    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1]",
          "expected_output": "[1,2,3]",
          "actual_output_or_error": "File \"/tmp/tmpq_90h1iy.py\", line 22\n    nums[i], nums[j] = nums[j], nums[i       \n                                    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,5]",
          "expected_output": "[1,5,1]",
          "actual_output_or_error": "File \"/tmp/tmp_j7u01cl.py\", line 22\n    nums[i], nums[j] = nums[j], nums[i       \n                                    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def nextPermutation(self, nums):\n        \"\"\"\n        Modify nums in-place to the next lexicographical permutation.\n        If such permutation does not exist, rearrange nums to the lowest possible order (ascending).\n        \"\"\"\n        n = len(nums)\n        i = n - 2\n        # Find the first index i such that nums[i] < nums[i+1] when scanning from right to left\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n\n        if i >= 0:\n            # Find the first index j from the end where nums[j] > nums[i]\n            j = n - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            # Swap the pivot and its successor\n            nums[i], nums[j] = nums[j], nums[i       \n\n        # Reverse the suffix starting at i+1 to get the smallest suffix\n        left, right = i + 1, n - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Expected format: \"nums = [1,2,3]\"\n    try:\n        # Split on the first '=' and evaluate the right-hand side safely\n        _, arr_str = data.split('=', 1)\n        nums = ast.literal_eval(arr_str.strip())\n    except (ValueError, SyntaxError):\n        # If the input format is not as expected, exit gracefully\n        sys.exit(\"Invalid input format\")\n\n    # Compute the next permutation\n    Solution().nextPermutation(nums)\n\n    # Output the resulting list\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step for algorithm: next permutation. Use Start, End, Decision, arrows. Provide explanation comment after each line.\n\nWe must not output actual code, only pseudocode lines. The user gave description of next permutation problem. We need to produce virtual code and explanation.\n\nSteps typical:\n\n1. Find largest index i such that nums[i] < nums[i+1]. If none, reverse entire array and end.\n2. Find largest index j > i such that nums[j] > nums[i].\n3. Swap nums[i] and nums[j].\n4. Reverse subarray nums[i+1:] (i.e., from i+1 to end).\n\nWe need to produce lines with arrows and comments. Use virtual code syntax like: Step 1: 找到 i... etc.\n\nLet's create a Start block.\n\nWe need to ensure we use arrow syntax as per requirement: \"→ Step 1:\" etc.\n\nWe need to include decisions.\n\nDecision: If i exists? yes/no. Then maybe no block.\n\nLet's outline:\n\nStart\n→ Step 1: 初始化 i = length(nums)-2 // 從倒數第二個元素開始向前尋找\n→ Decision: 如果 nums[i] < nums[i+1]? // 檢查是否有升序斜率\n    Yes → Step 2: 將 i 位置記錄\n    No  → Step 3: Reverse 整個陣列 // 最後一個排列，回到第一個\n        → End\nContinue after decision.\n\nBut we need to treat No path leading to reverse and end. If Yes path, we need to find j.\n\nSo we need nested decisions.\n\nLet's propose:\n\nStart\n→ Step 1: i = len(nums) - 2\n→ Decision: i < 0 或 nums[i] >= nums[i+1]? // 檢查是否存在升序段\n    Yes → Step 2: Reverse nums // 把整個陣列反轉成升序\n        → End\n    No  → Step 3: i = i // 繼續\n→ Decision: i >= 0 且 nums[i] < nums[i+1] ? // 確認 i 合法\n    Yes → Step 4: j = len(nums)-1\n    No  → (should not happen) // 這裡為安全\n→ Decision: nums[j] <= nums[i]? // 找 j\n    Yes → Step 5: j = j - 1\n    No  → Step 6: Swap nums[i] 與 nums[j]\n→ Step 7: Reverse nums[i+1:] // 反轉後半段\nEnd\n\nBut we need simpler.\n\nAlternate standard algorithm:\n\nStart\n→ Step 1: i = len(nums)-2\n→ Decision: i >= 0 AND nums[i] < nums[i+1]? // find pivot\n    Yes → Step 2: // pivot found\n    No  → Step 3: Reverse nums // array is highest perm\n        → End\nStep 2:\n→ Decision: i < 0? // if pivot not found\n    Yes → Step 4: Reverse nums\n        → End\n    No  → Step 5: // find rightmost successor\n→ Step 5: j = len(nums)-1\n→ Decision: nums[j] <= nums[i]?\n    Yes → Step 6: j = j-1\n    No  → Step 7: Swap nums[i], nums[j]\n→ Step 8: Reverse nums[i+1:] // reverse suffix\nEnd\n\nBut we can simplify: The first decision covers pivot detection. Actually algorithm:\n\n- Find i: largest index such that nums[i] < nums[i+1]\n- If i < 0: reverse entire array and return\n- Find j: largest index > i such that nums[j] > nums[i]\n- Swap nums[i] and nums[j]\n- Reverse nums[i+1:]\n\nThus we can produce lines accordingly.\n\nLet's produce pseudo:\n\nStart // 程式開始\n→ Step 1: i ← len(nums) - 2 // 從倒數第二個元素開始尋找\n→ Decision: i ≥ 0 AND nums[i] < nums[i+1]? // 檢查是否有升序斜率\n    Yes → // 進一步尋找 pivot\n    No  → Step 2: Reverse nums // 整個陣列反轉成升序\n        → End\nStep 2: // pivot 已找到，繼續尋找 j\n→ Step 3: j ← len(nums) - 1 // 從最後一個元素開始\n→ Decision: nums[j] ≤ nums[i]? // 是否還未找到更大值\n    Yes → Step 4: j ← j - 1\n    No  → Step 5: Swap nums[i], nums[j] // 交換 pivot 與 successor\n→ Step 6: Reverse nums[i+1:] // 反轉後半段\nEnd // 程式結束\n\nBut we need decision to loop j until find > pivot.\n\nIn pseudocode we could write loop but easier to use decisions: while nums[j] <= nums[i] do j = j-1. But we must show as decision chain.\n\nLet's produce:\n\n→ Decision: nums[j] ≤ nums[i]?\n    Yes → Step 4: j ← j - 1 // 逐步向左移動\n        → Decision: nums[j] ≤ nums[i]?\n            Yes → repeat\n            No  → Step 5: Swap\n    No  → Step 5: Swap\n\nBut easier: Show as while loop style.\n\nGiven constraints, we can use \"→ While\" structure? Not specified. But we can use Decision repeated.\n\nBetter: Use a loop structure: \"→ While nums[j] ≤ nums[i]:\" but not allowed? They didn't forbid loops but used Decision. Could use \"Decision:\" with Yes branch that loops back.\n\nWe can do:\n\n→ Decision: nums[j] ≤ nums[i]?\n    Yes → Step 4: j ← j - 1\n        → Decision: nums[j] ≤ nums[i]?\n            Yes → Step 5: j ← j - 1\n            No  → Step 6: Swap\n    No  → Step 6: Swap\n\nSimpler: we can assume j moves until > i, then swap.\n\nWe can produce a step: Step 4: Find j (rightmost element > nums[i]) // 迴圈尋找\n\nBut they'd want explicit decisions. Might be fine to state \"Step 4: 找到 j 使得 nums[j] > nums[i]\" but not show loop.\n\nLet's produce a concise virtual code with explanation.\n\nI'll produce:\n\nStart // 程式開始\n→ Step 1: i ← len(nums) - 2 // 從倒數第二個元素開始向左尋找\n→ Decision: i ≥ 0 AND nums[i] < nums[i+1]? // 找到升序斜率\n    Yes → // pivot 已找到，繼續\n    No  → Step 2: Reverse nums // 整個陣列反轉成升序\n        → End\nStep 2: // pivot 已找到\n→ Step 3: j ← len(nums) - 1 // 從最後一個元素開始\n→ Decision: nums[j] ≤ nums[i]? // 需要找到更大值\n    Yes → Step 4: j ← j - 1\n        → Decision: nums[j] ≤ nums[i]?\n            Yes → Step 5: j ← j - 1\n            No  → Step 6: Swap nums[i], nums[j]\n    No  → Step 6: Swap nums[i], nums[j]\n→ Step 7: Reverse nums[i+1:] // 反轉後半段，使其升序\nEnd // 程式結束\n\nBut we may want to show step 6 and step 7 clearly.\n\nAlternatively, we can compress decision chain by describing \"Find j\" as loop.\n\nMaybe better to present as:\n\n→ Step 3: Find j such that nums[j] > nums[i] // 迴圈向左尋找\n→ Step 4: Swap nums[i], nums[j] // 交換 pivot 與 successor\n→ Step 5: Reverse nums[i+1:] // 反轉後半段\n\nBut they'd ask to use Decision and arrows. We can use decision to indicate the loop.\n\nSimplify: Use while loop structure:\n\n→ While nums[j] ≤ nums[i] Do j ← j-1 // 迴圈尋找更大值\n\nBut not in required syntax. The requirement only says use Decision and arrows and structure.\n\nThey didn't forbid while, but might be okay.\n\nBut safer: Use Decision with Yes branch that loops back to previous step. For instance:\n\n→ Decision: nums[j] ≤ nums[i]?\n    Yes → Step 3: j ← j - 1 // 尋找更大值\n        → Decision: nums[j] ≤ nums[i]?\n            Yes → Step 4: j ← j - 1\n            No  → Step 5: Swap...\n    No  → Step 5: Swap...\n\nBut this gets repetitive.\n\nBetter: Write:\n\n→ Step 3: j ← len(nums) - 1\n→ Decision: nums[j] > nums[i]?\n    No → Step 3: j ← j - 1 // 如果不大，往左移\n        → Decision: nums[j] > nums[i]?\n            No → continue\n            Yes → Step 4: Swap\n    Yes → Step 4: Swap\n\nOk.\n\nGiven the format requirement, we need each line to include \"虛擬碼步驟 [空格] // 解釋/說明\". Also include arrow, Decision, Yes →, No →, Start, End.\n\nWe should maintain each line as a single line with arrow and comment.\n\nThus produce:\n\nStart // 程式開始\n→ Step 1: i ← len(nums) - 2 // 從倒數第二個元素開始尋找 pivot\n→ Decision: i ≥ 0 AND nums[i] < nums[i+1] ? // 判斷是否存在升序斜率\n    Yes → // 有 pivot，繼續\n    No  → Step 2: Reverse nums // 整個陣列反轉成升序\n        → End\nStep 3: // pivot 已找到，繼續尋找 j\n→ Step 4: j ← len(nums) - 1 // 從最後一個元素開始\n→ Decision: nums[j] > nums[i] ?\n    No  → Step 5: j ← j - 1 // 仍未找到更大值，往左移\n        → Decision: nums[j] > nums[i] ?\n            No  → Step 5: j ← j - 1 // 繼續往左\n            Yes → Step 6: Swap nums[i], nums[j] // 找到 successor\n    Yes → Step 6: Swap nums[i], nums[j] // 直接交換\n→ Step 7: Reverse nums[i+1:] // 反轉後半段，得到下一個排列\nEnd // 程式結束\n\nBut we used Step 5 twice. That's confusing. Maybe rename:\n\n→ Step 5: j ← j - 1 // 往左尋找更大值\n→ Step 6: Swap nums[i], nums[j]\n→ Step 7: Reverse nums[i+1:]\n\nBut we need to incorporate decisions accordingly.\n\nWe might present more linear:\n\nStart\n→ Step 1: i ← len(nums) - 2\n→ Decision: i ≥ 0 AND nums[i] < nums[i+1] ?\n    Yes →\n    No  → Step 2: Reverse nums\n        → End\nStep 3: j ← len(nums) - 1\n→ Decision: nums[j] ≤ nums[i] ?\n    Yes → Step 4: j ← j - 1\n        → Decision: nums[j] ≤ nums[i] ?\n            Yes → Step 4: j ← j - 1 // 循環\n            No  → Step 5: Swap nums[i], nums[j]\n    No  → Step 5: Swap nums[i], nums[j]\n→ Step 6: Reverse nums[i+1:]\nEnd\n\nBut this still shows Step 4 repeated. Perhaps we can compress using loop style but it's not required.\n\nBetter: Provide algorithm in a simpler pseudocode that uses loops but with comments.\n\nBut requirement: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`).\" They didn't forbid loops. We can use \"→ While\". Let's check if they explicitly forbid. They didn't mention.\n\nThus we can use \"→ While\" maybe.\n\nAlternatively, use a simplified approach: Step 1: Find i; Step 2: If no i, reverse; Step 3: Find j; Step 4: Swap; Step 5: Reverse suffix. Provide explanation. Use Decision to branch for i not found.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: i ← len(nums) - 2 // 從倒數第二個元素開始向左尋找\n→ Decision: i ≥ 0 AND nums[i] < nums[i+1] ?\n    Yes → // pivot exists\n    No  → Step 2: Reverse nums // 沒有更大的排列，重置為升序\n        → End\nStep 3: // pivot 已找到，尋找 successor\n→ Step 4: j ← len(nums) - 1 // 從最後一個元素開始\n→ While nums[j] ≤ nums[i] Do j ← j - 1 // 找到比 pivot 大的最右元素\n→ Step 5: Swap nums[i], nums[j] // 交換 pivot 與 successor\n→ Step 6: Reverse nums[i+1:] // 反轉後半段，使其升序\nEnd // 程式結束\n\nBut we didn't include Decision arrow for While but we used While. That may be acceptable.\n\nBut they ask each line to contain arrow, e.g., \"→ Step ...\". For While we could say \"→ While nums[j] ≤ nums[i] Do j ← j - 1\". But this line might be ambiguous. But acceptable.\n\nHowever, maybe better to avoid While. Provide explicit decision chain.\n\nBut the instruction: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`).\" They didn't say cannot use other constructs. But to be safe, use Decision and arrows only.\n\nWe can simulate while loop using recursion: \"Decision: nums[j] ≤ nums[i]?\" Yes → Step: j ← j - 1, then go back to same decision.\n\nWe can do:\n\n→ Decision: nums[j] ≤ nums[i] ?\n    Yes → Step 4: j ← j - 1\n        → Decision: nums[j] ≤ nums[i] ?\n            Yes → Step 4: j ← j - 1\n            No  → Step 5: Swap nums[i], nums[j]\n    No  → Step 5: Swap nums[i], nums[j]\n\nBut this will duplicate step 4 multiple times; but we can show just one and refer back? Might be confusing.\n\nGiven typical educational pseudocode, using While is acceptable.\n\nI'll produce with While.\n\nBut each line must have arrow and comment. For While line, we can do:\n\n→ While nums[j] ≤ nums[i] Do j ← j - 1 // 迴圈尋找更大值\n\nBut the arrow before While? We use \"→ While\".\n\nAlso, each step line must include comment.\n\nThus final answer:\n\nStart // 程式開始\n→ Step 1: i ← len(nums) - 2 // 從倒數第二個元素開始向左尋找 pivot\n→ Decision: i ≥ 0 AND nums[i] < nums[i+1] ?\n    Yes → // 有 pivot，繼續\n    No  → Step 2: Reverse nums // 整個陣列反轉成升序\n        → End\nStep 3: // pivot 已找到\n→ Step 4: j ← len(nums) - 1 // 從最後一個元素開始\n→ While nums[j] ≤ nums[i] Do j ← j - 1 // 迴圈尋找更大值\n→ Step 5: Swap nums[i], nums[j] // 交換 pivot 與 successor\n→ Step 6: Reverse nums[i+1:] // 反轉後半段，得到下一個排列\nEnd // 程式結束\n\nWe used Step labels 1-6. Good.\n\nEnsure each line has arrow. For the Decision lines we have indent lines. Need to maintain the arrow for Yes → and No → lines as well. But the \"Yes →\" and \"No →\" should be separate lines. The format is like:\n\nDecision: ... ?\n    Yes → ...\n    No  → ...\n\nBut we need to put each as separate lines with arrow.\n\nAlso for the \"No  → Step 2: Reverse nums // ...\" we need arrow and comment. Yes.\n\nLet's format precisely:\n\nStart // 程式開始\n→ Step 1: i ← len(nums) - 2 // 從倒數第二個元素開始向左尋找 pivot\n→ Decision: i ≥ 0 AND nums[i] < nums[i+1] ? // 判斷是否存在升序斜率\n    Yes → // 有 pivot，繼續\n    No  → Step 2: Reverse nums // 整個陣列反轉成升序\n        → End\nStep 3: // pivot 已找到\n→ Step 4: j ← len(nums) - 1 // 從最後一個元素開始\n→ While nums[j] ≤ nums[i] Do j ← j - 1 // 迴圈尋找更大值\n→ Step 5: Swap nums[i], nums[j] // 交換 pivot 與 successor\n→ Step 6: Reverse nums[i+1:] // 反轉後半段，得到下一個排列\nEnd // 程式結束\n\nBut after \"No  → Step 2: Reverse nums\" we need arrow for the inner step. We had \"→ End\" but that arrow may not be required; but we can keep.\n\nBut the \"End\" line we need arrow. But it's a separate line. So:\n\n→ End // 程式結束\n\nBut in the sample they had \"End // 程式執行結束\" no arrow. Actually sample used \"End // 程式執行結束\" without arrow. So we should follow that: \"End // 程式執行結束\" no arrow. Similarly, \"Start // 程式開始\" no arrow.\n\nThus we should have:\n\nStart // 程式開始\n→ Step 1: ...\n→ Decision: ...\n    Yes → ...\n    No  → Step 2: Reverse nums // ...\n        End // 程式結束\n\nBut the inner End maybe no arrow? They used \"End // 程式執行結束\" not preceded by arrow. So we should not use arrow before End. So in the branch, we should put \"End // 程式結束\" on a separate line with no arrow.\n\nBut how to indent? We can keep same indentation as arrow lines. In sample, they had:\n\n    No  → Decision: 如果數字等於 0? // ...\n        Yes → Step 3: 輸出 '零' // ...\n        No  → Step 4: 輸出 '負數' // ...\n\nThus within No branch they had a Decision line with arrow etc. They didn't show a separate End. So we should keep the End outside branches.\n\nThus we should not close inside the branch; the algorithm ends after entire flow, not within the branch.\n\nThus we should not put End inside No branch. The End line should appear after all lines.\n\nThus we do:\n\nStart // 程式開始\n→ Step 1: i ← len(nums) - 2 // ...\n→ Decision: i ≥ 0 AND nums[i] < nums[i+1] ?\n    Yes → // 有 pivot，繼續\n    No  → Step 2: Reverse nums // 整個陣列反轉成升序\nStep 3: // pivot 已找到\n→ Step 4: j ← len(nums) - 1 // ...\n→ While nums[j] ≤ nums[i] Do j ← j - 1 // 迴圈尋找更大值\n→ Step 5: Swap nums[i], nums[j] // ...\n→ Step 6: Reverse nums[i+1:] // ...\nEnd // 程式結束\n\nBut this flows incorrectly: If No branch triggers, we still execute Step 3 onward because no conditional skip. But we need to stop after reverse. In pseudocode, we might need an early exit after reverse. But we can just put \"End\" after reverse within the No branch. But they don't want arrow. But maybe we can use indentation to indicate we are inside No branch. But we still need End. Let's structure like:\n\nStart // 程式開始\n→ Step 1: i ← len(nums) - 2 // ...\n→ Decision: i ≥ 0 AND nums[i] < nums[i+1] ?\n    Yes → // 有 pivot，繼續\n    No  → Step 2: Reverse nums // ...\n        → End // 程式結束\nStep 3: // pivot 已找到\n...\n\nBut \"→ End\" has arrow. But sample didn't use arrow before End. But sample used \"End // 程式執行結束\" not preceded by arrow. So we should not use arrow.\n\nMaybe we can do:\n\nStart // 程式開始\n→ Step 1: i ← len(nums) - 2 // ...\n→ Decision: i ≥ 0 AND nums[i] < nums[i+1] ?\n    Yes → // 有 pivot，繼續\n    No  → Step 2: Reverse nums // ...\n        End // 程式結束\nStep 3: // pivot 已找到\n...\n\nBut that would place End inside No branch but no arrow. That might be acceptable.\n\nLet's adopt that.\n\nThus final answer:\n\nStart // 程式開始\n→ Step 1: i ← len(nums) - 2 // 從倒數第二個元素開始向左尋找 pivot\n→ Decision: i ≥ 0 AND nums[i] < nums[i+1] ? // 判斷是否存在升序斜率\n    Yes → // 有 pivot，繼續\n    No  → Step 2: Reverse nums // 整個陣列反轉成升序\n        End // 程式結束\nStep 3: // pivot 已找到\n→ Step 4: j ← len(nums) - 1 // 從最後一個元素開始\n→ While nums[j] ≤ nums[i] Do j ← j - 1 // 迴圈尋找更大值\n→ Step 5: Swap nums[i], nums[j] // 交換 pivot 與 successor\n→ Step 6: Reverse nums[i+1:] // 反轉後半段，得到下一個排列\nEnd // 程式結束\n\nHowever, we have End inside No branch and another End outside; that is duplicate. We should remove outer End. The outer End after all steps will be present only if No branch didn't trigger. But if No branch triggered, we had End inside, so we don't need outer End.\n\nThus we should keep one End. We'll structure with indentation.\n\nLet's present with proper indentation to show nested. Use 4 spaces indent for branches.\n\nThus:\n\nStart // 程式開始\n→ Step 1: i ← len(nums) - 2 // 從倒數第二個元素開始向左尋找 pivot\n→ Decision: i ≥ 0 AND nums[i] < nums[i+1] ? // 判斷是否存在升序斜率\n    Yes → // 有 pivot，繼續\n    No  → Step 2: Reverse nums // 整個陣列反轉成升序\n        End // 程式結束\nStep 3: // pivot 已找到\n→ Step 4: j ← len(nums) - 1 // 從最後一個元素開始\n→ While nums[j] ≤ nums[i] Do j ← j - 1 // 迴圈尋找更大值\n→ Step 5: Swap nums[i], nums[j] // 交換 pivot 與 successor\n→ Step 6: Reverse nums[i+1:] // 反轉後半段，得到下一個排列\nEnd // 程式結束\n\nNow we need to check that each line includes arrow except Start and End. The Step 3 line has no arrow. Should we add arrow? In sample, after a Decision branch, they had nested steps preceded by arrow too. For Step 3 after No branch, we are outside branch but inside main flow. Should have arrow? They had \"Step 3:\" preceded by arrow? In sample, after Decision branches, they had Step 3 preceded by arrow? Let's review sample:\n\nStart\n→ Step 1\n→ Decision\n    Yes → Step 2\n    No → Decision\n        Yes → Step 3\n        No  → Step 4\nEnd\n\nAfter the Decision branch, Step 3 had arrow because it's inside Yes branch. But in our flow, Step 3 is part of main flow after the Decision. But if No branch triggers, we exit earlier. So Step 3 should have arrow.\n\nThus Step 3 should be \"→ Step 3:\".\n\nAlso Step 4, 5, 6 lines should have arrows. The While line should have arrow.\n\nSo modify:\n\nStart // 程式開始\n→ Step 1: i ← len(nums) - 2 // ...\n→ Decision: i ≥ 0 AND nums[i] < nums[i+1] ?\n    Yes → // 有 pivot，繼續\n    No  → Step 2: Reverse nums // ...\n        End // 程式結束\n→ Step 3: // pivot 已找到\n→ Step 4: j ← len(nums) - 1 // ...\n→ While nums[j] ≤ nums[i] Do j ← j - 1 // ...\n→ Step 5: Swap nums[i], nums[j] // ...\n→ Step 6: Reverse nums[i+1:] // ...\nEnd // 程式結束\n\nNow we have two End lines: one inside No branch and one after all. But if No branch triggers, the outer End will be unreachable; but it's okay. But might be confusing.\n\nBetter to remove outer End and rely on inner End only. But we need an End for the main flow when Yes path. So we can restructure to have outer End, but inside No branch we can use \"→ End\" to break. But we need arrow for that End? They didn't use arrow in sample for End. But we could use \"End\" inside branch without arrow. Let's do:\n\nStart // 程式開始\n→ Step 1: i ← len(nums) - 2 // 從倒數第二個元素開始向左尋找 pivot\n→ Decision: i ≥ 0 AND nums[i] < nums[i+1] ?\n    Yes → // 有 pivot，繼續\n    No  → Step 2: Reverse nums // 整個陣列反轉成升序\n        End // 程式結束\n→ Step 3: // pivot 已找到\n→ Step 4: j ← len(nums) - 1 // 從最後一個元素開始\n→ While nums[j] ≤ nums[i] Do j ← j - 1 // 迴圈尋找更大值\n→ Step 5: Swap nums[i], nums[j] // 交換 pivot 與 successor\n→ Step 6: Reverse nums[i+1:] // 反轉後半段，得到下一個排列\nEnd // 程式結束\n\nNow we have two End lines: one inside No branch, one outside. That's acceptable: one for early exit, one for normal exit. It might appear redundant but okay.\n\nAlternatively, we can restructure to have early exit by using \"→ End\" after reverse inside No branch, but not have outer End.\n\nLet's restructure to have single End after all steps, and inside No branch we jump to that End via \"→ End\" but with arrow? They used \"→ End\" maybe okay. But sample didn't show arrow before End.\n\nBut we can use \"→ End\" for clarity. Let's do:\n\nStart // 程式開始\n→ Step 1: i ← len(nums) - 2 // 從倒數第二個元素開始向左尋找 pivot\n→ Decision: i ≥ 0 AND nums[i] < nums[i+1] ?\n    Yes → // 有 pivot，繼續\n    No  → Step 2: Reverse nums // 整個陣列反轉成升序\n        → End // 程式結束\n→ Step 3: // pivot 已找到\n→ Step 4: j ← len(nums) - 1 // 從最後一個元素開始\n→ While nums[j] ≤ nums[i] Do j ← j - 1 // 迴圈尋找更大值\n→ Step 5: Swap nums[i], nums[j] // 交換 pivot 與 successor\n→ Step 6: Reverse nums[i+1:] // 反轉後半段，得到下一個排列\nEnd // 程式結束\n\nNow we have two End lines: one inside No branch (with arrow), one after all steps. That is fine.\n\nBut the \"→ End\" inside No branch may be confusing because it's nested; but it's fine.\n\nHowever, we must check formatting: Each line must contain arrow before step except Start and End. For \"→ End\" we have arrow. That's acceptable.\n\nNow let's produce final answer with these lines.\n\nLet's ensure each line has the format: \"虛擬碼步驟 [空格] // 解釋/說明\". Our lines have arrow then step then comment.\n\nBut we need to ensure no missing spaces. Use single space after step.\n\nWe'll produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: i ← len(nums) - 2 // 從倒數第二個元素開始向左尋找 pivot  \n→ Decision: i ≥ 0 AND nums[i] < nums[i+1] ? // 判斷是否存在升序斜率  \n    Yes → // 有 pivot，繼續  \n    No  → Step 2: Reverse nums // 整個陣列反轉成升序  \n        → End // 程式結束  \n→ Step 3: // pivot 已找到  \n→ Step 4: j ← len(nums) - 1 // 從最後一個元素開始  \n→ While nums[j] ≤ nums[i] Do j ← j - 1 // 迴圈尋找更大值  \n→ Step 5: Swap nums[i], nums[j] // 交換 pivot 與 successor  \n→ Step 6: Reverse nums[i+1:] // 反轉後半段，得到下一個排列  \nEnd // 程式結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"\n        Rearranges nums into a wiggle sequence: nums[0] < nums[1] > nums[2] < nums[3] ...\n        The algorithm iterates through adjacent pairs and swaps them if they violate the\n        required inequality based on the index parity.\n        \"\"\"\n        n = len(nums)\n        for i in range(n - 1):\n            if i % 2 == 0:\n                # even index: should be smaller than next element\n                if nums[i] > nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n            else:\n                # odd index: should be greater than next element\n                if nums[i] < nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the list representation between the first '[' and the last ']'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        print(\"[]\")\n        sys.exit(0)\n\n    list_str = data[start:end + 1]\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        print(\"[]\")\n        sys.exit(0)\n\n    # Ensure we have a list of integers\n    if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums):\n        print(\"[]\")\n        sys.exit(0)\n\n    # Apply wiggle sort\n    Solution().wiggleSort(nums)\n\n    # Output the result as a Python list string\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the given problem: reorder array to wiggle: nums[0] < nums[1] > nums[2] < nums[3] etc. Approach: iterate, compare pairs, swap if not meeting condition: for odd index expect > next, for even index expect < next. But the condition depends on index parity. Actually typical solution: for i from 0 to n-2, if (i%2==0 && nums[i] > nums[i+1]) swap; else if (i%2==1 && nums[i] < nums[i+1]) swap. That's typical.\n\nWe need to produce virtual code lines following format. Each line: virtual code step + space + // explanation. Use Start, End, Decision, etc. Use arrow \"→\". Use \"Yes →\" and \"No →\" etc. They want line by line.\n\nLet's produce steps:\n\nStart\n→ Step 1: Let n = length(nums) // Get array length\n→ Step 2: For i from 0 to n-2 // Iterate through pairs\n    → Decision: If i is even? // Determine parity\n        Yes → Decision: If nums[i] > nums[i+1]? // For even index, need < next\n            Yes → Step 3: Swap nums[i] and nums[i+1] // Swap to satisfy < condition\n            No  → // do nothing\n        No  → Decision: If nums[i] < nums[i+1]? // For odd index, need > next\n            Yes → Step 4: Swap nums[i] and nums[i+1] // Swap to satisfy > condition\n            No  → // do nothing\nEnd\n\nWe need to include explanation after each line. Also the decision lines should have explanation. Let's ensure each line has `虛擬碼步驟` + space + `// 解釋/說明`.\n\nMake sure to include \"Start // 程式開始執行\" etc. Provide step numbering? Not necessary but okay.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Let n = length(nums) // 取得陣列長度\n→ Step 2: For i = 0 to n-2 // 逐一檢查相鄰元素\n    → Decision: i % 2 == 0? // 判斷索引為偶數\n        Yes → Decision: nums[i] > nums[i+1]? // 偶數位需小於下一個，若大則需交換\n            Yes → Step 3: Swap nums[i] and nums[i+1] // 交換兩個元素\n            No  → // 不需要交換，條件已滿足\n        No  → Decision: nums[i] < nums[i+1]? // 奇數位需大於下一個，若小則需交換\n            Yes → Step 4: Swap nums[i] and nums[i+1] // 交換兩個元素\n            No  → // 不需要交換，條件已滿足\nEnd // 程式執行結束\n\nMake sure formatting: each line indent properly. They may expect indentation for decision branches. We can just use spaces. Provide consistent arrow lines.\n\nAlso include \"Step 1:\" etc. Provide explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n = length(nums) // 取得陣列長度  \n→ Step 2: For i = 0 to n-2 // 逐一檢查相鄰元素  \n    → Decision: i % 2 == 0? // 判斷索引為偶數  \n        Yes → Decision: nums[i] > nums[i+1]? // 偶數位需小於下一個，若大則需交換  \n            Yes → Step 3: Swap nums[i] and nums[i+1] // 交換兩個元素  \n            No  → // 不需要交換，條件已滿足  \n        No  → Decision: nums[i] < nums[i+1]? // 奇數位需大於下一個，若小則需交換  \n            Yes → Step 4: Swap nums[i] and nums[i+1] // 交換兩個元素  \n            No  → // 不需要交換，條件已滿足  \nEnd // 程式執行結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpduspcvou.py\", line 49, in <module>\n    prerequisites = ast.literal_eval(part.split('=')[1].strip())\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpev9_bsru.py\", line 49, in <module>\n    prerequisites = ast.literal_eval(part.split('=')[1].strip())\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: list[list[int]]) -> list[int]:\n        # 建立鄰接清單與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 解析前置關係\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 以入度為 0 的課程作為起點\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # Kahn 演算法：逐層移除入度為 0 的節點\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若所有課程都已排好，回傳順序；否則回傳空清單\n        return order if len(order) == numCourses else []\n\nif __name__ == \"__main__\":\n    # 讀取輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        print([])\n        sys.exit()\n\n    # 解析格式：'numCourses = X, prerequisites = [[a,b],...]'\n    parts = [p.strip() for p in data.split(',')]\n    numCourses = 0\n    prerequisites = []\n\n    for part in parts:\n        if part.startswith('numCourses'):\n            numCourses = int(part.split('=')[1].strip())\n        elif part.startswith('prerequisites'):\n            # 使用 ast.literal_eval 以安全方式解析列表\n            prerequisites = ast.literal_eval(part.split('=')[1].strip())\n\n    # 呼叫解法並輸出結果\n    sol = Solution()\n    result = sol.findOrder(numCourses, prerequisites)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Problem is Topological Sort. Use Kahn's algorithm. Steps: Build graph adjacency list, indegree array. Initialize queue with zero indegree nodes. While queue not empty: pop node, add to result, reduce indegree of neighbors; if indegree becomes zero push. After loop, if result length equals numCourses return result else empty.\n\nLet's produce virtual code lines: Start, Step: Build graph, Step: Initialize indegree, Step: Queue fill, Decision: queue not empty? Yes→process, else→End.\n\nNeed to use arrows etc.\n\nLet's produce lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空白的鄰接清單 graph[0 … numCourses-1] // 為每門課程建立一個空的相鄰列表  \n→ Step 2: 建立 indegree 陣列 indegree[0 … numCourses-1] 初始化為 0 // 記錄每門課程的前置課程數量  \n→ Decision: 是否有 prerequisites? // 檢查是否有前置關係  \n    Yes → Step 3: 針對每個 pair [a, b]  \n        → 於 graph[b] 加入 a // b 為前置課程，a 為後續課程  \n        → indegree[a] 加 1 // a 的前置課程數量增加  \n    No  → Skip // 無前置關係，直接跳過  \n→ Step 4: 建立佇列 queue，並將所有 indegree 為 0 的課程入佇列 // 可立即修習的課程  \n→ Step 5: 初始化結果陣列 order = [] // 存放最終修習順序  \n→ Decision: queue 是否非空? // 判斷是否還有可修習的課程  \n    Yes → Step 6: 從 queue 取出一門課程 curr  \n        → order 加 curr // 將 curr 加入修習順序  \n        → Decision: graph[curr] 是否有鄰居? // 這門課程是否是其他課程的前置課程  \n            Yes → Step 7: 對於每個 neighbour in graph[curr]  \n                → indegree[neighbour] 減 1 // 前置課程已完成，前置數量減一  \n                → Decision: indegree[neighbour] 是否為 0?  \n                    Yes → queue 加 neighbour // 現在無前置課程，可加入佇列  \n                    No  → Skip  \n            No  → Skip  \n        → 回到 Decision: queue 是否非空? // 繼續處理剩餘課程  \n            Yes → 回到 Step 6  \n            No  → Jump to Step 8  \n    No  → Jump to Step 8 // 佇列已空，開始結束檢查  \n→ Step 8: Decision: order 長度是否等於 numCourses? // 檢查是否所有課程都已安排  \n    Yes → Return order // 有效的修習順序  \n    No  → Return [] // 無法完成所有課程，返回空陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Integer to English Words",
      "source_file": "Leetcode/leetcode273.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "num = 12345",
          "expected_output": "\"Twelve Thousand Three Hundred Forty Five\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'TwelveThousandThreeHundredFortyFive'\nGot (Norm):      'OneMillionTwelveThousandThreeHundredFortyFive'\n--- (Raw) ---\nRaw Expected: '\"Twelve Thousand Three Hundred Forty Five\"'\nRaw Got:      'One Million Twelve Thousand Three Hundred Forty Five'"
        },
        {
          "example_index": 2,
          "input": "num = 1234567",
          "expected_output": "\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'OneMillionTwoHundredThirtyFourThousandFiveHundredSixtySeven'\nGot (Norm):      'OneHundredTwentyThreeMillionTwoHundredThirtyFourThousandFiveHundredSixtySeven'\n--- (Raw) ---\nRaw Expected: '\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"'\nRaw Got:      'One Hundred Twenty Three Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        def one(n: int) -> str:\n            switcher = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\",\n                        \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n            return switcher[n]\n\n        def two_less_20(n: int) -> str:\n            switcher = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\",\n                        \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n            return switcher[n - 10]\n\n        def ten(n: int) -> str:\n            switcher = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\",\n                        \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n            return switcher[n]\n\n        def two(n: int) -> str:\n            if n == 0:\n                return \"\"\n            if n < 10:\n                return one(n)\n            if n < 20:\n                return two_less_20(n)\n            tens = n // 10\n            rest = n % 10\n            return ten(tens) + (\" \" + one(rest) if rest else \"\")\n\n        def three(n: int) -> str:\n            hundred = n // 100\n            rest = n % 100\n            if hundred and rest:\n                return one(hundred) + \" Hundred \" + two(rest)\n            if hundred:\n                return one(hundred) + \" Hundred\"\n            return two(rest)\n\n        billion = num // 1_000_000_000\n        million = (num % 1_000_000_000) // 1_000_0\n        thousand = (num % 1_000_000) // 1_000\n        rest = num % 1_000\n\n        parts = []\n        if billion:\n            parts.append(three(billion) + \" Billion\")\n        if million:\n            parts.append(three(million) + \" Million\")\n        if thousand:\n            parts.append(three(thousand) + \" Thousand\")\n        if rest:\n            parts.append(three(rest))\n        return \" \".join(parts)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r'(-?\\d+)', data)\n    if match:\n        num = int(match.group(1))\n        result = Solution().numberToWords(num)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to convert non-negative integer to English words. Provide each line with \"虛擬碼步驟 // 解釋\". Use arrow syntax. Steps: Start, check if num=0 then return \"Zero\". Define arrays for ones, teens, tens, thousands. Then while num>0 process groups of 3 digits. For each group, convert to words: hundreds digit, tens and ones. Append to result with scale. Use loops. Need to produce pseudo-code, not real code. Should be line by line. Use decision blocks. Let's craft.\n\nWe need to consider the typical algorithm: if num==0: return \"Zero\". Else, define words list. Define scale array [\"\", \"Thousand\", \"Million\", \"Billion\"] maybe. While num>0: group=num%1000. if group>0: words=helper(group)+scale[i]. Prepend. num/=1000. After loop, return words trimmed.\n\nHelper for number <1000: if n>=100: words += ones[n/100]+\" Hundred\". n%=100. if n>=20: words+=tens[n/10]; n%=10. if n>0: words+=ones[n]. handle teens 10-19.\n\nBut we should express virtual code step by step with decision arrows.\n\nLet's produce. Use indentation.\n\nRemember to include // explanation each line.\n\nLet's craft:\n\nStart // Start\n→ Decision: if num == 0? // Check zero case\n    Yes → Step: Return \"Zero\" // Output Zero\n    No  → Step: Initialize words list as empty // Prepare storage\n    → Step: Define arrays: ones, teens, tens, scales // Digit words and scale words\n    → Step: index = 0 // Scale index\n    → Step: tempNum = num // Working copy\n    → Decision: while tempNum > 0? // Process each thousand group\n        Yes → Step: group = tempNum % 1000 // Get last three digits\n        → Decision: if group > 0? // If this group contributes words\n            Yes → Step: groupWords = Helper(group) // Convert group to words\n            → Step: groupWords += \" \" + scales[index] // Add scale word\n            → Step: Prepend groupWords to words list // Build result\n            No  → // Do nothing for zero group\n        → Step: tempNum = tempNum / 1000 // Move to next group\n        → Step: index += 1 // Next scale\n        → Decision: tempNum > 0? // Loop again\n            Yes → // repeat\n            No  → End Loop\n    → Step: result = Join words with spaces // Final string\n    → Step: Return result // Output\nEnd // End\n\nNeed to include helper steps.\n\nAdd Helper subroutine.\n\n→ Step: Define Helper(n) // Convert number <1000 to words\n→ Decision: if n >= 100? // Hundreds\n    Yes → Step: words += ones[n/100] + \" Hundred\" // Hundreds part\n    No  → // skip\n→ Step: n = n % 100 // Remaining digits\n→ Decision: if n >= 20? // Tens 20-99\n    Yes → Step: words += tens[n/10] // Tens word\n    → Step: n = n % 10 // Ones\n    No  → Decision: if n >= 10? // Teens 10-19\n        Yes → Step: words += teens[n-10] // Teen word\n        No  → Decision: if n > 0? // 1-9\n            Yes → Step: words += ones[n] // Ones word\n            No  → // no word\n→ Step: Return words // Return group words\n\nLet's format each line with arrow and explanation. Use appropriate indentation.\n\nWe should avoid real code. Just pseudo-code.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 num 等於 0? // 檢查是否為零  \n  Yes → Step: 回傳 \"Zero\" // 若為零，直接輸出  \n  No  → Step: 初始化 words 為空串 // 用來存放結果文字  \n    → Step: 定義陣列 ones = [\"One\",\"Two\",...,\"Nine\"] // 1-9 的英文  \n    → Step: 定義陣列 teens = [\"Ten\",\"Eleven\",...,\"Nineteen\"] // 10-19 的英文  \n    → Step: 定義陣列 tens = [\"Twenty\",\"Thirty\",...,\"Ninety\"] // 20,30,... 的英文  \n    → Step: 定義陣列 scales = [\"\",\"Thousand\",\"Million\",\"Billion\"] // 千位、百萬、十億等  \n    → Step: index = 0 // 用於追蹤 scales 的索引  \n    → Step: tempNum = num // 用於迴圈處理的變數  \n    → Decision: tempNum > 0? // 是否還有位數需要處理  \n      Yes → Step: group = tempNum % 1000 // 取最後三位  \n       → Decision: group > 0? // 這一組是否需要寫字？  \n         Yes → Step: groupWords = Helper(group) // 把三位數轉成文字  \n          → Step: groupWords += \" \" + scales[index] // 加上對應的千級文字  \n          → Step: words = groupWords + \" \" + words // 前置新增，保持順序  \n         No  → // 若 group 為 0，直接跳過  \n       → Step: tempNum = tempNum / 1000 // 移除已處理的三位數  \n       → Step: index += 1 // 移動到下一個千級  \n       → Decision: tempNum > 0? // 是否還有數字未處理？  \n         Yes → // 重複上述步驟  \n        No  → // 所有位數已處理完畢  \n         → End Loop  \n    → Step: result = words.Trim() // 去除前後空白  \n    → Step: 回傳 result // 輸出最終字串  \nEnd // 程式執行結束  \n\n// ---------------- Helper 函式 ----------------  \n\nStep: 定義 Helper(n) // 轉換 0 < n < 1000 的數字為文字  \n  → Decision: n >= 100? // 是否有百位？  \n    Yes → Step: words = ones[n / 100] + \" Hundred\" // 加上百位字  \n    No  → // 跳過百位  \n    → Step: n = n % 100 // 取得剩餘兩位數  \n    → Decision: n >= 20? // 是否有 20-99 的十位？  \n      Yes → Step: words += \" \" + tens[n / 10] // 加上十位字  \n       → Step: n = n % 10 // 取剩餘個位  \n      No  → Decision: n >= 10? // 是否為 10-19 的特殊數字？  \n       Yes → Step: words += \" \" + teens[n - 10] // 加上十幾字  \n       No  → Decision: n > 0? // 是否有個位字？  \n        Yes → Step: words += \" \" + ones[n] // 加上個位字  \n        No  → // n 為 0，無需加字  \n    → Step: 回傳 words // 回傳三位數的文字表示  \nEnd // Helper 函式結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            emails = acc[1:]\n            if not emails:\n                continue\n            first_email = emails[0]\n            root = find(first_email)\n            for email in emails:\n                parent.setdefault(email, email)\n                parent[find(email)] = root\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        result = []\n        for root, emails in merged.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin 內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 移除可能的前置變數宣告，例如 \"accounts = \"\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n        data = rhs.strip()\n\n    # 解析為 Python 物件\n    try:\n        accounts = ast.literal_eval(data)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n    print(merged_accounts)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. The algorithm: Use DSU or graph. Steps: build mapping email->name, email->id; union emails; then group by root; sort emails; output. Provide line by line explanation. Need to output only virtual code, not actual code. Use arrows. Let's craft.\n\nLet's start with Start. Then Step: Initialize maps. Then iterate accounts to map email->name and build union graph. Then union. Then group by root. Then sort. Then output. Use decisions maybe not needed but can illustrate.\n\nWe'll produce steps like:\n\nStart\n→ Step 1: 建立空的資料結構 mapEmailToName, mapEmailToId, adjacency list, counter // 用於儲存電子郵件到名字與 id，和鄰接關係\n→ Step 2: 迭代每個帳號\n    → Substep: 取出姓名 name = accounts[i][0] // 取得帳號名稱\n    → Substep: 迭代從 accounts[i][1] 開始的每個 email\n        → Substep: 如果 email 尚未出現在 mapEmailToId，則給予新 id 並加入 adjacency list // 為新電子郵件分配 id\n        → Substep: 將 email 的名字 mapEmailToName[email] 設為 name // 儲存名字\n        → Substep: 若不是第一個 email，則在兩個相鄰 email 的 id 之間建立無向邊 // 連接同一帳號內的電子郵件\n→ Decision: 若存在多於一個帳號？ // 只需一次\n        ...\nBut maybe not necessary.\n\nWe need to union? Actually adjacency graph and DFS/Union-Find. Use union-find. Let's choose union-find.\n\nWe can describe DSU operations.\n\nSteps: define find, union functions. We'll mention.\n\nOk produce virtual code.\n\nLet's produce around 20 lines.\n\nEnsure each line ends with // explanation.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化資料結構 mapEmailToName, mapEmailToId, parent, rank, idCounter = 0 // 用於儲存電子郵件到名字、id、DSU 父節點、秩及 id 計數  \n→ Step 2: 定義函式 Find(x) → 跟蹤並壓縮路徑至根節點 // DSU 查找  \n→ Step 3: 定義函式 Union(x, y) → 將兩個 id 合併，根據 rank 決定新父節點 // DSU 合併  \n→ Step 4: 迭代每筆帳號 accounts[i]  \n  → Substep: name ← accounts[i][0] // 取得此帳號的名稱  \n  → Substep: 取 accounts[i] 從索引 1 開始的所有 emailList // 其餘元素是電子郵件  \n  → Substep: 迭代 emailList  \n    → Decision: email 是否已存在於 mapEmailToId? // 檢查是否為新電子郵件  \n      Yes → id ← idCounter； parent[id] ← id； rank[id] ← 0； mapEmailToId[email] ← id； mapEmailToName[email] ← name； idCounter ← idCounter + 1 // 新建 id 並初始化 DSU  \n      No  → id ← mapEmailToId[email] // 取得已存在 id  \n      No  → name ← mapEmailToName[email] // 取得該電子郵件的名字  \n      No  → // 若該名不一致，保持最初儲存的名字，因同一帳號必定相同  \n    → Substep: 若 emailList 有前一個 email prevEmail  \n      prevId ← mapEmailToId[prevEmail]  \n      Union(prevId, id) // 將同一帳號內的電子郵件合併  \n  → End Substep  \n→ End Step 4  \n→ Step 5: 建立空字典 groups // 用於存放根節點對應的所有電子郵件  \n  → Substep: 迭代 mapEmailToId 中所有 email, id  \n    → root ← Find(id) // 找到該 id 的根節點  \n    → groups[root] ← groups.get(root, []) ∪ {email} // 將電子郵件加入對應群組  \n→ End Step 5  \n→ Step 6: 準備結果 result = []  \n  → Substep: 迭代 groups 中的每個 root, emailSet  \n    → name ← mapEmailToName[next(iter(emailSet))] // 任取該群組中的一個 email 取得姓名  \n    → sortedEmails ← Sort(emailSet) // 將電子郵件排序  \n    → account ← [name] + sortedEmails // 組合名稱與排序後的電子郵件  \n    → result.append(account) // 加入結果  \n→ End Step 6  \nEnd // 程式執行結束，返回 result"
    },
    {
      "title": "Super Washing Machines",
      "source_file": "Leetcode/leetcode517.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[0,3,0]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMinMoves(self, machines):\n        total = sum(machines)\n        n = len(machines)\n        if total % n != 0:\n            return -1\n        target = total // n\n        prefix = 0\n        max_abs = 0\n        max_pos = 0\n        for i, load in enumerate(machines):\n            prefix += load\n            need = prefix - target * (i + 1)\n            if abs(need) > max_abs:\n                max_abs = abs(need)\n            if need > max_pos:\n                max_pos = need\n        return max(max_abs, max_pos)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 支援輸入為列表字面量，例如 '[1,0,5]'\n    try:\n        machines = ast.literal_eval(data)\n    except Exception:\n        # 若輸入不是合法列表，直接返回\n        print(-1)\n        return\n    if not isinstance(machines, list):\n        print(-1)\n        return\n    result = Solution().findMinMoves(machines)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm solving \"Super Washing Machines\" problem. It's similar to LeetCode 488. Approach: Compute total dresses, if not divisible by n return -1. Then iterate over machines, maintain prefix sum. For each i, compute need = prefix - target*(i+1). Keep track of max of abs(need) and need. Result is max of those two. Provide pseudocode step by step.\n\nNeed output format: each line \"虛擬碼步驟 // 解釋\". Use arrow markers. Use \"Start\" \"End\". Use Decision etc.\n\nWe must not output real code. Just virtual steps.\n\nLet's produce:\n\nStart // start\n\n→ Step 1: Compute n = length of machines // number of machines\n\n→ Step 2: Compute total = sum of machines // total dresses\n\n→ Decision: If total % n != 0? // check if equal distribution possible\n\n    Yes → Step 3: Output -1 and End // impossible\n\n    No  → Step 4: target = total / n // desired dresses per machine\n\n→ Step 5: Initialize prefix = 0 // cumulative dresses processed\n\n→ Step 6: Initialize maxAbs = 0 // maximum absolute net surplus\n\n→ Step 7: Initialize maxNet = 0 // maximum net surplus (positive)\n\n→ Step 8: For each index i from 0 to n-1: // iterate machines\n\n    → Step 9: prefix += machines[i] // update cumulative\n\n    → Step 10: need = prefix - target*(i+1) // net dresses that must move out/in up to i\n\n    → Decision: If |need| > maxAbs? // track largest absolute net\n\n        Yes → Step 11: maxAbs = |need| // update\n\n        No  → (none)\n\n    → Decision: If need > maxNet? // track largest positive net\n\n        Yes → Step 12: maxNet = need // update\n\n        No  → (none)\n\n→ Step 13: result = max(maxAbs, maxNet) // minimal moves\n\n→ Step 14: Output result // return answer\n\nEnd // finish\n\nNeed to use \"Yes →\", \"No →\" with indentation.\n\nMake sure each line ends with // explanation.\n\nAlso ensure \"虛擬碼步驟\" includes arrow maybe. Use \"→\" for steps.\n\nLet's write final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(machines) // 取得洗衣機的總數  \n→ Step 2: total ← sum(machines) // 計算所有衣服的總數  \n\n→ Decision: total mod n ≠ 0? // 檢查是否能平均分配  \n    Yes → Step 3: Output -1 // 無法達成等量分配，結束程式  \n    No  → Step 4: target ← total ÷ n // 每台洗衣機應有的衣服數  \n\n→ Step 5: prefix ← 0 // 目前已處理的衣服總數  \n→ Step 6: maxAbs ← 0 // 最高絕對淨移動量  \n→ Step 7: maxNet ← 0 // 最高正向淨移動量  \n\n→ Step 8: For i from 0 to n-1: // 逐一遍歷洗衣機  \n    → Step 9: prefix ← prefix + machines[i] // 更新前綴和  \n    → Step 10: need ← prefix - target*(i+1) // 第 i+1 台前的淨移動需求  \n    → Decision: |need| > maxAbs? // 是否更新最大絕對值  \n        Yes → Step 11: maxAbs ← |need| // 更新最大絕對淨移動量  \n        No  → (none)  \n    → Decision: need > maxNet? // 是否更新最大正向值  \n        Yes → Step 12: maxNet ← need // 更新最大正向淨移動量  \n        No  → (none)  \n\n→ Step 13: result ← max(maxAbs, maxNet) // 取得最小移動步數  \n→ Step 14: Output result // 回傳答案  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,6,1,4,6,6,4,1]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 6, 1, 4, 6, 6, 4, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        index = random.randint(0, self.size - 1)\n        return self.mapping.get(index, index)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = json.loads(data[0])\n    arguments = json.loads(data[1])\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        elif cmd == \"pick\":\n            results.append(obj.pick())\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, for the algorithm. The problem: given n and blacklist, need to pick uniformly random among numbers not in blacklist. Standard solution: map blacklisted numbers in [0, m-1] to allowed numbers in [m, n-1] where m = n - blacklist.length. Preprocessing: create mapping of blacklisted numbers in lower range to allowed numbers in upper range. Then pick a random integer from 0 to m-1. If it's in mapping, return mapped value; else return itself.\n\nWe must provide virtual code lines with explanations.\n\nWe must follow output format: each line: virtual code step + space + // explanation. Use arrows: Start, Decision, Yes→, No→, End.\n\nWe need to produce virtual code for:\n\n- Start\n- Step: Initialize Solution(n, blacklist)\n- Process: compute m = n - blacklist.length\n- Build set of blacklist in [m, n-1] maybe to skip\n- Build mapping dictionary for blacklisted numbers in [0, m-1] to smallest non-blacklisted numbers in [m, n-1].\n- pick() function: generate random int k in [0, m-1]\n- If k in mapping: return mapping[k]\n- else: return k\n- End\n\nNeed to incorporate random function call count minimized.\n\nWe'll describe algorithm in pseudo. Each line: we can include indentation? Not needed, but use arrows.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 計算 m = n - blacklist.size() // 可用數量\n→ Step 2: 建立 set B_high 包含 blacklist 中 ≥ m 的數 // 上區黑名單\n→ Step 3: 建立映射 map 以儲存將 [0, m-1] 中黑名單映射至合法數字 // 映射表\n→ Step 4: 初始化 next = m // 下一個可用數字指標\n→ Decision: 對每個 b 在 blacklist\n    → Decision: 如果 b < m? // b 在低區\n        Yes → While next in B_high: next++ // 找下個不在黑名單的數\n        Yes → map[b] = next // 將 b 映射至 next\n        Yes → next++ // 移動指標\n        No → // b >= m，已在 B_high 中，忽略\n→ End // 建構完成\n\nThen pick method:\n\nStart pick() // 進入 pick 方法\n→ Step 5: k = randomInt(0, m-1) // 取得隨機數\n→ Decision: 如果 k 在 map? // k 為低區黑名單\n    Yes → Return map[k] // 返回映射值\n    No  → Return k // k 本身合法\nEnd // pick 方法結束\n\nBut we need to show the virtual code lines in the specified format: arrow, step names. Use \"Start\", \"Decision:\", \"Yes →\", \"No →\", \"End\".\n\nLet's produce final output accordingly. Use each line as separate.\n\nWe must not output actual code, only virtual code. Let's provide.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 m = n - blacklist.size() // 可用數量  \n→ Step 2: 建立 set B_high 包含 blacklist 中 ≥ m 的數 // 上區黑名單  \n→ Step 3: 建立映射 map 以儲存將 [0, m-1] 中黑名單映射至合法數字 // 映射表  \n→ Step 4: 初始化 next = m // 下一個可用數字指標  \n→ Decision: 對每個 b 在 blacklist  \n  Decision: 如果 b < m? // b 在低區  \n   Yes → While next in B_high: next++ // 找下個不在黑名單的數  \n   Yes → map[b] = next // 將 b 映射至 next  \n   Yes → next++ // 移動指標  \n   No → // b ≥ m，已在 B_high 中，忽略  \n→ End // 建構完成  \n\nStart pick() // 進入 pick 方法  \n→ Step 5: k = randomInt(0, m-1) // 取得隨機數  \n→ Decision: 如果 k 在 map? // k 為低區黑名單  \n  Yes → Return map[k] // 返回映射值  \n  No  → Return k // k 本身合法  \nEnd // pick 方法結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,3,null,5]'\nGot (Norm):      '[null,null,0,null,0]'\n--- (Raw) ---\nRaw Expected: '[null, null, 3, null, 5]'\nRaw Got:      '[null, null, 0, null, 0]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\nclass TrieNode:\n    def __init__(self):\n        self.sum = 0\n        self.children = defaultdict(TrieNode)\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.key_map = {}          # 存放 key -> 原始值\n\n    def insert(self, key: str, val: int) -> None:\n        old_val = self.key_map.get(key, 0)\n        delta = val - old_val\n        self.key_map[key] = val\n        node = self.root\n        node.sum += delta          # 更新根節點\n        for ch in key:\n            node = node.children[ch]\n            node.sum += delta\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef main():\n    data = sys.stdin.read().strip().replace('\\n', '')\n    if not data:\n        return\n    # 以 '],' 為分隔，切割成兩個列表字串\n    split_idx = data.find('],')\n    if split_idx == -1:\n        # 若資料已經分兩行，直接切割\n        parts = data.split(',', 1)\n        ops_str, args_str = parts[0], parts[1]\n    else:\n        ops_str = data[:split_idx + 1]\n        args_str = data[split_idx + 2:]\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MapSum\":\n            obj = MapSum()\n            result.append(None)\n        elif op == \"insert\":\n            obj.insert(arg[0], arg[1])\n            result.append(None)\n        elif op == \"sum\":\n            result.append(obj.sum(arg))\n        else:\n            # 未知操作，直接忽略\n            result.append(None)\n\n    # 使用 json.dumps 將 None 轉為 null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines step by step with explanation. The code is for MapSum class. We need to design data structure: use Trie with sum at nodes. Also maintain map of key to old value for override. Steps: init: create root node, map. insert: check old value, compute delta, store new value, update map, then walk trie and add delta to sum at each node. sum: traverse trie following prefix, return node.sum or 0.\n\nWe'll produce virtual code lines with \"Start\", \"→\", \"Decision:\" etc. Provide explanation after each line.\n\nLet's outline:\n\nStart // begin\n→ Step 1: 定義類別 MapSum // 類別宣告\n→ Step 2: 初始化 root TrieNode 和 keyMap // 建構子\n→ Step 3: insert(key, val) 方法\n    → Step 3.1: 若 key 存在於 keyMap，取得 oldVal，否則 0\n    → Step 3.2: 計算 delta = val - oldVal\n    → Step 3.3: 更新 keyMap[key] = val\n    → Step 3.4: 設定 node = root\n    → Step 3.5: 對每個字符 c in key:\n        → Step 3.5.1: 若 node.children[c] 不存在，建立新 TrieNode\n        → Step 3.5.2: node = node.children[c]\n        → Step 3.5.3: node.sum += delta\n→ Step 4: sum(prefix) 方法\n    → Step 4.1: 設定 node = root\n    → Step 4.2: 對每個字符 c in prefix:\n        → Step 4.2.1: 若 node.children[c] 不存在，回傳 0\n        → Step 4.2.2: node = node.children[c]\n    → Step 4.3: 回傳 node.sum\nEnd\n\nAlso define TrieNode with sum and children map.\n\nWe need to output virtual code lines, each line with explanation.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 MapSum // 宣告 MapSum 類別\n→ Step 2: 初始化 root TrieNode 與 keyMap // 建構子中產生根節點及鍵值對儲存表\n    → Step 2.1: root ← new TrieNode() // 根節點用於儲存所有鍵的前綴\n    → Step 2.2: keyMap ← empty map // 用於追蹤每個鍵目前對應的值\n→ Step 3: insert(key, val) 方法 // 插入或覆蓋鍵值對\n    → Step 3.1: 若 keyMap 包含 key 則 oldVal ← keyMap[key]，否則 oldVal ← 0 // 取得舊值以計算變更量\n    → Step 3.2: delta ← val - oldVal // 新舊差值，用於更新 Trie 節點的 sum\n    → Step 3.3: keyMap[key] ← val // 更新鍵值對表\n    → Step 3.4: node ← root // 從根節點開始遍歷鍵字\n    → Step 3.5: 對 key 的每個字符 c 執行以下步驟\n        → Step 3.5.1: 若 node.children[c] 為空，則 node.children[c] ← new TrieNode() // 建立缺失的子節點\n        → Step 3.5.2: node ← node.children[c] // 移動到下一個子節點\n        → Step 3.5.3: node.sum ← node.sum + delta // 更新前綴節點的累計值\n→ Step 4: sum(prefix) 方法 // 回傳所有以 prefix 為前綴的鍵值總和\n    → Step 4.1: node ← root // 從根節點開始搜尋\n    → Step 4.2: 對 prefix 的每個字符 c 執行以下步驟\n        → Step 4.2.1: 若 node.children[c] 為空，則 return 0 // 沒有符合前綴的鍵\n        → Step 4.2.2: node ← node.children[c] // 移動到下一個子節點\n    → Step 4.3: return node.sum // 回傳最後節點的累計值\n→ Step 5: 定義 TrieNode 結構 // 辅助結構存放 sum 與子節點映射\n    → Step 5.1: sum ← 0 // 目前節點前綴的總和\n    → Step 5.2: children ← empty map // 子節點字典\nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.2532918550454775,0.20961775652614775],[-0.19845677290559244,-0.8893597230668597],[0.5332648055748068,0.16107887233013699]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.2532918550454775, 0.20961775652614775], [-0.19845677290559244, -0.8893597230668597], [0.5332648055748068, 0.16107887233013699]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 產生均勻分布的隨機點\n        r = self.radius * math.sqrt(random.random())  # sqrt 保證均勻分布\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data or len(data) < 2:\n        return\n    # 解析輸入\n    commands = json.loads(data[0])\n    arguments = json.loads(data[1])\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)  # constructor不返回值，輸出為 null\n        else:\n            # 這裡假設只有 randPoint 需要調用\n            method = getattr(obj, cmd)\n            res = method(*args)\n            results.append(res)\n\n    # 輸出結果，使用 json.dumps 以獲得 null 等符合範例的格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem. The function randPoint should generate uniform random point inside circle. Approach: polar coordinates: generate random angle theta uniform [0,2π], and radius sqrt(r)*uniform? Actually to uniform distribution inside circle: radial distance d = radius * sqrt(U) where U uniform [0,1]. Then x = d*cos(theta)+x_center, y = d*sin(theta)+y_center. So steps: initialize radius, center. randPoint: generate random u1, u2. Compute theta = 2π*u1, r0 = radius * sqrt(u2). Compute x, y. Return [x,y].\n\nWe need to output virtual code lines with explanations. Use Start, Decision, etc. It's just algorithm, no decisions. Might show random number generation steps. We'll use generic steps: Step 1: generate u1, u2. Step 2: compute theta. Step 3: compute r0. Step 4: compute x. Step 5: compute y. Step 6: return [x, y].\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 產生隨機數 u1 ← Random(0,1) // 產生均勻分佈的亂數，用於角度\n→ Step 2: 產生隨機數 u2 ← Random(0,1) // 產生均勻分佈的亂數，用於半徑\n→ Step 3: 計算角度 theta ← 2π * u1 // 將 u1 轉換為 0~2π 的角度\n→ Step 4: 計算半徑 r0 ← radius * sqrt(u2) // 取平方根以保證點均勻分布\n→ Step 5: 計算座標 x ← x_center + r0 * cos(theta) // 使用極座標轉回平面座標\n→ Step 6: 計算座標 y ← y_center + r0 * sin(theta) // 同上，得到 y 坐標\n→ Step 7: 回傳 [x, y] // 將生成的點作為陣列返回\nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,2,3],[1,2,3],[1,3,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 2, 3], [1, 2, 3], [1, 3, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 存儲原始陣列的副本，確保後續不會被改動\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列的副本\n        return list(self.original)\n\n    def shuffle(self):\n        # 先複製原始陣列，避免改動 self.original\n        arr = list(self.original)\n        n = len(arr)\n        # Fisher–Yates 洗牌算法\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)   # 隨機選取 0~i 的索引\n            arr[i], arr[j] = arr[j], arr[i]  # 交換\n        return arr\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入包裝成 JSON 陣列，方便解析\n    data = '[' + data + ']'\n    try:\n        parts = json.loads(data)\n    except json.JSONDecodeError:\n        # 若解析失敗，直接退出\n        return\n\n    if not parts or len(parts) < 2:\n        return\n\n    methods, args_list = parts[0], parts[1]\n    instance = None\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            instance = Solution(*args)\n            results.append(None)  # 物件建立不回傳值\n        elif method == \"reset\":\n            results.append(instance.reset())\n        elif method == \"shuffle\":\n            results.append(instance.shuffle())\n        else:\n            # 若出現未知方法，回傳 None\n            results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments. Must be step-by-step algorithm for Solution class with constructor, reset, shuffle. Use Start, End, Decision. Provide steps of shuffling algorithm: e.g., Fisher-Yates. Also resetting by copying original array.\n\nWe need to produce virtual code, not actual code. Each line: \"虛擬碼步驟 // 解釋\". Use arrow →. Provide sequential lines. Should include data structures: original array, current array.\n\nStructure: Start // Program start\n→ Step: Store nums as original array // store original\n→ Step: Create a copy current array // for shuffle\n→ Step: Reset method: copy original to current // reset\n→ Step: Shuffle method: apply Fisher-Yates on current // random shuffle\n→ End\n\nBut need step-by-step inside shuffle: for i from n-1 down to 1: pick j random [0,i]; swap current[i] and current[j]. Represent each as lines.\n\nAlso include decision points? Not many. But we can show loop.\n\nLet's craft.\n\nUse 虛擬碼 like:\n\nStart // 程式開始\n→ Step 1: Receive input array nums // store input\n→ Step 2: Copy nums to originalArray // preserve original\n→ Step 3: Initialize currentArray as copy of originalArray // current working copy\n→ Step 4: Define reset() // reset method\n    → Step 4.1: Copy originalArray to currentArray // restore original\n    → Step 4.2: Return currentArray // output\n→ Step 5: Define shuffle() // shuffle method\n    → Step 5.1: Set n = length of currentArray // size\n    → Decision: 循環從 n-1 降至 1? // loop condition\n        Yes → Step 5.2: Generate random index j in [0, i] // random\n        → Step 5.3: Swap currentArray[i] and currentArray[j] // swap\n        → Step 5.4: i = i - 1 // decrement\n        No → Step 5.5: Return currentArray // finished\nEnd // 程式結束\n\nBut need to show loop. We can show using Decision for loop.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始\n→ Step 1: 接收輸入陣列 nums // 初始化\n→ Step 2: 複製 nums 為 originalArray // 保存原始順序\n→ Step 3: 複製 originalArray 為 currentArray // 可變工作副本\n→ Step 4: 定義 reset() 方法 // 重新還原原始順序\n    → Step 4.1: 複製 originalArray 到 currentArray // 重新複製\n    → Step 4.2: 回傳 currentArray // 回傳還原後的陣列\n→ Step 5: 定義 shuffle() 方法 // 隨機打亂\n    → Step 5.1: 設定 n = currentArray 長度 // 總長度\n    → Decision: i 仍 > 0? // 循環條件\n        Yes → Step 5.2: 產生隨機整數 j ∈ [0, i] // 隨機索引\n        → Step 5.3: 交換 currentArray[i] 與 currentArray[j] // 交換元素\n        → Step 5.4: i ← i - 1 // i 下降\n        No  → Step 5.5: 回傳 currentArray // 回傳打亂後的陣列\nEnd // 程式結束\n```"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def subsets(self, nums):\n        \"\"\"回溯產生所有子集。\"\"\"\n        res = []\n\n        def backtrack(start, path):\n            res.append(path[:])  # 把目前子集加入結果\n            for i in range(start, len(nums)):\n                path.append(nums[i])        # 加入元素\n                backtrack(i + 1, path)      # 進行下一層遞歸\n                path.pop()                  # 回溯，移除最後加入的元素\n\n        backtrack(0, [])  # 從第一個元素開始遞歸\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        sys.exit()\n\n    # 解析輸入格式，如 \"nums = [1,2,3]\"\n    try:\n        if \"=\" in data:\n            _, list_part = data.split(\"=\", 1)\n        else:\n            list_part = data\n        nums = eval(list_part.strip())  # 直接將字串轉為列表\n    except Exception:\n        nums = []\n\n    solution = Solution()\n    subsets = solution.subsets(nums)\n    # 使用 json.dumps 以符合範例輸出的格式（無空格）\n    print(json.dumps(subsets))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all subsets of a set of unique integers, no duplicates. Use backtracking recursion. We need to produce line by line with explanation. Use Start, End, Decision, etc. Provide each step line by line. Provide \"虛擬碼步驟\" plus explanation.\n\nWe should include steps: Start, define function backtrack(start, path). Add current path to results. Iterate from start to end, include nums[i], recursive call with i+1. After loop, return. After function, call backtrack(0, []), return results.\n\nAlso maybe need to sort input? Not necessary.\n\nWe must format each line exactly: `Start // 程式開始執行` etc.\n\nLet's produce.\n\nUse arrows: → Step 1: 定義函式 backtrack(start, path) // 回溯生成子集\n\nBut we must ensure structure: Start, then arrow lines.\n\nThe format example: Start // 程式開始執行\n→ Step 1: ... // ...\n\nWe should use decision for recursion maybe? Not necessary.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 backtrack(start, path) // 用於回溯生成子集\n→ Step 2: 內部：將目前 path 加入結果集合 res // 把已經選擇的子集存進答案\n→ Step 3: 循環 i 從 start 到 nums.length-1 // 選擇每個元素進一步擴展子集\n→ Decision: 是否將 nums[i] 加入 path? // 這裡始終是加入，因為沒有重複元素\n    Yes → Step 4: path.append(nums[i]) // 把 nums[i] 加入目前子集\n    → Step 5: backtrack(i+1, path) // 以 i+1 作為新的起點遞歸\n    → Step 6: path.pop() // 回溯，移除最後加入的元素\n→ Step 7: 结束循环\n→ Step 8: 返回 // 回到上一层递归\n→ Step 9: 初始化 res = [] // 存放所有子集\n→ Step 10: 调用 backtrack(0, []) // 从第一个元素开始递归\n→ Step 11: 返回 res // 返回最终结果\nEnd // 程式執行結束\n\nBut we need to ensure \"虛擬碼步驟\" part is consistent: maybe we should label Step 1, Step 2 etc.\n\nWe must maintain arrow indentation maybe.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 backtrack(start, path) // 用於回溯生成子集  \n→ Step 2: 內部：res.append(path.copy()) // 把目前的子集加入結果集合  \n→ Step 3: 循環 i 從 start 到 nums.length-1 // 選擇每個未處理的元素  \n→ Decision: 加入 nums[i] 到 path? // 這裡總是需要加入，以生成所有組合  \n    Yes → Step 4: path.append(nums[i]) // 把 nums[i] 加入目前子集  \n    → Step 5: backtrack(i+1, path) // 以 i+1 作為新起點遞歸  \n    → Step 6: path.pop() // 回溯，移除最後加入的元素  \n→ Step 7: 结束循环  \n→ Step 8: 返回 // 回到上一層遞歸  \n→ Step 9: 初始化 res = [] // 用於存放所有子集  \n→ Step 10: 调用 backtrack(0, []) // 從第一個元素開始回溯  \n→ Step 11: 返回 res // 回傳最終的子集列表  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,0,0,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 0, 0, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    content = sys.stdin.read().strip()\n    if not content:\n        sys.exit()\n    # 找出第一個 ']'，這應該是 ops 陣列的結尾\n    first_bracket = content.find(']')\n    ops = ast.literal_eval(content[:first_bracket+1])\n    args = ast.literal_eval(content[first_bracket+2:].strip())\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0])\n            results.append(None)\n        elif op == \"pickIndex\":\n            results.append(obj.pickIndex())\n        else:\n            # 若有其他方法，可在此處處理\n            results.append(None)\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the described problem: pickIndex() with weights. We need to output step-by-step pseudocode with explanations. Each line: \"虛擬碼步驟 // 解釋\". Use arrow →, Start, End, Decision. Provide step for constructing prefix sum array in constructor, then pickIndex random uniform between 1 and sum, binary search to find index.\n\nWe need to include the constructor as part of process. The requirement: generate virtual code line by line. Use Chinese.\n\nWe'll produce:\n\nStart\n→ Step 1: 計算總重量 sum = Σ w[i] // 累計權重\n→ Step 2: 建立前綴和陣列 prefix where prefix[i] = Σ_{j=0}^{i} w[j] // 方便區間查找\n→ Decision: 如果 w.length = 1? // 特殊情況\n    Yes → Step 3: pickIndex() 直接返回 0\n    No  → Step 4: pickIndex() 執行隨機選取\n        → Step 5: 生成隨機數 r 在 [1, sum] 之間 // 包含端點\n        → Step 6: 用二分搜尋在 prefix 中找到最小索引 i 使得 prefix[i] ≥ r // 對應權重區間\n        → Step 7: 返回 i // 選定索引\nEnd\n\nBut we need to incorporate the function signature: constructor and pickIndex. We'll structure:\n\nStart\n→ Constructor: input w\n    → Step 1: 计算 sum\n    → Step 2: 构造 prefix array\n→ End Constructor\n→ pickIndex function\n    → Step 3: 生成随机数 r\n    → Step 4: 二分搜索 prefix 找到索引\n    → Step 5: 返回索引\nEnd\n\nBut we need to ensure each line is a separate step. Let's produce as:\n\nStart // 程式開始執行\n→ Constructor: input w // 建構子，接收權重陣列\n    → Step 1: sum = 0 // 初始化總重量\n    → Step 2: prefix = 空陣列 // 初始化前綴和\n    → Step 3: 循環 i 從 0 到 w.length-1\n        → sum = sum + w[i] // 加總權重\n        → prefix.append(sum) // 追加當前前綴和\n→ End Constructor // 建構完成\n→ pickIndex() // 隨機挑選索引\n    → Step 4: r = 隨機整數在 [1, sum] // 產生隨機數\n    → Step 5: low = 0, high = prefix.length - 1 // 二分搜尋範圍\n    → Step 6: Decision: low <= high? // 二分搜尋迴圈\n        Yes → mid = (low + high) / 2 // 計算中間索引\n            Decision: prefix[mid] < r? // 判斷是否繼續搜尋\n                Yes → low = mid + 1 // r 在右半部\n                No  → high = mid - 1 // r 在左半部\n        No → // 搜尋結束\n    → Step 7: 返回 low // low 即為對應索引\nEnd // 程式執行結束\n\nBut each line must contain \"虛擬碼步驟 [space] // 解釋\". Need to use arrow for steps, but not indent maybe.\n\nWe must be careful: each line separate. Use arrow '→' for step lines. Use 'Decision:' for decision lines. Use Start, End.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Constructor: input w // 建構子，接收權重陣列  \n    → Step 1: sum = 0 // 初始化總重量  \n    → Step 2: prefix = [] // 初始化前綴和陣列  \n    → Step 3: 循環 i 從 0 到 w.length-1  \n        → sum = sum + w[i] // 累加權重  \n        → prefix.append(sum) // 追加當前前綴和到陣列  \n→ End Constructor // 建構完成，已備好前綴和  \n\n→ pickIndex() // 隨機挑選索引  \n    → Step 4: r = 隨機整數在 [1, sum] // 產生隨機數  \n    → Step 5: low = 0, high = prefix.length - 1 // 設定二分搜尋範圍  \n    → Decision: low <= high? // 二分搜尋迴圈條件  \n        Yes → Step 6: mid = (low + high) // 2 // 取中間索引  \n            Decision: prefix[mid] < r? // 判斷 r 是否在右半部  \n                Yes → low = mid + 1 // 將搜尋範圍移到右側  \n                No  → high = mid - 1 // 將搜尋範圍移到左側  \n        No → // 搜尋結束  \n    → Step 7: return low // low 為對應索引，回傳結果  \nEnd // 程式執行結束"
    }
  ]
}