{
  "run_index": 17,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 388,
  "generation_or_validation_failure_count": 51,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取 stdin 但不作處理，確保程式能在需要時使用輸入\n    sys.stdin.read()\n\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe user wants virtual code for the described program. They ask for no real code, just virtual code steps. The output must be line by line with \"虛擬碼步驟\" and \"// 解釋/說明\" with arrows, Start, End, Decision, etc.\n\nWe need to produce steps: Start, then open file with try/except, use with, read lines, count lines, print count, except FileNotFoundError, print message. We need to follow formatting exactly.\n\nThe virtual code lines should contain \"虛擬碼步驟\" and a space then comment. The steps may be something like:\n\nStart // 程式開始執行\n→ Step 1: 嘗試開啟 'data.txt' 並進入 with 區塊 // 以 with 方式安全開啟檔案\n→ Decision: 檔案是否成功開啟? // 檢查是否出現 FileNotFoundError\n    Yes → Step 2: 讀取所有行並計算行數 // 取得檔案所有行並計數\n    Yes → Step 3: 輸出「共 X 行」 // 顯示行數\n    No  → Step 4: 輸出 '找不到檔案！' // 當檔案不存在時顯示訊息\nEnd // 程式結束\n\nBut we need proper structure: use Decision: with Yes and No. And try/except is a Decision.\n\nThe virtual code should reflect try/except: Step: Try open file, Decision: if exception occurs? If yes go to except block. So maybe:\n\nStart\n→ Step 1: 嘗試使用 with 開啟 'data.txt' // 進入檔案開啟區塊\n→ Decision: 是否成功執行到檔案開啟? // 判斷是否觸發 FileNotFoundError\n    Yes → Step 2: 讀取所有行並計數 // 計算行數\n    Yes → Step 3: 輸出「共 X 行」 // 顯示計算結果\n    No  → Step 4: 輸出 '找不到檔案！' // 例外處理\nEnd\n\nWe need to include with inside try block. So maybe:\n\nStart\n→ Step 1: 嘗試執行\n    → Step 1a: with open('data.txt') as file: // 以 with 開啟檔案\n        → Decision: 讀取成功? // 是否進入 with 區塊\n            Yes → Step 2: lines = file.readlines() // 讀取所有行\n            Yes → Step 3: count = len(lines) // 計算行數\n            Yes → Step 4: 輸出 \"共 {count} 行\" // 顯示\n        No  → Step 5: 輸出 '找不到檔案！' // 例外處理\nEnd\n\nBut they specifically said use try/except, so we need a Decision: if FileNotFoundError? We can structure:\n\nStart\n→ Decision: 嘗試執行以下程式? // start try block\n    Yes → Step 1: with open('data.txt') as file: // 打開檔案\n        → Step 2: lines = file.readlines() // 讀取所有行\n        → Step 3: count = len(lines) // 計算行數\n        → Step 4: 輸出 \"共 {count} 行\" // 顯示結果\n    No  → Step 5: 輸出 '找不到檔案！' // 例外處理\nEnd\n\nBut need to show that No branch is from FileNotFoundError. We could use Decision: 是否捕獲 FileNotFoundError? but maybe simpler: Decision: 是否有例外? No? The decision is not perfect.\n\nGiven the example, they use Decision: if condition? So we can phrase:\n\nStart\n→ Step 1: 嘗試執行以下程式 // 進入 try 區塊\n→ Decision: 是否成功打開檔案? // 檢查是否發生 FileNotFoundError\n    Yes → Step 2: with open('data.txt') as file: // 打開檔案\n        → Step 3: lines = file.readlines() // 讀取所有行\n        → Step 4: count = len(lines) // 計算行數\n        → Step 5: 輸出 \"共 {count} 行\" // 顯示行數\n    No  → Step 6: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd\n\nBut we might need to show with open inside try. Let's propose:\n\nStart\n→ Step 1: 嘗試執行以下程式 // 開始 try 區塊\n→ Decision: 是否發生 FileNotFoundError? // 判斷是否成功打開檔案\n    Yes → Step 2: with open('data.txt') as file: // 打開檔案\n        → Step 3: lines = file.readlines() // 讀取所有行\n        → Step 4: count = len(lines) // 計算行數\n        → Step 5: 輸出 \"共 {count} 行\" // 顯示行數\n    No  → Step 6: 輸出 '找不到檔案！' // 例外處理\nEnd\n\nBut they want the structure: Decision: 如果...? and then Yes → and No →. So we need to phrase decision condition: \"檔案是否存在?\" or \"是否成功打開檔案?\". The 'Yes' path should include opening file. But that path would be inside try. But we can phrase:\n\nStart\n→ Decision: 嘗試打開 'data.txt'? // 進入 try\n    Yes → Step 1: with open('data.txt') as file: // 打開檔案\n        → Step 2: lines = file.readlines() // 讀取所有行\n        → Step 3: count = len(lines) // 計算行數\n        → Step 4: 輸出 \"共 {count} 行\" // 顯示結果\n    No  → Step 5: 輸出 '找不到檔案！' // 檔案不存在\nEnd\n\nBut we need to reflect try/except. So maybe:\n\nStart\n→ Step 1: 嘗試執行以下程式 // 進入 try 區塊\n→ Decision: 檔案是否成功開啟? // 判斷是否捕獲 FileNotFoundError\n    Yes → Step 2: with open('data.txt') as file: // 打開檔案\n        → Step 3: lines = file.readlines() // 讀取所有行\n        → Step 4: count = len(lines) // 計算行數\n        → Step 5: 輸出 \"共 {count} 行\" // 顯示行數\n    No  → Step 6: 輸出 '找不到檔案！' // 處理例外\nEnd\n\nBetter include \"except FileNotFoundError:\" but we can embed it in decision. Let's produce the final answer with proper indentation? The example shows indentation for nested decisions. Use arrow. We need each line a separate line. Use \"虛擬碼步驟\" with arrow \"→\". For Decision we use \"Decision:\" and indentation.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Decision: 嘗試打開 'data.txt'? // 進入 try 區塊，檢查檔案是否存在\n    Yes → Step 1: with open('data.txt') as file: // 以 with 語法安全開啟檔案\n        → Step 2: lines = file.readlines() // 讀取所有行\n        → Step 3: count = len(lines) // 計算行數\n        → Step 4: 輸出 \"共 {count} 行\" // 顯示總行數\n    No  → Step 5: 輸出 '找不到檔案！' // 捕獲 FileNotFoundError，顯示錯誤訊息\nEnd // 程式執行結束\n\nMake sure each line ends with comment. Ensure arrow used. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 嘗試打開 'data.txt'? // 進入 try 區塊，檢查檔案是否存在  \n  Yes → Step 1: with open('data.txt') as file: // 以 with 語法安全開啟檔案  \n    → Step 2: lines = file.readlines() // 讀取所有行  \n    → Step 3: count = len(lines) // 計算行數  \n    → Step 4: 輸出 \"共 {count} 行\" // 顯示總行數  \n  No  → Step 5: 輸出 '找不到檔案！' // 捕獲 FileNotFoundError，顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[3,4,2,3,5]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[3, 4, 2, 3, 5]'"
        }
      ],
      "generated_code": "import random\n\ndef roll_dice(n: int):\n    \"\"\"\n    擲 n 次六面骰，並回傳所有結果的串列。\n    :param n: 擲骰次數\n    :return: 由 n 個 1~6 整數組成的 list\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    # 讀取標準輸入的全部內容，並執行其中的 Python 程式碼\n    # 這樣可以處理「print(roll_dice(5))」等任意合法輸入\n    code = sys.stdin.read()\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Start, then roll_dice(n) function, use random module, simulate n times, return list. Use virtual steps. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import: 導入 random 模組 // 使程式能使用隨機數功能  \n→ Function: roll_dice(n): // 定義函式，參數為擲骰次數  \n→    Init: results = [] // 建立空清單，用來存放每次擲骰的結果  \n→    Loop: 1 to n: // 進行 n 次迴圈  \n→        Step: result = random.randint(1, 6) // 產生 1~6 的隨機整數  \n→        Step: results.append(result) // 將結果加入清單  \n→    End Loop // 結束迴圈  \n→    Return: results // 回傳所有擲骰結果的清單  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"grape\",\"apple\",\"melon\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'grape', 'apple', 'melon'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入（此題無需實際資料，僅符合規範）\n    _ = sys.stdin.read()\n\n    # 初始化集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'（不會拋錯）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output line-by-line pseudocode with explanations, no actual code. Use Start, End, Decision maybe not needed. Just steps.\n\nLet's produce:\n\nStart\n→ Step 1: 定義集合 fruits 為 {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增橘子\n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增葡萄和西瓜\n→ Step 4: fruits.remove('banana') // 移除香蕉\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的鳳梨，不會拋錯\n→ Step 6: 輸出 fruits // 顯示最終集合\nEnd\n\nMake sure format each line: \"虛擬碼步驟 // 解釋\". So lines start with \"→\" maybe after Start? In sample, they used \"→ Step 1: ...\" after Start. So do that.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義集合 fruits 為 {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 使用 add() 新增橘子\n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 一次新增葡萄與西瓜\n→ Step 4: fruits.remove('banana') // 使用 remove() 移除香蕉\n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的鳳梨（不會拋錯）\n→ Step 6: 輸出 fruits // 顯示最終集合\nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.7TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.7 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\n# ------------------------------------------------------------\n# 取得美元兌台幣匯率的函式\n# ------------------------------------------------------------\ndef fetch_rate() -> float:\n    \"\"\"從 exchangerate-api 取得 USD → TWD 匯率，若失敗則拋出例外。\"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    r = requests.get(url, timeout=10)\n    r.raise_for_status()  # 若 HTTP 狀態非 200，拋出例外\n    data = r.json()\n    rate = data[\"rates\"][\"TWD\"]\n    return float(rate)\n\n# ------------------------------------------------------------\n# GUI 相關程式碼\n# ------------------------------------------------------------\ndef start_gui():\n    \"\"\"建立並啟動 tkinter GUI，按鈕可更新匯率。\"\"\"\n    win = tk.Tk()\n    win.title(\"USD → TWD 匯率查詢\")\n\n    # 標籤顯示匯率\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    # 更新匯率的函式\n    def update_rate():\n        try:\n            rate = fetch_rate()\n            label.config(text=f\"目前美元匯率：約 {rate:.1f} TWD\")\n        except Exception:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n\n    # 按鈕\n    tk.Button(win, text=\"更新匯率\", command=update_rate).pack(pady=5)\n\n    win.mainloop()\n\n# ------------------------------------------------------------\n# main 入口\n# ------------------------------------------------------------\nif __name__ == \"__main__\":\n    # 從標準輸入讀取內容\n    input_text = sys.stdin.read().strip()\n\n    # 若有任何輸入，視為「按下按鈕」的指令，直接輸出匯率\n    if input_text:\n        try:\n            rate = fetch_rate()\n            # 以「約」的格式輸出，保留一位小數\n            print(f\"目前美元匯率：約 {rate:.1f} TWD\")\n        except Exception:\n            print(\"更新失敗，請檢查網路連線\")\n    else:\n        # 無輸入時啟動 GUI\n        start_gui()",
      "virtual_code": "Thinking...\nWe need to generate pseudo-code step by step, with comments. Use virtual code arrows. Use Start, End. Need to incorporate requests module and tkinter. Steps: import modules, define function fetch_rate, set up tkinter window, label, button, callback to update label by fetching rate, main loop. Provide each line with explanation.\n\nMake sure each line ends with // explanation. Provide lines like:\n\nStart // 程式開始執行\n→ Import modules // 載入所需的模組\n→ Define fetch_rate() // 定義函式取得匯率\n...\n\nAlso we need to use arrows \"→\" for each step.\n\nMake sure \"Decision:\" for conditions: e.g., \"Decision: 取得匯率是否成功?\" etc.\n\nAlso need to show event binding: \"button clicked → update rate\".\n\nLet's produce pseudo-code. Use lines separated by newline.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import modules: requests, tkinter, json // 載入網路請求與 GUI 模組  \n→ Define fetch_rate(): // 定義函式用於抓取匯率資料  \n    → 將 API URL 設定為 \"https://api.exchangerate-api.com/v4/latest/USD\" // 指定匯率來源  \n    → Decision: 嘗試發送 GET 請求? // 檢查網路連線成功與否  \n        Yes → Step: 取得回應並解析 JSON // 取得 API 回應並轉成字典  \n            → Step: 從 JSON 中取得 'rates' -> 'TWD' 值 // 取出美元兌台幣匯率  \n            → Return 匯率 // 成功回傳匯率數值  \n        No  → Step: 回傳 None // 失敗時回傳空值  \n→ 建立主視窗 root = tkinter.Tk() // 初始化 Tkinter 視窗  \n→ 設定標題 \"USD to TWD 匯率查詢\" // 給視窗一個標題  \n→ 建立 Label 顯示匯率的元件 rate_label = tkinter.Label(root, text=\"匯率將於按鈕更新\") // 初始文字  \n→ 放置 Label 在視窗中 rate_label.pack(pady=20) // 佈局，並加上空白  \n→ 定義按鈕回呼函式 update_rate(): // 事件處理函式  \n    → Step: rate = fetch_rate() // 取得最新匯率  \n    → Decision: rate 是否為 None? // 判斷是否取得成功  \n        Yes → Step: rate_label.config(text=\"無法取得匯率\") // 失敗訊息  \n        No  → Step: rate_label.config(text=f\"USD -> TWD: {rate:.4f}\") // 成功顯示匯率  \n→ 建立按鈕 button = tkinter.Button(root, text=\"更新匯率\", command=update_rate) // 按鈕連結回呼  \n→ 放置按鈕在視窗中 button.pack(pady=10) // 佈局  \n→ 執行主循環 root.mainloop() // 開啟 GUI 主循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[1,0],[2,0],[0,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null,[1,0],[2,0],[0,0],null,[1,0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom typing import List, Optional, Any\n\nclass Solution:\n    def __init__(self, m: int, n: int) -> None:\n        \"\"\"\n        初始化 m x n 的二進位矩陣，所有元素皆為 0。\n        \"\"\"\n        self.m = m\n        self.n = n\n        self.total = m * n          # 剩餘未被翻轉的格子總數\n        self.map = {}               # 對應表，隨機索引 ↔ 真實索引\n\n    def flip(self) -> List[int]:\n        \"\"\"\n        隨機挑選一個目前為 0 的格子，將其翻轉為 1，並返回其位置 [i, j]。\n        \"\"\"\n        # 隨機取得一個可用的索引\n        k = random.randint(0, self.total - 1)\n\n        # 若 k 已經映射到其他位置，使用映射值；否則直接使用 k\n        real = self.map.get(k, k)\n\n        # 取最後一個可用索引（或其映射）以填補 k 的位置\n        last = self.map.get(self.total - 1, self.total - 1)\n        self.map[k] = last\n\n        # 減少剩餘可翻轉格子\n        self.total -= 1\n\n        # 將一維索引轉回二維坐標\n        i = real // self.n\n        j = real % self.n\n        return [i, j]\n\n    def reset(self) -> None:\n        \"\"\"\n        將所有格子重置為 0，並清空映射表。\n        \"\"\"\n        self.total = self.m * self.n\n        self.map.clear()\n\n\ndef main() -> None:\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 把兩個 JSON 陣列包裝成一個 JSON 陣列，方便解析\n    try:\n        ops_and_args = json.loads('[' + raw_input + ']')\n    except json.JSONDecodeError as e:\n        # 若輸入格式不符，直接退出\n        sys.exit(1)\n\n    if not isinstance(ops_and_args, list) or len(ops_and_args) != 2:\n        sys.exit(1)\n\n    ops: List[str] = ops_and_args[0]\n    args: List[Any] = ops_and_args[1]\n\n    result: List[Optional[Any]] = []\n    instance: Optional[Solution] = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # 建構子呼叫\n            instance = Solution(arg[0], arg[1])\n            result.append(None)\n        elif op == \"flip\":\n            if instance is None:\n                result.append(None)\n            else:\n                result.append(instance.flip())\n        elif op == \"reset\":\n            if instance is not None:\n                instance.reset()\n            result.append(None)\n        else:\n            # 不支援的操作，回傳 None\n            result.append(None)\n\n    # 輸出結果，使用 JSON 以得到 null 的表示法\n    print(json.dumps(result, separators=(',', ':')))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with explanation. Should design algorithm: use reservoir style mapping of available indices to random picks, maintain mapping dictionary. Use total cells M*N. When flip, choose random k from [0, remaining-1], map k to real index via mapping or k itself. Then mark mapping[ k ] = mapping[ remaining-1 ] or last. Decrement remaining. Return index conversion: row = idx // n, col = idx % n. Reset: clear mapping, set remaining=M*N.\n\nWe produce pseudo-code lines following the format. Need to include Start, End, Decision, etc. We should also include initialization.\n\nLet's craft steps. Use comments.\n\nProceed.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 m, n, total = m × n, remain = total // 設定矩陣尺寸、總格數與剩餘可翻轉格數  \n→ Step 2: 建立空映射 table // 用於把隨機索引對應到實際矩陣位置  \n\n// ---- flip() 函式 ----\n→ Function flip() // 開始 flip 方法  \n    → Decision: remain > 0? // 確認是否還有可翻轉的格子  \n        Yes → Step 3: 隨機產生 k ∈ [0, remain‑1] // 用隨機函式取得一個索引  \n        → Step 4: 取得 realIdx = table.get(k, k) // 若映射存在則取對應值，否則取 k 本身  \n        → Step 5: 取得 lastIdx = table.get(remain‑1, remain‑1) // 取最後一個未使用的索引或其映射  \n        → Step 6: 設定 table[k] = lastIdx // 用 lastIdx 替換 k，保持映射不變  \n        → Step 7: remain = remain - 1 // 减少剩餘可翻轉格數  \n        → Step 8: 轉換 realIdx 為行列：row = realIdx ÷ n, col = realIdx mod n // 將一維索引映射回二維坐標  \n        → Step 9: 回傳 [row, col] // 返回隨機且均勻的格子位置  \n        No → Step 10: 把空陣列返回 // 若已無格子可翻，返回空值或拋出異常  \n\n// ---- reset() 函式 ----\n→ Function reset() // 開始 reset 方法  \n    → Step 11: 重新設定 remain = total // 將剩餘格數恢復為全部格數  \n    → Step 12: 清空 table // 重新建立空映射，所有格子恢復為 0  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Teemo Attacking",
      "source_file": "Leetcode/leetcode495.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuhp792ou.py\", line 23, in <module>\n    time_series = eval(time_series_part.split(\"=\", 1)[1].strip())\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfkqh1jvt.py\", line 23, in <module>\n    time_series = eval(time_series_part.split(\"=\", 1)[1].strip())\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries, duration):\n        if not timeSeries:\n            return 0\n        total = 0\n        for i in range(len(timeSeries) - 1):\n            total += min(timeSeries[i + 1] - timeSeries[i], duration)\n        total += duration\n        return total\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Expected format: \"timeSeries = [1,4], duration = 2\"\n    parts = [part.strip() for part in data.split(\",\")]\n    time_series_part = parts[0]\n    duration_part = parts[1]\n\n    time_series = eval(time_series_part.split(\"=\", 1)[1].strip())\n    duration = int(duration_part.split(\"=\", 1)[1].strip())\n\n    sol = Solution()\n    result = sol.findPoisonedDuration(time_series, duration)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for computing total poisoned time given sorted attack times and duration, handling overlapping intervals by resetting timer.\n\nWe need to produce step-by-step pseudo code. For each attack, add duration to total unless overlapping, where we add only (attack_time - prev_attack_time) if less than duration? Actually total poisoned time = sum over attacks of min(duration, next_attack - current_attack) with last attack adding full duration. So we can loop.\n\nWe need to follow format: Start, → Step, Decision etc. Provide each line.\n\nLet's craft.\n\nStart // program starts\n\n→ Step 1: Initialize total = 0, prev = -∞ // set total poison time, previous attack time\n\n→ Step 2: For each attack_time in timeSeries // iterate over attack times\n\n→ Decision: Is prev < 0? // first attack\n\n    Yes → Step 3a: total += duration // first attack, no overlap\n\n    No → Step 3b: Decision: If attack_time - prev >= duration? // check if new attack occurs after previous poison ends\n\n        Yes → Step 4a: total += duration // add full duration\n\n        No  → Step 4b: total += attack_time - prev // only add time until new attack resets poison\n\n→ Step 5: prev = attack_time // update previous attack time\n\n→ End // done\n\nBut we need to ensure we include Step numbering consistent.\n\nAlso after loop, we are done; maybe not need final.\n\nBetter to produce more detailed pseudo steps:\n\nStart\n\n→ Step 1: total ← 0 // total poisoned seconds\n\n→ Step 2: prev ← -∞ // previous attack time\n\n→ Step 3: For each t in timeSeries // iterate attacks\n\n    → Decision: prev == -∞? // first attack\n\n        Yes → Step 3a: total ← total + duration // full duration\n\n        No → Step 3b: Decision: t - prev ≥ duration? // no overlap\n\n            Yes → Step 3b1: total ← total + duration // add full duration\n\n            No  → Step 3b2: total ← total + (t - prev) // add remaining time before reset\n\n    → Step 3c: prev ← t // update last attack\n\n→ End\n\nWe need to follow arrow formatting: Use `→` for steps, `Decision:` with Yes→ and No→. Indentation maybe with spaces.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: total ← 0 // 初始化總毒化秒數  \n→ Step 2: prev ← -∞ // 之前一次攻擊時間（初始為無）  \n\n→ Step 3: For each t in timeSeries // 逐一處理攻擊時間  \n  → Decision: prev == -∞? // 是否為第一次攻擊  \n   Yes → Step 3a: total ← total + duration // 第一次攻擊無重疊，直接加上完整持續時間  \n   No  → Decision: t - prev ≥ duration? // 新攻擊是否在前一次毒化結束之後  \n    Yes → Step 3b1: total ← total + duration // 無重疊，加入完整持續時間  \n    No  → Step 3b2: total ← total + (t - prev) // 重疊，僅加入兩次攻擊間的時間差  \n  → Step 3c: prev ← t // 更新最後一次攻擊時間  \n\nEnd // 程式執行結束，total 為總毒化秒數"
    },
    {
      "title": "Search in Rotated Sorted Array",
      "source_file": "Leetcode/leetcode33.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,5,6,7,0,1,2], target = 0",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjbrhdn2m.py\", line 39, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjbrhdn2m.py\", line 31, in parse_input\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [4\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2], target = 3",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk9onoi9y.py\", line 39, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk9onoi9y.py\", line 31, in parse_input\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [4\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:          # 左半段有序\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:                                # 右半段有序\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1\n\ndef parse_input(data: str):\n    # 移除 'nums =' 和 'target =' 前綴\n    data = data.replace('nums =', '').replace('target =', '').strip()\n    # 以逗號分隔，第一部分是 list，第二部分是 target\n    parts = data.split(',', 1)\n    nums_part = parts[0].strip()\n    target_part = parts[1].strip()\n    # 使用 ast.literal_eval 解析 list，確保安全\n    nums = ast.literal_eval(nums_part)\n    target = int(target_part)\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    nums, target = parse_input(raw_input)\n    result = Solution().search(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode with explanations. The task: rotated sorted array search. O(log n). We'll use binary search with check of sorted half. Provide steps line by line with arrow and comments.\n\nWe need to use the virtual code format with arrow arrows and decisions. Should include Start, End.\n\nWe need to produce line-by-line pseudocode: Start, initialize left/right, while left <= right, compute mid, compare mid to target, etc. Also include decision branches for rotation detection.\n\nWe should produce in Chinese Traditional.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: left ← 0, right ← length(nums)-1 // 初始化搜尋範圍\n→ Decision: while left <= right? // 只要搜尋範圍內有元素\n    Yes → Step 2: mid ← (left + right) // 2 // 計算中點\n    → Decision: nums[mid] == target? // 中點是否為目標\n        Yes → Step 3: return mid // 找到目標，返回索引\n        No  → Decision: nums[left] <= nums[mid]? // 左半段是否有序\n            Yes → Decision: nums[left] <= target < nums[mid]? // 目標在左半段\n                Yes → Step 4: right ← mid - 1 // 將搜尋範圍縮小到左半段\n                No  → Step 5: left ← mid + 1 // 目標在右半段，調整左邊界\n            No  → Decision: nums[mid] < target <= nums[right]? // 目標在右半段\n                Yes → Step 6: left ← mid + 1 // 目標在右半段\n                No  → Step 7: right ← mid - 1 // 目標在左半段\n→ End // 未找到目標，返回 -1\n← Step 8: return -1 // 搜尋結束，目標不存在\n\nBut need to use the arrow syntax for steps.\n\nWe need each line to be a single statement like \"→ Step 1: left ← 0, right ← len(nums)-1 //\". Use arrow for decision branches with Yes/No.\n\nBetter to structure with nested Decision and sub steps. Use indentation.\n\nLet's write lines:\n\nStart // 程式開始執行\n→ Step 1: left ← 0, right ← len(nums) - 1 // 初始化搜尋範圍\n→ Decision: while left <= right? // 循環，直到範圍無效\n    Yes → Step 2: mid ← (left + right) // 2 // 計算中點\n    → Decision: nums[mid] == target? // 判斷中點是否為目標\n        Yes → Step 3: return mid // 找到，返回索引\n        No  → Decision: nums[left] <= nums[mid]? // 判斷左半段是否有序\n            Yes → Decision: nums[left] <= target < nums[mid]? // 目標在左半段？\n                Yes → Step 4: right ← mid - 1 // 左半段搜索\n                No  → Step 5: left ← mid + 1 // 右半段搜索\n            No  → Decision: nums[mid] < target <= nums[right]? // 目標在右半段？\n                Yes → Step 6: left ← mid + 1 // 右半段搜索\n                No  → Step 7: right ← mid - 1 // 左半段搜索\n→ End // 循環結束，未找到\n← Step 8: return -1 // 返回 -1 表示不存在\n\nWe must make sure each line is a separate line with arrow or decision. Use \"←\" to denote assignment. Provide explanation after \"//\".\n\nWe should include \"Start\" line without arrow. Use \"Start //\".\n\nFor decisions, we use \"Decision: condition?\" and indent branches.\n\nOk produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left ← 0, right ← len(nums) - 1 // 初始化搜尋範圍  \n→ Decision: while left <= right? // 只要搜尋範圍內仍有元素  \n    Yes → Step 2: mid ← (left + right) // 2 // 計算中點索引  \n    → Decision: nums[mid] == target? // 判斷中點是否為目標  \n        Yes → Step 3: return mid // 找到目標，返回索引  \n        No  → Decision: nums[left] <= nums[mid]? // 判斷左半段是否已排序  \n            Yes → Decision: nums[left] <= target < nums[mid]? // 目標是否在左半段  \n                Yes → Step 4: right ← mid - 1 // 將搜尋範圍縮小到左半段  \n                No  → Step 5: left ← mid + 1 // 目標在右半段，調整左邊界  \n            No  → Decision: nums[mid] < target <= nums[right]? // 目標是否在右半段  \n                Yes → Step 6: left ← mid + 1 // 目標在右半段，調整左邊界  \n                No  → Step 7: right ← mid - 1 // 目標在左半段，調整右邊界  \n→ End // 循環結束，未找到目標  \n← Step 8: return -1 // 返回 -1 表示目標不存在於陣列中"
    },
    {
      "title": "Next Greater Element I",
      "source_file": "Leetcode/leetcode496.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [4,1,2], nums2 = [1,3,4,2]",
          "expected_output": "[-1,3,-1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8f7j_yyx.py\", line 32, in <module>\n    main()\n  File \"/tmp/tmp8f7j_yyx.py\", line 26, in main\n    nums1 = ast.literal_eval(parts[0].strip())\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [4\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums1 = [2,4], nums2 = [1,2,3,4]",
          "expected_output": "[3,-1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpl3gn6k4n.py\", line 32, in <module>\n    main()\n  File \"/tmp/tmpl3gn6k4n.py\", line 26, in main\n    nums1 = ast.literal_eval(parts[0].strip())\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def nextGreaterElement(self, nums1, nums2):\n        stack = []\n        next_greater = {}\n        for num in nums2:\n            while stack and num > stack[-1]:\n                next_greater[stack.pop()] = num\n            stack.append(num)\n        return [next_greater.get(x, -1) for x in nums1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 支援兩行輸入：第一行為 nums1，第二行為 nums2\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        nums1 = ast.literal_eval(lines[0].strip())\n        nums2 = ast.literal_eval(lines[1].strip())\n    else:\n        # 單行輸入，例如 \"nums1 = [4,1,2], nums2 = [1,3,4,2]\"\n        parts = data.replace('nums1', '').replace('nums2', '').replace('=', '').split(',')\n        nums1 = ast.literal_eval(parts[0].strip())\n        nums2 = ast.literal_eval(parts[1].strip())\n    result = Solution().nextGreaterElement(nums1, nums2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code, line by line, with explanation after //.\n\nTask: find next greater element for each element in nums1 within nums2. Standard solution: use stack to compute next greater for all nums2 elements, then map values to next greater; iterate nums1.\n\nBut we must output virtual code: Start → Step 1: ... etc. Should be structured. Need decision, loops, etc.\n\nWe need to produce virtual code lines, each with explanation. Provide steps like:\n\nStart // 程式開始執行\n→ Step 1: Initialize stack and map // Create empty stack and dictionary\n→ Step 2: For each element in nums2 from left to right: // Iterate through nums2\n    → Step 3: While stack not empty and current > stack top: // Find next greater\n        → Step 4: Pop top and set its next greater to current in map\n    → Step 5: Push current onto stack\n→ Step 6: After loop, for remaining elements in stack: // No next greater\n    → Step 7: Pop each and set its next greater to -1 in map\n→ Step 8: Initialize ans array of size nums1.length // Prepare result\n→ Step 9: For each index i in nums1:\n    → Step 10: Set ans[i] = map[nums1[i]]\n→ End // 結束\n\nWe might also handle mapping directly while building, but okay.\n\nWe must adhere to format: each line with virtual code and // explanation.\n\nAlso include decision nodes? Not much, but we can include Decision: if stack empty? Not needed. Use Yes/No arrows maybe.\n\nWe need to use arrow symbols: →, Yes →, No →, and Decision: lines.\n\nWe can incorporate decision inside while: Decision: If current > stack top? Actually while loop acts.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Create empty stack S and empty map M // 用於存儲每個元素對應的下一個更大元素\n→ Step 2: For i from 0 to length(nums2)-1: // 遍歷 nums2 的所有元素\n    → Step 3: Let cur = nums2[i] // 取得當前元素\n    → Decision: 如果 S 不為空且 cur > S.top()? // 判斷是否能找到更大的元素\n        Yes → While cur > S.top():\n            → Step 4: Let val = S.pop() // 取出堆頂元素\n            → Step 5: M[val] = cur // 將其下一個更大元素設為 cur\n        No  → // 不做任何操作\n    → Step 6: S.push(cur) // 把 cur 放入堆中等待後續比較\n→ Step 7: While S not empty: // 剩餘元素沒有更大的元素\n    → Step 8: Let val = S.pop()\n    → Step 9: M[val] = -1 // 設為 -1 表示不存在\n→ Step 10: Create array ans of size length(nums1) // 用於存儲答案\n→ Step 11: For j from 0 to length(nums1)-1: // 遍歷 nums1\n    → Step 12: ans[j] = M[nums1[j]] // 將對應的下一個更大元素賦值給答案\n→ End // 程式執行結束\n\nWe need each line with the format: \"虛擬碼步驟 [space] // 解釋/說明\"\n\nSo we need to produce like:\n\nStart // 程式開始執行\n→ Step 1: ... // ...\n\nMake sure each line has the arrow symbol after the step. For loops and decisions we include arrow.\n\nNeed to format properly.\n\nLet's produce the final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize empty stack S and empty map M // 建立堆疊與對應表  \n→ Step 2: For i from 0 to length(nums2)-1: // 逐個遍歷 nums2  \n  → Step 3: Let cur = nums2[i] // 取得當前元素  \n  → Decision: 如果 S 非空且 cur > S.top()? // 判斷是否存在更大的元素  \n   Yes → While cur > S.top(): // 找到所有小於 cur 的堆疊元素  \n     → Step 4: Let val = S.pop() // 取出堆疊頂部元素  \n     → Step 5: M[val] = cur // 設定其下一個更大元素為 cur  \n   No  → // 無需操作  \n  → Step 6: S.push(cur) // 把當前元素入堆疊等待後續比較  \n→ Step 7: While S not empty: // 堆疊中剩餘元素沒有更大的元素  \n   → Step 8: Let val = S.pop() // 取出元素  \n   → Step 9: M[val] = -1 // 標記為 -1 表示不存在  \n→ Step 10: Initialize array ans of size length(nums1) // 用於儲存最終答案  \n→ Step 11: For j from 0 to length(nums1)-1: // 遍歷 nums1  \n   → Step 12: ans[j] = M[nums1[j]] // 取得對應的下一個更大元素  \n→ End // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp93x8tros.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmp93x8tros.py\", line 47, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp93x8tros.py\", line 15, in __init__\n    self.lookup[(pref, suff)] = weight\n    ~~~~~~~~~~~^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass WordFilter:\n    def __init__(self, words):\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            # For each possible prefix length i and suffix start j\n            for i in range(L + 1):\n                pref = word[:i]\n                for j in range(L + 1):\n                    suff = word[j:]\n                    # Store the largest weight for each (pref, suff) pair\n                    self.lookup[(pref, suff)] = weight\n\n    def f(self, prefix, suffix):\n        return self.lookup.get((prefix, suffix), -1)\n\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input that can be either:\n    1. Two separate JSON arrays on separate lines.\n    2. A single line with two JSON arrays separated by a comma.\n    \"\"\"\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) == 2:\n        words = json.loads(lines[0])\n        queries = json.loads(lines[1])\n    else:\n        # Assume a single line containing two JSON arrays separated by a comma\n        # e.g. '[[\"apple\"]], [\"a\", \"e\"]'\n        first, second = lines[0].split('],', 1)\n        words = json.loads(first + ']')\n        # Ensure the second part starts with '['\n        if not second.strip().startswith('['):\n            second = '[' + second\n        queries = json.loads(second)\n    return words, queries\n\n\ndef main():\n    data = sys.stdin.read()\n    words, queries = parse_input(data)\n\n    wf = WordFilter(words)\n\n    # Each query is a list [prefix, suffix]\n    results = []\n    for query in queries:\n        if isinstance(query, list) and len(query) == 2:\n            pref, suff = query\n        else:\n            # If queries are given as separate strings without list wrapper\n            pref, suff = query, query\n        results.append(str(wf.f(pref, suff)))\n\n    sys.stdout.write(\"\\n\".join(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for a design of special dictionary with prefix and suffix search, WordFilter class with constructor and method f. We need to generate step-by-step pseudo code with explanations.\n\nWe need to think about algorithm: typical solution uses Trie for prefixes and suffixes. Use a combined trie with prefix and suffix keys. But since we only need virtual code, we can outline steps: Build a trie that stores mapping from (prefix, suffix) to max index. For each word, iterate all prefixes and suffixes: combine prefix + '#' + suffix -> insert into map with index. But typical solution uses a combined trie with all suffix prefixes, but we can keep a hash map of key to index.\n\nHowever we need to output virtual code step-by-step, not actual code. So we can outline steps of building dictionary: For each word index, for each prefix of word, for each suffix of word, create key = prefix + '#' + suffix, store index if larger. Then for f(pref, suff): key = pref + '#' + suff, lookup map, return value else -1.\n\nBut we need to produce pseudo code lines with arrow.\n\nLet's produce steps: Start, Step: Initialize dictionary, Step: Build map.\n\nPseudo code lines: Use loops, conditions.\n\nWe need to output in requested format: Each line: \"虛擬碼步驟 // 解釋\".\n\nLet's create lines:\n\nStart // 程式開始執行\n\n→ Step 1: Initialize WordFilter(words) // 建構子接收單字列\n\n→ Step 2: Create empty map prefixSuffixToIndex // 用來儲存前後綴對應的最大索引\n\n→ Step 3: For each word with index i in words // 逐個處理字詞\n\n    → Decision: If word is empty? // 處理空字\n\n        Yes → Continue // 跳過空字\n\n        No  → Decision: Set prefix = \"\" // 初始前綴\n\n           → Step 4: For each character c in word // 產生所有前綴\n\n               → Update prefix = prefix + c // 擴展前綴\n\n               → Decision: For each suffix starting at position j? // 產生所有後綴\n\n                    → Step 5: For j from 0 to length(word)-1\n\n                        → suffix = word.substring(j) // 從 j 開始到結尾\n\n                        → key = prefix + \"#\" + suffix // 組合鍵\n\n                        → Decision: If key not in map or map[key] < i? // 更新最大索引\n\n                            Yes → map[key] = i // 存入最大索引\n\n                    → End For suffix\n\n               → End Decision: suffix\n\n           → End For 前綴\n\n           → Decision: After loop, also need to handle empty prefix? Already handled\n\n        No  → End Decision\n\n    → End Decision: If word is empty\n\n→ End For words\n\n→ End // 構造完成\n\n→ Step 6: f(pref, suff) // 查詢方法\n\n    → Decision: key = pref + \"#\" + suff\n\n    → Decision: If key in map? // 是否存在\n\n        Yes → Return map[key] // 取得最大索引\n\n        No  → Return -1 // 無符合\n\n→ End // 方法結束\n\nBut we need to produce more concise lines. Use arrows.\n\nWe need to use \"Decision:\" and \"Yes →\" \"No →\".\n\nBetter to structure: Start, Step 1, etc.\n\nWe need to include arrow '→' for each line.\n\nLet's craft the final output.\n\nAlso we need to include \"End\" after the construction.\n\nBut we need to produce code for both constructor and f method.\n\nAlso we might need to include initialization of data structures.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: WordFilter(words) // 建構子接收單字列  \n→ Step 2: Initialize prefixSuffixToIndex ← empty hash map // 用來儲存 (前綴#後綴) → 最大索引  \n→ Step 3: For i, w in enumerate(words) // 逐個處理每個單字  \n  → Decision: w is empty? // 處理空字，直接跳過  \n   Yes → Continue // 跳過空字  \n   No → Decision: prefix ← \"\" // 初始前綴  \n     → Step 4: For each char c in w // 產生所有前綴  \n      → prefix ← prefix + c // 擴展前綴  \n      → Decision: j from 0 to len(w)-1 // 產生所有後綴  \n       Yes → Step 5: suffix ← w[j:] // 從位置 j 到結尾  \n        → key ← prefix + \"#\" + suffix // 組合鍵  \n        → Decision: key not in map or map[key] < i? // 是否需要更新最大索引  \n          Yes → map[key] ← i // 存入或更新最大索引  \n          No → Skip // 已有更大的索引  \n        → End Decision: 更新索引  \n       → End For j // 後綴完成  \n      → End Decision: 後綴  \n     → End For c // 前綴完成  \n    → End Decision: 前綴  \n  → End Decision: w 是否空  \n→ End For i, w // 所有單字已處理  \n→ End // 建構完成  \n\n→ Step 6: f(pref, suff) // 查詢方法  \n  → key ← pref + \"#\" + suff // 組合查詢鍵  \n  → Decision: key in prefixSuffixToIndex? // 是否存在此鍵  \n   Yes → Return prefixSuffixToIndex[key] // 取得最大索引  \n   No  → Return -1 // 無符合條件的單字  \n→ End // 方法結束"
    },
    {
      "title": "IPO",
      "source_file": "Leetcode/leetcode502.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpq51g8cgl.py\", line 44, in <module>\n    vars_dict = parse_input()\n                ^^^^^^^^^^^^^\n  File \"/tmp/tmpq51g8cgl.py\", line 40, in parse_input\n    vars_dict[key.strip()] = eval(value.strip())\n                             ^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjp7q06gl.py\", line 44, in <module>\n    vars_dict = parse_input()\n                ^^^^^^^^^^^^^\n  File \"/tmp/tmpjp7q06gl.py\", line 40, in parse_input\n    vars_dict[key.strip()] = eval(value.strip())\n                             ^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport heapq\n\ndef maximize_capital(k, W, profits, capital):\n    # 將專案按所需資本升序排序\n    projects = sorted(zip(capital, profits))\n    max_heap = []                # 儲存可用專案的利潤（取最大值用負值）\n    i = 0                        # 追蹤已加入堆的專案索引\n    n = len(profits)\n\n    for _ in range(k):\n        # 把目前資本可啟動的所有專案加入最大堆\n        while i < n and projects[i][0] <= W:\n            heapq.heappush(max_heap, -projects[i][1])\n            i += 1\n\n        if not max_heap:         # 沒有可啟動的專案，直接結束\n            break\n\n        # 取利潤最大的專案，並更新資本\n        W += -heapq.heappop(max_heap)\n\n    return W\n\ndef parse_input():\n    \"\"\"\n    解析形如：\n    k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n    的輸入，支持任何合法的整數或整數列表。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return None\n    parts = [p.strip() for p in data.split(',')]\n    vars_dict = {}\n    for part in parts:\n        if not part:\n            continue\n        key, value = part.split('=', 1)\n        vars_dict[key.strip()] = eval(value.strip())\n    return vars_dict\n\nif __name__ == \"__main__\":\n    vars_dict = parse_input()\n    if vars_dict is None:\n        sys.exit(0)\n    k = vars_dict.get('k')\n    w = vars_dict.get('w')\n    profits = vars_dict.get('profits')\n    capital = vars_dict.get('capital')\n    result = maximize_capital(k, w, profits, capital)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: maximize capital after selecting at most k projects with profit and capital requirements. Classic problem: choose at most k projects with enough capital, maximize final capital. Known solution: use min-heap for capital sorted ascending; max-heap for profits. Or use sort by capital then iterate selecting profits when capital available. The algorithm:\n\n- Pair projects as (capital, profit)\n- Sort by capital ascending\n- Use max-heap for profits of projects whose capital <= current capital\n- For i from 0 to k-1:\n   - while next project has capital <= current capital: push its profit into max-heap\n   - if max-heap empty: break (no further project)\n   - pop max profit, add to capital\n- return capital\n\nNow produce virtual code lines with explanation. Each line: \"虛擬碼步驟 // 解釋\" using arrows. Use Start, End, Decision. Also may need loops. We can structure as:\n\nStart\n→ Step: 將每個專案轉為 (capital, profit) 並放入 list // 資料結構準備\n→ Step: 將 list 按 capital 升序排序 // 方便篩選可投資專案\n→ Step: 初始化最大堆 profitHeap // 用於取最大利潤\n→ Step: 初始化 index = 0 // 用於遍歷排序後的專案\n→ Step: currentCapital = w // 初始資本\n→ Decision: 迴圈次數 < k? // 需挑選至多 k 個專案\n    Yes → Step: while index < n AND list[index].capital <= currentCapital:\n        → Step: push list[index].profit 到 profitHeap // 可開始的專案加入利潤堆\n        → Step: index += 1 // 移至下一個專案\n    → Decision: profitHeap 不是空? // 是否有可投資專案\n        Yes → Step: maxProfit = pop 最大值 from profitHeap // 取最大利潤\n        → Step: currentCapital += maxProfit // 資本增加\n        No  → Step: break // 無可投資專案，終止\n    → Step: 迴圈次數 += 1 // 進行下一次選擇\n→ End // 結束迴圈\n→ Step: return currentCapital // 最終資本\n\nBut need to use arrow style: \"→\" etc. Also need to use \"Decision:\" lines. Ensure each line has one arrow. For while loop we can incorporate as separate Decision and then Steps inside. But we can simplify: use \"→ Decision: While index < n AND list[index].capital <= currentCapital?\" with Yes → etc. But we can embed.\n\nLet's produce line by line.\n\nWe also need to mention variables: n, k, w, profits, capital. Use pseudocode.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將每個專案轉為 (capital, profit) 並放入 list // 準備專案資料  \n→ Step 2: 將 list 按 capital 升序排序 // 方便後續按資本篩選  \n→ Step 3: 初始化最大堆 profitHeap // 用於快速取得可用專案中的最大利潤  \n→ Step 4: 初始化 index = 0 // 追蹤已加入堆中的專案位置  \n→ Step 5: currentCapital = w // 記錄目前可用資本  \n→ Decision: 已選專案數 < k? // 判斷是否還能挑選專案  \n Yes → Step 6: Decision: index < n AND list[index].capital <= currentCapital? // 是否有可用專案  \n  Yes → Step 7: push list[index].profit 到 profitHeap // 將可投資專案的利潤加入堆  \n   → Step 8: index += 1 // 移至下一個專案  \n   → Decision: index < n AND list[index].capital <= currentCapital? // 仍有可用專案？  \n    Yes → 回到 Step 7  \n    No → 回到 Decision: 已選專案數 < k?  \n  No  → Decision: profitHeap 不是空? // 是否還有可選擇的專案  \n   Yes → Step 9: maxProfit = pop 最大值 from profitHeap // 取最大利潤  \n    → Step 10: currentCapital += maxProfit // 資本增加  \n    → Step 11: 已選專案數 += 1 // 更新已選專案計數  \n   No  → Step 12: break // 無可投資專案，結束迴圈  \n→ End // 程式執行結束  \n→ Step 13: return currentCapital // 回傳最終資本  \n\n這份虛擬碼逐行說明了從資料準備、排序、使用最大堆選取最大利潤，到在資本允許的情況下最多挑選 k 個專案的完整流程。"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()()\", \"(a())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\nfrom collections import deque\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"\n        Remove the minimum number of invalid parentheses to make the input string valid.\n        Return all unique results.\n        \"\"\"\n        def is_valid(string: str) -> bool:\n            count = 0\n            for ch in string:\n                if ch == '(':\n                    count += 1\n                elif ch == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        # BFS level by level to guarantee minimum deletions\n        level = {s}\n        while level:\n            # Find all valid strings at the current level\n            valid = [item for item in level if is_valid(item)]\n            if valid:\n                return valid\n            # Generate next level by removing one parenthesis from each string\n            next_level = set()\n            for item in level:\n                for i in range(len(item)):\n                    if item[i] in ('(', ')'):\n                        next_item = item[:i] + item[i+1:]\n                        next_level.add(next_item)\n            level = next_level\n        return []\n\ndef parse_input(line: str) -> str:\n    \"\"\"\n    Extract the string value from an input line like:\n    s = \"()())()\"\n    or just a raw string.\n    \"\"\"\n    # Try to find content inside quotes\n    m = re.search(r\"\"\"(['\"])(.*?)\\1\"\"\", line)\n    if m:\n        return m.group(2)\n    # Fallback: strip leading 's =' if present\n    line = line.strip()\n    if line.lower().startswith('s'):\n        parts = line.split('=', 1)\n        if len(parts) == 2:\n            return parts[1].strip().strip('\\'\"')\n    return line\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # If multiple lines, join them; treat first non-empty line as input string\n    lines = [ln for ln in data.splitlines() if ln.strip()]\n    s = parse_input(lines[0])\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm: remove minimum parentheses to make valid, output all unique results. Classic problem. Provide virtual code line-by-line with explanation. Use Start, Decision, etc. No actual code. Should cover algorithm: compute left/right removals, DFS/backtracking. Steps: compute max removals needed, then recursively build. Provide pseudocode lines. Each line with explanation. Use arrow.\n\nLet's craft steps:\n\nStart\n→ Compute total removals: count mismatched parentheses in left to right (for left) and right to left (for right)\n→ Call recursive function dfs(index, leftCount, rightCount, lrem, rrem, expr, resultSet)\nDecision: if lrem==0 and rrem==0? etc.\n\nWe need to produce a sequence of lines with arrow. Use indents? Provide decision arrows. We'll represent recursion lines.\n\nLet's craft.\n\nMake sure each line ends with // explanation.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算需要刪除的左括號數 lrem 與右括號數 rrem  \n    // 從左到右遍歷字串，當遇到 ')' 且左括號不足時 rrem++，否則左括號數加 1  \n    // 從右到左遍歷字串，當遇到 '(' 且右括號不足時 lrem++，否則右括號數加 1  \n→ Step 2: 建立結果集合 resultSet 用於存放所有唯一合法字串  \n→ Step 3: 呼叫遞迴函式 dfs(0, 0, 0, lrem, rrem, \"\", resultSet)  \n    // index: 當前處理的字元位置  \n    // leftCount: 目前已加入表達式中的 '(' 數  \n    // rightCount: 目前已加入表達式中的 ')' 數  \n    // lrem, rrem: 尚未刪除的左/右括號數  \n    // expr: 當前構造的字串  \n→ Decision: 如果 index == s.length()  \n    Yes → Decision: 如果 lrem == 0 AND rrem == 0  \n        Yes → Step 4: 把 expr 加入 resultSet  \n        No  → Step 5: 回傳（此路徑無效，因為還有剩餘刪除）  \n    No  → Step 6: 取得當前字元 ch = s.charAt(index)  \n→ Decision: 如果 ch 是字母  \n    Yes → Step 7: dfs(index+1, leftCount, rightCount, lrem, rrem, expr+ch, resultSet)  \n    No  → // ch 是括號  \n        Decision: 如果 ch == '('  \n            Yes → // 兩種選擇  \n                Decision: 如果 lrem > 0  \n                    Yes → Step 8: dfs(index+1, leftCount, rightCount, lrem-1, rrem, expr, resultSet)  \n                    // 刪除這個 '('，不將它加入 expr  \n                No  → Step 9: dfs(index+1, leftCount+1, rightCount, lrem, rrem, expr+ch, resultSet)  \n                // 仍保留 '('，左括號數加 1  \n            No  → // ch == ')'  \n                Decision: 如果 rightCount > leftCount  \n                    Yes → // 兩種選擇  \n                        Decision: 如果 rrem > 0  \n                            Yes → Step 10: dfs(index+1, leftCount, rightCount, lrem, rrem-1, expr, resultSet)  \n                            // 刪除這個 ')'  \n                        No  → Step 11: dfs(index+1, leftCount, rightCount+1, lrem, rrem, expr+ch, resultSet)  \n                        // 保留 ')'，右括號數加 1  \n                    No  → // 右括號數已不小於左括號數，無法保留此 ')'  \n                        Decision: 如果 rrem > 0  \n                            Yes → Step 12: dfs(index+1, leftCount, rightCount, lrem, rrem-1, expr, resultSet)  \n                            // 刪除此 ')'  \n                        No  → Step 13: 回傳（此路徑無效）  \n→ End // 程式執行結束，resultSet 包含所有合法且最少刪除的字串  \n```"
    },
    {
      "title": "Find K Pairs with Smallest Sums",
      "source_file": "Leetcode/leetcode373.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo1zil_3s.py\", line 36, in <module>\n    nums1, nums2, k = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpo1zil_3s.py\", line 31, in parse_input\n    data = ast.literal_eval(raw)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7e9b5a11a750>"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2yok9k01.py\", line 36, in <module>\n    nums1, nums2, k = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2yok9k01.py\", line 31, in parse_input\n    data = ast.literal_eval(raw)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x71421511a750>"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nimport heapq\nimport json\n\ndef k_smallest_pairs(nums1, nums2, k):\n    if not nums1 or not nums2 or k <= 0:\n        return []\n    heap = []\n    res = []\n    # 初始將 nums1 的前 min(k, len(nums1)) 個元素與 nums2[0] 形成對\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    # 取出最小總和的對，並將其同一列的下一個元素推入堆\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))\n    return res\n\ndef parse_input(raw):\n    # 去除可能的外層引號\n    raw = raw.strip()\n    if (raw.startswith(\"'\") and raw.endswith(\"'\")) or (raw.startswith('\"') and raw.endswith('\"')):\n        raw = raw[1:-1]\n    # 把 \"var = value\" 轉成 \"var: value\"\n    raw = re.sub(r'(\\w+)\\s*=\\s*', r'\\1: ', raw)\n    raw = '{' + raw + '}'\n    data = ast.literal_eval(raw)\n    return data['nums1'], data['nums2'], data['k']\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums1, nums2, k = parse_input(raw_input)\n    result = k_smallest_pairs(nums1, nums2, k)\n    print(json.dumps(result, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to find k pairs with smallest sums from two sorted arrays. This is classic problem: k smallest pairs. Use min-heap. We'll outline steps: start, push initial pairs (nums1[i], nums2[0])? Actually typical approach: push first pair (nums1[0], nums2[0]) with sum, and track indices (i,j). Use heap of tuples. While result size < k and heap not empty, pop smallest, add to result, then if j+1 < len(nums2), push (i, j+1). Also we can pre-fill up to min(k, len(nums1)) pairs (i,0). Implementation in virtual code. Need to use Decision nodes for bounds.\n\nMake sure to use required format: each line: \"虛擬碼步驟 // 解釋\". Use arrow: \"→\". Use Decision: \"Decision: 如果...\" and Yes/No branches.\n\nWe must not output actual code but pseudo steps.\n\nLet's create:\n\nStart\n→ Initialize result list // 存放 k 個最小總和的對\n→ Initialize min-heap // 儲存候選對的優先佇列\n→ 對 i from 0 to min(k, length(nums1))-1\n    → Push (nums1[i], nums2[0], i, 0) 到 min-heap // 先把第一列所有元素與第二列第一個元素組合\n→ While result.size < k AND min-heap not empty\n    → Pop min pair (u,v,i,j) from min-heap // 取得目前最小總和的對\n    → Append (u,v) 到 result // 將對加入答案\n    → Decision: j + 1 < length(nums2)? // 檢查是否還有下一個 j\n        Yes → Push (nums1[i], nums2[j+1], i, j+1) 到 min-heap // 推進同一行的下一個\n        No  → // 沒有更多 j，跳過\nEnd\n\nWe can add final output step.\n\nAdd details: maybe we need to store sum in heap to compare.\n\nLet's craft with arrows and decisions accordingly.\n\nMake sure each line has '//' comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化 result 為空列表 // 用來存放最終的 k 個對  \n→ 初始化 min-heap 為空 // 儲存候選對及其總和，按最小總和排序  \n→ 對 i 從 0 到 min(k, length(nums1)) - 1 做  \n  → 將 (nums1[i], nums2[0], i, 0) 推入 min-heap // 先把每個 nums1 元素與 nums2 第一個元素組合，並記錄索引  \n→ Decision: result.size < k 且 min-heap 不為空? // 需要再找對且還有候選  \n  Yes → 從 min-heap 取出最小總和對 (u, v, i, j)  \n   → 將 (u, v) 加入 result // 加入答案列表  \n   → Decision: j + 1 < length(nums2)? // 同一 i 的下一個 j 是否存在  \n    Yes → 將 (nums1[i], nums2[j+1], i, j+1) 推入 min-heap // 推進同一行的下一個對  \n    No → // 沒有更多 j，什麼也不做  \n  No → // result 已滿或 min-heap 空，結束循環  \nEnd // 程式執行結束，result 為所求的 k 個最小總和對列表"
    },
    {
      "title": "Top K Frequent Words",
      "source_file": "Leetcode/leetcode692.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2",
          "expected_output": "[\"i\",\"love\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcdg60m6t.py\", line 28, in <module>\n    k_part = parts[1].strip()\n             ~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4",
          "expected_output": "[\"the\",\"is\",\"sunny\",\"day\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo4czqas8.py\", line 28, in <module>\n    k_part = parts[1].strip()\n             ~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import Counter\n\ndef top_k_frequent(words, k):\n    \"\"\"Return the k most frequent words sorted by frequency (descending) and\n    lexicographical order for ties.\"\"\"\n    freq = Counter(words)\n    # Sort by (-frequency, word) so that higher frequency comes first\n    # and for equal frequency, words are sorted alphabetically.\n    sorted_words = sorted(freq.items(), key=lambda x: (-x[1], x[0]))\n    # Extract only the words for the top k entries\n    return [word for word, _ in sorted_words[:k]]\n\nif __name__ == \"__main__\":\n    # Read entire stdin input\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Expected format: words = [...], k = ...\n    # Remove the variable names and split by ', k ='\n    # This approach works even if the list contains commas.\n    cleaned = raw_input.replace('words =', '').replace('k =', '').strip()\n    parts = cleaned.split(', k =')\n    words_part = parts[0].strip()\n    k_part = parts[1].strip()\n\n    # Safely evaluate the list and convert k to integer\n    words = ast.literal_eval(words_part)\n    k = int(k_part)\n\n    result = top_k_frequent(words, k)\n    # Output in JSON format to match examples\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to generate pseudocode step by step. Use Start, End, Decision. We need to produce steps: input array words and integer k. Count frequencies. Sort by freq desc then lex asc. Pick top k. Return list. Provide explanations per line.\n\nLet's craft pseudocode:\n\nStart\n→ Step 1: Initialize frequency map // count words\n→ For each word in words: // iterate array\n    → Increment map[word]\n→ Step 2: Convert map entries to list of (word, freq)\n→ Step 3: Sort list with custom comparator: freq desc, word asc\n→ Step 4: Initialize result list\n→ For i from 0 to min(k, list.size)-1:\n    → Add list[i].word to result\n→ Return result\nEnd\n\nWe need decision? maybe not needed.\n\nBut we could use decision for sorting? not necessary. We can just show sorting step.\n\nMake sure each line has '虛擬碼步驟 // 解釋'.\n\nAlso include Start and End.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空的頻率映射 map // 用於統計每個字串出現的次數  \n→ For each word in words: // 遍歷輸入字串陣列  \n    → Increment map[word] // 若不存在則自動設定為 1，已存在則 +1  \n→ Step 2: 將 map 轉換為列表 pairs = [] // 存放 (word, frequency) 兩元組  \n→ For each entry (key, value) in map: // 讀取映射中的每一對  \n    → Append (key, value) to pairs // 建立 (字串, 次數) 的資料結構  \n→ Step 3: 對 pairs 進行排序，使用自訂比較器:  \n    → 先以 frequency 降序排列  \n    → 同頻度時以字串的字典序升序排列 // 確保符合題目要求  \n→ Step 4: 初始化結果列表 result = [] // 存放最終的 k 個字串  \n→ For i from 0 to min(k, pairs.size) - 1: // 取前 k 個項目  \n    → Append pairs[i].word to result // 只取字串部分加入結果  \n→ Return result // 回傳排序好的 k 個字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '457'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        # 逐位相加，從最低位開始\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        # 反轉結果並合併成字串\n        return ''.join(reversed(res))\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 從輸入中抓取所有數字字串（能處理 \"num1 = \\\"11\\\", num2 = \\\"123\\\"\" 或 兩個空格分隔的數字）\n    nums = re.findall(r'\\d+', data)\n    if len(nums) < 2:\n        return\n    num1, num2 = nums[0], nums[1]\n\n    solution = Solution()\n    result = solution.addStrings(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line. The algorithm: add two string numbers as if manual addition. Steps: Start, get length, set carry, loop from end, compute digit sums, build result, reverse, End.\n\nWe need to use virtual code with arrows and decisions.\n\nLet's produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 獲取 num1 和 num2 的長度 // 取得兩個字串長度\n→ Step 2: 初始化索引 i = len(num1)-1, j = len(num2)-1, carry = 0, result = 空字串 // 設定指標與暫存\n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還有位需要處理\n    Yes → Step 3: 計算 digit1 = (i >= 0)? num1[i]-'0' : 0 // 取得 num1 目前位數\n        → Step 4: 計算 digit2 = (j >= 0)? num2[j]-'0' : 0 // 取得 num2 目前位數\n        → Step 5: sum = digit1 + digit2 + carry // 位數總和\n        → Step 6: carry = sum / 10 // 新的進位\n        → Step 7: result = (sum % 10) + result // 將位數加到結果字串前面\n        → Step 8: i--, j-- // 移動指標\n        → Decision: i >= 0 OR j >= 0 OR carry > 0? // 再次判斷\n            Yes → 回到上面同樣處理\n            No → → Step 9: 如果 result 為空，則 result = \"0\" // 處理兩數都是 0 的情況\n→ End // 程式結束\n\nBut we must show the decision branching with Yes→, No→.\n\nWe need to use virtual code lines sequentially with indentation for decisions? In example, decisions had indentation. We'll follow similar style.\n\nBetter to use: Decision: i>=0 OR j>=0 OR carry>0? // ... \n    Yes → Step 3...\n    No  → Step 9...\n\nBut we need to show the loop. We could structure using recursion or repeat, but in virtual code we can indicate loop by repeating the steps. Use Decision with Yes→ and No→ inside.\n\nLet's produce final output with each line and comment.\n\nWe should include arrows in steps.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 num1 與 num2 的長度 // 取得兩個字串的長度  \n→ Step 2: 設定指標 i = len(num1)-1, j = len(num2)-1, 進位 carry = 0, 結果字串 result = \"\" // 初始化指標與暫存  \n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還有位需要處理  \n    Yes → Step 3: 取 digit1 = (i >= 0) ? num1[i] - '0' : 0 // 取得 num1 目前位數，若指標已越界則為 0  \n        → Step 4: 取 digit2 = (j >= 0) ? num2[j] - '0' : 0 // 取得 num2 目前位數，若指標已越界則為 0  \n        → Step 5: sum = digit1 + digit2 + carry // 計算兩位數字與進位之和  \n        → Step 6: carry = sum / 10 // 計算新的進位（十進位）  \n        → Step 7: result = (sum % 10) + result // 將此位數字加到結果字串前面  \n        → Step 8: i--, j-- // 指標向左移動  \n        → Decision: i >= 0 OR j >= 0 OR carry > 0? // 再次判斷是否還有位需要處理  \n            Yes → 回到 Step 3 進行下一位加法  \n            No  → → Step 9: 如果 result 為空，則 result = \"0\" // 處理兩數都是 0 的特殊情況  \n→ End // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,2,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 2, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nfrom collections import defaultdict\nimport json\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立每個數值對應到所有索引的字典\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機選擇一個符合 target 的索引\n        return random.choice(self.indices[target])\n\ndef main():\n    # 從 stdin 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 分離操作序列與對應的參數\n    parts = data.split('],', 1)\n    ops_str = parts[0] + ']'   # 結束第一個列表\n    args_str = parts[1]\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    results = []\n    sol = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            sol = Solution(arg[0])\n            results.append(None)\n        else:\n            results.append(getattr(sol, op)(arg[0]))\n\n    # 將結果輸出為 JSON 格式，Python 的 None 對應到 JSON 的 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, each line: \"虛擬碼步驟 // 解釋\" using arrows etc. Should not output actual code. Provide steps to initialize and pick method. Should mention reservoir sampling algorithm. Also include decision steps. Use Start, End, Decision etc. Provide line per step. Probably need to split into initialization steps and pick function. Use virtual code to explain logic. Ensure each line has a comment. Use arrow. Use \"→\" etc. Provide maybe some steps like: Start, Step 1: Input array, Step 2: Store array, Step 3: End initialization. Then pick: Step 1: Input target, Step 2: Initialize count, Step 3: Iterate through array with index, Step 4: If nums[i]==target, increment count, maybe random selection logic. Provide decision: If random condition, select index. Provide final Step: Return selected index. Provide End. Need to reflect reservoir sampling: probability 1/count. So at each match, generate random number between 0 and count-1, if 0 choose index.\n\nLet's produce virtual code lines:\n\nStart // 程式開始執行\n→ Step 1: Initialize class variable array // 存儲傳入的整數陣列\n→ Step 2: Store reference to nums in this.nums // 方便後續查詢\n→ End // 初始化結束\n\nThen pick method:\n\nStart // pick 方法開始\n→ Step 1: Input target // 取得要搜尋的目標值\n→ Step 2: Set chosenIndex = -1 // 預設未選中\n→ Step 3: Set count = 0 // 追蹤符合目標的個數\n→ Decision: 是否已遍歷完陣列? // 判斷是否繼續迴圈\n    No  → Step 4: 取下當前索引 i // 從 0 開始遞增\n    No  → Step 5: 若 nums[i] == target? // 檢查此索引是否符合\n        Yes → Step 6: count = count + 1 // 符合則計數加一\n        Yes → Decision: 生成隨機數 r ∈ [0, count-1]? // 決定是否選中\n            Yes → Step 7: chosenIndex = i // 隨機選中此索引\n            No  → No change // 保持上一次選中的索引\n    No → Continue loop to next i\n→ End // pick 方法結束\n→ Step 8: Return chosenIndex // 回傳等機會選中的索引\n\nBut need to be more explicit with arrows and decision labels.\n\nMake sure to use \"→\" before steps, \"Decision:\" lines with indentation.\n\nLet's format properly.\n\nAlso note we need to handle loop; maybe \"Decision: i < n?\" etc.\n\nWe can produce:\n\nStart // 程式開始\n→ Step 1: Store nums in this.nums // 以備後用\n→ End // 初始化結束\n\nStart // pick 方法開始\n→ Step 1: Set chosenIndex = -1 // 初始未選中\n→ Step 2: Set count = 0 // 目標出現次數\n→ Decision: i < this.nums.length? // 迴圈判斷\n    Yes → Step 3: If this.nums[i] == target? // 檢查是否等於目標\n        Yes → Step 4: count = count + 1 // 目標數量加一\n        Yes → Decision: 隨機數 r ∈ [0, count-1] == 0? // 隨機選中條件\n            Yes → Step 5: chosenIndex = i // 選中當前索引\n            No  → No change // 留下之前選中\n    No → No change // 不符合則忽略\n    Yes → i = i + 1 // 進行下一個索引\n    No → No // 迴圈結束\n→ Step 6: Return chosenIndex // 回傳等概率選中的索引\nEnd // pick 方法結束\n\nBut need to keep lines simple. Use arrows and decisions. Let's craft final answer.\n\nAlso we can use \"→ Decision:\" and indent sub-steps.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Store input array nums into class member this.nums // 存儲傳入的整數陣列，方便後續使用\n→ End // 初始化結束\n\nStart // pick 方法開始\n→ Step 1: Initialize chosenIndex ← -1 // 初始時未選中任何索引\n→ Step 2: Initialize count ← 0 // 目標值出現的次數計數器\n→ Decision: i < this.nums.length? // 迴圈判斷是否還有元素可處理\n    Yes → Step 3: If this.nums[i] == target? // 檢查當前索引的值是否等於目標\n        Yes → Step 4: count ← count + 1 // 目標值出現一次，計數器加一\n        Yes → Decision: randomInt(0, count-1) == 0? // 隨機決定是否選中此索引\n            Yes → Step 5: chosenIndex ← i // 以 1/count 的機率選中此索引\n            No  → No change // 保持上一個已選中的索引\n    No → No change // 非目標值，直接略過\n→ Decision: i + 1 < this.nums.length? // 檢查是否還有下一個索引\n    Yes → i ← i + 1 → Go back to Decision: i < this.nums.length?\n    No  → No // 迴圈結束\n→ Step 6: Return chosenIndex // 回傳等機會選中的索引\nEnd // pick 方法結束"
    },
    {
      "title": "First Unique Character in a String",
      "source_file": "Leetcode/leetcode387.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"loveleetcode\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        },
        {
          "example_index": 2,
          "input": "s = \"aabb\"",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport collections\n\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        # 统计每个字符出现的次数\n        count = collections.Counter(s)\n        # 再次遍历字符串，找到第一个计数为1的字符\n        for idx, char in enumerate(s):\n            if count[char] == 1:\n                return idx\n        # 如果没有非重复字符，返回 -1\n        return -1\n\ndef main():\n    # 读取标准输入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 尝试从输入中提取字符串\n    s = data\n    # 处理类似 \"s = \\\"leetcode\\\"\" 的格式\n    if '=\"' in s:\n        start = s.find('\"')\n        end = s.rfind('\"')\n        if start != -1 and end != -1 and end > start:\n            s = s[start + 1:end]\n    elif \"='\" in s:\n        start = s.find(\"'\")\n        end = s.rfind(\"'\")\n        if start != -1 and end != -1 and end > start:\n            s = s[start + 1:end]\n    # 否则直接使用输入的内容\n\n    # 调用解法并输出结果\n    solution = Solution()\n    result = solution.firstUniqChar(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. Use Start, End, Decision. We must not output actual code. Just virtual steps. Provide explanation. Use arrows →. Let's craft:\n\nStart\n→ Step 1: Initialize an empty hash map to store character counts // 用於統計每個字符出現次數\n→ Step 2: Iterate through string s to count occurrences // 第一次遍歷統計頻率\n    For each character c in s:\n        If c not in map → map[c] = 1\n        Else → map[c] += 1\n→ Step 3: Iterate through string s again to find first unique character // 第二次遍歷尋找第一個頻率為1的字符\n    For index i, character c in s:\n        If map[c] == 1 → Return i // 找到首個非重複字符的索引\n→ Decision: 若未找到任何非重複字符? // 檢查是否所有字符都有重複\n    Yes → Return -1 // 沒有非重複字符，返回 -1\nEnd\n\nBut must follow the format: each line \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow syntax. We need to indent for decisions. The structure:\n\nStart // 程式開始執行\n→ Step 1: 初始化空字典 charCount // 用於統計每個字符出現次數\n→ Step 2: 第一次遍歷 s 以統計字符頻率\n    → For 每個字符 c in s:\n        → Decision: c 是否在 charCount 中?\n            Yes → charCount[c] = charCount[c] + 1\n            No  → charCount[c] = 1\n→ Step 3: 第二次遍歷 s 尋找第一個頻率為1的字符\n    → For 每個索引 i, 字符 c in s:\n        → Decision: charCount[c] == 1 ?\n            Yes → Return i // 找到首個非重複字符\n→ Decision: 若未找到任何非重複字符?\n    Yes → Return -1 // 所有字符均重複\nEnd // 程式執行結束\n\nNeed to ensure each line has \"虛擬碼步驟\" plus explanation after //.\n\nWe need to use \"Start\", \"End\", \"Decision:\" exactly as specified. Use arrow for steps: \"→\". For nested decisions use indentation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 charCount // 用於統計每個字符出現次數  \n→ Step 2: 第一次遍歷 s 以統計字符頻率  \n  → For 每個字符 c in s:  \n    → Decision: c 是否在 charCount 中?  \n     Yes → charCount[c] = charCount[c] + 1 // 已存在，頻率加 1  \n     No  → charCount[c] = 1 // 首次遇到，頻率設為 1  \n→ Step 3: 第二次遍歷 s 尋找第一個頻率為 1 的字符  \n  → For 每個索引 i, 字符 c in s:  \n    → Decision: charCount[c] == 1 ?  \n     Yes → Return i // 找到首個非重複字符的索引  \n→ Decision: 若未找到任何非重複字符?  \n  Yes → Return -1 // 所有字符均重複，返回 -1  \nEnd // 程式執行結束"
    },
    {
      "title": "Lexicographical Numbers",
      "source_file": "Leetcode/leetcode386.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,10,11,12,13,2,3,4,5,6,7,8,9]'\nGot (Norm):      '[1,10,11,12,13,14,15,16,17,18,19,2,3]'\n--- (Raw) ---\nRaw Expected: '[1,10,11,12,13,2,3,4,5,6,7,8,9]'\nRaw Got:      '[1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3]'"
        }
      ],
      "generated_code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，支持 \"n = 13\" 或直接 \"13\"\n    if '=' in data:\n        _, value = data.split('=', 1)\n        n = int(value.strip())\n    else:\n        n = int(data)\n\n    result = []\n    curr = 1\n    for _ in range(n):\n        result.append(curr)\n        if curr * 10 <= n:\n            curr *= 10\n        else:\n            if curr % 10 != 9 and curr + 1 <= n:\n                curr += 1\n            else:\n                while curr % 10 == 9:\n                    curr //= 10\n                curr += 1\n\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "virtual_code": "Thinking...\nWe need produce virtual code for algorithm generating lexicographical order from 1 to n, O(n) time, O(1) extra space. It's like lexical DFS iterative using next function. We produce pseudocode lines with arrows. Provide explanation after each line. Ensure no actual code. Let's produce algorithm: Start, set curr=1, output curr, for count from 1 to n-1: if curr*10 <= n then curr*=10 else if curr%10 != 9 and curr+1 <= n then curr++ else while (curr/10)%10 == 9 or curr/10 == 0? we need to move up. Standard algorithm: If curr*10 <= n, curr*=10; else if curr%10 != 9 and curr+1 <= n, curr++; else curr/=10 until last digit not 9 and curr+1 <= n; curr++; Output curr. Use O(1) memory.\n\nWe'll produce virtual code step by step. Let's create lines:\n\nStart // 開始\n→ Step 1: 定義變數 curr = 1, count = 1 // 初始化當前數字為 1，已輸出的數量為 1\n→ Step 2: 輸出 curr // 第一個數字 1\n→ Decision: 是否已輸出 n 個數? // 檢查是否完成\n    Yes → End // 完成後結束\n    No  → →\n\nWe need a loop. We'll use while count < n. Provide pseudo:\n\n→ Step 3: While count < n: // 迴圈直到輸出 n 個數\n\nInside loop: compute next.\n\nWe'll produce pseudocode:\n\n→ Decision: 若 curr*10 <= n? // 看是否可以進一步深度\n    Yes → curr = curr * 10; // 進入子節點\n    No  → Decision: 若 curr % 10 != 9 且 curr + 1 <= n? // 能否右移\n        Yes → curr = curr + 1; // 右移\n        No  → // 需要回溯\n            → Step 4: curr = curr / 10; // 將 curr 上升至父節點\n            → Decision: 仍然 curr % 10 == 9? // 繼續回溯\n                Yes → 循環 Step 4 (使用 while loop)\n                No  → curr = curr + 1; // 最終右移\n    → Step 5: 輸出 curr // 輸出新數字\n    → Step 6: count = count + 1 // 記錄已輸出數量\n\nBut need to structure using arrows and decisions properly. Provide nested decisions maybe. Use \"While\" structure.\n\nLet's craft final virtual code:\n\nStart // 程式開始執行\n→ Step 1: 初始化 curr = 1, count = 1 // 設定當前數字為 1，已輸出數量為 1\n→ Step 2: 輸出 curr // 輸出第一個數字 1\n→ Decision: count == n? // 是否已輸出所有數字\n    Yes → End // 如果已完成則結束\n    No  → →\n\nWe then enter loop:\n\n→ While count < n: // 重複直到輸出 n 個數\n    → Decision: curr * 10 <= n? // 是否可以進一步進入下一層\n        Yes → curr = curr * 10; // 進入子節點\n        No  → Decision: curr % 10 != 9 AND curr + 1 <= n? // 是否可以向右移動\n            Yes → curr = curr + 1; // 向右移動\n            No  → \n                → Step 3: curr = curr / 10; // 回溯到父節點\n                → Decision: curr % 10 == 9 OR curr == 0? // 仍需要回溯\n                    Yes → 循環 Step 3 (持續回溯) // 重複上一步直到可以右移\n                    No  → curr = curr + 1; // 右移完成\n    → Step 4: 輸出 curr // 輸出目前的數字\n    → Step 5: count = count + 1 // 更新已輸出數量\n\nEnd // 程式結束\n\nBut arrow formatting: need \"→\" for each line. Use indentation for nested decisions.\n\nWe should ensure each line ends with // 解釋. Provide arrow at start of each line.\n\nAlso \"While\" maybe represented as \"→ While\". Use \"Decision:\" lines.\n\nLet's craft final output.\n\nAlso we should ensure O(1) space: only variables curr, count, maybe temp.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 curr = 1, count = 1 // 初始化目前數字為 1，已輸出數量為 1  \n→ Step 2: 輸出 curr // 輸出第一個數字 1  \n→ Decision: count == n? // 檢查是否已輸出所有數字  \n  Yes → End // 完成則結束程序  \n  No  →  // 需要繼續輸出剩餘數字  \n\n→ While count < n: // 迴圈直到輸出 n 個數  \n  → Decision: curr * 10 <= n? // 能否進一步往下層深度  \n   Yes → curr = curr * 10; // 進入子節點（把 curr 乘以 10）  \n   No  → Decision: curr % 10 != 9 AND curr + 1 <= n? // 是否可以右移到相鄰數字  \n    Yes → curr = curr + 1; // 右移到下一個數字  \n    No  → \n     → Step 3: curr = curr / 10; // 回溯到父節點  \n     → Decision: curr % 10 == 9 OR curr == 0? // 仍須回溯到可以右移的節點  \n      Yes → (持續執行 Step 3) // 只要最後一位是 9 或已到根節點就回溯  \n      No  → curr = curr + 1; // 右移完成  \n  → Step 4: 輸出 curr // 輸出目前的數字  \n  → Step 5: count = count + 1 // 已輸出數量加 1  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef permute(nums):\n    \"\"\"返回所有排列的列表。\"\"\"\n    res = []\n\n    def backtrack(start):\n        if start == len(nums):\n            res.append(nums[:])          # 复制当前排列\n            return\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]  # 放置元素\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]  # 回溯\n\n    backtrack(0)\n    return res\n\ndef main():\n    # 读取整行输入，例如 \"nums = [1,2,3]\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 提取列表字符串\n    if '=' in data:\n        _, arr_str = data.split('=', 1)\n        arr_str = arr_str.strip()\n    else:\n        arr_str = data.strip()\n    # 解析列表\n    nums = ast.literal_eval(arr_str)\n    # 计算排列\n    result = permute(nums)\n    # 输出结果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all permutations of an array of distinct integers. Use typical backtracking algorithm. Use Start, Decision, End. Each line: \"虛擬碼步驟 // 解釋\". Use arrows →. Let's create steps:\n\nStart // 程式開始\n→ Step 1: 定義結果 list // 儲存所有排列\n→ Step 2: 呼叫 Backtrack([], 0) // 從空路徑開始\n→ Subroutine Backtrack(current, startIndex) // 定義遞迴\n    → Decision: 是否已經到達陣列末尾? // 判斷是否完成排列\n        Yes → Step 3: 把 current 複製加入結果 // 完整排列加入結果\n        No  → Decision: 遍歷所有未使用的索引\n            Yes → Step 4: 將 nums[index] 加入 current // 選擇下一個元素\n            → Step 5: 呼叫 Backtrack(current, startIndex+1) // 繼續遞迴\n            → Step 6: 從 current 移除最後一個元素 // 回溯\n→ Step 7: 返回結果 // 結束\nEnd // 程式結束\n\nBut we need to include arrows appropriately. Need to format as lines.\n\nAlso we must mention usage of a visited set or swapping method. Let's use swapping approach: in place permutation by swapping. So steps:\n\nStep 1: define result list // store permutations\nStep 2: define recursive function permute(index) // index indicates current position\nDecision: index == n? // check if reached end\n    Yes -> copy current array to result\n    No -> Decision: for i in range(index, n) // loop remaining positions\n        Yes -> swap(nums, index, i) // place element\n        → permute(index+1) // recurse\n        → swap(nums, index, i) // backtrack\n\nReturn result.\n\nLet's produce virtual code accordingly. Use arrows: → Step 1: ... etc.\n\nWe need to use \"Decision:\" lines. We also need to use arrows for nested decisions. Provide explanation comments.\n\nLet's craft.\n\nLine 1: Start // 程式開始\n\nLine 2: → Step 1: 定義結果 list result = [] // 用於儲存所有排列\n\nLine 3: → Step 2: 定義遞迴函式 permute(index) // index 為當前排列的位置\n\nLine 4: → Decision: index 等於 nums 長度? // 判斷是否已排列完成\n\nLine 5:     Yes → Step 3: 把 nums 複製進 result // 完整排列加入結果\n\nLine 6:     No  → Decision: i 從 index 到 n-1 迭代? // 迴圈遍歷剩餘位置\n\nLine 7:         Yes → Step 4: 交換 nums[index] 與 nums[i] // 將元素放到當前位置\n\nLine 8:         → Step 5: 呼叫 permute(index+1) // 進一步排列\n\nLine 9:         → Step 6: 交換 nums[index] 與 nums[i] // 回到原始順序\n\nLine 10: → Step 7: 呼叫 permute(0) // 從第一個位置開始排列\n\nLine 11: → Step 8: 返回 result // 完成所有排列\n\nLine 12: End // 程式結束\n\nNeed to format with arrows \"→\" and \"Decision:\" properly. Also substeps under decisions need indentation. Provide each line as separate line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 定義結果 list result = [] // 用於儲存所有排列  \n→ Step 2: 定義遞迴函式 permute(index) // index 為當前排列的位置  \n→ Decision: index 等於 nums 長度? // 判斷是否已排列完成  \n  Yes → Step 3: 把 nums 複製進 result // 完整排列加入結果  \n  No  → Decision: i 從 index 到 n-1 迭代? // 迴圈遍歷剩餘位置  \n   Yes → Step 4: 交換 nums[index] 與 nums[i] // 將元素放到當前位置  \n   → Step 5: 呼叫 permute(index+1) // 進一步排列  \n   → Step 6: 交換 nums[index] 與 nums[i] // 回到原始順序  \n→ Step 7: 呼叫 permute(0) // 從第一個位置開始排列  \n→ Step 8: 返回 result // 完成所有排列  \nEnd // 程式結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,1]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    \"\"\"\n    1. data  : list，儲存所有元素\n    2. idx_map : dict，key 為值，value 為在 data 中所有索引的 set\n    \"\"\"\n\n    def __init__(self):\n        self.data = []  # 動態陣列，支持 O(1) 隨機存取\n        self.idx_map = collections.defaultdict(set)  # value -> set of indices\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入元素，返回是否為第一次插入\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1  # 第一次插入時才回傳 True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"移除一個 val，若存在則回傳 True，否則 False\"\"\"\n        if not self.idx_map[val]:\n            return False\n        # 任意取出一個索引\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n\n        # 覆蓋被移除的位置，除非是最後一個元素\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            # 更新 last_val 的索引集合\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n\n        # 刪除最後一個元素\n        self.data.pop()\n\n        # 若 val 的索引集合已空，刪除鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素，機率與其數量成正比\"\"\"\n        return random.choice(self.data)\n\ndef main() -> None:\n    # 讀取整個輸入，並轉成兩個列表\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 加上括號讓 ast.literal_eval 解析為 tuple\n    ops, args = ast.literal_eval(f\"({raw})\")\n\n    result = []\n    rc = None\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            rc = RandomizedCollection()\n            result.append(None)\n        elif op == \"insert\":\n            result.append(rc.insert(arg[0]))\n        elif op == \"remove\":\n            result.append(rc.remove(arg[0]))\n        elif op == \"getRandom\":\n            result.append(rc.getRandom())\n        else:\n            # 忽略未知操作\n            result.append(None)\n\n    # 使用 json.dumps 以符合 LeetCode 的輸出格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for implementing RandomizedCollection with insert, remove, getRandom, with O(1) average. Use vector and hashmap mapping value to set of indices. Provide step-by-step pseudocode with explanation. Output lines with \"虛擬碼步驟 // 解釋\". Use arrow style. Need to include Start, End, Decision. Provide for class initialization, insert, remove, getRandom. Each line of pseudocode should include comment.\n\nLet's craft. Use pseudocode: \nStart // start\n→ Step 1: Initialize list nums // dynamic array\n→ Step 2: Initialize map valIndices // mapping value -> set of positions\nEnd // initialization done\n\nInsert:\n→ Step 1: Append val to nums // add to end\n→ Step 2: Add index to valIndices[val] // record position\n→ Step 3: If size of set ==1 before insertion? Actually need to return true if val not present. Use Decision: If valIndices[val] had size 1 after addition? Actually if set size was 0 before insertion. So Decision: If val not in map? Use map existence.\n    Yes → Step 4: Return true // first occurrence\n    No  → Step 5: Return false // duplicate\n\nRemove:\n→ Decision: If val not in map? \n    Yes → Step 1: Return false\n    No  → Step 2: Pick any index idx from valIndices[val] // arbitrary\n    Step 3: Get last element lastVal and lastIndex = nums.size()-1\n    Step 4: Overwrite nums[idx] = lastVal\n    Step 5: Update valIndices[lastVal]: remove lastIndex, add idx (unless idx==lastIndex)\n    Step 6: Remove idx from valIndices[val]\n    Step 7: Pop_back nums\n    Step 8: If valIndices[val] empty, remove key from map\n    Step 9: Return true\n\ngetRandom:\n→ Step 1: Generate random index r in [0, nums.size()-1]\n→ Step 2: Return nums[r]\n\nWrap with class.\n\nLet's produce line by line. Use arrows, decisions. Ensure each line ends with // explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空列表 nums // 用於儲存所有元素，支持隨機存取\n→ Step 2: 初始化空映射 valIndices // key: 值, value: 其在 nums 中所有索引的集合\nEnd // 初始化完成\n\nInsert(val) // 插入元素\n→ Decision: 如果 val 不在 valIndices 中? // 判斷是否為第一次插入\n    Yes → Step 1: 在 nums 最後添加 val // O(1) append\n    → Step 2: 建立新集合 valIndices[val] 並加入索引 nums.size()-1\n    → Step 3: 回傳 true // 為新元素\n    No  → Step 1: 在 nums 最後添加 val\n    → Step 2: valIndices[val] 中加入索引 nums.size()-1\n    → Step 3: 回傳 false // 不是新元素\n\nRemove(val) // 刪除元素\n→ Decision: 如果 val 不在 valIndices 中? // 元素不存在\n    Yes → Step 1: 回傳 false\n    No  → Step 1: 任意取出 valIndices[val] 中的一個索引 idx // O(1)\n    → Step 2: 取得 nums 的最後一個元素 lastVal 及其索引 lastIdx\n    → Step 3: 用 lastVal 覆蓋 nums[idx] // 替換被刪除位置\n    → Step 4: 更新 valIndices[lastVal]：刪除 lastIdx，若 idx ≠ lastIdx 則加入 idx\n    → Step 5: 從 valIndices[val] 中刪除 idx\n    → Decision: 如果 valIndices[val] 變為空? // 只剩下最後一個\n        Yes → Step 6: 從映射中移除 key val\n        No  → Step 6: 無操作\n    → Step 7: 從 nums 刪除最後一個元素（pop_back） // O(1)\n    → Step 8: 回傳 true\n\nGetRandom() // 隨機取值\n→ Step 1: 隨機產生索引 r ∈ [0, nums.size()-1] // 任何位置均等概率\n→ Step 2: 回傳 nums[r] // 直接取得元素\n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\nimport ast\n\nclass MedianFinder:\n    \"\"\"\n    使用兩個堆疊來維持中位數:\n    - self.small  : 儲存較小的一半，使用負數實現最大堆\n    - self.large  : 儲存較大的一半，使用正常最小堆\n    \"\"\"\n    def __init__(self):\n        self.small = []  # max-heap (負數)\n        self.large = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        # 把新數先放進小堆\n        heapq.heappush(self.small, -num)\n\n        # 若兩堆存在且小堆頂大於大堆頂，交換\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡堆的大小，保證兩堆大小差不超過 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    # 解析為兩個列表\n    # 第一次 ']' 之後即結束第一個列表\n    end_cmd = raw.find(']')\n    commands = ast.literal_eval(raw[:end_cmd + 1])\n    args_str = raw[end_cmd + 2:].strip()  # 跳過 '],'\n    args = ast.literal_eval(args_str)\n\n    result = []\n    mf = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MedianFinder\":\n            mf = MedianFinder()\n            result.append(None)\n        elif cmd == \"addNum\":\n            mf.addNum(arg[0])\n            result.append(None)\n        elif cmd == \"findMedian\":\n            median = mf.findMedian()\n            result.append(median)\n        else:\n            # 若有其他命令，忽略或可自行處理\n            result.append(None)\n\n    # 將 None 轉成 JSON 的 null，保持輸出格式一致\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation, step by step. Use Start, End, Decision. The algorithm: use two heaps: max-heap for lower half, min-heap for upper half. On addNum, add to appropriate heap and balance. On findMedian, if sizes equal, average top of both; else, top of larger heap.\n\nWe output lines: Start, → Step 1: initialize two heaps // etc. Provide decisions.\n\nLet's produce step-by-step.\n\nNeed to include methods: constructor, addNum, findMedian. Each step as separate lines. Use arrow indentation for decisions.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Define MedianFinder class // 建立 MedianFinder 物件\n    → SubStep: Create maxHeap // 儲存較小的一半\n    → SubStep: Create minHeap // 儲存較大的一半\n\nBut we need per line: \"虛擬碼步驟 // 解釋\". For substeps we can indent with arrow.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 MedianFinder 類別並初始化兩個堆疊 // maxHeap 儲存左半，minHeap 儲存右半\n→ Step 2: addNum 方法開始 // 新增數字\n    → Decision: 若 maxHeap 为空或 num <= maxHeap.top? // 判斷放入哪個堆\n        Yes → Step 3: 把 num 插入 maxHeap // 放入左半\n        No  → Step 4: 把 num 插入 minHeap // 放入右半\n→ Step 5: 重新平衡堆疊 // 保持兩堆大小相差不超過 1\n    → Decision: maxHeap.size > minHeap.size + 1? // 若左堆過大\n        Yes → Step 6: 把 maxHeap.top() 移到 minHeap // 移動最大值到右堆\n        No  → Decision: minHeap.size > maxHeap.size + 1? // 若右堆過大\n            Yes → Step 7: 把 minHeap.top() 移到 maxHeap // 移動最小值到左堆\n            No → Step 8: 不需要平衡 // 堆已平衡\n→ Step 9: findMedian 方法開始 // 計算中位數\n    → Decision: maxHeap.size == minHeap.size? // 若兩堆大小相同\n        Yes → Step 10: median = (maxHeap.top() + minHeap.top()) / 2.0 // 平均兩中位數\n        No  → Decision: maxHeap.size > minHeap.size? // 左堆較大\n            Yes → Step 11: median = maxHeap.top() // 左堆中位\n            No  → Step 12: median = minHeap.top() // 右堆中位\n→ Step 13: 回傳 median // 結果\nEnd // 程式執行結束\n\nWe need to ensure each line is \"虛擬碼步驟 // 解釋\". Let's rewrite with arrow formatting: Each line starting with \"→\" except Start and End. Indentation? Use spaces. But format sample shows arrows for steps, decisions with \"Yes →\", \"No →\".\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: 建立 MedianFinder 類別並初始化兩個堆疊 // maxHeap 儲存左半，minHeap 儲存右半\n→ Step 2: addNum 方法開始 // 新增數字\n    → Decision: 若 maxHeap 为空或 num <= maxHeap.top()? // 判斷放入哪個堆\n        Yes → Step 3: 把 num 插入 maxHeap // 放入左半\n        No  → Step 4: 把 num 插入 minHeap // 放入右半\n→ Step 5: 重新平衡堆疊 // 保持兩堆大小相差不超過 1\n    → Decision: maxHeap.size > minHeap.size + 1? // 若左堆過大\n        Yes → Step 6: 把 maxHeap.top() 移到 minHeap // 移動最大值到右堆\n        No  → Decision: minHeap.size > maxHeap.size + 1? // 若右堆過大\n            Yes → Step 7: 把 minHeap.top() 移到 maxHeap // 移動最小值到左堆\n            No  → Step 8: 不需要平衡 // 堆已平衡\n→ Step 9: findMedian 方法開始 // 計算中位數\n    → Decision: maxHeap.size == minHeap.size? // 若兩堆大小相同\n        Yes → Step 10: median = (maxHeap.top() + minHeap.top()) / 2.0 // 平均兩中位數\n        No  → Decision: maxHeap.size > minHeap.size? // 左堆較大\n            Yes → Step 11: median = maxHeap.top() // 左堆中位\n            No  → Step 12: median = minHeap.top() // 右堆中位\n→ Step 13: 回傳 median // 結果\nEnd // 程式執行結束\n\nWe should ensure each line starts with \"→\" or \"Start\" or \"End\". The decisions are indented. Might want to keep arrow for each step.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 MedianFinder 類別並初始化兩個堆疊 // maxHeap 儲存左半，minHeap 儲存右半\n→ Step 2: addNum 方法開始 // 新增數字\n    → Decision: 若 maxHeap 为空或 num <= maxHeap.top()? // 判斷放入哪個堆\n        Yes → Step 3: 把 num 插入 maxHeap // 放入左半\n        No  → Step 4: 把 num 插入 minHeap // 放入右半\n→ Step 5: 重新平衡堆疊 // 保持兩堆大小相差不超過 1\n    → Decision: maxHeap.size > minHeap.size + 1? // 若左堆過大\n        Yes → Step 6: 把 maxHeap.top() 移到 minHeap // 移動最大值到右堆\n        No  → Decision: minHeap.size > maxHeap.size + 1? // 若右堆過大\n            Yes → Step 7: 把 minHeap.top() 移到 maxHeap // 移動最小值到左堆\n            No  → Step 8: 不需要平衡 // 堆已平衡\n→ Step 9: findMedian 方法開始 // 計算中位數\n    → Decision: maxHeap.size == minHeap.size? // 若兩堆大小相同\n        Yes → Step 10: median = (maxHeap.top() + minHeap.top()) / 2.0 // 平均兩中位數\n        No  → Decision: maxHeap.size > minHeap.size? // 左堆較大\n            Yes → Step 11: median = maxHeap.top() // 左堆中位\n            No  → Step 12: median = minHeap.top() // 右堆中位\n→ Step 13: 回傳 median // 結果\nEnd // 程式執行結束"
    },
    {
      "title": "Design HashSet",
      "source_file": "Leetcode/leetcode705.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]",
          "expected_output": "[null, null, null, true, false, null, true, null, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,null,true,null,false]'\nGot (Norm):      '[None,None,None,True,False,None,True,None,False]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, null, true, null, false]'\nRaw Got:      '[None, None, None, True, False, None, True, None, False]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MyHashSet:\n    def __init__(self):\n        self.size = 10007  # use a prime number for better distribution\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def add(self, key: int) -> None:\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        if key not in bucket:\n            bucket.append(key)\n\n    def remove(self, key: int) -> None:\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        if key in bucket:\n            bucket.remove(key)\n\n    def contains(self, key: int) -> bool:\n        h = self._hash(key)\n        return key in self.buckets[h]\n\nif __name__ == \"__main__\":\n    # Read the two lines from stdin\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n    ops = ast.literal_eval(data[0].strip())\n    vals = ast.literal_eval(data[1].strip())\n\n    result = []\n    obj = None\n\n    for op, val in zip(ops, vals):\n        if op == \"MyHashSet\":\n            obj = MyHashSet()\n            result.append(None)          # null in LeetCode output\n        elif op == \"add\":\n            obj.add(val[0])\n            result.append(None)\n        elif op == \"remove\":\n            obj.remove(val[0])\n            result.append(None)\n        elif op == \"contains\":\n            result.append(obj.contains(val[0]))\n\n    # Print the result list; None will be shown as null in LeetCode\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with arrow, explanation, no actual code, just structure. The requirement: implement MyHashSet without built-in hash table libraries. So design: Use array of buckets, each bucket is a linked list or dynamic array. Provide add, contains, remove.\n\nWe need to write virtual code steps: Start, initialization, etc. Steps for add, contains, remove. Also decision steps. Should produce code-like pseudo, with \"→\" for next step.\n\nWe should outline steps for initialization: create array of buckets, size maybe prime number like 1000. Each bucket holds list of keys.\n\nLet's produce.\n\nStart // 程式開始執行\n→ Step 1: 定義 MyHashSet 類別 // 建立 MyHashSet 類\n→ Step 2: 內部變數 bucketSize ← 1000 // 設定桶數\n→ Step 3: 建立 buckets ← 陣列，長度 bucketSize，元素為空 (null) // 用來儲存鍵\n→ Step 4: 方法 hash(key): return key mod bucketSize // 計算鍵所在桶\n→ Step 5: 方法 add(key):\n    → Decision: 如果 buckets[hash(key)] 為空? // 檢查桶是否已存在鏈表\n        Yes → Step 5a: 建立 new LinkedList，將 key 加入 // 新建鏈表並加入鍵\n        No  → Step 5b: 如果 key 已存在於鏈表? // 不重複加入\n            Yes → End // 已存在，結束\n            No  → Step 5c: 將 key 加入鏈表 // 插入鍵\n→ Step 6: 方法 contains(key):\n    → Decision: 如果 buckets[hash(key)] 為空? // 無鍵，直接返回 false\n        Yes → Step 6a: return False // 桶空，鍵不存在\n        No  → Decision: 是否 key 存在於鏈表中? // 查找\n            Yes → Step 6b: return True // 找到，返回真\n            No  → Step 6c: return False // 未找到，返回假\n→ Step 7: 方法 remove(key):\n    → Decision: 如果 buckets[hash(key)] 為空? // 無鍵，直接結束\n        Yes → End // 無需操作\n        No  → Decision: key 是否存在於鏈表中?\n            Yes → Step 7a: 移除鏈表中的 key // 刪除鍵\n            No  → End // 不存在，結束\nEnd // 程式執行結束\n\nWe should also mention that we use linked list or dynamic array. Use virtual steps accordingly. Ensure each line ends with // explanation. Provide arrow at start. Use indentation for decisions. Provide \"Yes →\", \"No →\".\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyHashSet 類別 // 建立 MyHashSet 類  \n→ Step 2: 內部變數 bucketSize ← 1000 // 設定桶數  \n→ Step 3: 建立 buckets ← 陣列，長度 bucketSize，元素為空 (null) // 用來儲存鍵  \n→ Step 4: 方法 hash(key): return key mod bucketSize // 計算鍵所在桶  \n→ Step 5: 方法 add(key):  \n  Decision: 是否 buckets[hash(key)] 為空? // 檢查桶是否已存在鏈表  \n   Yes → Step 5a: 建立 new LinkedList，將 key 加入 // 新建鏈表並加入鍵  \n   No  → Decision: 是否 key 已存在於鏈表? // 不重複加入  \n    Yes → Step 5b: End // 已存在，結束  \n    No  → Step 5c: 將 key 加入鏈表 // 插入鍵  \n→ Step 6: 方法 contains(key):  \n  Decision: 是否 buckets[hash(key)] 為空? // 無鍵，直接返回 false  \n   Yes → Step 6a: return False // 桶空，鍵不存在  \n   No  → Decision: 是否 key 存在於鏈表中? // 查找  \n    Yes → Step 6b: return True // 找到，返回真  \n    No  → Step 6c: return False // 未找到，返回假  \n→ Step 7: 方法 remove(key):  \n  Decision: 是否 buckets[hash(key)] 為空? // 無鍵，直接結束  \n   Yes → End // 無需操作  \n   No  → Decision: 是否 key 存在於鏈表中?  \n    Yes → Step 7a: 移除鏈表中的 key // 刪除鍵  \n    No  → End // 不存在，結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Index Sum of Two Lists",
      "source_file": "Leetcode/leetcode599.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]",
          "expected_output": "[\"Shogun\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0jbitlf5.py\", line 37, in parse_input\n    list1 = ast.literal_eval(list1_part)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\n          ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp0jbitlf5.py\", line 53, in <module>\n    list1, list2 = parse_input(input_text)\n                   ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp0jbitlf5.py\", line 42, in parse_input\n    data = ast.literal_eval(text)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\n          ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]",
          "expected_output": "[\"Shogun\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk_s32ip4.py\", line 37, in parse_input\n    list1 = ast.literal_eval(list1_part)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"]\n          ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpk_s32ip4.py\", line 53, in <module>\n    list1, list2 = parse_input(input_text)\n                   ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk_s32ip4.py\", line 42, in parse_input\n    data = ast.literal_eval(text)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]\n          ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]",
          "expected_output": "[\"sad\",\"happy\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxkmd9hr6.py\", line 37, in parse_input\n    list1 = ast.literal_eval(list1_part)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    list1 = [\"happy\",\"sad\",\"good\"]\n          ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpxkmd9hr6.py\", line 53, in <module>\n    list1, list2 = parse_input(input_text)\n                   ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpxkmd9hr6.py\", line 42, in parse_input\n    data = ast.literal_eval(text)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]\n          ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef find_common_min_index_sum(list1, list2):\n    \"\"\"Return all common strings whose index sums are minimal.\"\"\"\n    index_map = {name: i for i, name in enumerate(list1)}\n    min_sum = float('inf')\n    result = []\n\n    for j, name in enumerate(list2):\n        if name in index_map:\n            total = j + index_map[name]\n            if total < min_sum:\n                min_sum = total\n                result = [name]\n            elif total == min_sum:\n                result.append(name)\n    return result\n\ndef parse_input(text: str):\n    \"\"\"\n    Parse input of the form:\n        list1 = [...], list2 = [...]\n    and return two Python lists.\n    \"\"\"\n    # Split into the part for list1 and the part for list2\n    try:\n        list1_part, rest = text.split('],', 1)\n        list1_part += ']'          # restore closing bracket\n        # rest starts with something like ' list2 = [...]'\n        _, list2_part = rest.split('=', 1)\n        list2_part = list2_part.strip()\n        if not list2_part.endswith(']'):\n            # In case the split left a trailing comma or space\n            idx = list2_part.rfind(']')\n            list2_part = list2_part[:idx+1]\n        list1 = ast.literal_eval(list1_part)\n        list2 = ast.literal_eval(list2_part)\n    except Exception as e:\n        # Fallback: try to eval the whole string as a tuple\n        # This handles cases where the input is a single eval-able expression\n        data = ast.literal_eval(text)\n        list1, list2 = data\n    return list1, list2\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    input_text = sys.stdin.read().strip()\n    if not input_text:\n        sys.exit()\n\n    # Parse input into two lists\n    list1, list2 = parse_input(input_text)\n\n    # Compute result\n    result = find_common_min_index_sum(list1, list2)\n\n    # Output result\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode with explanations. Use arrow syntax. We must avoid real code. Provide steps. Use Start, End. Use Decision. Steps: Build map of list1 to index. Iterate list2, compute index sum, track min, collect. If new min, reset list. If equal, append. Return list. Use appropriate decisions. Let's craft.\n\nWe will produce lines:\n\nStart\n→ Build map from list1\n→ Initialize minSum to Infinity\n→ Initialize resultList empty\n→ For each index i and string s in list2\n    → If s exists in map\n        → Compute sum = i + map[s]\n        → Decision: sum < minSum?\n            Yes → Set minSum = sum\n                 → Clear resultList\n                 → Append s\n            No → Decision: sum == minSum?\n                Yes → Append s\n                No → Do nothing\nEnd\n\nAdd explanations after each line. Ensure each line ends with `//`.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Build map: For each index i in list1, store string → index mapping // 將 list1 的每個字串與其索引建立對應表  \n→ Initialize minSum = Infinity // 設定初始最小索引和為無限大  \n→ Initialize resultList = [] // 用來儲存符合最小索引和的字串  \n→ For each index j and string s in list2 // 遍歷 list2  \n    → Decision: 字串 s 是否在 map 中? // 判斷 s 是否同時出現在 list1  \n        Yes → Compute sum = j + map[s] // 取得 s 在兩個清單中的索引和  \n        → Decision: sum < minSum? // 比較目前索引和是否更小  \n            Yes → Set minSum = sum // 更新最小索引和  \n            → Clear resultList // 清除先前結果，因為已找到更小值  \n            → Append s to resultList // 把 s 加入結果列表  \n            No → Decision: sum == minSum? // 判斷是否等於目前最小索引和  \n                Yes → Append s to resultList // 若相等，亦加入結果列表  \n                No  → // 索引和更大，忽略此字串  \nEnd // 程式執行結束，返回 resultList。"
    },
    {
      "title": "K Inverse Pairs Array",
      "source_file": "Leetcode/leetcode629.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 3, k = 0",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpn6x3fi4s.py\", line 21, in <module>\n    nums = [int(x) for x in data.replace('=', ' ').replace(',', ' ').split()]\n            ^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpu3z7mjm_.py\", line 21, in <module>\n    nums = [int(x) for x in data.replace('=', ' ').replace(',', ' ').split()]\n            ^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        }
      ],
      "generated_code": "import sys\n\nMOD = 10**9 + 7\n\ndef k_inverse_pairs(n: int, k: int) -> int:\n    if k > n * (n - 1) // 2:\n        return 0\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n        for j in range(1, k + 1):\n            val = dp[i][j - 1] + dp[i - 1][j]\n            if j >= i:\n                val -= dp[i - 1][j - i]\n            dp[i][j] = val % MOD\n    return dp[n][k]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = [int(x) for x in data.replace('=', ' ').replace(',', ' ').split()]\n    if len(nums) >= 2:\n        n, k = nums[0], nums[1]\n        print(k_inverse_pairs(n, k))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for solving the problem: counting arrays of 1..n with exactly k inversions. Classic DP: dp[n][k] = sum_{i=0}^{min(k,n-1)} dp[n-1][k-i]. Use prefix sums for optimization. Mod 1e9+7.\n\nWe output steps in required format, with arrow and decision etc. Should include Start, End. Should be line by line. Each line: \"虛擬碼步驟 // 解釋\". Use arrow as \"→\" or \"Yes →\", \"No →\". They want arrow for decision branches. But algorithm is iterative loops; we can still format loops as steps.\n\nWe need to generate the steps, not actual code. Use pseudocode. Must not output actual code but steps. We can include variables like dp, n, k, MOD.\n\nLet's design steps:\n\nStart\n→ Initialize MOD = 1e9+7\n→ Create 2D array dp of size (n+1) x (k+1) // dp[i][j] number of arrays of size i with j inversions\n→ Set dp[0][0] = 1 // base case\n→ For i from 1 to n:\n    → For j from 0 to k:\n        → Set sum = 0\n        → For t from 0 to min(j, i-1):\n            → sum = (sum + dp[i-1][j-t]) % MOD\n        → dp[i][j] = sum\n→ Result = dp[n][k] % MOD\n→ Output Result\nEnd\n\nBut we can use prefix sum optimization: preSum[j] = preSum[j-1] + dp[i-1][j]. Then dp[i][j] = preSum[j] - preSum[j-i] if j>=i else preSum[j]. But maybe simpler to show DP with optimization.\n\nWe need to produce step-by-step pseudocode lines. Use arrow and explanation.\n\nWe also may include decision for j-i negative.\n\nBut they might want explicit decision: if j>=i.\n\nLet's structure:\n\nStart\n→ Set MOD = 1_000_000_007\n→ Create 2D array dp[0..n][0..k] and fill 0\n→ dp[0][0] = 1\n→ For i from 1 to n:\n    → // build prefix sum of dp[i-1]\n    → pre[0] = dp[i-1][0]\n    → For j from 1 to k:\n        → pre[j] = (pre[j-1] + dp[i-1][j]) % MOD\n    → For j from 0 to k:\n        → If j < i:\n            → dp[i][j] = pre[j] // all contributions\n        → Else:\n            → dp[i][j] = (pre[j] - pre[j-i] + MOD) % MOD // subtract values that exceed i-1 elements\n→ Answer = dp[n][k] % MOD\n→ End\n\nWe need to produce each line with arrow and explanation. Let's format:\n\nStart // 程式開始執行\n→ Step 1: 設定 MOD = 1_000_000_007 // 定義模數\n→ Step 2: 初始化 dp 為 (n+1)×(k+1) 的 0 陣列 // dp[i][j] 代表長度 i 的排列有 j 個逆序對\n→ Step 3: dp[0][0] = 1 // 空排列只有一種，逆序對數為 0\n→ Step 4: For i = 1 到 n: // 逐步建構長度 i 的 dp\n    → Step 4.1: 計算前綴和 pre[0..k]，pre[j] = (pre[j-1] + dp[i-1][j]) % MOD // 方便快速求和\n    → Step 4.2: For j = 0 到 k:\n        → Decision: 如果 j < i?\n            Yes → dp[i][j] = pre[j] // 所有前 j 個 dp[i-1] 都可使用\n            No  → dp[i][j] = (pre[j] - pre[j-i] + MOD) % MOD // 去除超過 i-1 個位置的部分\n→ Step 5: Answer = dp[n][k] % MOD // 最終答案\n→ End // 程式結束\n\nBut need to follow format: each line includes \"虛擬碼步驟\" then a space then \"// 解釋\". For decision, need \"Decision:\" line and Yes/No lines. So we need to break loops into steps but we can use indented lines? In example, they used indentation like:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // ...\n    No  → Decision: ...\n\nThus we should follow similar indentation. For loops, maybe we use Step: For i = 1 to n: // 逐步... Then within we can show inner steps with indentation. We need to ensure each line is a separate \"虛擬碼步驟\".\n\nWe will produce like:\n\nStart // 程式開始執行\n→ Step 1: Set MOD = 1_000_000_007 // 定義模數\n→ Step 2: Create dp[0..n][0..k] and initialize to 0 // dp[i][j] 為長度 i 逆序對 j 的數量\n→ Step 3: dp[0][0] = 1 // 空排列只有一種\n→ Step 4: For i from 1 to n: // 逐步計算長度 i 的 dp\n    → Step 4.1: // 計算 dp[i-1] 的前綴和 pre\n        → Step 4.1.1: pre[0] = dp[i-1][0] // 初始化前綴和\n        → Step 4.1.2: For j from 1 to k: // 建立前綴和\n            → Step 4.1.2.1: pre[j] = (pre[j-1] + dp[i-1][j]) % MOD // 前綴和更新\n    → Step 4.2: For j from 0 to k: // 計算 dp[i][j]\n        → Decision: j < i? // 判斷能否直接使用前綴和\n            Yes → Step 4.2.1: dp[i][j] = pre[j] // 所有前 j 個都可用\n            No  → Step 4.2.2: dp[i][j] = (pre[j] - pre[j-i] + MOD) % MOD // 去除超過 i-1 的部分\n→ Step 5: Result = dp[n][k] % MOD // 最終答案\n→ End // 程式結束\n\nNeed to ensure each line with arrow. For lines like \"Decision: j < i?\" we need indentation. Use \"Decision: j < i?\" with // explanation. Then the Yes and No lines with indent.\n\nAlso need to make sure that we have consistent indentation. In example, they used indentation spaces after arrow for decision branches. For example:\n\n    Yes → Step 2: 輸出 '正數' // ...\n\nThus we can replicate.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Set MOD = 1_000_000_007 // 定義模數\n→ Step 2: Create dp[0..n][0..k] and initialize to 0 // dp[i][j] 為長度 i 逆序對 j 的數量\n→ Step 3: dp[0][0] = 1 // 空排列只有一種\n→ Step 4: For i from 1 to n: // 逐步計算長度 i 的 dp\n    → Step 4.1: // 計算 dp[i-1] 的前綴和 pre\n        → Step 4.1.1: pre[0] = dp[i-1][0] // 初始化前綴和\n        → Step 4.1.2: For j from 1 to k: // 建立前綴和\n            → Step 4.1.2.1: pre[j] = (pre[j-1] + dp[i-1][j]) % MOD // 前綴和更新\n    → Step 4.2: For j from 0 to k: // 計算 dp[i][j]\n        → Decision: j < i? // 判斷能否直接使用前綴和\n            Yes → Step 4.2.1: dp[i][j] = pre[j] // 所有前 j 個都可用\n            No  → Step 4.2.2: dp[i][j] = (pre[j] - pre[j-i] + MOD) % MOD // 去除超過 i-1 的部分\n→ Step 5: Result = dp[n][k] % MOD // 最終答案\n→ End // 程式結束"
    },
    {
      "title": "Maximum Gap",
      "source_file": "Leetcode/leetcode164.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [3,6,9,1]",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpx1j_qwoy.py\", line 60, in <module>\n    main()\n  File \"/tmp/tmpx1j_qwoy.py\", line 56, in main\n    result = solution.maximumGap(nums)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpx1j_qwoy.py\", line 33, in maximumGap\n    if min_bucket[idx] is None or num < min_bucket[idx]:\n       ~~~~~~~~~~^^^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport re\nimport math\n\nclass Solution:\n    def maximumGap(self, nums):\n        # 如果元素少於兩個，直接回傳 0\n        if len(nums) < 2:\n            return 0\n\n        n = len(nums)\n        min_val = min(nums)\n        max_val = max(nums)\n\n        # 所有元素相同，差距為 0\n        if min_val == max_val:\n            return 0\n\n        # bucket 大小，保證至少為 1，避免除 0\n        bucket_size = max(1, (max_val - min_val) // (n - 1))\n        bucket_count = n - 1  # 只需要 n-1 個桶\n\n        # 每個桶存放最小值和最大值，空桶用 None 表示\n        min_bucket = [None] * bucket_count\n        max_bucket = [None] * bucket_count\n\n        # 分配到桶中\n        for num in nums:\n            idx = (num - min_val) // bucket_size\n            # 可能落到最後一個桶外，調整回最後一個桶\n            if idx == bucket_count:\n                idx = bucket_count - 1\n            if min_bucket[idx] is None or num < min_bucket[idx]:\n                min_bucket[idx] = num\n            if max_bucket[idx] is None or num > max_bucket[idx]:\n                max_bucket[idx] = num\n\n        # 計算最大差距\n        prev = min_val\n        max_gap = 0\n        for i in range(bucket_count):\n            if min_bucket[i] is None:\n                # 桶為空，跳過\n                continue\n            # min_bucket[i] - prev 為跨桶之間的差距\n            max_gap = max(max_gap, min_bucket[i] - prev)\n            prev = max_bucket[i]\n\n        return max_gap\n\ndef main():\n    data = sys.stdin.read()\n    # 從輸入中抽取所有整數\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    solution = Solution()\n    result = solution.maximumGap(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode step-by-step. It's virtual code with arrows, decisions, etc. We should cover the algorithm: use bucket sort/ pigeonhole principle: find min and max, bucket size, create buckets, compute max gap. Complexity O(n) time and space.\n\nWe need to output line by line: \"虛擬碼步驟\" + space + \"// 解釋\". Using arrows. For decisions: \"Decision: if ...\". Use \"Start\", \"End\". Provide lines of pseudocode.\n\nLet's craft steps:\n\n1. Start\n2. Input array nums\n3. If length < 2: return 0\n4. Find minVal and maxVal\n5. If minVal == maxVal: return 0 (all equal)\n6. Compute bucket size = max(1, ceil((maxVal - minVal) / (n-1))) maybe but linear? We can just compute bucket size = (maxVal - minVal) / (n-1) maybe. Use integer division: bucketSize = max(1, (maxVal - minVal) // (n-1))\n7. Number of buckets = n-1\n8. Initialize arrays minBucket[ n-1 ] with INF, maxBucket[ n-1 ] with -INF\n9. For each num in nums:\n   compute idx = (num - minVal) // bucketSize\n   If idx == n-1: idx = n-2? Actually bucketSize may lead to last bucket inclusive of max. We can handle by if idx == n-1: idx = n-2\n   Update minBucket[idx] = min(minBucket[idx], num)\n   Update maxBucket[idx] = max(maxBucket[idx], num)\n10. Initialize prev = minVal, maxGap = 0\n11. For i from 0 to n-2:\n    If minBucket[i] == INF: continue // bucket empty\n    maxGap = max(maxGap, minBucket[i] - prev)\n    prev = maxBucket[i]\n12. Return maxGap\n\nNeed to format with arrows.\n\nWe produce each line as step.\n\nLet's list lines:\n\nStart // 程式開始執行\n→ Step 1: Read array nums // 取得輸入數列\n→ Decision: if length(nums) < 2? // 檢查元素數量\n    Yes → Step 2: Return 0 // 兩個以下元素返回 0\n    No  → \n→ Step 3: minVal = min(nums) // 找到最小值\n→ Step 4: maxVal = max(nums) // 找到最大值\n→ Decision: if minVal == maxVal? // 所有元素相同\n    Yes → Step 5: Return 0 // 最大差距為 0\n    No  →\n→ Step 6: n = length(nums) // 數列長度\n→ Step 7: bucketSize = max(1, (maxVal - minVal) // (n - 1)) // 計算桶大小\n→ Step 8: bucketCount = n - 1 // 桶數\n→ Step 9: Initialize array minBucket[0..bucketCount-1] with +∞ // 每個桶最小值\n→ Step 10: Initialize array maxBucket[0..bucketCount-1] with -∞ // 每個桶最大值\n→ Step 11: For each num in nums: // 分配到桶\n    → idx = (num - minVal) // bucketSize // 桶索引\n    → Decision: if idx == bucketCount? // 可能落到最後桶\n        Yes → idx = bucketCount - 1 // 調整到最後一個桶\n        No  →\n    → minBucket[idx] = min(minBucket[idx], num) // 更新桶最小值\n    → maxBucket[idx] = max(maxBucket[idx], num) // 更新桶最大值\n→ Step 12: prev = minVal // 前一個桶的最大值\n→ Step 13: maxGap = 0 // 最大差距初始化\n→ Step 14: For i = 0 to bucketCount - 1: // 遍歷桶\n    → Decision: if minBucket[i] == +∞? // 桶空\n        Yes → Continue // 跳過空桶\n        No  →\n    → maxGap = max(maxGap, minBucket[i] - prev) // 可能的最大差距\n    → prev = maxBucket[i] // 更新前一個桶最大值\n→ Step 15: Return maxGap // 回傳結果\nEnd // 程式執行結束\n\nCheck arrow formatting: For loops we can use \"→ For each ...:\" and then inside arrow lines? Use indent. According to sample, they use \"→ Step 1:\" etc. For loops, maybe \"→ For each num in nums:\" and then indented lines with \"→\" also? In sample they used indentation for decisions.\n\nLet's ensure consistent indent.\n\nWe might need to use \"→ Step 11: For each num in nums:\" then indent inner steps with \"    →\". Use four spaces.\n\nOk.\n\nAlso for \"Continue\", we can use \"→ Continue\" but maybe \"→ Continue\" with comment.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Read array nums // 取得輸入數列\n→ Decision: if length(nums) < 2? // 檢查元素數量\n    Yes → Step 2: Return 0 // 兩個以下元素返回 0\n    No  →\n→ Step 3: minVal = min(nums) // 找到最小值\n→ Step 4: maxVal = max(nums) // 找到最大值\n→ Decision: if minVal == maxVal? // 所有元素相同\n    Yes → Step 5: Return 0 // 最大差距為 0\n    No  →\n→ Step 6: n = length(nums) // 數列長度\n→ Step 7: bucketSize = max(1, (maxVal - minVal) // (n - 1)) // 計算桶大小\n→ Step 8: bucketCount = n - 1 // 桶數\n→ Step 9: Initialize array minBucket[0..bucketCount-1] with +∞ // 每個桶最小值\n→ Step 10: Initialize array maxBucket[0..bucketCount-1] with -∞ // 每個桶最大值\n→ Step 11: For each num in nums: // 分配到桶\n    → idx = (num - minVal) // bucketSize // 桶索引\n    → Decision: if idx == bucketCount? // 可能落到最後桶\n        Yes → idx = bucketCount - 1 // 調整到最後一個桶\n        No  →\n    → minBucket[idx] = min(minBucket[idx], num) // 更新桶最小值\n    → maxBucket[idx] = max(maxBucket[idx], num) // 更新桶最大值\n→ Step 12: prev = minVal // 前一個桶的最大值\n→ Step 13: maxGap = 0 // 最大差距初始化\n→ Step 14: For i = 0 to bucketCount - 1: // 遍歷桶\n    → Decision: if minBucket[i] == +∞? // 桶空\n        Yes → Continue // 跳過空桶\n        No  →\n    → maxGap = max(maxGap, minBucket[i] - prev) // 可能的最大差距\n    → prev = maxBucket[i] // 更新前一個桶最大值\n→ Step 15: Return maxGap // 回傳結果\nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import bisect\nimport sys\n\nclass RangeModule:\n    def __init__(self):\n        # 存放已追蹤的區間，格式為 [start, end)，並且按 start 排序\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        \"\"\"將區間 [left, right) 加入追蹤，合併重疊部分\"\"\"\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:            # 目前區間在新區間左側且不重疊\n                new_ranges.append([l, r])\n            elif right < l:         # 目前區間在新區間右側且不重疊\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:                   # 兩區間重疊，合併\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:                # 新區間在最右側\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        \"\"\"檢查 [left, right) 是否完全被追蹤\"\"\"\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        \"\"\"移除 [left, right) 的追蹤，必要時拆分區間\"\"\"\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:          # 完全不重疊\n                new_ranges.append([l, r])\n            else:\n                if l < left:                     # 左側保留\n                    new_ranges.append([l, left])\n                if r > right:                    # 右側保留\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    outputs = []\n    module = None\n\n    for line in lines:\n        if line.endswith(';'):\n            line = line[:-1].strip()\n        # 初始化\n        if line.startswith('RangeModule'):\n            module = RangeModule()\n            outputs.append(None)\n            continue\n        # 方法呼叫\n        if line.startswith('rangeModule.'):\n            method_part = line.split('.', 1)[1]\n            if '(' in method_part:\n                method_name, args_str = method_part.split('(', 1)\n                args_str = args_str.rstrip(')')\n                args = [int(x.strip()) for x in args_str.split(',') if x.strip()]\n                if method_name == 'addRange':\n                    module.addRange(*args)\n                    outputs.append(None)\n                elif method_name == 'removeRange':\n                    module.removeRange(*args)\n                    outputs.append(None)\n                elif method_name == 'queryRange':\n                    res = module.queryRange(*args)\n                    outputs.append(res)\n                else:\n                    outputs.append(None)\n            else:\n                outputs.append(None)\n        else:\n            outputs.append(None)\n\n    # 轉成 LeetCode 風格輸出\n    out_str = '[' + ', '.join(\n        'null' if v is None else ('true' if v else 'false')\n        for v in outputs\n    ) + ']'\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line with explanations. The design likely uses an ordered map of intervals, maybe balanced BST. We'll produce steps of RangeModule class: constructor initializes data structure, addRange merges intervals, queryRange checks containment, removeRange splits intervals. We'll produce pseudo code lines with \"Start\", \"End\", \"Decision:\" etc.\n\nWe need to use arrow '→'. Provide each line as \"Step X: ...\" with explanation. We'll outline algorithm steps. Provide pseudocode skeleton, not actual code. Ensure each line has a comment. Provide enough detail. Use typical operations: addRange: while there is overlapping intervals, merge, else insert. queryRange: find interval containing left, ensure it covers right. removeRange: find overlapping intervals, adjust boundaries.\n\nLet's craft.\n\nWe'll need to maintain a list/ordered map of intervals. For pseudocode, we'll refer to a data structure \"Intervals\" sorted by start. We'll use operations: findPrev, findNext.\n\nOk let's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 定義 RangeModule 類別 // 建立資料結構類別\n    → Class RangeModule\n        → Data: Intervals // 有序集合，存放已追蹤的半開區間 [start, end)\n        → Constructor: RangeModule()\n            → Intervals ← 空集合 // 初始時無任何追蹤區間\n        → Method: addRange(left, right)\n            → 如果 left >= right → End // 無效區間直接返回\n            → 輸入 left, right // 將待加入的區間\n            → Find interval with start 最接近 left 且 end > left 的區間 (prev) // 可能有重疊\n            → If prev 不存在 or prev.end < left → prev ← 下一個區間 // 確定起始重疊區間\n            → newStart ← left\n            → newEnd ← right\n            → While prev 存在 且 prev.start <= right\n                → newStart ← min(newStart, prev.start) // 合併起點\n                → newEnd ← max(newEnd, prev.end)   // 合併終點\n                → 移除 prev 從 Intervals // 刪除已重疊的區間\n                → prev ← 下一個區間\n            → 插入區間 [newStart, newEnd) 到 Intervals // 添加合併後的區間\n        → Method: queryRange(left, right)\n            → 如果 left >= right → Return False // 無效區間\n            → 找到 Intervals 中 start <= left 且 end > left 的區間 (curr)\n            → If curr 不存在 → Return False // 沒有任何區間覆蓋左端\n            → If curr.end >= right → Return True // curr 完整覆蓋查詢區間\n            → Return False // 只覆蓋到右側一部分\n        → Method: removeRange(left, right)\n            → 如果 left >= right → End // 無效區間\n            → 找到 Intervals 中 start < right 且 end > left 的區間 (curr)\n            → While curr 存在 且 curr.start < right\n                → If curr.start < left AND curr.end > right\n                    → 插入區間 [curr.start, left) // 左側保留\n                    → 插入區間 [right, curr.end) // 右側保留\n                → Else If curr.start < left AND curr.end <= right\n                    → 插入區間 [curr.start, left) // 左側保留\n                → Else If curr.start >= left AND curr.end > right\n                    → 插入區間 [right, curr.end) // 右側保留\n                → // 若 curr 完全被移除，則不插入任何區間\n                → 移除 curr 從 Intervals // 刪除原始區間\n                → curr ← 下一個區間 // 前往下一個可能重疊的區間\n        → End // RangeModule 類別結束\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbvglmnqr.py\", line 62, in <module>\n    ops = json.loads(lines[0])\n          ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0\n        self.count = 0\n\n    def insertFront(self, value):\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value):\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self):\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self):\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self):\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self):\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self):\n        return self.count == 0\n\n    def isFull(self):\n        return self.count == self.k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    lines = data.splitlines()\n    ops = json.loads(lines[0])\n    args = json.loads(lines[1])\n    obj = None\n    output = []\n    for op, arg in zip(ops, args):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(*arg)\n            output.append(None)\n        else:\n            method = getattr(obj, op)\n            result = method(*arg)\n            output.append(result)\n    print(json.dumps(output))",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, with explanations after each line. We need to represent the design of MyCircularDeque class with operations. We'll create a data structure with an array and two pointers, front and rear. Need to define initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. The virtual code must use arrow symbols and decisions.\n\nWe need to produce a logical step-by-step pseudo algorithm, not actual code. Each line with explanation. We need to use \"Start\", \"End\", \"Decision:\".\n\nLet's outline:\n\nStart: Initialize MyCircularDeque with size k: allocate array of size k, set front = -1, rear = -1.\n\nInsertFront: if deque is full, return false. Else if empty, set front = rear = 0, set arr[front] = value, return true. Else front = (front -1 + k) % k, arr[front] = value, return true.\n\nInsertLast: similar but rear = (rear +1) % k.\n\nDeleteFront: if empty return false. Else if front==rear, set front=rear=-1. Else front = (front +1) % k.\n\nDeleteLast: similar.\n\ngetFront: if empty return -1 else return arr[front].\n\ngetRear: if empty return -1 else return arr[rear].\n\nisEmpty: front == -1.\n\nisFull: (rear +1) % k == front.\n\nWe need to express these as virtual code steps. Possibly group operations into separate blocks.\n\nWe should write a series of steps for each method, but might not need to enumerate all lines for each method, but we can produce pseudo steps. Each line needs explanation.\n\nWe need to ensure we do not output actual code, just virtual code with arrows.\n\nLet's produce something like:\n\nStart // 程式開始執行\n\n→ Step 1: MyCircularDeque(int k) // 建構函式，設定最大容量\n\n→ Step 2: array ← new int[k] // 儲存資料的陣列\n\n→ Step 3: front ← -1 // 初始化前指標\n\n→ Step 4: rear ← -1 // 初始化後指標\n\n→ Step 5: size ← k // 儲存容量\n\n→ End // 完成初始化\n\nThen for each method:\n\nInsertFront(value):\n\nStart // 插入前端\n\n→ Decision: If isFull()? // 檢查是否已滿\n\n    Yes → Return false // 已滿，插入失敗\n\n    No  → Decision: If isEmpty()? // 檢查是否為空\n\n        Yes → front ← 0 // 第一個元素的索引\n\n             rear ← 0\n\n             array[front] ← value\n\n             Return true\n\n        No  → front ← (front - 1 + size) % size // 往前移\n\n             array[front] ← value\n\n             Return true\n\nEnd\n\nSimilarly for InsertLast, DeleteFront, DeleteLast, etc.\n\nWe'll provide each line with explanation. Use arrow '→', 'Yes →', 'No →'.\n\nNeed to include comments after //.\n\nLet's produce final output with all methods.\n\nAlso note: each method should be separate block.\n\nMake sure each line includes '虛擬碼步驟' then space then '// 解釋/說明'.\n\nWe will produce something like:\n\nStart // 程式開始執行\n\n→ Step 1: MyCircularDeque(k) // 建構函式，接收最大容量\n\n...\n\nBetter to use consistent naming: Step 1: Initialize MyCircularDeque with capacity k\n\nBut each line must be virtual code step.\n\nLet's format each method block starting with a comment.\n\nExample:\n\n// ---------- MyCircularDeque 初始化 ----------\nStart // 程式開始執行\n→ Step 1: array ← new int[k] // 建立長度為 k 的陣列\n...\n\nOk.\n\nLet's craft.\n\nWe'll produce:\n\n// MyCircularDeque 建構函式\nStart // 程式開始執行\n→ Step 1: MyCircularDeque(k) // 建構函式，接收最大容量 k\n→ Step 2: array ← new int[k] // 建立容量為 k 的陣列\n→ Step 3: front ← -1 // 初始化前指標為 -1 表示空\n→ Step 4: rear ← -1 // 初始化後指標為 -1 表示空\n→ Step 5: size ← k // 儲存容量\nEnd // 建構完成\n\n// insertFront 方法\nStart // 插入前端\n→ Decision: If isFull()? // 檢查是否已滿\n    Yes → Return false // 已滿，插入失敗\n    No → Decision: If isEmpty()? // 檢查是否為空\n        Yes → front ← 0 // 第一個元素索引\n             rear ← 0\n             array[front] ← value\n             Return true\n        No  → front ← (front - 1 + size) % size // 前移\n             array[front] ← value\n             Return true\nEnd // 插入前端結束\n\nAnd so on.\n\nWe need to produce all methods.\n\nLet's also include getFront, getRear, isEmpty, isFull, deleteFront, deleteLast.\n\nWe'll maintain consistent format.\n\nEach step line: '→ Step ...' or '→ Decision...' with appropriate explanation.\n\nWe must ensure each line ends with // 解釋.\n\nOk.\n\nLet's generate final answer.\n...done thinking.\n\n// ---------- MyCircularDeque 建構函式 ----------\nStart // 程式開始執行\n→ Step 1: MyCircularDeque(k) // 建構函式，接收最大容量 k\n→ Step 2: array ← new int[k] // 建立長度為 k 的陣列，用於儲存元素\n→ Step 3: front ← -1 // 初始化前指標為 -1，代表空隊列\n→ Step 4: rear ← -1 // 初始化後指標為 -1，代表空隊列\n→ Step 5: size ← k // 儲存容量，供其他方法判斷滿/空\nEnd // 建構完成，物件可供使用\n\n// ---------- insertFront 方法 ----------\nStart // 插入前端\n→ Decision: If isFull()? // 檢查隊列是否已滿\n    Yes → Return false // 已滿，插入失敗，返回 false\n    No  → Decision: If isEmpty()? // 檢查隊列是否為空\n        Yes → front ← 0 // 前指標設為 0，為第一個元素\n             rear ← 0 // 後指標也設為 0，表示只有一個元素\n             array[front] ← value // 存入值\n             Return true // 插入成功，返回 true\n        No  → front ← (front - 1 + size) % size // 前移一格，循環使用\n             array[front] ← value // 存入值\n             Return true // 插入成功，返回 true\nEnd // 插入前端結束\n\n// ---------- insertLast 方法 ----------\nStart // 插入後端\n→ Decision: If isFull()? // 檢查隊列是否已滿\n    Yes → Return false // 已滿，插入失敗，返回 false\n    No  → Decision: If isEmpty()? // 檢查隊列是否為空\n        Yes → front ← 0 // 前指標設為 0，為第一個元素\n             rear ← 0 // 後指標也設為 0，表示只有一個元素\n             array[rear] ← value // 存入值\n             Return true // 插入成功，返回 true\n        No  → rear ← (rear + 1) % size // 後移一格，循環使用\n             array[rear] ← value // 存入值\n             Return true // 插入成功，返回 true\nEnd // 插入後端結束\n\n// ---------- deleteFront 方法 ----------\nStart // 刪除前端\n→ Decision: If isEmpty()? // 檢查隊列是否為空\n    Yes → Return false // 空，刪除失敗，返回 false\n    No  → Decision: If front = rear? // 只有一個元素時\n        Yes → front ← -1 // 重置前指標\n             rear ← -1 // 重置後指標，隊列變空\n             Return true // 刪除成功，返回 true\n        No  → front ← (front + 1) % size // 前移一格\n             Return true // 刪除成功，返回 true\nEnd // 刪除前端結束\n\n// ---------- deleteLast 方法 ----------\nStart // 刪除後端\n→ Decision: If isEmpty()? // 檢查隊列是否為空\n    Yes → Return false // 空，刪除失敗，返回 false\n    No  → Decision: If front = rear? // 只有一個元素時\n        Yes → front ← -1 // 重置前指標\n             rear ← -1 // 重置後指標，隊列變空\n             Return true // 刪除成功，返回 true\n        No  → rear ← (rear - 1 + size) % size // 後移一格\n             Return true // 刪除成功，返回 true\nEnd // 刪除後端結束\n\n// ---------- getFront 方法 ----------\nStart // 取得前端元素\n→ Decision: If isEmpty()? // 檢查隊列是否為空\n    Yes → Return -1 // 空，返回 -1\n    No  → Return array[front] // 返回前指標指向的值\nEnd // 取得前端結束\n\n// ---------- getRear 方法 ----------\nStart // 取得後端元素\n→ Decision: If isEmpty()? // 檢查隊列是否為空\n    Yes → Return -1 // 空，返回 -1\n    No  → Return array[rear] // 返回後指標指向的值\nEnd // 取得後端結束\n\n// ---------- isEmpty 方法 ----------\nStart // 判斷是否為空\n→ Return front = -1 // 若前指標為 -1，表示隊列為空，返回 true；否則 false\nEnd // 判斷是否為空結束\n\n// ---------- isFull 方法 ----------\nStart // 判斷是否已滿\n→ Return (rear + 1) % size = front // 後移一格後等於前指標，表示已滿，返回 true；否則 false\nEnd // 判斷是否已滿結束"
    },
    {
      "title": "Beautiful Arrangement II",
      "source_file": "Leetcode/leetcode667.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 3, k = 1",
          "expected_output": "[1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqddakw18.py\", line 35, in <module>\n    main()\n  File \"/tmp/tmpqddakw18.py\", line 27, in main\n    data = list(map(int, sys.stdin.read().strip().split()))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 2",
          "expected_output": "[1,3,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdz_jt6mc.py\", line 35, in <module>\n    main()\n  File \"/tmp/tmpdz_jt6mc.py\", line 27, in main\n    data = list(map(int, sys.stdin.read().strip().split()))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        }
      ],
      "generated_code": "import sys\n\ndef construct_array(n: int, k: int) -> list[int]:\n    \"\"\"\n    Construct a permutation of 1..n such that the absolute differences\n    between consecutive elements have exactly k distinct values.\n    \"\"\"\n    res = []\n    left, right = 1, k + 1\n\n    # 產生前 k+1 個元素，確保得到 k 個不同差值\n    for i in range(k + 1):\n        if i % 2 == 0:\n            res.append(left)\n            left += 1\n        else:\n            res.append(right)\n            right -= 1\n\n    # 其餘的數字按升序加入，新的差值只會是已存在的值\n    for num in range(k + 2, n + 1):\n        res.append(num)\n\n    return res\n\ndef main() -> None:\n    data = list(map(int, sys.stdin.read().strip().split()))\n    if len(data) < 2:\n        return\n    n, k = data[0], data[1]\n    answer = construct_array(n, k)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code steps line by line. The problem: given n,k produce permutation of 1..n such that absolute differences between consecutive elements have exactly k distinct values. We need algorithm. Common solution: start with a simple pattern to get k distinct differences, then fill remaining with monotonic tail to keep same difference set. Approach: produce first k+1 elements to create k distinct differences: use alternating smallest and largest remaining: start with 1, n, 2, n-1, ... until k+1 numbers. This yields differences set of k distinct values? Let's check: sequence 1,n,2,n-1,3,... gives differences: n-1, n-2, n-3,... distinct. So yes distinct count k. Then remaining numbers fill in ascending or descending order from remaining unused numbers to not introduce new differences beyond the set. But we need to ensure differences between last of pattern and next numbers don't create new distinct difference. We can simply append remaining numbers in ascending order; differences will be 1. Since 1 may already be in set (if k>=1). If not, we can ensure 1 already included. For k=1, we need all differences same, e.g., ascending sequence 1..n. So algorithm: if k==1 return [1..n]. else build pattern of length k+1 using smallest and largest alternation. Then append remaining numbers sorted ascending (or descending) ensuring no new diff; difference will be 1. 1 may not be in set if k>=2? For k>=2, pattern includes 1 difference? Let's test: pattern 1,n,2,n-1,... differences: n-1, n-2, ... includes 1 eventually when k>=n-1. But for k small, like k=2, pattern 1,n,2 gives diffs: n-1, n-2 which are distinct and not 1. Append 3..n: difference from 2 to 3 is 1 new diff. That would add new distinct diff, increasing count to 3 > k. So need to adjust. Instead we can fill remaining with numbers that produce differences already in set. For k=2, we need only differences {n-1, n-2}. To avoid new diff 1, we could append numbers that maintain difference either n-1 or n-2. Hard.\n\nAlternate known solution: use sequence 1,2,...,k+1 then  k+2,...n but this yields differences 1 repeated, distinct count 1. Not good.\n\nBetter known approach: For any n,k, we can construct as follows: start with left=1, right=n. Create result list: for i in 1..k: if i odd, append left; left++ else append right; right--. After k elements, append remaining numbers from left to right (in increasing order). This gives exactly k distinct differences? Let's test n=5,k=2: left=1,right=5. i=1 odd->1; i=2 even->5. Result=[1,5]. left=2,right=4 remaining numbers [2,3,4] appended: [1,5,2,3,4]. Differences: |1-5|=4, |5-2|=3, |2-3|=1, |3-4|=1. Distinct diffs {4,3,1} count=3 >k. So not good.\n\nKnown solution from Leetcode problem 2214 \"Construct Array With Stack\" maybe. Actually there is problem 2214 \"Construct Array With K Distinct Differences\". Standard solution: use two pointers to produce differences of size k by alternating from extremes, but after k steps, append remaining in increasing order. For k=2 case earlier we got extra difference 1. Wait check: For k=2, n=5: pattern length k+1=3: [1,5,2] differences: 4,3 distinct {4,3}. Append remaining numbers 3,4: differences from 2 to 3=1 new diff. So need adjust: Instead of appending in increasing order, we can append remaining numbers in such a way that difference equals either of the existing diffs. For n=5,k=2, remaining numbers 3,4. We can place 4 then 3 maybe? Let's test: sequence [1,5,2,4,3]: differences:4,3,2,1. Distinct {4,3,2,1} 4 diffs >k.\n\nMaybe we can choose to append remaining numbers in decreasing order: [1,5,2,4,3] same issue.\n\nAlternative method: After constructing first k+1 elements, we can fill remaining numbers in increasing order but we can ensure difference 1 is already included if k>=1? For k=2, we need diff set {n-1,n-2}. 1 not in set. So adding 1 will increase distinct. But we can choose remaining numbers so that difference 1 does not appear: we can use numbers such that difference equals n-1 or n-2. For small n, maybe impossible. Let's test n=5,k=2: we need sequence length 5. Our pattern [1,5,2] uses numbers 1,5,2. Remaining numbers {3,4}. We need to insert them such that diffs are either 4 or 3. Differences between 2 and 3 is 1, not allowed. So maybe we need different pattern.\n\nLet's think of general solution: We can produce differences by using values from 1 to k+1 in ascending and descending: e.g., for n=5,k=2 produce [1,2,5,3,4]? differences:1,3,2,1 distinct {1,3,2}. 3 distinct.\n\nBetter to think: we want exactly k distinct differences. We can achieve by generating differences as sequence of decreasing numbers from k+1 to 1 maybe. For n=5,k=2 we need diffs of 4 and 3 only. So we need arrangement where consecutive differences produce 4 and 3 only. Sequence: [1,5,2] gives 4 and 3. Then we have two more positions. To keep diffs only 4 or 3, we can place remaining numbers 3 and 4 somewhere such that differences to neighbors are 4 or 3. Let's try [1,5,2,4,3] differences:4,3,2,1 not allowed. [1,5,2,3,4] differences:4,3,1,1 includes 1 new. [1,5,2,4,3] not.\n\nMaybe impossible for n=5,k=2? Let's brute think. Need 4 distinct diffs? no, exactly 2. Let's attempt to find any permutation. Let's brute mentally: Suppose we have numbers 1..5. Need differences set size 2. Let's search: try [1,5,3,2,4]. differences:4,2,1,2 -> {4,2,1} size3. [2,5,1,4,3] diffs:3,4,3,1 -> {3,4,1} size3. [3,1,5,2,4]:2,4,3,2 -> {2,4,3} size3. Maybe impossible? Let's think logically: For 5 numbers, number of differences is 4. We need exactly 2 distinct differences among 4 values. So we need two differences that appear multiple times. Suppose differences are a and b. Count of a + count of b =4. Both positive integers. Must use values from set {1,2,3,4}. So a,b in {1,2,3,4}. Need arrangement. Might be possible. Let's brute systematically? Hard.\n\nBut known problem \"Construct Array With K Distinct Differences\" always has solution. Let's find algorithm: The usual approach: start with left=1,right=n. For i from 0 to k: if i even -> append left else append right; left++, right--. After that, if k is even, continue appending from right+1 to left-1? Actually typical solution: produce sequence where first k+1 elements produce k distinct diffs. After that, fill remaining numbers in either increasing or decreasing order from remaining left to right, whichever keeps differences same. Let's look up: The official solution: Use two pointers l=1,r=n. result empty. For i=0..k: if i%2==0 -> push_back(l++), else push_back(r--). After that, if k%2==0: append remaining numbers from l to r in ascending order; else append from r to l descending. This ensures differences remain existing. Let's test with n=5,k=2: l=1,r=5. i=0 even ->1, l=2. i=1 odd ->5,r=4. i=2 even ->2,l=3. So result=[1,5,2]. Remaining l=3,r=4. Since k even? k=2 even, so append ascending from l to r: 3,4. Sequence [1,5,2,3,4] differences:4,3,1,1 -> distinct {4,3,1}. Not good.\n\nBut maybe because they appended ascending but difference 1 appears. Maybe the known solution uses ascending when k%2==1? Let's test if k=2 odd? no. Let's try if we append descending when k even: from r down to l: 4,3. Sequence [1,5,2,4,3] diffs:4,3,2,1 again.\n\nSeems still not.\n\nMaybe the official algorithm uses k+1 distinct differences from 1 to k+1? Actually they produce sequence: 1,k+1,2,k,3,k-1,... etc. That yields differences that are decreasing: k, k-1, ...,1. So distinct count k. After that, they append remaining numbers in ascending order, but differences after the k+1 element will be 1 (since consecutive remaining numbers difference 1). But 1 is already included (since it's in the set). Good. For k=2, differences set {2,1}. Let's test n=5,k=2. Sequence built: start with left=1,right=3? Wait n=5,k=2 => pattern length k+1=3: use 1,3,2. Differences:2,1 distinct {2,1}. Append remaining numbers 4,5 ascending: diff 2-4=2 (present), 4-5=1 (present). So final diffs {2,1}. Works! Let's compute: pattern: 1,3,2. How to produce? left=1,right=n? But we want k+1 numbers using extremes from 1..k+1? Actually we can use numbers 1..k+1 in that alternating pattern. Because we only need k+1 numbers to get k distinct differences. Using values 1..k+1 ensures differences are exactly k,k-1,...,1. Because sequence: 1, k+1, 2, k, 3, k-1,... yields differences: k, k-1, k-2,...,1. For k=2: sequence 1,3,2. Yes. For n=5, after that we append numbers from k+2 to n ascending: 4,5. That works.\n\nSo algorithm: produce first k+1 numbers using two pointers l=1,r=k+1. For i=0..k: if i even -> append l; l++ else append r; r--. Then append remaining numbers from k+2 to n ascending. This ensures new differences are either k,...,1 and differences with remaining numbers are 1 or k? Let's check difference between last of pattern and k+2: last of pattern depends on parity of k. If k even, last appended is l? Let's analyze. Sequence length k+1. For even k, last appended will be l? Let's simulate k=2 even: l=1,r=3: i0: l=1 append; l=2; i1: r=3 append; r=2; i2: l=2 append; l=3. Last appended 2. Next number k+2=4 diff=2 present. For k=3 odd: l=1,r=4: i0:1; i1:4; i2:2; i3:3. Last appended 3. Next number 5 diff=2? Wait 3 to 5 diff=2, which is present? For k=3, diffs set {3,2,1}. 2 present yes. Good.\n\nThus algorithm works.\n\nEdge case: k==1: pattern of 2 numbers: l=1,r=2: sequence 1,2. diff=1. Append remaining 3..n ascending: diff=1 all. Works.\n\nEdge case: k==n-1: pattern uses 1..n: l=1,r=n: produce alternation uses all numbers: after pattern done, no remaining numbers. Diff set {n-1,...,1} size n-1. Good.\n\nThus we produce virtual code steps accordingly.\n\nNow produce step-by-step pseudocode lines.\n\nLet's produce lines:\n\nStart\n→ Step 1: Read integers n, k\n→ Step 2: Initialize empty list answer\n→ Step 3: Set left = 1, right = k + 1\n→ Decision: If k == 0? Actually k >=1 per problem maybe; but handle if k==0? Distinct diffs 0 meaning all differences same? But n>1? We'll ignore\n→ Step 4: For i from 0 to k: \n    → Decision: If i mod 2 == 0?\n        Yes → Step 4a: Append left to answer; left = left + 1\n        No  → Step 4b: Append right to answer; right = right - 1\n→ Step 5: For num from k + 2 to n:\n    → Step 5a: Append num to answer\n→ End\n\nExplain each line.\n\nAlso we might include an explanation of decision regarding parity. Let's produce.\n\nAlso mention difference reasoning: The first part ensures k distinct differences, etc.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取兩個整數 n 與 k // 取得輸入的數字  \n→ Step 2: 初始化空清單 answer // 用來儲存最終排列  \n→ Step 3: 設定 left = 1, right = k + 1 // 兩端指標，用於產生前 k+1 個元素  \n→ Step 4: 針對 i 從 0 到 k 執行  \n&nbsp;&nbsp;&nbsp;Decision: i 為偶數? // 判斷當前位置的奇偶性  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4a: 把 left 加到 answer； left = left + 1 // 取左端小值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 4b: 把 right 加到 answer； right = right - 1 // 取右端大值  \n→ Step 5: 將剩餘的數字從 k+2 到 n 按升序加入 answer  \n&nbsp;&nbsp;&nbsp;Step 5a: 把 num 加到 answer // 完成剩餘元素的填充  \n→ End // 程式執行結束  \n\n// 說明：  \n// 第 4 步產生的 k+1 個元素依序為 1, k+1, 2, k, 3, k-1 …，其相鄰差值為 k, k-1, …, 1，故恰好有 k 個不同差值。  \n// 第 5 步將剩餘的數字以升序接上，新增的相鄰差值只會是 1 或已經存在於前面差值集合中的值，因而不會增加新的不同差值，整體仍保持正好 k 個不同差值。"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxyc8lhpv.py\", line 39, in <module>\n    main()\n  File \"/tmp/tmpxyc8lhpv.py\", line 22, in main\n    methods, args = json.loads(data)\n                    ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 50 (char 49)"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8jhwp5fc.py\", line 39, in <module>\n    main()\n  File \"/tmp/tmp8jhwp5fc.py\", line 22, in main\n    methods, args = json.loads(data)\n                    ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 43 (char 42)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    methods, args = json.loads(data)\n\n    results = []\n    obj = None\n\n    for i, method in enumerate(methods):\n        if method == \"KthLargest\":\n            k, nums = args[i]\n            obj = KthLargest(k, nums)\n            results.append(None)  # constructor returns null\n        elif method == \"add\":\n            val = args[i][0] if isinstance(args[i], list) else args[i]\n            results.append(obj.add(val))\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The logic: maintain min-heap of size k. Initialization: push existing nums, if more than k, pop smallest. add: push val, if size>k pop. Return heap[0]. Virtual code lines.\n\nWe need to use Start, End, Decision. Each line: \"虛擬碼步驟 // 解釋\". Provide arrow lines. We'll produce steps:\n\nStart\n→ Step 1: Initialize min-heap H // create min-heap for k largest\n→ Step 2: For each num in nums // iterate initial scores\n    → Decision: If H.size < k? // if heap not full\n        Yes → Step 3: Push num into H // add to heap\n        No  → Step 4: If num > H.peek()? // new score larger than smallest in heap\n            Yes → Step 5: Pop from H then Push num // replace smallest\n            No  → Step 6: Discard num // ignore\n→ Step 7: End of initialization\n\nAdd function:\nStart\n→ Step 8: Push val into H // add new score\n→ Step 9: If H.size > k? // heap overflow\n    Yes → Step 10: Pop from H // remove smallest\n    No  → Step 11: Do nothing\n→ Step 12: Return H.peek() // kth largest\n\nBut we need to incorporate methods. Probably show KthLargest constructor and add method.\n\nWe output line by line.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: Create min-heap H // 用於存放目前k個最大分數\n→ Step 2: For each score s in initial array nums // 逐一處理初始分數\n    → Decision: 若 H.size < k? // 判斷堆是否已滿\n        Yes → Step 3: Push s into H // 將分數加入堆\n        No  → Decision: 若 s > H.peek()? // 新分數比堆中最小分數大？\n            Yes → Step 4: Pop H.peek()；Push s // 取代最小分數\n            No  → Step 5: 忽略 s // 不影響前k大分數\n→ End // 初始化完成\n\nStart // add 方法開始\n→ Step 6: Push val into H // 新分數進入堆\n→ Decision: 若 H.size > k? // 堆容量是否超過k\n    Yes → Step 7: Pop H.peek() // 移除最小分數以維持k個\n    No  → Step 8: Do nothing\n→ Step 9: Return H.peek() // 堆頂即為第k大分數\nEnd // add 方法結束\n\nBut we need to show as a virtual code structure: Start, End, Decision, Yes→, No→. Might need to indent lines.\n\nLet's produce a more structured approach:\n\nStart // 程式開始\n→ Step 1: 初始化 min-heap H // 用來保存k個最大分數\n→ Step 2: 遍歷初始陣列 nums\n    → Decision: 如果 H.size < k? // 堆未滿\n        Yes → Step 3: 將 nums[i] 插入 H\n        No  → Decision: 如果 nums[i] > H.peek()? // 新分數比堆中最小分數大\n            Yes → Step 4: 移除 H.peek()；再插入 nums[i]\n            No  → Step 5: 忽略此分數\n→ End // 初始化完成\n\nStart // add 方法開始\n→ Step 6: 將 val 插入 H\n→ Decision: 若 H.size > k? // 堆溢出\n    Yes → Step 7: 移除 H.peek()\n    No  → Step 8: 什麼也不做\n→ Step 9: 返回 H.peek() // 第k大分數\nEnd // add 方法結束\n\nBut we need to produce as virtual code lines with arrow and comments. Provide each line separately. For decisions we might need sub-steps lines. Use indentation with spaces? We'll just use spaces to show indent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立最小堆 H // 用來儲存目前最大的 k 個分數\n→ Step 2: 遍歷初始陣列 nums // 處理所有已存在的分數\n    → Decision: H.size < k? // 堆還沒滿k個元素\n        Yes → Step 3: 將 nums[i] 插入 H // 直接加入堆\n        No  → Decision: nums[i] > H.peek()? // 新分數是否比堆中最小分數大\n            Yes → Step 4: 移除 H.peek()；再將 nums[i] 插入 H // 替換最小分數\n            No  → Step 5: 忽略 nums[i] // 不影響前k大分數\n→ End // 初始化完成\n\nStart // add 方法開始\n→ Step 6: 將 val 插入 H // 新分數加入堆\n→ Decision: H.size > k? // 堆已超過k個元素\n    Yes → Step 7: 移除 H.peek() // 刪除最小分數以維持堆長度\n    No  → Step 8: 不執行任何操作 // 堆長度已在允許範圍內\n→ Step 9: 返回 H.peek() // 堆頂即為第k大分數\nEnd // add 方法結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\", \"root/4.txt\"]]'"
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\"]]'"
        }
      ],
      "generated_code": "from collections import defaultdict\nimport sys\nimport ast\nimport json\n\ndef findDuplicate(paths):\n    \"\"\"Return groups of duplicate file paths based on file content.\"\"\"\n    content_map = defaultdict(list)\n    for path in paths:\n        parts = path.split()\n        root = parts[0]\n        for file_info in parts[1:]:\n            name, content = file_info.split('(')\n            content = content.rstrip(')')          # 去掉右括號\n            full_path = f\"{root}/{name}\"\n            content_map[content].append(full_path)\n    # 只保留至少兩個檔案的群組\n    return [files for files in content_map.values() if len(files) > 1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if data.startswith('paths ='):\n        data = data[len('paths ='):].strip()\n    try:\n        paths = ast.literal_eval(data)\n    except Exception:\n        paths = eval(data)  # 如果 literal_eval 失敗，使用 eval（假設輸入合法）\n    result = findDuplicate(paths)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code in Chinese explanation lines. The algorithm: For each directory info string, parse directory path and files with content. Use hash map content -> list of full paths. After processing all, filter lists with size>1. Output list of lists.\n\nWe'll produce pseudocode step by step. Use virtual code lines. Start, then iterate over list, parse, etc. Use Decision etc.\n\nLet's create:\n\nStart\n→ Step 1: 初始化 map content_to_paths // 用於儲存相同內容對應的檔案路徑\n\n→ Step 2: 迴圈 遍歷 paths // 逐個處理每個目錄資訊\n\nInside loop:\n→ Step 3: 拆分 directory_path 與 files_string // 以空格分割，第一項是目錄路徑，後面是檔案內容\n\n→ Decision: 是否有檔案? // 以確保後續處理\n   Yes → Step 4: 以空格分割 files_string 為 files_list // 取得每個檔案字串\n\nInside files list loop:\n→ Step 5: 拆分檔名與內容 // 以 '(' 與 ')' 分割\n\n→ Step 6: 組合 full_path = directory_path + '/' + file_name // 完整路徑\n\n→ Step 7: 若 content_to_paths 中不存在 content 則新增一個空陣列\n\n→ Step 8: 把 full_path 加入 content_to_paths[content] // 收集相同內容的路徑\n\nAfter outer loop end:\n→ Step 9: 初始化 result // 用於儲存重複檔案群組\n\n→ Step 10: 迴圈 遍歷 content_to_paths 的值 // 每個內容對應的路徑列表\n\n→ Decision: 列表長度>1? // 只保留重複的\n\n   Yes → Step 11: 把該列表加入 result // 收集\n\nEnd\n\nReturn result\n\nThat's the pseudocode lines. Ensure each line ends with // 解釋. Use virtual arrow lines.\n\nWe should format exactly. Let's produce lines.\n\nWe may need to denote loops: e.g., \"→ Loop: For each path in paths // ...\". Similarly for inner loops.\n\nLet's produce.\n\nAlso we need to include 'Decision:' lines with Yes →, No →.\n\nWe might use 'Decision: 是否有檔案?' But that may not be necessary. Could skip that decision and directly parse.\n\nBut maintain structure.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: content_to_paths = {} // 建立內容到檔案路徑的映射\n→ Loop: For each dir_info in paths // 逐行處理每個目錄資訊\n    → Step 2: parts = dir_info.split(' ') // 以空格分割，第一個是目錄路徑\n    → Step 3: dir_path = parts[0] // 取得目錄路徑\n    → Step 4: files = parts[1:] // 其餘為檔案字串\n    → Loop: For each file_str in files // 處理每個檔案\n        → Step 5: name, content = file_str.split('(') // 拆分檔名與內容\n        → Step 6: content = content.rstrip(')') // 去除右括號\n        → Step 7: full_path = dir_path + '/' + name // 組成完整路徑\n        → Decision: content 於 content_to_paths 中? // 檢查是否已存在此內容\n            Yes → Step 8: content_to_paths[content].append(full_path) // 加入已存在的列表\n            No  → Step 8: content_to_paths[content] = [full_path] // 建立新列表\n→ Step 9: result = [] // 用於儲存重複檔案群組\n→ Loop: For each paths_list in content_to_paths.values() // 遍歷所有內容對應的路徑\n    → Decision: len(paths_list) > 1? // 只保留至少兩個檔案的群組\n        Yes → Step 10: result.append(paths_list) // 加入結果\n        No  → Step 10: pass // 無需處理\nEnd // 程式執行結束\n\nWe should add explanation after each line.\n\nMake sure each line ends with // ... The lines inside loops should have indentation but it's okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: content_to_paths = {} // 建立內容到檔案路徑的映射  \n→ Loop: For each dir_info in paths // 逐行處理每個目錄資訊  \n    → Step 2: parts = dir_info.split(' ') // 以空格分割，第一個是目錄路徑  \n    → Step 3: dir_path = parts[0] // 取得目錄路徑  \n    → Step 4: files = parts[1:] // 其餘為檔案字串  \n    → Loop: For each file_str in files // 處理每個檔案  \n        → Step 5: name, content = file_str.split('(') // 拆分檔名與內容  \n        → Step 6: content = content.rstrip(')') // 去除右括號  \n        → Step 7: full_path = dir_path + '/' + name // 組成完整路徑  \n        → Decision: content 於 content_to_paths 中? // 檢查是否已存在此內容  \n            Yes → Step 8: content_to_paths[content].append(full_path) // 加入已存在的列表  \n            No  → Step 8: content_to_paths[content] = [full_path] // 建立新列表  \n→ Step 9: result = [] // 用於儲存重複檔案群組  \n→ Loop: For each paths_list in content_to_paths.values() // 遍歷所有內容對應的路徑  \n    → Decision: len(paths_list) > 1? // 只保留至少兩個檔案的群組  \n        Yes → Step 10: result.append(paths_list) // 加入結果  \n        No  → Step 10: pass // 無需處理  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[3]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[3]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[7,3,10]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[7,3,10]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\n# 假設已經有一個 API rand7() 可用\ndef rand7() -> int:\n    \"\"\"回傳 1 到 7 的均勻隨機整數。\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"使用 rand7() 產生 1 到 10 的均勻隨機整數。\"\"\"\n        while True:\n            # 兩次 rand7() 產生 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:  # 只使用 1~40 以保持均勻\n                return 1 + (num - 1) % 10\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整數 n（例如：'n = 3'）\n    data = sys.stdin.read().strip()\n    # 找出字串中的第一個整數\n    n = 0\n    for part in data.split():\n        if part.isdigit():\n            n = int(part)\n            break\n    # 產生 n 個 rand10() 的結果\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    # 輸出格式符合範例：無空格的列表\n    output = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines following format. Need to explain algorithm: use rand7 to generate 49 outcomes via two calls (like base-7), use rejection to get 1-10 uniform.\n\nExplain: generate x = (rand7()-1)*7 + rand7(); // 1-49. If <=40, return (x-1)%10 +1. Else repeat.\n\nAdd loops, decisions.\n\nWe need step-by-step. Provide Start, then Steps, etc. Use arrow \"→\" and \"Decision:\".\n\nLet's craft:\n\nStart\n→ Step 1: 產生 x = (rand7() - 1) * 7 + rand7() // 兩次 rand7 產生 1-49\n→ Decision: x <= 40? // 檢查是否在可接受範圍\n    Yes → Step 2: 返回 (x - 1) mod 10 + 1 // 轉換為 1-10\n    No  → Step 3: 重複 Step 1 // 重新嘗試直到成功\nEnd\n\nWe need to show loop structure. Use decision repeated. Use End. Add maybe a while loop concept.\n\nCould use:\n\n→ Loop: \n    → Step 1 ...\n    → Decision ...\n        Yes ...\n        No ...\n\nBut virtual code can show recursion? Use while. Use Decision: while true? Actually can represent:\n\n→ Decision: True? // 永遠 true\n    Yes → Step 1 ...\n\nBut simpler: use \"Repeat\" maybe not allowed? But we can do decision.\n\nLet's produce:\n\nStart\n→ Decision: 永遠 true? // 進入無限迴圈直到產生有效值\n    Yes → Step 1: x = (rand7() - 1) * 7 + rand7() // 產生 1-49\n        → Decision: x <= 40?\n            Yes → Step 2: return (x - 1) mod 10 + 1 // 轉換為 1-10\n            No  → (回到 Decision: 永遠 true?) // 重試\nEnd\n\nBut need to have arrows. Provide nested decisions.\n\nLet's produce a cleaner:\n\nStart\n→ Decision: 1 // 進入重試迴圈\n    Yes →\n        Step 1: x = (rand7() - 1) * 7 + rand7() // 兩次 rand7 產生 1-49\n        → Decision: x <= 40?\n            Yes → Step 2: return (x - 1) mod 10 + 1 // 轉換為 1-10\n            No  → (回到外層 Decision: 1) // 重試\nEnd\n\nBut \"回到外層 Decision: 1\" maybe ambiguous. Might instead use loop:\n\n→ Loop: \n    Step 1: ...\n    Decision: ...\n        Yes → Step 2\n        No  → (continue loop)\n\nBut we need use arrow.\n\nBetter to represent like:\n\n→ Decision: 永遠 true\n    Yes → Step 1\n        → Decision: x <= 40?\n            Yes → Step 2\n            No  → (返回至外層 Decision: 永遠 true) // 重試\n\nOk.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: 永遠 true? // 進入無限迴圈直到產生有效值\n    Yes →\n        Step 1: x = (rand7() - 1) * 7 + rand7() // 兩次 rand7 產生 1~49 的數字\n        → Decision: x <= 40? // 檢查數字是否在可接受範圍\n            Yes → Step 2: return (x - 1) mod 10 + 1 // 將 1~40 轉為 1~10，返回結果\n            No  → (回到外層 Decision: 永遠 true) // 若超過 40，重新嘗試\nEnd // 程式執行結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        # 計算兩點之間距離平方，避免浮點誤差\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n\n        # 取得所有 6 對點之間的距離平方\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n\n        # 邊長必須大於 0，四邊相等，兩條對角相等且對角長度大於邊長\n        return (\n            dists[0] > 0 and\n            dists[0] == dists[1] == dists[2] == dists[3] and\n            dists[4] == dists[5] and\n            dists[4] > dists[0]\n        )\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 取得所有整數（含負號）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) != 8:\n        print(\"false\")\n        sys.exit(0)\n    # 將數字分成四個點\n    points = [[nums[i], nums[i + 1]] for i in range(0, 8, 2)]\n    sol = Solution()\n    result = sol.validSquare(*points)\n    # 依題目要求輸出小寫\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line by line for checking if 4 points form a square. Must be virtual code not actual code. Steps: compute all pairwise distances squared. Sort. Check first 4 equal (sides), last 2 equal (diagonals), diagonal > side, and side >0. So produce steps. Use Start, Decision, etc. Provide explanations. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 points 為 [p1, p2, p3, p4] // 收集四個點  \n→ Step 2: 初始化 distances 為空陣列 // 用於儲存所有 6 對之間的距離平方  \n→ Step 3: 循環 i 從 0 到 3  \n  → Step 3.1: 循環 j 從 i+1 到 3  \n    → Step 3.1.1: 計算 dx = points[i].x - points[j].x // 差值 x  \n    → Step 3.1.2: 計算 dy = points[i].y - points[j].y // 差值 y  \n    → Step 3.1.3: 計算 dist = dx*dx + dy*dy // 距離平方  \n    → Step 3.1.4: 將 dist 加入 distances // 收集距離  \n→ Step 4: 將 distances 依大小排序 // 方便後續判斷  \n→ Decision: 是否有 6 個距離？ // 檢查是否完整  \n  Yes → Step 5: 計算 side = distances[0] // 最短距離為邊長  \n    → Decision: side == 0? // 邊長不能為 0  \n     Yes → Step 6: 輸出 False // 退化為點，非正方形  \n     No → Step 7: 判斷前四個距離是否相等  \n      → Decision: distances[0]==distances[1] AND distances[1]==distances[2] AND distances[2]==distances[3]? // 四邊相等  \n       Yes → Step 8: 判斷最後兩個距離是否相等且大於邊長  \n        → Decision: distances[4]==distances[5] AND distances[4]>side?  \n         Yes → Step 9: 輸出 True // 四邊相等，兩對角相等且長度大於邊長 → 正方形  \n         No → Step 10: 輸出 False // 對角不相等或不大於邊長  \n      No → Step 11: 輸出 False // 四邊不相等  \n  No → Step 12: 輸出 False // 距離數量不足  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp83xqp4ja.py\", line 43, in <module>\n    price, special, needs = parse_input(raw)\n                            ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp83xqp4ja.py\", line 35, in parse_input\n    raise ValueError(\"輸入格式錯誤，請提供三個列表。\")\nValueError: 輸入格式錯誤，請提供三個列表。"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpesbgg3l9.py\", line 43, in <module>\n    price, special, needs = parse_input(raw)\n                            ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpesbgg3l9.py\", line 35, in parse_input\n    raise ValueError(\"輸入格式錯誤，請提供三個列表。\")\nValueError: 輸入格式錯誤，請提供三個列表。"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom typing import List\n\nclass Solution:\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs: List[int]) -> int:\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # cost without any special offer\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            # try every special offer\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中抽取 price、special、needs 三個列表。\"\"\"\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) != 3:\n        raise ValueError(\"輸入格式錯誤，請提供三個列表。\")\n    price = ast.literal_eval(lists[0])\n    special = ast.literal_eval(lists[1])\n    needs = ast.literal_eval(lists[2])\n    return price, special, needs\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    price, special, needs = parse_input(raw)\n    sol = Solution()\n    result = sol.shoppingOffers(price, special, needs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solving LeetCode Shopping Offers problem (minimum cost with special offers). Must output line by line, with virtual code and comment. Use Start, Decision, etc.\n\nWe need to outline algorithm: DFS with memoization or DP. Steps: preprocess offers: remove useless ones. Then recursive function dfs(remaining) returns min cost. Use memoization map key as string of remaining counts.\n\nImplementation steps: Start, read price, needs, special. Preprocess: filter offers where each item count <= needs and offer price < sum of normal price. Then define DFS(remaining). If remaining all zero, return 0. Compute cost = sum(remaining[i] * price[i]). Then for each offer: if offer can be applied (offer counts <= remaining): new_remaining = remaining - offer counts; cost = min(cost, offer price + dfs(new_remaining)). Store memo. Return cost. End.\n\nNeed to output lines accordingly.\n\nLet's craft pseudocode line by line.\n\nLine: Start // 程式開始\n\n→ Step 1: 讀取 price, needs, special arrays // 取得商品價格、需求量與特價資訊\n\n→ Step 2: 初始化 memo map // 用於儲存已計算過的子問題結果\n\n→ Step 3: 呼叫 dfs(needs) 並輸出結果 // 取得最小總價\n\n→ Step 4: End // 程式結束\n\nBut we need define dfs. So maybe separate subfunction.\n\nDefine function dfs(remaining) // 參數為當前剩餘購買需求\n\n→ Decision: 檢查 memo 是否有 remaining // 若已計算過\n\n    Yes → Return memo[remaining] // 直接回傳\n\n→ Decision: 是否所有 remaining 為 0? // 若需求已滿\n\n    Yes → memo[remaining] = 0 // 無需再購買\n\n    No →\n\n→ Step 5: 計算 baseCost = sum(remaining[i] * price[i]) // 直接按單價購買\n\n→ Step 6: minCost ← baseCost // 初始最小成本\n\n→ Step 7: For each offer in special 循環\n\n    → Decision: 是否 offer 可套用 (offer[i] <= remaining[i] for all i) // 檢查是否符合需求\n\n        Yes →\n\n            → Step 8: newRemaining ← remaining - offer[i] for each i // 減去已購買的數量\n\n            → Step 9: offerCost ← offer price + dfs(newRemaining) // 計算套用此特價後的總價\n\n            → Decision: 是否 offerCost < minCost? // 更新最小成本\n\n                Yes → minCost ← offerCost\n\n        No → continue\n\n→ Step 10: memo[remaining] ← minCost // 記錄結果\n\n→ Step 11: Return minCost\n\nBut we also should include preprocessing step to filter offers. Let's incorporate.\n\n→ Step 2a: Preprocess special offers: 移除不必要的 offer // 只保留在需求內且價格較低的特價\n\nWe need details.\n\nLet's produce final pseudocode lines accordingly. Ensure each line has \"虛擬碼步驟\" and comment.\n\nNeed to include arrow arrows and indentation. We'll include indentation via spaces maybe. Provide lines accordingly. Let's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取 price, needs, special // 取得商品價格、需求量與特價資訊\n→ Step 2: 初始化 memo map // 用於儲存已計算過的子問題結果\n→ Step 3: 呼叫 dfs(needs) 並輸出結果 // 取得最小總價\nEnd // 程式結束\n\n// ---------- Helper function: 深度優先搜尋 ----------\nDefine Function dfs(remaining) // 參數為當前剩餘購買需求\n    → Decision: memo 中是否存在 remaining？ // 若已計算過\n        Yes → Return memo[remaining] // 直接回傳已存的結果\n    → Decision: all remaining[i] == 0? // 若需求已滿\n        Yes → memo[remaining] ← 0 // 無需再購買\n        No →\n    → Step 5: baseCost ← Σ remaining[i] * price[i] // 直接按單價購買的成本\n    → Step 6: minCost ← baseCost // 初始化最小成本為單價總和\n    → For each offer in special 循環\n        → Decision: 所有 offer[i] <= remaining[i]? // 特價是否可套用\n            Yes →\n                → Step 8: newRemaining ← remaining[i] - offer[i] for all i // 減去已購買的數量\n                → Step 9: offerCost ← offer[n] + dfs(newRemaining) // 計算套用此特價後的總成本\n                → Decision: offerCost < minCost? // 更新最小成本\n                    Yes → minCost ← offerCost\n            No → // 特價不可套用，跳過\n    → Step 10: memo[remaining] ← minCost // 記錄結果以備重複使用\n    → Return minCost\n\n// ---------- 先前處理：過濾不必要的特價 ----------\n→ Step 2a: preOffers ← [] // 用於儲存有效特價\n→ For each offer in special 循環\n    → Decision: 所有 offer[i] <= needs[i] 及 offer[n] < Σ offer[i]*price[i]? // 需求內且價格更優惠\n        Yes → preOffers ← preOffers ∪ {offer} // 保留此特價\n→ Step 3a: special ← preOffers // 用有效特價替換原特價\n\n```"
    },
    {
      "title": "Rotate Function",
      "source_file": "Leetcode/leetcode396.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '26'\nGot (Norm):      '34'\n--- (Raw) ---\nRaw Expected: '26'\nRaw Got:      '34'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxRotateFunction(self, A):\n        n = len(A)\n        if n == 0:\n            return 0\n        total = sum(A)\n        F = sum(i * num for i, num in enumerate(A))\n        max_val = F\n        for i in range(n - 1):\n            # Update rotation function using the derived formula\n            F = F + total - n * A[i]\n            if F > max_val:\n                max_val = F\n        return max_val\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        sys.exit(0)\n\n    # Extract the list part from the input, e.g. \"nums = [4,3,2,6]\"\n    try:\n        start = data.index('[')\n        end = data.rindex(']') + 1\n        list_str = data[start:end]\n        nums = ast.literal_eval(list_str)\n    except (ValueError, SyntaxError):\n        # If parsing fails, assume the whole input is a list literal\n        try:\n            nums = ast.literal_eval(data)\n        except Exception:\n            print(0)\n            sys.exit(0)\n\n    solution = Solution()\n    result = solution.maxRotateFunction(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to compute max rotation function. Known solution: compute sum of array, compute initial F(0). Then iteratively compute F(i+1) = F(i) + sum - n * arr[i]. Keep max. Complexity O(n). We'll produce pseudocode lines with explanations. Use virtual code structure with arrows. Use Start, Decision. Each step line: e.g., \"Start // 程式開始\" etc. Provide each line with explanation after //.\n\nLet's draft.\n\nLine1: Start // 程式開始\nLine2: → Input: nums // 讀取輸入陣列\nLine3: → n ← length(nums) // 取得陣列長度\nLine4: → sum ← 0 // 初始化總和\nLine5: → F ← 0 // 初始化旋轉函數值\nLine6: → maxF ← -∞ // 初始化最大值\nLine7: → for i from 0 to n-1 do // 遍歷陣列\nLine8:        sum ← sum + nums[i] // 加總\nLine9:        F ← F + i * nums[i] // 計算 F(0)\nLine10:    end for\nLine11: → maxF ← F // F(0) 作為初始最大值\nLine12: → for i from 0 to n-2 do // 依序計算 F(1)...F(n-1)\nLine13:        // 根據公式更新 F\nLine14:        F ← F + sum - n * nums[i] // 更新旋轉函數值\nLine15:        if F > maxF then // 判斷是否為新最大值\nLine16:            maxF ← F\nLine17:        end if\nLine18:    end for\nLine19: → Output: maxF // 回傳最大旋轉函數值\nLine20: End // 程式結束\n\nNeed to adhere to format: each line \"虛擬碼步驟 // 解釋\". Use arrows \"→\" for each line after Start. Use \"Decision:\" for if.\n\nLet's write accordingly.\n\nRemember each line must contain code + space + // + explanation. Use appropriate arrows. For Decision, use \"Decision:\" with indentation. In example, they used \"Decision:\" with indent. Let's replicate.\n\nWe'll use indentation for inner lines.\n\nMake sure each line ends with // explanation. Use Chinese. For example: \"→ Start // 程式開始\".\n\nBut Start line has no arrow? In example, they used \"Start // 程式開始\". No arrow. Let's keep as \"Start // 程式開始\". Next lines use \"→\".\n\nIndentation: They used spaces before Yes → inside Decision. We'll mimic: \"Decision: ...\". Inside indent, \"Yes →\" and \"No →\". For for loop, we can indent inside. Use simple. The format is flexible but must be similar.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始  \n→ Input: nums // 讀取輸入陣列  \n→ n ← length(nums) // 取得陣列長度  \n→ sum ← 0 // 初始化總和  \n→ F ← 0 // 初始化旋轉函數值  \n→ maxF ← -∞ // 初始化最大值  \n→ for i from 0 to n-1 do // 遍歷陣列計算 F(0) 與總和  \n  sum ← sum + nums[i] // 累加陣列元素  \n  F ← F + i * nums[i] // 累積 F(0)  \n end for  \n→ maxF ← F // 以 F(0) 作為初始最大值  \n→ for i from 0 to n-2 do // 循環計算 F(1) 到 F(n-1)  \n  F ← F + sum - n * nums[i] // 根據公式更新旋轉函數值  \n  Decision: 如果 F 大於 maxF? // 判斷是否更新最大值  \n   Yes → maxF ← F // 若更大，更新 maxF  \n   No  → // 無需更新  \n  end if  \n end for  \n→ Output: maxF // 回傳最大旋轉函數值  \nEnd // 程式結束"
    },
    {
      "title": "Count of Range Sum",
      "source_file": "Leetcode/leetcode327.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [-2,5,-1], lower = -2, upper = 2",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdcmklpvj.py\", line 40, in <module>\n    lower_part = parts[1].split('=')[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def countRangeSum(self, nums, lower, upper):\n        # 建立前綴和陣列\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n\n        # 分治排序並計數\n        def sort_and_count(lo, hi):\n            if hi - lo <= 1:   # 子陣列長度為 0 或 1 時不可能有對\n                return 0\n            mid = (lo + hi) // 2\n            count = sort_and_count(lo, mid) + sort_and_count(mid, hi)\n\n            # 計算跨左右子陣列的對數\n            i = j = mid\n            for left in prefix[lo:mid]:\n                while i < hi and prefix[i] - left < lower:\n                    i += 1\n                while j < hi and prefix[j] - left <= upper:\n                    j += 1\n                count += j - i\n\n            # 合併兩個已排序的子陣列\n            prefix[lo:hi] = sorted(prefix[lo:hi])\n            return count\n\n        return sort_and_count(0, len(prefix))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將輸入字串拆成三部分：nums、lower、upper\n    parts = [p.strip() for p in data.split(',')]\n    nums_part = parts[0].split('=')[1].strip()\n    lower_part = parts[1].split('=')[1].strip()\n    upper_part = parts[2].split('=')[1].strip()\n\n    # 解析陣列與整數\n    nums = eval(nums_part)\n    lower = int(lower_part)\n    upper = int(upper_part)\n\n    solution = Solution()\n    result = solution.countRangeSum(nums, lower, upper)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem. We need to design an algorithm. For counting range sums, typical solution uses prefix sums and divide and conquer (similar to counting inversions). Or use BIT with coordinate compression. We can produce a virtual code that uses divide and conquer counting: compute prefix sums array, then recursive function that counts number of pairs (i<j) where prefix[j]-prefix[i] in [lower, upper]. Steps: compute prefix sums with 0 initial, then merge sort based counting. Provide steps. We'll produce a linear algorithm using divide and conquer.\n\nWe need to output line by line: \"Start // 程式開始執行\" etc. Use arrow arrows and Decision nodes. Provide explanation comments. Should not output actual code. Provide steps like \"Compute prefix sums\" etc.\n\nWe must keep steps in a clear sequential format. Use the structure: Start, → Step, → Decision, etc. Provide explanation after each line.\n\nLet's produce the algorithm steps.\n\nOutline:\n\nStart\n→ Step 1: Build prefix sums array P of length n+1 with P[0]=0, P[i]=P[i-1]+nums[i-1] // compute cumulative sums\n→ Step 2: Call recursive function count_while_merge(P, 0, n) // count pairs in P\n→ Step 3: Return result // final count\n\nNow count_while_merge(low, high):\nIf high - low <= 1: return 0 // base case no pairs\nmid = (low+high)//2\ncount_left = count_while_merge(low, mid)\ncount_right = count_while_merge(mid, high)\ncount_cross = count_cross_pairs(P, low, mid, high, lower, upper) // count pairs with i in [low,mid), j in [mid,high)\nmerge P[low:mid] and P[mid:high] sorted // maintain sorted order\nreturn count_left + count_right + count_cross\n\nCounting cross pairs:\nfor each left in P[low:mid], find number of right in P[mid:high] such that lower <= right - left <= upper\nUsing two pointers: start=j=mid, end=j=mid\nfor left_index in range(low, mid):\n   while j < high and P[j] - left < lower: j++\n   while k < high and P[k] - left <= upper: k++\n   cross_count += k - j\n\nMerge sorted subarrays.\n\nReturn count.\n\nOk produce lines.\n\nWe must incorporate Decision nodes? Possibly for base case.\n\nBut we can illustrate recursion as Decision: If subarray size <=1? Yes -> return 0 else -> proceed. But we can keep it simple: just Steps.\n\nWe need to follow the output format strictly: each line: `虛擬碼步驟` + `[space]` + `// 解釋/說明`.\n\nWe must include arrow symbol `→` where needed, also `Start`, `End`, `Decision:` etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立前綴和陣列 P，P[0] = 0，P[i] = P[i-1] + nums[i-1] // 先計算所有累積和\n→ Step 2: 呼叫 Count(P, 0, n) // 進行分治計數\n→ Step 3: 回傳計數結果 // 最終答案\n\nNow define Count:\n\n→ Decision: 子陣列長度 <=1? // 檢查是否需要再分解\n    Yes → Return 0 // 沒有足夠元素產生區間和\n    No → \n        → Step 4: 計算 mid = (low + high) / 2 // 找中點分割陣列\n        → Step 5: left_count = Count(P, low, mid) // 先處理左半部\n        → Step 6: right_count = Count(P, mid, high) // 再處理右半部\n        → Step 7: cross_count = CountCross(P, low, mid, high, lower, upper) // 計算跨左右的對數\n        → Step 8: MergeSort(P, low, mid, high) // 合併並保持排序\n        → Step 9: Return left_count + right_count + cross_count // 返回總計數\n\nNow define CountCross:\n\n→ Step 10: 初始化 j = mid, k = mid // 指標遍歷右半部\n→ Step 11: For i from low to mid-1: // 遍歷左半部每個前綴和\n    → Decision: 右半部前綴和 < P[i] + lower? // 若右半部前綴和太小，需要移動 j\n        Yes → While j < high and P[j] - P[i] < lower: j++ // 將 j 向右移動至可行區間起點\n    → Decision: 右半部前綴和 <= P[i] + upper? // 若右半部前綴和仍在上限，移動 k\n        Yes → While k < high and P[k] - P[i] <= upper: k++ // k 指向第一個超過上限的位置\n    → Step 12: cross_count += k - j // 右半部符合區間的個數\n\nReturn cross_count\n\nMergeSort:\n\n→ Step 13: 用兩指標 i=low, j=mid, k=low // 合併兩個已排序子陣列\n→ While i < mid and j < high:\n    → Decision: P[i] <= P[j]?\n        Yes → temp[k++] = P[i++]\n        No  → temp[k++] = P[j++]\n→ While i < mid: temp[k++] = P[i++]\n→ While j < high: temp[k++] = P[j++]\n→ For t from low to high-1: P[t] = temp[t] // 將合併結果複寫回 P\n\nEnd // 程式執行結束\n\nWe should ensure each line follows format. We need to ensure \"虛擬碼步驟\" may include arrow and step name. Use \"Step\" as part of description. It's okay.\n\nLet's format precisely.\n\nI will produce each line separately, with comment after //.\n\nLet's write.\n\nNote: Ensure no actual code but virtual steps. We can use simplified pseudo-names: \"計算前綴和\", \"呼叫 Count\", etc.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立前綴和陣列 P，P[0] = 0，P[i] = P[i-1] + nums[i-1] // 先計算所有累積和  \n→ Step 2: 呼叫 Count(P, 0, n) // 進行分治計數  \n→ Step 3: 回傳計數結果 // 最終答案  \n\n// 定義遞迴計數函式  \n→ Decision: 子陣列長度 <= 1? // 檢查是否需要再分解  \n    Yes → Return 0 // 沒有足夠元素產生區間和  \n    No →  \n        → Step 4: 計算 mid = (low + high) / 2 // 找中點分割陣列  \n        → Step 5: left_count = Count(P, low, mid) // 先處理左半部  \n        → Step 6: right_count = Count(P, mid, high) // 再處理右半部  \n        → Step 7: cross_count = CountCross(P, low, mid, high, lower, upper) // 計算跨左右的對數  \n        → Step 8: MergeSort(P, low, mid, high) // 合併並保持排序  \n        → Step 9: Return left_count + right_count + cross_count // 返回總計數  \n\n// 計算跨左右區間對數的輔助函式  \n→ Step 10: 初始化 j = mid, k = mid // 指標遍歷右半部  \n→ Step 11: For i from low to mid-1: // 遍歷左半部每個前綴和  \n    → Decision: 右半部前綴和 < P[i] + lower? // 若右半部前綴和太小，需要移動 j  \n        Yes → While j < high and P[j] - P[i] < lower: j++ // 將 j 向右移動至可行區間起點  \n    → Decision: 右半部前綴和 <= P[i] + upper? // 若右半部前綴和仍在上限，移動 k  \n        Yes → While k < high and P[k] - P[i] <= upper: k++ // k 指向第一個超過上限的位置  \n    → Step 12: cross_count += k - j // 右半部符合區間的個數  \n→ Step 13: Return cross_count // 傳回跨區對數  \n\n// 合併兩個已排序子陣列的輔助函式  \n→ Step 14: 用兩指標 i=low, j=mid, k=low // 合併兩個已排序子陣列  \n→ While i < mid and j < high:  \n    → Decision: P[i] <= P[j]?  \n        Yes → temp[k++] = P[i++]  \n        No  → temp[k++] = P[j++]  \n→ While i < mid: temp[k++] = P[i++] // 把左半部剩餘元素加入  \n→ While j < high: temp[k++] = P[j++] // 把右半部剩餘元素加入  \n→ For t from low to high-1: P[t] = temp[t] // 將合併結果複寫回 P  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Time Based Key-Value Store",
      "source_file": "Leetcode/leetcode981.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,\"bar\",\"bar\",null,\"bar2\",\"bar2\"]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport bisect\nimport json\nfrom collections import defaultdict\n\nclass TimeMap:\n    def __init__(self):\n        self.store = defaultdict(list)\n\n    def set(self, key, value, timestamp):\n        self.store[key].append((timestamp, value))\n\n    def get(self, key, timestamp):\n        if key not in self.store:\n            return None\n        arr = self.store[key]\n        i = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if i == 0:\n            return None\n        return arr[i - 1][1]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    ops = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n\n    results = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"TimeMap\":\n            obj = TimeMap()\n            results.append(None)\n        elif op == \"set\":\n            obj.set(*args)\n            results.append(None)\n        elif op == \"get\":\n            res = obj.get(*args)\n            results.append(res)\n\n    output = '[' + ', '.join(json.dumps(r) for r in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The task: design a time-based key-value data structure: TimeMap with set and get. Need to output virtual code lines with explanation. Let's think of data structure: use a hash map key -> list of (timestamp, value) sorted by timestamp. set: append. get: binary search for <= timestamp. Implementation logic.\n\nWe'll produce virtual code lines like:\n\nStart // begin\n→ Step: define class TimeMap // initialize\n→ Step: create dictionary map // store key to list\n...\n\nWe need to include Decision steps.\n\nLet's produce step-by-step algorithm for constructor, set, get.\n\nAlso we might include steps for binary search.\n\nWe need to provide virtual code only, no actual code. Use arrows.\n\nLet's outline:\n\nStart\n→ Step 1: Define class TimeMap\n→ Step 2: Initialize internal dictionary map\n→ Step 3: Define method set(key, value, timestamp)\n    → Step 3.1: If key not in map, add empty list\n    → Step 3.2: Append (timestamp, value) to list\n→ Step 4: Define method get(key, timestamp)\n    → Decision: If key not in map? // no entries\n        Yes → Return \"\"\n        No  → Step 4.1: Retrieve list\n        Step 4.2: Binary search for largest index where timestamp <= given\n            → Decision: If found? \n                Yes → Return value at that index\n                No  → Return \"\"\nEnd\n\nAlso we might include step to keep list sorted but since we only append increasing timestamp, it's sorted.\n\nWe need to ensure each line has \"虛擬碼步驟\" then space then comment.\n\nAlso use Decision: and Yes → / No →.\n\nLet's produce.\n\nWe must produce each line separately.\n\nWill include Start and End.\n\nLet's start.\n\nWill use arrow \"→\" before each step.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 TimeMap // 初始化時間鍵值資料結構\n→ Step 2: 建立空字典 map // key → list of (timestamp, value) // 用於存儲多個時間戳的值\n→ Step 3: 定義方法 set(key, value, timestamp) // 存儲鍵值對\n    → Step 3.1: Decision: 若 key 不在 map? // 檢查是否已有該鍵\n        Yes → Step 3.1.1: 在 map 中新增 key 並初始化為空列表 // 新鍵建立\n        No  → // 已存在，無需新增\n    → Step 3.2: Step 3.3: 把 (timestamp, value) 附加到 map[key] 列表中 // 時間戳遞增，保持排序\n→ Step 4: 定義方法 get(key, timestamp) // 取得指定時間戳的值\n    → Decision: 若 key 不在 map? // 該鍵不存在\n        Yes → Step 4.1: Return \"\" // 無資料，返回空字串\n        No  → Step 4.2: 取得 list = map[key] // 讀取對應列表\n        → Step 4.3: BinarySearch(list, timestamp) // 找到最大 timestamp_prev ≤ timestamp\n            → Decision: 若找不到? // 所有時間戳都大於查詢時間\n                Yes → Step 4.4: Return \"\" // 無符合條件的值\n                No  → Step 4.5: Return list[foundIndex].value // 回傳對應值\nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        # 對每個相鄰對進行檢查並交換以符合 < > < > 的模式\n        for i in range(len(nums) - 1):\n            if i % 2 == 0:\n                # 偶數位應該小於下一個\n                if nums[i] >= nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n            else:\n                # 奇數位應該大於下一個\n                if nums[i] <= nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        return nums\n\ndef parse_input(input_str):\n    \"\"\"\n    解析輸入字串，例如：\n        'nums = [1,5,1,1,6,4]'\n    轉成 Python list。\n    \"\"\"\n    if '=' in input_str:\n        _, expr = input_str.split('=', 1)\n        return ast.literal_eval(expr.strip())\n    else:\n        # 若直接給陣列字串\n        return ast.literal_eval(input_str.strip())\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.wiggleSort(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code that reorders an integer array into wiggle sequence: nums[0] < nums[1] > nums[2] < nums[3]...\n\nGiven that there's always a valid answer. Classic Leetcode 280. The typical solution is to iterate and swap when condition fails.\n\nWe need to produce step-by-step virtual code, no actual code. Use arrow, Start, End, Decision, etc.\n\nWe must produce line-by-line, each line: \"虛擬碼步驟 // 解釋\"\n\nWe should produce maybe:\n\nStart\n→ Step 1: 獲取輸入陣列 nums // 取得陣列\n→ Step 2: 初始化 index i = 0 // 從第一個元素開始\n→ Decision: i < length(nums) - 1? // 檢查是否還有相鄰元素\n    Yes → Step 3: 如果 i 為偶數則 // i%2==0\n        Yes → Decision: nums[i] >= nums[i+1]? // 檢查小於\n            Yes → Step 4: 交換 nums[i] 與 nums[i+1] // 交換以滿足 < 條件\n        No → No action // 已滿足\n    No → Step 5: 如果 i 為奇數則 // i%2==1\n        Yes → Decision: nums[i] <= nums[i+1]? // 檢查大於\n            Yes → Step 6: 交換 nums[i] 與 nums[i+1] // 交換以滿足 > 條件\n        No → No action // 已滿足\n→ Step 7: i = i + 1 // 移動到下一對\n→ Step 8: 迴圈回到 Decision\nEnd\n\nBut we need to produce proper arrow style.\n\nBetter: Use Start, Decision: If i % 2 == 0 else etc.\n\nSimplify: For each i from 0 to len-2:\nif (i%2==0 && nums[i] >= nums[i+1]) swap\nif (i%2==1 && nums[i] <= nums[i+1]) swap\n\nWe'll produce virtual code accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 取得要重新排序的整數陣列  \n→ Step 2: 設定 i = 0 // 從第一個索引開始  \n→ Decision: i < length(nums) - 1? // 檢查是否還有相鄰的元素  \n Yes → Step 3: 判斷 i 是偶數? // 根據索引決定 \"<\" 或 \">\"  \n  Yes → Decision: nums[i] ≥ nums[i+1]? // 偶數位需小於下一個  \n   Yes → Step 4: 交換 nums[i] 與 nums[i+1] // 交換以滿足 \"<\" 條件  \n   No → No action // 已滿足 \"<\" 條件  \n  No → Step 5: 判斷 i 是奇數? // 奇數位需大於下一個  \n   Yes → Decision: nums[i] ≤ nums[i+1]? // 奇數位需大於下一個  \n    Yes → Step 6: 交換 nums[i] 與 nums[i+1] // 交換以滿足 \">\" 條件  \n    No → No action // 已滿足 \">\" 條件  \n  No → No action // 不會發生，因為 i 只會是偶數或奇數  \n→ Step 7: i = i + 1 // 移至下一個索引  \n→ Step 8: 迴圈回到 Decision  \nEnd // 程式執行結束，陣列已經符合 nums[0] < nums[1] > nums[2] < nums[3] ... 的排列要求"
    },
    {
      "title": "Prime Number of Set Bits in Binary Representation",
      "source_file": "Leetcode/leetcode762.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "left = 6, right = 10",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "left = 10, right = 15",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef count_prime_set_bits(left: int, right: int) -> int:\n    \"\"\"Count numbers in [left, right] whose binary representation has a prime number of 1-bits.\"\"\"\n    primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31}\n    count = 0\n    for num in range(left, right + 1):\n        bits = bin(num).count('1')\n        if bits in primes:\n            count += 1\n    return count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    numbers = [int(x) for x in re.findall(r'-?\\\\d+', data)]\n    if len(numbers) >= 2:\n        left, right = numbers[0], numbers[1]\n        result = count_prime_set_bits(left, right)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for counting numbers in [left,right] with prime number of set bits. Provide each line with \"→\" or Start/End etc. Explanation after space. Use decision arrows.\n\nWe must not output actual code, just pseudocode. Also no code language. Provide stepwise: Start, compute primes up to 31 (since int bits). For each number in range, count set bits, check prime, increment count. Output final count. Use decision blocks.\n\nWe should include loop over range. Use decision: if prime? etc. Use variable names.\n\nLet's craft.\n\nLines:\n\nStart // program start\n→ Step 1: Initialize count to 0 // counter for valid numbers\n→ Step 2: Determine primes up to 31 and store in set // precompute prime bit counts\n→ Step 3: For each num from left to right inclusive // iterate range\n→ Step 4: Count set bits of num and store in bits // count 1s\n→ Decision: Is bits in prime set? // check prime\n Yes → Step 5: Increment count // number qualifies\n No → Step 6: Do nothing // skip\n→ Step 7: End of loop // after all numbers processed\n→ Step 8: Return count // output result\nEnd // program end\n\nNeed to include \"Decision:\" and arrows inside.\n\nAlso maybe we can add a helper for counting bits.\n\nWe might use subroutine: Step 4 could be \"→ Subroutine: countSetBits(num) → bits\" but better keep simple.\n\nWe must adhere to formatting: Each line must be \"虛擬碼步驟 [space] // 解釋\".\n\nEnsure arrows and indentations maybe using spaces.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize count to 0 // 建立計數器，用於統計符合條件的數字  \n→ Step 2: Determine primes up to 31 and store in primeSet // 先找出 0~31 之間的質數，因為 32 位整數最多只有 32 個 1  \n→ Step 3: For each num from left to right inclusive // 逐一遍歷給定範圍內的所有整數  \n→ Step 4: Count set bits of num and store in bits // 計算 num 的二進位表示中 1 的個數  \n→ Decision: Is bits in primeSet? // 檢查該數字的 set bits 數是否為質數  \n Yes → Step 5: Increment count // 若為質數，將計數器加 1  \n No → Step 6: Do nothing // 若不是質數，跳過  \n→ Step 7: End of loop // 所有數字已處理完畢  \n→ Step 8: Return count // 將符合條件的數字總數回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0iik6_aa.py\", line 69, in <module>\n    main()\n  File \"/tmp/tmp0iik6_aa.py\", line 47, in main\n    ops, args = parse_input(data)\n                ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp0iik6_aa.py\", line 39, in parse_input\n    args = ast.literal_eval(parts[1])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        \"\"\"Push element x onto the stack.\"\"\"\n        self.q2.append(x)                       # 1. 把新元素加入輔助隊列\n        while self.q1:                          # 2. 將主隊列所有元素搬到輔助隊列\n            self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1     # 3. 交換兩個隊列，主隊列恢復為完整堆疊\n\n    def pop(self) -> int:\n        \"\"\"Remove the element on the top of the stack and return it.\"\"\"\n        return self.q1.popleft()                # 4. 直接從主隊列前端取出即為堆疊頂部\n\n    def top(self) -> int:\n        \"\"\"Get the top element.\"\"\"\n        return self.q1[0]                       # 5. 只看主隊列前端\n\n    def empty(self) -> bool:\n        \"\"\"Return True if the stack is empty, False otherwise.\"\"\"\n        return not self.q1                      # 6. 判斷主隊列是否為空\n\n\ndef parse_input(s: str):\n    \"\"\"Parse the special LeetCode-style input string into ops and args.\"\"\"\n    if s.startswith(\"Input\"):\n        s = s[len(\"Input\"):].strip()\n    # Replace the separator to split into two list strings\n    s = s.replace(\"], [\", \"]|[\")\n    parts = s.split(\"|\")\n    ops = ast.literal_eval(parts[0])\n    args = ast.literal_eval(parts[1])\n    return ops, args\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    ops, args = parse_input(data)\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyStack\":\n            obj = MyStack()\n            res.append(None)                    # constructor returns null\n        elif op == \"push\":\n            obj.push(arg[0])\n            res.append(None)                    # push returns null\n        elif op == \"pop\":\n            res.append(obj.pop())\n        elif op == \"top\":\n            res.append(obj.top())\n        elif op == \"empty\":\n            res.append(obj.empty())\n    # Output in LeetCode JSON-like format\n    print(json.dumps(res))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code (like pseudocode steps) line by line with arrow and explanation. Must use only two queues. Standard stack operations. So we need algorithm: push: add to empty queue1? Actually common method: use two queues q1, q2. For push, enqueue to q2, then dequeue all from q1 and enqueue to q2, then swap names. That makes push O(n). Pop: dequeue from q1. Top: peek front of q1. Empty: q1.isEmpty.\n\nLet's produce steps: Start, initialize two queues. push: q2.enqueue(x); while q1 not empty: q2.enqueue(q1.dequeue()); swap q1 and q2. pop: return q1.dequeue(); top: return q1.peek(); empty: return q1.isEmpty(); End.\n\nNeed to provide each line as \"虛擬碼步驟 // 解釋\".\n\nWe also need to use Decision structure maybe not necessary but show operations.\n\nLet's produce lines:\n\nStart // 初始化程式\n→ Step 1: 建立兩個空隊列 Q1, Q2 // 用於模擬堆疊\n\nDefine push function: Step 2: 進入 push(x) // 進行推入操作\n→ Step 3: Q2.enqueue(x) // 把新元素放入輔助隊列\n→ Decision: 如果 Q1 非空? // 需要搬移現有元素\n    Yes → Step 4: 迴圈 While Q1 非空:\n                Q2.enqueue(Q1.dequeue()) // 把 Q1 的所有元素移到 Q2\n    No  →  // 若 Q1 空，直接跳過\n→ Step 5: 交換 Q1 與 Q2 的引用 // 使 Q1 成為含所有元素的隊列\n→ Step 6: 返回 // push 完成\n\npop: Step 7: 進入 pop() // 進行彈出操作\n→ Decision: Q1 是否為空? // 檢查是否有元素\n    Yes → Step 8: 返回錯誤/空值 // 無元素可彈出\n    No  → Step 9: 返回 Q1.dequeue() // 移除並返回頂部元素\n\ntop: Step 10: 進入 top() // 取得頂部元素\n→ Decision: Q1 是否為空?\n    Yes → Step 11: 返回錯誤/空值\n    No  → Step 12: 返回 Q1.peek() // 取得隊首元素\n\nempty: Step 13: 進入 empty() // 判斷是否為空\n→ Decision: Q1.isEmpty()?\n    Yes → Step 14: 返回 true\n    No  → Step 15: 返回 false\n\nEnd // 程式結束\n\nNeed to keep format: each line with arrow if substeps? Might produce indentation. They expect each line separate. Use arrow for each step. Indentation for nested steps? In example they used \"→ Decision:\" then indent Yes → Step etc. Let's emulate that.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立兩個空隊列 Q1, Q2 // 用於模擬堆疊  \n\n→ Function: push(x) // 推入新元素  \n→ Step 2: Q2.enqueue(x) // 把新元素放入輔助隊列  \n→ Decision: 如果 Q1 非空? // 判斷是否有現有元素需要搬移  \n  Yes → While Q1 非空:  \n    Q2.enqueue(Q1.dequeue()) // 把 Q1 的所有元素移到 Q2  \n  No  → // Q1 已空，直接跳過  \n→ Step 3: 交換 Q1 與 Q2 的引用 // 讓 Q1 成為含所有元素的隊列，Q2 重新成空  \n→ Step 4: 返回 // 推入完成  \n\n→ Function: pop() // 彈出頂部元素  \n→ Decision: Q1.isEmpty()? // 檢查是否有元素可彈出  \n  Yes → Step 5: 返回錯誤/空值 // 堆疊為空的情況  \n  No  → Step 6: 返回 Q1.dequeue() // 移除並返回隊首元素  \n\n→ Function: top() // 取得頂部元素  \n→ Decision: Q1.isEmpty()?  \n  Yes → Step 7: 返回錯誤/空值 // 堆疊為空  \n  No  → Step 8: 返回 Q1.peek() // 取得隊首元素（即堆疊頂部）  \n\n→ Function: empty() // 判斷堆疊是否為空  \n→ Decision: Q1.isEmpty()?  \n  Yes → Step 9: 返回 true // 堆疊為空  \n  No  → Step 10: 返回 false // 堆疊非空  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        \"\"\"\n        使用并查集将所有关联的邮箱合并。\n        \"\"\"\n        parent = {}          # 邮箱到其父节点的映射\n        email_to_name = {}   # 邮箱对应的姓名\n\n        def find(x):\n            \"\"\"\n            递归查找根节点并做路径压缩。\n            \"\"\"\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        # 1. 建立并查集结构\n        for account in accounts:\n            name = account[0]\n            first_email = account[1]\n            # 将此账号下所有邮箱与 first_email 合并\n            for email in account[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                if root1 != root2:\n                    parent[root2] = root1\n                email_to_name[email] = name\n\n        # 2. 根据根节点收集邮箱\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        # 3. 生成最终结果：姓名 + 排序后的邮箱列表\n        result = []\n        for root, emails in merged.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\ndef main():\n    \"\"\"\n    主函数：从标准输入读取数据，调用算法并输出结果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 如果输入包含变量名，例如 \"accounts = [...]\"，先去掉它\n    if data.startswith('accounts'):\n        _, data = data.split('=', 1)\n        data = data.strip()\n\n    # 解析字符串为 Python 对象（列表）\n    accounts = ast.literal_eval(data)\n\n    solver = Solution()\n    merged_accounts = solver.accountsMerge(accounts)\n\n    # 输出结果，保持与示例相同的列表格式\n    print(merged_accounts)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines. Steps: Build graph mapping emails to name and adjacency via same account. Then DFS/BFS to group. Then output sorted emails.\n\nWe need to use \"虛擬碼步驟\" and comments. Provide lines. Use arrows.\n\nLet's outline:\n\nStart\n→ Build empty map email_to_name\n→ Build empty adjacency map email_to_neighbors\n\n→ Decision: accounts list empty? (But we can skip)\n\nLoop over each account\n   → Extract name = account[0]\n   → Loop over emails from index1\n        → Set email_to_name[email] = name\n        → If first email not set, set prev = email\n        → Else: Add edge between prev and email in adjacency\n        → Update prev = email\n\nAfter building graph\n→ Initialize visited set\n→ Initialize result list\n\n→ For each email in email_to_name keys\n    → Decision: email visited?\n        Yes → Continue\n        No → Start new component\n            → Initialize stack with email\n            → Initialize component list\n            → While stack not empty\n                → Pop cur\n                → Decision: cur visited?\n                    Yes → Continue\n                    No → Mark visited\n                    → Add cur to component\n                    → For each neighbor in adjacency[cur]\n                        → Push neighbor to stack\n            → Sort component\n            → Prepend name (email_to_name[email])\n            → Append to result\n\nEnd\n\nReturn result\n\nWe need to output as lines with comments. Let's produce accordingly.\n\nMake sure each line includes the step and comment. Use indentation? Probably not needed. Just arrow lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 map email_to_name，存放每封信件對應的姓名 // 方便之後根據信件取得姓名\n→ Step 2: 建立 map email_to_neighbors，存放相同帳號內信件之間的鄰接關係 // 用於構建圖形\n→ Decision: 是否有帳號資料? // 檢查輸入是否為空\n    No  → End // 沒有資料直接結束\n\n→ Step 3: For each account in accounts\n    → Step 3a: name = account[0] // 取得此帳號的姓名\n    → Step 3b: prev = null // 用來連結相鄰信件\n    → For each email in account[1:]:\n        → Step 3b1: email_to_name[email] = name // 記錄信件與姓名的關係\n        → Decision: prev 是否為 null? // 判斷是否為第一封信件\n            Yes → Step 3b2: prev = email // 第一封信件設定 prev\n            No  → Step 3b3: email_to_neighbors[prev].add(email) // 將 prev 與當前信件連結\n                  → Step 3b4: email_to_neighbors[email].add(prev) // 兩端相互連結\n                  → Step 3b5: prev = email // 更新 prev 為當前信件\n→ Step 4: 建立 visited 集合 // 標記已被處理的信件\n→ Step 5: 建立 result 列表 // 存放合併後的帳號\n\n→ Step 6: For each email in email_to_name.keys()\n    → Decision: email 是否已在 visited? \n        Yes → Step 6a: Continue // 已處理跳過\n        No  → Step 6b: 初始化 stack = [email] // 用 DFS 開始遍歷\n              → Step 6c: 初始化 component = [] // 儲存同一個人所有信件\n              → While stack 不為空:\n                  → Step 6d: cur = stack.pop() // 取出一封信件\n                  → Decision: cur 是否已在 visited?\n                      Yes → Step 6e: Continue // 已標記跳過\n                      No  → Step 6f: visited.add(cur) // 標記已訪問\n                            → Step 6g: component.add(cur) // 加入同一組\n                            → For each neighbor in email_to_neighbors[cur]:\n                                → Step 6h: stack.add(neighbor) // 推進鄰接信件\n              → Step 6i: component.sort() // 依字典序排序信件\n              → Step 6j: name = email_to_name[email] // 取出此組的姓名\n              → Step 6k: result.append([name] + component) // 加入結果\n\nEnd // 程式執行結束（返回 result）"
    },
    {
      "title": "My Calendar I",
      "source_file": "Leetcode/leetcode729.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwbuyjtf4.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmpwbuyjtf4.py\", line 32, in main\n    second = json.loads('[' + parts[1])\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 37 (char 36)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCalendar:\n    def __init__(self):\n        # 以列表方式儲存所有已預約的區間\n        self.bookings = []\n\n    def book(self, start: int, end: int) -> bool:\n        \"\"\"\n        若與已存在的區間有重疊，則拒絕預約，否則新增區間並回傳 True。\n        \"\"\"\n        for s, e in self.bookings:\n            # 若 max(s, start) < min(e, end)，代表兩個區間有交集\n            if max(s, start) < min(e, end):\n                return False\n        # 無衝突，將新區間加入\n        self.bookings.append((start, end))\n        return True\n\ndef main():\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 解析為兩個 JSON 陣列\n    # 例：[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]\n    # 先把第一個閉括號與第二個開括號之間的分隔符分開\n    parts = raw.split('],', 1)\n    first = json.loads(parts[0] + ']')\n    second = json.loads('[' + parts[1])\n\n    results = []\n    obj = None\n\n    for cmd, args in zip(first, second):\n        if cmd == 'MyCalendar':\n            obj = MyCalendar()\n            results.append(None)          # 按 LeetCode 規則，constructor 回傳 null\n        elif cmd == 'book':\n            results.append(obj.book(*args))\n        else:\n            # 若有其他方法可在此處擴充\n            results.append(None)\n\n    # 輸出結果，符合 LeetCode 範例格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for implementing MyCalendar with book method, ensuring no double booking. Use simple approach: maintain list of intervals sorted, check for overlap. Steps: Start, initialize list, book method: iterate over intervals to check overlap; if found return false; else add interval and return true. End. Use decision arrows. Provide explanation after each line. Ensure each line ends with `// 解釋/說明`. Use arrow `→`. Let's produce steps.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCalendar 類別 // 建立日曆物件  \n→ Step 2: 初始化空列表 bookings ← [] // 用來儲存已預約的時間區間  \n→ Step 3: 定義 book(start, end) 方法 // 計算是否可以新增事件  \n→ Decision: 是否存在與 [start, end) 重疊的區間? // 檢查是否會衝突  \n  Yes → Step 4: 返回 false // 若有重疊，拒絕預約  \n  No → Step 5: 將 [start, end) 加入 bookings 列表 // 成功新增"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,1,4,0,6,4,6,6]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 1, 4, 0, 6, 4, 6, 6]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # 計算可用的合法數量\n        self.size = n - len(blacklist)\n        black_set = set(blacklist)\n        self.mapping = {}\n        last = n - 1\n        # 將低位黑名單映射到高位合法數字\n        for b in blacklist:\n            if b < self.size:\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        # 隨機挑選一個低位索引，然後映射或直接返回\n        idx = random.randint(0, self.size - 1)\n        return self.mapping.get(idx, idx)\n\ndef main():\n    # 讀取兩行輸入：指令列表與對應參數列表\n    commands_line = sys.stdin.readline()\n    args_line = sys.stdin.readline()\n    if not commands_line or not args_line:\n        return\n    commands = json.loads(commands_line.strip())\n    args_list = json.loads(args_line.strip())\n\n    result = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # 建構子，args 為 [n, blacklist]\n            obj = Solution(*args)\n            result.append(None)\n        elif cmd == \"pick\" and obj is not None:\n            result.append(obj.pick())\n        else:\n            # 其他指令可忽略\n            result.append(None)\n\n    # 輸出結果，使用 JSON 以符合範例格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. The algorithm: map blacklisted numbers to the end of the range that are not blacklisted. Use dictionary/hash map. Complexity: O(b) init, O(1) pick. Use random.randint(0, m-1). Implementation details: Let m = n - len(blacklist). For each b in blacklist: if b < m: map[b] = last unblacklisted in [m, n-1] and decrement last. Then pick: r = random.randint(0, m-1); return map.get(r, r). Provide virtual code.\n\nWe must output line by line. Use virtual steps: Start, Step 1, Decision, etc. Provide explanations. Use arrow syntax. Must not output real code. Use virtual code steps. Provide explanation after space. Use arrow with \"→\". We'll structure like:\n\nStart // 開始\n→ Step 1: 初始化 m = n - blacklist_size // 計算可用數量\n→ Step 2: 建立空白映射 map // 用來轉換黑名單內的數\n→ Step 3: 設定 last = n-1 // 指向可接受範圍的最高值\n→ Step 4: 對每個 b in blacklist: // 逐一處理黑名單\n    → Decision: b < m? // 只處理落在可選範圍內的\n        Yes → Step 5: 若 last 在 blacklist: last-- // 找到一個未被黑名單的高位\n        Yes → Step 6: map[b] = last // 將低位映射到高位\n        Yes → Step 7: last-- // 移動到下一個可用高位\n        No → No action // 若 b >= m 則不需要映射\n→ Step 8: pick 函式開始 // 產生隨機\n    → Step 9: r = random_int(0, m-1) // 產生低位隨機數\n    → Step 10: 若 r 在 map 中: return map[r] else return r // 轉換或直接返回\n\nEnd\n\nWe need to include \"Decision:\" lines. Provide each line with explanation after //.\n\nLet's craft. Ensure each line has virtual code and comment. Use indentation? Use the arrow for nested steps. Provide \"→ Decision:\" with Yes/No arrow as shown. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 m = n - blacklist.size // 可用的合法數量  \n→ Step 2: 初始化 map 為空映射 // 用於將低位黑名單映射到高位  \n→ Step 3: 設定 last = n - 1 // 指向可接受範圍的最高值  \n→ Step 4: 對每個 b 在 blacklist 迭代  \n  → Decision: 是否需要映射? (b < m)? // 只處理落在 [0, m-1] 範圍內的黑名單項目  \n   Yes → Step 5: 若 last 在 blacklist 內, 則 last-- // 找到一個未被黑名單的高位  \n   Yes → Step 6: map[b] = last // 將低位黑名單映射到可用高位  \n   Yes → Step 7: last-- // 移動到下一個可用高位  \n   No  → No action // 若 b ≥ m，則不需映射  \n→ Step 8: 定義 pick 函式  \n  → Step 9: r = random_int(0, m-1) // 產生低位隨機數  \n  → Decision: r 在 map 中? // 判斷是否需要轉換  \n   Yes → Step 10: return map[r] // 轉換後返回合法數字  \n   No  → Step 11: return r // 直接返回合法數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.699879723804596,0.25030738388339735],[-0.3444759598295589,0.561565890964166],[-0.9385210354167326,0.09360004656236243]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.699879723804596, 0.25030738388339735], [-0.3444759598295589, 0.561565890964166], [-0.9385210354167326, 0.09360004656236243]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 均勻分佈：先產生 0~1 的隨機數，取平方根後乘以半徑\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    results = []\n    for i, op in enumerate(ops):\n        if i == 0:  # constructor\n            instance = Solution(*args[0])\n            results.append(None)\n        else:\n            method = getattr(instance, op)\n            res = method(*args[i])\n            results.append(res)\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to generate pseudo code for the problem: generating a uniform random point inside a circle. Steps: generate random angle theta uniform [0, 2π). generate random radius sqrt(r) * R? Actually uniform area distribution: radius = sqrt(rand) * R. Then x = center_x + radius * cos(theta), y = center_y + radius * sin(theta). Implementation: Solution class with constructor, randPoint method.\n\nWe need to output line by line pseudocode with explanation. Use Start, End, Decision, etc. For random generation, use Random object maybe. But pseudocode. Let's produce:\n\nStart\n→ Step 1: 定義類別 Solution\n→ Decision: 檢查是否呼叫構造函式?\n    Yes → Step 2: 參數 radius, x_center, y_center // 初始化\n→ Step 3: Store radius, x_center, y_center // 保存屬性\n→ Step 4: 初始化隨機數生成器 rng // 用於產生隨機數\n→ End // 結束初始化\n\nDefine randPoint()\n→ Start // randPoint 執行\n→ Step 1: 產生隨機角度 theta 0~2π // 使用 rng.uniform(0, 2π)\n→ Step 2: 產生隨機半徑 r = sqrt(rng.uniform(0, 1)) * radius // 保證面積均勻\n→ Step 3: 計算 x = x_center + r * cos(theta) // 轉換為座標\n→ Step 4: 計算 y = y_center + r * sin(theta)\n→ Step 5: 回傳 [x, y] // 產生的隨機點\n→ End\n\nBut need to follow format: Each line: \"虛擬碼步驟 // 解釋\". Use arrow and decision etc. Let's produce a structured pseudocode: Start, Decision: ... etc. Should we include \"→\" before each step? Example format: \"Start // 程式開始執行\". Then \"→ Step 1: ...\" etc. For decision, indent lines with spaces: \"Decision: ...\". The example shows indenting with four spaces? Let's mimic: \"Decision: ...\". Then inside \"Yes → ...\", \"No → ...\". In our pseudocode, no decision required except maybe for constructor? But we can keep simple.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Define class Solution // 定義類別\n    → Constructor: Solution(radius, x_center, y_center) // 建構函式\n        → Store radius, x_center, y_center // 內部變數\n        → Initialize rng // 隨機數產生器\n→ End // 結束類別定義\n\nDefine method randPoint()\n    → Start // randPoint 開始\n    → Generate theta = rng.uniform(0, 2π) // 隨機角度\n    → Generate u = rng.uniform(0, 1) // 隨機值\n    → Compute r = sqrt(u) * radius // 均勻半徑\n    → Compute x = x_center + r * cos(theta) // 轉換為座標\n    → Compute y = y_center + r * sin(theta)\n    → Return [x, y] // 回傳點\n    → End // randPoint 結束\n\nBut we need to maintain formatting exactly: Each line has \"虛擬碼步驟 // 解釋\". Use arrow, decisions. Use indentation maybe with spaces. Example uses \"Decision: If ...\", then \"Yes →\", \"No →\". For our case no decision needed. Just straightforward steps. Use \"→\" prefix. Let's produce:\n\nStart // 程式開始執行\n→ Define class Solution // 建立 Solution 類別\n    → Constructor: Solution(radius, x_center, y_center) // 初始化參數\n        → Store radius, x_center, y_center // 保存半徑與中心座標\n        → Initialize rng // 建立隨機數生成器\n→ End // 結束類別定義\n\nDefine method randPoint()\n    → Start // randPoint 方法開始\n    → theta = rng.uniform(0, 2π) // 產生 0~2π 的隨機角度\n    → u = rng.uniform(0, 1) // 產生 0~1 的隨機數\n    → r = sqrt(u) * radius // 將 u 轉為均勻半徑\n    → x = x_center + r * cos(theta) // 計算 x 座標\n    → y = y_center + r * sin(theta) // 計算 y 座標\n    → Return [x, y] // 回傳隨機點\n    → End // randPoint 方法結束\n\nBut we need each line with \"虛擬碼步驟\" and explanation after //. Provide arrow \"→\". For indent, we can indent with two spaces? The example uses one tab? We can use four spaces. Use \"    \" for nested lines. Provide \"Decision:\" only if needed. We can include \"→\" on each line. Provide \"End\" lines for class and method. Let's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define class Solution // 建立 Solution 類別  \n    → Constructor: Solution(radius, x_center, y_center) // 初始化參數  \n        → Store radius, x_center, y_center // 保存半徑與中心座標  \n        → Initialize rng // 建立隨機數生成器  \n→ End // 結束類別定義  \n\nDefine method randPoint()  \n    → Start // randPoint 方法開始  \n    → theta = rng.uniform(0, 2π) // 產生 0~2π 的隨機角度  \n    → u = rng.uniform(0, 1) // 產生 0~1 的隨機數  \n    → r = sqrt(u) * radius // 將 u 轉為均勻半徑  \n    → x = x_center + r * cos(theta) // 計算 x 座標  \n    → y = y_center + r * sin(theta) // 計算 y 座標  \n    → Return [x, y] // 回傳隨機點  \n    → End // randPoint 方法結束"
    },
    {
      "title": "Count Different Palindromic Subsequences",
      "source_file": "Leetcode/leetcode730.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '7'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '7'"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '104860361'\nGot (Norm):      '104860362'\n--- (Raw) ---\nRaw Expected: '104860361'\nRaw Got:      '104860362'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                l, r = i + 1, j - 1\n                while l <= r and s[l] != s[i]:\n                    l += 1\n                while l <= r and s[r] != s[i]:\n                    r -= 1\n                if l > r:                     # no same character inside\n                    dp[i][j] = (dp[i + 1][j - 1] * 2 + 2) % MOD\n                elif l == r:                   # one same character inside\n                    dp[i][j] = (dp[i + 1][j - 1] * 2 + 1) % MOD\n                else:                          # at least two same characters inside\n                    dp[i][j] = (dp[i + 1][j - 1] * 2 - dp[l + 1][r - 1]) % MOD\n            else:                              # different ends\n                dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]) % MOD\n    return dp[0][n - 1] % MOD\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract alphabetic characters only to form the string\n    s = ''.join(re.findall(r'[a-zA-Z]', data))\n    result = count_palindromic_subsequences(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm. Problem: count distinct non-empty palindromic subsequences in string s, modulo 1e9+7. Standard DP: dp[l][r] count in substring l..r. Recurrence: if s[l] != s[r]: dp[l][r] = dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]; else: let left = l+1, right = r-1; find next occurrence of s[l] after left, and prev occurrence before right. If no such: dp[l][r] = 2 * dp[l+1][r-1] + 2; if next > prev: dp[l][r] = 2 * dp[l+1][r-1] + 1; else: dp[l][r] = 2 * dp[l+1][r-1] - dp[next+1][prev-1]. Ensure mod.\n\nWe need to output step-by-step pseudocode lines with explanations. Must not output actual code, only structure.\n\nWe should include initialization, loops over length, compute dp. Also need arrays nextOcc, prevOcc. Provide algorithm explanation. Provide modular arithmetic.\n\nWe should maintain mod constant. Ensure subtraction mod.\n\nWe need to produce lines like \"Start // ...\", \"→ Step 1: ...\" etc.\n\nWe need to include decisions with Yes/No.\n\nLet's craft.\n\nWe need to consider the following steps:\n\n1. Read string s\n2. N = length\n3. Precompute next occurrence for each position and character? Instead we need for each index i the next index of same char after i, and previous index before i. Use arrays nextSame[i], prevSame[i].\n   We can precompute by scanning.\n\n4. Initialize dp matrix NxN zeros.\n\n5. For each i from 0 to N-1: dp[i][i] = 1 // single char palindrome.\n\n6. For len from 2 to N:\n   For l from 0 to N-len:\n      r = l+len-1\n      If s[l] != s[r]: dp[l][r] = (dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]) mod M\n      Else:\n         left = l+1, right = r-1\n         next = nextSame[l]\n         prev = prevSame[r]\n         If next > right: // no same char inside\n             dp[l][r] = (2*dp[l+1][r-1] + 2) mod M\n         Else if next > prev: // no same char inside? Actually if next>prev means no duplicate inside\n             dp[l][r] = (2*dp[l+1][r-1] + 1) mod M\n         Else:\n             dp[l][r] = (2*dp[l+1][r-1] - dp[next+1][prev-1]) mod M\n   Ensure mod positivity.\n\n7. Result dp[0][N-1] mod M.\n\nNow produce virtual code lines.\n\nWe need to use arrows \"→\". For decisions we use Yes →, No →.\n\nMake sure to include mod step. For subtraction we use (value + M) % M.\n\nLet's generate.\n\nWe'll start with \"Start // 程式開始\". Then \"→ Step 1: 讀取輸入字串 s // 取得要處理的字串\". etc.\n\nWe'll need arrays nextSame, prevSame. We compute nextSame[i] as index of next occurrence of s[i] after i else -1? We'll treat as N if none. Similarly prevSame[i] as previous index of s[i] before i else -1.\n\nWe'll need to precompute nextSame for each i. Use reverse loop.\n\nLet's produce.\n\nWe need to show decision points: if s[l] != s[r] etc. Use Decision: if s[l] != s[r]? // 兩端字不同\n\nAlso inside same char case: Decision: next > right? // no same inside\n\nThen sub-decisions: next > prev? // no duplicate inside\n\nOk.\n\nAlso mod operation: We can produce step for addition and subtraction.\n\nWill use variable M = 1000000007.\n\nOk produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 從使用者處取得要處理的字串  \n→ Step 2: N ← s.length // 字串長度  \n→ Step 3: M ← 1_000_000_007 // 取模常數  \n→ Step 4: 建立陣列 nextSame[0..N-1] // nextSame[i] 為 i 後面第一次出現 s[i] 的索引  \n→ Step 5: 建立陣列 prevSame[0..N-1] // prevSame[i] 為 i 前面最後一次出現 s[i] 的索引  \n→ Step 6: 設定 nextSame[N-1] ← N, prevSame[0] ← -1 // 边界值  \n→ Decision: 從 N-2 迴圈到 0? // 計算 nextSame  \n    Yes → Step 7: 如果 s[i+1] == s[i]?  \n        Yes → Step 8: nextSame[i] ← i+1 // 下一個相同字母即 i+1  \n        No  → Step 9: nextSame[i] ← nextSame[i+1] // 跟 i+1 的 nextSame 相同  \n    No  → Step 10: 從 1 迴圈到 N-1? // 計算 prevSame  \n        Yes → Step 11: 如果 s[i-1] == s[i]?  \n            Yes → Step 12: prevSame[i] ← i-1 // 前一個相同字母即 i-1  \n            No  → Step 13: prevSame[i] ← prevSame[i-1] // 跟 i-1 的 prevSame 相同  \n        No  → Step 14: 建立 dp[N][N] 2D 陣列 // dp[l][r] 代表子字串 l..r 的答案  \n→ Step 15: 初始化 dp[i][i] ← 1 for all i // 單一字符本身即為回文子序列  \n→ Step 16: 設定 len ← 2 // 子字串長度  \n→ Decision: len ≤ N? // 逐長度計算  \n    Yes → Step 17: 設定 l ← 0 // 子字串左端點  \n    → Decision: l ≤ N-len? // 逐左端點遍歷  \n        Yes → Step 18: r ← l + len - 1 // 右端點  \n        → Decision: s[l] ≠ s[r]? // 兩端字不同  \n            Yes → Step 19: dp[l][r] ← (dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]) mod M // 差集公式  \n            No  → Decision: nextSame[l] > r-1? // 右端點左側沒有同樣字母  \n                Yes → Step 20: dp[l][r] ← (2 * dp[l+1][r-1] + 2) mod M // 兩端相同且中間無重複  \n                No  → Decision: nextSame[l] > prevSame[r]? // 內部無重複  \n                    Yes → Step 21: dp[l][r] ← (2 * dp[l+1][r-1] + 1) mod M // 兩端相同但內部單一重複  \n                    No  → Step 22: dp[l][r] ← (2 * dp[l+1][r-1] - dp[nextSame[l]+1][prevSame[r]-1]) mod M // 兩端相同且內部有重複  \n        No  → Step 23: l ← l + 1 // 下一個左端點  \n    No  → Step 24: len ← len + 1 // 下一個子字串長度  \n→ Step 25: 結果 ← dp[0][N-1] mod M // 最終答案  \n→ End // 程式執行結束"
    },
    {
      "title": "Remove Duplicates from Sorted Array",
      "source_file": "Leetcode/leetcode26.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "2, nums = [1,2,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2,nums=[1,2,_]'\nGot (Norm):      '2,nums=[1,2,2]'\n--- (Raw) ---\nRaw Expected: '2, nums = [1,2,_]'\nRaw Got:      '2, nums = [1, 2, 2]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
          "expected_output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,2,3,4,_,_,_,_,_]'\nGot (Norm):      '5,nums=[0,1,2,3,4,2,2,3,3,4]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,2,3,4,_,_,_,_,_]'\nRaw Got:      '5, nums = [0, 1, 2, 3, 4, 2, 2, 3, 3, 4]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        移除排序後陣列中的重複元素，並在原地將唯一值放在前面。\n        回傳唯一元素的個數 k。\n        \"\"\"\n        if not nums:\n            return 0\n\n        # writeIndex 代表下一個要寫入唯一元素的位置\n        writeIndex = 0\n        for i in range(1, len(nums)):\n            if nums[i] != nums[writeIndex]:\n                writeIndex += 1\n                nums[writeIndex] = nums[i]\n        # writeIndex 為最後一個唯一元素的索引，k 為 writeIndex+1\n        return writeIndex + 1\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中抽取整數列表。\n    例如：'nums = [1,1,2]' 會回傳 [1, 1, 2]\n    \"\"\"\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    return numbers\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    nums = parse_input(raw)\n    solution = Solution()\n    k = solution.removeDuplicates(nums)\n\n    # 輸出結果\n    print(f\"{k}, nums = {nums}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode for removing duplicates from sorted array in-place, return k. Should be linear time, O(1) space. Approach: use two pointers: i for scanning, j for writing unique. Start j=0. For each element i, if i==0 or nums[i]!=nums[i-1] then nums[j]=nums[i]; j++. At end return j. Provide step-by-step. Ensure we follow format. Use Start, End, Decision. Let's produce.\n\nAlso include explanation comments. Use arrow \"→\". Also maybe use Decision: \"If i > 0 AND nums[i] == nums[i-1]?\" but simpler: if i==0 or nums[i]!=nums[i-1]. Provide decisions accordingly.\n\nLet's craft lines:\n\nStart // 開始執行\n→ Step 1: 初始化寫入指標 writeIndex = 0 // 記錄唯一元素要寫入的位置\n→ Step 2: 對於每個索引 i 從 0 到 nums.length-1 // 遍歷整個陣列\n    → Decision: 如果 i == 0 或者 nums[i] != nums[i-1]? // 判斷是否為唯一元素\n        Yes → Step 3: nums[writeIndex] = nums[i] // 把唯一元素寫入前面位置\n        Yes → Step 4: writeIndex = writeIndex + 1 // 更新寫入指標\n        No  → // 跳過重複元素，直接繼續下一個 i\nEnd // 程式結束\n→ Return writeIndex // writeIndex 即為唯一元素個數 k\n\nBut each line must be \"虛擬碼步驟 [space] // 解釋\". Also \"Decision:\" lines indent.\n\nUse indentation for nested lines? Example format: \n```\n→ Decision: 如果數字大於 0? \n    Yes → Step 2: 輸出 '正數' \n    No  → Decision: 如果數字等於 0? \n        Yes → Step 3: 輸出 '零' \n```\nSo we follow same style.\n\nLet's output.\n\nAlso need to use \"Start\" and \"End\" on separate lines. Each line ends with comment.\n\nReturn line after End. But format says \"→ Return writeIndex // ...\" should be after End? Actually \"End\" indicates end of process; we can place Return before End or after End? In example they placed End after last step, not return. But we need to return value. Could add after End: \"→ Return writeIndex // 回傳唯一元素數量\" before End. Or put End after return.\n\nBetter: After loop we add Step to return, then End.\n\nLet's produce final pseudocode accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化寫入指標 writeIndex = 0 // 記錄唯一元素要寫入的位置\n→ Step 2: 對於每個索引 i 從 0 到 nums.length-1 // 遍歷整個陣列\n    → Decision: i == 0 或 nums[i] != nums[i-1]? // 判斷是否為唯一元素\n        Yes → Step 3: nums[writeIndex] = nums[i] // 把唯一元素寫入前面位置\n        Yes → Step 4: writeIndex = writeIndex + 1 // 更新寫入指標\n        No  → // 跳過重複元素，直接繼續下一個 i\n→ Step 5: Return writeIndex // 回傳唯一元素數量 k\nEnd // 程式執行結束"
    },
    {
      "title": "Couples Holding Hands",
      "source_file": "Leetcode/leetcode765.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "row = [0,2,1,3]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg59pzbwr.py\", line 34, in parse_input\n    return ast.literal_eval(data)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    row = [0,2,1,3]\n        ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpg59pzbwr.py\", line 45, in <module>\n    row = parse_input(raw)\n          ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpg59pzbwr.py\", line 41, in parse_input\n    return ast.literal_eval(data[start:end])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [0,2,1,3\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "row = [3,2,0,1]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp88s35tcm.py\", line 34, in parse_input\n    return ast.literal_eval(data)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    row = [3,2,0,1]\n        ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp88s35tcm.py\", line 45, in <module>\n    row = parse_input(raw)\n          ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp88s35tcm.py\", line 41, in parse_input\n    return ast.literal_eval(data[start:end])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3,2,0,1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef min_swaps_couples(row):\n    n = len(row)\n    pos = [0] * n\n    for i, x in enumerate(row):\n        pos[x] = i\n\n    swaps = 0\n    for i in range(0, n, 2):\n        partner = row[i] ^ 1\n        if row[i + 1] != partner:\n            partner_idx = pos[partner]\n            # swap the person at i+1 with the partner\n            row[i + 1], row[partner_idx] = row[partner_idx], row[i + 1]\n            # update positions\n            pos[row[partner_idx]] = partner_idx\n            pos[row[i + 1]] = i + 1\n            swaps += 1\n    return swaps\n\ndef parse_input(data: str):\n    \"\"\"\n    Parses input of the form:\n        row = [0, 2, 1, 3]\n    or just a raw list representation.\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    # try evaluating the whole string\n    try:\n        return ast.literal_eval(data)\n    except Exception:\n        # find first '[' and last ']'\n        start = data.find('[')\n        end = data.rfind(']')\n        if start == -1 or end == -1:\n            raise ValueError(\"Invalid input format\")\n        return ast.literal_eval(data[start:end])\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    row = parse_input(raw)\n    result = min_swaps_couples(row)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, not actual code. The problem: arrange couples in adjacent seats with minimum swaps. Known solution: treat as graph where couples need to be adjacent, and each swap can fix a cycle. Approach: build mapping from person to seat. Then iterate seats i by i+=2, check if couple at seat i and i+1 correct. If not, swap person at seat i+1 with partner of seat i. Count swaps. Provide virtual code. Steps: Start, create mapping, swaps=0, for i in 0..len-1 step 2, person1 = row[i], person2 = row[i+1]. If partner(person1)!=person2, then swap partner with seat i+1. Increase swaps. Update mapping. End. Provide explanations.\n\nNeed to output each line with virtual code step and explanation comment. Use arrow, decisions. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 創建座位到人員的映射 seat_to_person // 建立座位索引到人員 ID 的關係  \n→ Step 2: 初始化 swap_count = 0 // 記錄需要的交換次數  \n→ Step 3: 迭代座位 i = 0 到 row.length-1，步長為 2 // 每兩個座位檢查一對可能的夫妻  \n  → Decision: 如果 row[i] 與 row[i+1] 已是合法夫妻? // 檢查當前相鄰兩人是否為正確的夫妻對  \n    Yes → Step 4: i += 2 // 若已正確，繼續到下一對座位  \n    No  → Step 5: 找到 row[i] 的配偶 partner = row[i] + 1 或 -1 // 依照夫妻編號規則計算配偶 ID  \n      Decision: partner 在哪個座位? // 透過 seat_to_person 映射查找配偶所在座位  \n       Yes → Step 6: target_seat = seat_of_partner // 取得配偶目前所在的座位索引  \n       No → Step 6: target_seat = 0 // （此情況不應發生，保險）  \n      → Step 7: 交換 row[i+1] 與 row[target_seat] // 將配偶移到 i+1 位置  \n      → Step 8: 更新 seat_to_person 映射：  \n        → seat_to_person[i+1] = partner  \n        → seat_to_person[target_seat] = row[i+1] // 原本 i+1 的人現在在 target_seat  \n      → Step 9: swap_count += 1 // 記錄一次交換  \n      → Step 10: i += 2 // 交換後的 i+1 已正確，移到下一對座位  \nEnd // 程式執行結束，swap_count 為最小交換次數"
    },
    {
      "title": "4Sum",
      "source_file": "Leetcode/leetcode18.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,0,-1,0,-2,2], target = 0",
          "expected_output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_tsnzq1y.py\", line 52, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_tsnzq1y.py\", line 43, in parse_input\n    nums = ast.literal_eval(value)\n           ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2], target = 8",
          "expected_output": "[[2,2,2,2]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpadm16of_.py\", line 52, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpadm16of_.py\", line 43, in parse_input\n    nums = ast.literal_eval(value)\n           ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def fourSum(self, nums, target):\n        nums.sort()\n        n = len(nums)\n        res = []\n\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res\n\ndef parse_input(data):\n    nums = None\n    target = None\n    for part in data.replace('\\n', ' ').split(','):\n        if '=' not in part:\n            continue\n        key, value = part.split('=', 1)\n        key = key.strip()\n        value = value.strip()\n        if key == 'nums':\n            nums = ast.literal_eval(value)\n        elif key == 'target':\n            target = int(value)\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    nums, target = parse_input(raw_input)\n    solution = Solution()\n    result = solution.fourSum(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the four sum problem. Provide each step line with arrow and comments. Use Start, Decision, End. Provide algorithm: sort array, nested loops for i, j, then two pointers left, right, skip duplicates. Provide explanation.\n\nWe must not output actual code, only pseudocode steps. Provide each line as described. We'll produce a fairly detailed step-by-step algorithm, but each line is just a conceptual step, not code. Need to be careful to keep lines simple but cover entire logic.\n\nWe'll use \"Start\" line, then steps: sort array, set result list, for i from 0 to n-4, skip duplicates, for j from i+1 to n-3 skip duplicates, left = j+1, right = n-1, while left<right: sum = nums[i]+nums[j]+nums[left]+nums[right], compare to target, if equal: add quadruplet, move left/right skipping duplicates, if sum<target: left++, else right--. After loops, End. Also need to handle array size check.\n\nWe can produce more detailed steps: check array length <4 → return empty.\n\nLet's produce line by line. Use \"→\" for each step. Use \"Decision:\" for conditions. Provide comments after //.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 若 nums 數組長度 < 4? // 若元素不足四個則無法組成四元組  \n    Yes → Step 1: 產生空結果陣列並返回 // 直接返回空集合  \n    No  → Step 2: 將 nums 依升序排序 // 為了方便使用兩指標並跳過重複  \n→ Step 3: 初始化結果列表 results // 用於存放所有符合條件的四元組  \n→ Decision: 對 i 進行迭代，i 從 0 到 n-4 // 第一個指標  \n    Yes → Decision: 若 i > 0 且 nums[i] == nums[i-1]? // 跳過重複的第一個元素  \n        Yes → 跳過此次迭代 // 直接進入下一個 i  \n        No → Step 4: 對 j 進行迭代，j 從 i+1 到 n-3 // 第二個指標  \n            Decision: 若 j > i+1 且 nums[j] == nums[j-1]? // 跳過重複的第二個元素  \n                Yes → 跳過此次迭代 // 直接進入下一個 j  \n                No → Step 5: 設置 left = j+1, right = n-1 // 創建兩指標  \n                    → Decision: 當 left < right 時 // 開始兩指標搜尋  \n                        Yes → Step 6: 計算 sum = nums[i] + nums[j] + nums[left] + nums[right] // 四數和  \n                            → Decision: sum == target? // 是否符合目標  \n                                Yes → Step 7: 把 [nums[i], nums[j], nums[left], nums[right]] 加入 results // 存入答案  \n                                    → Step 8: 左右指標同時移動並跳過重複  \n                                        → Decision: left < right?  \n                                            Yes → left++，right--  \n                                            No → 返回到 Decision: left < right  \n                                No → Decision: sum < target? // 需要更大和  \n                                    Yes → left++ // 移動左指標至更大的數  \n                                    No → right-- // 移動右指標至更小的數  \n                            → 返回到 Decision: left < right  \n                    → 返回到 Decision: 當 left < right  \n            → 返回到 Decision: 對 j 的迭代  \n    → 返回到 Decision: 對 i 的迭代  \n→ Step 9: 返回 results // 所有符合條件的四元組  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,2,3],[1,2,3],[2,3,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 2, 3], [1, 2, 3], [2, 3, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列的副本\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列的副本\n        return self.original[:]\n\n    def shuffle(self):\n        # 使用 Fisher‑Yates 洗牌演算法\n        arr = self.original[:]\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\n\ndef main():\n    # 讀取整個 stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找到第一個 ']' 以分割 operations 與 args\n    end_ops_idx = data.find(']')\n    ops_str = data[:end_ops_idx + 1]\n    args_str = data[end_ops_idx + 1:].strip()\n    if args_str.startswith(','):\n        args_str = args_str[1:].strip()\n\n    # 解析為 Python 物件（安全使用 ast.literal_eval）\n    operations = ast.literal_eval(ops_str)\n    args_list = ast.literal_eval(args_str)\n\n    results = []\n    obj = None\n    for op, arg in zip(operations, args_list):\n        if op == \"Solution\":\n            obj = Solution(arg[0])  # arg 為包含單一列表的列表\n            results.append(None)    # 按 LeetCode 風格返回 null\n        elif op == \"reset\":\n            results.append(obj.reset())\n        elif op == \"shuffle\":\n            results.append(obj.shuffle())\n\n    # 輸出 JSON 格式，將 None 轉成 null\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. No actual code. Steps for a class with constructor, reset, shuffle. Include fields: original array copy, current array maybe not needed, but store original. Shuffle uses Fisher-Yates. Random generator.\n\nLet's produce step-by-step pseudocode: Start, init field, constructor, reset, shuffle, etc. Use arrows. Use Decision for random index selection? But shuffle is algorithm loop. Use for loop.\n\nUse \"Start\" and \"End\" around the entire algorithm? Maybe we show pseudo for the whole class.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrow after Start.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義全域變數 originalArray // 儲存原始陣列\n→ Step 2: 定義全域變數 rand = new Random() // 隨機數生成器\n→ Step 3: 定義 Constructor Solution(nums) // 建構子\n    → Step 3.1: originalArray = copy(nums) // 複製輸入陣列\n→ Step 4: 定義 Method reset() // 重置方法\n    → Step 4.1: return copy(originalArray) // 回傳原始陣列副本\n→ Step 5: 定義 Method shuffle() // 隨機打亂\n    → Step 5.1: arr = copy(originalArray) // 先複製原始陣列\n    → Step 5.2: n = length(arr) // 取得長度\n    → Step 5.3: for i from n-1 down to 1 // Fisher-Yates 循環\n        → Step 5.3.1: j = rand.nextInt(i+1) // 隨機索引 0~i\n        → Step 5.3.2: swap arr[i] and arr[j] // 交換元素\n    → Step 5.4: return arr // 回傳打亂後陣列\nEnd // 程式執行結束\n\nWe need each line separate, with \"→\". Provide explanation after comment. Ensure each line unique.\n\nLet's produce output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義全域變數 originalArray // 用於儲存原始陣列的副本  \n→ Step 2: 定義全域變數 rand = new Random() // 用於產生隨機數的物件  \n→ Step 3: 定義 Constructor Solution(nums) // 建構子，初始化物件  \n  → Step 3.1: originalArray = copy(nums) // 把輸入陣列複製進 originalArray，確保不被修改  \n→ Step 4: 定義 Method reset() // 重置方法，恢復原始順序  \n  → Step 4.1: return copy(originalArray) // 回傳 originalArray 的深複製，保持外部不變  \n→ Step 5: 定義 Method shuffle() // 隨機打亂方法  \n  → Step 5.1: arr = copy(originalArray) // 先複製原始陣列，進行打亂  \n  → Step 5.2: n = length(arr) // 取得陣列長度  \n  → Step 5.3: for i from n-1 down to 1 // Fisher‑Yates 迴圈，從後向前遍歷  \n    → Step 5.3.1: j = rand.nextInt(i+1) // 隨機選擇 0~i 的索引  \n    → Step 5.3.2: swap arr[i] and arr[j] // 交換元素，完成一次隨機交換  \n  → Step 5.4: return arr // 回傳已打亂的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Accept input in the form \"nums = [1,2,3]\" or just \"[1,2,3]\"\n    if '=' in data:\n        _, nums_part = data.split('=', 1)\n        nums_str = nums_part.strip()\n    else:\n        nums_str = data\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        nums = []\n    result = Solution().subsets(nums)\n    # Format output exactly as the example: no spaces inside the lists\n    formatted = '[' + ','.join(str(subset).replace(' ', '') for subset in result) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets of an array of unique integers. The virtual code should be step-by-step, using arrows, decisions, etc.\n\nWe will use a backtracking algorithm. Each step: Start, decide to include or exclude each element, recursion.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義輸入數組 nums, 取長度 n // 取得輸入與長度\n→ Step 2: 初始化答案列表 result = [] // 用來存所有子集\n→ Decision: 如果 n == 0? // 檢查是否為空數組\n    Yes → Step 3: 將空集 [] 加入 result // 空集合也為子集\n    No → Step 4: 呼叫 Backtrack(0, []) // 開始遞迴\nEnd // 程式執行結束\n\nDefine Backtrack(index, path):\n    → Step 5: 加入 path 至 result // 當前子集加入結果\n    → Decision: 如果 index == n? // 檢查是否到達最後\n        Yes → Return // 終止此路徑\n        No →\n            → Step 6: 取 element = nums[index] // 取得當前元素\n            → Step 7: 呼叫 Backtrack(index+1, path ∪ {element}) // 包含元素\n            → Step 8: 呼叫 Backtrack(index+1, path) // 不包含元素\n\nBut need to write in virtual code format with arrows and decisions.\n\nLet's produce each line.\n\nUse format: Start // ...\n→ Step: ...\n→ Decision: ... // ...\n    Yes → ...\n    No → ...\n\nAlso for recursion, we can use a label for function.\n\nWe need to produce \"虛擬碼步驟\" and \"// 解釋\".\n\nLet's produce full algorithm:\n\nStart // 程式開始執行\n→ Step 1: 定義輸入數組 nums, 取得長度 n // 取得輸入及長度\n→ Step 2: 初始化結果列表 result = [] // 用來存所有子集\n→ Decision: 如果 n == 0? // 檢查是否為空數組\n    Yes → Step 3: 將空集 [] 加入 result // 空集合也為子集\n    No  → Step 4: 呼叫 Backtrack(0, []) // 從索引 0 開始遞迴\nEnd // 程式執行結束\n\nFunction Backtrack(index, path) // 遞迴處理\n    → Step 5: 將 path 加入 result // 把目前子集加入答案\n    → Decision: 如果 index == n? // 是否已走完所有元素\n        Yes → Return // 結束此遞迴分支\n        No →\n            → Step 6: 取 current = nums[index] // 取目前索引的元素\n            → Step 7: 呼叫 Backtrack(index+1, path ∪ {current}) // 包含此元素\n            → Step 8: 呼叫 Backtrack(index+1, path) // 不包含此元素\n\nBut we need to maintain the format: arrows at each line. We need to maintain indent for decisions. Use spaces.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義輸入數組 nums, 取長度 n // 取得輸入與長度\n→ Step 2: 初始化結果列表 result = [] // 用來存所有子集\n→ Decision: 如果 n == 0? // 檢查數組是否為空\n    Yes → Step 3: 將空集 [] 加入 result // 空集合也為子集\n    No  → Step 4: 呼叫 Backtrack(0, []) // 開始遞迴\nEnd // 程式執行結束\n\nFunction Backtrack(index, path) // 定義遞迴函式\n    → Step 5: 將 path 加入 result // 把目前子集加入答案\n    → Decision: 如果 index == n? // 是否已處理完所有元素\n        Yes → Return // 結束此路徑\n        No  →\n            → Step 6: 取 current = nums[index] // 取得當前元素\n            → Step 7: 呼叫 Backtrack(index+1, path ∪ {current}) // 包含此元素\n            → Step 8: 呼叫 Backtrack(index+1, path) // 不包含此元素\n\nWe need to produce a line for the Function Backtrack header maybe.\n\nBut the spec: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So \"Function Backtrack(index, path) // ...\" counts as a line.\n\nAlso the arrow for Function? Could use \"→ Function Backtrack(index, path) // ...\" but maybe not needed.\n\nBetter produce:\n\n→ Function Backtrack(index, path) // 定義遞迴函式\n\nBut the arrow \"→\" is used for steps. Let's include it.\n\nOk.\n\nAlso \"Step 6: 取 current = nums[index]\" is an action line.\n\nBut \"Step 7: 呼叫 Backtrack(index+1, path ∪ {current})\" etc.\n\nAll good.\n\nLet's output.\n\nAlso ensure each line ends with // Explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義輸入數組 nums，取長度 n // 取得輸入與長度  \n→ Step 2: 初始化結果列表 result = [] // 用來存所有子集  \n→ Decision: 如果 n == 0? // 檢查數組是否為空  \n    Yes → Step 3: 將空集 [] 加入 result // 空集合也為子集  \n    No  → Step 4: 呼叫 Backtrack(0, []) // 開始遞迴  \nEnd // 程式執行結束  \n\n→ Function Backtrack(index, path) // 定義遞迴函式  \n    → Step 5: 將 path 加入 result // 把目前子集加入答案  \n    → Decision: 如果 index == n? // 是否已處理完所有元素  \n        Yes → Return // 結束此路徑  \n        No  →  \n            → Step 6: 取 current = nums[index] // 取得當前元素  \n            → Step 7: 呼叫 Backtrack(index+1, path ∪ {current}) // 包含此元素  \n            → Step 8: 呼叫 Backtrack(index+1, path) // 不包含此元素"
    },
    {
      "title": "Combination Sum",
      "source_file": "Leetcode/leetcode39.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpc_tgeor0.py\", line 51, in <module>\n    candidates, target = parse_input(data)\n                         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpc_tgeor0.py\", line 38, in parse_input\n    candidates = eval(cand_eq)  # 內部安全，因為輸入為數字\n                 ^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo4t7awjy.py\", line 51, in <module>\n    candidates, target = parse_input(data)\n                         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpo4t7awjy.py\", line 38, in parse_input\n    candidates = eval(cand_eq)  # 內部安全，因為輸入為數字\n                 ^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        Find all unique combinations in candidates where numbers sum to target.\n        Each number can be used unlimited times.\n        \"\"\"\n        res = []\n\n        def backtrack(start, path, total):\n            # 如果已達到目標，加入結果\n            if total == target:\n                res.append(list(path))\n                return\n            # 若已超過目標，停止\n            if total > target:\n                return\n            # 逐一嘗試後續候選數\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, total + candidates[i])  # 可重複使用相同數字\n                path.pop()  # 回溯\n\n        backtrack(0, [], 0)\n        return res\n\ndef parse_input(s):\n    \"\"\"\n    將形如 'candidates = [2,3,6,7], target = 7' 的字串解析成\n    (candidates, target)。\n    \"\"\"\n    parts = s.split(',', 1)\n    cand_part, tgt_part = parts[0].strip(), parts[1].strip()\n\n    # 解析候選數字列表\n    cand_eq = cand_part.split('=', 1)[1].strip()\n    candidates = eval(cand_eq)  # 內部安全，因為輸入為數字\n\n    # 解析目標值\n    tgt_eq = tgt_part.split('=', 1)[1].strip()\n    target = int(eval(tgt_eq))\n\n    return candidates, target\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    candidates, target = parse_input(data)\n    sol = Solution()\n    result = sol.combinationSum(candidates, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the combination sum problem (like LeetCode 39). Provide step-by-step pseudocode lines with explanations. Must use arrows and structure.\n\nLet's produce steps: Start, read candidates, target. Sort candidates maybe. Then recursive DFS with backtracking.\n\nLet's produce steps: Sort array for optimization. Define DFS function (start index, current sum, path). Base cases: if sum==target: add path copy; return. If sum>target: return. For i from start to length-1: choose candidate[i], append to path, call DFS(i, sum+candidate[i]) because unlimited. After recursion, pop.\n\nThen main: call DFS(0, 0, []), output result.\n\nWe'll produce lines accordingly. Let's make virtual code lines.\n\nUse arrow \"→\". Provide explanation after \"//\".\n\nLet's produce around 15-20 lines. Ensure each line ends with // 解釋.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Read input: candidates array and target integer // 取得候選數組和目標值  \n→ Sort candidates in ascending order // 方便後續剪枝  \n→ Initialize result list // 存放所有符合條件的組合  \n\n→ Define function DFS(startIndex, currentSum, currentPath) // 回溯搜尋  \n  Decision: 如果 currentSum 等於 target? // 判斷是否已達到目標  \n   Yes → Add copy of currentPath to result list // 找到一組合法組合  \n   No  → Decision: 如果 currentSum 大於 target? // 超過目標即無效  \n    Yes → Return // 回到上一層  \n    No  → For i from startIndex to candidates.length-1: // 嘗試每個候選數  \n      → Append candidates[i] to currentPath // 加入目前數字  \n      → Call DFS(i, currentSum + candidates[i], currentPath) // 允許重複使用同一數字  \n      → Remove last element from currentPath // 回溯，移除已加入的數字  \n\n→ Call DFS(0, 0, empty list) // 開始回溯搜索  \n→ Output result list // 將所有組合回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpm_3mgm53.py\", line 52, in <module>\n    main()\n  File \"/tmp/tmpm_3mgm53.py\", line 41, in main\n    func = getattr(obj, method)\n           ^^^^^^^^^^^^^^^^^^^^\nAttributeError: 'NoneType' object has no attribute 'pickIndex'"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5ksssr7m.py\", line 52, in <module>\n    main()\n  File \"/tmp/tmp5ksssr7m.py\", line 41, in main\n    func = getattr(obj, method)\n           ^^^^^^^^^^^^^^^^^^^^\nAttributeError: 'NoneType' object has no attribute 'pickIndex'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport bisect\nimport json\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # split the input into method names and arguments\n    idx = data.find('],')\n    if idx == -1:\n        return\n    first_part = data[:idx+1]\n    second_part = data[idx+2:].lstrip()\n    commands = ast.literal_eval(first_part)\n    args_list = ast.literal_eval(second_part)\n\n    results = [None]  # constructor returns null\n    obj = None\n    for i in range(1, len(commands)):\n        method = commands[i]\n        args = args_list[i]\n        if method == \"__init__\" or method == \"Solution\":\n            obj = Solution(*args)\n        else:\n            func = getattr(obj, method)\n            if args:\n                res = func(*args)\n            else:\n                res = func()\n            results.append(res)\n\n    # Convert None to null for JSON output\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with comments. The requirement: no actual code, just pseudocode. We need to cover the algorithm: precompute prefix sums, total weight, then pickIndex uses random between 1..total, binary search or linear search to find first prefix >= random. Provide steps.\n\nWe should follow format: Start, etc. Use arrows. Provide each line as \"虛擬碼步驟 // 解釋/說明\". We need to output in Traditional Chinese.\n\nLet's produce steps:\n\nStart\n→ Step 1: 初始化 w, prefixSums = [], total = 0 // 計算前綴和\n→ Decision: 遍歷 w? // 建立前綴和陣列\n    → Loop i from 0 to w.length-1:\n        → Step 2: total += w[i] // 累加總重量\n        → Step 3: prefixSums.append(total) // 儲存前綴和\n→ Step 4: 定義函式 pickIndex() // 產生隨機索引\n→ Step 5: r = random integer in [1, total] // 隨機取值\n→ Decision: 使用二分搜尋? // 找到最小前綴和 >= r\n    → Step 6: low = 0, high = prefixSums.length - 1 // 初始化搜尋範圍\n    → Step 7: While low < high:\n        → Step 8: mid = (low + high) // 2\n        → Decision: prefixSums[mid] >= r? // 判斷中間值\n            → Yes → Step 9: high = mid // 設定上限\n            → No  → Step 10: low = mid + 1 // 設定下限\n    → Step 11: return low // low 即為符合條件的索引\nEnd\n\nWe might need to show loops and decisions. Use appropriate arrows. Provide comments.\n\nWe need to follow the format exactly: each line is a step, with a space after the step text, then // explanation. We can use indentation with tabs? Not necessary. Just ensure each line ends with explanation comment. Provide line numbers? Not needed. But need to maintain arrow characters. Use \"→\" arrow before step lines. For decisions, \"Decision:\" lines. For loops, maybe \"Loop:\" but we can embed as Step lines with while loops.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: w ← 輸入正整數陣列 // 取得權重陣列  \n→ Step 2: prefixSums ← 空陣列 // 用於存前綴和  \n→ Step 3: total ← 0 // 用於累加總重量  \n→ Decision: 迭代 w? // 準備建構前綴和陣列  \n    → Step 4: 對於每個 i 從 0 到 w.length-1  \n        → Step 5: total ← total + w[i] // 加總權重  \n        → Step 6: prefixSums.append(total) // 儲存前綴和  \n→ Step 7: 定義函式 pickIndex() // 開始隨機挑選索引  \n→ Step 8: r ← 隨機整數 [1, total] // 生成隨機數  \n→ Decision: 是否使用二分搜尋? // 找出最小前綴和 ≥ r  \n    → Step 9: low ← 0 // 搜尋左界  \n    → Step 10: high ← prefixSums.length - 1 // 搜尋右界  \n    → Step 11: while low < high  \n        → Step 12: mid ← (low + high) // 2 // 計算中點  \n        → Decision: prefixSums[mid] ≥ r? // 判斷中點是否足夠  \n            → Yes → Step 13: high ← mid // 縮小右界  \n            → No  → Step 14: low ← mid + 1 // 縮小左界  \n    → Step 15: return low // low 為符合條件的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Cracking the Safe",
      "source_file": "Leetcode/leetcode753.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '01'\n--- (Raw) ---\nRaw Expected: '\"10\"'\nRaw Got:      '01'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef crack_safe(n, k):\n    seen = set()\n    res = []\n\n    def dfs(node: str):\n        for d in map(str, range(k)):\n            nxt = node + d\n            if nxt not in seen:\n                seen.add(nxt)\n                dfs(nxt[1:])          # remove the first char to keep length n-1\n                res.append(d)\n\n    start = \"0\" * (n - 1)\n    dfs(start)\n    # reverse the collected digits to get the correct order\n    return \"\".join(reversed(res)) + start\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        sys.exit(0)\n    n, k = nums[0], nums[1]\n    result = crack_safe(n, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to generate a shortest sequence of digits that contains all n-length strings over [0, k-1] as substrings. This is de Bruijn sequence generation. So the algorithm: use DFS/ Hierholzer to find Eulerian cycle in k-ary de Bruijn graph of order n-1. Then output initial n-1 digits + the traversal. So produce steps.\n\nWe must output line by line with virtual code and explanation. No actual code. Let's create steps: Start, Input n,k, Build graph, DFS recursion, etc.\n\nWe'll outline steps: Start, Input n,k, create adjacency list, visited edges set, stack path, recursive function deBruijn(current), for each digit d, if edge not visited, mark visited, deBruijn(next node), push d to output. After recursion, end, build result: initial n-1 zeros? Actually typical de Bruijn sequence for all n-length strings: start with n-1 zeros, then output traversal digits. So produce result string.\n\nWe'll show steps: Step 1: Read n,k // read inputs; Step 2: Initialize adjacency list for each node of length k^(n-1) // nodes represent sequences of length n-1; Step 3: For each node, push edges 0..k-1 // each edge corresponds to appending digit; Step 4: Define empty stack path; Step 5: DFS(node) procedure // Hierholzer: while node has edges, pop edge, DFS(next node), push digit to stack; Step 6: Call DFS(0) // starting node all zeros; Step 7: Build sequence: start with n-1 zeros, then append digits from stack reversed; Step 8: Output sequence; End.\n\nNeed to reflect that we need minimal length: length = k^n + n - 1.\n\nWe should use virtual code steps with arrows and decisions.\n\nWe'll produce step by step.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 n, k // 取得密碼長度與數字範圍  \n→ Decision: 如果 n <= 0 或 k <= 1? // 檢查輸入合法性  \n  Yes → Step 2: 輸出錯誤訊息並結束 // 無效輸入  \n  No → Step 3: 建立圖的節點 // 節點代表長度 n-1 的字串  \n→ Step 4: 計算節點數 numNodes = k^(n-1) // 每個節點是 [0, k-1] 的長度 n-1 組合  \n→ Step 5: 建立鄰接清單 edges[numNodes] // 每個節點的出邊  \n  → For each node u in 0 .. numNodes-1  \n    → For digit d in 0 .. k-1  \n      → nextNode = (u * k + d) mod numNodes // 將 d 加到右邊並截斷長度 n-1  \n      → edges[u].push_back(d, nextNode) // 儲存邊 (d, nextNode)  \n→ Step 6: 建立空堆疊 stackDigits // 用於保存後遞迴回溯時的數字  \n→ Step 7: 定義遞迴函式 DeBruijn(u) // Hierholzer 演算法  \n  → While edges[u] 非空  \n    → 取出並移除最後一條邊 (d, v) = edges[u].pop_back()  \n    → DeBruijn(v) // 先遞迴進下一節點  \n    → stackDigits.push_back(d) // 記錄邊的數字  \n→ Decision: 是否有未遍歷的邊? // 確認所有邊已被走完  \n  Yes → Step 8: 重新呼叫 DeBruijn(0) // 從起始節點再次遍歷  \n  No → Step 9: 生成答案序列 // 從起始 n-1 個 0 開始，接著把 stackDigits 反轉後加上  \n    → string result = string(n-1, '0') // 初始 n-1 個 0  \n    → For i from stackDigits.size()-1 down to 0  \n      → result += char('0' + stackDigits[i]) // 加入對應數字  \n    → 輸出 result // 最短序列已生成  \nEnd // 程式執行結束"
    }
  ]
}