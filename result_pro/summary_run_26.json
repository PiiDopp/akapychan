{
  "run_index": 26,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 399,
  "generation_or_validation_failure_count": 40,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[6,6,1,4,6]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[6, 6, 1, 4, 6]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳結果列表。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取程式碼，並直接執行\n    code = sys.stdin.read()\n    # 允許程式碼呼叫 roll_dice 並輸出結果\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. Use arrow, decisions maybe. We have function definition, import random, loop, append, return. Use Start/End. Provide each line with explanation. No actual code. Just virtual. Let's produce.\n\nWe should show Start, import, function definition, initialize list, loop over range n, generate random int 1-6, append, after loop return list, End. Use arrow. Use decisions? Not needed. But we can include decision if n <=0? Might be optional. Provide simple. Provide \"Decision: n <= 0?\" maybe but not required. The user didn't mention error handling. We can keep simple.\n\nWe produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 載入 random 模組 // 用於產生隨機數\n→ Step 2: 定義函數 roll_dice(n) // 接收擲骰次數\n    → Step 3: 初始化結果列表 results = [] // 用於存放每次擲骰結果\n    → Step 4: For i in range(n): // 重複 n 次\n        → Step 5: 生成隨機整數 r = random.randint(1, 6) // 模擬一次六面骰擲骰\n        → Step 6: 將 r 加入 results // 存入列表\n    → Step 7: 回傳 results // 回傳所有擲骰結果\nEnd // 程式結束\n\nBut we need each line with explanation. Provide arrow for nested steps? We can indent with tabs? We can just use arrow lines with nested indentation? But format example uses indentation for nested steps inside Decision. We can use similar for function body. Use arrow lines. Let's craft.\n\nEnsure each line includes \"虛擬碼步驟\" + space + \"// 解釋\". We need no code, just virtual code.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 載入 random 模組 // 用於產生隨機數  \n→ Step 2: 定義函數 roll_dice(n) // 接收擲骰次數 n  \n → Step 3: 初始化結果列表 results = [] // 用於存放每次擲骰結果  \n → Step 4: For i in range(n): // 重複 n 次  \n   → Step 5: 生成隨機整數 r = random.randint(1, 6) // 模擬一次六面骰擲骰  \n   → Step 6: 將 r 加入 results // 存入列表  \n → Step 7: 回傳 results // 回傳所有擲骰結果  \nEnd // 程式結束執行"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp43ghd6vk.py\", line 21, in <module>\n    main()\n  File \"/tmp/tmp43ghd6vk.py\", line 18, in main\n    exec(code, {}, local_namespace)\n  File \"<string>\", line 7, in <module>\n  File \"/tmp/tmp43ghd6vk.py\", line 7, in measure_time\n    func(*args)\n  File \"<string>\", line 4, in slow_add\nNameError: name 'time' is not defined. Did you forget to import 'time'?"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"測量傳入函式 func 執行所需秒數，並回傳四捨五入至三位小數的值。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"從標準輸入讀取程式碼，並在已定義 measure_time 的環境下執行。\"\"\"\n    # 讀取整個標準輸入作為程式碼\n    code = sys.stdin.read()\n    # 建立一個新的命名空間，先放進 measure_time\n    local_namespace = {\"measure_time\": measure_time}\n    # 執行讀入的程式碼，任何 print 會直接輸出到 stdout\n    exec(code, {}, local_namespace)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation. Should use time module. Steps: import time, define function measure_time(func, *args). Inside, record start = time.time(); result = func(*args); end = time.time(); elapsed = end - start; rounded = round(elapsed, 3); return rounded, result maybe? Actually function returns time? Problem says \"回傳結果 (四捨五入到小數點 3 位)\" - ambiguous: should return time only or also result of func? Might be time only. Provide just elapsed. Provide explanation.\n\nWe produce Start block. Then import time. Then function definition. Then inside measure_time: record start, call func, record end, compute elapsed, round, return. End.\n\nNeed decision? Not needed. Just straight lines.\n\nWe need each line \"虛擬碼步驟 // 解釋\". Use arrow →. Start / End.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ 虛擬碼: 導入 time 模組 // 需要使用時間函式  \n→ 虛擬碼: 定義函式 measure_time(func, *args) // 接收待測函式與任意參數  \n→ 虛擬碼: 取得 start = time.time() // 記錄開始時間  \n→ 虛擬碼: 執行 result = func(*args) // 呼叫傳入函式並取得回傳值  \n→ 虛擬碼: 取得 end = time.time() // 記錄結束時間  \n→ 虛擬碼: 計算 elapsed = end - start // 取得執行秒數  \n→ 虛擬碼: 四捨五入 elapsed = round(elapsed, 3) // 保留 3 位小數  \n→ 虛擬碼: 回傳 elapsed // 返回測量時間  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"melon\",\"grape\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'melon', 'grape', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取並忽略所有標準輸入（即使目前無需任何輸入）\n    sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 新增 'orange'\n    fruits.add('orange')\n\n    # 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 移除 'banana'\n    fruits.remove('banana')\n\n    # 嘗試移除不存在的 'pineapple'（不會拋出錯誤）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for operations on a set in Python style but virtual code. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and Start, End. Steps: Start, Step1: define fruits set. Step2: add 'orange'. Step3: update with ['grape','melon']. Step4: remove 'banana'. Step5: discard 'pineapple'. Step6: output set. End.\n\nNeed to follow format exactly. Each line separate.\n\nWe need to use 虛擬碼步驟: maybe \"Step 1: Set fruits = {'apple', 'banana'}\". The arrow after Start: \"→\" before each step? The example shows: \"→ Step 1: ...\" So start line: \"Start // 程式開始執行\". Then arrow lines. End: \"End // 程式執行結束\".\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Define set fruits = {'apple', 'banana'} // 建立初始集合\n→ Step 2: fruits.add('orange') // 新增 'orange' 元素\n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增多個元素\n→ Step 4: fruits.remove('banana') // 移除 'banana' 元素\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的元素，不會產生錯誤\n→ Step 6: Output fruits // 輸出最終集合\nEnd // 程式執行結束\n\nYes.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define set fruits = {'apple', 'banana'} // 建立初始集合  \n→ Step 2: fruits.add('orange') // 新增 'orange' 元素  \n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增多個元素  \n→ Step 4: fruits.remove('banana') // 移除 'banana' 元素  \n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的元素，不會產生錯誤  \n→ Step 6: Output fruits // 輸出最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.76TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.76 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef get_rate() -> float:\n    \"\"\"\n    取得最新美元對台幣的匯率。\n    如果請求失敗則拋出例外。\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    try:\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()\n        data = r.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        raise RuntimeError(\"無法取得匯率，請檢查網路連線\")\n\ndef run_gui() -> None:\n    \"\"\"\n    啟動 tkinter GUI。\n    GUI 中有一個 Label 顯示目前匯率，\n    以及一個按鈕可以手動更新匯率。\n    \"\"\"\n    root = tk.Tk()\n    root.title(\"美元匯率查詢\")\n\n    label = tk.Label(root, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update_display() -> None:\n        try:\n            rate = get_rate()\n            label.config(text=f\"目前美元匯率：約 {rate} TWD\")\n        except Exception:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n\n    tk.Button(root, text=\"更新匯率\", command=update_display).pack(pady=5)\n\n    root.mainloop()\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    input_data = sys.stdin.read().strip()\n    if input_data:\n        # 有輸入時視為「更新匯率」指令，直接取得匯率並輸出\n        try:\n            rate = get_rate()\n            print(f\"目前美元匯率：約 {rate} TWD\")\n        except Exception:\n            print(\"無法取得匯率，請檢查網路連線\")\n    else:\n        # 無輸入時啟動 GUI\n        run_gui()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, no actual code. Should use Start, End, Decision. Use arrow arrows. Need steps to import requests, create tkinter window, label, button, function to fetch rate, update label, bind button, mainloop. Use virtual code language. Provide brief explanation after //.\n\nEnsure each line contains \"虛擬碼步驟\" and explanation. Format example shows \"Start // 程式開始執行\" then arrow lines.\n\nWe should include arrow lines: \"→ Step X: ...\" For decisions we use Decision: If ...? etc.\n\nLet's craft.\n\nLine1: Start // 程式開始執行\n\nLine2: → Step 1: Import requests and tkinter // 載入需要的模組\n\nLine3: → Step 2: 定義函式 fetch_rate() // 用於向 API 取回匯率\n\nLine4: → Step 3: 內部於 fetch_rate() 發送 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率資料\n\nLine5: → Step 4: 解析 JSON 回傳並取出 'rates' -> 'TWD' // 取得美元兌台幣匯率\n\nLine6: → Step 5: 回傳匯率值 // 結束函式\n\nLine7: → Step 6: 建立 tkinter 視窗 root // 創建主視窗\n\nLine8: → Step 7: 新增 Label rate_label 在 root 中顯示 \"匯率: 取得中...\" // 初始顯示文字\n\nLine9: → Step 8: 新增 Button update_btn 在 root 中，文字 \"更新匯率\" // 按鈕\n\nLine10: → Step 9: 定義函式 update_display() // 用於更新 Label 內容\n\nLine11: → Step 10: 內部於 update_display() 呼叫 fetch_rate() 並取得 rate // 取得最新匯率\n\nLine12: → Step 11: 更新 rate_label 的文字為 \"1 USD = {rate} TWD\" // 顯示最新匯率\n\nLine13: → Step 12: 設定 update_btn 的 command 為 update_display // 連結按鈕\n\nLine14: → Step 13: 呼叫 update_display() 一次以初始化顯示 // 初始載入\n\nLine15: → Step 14: 執行 root.mainloop() // 開始 GUI 事件迴圈\n\nLine16: End // 程式執行結束\n\nCheck format: Each line must have arrow \"→\" except start and end. For step lines we include \"→ Step X:\".\n\nShould we use Decision? There's no decision needed. Could add a Decision to handle error maybe. But requirement says use Decision if needed. We can add a Decision: 如果 fetch_rate 失敗? but optional. The user didn't ask for error handling. We can skip.\n\nBut to demonstrate Decision structure maybe include: Decision: 如果匯率取得成功? Yes update display, No update_label with error. We'll include to show.\n\nLet's modify: Add a decision after fetch_rate call: after obtaining rate, Decision: if rate is not None? Yes update. But we can embed within update_display function.\n\nSimplify: Keep as straightforward.\n\nThe sample only needs to follow format. Each line should be like \"→ Step X: ...\" with explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests and tkinter // 載入需要的模組  \n→ Step 2: Define function fetch_rate() // 用於向 API 取回匯率  \n→ Step 3: Inside fetch_rate(), send GET request to https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率資料  \n→ Step 4: Parse JSON response and extract 'rates' → 'TWD' // 取得美元兌台幣匯率  \n→ Step 5: Return the extracted rate // 結束函式  \n→ Step 6: Create tkinter root window // 創建主視窗  \n→ Step 7: Add Label rate_label to root with initial text \"匯率: 取得中...\" // 顯示初始文字  \n→ Step 8: Add Button update_btn to root with text \"更新匯率\" // 按鈕  \n→ Step 9: Define function update_display() // 用於更新 Label 內容  \n→ Step 10: Inside update_display(), call fetch_rate() to get latest rate // 取得最新匯率  \n→ Step 11: Update rate_label text to \"1 USD = {rate} TWD\" // 顯示最新匯率  \n→ Step 12: Set update_btn command to update_display // 連結按鈕與函式  \n→ Step 13: Call update_display() once to initialize the display // 初始載入  \n→ Step 14: Run root.mainloop() // 開始 GUI 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.val_to_index:\n            return False\n        index = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[index] = last_val\n        self.val_to_index[last_val] = index\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.values)\n\ndef format_output(lst):\n    parts = []\n    for v in lst:\n        if v is None:\n            parts.append('null')\n        elif isinstance(v, bool):\n            parts.append('true' if v else 'false')\n        else:\n            parts.append(str(v))\n    return '[' + ', '.join(parts) + ']'\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the two top‑level lists\n    split_pos = data.find('], [')\n    ops_str = data[:split_pos + 1]\n    args_str = data[split_pos + 3:]\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            res.append(None)\n        elif op == \"insert\":\n            res.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            res.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            res.append(obj.getRandom())\n    print(format_output(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for implementing RandomizedSet class methods with average O(1). The requirement: Output step by step with comments. Must be structured, use arrows, decisions, etc. No real code. Use Start, End, Decision. Provide each line.\n\nWe should outline the design: Use a dynamic array (list) to store values, and a hash map (dict) mapping value to index in array. insert: if val not in map, append to array, record index, return true. remove: if val in map, get index, swap last element into that position, update map for swapped element, pop last, delete map entry. getRandom: return random element from array. Provide O(1) average.\n\nWe'll produce lines like:\n\nStart // start of RandomizedSet initialization\n→ Step 1: 初始化空列表 values // store elements\n→ Step 2: 初始化空映射 val_to_index // map values to indices\n\nDecision: ??? maybe not needed.\n\nThen method insert: start, check presence etc.\n\nWe'll provide lines for each method: Insert, Remove, GetRandom.\n\nWe can separate into blocks: class initialization, insert method, remove method, getRandom method. Each block start and end.\n\nMake sure each line has arrow or indentation: For decisions use Yes → and No →.\n\nLet's produce.\n...done thinking.\n\nStart // RandomizedSet 初始化開始\n→ Step 1: 初始化空列表 values // 用於儲存所有元素\n→ Step 2: 初始化空映射 val_to_index // 用於儲存元素對應的索引\n\n// ---------- insert 方法 ----------\nStart // insert 方法開始\n→ Step 3: 若 val 已在 val_to_index 中\n    Yes → Return false // 元素已存在，插入失敗\n    No  → Step 4: 在 values 陣列末尾追加 val\n→ Step 5: 取得 val 的索引 new_index = values.length - 1\n→ Step 6: 在 val_to_index 中記錄 val → new_index\n→ Step 7: Return true // 插入成功\nEnd // insert 方法結束\n\n// ---------- remove 方法 ----------\nStart // remove 方法開始\n→ Step 8: 若 val 不在 val_to_index 中\n    Yes → Return false // 無法移除，元素不存在\n    No  → Step 9: 取得 val 的索引 idx = val_to_index[val]\n→ Step 10: 取得陣列最後一個元素 last_val = values.last\n→ Step 11: 將 last_val 放到 idx 位置 values[idx] = last_val\n→ Step 12: 更新 val_to_index[last_val] = idx // 更新移入元素的索引\n→ Step 13: 從 values 刪除最後一個元素 values.pop\n→ Step 14: 從 val_to_index 刪除 val 的鍵 val_to_index.remove(val)\n→ Step 15: Return true // 移除成功\nEnd // remove 方法結束\n\n// ---------- getRandom 方法 ----------\nStart // getRandom 方法開始\n→ Step 16: 產生隨機索引 r = random(0, values.length - 1)\n→ Step 17: Return values[r] // 隨機回傳元素\nEnd // getRandom 方法結束\n\nEnd // RandomizedSet 初始化結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[0,0],[1,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [0, 0], [1, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n          # remaining zero cells\n        self.map = {}               # mapping for swapped indices\n\n    def flip(self):\n        # Pick a random index among the remaining zeros\n        r = random.randint(0, self.total - 1)\n        # Resolve the actual linear index\n        actual = self.map.get(r, r)\n        # Reduce the count of remaining zeros\n        self.total -= 1\n        last = self.total\n        # Resolve the actual index for the last remaining position\n        last_actual = self.map.get(last, last)\n        # Update mapping: r now points to last_actual\n        self.map[r] = last_actual\n        # Convert linear index to 2D coordinates\n        i = actual // self.n\n        j = actual % self.n\n        return [i, j]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.map.clear()\n\ndef main():\n    # Read entire stdin input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Wrap input in brackets to parse as JSON list of two lists\n    try:\n        ops, args = json.loads('[' + data + ']')\n    except Exception:\n        # Fallback: use ast.literal_eval if json fails\n        ops, args = ast.literal_eval('(' + data + ')')\n    outputs = []\n    instance = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            instance = Solution(*arg)\n            outputs.append(None)\n        elif op == \"flip\":\n            outputs.append(instance.flip())\n        elif op == \"reset\":\n            instance.reset()\n            outputs.append(None)\n        else:\n            # Unknown operation; skip\n            outputs.append(None)\n    # Print results in JSON format (null for None)\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this algorithm. The idea: we maintain a mapping of index to value for the remaining zeros. Initially have m*n slots. Use reservoir idea: treat linear index from 0 to m*n-1. For each flip: pick random index r in [0, remaining-1]. Map r to actual index: if r in map, use map[r]; else use r. Then swap with last remaining: let last = remaining-1; if last in map, use map[last], else last. Map[r] = last. Decrease remaining. Flip matrix cell accordingly. Reset: clear map and set remaining=m*n.\n\nSo we produce virtual code line by line with explanations. Use Start, End, Decision, etc. Let's produce steps for constructor, flip, reset. Provide explanation for each.\n\nLet's start.\n\nAlso note we need to maintain mapping dict.\n\nWe should keep code steps within functions. Provide each line of algorithm.\n\nWe'll create a class Solution: with attributes: m, n, total, map.\n\nStart // initialize class\n\n→ Step 1: Set m ← input m, n ← input n // store dimensions\n\n→ Step 2: Set total ← m * n // total cells\n\n→ Step 3: Set remaining ← total // count of zeros remaining\n\n→ Step 4: Initialize empty map // mapping for swapped indices\n\nEnd // constructor finished\n\nNow flip:\n\nStart // flip function\n\n→ Step 1: If remaining == 0 → Decision: return null? But problem expects that flip will only be called when there is at least one zero. We'll just proceed.\n\n→ Step 2: Generate random integer r in [0, remaining-1] // choose random remaining index\n\n→ Step 3: If r exists in map → Decision: choose actualIndex = map[r] else actualIndex = r // map actual linear index\n\n→ Step 4: Decrease remaining by 1 // one less zero\n\n→ Step 5: Let last = remaining // last index after decrement\n\n→ Step 6: If last exists in map → Decision: mapLast = map[last] else mapLast = last // get actual last index\n\n→ Step 7: Set map[r] = mapLast // update mapping for r to point to last\n\n→ Step 8: // compute i,j from actualIndex: i = actualIndex // n, j = actualIndex % n\n\n→ Step 9: return [i, j] // return coordinates\n\nEnd // flip function\n\nReset:\n\nStart // reset function\n\n→ Step 1: Set remaining ← total // reset count\n\n→ Step 2: Clear map // remove all mappings\n\nEnd // reset\n\nWe can add comments. Also mention min random calls: only 1 per flip.\n\nWe might add decision for empty map. Provide explanation lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 建立 Solution 物件\n→ Step 1: m ← input m, n ← input n // 儲存矩陣尺寸\n→ Step 2: total ← m * n // 計算總格數\n→ Step 3: remaining ← total // 初始可被翻轉的 0 的數量\n→ Step 4: map ← 空映射 // 供交換映射使用\nEnd // 建構完成\n\nStart // flip() 方法\n→ Step 1: r ← 隨機整數 [0, remaining-1] // 只呼叫一次 random\n→ Step 2: Decision: r 是否在 map 中? // 判斷是否已被交換\n    Yes → actual ← map[r] // 取映射後的實際索引\n    No  → actual ← r      // 原索引即為實際索引\n→ Step 3: remaining ← remaining - 1 // 取走一個 0\n→ Step 4: last ← remaining // 最後一個仍為 0 的索引\n→ Step 5: Decision: last 是否在 map 中? // 判斷是否已被映射\n    Yes → lastActual ← map[last] // 取得實際索引\n    No  → lastActual ← last\n→ Step 6: map[r] ← lastActual // 把 r 對應到 last，完成交換\n→ Step 7: i ← actual // n // 計算行\n→ Step 8: j ← actual % n // 計算列\n→ Step 9: return [i, j] // 回傳座標並把對應格子視為 1\nEnd // flip 完成\n\nStart // reset() 方法\n→ Step 1: remaining ← total // 重新設定剩餘 0 的數量\n→ Step 2: map ← 空映射 // 清空所有映射\nEnd // reset 完成"
    },
    {
      "title": "Teemo Attacking",
      "source_file": "Leetcode/leetcode495.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6c1zyhx6.py\", line 22, in parse_input\n    d = eval('{' + data.replace('=', ':') + '}')\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'timeSeries' is not defined\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp6c1zyhx6.py\", line 39, in <module>\n    timeSeries, duration = parse_input(data)\n                           ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6c1zyhx6.py\", line 35, in parse_input\n    return ast.literal_eval(lines[0]), 0\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    timeSeries = [1,4], duration = 2\n               ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp32irwsy9.py\", line 22, in parse_input\n    d = eval('{' + data.replace('=', ':') + '}')\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'timeSeries' is not defined\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp32irwsy9.py\", line 39, in <module>\n    timeSeries, duration = parse_input(data)\n                           ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp32irwsy9.py\", line 35, in parse_input\n    return ast.literal_eval(lines[0]), 0\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    timeSeries = [1,2], duration = 2\n               ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries, duration):\n        if not timeSeries:\n            return 0\n        total = 0\n        for i in range(len(timeSeries) - 1):\n            # 對於相鄰兩次攻擊，加入兩次攻擊間距與持續時間中的最小值\n            total += min(timeSeries[i + 1] - timeSeries[i], duration)\n        total += duration  # 最後一次攻擊的完整持續時間\n        return total\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中解析 timeSeries 與 duration。\"\"\"\n    data = data.strip()\n    if not data:\n        return [], 0\n    # 嘗試將輸入解析成字典形式\n    try:\n        d = eval('{' + data.replace('=', ':') + '}')\n        timeSeries = d.get('timeSeries', [])\n        duration = d.get('duration', 0)\n        return timeSeries, duration\n    except Exception:\n        # 若解析失敗，則假設輸入為兩行：第一行 list，第二行 int\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            timeSeries = ast.literal_eval(lines[0].strip())\n            duration = int(lines[1].strip())\n            return timeSeries, duration\n        else:\n            # 只輸入一行 list，無 duration\n            return ast.literal_eval(lines[0]), 0\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    timeSeries, duration = parse_input(data)\n    solution = Solution()\n    result = solution.findPoisonedDuration(timeSeries, duration)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode to compute total poisoned seconds. The logic: iterate over timeSeries, maintain last attack time, compute overlap. If current attack <= last + duration -1? Actually if current <= last + duration -1, we overlap, add only non-overlap part: duration - (current - last). Else add full duration. Sum.\n\nPseudo:\n\nStart\n→ Step 1: 初始化 total=0, prev=-inf\n→ For each attack time t in timeSeries:\n    → If t <= prev + duration -1:\n        → Step 2: total += duration - (t - prev)\n    → Else:\n        → Step 3: total += duration\n    → Step 4: prev = t\n→ Step 5: 返回 total\nEnd\n\nNeed to use Decision. Provide each line with explanation. Use arrow structure.\n\nMake sure to follow format: each line: \"虛擬碼步驟 // 解釋\". Use \"→\" at beginning.\n\nLet's produce.\n\nWe can also include Start and End lines.\n\nMake sure to use proper arrow indentation. Example:\n\nStart // 程式開始\n→ Step 1: total ← 0 // 初始化總毒秒數\n→ Step 2: prev ← -∞ // 先前攻擊時間，初始化為負無限\n→ Decision: 是否有攻擊事件? // 判斷 timeSeries 是否非空\n    Yes → Step 3: 對於每個 t 在 timeSeries 中循環 // 逐一處理攻擊\n        → Decision: t 是否 <= prev + duration - 1? // 檢查是否重疊\n            Yes → Step 4: total ← total + duration - (t - prev) // 加入非重疊部分\n            No  → Step 5: total ← total + duration // 加入完整持續時間\n        → Step 6: prev ← t // 更新前一次攻擊時間\n    No → // timeSeries 為空，無毒秒\n→ Step 7: 返回 total // 結果\nEnd // 程式結束\n\nWe should maintain each line separately. Provide line numbers maybe not necessary. Provide arrow for Decision indent.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: total ← 0 // 初始化總毒秒數  \n→ Step 2: prev ← -∞ // 先前攻擊時間，初始為負無限  \n→ Decision: 是否存在攻擊事件? // 判斷 timeSeries 是否非空  \n Yes → Step 3: 對於每個 t 在 timeSeries 中循環 // 逐一處理攻擊  \n  → Decision: t 是否 ≤ prev + duration - 1? // 檢查新攻擊是否覆蓋前一次毒效果  \n   Yes → Step 4: total ← total + duration - (t - prev) // 加入新攻擊僅新增的毒秒  \n   No  → Step 5: total ← total + duration // 新攻擊不重疊，加入完整毒秒  \n  → Step 6: prev ← t // 更新前一次攻擊時間  \n No  → // timeSeries 為空，無毒秒  \n→ Step 7: 返回 total // 結果輸出  \nEnd // 程式結束執行"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9kuiq4ci.py\", line 69, in <module>\n    main()\n  File \"/tmp/tmp9kuiq4ci.py\", line 48, in main\n    obj.buildDict(params[i])\n  File \"/tmp/tmp9kuiq4ci.py\", line 13, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MagicDictionary:\n    \"\"\"魔法字典：能檢查是否可以改變一個字元與已存字典相符。\"\"\"\n\n    def __init__(self):\n        # 用 set 儲存所有單詞，O(1) 查詢\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        \"\"\"設定字典，dictionary 為字串列表。\"\"\"\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        \"\"\"若能改變 searchWord 的恰好一個字元，使其與字典中的某字相同，則回傳 True。\"\"\"\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = 0\n            for a, b in zip(word, searchWord):\n                if a != b:\n                    diff += 1\n                    if diff > 1:\n                        break\n            if diff == 1:\n                return True\n        return False\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 將輸入解析為兩個列表：方法名與對應參數\n    data = ast.literal_eval(f'({raw_input})')\n    methods, params = data\n\n    results = []\n    obj = None\n\n    for i, method in enumerate(methods):\n        if method == 'MagicDictionary':\n            obj = MagicDictionary()\n            results.append(None)            # 建構函式回傳 null\n        elif method == 'buildDict':\n            obj.buildDict(params[i])\n            results.append(None)            # buildDict 回傳 null\n        elif method == 'search':\n            res = obj.search(params[i])\n            results.append(res)             # search 回傳 true/false\n        else:\n            # 任何未知方法都視為 None\n            results.append(None)\n\n    # 轉換結果為 LeetCode 所需格式（null/true/false）\n    output = []\n    for v in results:\n        if v is None:\n            output.append('null')\n        elif isinstance(v, bool):\n            output.append('true' if v else 'false')\n        else:\n            output.append(str(v))\n    print('[' + ', '.join(output) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudocode) for the MagicDictionary problem. Provide step-by-step instructions with explanations, using arrows and decisions. Must be line-by-line. No actual code. Just pseudocode steps.\n\nLet's design algorithm: Use a map from word to list of variants with one character replaced by placeholder. For search: generate all variants of searchWord by replacing each char with placeholder and check if any variant exists in map and matches word not same as searchWord? Actually we need exactly one char changed to match any word. So we can iterate each position, change char to any letter a-z, if matches any word. Use set of words for quick check. So simpler: searchWord, for each pos, for each letter 'a' to 'z' != original, replace, check if word exists in dictionary set. Return true if any. Complexity O(26 * L). Build dict store set.\n\nPseudocode steps: Start, initialize set, buildDict: iterate each word add to set. search: if searchWord in set? Not needed but we might skip. For each index i in searchWord: original = searchWord[i]; for each letter c in 'a'..'z': if c == original continue; newWord = searchWord[0:i] + c + searchWord[i+1:]; if newWord in dict set: return true. After loops return false. End.\n\nNeed to use Virtual Code arrows.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化空字典集合 // 用於存放所有單詞\n→ Step 2: buildDict(dictionary) // 建構函式，接收字典\n    → Decision: 若 dictionary 為空? // 檢查是否有單詞\n        Yes → End // 空字典，結束\n        No  → For each word in dictionary: // 迭代所有單詞\n            → Step 3: 將 word 加入字典集合 // 儲存單詞\n→ Step 4: search(searchWord) // 搜尋函式\n    → Step 5: For i from 0 to length(searchWord)-1: // 遍歷每個位置\n        → Step 6: original = searchWord[i] // 取得原始字母\n        → For each letter c in 'a'..'z': // 嘗試替換\n            → Decision: c == original? // 是否為相同字母\n                Yes → Continue // 跳過\n                No  → Step 7: newWord = 替換位置 i 的字母為 c // 建構新字串\n                    → Decision: newWord 在字典集合中? // 檢查是否存在\n                        Yes → Return true // 找到可改變一個字母的單詞\n                        No  → Continue // 試下個字母\n    → Step 8: Return false // 未找到符合條件的單詞\nEnd\n\nWe must format each line: \"虛擬碼步驟 // 解釋\".\n\nInclude arrows with spaces. Use Start, End.\n\nWe need to ensure each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典集合 // 用於存放所有單詞  \n→ Step 2: buildDict(dictionary) // 建構函式，接收字典  \n    → Decision: 若 dictionary 為空? // 檢查是否有單詞  \n        Yes → End // 空字典，結束  \n        No  → For each word in dictionary: // 迭代所有單詞  \n            → Step 3: 將 word 加入字典集合 // 儲存單詞  \n→ Step 4: search(searchWord) // 搜尋函式  \n    → Step 5: For i from 0 to length(searchWord)-1: // 遍歷每個位置  \n        → Step 6: original = searchWord[i] // 取得原始字母  \n        → For each letter c in 'a'..'z': // 嘗試替換  \n            → Decision: c == original? // 是否為相同字母  \n                Yes → Continue // 跳過  \n                No  → Step 7: newWord = 替換位置 i 的字母為 c // 建構新字串  \n                    → Decision: newWord 在字典集合中? // 檢查是否存在  \n                        Yes → Return true // 找到可改變一個字母的單詞  \n                        No  → Continue // 試下個字母  \n    → Step 8: Return false // 未找到符合條件的單詞  \nEnd // 程式執行結束"
    },
    {
      "title": "Non-decreasing Subsequences",
      "source_file": "Leetcode/leetcode491.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,6,7,7]",
          "expected_output": "[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]'\nGot (Norm):      '[[7,7],[4,6],[4,7,7],[6,7],[6,7,7],[4,6,7],[4,6,7,7],[4,7]]'\n--- (Raw) ---\nRaw Expected: '[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]'\nRaw Got:      '[[7, 7], [4, 6], [4, 7, 7], [6, 7], [6, 7, 7], [4, 6, 7], [4, 6, 7, 7], [4, 7]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findSubsequences(self, nums):\n        result = set()  # 用集合保存唯一的子序列，使用 tuple 作為鍵\n\n        def backtrack(start, path):\n            if len(path) >= 2:\n                result.add(tuple(path))  # 把可哈希的 tuple 加入集合\n            used = set()  # 同一層級已選過的數字，避免重複\n            for i in range(start, len(nums)):\n                if (not path or nums[i] >= path[-1]) and nums[i] not in used:\n                    used.add(nums[i])\n                    path.append(nums[i])\n                    backtrack(i + 1, path)\n                    path.pop()\n\n        backtrack(0, [])\n        return [list(t) for t in result]  # 將 tuple 轉回列表\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 解析輸入，預期類似 \"nums = [4,6,7,7]\"\n    try:\n        # 找到第一個 '[' 並提取到最後一個 ']' 之間的子串\n        start = data.index('[')\n        end = data.rindex(']') + 1\n        nums = ast.literal_eval(data[start:end])\n    except Exception:\n        # 若輸入格式不符合，直接嘗試解析整個輸入\n        nums = ast.literal_eval(data)\n    sol = Solution()\n    res = sol.findSubsequences(nums)\n    print(res)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve problem: find all distinct non-decreasing subsequences length>=2. We need to provide each line with explanation. Should include Start, End, Decision, arrow. Virtual code: maybe use recursion/backtracking, set for uniqueness.\n\nWe need step by step: Start, initialize result set, define backtrack function, iterate over indices, maintain path, etc. Provide each line. Use virtual code language.\n\nWe should produce something like:\n\nStart // 開始\n\n→ Step 1: 初始化 result 為空集合 // 用於儲存唯一子序列\n\n→ Step 2: 定義遞迴函式 backtrack(startIndex, currentPath) // 生成子序列\n\n→ Decision: 若 currentPath 長度 >=2? // 判斷是否符合長度要求\n\n    Yes → Step 3: 把 currentPath 的字串表示加入 result // 以字串或 tuple 存入集合避免重複\n\n→ Step 4: 循環 i 從 startIndex 到 nums.length-1 // 選擇下一個元素\n\n    → Decision: 若 currentPath 為空 或 nums[i] >= currentPath.last? // 非遞減條件\n\n        Yes → Step 5: 將 nums[i] 加入 currentPath // 選擇元素\n\n        → Step 6: 呼叫 backtrack(i+1, currentPath) // 深度遞迴\n\n        → Step 7: 移除 currentPath 最後一個元素 // 回溯\n\n→ End // 完成\n\n→ Step 8: 把 result 轉成數字列表列表 // 將字串/tuple 轉回數組\n\n→ Return result // 返回結果\n\nAlso need to handle duplicates: we can use set to avoid duplicates; or skip same numbers at same depth. Might mention using a local set to avoid duplicate next values in same level.\n\nLet's produce virtual code lines with explanation.\n\nMake sure to use arrow → for steps, Decision: with Yes → No →. Provide explanation in Chinese.\n\nLet's craft each line.\n\nWe also need to include recursion function signature.\n\nLine order:\n\n1. Start\n2. → Step 1: result = empty set // 用於儲存不同子序列\n3. → Step 2: 定義函式 backtrack(index, path) // index 為下一個可選擇的位置\n4. → Step 3: 如果 path 長度 >= 2? // 判斷是否為合法子序列\n    Yes → Step 4: 把 path 轉成 tuple 加入 result // 使用 tuple 以可哈希存入集合\n5. → Step 5: localVisited = empty set // 用於此層級避免重複選擇相同數字\n6. → Step 6: 循環 i 從 index 到 nums.length-1\n    → Decision: 若 nums[i] 已在 localVisited? // 同一層級的重複數字跳過\n        Yes → No  // 跳過\n    → Step 7: 將 nums[i] 加入 localVisited // 記錄已處理\n    → Decision: 若 path 為空 或 nums[i] >= path.last? // 非遞減條件\n        Yes → Step 8: path.append(nums[i]) // 添加\n        → Step 9: backtrack(i+1, path) // 進一步延伸\n        → Step 10: path.pop() // 回溯\n        No  → No // 跳過\n7. → Step 11: return // backtrack 退出\n8. → Step 12: backtrack(0, empty list) // 開始遞迴\n9. → Step 13: resultList = 把 result 集合中的 tuple 轉成數字列表 // 轉回原型\n10. → Step 14: return resultList // 結果輸出\nEnd\n\nWe need to ensure each line ends with // 解釋.\n\nAlso we must maintain format: each line has \"虛擬碼步驟 [空格] // 解釋/說明\". Use arrow. The decision block uses indentation? We can indent lines under decision but still separate lines. Use arrow for nested steps. Eg:\n\nDecision: ... \n    Yes → Step ...\n    No  → Step ... (maybe no step)\n\nBut we need each line.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result = EmptySet() // 用來儲存所有不同的子序列  \n→ Step 2: 定義函式 backtrack(index, path) // index 為下一個可選擇的元素位置  \n→ Step 3: Decision: 如果 path 長度 >= 2? // 檢查是否已滿足子序列長度  \n  Yes → Step 4: result.add(tuple(path)) // 把 path 轉成不可變元組加入集合，避免重複  \n→ Step 5: localVisited = EmptySet() // 本層級已選擇過的數字，避免重複選擇  \n→ Step 6: 循環 i 於 index .. nums.length-1 // 嘗試每個未選元素  \n  Decision: 如果 nums[i] 已在 localVisited? // 同一層級重複的數字不再考慮  \n   Yes → No // 跳過此元素  \n   No  → Step 7: localVisited.add(nums[i]) // 標記已處理  \n  Decision: 如果 path 為空 或 nums[i] >= path[-1]? // 確保非遞減  \n   Yes → Step 8: path.append(nums[i]) // 選取此數字  \n    → Step 9: backtrack(i+1, path) // 進一步遞迴  \n    → Step 10: path.pop() // 回溯至上一狀態  \n   No  → No // 不符合非遞減條件，跳過  \n→ Step 11: return // backtrack 結束  \n→ Step 12: backtrack(0, EmptyList()) // 從首位開始遞迴  \n→ Step 13: resultList = [list(t) for t in result] // 把集合中的元組轉回列表  \n→ Step 14: return resultList // 回傳所有不同的非遞減子序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0p8cunnn.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmp0p8cunnn.py\", line 42, in main\n    words = ast.literal_eval(matches[0])\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"apple\"]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass WordFilter:\n    \"\"\"\n    建構時將所有單字的每個前綴與每個後綴組合存成 dict。\n    key 為 (前綴, 後綴)，value 為對應單字的最大索引。\n    \"\"\"\n    def __init__(self, words):\n        self.lookup = {}\n        for idx, word in enumerate(words):\n            L = len(word)\n            # 產生所有可能的前綴\n            for i in range(L + 1):\n                pref = word[:i]\n                # 產生所有可能的後綴\n                for j in range(L + 1):\n                    suff = word[j:]\n                    # 只保留最大的索引\n                    self.lookup[(pref, suff)] = idx\n\n    def f(self, prefix, suffix):\n        \"\"\"\n        直接從 dict 查詢，若沒有則回傳 -1。\n        \"\"\"\n        return self.lookup.get((prefix, suffix), -1)\n\ndef main():\n    \"\"\"\n    讀取標準輸入並處理。\n    期望輸入格式：\n        第一個 Python list 為單字列表\n        第二個 Python list 為 [prefix, suffix]（單一查詢）\n    範例：\n        [\"apple\",\"apply\",\"ape\"] , [\"ap\",\"e\"]\n    \"\"\"\n    data = sys.stdin.read()\n    # 找出兩個最外層的 []，這裡假設輸入只有兩個列表\n    matches = re.findall(r'\\[.*?\\]', data)\n    if len(matches) >= 2:\n        words = ast.literal_eval(matches[0])\n        query = ast.literal_eval(matches[1])\n        prefix, suffix = query[0], query[1]\n    else:\n        # 無法解析輸入時回傳 -1\n        words = []\n        prefix, suffix = '', ''\n\n    wf = WordFilter(words)\n    result = wf.f(prefix, suffix)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing WordFilter class: constructor, function f(pref, suff). The problem: we need to design a special dictionary that can search words by prefix and suffix. Typically solution: build a Trie for prefixes and suffixes or build a dictionary mapping (pref, suff) to max index. But we need virtual code, not actual code. We'll produce step-by-step pseudocode: Start, Step 1: Initialize data structures (like hash map), Step 2: For each word, iterate all prefixes and suffixes, update map, etc. Then f: look up key and return index or -1.\n\nWe need to output line by line: each line: virtual code step + \" // explanation\". Use arrows: Start, End, Decision: etc. Use \"→\" for flow. Provide steps as per virtual code. Let's structure:\n\nStart\n→ Step 1: Initialize an empty hash map map<pair<string,string>, int> // map from prefix+suffix to max index\n→ Step 2: For each word with index i in words // Build map\n    → Decision: iterate all prefixes p of word\n        Yes → Decision: iterate all suffixes s of word\n            Yes → Step 3: key = p + \"#\" + s // combine\n                → Step 4: if key not in map or map[key] < i: map[key] = i // store max index\n            No → // no more suffixes\n        No → // no more prefixes\n→ Step 5: Store map in object // ready\n→ End\n\nf(pref, suff)\n→ Step 6: key = pref + \"#\" + suff\n→ Decision: if key exists in map? // check\n    Yes → Step 7: return map[key] // found index\n    No  → Step 8: return -1 // not found\n→ End\n\nMake sure to use the arrow syntax. Use \"Decision:\" lines. Provide explanation in Chinese. Also need to keep each line separated. Provide no actual code. Use proper formatting.\n\nLet's produce.\n\nNote: We might want to mention that map can be built with nested loops. Provide steps accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空的 hash map key為「prefix#suffix」→最大索引 // 用來存放每個前後綴組合對應的最大單字索引\n→ Step 2: 從 words 列表取出每個單字 word 並記錄其索引 i // 開始為所有單字建立索引對應表\n    → Decision: 產生單字 word 的所有可能前綴 p\n        Yes → Decision: 產生單字 word 的所有可能後綴 s\n            Yes → Step 3: key = p + \"#\" + s // 用「#」分隔前後綴作為字典鍵\n                → Step 4: 若 key 不存在於 map 或 map[key] < i，則 map[key] ← i // 只保留最大的索引\n            No  → // 無更多後綴\n        No  → // 無更多前綴\n→ Step 5: 以上循環結束，將 map 存入物件中，完成建構階段\n→ End // 建構結束，準備接受查詢\n\n// -------------------------- 查詢方法 f --------------------------\nStart // f 方法開始執行\n→ Step 6: key = pref + \"#\" + suff // 組合前綴和後綴作為查詢鍵\n→ Decision: key 是否存在於 map？\n    Yes → Step 7: return map[key] // 回傳對應的最大索引\n    No  → Step 8: return -1 // 若不存在，回傳 -1 表示沒有符合條件的單字\n→ End // f 方法結束執行"
    },
    {
      "title": "License Key Formatting",
      "source_file": "Leetcode/leetcode482.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"5F3Z-2e-9-w\", k = 4",
          "expected_output": " \"5F3Z-2E9W\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5F3Z-2E9W'\nGot (Norm):      '5F3Z2E9W'\n--- (Raw) ---\nRaw Expected: ' \"5F3Z-2E9W\"'\nRaw Got:      '5F3Z2E9W'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\n        # 移除所有 '-' 並轉為大寫\n        S = S.replace('-', '').upper()\n        n = len(S)\n        # 第一組長度，如果 n % K 為 0 則整個字串即為完整組\n        first_group_len = n % K or K\n        res = [S[:first_group_len]]\n        for i in range(first_group_len, n, K):\n            res.append(S[i:i+K])\n        return '-'.join(res)\n\ndef parse_input(data: str):\n    lines = data.strip().splitlines()\n    # 若兩行且都不包含雙引號，直接使用\n    if len(lines) >= 2 and all('\"' not in line for line in lines[:2]):\n        s = lines[0].strip()\n        try:\n            k = int(lines[1].strip())\n        except ValueError:\n            # 可能行中含有其他字元，嘗試抽取數字\n            m_k = re.search(r'\\b(\\d+)\\b', lines[1])\n            k = int(m_k.group(1)) if m_k else 0\n        return s, k\n\n    # 其它情況，嘗試用正則從整個輸入中提取\n    m_str = re.search(r'\"([^\"]*)\"', data)\n    s = m_str.group(1) if m_str else lines[0].strip()\n    m_k = re.search(r'\\b(\\d+)\\b', data)\n    k = int(m_k.group(1)) if m_k else 0\n    return s, k\n\ndef main():\n    input_data = sys.stdin.read()\n    s, k = parse_input(input_data)\n    solution = Solution()\n    result = solution.licenseKeyFormatting(s, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the license key reformatting problem. Steps: remove dashes, uppercase, then split into groups of k from the end. Then join with dashes.\n\nWe need to output each line: Virtual step + comment. Use Start, End, Decision. Use arrow →. Each step line: \"→ Step X: description // explanation\".\n\nLet's design steps:\n\nStart\n→ Step 1: Remove all dashes from s // clean string\n→ Step 2: Convert all letters to uppercase // unify case\n→ Decision: Determine length of cleaned string? Actually compute number of groups. \nSimplify: Let L = length of cleaned string.\n→ Step 3: Calculate size of first group: firstGroupSize = L % k; if 0, set firstGroupSize = k // compute first group length\n→ Decision: If firstGroupSize == 0? but we already set to k; maybe skip.\n→ Step 4: Initialize result list\n→ Decision: If firstGroupSize > 0? Actually always >0, but may equal k if L%k==0. We'll handle.\n\nWe'll create result list.\n\n→ Step 5: Append first group substring of cleaned string[0:firstGroupSize] to result // first group\n→ Step 6: For i from firstGroupSize to L step k: Append cleaned string[i:i+k] to result // subsequent groups\n→ Step 7: Join result list with dashes to form reformatted string // final output\nEnd\n\nWe can include some decisions, but minimal.\n\nBut they want arrows and decision structure. We could add Decision for if firstGroupSize==0? But we set to k. So maybe not needed.\n\nWe can still show Decision: If firstGroupSize==0? But we set to k. We could use decision to handle if firstGroupSize==k meaning first group full? Might be not necessary.\n\nBetter: Use Decision: If firstGroupSize==k? Then first group will be full k, no special. But anyway.\n\nWe can produce steps as simple.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Remove all dashes from s // 移除所有破折號\n→ Step 2: Convert string to uppercase // 將所有字母轉為大寫\n→ Step 3: Calculate length L of cleaned string // 取得字串長度\n→ Step 4: Determine firstGroupSize = L mod k; if firstGroupSize == 0 then firstGroupSize = k // 計算第一組長度\n→ Decision: firstGroupSize < k? // 判斷第一組是否短於 k\n    Yes → Step 5: Append firstGroup = cleaned[0:firstGroupSize] to result list // 加入第一組\n    No  → Step 5: Append firstGroup = cleaned[0:k] to result list // 若等於 k，仍加入\n→ Step 6: For i from firstGroupSize to L step k: Append cleaned[i:i+k] to result // 加入後續每組 k 個字元\n→ Step 7: Join result with dashes to form reformattedKey // 用破折號連接各組\nEnd // 程式執行結束\n\nBut maybe too many decisions. They want arrow and structure. Let's refine.\n\nBetter:\n\nStart // 程式開始執行\n→ Step 1: cleaned ← RemoveAll(s, '-') // 移除所有破折號\n→ Step 2: cleaned ← ToUpperCase(cleaned) // 將字母轉為大寫\n→ Step 3: L ← Length(cleaned) // 取得字串長度\n→ Step 4: firstGroupSize ← L mod k // 計算第一組長度\n    Decision: firstGroupSize == 0? // 判斷是否為 0\n        Yes → firstGroupSize ← k // 若為 0，第一組為完整 k 個字元\n        No  → // 保持原值\n→ Step 5: result ← EmptyList // 初始化結果列表\n→ Step 6: Append(result, Substring(cleaned, 0, firstGroupSize)) // 加入第一組\n→ Step 7: i ← firstGroupSize // 設定迴圈起點\n→ Decision: i < L? // 是否還有剩餘字元？\n    Yes → \n        → While i < L:\n            → Append(result, Substring(cleaned, i, k)) // 加入每個 k 字元組\n            → i ← i + k // 移動到下一組起點\n    No  → // 無剩餘字元，跳過\n→ Step 8: reformattedKey ← Join(result, '-') // 用破折號連接各組\nEnd // 程式執行結束\n\nThis includes while loop; but virtual code can use While. The structure uses Decision. Provide explanation.\n\nLet's format properly with arrows and comments.\n\nEnsure each line has \"→ Step X:\" etc. Indentation for nested steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: cleaned ← RemoveAll(s, '-') // 移除所有破折號，得到純字元串  \n→ Step 2: cleaned ← ToUpperCase(cleaned) // 將所有字母轉為大寫，統一格式  \n→ Step 3: L ← Length(cleaned) // 取得清理後字串的長度  \n→ Step 4: firstGroupSize ← L mod k // 計算第一組應有的長度  \n Decision: firstGroupSize == 0? // 判斷是否剛好能被 k 整除  \n  Yes → firstGroupSize ← k // 若為 0，則第一組長度設為完整 k  \n  No  → // 保持原值，第一組會短於 k  \n→ Step 5: result ← EmptyList // 初始化結果列表，用於存放各組字串  \n→ Step 6: Append(result, Substring(cleaned, 0, firstGroupSize)) // 加入第一組  \n→ Step 7: i ← firstGroupSize // 設定接下來的起點  \n Decision: i < L? // 是否還有剩餘字元需要分組？  \n  Yes →  \n   → While i < L:  \n     → Append(result, Substring(cleaned, i, k)) // 把每 k 個字元加入結果  \n     → i ← i + k // 移動到下一組的起點  \n  No  → // 沒有剩餘字元，跳過迴圈  \n→ Step 8: reformattedKey ← Join(result, '-') // 用破折號把各組連接起來  \nEnd // 程式執行結束"
    },
    {
      "title": "Parse Lisp Expression",
      "source_file": "Leetcode/leetcode736.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe9p_yxg3.py\", line 60, in <module>\n    result = solution.evaluate(expr)\n             ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpe9p_yxg3.py\", line 52, in evaluate\n    return eval_expr(expression, {})\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpe9p_yxg3.py\", line 12, in eval_expr\n    return int(expr)               # integer\n           ^^^^^^^^^\nValueError: invalid literal for int() with base 10: '\"(let x 2 (mult x (let x 3 y 4 (add x y))))\"'"
        },
        {
          "example_index": 1,
          "input": "expression = \"(let x 3 x 2 x)\"",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcfy7brul.py\", line 60, in <module>\n    result = solution.evaluate(expr)\n             ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpcfy7brul.py\", line 52, in evaluate\n    return eval_expr(expression, {})\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpcfy7brul.py\", line 12, in eval_expr\n    return int(expr)               # integer\n           ^^^^^^^^^\nValueError: invalid literal for int() with base 10: '\"(let x 3 x 2 x)\"'"
        },
        {
          "example_index": 2,
          "input": "expression = \"(let x 1 y 2 x (add x y) (add x y))\"",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8_4wrac0.py\", line 60, in <module>\n    result = solution.evaluate(expr)\n             ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8_4wrac0.py\", line 52, in evaluate\n    return eval_expr(expression, {})\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8_4wrac0.py\", line 12, in eval_expr\n    return int(expr)               # integer\n           ^^^^^^^^^\nValueError: invalid literal for int() with base 10: '\"(let x 1 y 2 x (add x y) (add x y))\"'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        def eval_expr(expr: str, env: dict) -> int:\n            expr = expr.strip()\n            # Base case: single token (integer or variable)\n            if expr[0] != '(':\n                if expr[0].isalpha():          # variable\n                    return env[expr]\n                return int(expr)               # integer\n\n            # Remove outer parentheses\n            expr = expr[1:-1]\n            tokens = []\n            bal = 0\n            start = 0\n            for i, ch in enumerate(expr):\n                if ch == '(':\n                    bal += 1\n                elif ch == ')':\n                    bal -= 1\n                elif ch == ' ' and bal == 0:\n                    tokens.append(expr[start:i])\n                    start = i + 1\n            tokens.append(expr[start:])          # last token\n\n            op = tokens[0]\n            if op == 'add':\n                left = eval_expr(tokens[1], env.copy())\n                right = eval_expr(tokens[2], env.copy())\n                return left + right\n            if op == 'mult':\n                left = eval_expr(tokens[1], env.copy())\n                right = eval_expr(tokens[2], env.copy())\n                return left * right\n            if op == 'let':\n                new_env = env.copy()\n                i = 1\n                # Process all var expr pairs except the last expression\n                while i < len(tokens) - 1:\n                    var_name = tokens[i]\n                    var_value = eval_expr(tokens[i + 1], new_env)\n                    new_env[var_name] = var_value\n                    i += 2\n                # Evaluate the final expression in the updated environment\n                return eval_expr(tokens[-1], new_env)\n            # Should not reach here for valid inputs\n            return 0\n\n        return eval_expr(expression, {})\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the expression after 'expression =' if present\n    match = re.search(r'expression\\s*=\\s*(.*)', data)\n    expr = match.group(1).strip() if match else data\n    solution = Solution()\n    result = solution.evaluate(expr)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for evaluating such expression. Probably design algorithm. Use stack, recursion, scope dictionary stack. Provide steps. Let's write generic algorithm: parse expression string into tokens. Then evaluate recursively.\n\nWe must output virtual code line by line. Use Start, Step, Decision, etc.\n\nLet's craft steps:\n\nStart // begin evaluation\n→ Step 1: Tokenize input string // split parentheses, variables, integers\n→ Step 2: Initialize empty scope stack // list of dictionaries\n→ Step 3: Call Evaluate(tokens, index=0, scopeStack) // recursive parse\n\nDefine Evaluate function:\n\n→ Decision: If current token is '(' // it's an expression\n    Yes → Step 4: Read operator token after '('\n    → Decision: If operator == 'let'\n        Yes → Step 5: Initialize newScope = copy of top scope\n        → Step 6: While next token not end of let expression '... expr'\n            → Step 7: Parse variable name\n            → Step 8: Evaluate expression for variable and store in newScope\n            → Decision: If next token is variable name (start of next pair)\n                Yes → Continue loop\n                No → Break\n        → Step 9: Evaluate final expr with newScope\n        → Step 10: Return result\n    → Decision: If operator == 'add'\n        Yes → Step 11: Evaluate first operand\n        → Step 12: Evaluate second operand\n        → Step 13: Return sum\n    → Decision: If operator == 'mult'\n        Yes → Step 14: Evaluate first operand\n        → Step 15: Evaluate second operand\n        → Step 16: Return product\n→ Decision: If current token is variable name // not '('\n    Yes → Step 17: Lookup variable in scope stack from top to bottom\n    → Step 18: Return found value\n→ Decision: If current token is integer // digit or '-'\n    Yes → Step 19: Convert to integer and return\n\nAfter recursion ends:\n→ Step 20: Output result // final integer\nEnd // program ends\n\nNeed to use arrows and structure. Provide line-by-line.\n\nWe must ensure each line ends with // explanation. Use arrow after Start and End. Provide decision branches.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Tokenize input string // 把表達式拆成單獨的符號、變數與整數\n→ Step 2: 初始化空的作用域棧 // 每層括號對應一個字典\n→ Step 3: 調用 Evaluate( tokens , idx = 0 , scopeStack ) // 從左邊開始遞迴解析\n\nNow define Evaluate:\n\n→ Decision: tokens[idx] 是否為 '(' // 判斷是否為子表達式\n    Yes → Step 4: idx++ // 移到操作符位置\n    → Step 5: operator = tokens[idx] // 取得 let / add / mult\n    → Decision: operator 為 'let'?\n        Yes → Step 6: 新建 currentScope 為上一層作用域的複製 // 變數只在 let 的內部可見\n        → Step 7: idx++ // 跳到第一個變數或表達式\n        → Decision: tokens[idx] 是否為最後一個 expr 的開始?\n            No → Step 8: 解析變數名 varName = tokens[idx]\n            → Step 9: idx++ // 進入對應的表達式\n            → Step 10: value = Evaluate( tokens , idx , scopeStack + [currentScope] ) // 評估表達式並儲存\n            → Step 11: currentScope[varName] = value // 把變數加入作用域\n            → Step 12: idx++ // 移到下一個 token\n            → Decision: tokens[idx] 是否為變數名（仍有 pair）\n                Yes → Go back to Step 8\n                No  → Go to Step 13\n        → Step 13: idx++ // 移到最後 expr\n        → Step 14: result = Evaluate( tokens , idx , scopeStack + [currentScope] ) // 評估最後 expr\n        → Step 15: return result\n    → Decision: operator 為 'add'?\n        Yes → Step 16: idx++ // 移到第一個操作數\n        → Step 17: left = Evaluate( tokens , idx , scopeStack )\n        → Step 18: idx++ // 移到第二個操作數\n        → Step 19: right = Evaluate( tokens , idx , scopeStack )\n        → Step 20: return left + right\n    → Decision: operator 為 'mult'?\n        Yes → Step 21: idx++ // 移到第一個操作數\n        → Step 22: left = Evaluate( tokens , idx , scopeStack )\n        → Step 23: idx++ // 移到第二個操作數\n        → Step 24: right = Evaluate( tokens , idx , scopeStack )\n        → Step 25: return left * right\n    → Step 26: idx++ // 移到 ')'，結束本子表達式\n\n→ Decision: tokens[idx] 是否為變數名（非 '('）?\n    Yes → Step 27: 在 scopeStack 從上往下查找 varName\n    → Step 28: 取到對應的值並返回\n→ Decision: tokens[idx] 是否為整數（正負號）?\n    Yes → Step 29: 將字串轉成整數並返回\n\nAfter Evaluate completes:\n→ Step 30: 將結果輸出 // 最終回傳的整數值\n\nEnd // 程式執行結束\n\nWe need to maintain idx updates etc. Provide more concise but maintain logic. Ensure arrow formatting. Let's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Tokenize input string // 把整個 Lisp 風格表達式拆成單獨的符號、變數與整數\n→ Step 2: 初始化空的作用域棧 // 每層括號對應一個字典，儲存該層的變數值\n→ Step 3: 調用 Evaluate( tokens , idx = 0 , scopeStack ) // 從左邊開始遞迴解析\n\n// Evaluate 函式\n→ Decision: tokens[idx] 是否為 '(' // 判斷是否為子表達式\n    Yes → Step 4: idx++ // 移到操作符位置\n    → Step 5: operator = tokens[idx] // 取得 'let' / 'add' / 'mult'\n    → Decision: operator 為 'let'?\n        Yes → Step 6: currentScope ← 複製上一層作用域 // 變數只在此 let 的內部可見\n        → Step 7: idx++ // 進入第一個變數或表達式\n        → Decision: tokens[idx] 為最後一個 expr 的開始？\n            No  → Step 8: varName ← tokens[idx] // 取得變數名\n            → Step 9: idx++ // 進入對應的表達式\n            → Step 10: value ← Evaluate( tokens , idx , scopeStack + [currentScope] ) // 評估表達式\n            → Step 11: currentScope[varName] ← value // 把變數加入作用域\n            → Step 12: idx++ // 移到下一個 token\n            → Decision: tokens[idx] 是否仍為變數名？\n                Yes → Go back to Step 8\n                No  → Go to Step 13\n        → Step 13: idx++ // 跳到最後 expr\n        → Step 14: result ← Evaluate( tokens , idx , scopeStack + [currentScope] ) // 評估最後 expr\n        → Step 15: return result\n    → Decision: operator 為 'add'?\n        Yes → Step 16: idx++ // 進入第一個操作數\n        → Step 17: left ← Evaluate( tokens , idx , scopeStack )\n        → Step 18: idx++ // 進入第二個操作數\n        → Step 19: right ← Evaluate( tokens , idx , scopeStack )\n        → Step 20: return left + right\n    → Decision: operator 為 'mult'?\n        Yes → Step 21: idx++ // 進入第一個操作數\n        → Step 22: left ← Evaluate( tokens , idx , scopeStack )\n        → Step 23: idx++ // 進入第二個操作數\n        → Step 24: right ← Evaluate( tokens , idx , scopeStack )\n        → Step 25: return left * right\n    → Step 26: idx++ // 移到 ')'，結束本子表達式\n\n→ Decision: tokens[idx] 是否為變數名（非 '('）？\n    Yes → Step 27: 從 scopeStack 頂層往下查找 varName 的值\n    → Step 28: 取到對應的值並返回\n→ Decision: tokens[idx] 是否為整數（含負號）？\n    Yes → Step 29: 將字串轉成整數並返回\n\n// Evaluate 結束，回到 Step 3\n→ Step 30: 將最終結果輸出 // 回傳整個表達式的整數值\n\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,4,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 4, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"將所有索引分組，方便之後隨機挑選\"\"\"\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        \"\"\"隨機返回 target 所對應索引的其中一個，均等機率\"\"\"\n        return random.choice(self.indices[target])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入分為方法名列表與對應的參數列表\n    split_idx = data.find('],')\n    methods_str = data[:split_idx + 1]\n    args_str = data[split_idx + 2:].strip()\n\n    methods = ast.literal_eval(methods_str)\n    args_list = ast.literal_eval(args_str)\n\n    # 建立 Solution 物件\n    obj = None\n    results = []\n    for i, method in enumerate(methods):\n        if i == 0:          # 第一個方法為建構子\n            obj = Solution(*args_list[i])\n            results.append(None)  # 建構子回傳 null\n        else:\n            # 呼叫對應的方法，並記錄回傳值\n            func = getattr(obj, method)\n            res = func(*args_list[i])\n            results.append(res)\n\n    # 產生輸出字串，null 需要不帶引號\n    out_parts = []\n    for r in results:\n        if r is None:\n            out_parts.append('null')\n        else:\n            out_parts.append(str(r))\n    output = '[' + ', '.join(out_parts) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps, not actual code, with explanation, line by line. The requirement: implement Solution class: constructor takes array; pick method picks random index among equal values. We need to design approach: store mapping from target to list of indices; then pick random index using random generator.\n\nSo steps: Start, initialize data structure, fill mapping. For pick: get list of indices for target; generate random number between 0 and list size-1; return index at that position.\n\nAlso ensure randomness each call.\n\nWe output line by line with \"虛擬碼步驟 // 解釋\". Use arrow etc.\n\nLet's produce.\n\nAlso we need to include Start and End. Use Decision? Not necessary.\n\nLet's produce:\n\nStart\n→ Initialize map // create empty mapping\n→ For each index i in nums\n    → Add i to map[nums[i]] list // group indices by value\n→ End Constructor // finish initialization\n\npick(target)\n→ Retrieve list L from map for target // indices with that value\n→ Generate r = random integer in [0, size(L)-1] // random offset\n→ Return L[r] // random index chosen\nEnd\n\nWe might also include a method for random generator: Use random function.\n\nWe need to follow the format: each line: \"虛擬碼步驟 // 解釋\". Use arrow for substeps? Use indentation.\n\nLet's craft.\n\nAlso need to start with Start comment and End comment.\n\nOk.\n\nNow produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize map ← {} // 建立一個空的映射，key 為目標數值，value 為索引列表  \n→ For each index i in nums  \n  → Append i to map[nums[i]] list // 把相同數值的索引聚集在同一個列表中  \n→ End Constructor // 初始化完成，已備妥所有索引分組  \n\npick(target) // 隨機選取 target 的索引  \n→ Retrieve list L = map[target] // 取得所有等於 target 的索引集合  \n→ Generate r = RandomInt(0, size(L) - 1) // 產生一個 0 到列表長度-1 的隨機整數  \n→ Return L[r] // 從列表中取出隨機索引並回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3, 2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[0,1],[1,0],[1,0],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[0, 1], [1, 0], [1, 0], [0, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立字典，鍵為每個單字的逆序，值為其索引\n        rev_map = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        # 判斷是否存在空字串\n        empty_idx = rev_map.get('', -1)\n\n        for i, word in enumerate(words):\n            # 針對每個分割位置\n            for j in range(len(word) + 1):\n                prefix, suffix = word[:j], word[j:]\n\n                # 情況 1：前綴是回文，尋找 suffix 的逆序\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in rev_map and rev_map[rev_suffix] != i:\n                        res.append([rev_map[rev_suffix], i])\n\n                # 情況 2：後綴是回文，且 j != len(word) 防止重複\n                if j != len(word) and suffix == suffix[::-1]:\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in rev_map and rev_map[rev_prefix] != i:\n                        res.append([i, rev_map[rev_prefix]])\n\n        # 空字串與其他回文字串的配對\n        if empty_idx != -1:\n            for j, word in enumerate(words):\n                if j != empty_idx and word == word[::-1]:\n                    res.append([empty_idx, j])\n                    res.append([j, empty_idx])\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從輸入字串中抽取字串列表\n    try:\n        start = data.index('[')\n        end = data.rindex(']') + 1\n        list_str = data[start:end]\n        words = ast.literal_eval(list_str)\n    except Exception:\n        # 若輸入格式不符，直接結束\n        sys.exit(0)\n\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Traditional Chinese, describing algorithm for palindrome pairs with linear runtime. Use data structures: for each word, store reverse, map of word to index. For each word, iterate over splits, check prefix or suffix palindrome and lookup reverse. Need to handle empty string case. Provide steps.\n\nWe need to output line by line with \"虛擬碼步驟 // 解釋\". Use arrows. Provide steps like Start, etc. Each step with virtual pseudocode.\n\nLet's craft algorithm steps.\n\n1. Start\n2. Create hash map reverseWordToIndex mapping reversed word to its index.\n3. Initialize result list.\n4. For each word and its index:\n   a. For each split position from 0 to len(word):\n      i. prefix = word[0:pos], suffix = word[pos:]\n      ii. If prefix is palindrome:\n           lookup reversed suffix; if exists and not same index, add pair (reverseIndex, index)\n      iii. If suffix is palindrome and pos != len(word):\n           lookup reversed prefix; if exists and not same index, add pair (index, reverseIndex)\n5. Handle empty string: if empty exists, for each word that's palindrome, add pair with empty index both ways.\n6. End\nReturn result.\n\nNeed to produce virtual code lines. Use arrows and decisions. Let's produce:\n\nStart\n→ Step 1: 建立空字典 reverseMap // 逆序字典\n→ Step 2: 將所有單字的逆序字串與索引存入 reverseMap // O(total length)\n→ Step 3: 建立空列表 result // 存儲對\n→ Decision: 若 words 包含空字串?\n    Yes → Step 4: 取得空字串索引 emptyIdx // 方便後續處理\n    No  → emptyIdx = -1\n→ Step 5: 對每個單字 word 及其索引 i 執行\n    → Step 5a: 針對每個分割點 pos 從 0 到 len(word)\n        → Decision: 前綴 prefix 是否為回文?\n            Yes → Step 5b: 取 reversed suffix revSuffix = reverse(word[pos:])\n                → Decision: revSuffix 是否存在於 reverseMap 且 reverseMap[revSuffix] != i?\n                    Yes → Step 5c: 加入 (reverseMap[revSuffix], i) 至 result\n        → Decision: 後綴 suffix 是否為回文且 pos != len(word)?\n            Yes → Step 5d: 取 reversed prefix revPrefix = reverse(word[:pos])\n                → Decision: revPrefix 是否存在於 reverseMap 且 reverseMap[revPrefix] != i?\n                    Yes → Step 5e: 加入 (i, reverseMap[revPrefix]) 至 result\n→ Decision: emptyIdx != -1 ?\n    Yes → Step 6: 對每個單字 word 及其索引 j 若 word != \"\" 且 word 為回文\n        → Step 6a: 加入 (emptyIdx, j) 及 (j, emptyIdx) 至 result\n→ End // 回傳 result\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Use arrows. We'll format each step accordingly. Ensure each step is a single line with arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 reverseMap // 用於儲存每個字串的逆序與其索引  \n→ Step 2: 將 words 中每個 word 及其索引 i 存入 reverseMap，鍵為 word 的逆序 // O(總字長)  \n→ Step 3: 建立空列表 result // 用於收集所有符合條件的對  \n→ Decision: words 是否包含空字串？ // 檢查是否需要額外處理空字串情況  \n Yes → Step 4: 取得空字串索引 emptyIdx // 方便後續快速查找  \n No  → emptyIdx = -1  \n→ Step 5: 對 words 中每個 word 與其索引 i 執行  \n → Step 5a: 針對所有分割位置 pos 從 0 到 word.length  \n  → Decision: 前綴 prefix = word[0:pos] 是否為回文？ // 檢查能否以後綴結合形成回文  \n   Yes → Step 5b: 取 reversed suffix revSuffix = reverse(word[pos:]) // 後綴的逆序  \n    → Decision: revSuffix 是否存在於 reverseMap 且 reverseMap[revSuffix] ≠ i？ // 確認能否配對且不是同一個單字  \n     Yes → Step 5c: 加入 (reverseMap[revSuffix], i) 到 result // 前後順序符合回文  \n  → Decision: 後綴 suffix = word[pos:] 是否為回文且 pos ≠ word.length？ // 避免重複且完整字串情況  \n   Yes → Step 5d: 取 reversed prefix revPrefix = reverse(word[0:pos]) // 前綴的逆序  \n    → Decision: revPrefix 是否存在於 reverseMap 且 reverseMap[revPrefix] ≠ i？  \n     Yes → Step 5e: 加入 (i, reverseMap[revPrefix]) 到 result // 這個順序也能形成回文  \n→ Decision: emptyIdx ≠ -1？ // 如果存在空字串，還需處理其與其他回文字串的配對  \n Yes → Step 6: 對 words 中每個 word 與索引 j 執行  \n   → Decision: word 不是空字串且 word 為回文？  \n    Yes → Step 6a: 加入 (emptyIdx, j) 及 (j, emptyIdx) 到 result // 空字串與任何回文字串皆可配對  \n→ End // 回傳 result，完成所有 palindrome pair 的搜尋。"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\ndef main():\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract list part from the input, which may be like \"nums = [1,2,3]\"\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums_str = match.group()\n    else:\n        nums_str = data\n\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        # If parsing fails, assume input is a comma-separated list without brackets\n        nums = [int(x.strip()) for x in data.split(',') if x.strip()]\n\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code for generating all permutations. Need to use Start, End, Decision, etc. Use arrow →, Yes →, No →. Each line: \"虛擬碼步驟 // 解釋\".\n\nSo produce algorithm: backtracking. Steps: Start, Step1: Define function permute(nums) // main entry. Step2: Initialize result list. Step3: Define backtrack(path, used). Step4: If path length == len(nums), add copy to result. Else iterate over indices, if not used, add, mark used, call backtrack, unmark, remove. Step5: Call backtrack([], [False]*len(nums)). Step6: Return result. End.\n\nWe need to show decisions: e.g., Decision: if path length equals length? Yes -> add, else -> iterate. For each iteration, Decision: if not used[i]? Yes -> choose.\n\nLet's format.\n\nProbably something like:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 permute(nums) // 主入口函式\n→ Step 2: 初始化結果列表 result = [] // 存儲所有排列\n→ Step 3: 定義遞迴函式 backtrack(path, used) // 回溯\n    → Decision: 如果 len(path) == len(nums)? // 是否已經形成完整排列\n        Yes → Step 4: 把 path 的複製加入 result // 收集完整排列\n        No → Decision: 迭代索引 i 從 0 到 len(nums)-1? // 遍歷所有元素\n            → Decision: if not used[i]? // 是否未被選用\n                Yes → Step 5: path.append(nums[i]) // 選取元素\n                → Step 6: used[i] = True // 標記已使用\n                → Step 7: backtrack(path, used) // 深入遞迴\n                → Step 8: path.pop() // 回溯移除元素\n                → Step 9: used[i] = False // 取消標記\n    ...\n→ Step 10: 呼叫 backtrack([], [False]*len(nums)) // 開始回溯\n→ Step 11: 回傳 result // 返回所有排列\nEnd // 程式執行結束\n\nBut must use arrow → for each step. Also need to show Decision block indentation. Use arrow and indentation.\n\nAlso each line should have \"虛擬碼步驟 // 解釋\". So include code and comment.\n\nLet's format carefully.\n\nWe can indent by adding spaces before arrow maybe.\n\nWe'll produce as plain text.\n\nEnsure each line: step arrow and comment. Use Decision:.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 permute(nums) // 主入口函式  \n→ Step 2: 初始化結果列表 result = [] // 用來存放所有排列  \n→ Step 3: 定義遞迴函式 backtrack(path, used) // 回溯核心  \n  → Decision: 如果 len(path) == len(nums)? // 判斷是否已形成完整排列  \n    Yes → Step 4: 把 path 的複製加入 result // 收集完整排列  \n    No → Step 5: 迭代索引 i 從 0 到 len(nums)-1 // 嘗試每個數字  \n     → Decision: 如果 not used[i]? // 是否尚未使用該數字  \n      Yes → Step 6: path.append(nums[i]) // 選取該數字  \n       → Step 7: used[i] = True // 標記為已使用  \n       → Step 8: backtrack(path, used) // 深入遞迴  \n       → Step 9: path.pop() // 回溯移除該數字  \n       → Step 10: used[i] = False // 取消標記  \n→ Step 11: 呼叫 backtrack([], [False] * len(nums)) // 開始回溯  \n→ Step 12: 回傳 result // 返回所有生成的排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport collections\nimport json\n\nclass RandomizedCollection:\n    def __init__(self):\n        # list to store values for O(1) random access\n        self.data = []\n        # map value -> set of indices in data list\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val):\n        # add value at the end\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        # return True if this is the first occurrence\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val):\n        if not self.idx_map[val]:\n            return False  # value not present\n        # remove an arbitrary index of val\n        remove_idx = self.idx_map[val].pop()\n        last_idx = len(self.data) - 1\n        last_val = self.data[last_idx]\n\n        # Move the last element into the spot of the removed element\n        self.data[remove_idx] = last_val\n        if remove_idx != last_idx:\n            # update index sets for the moved element\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n\n        # remove the last element from the list\n        self.data.pop()\n        return True\n\n    def getRandom(self):\n        # random choice from the current list\n        return random.choice(self.data)\n\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # input format: '[\"op1\", ...], [[arg1], [arg2], ...]'\n    ops, args_list = ast.literal_eval(raw_input)\n\n    # storage for the resulting outputs\n    results = []\n\n    # instance holder for RandomizedCollection\n    rc_instance = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"RandomizedCollection\":\n            rc_instance = RandomizedCollection()\n            results.append(None)  # constructor returns null\n        elif op == \"insert\":\n            res = rc_instance.insert(*args)\n            results.append(res)\n        elif op == \"remove\":\n            res = rc_instance.remove(*args)\n            results.append(res)\n        elif op == \"getRandom\":\n            res = rc_instance.getRandom()\n            results.append(res)\n        else:\n            # unknown operation, ignore or raise error\n            pass\n\n    # output in JSON format: None->null, True/False->true/false\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, not actual code. Steps of design: use array for values, hashmap from value to set of indices. Insert: push to array, add index to set; return true if new. Remove: if not present return false; otherwise get index, swap last element into removed spot, update sets; pop last; return true. getRandom: pick random index from array. Each step explained. Need to output line by line with \"虛擬碼步驟 // 解釋\". Use arrows. We'll structure as Start, then define data structures, then functions. Provide pseudo-code. Ensure each line with arrow. Use \"Start\" line. For each function, use Start/End. Probably we produce flow of operations within functions. Provide decisions. Let's craft.\n\nWe can break into sections: Initialize data structures; insert; remove; getRandom. Use decision arrows. Provide explanation each line. Let's do.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告 空陣列 list  // 用於存放所有元素，便於隨機取值  \n→ Step 2: 宣告 Map valToIdxSet，key 為元素值，value 為該值在 list 中所有索引的集合 // 方便 O(1) 位置查找與更新  \n\n// ---------- 1. RandomizedCollection() ----------\n→ Start RandomizedCollection() // 建構子  \n    → Step 3: 初始化 list 為空陣列  \n    → Step 4: 初始化 valToIdxSet 為空 Map  \n→ End RandomizedCollection() // 建構完成  \n\n// ---------- 2. insert(int val) ----------\n→ Start insert(val) // 插入元素  \n    → Decision: 如果 val 不在 valToIdxSet? // 判斷是否為第一次插入  \n        Yes → Step 5: 在 valToIdxSet 為 val 建立新空集合  \n    → Step 6: 將 val 加到 list 的末尾，記錄索引 newIndex = list.size()  \n    → Step 7: 把 newIndex 加入 valToIdxSet[val] 集合  \n    → Decision: val 原本是否存在? // 回傳是否為全新元素  \n        Yes → Step 8: Return false // 既有元素，插入成功但不是全新  \n        No  → Step 9: Return true  // 全新元素，插入成功且返回 true  \n→ End insert(val) // 插入結束  \n\n// ---------- 3. remove(int val) ----------\n→ Start remove(val) // 刪除元素  \n    → Decision: val 是否存在於 valToIdxSet?  \n        No  → Step 10: Return false // 沒有要刪除的元素  \n        Yes → Step 11: 從 valToIdxSet[val] 取任意一個索引 removeIdx  \n        → Step 12: 取得 list 最後一個元素 lastVal 與其索引 lastIdx = list.size()-1  \n        → Decision: removeIdx 不是最後索引?  \n            Yes → Step 13: 把 lastVal 放到 removeIdx，list[removeIdx] = lastVal  \n            → Step 14: 更新 valToIdxSet[lastVal]：  \n                → Step 15: 從其集合中移除 lastIdx  \n                → Step 16: 加入 removeIdx  \n            → No  → // removeIdx 已是最後索引，無需移動  \n        → Step 17: 從 valToIdxSet[val] 移除 removeIdx  \n        → Decision: valToIdxSet[val] 是否為空?  \n            Yes → Step 18: 刪除 val 這個 key 從 valToIdxSet // 清除空集合  \n        → Step 19: list.pop_back() // 移除最後一個元素  \n        → Step 20: Return true // 刪除成功  \n→ End remove(val) // 刪除結束  \n\n// ---------- 4. getRandom() ----------\n→ Start getRandom() // 隨機取值  \n    → Step 21: 生成隨機索引 randIdx ∈ [0, list.size()-1]  \n    → Step 22: Return list[randIdx] // 直接返回對應元素，符合頻率分佈  \n→ End getRandom() // 取值結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        # 小根堆存放較大的數字\n        self.large = []\n        # 大根堆（負值實作）存放較小的數字\n        self.small = []\n\n    def addNum(self, num: int) -> None:\n        # 將數字先加入小根堆\n        heapq.heappush(self.large, num)\n        # 若大根堆頂大於小根堆頂，交換兩者\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n        # 平衡兩堆大小\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 分離兩個 JSON 陣列\n    idx = data.find(']')\n    ops_str = data[:idx + 1]\n    params_str = data[idx + 2 :].strip()\n    ops = json.loads(ops_str)\n    params = json.loads(params_str)\n\n    result = []\n    mf = None\n    for op, p in zip(ops, params):\n        if op == \"MedianFinder\":\n            mf = MedianFinder()\n            result.append(None)\n        elif op == \"addNum\":\n            mf.addNum(p[0])\n            result.append(None)\n        elif op == \"findMedian\":\n            median = mf.findMedian()\n            result.append(median)\n        else:\n            # 若有其他操作可在此處擴充\n            result.append(None)\n\n    # 輸出結果，將 None 轉成 null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations for implementing MedianFinder class with addNum and findMedian. Use two heaps: max-heap for lower half, min-heap for upper half. Steps: initialize two heaps. addNum: push into appropriate heap then rebalance. findMedian: if heaps equal size, median = (max + min)/2 else median = top of larger heap.\n\nWe must output line by line virtual code steps, each line like \"Start // 程式開始執行\". Use arrows. Use Decision etc. Provide explanation.\n\nLet's outline.\n\nStart\n\n→ Step 1: 初始化最大堆 lower (負數) // 用來儲存小於等於中位數的數\n\n→ Step 2: 初始化最小堆 upper // 用來儲存大於等於中位數的數\n\n→ End? Actually we should provide class methods. We can structure like a pseudo-function for addNum and findMedian.\n\nWe need to create steps for addNum: Step: 接收 num.\n\nDecision: 如果 lower 為空或 num ≤ top of lower? -> push to lower else push to upper.\n\nAfter pushing, rebalance: Decision: if size(lower) > size(upper)+1? -> move top of lower to upper.\n\nDecision: if size(upper) > size(lower)+1? -> move top of upper to lower.\n\nReturn.\n\nFor findMedian: Decision: if sizes equal -> median = (top lower + top upper)/2. Else if lower bigger -> median = top lower. Else median = top upper.\n\nReturn.\n\nWe must produce virtual code lines with arrow formatting. Provide explanation.\n\nLet's write.\n\nStart\n\n→ Step 1: Initialize maxHeap lower // 儲存較小的一半\n\n→ Step 2: Initialize minHeap upper // 儲存較大的一半\n\nThen define addNum function:\n\n→ Step 3: Function addNum(num)\n\n→ Decision: 如果 lower 為空 或 num ≤ top(lower) ?\n\n    Yes → Step 4: lower.push(num) // 把數放進較小堆\n\n    No  → Step 5: upper.push(num) // 把數放進較大堆\n\n→ Step 6: // 重新平衡堆大小\n\n→ Decision: size(lower) > size(upper)+1 ?\n\n    Yes → Step 7: upper.push(lower.pop()) // 把較小堆頂移到較大堆\n\n    No → Decision: size(upper) > size(lower)+1 ?\n\n        Yes → Step 8: lower.push(upper.pop()) // 把較大堆頂移到較小堆\n\n        No → Step 9: // 堆已平衡，無需操作\n\n→ End of addNum\n\nDefine findMedian:\n\n→ Step 10: Function findMedian()\n\n→ Decision: size(lower) == size(upper) ?\n\n    Yes → Step 11: median = (lower.peek() + upper.peek()) / 2.0 // 兩堆相等，取平均\n\n    No → Decision: size(lower) > size(upper) ?\n\n        Yes → Step 12: median = lower.peek() // 左堆較大，取左頂\n\n        No  → Step 13: median = upper.peek() // 右堆較大，取右頂\n\n→ Step 14: return median\n\nEnd\n\nAdd End of class.\n\nLet's output accordingly. Ensure each line has \"虛擬碼步驟\" and \" // 解釋/說明\".\n\nMake sure each step uses arrow \"→\" at start of line? In example, Start has no arrow. But we can use \"Start //\". We'll produce as per format.\n\nWe should include End after the whole program? Might not be necessary but can include.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize maxHeap lower // 用來儲存小於等於中位數的一半  \n→ Step 2: Initialize minHeap upper // 用來儲存大於等於中位數的一半  \n\n→ Step 3: Function addNum(num) // 新增數字進資料結構  \n→ Decision: 如果 lower 為空 或 num ≤ top(lower) ? // 判斷該數應放進哪個堆  \n  Yes → Step 4: lower.push(num) // 把數放進左側最大堆  \n  No  → Step 5: upper.push(num) // 把數放進右側最小堆  \n\n→ Step 6: // 重新平衡兩個堆的大小  \n→ Decision: size(lower) > size(upper)+1 ? // 左堆太大？  \n  Yes → Step 7: upper.push(lower.pop()) // 從左堆頂移到右堆  \n  No → Decision: size(upper) > size(lower)+1 ? // 右堆太大？  \n    Yes → Step 8: lower.push(upper.pop()) // 從右堆頂移到左堆  \n    No  → Step 9: // 堆已平衡，無需操作  \n\n→ Step 10: End of addNum // 新增結束  \n\n→ Step 11: Function findMedian() // 取得目前的中位數  \n→ Decision: size(lower) == size(upper) ? // 堆大小相等？  \n  Yes → Step 12: median = (lower.peek() + upper.peek()) / 2.0 // 取兩個堆頂平均  \n  No  → Decision: size(lower) > size(upper) ? // 左堆較大？  \n    Yes → Step 13: median = lower.peek() // 直接取左堆頂  \n    No  → Step 14: median = upper.peek() // 直接取右堆頂  \n\n→ Step 15: return median // 回傳中位數  \n→ End // 程式執行結束"
    },
    {
      "title": "Substring with Concatenation of All Words",
      "source_file": "Leetcode/leetcode30.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "actual_output_or_error": "Error parsing input: Failed to parse input: invalid syntax. Maybe you meant '==' or ':=' instead of '='? (<string>, line 1)"
        },
        {
          "example_index": 1,
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Error parsing input: Failed to parse input: invalid syntax. Maybe you meant '==' or ':=' instead of '='? (<string>, line 1)"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "actual_output_or_error": "Error parsing input: Failed to parse input: invalid syntax. Maybe you meant '==' or ':=' instead of '='? (<string>, line 1)"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter, defaultdict\n\nclass Solution:\n    def findSubstring(self, s: str, words: list[str]) -> list[int]:\n        \"\"\"\n        Find all starting indices of concatenated substrings in s that consist\n        of each word in words exactly once and in any order.\n        \"\"\"\n        if not words:\n            return []\n\n        word_len = len(words[0])\n        num_words = len(words)\n        concat_len = word_len * num_words\n        n = len(s)\n\n        # If the string is too short to contain any concatenation.\n        if n < concat_len:\n            return []\n\n        # Frequency map of the words to match.\n        target_count = Counter(words)\n\n        result = []\n\n        # We will check n-word_len+1 starting positions, but we can\n        # optimize by sliding window of size concat_len with step word_len.\n        for offset in range(word_len):\n            left = offset\n            right = offset\n            window_count = defaultdict(int)\n            count = 0  # number of words matched in current window\n\n            while right + word_len <= n:\n                word = s[right:right + word_len]\n                right += word_len\n\n                if word in target_count:\n                    window_count[word] += 1\n                    count += 1\n\n                    # If the word appears too many times, shrink window from left\n                    while window_count[word] > target_count[word]:\n                        left_word = s[left:left + word_len]\n                        window_count[left_word] -= 1\n                        left += word_len\n                        count -= 1\n\n                    # When window size equals number of words, we found a match\n                    if count == num_words:\n                        result.append(left)\n                else:\n                    # Reset window if a non‑matching word is encountered\n                    window_count.clear()\n                    count = 0\n                    left = right\n\n        return result\n\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form:\n        s = \"some string\", words = [\"w1\",\"w2\",...]\n    or multi‑line variants. Returns tuple (s, words).\n    \"\"\"\n    # Remove newlines and surrounding whitespace\n    data = data.strip()\n    if not data:\n        raise ValueError(\"No input data provided\")\n\n    # Wrap into a dict literal for eval\n    try:\n        parsed = eval(f'{{{data}}}', {}, {})\n    except Exception as e:\n        raise ValueError(f\"Failed to parse input: {e}\")\n\n    s = parsed.get('s')\n    words = parsed.get('words')\n    if s is None or words is None:\n        raise ValueError(\"Input must contain 's' and 'words'\")\n\n    return s, words\n\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    try:\n        s, words = parse_input(raw_input)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    sol = Solution()\n    indices = sol.findSubstring(s, words)\n    print(indices)",
      "virtual_code": "Thinking...\nWe need produce virtual code lines. The problem: find starting indices of concatenated substrings of words in s. All words same length. Classic LeetCode problem \"Substring with Concatenation of All Words\".\n\nWe need to produce virtual code steps line by line, with explanation. Use arrow notation.\n\nWe should outline algorithm: Use sliding window with steps of word length, maintain count map of words, sliding window size = totalWords*wordLen. For each starting index i from 0 to wordLen-1, slide. But for brevity, we can give high-level steps.\n\nWe need to not output actual code. Just virtual code with explanation.\n\nLet's produce:\n\nStart\n→ Step 1: 定義 wordLen = words[0].length // 獲取每個單詞長度\n→ Step 2: 定義 totalLen = words.length * wordLen // 整個連接字串長度\n→ Step 3: 準備一個哈希表 targetCount 來存儲每個單詞的目標次數 // words 的頻率表\n    For each word in words:\n        Increment targetCount[word]\n→ Decision: 如果 s.length < totalLen? // s 不足以容納任何連接子字串\n    Yes → End // 返回空結果\n    No  →\n→ Step 4: 準備結果列表 result\n→ Step 5: 對 offset from 0 to wordLen-1:\n    → Step 6: 建立一個滑動窗口的哈希表 windowCount\n    → Step 7: 設置左指標 left = offset，right = offset\n    → Step 8: 記錄目前已處理的單詞數 count = 0\n    → While right + wordLen <= s.length:\n        → Step 9: currentWord = s.substring(right, right+wordLen)\n        → Step 10: right += wordLen\n        → Step 11: 如果 currentWord 在 targetCount:\n            → Step 12: windowCount[currentWord] += 1\n            → Step 13: count += 1\n            → While windowCount[currentWord] > targetCount[currentWord]:\n                → Step 14: leftWord = s.substring(left, left+wordLen)\n                → Step 15: windowCount[leftWord] -= 1\n                → Step 16: left += wordLen\n                → Step 17: count -= 1\n        → Decision: 如果 count == words.length? // 視窗正好包含所有單詞\n            Yes → Step 18: Add left to result // 位置符合\n            No  → // 什麼也不做\n→ End // 返回 result\n\nWe need to include explanations after each line.\n\nMake sure formatting: each line \"虛擬碼步驟 // 解釋\".\n\nAdd arrow \"→\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 wordLen = words[0].length // 取得每個單詞的長度\n→ Step 2: 定義 totalLen = words.length * wordLen // 整個連接子字串的總長度\n→ Step 3: 準備一個哈希表 targetCount 來存儲每個單詞的目標次數 // words 的頻率表\n    → Decision: For each word in words? // 建立頻率表\n        Yes → Step 3a: targetCount[word] += 1 // 計算每個單詞的出現次數\n→ Decision: 如果 s.length < totalLen? // s 太短，無法包含任何合法子字串\n    Yes → End // 直接結束，返回空結果\n    No  →\n→ Step 4: 準備結果列表 result = [] // 存放所有合法起始索引\n→ Step 5: 對 offset 從 0 到 wordLen-1 進行迴圈 // 以單詞長度為步長檢查所有可能的起點\n    → Step 6: 建立滑動窗口的哈希表 windowCount = {} // 記錄當前窗口中單詞的頻率\n    → Step 7: 設置左指標 left = offset，右指標 right = offset // 窗口起始位置\n    → Step 8: 記錄已處理單詞數 count = 0 // 方便判斷窗口是否已滿\n    → While right + wordLen <= s.length: // 右指標仍可擴展窗口\n        → Step 9: currentWord = s.substring(right, right + wordLen) // 取出右指標所在的單詞\n        → Step 10: right += wordLen // 右指標向前滑動單詞長度\n        → Decision: 如果 currentWord 在 targetCount? // 只處理有效單詞\n            Yes →\n                → Step 11: windowCount[currentWord] = (windowCount[currentWord] or 0) + 1 // 更新窗口頻率\n                → Step 12: count += 1 // 已加入一個有效單詞\n                → While windowCount[currentWord] > targetCount[currentWord]: // 超過目標頻率，縮小窗口\n                    → Step 13: leftWord = s.substring(left, left + wordLen) // 取左指標單詞\n                    → Step 14: windowCount[leftWord] -= 1 // 減少左指標單詞頻率\n                    → Step 15: left += wordLen // 左指標向前滑動單詞長度\n                    → Step 16: count -= 1 // 已移除一個有效單詞\n            No → // 非目標單詞，忽略\n        → Decision: 如果 count == words.length? // 窗口已包含所有單詞\n            Yes → Step 17: result.append(left) // 將左指標加入結果列表\n            No  → // 窗口不滿足，繼續擴展\n→ End // 程式執行結束，返回 result list of starting indices"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '13'\nGot (Norm):      'Failedtoparsematrix'\n--- (Raw) ---\nRaw Expected: '13'\nRaw Got:      'Failed to parse matrix'"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-5'\nGot (Norm):      'Failedtoparsematrix'\n--- (Raw) ---\nRaw Expected: '-5'\nRaw Got:      'Failed to parse matrix'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom typing import List\n\nclass Solution:\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\n        \"\"\"Return the k-th smallest element in a sorted matrix using binary search.\"\"\"\n        n = len(matrix)\n        low, high = matrix[0][0], matrix[n - 1][n - 1]\n\n        # Count how many elements are <= mid\n        def countLessEqual(mid: int) -> int:\n            count = 0\n            for i in range(n):\n                j = n - 1\n                while j >= 0 and matrix[i][j] > mid:\n                    j -= 1\n                count += j + 1\n            return count\n\n        # Binary search on the value range\n        while low < high:\n            mid = low + (high - low) // 2\n            if countLessEqual(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        return low\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    # Extract matrix and k from input string\n    matrix_match = re.search(r'matrix\\s*=\\s*(\\[[^\\]]*\\])', data, re.S)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n\n    if not matrix_match or not k_match:\n        print(\"Invalid input format\")\n        return\n\n    # Evaluate the matrix safely\n    matrix_str = matrix_match.group(1)\n    try:\n        matrix = ast.literal_eval(matrix_str)\n    except Exception:\n        print(\"Failed to parse matrix\")\n        return\n\n    k = int(k_match.group(1))\n\n    # Validate matrix dimensions\n    if not matrix or not all(len(row) == len(matrix) for row in matrix):\n        print(\"Matrix must be n x n\")\n        return\n\n    solution = Solution()\n    result = solution.kthSmallest(matrix, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: given sorted matrix n x n, find k-th smallest element. Use binary search on value range with count <= mid. Complexity O(n log(range)). Or use min-heap O(k log n). Use memory O(n). Provide virtual code line by line with explanations. Let's produce steps:\n\nStart\n→ Step: Read n, k, matrix\n→ Step: Set low = matrix[0][0], high = matrix[n-1][n-1]\n→ Decision: While low < high\n    → Step: mid = low + (high - low)/2\n    → Step: count = countLessEqual(matrix, mid) // count elements <= mid\n    → Decision: if count < k\n        Yes → low = mid + 1\n        No → high = mid\n→ Step: Result = low\n→ Step: Output Result\nEnd\n\nNeed also define countLessEqual: traverse each row binary search. Or two pointers.\n\nWe'll provide virtual code with each line and comment. Use arrows.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 讀取矩陣大小 n、目標 k 及整個 n x n 排序矩陣 // 從輸入取得所有資料  \n→ Step: low = matrix[0][0] // 設定搜尋範圍最小值為矩陣左上角元素  \n→ Step: high = matrix[n-1][n-1] // 設定搜尋範圍最大值為矩陣右下角元素  \n\n→ Decision: 只要 low < high, 繼續搜尋 // 進行二分搜尋直到範圍縮小至單一值  \n    → Step: mid = low + (high - low) / 2 // 取中間值作為判斷基準  \n    → Step: count = CountLessEqual(matrix, mid) // 計算小於等於 mid 的元素個數  \n    → Decision: 若 count < k? // 若小於 k，表示第 k 小的元素必在更大值區間  \n        Yes → low = mid + 1 // 將 lower bound 上移至 mid+1  \n        No  → high = mid // 否則第 k 小的元素在 mid 及以下，將 upper bound 設為 mid  \n\n→ Step: Result = low // 搜尋結束時 low 即為第 k 小元素的值  \n→ Step: 輸出 Result // 回傳答案  \n\nEnd // 程式執行結束  \n\n// ---------- CountLessEqual 函式 (在虛擬碼中作為輔助子程式) ----------  \nStart // 進入 CountLessEqual 函式  \n→ Step: count = 0  \n→ Step: i = 0  \n→ Decision: 只要 i < n, 繼續迭代 // 逐行計算  \n    → Step: j = n - 1 // 從最右側開始尋找第一個 > mid 的位置  \n    → Decision: 只要 j >= 0 且 matrix[i][j] > mid, 迴圈向左移動  \n        Yes → j = j - 1  \n        No →  \n    → Step: count = count + (j + 1) // 在此行中，j+1 個元素 <= mid  \n    → Step: i = i + 1 // 進入下一行  \n→ Step: Return count // 回傳總計數  \nEnd // CountLessEqual 函式結束"
    },
    {
      "title": "Delete Operation for Two Strings",
      "source_file": "Leetcode/leetcode583.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "word1 = \"sea\", word2 = \"eat\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '6'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '6'"
        },
        {
          "example_index": 1,
          "input": "word1 = \"leetcode\", word2 = \"etco\"",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '6'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '6'"
        }
      ],
      "generated_code": "import sys\n\ndef min_distance(word1: str, word2: str) -> int:\n    \"\"\"Return the minimum number of deletions required to make word1 and word2 equal.\"\"\"\n    m, n = len(word1), len(word2)\n    # dp[i][j] = min deletions to transform word1[:i] into word2[:j]\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Base cases: delete all characters to match empty string\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n\n    return dp[m][n]\n\n\ndef main() -> None:\n    # Read all input from stdin\n    content = sys.stdin.read().strip()\n    if not content:\n        return\n\n    lines = content.splitlines()\n    if len(lines) >= 2:\n        # Assume each word is on its own line\n        word1, word2 = lines[0].strip(), lines[1].strip()\n    else:\n        # Otherwise split by whitespace\n        parts = content.split()\n        if len(parts) >= 2:\n            word1, word2 = parts[0], parts[1]\n        else:\n            # Only one word provided – treat the other as empty\n            word1, word2 = parts[0], \"\"\n\n    result = min_distance(word1, word2)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: minimum deletions to make two strings equal. Classic solution: find longest common subsequence (LCS), then deletions = len(word1)+len(word2)-2*LCS. Need DP algorithm.\n\nWe need to produce virtual code lines with explanation, using arrows. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" before each step. Start, End, Decision, loops.\n\nWe must produce structured step-by-step, not actual code. Use pseudocode but no real code.\n\nWe can outline:\n\nStart\n→ Step 1: 輸入 word1, word2\n→ Decision: If either string empty? (Could skip)\nBut typical DP: Create 2D array dp of size (len1+1) x (len2+1) initialized to 0\n→ Loop i from 1 to len1\n   → Loop j from 1 to len2\n      → Decision: if word1[i-1]==word2[j-1]?\n          Yes → dp[i][j] = dp[i-1][j-1] + 1\n          No  → dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n→ After loops, lcs = dp[len1][len2]\n→ Step: deletions = len1 + len2 - 2*lcs\n→ Output deletions\nEnd\n\nAlso need decision for loops? They can be shown as nested loops, maybe as loops rather than decision. But we can show loops as \"→ Loop i ...\" etc.\n\nEnsure each line ends with // 解釋.\n\nUse virtual code arrow for steps. Use \"→\" before each step. For loops, we can use \"→ Loop i ...\" with explanation.\n\nWe must not output actual code, only steps.\n\nLet's produce.\n\nWe need to be mindful of formatting: \"虛擬碼步驟 // 解釋\".\n\nWe can produce:\n\nStart // 程式開始執行\n→ Step 1: 取得 word1, word2 // 從輸入取得兩個字串\n→ Step 2: 取得 len1 = length of word1, len2 = length of word2 // 計算字串長度\n→ Step 3: 初始化 dp[0..len1][0..len2] 為 0 // 建立長度表，用於 LCS 計算\n→ Loop i = 1 to len1\n   → Loop j = 1 to len2\n      → Decision: 如果 word1[i-1] == word2[j-1]?\n          Yes → dp[i][j] = dp[i-1][j-1] + 1 // 字元相同，擴充 LCS\n          No  → dp[i][j] = max(dp[i-1][j], dp[i][j-1]) // 取前一步最大\n→ Step 4: lcs = dp[len1][len2] // 取完整長度表最後值為 LCS\n→ Step 5: deletions = len1 + len2 - 2 * lcs // 計算最小刪除步驟\n→ Step 6: 輸出 deletions // 顯示結果\nEnd // 程式執行結束\n\nMake sure each line includes arrow or Start/End.\n\nWe must avoid actual code syntax. Use words. Use Chinese explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 word1, word2 // 從輸入取得兩個字串  \n→ Step 2: 取得 len1 = length of word1, len2 = length of word2 // 計算兩字串長度  \n→ Step 3: 初始化 dp[0..len1][0..len2] 為 0 // 建立用於 LCS 計算的長度表  \n→ Loop i = 1 to len1 // 逐行遍歷 word1  \n  → Loop j = 1 to len2 // 逐列遍歷 word2  \n    → Decision: 如果 word1[i-1] == word2[j-1] ? // 比較當前字元是否相同  \n     Yes → dp[i][j] = dp[i-1][j-1] + 1 // 相同則 LCS 加 1  \n     No  → dp[i][j] = max(dp[i-1][j], dp[i][j-1]) // 不同則取前一步最大值  \n→ Step 4: lcs = dp[len1][len2] // 取得整個字串的 LCS 長度  \n→ Step 5: deletions = len1 + len2 - 2 * lcs // 計算最小刪除步驟  \n→ Step 6: 輸出 deletions // 顯示結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpn145xko4.py\", line 85, in <module>\n    main()\n  File \"/tmp/tmpn145xko4.py\", line 67, in main\n    obj = objects[var_name]\n          ~~~~~~~^^^^^^^^^^\nKeyError: '\\\\nrangeModule'"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []  # store non-overlapping half-open intervals [l, r)\n\n    def addRange(self, left, right):\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:  # current interval is completely before new interval\n                new_ranges.append([l, r])\n            elif right < l:  # current interval is completely after new interval\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:  # overlap, merge\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left, right):\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left, right):\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:  # no overlap\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main():\n    data = sys.stdin.read()\n    # Normalize newlines to spaces, then split by semicolons\n    statements = [stmt.strip() for stmt in data.replace('\\n', ';').split(';') if stmt.strip()]\n    objects = {}\n    outputs = []\n\n    for stmt in statements:\n        # Constructor: \"RangeModule var = new RangeModule()\"\n        if 'new RangeModule' in stmt:\n            left = stmt.split('=')[0].strip()\n            var_name = left.split()[-1]\n            objects[var_name] = RangeModule()\n            outputs.append('null')\n            continue\n\n        # Method call: \"var.method(args)\"\n        if '.' in stmt:\n            var_name, rest = stmt.split('.', 1)\n            method_part = rest.strip()\n            method_name = method_part.split('(')[0]\n            args_str = method_part.split('(')[1].split(')')[0]\n            args = [int(x.strip()) for x in args_str.split(',') if x.strip()]\n            obj = objects[var_name]\n            if method_name == 'addRange':\n                obj.addRange(*args)\n                outputs.append('null')\n            elif method_name == 'removeRange':\n                obj.removeRange(*args)\n                outputs.append('null')\n            elif method_name == 'queryRange':\n                result = obj.queryRange(*args)\n                outputs.append('true' if result else 'false')\n            else:\n                # Unknown method, skip\n                pass\n\n    # Print result list\n    print('[' + ', '.join(outputs) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments. It's a design of RangeModule. Likely using interval tree or sorted list. We'll produce steps for class methods: initialization, addRange, queryRange, removeRange. The virtual code may include steps for these methods. Use decision steps.\n\nWe need to output line by line. Each line: \"虛擬碼步驟 // 解釋\". Use arrow and Decision, Start, End. Provide a simple algorithm: maintain a sorted list of non-overlapping intervals. For addRange: merge intervals. For queryRange: check coverage. For removeRange: split intervals.\n\nWe need to generate virtual code for entire class? The user wants virtual code that solves the problem, step-by-step. We can provide high-level algorithm for each method.\n\nWe can structure like:\n\nStart\n\n→ Step: Initialize intervals list // empty list\n\n→ Method: addRange(left, right)\n\n    → Decision: find insertion index for left\n\n    ...\n\nBetter to produce each method as separate block.\n\nMake sure each line includes explanation.\n\nLet's produce:\n\nStart // program start\n→ Step: Create empty list 'intervals' // stores non-overlapping intervals\nEnd // end initialization\n\nThen methods:\n\nStart // addRange method\n→ Step: left = input left\n→ Step: right = input right\n→ Decision: if right <= left? // invalid\n    Yes → Step: return // nothing to add\n    No → Continue\n→ Step: Find index i such that intervals[i].right >= left // first overlapping\n→ Step: Find index j such that intervals[j].left <= right // last overlapping\n→ Decision: if i > j? // no overlap\n    Yes → Step: Insert [left,right] at position i\n    No → Step: Merge new interval with intervals[i..j]\n        → Step: newLeft = min(left, intervals[i].left)\n        → Step: newRight = max(right, intervals[j].right)\n        → Step: Replace intervals[i..j] with [newLeft,newRight]\nEnd // end addRange\n\nSimilarly queryRange:\n\nStart // queryRange\n→ Decision: if left >= right? // empty interval\n    Yes → Return true\n    No → Continue\n→ Step: Find index i such that intervals[i].right > left\n→ Decision: if i == 0? // no interval covers left\n    Yes → Return false\n    No → Step: if intervals[i-1].right < left? // left not covered\n        → Return false\n→ Step: For k from i to end while intervals[k].left <= right\n    → Decision: if intervals[k].right < right? // gap\n        → Return false\n→ Return true\nEnd\n\nremoveRange:\n\nStart // removeRange\n→ Decision: if left >= right? // nothing\n    Yes → Return\n    No → Continue\n→ Step: Find index i such that intervals[i].right > left\n→ Step: Find index j such that intervals[j].left < right\n→ Decision: if i > j? // no overlap\n    Yes → Return\n    No →\n        → Step: if intervals[i].left < left:\n            → Step: Add [intervals[i].left, left] // keep left part\n        → Step: if intervals[j].right > right:\n            → Step: Add [right, intervals[j].right] // keep right part\n        → Step: Remove intervals[i..j]\nEnd\n\nBut need to use arrow notation as per spec: \"→ Step 1: ...\". Each line should start with arrow? In example, they use \"Start\" not arrow. Let's follow pattern: \"Start // ...\", then \"→ Step ...\". For decisions: \"→ Decision: ...\" and then indent lines? They used indentation: Yes → ... No → ... The format is flexible.\n\nWe'll produce each line as separate line, no nested indentation but we can include indentation spaces. Example: \"    Yes → Step 3: ...\" That's okay.\n\nMake sure to include comments after space and //.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始，初始化資料結構  \n→ Step: intervals ← empty list // 用於儲存非重疊的半開區間  \n\n---  \nStart // addRange 方法開始  \n→ Step: input left, right // 取得要加入的區間  \n→ Decision: if right ≤ left? // 檢查區間是否合法  \n    Yes → Step: return // 若非法則直接返回  \n    No  → Continue // 否則繼續  \n→ Step: i ← first index where intervals[i].right ≥ left // 找到可能重疊的起始區間  \n→ Step: j ← last index where intervals[j].left ≤ right // 找到可能重疊的結束區間  \n→ Decision: if i > j? // 沒有任何重疊  \n    Yes → Step: insert [left, right] at position i // 直接插入新區間  \n    No  → Step: newLeft ← min(left, intervals[i].left) // 計算合併後的新左端點  \n        → Step: newRight ← max(right, intervals[j].right) // 計算合併後的新右端點  \n        → Step: replace intervals[i…j] with [newLeft, newRight] // 用合併後的區間取代原有區間  \nEnd // addRange 方法結束  \n\n---  \nStart // queryRange 方法開始  \n→ Step: input left, right // 取得要查詢的區間  \n→ Decision: if left ≥ right? // 空區間，始終為真  \n    Yes → Step: return true  \n    No  → Continue // 否則繼續  \n→ Step: i ← first index where intervals[i].right > left // 找到可能覆蓋 left 的區間  \n→ Decision: if i == 0? // 沒有區間覆蓋 left  \n    Yes → Step: return false  \n    No  → Step: if intervals[i-1].right < left? // left 仍未被覆蓋  \n        → Step: return false  \n→ Step: k ← i // 從找到的區間開始檢查  \n→ Step: while k < len(intervals) and intervals[k].left ≤ right  \n    → Decision: if intervals[k].right < right? // 發現缺口  \n        → Step: return false  \n    → Step: k ← k + 1 // 進一步檢查下一個區間  \n→ Step: return true // 全部區間均被覆蓋  \nEnd // queryRange 方法結束  \n\n---  \nStart // removeRange 方法開始  \n→ Step: input left, right // 取得要移除的區間  \n→ Decision: if left ≥ right? // 空區間，無須處理  \n    Yes → Step: return  \n    No  → Continue  \n→ Step: i ← first index where intervals[i].right > left // 可能被移除的起始區間  \n→ Step: j ← last index where intervals[j].left < right // 可能被移除的結束區間  \n→ Decision: if i > j? // 沒有區間被覆蓋  \n    Yes → Step: return  \n    No  → Step: // 需要調整被覆蓋區間  \n        → Step: if intervals[i].left < left? // 左側保留部分  \n            → Step: add [intervals[i].left, left] to intervals  \n        → Step: if intervals[j].right > right? // 右側保留部分  \n            → Step: add [right, intervals[j].right] to intervals  \n        → Step: remove intervals[i…j] // 刪除被覆蓋的區間  \nEnd // removeRange 方法結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5cv16q_h.py\", line 106, in <module>\n    main()\n  File \"/tmp/tmp5cv16q_h.py\", line 72, in main\n    commands = ast.literal_eval(data[0])\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n                                                                                                                                                ^\nSyntaxError: unexpected character after line continuation character"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        \"\"\"初始化雙端隊列，容量為 k\"\"\"\n        self.k = k\n        self.buf = [0] * k  # 用於存儲元素的循環緩衝區\n        self.head = 0       # 指向前端元素的索引\n        self.count = 0      # 當前元素個數\n\n    def insertFront(self, value: int) -> bool:\n        \"\"\"在前端插入元素\"\"\"\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        \"\"\"在後端插入元素\"\"\"\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        \"\"\"刪除前端元素\"\"\"\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        \"\"\"刪除後端元素\"\"\"\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        \"\"\"取得前端元素值\"\"\"\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        \"\"\"取得後端元素值\"\"\"\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        \"\"\"判斷是否為空\"\"\"\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        \"\"\"判斷是否已滿\"\"\"\n        return self.count == self.k\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n\n    result = []\n    obj = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MyCircularDeque\":\n            obj = MyCircularDeque(args[0])\n            result.append(None)  # constructor returns null\n        elif cmd == \"insertFront\":\n            result.append(obj.insertFront(args[0]))\n        elif cmd == \"insertLast\":\n            result.append(obj.insertLast(args[0]))\n        elif cmd == \"deleteFront\":\n            result.append(obj.deleteFront())\n        elif cmd == \"deleteLast\":\n            result.append(obj.deleteLast())\n        elif cmd == \"getFront\":\n            result.append(obj.getFront())\n        elif cmd == \"getRear\":\n            result.append(obj.getRear())\n        elif cmd == \"isEmpty\":\n            result.append(obj.isEmpty())\n        elif cmd == \"isFull\":\n            result.append(obj.isFull())\n        else:\n            # 不合法命令，跳過\n            result.append(None)\n\n    # 使用 json.dumps 以得到符合範例的輸出格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing a circular deque, step by step, with explanations. Not actual code, just pseudocode lines.\n\nWe need to adhere to the format: each line has virtual code step and // explanation. Use arrows, Start, End, Decision. Provide logic for initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Since it's virtual, we don't need actual array operations but can describe logically.\n\nLet's design. We'll use variables: array items[], int front, int rear, int size, int capacity.\n\nInitialize: set capacity = k; front = 0; rear = -1; size = 0; array of size k.\n\nInsertFront: if isFull() return false; front = (front - 1 + capacity) % capacity; items[front] = value; size++; return true.\n\nInsertLast: if isFull() return false; rear = (rear + 1) % capacity; items[rear] = value; size++; return true.\n\nDeleteFront: if isEmpty() return false; front = (front + 1) % capacity; size--; return true.\n\nDeleteLast: if isEmpty() return false; rear = (rear - 1 + capacity) % capacity; size--; return true.\n\nGetFront: if isEmpty() return -1; return items[front].\n\nGetRear: if isEmpty() return -1; return items[rear].\n\nisEmpty: return size == 0.\n\nisFull: return size == capacity.\n\nWe need to express each step line by line.\n\nAlso we might need to handle decision structures for isFull, isEmpty etc.\n\nLet's produce pseudocode:\n\nStart\n→ Step 1: 定義 MyCircularDeque 類 // 宣告類別\n→ Step 2: 定義成員變數 items[capacity], front, rear, size, capacity // 儲存數據與指標\n→ Step 3: 定義建構子 MyCircularDeque(int k) // 初始化\n    → Step 3.1: Set capacity = k // 設定最大容量\n    → Step 3.2: Allocate items array of size k // 分配儲存空間\n    → Step 3.3: Set front = 0 // 指向前端\n    → Step 3.4: Set rear = -1 // 指向尾端\n    → Step 3.5: Set size = 0 // 空度\n\n→ Step 4: 定義方法 insertFront(val) // 往前插入\n    → Decision: 如果 isFull()? // 檢查是否滿\n        Yes → Return false // 插入失敗\n        No  → Step 4.1: front = (front - 1 + capacity) % capacity // 往前移動指標\n              Step 4.2: items[front] = val // 儲存數值\n              Step 4.3: size++ // 更新大小\n              Step 4.4: Return true // 成功\n\n... and similar for others.\n\nWe need to use \"Yes →\", \"No →\" format. Also \"Decision:\".\n\nAlso for each function we can start with \"Step: ...\".\n\nWe might also need to mention variable 'value' param.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCircularDeque 類 // 建立類別框架  \n→ Step 2: 定義成員變數 items[capacity], front, rear, size, capacity // 儲存資料與指標  \n→ Step 3: 定義建構子 MyCircularDeque(int k) // 初始化  \n  → Step 3.1: Set capacity = k // 設定最大容量  \n  → Step 3.2: Allocate items array of size k // 建立固定長度陣列  \n  → Step 3.3: Set front = 0 // 前端指標指向第一個位置  \n  → Step 3.4: Set rear = -1 // 後端指標先設為-1，代表空  \n  → Step 3.5: Set size = 0 // 初始時資料量為0  \n\n→ Step 4: 定義方法 insertFront(val) // 往前端插入  \n  → Decision: 如果 isFull()? // 檢查是否已滿  \n    Yes → Return false // 插入失敗  \n    No  → Step 4.1: front = (front - 1 + capacity) % capacity // 往前移動指標  \n     Step 4.2: items[front] = val // 存入資料  \n     Step 4.3: size++ // 更新資料量  \n     Step 4.4: Return true // 成功  \n\n→ Step 5: 定義方法 insertLast(val) // 往後端插入  \n  → Decision: 如果 isFull()? // 檢查是否已滿  \n    Yes → Return false // 插入失敗  \n    No  → Step 5.1: rear = (rear + 1) % capacity // 往後移動指標  \n     Step 5.2: items[rear] = val // 存入資料  \n     Step 5.3: size++ // 更新資料量  \n     Step 5.4: Return true // 成功  \n\n→ Step 6: 定義方法 deleteFront() // 刪除前端  \n  → Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Return false // 刪除失敗  \n    No  → Step 6.1: front = (front + 1) % capacity // 往後移動指標  \n     Step 6.2: size-- // 更新資料量  \n     Step 6.3: Return true // 成功  \n\n→ Step 7: 定義方法 deleteLast() // 刪除後端  \n  → Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Return false // 刪除失敗  \n    No  → Step 7.1: rear = (rear - 1 + capacity) % capacity // 往前移動指標  \n     Step 7.2: size-- // 更新資料量  \n     Step 7.3: Return true // 成功  \n\n→ Step 8: 定義方法 getFront() // 取得前端資料  \n  → Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Return -1 // 空時返回-1  \n    No  → Step 8.1: Return items[front] // 回傳前端值  \n\n→ Step 9: 定義方法 getRear() // 取得後端資料  \n  → Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Return -1 // 空時返回-1  \n    No  → Step 9.1: Return items[rear] // 回傳後端值  \n\n→ Step 10: 定義方法 isEmpty() // 檢查是否為空  \n  → Step 10.1: Return size == 0 // 若資料量為0則為空  \n\n→ Step 11: 定義方法 isFull() // 檢查是否已滿  \n  → Step 11.1: Return size == capacity // 若資料量等於容量則已滿  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "\"1+1i\", \"1+1i\"",
          "expected_output": "\"0+2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2e6gntgv.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmp2e6gntgv.py\", line 36, in main\n    result = solver.multiply(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2e6gntgv.py\", line 11, in multiply\n    a_real, a_imag = self.complexNumberMultiply(num1)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: Solution.complexNumberMultiply() missing 1 required positional argument: 'b'"
        },
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbco2tck5.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmpbco2tck5.py\", line 36, in main\n    result = solver.multiply(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbco2tck5.py\", line 11, in multiply\n    a_real, a_imag = self.complexNumberMultiply(num1)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: Solution.complexNumberMultiply() missing 1 required positional argument: 'b'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        \"\"\"Parse a complex number string and return its real and imaginary parts.\"\"\"\n        real_part, imag_part = a.split('+')\n        return int(real_part), int(imag_part[:-1])  # remove trailing 'i'\n\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"Multiply two complex numbers represented as strings.\"\"\"\n        a_real, a_imag = self.complexNumberMultiply(num1)\n        b_real, b_imag = self.complexNumberMultiply(num2)\n\n        real = a_real * b_real - a_imag * b_imag\n        imag = a_real * b_imag + a_imag * b_real\n\n        return f\"{real}+{imag}i\"\n\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split input into two parts separated by comma\n    parts = data.split(',')\n    if len(parts) != 2:\n        raise ValueError(\"Input must contain two complex numbers separated by a comma\")\n\n    # Strip whitespace and surrounding quotes from each part\n    num1 = parts[0].strip().strip('\"')\n    num2 = parts[1].strip().strip('\"')\n\n    solver = Solution()\n    result = solver.multiply(num1, num2)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for multiplying two complex numbers represented as strings like \"a+bi\". Steps: parse string, extract real and imag integers, compute product: (a+bi)*(c+di) = (ac - bd) + (ad + bc)i. Then format result string.\n\nWe need to produce virtual code lines, each line with explanation. Use arrows, decision, etc.\n\nWe must not output actual code, just pseudo steps. Format like the example. Use Start, End, Decision etc. We'll include steps: Start, Input num1, Input num2, Parse num1, parse num2, compute real part, compute imaginary part, format string, Output result, End.\n\nAlso maybe decisions for parsing signs, but keep simple.\n\nWe'll produce each line with arrow symbol \"→\" preceding each step.\n\nLet's produce:\n\nStart // start\n→ Input num1 // read first complex string\n→ Input num2 // read second complex string\n→ Parse num1: real1 = extract integer before '+' or '-' ; imag1 = extract integer between '+'/'-' and 'i' // parse first number\n→ Parse num2: real2 = extract integer before '+' or '-' ; imag2 = extract integer between '+'/'-' and 'i' // parse second number\n→ Compute real product: realPart = real1 * real2 - imag1 * imag2 // real part of multiplication\n→ Compute imaginary product: imagPart = real1 * imag2 + imag1 * real2 // imaginary part of multiplication\n→ Format result string: result = realPart + \"+\" + imagPart + \"i\" // concatenate into string\n→ Output result // return the string\nEnd // finish\n\nWe can include decision maybe for negative imaginary part? But the format always uses '+' sign? In standard representation, if imagPart negative, might show '-bi'. But requirement? It says \"real+imaginaryi\" so always plus? But if imag negative, representation might be \"real-abs(i)\" but given they want \"real+imaginaryi\" maybe always plus? We can just format accordingly: If imagPart negative, show '-' sign.\n\nAdd decision: if imagPart < 0 then use '-' else '+'. Provide string accordingly.\n\nLet's include that.\n\nSo after computing imagPart, we format with sign decision.\n\nSteps:\n\n→ Decision: imagPart >= 0? // check sign\n   Yes → Format result string with '+' sign\n   No  → Format result string with '-' sign and absolute value\n\nThus include.\n\nWe should keep each line separated, each with explanation.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input num1 // 讀取第一個複數字串  \n→ Input num2 // 讀取第二個複數字串  \n\n→ Parse num1: real1 = 數字字串中 '+' 或 '-' 前的整數；imag1 = '+' 或 '-' 後 'i' 前的整數 // 從字串拆解實部與虛部  \n→ Parse num2: real2 = 數字字串中 '+' 或 '-' 前的整數；imag2 = '+' 或 '-' 後 'i' 前的整數 // 同樣拆解第二個複數  \n\n→ Compute real product: realPart = real1 * real2 - imag1 * imag2 // (ac - bd)  \n→ Compute imaginary product: imagPart = real1 * imag2 + imag1 * real2 // (ad + bc)  \n\n→ Decision: imagPart >= 0? // 判斷虛部符號  \n    Yes → Format result string: result = realPart + \"+\" + imagPart + \"i\" // 正虛部使用 '+'  \n    No  → Format result string: result = realPart + \"-\" + abs(imagPart) + \"i\" // 負虛部使用 '-'  \n\n→ Output result // 回傳格式化後的複數字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef find_duplicate(paths):\n    content_map = defaultdict(list)\n    for path in paths:\n        parts = path.split()\n        root = parts[0]\n        for file_info in parts[1:]:\n            name, content = file_info.split('(')\n            content = content[:-1]  # remove trailing ')'\n            content_map[content].append(f\"{root}/{name}\")\n    return [files for files in content_map.values() if len(files) > 1]\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    # Extract the list assigned to 'paths'\n    if raw_input.startswith(\"paths\"):\n        raw_input = raw_input.split(\"=\", 1)[1].strip()\n    # Safely evaluate the list literal\n    try:\n        paths_list = ast.literal_eval(raw_input)\n    except Exception as e:\n        # If evaluation fails, print an empty list and exit\n        print([])\n        sys.exit(0)\n    # Compute duplicate file groups\n    result = find_duplicate(paths_list)\n    # Print the result to stdout\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for algorithm that given list of directory info strings, find duplicate file paths by content. We need to produce line-by-line pseudo-code with explanation comments. Use Start, End, Decision etc. We cannot output actual code, just pseudo.\n\nWe should design algorithm: iterate through each path string, parse directory path and files. For each file, get content, create map content->list of file paths. After processing all, iterate over map, collect lists with size>1 into result. Output result.\n\nWe need to produce pseudo-code lines with arrows.\n\nWe should include parsing details: split by space, first token is directory path, rest are fileInfo tokens like \"f1.txt(f1_content)\". We need to extract file name and content by splitting on '(' and ')'.\n\nWe need to maintain dictionary mapping content to list of full paths.\n\nAt the end, iterate dictionary and produce result.\n\nMake sure to include Start, End, Decision.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize empty map content_to_paths // mapping content -> list of file paths\n→ Step 2: For each dir_info in input_list // iterate directory info strings\n    → Step 3: Split dir_info by space into tokens // tokens[0] is dir_path\n        → Step 4: dir_path = tokens[0]\n        → Step 5: For each file_token in tokens[1:] // file info\n            → Step 6: Extract file_name and content from file_token // by parsing parentheses\n                → Step 7: full_path = dir_path + \"/\" + file_name\n                → Step 8: If content not in map → add new list\n                → Step 9: Append full_path to map[content]\n→ Step 10: Initialize result list\n→ Step 11: For each content, paths in map\n    → Decision: If length(paths) > 1? // duplicates exist\n        Yes → Step 12: Append paths to result\n→ End\n\nBut we need to output with \"虛擬碼步驟\" lines. Use arrow or \"→\".\n\nAlso we might need to show decision branch indentation.\n\nWe need to format exactly like example: lines start with \"Start\" or \"→ ...\". Use arrow for steps. For Decision, show \"Decision: ...\" with nested Yes / No branches.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 content_to_paths // 以檔案內容作為鍵，對應檔案完整路徑清單  \n→ Step 2: 對輸入清單中的每一筆 dir_info 進行迴圈 // 逐行處理每個目錄資訊  \n    → Step 3: 以空白字元將 dir_info 分割成 tokens // tokens[0] 為目錄路徑，後續為檔案資訊  \n        → Step 4: dir_path ← tokens[0] // 取得目錄路徑  \n        → Step 5: 對 tokens[1:] 中的每一個 file_token 進行迴圈 // 處理每個檔案  \n            → Step 6: 從 file_token 取出 file_name 與 content // 解析括號前的檔名與括號內的內容  \n                → Step 7: full_path ← dir_path + \"/\" + file_name // 組合完整路徑  \n                → Step 8: 若 content 不在 content_to_paths 中，則 content_to_paths[content] ← 空清單 // 初始化清單  \n                → Step 9: content_to_paths[content].append(full_path) // 將檔案路徑加入對應內容的清單  \n→ Step 10: 建立空清單 result // 存放重複檔案的路徑群組  \n→ Step 11: 對 content_to_paths 中的每一對 (content, paths) 進行迴圈  \n    → Decision: paths 長度 > 1? // 是否有重複檔案  \n        Yes → Step 12: result.append(paths) // 將重複群組加入結果  \n        No  → // 不做任何動作，跳過單一檔案  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpph1x2iup.py\", line 39, in <module>\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmpph1x2iup.py\", line 19, in rand10\n    num = (rand7() - 1) * 7 + rand7()\n           ^^^^^^^\n  File \"/tmp/tmpph1x2iup.py\", line 10, in rand7\n    raise NotImplementedError(\"rand7() 必須由測試環境提供。\")\nNotImplementedError: rand7() 必須由測試環境提供。"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2p1clvck.py\", line 39, in <module>\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmp2p1clvck.py\", line 19, in rand10\n    num = (rand7() - 1) * 7 + rand7()\n           ^^^^^^^\n  File \"/tmp/tmp2p1clvck.py\", line 10, in rand7\n    raise NotImplementedError(\"rand7() 必須由測試環境提供。\")\nNotImplementedError: rand7() 必須由測試環境提供。"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphwlupgca.py\", line 39, in <module>\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmphwlupgca.py\", line 19, in rand10\n    num = (rand7() - 1) * 7 + rand7()\n           ^^^^^^^\n  File \"/tmp/tmphwlupgca.py\", line 10, in rand7\n    raise NotImplementedError(\"rand7() 必須由測試環境提供。\")\nNotImplementedError: rand7() 必須由測試環境提供。"
        }
      ],
      "generated_code": "import sys\n\n# -------------------------------------------------------------\n# 這個函式假設環境已經提供了 rand7()，不需要自行實作。\n# -------------------------------------------------------------\ndef rand7():\n    \"\"\"\n    本函式由測試環境提供。若在本地測試，需要自行實作。\n    \"\"\"\n    raise NotImplementedError(\"rand7() 必須由測試環境提供。\")\n\nclass Solution:\n    def rand10(self):\n        \"\"\"\n        使用兩次 rand7() 產生 1~49 的均勻分布，並用拒絕抽樣映射到 1~10。\n        \"\"\"\n        while True:\n            # 產生 1~49 的整數\n            num = (rand7() - 1) * 7 + rand7()\n            if num <= 40:                      # 只使用 1~40 的數值\n                return 1 + (num - 1) % 10     # 映射到 1~10\n\nif __name__ == \"__main__\":\n    # 讀取輸入，例如 \"n = 3\"\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    # 解析出 n 的值\n    try:\n        _, value = raw.split('=', 1)\n        n = int(value.strip())\n    except ValueError:\n        # 若輸入格式不符合，直接退出\n        sys.exit(0)\n\n    # 呼叫 rand10() n 次\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n\n    # 輸出結果，保持與範例相同的格式\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, no actual code, in Chinese (traditional). Use Start, End, Decision etc. Provide line-by-line steps for generating uniform random integer 1-10 using rand7. Standard approach: use rejection sampling: use two rand7 to produce numbers 1-49. If <= 40, map to 1-10 via modulo. If >40, reject and retry. That uses at most 2 calls to rand7. Could also use method: generate 1-49 by (rand7-1)*7 + rand7. If <=40: return ((x-1)%10)+1 else repeat.\n\nSo produce steps: Start -> Step1: Generate a random number r1 via rand7() // get first 1-7. -> Step2: Generate r2 via rand7() // second 1-7. -> Step3: Compute combined = (r1-1)*7 + r2 // produce 1-49. -> Decision: If combined <= 40? // Check if within usable range. Yes -> Step4: Return ((combined-1) % 10) + 1 // map to 1-10. No -> Step5: Repeat from Step1 // reject and try again. End.\n\nAlso we might need a loop. Use \"Repeat until return\" style. So maybe Step5: Go back to Step1. Also can note about expected number of calls ~ 2.1.\n\nWe need to produce virtual code lines with // explanation.\n\nMake sure to keep proper indentation: Decision: If combined <= 40? // check. Then Yes→..., No→... maybe go back to Step1.\n\nUse arrow for steps: →. Use Decision: etc.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 r1 = rand7() // 先呼叫 rand7() 產生 1~7  \n→ Step 2: 取得 r2 = rand7() // 再呼叫 rand7() 產生 1~7  \n→ Step 3: 計算 combined = (r1 - 1) * 7 + r2 // 結合兩個數字得到 1~49  \n→ Decision: 如果 combined <= 40? // 只在可用範圍內使用  \n Yes → Step 4: 回傳 ((combined - 1) % 10) + 1 // 將 1~40 映射為 1~10  \n No  → Step 5: 重複從 Step 1 開始 // 超過 40 時拒絕並重試  \nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\n\ndef wiggle_sort(nums):\n    \"\"\"Reorder nums so that nums[0] < nums[1] > nums[2] < nums[3] …\"\"\"\n    n = len(nums)\n    for i in range(n - 1):\n        if i % 2 == 0:\n            # even index: we need nums[i] < nums[i+1]\n            if nums[i] >= nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        else:\n            # odd index: we need nums[i] > nums[i+1]\n            if nums[i] <= nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Find the first '[' and the last ']' to extract the list literal\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        # Fallback: try to eval the whole input\n        nums = eval(data)\n    else:\n        nums_str = data[start:end+1]\n        nums = eval(nums_str)\n\n    wiggle_sort(nums)\n    print(nums)",
      "virtual_code": "Thinking...\nThe user wants virtual code steps for rearranging an array into wiggle sort: nums[0] < nums[1] > nums[2] < nums[3] ... We need to produce pseudo-code line by line with explanation. Use structure arrows, Start, End, Decision. The algorithm likely: iterate i from 0 to len-2, if (i%2==0 and nums[i] >= nums[i+1]) swap, else if (i%2==1 and nums[i] <= nums[i+1]) swap. This ensures wiggle. Provide steps. Let's produce with Start, loop, decision, swap. Use arrow. Provide each line. Ensure we don't output real code, just pseudo steps. Let's include variable names: i, n. Use \"Loop: i=0 to n-2\" etc. Provide explanation each line.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n = nums 的長度 // 取得陣列長度  \n→ Step 2: 初始化 i = 0 // 從第一個索引開始  \n→ Loop: 當 i < n-1 時 // 逐一檢查相鄰兩個元素  \n  → Decision: i 為偶數? // 判斷索引是否為偶數  \n   Yes → Decision: nums[i] ≥ nums[i+1]? // 若偶數索引，需確保小於下個元素  \n    Yes → Step 3: 交換 nums[i] 與 nums[i+1] // 交換以滿足 nums[i] < nums[i+1]  \n    No  →  // 不需要交換  \n   No → Decision: nums[i] ≤ nums[i+1]? // 若奇數索引，需確保大於下個元素  \n    Yes →  // 不需要交換  \n    No  → Step 4: 交換 nums[i] 與 nums[i+1] // 交換以滿足 nums[i] > nums[i+1]  \n  → Step 5: i = i + 1 // 移動到下一個索引  \n→ End // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpayqhp7if.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmpayqhp7if.py\", line 37, in main\n    module = ast.parse(code)\n             ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwq0u4aae.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmpwq0u4aae.py\", line 37, in main\n    module = ast.parse(code)\n             ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppz5o9a8p.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmppz5o9a8p.py\", line 37, in main\n    module = ast.parse(code)\n             ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\ndef main():\n    # Read all input from stdin\n    code = sys.stdin.read().strip()\n    if not code:\n        return\n\n    # Parse assignments from the input string\n    module = ast.parse(code)\n    data = {}\n    for node in module.body:\n        if isinstance(node, ast.Assign):\n            var_name = node.targets[0].id\n            # Convert the AST node back to source code and evaluate safely\n            value_str = ast.unparse(node.value)\n            value = ast.literal_eval(value_str)\n            data[var_name] = value\n\n    equations = data.get('equations', [])\n    values = data.get('values', [])\n    queries = data.get('queries', [])\n\n    solver = Solution()\n    results = solver.calcEquation(equations, values, queries)\n\n    # Format output: each value to 5 decimal places, no spaces\n    formatted = '[' + ','.join(f'{v:.5f}' for v in results) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, not actual code. Problem is evaluating division queries using equations. We need to produce virtual algorithm: build graph, DFS or Union Find. Use DFS. Provide steps line by line with explanation.\n\nLet's produce steps:\n\nStart\n→ Build graph adjacency map from equations and values\n→ For each query, call DFS to find product ratio from C to D\n→ If no path, return -1.0 else ratio\n→ Collect results\nEnd\n\nBut need to produce each step line by line. Provide structure with Decision: etc. Let's write detailed steps.\n\nWe need to output lines with \"虛擬碼步驟\" then comment.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: Initialize empty map graph // 建立鄰接表\n→ Decision: 如果 equations 不是空？ // 檢查是否有方程\n    Yes → For each index i in equations\n        → Step 2: Ai ← equations[i][0] // 取得左變數\n        → Step 3: Bi ← equations[i][1] // 取得右變數\n        → Step 4: val ← values[i] // 對應值\n        → Step 5: Add edge Ai → (Bi, val) to graph // 加入正向邊\n        → Step 6: Add edge Bi → (Ai, 1/val) to graph // 加入反向邊\n    No  → // 無方程，圖保持空\n→ Step 7: Initialize empty list results // 用於儲存查詢答案\n→ For each query in queries\n    → Step 8: C ← query[0] // 查詢分子\n    → Step 9: D ← query[1] // 查詢分母\n    → Decision: 如果 C 或 D 不在 graph？ // 無效變數\n        Yes → Step 10: Append -1.0 to results // 回傳無法計算\n        No  → Decision: 如果 C == D？ // 同一變數\n            Yes → Step 11: Append 1.0 to results // 自己除以自己\n            No  → Step 12: Perform DFS from C to D\n                → Sub-step: Define stack (node, accumulated_product)\n                → Push (C, 1.0) // 起始點\n                → Initialize set visited\n                → While stack not empty\n                    → Pop (node, prod)\n                    → Mark node visited\n                    → For each neighbor (next, weight) of node in graph\n                        → Decision: 如果 next 已訪問？ // 防止循環\n                            Yes → // skip\n                            No  → If next == D\n                                → Step 13: Append prod * weight to results // 找到路徑\n                                → Break outer loops // 完成查詢\n                            No → Push (next, prod * weight) // 繼續搜尋\n                → Decision: 如果沒有找到路徑？ // 未找到\n                    Yes → Step 14: Append -1.0 to results\n                    No  → // 已在上一步加入結果\n→ Step 15: Return results // 完成所有查詢\nEnd // 程式執行結束\n\nNeed to ensure each line separate. Use \"→\" for flow. Provide explanation after //.\n\nLet's craft final output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化空鄰接表 graph // 建立變數之間的加權邊\n→ Decision: 如果 equations 非空？ // 是否有方程可解析\n    Yes → For i = 0 to equations.length-1\n        → Step 2: Ai ← equations[i][0] // 取得左變數\n        → Step 3: Bi ← equations[i][1] // 取得右變數\n        → Step 4: val ← values[i] // 對應的比例值\n        → Step 5: graph[Ai].append((Bi, val)) // 加入正向邊 Ai → Bi\n        → Step 6: graph[Bi].append((Ai, 1/val)) // 加入反向邊 Bi → Ai\n    No  → // 無方程，圖保持空\n→ Step 7: 建立空列表 results // 用於儲存查詢答案\n→ For each query in queries\n    → Step 8: C ← query[0] // 查詢分子\n    → Step 9: D ← query[1] // 查詢分母\n    → Decision: C 或 D 不在 graph？ // 變數未定義\n        Yes → Step 10: results.append(-1.0) // 無法計算\n        No  → Decision: C == D？ // 同一變數\n            Yes → Step 11: results.append(1.0) // 自己除以自己等於 1\n            No  → Step 12: 執行 DFS 從 C 尋找 D\n                → Sub-step: 初始化 stack with (C, 1.0) // 起始點與累積乘積\n                → Sub-step: 初始化 visited set\n                → While stack 非空\n                    → Pop (node, prod) from stack\n                    → visited.add(node) // 標記已訪問\n                    → For each (next, weight) in graph[node]\n                        → Decision: next 已訪問？ // 防止循環\n                            Yes → // 跳過\n                            No  → Decision: next == D？\n                                Yes → Step 13: results.append(prod * weight) // 找到答案\n                                → Break 所有循環 // 查詢完成\n                                No  → Push (next, prod * weight) 到 stack // 繼續搜尋\n                → Decision: 沒有找到路徑？\n                    Yes → Step 14: results.append(-1.0) // 無法透過圖找到比例\n                    No  → // 已在上述成功路徑中加入結果\n→ Step 15: Return results // 回傳所有查詢答案\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Kth Largest Element in an Array",
      "source_file": "Leetcode/leetcode215.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1,5,6,4], k = 2",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport re\n\nclass Solution:\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        找到 nums 中第 k 大的元素，使用 QuickSelect\n        \"\"\"\n        target = len(nums) - k  # 在升冪排序中，k 大元素的索引\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            pivot_index = self._partition(nums, left, right)\n            if pivot_index == target:\n                return nums[pivot_index]\n            elif pivot_index > target:\n                right = pivot_index - 1\n            else:\n                left = pivot_index + 1\n        # 若輸入錯誤，回傳 None\n        return None\n\n    def _partition(self, nums, left, right):\n        \"\"\"\n        以右邊界元素為 pivot，將大於 pivot 的元素移到左側，\n        返回 pivot 的最終索引\n        \"\"\"\n        # 隨機選擇 pivot，避免最壞情況\n        pivot_idx = random.randint(left, right)\n        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n        pivot = nums[right]\n        store = left\n\n        for i in range(left, right):\n            if nums[i] > pivot:          # 大於 pivot 的放左側\n                nums[store], nums[i] = nums[i], nums[store]\n                store += 1\n\n        nums[store], nums[right] = nums[right], nums[store]\n        return store\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，支援 \"nums = [...], k = ...\"\n    match = re.search(r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*k\\s*=\\s*(\\d+)', data)\n    if match:\n        nums_str = match.group(1)\n        k_str = match.group(2)\n    else:\n        # 也支援兩行分別輸入\n        parts = data.replace('\\n', ' ').split(',')\n        if len(parts) >= 2:\n            nums_str = parts[0].split('=', 1)[1].strip()\n            k_str = parts[1].split('=', 1)[1].strip()\n        else:\n            print(\"Invalid input format\")\n            sys.exit()\n\n    try:\n        nums = eval(nums_str)\n        k = int(k_str)\n    except Exception as e:\n        print(\"Error parsing input:\", e)\n        sys.exit()\n\n    solution = Solution()\n    result = solution.findKthLargest(nums, k)\n    if result is not None:\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for finding k-th largest element in an array without sorting. We can use QuickSelect (selection algorithm) or min-heap of size k. We'll produce a virtual algorithm that uses QuickSelect. Provide step by step. Use Start, End, Decision. We'll output lines. Provide explanation after each line.\n\nLet's design algorithm:\n\nStart\n→ Step 1: Set left=0, right=length(nums)-1 // bounds\n→ Decision: While left <= right? // loop until find kth largest\n    Yes → Step 2: Partition array around pivot at position right, get pivot index p // partition\n    Yes → Decision: If p == k-1? // if pivot is kth largest (sorted ascending)\n        Yes → Step 3: Return nums[p] // found\n        No → Decision: If p > k-1? // pivot index larger than target, search left\n            Yes → Step 4: right = p-1 // adjust right\n            No  → Step 5: left = p+1 // adjust left\n    No → End // condition false (should not happen)\nEnd\n\nBut we need to incorporate selecting pivot and partition logic.\n\nBetter step:\n\n→ Step 2: Choose pivot index randomly between left and right // avoid worst-case\n→ Step 3: Swap pivot with right // move pivot to end\n→ Step 4: Initialize storeIndex = left // index for smaller elements\n→ For i from left to right-1:\n        If nums[i] <= nums[right] // since we want kth largest, use >= or <= accordingly\n            Swap nums[storeIndex] and nums[i]\n            storeIndex++\n→ Swap nums[storeIndex] and nums[right] // place pivot in correct position\n→ Return storeIndex as pivotIndex\n\nWe'll incorporate.\n\nBut we also need to mention k-th largest in sorted order ascending? Actually k-th largest means we want element that would appear at position len-k if sorted ascending. But algorithm uses partition with respect to <= or >=. Let's decide: use partition that places larger elements on left. For kth largest, we want pivotIndex == k-1 (0-based) after partition if sorted descending. Alternatively we can compute target = len(nums) - k (for ascending). We'll use target = len(nums) - k.\n\nSimplify: In Step 2, compute target = len(nums) - k.\n\nProceed accordingly.\n\nLet's produce virtual code lines.\n\nWe need to output each line with explanation.\n\nWe'll produce:\n\nStart // Program start\n→ Step 1: Define targetIndex = length(nums) - k // index of kth largest in ascending order\n→ Step 2: left = 0, right = length(nums) - 1 // bounds for search\n→ Decision: while left <= right? // continue until pivot at target\n    Yes → Step 3: pivotIndex = Partition(nums, left, right) // partition around a pivot\n    Yes → Decision: if pivotIndex == targetIndex? // pivot at desired position\n        Yes → Step 4: Return nums[pivotIndex] // kth largest found\n        No  → Decision: if pivotIndex > targetIndex? // pivot too far right, search left half\n            Yes → Step 5: right = pivotIndex - 1 // narrow right boundary\n            No  → Step 6: left = pivotIndex + 1 // narrow left boundary\n    No → End // should not happen\nEnd // program end\n\nWe need to include the Partition procedure.\n\nAdd:\n\n→ Step 7: Procedure Partition(nums, left, right) // returns pivot final index\n    → Step 7.1: pivotValue = nums[right] // choose rightmost as pivot\n    → Step 7.2: storeIndex = left // index for storing greater elements\n    → For i from left to right-1:\n            If nums[i] > pivotValue? // greater goes to left\n                Swap nums[storeIndex] and nums[i]\n                storeIndex++\n    → Swap nums[storeIndex] and nums[right] // place pivot\n    → Return storeIndex // pivot final index\n\nBut we need each line as virtual code line with explanation. The procedure lines may need sublines? The format: \"Step 7: Procedure Partition(nums, left, right) // returns pivot final index\" then inside maybe \"→ Step 7.1:\" etc. But the format requires arrow lines. We can do indentation with arrow. Example:\n\n→ Step 7: Procedure Partition(nums, left, right) // returns pivot final index\n    → Step 7.1: pivot = nums[right] // choose pivot\n    → Step 7.2: store = left // pointer for > pivot\n    → For i = left to right-1:\n        → Step 7.3: If nums[i] > pivot? // bigger to left\n            Yes → Step 7.4: Swap nums[store] and nums[i] // move bigger element\n            Yes → Step 7.5: store = store + 1\n    → Step 7.6: Swap nums[store] and nums[right] // pivot to its final position\n    → Step 7.7: Return store // pivot index\n\nBut the format requires each line like \"虛擬碼步驟 [空格] // 解釋/說明\". We'll maintain this for each line. For the loop inside procedure, we need each line.\n\nLet's produce final output with lines. Use Start, End.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: targetIndex = length(nums) - k // 先計算在升冪排序中，k 大的元素所對應的索引\n→ Step 2: left = 0, right = length(nums) - 1 // 設定搜尋區間的左右邊界\n→ Decision: while left <= right? // 只要搜尋區間有效，就持續進行\n    Yes → Step 3: pivotIndex = Partition(nums, left, right) // 對區間做一次 partition，得到 pivot 的最終位置\n    Yes → Decision: if pivotIndex == targetIndex? // 若 pivot 正好是目標索引\n        Yes → Step 4: Return nums[pivotIndex] // 找到 k 大的元素，結束\n        No  → Decision: if pivotIndex > targetIndex? // pivot 在目標索引右側，須搜尋左半邊\n            Yes → Step 5: right = pivotIndex - 1 // 收縮右邊界\n            No  → Step 6: left = pivotIndex + 1 // 收縮左邊界\n    No → End // (理論上不會進入此分支)\nEnd // 程式結束執行\n\n→ Step 7: Procedure Partition(nums, left, right) // 以右邊界元素作 pivot，返回其最終索引\n    → Step 7.1: pivot = nums[right] // 選擇 pivot 值\n    → Step 7.2: store = left // 初始化存放 > pivot 元素的起點\n    → For i = left to right-1:\n        → Step 7.3: If nums[i] > pivot? // 大於 pivot 的元素放到左側\n            Yes → Step 7.4: Swap nums[store] and nums[i] // 交換位置\n            Yes → Step 7.5: store = store + 1 // 移動存放指標\n    → Step 7.6: Swap nums[store] and nums[right] // 把 pivot 放到正確位置\n    → Step 7.7: Return store // 回傳 pivot 的最終索引"
    },
    {
      "title": "Partition to K Equal Sum Subsets",
      "source_file": "Leetcode/leetcode698.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,3,5,2,1], k = 4",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\n        total = sum(nums)\n        if total % k != 0:\n            return False\n        target = total // k\n        n = len(nums)\n        nums.sort(reverse=True)\n        memo = {}\n\n        def dfs(used_mask: int, curr_sum: int, k_remaining: int) -> bool:\n            if k_remaining == 0:\n                return True\n            key = (used_mask, curr_sum, k_remaining)\n            if key in memo:\n                return memo[key]\n            for i in range(n):\n                if not (used_mask >> i) & 1 and curr_sum + nums[i] <= target:\n                    next_mask = used_mask | (1 << i)\n                    next_sum = (curr_sum + nums[i]) % target\n                    next_k = k_remaining - ((curr_sum + nums[i]) // target)\n                    if dfs(next_mask, next_sum, next_k):\n                        memo[key] = True\n                        return True\n            memo[key] = False\n            return False\n\n        return dfs(0, 0, k)\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    nums = []\n    k = 0\n    # Try to parse input of the form: nums = [4,3,2,3,5,2,1], k = 4\n    # or variants with whitespace differences.\n    parts = [p.strip() for p in input_data.split(',')]\n    for part in parts:\n        if part.startswith('nums'):\n            # Extract the list part after '='\n            nums_part = part.split('=', 1)[1].strip()\n            try:\n                nums = eval(nums_part, {\"__builtins__\": None}, {})\n            except Exception:\n                # Fallback: try to parse manually\n                nums = [int(x) for x in nums_part.strip('[]').split(',') if x.strip()]\n        elif part.startswith('k'):\n            k_part = part.split('=', 1)[1].strip()\n            try:\n                k = int(k_part)\n            except ValueError:\n                # If k is provided without a number, default to 0\n                k = 0\n\n    # If parsing failed, attempt a more general eval of the whole input\n    if not nums or not k:\n        try:\n            data = eval(input_data, {\"__builtins__\": None}, {})\n            if isinstance(data, dict):\n                nums = data.get('nums', [])\n                k = data.get('k', 0)\n            elif isinstance(data, tuple) and len(data) == 2:\n                nums, k = data\n        except Exception:\n            pass\n\n    solution = Solution()\n    result = solution.canPartitionKSubsets(nums, k)\n    print('true' if result else 'false')",
      "virtual_code": "Thinking...\nWe need to generate pseudo-code for checking if array can be partitioned into k subsets equal sum. Typical algorithm: check sum % k, target sum. Backtracking / recursion with bitmask. Use DFS with pruning. We need step by step. Provide line-by-line virtual code. Let's produce steps: Start, compute total sum, if not divisible, return false. Compute target. Sort array descending for pruning. Use visited bitmask or array used. DFS(current_sum, count, start_index). Use recursion. Provide decisions. Provide final return. Also maybe iterative BFS. But typical DFS.\n\nWe should produce pseudo-code lines like:\n\nStart // 程式開始執行\n→ Step 1: 計算陣列總和 totalSum = sum(nums) // 取得所有數字之和\n→ Decision: 如果 totalSum % k ≠ 0? // 檢查是否能平均分配\n    Yes → Step 2: return false // 無法分成 k 個相等子集\n    No  → ...\n\nSort nums descending to improve pruning\n→ Step 3: sort(nums, descending) // 排序以加速搜尋\n\nCompute target = totalSum / k\n\nInitialize visited array boolean[nums.length] = false\n\nDefine function dfs(startIndex, currentSum, count)\n\nWe need to represent as lines: each line with virtual code and comment.\n\nWe need to include decisions, loops, recursion. Use arrow and indent? Use indentation with spaces maybe 4 spaces. Use arrow before each line.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: totalSum = sum(nums) // 計算總和\n→ Decision: totalSum % k ≠ 0? // 是否能平均分配\n    Yes → Step 2: return false // 無法分成 k 個子集\n    No  → Step 3: target = totalSum / k // 目標子集和\n→ Step 4: sort(nums, descending) // 降序排序\n→ Step 5: visited = array of false of length nums.length // 標記已使用的元素\n→ Step 6: Define function dfs(startIndex, currentSum, completed) // 回溯函式\n    → Decision: completed == k? // 是否已完成 k 個子集\n        Yes → Step 7: return true // 成功\n        No  →\n            → Decision: currentSum == target? // 是否填滿一個子集\n                Yes → Step 8: return dfs(0, 0, completed + 1) // 開始下一個子集\n                No  →\n                    → For i from startIndex to nums.length-1\n                        → Decision: visited[i] == false AND currentSum + nums[i] <= target? // 可否加入\n                            Yes →\n                                → visited[i] = true // 標記使用\n                                → Step 9: if dfs(i+1, currentSum + nums[i], completed) return true // 递归\n                                → visited[i] = false // 回溯\n                    → Step 10: return false // 所有嘗試失敗\n→ Step 11: return dfs(0, 0, 0) // 開始回溯\nEnd // 程式執行結束\n\nWe must format each line with virtual code and comment separated by space. Use arrow before each line.\n\nMake sure each line has arrow `→`. For decisions we can indent or use arrow plus spaces. Use \"Decision:\" lines.\n\nWe must follow format: `虛擬碼步驟 [空格] // 解釋/說明`.\n\nThus for decision lines we need to include the decision statement.\n\nLet's format:\n\nStart // 程式開始執行\n→ totalSum = sum(nums) // 計算陣列總和\n→ Decision: totalSum % k ≠ 0? // 檢查是否能平均分配\n    Yes → return false // 無法分成 k 個相等子集\n    No  → target = totalSum / k // 目標子集和\n→ sort(nums, descending) // 降序排序以提升搜尋效率\n→ visited = array of false[nums.length] // 標記已使用的元素\n→ Define function dfs(startIndex, currentSum, completed) // 回溯函式\n    → Decision: completed == k? // 所有子集已填滿\n        Yes → return true // 成功分割\n        No  →\n            → Decision: currentSum == target? // 本子集已達目標和\n                Yes → return dfs(0, 0, completed + 1) // 開始下一個子集\n                No  →\n                    → For i = startIndex to nums.length - 1\n                        → Decision: not visited[i] AND currentSum + nums[i] <= target? // 可加入元素\n                            Yes →\n                                → visited[i] = true // 標記為已使用\n                                → Decision: dfs(i + 1, currentSum + nums[i], completed)? // 進行遞迴\n                                    Yes → return true // 成功\n                                    No  → visited[i] = false // 回溯\n                    → return false // 無法完成分割\n→ return dfs(0, 0, 0) // 開始回溯\nEnd // 程式執行結束\n\nBut we need to keep each line exactly one step. The \"Decision:\" line can be considered a step. But the nested \"Yes →\" and \"No →\" need to be separate lines. Indentation maybe 4 spaces.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ totalSum = sum(nums) // 計算陣列總和\n→ Decision: totalSum % k ≠ 0? // 檢查總和是否能被 k 平均分配\n    Yes → return false // 若不整除，直接返回 false\n    No  → target = totalSum / k // 計算每個子集需要的目標和\n→ sort(nums, descending) // 降序排序以加速搜尋\n→ visited = array of false[nums.length] // 建立布林陣列標記元素是否已使用\n→ Define function dfs(startIndex, currentSum, completed) // 回溯函式\n    → Decision: completed == k? // 是否已成功分割出 k 個子集\n        Yes → return true // 成功，回傳 true\n        No  →\n            → Decision: currentSum == target? // 本子集是否已達目標和\n                Yes → return dfs(0, 0, completed + 1) // 開始填寫下一個子集\n                No  →\n                    → For i = startIndex to nums.length - 1\n                        → Decision: not visited[i] AND currentSum + nums[i] <= target? // 是否可以加入此元素\n                            Yes →\n                                → visited[i] = true // 標記為已使用\n                                → Decision: dfs(i + 1, currentSum + nums[i], completed)? // 進行遞迴\n                                    Yes → return true // 成功，直接回傳\n                                    No  → visited[i] = false // 回溯，恢復標記\n                    → return false // 所有嘗試均失敗，回傳 false\n→ return dfs(0, 0, 0) // 從索引 0 開始，累計 0，完成子集數為 0\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,2,2,false]'\nGot (Norm):      '[null,null,2,2,false]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 2, 2, false]'\nRaw Got:      '[null, null, 2, 2, false]'"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q = deque()\n\n    def push(self, x):\n        self.q.append(x)\n        for _ in range(len(self.q) - 1):\n            self.q.append(self.q.popleft())\n\n    def pop(self):\n        return self.q.popleft()\n\n    def top(self):\n        return self.q[0]\n\n    def empty(self):\n        return not self.q\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Remove leading 'Input' if present\n    if data.lower().startswith('input'):\n        data = data[data.lower().find('['):]\n    # Evaluate the two lists\n    ops, args = eval(data)\n    stack = MyStack()\n    results = []\n    for op, arg in zip(ops, args):\n        if op == 'push':\n            stack.push(arg[0])\n            results.append(None)\n        elif op == 'pop':\n            results.append(stack.pop())\n        elif op == 'top':\n            results.append(stack.top())\n        elif op == 'empty':\n            results.append(stack.empty())\n    # Format output as requested\n    out_str = '[' + ', '.join(\n        'null' if r is None else\n        'true' if r is True else\n        'false' if r is False else\n        str(r)\n        for r in results\n    ) + ']'\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing a stack using two queues, with operations push, pop, top, empty. Use virtual code, each line with arrow, etc. We'll explain each line.\n\nWe should describe the algorithm: two queues q1 and q2. For push: enqueue to q1. For pop: move all but last element from q1 to q2, then dequeue last from q1, which is the popped element, then swap q1 and q2. For top: similar to pop but put last element back into q2 after retrieving. For empty: check if q1 is empty.\n\nBut we could also maintain that after each operation, q1 holds the stack with most recent element at front? Wait typical solution: Use one queue to hold elements and on push, rotate queue. Another solution: Use two queues, one is main, other temporary. Implementation can vary. We'll produce steps using two queues as main.\n\nLet's design algorithm:\n\nInitialize queue1 empty, queue2 empty.\n\npush(x): enqueue x to queue1. // simply add to back.\n\npop(): if queue1 empty return error. Move all elements except last from queue1 to queue2: while queue1 size >1: temp = queue1.dequeue(); queue2.enqueue(temp). Then result = queue1.dequeue(); // last element. Swap queue1 and queue2. Return result.\n\ntop(): similar but after retrieving last, also enqueue back to queue2, then swap. So: while queue1 size >1: temp = queue1.dequeue(); queue2.enqueue(temp). last = queue1.dequeue(); queue2.enqueue(last); swap; return last.\n\nempty(): return queue1.isEmpty()\n\nWe should present virtual code line by line. Use arrow arrow. Provide explanation after //.\n\nWe must output only virtual code, each line with \"虛擬碼步驟\" then space then explanation. Use Start, End, Decision.\n\nWe'll produce code for class MyStack with operations. Let's produce a skeleton:\n\nStart // 初始化\n→ Declare queue q1 // 主隊列\n→ Declare queue q2 // 暫存隊列\nEnd // 初始化完成\n\nBut we may treat the whole class as the program. However, each method can be described separately.\n\nLet's create separate blocks for each method:\n\nStart // 程式開始執行\n→ Define class MyStack // 宣告堆疊類別\n    → Constructor: initialize q1, q2\n    → push(x)\n        → q1.enqueue(x) // 將元素放入主隊列\n    → pop()\n        → Decision: q1 is empty? // 檢查是否為空\n            Yes → Return error // 空時返回錯誤\n            No  →\n                → While q1.size > 1: // 移除所有除最後一個外的元素\n                    → temp = q1.dequeue()\n                    → q2.enqueue(temp)\n                → result = q1.dequeue() // 最後一個即堆疊頂端\n                → Swap q1 and q2 // 交換兩隊列\n                → Return result\n    → top()\n        → Decision: q1 is empty? // 檢查是否為空\n            Yes → Return error\n            No  →\n                → While q1.size > 1:\n                    → temp = q1.dequeue()\n                    → q2.enqueue(temp)\n                → last = q1.dequeue() // 最後一個元素\n                → q2.enqueue(last) // 將其放回\n                → Swap q1 and q2\n                → Return last\n    → empty()\n        → Return q1.isEmpty() // 判斷主隊列是否為空\nEnd // 程式結束\n\nBut we need to format each line: each line has \"→\" or \"Start\". We need each line's content and explanation. We can't combine lines in indentation? The example shows indentation using spaces and \"Yes →\" etc. We should follow format: Each line may be nested under Decision. Let's replicate style.\n\nWe'll use:\n\nStart // 程式開始執行\n→ Define class MyStack // 宣告堆疊類別\n    → Constructor: q1 ← empty queue // 初始化主隊列\n    → Constructor: q2 ← empty queue // 初始化暫存隊列\n    → Method push(x): // 定義 push 方法\n        → q1.enqueue(x) // 將元素加入主隊列\n    → Method pop(): // 定義 pop 方法\n        → Decision: q1.isEmpty()? // 判斷主隊列是否空\n            Yes → Return error // 空時返回錯誤\n            No  →\n                → While q1.size > 1: // 將所有除最後一個外的元素移到暫存隊列\n                    → temp ← q1.dequeue()\n                    → q2.enqueue(temp)\n                → result ← q1.dequeue() // 取得最後一個元素\n                → Swap q1 and q2 // 交換兩隊列\n                → Return result // 返回被彈出的元素\n    → Method top(): // 定義 top 方法\n        → Decision: q1.isEmpty()? // 判斷主隊列是否空\n            Yes → Return error // 空時返回錯誤\n            No  →\n                → While q1.size > 1:\n                    → temp ← q1.dequeue()\n                    → q2.enqueue(temp)\n                → last ← q1.dequeue() // 取得最後一個元素\n                → q2.enqueue(last) // 將其放回\n                → Swap q1 and q2 // 交換兩隊列\n                → Return last // 返回頂端元素\n    → Method empty(): // 定義 empty 方法\n        → Return q1.isEmpty() // 判斷主隊列是否為空\nEnd // 程式結束\n\nBut we need each line with arrow at the start? The example uses \"→\" at the start of each line after Start. Indentation with spaces. For Decision block, we used Yes →, No → lines.\n\nThus we should produce each line following that.\n\nAlso we should ensure each line has an explanation after \"//\".\n\nWe should not produce actual code but just virtual steps.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define class MyStack // 宣告堆疊類別  \n → Constructor: q1 ← empty queue // 初始化主隊列  \n → Constructor: q2 ← empty queue // 初始化暫存隊列  \n → Method push(x): // 定義 push 方法  \n  → q1.enqueue(x) // 將元素加入主隊列  \n → Method pop(): // 定義 pop 方法  \n  → Decision: q1.isEmpty()? // 判斷主隊列是否空  \n   Yes → Return error // 空時返回錯誤  \n   No  →  \n    → While q1.size > 1: // 將所有除最後一個外的元素移到暫存隊列  \n     → temp ← q1.dequeue()  \n     → q2.enqueue(temp)  \n    → result ← q1.dequeue() // 取得最後一個元素  \n    → Swap q1 and q2 // 交換兩隊列  \n    → Return result // 返回被彈出的元素  \n → Method top(): // 定義 top 方法  \n  → Decision: q1.isEmpty()? // 判斷主隊列是否空  \n   Yes → Return error // 空時返回錯誤  \n   No  →  \n    → While q1.size > 1: // 將所有除最後一個外的元素移到暫存隊列  \n     → temp ← q1.dequeue()  \n     → q2.enqueue(temp)  \n    → last ← q1.dequeue() // 取得最後一個元素  \n    → q2.enqueue(last) // 將其放回  \n    → Swap q1 and q2 // 交換兩隊列  \n    → Return last // 返回頂端元素  \n → Method empty(): // 定義 empty 方法  \n  → Return q1.isEmpty() // 判斷主隊列是否為空  \nEnd // 程式結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "expected_output": "[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]'\nGot (Norm):      '[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"John\",\"johnnybravo@mail.com\"],[\"Mary\",\"mary@mail.com\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]'\nRaw Got:      \"[['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], ['John', 'johnnybravo@mail.com'], ['Mary', 'mary@mail.com']]\""
        },
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co'], ['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        # Union‑Find data structure\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            # 連結所有 email 到第一個 email\n            for email in acc[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        # 組成結果並排序\n        result = []\n        for root, emails in merged.items():\n            emails.sort()\n            result.append([email_to_name[root]] + emails)\n\n        # 為了得到一致的輸出順序，先按姓名排序再按第一個 email\n        result.sort(key=lambda x: (x[0], x[1] if len(x) > 1 else \"\"))\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 只取等號右側的字串，並使用 literal_eval 解析為 Python 物件\n    if '=' in raw_input:\n        _, _, expr = raw_input.partition('=')\n    else:\n        expr = raw_input\n    expr = expr.strip()\n    try:\n        accounts = ast.literal_eval(expr)\n    except Exception as e:\n        # 若解析失敗則直接終止\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    sol = Solution()\n    merged_accounts = sol.accountsMerge(accounts)\n    print(merged_accounts)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for merging accounts problem (Leetcode 721). Provide step-by-step algorithm in virtual code. Must output line by line with \"→\" arrow, decision, etc.\n\nNeed to cover reading accounts, building graph of emails, union find, grouping by root, sorting emails, assemble result.\n\nProvide pseudo-code.\n\nAlso each line with explanation comment.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個空字典 email_to_name // 用來儲存每個 email 對應的姓名  \n→ Step 2: 初始化一個空字典 graph (字典 → 集合) // 用來建立 email 之間的連結  \n→ Step 3: 針對每一筆帳號 accounts[i] 做以下處理  \n&nbsp;&nbsp;→ Step 3.1: 取出姓名 name = accounts[i][0]  \n&nbsp;&nbsp;→ Step 3.2: 取出 email 列表 emails = accounts[i][1:]  \n&nbsp;&nbsp;→ Step 3.3: 對每一個 email e 在 emails 中  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3.3.1: email_to_name[e] ← name // 記錄 email 對應姓名  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3.3.2: 若 e 不在 graph 中，graph[e] ← 空集合 // 初始化鄰接集合  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3.3.3: 若不是第一個 email，將 e 與首個 email 連結  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3.3.3.1: graph[e] 加入 emails[0]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3.3.3.2: graph[emails[0]] 加入 e  \n&nbsp;&nbsp;→ Step 3.4: 完成此帳號的所有連結  \n→ Step 4: 定義一個 DFS 函式 dfs(email, visited, component)  \n&nbsp;&nbsp;→ Decision: 如果 email 已在 visited? // 防止重複遍歷  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → End DFS // 已處理，結束  \n&nbsp;&nbsp;&nbsp;&nbsp;No →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.1: visited 加入 email  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.2: component 加入 email  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.3: 針對 graph[email] 中的每個 neighbour  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.3.1: 呼叫 dfs(neighbour, visited, component)  \n→ Step 5: 初始化 visited 為空集合 // 追蹤已探索的 email  \n→ Step 6: 初始化 result 為空列表 // 存放最終帳號  \n→ Step 7: 針對 graph 中每個 email e 做以下  \n&nbsp;&nbsp;→ Decision: e 是否已在 visited?  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Continue // 已處理，跳過  \n&nbsp;&nbsp;&nbsp;&nbsp;No →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7.1: 初始化 component 為空列表 // 用來收集同一個人的所有 email  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7.2: 呼叫 dfs(e, visited, component) // 取得連結的全部 email  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7.3: component 內的 email 先排序 // 必須升序  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7.4: 取出任一 email e0 = component[0] // 任意 email 可用來取得姓名  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7.5: name ← email_to_name[e0] // 取得姓名  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7.6: 把 [name] + component 放入 result  \n→ End // 程式執行結束，result 為合併後的帳號列表"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,6,4,1,6,6,6,1]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 6, 4, 1, 6, 6, 6, 1]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black_set = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        idx = random.randint(0, self.size - 1)\n        return self.mapping.get(idx, idx)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    ops = eval(data[0])          # list of operation names\n    args = eval(data[1])         # list of argument lists\n    res = []\n    instance = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            instance = Solution(*arg)\n            res.append(None)      # constructor returns null\n        elif op == \"pick\":\n            res.append(instance.pick())\n    # Format result for output: replace None with null\n    output = '[' + ', '.join('null' if v is None else str(v) for v in res) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code for algorithm. Approach: use mapping of blacklisted numbers in [0, n-1] to whitelist high numbers. Preprocess: let m = n - len(blacklist). Create set of blacklist. Then build mapping from each blacklisted number < m to a whitelisted number >= m not in blacklist. Use next available pointer. Then pick random k in [0, m-1], if k in map return map[k] else k. Complexity: O(n). Provide virtual code steps.\n\nWe need to output line by line with virtual code plus comments. Use Start, End, Decision. Need to not output actual code. Use arrows.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize n, blacklist, compute m = n - len(blacklist) // size of allowed set\n→ Step 2: Create set B from blacklist // for O(1) lookup\n→ Step 3: Initialize empty mapping M // dictionary\n→ Step 4: Initialize pointer w = n-1 // start from highest index\n→ Decision: While there are blacklisted numbers < m? // Need to fill mapping\n    Yes → For each b in blacklist:\n        Decision: If b < m? // only those less than m need mapping\n            Yes → Decision: While w in B? // find next non-blacklisted high number\n                Yes → w = w - 1 // decrement w\n            No → M[b] = w // map low black number to high free number\n                w = w - 1 // decrement for next\n    No → // mapping complete\n→ Step 5: Function pick:\n    → Step 5a: Generate random integer k in [0, m-1] // use built-in random\n    → Decision: If k in M? // if mapped\n        Yes → Return M[k] // return mapped high number\n        No → Return k // otherwise return k\nEnd\n\nWe need to produce each line. Use arrow \"→\" and indent? Example uses indentation. We'll do same. Also include explanation comments after //. Provide short explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n、blacklist，計算 m = n - len(blacklist) // 允許的數字總數  \n→ Step 2: 建立集合 B = set(blacklist) // 方便 O(1) 判斷  \n→ Step 3: 初始化空字典 M // 用於存放黑名單 < m 的對應值  \n→ Step 4: 設定指標 w = n-1 // 從最大值開始搜尋可用的高位數字  \n→ Decision: 需要對黑名單進行映射?  \n    Yes → Step 5: 遍歷 blacklist  \n        → Decision: 如果 b < m? // 只處理低於允許範圍的黑名單  \n            Yes → Decision: 當 w 屬於 B? // 找到下一個非黑名單高位數字  \n                Yes → w = w - 1 // 向左搜尋  \n            No → M[b] = w // 建立映射  \n                w = w - 1 // 更新指標以備下一次  \n        No → // b >= m，無需映射  \n    No → // 所有需要的映射已完成  \n→ Step 6: 函式 pick()  \n    → Step 6a: 產生隨機整數 k ∈ [0, m-1] // 只呼叫一次 random  \n    → Decision: k 是否存在於 M?  \n        Yes → Return M[k] // 取對應的高位數字  \n        No → Return k // 直接回傳 k  \nEnd // 程式執行結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy7fmnqe0.py\", line 60, in <module>\n    main()\n  File \"/tmp/tmpy7fmnqe0.py\", line 39, in main\n    ops = json.loads(ops_str)\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 10 (char 9)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.key_to_val = {}\n\n    def insert(self, key: str, val: int) -> None:\n        old_val = self.key_to_val.get(key, 0)\n        delta = val - old_val\n        self.key_to_val[key] = val\n        node = self.root\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += delta\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the input into two parts: operations and arguments\n    ops_str, args_str = data.split(',', 1)\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MapSum\":\n            obj = MapSum()\n            results.append(None)  # Constructor returns null\n        elif op == \"insert\":\n            obj.insert(arg[0], arg[1])\n            results.append(None)  # insert returns null\n        elif op == \"sum\":\n            results.append(obj.sum(arg[0]))\n        else:\n            # Unknown operation, skip or raise error\n            results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, using arrow notation and explanation. Should design algorithm for MapSum: maintain a trie with cumulative sums. Insert updates difference. sum traverses prefix. So virtual steps: Start, initialize trie node root, dictionary for key->value. Insert: compute delta = val - oldVal (or 0). Update key map. Traverse trie, add delta to sum field of nodes along key. Sum: traverse prefix; if node missing return 0; else return node.sum. End.\n\nWe output each line with arrow and comment. Need to use Decision blocks. Let's produce step-by-step:\n\nStart\n→ Step 1: 初始化 TrieNode root, map keyToVal // create root and dictionary\n\nInsert method:\n→ Step 2: 定義函式 insert(key, val)\n→ Decision: key 是否已存在? // check oldVal\n    Yes → Step 3: oldVal = keyToVal[key] // retrieve previous\n    No  → Step 3: oldVal = 0 // no previous value\n→ Step 4: delta = val - oldVal // difference to update sums\n→ Step 5: keyToVal[key] = val // store new value\n→ Step 6: node = root // start at root\n→ Step 7: for each character ch in key\n    → Step 8: 如果 node.children[ch] 不存在，創建新 TrieNode\n    → Step 9: node = node.children[ch] // 移至子節點\n    → Step 10: node.sum += delta // 更新此節點的累計值\nEnd of insert\n\nSum method:\n→ Step 11: 定義函式 sum(prefix)\n→ Step 12: node = root\n→ Step 13: for each character ch in prefix\n    → Decision: node.children[ch] 是否存在?\n        Yes → Step 14: node = node.children[ch]\n        No  → Step 15: return 0 // 前綴不存在\n→ Step 16: return node.sum // 返回前綴的總和\n\nEnd\n\nWe need to follow output format: each line \"虛擬碼步驟 // 解釋\". Use arrows like \"→\". For Decision, need indentation? Provide as example.\n\nLet's produce. Ensure to start with \"Start\" line. Use Chinese. Provide line numbers? Not necessary. Just each line.\n\nAlso maybe include indentation spaces for decision branches. The format examples show indentation with spaces before Yes / No lines. So we need to indent them appropriately. Let's match style.\n\nI'll produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 TrieNode root, map keyToVal // 建立根節點與鍵值映射\n→ Step 2: 定義函式 insert(key, val) // 插入鍵值對\n    → Decision: key 是否已存在? // 檢查舊值\n        Yes → Step 3: oldVal = keyToVal[key] // 取得舊值\n        No  → Step 3: oldVal = 0 // 若不存在，舊值為 0\n→ Step 4: delta = val - oldVal // 計算差值以更新累計\n→ Step 5: keyToVal[key] = val // 更新鍵值映射\n→ Step 6: node = root // 從根節點開始\n→ Step 7: for each char ch in key\n    → Step 8: 如果 node.children[ch] 不存在，則 node.children[ch] = new TrieNode() // 建立新節點\n    → Step 9: node = node.children[ch] // 移動到子節點\n    → Step 10: node.sum += delta // 更新此節點的總和\n→ End // 插入結束\n\n→ Step 11: 定義函式 sum(prefix) // 計算前綴總和\n→ Step 12: node = root // 從根節點開始\n→ Step 13: for each char ch in prefix\n    → Decision: node.children[ch] 是否存在?\n        Yes → Step 14: node = node.children[ch] // 移動到子節點\n        No  → Step 15: return 0 // 前綴不存在，總和為 0\n→ Step 16: return node.sum // 返回前綴的總和\n\nEnd // 程式執行結束\n\nBut we need to follow format exactly: each line starts with something like \"→ Step X:\" or \"Decision:\" etc. For End, we might write \"End // 程式執行結束\". But earlier they used \"End\". Should we indent? They used \"End // 程式執行結束\". So we can.\n\nAlso inside for loops, maybe not necessary to indent but okay.\n\nBut they want each line with arrow and comment. So we need to maintain the \"→\" arrow for all steps, except \"Start\" and \"End\". For decisions, \"Decision:\" line should not have arrow? Example shows:\n\nDecision: 如果數字大於 0? // ...\n\nYes → Step 2: ...\n\nSo \"Decision:\" line not arrow. The Yes / No lines have arrow.\n\nThus we need to reflect that.\n\nLet's produce final output with lines as specified.\n\nAlso \"→ End\" maybe not used; we just put \"End\".\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 TrieNode root, map keyToVal // 建立根節點與鍵值映射\n\n→ Step 2: 定義函式 insert(key, val) // 插入鍵值對\nDecision: key 是否已存在? // 檢查舊值\n    Yes → Step 3: oldVal = keyToVal[key] // 取得舊值\n    No  → Step 3: oldVal = 0 // 若不存在，舊值為 0\n→ Step 4: delta = val - oldVal // 計算差值以更新累計\n→ Step 5: keyToVal[key] = val // 更新鍵值映射\n→ Step 6: node = root // 從根節點開始\n→ Step 7: for each char ch in key\n    → Step 8: 如果 node.children[ch] 不存在，則 node.children[ch] = new TrieNode() // 建立新節點\n    → Step 9: node = node.children[ch] // 移動到子節點\n    → Step 10: node.sum += delta // 更新此節點的總和\n\n→ Step 11: 定義函式 sum(prefix) // 計算前綴總和\n→ Step 12: node = root // 從根節點開始\n→ Step 13: for each char ch in prefix\n    Decision: node.children[ch] 是否存在?\n        Yes → Step 14: node = node.children[ch] // 移動到子節點\n        No  → Step 15: return 0 // 前綴不存在，總和為 0\n→ Step 16: return node.sum // 返回前綴的總和\n\nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.49861334184602185,0.38888762599454385],[-0.551179446879501,-0.13065059564096226],[-0.425980228696782,-0.2827541161073029]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.49861334184602185, 0.38888762599454385], [-0.551179446879501, -0.13065059564096226], [-0.425980228696782, -0.2827541161073029]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 用極座標隨機產生點，確保均勻分佈\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    # 解析方法名稱與對應參數\n    funcs = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    obj = None\n    outputs = []\n\n    for func, args in zip(funcs, args_list):\n        if func == \"Solution\":\n            obj = Solution(*args)\n            outputs.append(None)          # 建構子回傳 null\n        elif func == \"randPoint\":\n            outputs.append(obj.randPoint())\n        else:\n            # 若有其他方法，可在此處擴充\n            outputs.append(None)\n\n    # 輸出結果，使用 JSON 形式\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, no actual code. Use Start, End, Decision, etc. Steps: initialize with radius, center. randPoint: generate random angle, random radius via sqrt of random to ensure uniform distribution. Compute x = x_center + r*cos(theta), y similar. Return. Include explanation comments.\n\nWe need to produce step-by-step virtual code. Should include algorithm. Let's write:\n\nStart // program start\n→ Step 1: Store radius, center coordinates // Save parameters\n→ Step 2: Define randPoint method // Method to generate random point\n→ Inside randPoint:\n    → Step 3: Generate random u in [0,1) // uniform\n    → Step 4: Compute r = radius * sqrt(u) // radius scaling for uniform\n    → Step 5: Generate random theta in [0,2π) // angle\n    → Step 6: Compute x = x_center + r * cos(theta)\n    → Step 7: Compute y = y_center + r * sin(theta)\n    → Step 8: Return [x, y]\nEnd\n\nAlso maybe Decision: None. We can include Decision for random? Not needed.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\". Provide arrow and indentation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Store radius, center_x, center_y // 儲存圓半徑與中心座標  \n→ Step 2: Define Method randPoint() // 定義產生隨機點的函式  \n\n→ Inside randPoint:  \n    → Step 3: Generate random u ∈ [0,1) // 產生均勻分布的隨機數  \n    → Step 4: Compute r = radius × sqrt(u) // 用 sqrt 使半徑分布均勻  \n    → Step 5: Generate random θ ∈ [0, 2π) // 隨機角度，覆蓋整個圓  \n    → Step 6: Compute x = center_x + r × cos(θ) // 計算 x 坐標  \n    → Step 7: Compute y = center_y + r × sin(θ) // 計算 y 坐標  \n    → Step 8: Return [x, y] // 回傳隨機點的座標  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Count Different Palindromic Subsequences",
      "source_file": "Leetcode/leetcode730.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '104860361'\nGot (Norm):      '116681050'\n--- (Raw) ---\nRaw Expected: '104860361'\nRaw Got:      '116681050'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # 预处理每个位置右侧最近相同字符的位置\n    next_pos = [[-1] * 26 for _ in range(n + 1)]\n    last = [-1] * 26\n    for i in range(n - 1, -1, -1):\n        last[ord(s[i]) - 97] = i\n        next_pos[i] = last.copy()\n\n    # 预处理每个位置左侧最近相同字符的位置\n    prev_pos = [[-1] * 26 for _ in range(n)]\n    last = [-1] * 26\n    for i in range(n):\n        prev_pos[i] = last.copy()\n        last[ord(s[i]) - 97] = i\n\n    # dp[i][j] 表示子串 s[i..j] 的不同回文子序列数\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1  # 单字符本身就是回文\n        for j in range(i + 1, n):\n            if s[i] != s[j]:\n                dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]) % MOD\n            else:\n                c = ord(s[i]) - 97\n                l = next_pos[i + 1][c]   # i 右侧最近相同字符的位置\n                r = prev_pos[j - 1][c]   # j 左侧最近相同字符的位置\n                if l > r:          # 子串内没有相同字符\n                    dp[i][j] = 2\n                elif l == r:       # 子串内恰好一个相同字符\n                    dp[i][j] = (dp[i + 1][j - 1] + 2) % MOD\n                else:              # 子串内有两个或更多相同字符\n                    dp[i][j] = (dp[i + 1][j - 1] * 2 - dp[l + 1][r - 1]) % MOD\n            dp[i][j] = (dp[i][j] + MOD) % MOD  # 保证非负\n\n    return dp[0][n - 1]\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 从输入中提取字符串，支持两种格式：s = \"abc\" 或 直接输入 abc\n    match = re.search(r'\"([^\"]*)\"', data)\n    s = match.group(1) if match else data.strip()\n    if not s:\n        print(0)\n        return\n    result = count_palindromic_subsequences(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for counting distinct non-empty palindromic subsequences modulo 1e9+7. Classic problem: Count different palindromic subsequences in string s. DP approach with dp[l][r] counts. Use 2D dp and next/prev arrays for each character.\n\nWe need to output virtual code steps line by line with explanation. We must not output actual code, only virtual pseudocode with arrow.\n\nLet's produce algorithm steps:\n\nStart\n→ Input string s\n→ Let n = length\n→ Define MOD = 1e9+7\n→ Create array nextPos[n][26] and prevPos[n][26]\n→ Compute nextPos and prevPos\n→ Initialize dp[n][n] 2D array\n→ For i from n-1 downto 0:\n    → For j from i to n-1:\n        → If i == j:\n            → dp[i][j] = 1 // single char palindrome\n        → Else:\n            → Let lChar = s[i], rChar = s[j]\n            → If lChar != rChar:\n                → dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]\n            → Else:\n                → nextIdx = nextPos[i][lChar]\n                → prevIdx = prevPos[j][lChar]\n                → If nextIdx > prevIdx: // no same char inside\n                    → dp[i][j] = 2 // two palindromes: lChar and lChar...lChar (just lChar)\n                → Else if nextIdx == prevIdx: // one same char inside\n                    → dp[i][j] = dp[i+1][j-1] + 2\n                → Else: // more than one same char inside\n                    → dp[i][j] = dp[i+1][j-1] * 2 - dp[nextIdx+1][prevIdx-1]\n            → dp[i][j] = (dp[i][j] % MOD + MOD) % MOD // ensure positive\n→ Result = dp[0][n-1]\n→ Output result\nEnd\n\nWe need to produce step lines with explanation. Each step might include loops and conditions. Use arrow syntax. We must not output actual code. So we can produce lines like:\n\nStart // 程式開始執行\n→ Input string s // 取得輸入字串\n→ Let n = length(s) // 字串長度\n→ Define MOD = 1e9+7 // 模數\n→ Create 2D array nextPos[n][26] // 下一個相同字母的位置\n→ Create 2D array prevPos[n][26] // 上一個相同字母的位置\n→ Compute nextPos from right to left // 填寫下一個位置表\n→ Compute prevPos from left to right // 填寫上一個位置表\n→ Create 2D array dp[n][n] // dp[i][j] 代表子字串 i~j 的不同回文子序列數\n→ Decision: for i from n-1 downto 0? But we need loops.\n\nWe need to produce structured pseudo-code lines. For loops we can write e.g.:\n\n→ For i = n-1 downto 0: // 外層循環\n    → For j = i to n-1: // 內層循環\n\nBut arrow lines need to be indented. We can just put indentation with spaces or tabs. Use arrow for lines inside loops. Provide explanation.\n\nLet's produce final output accordingly.\n\nEnsure each line ends with `// 解釋`. Use proper indentation. Use Start, End.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input string s // 取得輸入字串  \n→ Let n = length(s) // 取得字串長度  \n→ Define MOD = 1000000007 // 取模數  \n→ Create 2D array nextPos[n][26] // 用於記錄每個位置右側最近的相同字母  \n→ Create 2D array prevPos[n][26] // 用於記錄每個位置左側最近的相同字母  \n→ Decision: 初始化 nextPos 為 -1? // 若未找到，保持 -1  \n    Yes → Set all nextPos[i][c] = -1 // 預設為不存在  \n    No  → （不執行）  \n→ Decision: 初始化 prevPos 為 -1? // 若未找到，保持 -1  \n    Yes → Set all prevPos[i][c] = -1 // 預設為不存在  \n    No  → （不執行）  \n→ For i = n-1 downto 0: // 從右向左掃描每個位置  \n    → For c = 0 to 25: // 26 個字母  \n        → nextPos[i][c] = nextPos[i+1][c] // 初始化為右側的下一個位置  \n    → Let idx = s[i] - 'a' // 對應的字母索引  \n    → nextPos[i][idx] = i // 更新當前位置為最近  \n→ For i = 0 to n-1: // 從左向右掃描每個位置  \n    → For c = 0 to 25: // 26 個字母  \n        → prevPos[i][c] = prevPos[i-1][c] // 初始化為左側的上一個位置  \n    → Let idx = s[i] - 'a' // 對應的字母索引  \n    → prevPos[i][idx] = i // 更新當前位置為最近  \n→ Create 2D array dp[n][n] // dp[i][j] 存放子字串 s[i..j] 的不同回文子序列數  \n→ For i = n-1 downto 0: // 外層循環從右往左  \n    → For j = i to n-1: // 內層循環從左到右  \n        → Decision: i == j? // 子字串長度為 1  \n            Yes → dp[i][j] = 1 // 單字符本身即為回文  \n            No  → Decision: s[i] != s[j]? // 還是不同字母  \n                Yes → dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] // 排除重複計算  \n                No  → // s[i] == s[j] 時的處理  \n                    → Let l = nextPos[i][s[i]-'a'] // i 右側最近同字母的位置  \n                    → Let r = prevPos[j][s[j]-'a'] // j 左側最近同字母的位置  \n                    → Decision: l > r? // 右側沒有同字母或右側位於左側左邊  \n                        Yes → dp[i][j] = 2 // 兩種回文：單字母和兩端字母形成的回文  \n                        No  → Decision: l == r? // 右側與左側相同位置，只有一個相同字母在內部  \n                            Yes → dp[i][j] = dp[i+1][j-1] + 2 // 加上兩端形成的回文  \n                            No  → // 內部有多於一個相同字母  \n                                → dp[i][j] = dp[i+1][j-1] * 2 - dp[l+1][r-1] // 避免重複計算  \n                    → dp[i][j] = (dp[i][j] % MOD + MOD) % MOD // 取模並確保非負  \n→ Result = dp[0][n-1] // 整個字串的答案  \n→ Output Result // 顯示最終答案  \nEnd // 程式執行結束"
    },
    {
      "title": "4Sum",
      "source_file": "Leetcode/leetcode18.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,0,-1,0,-2,2], target = 0",
          "expected_output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuzn1nevd.py\", line 52, in <module>\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2], target = 8",
          "expected_output": "[[2,2,2,2]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmt2t62fa.py\", line 52, in <module>\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def fourSum(self, nums, target):\n        \"\"\"\n        找出 nums 中所有不重複的四元組，使其和為 target。\n        使用排序 + 兩指針 + 重複值排除。\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        res = []\n\n        for i in range(n - 3):\n            # 跳過重複的第一個數字\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                # 跳過重複的第二個數字\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        # 移動左指針，跳過重複\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        # 移動右指針，跳過重複\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入格式: 例如 \"nums = [1,0,-1,0,-2,2], target = 0\"\n    parts = data.split(',')\n    # 第一部分包含 nums\n    nums_part = parts[0].strip()\n    nums_str = nums_part.split('=', 1)[1].strip()\n    nums = ast.literal_eval(nums_str)\n\n    # 第二部分包含 target\n    target_part = parts[1].strip()\n    target_str = target_part.split('=', 1)[1].strip()\n    target = int(target_str)\n\n    solution = Solution()\n    result = solution.fourSum(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output a virtual code that solves 4-sum unique quadruplets. Provide step-by-step pseudocode with arrows, decisions. Each line: virtual code step + space + // explanation. Must not output actual code. Use structure Start, End, Decision: with arrows. We need to include sorting array, nested loops, two pointers, skip duplicates. Provide explanation for each step. Let's produce.\n\nWe should include steps: sort array, initialize result list, outer loop i, skip duplicates, second loop j, skip duplicates, left, right pointers, sum, adjust, skip duplicates when found. Add quadruplet to result. Finally return result.\n\nMake sure each line includes `→` arrow. For decisions use `Decision:` lines. Let's produce.\n\nUse Start //.\n\nWe need to ensure arrow formatting: each step line starts with `→` and colon maybe. Eg: `→ Step 1: Sort nums ascending // Sort input array`.\n\nAlso need to include Decision lines: `Decision: If i > 0 and nums[i] == nums[i-1]? // Skip duplicate i`. Then Yes → `Continue to next i`. No → continue.\n\nSimilarly for j.\n\nAlso decision for sum < target or > target.\n\nFor duplicates after moving pointers: decision skip duplicates.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums in ascending order // 先將輸入陣列排序，方便後續兩指針與重複值排除  \n→ Step 2: 初始化 result 為空集合 // 用來存放所有符合條件的四元組  \n→ Step 3: 迴圈 i 從 0 到 n-4 // 第一個元素的索引  \n  Decision: i > 0 且 nums[i] == nums[i-1]? // 檢查 i 是否為重複值  \n   Yes → Continue // 若重複，跳過此 i  \n   No  → Step 4: 迴圈 j 從 i+1 到 n-3 // 第二個元素的索引  \n    Decision: j > i+1 且 nums[j] == nums[j-1]? // 檢查 j 是否為重複值  \n     Yes → Continue // 若重複，跳過此 j  \n     No  → Step 5: 設定 left = j+1, right = n-1 // 開始兩指針搜尋剩餘兩個元素  \n     → Decision: left < right? // 判斷指針是否重疊  \n      Yes → Step 6: 計算 sum = nums[i] + nums[j] + nums[left] + nums[right] // 目前四個數之和  \n       Decision: sum == target? // 是否符合目標  \n         Yes → Step 7: 將 [nums[i], nums[j], nums[left], nums[right]] 加入 result // 記錄符合的四元組  \n          → Step 8: 左移 left 同時跳過重複 // 移動左指針並排除重複值  \n           → Decision: left < right 且 nums[left] == nums[left-1]? // 檢查是否仍重複  \n             Yes → Continue // 若重複，繼續左移  \n             No  → Continue // 否則繼續下一步  \n           → Step 9: 右移 right 同時跳過重複 // 移動右指針並排除重複值  \n            → Decision: left < right 且 nums[right] == nums[right+1]? // 檢查是否仍重複  \n             Yes → Continue // 若重複，繼續右移  \n             No  → Continue // 否則繼續下一步  \n           → Step 10: 右移 right // 如果 sum > target，右移右指針  \n           → Decision: sum > target?  \n            Yes → Step 10: 右移 right // 右移右指針  \n            No  → Step 11: 左移 left // 若 sum < target，左移左指針  \n            → Decision: sum < target?  \n             Yes → Step 11: 左移 left // 左移左指針  \n             No  → Step 6 // 重新計算 sum，持續迴圈  \n             → Decision: left < right? // 判斷是否還有可能組合  \n              Yes → Step 6  \n              No  → Back to Step 4 (j 迴圈)  \n             → Decision: j < n-3? // j 迴圈是否結束  \n              Yes → Continue  \n             No  → Back to Step 3 (i 迴圈)  \n            → Decision: i < n-4? // i 迴圈是否結束  \n             Yes → Continue  \n            No  → End // 完成所有四元組搜尋  \nEnd // 程式執行結束，result 為所有符合條件的唯一四元組集合"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,2,1],[1,2,3],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [3, 2, 1], [1, 2, 3], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列的深拷貝\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列的拷貝\n        return list(self.original)\n\n    def shuffle(self):\n        # 使用 Fisher‑Yates 洗牌演算法\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef main():\n    input_str = sys.stdin.read().strip()\n    if not input_str:\n        return\n    # 解析輸入成 (operations, arguments) 的二元組\n    data = ast.literal_eval('(' + input_str + ')')\n    operations, arguments = data\n\n    result = []\n    obj = None\n\n    for op, arg in zip(operations, arguments):\n        if op == \"Solution\":\n            # arg 會是 [[1,2,3]] 這樣的結構\n            obj = Solution(arg[0])\n            result.append(None)\n        elif op == \"reset\":\n            result.append(obj.reset())\n        elif op == \"shuffle\":\n            result.append(obj.shuffle())\n        else:\n            result.append(None)\n\n    # 使用 JSON 格式輸出，確保 null 的輸出正確\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the described algorithm: shuffling array with uniform distribution, using Fisher-Yates. Implementation in a class with constructor storing original array copy, reset returning copy, shuffle returning random shuffle using Fisher-Yates.\n\nWe need to output line by line virtual code with explanation. Use arrow notation. So each line: \"虛擬碼步驟 // 解釋\". Must not output actual code. Should describe steps conceptually.\n\nLet's outline:\n\nStart // start program\n→ Step 1: 定義類 Solution // 定義類別\n    → Step 1.1: 定義成員變數 originalList // 存儲原始陣列\n    → Step 1.2: 定義成員變數 currentList // 存儲目前陣列\n→ Step 2: 構造函式 Solution(nums) // 初始化\n    → Step 2.1: 把 nums 的深拷貝存到 originalList // 保存原始順序\n    → Step 2.2: 把 nums 的深拷貝存到 currentList // 初始化目前陣列\n→ Step 3: 方法 reset() // 重置\n    → Step 3.1: 把 originalList 的深拷貝賦值給 currentList // 恢復原始順序\n    → Step 3.2: 返回 currentList // 回傳重置後陣列\n→ Step 4: 方法 shuffle() // 隨機打亂\n    → Step 4.1: 對 currentList 進行 Fisher-Yates 隨機化\n        → Step 4.1.1: 對 i 從 len-1 下降到 1\n            → Step 4.1.1.1: 隨機產生 j 在 0~i 之間\n            → Step 4.1.1.2: 交換 currentList[i] 與 currentList[j] // 交換元素\n    → Step 4.2: 返回 currentList // 回傳隨機排列\nEnd // 結束\n\nNeed to use arrow symbols as per guidelines: \"Start\", \"End\", \"Decision:\" maybe not needed here. But we can use \"→\" for steps.\n\nLet's produce lines accordingly.\n\nRemember to not output actual code. Use only virtual steps.\n\nLet's produce the final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類 Solution // 建立 Solution 類別  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 1.1: 定義成員變數 originalList // 用來儲存輸入的原始陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 1.2: 定義成員變數 currentList // 用來儲存目前的陣列狀態  \n→ Step 2: 构造函式 Solution(nums) // 初始化物件  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 2.1: 把 nums 的深拷貝存到 originalList // 保留原始順序  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 2.2: 把 nums 的深拷貝存到 currentList // 初始化目前陣列  \n→ Step 3: 方法 reset() // 重置陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3.1: 把 originalList 的深拷貝賦值給 currentList // 回到原始順序  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3.2: 返回 currentList // 輸出重置後的陣列  \n→ Step 4: 方法 shuffle() // 隨機打亂陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.1: 對 currentList 進行 Fisher‑Yates 隨機化  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.1.1: 從 i = len(currentList) - 1 下降到 1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.1.1.1: 隨機產生 j 在 0 ~ i 之間  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.1.1.2: 交換 currentList[i] 與 currentList[j] // 交換兩個元素  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.2: 返回 currentList // 輸出隨機排列的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 若輸入包含「nums = 」前綴，先移除之\n    if data.startswith(\"nums\"):\n        _, nums_str = data.split(\"=\", 1)\n        nums_str = nums_str.strip()\n    else:\n        nums_str = data\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        # 若解析失敗，直接輸出空列表\n        print([])\n        sys.exit()\n    result = Solution().subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, for generating all subsets of unique integer array. Should use arrows, decisions, etc. Provide each line of virtual code with explanation. Should not output actual code. Should be in Chinese, presumably Traditional Chinese. Use \"虛擬碼步驟\" but they don't specify exact syntax. In example, they used \"Step 1:\" etc. So we can produce similar lines: Start, Step, Decision, etc. Also include \"→\". Each line must have virtual code + space + comment // explanation.\n\nWe must cover algorithm: backtracking. Steps: start, input array, initialize result list, define backtrack function, iterate over indices, include current element, exclude, etc. End.\n\nWe need to output each line separately.\n\nLet's produce:\n\nStart\n→ Step 1: 接收 nums // 取得輸入陣列\n→ Step 2: 初始化 subsets = [] // 用來儲存所有子集\n→ Step 3: 定義 backtrack(index, current) // 回溯函式\n    → Step 4: Add copy of current to subsets // 將目前子集加入結果\n    → Decision: 如果 index == len(nums)？ // 檢查是否已遍歷完所有元素\n        Yes → Return // 結束此路徑\n        No  → \n            → Step 5: backtrack(index + 1, current + [nums[index]]) // 包含 nums[index]\n            → Step 6: backtrack(index + 1, current) // 排除 nums[index]\n→ Step 7: 呼叫 backtrack(0, []) // 開始回溯\n→ Step 8: 返回 subsets // 回傳所有子集\nEnd\n\nMake sure each line includes arrow and comment.\n\nLet's produce output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收 nums // 取得輸入陣列  \n→ Step 2: 初始化 subsets = [] // 用來儲存所有子集  \n→ Step 3: 定義 backtrack(index, current) // 回溯函式  \n  → Step 4: Add copy of current to subsets // 將目前子集加入結果  \n  → Decision: 如果 index == len(nums)？ // 檢查是否已遍歷完所有元素  \n   Yes → Return // 結束此路徑  \n   No  →  \n    → Step 5: backtrack(index + 1, current + [nums[index]]) // 包含 nums[index]  \n    → Step 6: backtrack(index + 1, current) // 排除 nums[index]  \n→ Step 7: 呼叫 backtrack(0, []) // 開始回溯  \n→ Step 8: 返回 subsets // 回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfrgf4nri.py\", line 82, in <module>\n    main()\n  File \"/tmp/tmpfrgf4nri.py\", line 61, in main\n    args = ast.literal_eval('[' + parts[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}          # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key: int):\n        value, freq = self.key_to_val_freq[key]\n        # Remove from old frequency list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add to new frequency list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used key (and LRU among them)\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        ops = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip())\n    else:\n        # In case both parts are on the same line separated by a comma\n        parts = data.split('],', 1)\n        ops = ast.literal_eval(parts[0] + ']')\n        args = ast.literal_eval('[' + parts[1].strip())\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == 'LFUCache':\n            obj = LFUCache(arg[0])\n            res.append(None)\n        elif op == 'put':\n            obj.put(arg[0], arg[1])\n            res.append(None)\n        elif op == 'get':\n            val = obj.get(arg[0])\n            res.append(val)\n        else:\n            # Unsupported operation; ignore\n            res.append(None)\n    # Convert results to LeetCode style string (null for None)\n    output = '[' + ', '.join('null' if v is None else str(v) for v in res) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanations, following the format. It's a design of LFUCache with O(1) operations.\n\nWe should produce step-by-step algorithm for initialization, get, put, internal functions. We'll use data structures: hash map key->Node, doubly linked list of frequency nodes, each freq node has list of keys, also map freq->freq node, and maintain minFreq. This is typical. We'll produce virtual code for class, constructor, get, put, helper increaseFreq, removeNode, evict. We'll show steps.\n\nWe need to produce line by line, each line with virtual code + // explanation. Use arrows \"→\". Use Decision: and Yes →, No →. Use Start and End.\n\nWe need to present pseudo-code of algorithm, not actual code.\n\nWe'll produce a structure:\n\nStart // 程式開始執行\n→ Step 1: Define class LFUCache // 定義LFUCache類別\n\nThen inside class:\n\n→ Step 2: Declare capacity, minFreq, keyMap, freqMap // 宣告容量、最小頻率、鍵到節點、頻率到節點的映射\n\nConstructor:\n\n→ Step 3: LFUCache(capacity) // 初始化\n→ Decision: 如果 capacity <= 0? // 檢查容量有效性\n    Yes → Step 4: Set capacity = 0 // 設為 0 以避免後續操作\n    No  → Step 5: Set capacity as given // 正常設置\n\nSet minFreq = 0 // 初始化最小頻率\n\nGet:\n\n→ Step 6: get(key) // 取得鍵\n→ Decision: 如果 key 在 keyMap? // 判斷鍵是否存在\n    Yes → Step 7: node = keyMap[key] // 取出節點\n    → Step 8: increaseFreq(node) // 更新頻率\n    → Step 9: return node.value // 返回值\n    No  → Step 10: return -1 // 不存在\n\nPut:\n\n→ Step 11: put(key, value) // 插入或更新\n→ Decision: capacity == 0? // 如果容量為 0\n    Yes → Step 12: return // 直接返回不做任何事\n    No  → Step 13: \n\n→ Decision: 如果 key 在 keyMap? // 判斷鍵已存在\n    Yes → Step 14: node = keyMap[key]\n    → Step 15: node.value = value // 更新值\n    → Step 16: increaseFreq(node) // 更新頻率\n    No  → Step 17: Decision: keyMap.size == capacity? // 是否已滿\n        Yes → Step 18: evict() // 淘汰最少頻率且最舊的鍵\n        No  → Step 19: // 無需淘汰\n    → Step 20: create new node with freq=1, value\n    → Step 21: insert node into freq 1 list\n    → Step 22: keyMap[key] = node\n    → Step 23: minFreq = 1 // 重設最小頻率\n\nHelper increaseFreq:\n\n→ Step 24: increaseFreq(node) // 提升頻率\n→ Step 25: oldFreq = node.freq\n→ Step 26: remove node from freqList[oldFreq]\n→ Decision: freqList[oldFreq] empty? // 若舊頻率清空\n    Yes → Step 27: delete freqList[oldFreq]\n    → Decision: oldFreq == minFreq? // 若舊頻率是最小頻率\n        Yes → Step 28: minFreq += 1 // 更新最小頻率\n        No  → Step 29: // 不變\n    No  → Step 30: // 不須刪除\n→ Step 31: node.freq += 1\n→ Step 32: add node to freqList[newFreq]\n→ Step 33: return\n\nHelper evict:\n\n→ Step 34: evict() // 淘汰\n→ Step 35: freqNode = freqList[minFreq] // 取得最小頻率列表\n→ Step 36: lruNode = freqNode.head // 取得最舊節點（LRU）\n→ Step 37: remove lruNode from freqNode\n→ Decision: freqNode empty? // 若此頻率列表空\n    Yes → Step 38: delete freqNode\n    No  → Step 39: // 不須刪除\n→ Step 40: delete keyMap[lruNode.key] // 刪除鍵映射\n→ Step 41: return\n\nWe need to output line by line. Also include Start and End.\n\nMake sure to prefix each line with virtual code and a space before comment.\n\nLet's produce lines accordingly.\n\nAlso need indentation with arrows. Use \"→\" at start of each step except Start and End.\n\nAlso include decisions with indentation.\n\nWe need to ensure we don't output actual code like class definitions, but pseudo-code.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class LFUCache // 定義 LFUCache 類別  \n→ Step 2: Declare capacity, minFreq, keyMap, freqMap // 宣告容量、最小頻率、鍵到節點、頻率到節點的映射  \n\n// ---------- 建構子 ----------\n→ Step 3: LFUCache(capacity) // 初始化 LFUCache  \n→ Decision: 如果 capacity <= 0? // 檢查容量有效性  \n  Yes → Step 4: Set capacity = 0 // 設為 0 以避免後續操作  \n  No  → Step 5: Set capacity as given // 正常設置  \n→ Step 6: Set minFreq = 0 // 初始化最小頻率  \n\n// ---------- 取得 ----------\n→ Step 7: get(key) // 取得鍵值  \n→ Decision: 如果 key 在 keyMap? // 判斷鍵是否存在  \n  Yes → Step 8: node = keyMap[key] // 取得節點  \n   → Step 9: increaseFreq(node) // 更新頻率  \n   → Step 10: return node.value // 返回值  \n  No  → Step 11: return -1 // 鍵不存在  \n\n// ---------- 插入/更新 ----------\n→ Step 12: put(key, value) // 插入或更新鍵  \n→ Decision: 如果 capacity == 0? // 容量為 0 時不做任何事  \n  Yes → Step 13: return // 直接返回  \n  No  → Step 14: // 繼續  \n\n→ Decision: 如果 key 在 keyMap? // 鍵已存在  \n  Yes → Step 15: node = keyMap[key] // 取出節點  \n   → Step 16: node.value = value // 更新值  \n   → Step 17: increaseFreq(node) // 更新頻率  \n  No  → Step 18: Decision: keyMap.size == capacity? // 是否已滿  \n    Yes → Step 19: evict() // 淘汰最少頻率且最舊的鍵  \n    No  → Step 20: // 不需要淘汰  \n\n→ Step 21: Create new node with freq = 1, value = value // 建立新節點  \n→ Step 22: Insert node into freqList[1] // 將節點加入頻率為 1 的列表  \n→ Step 23: keyMap[key] = node // 更新鍵到節點映射  \n→ Step 24: Set minFreq = 1 // 重設最小頻率  \n\n// ---------- 提升頻率 ----------\n→ Step 25: increaseFreq(node) // 提升節點頻率  \n→ Step 26: oldFreq = node.freq // 取得舊頻率  \n→ Step 27: Remove node from freqList[oldFreq] // 從舊頻率列表移除  \n→ Decision: 如果 freqList[oldFreq] 為空? // 檢查舊頻率列表是否清空  \n  Yes → Step 28: Delete freqList[oldFreq] // 刪除空列表  \n   → Decision: 如果 oldFreq == minFreq? // 是否為最小頻率  \n    Yes → Step 29: minFreq += 1 // 更新最小頻率  \n    No  → Step 30: // 無需改動  \n  No  → Step 31: // 舊頻率列表仍有節點  \n→ Step 32: node.freq += 1 // 增加頻率  \n→ Step 33: Add node to freqList[node.freq] // 加入新頻率列表  \n→ Step 34: return // 完成提升頻率  \n\n// ---------- 淘汰 ----------\n→ Step 35: evict() // 淘汰最少頻率且最舊的鍵  \n→ Step 36: freqNode = freqList[minFreq] // 取得最小頻率列表  \n→ Step 37: lruNode = freqNode.head // 取得最舊節點（LRU）  \n→ Step 38: Remove lruNode from freqNode // 從列表移除  \n→ Decision: 如果 freqNode 為空? // 檢查此頻率列表是否空  \n  Yes → Step 39: Delete freqNode // 刪除空列表  \n  No  → Step 40: // 無需刪除  \n→ Step 41: Delete keyMap[lruNode.key] // 刪除鍵映射  \n→ Step 42: return // 完成淘汰  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"建立前綴和，方便二分搜尋\"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"隨機挑選一個索引，機率與權重成正比\"\"\"\n        target = random.randint(1, self.total)  # 產生 1 ~ total 的整數\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 把輸入包裝成 JSON 數組，方便解析\n    data = json.loads('[' + raw + ']')\n    commands, args = data[0], data[1]\n\n    res = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == 'Solution':\n            obj = Solution(arg[0] if isinstance(arg, list) and len(arg) == 1 else arg)\n            res.append(None)  # 建構子沒有回傳值\n        else:\n            # 其它方法只需要直接呼叫\n            method = getattr(obj, cmd)\n            if isinstance(arg, list):\n                res.append(method(*arg))\n            else:\n                res.append(method(arg))\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode in Chinese (Traditional) with arrow syntax and explanations. Need to generate the algorithm for picking index weighted random. Typically we compute prefix sums, store in array, and binary search with random. Steps: initialization: compute cumulative weights. pickIndex: generate random r in [1, total], binary search. Need to handle random function. Provide comments. Provide each line. Let's structure: Start, compute prefix sums, store. End of init? But we might include separate steps for initialization. Then pickIndex: Start -> generate r -> binary search. Use Decision: if r <= prefix[i] etc.\n\nLet's produce pseudocode lines. Each line includes \"→\" and comment after //.\n\nWe need to ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". For decisions use \"Decision:\".\n\nLet's create:\n\nStart // 程式開始執行\n\n→ Step 1: 輸入 w // 取得權重陣列\n\n→ Step 2: 初始化 pref = 空陣列 // 用來存累積權重\n\n→ Step 3: total = 0 // 用於累計總重量\n\n→ Step 4: 循環 i 從 0 到 w.length-1 // 建立累積陣列\n\n    → Decision: 若 i == 0? // 檢查是否第一個元素\n        Yes → Step 5: pref[i] = w[i] // 第一個權重直接存\n        No  → Step 6: pref[i] = pref[i-1] + w[i] // 其餘權重累加\n\n    → Step 7: total += w[i] // 更新總重量\n\n→ Step 8: 存儲 pref 與 total // 完成初始化\n\nEnd // 初始化完成\n\nNow function pickIndex:\n\nStart // pickIndex 開始\n\n→ Step 9: 生成 r = 隨機數 (1, total) // 產生 1 到 total 之間的隨機整數\n\n→ Step 10: 循環 i 從 0 到 pref.length-1 // 二分或線性搜尋\n\n    → Decision: 若 r <= pref[i]? // 找到最小符合的索引\n\n        Yes → Step 11: 返回 i // 返回對應索引\n\n        No  → Decision: 若 i == pref.length-1? // 是否到尾端？\n\n            Yes → Step 12: 返回 i // 在極端情況返回最後索引\n\n            No  → Step 13: 繼續迴圈 // 仍未找到，往後繼續\n\nEnd // pickIndex 完成\n\nBut we might want to use binary search pseudocode. But simpler linear search fine.\n\nLet's produce line by line with arrows. Use \"→\" for steps. Use \"Decision:\" lines. Ensure each line has comment. Provide start and end for pickIndex as separate.\n\nAlso note we might need to indicate separate functions: Initialization code and pickIndex. We can denote with Start, End. Provide step numbers optionally. But each line should have the code step, then // explanation.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 w // 取得權重陣列  \n→ Step 2: 初始化 pref = 空陣列 // 用來存累積權重  \n→ Step 3: total = 0 // 用於累計總重量  \n→ Step 4: 循環 i 從 0 到 w.length-1 // 建立累積陣列  \n    → Decision: 若 i == 0? // 檢查是否第一個元素  \n        Yes → Step 5: pref[i] = w[i] // 第一個權重直接存入 pref  \n        No → Step 6: pref[i] = pref[i-1] + w[i] // 其餘權重累加到前一個累積值  \n    → Step 7: total += w[i] // 更新總重量  \n→ Step 8: 存儲 pref 與 total // 完成初始化  \nEnd // 初始化完成  \n\nStart // pickIndex 開始  \n→ Step 9: 生成 r = 隨機數 (1, total) // 產生 1 到 total 之間的隨機整數  \n→ Step 10: 循環 i 從 0 到 pref.length-1 // 依序尋找最小符合的索引  \n    → Decision: 若 r <= pref[i]? // r 小於或等於當前累積權重  \n        Yes → Step 11: 返回 i // 找到符合條件的索引即為結果  \n        No → Decision: 若 i == pref.length-1? // 是否已到最後一個索引？  \n            Yes → Step 12: 返回 i // 在極端情況下返回最後索引  \n            No → Step 13: 繼續迴圈 // 仍未找到，往後搜尋  \nEnd // pickIndex 完成"
    }
  ]
}