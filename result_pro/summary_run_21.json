{
  "run_index": 21,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 398,
  "generation_or_validation_failure_count": 41,
  "failed_cases_details": [
    {
      "title": "安全除法",
      "source_file": "900.json",
      "problem_index_in_file": 0,
      "generation_error": "Failed to extract code from model response.",
      "failed_validation_details": [
        {
          "example_index": -1,
          "input": null,
          "expected_output": null,
          "actual_output_or_error": "[CLI 呼叫失敗] 'utf-8' codec can't decode byte 0xa6 in position 254: invalid start byte"
        }
      ],
      "generated_code": null,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. Use Start, End, Decision, arrows. Use try/except structure. Show reading two integers a and b, attempt to convert input to int, division, catch exceptions, and error message. We'll produce a step-by-step pseudocode.\n\nWe need to format: each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" for next steps. Use Decision lines for conditions. We'll use indentation to show nested structure maybe with tabs.\n\nWe must ensure no actual code, just virtual code steps. Use \"try\" block indicated by Step or maybe \"Step: Try: ...\". Let's craft.\n\nStart\n→ Step 1: 輸入字串 a_input // 取得第一個輸入\n→ Step 2: 輸入字串 b_input // 取得第二個輸入\n→ Step 3: 開始 try 區塊 // 進入錯誤捕捉\n    → Step 3a: 將 a_input 轉為整數 a // 轉型\n    → Step 3b: 將 b_input 轉為整數 b // 轉型\n    → Step 3c: 計算 result = a / b // 執行除法\n    → Step 3d: 輸出 result // 顯示結果\n→ Step 4: except 所有例外\n    → Step 4a: 輸出『輸入錯誤或除數為 0』 // 顯示錯誤訊息\nEnd\n\nBut need to include Decision lines for checking division by zero? However division by zero will raise exception; we can rely on except.\n\nBut may also decide: if b == 0 then error; but we can also just use except. But we can show Decision: if b == 0? but we may not need. But maybe include Decision for clarity.\n\nBetter to show Decision: if b == 0? -> error else -> division.\n\nBut the requirement: use try/except. So maybe inside try, attempt conversion and division; if any exception (ValueError, ZeroDivisionError) catch and output error. So we don't need Decision.\n\nHowever we may show a Decision: if b == 0? inside try to produce error earlier? But then no except necessary for ZeroDivision? But requirement says use try/except. So we need to use try/except. So we will show a Decision: maybe for checking if b==0 inside try, but still catch exception. But simplest: no Decision.\n\nBut the virtual code may include Decision for clarity: Decision: 是否有例外? But not necessary.\n\nWe need to produce code lines with \"→\" arrow, \"Decision:\" lines. Also we need to indent nested steps.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 輸入字串 a_input // 取得第一個輸入\n→ Step 2: 輸入字串 b_input // 取得第二個輸入\n→ Step 3: 開始 try 區塊 // 進入錯誤捕捉\n    → Step 3a: 將 a_input 轉為整數 a // 轉型\n    → Step 3b: 將 b_input 轉為整數 b // 轉型\n    → Step 3c: 計算 result = a / b // 執行除法\n    → Step 3d: 輸出 result // 顯示結果\n→ Step 4: except 所有例外\n    → Step 4a: 輸出『輸入錯誤或除數為 0』 // 顯示錯誤訊息\nEnd // 程式結束\n\nWe may include a Decision: if conversion fails? But except covers that.\n\nBut the format requires \"Decision:\" lines for conditions. Might not be necessary but it's allowed.\n\nBut maybe we add a Decision: 是否成功轉換? but that duplicates except.\n\nBetter to just use try/except.\n\nBut they specifically want \"使用 try / except 結構\". So we show that.\n\nBut we should also show inside try block a Decision: if b == 0? but we can rely on exception. But we can still show Decision: if b == 0? and then error.\n\nBut we could include Decision after conversion: Decision: b 為 0? // 檢查除數為零\n   Yes → Step: 輸出錯誤 // 直接輸出錯誤\n   No  → Step: 計算 result = a / b // 執行除法\n\nBut that would duplicate except. But it's okay as we still have try/except. We can show nested Decision inside try to short-circuit but still exception if conversion fails.\n\nLet's adopt this: In try block, after conversions, Decision if b == 0? Yes -> output error, No -> compute result. That still uses try/except for conversion errors.\n\nThus the pseudocode:\n\nStart\n→ Step 1: 輸入字串 a_input // 取得第一個輸入\n→ Step 2: 輸入字串 b_input // 取得第二個輸入\n→ Step 3: 開始 try 區塊 // 進入錯誤捕捉\n    → Step 3a: 將 a_input 轉為整數 a // 轉型\n    → Step 3b: 將 b_input 轉為整數 b // 轉型\n    → Decision: b == 0? // 檢查除數是否為零\n        Yes → Step 3c1: 輸出『輸入錯誤或除數為 0』 // 顯示錯誤訊息\n        No  → Step 3c2: 計算 result = a / b // 執行除法\n              → Step 3c3: 輸出 result // 顯示結果\n→ Step 4: except (ValueError, ZeroDivisionError) as e // 捕捉轉型或除法錯誤\n    → Step 4a: 輸出『輸入錯誤或除數為 0』 // 顯示錯誤訊息\nEnd\n\nBut the error message may display twice? But it's okay because if b==0 we output error before division; but still we catch other errors. That covers all.\n\nWe can keep as above.\n\nEnsure each line with \"虛擬碼步驟 // 解釋\". Use arrow and indent. Use \"→\" for each step, indent by tabs.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 a_input // 取得第一個輸入  \n→ Step 2: 輸入字串 b_input // 取得第二個輸入  \n→ Step 3: 開始 try 區塊 // 進入錯誤捕捉  \n  → Step 3a: 將 a_input 轉為整數 a // 轉型  \n  → Step 3b: 將 b_input 轉為整數 b // 轉型  \n  → Decision: b == 0? // 檢查除數是否為零  \n    Yes → Step 3c1: 輸出『輸入錯誤或除數為 0』 // 顯示錯誤訊息  \n    No → Step 3c2: 計算 result = a / b // 執行除法  \n      → Step 3c3: 輸出 result // 顯示結果  \n→ Step 4: except (ValueError, ZeroDivisionError) as e // 捕捉轉型或除法錯誤  \n  → Step 4a: 輸出『輸入錯誤或除數為 0』 // 顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,5,3,3,5]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 5, 3, 3, 5]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰子，回傳所有結果的串列。\n    若 n 為 0 或負數，回傳空串列。\n    \"\"\"\n    if n <= 0:\n        return []\n    return [random.randint(1, 6) for _ in range(n)]\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入的所有內容，並直接執行。\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to output a step-by-step virtual code, each line with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision:, arrow etc. So we write:\n\nStart\n→ Step 1: Import random module // import random\n→ Step 2: Define function roll_dice(n) // function definition\n→ Step 3: 初始化結果列表 // ...\n→ Step 4: Decision: If n <=0? // check input\nYes → Step 5: Return [] // empty list\nNo → Step 6: For i in range(n): // loop\n→ Step 7: 生成隨機數 1-6\n→ Step 8: Append to results\n→ Step 9: End loop\n→ Step 10: Return results\nEnd\n\nAdd explanations. Ensure each line has arrow or Start. Use virtual code syntax as described. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 匯入 random 模組，供隨機數產生  \n→ Step 2: Define function roll_dice(n) // 建立 roll_dice 函式，接受擲骰次數 n  \n→ Step 3: Initialize empty list results // 用於儲存每次擲骰得到的點數  \n→ Decision: 如果 n <= 0? // 檢查輸入的次數是否有效  \n    Yes → Step 4: Return [] // 次數不合法，直接回傳空串列  \n    No  → Step 5: For i in range(n): // 迴圈 n 次  \n        → Step 6: Generate random integer r = random.randint(1, 6) // 產生 1~6 的隨機點數  \n        → Step 7: Append r to results // 將點數加入結果列表  \n        → End // 結束迴圈  \n→ Step 8: Return results // 回傳所有擲骰結果的串列  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量 func 執行所需的秒數，並回傳四捨五入到小數點第三位的結果。\n    \"\"\"\n    start = time.perf_counter()      # 取得執行前的高精度時間\n    func(*args)                      # 執行目標函式\n    end = time.perf_counter()        # 取得執行後的高精度時間\n    elapsed = end - start            # 計算耗時\n    return round(elapsed, 3)         # 四捨五入到 3 位小數\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整段程式碼，並執行\n    input_code = sys.stdin.read()\n    # 使用 globals() 作為執行環境，讓 measure_time 可被呼叫\n    exec(input_code, globals())",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode lines, each with \"虛擬碼步驟\" and comment. Use arrow. Use time module, function measure_time(func,*args). Measure execution time in seconds, return result rounded to 3 decimal places. So steps: import time; define function; start_time = time.perf_counter(); result = func(*args); end_time = time.perf_counter(); elapsed = end_time - start_time; rounded = round(elapsed,3); return rounded. The function returns result? Wait requirement: \"測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)\". It says \"並回傳結果\", ambiguous whether return time or result of func. Likely return time. The function measure_time returns elapsed time. Let's assume returning elapsed. Also maybe return both? But simple: return elapsed. Provide pseudocode accordingly.\n\nLet's produce. Use Start, End. Should include import time. Use \"Start\" to represent file start. Provide steps.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Import time module // 載入 time 模組以便計時\n→ Define function measure_time(func, *args) // 建立測量時間的函式，接受目標函式和任意參數\n    → Step 1: start_time ← time.perf_counter() // 取得執行前的高精度時間\n    → Step 2: result ← func(*args) // 呼叫傳入的函式並將回傳值暫存\n    → Step 3: end_time ← time.perf_counter() // 取得執行後的高精度時間\n    → Step 4: elapsed ← end_time - start_time // 計算實際耗時\n    → Step 5: rounded_elapsed ← round(elapsed, 3) // 四捨五入到小數點第三位\n    → Step 6: return rounded_elapsed // 回傳計算出的秒數\nEnd // 程式執行結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\n\nclass Student:\n    \"\"\"\n    學生類別，包含姓名(name)與分數(score)兩個屬性。\n    \"\"\"\n    def __init__(self, name, score):\n        \"\"\"\n        建構子，將傳入的姓名與分數存入實例屬性。\n        \"\"\"\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        \"\"\"\n        輸出學生資訊，格式為「姓名 的分數是 分數」。\n        \"\"\"\n        print(f'{self.name} 的分數是 {self.score}')\n\ndef main():\n    \"\"\"\n    主程式：從標準輸入讀取資料，建立 Student 物件並呼叫 show_info()。\n    若無輸入，則以預設值建立兩位學生以符合範例要求。\n    \"\"\"\n    # 讀取所有非空白行\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n\n    students = []\n\n    if not lines:\n        # 無輸入時使用預設學生資料\n        students.append(Student('Alice', 90))\n        students.append(Student('Bob', 80))\n    else:\n        # 逐行解析：預期格式為「姓名 分數」\n        for line in lines:\n            parts = line.split()\n            if len(parts) >= 2:\n                name = parts[0]\n                try:\n                    score = int(parts[1])\n                except ValueError:\n                    # 若分數無法轉為整數，跳過此筆資料\n                    continue\n                students.append(Student(name, score))\n\n    # 呼叫每個學生的 show_info() 方法\n    for student in students:\n        student.show_info()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with comments. So produce Start, then step defining class Student, init, etc. Provide steps for creating two objects and calling show_info. Use arrows. We'll include Decision? None needed. Just linear steps. Ensure no actual code. Use virtual steps like \"Define Class Student\". Use arrow notation: → Step ... We'll maintain formatting. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define Class Student // 宣告 Student 類別  \n→ Step 2: Define __init__(self, name, score) // 建構子，接收姓名與分數  \n→ Step 3: Set self.name = name // 初始化姓名屬性  \n→ Step 4: Set self.score = score // 初始化分數屬性  \n→ Step 5: Define show_info(self) // 定義輸出資訊的方法  \n→ Step 6: Print '{self.name} 的分數是 {self.score}' // 輸出姓名與分數  \n→ Step 7: Instantiate Student('Alice', 88) as student1 // 建立第一個 Student 物件  \n→ Step 8: Call student1.show_info() // 呼叫第一個物件的輸出方法  \n→ Step 9: Instantiate Student('Bob', 72) as student2 // 建立第二個 Student 物件  \n→ Step 10: Call student2.show_info() // 呼叫第二個物件的輸出方法  \nEnd // 程式執行結束"
    },
    {
      "title": "三數最大值",
      "source_file": "400.json",
      "problem_index_in_file": 1,
      "generation_error": "Failed to extract code from model response.",
      "failed_validation_details": [
        {
          "example_index": -1,
          "input": null,
          "expected_output": null,
          "actual_output_or_error": "Thinking...\nWe need to output a single Python code block with correct implementation. The code should read three integers from stdin, find max without max().\n\nWe can implement simple comparisons.\n\nWe'll follow the pseudocode: set maxVal = a, compare with b, c.\n\nEdge cases: equal numbers.\n\nWe should use sys.stdin.read() or input().split().\n\nSimplest: a, b, c = map(int, sys.stdin.read().split())\n\nBut we can also use input().split().\n\nLet's do:\n\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data: return\n    a, b, c = map(int, data[:3])\n    max_val = a\n    if b > max_val:\n        max_val = b\n    if c > max_val:\n        max_val = c\n    print(max_val)\n\nif __name__ == \"__main__\":\n    main()\n\nWe need to read only 3 numbers. If there are more,20A:+440<)6@:A@,C1@5E<6>6%=#/1>F\"(0>)=AF#&/6C#*;:.6D\"<3E7'=\"'@C?.:'E*:=6F).*$('>156#0.*&*8/7+@>.A*8B2&12E(F=+->%F5D(;B3,3<58BD(\"71C5+A?(3'\",).8D/-,'A>F+D=$3>>$B0,;#&63EE@:=&.B+704\"/(->C+,.<\"4>&-46C'<+.',@<+2';+.8-4%7&5*,#)0F*#5#)11(#$32<1)%3-3%39+F)/<4%>$\"-<:40(84B#='CC@846&=,#>8118E/\"CA45F/F?#3-)/0.9(61,4'\")B?\"A@A>%);&,-@+:?EA@%*\"&<,A.<0\"C.*1)$%+(?7'.$:#6-=A-?(7C(:+;@@7&%/>%53%6B9$<$C55:-(@;6F/+%(3'&$C(?C@,A6@:&C'<8<D6$*-)?834&\"E(?;&(#/E*07=>,)<>*\"2,=%'/'6\"\",82&.5/%\"-6A8'(\"?:;#%EB&.D9C#(1E3)?57'D:9?%B.EC>:(-$A@&%'E)CB(DFF&#=4.A'=1-=:0C(,&&.0-??DD(7<#B+F5.7)=AB4#(ED\"&,*.&*4@$9;,=&-+D)+%35$5@F-/./7F/=2+(+9=#=4.)))\"::?E8<=+/CC-&53ED-#:\"$,186->*:3-,/7#.<2&?/8E*\"6-4.&'/35,>+F\"B+56-1;*#2/$D(\"B1@D<&)')F#A<66#&0A927*$87/).\"@B(.,#:55+?.8CE##336'E+D>\"-C+4*6B'9C5CCA$<0>,6#)#+4)05<)>'-%.6+16/)#5#(;1C:C:?*@?$/A@2+5,@<88D5:+F/3><2B99/60F@\":A''3@2>1+'F3+5B&=7/%$09,%*+F#3,5+6CA:2E)0.?%&8DF-0*&<6=<#-04=0,-<'2=6?''D26'&C*$'.3(,%-E\"C8?<<<E+-#?24<>.:($1;4\"?*(BC*9\"&8$/"
        }
      ],
      "generated_code": null,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode with explanation per line. Use virtual code arrow arrows, Decision etc. Output format: each line: \"虛擬碼步驟 // 解釋\". Must be in Traditional Chinese. Should not output actual code. Just pseudocode.\n\nWe need to produce virtual code lines: Start, input numbers, comparisons, assign max, output, End.\n\nUse Decision: If a > b? etc.\n\nLet's design:\n\nStart\n\n→ Step 1: 輸入 a, b, c\n\n→ Step 2: 設置 maxVal = a\n\n→ Decision: 如果 b 大於 maxVal?\n\n    Yes → Step 3: 設置 maxVal = b\n\n    No  → (nothing)\n\n→ Decision: 如果 c 大於 maxVal?\n\n    Yes → Step 4: 設置 maxVal = c\n\n    No  → (nothing)\n\n→ Step 5: 輸出 maxVal\n\nEnd\n\nWe must annotate each line with explanation.\n\nWe must ensure each line includes \"虛擬碼步驟 // 解釋\".\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 a, b, c // 取得三個使用者輸入的數值  \n→ Step 2: 設定 maxVal = a // 初始將最大值設為 a  \n→ Decision: 如果 b 大於 maxVal? // 判斷 b 是否比目前最大值還大  \n  Yes → Step 3: 設定 maxVal = b // 若是，更新最大值為 b  \n  No  → (無操作) // 若不是，保留原最大值  \n→ Decision: 如果 c 大於 maxVal? // 判斷 c 是否比目前最大值還大  \n  Yes → Step 4: 設定 maxVal = c // 若是，更新最大值為 c  \n  No  → (無操作) // 若不是，保留原最大值  \n→ Step 5: 輸出 maxVal // 顯示三個數中最大的值  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"melon\",\"apple\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'melon', 'apple', 'orange'}\""
        }
      ],
      "generated_code": "def main():\n    import sys\n\n    # 讀取 stdin（如果有輸入，會被忽略）\n    sys.stdin.read()\n\n    # 1. 建立集合\n    fruits = {'apple', 'banana'}\n\n    # 2. 使用 add() 新增 'orange'\n    fruits.add('orange')\n\n    # 3. 使用 update() 同時新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 4. 使用 remove() 移除 'banana'\n    fruits.remove('banana')\n\n    # 5. 使用 discard() 嘗試移除 'pineapple'（不存在時不報錯）\n    fruits.discard('pineapple')\n\n    # 6. 輸出最終集合\n    print(fruits)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, with arrow and explanation. Must not output actual code, but virtual code. Format: \"虛擬碼步驟 // 解釋\". Use arrow: →, Decision: etc. It's simple: Start, Step 1: create set, Step 2: add orange, Step 3: update with grape melon, Step 4: remove banana, Step 5: discard pineapple, Step 6: output set, End. Each line with explanation. Use \"Start\", \"End\". Provide line number? Not required. Use \"Step 1:\" etc. Provide each line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 fruits = {'apple', 'banana'} // 初始化集合  \n→ Step 2: 使用 add() 新增 'orange' // 將 'orange' 加入集合  \n→ Step 3: 使用 update() 新增 'grape' 與 'melon' // 同時將兩個元素加入集合  \n→ Step 4: 使用 remove() 移除 'banana' // 刪除 'banana'，若不存在會拋錯  \n→ Step 5: 使用 discard() 嘗試移除 'pineapple' // 失敗時不拋錯，元素不存在不變  \n→ Step 6: 輸出 fruits // 顯示最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.8TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.8 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate() -> str:\n    \"\"\"取得美元兌台幣匯率，回傳格式化字串。\"\"\"\n    url = 'https://api.exchangerate-api.com/v4/latest/USD'\n    try:\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()\n        data = r.json()\n        rate = data['rates']['TWD']\n        # 取 1 位小數，符合範例格式\n        return f\"目前美元匯率：約 {rate:.1f} TWD\"\n    except Exception:\n        return \"更新失敗，請檢查網路連線\"\n\ndef start_gui() -> None:\n    \"\"\"建立 tkinter GUI，並在按鈕被點擊時更新匯率。\"\"\"\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=('Arial', 12))\n    label.pack(pady=10)\n\n    def update_label() -> None:\n        \"\"\"按鈕回呼函式，更新 label 文字。\"\"\"\n        label.config(text=fetch_rate())\n\n    button = tk.Button(win, text=\"更新匯率\", command=update_label)\n    button.pack(pady=5)\n\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取所有輸入，並剔除前後空白\n    cmd = sys.stdin.read().strip()\n    # 若收到「按下「更新匯率」按鈕」的文字，直接輸出結果並結束\n    if cmd == '按下「更新匯率」按鈕':\n        print(fetch_rate())\n    else:\n        # 否則啟動 GUI\n        start_gui()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with comments after a space. Use Start, End, Decision, etc. Use arrows. Provide steps for requests, tkinter, button. Should be virtual code only, not actual code. Each line ends with // explanation. Let's craft.\n\nWe need to show import modules, create root window, label, button. Define function to fetch rate. Use requests.get to API. Parse JSON. Get rate. Update label. Button command. Then mainloop.\n\nUse arrows for flow: Start → Step 1: Import modules → Step 2: Define function fetch_rate → Step 3: Create Tk window and widgets → Step 4: Assign button command → Step 5: Mainloop. Use Decision maybe for error handling: if request success? Yes/No. Also if JSON contains 'rates' and 'TWD'.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import 模組 requests, tkinter, json // 先載入所需的第三方與內建模組  \n→ Step 2: 定義函式 fetch_rate() // 用來呼叫 API 取得匯率  \n→ Step 3: 在 fetch_rate() 內部 → Decision: 嘗試連線 API? // 檢查連線是否成功  \n    Yes → Step 4: 取得回傳內容 response.text // 取得 API 回應字串  \n    No  → Step 5: 顯示錯誤訊息 \"無法取得匯率\" // 連線失敗時顯示提示  \n→ Decision: 解析 JSON 成 obj? // 確認回傳能否轉為 JSON  \n    Yes → Step 6: 取得 obj['rates']['TWD'] // 從 JSON 取得台幣匯率  \n    No  → Step 7: 顯示錯誤訊息 \"JSON 解析失敗\" // 解析失敗時提示  \n→ Step 8: Return 匯率值 // 回傳取得的匯率  \n→ Step 9: 建立 tkinter 視窗 root // 初始化 GUI 主視窗  \n→ Step 10: 建立標籤 label, 初始文字為 \"匯率將在此顯示\" // 顯示匯率的地方  \n→ Step 11: 建立按鈕 button，文字為 \"更新匯率\" // 用來觸發更新功能  \n→ Step 12: 定義函式 update_display() // 按鈕點擊時執行的函式  \n→ Step 13: 在 update_display() 內部 → Call fetch_rate() → Decision: 匯率取得成功?  \n    Yes → Step 14: label.config(text=\"USD/TWD: {rate}\") // 更新標籤文字顯示最新匯率  \n    No  → Step 15: label.config(text=\"取得匯率失敗\") // 匯率失敗時顯示錯誤  \n→ Step 16: 設定 button.command = update_display // 把函式綁定到按鈕  \n→ Step 17: 放置 label、button 在視窗中 // 以 pack/grid 方式放置元件  \n→ Step 18: 呼叫 root.mainloop() // 啟動 tkinter 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp283hlvdz.py\", line 35, in <module>\n    args_list = ast.literal_eval(lists[1])\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[3, 1]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.n, x % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.flipped.clear()\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract the two lists from the input\n    lists = re.findall(r'\\[.*?\\]', data, flags=re.S)\n    if len(lists) < 2:\n        sys.exit()\n    ops = ast.literal_eval(lists[0])\n    args_list = ast.literal_eval(lists[1])\n\n    obj = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            method = getattr(obj, op)\n            if args:\n                res = method(*args)\n            else:\n                res = method()\n            results.append(res)\n\n    # Convert Python None to JSON null in the output\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the algorithm. We must not output actual code, but pseudo-code lines with explanation.\n\nWe need to design algorithm that uses minimal random calls, time O(1) expected, space O(k) where k is number of flips, or O(mn) maybe.\n\nStandard solution: use mapping technique: maintain mapping from index to value, treat matrix as flattened array of m*n cells. Keep track of available count remaining = m*n. For flip: pick random r from 0 to remaining-1. map[r] gives actual index. Then decrement remaining. Set map[r] = map[remaining] if map[remaining] exists else remaining. That ensures we don't pick same cell again. For reset: clear map and reset remaining.\n\nNeed to produce pseudocode lines with arrow.\n\nWe should follow format: Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow \"→\".\n\nLet's structure:\n\nStart\n→ Initialize variables: m, n, total = m*n, remaining = total, mapping = empty dict\n→ Function flip():\n    → Decision: remaining == 0? // If no zeros left, maybe throw error\n        Yes → return null\n        No  → Step: r = random integer in [0, remaining-1] // pick random free index\n        → Step: idx = mapping.get(r, r) // actual index to flip\n        → Step: remaining -= 1\n        → Step: last = mapping.get(remaining, remaining) // mapping for last spot\n        → Step: mapping[r] = last // move last into r\n        → Step: if remaining in mapping: delete mapping[remaining] // optional\n        → Step: i = idx // compute row\n        → Step: j = idx % n // compute column\n        → Step: return [i, j]\n→ Function reset():\n    → Step: mapping.clear()\n    → Step: remaining = total\nEnd\n\nNeed to keep arrow lines for each step.\n\nAlso we need to mention use of random integer generator.\n\nOk.\n\nWe'll output lines.\n\nWe need to incorporate decision lines. Let's write as:\n\nStart // 程式開始執行\n→ Step 1: Set m, n, total = m*n, remaining = total, mapping = {} // 初始化參數\n\nThen for flip:\n\n→ Step 2: flip() // 開始翻轉操作\n    → Decision: remaining == 0? // 檢查是否還有 0 可翻轉\n        Yes → Return null // 或者拋出例外，表示矩陣已全為 1\n        No  → Continue\n    → Step 3: r = randomInt(0, remaining-1) // 隨機選取一個可用索引\n    → Step 4: idx = mapping.get(r, r) // 取得實際要翻轉的索引\n    → Step 5: remaining -= 1 // 使可用數量減 1\n    → Step 6: last = mapping.get(remaining, remaining) // 取得剩餘最後一個索引的映射\n    → Step 7: mapping[r] = last // 把 last 放回 r 的位置，避免重複\n    → Step 8: if remaining in mapping: delete mapping[remaining] // 刪除已用位置的映射（可選）\n    → Step 9: i = idx // 計算行號\n    → Step 10: j = idx % n // 計算列號\n    → Step 11: return [i, j] // 回傳翻轉的座標\n\nThen reset:\n\n→ Step 12: reset() // 重置操作\n    → Step 13: mapping.clear() // 清空映射表\n    → Step 14: remaining = total // 將剩餘數量重設為總量\n\nEnd // 程式執行結束\n\nNeed to ensure arrow formatting. Use \"→\". Decision lines use \"Decision:\".\n\nAlso the steps after a Decision should be indented. In format example, they used 4 spaces indent? They didn't specify indent but use indentation with spaces.\n\nWe'll mimic same style:\n\nDecision: if ...?\n    Yes → ...\n    No → ...\n\nOk.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set m, n, total = m*n, remaining = total, mapping = {} // 初始化矩陣尺寸與可用空位數  \n\n→ Step 2: flip() // 開始一次翻轉操作  \n    → Decision: remaining == 0? // 檢查是否已無 0 可翻轉  \n        Yes → Return null // 或拋出例外，表示矩陣已全為 1  \n        No  → Continue // 有可翻轉空位  \n\n    → Step 3: r = randomInt(0, remaining-1) // 隨機選取一個可用索引  \n    → Step 4: idx = mapping.get(r, r) // 取得實際要翻轉的索引（已映射則取映射值）  \n    → Step 5: remaining -= 1 // 把已選位置從可用集合移除  \n    → Step 6: last = mapping.get(remaining, remaining) // 取得剩餘最後一個索引的映射值  \n    → Step 7: mapping[r] = last // 把 last 放回 r 的位置，確保不再重複  \n    → Step 8: if remaining in mapping: delete mapping[remaining] // 可選，刪除已用位置的映射  \n    → Step 9: i = idx // 轉回行號  \n    → Step 10: j = idx % n // 轉回列號  \n    → Step 11: return [i, j] // 回傳翻轉的座標  \n\n→ Step 12: reset() // 重置操作  \n    → Step 13: mapping.clear() // 清空所有映射  \n    → Step 14: remaining = total // 將可用空位重設為總量  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjuokwuz1.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpjuokwuz1.py\", line 43, in main\n    obj.buildDict(arg)\n  File \"/tmp/tmpjuokwuz1.py\", line 13, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MagicDictionary:\n    \"\"\"\n    這個類別用於儲存字典並提供能否改一個字元達到匹配的功能。\n    \"\"\"\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        # 把所有單字存進集合，方便查詢\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        # 逐一比對字典中的單字\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            # 計算兩個字串不同的位置數量\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析成兩個列表：commands 和 arguments\n    # 由於輸入使用單引號，使用 ast.literal_eval 解析\n    commands, arguments = ast.literal_eval('(' + data + ')')\n\n    results = []\n    obj = None\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"MagicDictionary\":\n            obj = MagicDictionary()\n            results.append(None)\n        elif cmd == \"buildDict\":\n            obj.buildDict(arg)\n            results.append(None)\n        elif cmd == \"search\":\n            res = obj.search(arg)\n            results.append(res)\n        else:\n            # 若有未知指令，略過\n            results.append(None)\n\n    # 輸出結果，保持與範例相同的格式\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the design of MagicDictionary. Steps: start, buildDict, search with logic. Use decision structures. No actual code. Provide explanation. Let's produce steps: Initialize dictionary, store words, maybe using map of patterns? Simpler: store words list. searchWord: for each word in dictionary, if length matches and count diff==1 return true. Provide steps accordingly. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的字典資料結構 (如陣列或集合) // 用於儲存所有單字  \n→ Step 2: 建構函式 MagicDictionary() // 初始化時不做其他工作  \n→ Step 3: 定義方法 buildDict(String[] dictionary) // 接收單字陣列  \n  → Decision: dictionary 不是空陣列? // 檢查輸入是否有效  \n   Yes → Step 4: 將 dictionary 中所有字串逐一加入字典資料結構 // 以便後續搜尋  \n   No  → End // 若輸入為空，直接結束建構  \n→ Step 5: 定義方法 search(String searchWord) // 進行搜尋判斷  \n  → Decision: 迭代字典中每個單字 word? // 檢查每個候選字串  \n   Yes → Decision: word.length == searchWord.length? // 必須長度相同  \n    Yes → Step 6: 計算兩個字串不同字符的個數 diffCount  \n     → Decision: diffCount == 1? // 只允許改一個字元  \n      Yes → Return true // 找到符合條件的字串  \n      No  → No action, 轉到下一個 word  \n    No → No action, 轉到下一個 word  \n   No → End // 所有字串已檢查完畢  \n  → End // 搜尋結束，若未返回 true  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      \"['(a)()()', '(a())()']\""
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"\n        Return all possible strings after removing the minimum number of invalid parentheses.\n        \"\"\"\n        # Count how many '(' and ')' need to be removed\n        left_rem, right_rem = 0, 0\n        for ch in s:\n            if ch == '(':\n                left_rem += 1\n            elif ch == ')':\n                if left_rem == 0:\n                    right_rem += 1\n                else:\n                    left_rem -= 1\n\n        results = set()\n\n        def dfs(index: int, left_count: int, right_count: int,\n                left_remain: int, right_remain: int, path: str):\n            \"\"\"\n            Backtracking helper to build valid strings.\n            index        : current position in s\n            left_count   : number of '(' used so far\n            right_count  : number of ')' used so far\n            left_remain  : remaining '(' that can still be removed\n            right_remain : remaining ')' that can still be removed\n            path         : current constructed string\n            \"\"\"\n            if index == len(s):\n                if left_remain == 0 and right_remain == 0 and left_count == right_count:\n                    results.add(path)\n                return\n\n            ch = s[index]\n\n            if ch == '(':\n                # Option 1: skip this '(' if we still have left removals left\n                if left_remain > 0:\n                    dfs(index + 1, left_count, right_count,\n                        left_remain - 1, right_remain, path)\n                # Option 2: keep this '('\n                dfs(index + 1, left_count + 1, right_count,\n                    left_remain, right_remain, path + '(')\n\n            elif ch == ')':\n                # Option 1: skip this ')' if we still have right removals left\n                if right_remain > 0:\n                    dfs(index + 1, left_count, right_count,\n                        left_remain, right_remain - 1, path)\n                # Option 2: keep this ')' only if it will not make the string invalid\n                if left_count > right_count:\n                    dfs(index + 1, left_count, right_count + 1,\n                        left_remain, right_remain, path + ')')\n\n            else:\n                # Non-parenthesis characters are always kept\n                dfs(index + 1, left_count, right_count,\n                    left_remain, right_remain, path + ch)\n\n        dfs(0, 0, 0, left_rem, right_rem, \"\")\n        return list(results)\n\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    Parse the input string. The input may be:\n      - Just a raw string like \"()())()\"\n      - Or in the form s = \"()())()\"\n    \"\"\"\n    raw = raw.strip()\n    if '=' in raw:\n        _, val = raw.split('=', 1)\n        val = val.strip()\n        # Remove surrounding quotes if present\n        if (val.startswith('\"') and val.endswith('\"')) or \\\n           (val.startswith(\"'\") and val.endswith(\"'\")):\n            val = val[1:-1]\n        return val\n    return raw\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n    # Output as a Python list representation\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm to remove minimum invalid parentheses and return all valid strings. Use BFS or DFS with pruning. We will produce virtual code step by step with decision arrows.\n\nWe'll describe approach: compute number of left and right parentheses to remove. Then DFS generating all possibilities by removing characters, skip duplicates via set.\n\nBut produce as virtual steps.\n\nLet's craft steps:\n\nStart // begin\n→ Step: 定義函式 removeInvalidParentheses(s) // main function\n→ Step: 計算要刪除的左括號 countLeft, 右括號 countRight // counts\n→ Step: 定義結果集合 results // store unique valid strings\n→ Step: 定義回溯函式 dfs(index, leftCount, rightCount, leftRemove, rightRemove, path) // parameters\n→ Decision: index == len(s)? // end of string\n    Yes → Decision: leftRemove==0 and rightRemove==0 and leftCount==rightCount? // valid\n        Yes → Step: 將 path 轉為字串加入 results\n        No  → Step: return // 不合法\n    No  → Step: char = s[index] // 取得當前字元\n→ Decision: char=='('? // if left parenthesis\n    Yes →\n        // Option 1: skip this '(' if leftRemove>0\n        Decision: leftRemove>0? \n            Yes → dfs(index+1, leftCount, rightCount, leftRemove-1, rightRemove, path) // skip\n            No → No\n        // Option 2: keep '('\n        dfs(index+1, leftCount+1, rightCount, leftRemove, rightRemove, path + '(')\n    No →\n        Decision: char==')'? // right parenthesis\n            Yes →\n                // Option 1: skip if rightRemove>0\n                Decision: rightRemove>0? \n                    Yes → dfs(index+1, leftCount, rightCount, leftRemove, rightRemove-1, path) // skip\n                    No → No\n                // Option 2: keep if leftCount>rightCount\n                Decision: leftCount>rightCount? \n                    Yes → dfs(index+1, leftCount, rightCount+1, leftRemove, rightRemove, path + ')')\n                    No → No\n            No → // letter\n                dfs(index+1, leftCount, rightCount, leftRemove, rightRemove, path + char)\n→ End // function end\n→ Step: return results as list\n\nNeed to maintain uniqueness via set results. Also skip duplicates: we could avoid by not adding duplicates to set, but BFS also typical. Provide explanation each line.\n\nMake sure to use arrows.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 定義函式 removeInvalidParentheses(s) // 主要入口，輸入原始字串\n→ Step: 計算 countLeft = 0, countRight = 0 // 需要刪除的左、右括號數量\n→ Decision: for 每個字元 c in s? // 遍歷字串\n    Yes → Decision: c == '('? \n        Yes → countLeft++ // 左括號數增一\n        No  → Decision: c == ')'?\n            Yes → countRight++ // 右括號數增一\n            No  → No // 字母不影響計數\n→ Step: results = set() // 儲存唯一的合法字串\n→ Step: 定義回溯函式 dfs(idx, leftCnt, rightCnt, leftRem, rightRem, path) // idx 為目前索引\n→ Decision: idx == len(s)? // 字串結束\n    Yes → Decision: leftRem == 0 and rightRem == 0 and leftCnt == rightCnt? // 是否完全合法\n        Yes → Step: results.add(path) // 加入合法結果\n        No  → Step: return // 不是合法字串，返回\n    No  → Step: c = s[idx] // 取得目前字元\n→ Decision: c == '('? // 處理左括號\n    Yes →\n        // 選項 1：刪除此左括號（若允許）\n        Decision: leftRem > 0? \n            Yes → dfs(idx+1, leftCnt, rightCnt, leftRem-1, rightRem, path) // 跳過此字元\n            No  → No\n        // 選項 2：保留此左括號\n        dfs(idx+1, leftCnt+1, rightCnt, leftRem, rightRem, path + '(')\n    No →\n        Decision: c == ')'? // 處理右括號\n            Yes →\n                // 選項 1：刪除此右括號（若允許）\n                Decision: rightRem > 0? \n                    Yes → dfs(idx+1, leftCnt, rightCnt, leftRem, rightRem-1, path) // 跳過此字元\n                    No  → No\n                // 選項 2：保留此右括號（需左括號多於右括號）\n                Decision: leftCnt > rightCnt? \n                    Yes → dfs(idx+1, leftCnt, rightCnt+1, leftRem, rightRem, path + ')')\n                    No  → No\n            No  → // 非括號，為字母\n                dfs(idx+1, leftCnt, rightCnt, leftRem, rightRem, path + c)\n→ End // 函式結束\n→ Step: return list(results) // 將集合轉成清單回傳\n\nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar III",
      "source_file": "Leetcode/leetcode732.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,2,3,3,3]'\nGot (Norm):      '[null,null,1,1,2,3,3,3]'\n--- (Raw) ---\nRaw Expected: '[null, 1, 1, 2, 3, 3, 3]'\nRaw Got:      '[null, null, 1, 1, 2, 3, 3, 3]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport bisect\n\nclass MyCalendarThree:\n    def __init__(self):\n        self.timeline = []\n\n    def book(self, start, end):\n        bisect.insort(self.timeline, (start, 1))\n        bisect.insort(self.timeline, (end, -1))\n        active = 0\n        max_active = 0\n        for time, delta in self.timeline:\n            active += delta\n            if active > max_active:\n                max_active = active\n        return max_active\n\nif __name__ == \"__main__\":\n    # Read all non-empty lines from stdin\n    lines = [line.strip() for line in sys.stdin if line.strip() != \"\"]\n    if len(lines) == 2:\n        ops = json.loads(lines[0])\n        args = json.loads(lines[1])\n    elif len(lines) == 1:\n        # Handle single-line input like\n        # [\"MyCalendarThree\", \"book\", ...], [[], [10,20], ...]\n        part = lines[0]\n        # Wrap with brackets and eval to get two lists\n        data = eval(f'[{part}]')\n        ops, args = data[0], data[1]\n    else:\n        ops, args = [], []\n\n    results = [None]          # The first call to MyCalendarThree returns null\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyCalendarThree\":\n            obj = MyCalendarThree()\n            results.append(None)\n        elif op == \"book\":\n            res = obj.book(arg[0], arg[1])\n            results.append(res)\n\n    # Output the results as a JSON array (null for None)\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for MyCalendarThree, which is the Leetcode problem. We need to output step-by-step virtual code lines with explanations. Use Start, End, Decision, etc. No actual code. It's about algorithm: using sweep line and segment tree? Usually solution uses a difference array / map of events: store counts at times, then iterate sorted times, keep current overlap, max. For each book, add to map start: +1, end: -1. Then recompute? But we can compute incrementally: after each book, we insert and track current max. But we need to compute max after adding new event. Approach: use sorted map of events, maintain cumulative count. After each insertion, recompute max by scanning map. Complexity O(n^2) but fine. But we can maintain more efficiently: Use segment tree. But we can propose simpler algorithm: maintain list of intervals and use line sweep each book.\n\nBut virtual code step by step: Define class MyCalendarThree. In constructor: initialize event map. In book: add start+1, end-1 to map. Then sweep sorted keys, compute current, track max, return max.\n\nSo produce virtual code lines with comments. Use arrow notation.\n\nLet's produce code lines: Start, Step: Initialize map, Step: book function, etc. Use Decision? Not needed maybe. But we can include Decision for computing max. Provide steps.\n\nLet's produce about 12-15 lines.\n\nLet's do:\n\nStart\n→ Step 1: 定義 MyCalendarThree 類別 // 建立類別\n→ Step 2: 在建構子內初始化 events 為空的有序映射 // 用來儲存時間點與變化量\n→ Step 3: book(startTime, endTime) // 進行一次預約\n    → Step 4: events[startTime] += 1 // 在開始時間增加 1\n    → Step 5: events[endTime] -= 1 // 在結束時間減少 1\n    → Step 6: 初始化 current = 0, maxOverlap = 0 // 用於計算最大重疊\n    → Step 7: 遍歷 events 按時間排序\n        → Step 8: current += events[time] // 累加變化量\n        → Step 9: maxOverlap = max(maxOverlap, current) // 更新最大值\n    → Step 10: 回傳 maxOverlap // 回傳此時最大的 k-booking\nEnd\n\nWe should also include decision if events map not empty etc. But that's fine.\n\nMake sure each line has virtual code step + comment.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCalendarThree 類別 // 建立一個能記錄事件的類別  \n→ Step 2: 在建構子內初始化 events 為空的有序映射 // 用來存放時間點與對應的變化量 (+1 或 -1)  \n→ Step 3: book(startTime, endTime) // 開始一個新預約  \n    → Step 4: events[startTime] += 1 // 在開始時間點增加一次預約數量  \n    → Step 5: events[endTime] -= 1 // 在結束時間點減少一次預約數量  \n    → Step 6: 初始化 current = 0, maxOverlap = 0 // current 為目前時間段的重疊數量，maxOverlap 為目前已知的最大重疊數  \n    → Step 7: 遍歷 events 按時間順序  \n        → Step 8: current += events[time] // 累加該時間點的變化量，得到此刻的重疊數  \n        → Step 9: maxOverlap = max(maxOverlap, current) // 如有更大的重疊數，更新 maxOverlap  \n    → Step 10: 回傳 maxOverlap // 返回此時整體最大 k-booking  \nEnd // 程式執行結束"
    },
    {
      "title": "leetcode846_problem_1",
      "source_file": "Leetcode/leetcode846.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
          "expected_output": "True",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpa_oh2gee.py\", line 38, in <module>\n    main()\n  File \"/tmp/tmpa_oh2gee.py\", line 27, in main\n    hand = eval(hand_str, {}, {})\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "hand = [1,2,3,4,5], groupSize = 4",
          "expected_output": "False",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwlshpkqc.py\", line 38, in <module>\n    main()\n  File \"/tmp/tmpwlshpkqc.py\", line 27, in main\n    hand = eval(hand_str, {}, {})\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def isNStraightHand(self, hand, groupSize):\n        if len(hand) % groupSize != 0:\n            return False\n        count = Counter(hand)\n        for card in sorted(count):\n            freq = count[card]\n            if freq > 0:\n                for i in range(card, card + groupSize):\n                    if count[i] < freq:\n                        return False\n                    count[i] -= freq\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Assume input format: \"hand = [...], groupSize = ...\"\n    parts = [p.strip() for p in data.split(',')]\n    # Parse hand list\n    hand_part = parts[0]\n    hand_str = hand_part.split('=', 1)[1].strip()\n    hand = eval(hand_str, {}, {})\n    # Parse groupSize\n    group_part = parts[1]\n    group_str = group_part.split('=', 1)[1].strip()\n    groupSize = int(group_str)\n    # Solve\n    sol = Solution()\n    result = sol.isNStraightHand(hand, groupSize)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for determining if array can be rearranged into groups of size groupSize with consecutive values. Standard problem: \"Hand of Straights\" leetcode 846. Approach: count frequencies, sort unique values, iterate sorted keys, try to subtract counts for each consecutive sequence of length groupSize. If any count fails, return false. Complexity O(n log n).\n\nWe need to produce virtual code with step-by-step explanation. Use Start, Decision, Yes→, No→.\n\nWe need to adhere to format: each line: \"虛擬碼步驟 // 解釋\". Use arrows like →, Yes →, No →, Decision:.\n\nWe need to produce \"逐行\" outputs. Provide steps.\n\nLet's craft pseudocode:\n\nStart // 開始\n→ Step 1: 計算每張卡牌數值的頻率 // Frequency map\n→ Step 2: 取得所有不同數值並排序 // Sorted unique values\n→ Decision: 若 groupSize 為 0 或 hand 为空? // Edge cases\n    Yes → Step 3: 回傳 false // 無法組成\n    No → Step 4: 若 hand 長度 % groupSize != 0? // Check divisibility\n        Yes → Step 5: 回傳 false // 長度不能被 groupSize 整除\n        No → Step 6: 開始處理每個最小值 // For each value in sorted\n→ Step 6: 循環每個值 val 在 sortedValues\n    → Decision: 若頻率[ val ] == 0? // 已消耗\n        Yes → Continue // 跳過\n        No → Step 7: 取需使用的數量 count = freq[val] // 需要使用的數量\n→ Step 7: 為 i from 0 to groupSize-1\n        → Step 8: nextVal = val + i\n        → Decision: 若 freq[nextVal] < count? // 沒足夠\n            Yes → Step 9: 回傳 false\n            No → Step 10: freq[nextVal] -= count // 減少數量\n→ Decision: 所有循環結束? // 如果完成\n    Yes → Step 11: 回傳 true\n    No → 重新進入 Step 6\n\nEnd // 程式結束\n\nBut we need to express each line with arrow and comment.\n\nWe should format like:\n\nStart // 程式開始執行\n→ Step 1: 建立一個哈希表 freq，用於記錄每個卡牌數值出現的次數 // Count frequencies\n→ Step 2: 將 hand 中所有不同的數值收集並排序為 sortedValues // Get sorted unique values\n→ Decision: 若 groupSize 為 0 或 hand 為空? // Edge case checks\n    Yes → Step 3: 回傳 false // 無法組成\n    No  → Decision: 若 hand 長度 % groupSize ≠ 0? // 整除檢查\n        Yes → Step 4: 回傳 false // 長度不符合\n        No  → Step 5: 開始處理最小值 // 進入主循環\n→ Step 5: 對於 sortedValues 中的每個 val\n    → Decision: 若 freq[val] == 0? // 已消耗\n        Yes → Continue // 跳過此 val\n        No  → Step 6: 設定 count = freq[val] // 需要分配的數量\n→ Step 6: 從 0 到 groupSize-1 進行\n    → Step 7: 計算 nextVal = val + i // 下一個連續數值\n    → Decision: 若 freq[nextVal] < count? // 檢查足夠\n        Yes → Step 8: 回傳 false // 無法完成\n        No  → Step 9: freq[nextVal] -= count // 減少對應數值的頻率\n→ Decision: 所有循環完成? // 判斷是否成功\n    Yes → Step 10: 回傳 true // 成功\n    No  → 回到 Step 5 // 繼續處理下一個 val\nEnd // 程式結束\n\nBut need to follow \"逐行\" each line of pseudocode. Use arrow lines and decision. Also we must include \"Decision:\" lines. For loop we need to represent \"for\" with arrow maybe.\n\nWe need to produce each line as \"虛擬碼步驟 [space] // 解釋\".\n\nLet's produce final output.\n\nWe must include Start and End. Also ensure each line follows the format: \"虛擬碼步驟 // 解釋\". Use \"Decision:\" when conditional. Use Yes → and No → for branches. Use \"→\" for normal flow.\n\nWe must maintain one line per step; no actual code, just pseudocode steps.\n\nLet's produce.\n\nMake sure that the lines are numbered? Not required.\n\nOk.\n\nWe'll output:\n\nStart // 程式開始執行\n→ Step 1: 建立頻率表 freq，統計 hand 中每個數值的出現次數 // Count each card value\n→ Step 2: 將所有不同的數值取出並按升序排列為 sortedValues // Sort unique card values\n→ Decision: 是否有特殊情況需要直接回傳 false？ // Edge case check\n    Yes → Step 3: 回傳 false // 無法組成\n    No  → Decision: hand 長度是否能被 groupSize 整除？ // Check divisibility\n        Yes → Step 4: 回傳 false // 長度不符合分組要求\n        No  → Step 5: 開始處理每個最小的數值 // Proceed to main loop\n→ Step 5: 對於 sortedValues 中的每個 val\n    → Decision: 若 freq[val] 為 0？ // Already used\n        Yes → Continue // 跳過\n        No  → Step 6: 設定 count = freq[val] // 需要分配的數量\n→ Step 6: 從 i = 0 到 groupSize-1\n    → Step 7: 計算 nextVal = val + i // 下一個連續數值\n    → Decision: 若 freq[nextVal] < count？ // 足夠嗎？\n        Yes → Step 8: 回傳 false // 無法完成分組\n        No  → Step 9: freq[nextVal] -= count // 減少相應頻率\n→ Decision: 所有 val 已處理完？ // 完成檢查\n    Yes → Step 10: 回傳 true // 成功組成\n    No  → 回到 Step 5 // 繼續處理下一個 val\nEnd // 程式結束\n\nBut we need to keep each line strictly: \"虛擬碼步驟 // 解釋\". No indentation? It's okay. But we need to keep arrow \"→\" and decisions properly. Let's output exactly.\n\nAlso ensure each line ends with a comment. Provide \"Decision:\" lines with Yes→, No→.\n\nWe should output like:\n\nStart // 程式開始執行\n→ Step 1: 建立頻率表 freq，統計 hand 中每個數值的出現次數 // Count each card value\n→ Step 2: 取出 hand 中所有不同數值並按升序排列為 sortedValues // Sort unique values\n→ Decision: 是否需要直接回傳 false？ // Edge case check\n    Yes → Step 3: 回傳 false // 無法組成\n    No  → Decision: hand 長度是否能被 groupSize 整除？ // Divisibility check\n        Yes → Step 4: 回傳 false // 長度不符合分組需求\n        No  → Step 5: 開始處理每個最小數值 // Proceed to main loop\n→ Step 5: 對 sortedValues 中的每個 val\n    → Decision: 若 freq[val] 為 0？ // Already used\n        Yes → Continue // 跳過\n        No  → Step 6: 設定 count = freq[val] // 需要分配的數量\n→ Step 6: 從 i = 0 到 groupSize-1\n    → Step 7: 計算 nextVal = val + i // 下一個連續數值\n    → Decision: 若 freq[nextVal] < count？ // 足夠嗎？\n        Yes → Step 8: 回傳 false // 無法完成\n        No  → Step 9: freq[nextVal] -= count // 減少相應頻率\n→ Decision: 所有 val 已處理完？ // 完成檢查\n    Yes → Step 10: 回傳 true // 成功組成\n    No  → Step 5 // 繼續處理下一個 val\nEnd // 程式結束\n\nThis seems fine. Ensure each line has \"虛擬碼步驟 // 解釋\". Good.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立頻率表 freq，統計 hand 中每個數值的出現次數 // Count each card value  \n→ Step 2: 取出 hand 中所有不同數值並按升序排列為 sortedValues // Sort unique values  \n→ Decision: 是否需要直接回傳 false？ // Edge case check  \n Yes → Step 3: 回傳 false // 無法組成  \n No  → Decision: hand 長度是否能被 groupSize 整除？ // Divisibility check  \n  Yes → Step 4: 回傳 false // 長度不符合分組需求  \n  No  → Step 5: 開始處理每個最小數值 // Proceed to main loop  \n→ Step 5: 對 sortedValues 中的每個 val  \n → Decision: 若 freq[val] 為 0？ // Already used  \n  Yes → Continue // 跳過  \n  No  → Step 6: 設定 count = freq[val] // 需要分配的數量  \n→ Step 6: 從 i = 0 到 groupSize-1  \n → Step 7: 計算 nextVal = val + i // 下一個連續數值  \n → Decision: 若 freq[nextVal] < count？ // 足夠嗎？  \n  Yes → Step 8: 回傳 false // 無法完成  \n  No  → Step 9: freq[nextVal] -= count // 減少相應頻率  \n→ Decision: 所有 val 已處理完？ // 完成檢查  \n Yes → Step 10: 回傳 true // 成功組成  \n No  → Step 5 // 繼續處理下一個 val  \nEnd // 程式結束"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,null,-3,null,0,-2]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null,null,null,null,-3,null,0,-2]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MinStack:\n    \"\"\"\n    使用兩個堆疊（stack 與 min_stack）實作最小堆疊。\n    - stack 儲存所有進入的元素。\n    - min_stack 儲存目前堆疊中的最小值，每次 push 時若新值 <= min_stack 的頂部，亦推入 min_stack。\n      每次 pop 時若彈出的值等於 min_stack 的頂部，同時從 min_stack 中彈出，確保 min_stack 的頂部永遠是\n      當前堆疊中的最小值。\n    這樣做可以在 O(1) 時間完成 push、pop、top 與 getMin 四項操作。\n    \"\"\"\n    def __init__(self):\n        self.stack = []       # 主堆疊\n        self.min_stack = []   # 儲存最小值的堆疊\n\n    def push(self, val: int) -> None:\n        \"\"\"將元素推入堆疊，並更新最小堆疊。\"\"\"\n        self.stack.append(val)\n        # 若 min_stack 為空或新值比目前最小值還小，亦推入 min_stack\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        \"\"\"從堆疊中彈出頂部元素，同時更新 min_stack。\"\"\"\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        if val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self):\n        \"\"\"取得堆疊頂部元素。\"\"\"\n        if not self.stack:\n            return None\n        return self.stack[-1]\n\n    def getMin(self):\n        \"\"\"取得目前堆疊中的最小值。\"\"\"\n        if not self.min_stack:\n            return None\n        return self.min_stack[-1]\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入，預期為兩行：操作序列與參數序列\n    data = sys.stdin.read().strip().splitlines()\n    if not data or len(data) < 2:\n        # 若輸入格式不符，直接結束\n        sys.exit(0)\n\n    # 解析輸入，將單引號轉為雙引號以符合 json.loads\n    ops = json.loads(data[0].replace(\"'\", '\"'))\n    args = json.loads(data[1].replace(\"'\", '\"'))\n\n    result = []\n    stack_obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MinStack\":\n            stack_obj = MinStack()\n            result.append(None)          # MinStack 建構子回傳 null\n        elif op == \"push\":\n            stack_obj.push(arg[0])\n            result.append(None)          # push 回傳 null\n        elif op == \"pop\":\n            stack_obj.pop()\n            result.append(None)          # pop 回傳 null\n        elif op == \"top\":\n            result.append(stack_obj.top())\n        elif op == \"getMin\":\n            result.append(stack_obj.getMin())\n        else:\n            # 若有未知操作，直接忽略\n            result.append(None)\n\n    # 使用 json.dumps 以自動將 None 轉成 null，符合 LeetCode 期望格式\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MinStack with O(1) operations. Provide lines with \"Start\", \"Decision:\" etc. Should include pushing to main stack and min stack. Provide algorithm. Let's produce step-by-step. Should start with Start. Then Step 1: Initialize two stacks. Step 2: push: push onto main, and if min stack empty or val <= top(min) push onto min stack. Step 3: pop: pop main, and if popped equals top(min) pop min. Step 4: top: return top(main). Step 5: getMin: return top(min). End. Use decision arrows. Also need comments. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化兩個空堆疊 MainStack, MinStack // MainStack 儲存所有元素，MinStack 儲存目前最小值\n→ Decision: 用戶調用 MinStack()? // 判斷是否需要創建 MinStack 物件\n    Yes → Step 2: MinStack 物件初始化 // 建立 MainStack 與 MinStack 為空\n    No  → End // 若不初始化，程式結束\n→ Decision: 用戶調用 push(val)? // 判斷是否有推入元素的需求\n    Yes → Step 3: MainStack.push(val) // 把 val 加到 MainStack\n        → Decision: MinStack.isEmpty() 或 val ≤ MinStack.top()? // 判斷是否需要更新最小堆疊\n            Yes → MinStack.push(val) // 新值是目前最小值，加入 MinStack\n            No  → // 不更新 MinStack\n        End\n    No  → // 無推入操作\n→ Decision: 用戶調用 pop()? // 判斷是否要移除頂部元素\n    Yes → Step 4: popped = MainStack.pop() // 從 MainStack 移除頂部元素\n        → Decision: popped == MinStack.top()? // 判斷 popped 是否為最小值\n            Yes → MinStack.pop() // 同時從 MinStack 移除最小值\n            No  → // 不移除 MinStack\n        End\n    No  → // 無彈出操作\n→ Decision: 用戶調用 top()? // 判斷是否要取得頂部元素\n    Yes → Step 5: return MainStack.top() // 返回 MainStack 的頂部\n    No  → // 無 top 操作\n→ Decision: 用戶調用 getMin()? // 判斷是否要取得最小值\n    Yes → Step 6: return MinStack.top() // 返回 MinStack 的頂部，即最小值\n    No  → // 無 getMin 操作\nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum II",
      "source_file": "Leetcode/leetcode40.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "candidates = [10,1,2,7,6,1,5], target = 8",
          "expected_output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk3q8gc89.py\", line 41, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    candidates = [10,1,2,7,6,1,5], target = 8\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,5,2,1,2], target = 5",
          "expected_output": "[[1,2,2],[5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphzmszixl.py\", line 41, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    candidates = [2,5,2,1,2], target = 5\n    ^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        Find all unique combinations of candidates that sum to target.\n        Each number in candidates may only be used once in the combination.\n        \"\"\"\n        candidates.sort()\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            prev = None\n            for i in range(start, len(candidates)):\n                # skip duplicates\n                if prev is not None and candidates[i] == prev:\n                    continue\n                path.append(candidates[i])\n                backtrack(i + 1, path, total + candidates[i])\n                path.pop()\n                prev = candidates[i]\n\n        backtrack(0, [], 0)\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入：假設格式為 \"candidates = [...], target = ...\"\n    # 使用 exec 直接執行，變量將被賦值\n    local_vars = {}\n    exec(data, {}, local_vars)\n\n    # 取得 candidates 與 target\n    candidates = local_vars.get(\"candidates\")\n    target = local_vars.get(\"target\")\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.combinationSum2(candidates, target)\n\n    # 使用 json.dumps 以無空白的格式輸出\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for combination sum II (like Leetcode 40). The user wants virtual code lines with explanations, not actual code. Use Start, End, Decision, arrow etc.\n\nWe need to process collection of candidate numbers, each used at most once, find all unique combinations that sum to target, no duplicates. We can sort array and use backtracking with skip duplicates. So pseudo-code:\n\nStart\n→ Step: Sort candidates ascending // to handle duplicates\n→ Step: Initialize result list\n→ Step: Call backtrack(startIndex=0, currentCombination=[], remaining=target)\n→ End\n\nBacktrack function: Step: If remaining==0 → Add copy of currentCombination to result // found combination\n→ Decision: If remaining<0 → return // exceed target\n→ For i from startIndex to length-1:\n   → Decision: If i>startIndex AND candidates[i]==candidates[i-1] → Continue // skip duplicates\n   → Step: Add candidates[i] to currentCombination\n   → Step: Call backtrack(i+1, currentCombination, remaining - candidates[i])\n   → Step: Remove last element from currentCombination // backtrack\n\nReturn result\n\nWe need to produce each line in format \"虛擬碼步驟 // 解釋\". Use arrows and decisions. Need to include pseudo steps. Let's write line by line.\n\nWe should start with \"Start\". Then lines with arrows.\n\nLine 1: Start // 程式開始執行\nLine 2: → Step: Sort candidates ascending // 為了方便去除重複組合\nLine 3: → Step: Initialize result list // 用於儲存所有合法組合\nLine 4: → Step: Call backtrack(startIndex=0, currentCombination=[], remaining=target) // 開始遞迴搜尋\nLine 5: End // 程式執行結束\n\nBut we also need to show the backtrack function definition. So maybe we need to include \"Define function backtrack\". Use arrow? For readability we can add a block.\n\nLet's propose:\n\n→ Decision: 定義 backtrack(startIndex, currentCombination, remaining) // 遞迴搜尋子問題\n\nBut we need to produce step lines inside function.\n\nOk, restructure: After Step 4, we define backtrack as a block. Use indentation? Not necessary but we can show steps within. But requirement: every line must have 虛擬碼步驟 and explanation. So we need to produce lines for backtrack logic. We'll present them as separate lines but indicate that they belong to backtrack.\n\nWe can use \"→ Step: Define function backtrack...\" but then next lines inside.\n\nBetter: Use \"→ Step: Define function backtrack(startIndex, currentCombination, remaining)\" as a step. Then lines for inside function with indent arrow? Could be \"→  Step\" or \"→ Decision\".\n\nLet's produce:\n\n→ Step: Define function backtrack(startIndex, currentCombination, remaining) // 递归函数\n\nThen inside:\n\n→  Decision: 如果 remaining == 0? // 找到合法组合\n    →  Yes → Step: Add copy of currentCombination to result // 保存组合\n    →  No  → Decision: 如果 remaining < 0? // 超过目标\n        →  Yes → Step: Return // 结束此路径\n        →  No  → For i from startIndex to len(candidates)-1: // 逐个尝试\n            →  Decision: 如果 i > startIndex 且 candidates[i] == candidates[i-1]? // 跳过重复\n                →  Yes → Step: Continue // 跳过此循环\n                →  No  → Step: Append candidates[i] to currentCombination // 选取该数字\n                    →  Step: Call backtrack(i+1, currentCombination, remaining - candidates[i]) // 递归下去\n                    →  Step: Remove last element from currentCombination // 回溯\n\nBut need to keep each step separate line.\n\nLet's produce line list accordingly.\n\nWe must keep arrow usage: \"→ Decision:\" etc.\n\nMake sure each line has a space between virtual code and explanation comment.\n\nWe'll produce like:\n\nStart // 程式開始執行\n→ Step: Sort candidates ascending // 為了方便去除重複組合\n→ Step: Initialize result list // 用於儲存所有合法組合\n→ Step: Define function backtrack(startIndex, currentCombination, remaining) // 递归函数\n→   Decision: 如果 remaining == 0? // 找到合法组合\n        Yes → Step: Add copy of currentCombination to result // 保存组合\n        No  → Decision: 如果 remaining < 0? // 超过目标\n            Yes → Step: Return // 结束此路径\n            No  → Step: For i from startIndex to len(candidates)-1: // 逐个尝试\n                → Decision: 如果 i > startIndex 且 candidates[i] == candidates[i-1]? // 跳过重复\n                    Yes → Step: Continue // 跳过此循环\n                    No  → Step: Append candidates[i] to currentCombination // 选取该数字\n                        → Step: Call backtrack(i+1, currentCombination, remaining - candidates[i]) // 递归下去\n                        → Step: Remove last element from currentCombination // 回溯\n→ Step: Call backtrack(0, [], target) // 开始搜索\nEnd // 程式執行結束\n\nBut indentation may be confusing. Each line must be \"虛擬碼步驟\" with arrow maybe, but we can show indentation by preceding with spaces? Not specified. But we can just keep all lines separate. It's okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: Sort candidates ascending // 為了方便後續去除重複組合\n→ Step: Initialize result list // 用於儲存所有合法組合\n→ Step: Define function backtrack(startIndex, currentCombination, remaining) // 递归函数，探索子问题\n→   Decision: 如果 remaining == 0? // 已找到一组符合目标的组合\n        Yes → Step: Add copy of currentCombination to result // 保存该组合\n        No  → Decision: 如果 remaining < 0? // 当前和已超过目标\n            Yes → Step: Return // 结束此路径\n            No  → Step: For i from startIndex to len(candidates)-1: // 逐个尝试剩余数字\n                → Decision: 如果 i > startIndex 且 candidates[i] == candidates[i-1]? // 跳过相同数字以避免重复组合\n                    Yes → Step: Continue // 跳过本次循环\n                    No  → Step: Append candidates[i] to currentCombination // 选取该数字\n                        → Step: Call backtrack(i+1, currentCombination, remaining - candidates[i]) // 递归往下探索\n                        → Step: Remove last element from currentCombination // 回溯，恢复状态\n→ Step: Call backtrack(0, [], target) // 开始搜索\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,4,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 4, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport random\nfrom collections import defaultdict\nimport ast\n\nclass Solution:\n    def __init__(self, nums):\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        return random.choice(self.indices[target])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入包成一個元組以便直接解析\n    ops, args = ast.literal_eval('(' + data + ')')\n    res = []\n    obj = None\n    for method, arg in zip(ops, args):\n        if method == \"Solution\":\n            obj = Solution(arg[0])  # arg[0] 是整數陣列\n            res.append(None)\n        else:  # pick\n            res.append(obj.pick(arg[0]))\n    # 將 None 轉成 null 以符合題目輸出格式\n    output = '[' + ', '.join('null' if x is None else str(x) for x in res) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with explanation, not actual code. It's for a problem: Random Pick with Weight? Actually \"Random Pick Index\" LeetCode 398. Implementation: store mapping from number to list of indices. Constructor: build dict. pick: random choice among list.\n\nWe output step-by-step virtual code for class Solution. Provide constructor and pick method. Use Start, End, Decision. Show storing mapping. Random selection.\n\nWe produce each line: \"Start\", \"→ Step: ...\", etc. Provide explanation after //.\n\nWe need to ensure it's in Traditional Chinese. So explanations in Chinese.\n\nLet's produce virtual code:\n\nStart\n→ Step: 建立空字典 value_to_indices // 用於存儲每個數值對應的索引列表\n→ Step: 遍歷 nums 以填充字典 // 為每個值將其索引加入對應列表\n    → Decision: 若 value 在字典中？ // 檢查是否已有該數值\n        Yes → Step: 將索引追加到 value 的列表中 // 已有則加入\n        No  → Step: 建立新列表並加入索引 // 無則創建並加入\n→ End // 建構完成\n\n→ Method: pick(target)\n    → Decision: 取得 target 的索引列表 list = value_to_indices[target] // 從字典取列表\n        Yes → Step: 確認列表非空 // 但題目保證存在\n    → Step: 生成隨機整數 r 在 [0, len(list)-1] // 隨機索引位置\n    → Step: 回傳 list[r] // 返回對應的索引\n\nEnd\n\nBut we need to follow format with Start, End. Also include class definition? Virtual code steps.\n\nLet's structure:\n\nStart // 程式開始\n→ Step: 定義類別 Solution // 建立 Solution 類\n    → Step: 初始化方法: Solution(nums) // 接受數組\n        → Step: 建立空字典 value_to_indices // 用於存儲索引\n        → Step: 遍歷 nums 並填充字典 // 逐一加入索引\n            → Decision: 若 nums[i] 已在字典中? // 檢查\n                Yes → Step: value_to_indices[nums[i]].append(i) // 加入\n                No  → Step: value_to_indices[nums[i]] = [i] // 創建\n        → End // 初始化完成\n    → Step: 方法 pick(target) // 隨機選取\n        → Step: idx_list = value_to_indices[target] // 取列表\n        → Step: rand_idx = random_int(0, len(idx_list)-1) // 隨機\n        → Step: return idx_list[rand_idx] // 回傳\n    → End // 方法完成\n→ End // 類定義結束\nEnd // 程式結束\n\nWe need to maintain \"→ Decision:\" structure properly. Provide comments.\n\nLet's output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step: 定義類別 Solution // 建立 Solution 類\n    → Step: 初始化方法: Solution(nums) // 建構子，接收整數陣列\n        → Step: 建立空字典 value_to_indices // 用於儲存每個數值對應的索引列表\n        → Step: 迭代 i 從 0 到 len(nums)-1 // 遍歷陣列\n            → Decision: nums[i] 是否已在字典中? // 檢查是否已有該數值\n                Yes → Step: value_to_indices[nums[i]].append(i) // 已存在，追加索引\n                No  → Step: value_to_indices[nums[i]] = [i] // 新數值，建立列表\n        → End // 初始化完成，字典已填滿\n    → Step: 方法 pick(target) // 隨機挑選目標數值的索引\n        → Step: idx_list = value_to_indices[target] // 取得所有該目標值的索引列表\n        → Step: rand_idx = random_int(0, len(idx_list)-1) // 產生範圍內的隨機整數\n        → Step: return idx_list[rand_idx] // 回傳對應索引\n    → End // pick 方法結束\n→ End // 類別 Solution 定義結束\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3, 2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立字典：把每個單字的逆序對應到其索引\n        reverse_map = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        # 判斷字串是否為迴文\n        def is_pal(s: str) -> bool:\n            return s == s[::-1]\n\n        # 對每個單字做所有可能的分割\n        for i, word in enumerate(words):\n            length = len(word)\n            for j in range(length + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                # 1. 前半部為迴文 → 在前面加上後半部逆序的單字\n                if is_pal(prefix):\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in reverse_map:\n                        idx = reverse_map[rev_suffix]\n                        if idx != i:\n                            res.append([idx, i])\n\n                # 2. 後半部為迴文且 j != length 以避免重複 → 在後面加上前半部逆序的單字\n                if j != length and is_pal(suffix):\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in reverse_map:\n                        idx = reverse_map[rev_prefix]\n                        if idx != i:\n                            res.append([i, idx])\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 取得 '[' 與 ']' 之間的字串並使用 literal_eval 轉成 list\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        words = []\n    else:\n        list_str = data[start:end+1]\n        words = ast.literal_eval(list_str)\n\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps to find palindrome pairs in an array of unique strings. Need O(total length) runtime. Classic solution uses a hash map of reversed words and checking splits. We need to produce steps line by line with explanations. Let's design algorithm:\n\nStart\n→ Build map: for each word, store reverse(word) → index\n→ Initialize result list\n→ For each word at index i:\n   → For each split position from 0 to len(word):\n       → prefix = word[0:pos], suffix = word[pos:]\n       → If prefix is palindrome:\n           → If reverse(suffix) exists and not equal i → add (reverse(suffix), i)\n       → If suffix is palindrome and pos != len(word): // avoid duplicate when pos==len\n           → If reverse(prefix) exists and not equal i → add (i, reverse(prefix))\n→ Return result\nEnd\n\nWe need to ensure we don't double count. Use checks. Also unique strings guarantee no duplicates. Complexity O(total length). Need explanation for each line.\n\nLet's produce lines with \"→\" and steps. Use \"Decision:\" for conditions.\n\nAlso need to include Start and End. Let's produce.\n\nCheck: For splits, positions 0..len, inclusive? For prefix palindrome case, include empty prefix; suffix reversed may be empty? but words are unique non-empty? Might handle. We will include pos from 0 to len(word). For suffix palindrome condition, we need pos from 0 to len(word)-1 maybe. We'll implement accordingly.\n\nLet's output pseudo-code.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 reverseMap // 用來快速查找逆序字串對應的索引\n→ Decision: 迭代 words 並填充 reverseMap\n    → For 每個單字 words[i]\n        → reverseMap[ reverse(words[i]) ] ← i // 把逆序字串對應到其原始索引\n→ Step 2: 初始化結果列表 result // 存放所有符合的 (i, j) 組合\n→ Decision: 針對每個單字 words[i] 進行分割檢查\n    → For 每個單字 words[i]（索引 i）\n        → Decision: 從位置 0 到 len(words[i]) 逐一分割\n            → For pos 在 0 … len(words[i]) \n                → prefix ← words[i][0:pos] // 取前半部\n                → suffix ← words[i][pos:]   // 取後半部\n                → Decision: prefix 是否為迴文？\n                    → Yes → Decision: reverseMap 內是否有 suffix 的逆序字串？\n                        → Yes → reverseIdx ← reverseMap[ reverse(suffix) ]\n                            → Decision: reverseIdx != i？\n                                → Yes → result ← result + (reverseIdx, i) // 把 (reverseIdx, i) 加入結果\n                                → No  → // 同一個單字，忽略\n                    → No  → // 直接跳過\n                → Decision: suffix 是否為迴文？ 且 pos < len(words[i]) 以避免重複\n                    → Yes → Decision: reverseMap 內是否有 prefix 的逆序字串？\n                        → Yes → reverseIdx ← reverseMap[ reverse(prefix) ]\n                            → Decision: reverseIdx != i？\n                                → Yes → result ← result + (i, reverseIdx) // 把 (i, reverseIdx) 加入結果\n                                → No  → // 同一個單字，忽略\n                    → No  → // 直接跳過\n→ Step 3: 回傳 result // 完成所有符合條件的迴文對\nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef find_lus_length(strs):\n    \"\"\"\n    Find the length of the longest uncommon subsequence among the given strings.\n    A string that appears only once in the list cannot be a subsequence of any\n    other string in the list, so the longest such string is the answer.\n    \"\"\"\n    freq = {}\n    for s in strs:\n        freq[s] = freq.get(s, 0) + 1\n\n    max_len = 0\n    for s, cnt in freq.items():\n        if cnt == 1 and len(s) > max_len:\n            max_len = len(s)\n\n    return max_len if max_len > 0 else -1\n\n\ndef main():\n    \"\"\"\n    Read input from stdin, parse it as a list of strings, compute the answer,\n    and print the result to stdout.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        print(-1)\n        return\n\n    try:\n        strs = ast.literal_eval(data)\n        if not isinstance(strs, list):\n            print(-1)\n            return\n    except Exception:\n        print(-1)\n        return\n\n    result = find_lus_length(strs)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps for problem: longest uncommon subsequence length. Approach: The longest uncommon subsequence between an array of strings: basically if there exists a string that is not equal to any other string, then answer is its length. Because if a string is unique, it cannot be subsequence of others? Wait definition: uncommon subsequence between an array of strings is a string that is a subsequence of one string but not the others. The longest uncommon subsequence is the longest string that satisfies that. Known solution: if there exists string that is not equal to any other, answer is its length. Else answer -1. Actually if duplicates exist, then can't use duplicate. But maybe longer unique string is subsequence of another? But the longest common solution is: if there is any string that is not equal to any other, answer is its length. Because any longer string that is a subsequence of one string but not the others cannot exist if all strings are same? If duplicates only, answer -1. If all strings same, -1. If there is at least one unique string, its length is longest uncommon subsequence.\n\nEdge: If two strings different, the longer one is not subsequence of shorter? But could be subsequence of other? For example strs = [\"aba\",\"cdc\",\"eae\"]. Each unique, lengths 3. Answer 3. So algorithm: Count frequency of each string. For each string if freq==1, track max length. If max==0 return -1 else return max.\n\nImplement pseudocode. Need to produce line by line with explanations. Use Start, Decision, etc. Ok. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 freq 以儲存每個字串的出現次數 // 用於統計重複度  \n→ Step 2: 迭代輸入陣列 strs  \n    → Step 2.1: 若字串在 freq 中不存在，將其加入並設為 1  \n    → Step 2.2: 若已存在，將其計數加 1 // 完成頻率統計  \n→ Step 3: 設定變數 maxLen 為 0 // 追蹤最長的不重複字串長度  \n→ Step 4: 迭代 freq 中每個 (字串, 次數)  \n    → Decision: 次數等於 1? // 只考慮唯一出現的字串  \n        Yes → Step 4.1: 若字串長度 > maxLen，更新 maxLen 為該長度 // 找到更長的不重複字串  \n        No  → Step 4.2: 省略 // 重複的字串無法成為最長不常見子序列  \n→ Decision: maxLen 為 0? // 若未找到唯一字串  \n    Yes → Step 5: 回傳 -1 // 無法形成不常見子序列  \n    No  → Step 6: 回傳 maxLen // 返回最長的不常見子序列長度  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def permute(self, nums):\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Find the first '[' and the last ']'\n    left = data.find('[')\n    right = data.rfind(']')\n    if left == -1 or right == -1 or right <= left:\n        print(\"[]\")\n        sys.exit(0)\n    nums_str = data[left:right+1]\n    try:\n        nums = eval(nums_str, {}, {})\n    except Exception:\n        print(\"[]\")\n        sys.exit(0)\n\n    solution = Solution()\n    result = solution.permute(nums)\n\n    # Format output without spaces\n    output = '[' + ','.join('[' + ','.join(str(x) for x in perm) + ']' for perm in result) + ']'\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanation. Should reflect algorithm to generate permutations of distinct integers. Use recursion/backtracking. Need to produce all permutations. The user request: \"Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\" So we produce pseudocode lines.\n\nWe'll output like:\n\nStart\n→ Step 1: 定義輸入陣列 nums\n→ Step 2: 初始化結果列表 result\n→ Step 3: 定義遞迴函式 backtrack(current, remaining)\n→ Step 4: If remaining 為空: 把 current 加入 result\n→ Step 5: 否則 遍歷 remaining 中每個元素\n   → Step 5a: 創建新的 current+元素\n   → Step 5b: 創建新的 remaining-元素\n   → Step 5c: 呼叫 backtrack(new_current, new_remaining)\n→ Step 6: 呼叫 backtrack([], nums)\n→ Step 7: 返回 result\nEnd\n\nBut must use arrow syntax. Also use Decision: for condition.\n\nWe should include step numbering maybe, but not necessary. But each line must be \"虛擬碼步驟 // 解釋\". Use arrow →. Use Decision: for condition.\n\nSo lines:\n\nStart // 程式開始執行\n→ Step 1: 定義輸入陣列 nums // 接收輸入數字陣列\n→ Step 2: 初始化結果列表 result // 用於儲存所有排列\n→ Step 3: 定義遞迴函式 backtrack(current, remaining) // current為已選取的元素，remaining為尚未選取的元素\n→ Step 4: Decision: 如果 remaining 為空? // 判斷是否已選完所有元素\n    Yes → Step 5: result.Add(current) // 完成一個排列，加入結果\n    No  → Step 6: Decision: 遍歷 remaining 中每個元素? // 逐一選取\n        Yes → Step 7: newCurrent ← current + [element] // 將元素加入已選取\n        → Step 8: newRemaining ← remaining - [element] // 移除已選取的元素\n        → Step 9: backtrack(newCurrent, newRemaining) // 進一步遞迴\n→ Step 10: backtrack([], nums) // 從空已選取開始遞迴\n→ Step 11: Return result // 回傳所有排列\nEnd // 程式執行結束\n\nNeed to maintain arrow for each line. But inside Decision we indent steps. According to format, they use indentation for nested steps. Should we put \"→\" before nested steps. Provide explanation after each line.\n\nAlso Step 6: Decision: 遍歷 remaining 中每個元素? Actually \"Decision: for each element\" might not be a decision but a loop. But we can use Decision: for element in remaining? maybe treat as loop. But we might use \"Decision:\" for each iteration? Use \"Decision: 仍有未選取元素?\" or we can use \"Decision: 是否已完成遞迴?\" etc. But loop can be represented by Decision: 仍有元素? but we can just list steps inside. Let's produce simple representation.\n\nAlso maybe use \"Decision: 是否為空?\" then Yes/No.\n\nWithin No branch, we iterate, we can just list steps as part of loop.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義輸入陣列 nums // 接收輸入數字陣列  \n→ Step 2: 初始化結果列表 result // 用於儲存所有排列  \n→ Step 3: 定義遞迴函式 backtrack(current, remaining) // current 為已選取的元素，remaining 為尚未選取的元素  \n→ Step 4: Decision: 如果 remaining 為空? // 判斷是否已選完所有元素  \n  Yes → Step 5: result.Add(current) // 完成一個排列，加入結果  \n  No  → Decision: 遍歷 remaining 中每個元素? // 逐一選取每個未選取的元素  \n   Yes → Step 6: newCurrent ← current + [element] // 將當前元素加入已選取序列  \n   → Step 7: newRemaining ← remaining - [element] // 移除已選取的元素  \n   → Step 8: backtrack(newCurrent, newRemaining) // 進一步遞迴處理剩餘元素  \n→ Step 9: backtrack([], nums) // 從空已選取序列開始遞迴  \n→ Step 10: Return result // 回傳所有已生成的排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Text Justification",
      "source_file": "Leetcode/leetcode68.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5yc3la6o.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmp5yc3la6o.py\", line 46, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpx502zy3i.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpx502zy3i.py\", line 46, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpepr36tmb.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpepr36tmb.py\", line 46, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # determine how many words can fit in the line\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            # build the line\n            line_words = words[i:j]\n            spaces_needed = maxWidth - sum(len(word) for word in line_words)\n            gaps = len(line_words) - 1\n\n            if j == n or gaps == 0:\n                # left-justify for last line or single word\n                line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n            else:\n                # fully justify\n                space, extra = divmod(spaces_needed, gaps)\n                line_parts = []\n                for k in range(gaps):\n                    line_parts.append(line_words[k] + ' ' * (space + (1 if k < extra else 0)))\n                line_parts.append(line_words[-1])\n                line = ''.join(line_parts)\n\n            res.append(line)\n            i = j\n\n        return res\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    # Execute the input to get variables `words` and `maxWidth`\n    local_vars = {}\n    exec(data, {}, local_vars)\n    words = local_vars['words']\n    maxWidth = local_vars['maxWidth']\n\n    solution = Solution()\n    justified_text = solution.fullJustify(words, maxWidth)\n    print(justified_text)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code with step-by-step explanation, each line containing \"虛擬碼步驟 // 解釋\". Use arrow and decision structure. The algorithm: iterate over words, gather words into current line until next word would exceed maxWidth. Then build line: if last line or only one word -> left-justified: join with single spaces, pad end. Else distribute spaces evenly: total spaces = maxWidth - sum lengths of words. slots = words_count - 1. base = total_spaces // slots, extra = total_spaces % slots. Build string: for i < slots: add word + spaces(base + (i<extra?1:0)), last word + no space. Continue. End. Provide virtual code lines accordingly.\n\nLet's produce: Start, loop over words: set index, gather. Build line. Add to result. After loop, output. Use pseudocode. Provide explanation.\n\nLet's craft.\n\nUse arrow: →. Use Decision: etc.\n\nNeed to ensure each line includes virtual code then space then comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ wordsIndex ← 0 // 取得第一個單字索引  \n→ result ← 空清單 // 儲存排版後的每一行  \n\n→ Decision: wordsIndex 是否小於 words 數量? // 是否還有未處理的單字  \n    Yes → → lineWords ← 空清單 // 目前行的單字列表  \n    Yes → → lineLen ← 0 // 目前行單字總長度（不含空格）  \n\n    → Decision: wordsIndex 是否小於 words 數量? // 再次確認是否還有單字  \n        Yes → → nextWord ← words[wordsIndex] // 取下一個單字  \n        Yes → → Decision: lineLen + nextWord.length + lineWords 數量 是否 ≤ maxWidth?  \n            Yes → → lineWords ← lineWords 加 nextWord // 將單字加入目前行  \n            Yes → → lineLen ← lineLen + nextWord.length // 更新行長度  \n            Yes → → wordsIndex ← wordsIndex + 1 // 移到下一個單字  \n            No  → → // 無法再加入，結束目前行的收集  \n                → Decision: wordsIndex == words 數量 且 lineWords 數量 == 1? // 是否是最後一行且只有一個單字？  \n                    Yes → → lineText ← lineWords[0] + 重複空格(maxWidth - lineWords[0].length) // 左對齊，填滿剩餘空格  \n                    No  → → Decision: wordsIndex == words 數量? // 是最後一行？  \n                        Yes → → // 最後一行左對齊  \n                            → lineText ← 空字串  \n                            → For each word in lineWords  \n                                → lineText ← lineText + word + 空格  \n                            → lineText ← lineText 去除最後一個空格  \n                            → lineText ← lineText + 重複空格(maxWidth - lineText.length) // 右側填充空格  \n                        No  → → // 非最後一行，完全左右對齊  \n                            → totalSpaces ← maxWidth - lineLen // 必須填充的空格總數  \n                            → slots ← lineWords 數量 - 1 // 需要插入空格的間隙數  \n                            → baseSpace ← totalSpaces // slots // 每個間隙最少空格數  \n                            → extraSpace ← totalSpaces % slots // 需額外分配給左側空隙的空格數  \n                            → lineText ← 空字串  \n                            → For i from 0 到 slots-1  \n                                → lineText ← lineText + lineWords[i] + 重複空格(baseSpace + (i < extraSpace ? 1 : 0)) // 左側多一空格  \n                            → lineText ← lineText + lineWords[slots] // 最後一個單字  \n                → result ← result 加 lineText // 加入排版後的行到結果清單  \n    No  → // 已處理完所有單字，進入清理最後一行（若仍有未排版單字）  \n        → Decision: lineWords 數量 > 0? // 有剩餘單字？  \n            Yes → → lineText ← 空字串  \n            Yes → → For each word in lineWords  \n                → lineText ← lineText + word + 空格  \n            Yes → → lineText ← lineText 去除最後一個空格  \n            Yes → → lineText ← lineText + 重複空格(maxWidth - lineText.length) // 右側填充空格  \n            Yes → → result ← result 加 lineText // 加入最後一行  \n\nEnd // 程式執行結束，輸出結果清單 result"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass MedianFinder:\n    def __init__(self):\n        # 小堆（最大堆）存放較小的一半數字，使用負值模擬最大堆\n        self.small = []  # Max-heap: store negatives\n        # 大堆（最小堆）存放較大的一半數字\n        self.large = []  # Min-heap\n\n    def addNum(self, num: int) -> None:\n        # 先將數字推入小堆\n        heapq.heappush(self.small, -num)\n\n        # 保持兩堆大小差不超過 1\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 調整小堆過大\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # 調整大堆過大\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        # 若小堆較多，返回其最大值\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        # 否則平均兩堆頂部值\n        return (-self.small[0] + self.large[0]) / 2.0\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入拆成兩個列表：方法名稱和對應參數\n    split_idx = data.find('],')\n    if split_idx == -1:\n        parts = data.split(',', 1)\n        methods = ast.literal_eval(parts[0].strip())\n        args = ast.literal_eval(parts[1].strip())\n    else:\n        first_part = data[:split_idx+1]\n        second_part = data[split_idx+2:].strip()\n        methods = ast.literal_eval(first_part.strip())\n        args = ast.literal_eval(second_part.strip())\n\n    results = []\n    obj = None\n\n    for method, arg in zip(methods, args):\n        if method == 'MedianFinder':\n            obj = MedianFinder()\n            results.append(None)\n        elif method == 'addNum':\n            obj.addNum(arg[0])  # arg 是單元素列表\n            results.append(None)\n        elif method == 'findMedian':\n            results.append(obj.findMedian())\n        else:\n            results.append(None)\n\n    # 輸出結果，將 None 轉成 JSON 的 null\n    output = '[' + ', '.join('null' if x is None else str(x) for x in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the class MedianFinder with methods addNum and findMedian. We need to implement logic for median using two heaps. We'll produce pseudocode lines with arrows and explanations. The format: \"虛擬碼步驟 // 解釋\". Each line uses virtual arrows. Should start with Start and End. Use Decision lines. We'll explain the algorithm: Use two heaps: max-heap for lower half, min-heap for upper half. Maintain sizes balanced. In addNum, compare with top of max-heap to decide which heap to push. Then rebalance. In findMedian, if sizes equal, median = (max-heap top + min-heap top)/2 else median = top of larger heap.\n\nWe'll produce step-by-step pseudocode for class initialization and methods. We can show flow of addNum and findMedian separately. Probably separate blocks with Start and End for each method. Or we can incorporate inside class.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 建立 MedianFinder 類別 // 宣告兩個堆疊\n    → Step 1.1: lower = MaxHeap // 用於儲存較小的一半\n    → Step 1.2: higher = MinHeap // 用於儲存較大的一半\nEnd // 完成初始化\n\nBut we need to show virtual steps for addNum and findMedian.\n\nWe will produce a block for addNum:\n\nStart // addNum 方法開始\n→ Step 1: 如果 lower 為空 或 num ≤ lower.peek() → push num 到 lower\n    → Decision: ...\n→ Step 2: 否則 push num 到 higher\n→ Step 3: 若 lower.size() > higher.size() + 1 → move top from lower to higher\n→ Step 4: 若 higher.size() > lower.size() + 1 → move top from higher to lower\nEnd // addNum 方法結束\n\nSimilarly findMedian:\n\nStart // findMedian 方法開始\n→ Decision: 如果 lower.size() == higher.size()\n    → Yes → Step 1: median = (lower.peek() + higher.peek()) / 2.0\n    → No → Decision: 如果 lower.size() > higher.size()\n        → Yes → Step 2: median = lower.peek()\n        → No  → Step 3: median = higher.peek()\nEnd // findMedian 方法結束\n\nWe need each line with comment. We'll produce all lines with the arrow syntax. For decisions, indent accordingly.\n\nWe need to ensure the arrow and \"Decision:\" lines. Use \"Yes →\" \"No →\".\n\nLet's produce. We'll include \"Start\" and \"End\" at the top-level. Provide separate sections for class initialization, addNum, findMedian. Could treat each method separately but maybe within class.\n\nSimplify: Use \"Start\" at class definition. Then \"Step 1: Init heaps\". Then separate blocks for addNum and findMedian. Use \"End\" at end.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 MedianFinder 類別 // 宣告兩個堆疊，lower 為最大堆，higher 為最小堆  \n  → Step 1.1: lower ← MaxHeap() // 儲存較小的一半  \n  → Step 1.2: higher ← MinHeap() // 儲存較大的一半  \n\n// ---------------------- addNum 方法 ----------------------\nStart // addNum 方法開始  \n→ Step 1: 如果 lower 為空 或 num ≤ lower.peek() → push num 到 lower // 判斷將數字放進哪一堆  \n  → Decision: 若 true?  \n    Yes → Step 1.1: lower.push(num) // 把 num 加入 lower  \n    No  → Step 1.2: higher.push(num) // 否則加到 higher  \n→ Step 2: 若 lower.size() > higher.size() + 1 → move top from lower to higher // 重新平衡堆  \n  → Decision: 若 true?  \n    Yes → Step 2.1: temp ← lower.pop()  \n      higher.push(temp)  \n→ Step 3: 若 higher.size() > lower.size() + 1 → move top from higher to lower // 重新平衡堆  \n  → Decision: 若 true?  \n    Yes → Step 3.1: temp ← higher.pop()  \n      lower.push(temp)  \nEnd // addNum 方法結束  \n\n// ---------------------- findMedian 方法 ----------------------\nStart // findMedian 方法開始  \n→ Decision: 如果 lower.size() == higher.size()? // 判斷堆大小是否相等  \n  Yes → Step 1: median ← (lower.peek() + higher.peek()) / 2.0 // 兩堆均勻，取平均  \n  No  → Decision: 如果 lower.size() > higher.size()?  \n    Yes → Step 2: median ← lower.peek() // lower 更大，取其最大值  \n    No  → Step 3: median ← higher.peek() // higher 更大，取其最小值  \nEnd // findMedian 方法結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcgj9ee1e.py\", line 38, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    intervals = [[1,3],[6,9]], newInterval = [2,5]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpenmshesc.py\", line 38, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result: List[List[int]] = []\n        # 以 local 變數保存 newInterval 的起點與終點，方便在迴圈中更新\n        start, end = newInterval[0], newInterval[1]\n        added = False  # 標記 newInterval 是否已加入結果\n\n        for interval in intervals:\n            i_start, i_end = interval\n            # 1. 當區間完全在 newInterval 的左側時，直接加入\n            if i_end < start:\n                result.append([i_start, i_end])\n                continue\n            # 2. 當區間完全在 newInterval 的右側時\n            if i_start > end:\n                if not added:\n                    result.append([start, end])  # 加入新區間\n                    added = True\n                result.append([i_start, i_end])   # 加入後續區間\n                continue\n            # 3. 兩區間重疊，進行合併\n            start = min(start, i_start)\n            end = max(end, i_end)\n\n        # 迴圈結束後，如果 newInterval 還沒加入，將其加入\n        if not added:\n            result.append([start, end])\n\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，預期格式類似:  intervals = [[1,3],[6,9]], newInterval = [2,5]\n    data = sys.stdin.read()\n    # 用 exec 執行，讓變數 intervals 與 newInterval 變成本地變數\n    exec(data, globals())\n    # 確保兩個變數都存在\n    intervals = globals().get('intervals', [])\n    newInterval = globals().get('newInterval', [])\n    # 呼叫解法\n    sol = Solution()\n    merged = sol.insert(intervals, newInterval)\n    # 輸出結果\n    print(merged)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for merging intervals. We must do step-by-step. Should be clear.\n\nWe'll produce steps:\n\nStart, initialize result array, iterate intervals.\n\n- For each interval, if current.end < newInterval.start: append interval\n- Else if interval.start > newInterval.end: if newInterval not yet added: append newInterval, mark added; then append interval\n- Else overlapping: merge by updating newInterval.start = min(newInterval.start, interval.start), newInterval.end = max(newInterval.end, interval.end)\nAfter loop, if not added, append newInterval\nReturn result\n\nNeed to use decision arrows. Ensure each line ends with // explanation.\n\nLet's output each step line. Let's use proper indentation for decisions.\n\nWe'll include array variable names.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告 result 為空陣列 // 用來儲存合併後的區間  \n→ Step 2: 宣告 newStart, newEnd 為 newInterval[0], newInterval[1] // 以便在迴圈中更新  \n→ Step 3: 宣告 added 為 False // 標記 newInterval 是否已加入 result  \n→ Step 4: 循環遍歷 intervals，設定 i 為每個區間 // 逐一處理每個原始區間  \n  → Decision: if i.end < newStart? // 判斷區間是否完全在 newInterval 之前  \n    Yes → Step 5: 輸入 i 到 result // 完全不重疊，直接加入  \n    No  → Decision: if i.start > newEnd? // 判斷區間是否完全在 newInterval 之後  \n      Yes → Decision: if added == False? // 新區間還沒加入  \n        Yes → Step 6: 輸入 [newStart, newEnd] 到 result // 加入 newInterval  \n          added = True // 標記已加入  \n       No  → Step 7: 輸入 i 到 result // 加入後續區間  \n          added = True // 標記已加入（已在前一步）  \n       No → Step 8: 合併 i 與 newInterval  \n         newStart = min(newStart, i.start) // 更新合併後的起點  \n         newEnd = max(newEnd, i.end) // 更新合併後的終點  \n→ Decision: if added == False? // 迴圈結束後檢查 newInterval 是否還未加入  \n   Yes → Step 9: 輸入 [newStart, newEnd] 到 result // 加入尚未加入的 newInterval  \n→ Step 10: 回傳 result // 結果返回  \nEnd // 程式執行結束"
    },
    {
      "title": "All O`one Data Structure",
      "source_file": "Leetcode/leetcode432.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg34ggnpf.py\", line 114, in <module>\n    main()\n  File \"/tmp/tmpg34ggnpf.py\", line 87, in main\n    ops = json.loads(lines[0])\n          ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 355, in raw_decode\n    raise JSONDecodeError(\"Expecting value\", s, err.value) from None\njson.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Node:\n    def __init__(self):\n        self.count = 0\n        self.keys = set()\n        self.prev = None\n        self.next = None\n\nclass AllOne:\n    def __init__(self):\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}\n\n    def _insert_after(self, prev_node, count):\n        node = Node()\n        node.count = count\n        node.prev = prev_node\n        node.next = prev_node.next\n        prev_node.next.prev = node\n        prev_node.next = node\n        return node\n\n    def _remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key):\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            next_count = node.count + 1\n            if node.next == self.tail or node.next.count > next_count:\n                new_node = self._insert_after(node, next_count)\n            else:\n                new_node = node.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            if self.head.next == self.tail or self.head.next.count > 1:\n                new_node = self._insert_after(self.head, 1)\n            else:\n                new_node = self.head.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n\n    def dec(self, key):\n        if key not in self.key_to_node:\n            return\n        node = self.key_to_node[key]\n        prev_count = node.count - 1\n        node.keys.remove(key)\n        if prev_count == 0:\n            del self.key_to_node[key]\n        else:\n            if node.prev == self.head or node.prev.count < prev_count:\n                new_node = self._insert_after(node.prev, prev_count)\n            else:\n                new_node = node.prev\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self):\n        if self.tail.prev == self.head:\n            return \"\"\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self):\n        if self.head.next == self.tail:\n            return \"\"\n        return next(iter(self.head.next.keys))\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    # Filter out any empty lines\n    lines = [line for line in data if line.strip() != \"\"]\n    if len(lines) < 2:\n        return\n    ops = json.loads(lines[0])\n    args_list = json.loads(lines[1])\n\n    result = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"AllOne\":\n            obj = AllOne()\n            result.append(None)\n        elif op == \"inc\":\n            obj.inc(args[0])\n            result.append(None)\n        elif op == \"dec\":\n            obj.dec(args[0])\n            result.append(None)\n        elif op == \"getMaxKey\":\n            result.append(obj.getMaxKey())\n        elif op == \"getMinKey\":\n            result.append(obj.getMinKey())\n        else:\n            # Unknown operation, append None\n            result.append(None)\n\n    print(\"Output\")\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudo code for implementing the AllOne data structure with O(1) operations. Usually solution uses double linked list of count nodes and hashmap of key->node. Provide steps.\n\nWe need to output line by line with arrow.\n\nLet's produce steps: Start, initialize maps, etc. Then inc, dec, getMaxKey, getMinKey functions.\n\nWe should produce pseudo code with decisions, loops.\n\nImportant: Each line must include \"→\" and explanation comment after space.\n\nLet's structure: Start of class initialization.\n\nUse dictionary keyCount? Actually key to node pointer.\n\nUse Node structure: count, set of keys.\n\nAlso head sentinel and tail sentinel.\n\nImplement inc: get node of key; if none, insert new node with count1 after head? Actually head holds smallest count. Use map to node.\n\nImplementation steps.\n\nAlso dec: similar.\n\nEdge cases: removal of node when set empty.\n\ngetMaxKey: return any key from tail.prev.keys set or empty.\n\ngetMinKey: return any key from head.next.keys or empty.\n\nWill produce pseudo code lines.\n\nLet's craft.\n\nLine count not too large.\n\nUse decisions with \"Decision:\".\n\nLet's begin.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 創建頭尾哨兵節點 head, tail，並設置 head.next = tail, tail.prev = head // 初始化雙向鏈表的起始結構\n→ Step 2: 創建空字典 keyNodeMap // 存儲 key 與其所在節點的映射\n→ Step 3: 定義節點 Node { count, keySet, prev, next } // 節點結構包含計數、鍵集合及鏈表指針\n\n// --------------- inc(String key) ---------------\n→ Step 4: inc(key) // 進入增量操作\n→ Step 5: If keyNodeMap[key] 不存在? // 判斷 key 是否已存在\n    Yes → Step 6: 創建新節點 newNode(count=1, keySet={key}) // 為新 key 創建節點\n        → Step 7: 插入 newNode 到 head.next 位置 // 位置為最小計數\n        → Step 8: keyNodeMap[key] = newNode // 更新映射\n        → Step 9: End // 完成新增 key\n    No → Step 10: currentNode = keyNodeMap[key] // 取得目前節點\n        → Step 11: targetCount = currentNode.count + 1 // 計算新計數\n        → Step 12: If currentNode.next.count == targetCount? // 判斷下一節點是否已是目標計數\n            Yes → Step 13: targetNode = currentNode.next\n            No  → Step 14: 創建新節點 targetNode(count=targetCount, keySet=空) // 新建節點\n                → Step 15: 插入 targetNode 到 currentNode.next 位置\n        → Step 16: 移動 key 至 targetNode.keySet\n        → Step 17: 移除 key 從 currentNode.keySet\n        → Step 18: keyNodeMap[key] = targetNode // 更新映射\n        → Step 19: If currentNode.keySet 為空? // 若原節點已無鍵\n            Yes → Step 20: 從鏈表中移除 currentNode\n        → Step 21: End // 完成遷移\n\n// --------------- dec(String key) ---------------\n→ Step 22: dec(key) // 進入減量操作\n→ Step 23: currentNode = keyNodeMap[key] // 取得目前節點\n→ Step 24: targetCount = currentNode.count - 1 // 計算新計數\n→ Step 25: If targetCount == 0? // 若計數降至 0\n    Yes → Step 26: 從 keyNodeMap 刪除 key\n        → Step 27: 移除 key 從 currentNode.keySet\n        → Step 28: If currentNode.keySet 為空? // 若節點已空\n            Yes → Step 29: 從鏈表中移除 currentNode\n        → Step 30: End // 完成刪除\n    No  → Step 31: If currentNode.prev.count == targetCount? // 判斷前一節點是否已是目標計數\n        Yes → Step 32: targetNode = currentNode.prev\n        No  → Step 33: 創建新節點 targetNode(count=targetCount, keySet=空) // 新建節點\n            → Step 34: 插入 targetNode 到 currentNode.prev 位置\n    → Step 35: 移動 key 至 targetNode.keySet\n    → Step 36: 移除 key 從 currentNode.keySet\n    → Step 37: keyNodeMap[key] = targetNode // 更新映射\n    → Step 38: If currentNode.keySet 為空? // 若原節點已無鍵\n        Yes → Step 39: 從鏈表中移除 currentNode\n    → Step 40: End // 完成遷移\n\n// --------------- getMaxKey() ---------------\n→ Step 41: getMaxKey() // 取得最大計數鍵\n→ Step 42: If tail.prev == head? // 若鏈表空\n    Yes → Step 43: return \"\" // 返回空字串\n    No  → Step 44: maxNode = tail.prev\n→ Step 45: return 任意元素 from maxNode.keySet // 返回任一最大計數鍵\n\n// --------------- getMinKey() ---------------\n→ Step 46: getMinKey() // 取得最小計數鍵\n→ Step 47: If head.next == tail? // 若鏈表空\n    Yes → Step 48: return \"\" // 返回空字串\n    No  → Step 49: minNode = head.next\n→ Step 50: return 任意元素 from minNode.keySet // 返回任一最小計數鍵\n\nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        # 每個元素為 [l, r) 的區間，且不重疊，按 l 升序\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        if left >= right:\n            return\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        if left >= right:\n            return False\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i - 1][0] <= left and right <= self.ranges[i - 1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        if left >= right:\n            return\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef parse_arguments(s: str):\n    \"\"\"從 '(a, b)' 取得整數 a, b\"\"\"\n    s = s.strip()\n    if s.startswith('(') and s.endswith(')'):\n        s = s[1:-1]\n    parts = s.split(',')\n    return int(parts[0].strip()), int(parts[1].strip())\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit(0)\n    # 以分號分割指令，並去除空行與空白\n    commands = [cmd.strip() for cmd in data.split(';') if cmd.strip()]\n    results = []\n    range_module = None\n    for cmd in commands:\n        if cmd.startswith('RangeModule') and 'new RangeModule' in cmd:\n            range_module = RangeModule()\n            results.append('null')\n        elif cmd.startswith('rangeModule.addRange('):\n            args = cmd[cmd.find('(')+1:cmd.find(')')]\n            left, right = parse_arguments(args)\n            range_module.addRange(left, right)\n            results.append('null')\n        elif cmd.startswith('rangeModule.removeRange('):\n            args = cmd[cmd.find('(')+1:cmd.find(')')]\n            left, right = parse_arguments(args)\n            range_module.removeRange(left, right)\n            results.append('null')\n        elif cmd.startswith('rangeModule.queryRange('):\n            args = cmd[cmd.find('(')+1:cmd.find(')')]\n            left, right = parse_arguments(args)\n            res = range_module.queryRange(left, right)\n            results.append('true' if res else 'false')\n        else:\n            # 未識別的指令，略過\n            pass\n    print('[' + ', '.join(results) + ']')",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for designing a RangeModule data structure. Must be in Chinese traditional. Provide line-by-line virtual code with explanation comment. Use arrows and structure: Start, End, Decision. Need to design operations addRange, queryRange, removeRange, likely using a balanced BST or interval tree. But as virtual code, we can represent high-level steps. Provide a design with sorted list of intervals. So algorithm: maintain sorted list of non-overlapping intervals. For addRange: find insertion point, merge overlapping. For removeRange: split intervals if needed. For queryRange: check that interval fully covered by existing intervals.\n\nLet's craft pseudocode.\n\nStart\n→ Step: Initialize empty list intervals // store non-overlapping [l, r)\n→ Step: Define function addRange(left, right)\n    → Decision: If left >= right? // invalid, ignore\n        Yes → End\n        No  → Step: Find index i where intervals[i].right >= left // first interval that might overlap\n        → While i < len(intervals) and intervals[i].left <= right\n            → Decision: intervals[i].left <= right and intervals[i].right >= left? // overlapping\n                Yes → Step: left = min(left, intervals[i].left) // expand merge\n                       Step: right = max(right, intervals[i].right)\n                       Step: Remove intervals[i]\n                No  → Step: i++\n        → Insert new interval [left, right] at correct position // keep sorted\n→ Step: Define function queryRange(left, right)\n    → Decision: If left >= right? // invalid\n        Yes → Return False\n        No  → Step: Find interval j where intervals[j].right > left // potential covering\n        → Decision: intervals[j].left <= left and intervals[j].right >= right?\n            Yes → Return True\n            No  → Return False\n→ Step: Define function removeRange(left, right)\n    → Decision: If left >= right? // invalid\n        Yes → End\n        No  → Step: Find index i where intervals[i].right > left // first possibly overlapping\n        → While i < len(intervals) and intervals[i].left < right\n            → Decision: intervals[i].left < left and intervals[i].right > right? // interval fully covers removal\n                Yes → Step: Split into [intervals[i].left, left] and [right, intervals[i].right]\n                       Step: Replace intervals[i] with first part, insert second part after\n                No  → Decision: intervals[i].left < left? // left part remains\n                    Yes → Step: intervals[i].right = left\n                    No  → // no left part\n                → Decision: intervals[i].right > right? // right part remains\n                    Yes → Step: Insert new interval [right, intervals[i].right] after i\n                → Step: i++ // move to next after potential insertion\n        → End\nEnd\n\nBut need to ensure formatting lines with arrow and comments. We can indent decisions. Use \"Decision:\" lines with indentation. Each line should be \"虛擬碼步驟 // 解釋\". Provide arrow \"→\" before each step. Decision block lines should be \"Decision:\" preceded by arrow? Format says use \"Decision:\" as part of structure. We can follow sample: \n→ Decision: ... \n    Yes → ...\n    No  → ...\n\nThus each Decision line starts with arrow and \"Decision:\".\n\nLet's produce final answer.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step: 初始化 intervals 為空列表 // 用於儲存非重疊的 [left, right) 片段\n→ Step: 定義 addRange(left, right) // 加入一段區間\n    → Decision: left >= right? // 檢查參數合法性\n        Yes → End // 無效區間直接返回\n        No  → Step: 找到第一個 intervals[i].right >= left 的索引 i // 可能重疊的起點\n    → While i < intervals.length 且 intervals[i].left <= right\n        → Decision: intervals[i] 與 [left, right) 重疊嗎？\n            Yes → Step: left = min(left, intervals[i].left) // 合併左端\n                  Step: right = max(right, intervals[i].right) // 合併右端\n                  Step: 刪除 intervals[i] // 移除重疊的舊片段\n            No  → Step: i = i + 1 // 走到下一個片段\n    → Step: 在正確位置插入新片段 [left, right) // 保持排序且無重疊\n→ Step: 定義 queryRange(left, right) // 查詢一段區間是否全部被追蹤\n    → Decision: left >= right? // 檢查參數合法性\n        Yes → Return False // 空區間視為未被追蹤\n        No  → Step: 找到第一個 intervals[j].right > left 的索引 j // 可能覆蓋起點\n    → Decision: intervals[j].left <= left 且 intervals[j].right >= right?\n        Yes → Return True // 整段被覆蓋\n        No  → Return False // 未被完整覆蓋\n→ Step: 定義 removeRange(left, right) // 移除一段區間的追蹤\n    → Decision: left >= right? // 檢查參數合法性\n        Yes → End // 無效區間直接返回\n        No  → Step: 找到第一個 intervals[i].right > left 的索引 i // 可能重疊的起點\n    → While i < intervals.length 且 intervals[i].left < right\n        → Decision: intervals[i].left < left 且 intervals[i].right > right? // 整段覆蓋\n            Yes → Step: 將 intervals[i] 切成 [intervals[i].left, left] 與 [right, intervals[i].right] // 保留兩端\n                  Step: 替換 intervals[i] 為左端片段\n                  Step: 在 i+1 處插入右端片段\n        → Decision: intervals[i].left < left? // 只保留左端\n            Yes → Step: intervals[i].right = left\n        → Decision: intervals[i].right > right? // 只保留右端\n            Yes → Step: 在 i+1 處插入新片段 [right, intervals[i].right]\n        → Step: i = i + 1 // 移到下一個片段\n→ End // 程式執行結束\n```"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprl724hc1.py\", line 62, in <module>\n    commands, args = json.loads(data)\n                     ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0\n        self.count = 0\n\n    def insertFront(self, value):\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value):\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self):\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self):\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self):\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self):\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self):\n        return self.count == 0\n\n    def isFull(self):\n        return self.count == self.k\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    commands, args = json.loads(data)\n\n    obj = None\n    results = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MyCircularDeque\":\n            obj = MyCircularDeque(*arg)\n            results.append(None)\n        elif cmd == \"insertFront\":\n            results.append(obj.insertFront(arg[0]))\n        elif cmd == \"insertLast\":\n            results.append(obj.insertLast(arg[0]))\n        elif cmd == \"deleteFront\":\n            results.append(obj.deleteFront())\n        elif cmd == \"deleteLast\":\n            results.append(obj.deleteLast())\n        elif cmd == \"getFront\":\n            results.append(obj.getFront())\n        elif cmd == \"getRear\":\n            results.append(obj.getRear())\n        elif cmd == \"isEmpty\":\n            results.append(obj.isEmpty())\n        elif cmd == \"isFull\":\n            results.append(obj.isFull())\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output line-by-line virtual code with explanations, no actual code. Provide structure: Start, End, Decision, etc. We need to design the implementation of circular deque. So we produce virtual pseudocode for the class, with methods. Each line should be something like \"Start // 程式開始執行\". Then steps for initialization, insertion front, insertion last, delete front, delete last, get front, get rear, isEmpty, isFull. Use arrows and decisions.\n\nWe need to produce step-by-step operations with decision points. Use Start, End. The class definition maybe: \"Class MyCircularDeque\" but we can treat as steps within initialization. Provide variable definitions: capacity, array, front, rear, count. Provide logic. Each method produce steps.\n\nLet's write virtual code:\n\nStart // Start of algorithm\n\n→ Step 1: Initialize array of size k // array for storage\n→ Step 2: Set front = 0, rear = 0, size = 0 // pointers\n→ Step 3: Set capacity = k // maximum size\n\nThen methods. Maybe separate sections: InsertFront, InsertLast etc. Provide each as separate steps with decision whether full. We'll use Decision nodes.\n\nFor InsertFront:\n→ Decision: 如果 size == capacity? // full\n    Yes → Step: Return false // cannot insert\n    No  → Step: arr[(front - 1 + capacity) % capacity] = value // put value at new front\n          Step: front = (front - 1 + capacity) % capacity // move front pointer\n          Step: size++ // increment count\n          Step: Return true\n\nSimilar for InsertLast. DeleteFront: decision if empty, else get value, move front, decrement size. DeleteLast: decision if empty, else get value, move rear, decrement size.\n\nGetFront: decision if empty? Yes -> -1; No -> arr[front].\nGetRear: decision if empty? Yes -> -1; No -> arr[(rear -1 + capacity)%capacity].\n\nisEmpty: return size == 0. isFull: return size == capacity.\n\nWe'll format each line with code and comment.\n\nEnsure we output line-by-line. Use arrows. Provide Start and End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: MyCircularDeque(k) // 建立類別實例，k 為最大容量\n→ Step 2: arr ← array of size k // 用於儲存元素\n→ Step 3: front ← 0 // 前指標初始位置\n→ Step 4: rear ← 0  // 後指標初始位置\n→ Step 5: size ← 0  // 當前元素個數\n→ Step 6: capacity ← k // 最大容量\n\n// ---------- insertFront ----------\n→ Step 7: insertFront(value) // 方法入口\n→ Decision: 如果 size == capacity? // 判斷是否已滿\n    Yes → Step 8: Return false // 無法插入，返回失敗\n    No  → Step 9: front ← (front - 1 + capacity) mod capacity // 前移\n          Step 10: arr[front] ← value // 放入新值\n          Step 11: size ← size + 1 // 元素個數加一\n          Step 12: Return true // 成功插入\n\n// ---------- insertLast ----------\n→ Step 13: insertLast(value) // 方法入口\n→ Decision: 如果 size == capacity? // 判斷是否已滿\n    Yes → Step 14: Return false // 無法插入，返回失敗\n    No  → Step 15: arr[rear] ← value // 放入新值\n          Step 16: rear ← (rear + 1) mod capacity // 後移\n          Step 17: size ← size + 1 // 元素個數加一\n          Step 18: Return true // 成功插入\n\n// ---------- deleteFront ----------\n→ Step 19: deleteFront() // 方法入口\n→ Decision: 如果 size == 0? // 判斷是否為空\n    Yes → Step 20: Return false // 無法刪除，返回失敗\n    No  → Step 21: front ← (front + 1) mod capacity // 前移\n          Step 22: size ← size - 1 // 元素個數減一\n          Step 23: Return true // 成功刪除\n\n// ---------- deleteLast ----------\n→ Step 24: deleteLast() // 方法入口\n→ Decision: 如果 size == 0? // 判斷是否為空\n    Yes → Step 25: Return false // 無法刪除，返回失敗\n    No  → Step 26: rear ← (rear - 1 + capacity) mod capacity // 後移\n          Step 27: size ← size - 1 // 元素個數減一\n          Step 28: Return true // 成功刪除\n\n// ---------- getFront ----------\n→ Step 29: getFront() // 方法入口\n→ Decision: 如果 size == 0? // 判斷是否為空\n    Yes → Step 30: Return -1 // 空時返回 -1\n    No  → Step 31: Return arr[front] // 回傳前端元素\n\n// ---------- getRear ----------\n→ Step 32: getRear() // 方法入口\n→ Decision: 如果 size == 0? // 判斷是否為空\n    Yes → Step 33: Return -1 // 空時返回 -1\n    No  → Step 34: idx ← (rear - 1 + capacity) mod capacity // 取得最後一個索引\n          Step 35: Return arr[idx] // 回傳後端元素\n\n// ---------- isEmpty ----------\n→ Step 36: isEmpty() // 方法入口\n→ Decision: 如果 size == 0? // 判斷是否為空\n    Yes → Step 37: Return true // 空\n    No  → Step 38: Return false // 非空\n\n// ---------- isFull ----------\n→ Step 39: isFull() // 方法入口\n→ Decision: 如果 size == capacity? // 判斷是否已滿\n    Yes → Step 40: Return true // 已滿\n    No  → Step 41: Return false // 未滿\n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\", \"root/4.txt\"]]'"
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"Return groups of duplicate file paths based on file contents.\"\"\"\n        content_map = defaultdict(list)\n\n        for path in paths:\n            parts = path.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                # file_info format: name(content)\n                name, content_with_paren = file_info.split('(')\n                content = content_with_paren[:-1]  # remove trailing ')'\n                full_path = f\"{root}/{name}\"\n                content_map[content].append(full_path)\n\n        # Keep only groups that have at least two files\n        return [files for files in content_map.values() if len(files) > 1]\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Extract the list assigned to 'paths'\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n    else:\n        list_str = data\n    list_str = list_str.strip()\n\n    try:\n        paths = ast.literal_eval(list_str)\n    except Exception:\n        # If the input is not a valid Python literal, exit silently\n        sys.exit()\n\n    result = Solution().findDuplicate(paths)\n    # Use json.dumps to match the expected output format with double quotes\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need produce virtual code for problem: find duplicate file paths given directory info strings. So algorithm: iterate over input list, parse each string: split by space; first token is dir path, rest tokens are files. For each file token, parse file name and content inside parentheses. Build map content->list of full paths. After processing, filter list of lists with size>=2.\n\nWe need produce step-by-step virtual code lines with explanation.\n\nUse structure: Start, then Step lines, Decision, etc.\n\nWe can show:\n\nStart // program start\n→ Step 1: Initialize empty dictionary contentMap // map content to list of paths\n\nThen iterate over each pathInfo in input list:\n\n→ Step 2: For each pathInfo in input list // loop over directory info strings\n    → Step 2.1: Split pathInfo by space into parts // separate dir and files\n    → Step 2.2: Let dir = parts[0] // directory path\n    → Step 2.3: For each filePart in parts[1:]:\n        → Step 2.3.1: Find index of '(' in filePart // locate start of content\n        → Step 2.3.2: fileName = substring before '(' // file name\n        → Step 2.3.3: content = substring between '(' and ')' // file content\n        → Step 2.3.4: fullPath = dir + \"/\" + fileName // construct full path\n        → Step 2.3.5: If content not in contentMap:\n                → Step 2.3.5.1: contentMap[content] = empty list // initialize\n            → Step 2.3.6: Append fullPath to contentMap[content] // add to list\n\nAfter loop:\n\n→ Step 3: Initialize result list // store groups\n\n→ Step 4: For each content in contentMap:\n    → Decision: If length of contentMap[content] >= 2? // duplicate group\n        Yes → Step 4.1: Append contentMap[content] to result // add group\n        No → Step 4.2: // ignore\n\nEnd // output result\n\nWe must format each line with `虛擬碼步驟` + space + `// 解釋`. Use arrow and indent accordingly.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: contentMap ← {} // 建立內容到檔案路徑的映射\n→ Step 2: For each pathInfo in paths // 遍歷每個目錄資訊字串\n    → Step 2.1: parts ← split(pathInfo, \" \") // 以空格拆分為目錄和檔案\n    → Step 2.2: dir ← parts[0] // 取得目錄路徑\n    → Step 2.3: For each filePart in parts[1:] // 逐一處理檔案\n        → Step 2.3.1: idx ← indexOf(filePart, \"(\") // 找到 '(' 的位置\n        → Step 2.3.2: fileName ← substring(filePart, 0, idx) // 取得檔名\n        → Step 2.3.3: content ← substring(filePart, idx+1, length-1) // 取得內容\n        → Step 2.3.4: fullPath ← dir + \"/\" + fileName // 組成完整路徑\n        → Step 2.3.5: If content not in contentMap // 若尚未存在內容鍵\n            → Step 2.3.5.1: contentMap[content] ← [] // 建立空列表\n        → Step 2.3.6: Append fullPath to contentMap[content] // 加入路徑\n→ Step 3: result ← [] // 存放重複檔案群組\n→ Step 4: For each key, pathsList in contentMap // 檢查每個內容\n    → Decision: If length(pathsList) >= 2? // 有重複檔案\n        Yes → Step 4.1: Append pathsList to result // 加入結果\n        No → Step 4.2: // 無重複，忽略\nEnd // 程式結束，返回 result\n\nWe need to include arrow for decisions.\n\nMake sure formatting: Each line should start with virtual code step, then space, then comment.\n\nAlso indentation for nested steps.\n\nWe'll produce exactly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: contentMap ← {} // 建立內容到檔案路徑的映射\n→ Step 2: For each pathInfo in paths // 遍歷每個目錄資訊字串\n    → Step 2.1: parts ← split(pathInfo, \" \") // 以空格拆分為目錄和檔案\n    → Step 2.2: dir ← parts[0] // 取得目錄路徑\n    → Step 2.3: For each filePart in parts[1:] // 逐一處理檔案\n        → Step 2.3.1: idx ← indexOf(filePart, \"(\") // 找到 '(' 的位置\n        → Step 2.3.2: fileName ← substring(filePart, 0, idx) // 取得檔名\n        → Step 2.3.3: content ← substring(filePart, idx+1, length-1) // 取得內容\n        → Step 2.3.4: fullPath ← dir + \"/\" + fileName // 組成完整路徑\n        → Step 2.3.5: If content not in contentMap // 若尚未存在內容鍵\n            → Step 2.3.5.1: contentMap[content] ← [] // 建立空列表\n        → Step 2.3.6: Append fullPath to contentMap[content] // 加入路徑\n→ Step 3: result ← [] // 存放重複檔案群組\n→ Step 4: For each key, pathsList in contentMap // 檢查每個內容\n    → Decision: If length(pathsList) >= 2? // 有重複檔案\n        Yes → Step 4.1: Append pathsList to result // 加入結果\n        No  → Step 4.2: // 無重複，忽略\nEnd // 程式結束，返回 result\n```"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpu92kgqhg.py\", line 30, in <module>\n    results = [solver.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^^^^\n  File \"/tmp/tmpu92kgqhg.py\", line 9, in rand10\n    num = (rand7() - 1) * 7 + rand7()  # 1 ~ 49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_ijbiwof.py\", line 30, in <module>\n    results = [solver.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_ijbiwof.py\", line 9, in rand10\n    num = (rand7() - 1) * 7 + rand7()  # 1 ~ 49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpu7ps09wr.py\", line 30, in <module>\n    results = [solver.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^^^^\n  File \"/tmp/tmpu7ps09wr.py\", line 9, in rand10\n    num = (rand7() - 1) * 7 + rand7()  # 1 ~ 49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        }
      ],
      "generated_code": "class Solution:\n    def rand10(self):\n        \"\"\"\n        Generate a uniform random integer in [1, 10] using only rand7().\n        Uses rejection sampling with two calls to rand7().\n        \"\"\"\n        while True:\n            # Use two rand7() calls to get a number in [1, 49]\n            num = (rand7() - 1) * 7 + rand7()  # 1 ~ 49\n            if num <= 40:                     # Acceptable range\n                return 1 + (num - 1) % 10     # Map 1-40 to 1-10\n\nif __name__ == \"__main__\":\n    import sys\n\n    # Read the entire input, expected format: 'n = X'\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Extract the integer value of n\n    if '=' in data:\n        _, value = data.split('=', 1)\n        n = int(value.strip())\n    else:\n        n = int(data)\n\n    # Generate n random numbers using rand10\n    solver = Solution()\n    results = [solver.rand10() for _ in range(n)]\n\n    # Output the results as a Python list\n    print(results)",
      "virtual_code": "Thinking...\nWe need to generate pseudo-code algorithm for rand10() using rand7() only. Classic solution: generate two rand7() to get 49 possibilities, map 1-40 to 1-10 via modulo 10, reject 41-49. Equivalent algorithm.\n\nWe'll produce step by step with virtual code lines. Use structure Start, Decision, etc.\n\nNeed to explain each line. Use arrow syntax.\n\nWe'll produce something like:\n\nStart\n→ Step 1: repeat\n    → Step 1.1: a ← rand7() // first roll 1-7\n    → Step 1.2: b ← rand7() // second roll 1-7\n    → Step 1.3: result ← (a - 1) * 7 + b // 1-49\n    → Decision: If result ≤ 40? // acceptable range\n        Yes → Return (result - 1) mod 10 + 1 // map to 1-10\n        No  → Go back to repeat // reject and repeat\nEnd\n\nBut need arrow and structure. We'll embed loops: maybe use Decision for repeat: Yes -> continue loop? Use \"Loop\" concept: we can do Decision: If result ≤ 40? -> Yes return else -> repeat loop. In virtual code, we could do \"Repeat\" block: \"→ Repeat:\" etc. Or use \"Decision: 是否需要重試?\".\n\nLet's produce a linear style: Start, Step 1, Step 2 etc. Use \"Decision:\" to decide whether to return.\n\nBut need to maintain structure: Use arrow to show flow.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 產生隨機數 a ← rand7() // 第一次呼叫 rand7()\n→ Step 2: 產生隨機數 b ← rand7() // 第二次呼叫 rand7()\n→ Step 3: 合併兩個數為 index ← (a-1) * 7 + b // 生成 1-49 的索引\n→ Decision: 如果 index ≤ 40? // 檢查是否在可接受區間\n    Yes → Step 4: 回傳 (index-1) mod 10 + 1 // 轉換到 1-10\n    No  → Step 1 // 重複步驟 1 到 4 直到成功\nEnd // 程式結束\n\nBut the arrow for repeat: We might need to show \"→ Step 1\" as a loop. But it's okay.\n\nBut each line must include the \"虛擬碼步驟\" and explanation. So we need to ensure each line has a single step. But the repeat may need to be expressed properly.\n\nBetter to do:\n\nStart\n→ Decision: 需要生成 rand10()?\n    Yes → Step 1: a ← rand7() // 第一次呼叫\n    → Step 2: b ← rand7() // 第二次呼叫\n    → Step 3: index ← (a-1)*7 + b // 1-49\n    → Decision: index ≤ 40?\n        Yes → Return (index-1) mod 10 + 1\n        No  → Go back to Step 1\nEnd\n\nBut we can just present as while loop: \"→ Loop:\" but the format expects arrow and Step.\n\nMaybe:\n\nStart // 程式開始執行\n→ Loop: // 開始循環生成直到成功\n    → Step 1: a ← rand7() // 第一次呼叫 rand7()\n    → Step 2: b ← rand7() // 第二次呼叫 rand7()\n    → Step 3: index ← (a-1) * 7 + b // 產生 1-49 的索引\n    → Decision: index ≤ 40?\n        Yes → Return (index-1) mod 10 + 1 // 映射到 1-10\n        No  → Continue // 重複迴圈\nEnd // 程式結束\n\nBut \"Continue\" maybe \"Go back to Loop\".\n\nThe spec says: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)。\" So we can use \"Loop:\" as a label? It didn't specify. But we can just use Decision and arrows.\n\nLet's keep simple.\n\nWe can produce:\n\nStart // 程式開始執行\n→ Decision: 是否需要產生 rand10()?\n    Yes → Step 1: a ← rand7() // 呼叫 rand7() 產生 1-7\n    → Step 2: b ← rand7() // 第二次呼叫 rand7()\n    → Step 3: index ← (a-1)*7 + b // 產生 1-49\n    → Decision: index ≤ 40?\n        Yes → Return (index-1) mod 10 + 1 // 轉換到 1-10\n        No  → Go back to Step 1 // 重複\nEnd // 程式結束\n\nBut we might not need the outer decision. Let's just do a loop.\n\nI'll produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 需要生成 rand10()? // 檢查是否要執行函式  \n Yes → Step 1: a ← rand7() // 呼叫 rand7() 產生 1-7 的隨機數  \n  → Step 2: b ← rand7() // 第二次呼叫 rand7() 產生 1-7 的隨機數  \n  → Step 3: index ← (a - 1) * 7 + b // 將兩個數合併成 1-49 的索引  \n  → Decision: index ≤ 40? // 判斷索引是否在可接受區間  \n   Yes → Return (index - 1) mod 10 + 1 // 將 1-40 映射到 1-10  \n   No  → Go back to Step 1 // 若超過 40，重複步驟 1-3 直至成功  \nEnd // 程式執行結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0]-b[0])**2 + (a[1]-b[1])**2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n        for i in range(4):\n            for j in range(i+1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n        dists.sort()\n        return (dists[0] > 0 and\n                dists[0] == dists[1] == dists[2] == dists[3] and\n                dists[4] == dists[5] and\n                dists[4] == 2 * dists[0])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) != 8:\n        print(\"false\")\n        sys.exit(0)\n    p1 = [nums[0], nums[1]]\n    p2 = [nums[2], nums[3]]\n    p3 = [nums[4], nums[5]]\n    p4 = [nums[6], nums[7]]\n    sol = Solution()\n    result = sol.validSquare(p1, p2, p3, p4)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to check if four points form a square. Use virtual code with arrows, decisions etc. Provide explanation per line. Use Start, End, Decision, Step. Need to compute distances squared between all pairs, find unique distances. Steps: calculate all 6 distances squared, store them. Find min distance >0; then check that there are exactly 2 distinct distances: side and diagonal. Also side count should be 4, diagonal count 2. Also diagonal is twice side length? Actually for square, diagonal^2 = 2*side^2. Could check that.\n\nThus virtual steps: Start, compute distances, store, sort, determine unique counts, etc.\n\nProvide explanation for each line.\n\nLet's generate. Use lines with \"→ Step X:\" etc. Use indentation.\n\nWe should follow example style. Provide arrow, step, and explanation. For decisions, use \"Decision: ...\" then Yes/No branches. For simplicity, we can have step: Compute distances; Step: Sort distances; Step: Count unique values; Decision: Count distinct==2? Yes/No; etc. Also check min>0.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空列表 distances // 用於儲存所有 6 個點對之間的距離平方  \n→ Step 2: 對每一對不同的點 (p1,p2), (p1,p3), …, (p3,p4) 進行迴圈  \n  → Step 3: 計算 dx = x_i - x_j, dy = y_i - y_j // 計算座標差  \n  → Step 4: 計算 dist2 = dx*dx + dy*dy // 距離平方，避免浮點誤差  \n  → Step 5: 將 dist2 加入 distances // 將結果儲存  \n→ Step 6: 排序 distances // 方便後續統計  \n→ Step 7: 取最小值 side2 = distances[0] // 最小距離平方應為邊長平方  \n→ Decision: 是否有 side2 <= 0? // 邊長必須為正  \n  Yes → Step 8: 返回 False // 若邊長為零，直接不是正方形  \n  No → Step 9: 創建集合 unique_dist = set(distances) // 找出不同距離值  \n→ Decision: unique_dist 的大小是否為 2? // 正方形需有兩種距離：邊與對角線  \n  Yes → Step 10: 取 sides = unique_dist[0], diags = unique_dist[1]（依大小排序）  \n  No  → Step 11: 返回 False // 不是正方形  \n→ Step 12: 計算 side_count = distances.count(sides) // 邊的出現次數  \n→ Decision: side_count 是否為 4? // 正方形四邊相等  \n  Yes → Step 13: 計算 diag_count = distances.count(diags) // 對角線出現次數  \n  No  → Step 14: 返回 False // 邊數不為四  \n→ Decision: diag_count 是否為 2? // 正方形兩條對角線  \n  Yes → Step 15: 檢查 diags == 2 * sides // 對角線長度平方應為 2 倍邊長平方  \n    Yes → Step 16: 返回 True // 符合所有條件，為正方形  \n    No  → Step 17: 返回 False // 對角線長度不符合 2 倍關係  \n  No  → Step 18: 返回 False // 對角線數量不為兩條  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7lq25rog.py\", line 42, in <module>\n    price, special, needs = parse_input(data)\n                            ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7lq25rog.py\", line 11, in parse_input\n    special = ast.literal_eval(special_str)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[3,0,5]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpc5xbhdkq.py\", line 42, in <module>\n    price, special, needs = parse_input(data)\n                            ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpc5xbhdkq.py\", line 11, in parse_input\n    special = ast.literal_eval(special_str)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,4]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\ndef parse_input(text: str):\n    \"\"\"從輸入字串中提取 price、special 與 needs。\"\"\"\n    price_str = re.search(r'price\\s*=\\s*(\\[.*?\\])', text, re.S).group(1)\n    special_str = re.search(r'special\\s*=\\s*(\\[.*?\\])', text, re.S).group(1)\n    needs_str = re.search(r'needs\\s*=\\s*(\\[.*?\\])', text, re.S).group(1)\n    price = ast.literal_eval(price_str)\n    special = ast.literal_eval(special_str)\n    needs = ast.literal_eval(needs_str)\n    return price, special, needs\n\ndef shopping_offers(price, special, needs):\n    \"\"\"計算最小購買價格，使用 DFS + memoization。\"\"\"\n    n = len(price)\n    memo = {}\n\n    def dfs(curr_needs):\n        key = tuple(curr_needs)\n        if key in memo:\n            return memo[key]\n        # 直接按單價購買的成本\n        res = sum(curr_needs[i] * price[i] for i in range(n))\n        # 嘗試使用每一個特價方案\n        for offer in special:\n            temp = []\n            for i in range(n):\n                if offer[i] > curr_needs[i]:\n                    break  # 此特價不可用\n                temp.append(curr_needs[i] - offer[i])\n            else:  # 所有項皆可減\n                res = min(res, offer[-1] + dfs(temp))\n        memo[key] = res\n        return res\n\n    return dfs(needs)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    price, special, needs = parse_input(data)\n    result = shopping_offers(price, special, needs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm solving LeetCode Store problem. Must output line-by-line with explanation. Use Start, End, Decision, etc.\n\nWe need to produce pseudocode. We'll include recursion with memoization or DP. Use DFS + caching. Steps: start, define function dfs(needs) returns min cost. base: if all zeros return 0. For each special offer check if can apply (needs >= offer counts). If yes, compute cost=offer price + dfs(newNeeds). Keep min. Also consider buying items individually: sum(needs[i]*price[i]). Return min.\n\nAlso need memoization with map of vector to cost. We'll use string key.\n\nNeed to include all steps: reading inputs? The function solve receives price, needs, special. We'll output steps accordingly.\n\nLet's produce lines with \"→ Step X: ...\" with explanation.\n\nMake sure each line ends with // explanation. Use arrow. Use indentation maybe.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義遞迴函式 dfs(需求) // 以需求向量為輸入，計算最小價格  \n→ Step 2: 若需求向量中所有項皆為 0，返回 0 // 無需購買任何商品  \n→ Step 3: 若需求向量已在 memo 中，返回 memo[需求] // 使用已計算的結果避免重複  \n→ Step 4: 計算單品購買總價 sum = Σ (需求[i] × 價格[i]) // 直接買單品的備用方案  \n→ Step 5: 初始化最小價格 minCost = sum // 從單品方案開始  \n→ Step 6: 對於每個特價方案 offer in specials  \n  → Decision: 若 offer 可應用於需求 (即需求[i] ≥ offer[i] for 所有 i)  \n   Yes → Step 7: 生成新需求 newNeeds = 需求 - offer 的前 n 個數字  \n    → Step 8: 取得套裝價格 offerPrice = offer[n]  \n    → Step 9: 取得套裝加剩餘需求的最小價格 subCost = dfs(newNeeds)  \n    → Step 10: 更新 minCost = min(minCost, offerPrice + subCost) // 若套裝方案更便宜則更新  \n   No → Step 11: 跳過此套裝  \n→ Step 12: memo[需求] = minCost // 進行備忘錄化  \n→ Step 13: 返回 minCost // 結束遞迴呼叫  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Break II",
      "source_file": "Leetcode/leetcode140.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']",
          "expected_output": "['cats and dog','cat sand dog']",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1ropms_1.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmp1ropms_1.py\", line 30, in main\n    data = sys.stdin.read().strip()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        },
        {
          "example_index": 1,
          "input": "s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']",
          "expected_output": "['pine apple pen apple','pineapple pen apple','pine applepen apple']",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpne8lp2v4.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpne8lp2v4.py\", line 30, in main\n    data = sys.stdin.read().strip()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        },
        {
          "example_index": 2,
          "input": "s = 'catsandog', wordDict = ['cats','dog','sand','and','cat']",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpco6dz_qd.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpco6dz_qd.py\", line 30, in main\n    data = sys.stdin.read().strip()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        }
      ],
      "generated_code": "import ast\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        word_set = set(wordDict)\n        memo = {}\n\n        def backtrack(start):\n            if start in memo:\n                return memo[start]\n            if start == len(s):\n                return [\"\"]\n\n            res = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in word_set:\n                    for sub_sentence in backtrack(end):\n                        if sub_sentence:\n                            res.append(word + \" \" + sub_sentence)\n                        else:\n                            res.append(word)\n            memo[start] = res\n            return res\n\n        return backtrack(0)\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split the input into the part for s and the part for wordDict\n    if \", wordDict = \" in data:\n        s_part, word_part = data.split(\", wordDict = \", 1)\n    else:\n        # Fallback if the format is slightly different\n        s_part, word_part = data, \"[]\"\n\n    # Remove the variable name prefix and strip whitespace\n    s_value = s_part.replace(\"s = \", \"\", 1).strip()\n    word_dict_value = word_part.strip()\n\n    # Safely evaluate the string and list literals\n    s = ast.literal_eval(s_value)\n    wordDict = ast.literal_eval(word_dict_value)\n\n    result = Solution().wordBreak(s, wordDict)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for Word Break II. Steps: DP for segmentation and backtracking. Provide line-by-line with explanations. Use arrow and decision. We must not output actual code, just pseudo steps.\n\nLet's create flow: Start, preprocess dictionary into set, define function DFS with memo. Step: DFS(index). Decision: index==len(s)? Yes → add empty sentence. No → iterate over end from index+1 to len(s) inclusive: substring = s[index:end]; Decision: substring in dict? Yes → DFS(end) results, for each suffix, combine. Memoization: if memo contains index, return memo[index]. After loop, memo[index] = result. Return result. Then in main: result = DFS(0). Return result. End.\n\nNeed arrow formatting. Use \"→\" after each step. Indent substeps maybe with spaces. Use \"Decision:\" lines. Use \"Yes →\", \"No →\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立字典集合 dict = Set(wordDict) // 方便 O(1) 查詢\n→ Step 2: 初始化記憶化字典 memo = {} // 用於儲存子問題結果\n→ Decision: 定義遞迴函式 DFS(idx) // idx 為目前分割起點\n    → Decision: idx == len(s) ? // 是否已經到字串結尾\n        Yes → Step 3: 返回 [\"\" ] // 返回一個空句子作為基礎\n        No  → Decision: 是否已存在 memo[idx] ?\n            Yes → Step 4: 返回 memo[idx] // 直接取記憶化結果\n            No  → Step 5: 初始化 local_res = [] // 儲存 idx 開始的所有句子\n            → For end in range(idx+1, len(s)+1) // 嘗試所有可能結束位置\n                → Step 6: sub = s[idx:end] // 取子字串\n                → Decision: sub in dict ?\n                    Yes → Step 7: suffixes = DFS(end) // 取得從 end 開始的所有句子\n                    → For each word in suffixes\n                        → Decision: word == \"\" ?\n                            Yes → Step 8: local_res.append(sub) // 只剩一個單詞\n                            No  → Step 9: local_res.append(sub + \" \" + word) // 加上空格拼接\n                    No  → Step 10: 跳過該子字串 // 子字串不是字典詞\n            → Step 11: memo[idx] = local_res // 記憶化結果\n            → Step 12: 返回 local_res\n→ Step 13: result = DFS(0) // 從字串起點開始拆分\n→ Step 14: 返回 result // 所有可能的句子\nEnd // 程式執行結束"
    },
    {
      "title": "Rotate Function",
      "source_file": "Leetcode/leetcode396.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '26'\nGot (Norm):      '34'\n--- (Raw) ---\nRaw Expected: '26'\nRaw Got:      '34'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def maxRotateFunction(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = sum(nums)\n        # F(0)\n        F = sum(i * num for i, num in enumerate(nums))\n        max_val = F\n        # iterate k = 0 .. n-2\n        for i in range(n - 1):\n            # update to F(k+1)\n            F = F + total - n * nums[i]\n            if F > max_val:\n                max_val = F\n        return max_val\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串中的列表提取出來，並轉換為 Python list。\n    支援類似 'nums = [4,3,2,6]' 或僅僅 '[4,3,2,6]' 的格式。\n    \"\"\"\n    # 找到第一個括號內的內容\n    m = re.search(r'\\[([^\\]]*)\\]', data)\n    if not m:\n        return []\n    # 重新組成完整的列表字串\n    list_str = '[' + m.group(1).strip() + ']'\n    try:\n        return ast.literal_eval(list_str)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = parse_input(data)\n    solution = Solution()\n    result = solution.maxRotateFunction(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for computing max rotation function. We must not output real code, just pseudocode with arrows and explanations. Use virtual code style. Steps: compute sum of array, sum of weighted values initial F0, then iterate rotations updating F value using formula: F(k+1) = F(k) + sum - n*arr[k] maybe. Actually formula: F(k+1) = F(k) + sum(nums) - n*arr[k]. Wait check: F(k) = sum i*arrk[i]; arrk is rotated. Relationship: arr_{k+1}[i] = arr_k[(i-1+n)%n]. Derive update: F(k+1) = F(k) + sum - n*arr_k[0]? Let's recall known solution: F(k+1) = F(k) + sum(nums) - n*nums[k]. Yes.\n\nThus algorithm: compute sum = sum(nums), compute initial F0 = sum i*nums[i]. Set maxF = F0. For k from 0 to n-2: F = F + sum - n*nums[k]; if F > maxF update. Return maxF.\n\nAlso handle n==1 case: return 0.\n\nWe need to produce virtual code with Start, End, decisions. Use steps.\n\nLet's write:\n\nStart\n→ Step 1: 計算陣列長度 n // 取得陣列長度\n→ Decision: 如果 n == 1? // 單元素情況\n    Yes → Step 2: 回傳 0 // F(0) 為 0\n    No → Step 3: 計算 sum = sum(nums) // 取得所有元素總和\n→ Step 4: 計算 F0 = Σ i * nums[i] // 初始旋轉函數值\n→ Step 5: 設定 maxF = F0 // 初始最大值\n→ Step 6: 設定 currentF = F0 // 目前旋轉函數值\n→ Decision: 如果 n <= 1? // 已處理 n==1，不再迭代\n    Yes → End // 直接結束\n    No → Step 7: 從 k = 0 到 n-2 迭代 // 進行剩餘旋轉\n        → Step 8: 更新 currentF = currentF + sum - n * nums[k] // 利用公式更新\n        → Step 9: Decision: 如果 currentF > maxF? // 檢查是否新最大值\n            Yes → Step 10: 設定 maxF = currentF // 更新最大值\n            No  → Step 10: 留待下一輪\n→ Step 11: 回傳 maxF // 返回最大旋轉函數值\nEnd\n\nWe need to ensure each line has explanation. Use arrow \"→\". Use Decision block indent.\n\nAlso, we might need to incorporate indentation for Decision branches.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列長度 n // 讀取 nums 的元素個數  \n→ Decision: n 是否等於 1? // 單元素特殊情況  \n  Yes → Step 2: 回傳 0 // F(0) 為 0，直接結束  \n  No  → Step 3: 計算 sum = Σ nums[i] // 取得所有元素之和  \n\n→ Step 4: 計算初始旋轉函數 F0 = Σ i * nums[i] // 以 k=0 為基準計算  \n→ Step 5: 設定 maxF = F0 // 初始最大值  \n→ Step 6: 設定 currentF = F0 // 目前旋轉函數值  \n\n→ Decision: n <= 1? // 已處理單元素情況  \n  Yes → End // 程式結束  \n  No  → Step 7: 從 k = 0 到 n-2 進行迭代 // 迭代剩餘旋轉  \n    → Step 8: currentF = currentF + sum - n * nums[k] // 根據公式更新 F(k+1)  \n    → Decision: currentF 是否大於 maxF?  \n      Yes → Step 9: maxF = currentF // 更新最大值  \n      No  → Step 9: 何不更新，直接繼續  \n\n→ Step 10: 回傳 maxF // 回傳所有旋轉函數中的最大值  \nEnd // 程式執行結束"
    },
    {
      "title": "Time Based Key-Value Store",
      "source_file": "Leetcode/leetcode981.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,\"bar\",\"bar\",null,\"bar2\",\"bar2\"]'\nGot (Norm):      '[\"null\",\"null\",\"bar\",\"bar\",\"null\",\"bar2\",\"bar2\"]'\n--- (Raw) ---\nRaw Expected: '[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]'\nRaw Got:      \"['null', 'null', 'bar', 'bar', 'null', 'bar2', 'bar2']\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\nimport bisect\n\nclass TimeMap:\n    def __init__(self):\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # bisect_right finds insertion point to keep order, using a value larger than any string\n        i = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if i == 0:\n            return \"\"\n        return arr[i - 1][1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Ensure the data is a list containing two lists\n    if not data.startswith('['):\n        data = '[' + data + ']'\n    try:\n        ops, args = ast.literal_eval(data)\n    except Exception:\n        # If parsing fails, try splitting by newline\n        parts = data.splitlines()\n        ops = ast.literal_eval(parts[0].strip())\n        args = ast.literal_eval(parts[1].strip())\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"TimeMap\":\n            obj = TimeMap()\n            results.append(None)\n        elif op == \"set\":\n            obj.set(*arg)\n            results.append(None)\n        elif op == \"get\":\n            val = obj.get(*arg)\n            results.append(val)\n    # Convert None to 'null' as per example output\n    output = ['null' if v is None else v for v in results]\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation. Need to design data structure: TimeMap with set and get. Use dictionary mapping key -> list of (timestamp, value) sorted by timestamp. For get, binary search. We need to produce virtual steps: Start, Step1: define class, Step2: init, Step3: set, Step4: get, End. Use arrow style. Provide explanation after //.\n\nWe need to reflect operations like \"add key-value pair\" etc. Provide explanation. Use Yes/No decisions for binary search. Provide decision: if key exists. For get: if key not exist, return \"\". Else binary search to find rightmost <= timestamp. Use decision loops. Provide steps: Search left, right boundaries. Provide explanation. Ensure we maintain sorted insertion (append). Let's produce.\n\nWe need to adhere to format: each line: 虛擬碼步驟 [space] // 解釋. Use arrow symbols. We'll start with Start. Use → for subsequent steps. Indentation? Format example uses indentation for nested decisions. We'll replicate. Provide End.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 定義 TimeMap 類別 // 建立時間鍵值儲存結構\n→ Step 2: 定義建構子 TimeMap() // 初始化內部資料結構\n    → 子步驟 2.1: 建立空字典 key_to_records // key 到 [timestamp, value] 的列表\n→ Step 3: 定義 set(key, value, timestamp) 方法 // 儲存資料\n    → 子步驟 3.1: 若 key 不在 key_to_records → 建立新列表 // 確保 key 有存儲容器\n    → 子步驟 3.2: 將 (timestamp, value) 加入 key_to_records[key] 列表 // 依時間遞增新增\n→ Step 4: 定義 get(key, timestamp) 方法 // 取得符合條件的值\n    → 子步驟 4.1: 若 key 不在 key_to_records → 回傳 \"\" // 無該鍵\n    → 子步驟 4.2: 取得 records = key_to_records[key] // 取得時間序列\n    → 子步驟 4.3: 初始化 left = 0, right = len(records)-1, result = \"\" // 二分準備\n    → 子步驟 4.4: Decision: 是否存在 left <= right? // 開始二分搜尋\n        Yes → 子步驟 4.4.1: 計算 mid = (left + right) // 2 // 中點\n        → 子步驟 4.4.2: Decision: records[mid].timestamp <= timestamp? // 判斷是否符合時間\n            Yes → 子步驟 4.4.2.1: result = records[mid].value // 更新最近符合的值\n                     → 子步驟 4.4.2.2: left = mid + 1 // 仍可搜尋更大的時間\n            No  → 子步驟 4.4.2.3: right = mid - 1 // 時間太大，縮小搜尋範圍\n        → 子步驟 4.4.4: 回到 Decision: 是否存在 left <= right? // 迴圈繼續\n    → 子步驟 4.5: 回傳 result // 取得最接近但不超過的值\nEnd // 程式結束\n\nNeed to keep arrows and indentation. Ensure \"Yes →\", \"No →\". Use consistent spacing. Use brackets for decisions. Provide explanation for each line. Let's format accordingly. Use Chinese. Provide explanation after //.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TimeMap 類別 // 建立時間鍵值儲存結構  \n→ Step 2: 定義建構子 TimeMap() // 初始化內部資料結構  \n  → 子步驟 2.1: 建立空字典 key_to_records // key 到 [timestamp, value] 的列表  \n→ Step 3: 定義 set(key, value, timestamp) 方法 // 儲存資料  \n  → 子步驟 3.1: 若 key 不在 key_to_records → 建立新列表 // 確保 key 有存儲容器  \n  → 子步驟 3.2: 將 (timestamp, value) 加入 key_to_records[key] 列表 // 依時間遞增新增  \n→ Step 4: 定義 get(key, timestamp) 方法 // 取得符合條件的值  \n  → 子步驟 4.1: 若 key 不在 key_to_records → 回傳 \"\" // 無該鍵  \n  → 子步驟 4.2: 取得 records = key_to_records[key] // 取得時間序列  \n  → 子步驟 4.3: 初始化 left = 0, right = len(records)-1, result = \"\" // 二分準備  \n  → 子步驟 4.4: Decision: 是否存在 left <= right? // 開始二分搜尋  \n    Yes → 子步驟 4.4.1: 計算 mid = (left + right) // 2 // 中點  \n    → 子步驟 4.4.2: Decision: records[mid].timestamp <= timestamp? // 判斷是否符合時間  \n     Yes → 子步驟 4.4.2.1: result = records[mid].value // 更新最近符合的值  \n      → 子步驟 4.4.2.2: left = mid + 1 // 仍可搜尋更大的時間  \n     No  → 子步驟 4.4.2.3: right = mid - 1 // 時間太大，縮小搜尋範圍  \n    → 子步驟 4.4.3: 回到 Decision: 是否存在 left <= right? // 迴圈繼續  \n  → 子步驟 4.5: 回傳 result // 取得最接近但不超過的值  \nEnd // 程式結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"Reorder nums to satisfy nums[0] < nums[1] > nums[2] < nums[3] ...\"\"\"\n        n = len(nums)\n        if n <= 1:\n            return\n        for i in range(n - 1):\n            if i % 2 == 0:\n                # even index: ensure nums[i] < nums[i+1]\n                if nums[i] >= nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n            else:\n                # odd index: ensure nums[i] > nums[i+1]\n                if nums[i] <= nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\nif __name__ == \"__main__\":\n    # Read entire input\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Attempt to extract the list after '=' if present\n    try:\n        # Split only on the first '=' to preserve any nested structures\n        _, list_part = raw_input.split('=', 1)\n        list_str = list_part.strip()\n    except ValueError:\n        # No '=', assume the whole input is the list\n        list_str = raw_input\n\n    # Safely evaluate the list of integers\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception as e:\n        # If evaluation fails, print an error and exit\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    # Ensure the parsed object is a list of integers\n    if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums):\n        print(\"Input must be a list of integers.\", file=sys.stderr)\n        sys.exit(1)\n\n    # Apply the wiggle sort algorithm\n    Solution().wiggleSort(nums)\n\n    # Output the resulting list\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step. The problem: reorder array into wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3]... We can solve by iterating i from 0 to len-1, if i is even, ensure nums[i] < nums[i+1], else nums[i] > nums[i+1]. If not, swap.\n\nLet's produce virtual code. Use \"Start\", \"End\". Use Decision. Provide explanations. Ensure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow \"→\". Use \"Yes →\", \"No →\". Must be line by line. Let's produce:\n\nStart // 程式開始\n→ Step 1: let n = length of nums // 取得陣列長度\n→ Decision: n <= 1? // 判斷陣列長度是否小於等於1\n    Yes → End // 小於等於1時直接結束，已符合 wiggle\n    No → \n→ Step 2: for i from 0 to n-2 // 迭代每個相鄰對\n    → Decision: i is even? // 檢查索引是否為偶數\n        Yes → \n            → Decision: nums[i] >= nums[i+1]? // 若偶數位置不小於下一個\n                Yes → Step 3: swap nums[i] and nums[i+1] // 交換使 nums[i] < nums[i+1]\n                No → // 已符合，無需變動\n        No →\n            → Decision: nums[i] <= nums[i+1]? // 若奇數位置不大於下一個\n                Yes → Step 4: swap nums[i] and nums[i+1] // 交換使 nums[i] > nums[i+1]\n                No → // 已符合，無需變動\n→ End // 完成所有交換，結束\n\nMake sure each line is separate. Provide the virtual code lines as described. Let's produce final.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: let n = length of nums // 取得陣列長度\n→ Decision: n <= 1? // 判斷陣列長度是否小於等於1\n    Yes → End // 小於等於1時直接結束，已符合 wiggle\n    No → \n→ Step 2: for i from 0 to n-2 // 迭代每個相鄰對\n    → Decision: i is even? // 檢查索引是否為偶數\n        Yes → \n            → Decision: nums[i] >= nums[i+1]? // 若偶數位置不小於下一個\n                Yes → Step 3: swap nums[i] and nums[i+1] // 交換使 nums[i] < nums[i+1]\n                No → // 已符合，無需變動\n        No →\n            → Decision: nums[i] <= nums[i+1]? // 若奇數位置不大於下一個\n                Yes → Step 4: swap nums[i] and nums[i+1] // 交換使 nums[i] > nums[i+1]\n                No → // 已符合，無需變動\n→ End // 完成所有交換，結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            # 初始化父節點\n            if x not in parent:\n                parent[x] = x\n            # 路徑壓縮\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n\n        for acc in accounts:\n            name = acc[0]\n            if len(acc) < 2:\n                continue\n            first_email = acc[1]\n            email_to_name[first_email] = name\n            root = find(first_email)\n            for email in acc[2:]:\n                email_to_name[email] = name\n                parent_email = find(email)\n                if parent_email != root:\n                    parent[parent_email] = root\n\n        groups = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            groups[root].append(email)\n\n        result = []\n        for root, emails in groups.items():\n            merged = [email_to_name[root]] + sorted(emails)\n            result.append(merged)\n\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 提取 accounts 列表\n    if '=' in data:\n        _, rest = data.split('=', 1)\n        rest = rest.strip()\n    else:\n        rest = data\n\n    try:\n        accounts = ast.literal_eval(rest)\n    except Exception:\n        # 若輸入本身就是列表字串\n        accounts = ast.literal_eval(data)\n\n    solution = Solution()\n    merged = solution.accountsMerge(accounts)\n    print(merged)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for merging accounts by email connectivity (union-find or DFS). Provide step-by-step pseudocode lines. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: etc. Must be in Traditional Chinese. Provide all steps: start, build mapping from email to index, union emails of each account, find sets, gather emails per root, sort, assemble result. Provide lines. Use arrow formatting. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化父層字典 parent ← 空字典 // 用於 Union‑Find，key 為 email，value 為父節點  \n→ Step 2: 初始化 rank 字典 rank ← 空字典 // 儲存每個根節點的高度，優化合併  \n\n→ Step 3: 建立 email ↔ 帳號對應表 email_to_name ← 空字典 // 存儲每個 email 對應的姓名  \n→ Decision: 對於每個帳號 accounts[i]  \n  → Step 4: 取帳號名稱 name ← accounts[i][0] // 取得此帳號的姓名  \n  → Step 5: 對於此帳號中每個 email e  \n      → Decision: 若 e 不在 parent 中  \n         Yes → Step 6: parent[e] ← e // 自己作為根節點  \n           rank[e] ← 0 // 初始高度  \n           email_to_name[e] ← name // 記錄此 email 的姓名  \n           Yes → Step 7: email_to_name[e] ← name // 若已存在，確認姓名一致（可選）  \n\n→ Step 8: 定義函式 find(x) → 若 parent[x] ≠ x，則 parent[x] ← find(parent[x])，回傳 parent[x] // 路徑壓縮  \n→ Step 9: 定義函式 union(x, y)  \n  → x_root ← find(x)  \n  → y_root ← find(y)  \n  → 若 x_root = y_root，返回  \n  → Decision: 若 rank[x_root] < rank[y_root]  \n     Yes → parent[x_root] ← y_root  \n     No  → parent[y_root] ← x_root  \n         若 rank[x_root] = rank[y_root]，rank[x_root] ← rank[x_root] + 1  \n\n→ Decision: 對於每個帳號 accounts[i]  \n  → Step 10: 對於此帳號中所有 email e，除第一個（姓名）外  \n     → Step 11: union(e, accounts[i][1]) // 把帳號中所有 email 連到第一個 email，形成同一個集合  \n\n→ Step 12: 建立 dict groups ← 空字典 // key 為根節點，value 為對應的 email 集合  \n→ Decision: 對於每個 email e 在 parent 中  \n  → Step 13: root ← find(e) // 找到其根節點  \n  → Decision: 若 root 不在 groups 中  \n     Yes → groups[root] ← 空集合  \n     No  → 無  \n  → Step 14: groups[root].add(e) // 把 email 加入對應集合  \n\n→ Step 15: 建立結果列表 result ← 空列表  \n→ Decision: 對於每個根節點 root 在 groups 中  \n  → Step 16: 取 name ← email_to_name[any element in groups[root]] // 取任意 email 的姓名  \n  → Step 17: 取 emails_list ← 排序(groups[root]) // 按字母順序排序  \n  → Step 18: result.append([name] + emails_list) // 組成完整帳號  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,4,4,1,6,4,4,0]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 4, 4, 1, 6, 4, 4, 0]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        index = random.randint(0, self.size - 1)\n        return self.mapping.get(index, index)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    methods = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    results = [None]\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n        else:\n            func = getattr(obj, method)\n            results.append(func(*args))\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps, with explanations, per line. The user asks for algorithm design. We need to generate virtual code for the solution class, constructor, pick method. Also include optimization: minimize random calls. We can describe using mapping approach: compress range. Outline steps.\n\nWe need to produce a step-by-step virtual code, line by line.\n\nWe must not output actual code, only virtual steps.\n\nWe should include steps: Start, constructor, build map, pick.\n\nLet's produce.\n\nWe'll structure:\n\nStart\n\n→ Step 1: Store n and blacklist\n\n→ Step 2: Compute m = n - size of blacklist // number of allowed numbers\n\n→ Step 3: Create set of blacklist elements for O(1) lookup\n\n→ Step 4: Initialize empty mapping dict\n\n→ Step 5: Initialize pointer w = n-1 // largest index\n\n→ Step 6: For each b in blacklist sorted ascending\n\n   → Decision: Is b < m?\n\n   → Yes → While w in blacklist set, decrement w\n\n   → Yes → Map[b] = w\n\n   → No → Continue\n\n→ Step 7: End Constructor\n\n→ Start pick method\n\n→ Step 1: Generate random integer r in [0, m-1] using one random call\n\n→ Step 2: Decision: Is r in mapping?\n\n   → Yes → Return mapping[r]\n\n   → No  → Return r\n\n→ End pick method\n\n→ End // End program\n\nWe need to produce each line with arrow etc.\n\nWe should use \"Start\" at beginning. Each line: \"→ ... // explanation\".\n\nInclude Decision lines with indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 儲存輸入參數 n 與 blacklist // 保存設定  \n→ Step 2: 計算 m = n - blacklist.size() // 可選擇的整數個數  \n→ Step 3: 建立 hashSet B = set(blacklist) // O(1) 判斷  \n→ Step 4: 初始化空映射 map // 用於映射被屏蔽的低區值  \n→ Step 5: 設定指標 w = n - 1 // 從最大值開始尋找映射目標  \n→ Step 6: 依序處理 blacklist 內每個 b  \n  Decision: 如果 b < m? // 只對低區範圍內的黑名單進行映射  \n   Yes → While w in B? // 跳過所有黑名單項目  \n      Yes → w = w - 1  \n      No → 跳出 while  \n    Yes → map[b] = w // 建立映射  \n      w = w - 1 // 為下一個映射遞減 w  \n   No → 直接跳過 // 高區黑名單不需要映射  \n→ Step 7: End Constructor // 完成初始化  \n\nStart pick() // pick 方法開始  \n→ Step 1: 產生隨機整數 r = random(0, m-1) // 只呼叫一次隨機函式  \n→ Step 2: Decision: 如果 r 在 map? // 判斷是否需要映射  \n  Yes → Return map[r] // 返回映射的合法數字  \n  No  → Return r // 直接返回原始數字  \n→ End pick() // pick 方法結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.01586410258633953,-0.6417971863120101],[0.15617475740228617,0.04081114358550712],[0.5537516778432092,-0.20623588810516424]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.01586410258633953, -0.6417971863120101], [0.15617475740228617, 0.04081114358550712], [0.5537516778432092, -0.20623588810516424]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    # 找到第一個非空行作為命令列表，第二個非空行作為參數列表\n    ops = None\n    args = None\n    for line in data:\n        if line.strip():\n            if ops is None:\n                ops = json.loads(line)\n            elif args is None:\n                args = json.loads(line)\n                break\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)\n        elif op == \"randPoint\":\n            if obj is None:\n                raise ValueError(\"Solution instance not initialized\")\n            results.append(obj.randPoint())\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to generate pseudo-code steps for the described functionality. Each line with arrow and comment. Use Start, End, Decision. Should be step-by-step, describing initialization and randPoint.\n\nStructure: Start, Step: Constructor, Step: randPoint. Need random generation: radius, center, random angle 0-2π, random radius sqrt(rand). Steps: generate random u in [0,1], r = radius * sqrt(u), θ = uniform random [0,2π], compute x = center_x + r*cosθ, y = center_y + r*sinθ. Return [x,y].\n\nWe need pseudo code with arrow for each step. Let's produce a sequence. Use \"→\" arrow for linear flow. For loops or decisions: we don't need loops, just random call. Use \"Decision:\" if needed. But we can include random generation as steps. Use \"Step: Generate random u in [0,1]\" etc.\n\nAdd Explanation after each line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 設定 class Solution with 屬性 radius, x_center, y_center // 儲存圓半徑及中心座標\n→ Step 2: 在建構子中接收參數 radius, x_center, y_center 並賦值 // 初始化物件\n→ Step 3: 實作 randPoint() 方法 // 生成隨機點\n→ Decision: 需要產生一個均勻分佈的半徑 r? // 確定生成半徑\n    Yes → Step 4: 產生隨機數 u ∈ [0,1] // uniform(0,1)\n    → Step 5: 計算半徑 r = radius * sqrt(u) // 以 sqrt 變換保證均勻\n→ Decision: 需要產生一個均勻分佈的角度 θ? // 確定生成角度\n    Yes → Step 6: 產生隨機數 θ ∈ [0, 2π] // uniform(0, 2π)\n→ Step 7: 計算 x = x_center + r * cos(θ) // 轉換到 Cartesian 坐標\n→ Step 8: 計算 y = y_center + r * sin(θ) // 轉換到 Cartesian 坐標\n→ Step 9: 回傳 [x, y] // 結果\nEnd // 程式執行結束\n\nWe need to ensure arrow formatting: Each line starts with arrow (→) except Start and End. Use \"Decision:\" with nested lines. Indent for nested. Ensure format exactly: \"→ Step X:\" etc. Let's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 class Solution // 建立解決方案類別\n→ Step 2: 設定屬性 radius, x_center, y_center // 儲存圓半徑與中心座標\n→ Step 3: 建構子 Solution(radius, x_center, y_center) → Assign radius, x_center, y_center to instance // 初始化物件\n→ Step 4: 實作 randPoint() 方法 // 生成隨機點\n→ Decision: 是否要產生均勻分佈的半徑? // 判斷是否需要生成半徑\n    Yes → Step 5: 產生隨機數 u ∈ [0,1] // uniform(0,1)\n    → Step 6: 計算 r = radius * sqrt(u) // sqrt 轉換確保點均勻分佈\n→ Decision: 是否要產生均勻分佈的角度? // 判斷是否需要生成角度\n    Yes → Step 7: 產生隨機數 θ ∈ [0, 2π] // uniform(0, 2π)\n→ Step 8: 計算 x = x_center + r * cos(θ) // 轉換到 Cartesian 坐標\n→ Step 9: 計算 y = y_center + r * sin(θ) // 轉換到 Cartesian 坐標\n→ Step 10: 回傳 [x, y] // 結果為隨機點\nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,2,3],[1,2,3],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 2, 3], [1, 2, 3], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = list(nums)   # 儲存原始陣列\n\n    def reset(self):\n        # 回傳原始陣列的複本\n        return list(self.original)\n\n    def shuffle(self):\n        # Fisher‑Yates 洗牌\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef parse_input(data: str):\n    \"\"\"將輸入字串拆成兩個頂層列表：commands 與 args。\"\"\"\n    depth = 0\n    split_idx = None\n    for i, ch in enumerate(data):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            split_idx = i\n            break\n    if split_idx is None:\n        raise ValueError(\"Invalid input format\")\n    left = data[:split_idx].strip()\n    right = data[split_idx + 1:].strip()\n    commands = ast.literal_eval(left)\n    args = ast.literal_eval(right)\n    return commands, args\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n    commands, args = parse_input(raw)\n\n    obj = None\n    results = []\n\n    for cmd, arg_list in zip(commands, args):\n        if cmd == \"Solution\":\n            obj = Solution(*arg_list)\n            results.append(None)\n        else:\n            method = getattr(obj, cmd)\n            res = method(*arg_list)\n            results.append(res)\n\n    # 使用 json.dumps 以得到符合題目要求的輸出格式\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output virtual code lines, each with explanation. Use virtual arrows. The algorithm: store original array, have shuffle performing Fisher-Yates.\n\nWe need to design class with constructor, reset, shuffle methods.\n\nSo steps: Start, Step 1: initialize Solution with nums, store copy original, copy to working array.\n\nMethod reset: return original copy.\n\nMethod shuffle: copy original array into working, then for i from end-1 to 0, pick random j between 0..i inclusive, swap.\n\nNeed to produce virtual code with arrows and decision lines. Let's create stepwise pseudocode.\n\nWe should produce maybe something like:\n\nStart\n→ Step 1: Define class Solution\n    → Step 2: Field: originalArray\n    → Step 3: Field: workingArray\n    → Step 4: Constructor(nums)\n        → Assign originalArray = copy(nums) // keep original\n        → Assign workingArray = copy(nums) // working copy\n    → Step 5: Method reset()\n        → Return originalArray // reset to original\n    → Step 6: Method shuffle()\n        → Assign workingArray = copy(originalArray) // start fresh\n        → For i from len(workingArray)-1 downto 0\n            → Step: j = random integer [0,i] // random index\n            → Step: swap workingArray[i] and workingArray[j] // Fisher-Yates\n        → Return workingArray\n\nEnd\n\nAdd arrows: Use arrow before each step. Use \"→\" to indicate flow.\n\nWe need each line with \"虛擬碼步驟\" + space + \"// 解釋\". So each line like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類別\n→ Step 2: 定義成員變數 originalArray // 儲存原始陣列\n→ Step 3: 定義成員變數 workingArray // 用於洗牌\n\nand so on.\n\nNeed to include Decision lines? Not much decisions except maybe if i==0? But we can skip.\n\nBut we should incorporate Decision? Could add decision for for loop end condition: Decision: i >= 0? But not necessary.\n\nSimpler.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類別\n    → Step 2: 宣告變數 originalArray // 儲存原始陣列\n    → Step 3: 宣告變數 workingArray // 用於洗牌\n    → Step 4: 建構子 Solution(nums)\n        → Step 5: originalArray ← copy(nums) // 複製輸入陣列作為原始\n        → Step 6: workingArray ← copy(nums) // 複製輸入陣列作為工作副本\n    → Step 7: 方法 reset()\n        → Step 8: 回傳 originalArray // 回復至原始順序\n    → Step 9: 方法 shuffle()\n        → Step 10: workingArray ← copy(originalArray) // 重新開始於原始陣列\n        → Step 11: 迴圈 i 由 len(workingArray)-1 下降至 0\n            → Decision: i >= 0? // 檢查是否還有元素\n                Yes → Step 12: j ← 隨機整數 [0, i] // 隨機選取索引\n                Yes → Step 13: 交換 workingArray[i] 與 workingArray[j] // Fisher-Yates 交換\n                No  → End 迴圈\n        → Step 14: 回傳 workingArray // 回傳洗牌後陣列\nEnd // 程式執行結束\n\nBut we need each line to have \"虛擬碼步驟\" + space + \"// 解釋\". For nested steps we can indent or still use \"→\" lines.\n\nWe should produce a single block of lines, each line starts with \"Start\", \"→\", etc. Use indentation maybe not required but keep readability.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: 宣告成員變數 originalArray // 儲存原始陣列  \n→ Step 3: 宣告成員變數 workingArray // 用於洗牌  \n→ Step 4: 建構子 Solution(nums) // 初始化物件  \n→ Step 5: originalArray ← copy(nums) // 複製輸入陣列作為原始  \n→ Step 6: workingArray ← copy(nums) // 複製輸入陣列作為工作副本  \n→ Step 7: 方法 reset() // 回復陣列  \n→ Step 8: 回傳 originalArray // 回傳原始陣列  \n→ Step 9: 方法 shuffle() // 隨機洗牌  \n→ Step 10: workingArray ← copy(originalArray) // 重新從原始陣列開始  \n→ Step 11: 迴圈 i 由 len(workingArray)-1 下降至 0 // Fisher‑Yates 迴圈  \n→ Decision: i ≥ 0? // 檢查是否還有元素  \n  Yes → Step 12: j ← 隨機整數 [0, i] // 隨機選取索引  \n  Yes → Step 13: 交換 workingArray[i] 與 workingArray[j] // 交換兩個元素  \n  No  → End 迴圈  \n→ Step 14: 回傳 workingArray // 回傳洗牌後陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Comments",
      "source_file": "Leetcode/leetcode722.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "source = [\"a/*comment\", \"line\", \"more_comment*/b\"]",
          "expected_output": "[\"ab\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"ab\"]'\nGot (Norm):      '[\"a\",\"a\",\"ab\"]'\n--- (Raw) ---\nRaw Expected: '[\"ab\"]'\nRaw Got:      \"['a', 'a', 'ab']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeComments(self, source):\n        res = []\n        in_block = False\n\n        for line in source:\n            i = 0\n            if not in_block:\n                new_line = []\n            while i < len(line):\n                if not in_block and i + 1 < len(line) and line[i] == '/' and line[i + 1] == '*':\n                    in_block = True\n                    i += 1  # skip '*'\n                elif in_block and i + 1 < len(line) and line[i] == '*' and line[i + 1] == '/':\n                    in_block = False\n                    i += 1  # skip '/'\n                elif not in_block and i + 1 < len(line) and line[i] == '/' and line[i + 1] == '/':\n                    break  # rest of line is a comment\n                elif not in_block:\n                    new_line.append(line[i])\n                i += 1\n            if new_line:\n                res.append(\"\".join(new_line))\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # The input may be prefixed with \"source = \"\n    if data.startswith(\"source\"):\n        data = data.split(\"=\", 1)[1].strip()\n    # Safely evaluate the list literal\n    source = ast.literal_eval(data)\n    solution = Solution()\n    result = solution.removeComments(source)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo-code with comments explaining each line. This is a standard problem: remove comments from code. We need to write pseudocode, line by line, each line with explanation. Use arrows, decisions, etc. Must not output real code.\n\nWe'll produce steps: Start, then loops over lines, then for each line we maintain index, state (inside block comment or not). Use flags: in_block_comment = False. For each character in line: if in_block_comment: check for \"*/\" to exit. else check for \"//\" to break rest of line, check for \"/*\" to enter block comment. If not comment, add to result_line. After processing, if result_line non-empty and not in block comment, add to output. At end, return output.\n\nWe should produce pseudocode in plain text: e.g.:\n\nStart // begin\n→ Initialize output list // store cleaned lines\n→ Initialize block_flag = False // track if inside block comment\n→ For each line in source // iterate lines\n    → Initialize i = 0 // index in line\n    → Initialize curr = \"\" // accumulate current cleaned line\n    → While i < length(line) // process characters\n        → If block_flag // inside block comment\n            → If line[i:i+2] == \"*/\" // find end\n                → block_flag = False\n                → i += 2\n            → Else\n                → i += 1 // skip char inside block comment\n        → Else // not inside block comment\n            → If line[i:i+2] == \"//\" // line comment\n                → Break // ignore rest of line\n            → Else if line[i:i+2] == \"/*\" // start block comment\n                → block_flag = True\n                → i += 2\n            → Else\n                → curr += line[i]\n                → i += 1\n    → If curr not empty AND not block_flag // if not in block comment\n        → Append curr to output\nEnd // finished\n\nEdge: after loop, if still in block comment, we ignore lines until closed.\n\nWe also need to ignore lines that become empty. So we check curr length > 0 before append.\n\nAlso, if after loop we are still inside block comment, we shouldn't append the line. Our condition curr not empty AND not block_flag ensures that.\n\nBut if block_flag is true at end of line, we still may have some part of line before block comment that should be kept. In typical algorithm, we still need to add curr even if block_flag is true because the part before comment should be kept. But the pseudocode condition: If curr not empty, append curr. The flag doesn't matter. Wait, we must not append the line if it becomes empty after removing comments. If block_flag remains true, but curr has characters, we should still add curr. So we don't need block_flag condition. We just add curr if non-empty. So condition: If curr not empty, append curr.\n\nBut also if block_flag remains true across lines, we just continue skipping until closed.\n\nSo modify: After while, if curr length > 0, append to output.\n\nEdge: If line ends inside block comment, curr may be empty. Then nothing appended.\n\nOk.\n\nAlso we should handle block comment start inside a line but not closed; we still add previous curr, then skip rest.\n\nHence after while, we append curr if not empty.\n\nImplement pseudocode accordingly.\n\nLet's produce pseudocode lines with arrows and explanation.\n\nWe need to use decision arrows for decisions: Yes →, No →, etc. Use Start, End.\n\nWe'll create a while loop for lines, but it's easier to have For each line.\n\nWe might represent For each line as → Step:  Loop over lines.\n\nIn pseudocode we can just have \"→ Step: Loop over each line\" with explanation. Then inside a while loop.\n\nWe should show decision: if block_flag? etc.\n\nLet's produce final answer.\n\nAlso we need to mention that string length functions, slice operations etc.\n\nMake sure each line has code part and comment separated by space. Use \"虛擬碼步驟 // 解釋/說明\".\n\nWe'll produce the lines.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ output ← [] // 儲存去除註解後的程式碼行\n→ inBlock ← False // 標記是否處於區塊註解中\n→ Step 1: Loop over each line in source // 逐行處理原始程式碼\n    → i ← 0 // 目前字元索引\n    → curr ← \"\" // 用於累積該行清除註解後的內容\n    → While i < length(line) // 逐字元掃描\n        → Decision: inBlock? // 判斷是否已進入區塊註解\n            Yes → // 在區塊註解內\n                → Decision: line[i:i+2] == \"*/\"? // 檢查是否結束區塊註解\n                    Yes → inBlock ← False // 結束區塊註解\n                            i ← i + 2 // 跳過 \"*/\"\n                    No → i ← i + 1 // 仍在註解內，忽略此字元\n            No → // 未進入區塊註解\n                → Decision: line[i:i+2] == \"//\"? // 檢查是否開始行註解\n                    Yes → Break // 跳過整行剩餘字元\n                → Decision: line[i:i+2] == \"/*\"? // 檢查是否開始區塊註解\n                    Yes → inBlock ← True // 進入區塊註解\n                            i ← i + 2 // 跳過 \"/*\"\n                → // 字元屬於程式碼\n                    curr ← curr + line[i] // 加入結果\n                    i ← i + 1 // 移動到下一個字元\n    → Decision: curr != \"\"? // 檢查是否有可輸出的程式碼\n        Yes → output.append(curr) // 將清除註解後的行加入結果\n→ End // 程式執行結束\nreturn output // 回傳去除註解後的程式碼列表"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Wrap the input with brackets to make it a valid JSON array\n    parsed = json.loads(f'[{data}]')\n    commands, args_list = parsed[0], parsed[1]\n\n    instance = None\n    outputs = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            instance = Solution(*args)\n            outputs.append(None)\n        else:\n            method = getattr(instance, cmd)\n            result = method(*args)\n            outputs.append(result)\n\n    # Print the results using JSON to ensure None -> null\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. The problem: weighted random selection from array w. Implementation: preprocess prefix sums, store total weight. Then pickIndex: generate random number r between 1 and total weight, binary search prefix sums to find index. But virtual code not actual code, just pseudocode steps.\n\nWe need step by step lines: Start, Step 1: Compute prefix sums array prefix. Step 2: store total weight. Step 3: pickIndex function: generate random r, binary search, return index. Also include decision flows? Maybe not needed but can use Decision for binary search steps.\n\nLet's produce lines with arrow \"→\". Use \"Decision:\" for binary search step.\n\nLet's do:\n\nStart\n→ Step 1: 初始化 prefix[0] = w[0]，並計算其餘 prefix[i] = prefix[i-1] + w[i] // 生成前綴和\n→ Step 2: 設定 total = prefix[w.length-1] // 整體權重總和\n→ Step 3: 定義函式 pickIndex() // 開始隨機選取\n    → Step 4: 產生隨機數 r ∈ [1, total] // 生成隨機權重\n    → Decision: r 與 prefix 陣列做二分搜尋以尋找最小 index i 使 prefix[i] ≥ r\n        Yes → Step 5: 返回 i // 找到符合條件的索引\n        No  → Step 6: 連續調整 r 並重複搜尋 // （實際上二分搜尋會在決策內完成）\nEnd\n\nBut better to write Decision properly: we can show binary search loop: while low < high etc. But using Decision: maybe:\n\nDecision: low < high? No -> return low. But simpler: Step 5: 執行二分搜尋，返回找到的索引。\n\nLet's produce more explicit.\n\nMaybe include a loop:\n\n→ Decision: low < high? // 判斷是否還有多個區間\n    Yes → Step 5: 計算 mid = (low+high)/2\n           → Decision: r ≤ prefix[mid]? // r 在左半邊？\n                Yes → Step 6: high = mid\n                No  → Step 7: low = mid + 1\n           → 回到 Decision: low < high?\n    No  → Step 8: 返回 low // low 為選取的索引\n\nBut that's complex; still okay.\n\nSimplify: Use Step 5: 進行二分搜尋，找到索引 i; Step 6: 返回 i.\n\nLet's keep decision for search.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算前綴和陣列 prefix，其中 prefix[0] = w[0]，對於 i>0 取 prefix[i] = prefix[i-1] + w[i] // 生成各位置累積權重  \n→ Step 2: 設定 total = prefix[w.length-1] // 記錄所有權重總和  \n→ Step 3: 定義函式 pickIndex() // 開始隨機選取索引  \n  → Step 4: 產生隨機數 r ∈ [1, total] // 生成一個隨機權重位置  \n  → Decision: r 與 prefix 陣列做二分搜尋以尋找最小 index i 使 prefix[i] ≥ r  \n    Yes → Step 5: 找到符合條件的索引 i // binary‑search 結束  \n    No  → Step 6: 重複搜尋（實際上二分搜尋在 Decision 內完成）  \n  → Step 7: 返回 i // 隨機選取的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp950g6_vu.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmp950g6_vu.py\", line 39, in main\n    raise ValueError(\"輸入格式不正確\")\nValueError: 輸入格式不正確"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3mnn7255.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmp3mnn7255.py\", line 39, in main\n    raise ValueError(\"輸入格式不正確\")\nValueError: 輸入格式不正確"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        # 使用二分搜尋計算每一行的 1 的數量\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()                         # 先按士兵數量升序，再按索引升序\n        return [i for _, i in soldiers[:k]]     # 取前 k 個最弱行的索引\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 解析輸入格式：mat = [[...]], k = 3\n    pattern = r'mat\\s*=\\s*(\\[[\\[\\],\\s]*\\])\\s*,\\s*k\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data, re.DOTALL)\n    if not match:\n        # 若輸入不符合上述格式，嘗試另一種常見格式\n        # 例如第一行 m n，接下來 m 行矩陣，最後一行 k\n        parts = data.splitlines()\n        if len(parts) >= 3:\n            m, n = map(int, parts[0].split())\n            mat = [list(map(int, parts[i+1].split())) for i in range(m)]\n            k = int(parts[m+1])\n            result = Solution().kWeakestRows(mat, k)\n            print(result)\n            return\n        else:\n            raise ValueError(\"輸入格式不正確\")\n    mat_str, k_str = match.group(1), match.group(2)\n    mat = ast.literal_eval(mat_str)\n    k = int(k_str)\n    result = Solution().kWeakestRows(mat, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe user wants a virtual code solution in Traditional Chinese. They gave the problem: Find k weakest rows in binary matrix where each row has all 1s before 0s. Need to output indices of k weakest rows sorted from weakest to strongest. Provide pseudocode line by line with explanations after //.\n\nWe must use the specified format: each line has virtual code + space + // explanation.\n\nWe need to use arrows →, Start, End, Decision: etc.\n\nWe need to describe algorithm: For each row, count number of 1s. Then store pair (count, index). Sort by count ascending, index ascending. Then take first k indices. Output them.\n\nWe must use virtual code, not actual code.\n\nWe must produce each line as \"→ Step X: ...\" etc.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化空列表 rowsInfo // 存放每行的 (士兵數, 行索引)\n→ Step 2: 循環遍歷每一行 i 從 0 到 m-1 // 逐行處理\n    → Step 2a: 初始化士兵計數 count = 0 // 先將計數器設為0\n    → Step 2b: 循環遍歷每個列 j 從 0 到 n-1 // 逐列檢查\n        → Decision: 如果 mat[i][j] == 1? // 判斷是否為士兵\n            Yes → Step 2b.i: count = count + 1 // 計數加一\n            No  → Decision: 如果 mat[i][j] == 0? // 檢查是否為平民\n                Yes → Step 2b.ii: 跳出內層循環 // 因為已經是0，後面全是0\n    → Step 2c: Append (count, i) 到 rowsInfo // 存入結果\n→ Step 3: 對 rowsInfo 進行排序，首先按 count 升序，若相同則按 index 升序 // 先排序\n→ Step 4: 初始化結果列表 result // 存放最弱的 k 行索引\n→ Step 5: 循環從 0 到 k-1\n    → Step 5a: Append rowsInfo[i].index 到 result // 把最弱的索引加進去\n→ End // 返回 result\n\nBut we need to keep in format: each line separated. We need to indent decisions maybe use spaces.\n\nThey gave example with indentation.\n\nWe'll replicate that.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空列表 rowsInfo // 用來存放每行的 (士兵數, 行索引)  \n→ Step 2: 循環遍歷每一行 i 從 0 到 m-1 // 逐行處理  \n  → Step 2a: 初始化士兵計數 count = 0 // 將計數器設為 0  \n  → Step 2b: 循環遍歷每個列 j 從 0 到 n-1 // 逐列檢查  \n    → Decision: 如果 mat[i][j] == 1? // 判斷是否為士兵  \n     Yes → Step 2b.i: count = count + 1 // 計數加一  \n     No → Decision: 如果 mat[i][j] == 0? // 檢查是否為平民  \n      Yes → Step 2b.ii: 跳出內層循環 // 後面全是 0，結束此行遍歷  \n  → Step 2c: Append (count, i) 到 rowsInfo // 存入此行結果  \n→ Step 3: 對 rowsInfo 進行排序，首先按 count 升序，若相同則按 index 升序 // 先排序  \n→ Step 4: 初始化結果列表 result // 用來存放最弱的 k 行索引  \n→ Step 5: 循環從 0 到 k-1  \n  → Step 5a: Append rowsInfo[i].index 到 result // 把最弱的索引加進去  \nEnd // 程式執行結束並返回 result"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"Return the product of two non‑negative integers represented as strings.\"\"\"\n        # 如果任一數字為 0，直接返回 0\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        m, n = len(num1), len(num2)\n        # 結果最多有 m + n 位，初始化為 0\n        pos = [0] * (m + n)\n\n        # 從右往左遍歷兩個數字\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                # 兩位相乘後會影響 pos[i+j] 與 pos[i+j+1]\n                p1, p2 = i + j, i + j + 1\n                total = mul + pos[p2]\n\n                # 把進位存回 pos[p1]，餘數留在 pos[p2]\n                pos[p1] += total // 10\n                pos[p2] = total % 10\n\n        # 把整數陣列轉成字串，並去除前導 0\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result\n\ndef main():\n    # 讀取整個輸入，允許多種格式\n    data = sys.stdin.read()\n    # 把所有的數字字串（包含在引號或直接）找出來\n    nums = re.findall(r\"\\d+\", data)\n    if len(nums) < 2:\n        # 如果沒有足夠的數字，直接結束\n        return\n    num1, num2 = nums[0], nums[1]\n\n    sol = Solution()\n    product = sol.multiply(num1, num2)\n    # 輸出結果\n    print(product)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line for multiplying two big integer strings without using big integers. We'll output steps similar to typical multiplication algorithm using arrays. Use steps: Start, handle zero cases, reverse strings, init result array size len1+len2, loop over digits, compute product, accumulate carry, convert to string. End. Ensure each line: \"虛擬碼步驟 // 解釋\". Use arrows. Use Start End. Use Decision and loops. Provide explanation after each line. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 若 num1 == \"0\" 或 num2 == \"0\" 则返回 \"0\" // 檢查任何一個數字是否為 0，直接返回 0  \n→ Decision: 若任一為 0?  \n    Yes → End // 若有 0，程式結束，返回 \"0\"  \n    No  → Step 2: 取 num1 和 num2 的長度，分別記為 m 和 n // 為後續陣列準備大小  \n→ Step 3: 建立整數陣列 result[ m + n ]，所有值初始化為 0 // 用於存放乘法結果的每一位  \n→ Step 4: 反轉 num1 並將每個字符轉為對應數字，存入 array1 // 方便從低位開始計算  \n→ Step 5: 反轉 num2 並將每個字符轉為對應數字，存入 array2 // 同上  \n→ Step 6: 循環 i 從 0 到 m-1  \n    → Step 7: 循環 j 從 0 到 n-1  \n        → Step 8: 乘以當前位：mul = array1[i] * array2[j] // 兩位數字相乘  \n        → Step 9: 加入到結果中：sum = result[i + j] + mul // 與前面累積的值相加  \n        → Step 10: result[i + j] = sum % 10 // 將單位位放回結果陣列  \n        → Step 11: result[i + j + 1] += sum / 10 // 將進位加到高一位  \n→ Step 12: 從結果陣列的末尾開始跳過任何前導 0，找出最高有效位 idx // 去除不必要的前導零  \n→ Step 13: 建立字串 builder，從 idx 到 0 依序將 result[k] 轉為字符加入 builder // 重新組成最終結果  \n→ Step 14: 返回 builder 的字串 // 完成乘法運算，返回字符串結果  \nEnd // 程式執行結束"
    },
    {
      "title": "H-Index II",
      "source_file": "Leetcode/leetcode275.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef h_index(citations):\n    \"\"\"Return the h-index of a researcher given a sorted list of citations.\"\"\"\n    n = len(citations)\n    left, right = 0, n - 1\n    h = 0\n    while left <= right:\n        mid = (left + right) // 2\n        # Number of papers from mid to end\n        papers = n - mid\n        if citations[mid] >= papers:\n            h = papers\n            left = mid + 1\n        else:\n            right = mid - 1\n    return h\n\nif __name__ == \"__main__\":\n    # Read entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Try to extract the list of citations from the input\n    try:\n        if '=' in data:\n            # e.g., \"citations = [0,1,3,5,6]\"\n            _, expr = data.split('=', 1)\n            citations = ast.literal_eval(expr.strip())\n        else:\n            # e.g., \"[0,1,3,5,6]\"\n            citations = ast.literal_eval(data)\n    except Exception as e:\n        # If parsing fails, treat input as a single integer per line\n        citations = [int(line) for line in data.splitlines() if line.strip()]\n\n    # Ensure the list is sorted (the problem guarantees it, but we guard anyway)\n    citations.sort()\n    result = h_index(citations)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code in Chinese, step by step, with explanation comments. Must follow format. Provide algorithm to compute h-index in log time given sorted citations array. Use binary search. Steps: Start, input array, set low=0 high=n-1, result=0. While low<=high: mid, citation=arr[mid]; papersFromMid = n-mid; if citation>=papersFromMid: result=mid+1; low=mid+1; else: high=mid-1. End: output result. Provide explanations. Use arrows and Decision structure. Ensure each line ends with comment. Provide Step tags. Use \"Step\" labels maybe \"Step 1:\". Use arrow \"→\". Use \"Decision:\" lines.\n\nMake sure format: \"虛擬碼步驟 // 解釋\". Use Chinese. Provide in order. Use Start, End. Provide binary search loop. Provide condition evaluation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得 citations 陣列與其長度 n // 讀取已排序的引用次數與大小\n→ Step 2: 初始化 low ← 0, high ← n-1, hIndex ← 0 // 設定二分搜尋的左右邊界與結果變數\n→ Decision: while low ≤ high? // 判斷是否還有範圍可搜尋\n    Yes → Step 3: mid ← (low + high) // 2 // 計算中間索引\n    → Step 4: citation ← citations[mid] // 取得中間位置的引用次數\n    → Decision: 是否 citation ≥ (n - mid)? // 檢查此引用是否能滿足至少 (n-mid) 篇被至少 citation 次引用\n        Yes → Step 5: hIndex ← mid + 1 // 更新 h-index 為目前可行值\n        → Step 6: low ← mid + 1 // 搜尋更高的 h-index\n        No  → Step 7: high ← mid - 1 // 搜尋更低的 h-index\n    End // while 迴圈結束\n→ Step 8: 輸出 hIndex // 回傳計算出的 h-index\nEnd // 程式執行結束"
    }
  ]
}