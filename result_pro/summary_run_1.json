{
  "run_index": 1,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 393,
  "generation_or_validation_failure_count": 46,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,2,5,1,5]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 2, 5, 1, 5]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳結果清單\"\"\"\n    return [random.randint(1, 6) for _ in range(n)]\n\ndef main():\n    # 讀取所有輸入\n    code = sys.stdin.read()\n    # 在 local 域中執行輸入的程式碼，讓 roll_dice 可用\n    local_vars = {\"roll_dice\": roll_dice}\n    exec(code, {}, local_vars)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations, following the format. No actual code. Just pseudo steps. Should include random module import? In virtual code, maybe \"Import random\". Then define function roll_dice(n). Then initialize result list. Then loop i from 1 to n. Inside loop, generate random number 1-6. Append to list. End loop. Return list. End. Provide explanation comments. Use Start and End.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\". Use arrow notation. For loops: \"→ For i in range 1 to n\". Provide Decision? No.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Import random // 引入 random 模組\n→ Function roll_dice(n) // 定義 roll_dice 函數，參數 n 為擲骰次數\n    → Initialize result_list as empty list // 建立空清單用來儲存每次擲骰結果\n    → For i from 1 to n // 重複擲骰 n 次\n        → Generate roll = random integer between 1 and 6 // 產生 1~6 的隨機整數\n        → Append roll to result_list // 將結果加入清單\n    → Return result_list // 回傳所有擲骰結果的清單\nEnd // 程式執行結束\n\nCheck format: each line with arrow. Indentation represented by leading spaces? Use arrow after line number? The format example uses \"→ Step 1: ...\" with indentation for nested. Use consistent.\n\nMake sure to include \"End\" line. Provide explanation after comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import random // 引入 random 模組  \n→ Function roll_dice(n) // 定義 roll_dice 函數，參數 n 為擲骰次數  \n → Initialize result_list as empty list // 建立空清單用來儲存每次擲骰結果  \n → For i from 1 to n // 重複擲骰 n 次  \n  → Generate roll = random integer between 1 and 6 // 產生 1~6 的隨機整數  \n  → Append roll to result_list // 將結果加入清單  \n → Return result_list // 回傳所有擲骰結果的清單  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量 func 執行所需的秒數，並回傳四捨五入到小數點 3 位的結果。\n    \"\"\"\n    start = time.time()\n    func(*args)          # 執行傳入的函式\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取完整程式碼\n    code = sys.stdin.read()\n\n    # 執行讀取到的程式碼，讓 measure_time 可用\n    exec_namespace = {\"measure_time\": measure_time}\n    exec(code, exec_namespace)",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step. Each line: virtual code step + \" // 解釋\". Use arrows. Provide Start, End. We need to implement measure_time(func,*args). Steps: import time module, define function measure_time, record start time, call func with args, record end time, compute elapsed, round to 3 decimal, return result. But virtual code only, not actual code. Should use \"Start\", \"→\", \"Decision:\" maybe not necessary. Use \"→ Function: measure_time\". Provide steps inside. The function should maybe be inside the flow. We can show \"→ Function: measure_time\". Inside, start time, call function, end time, elapsed = end - start, rounded = round(elapsed,3), return rounded. Use \"→ Return\". Provide explanation.\n\nWe must not output actual code but virtual steps. Use format like sample. We also can include import at start.\n\nSo lines:\n\nStart // 程式開始\n→ Import time module // 載入 time 模組\n→ Function: measure_time(func, *args) // 定義 measure_time 函式\n    → Step: start = time.time() // 記錄開始時間\n    → Step: result = func(*args) // 執行傳入函式並傳回結果\n    → Step: end = time.time() // 記錄結束時間\n    → Step: elapsed = end - start // 計算執行時間\n    → Step: rounded = round(elapsed, 3) // 四捨五入到小數點三位\n    → Return: rounded // 回傳時間\nEnd // 程式結束\n\nNeed to maintain arrow levels. Use indentation. Provide each line as separate line.\n\nMake sure each line ends with \"// 解釋\". Provide appropriate explanation in Chinese.\n\nLet's craft.\n\nAlso maybe we need to mention function returns the time, but the result of func is not returned? The requirement says \"測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)\". Wait ambiguous: \"並回傳結果\" could mean return time or return func result? Usually measure_time returns elapsed time. Could also return the result of func and time. But sample: \"回傳結果\" maybe refers to time. Let's assume returns elapsed time. So we don't return func result. Only elapsed time.\n\nThus steps fine.\n\nOk output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import time module // 載入 time 模組  \n→ Function: measure_time(func, *args) // 定義 measure_time 函式  \n → Step: start = time.time() // 記錄開始時間  \n → Step: func(*args) // 執行傳入函式  \n → Step: end = time.time() // 記錄結束時間  \n → Step: elapsed = end - start // 計算執行時間  \n → Step: rounded = round(elapsed, 3) // 四捨五入到小數點 3 位  \n → Return: rounded // 回傳測量到的秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"melon\",\"orange\",\"apple\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'melon', 'orange', 'apple', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取並忽略任何來自標準輸入的資料\n    sys.stdin.read()\n\n    # 建立並操作集合\n    fruits = {'apple', 'banana'}          # 1. 初始化集合\n    fruits.add('orange')                  # 2. 新增單一元素\n    fruits.update(['grape', 'melon'])     # 3. 一次新增多個元素\n    fruits.remove('banana')               # 4. 移除已存在元素\n    fruits.discard('pineapple')           # 5. 嘗試移除不存在元素（不會拋錯）\n\n    # 輸出最終結果\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce line by line pseudo-code for the described operations. Provide explanation after each line. Use Start, End, Decision. But there are no decisions except maybe discarding missing element. We'll just show steps.\n\nSteps:\n\nStart\n\n→ Step 1: Create set fruits = {'apple', 'banana'} // initialize set\n\n→ Step 2: Call fruits.add('orange') // add single element\n\n→ Step 3: Call fruits.update(['grape', 'melon']) // add multiple elements\n\n→ Step 4: Call fruits.remove('banana') // remove existing element\n\n→ Step 5: Call fruits.discard('pineapple') // attempt to discard non-existing element\n\n→ Step 6: Output fruits // print set\n\nEnd\n\nAlso may add a decision if element present for remove? But remove will throw error if not present; but we assume banana present.\n\nJust keep simple. Provide each line with explanation.\n\nLet's output in required format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits = {'apple', 'banana'} // 建立包含兩個元素的集合  \n→ Step 2: fruits.add('orange') // 使用 add() 新增單一元素 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 一次新增多個元素 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除已存在的元素 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的元素 'pineapple'（不會拋錯誤）  \n→ Step 6: Output fruits // 輸出最終的集合內容  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.88TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.88 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\n\n# ------------------------------------------------------------\n# 取得美元對台幣的匯率\n# ------------------------------------------------------------\ndef get_rate():\n    \"\"\"\n    連接 https://api.exchangerate-api.com/v4/latest/USD 並抓取 TWD 的匯率。\n    成功時回傳浮點數，失敗時回傳 None。\n    \"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        r = requests.get(url, timeout=5)\n        r.raise_for_status()                      # 失敗時拋出 HTTPError\n        data = r.json()\n        rate = data[\"rates\"][\"TWD\"]\n        return float(rate)\n    except Exception:\n        return None\n\n# ------------------------------------------------------------\n# 以 Tkinter 展示匯率的 GUI（不會在主程式執行時自動開啟）\n# ------------------------------------------------------------\ndef run_gui():\n    \"\"\"\n    建立一個簡易的 GUI，按下「更新匯率」按鈕時會呼叫 get_rate()\n    並把結果寫入 Label。\n    \"\"\"\n    import tkinter as tk\n\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update():\n        rate = get_rate()\n        if rate is not None:\n            label.config(text=f\"目前美元匯率：約 {rate:.2f} TWD\")\n        else:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n\n    tk.Button(win, text=\"更新匯率\", command=update).pack(pady=5)\n    win.mainloop()\n\n# ------------------------------------------------------------\n# 主程式：讀取標準輸入並輸出匯率資訊\n# ------------------------------------------------------------\ndef main():\n    \"\"\"\n    程式執行時從標準輸入讀取文字。\n    若輸入中包含「更新匯率」字樣，就會抓取最新匯率並印出，\n    其餘輸入則不作任何處理。\n    \"\"\"\n    command = sys.stdin.read().strip()\n    if \"更新匯率\" in command:\n        rate = get_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate:.2f} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n    # 若輸入不包含「更新匯率」，則不輸出任何內容\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with comments in Chinese. Use Start, End, Decision. Include steps for importing modules, creating Tkinter window, label, button, function to fetch rate via requests, update label, set button command, run mainloop. Use arrow \"→\". No actual code. Provide step per line. Use virtual code style. Each line: \"Step X: ... // explanation\". Must include arrow and indentation for Decision branches. Use \"Decision:\" lines for conditions. The only decision: maybe checking if requests succeed? But we can keep simple: if API call succeeded else show error. Provide that decision.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 requests 模組與 tkinter 模組 // 引入外部 API 與 GUI 所需的模組  \n→ Step 2: 建立 tkinter 視窗 root 並設定標題為 '匯率查詢' // 初始化主視窗  \n→ Step 3: 在 root 中加入 Label 用於顯示匯率，預設文字為 '匯率載入中...' // 佈局顯示區域  \n→ Step 4: 定義函式 fetch_rate() 用於呼叫 API 並更新 Label // 準備更新匯率的功能  \n→ Step 5: 在 fetch_rate() 中，使用 requests.get 呼叫 'https://api.exchangerate-api.com/v4/latest/USD' // 取得美元最新匯率資料  \n→ Step 6: Decision: 若請求成功 (status_code == 200)? // 檢查 HTTP 回傳是否成功  \n  Yes → Step 7: 解析 JSON 並取出 rates.TWD 值 // 讀取台幣匯率  \n   → Step 8: 將 Label 文字更新為 'USD to TWD: {rate}' // 顯示最新匯率  \n  No  → Step 9: 將 Label 文字更新為 '取得匯率失敗，請稍後再試' // 顯示錯誤訊息  \n→ Step 10: 在 root 中加入 Button，文字為 '更新匯率' 並設定 command 為 fetch_rate // 設置更新按鈕  \n→ Step 11: 在啟動時即呼叫 fetch_rate() 以載入初始匯率 // 第一次進入程式時即顯示資料  \n→ Step 12: 執行 root.mainloop() // 啟動 tkinter 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp07uj9fw8.py\", line 61, in <module>\n    args = json.loads(array_matches[1])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 4 (char 3)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport re\n\nclass RandomizedSet:\n    \"\"\"O(1) average time complexity for insert, remove, getRandom.\"\"\"\n\n    def __init__(self):\n        # dict: value -> index in the list\n        self.val_to_index = {}\n        # list of current values\n        self.values = []\n\n    def insert(self, val):\n        \"\"\"Insert val if not present. Return True if inserted, False otherwise.\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        \"\"\"Remove val if present. Return True if removed, False otherwise.\"\"\"\n        if val not in self.val_to_index:\n            return False\n        # index of element to remove\n        idx = self.val_to_index[val]\n        # last element in the list\n        last_val = self.values[-1]\n        # move last element to idx\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        # pop last element\n        self.values.pop()\n        # delete entry for val\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        \"\"\"Return a random element from the set.\"\"\"\n        return random.choice(self.values)\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Find the two top‑level arrays in the input\n    array_matches = re.findall(r'\\[.*?\\]', data, flags=re.S)\n    if len(array_matches) < 2:\n        # Fallback: split at the first '],'\n        split_idx = data.find('],')\n        ops_str = data[:split_idx + 1]\n        args_str = data[split_idx + 2:].strip()\n        ops = json.loads(ops_str)\n        args = json.loads(args_str)\n    else:\n        ops = json.loads(array_matches[0])\n        args = json.loads(array_matches[1])\n\n    result = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            result.append(None)\n        elif op == \"insert\":\n            result.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            result.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            result.append(obj.getRandom())\n        else:\n            # Unknown operation; append None\n            result.append(None)\n\n    # Print result in LeetCode style (null/true/false)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. We need to show steps for the RandomizedSet class with insert, remove, getRandom, each O(1). Use a hashmap and array. Virtual code: Start, Step 1: Define class RandomizedSet // etc. Provide steps: Initialize dict and list. For insert: check if val in dict, if not, append to list, store index in dict, return true else false. For remove: check if val in dict, if not return false. else get index, get last element, move last to index, update dict for last, pop last from list, delete val from dict, return true. getRandom: generate random index, return list[idx].\n\nWe need to use virtual code style with arrows, decisions. Provide line per step. Ensure each line includes explanation. Use [Start] etc.\n\nLet's produce. Use \"虛擬碼步驟 // 解釋\".\n\nWe need to incorporate arrow lines. Use indentation for decisions. Provide each line as separate. Use \"Start\" and \"End\". Use \"Decision:\" for condition.\n\nWe must not output actual code, just virtual steps. Use arrow \"→\". Provide each line separately.\n\nLet's craft.\n\nWe'll start with Start // 程式開始.\n\nLine 1: Start // 程式開始\n\nLine 2: → Step 1: 建立 RandomizedSet 類別 // 定義類別結構\n\nLine 3: → Step 2: 初始化內部資料結構 // 建立 dict 與 list 以支援 O(1) 操作\n\nWe'll show dictionary mapping value to index, list storing values.\n\nBut need to be step by step: e.g., \"→ Step 2a: 創建 empty dict value_to_index // 快速查找索引\" then \"→ Step 2b: 創建 empty list elements // 儲存所有值\". Maybe we can combine.\n\nBut easier: \"→ Step 2: 初始化 value_to_index 為空字典，elements 為空列表 // 用於 O(1) 參照\". Provide explanation.\n\nSimilarly for methods: Insert, Remove, getRandom. Provide decisions.\n\nLet's produce.\n\nAlso use \"Decision:\" with Yes/No. For insert: check if val exists: Decision: val in dict? Yes/No. For remove: same.\n\nFor getRandom: just pick random index.\n\nWill produce line by line with arrow. Let's do.\n\nWe must ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use the arrow \"→\" to denote steps. The decision lines include indentation. For decisions, we need to format: \"Decision: ...? // ...\", then \"    Yes → ...\", \"    No → ...\".\n\nMake sure to indent properly with spaces. Provide each line as separate. Use \"End\" at end.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 RandomizedSet 類別 // 定義資料結構與方法  \n→ Step 2: 初始化 value_to_index 為空字典，elements 為空列表 // 用於 O(1) 存取與插入  \n→ Step 3: 建立 insert(val) 方法 // 處理新增元素  \n→ Decision: val 是否已存在於 value_to_index? // 檢查重複  \n  Yes → Step 4: 返回 false // 元素已存在，插入失敗  \n  No  → Step 5: 將 val 加入 elements 並記錄其索引於 value_to_index // 先加入列表，再更新字典  \n   → Step 6: 返回 true // 插入成功  \n→ Step 7: 建立 remove(val) 方法 // 處理刪除元素  \n→ Decision: val 是否存在於 value_to_index? // 檢查是否可刪除  \n  Yes → Step 8: 取得 val 在 elements 的索引 idx  \n   → Step 9: 取得最後一個元素 last_val 以及其索引 last_idx  \n   → Step 10: 將 last_val 移動到 idx 位置並更新其在 value_to_index 的索引為 idx  \n   → Step 11: 從 elements 刪除最後一個元素並移除 val 在 value_to_index 的條目  \n   → Step 12: 返回 true // 刪除成功  \n  No  → Step 13: 返回 false // 元素不存在，刪除失敗  \n→ Step 14: 建立 getRandom() 方法 // 隨機取得元素  \n→ Step 15: 生成隨機索引 r 在 0 到 elements.size() - 1 之間  \n→ Step 16: 返回 elements[r] // 等機率返回任一元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[1,0],[0,0],[2,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [1, 0], [0, 0], [2, 0], null, [2, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, m: int, n: int):\n        self.m = m\n        self.n = n\n        self.total = m * n          # 目前還未翻轉的 0 的個數\n        self.mapping = {}           # 線性索引到實際位置的映射\n\n    def flip(self):\n        # 隨機挑選一個仍為 0 的位置\n        r = random.randint(0, self.total - 1)\n        # 如果 r 已經映射，使用映射後的實際索引；否則直接使用 r\n        x = self.mapping.get(r, r)\n        # 把剩餘的最後一個位置映射到 r\n        self.total -= 1\n        self.mapping[r] = self.mapping.get(self.total, self.total)\n        # 轉回 (row, col)\n        return [x // self.n, x % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.mapping.clear()\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把輸入視為兩個列表，用小括號包起來變成合法的 tuple\n    ops, args = ast.literal_eval('(' + data + ')')\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0], arg[1])\n            results.append(None)\n        elif op == \"flip\":\n            results.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            results.append(None)\n        else:\n            # 若遇到未知指令，直接忽略\n            results.append(None)\n\n    # 將結果輸出為 JSON 風格，Python 的 None 會轉成 null\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps. Provide algorithm: use reservoir sampling? Actually to pick random zero efficiently, we can maintain a list of available cells count. Use mapping approach: maintain map from index to value. Represent matrix linearized indices from 0 to m*n-1. Use mapping: when flip called, pick random k from [0, remaining-1], map it to actual index: if map contains k, use map[k], else use k. Then map[k] = map[remaining-1] if exists else remaining-1. Decrement remaining. Reset: clear map and set remaining=m*n. Complexity: O(1) per flip, O(m*n) reset. Good.\n\nWe produce virtual code lines with explanations. Need to include initialization, flip, reset. Use Start/End markers. Use decision steps. Provide each line. Use arrow notation. Let's produce.\n\nWe should not output actual code, just virtual steps.\n\nLet's outline:\n\nStart\nInitialize m, n\nInitialize total = m*n\nInitialize remaining = total\nInitialize map = empty dictionary\n\nDefine flip:\nDecision: if remaining == 0? maybe not needed.\nGenerate randIndex = random(0, remaining-1)\nDecision: if randIndex in map? Use mapped value else randIndex\nStore selected = mapping\nSwap mapping: if remaining-1 in map? mapping[remaining-1] else remaining-1\nSet map[randIndex] = mapping\nDecrement remaining\nReturn row = selected / n, col = selected % n\n\nDefine reset:\nClear map\nSet remaining = total\n\nEnd\n\nWe need to express steps line by line.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: Input m, n // 獲取矩陣尺寸\n\n→ Step 2: Set total = m * n // 總元素數量\n\n→ Step 3: Set remaining = total // 剩餘可選 0 的元素數量\n\n→ Step 4: Initialize map = {} // 用於映射線性索引\n\n→ Function flip() // 開始 flip 方法\n\n→ Decision:  if remaining == 0? // 檢查是否已無 0 可選\n\n    No  → Step 5: randIndex = randomInt(0, remaining-1) // 隨機取得一個有效索引\n\n    Yes → Step 6: // 可選: 把未選中情況報錯或返回空\n\n→ Step 7: Decision: if randIndex in map? // 是否已被映射\n\n        Yes → selected = map[randIndex] // 取得實際索引\n\n        No  → selected = randIndex // 原始索引\n\n→ Step 8: last = remaining - 1 // 最後一個可選索引\n\n→ Step 9: Decision: if last in map? // 確定 last 的實際索引\n\n        Yes → map[randIndex] = map[last] // 交換映射\n\n        No  → map[randIndex] = last\n\n→ Step 10: remaining = remaining - 1 // 更新剩餘數量\n\n→ Step 11: row = selected / n // 轉換為行\n\n→ Step 12: col = selected % n // 轉換為列\n\n→ Step 13: Return [row, col] // 回傳\n\n→ End Function flip()\n\n→ Function reset() // 開始 reset 方法\n\n→ Step 14: map.clear() // 清空映射\n\n→ Step 15: remaining = total // 重置剩餘數量\n\n→ End Function reset()\n\nEnd // 程式結束\n\nWe need to ensure each line uses \"→\" after Start? Example uses \"Start\" then \"→ Step 1\". Yes.\n\nAlso include decision lines with Yes/No.\n\nMake sure no actual code; just steps. Provide line numbers? Not required. Provide arrow with each step. Let's format accordingly.\n...done thinking.\n\n```\nStart // 程式開始\n→ Step 1: Input m, n // 讀入矩陣尺寸\n→ Step 2: Set total = m * n // 計算矩陣中所有元素數量\n→ Step 3: Set remaining = total // 初始化剩餘可被翻轉為 1 的 0 的數量\n→ Step 4: Initialize map = {} // 用於映射線性索引到實際位置的字典\n\n→ Function flip() // 開始 flip 方法\n    → Decision: remaining == 0? // 檢查是否已無 0 可翻轉\n        Yes → // 若無，可能拋出錯誤或返回空\n        No  → Step 5: randIndex = randomInt(0, remaining - 1) // 隨機取得一個有效索引\n    → Decision: randIndex in map? // 判斷 randIndex 是否已被映射\n        Yes → Step 6: selected = map[randIndex] // 取出映射後的實際索引\n        No  → Step 7: selected = randIndex // 使用原始索引\n    → Step 8: last = remaining - 1 // 計算最後一個可選索引\n    → Decision: last in map? // 判斷 last 是否已被映射\n        Yes → Step 9: map[randIndex] = map[last] // 把 last 的映射值放到 randIndex\n        No  → Step 10: map[randIndex] = last // 直接把 last 放到 randIndex\n    → Step 11: remaining = remaining - 1 // 更新剩餘可翻轉數量\n    → Step 12: row = selected / n // 將線性索引轉為行號\n    → Step 13: col = selected % n // 將線性索引轉為列號\n    → Step 14: Return [row, col] // 回傳所選取的 [i, j] 並已被翻轉為 1\n→ End Function flip() // flip 方法結束\n\n→ Function reset() // 開始 reset 方法\n    → Step 15: map.clear() // 清空映射字典，恢復所有位置為 0\n    → Step 16: remaining = total // 重置剩餘可翻轉數量\n→ End Function reset() // reset 方法結束\n\nEnd // 程式結束\n```"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Error parsing input: Extra data: line 1 column 73 (char 72)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Wrap the input in brackets to make it a valid JSON list\n    if not raw_input.startswith('['):\n        raw_input = '[' + raw_input + ']'\n\n    # Parse the two lists: operations and corresponding arguments\n    try:\n        ops, args = json.loads(raw_input)\n    except json.JSONDecodeError as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MagicDictionary\":\n            obj = MagicDictionary()\n            results.append(None)           # null in JSON\n        elif op == \"buildDict\":\n            obj.buildDict(arg)\n            results.append(None)           # null in JSON\n        elif op == \"search\":\n            res = obj.search(arg)\n            results.append(res)            # True/False\n        else:\n            results.append(None)\n\n    # Output the results as a JSON array (null, true, false)\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code, line by line, with explanation. Not actual code. Need to design algorithm.\n\nWe need to implement MagicDictionary with buildDict and search. Approach: store dictionary; for search, for each word in dictionary, check if differ by exactly one char. Complexity maybe O(n*m). But we can also use hashmap mapping patterns of words with one char replaced by a wildcard. But virtual code can be simple O(n*m). Since it's pseudo, okay.\n\nBut need to produce \"逐行\" and each line has virtual code step and explanation. Use arrows.\n\nWe can produce:\n\nStart\n→ Step 1: Define class MagicDictionary // 定義類別\n→ Step 2: Initialize internal storage list // 初始化資料結構\n→ Step 3: buildDict(dict) // 設定字典\n   → For each word in dict:\n        → Append word to internal list\n→ Step 4: search(word) // 搜尋\n   → For each dictWord in internal list:\n        → If length differs, continue\n        → Count differences\n        → If exactly one, return true\n   → Return false\nEnd\n\nBut need to use Decision arrow formatting.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 MagicDictionary 類別 // 類別結構\n→ Step 2: 定義建構子 MagicDictionary() // 建構子，初始化空的字典\n    → 內部儲存字典列表 dict ← 空列表 // 用於儲存所有單字\n→ Step 3: 定義 buildDict(dictionary) 方法 // 接收字串陣列\n    → Decision: dictionary 是否非空? // 檢查輸入\n        Yes → For each word in dictionary:\n                → Append word 到 dict // 儲存單字\n        No  → 跳過 // 若為空不做任何事\n→ Step 4: 定義 search(searchWord) 方法 // 接收要搜尋的字串\n    → For each word in dict:\n        → Decision: word.length ≠ searchWord.length?\n            Yes → Continue // 長度不同不可能只改一字\n            No  → Decision: word 與 searchWord 差異數是否等於 1?\n                Yes → Return true // 恰好一個不同\n                No  → Continue // 不是一個不同，檢查下一個\n    → Return false // 沒有符合的單字\nEnd // 程式結束\n\nBut we need to use arrow formatting properly: use → Step X: … ; use Decision: … ; Yes → … ; No → …\n\nLet's format accordingly.\n\nNeed to ensure each line ends with // explanation.\n\nWe'll produce multi-line.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MagicDictionary 類別 // 建立字典物件的類別結構  \n→ Step 2: 建構子 MagicDictionary() // 初始化時建立空的字典列表  \n    → dict ← 空列表 // 用於儲存所有加入的單字  \n→ Step 3: 定義 buildDict(dictionary) 方法 // 接收字串陣列並填充字典  \n    → Decision: dictionary 是否為空? // 檢查輸入是否有效  \n        Yes → Return // 若為空則直接回傳，無需進一步處理  \n        No  → For each word in dictionary:  \n                → Append word 到 dict // 將每個單字加入內部列表  \n→ Step 4: 定義 search(searchWord) 方法 // 判斷是否能改一字匹配字典  \n    → For each word in dict:  \n        → Decision: word.length ≠ searchWord.length? // 長度不同不可能只改一字  \n            Yes → Continue // 跳過此單字  \n            No  → Decision: word 與 searchWord 差異字數是否等於 1? // 逐字比較差異  \n                Yes → Return true // 恰好一個字不同，符合條件  \n                No  → Continue // 差異不是一個，檢查下一個單字  \n    → Return false // 所有單字都不符合條件  \nEnd // 程式結束執行"
    },
    {
      "title": "Find K Closest Elements",
      "source_file": "Leetcode/leetcode658.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "arr = [1,2,3,4,5], k = 4, x = 3",
          "expected_output": "[1,2,3,4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp80np6lin.py\", line 36, in <module>\n    arr, k, x = parse_input(data)\n                ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp80np6lin.py\", line 25, in parse_input\n    arr = ast.literal_eval(part.split('=', 1)[1].strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "arr = [1,1,2,3,4,5], k = 4, x = -1",
          "expected_output": "[1,1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpx1lzl16_.py\", line 36, in <module>\n    arr, k, x = parse_input(data)\n                ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpx1lzl16_.py\", line 25, in parse_input\n    arr = ast.literal_eval(part.split('=', 1)[1].strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findClosestElements(self, arr, k, x):\n        # 二分搜尋找出左邊界 left，使得 arr[left:left+k] 為最接近 x 的區間\n        left, right = 0, len(arr) - k\n        while left < right:\n            mid = (left + right) // 2\n            # 比較 arr[mid] 與 arr[mid + k] 與 x 的距離\n            if x - arr[mid] > arr[mid + k] - x:\n                left = mid + 1\n            else:\n                right = mid\n        return arr[left:left + k]\n\ndef parse_input(line: str):\n    \"\"\"\n    從 'arr = [...], k = ..., x = ...' 的字串解析出 arr、k 與 x。\n    \"\"\"\n    parts = [p.strip() for p in line.split(',')]\n    arr = k = x = None\n    for part in parts:\n        if part.startswith('arr'):\n            arr = ast.literal_eval(part.split('=', 1)[1].strip())\n        elif part.startswith('k'):\n            k = int(part.split('=', 1)[1].strip())\n        elif part.startswith('x'):\n            x = int(part.split('=', 1)[1].strip())\n    return arr, k, x\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    arr, k, x = parse_input(data)\n    sol = Solution()\n    result = sol.findClosestElements(arr, k, x)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code lines for algorithm to find k closest integers to x in sorted array. Classic solution: binary search for position, then two-pointer expansion. So produce steps: Start, input array arr, k, x. Use binary search to find leftmost index where arr[i] >= x. Then left = index-1, right=index. While result size < k: compare distances, pick closer, adjust pointers. Finally collect selected elements, sort ascending. End. Provide lines with explanation.\n\nMake sure each line includes virtual code step and comment. Use arrow symbols and Decision: etc. We'll output line by line.\n\nLet's create lines:\n\nStart // 程式開始執行\n→ Step 1: 讀取排序陣列 arr, 整數 k, 數字 x // 從使用者取得資料\n→ Step 2: 使用二分搜尋找到首個 arr[i] >= x 的索引 pos // 定位 x 在陣列中的位置\n→ Decision: pos 是否等於 0? // 判斷是否左側空\n    Yes → Step 3: left = -1 // 左邊沒有元素\n    No  → Step 3: left = pos - 1 // 左指標設定為 pos 前一個位置\n→ Step 4: right = pos // 右指標設定為 pos\n→ Step 5: 建立空清單 result // 用來儲存最終 k 個最接近的數\n→ Decision: result 大小 < k? // 是否已收集足夠數字\n    Yes → Decision: left < 0 or right >= arr.Length or |arr[left]-x| <= |arr[right]-x|? // 比較可選擇左或右\n        Yes → Step 6: result.Add(arr[left]) // 選擇左邊較近或左邊等距且更小的數\n            left = left - 1 // 左指標左移\n        No  → Step 6: result.Add(arr[right]) // 選擇右邊較近的數\n            right = right + 1 // 右指標右移\n    No  → Step 7: result.Sort() // 將結果升序排列\n→ End // 程式執行結束\n\nBut ensure proper arrow usage. Each line starting with \"→\" except Start and End. Use \"Decision:\" etc. Provide explanation after //.\n\nMake sure to include \"End\" line with comment. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取排序陣列 arr、整數 k 以及數值 x // 從使用者取得輸入\n→ Step 2: 使用二分搜尋找出第一個 arr[i] >= x 的索引 pos // 定位 x 在陣列中的大於等於位置\n→ Decision: pos 是否等於 0? // 判斷左邊是否還有元素\n    Yes → Step 3: left = -1 // 左指標設定為不存在\n    No  → Step 3: left = pos - 1 // 左指標指向 pos 前一個位置\n→ Step 4: right = pos // 右指標設定為 pos\n→ Step 5: 建立空清單 result // 用來儲存最終的 k 個最近元素\n→ Decision: result.長度 < k? // 是否已收集足夠數字\n    Yes → Decision: left < 0 or right >= arr.Length or |arr[left]-x| <= |arr[right]-x|? // 比較可選擇左或右\n        Yes → Step 6: result.Add(arr[left]) // 選擇左邊較近或左邊等距且更小的數\n            left = left - 1 // 左指標左移\n        No  → Step 6: result.Add(arr[right]) // 選擇右邊較近的數\n            right = right + 1 // 右指標右移\n    No  → Step 7: result.Sort() // 將結果升序排列\nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnc_ju99w.py\", line 40, in <module>\n    main()\n  File \"/tmp/tmpnc_ju99w.py\", line 36, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpnc_ju99w.py\", line 19, in __init__\n    if key not in self.lookup or idx > self.lookup[key]:\n       ^^^^^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass WordFilter:\n    \"\"\"\n    使用字典存儲每個 (前綴, 後綴) 組合對應的最大索引。\n    在建構時，對每個單字產生所有可能的前綴與後綴，並更新對應的索引。\n    \"\"\"\n    def __init__(self, words):\n        self.lookup = {}\n        for idx, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):              # 前綴長度\n                prefix = word[:i]\n                for j in range(L + 1):          # 後綴長度\n                    suffix = word[j:]\n                    key = (prefix, suffix)\n                    # 只保留最大的索引\n                    if key not in self.lookup or idx > self.lookup[key]:\n                        self.lookup[key] = idx\n\n    def f(self, pref, suff):\n        \"\"\"\n        回傳符合前綴 pref 與後綴 suff 的單字最大索引，若不存在則回傳 -1。\n        \"\"\"\n        return self.lookup.get((pref, suff), -1)\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 讓整個輸入成為一個合法的 JSON 列表，方便解析\n    data = json.loads('[' + raw + ']')\n    words, pair = data[0], data[1]\n    pref, suff = pair[0], pair[1]\n    wf = WordFilter(words)\n    print(wf.f(pref, suff))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to design virtual code for WordFilter with constructor and method f. The dictionary search by prefix and suffix. Probably use Trie with suffixes or combine. But virtual code. Each line: 虛擬碼步驟 // 解釋. Use arrows. Must not output actual code, just virtual code. Steps: Start, Build prefix and suffix tries, or map combined key. Implementation: We can store map from prefix+suffix to max index. For each word index, for all prefixes and suffixes generate key. Complexity: O(N*len^2). Acceptable for small. Provide steps. Ensure each line has virtual code and explanation.\n\nLet's produce algorithm:\n\nStart\n→ Build dictionary: for each word with index i\n    → For pLen 0..len: prefix = word[0:pLen]\n        → For sLen 0..len: suffix = word[len-sLen:]\n            → key = prefix + \"#\" + suffix\n            → Store max index in map[key] = i\nEnd build\n\nMethod f:\n→ Input pref, suff\n→ key = pref + \"#\" + suff\n→ If key in map: return map[key] else -1\n\nReturn largest index due to overwriting.\n\nProvide virtual code lines. Use arrows: Start, → Step, Decision. Let's produce.\n\nLet's ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow syntax. For loops, we can write \"For each word index i in words\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ 初始化 WordFilter(words) // 接收所有單字並建立查詢資料結構\n    → 建立空 Map<string, int> bestIndex // 用於儲存每個前綴+後綴組合對應的最大索引\n    → For each word index i in words // 逐一處理每個單字\n        → For pLen from 0 to length(word) // 產生所有可能的前綴長度\n            → prefix = word[0:pLen] // 取得前綴子字串\n            → For sLen from 0 to length(word) // 產生所有可能的後綴長度\n                → suffix = word[length(word)-sLen:] // 取得後綴子字串\n                → key = prefix + \"#\" + suffix // 組合成唯一鍵，使用 '#' 隔離前後綴\n                → bestIndex[key] = i // 儲存或更新為更大的索引 (i 越大則越靠後)\nEnd // 建立完成，結構已準備好\n\nMethod f(pref, suff) // 查詢給定前綴與後綴的最大索引\n    → key = pref + \"#\" + suff // 同樣的鍵組合\n    → Decision: key 是否存在於 bestIndex? // 檢查是否有符合的單字\n        Yes → Return bestIndex[key] // 回傳對應的最大索引\n        No  → Return -1 // 沒有符合的單字，返回 -1\nEnd // 方法結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "License Key Formatting",
      "source_file": "Leetcode/leetcode482.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"5F3Z-2e-9-w\", k = 4",
          "expected_output": " \"5F3Z-2E9W\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe9n0rhhx.py\", line 32, in <module>\n    main()\n  File \"/tmp/tmpe9n0rhhx.py\", line 27, in main\n    k = int(data[1].strip())\n            ~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "s = \"2-5g-3-J\", k = 2",
          "expected_output": "\"2-5G-3J\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpu0aqwblm.py\", line 32, in <module>\n    main()\n  File \"/tmp/tmpu0aqwblm.py\", line 27, in main\n    k = int(data[1].strip())\n            ~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\n\ndef license_key_formatting(S: str, K: int) -> str:\n    \"\"\"把輸入字串重新格式化為每組 K 個字元，首組可能較短。\"\"\"\n    # 移除所有 dashes 並轉成大寫\n    cleaned = S.replace('-', '').upper()\n    n = len(cleaned)\n\n    # 第一組長度：若長度能被 K 整除則為 K，否則為 n % K\n    first_group_len = n % K or K\n\n    # 先把第一組加入結果\n    parts = [cleaned[:first_group_len]]\n\n    # 從第一組後面開始，每 K 個字元為一組\n    for i in range(first_group_len, n, K):\n        parts.append(cleaned[i:i + K])\n\n    # 用 dash 連接各組\n    return '-'.join(parts)\n\ndef main() -> None:\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    s = data[0].strip()\n    k = int(data[1].strip())\n    result = license_key_formatting(s, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanation after //. The user gives problem: reformat license key: given string s (alphanumeric and dashes), remove dashes, uppercase letters, split into groups of k, first group may be shorter but at least 1, join with dashes. Need to produce steps.\n\nWe need to produce virtual code steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Provide start, end, decision, loops, etc. Should reflect algorithm: remove dashes, uppercase, compute length, compute first group length: len % k, if zero then k. Then iterate. Steps.\n\nWe don't output actual code. Just pseudocode steps.\n\nLet's design algorithm:\n\nStart\n→ Step 1: Remove all dashes from s and convert to uppercase → cleaned\n→ Step 2: Let L = length of cleaned\n→ Step 3: If L <= k → return cleaned // Only one group\n→ Step 4: Compute firstGroupLen = L mod k; if 0 then k\n→ Step 5: Initialize result with first group: cleaned[0:firstGroupLen]\n→ Step 6: For i from firstGroupLen to L step k: append '-' + cleaned[i:i+k] to result\n→ End return result\n\nAdd decisions. Let's produce lines.\n\nNeed to include arrows and decision for L <= k, else. Also loop.\n\nWe should also show decisions for each step.\n\nLet's produce.\n\nLine format:\n\nStart // 程式開始執行\n→ Step 1: Remove all dashes and convert to uppercase // 先將輸入字串清理成只有字母數字且大寫\n→ Step 2: Let L = length of cleaned string // 取得清理後字串長度\n→ Decision: L <= k? // 判斷是否只需要一組\n    Yes → Step 3: Return cleaned // 若長度不超過 k，直接回傳\n    No  → Step 4: Compute firstGroupLen = L mod k; if 0 then k // 計算第一組長度\n→ Step 5: result = cleaned[0:firstGroupLen] // 取出第一組\n→ Decision: firstGroupLen < L? // 檢查是否還有剩餘字元\n    Yes → Step 6: i = firstGroupLen\n            → Loop: while i < L\n                → Append '-' + cleaned[i:i+k] to result // 加入後續每 k 個字元為一組\n                → i = i + k\n            → End Loop\n    No  → // 只有第一組，已處理完畢\n→ End // 程式執行結束\n\nBut we need to use arrow for loop etc. Provide each line. The lines inside loop maybe multiple steps. Use arrow and indent.\n\nLet's produce more precise pseudocode lines. Use \"→\" and \"Decision:\".\n\nWe must not output actual code. So no syntax, just description.\n\nWe'll produce each line.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Remove all dashes from s and convert all letters to uppercase // 先將輸入字串清理成只有字母數字且大寫  \n→ Step 2: Let L = length of the cleaned string // 取得清理後字串長度  \n→ Decision: L <= k? // 判斷是否只需要一組  \n  Yes → Step 3: Return the cleaned string // 若長度不超過 k，直接回傳  \n  No  → Step 4: Compute firstGroupLen = L mod k; if firstGroupLen == 0 then firstGroupLen = k // 計算第一組長度  \n→ Step 5: Initialize result = cleaned[0:firstGroupLen] // 取出第一組  \n→ Decision: firstGroupLen < L? // 檢查是否還有剩餘字元  \n  Yes → Step 6: i = firstGroupLen // 先設置索引位置  \n   → Loop: while i < L  \n     → Append '-' + cleaned[i:i+k] to result // 加入後續每 k 個字元為一組  \n     → i = i + k // 移動到下一組的起始位置  \n   → End Loop  \n  No  → // 只有第一組，已處理完畢  \n→ End // 程式執行結束"
    },
    {
      "title": "Find K Pairs with Smallest Sums",
      "source_file": "Leetcode/leetcode373.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp24unyghe.py\", line 44, in <module>\n    main()\n  File \"/tmp/tmp24unyghe.py\", line 34, in main\n    nums1 = eval(val)\n            ^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4f1790tg.py\", line 44, in <module>\n    main()\n  File \"/tmp/tmp4f1790tg.py\", line 34, in main\n    nums1 = eval(val)\n            ^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import heapq\nimport sys\n\nclass Solution:\n    def kSmallestPairs(self, nums1, nums2, k):\n        if not nums1 or not nums2 or k <= 0:\n            return []\n        heap = []\n        res = []\n        # 初始化堆：將前 k 個 nums1 的元素與 nums2[0] 的對加入堆\n        for i in range(min(k, len(nums1))):\n            heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n        # 主循環：取最小和，並將其右、下鄰加入堆\n        while heap and len(res) < k:\n            sum_val, i, j = heapq.heappop(heap)\n            res.append([nums1[i], nums2[j]])\n            if j + 1 < len(nums2):\n                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums1, nums2, k = [], [], 0\n    # 解析輸入：格式類似 \"nums1 = [1,7,11], nums2 = [2,4,6], k = 3\"\n    for part in data.split(','):\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        if key == 'nums1':\n            nums1 = eval(val)\n        elif key == 'nums2':\n            nums2 = eval(val)\n        elif key == 'k':\n            k = int(val)\n    solution = Solution()\n    result = solution.kSmallestPairs(nums1, nums2, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code (not real code) for algorithm: find k smallest sum pairs from two sorted arrays. Classic using min-heap. Steps: start, push first pair (0,0) sum into heap, maintain visited set. While result length < k and heap not empty: pop smallest, add pair to result, then push next pairs (i+1,j) and (i,j+1) if not visited. Ensure not duplicate. Use heap store sum, i, j. Complexity.\n\nWe need to produce lines like \"Start // ...\". Each line with \"虛擬碼步驟 // 解釋\". Use arrows etc. We'll produce pseudocode lines.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 min-heap H, visited set V, result list R // 建立最小堆、已訪問集合與結果容器\n→ Step 2: 若 nums1 或 nums2 為空，返回空結果 // 防止空陣列\n→ Step 3: 進入循環：當 len(R) < k 且 H 非空時 // 主要循環\n   → Decision: 是否已將初始索引 (0,0) 插入 H？ // 檢查是否已加入第一個對\n      Yes → 進入下一步\n      No  → H ← push(sum=nums1[0]+nums2[0], i=0, j=0); V ← add((0,0)) // 把第一個對加入堆\n   → Step 4: pop 最小元素 (s,i,j) 從 H // 取出當前最小和\n   → Step 5: R ← append((nums1[i], nums2[j])) // 加入結果\n   → Decision: i+1 < len(nums1) 且 (i+1,j) 未在 V? // 檢查右鄰是否可加入\n      Yes → H ← push(sum=nums1[i+1]+nums2[j], i+1, j); V ← add((i+1,j))\n      No  → 無操作\n   → Decision: j+1 < len(nums2) 且 (i,j+1) 未在 V? // 檢查下鄰是否可加入\n      Yes → H ← push(sum=nums1[i]+nums2[j+1], i, j+1); V ← add((i,j+1))\n      No  → 無操作\nEnd // 程式執行結束\n\nBut need arrow lines for each step. Use \"→\" for step lines. Use \"Decision:\" lines for branching.\n\nAlso need each line as \"虛擬碼步驟 [space] // 解釋\". Use \"Start\" etc. Use arrows.\n\nBetter to create more structured pseudo:\n\nStart // 程式開始執行\n→ Step 1: Initialize H, V, R // 初始化最小堆、訪問集合與結果列表\n→ Decision: nums1 为空或 nums2 为空? // 檢查輸入是否有效\n    Yes → Return R // 直接返回空結果\n    No  → Continue\n→ Step 2: Push initial pair (0,0) into H, mark visited // 將第一個對加入堆\n→ Step 3: While len(R) < k and H 非空 循環開始 // 主循環\n    → Step 3.1: Pop (s,i,j) from H // 取出最小和\n    → Step 3.2: Append (nums1[i], nums2[j]) to R // 將對加入結果\n    → Decision: i+1 < len(nums1) 且 (i+1,j) 未訪問? // 檢查右鄰\n        Yes → Push (nums1[i+1]+nums2[j], i+1, j) into H, mark visited\n        No  → 無操作\n    → Decision: j+1 < len(nums2) 且 (i,j+1) 未訪問? // 檢查下鄰\n        Yes → Push (nums1[i]+nums2[j+1], i, j+1) into H, mark visited\n        No  → 無操作\nEnd // 程式執行結束\n\nBut need to use arrow indentation maybe. Use \"→\" for lines and \"Decision:\" for decisions. Provide explanation for each. Use \"Yes →\" and \"No →\".\n\nAlso note we need to keep lines separate for each step. For decision branches we may indent.\n\nWe need to output exactly as format: each line: \"虛擬碼步驟 // 解釋\".\n\nLet's craft final answer.\n\nEnsure we include the Start and End. Use \"→\" for steps, \"Decision:\" for decisions. For each branch we add \"Yes →\" and \"No →\".\n\nLet's produce.\n\nAlso we need to mention the heap and visited logic. Also mention that H is a min-heap sorted by sum. Use \"push\" \"pop\".\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化最小堆 H、已訪問集合 V 與結果列表 R // 用於存儲候選對、已訪索引、最終答案\n→ Decision: nums1 为空或 nums2 为空? // 檢查輸入是否有效\n    Yes → Step 2: 返回 R // 若有空陣列直接返回空結果\n    No  → Continue // 有效數組才繼續\n→ Step 3: 將索引 (0,0) 的對加入 H 並標記為已訪問 // 開始從第一個最小和入手\n    → Push (sum = nums1[0] + nums2[0], i=0, j=0) into H\n    → Add (0,0) to V\n→ Step 4: 開始主循環：While len(R) < k 且 H 非空 // 循環直到得到 k 個對或無候選\n    → Step 4.1: Pop 最小元素 (s,i,j) 從 H // 取得當前最小和\n    → Step 4.2: Append (nums1[i], nums2[j]) 到 R // 把對加入結果\n    → Decision: i+1 < len(nums1) 且 (i+1,j) 未在 V? // 檢查右鄰是否可加入\n        Yes → Push (sum=nums1[i+1]+nums2[j], i+1, j) into H\n        No  → 無操作\n    → Decision: j+1 < len(nums2) 且 (i,j+1) 未在 V? // 檢查下鄰是否可加入\n        Yes → Push (sum=nums1[i]+nums2[j+1], i, j+1) into H\n        No  → 無操作\nEnd // 程式執行結束\n\nBut note the decision branch lines need to be \"Decision:\" lines not \"→\". Format requires \"Decision:\" lines and \"Yes →\" \"No →\". Example in prompt: \"Decision: 如果數字大於 0?\" then \"Yes →\" etc.\n\nSo we must produce exactly that style.\n\nLet's adjust:\n\nStart // 程式開始執行\n→ Step 1: 初始化最小堆 H、已訪問集合 V 與結果列表 R // 用於存儲候選對、已訪索引、最終答案\n→ Decision: nums1 为空或 nums2 为空? // 檢查輸入是否有效\n    Yes → Step 2: 返回 R // 若有空陣列直接返回空結果\n    No  → Continue // 有效數組才繼續\n→ Step 3: 將索引 (0,0) 的對加入 H 並標記為已訪問 // 開始從第一個最小和入手\n    → Push (sum = nums1[0] + nums2[0], i=0, j=0) into H\n    → Add (0,0) to V\n→ Step 4: 開始主循環：While len(R) < k 且 H 非空 // 循環直到得到 k 個對或無候選\n    → Step 4.1: Pop 最小元素 (s,i,j) 從 H // 取得當前最小和\n    → Step 4.2: Append (nums1[i], nums2[j]) 到 R // 把對加入結果\n    → Decision: i+1 < len(nums1) 且 (i+1,j) 未在 V? // 檢查右鄰是否可加入\n        Yes → Push (sum=nums1[i+1]+nums2[j], i+1, j) into H\n        No  → 無操作\n    → Decision: j+1 < len(nums2) 且 (i,j+1) 未在 V? // 檢查下鄰是否可加入\n        Yes → Push (sum=nums1[i]+nums2[j+1], i, j+1) into H\n        No  → 無操作\nEnd // 程式執行結束\n\nBut \"Step 2: 返回 R\" maybe no \"Continue\". Instead we can just \"Return R\" as a step. And if No -> we go to Step 3. Use \"→\" but the prompt example uses \"Decision:\" and then \"Yes →\" etc. For non-decision branches, we use \"→\". Let's restructure.\n\nWe need to keep each line as \"虛擬碼步驟 // 解釋\". For decisions, we include \"Decision:\" line, then indent \"Yes →\" and \"No →\". Each of those lines must end with \"// explanation\".\n\nSo we need to format accordingly.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化最小堆 H、已訪問集合 V 與結果列表 R // 用於存儲候選對、已訪索引、最終答案  \n→ Decision: nums1 为空或 nums2 为空? // 檢查輸入是否有效  \n Yes → Step 2: 返回 R // 若有空陣列直接返回空結果  \n No  → Step 3: 將索引 (0,0) 的對加入 H 並標記為已訪問 // 開始從第一個最小和入手  \n  → Push (sum = nums1[0] + nums2[0], i=0, j=0) into H  \n  → Add (0,0) to V  \n→ Step 4: 開始主循環：While len(R) < k 且 H 非空 // 循環直到得到 k 個對或無候選  \n  → Step 4.1: Pop 最小元素 (s,i,j) 從 H // 取得當前最小和  \n  → Step 4.2: Append (nums1[i], nums2[j]) 到 R // 把對加入結果  \n  → Decision: i+1 < len(nums1) 且 (i+1,j) 未在 V? // 檢查右鄰是否可加入  \n   Yes → Push (sum=nums1[i+1]+nums2[j], i+1, j) into H // 加入右鄰  \n   No  → // 無操作  \n  → Decision: j+1 < len(nums2) 且 (i,j+1) 未在 V? // 檢查下鄰是否可加入  \n   Yes → Push (sum=nums1[i]+nums2[j+1], i, j+1) into H // 加入下鄰  \n   No  → // 無操作  \nEnd // 程式執行結束"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzctk1v44.py\", line 73, in <module>\n    main()\n  File \"/tmp/tmpzctk1v44.py\", line 46, in main\n    args = ast.literal_eval(right)   # 例如 [[],[1],[2],[]]\n           ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[],[-2],[0],[-3],[],[],[],[]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MinStack:\n    \"\"\"保持兩個堆疊，主堆疊和最小值堆疊，均支持 O(1) 操作。\"\"\"\n    def __init__(self):\n        self.stack = []      # 主堆疊，存放所有進入的元素\n        self.min_stack = []  # 最小值堆疊，存放目前的最小元素\n\n    def push(self, val: int) -> None:\n        \"\"\"把 val 推入主堆疊，同時若它是新的最小值，也推入最小堆疊。\"\"\"\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        \"\"\"把主堆疊頂部元素彈出；若該元素同時是最小值，亦從最小堆疊彈出。\"\"\"\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        if self.min_stack and val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self) -> int:\n        \"\"\"返回主堆疊頂部元素。\"\"\"\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -> int:\n        \"\"\"返回目前最小值。\"\"\"\n        return self.min_stack[-1] if self.min_stack else None\n\ndef main() -> None:\n    \"\"\"主函式，從標準輸入讀取操作序列與參數，執行 MinStack 操作並輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入分成兩個部分：操作序列和參數序列\n    # 輸入格式示例：[\"MinStack\",\"push\",\"push\"],[[],[1],[2]]\n    left, right = data.split('],', 1)\n    left = left + ']'\n    right = '[' + right\n\n    ops = ast.literal_eval(left)     # 例如 [\"MinStack\",\"push\",\"push\",\"getMin\"]\n    args = ast.literal_eval(right)   # 例如 [[],[1],[2],[]]\n\n    res = []\n    stack = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MinStack\":\n            stack = MinStack()\n            res.append(None)\n        elif op == \"push\":\n            stack.push(arg[0])\n            res.append(None)\n        elif op == \"pop\":\n            stack.pop()\n            res.append(None)\n        elif op == \"top\":\n            res.append(stack.top())\n        elif op == \"getMin\":\n            res.append(stack.getMin())\n        else:\n            # 未知操作，忽略\n            res.append(None)\n\n    # 使用 json.dumps 直接將 None 轉成 null，符合題目輸出格式\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation for MinStack class. We must not output real code, only pseudocode lines with arrows. We need to cover initialization, push, pop, top, getMin. Use two stacks or one with pair. Provide logic.\n\nWe need \"Start\" and \"End\". Use \"Decision:\" where needed.\n\nLet's outline:\n\nStart\n→ Step 1: 初始化兩個空堆疊 mainStack, minStack // mainStack儲存所有元素, minStack儲存目前最小值\n→ Step 2: 定義方法 push(val)\n    → Step 3: push val到 mainStack // 將元素加入主堆疊\n    → Decision: 若 minStack 為空 或 val <= minStack.top()\n        Yes → Step 4: push val到 minStack // 更新最小堆疊\n        No  → // 不更新\n→ Step 5: 定義方法 pop()\n    → Step 6: val = mainStack.pop() // 移除主堆疊頂部\n    → Decision: 若 val == minStack.top()\n        Yes → Step 7: minStack.pop() // 若被移除元素為目前最小值，也從 minStack 移除\n        No  → // 不做\n→ Step 8: 定義方法 top()\n    → Step 9: return mainStack.top() // 回傳主堆疊頂部\n→ Step 10: 定義方法 getMin()\n    → Step 11: return minStack.top() // 回傳最小堆疊頂部\nEnd\n\nMake sure each line has virtual code and explanation. Use arrow \"→\". For decisions use \"Decision:\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個空堆疊 mainStack, minStack // mainStack 儲存所有元素，minStack 儲存目前最小值  \n→ Step 2: 定義方法 push(val) // 開始實作 push 功能  \n  → Step 3: mainStack.push(val) // 把 val 推入主堆疊  \n  → Decision: 若 minStack 為空 或 val <= minStack.top()? // 判斷是否需要更新最小堆疊  \n   Yes → Step 4: minStack.push(val) // val 為新最小值，推入最小堆疊  \n   No  → // 不做任何事，保持最小堆疊不變  \n→ Step 5: 定義方法 pop() // 開始實作 pop 功能  \n  → Step 6: val = mainStack.pop() // 移除並取得主堆疊頂部元素  \n  → Decision: 若 val == minStack.top()? // 判斷被移除元素是否為目前最小值  \n   Yes → Step 7: minStack.pop() // 同時從最小堆疊移除，維持正確最小值  \n   No  → // 不做任何事  \n→ Step 8: 定義方法 top() // 開始實作 top 功能  \n  → Step 9: return mainStack.top() // 回傳主堆疊頂部元素  \n→ Step 10: 定義方法 getMin() // 開始實作 getMin 功能  \n  → Step 11: return minStack.top() // 回傳最小堆疊頂部元素，即目前最小值  \nEnd // 程式執行結束"
    },
    {
      "title": "Maximum Average Subarray I",
      "source_file": "Leetcode/leetcode643.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,12,-5,-6,50,3], k = 4",
          "expected_output": "12.75000",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpntegn7p4.py\", line 28, in <module>\n    main()\n  File \"/tmp/tmpntegn7p4.py\", line 21, in main\n    nums, k = eval(data)\n              ^^^^^^^^^^\n  File \"<string>\", line 1\n    nums = [1,12,-5,-6,50,3], k = 4\n         ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "nums = [5], k = 1",
          "expected_output": "5.00000",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9qdo8j0e.py\", line 28, in <module>\n    main()\n  File \"/tmp/tmp9qdo8j0e.py\", line 21, in main\n    nums, k = eval(data)\n              ^^^^^^^^^^\n  File \"<string>\", line 1\n    nums = [5], k = 1\n         ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findMaxAverage(self, nums, k):\n        # 初始窗口總和\n        window_sum = sum(nums[:k])\n        max_sum = window_sum\n        # 滑動窗口計算最大總和\n        for i in range(k, len(nums)):\n            window_sum += nums[i] - nums[i - k]\n            if window_sum > max_sum:\n                max_sum = window_sum\n        # 轉換為平均值\n        return max_sum / k\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，格式如：'nums = [1,12,-5,-6,50,3], k = 4'\n    nums, k = eval(data)\n    sol = Solution()\n    result = sol.findMaxAverage(nums, k)\n    # 輸出五位小數\n    print(f\"{result:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: find subarray of length k with max average. Standard sliding window. Steps: compute initial sum of first k. maxAvg = sum/k. then slide. For i from k to n-1: sum += nums[i] - nums[i-k]; avg=sum/k; if avg > maxAvg: maxAvg=avg. After loop, return maxAvg. In virtual code, use Start, End, Decision. Provide line by line with explanation comments. Should not output actual code but pseudocode lines.\n\nLet's produce steps. Also include array indexing etc. Provide arrow, etc. Use Decision for comparisons.\n\nAlso we need to include Step lines with arrow.\n\nLet's produce:\n\nStart\n→ Step 1: 獲取 nums 長度 n\n→ Step 2: 初始化 sum = 0\n→ Step 3: For i from 0 to k-1: sum += nums[i] // 計算前 k 個元素總和\n→ Step 4: maxAvg = sum / k // 計算初始平均值\n→ Decision: 是否還有更多元素? (i < n) // 判斷是否需要滑動窗口\n    Yes → Step 5: i = k // 設定滑動起點\n    No  → End // 如果 k == n，直接返回 maxAvg\n→ While i < n: // 進行滑動窗口\n    → Step 6: sum = sum + nums[i] - nums[i - k] // 移除左邊元素，加入右邊元素\n    → Step 7: currentAvg = sum / k // 計算當前窗口平均\n    → Decision: currentAvg > maxAvg? // 判斷是否更新最大平均\n        Yes → Step 8: maxAvg = currentAvg // 更新最大平均\n        No  → No change\n    → Step 9: i = i + 1 // 移動到下一個位置\n→ End // 返回 maxAvg\n\nBut need each line includes explanation after //. Ensure arrow and indentation.\n\nWe also need Step 3's for loop maybe not fully expanded. Maybe we can use a loop.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: n = length(nums) // 取得陣列長度\n→ Step 2: sum = 0 // 初始化滑動窗口總和\n→ Step 3: For idx = 0 to k-1: sum += nums[idx] // 先計算前 k 個元素的總和\n→ Step 4: maxAvg = sum / k // 計算初始平均值\n→ Decision: 是否還有剩餘元素? (k < n) // 判斷是否需要滑動窗口\n    Yes → Step 5: idx = k // 設定滑動起始位置\n    No  → End // k == n 時直接返回 maxAvg\n→ While idx < n: // 循環滑動窗口\n    → Step 6: sum = sum + nums[idx] - nums[idx - k] // 移除左端元素並加入右端元素\n    → Step 7: currentAvg = sum / k // 計算當前窗口平均\n    → Decision: currentAvg > maxAvg? // 比較是否為新的最大平均\n        Yes → Step 8: maxAvg = currentAvg // 更新最大平均\n        No  → No change\n    → Step 9: idx = idx + 1 // 前進到下一個位置\n→ End // 程式執行結束，返回 maxAvg\n\nCheck formatting: each line with arrow or decision. Use \"→\" before Step lines. For decision block, indent lines with arrow after spaces. Provide explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = length(nums) // 取得陣列長度  \n→ Step 2: sum = 0 // 初始化滑動窗口總和  \n→ Step 3: For idx = 0 to k-1: sum += nums[idx] // 計算前 k 個元素的總和  \n→ Step 4: maxAvg = sum / k // 計算初始平均值  \n→ Decision: k < n? // 判斷是否需要滑動窗口  \n  Yes → Step 5: idx = k // 設定滑動起始位置  \n  No  → End // k 等於 n 時直接返回 maxAvg  \n→ While idx < n: // 進行滑動窗口  \n  → Step 6: sum = sum + nums[idx] - nums[idx - k] // 移除左端元素並加入右端元素  \n  → Step 7: currentAvg = sum / k // 計算當前窗口平均  \n  → Decision: currentAvg > maxAvg? // 比較是否為新的最大平均  \n    Yes → Step 8: maxAvg = currentAvg // 更新最大平均  \n    No  → No change // 保持原值  \n  → Step 9: idx = idx + 1 // 前進到下一個位置  \n→ End // 程式執行結束，返回 maxAvg"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[1,2,2],[2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[1, 2, 2], [2, 2]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[0]]'\nGot (Norm):      '[[0]]'\n--- (Raw) ---\nRaw Expected: '[[],[0]]'\nRaw Got:      '[[0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        Generate all unique subsets of nums which may contain duplicates.\n        The algorithm sorts the array and uses backtracking while skipping\n        duplicate starting positions to avoid generating identical subsets.\n        \"\"\"\n        nums.sort()                     # Sort to bring equal elements together\n        res = []\n\n        def backtrack(start, path):\n            # When we have considered all elements, add current subset\n            if start == len(nums):\n                res.append(path.copy())\n                return\n            prev = None\n            for i in range(start, len(nums)):\n                # Skip duplicate elements at the same recursion depth\n                if prev is not None and nums[i] == prev:\n                    continue\n                prev = nums[i]\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    # Read the entire stdin, expecting a line like: nums = [1,2,2]\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Extract the list expression after '=' if present\n    if '=' in raw_input:\n        _, expr = raw_input.split('=', 1)\n    else:\n        expr = raw_input\n    expr = expr.strip()\n\n    # Safely evaluate the list expression\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception as e:\n        raise ValueError(f\"Invalid input format: {expr}\") from e\n\n    # Ensure we have a list of integers\n    if not isinstance(nums, list):\n        raise ValueError(\"Input must be a list of integers\")\n\n    solution = Solution()\n    subsets = solution.subsetsWithDup(nums)\n    print(subsets)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines describing algorithm to generate all subsets of an integer array that may contain duplicates, ensuring no duplicate subsets. Standard approach: sort array, backtracking with skip duplicates when iterating over indices. Virtual code lines with arrows etc.\n\nWe need each line: virtual code step + space + // explanation. Must use arrow symbols and Decision etc.\n\nWe should produce a structured algorithm. Use Start, End, Decision. Use \"→\" for steps. For loops maybe represented as Decision or Step with loop. Keep each step on one line. Use indentation maybe with spaces? The example shows indentation for nested decisions. We can mimic.\n\nSo structure:\n\nStart\n→ Step 1: Sort nums ascending // to group duplicates\n→ Step 2: Initialize result list with empty subset // start with base case\n→ Step 3: Define recursive backtrack function(index, path) // recursion helper\n    → Decision: If index == length(nums) ?\n        Yes → Add copy of path to result // add current subset\n        No  → Decision: If we include nums[index] ?\n            Yes → backtrack(index+1, path + nums[index]) // include current element\n            No  → backtrack(index+1, path) // exclude current element\n            // But need to skip duplicates: if next duplicate skip\n            // Actually modify loop: iterate i from index to n-1:\nWe can use iterative loop: For i from index to n-1:\n    If i > index and nums[i]==nums[i-1] → continue // skip duplicate\n    Append nums[i] to path\n    backtrack(i+1, path)\n    pop from path\nBut need virtual code step per line.\n\nLet's craft step-by-step.\n\nStart\n→ Step 1: Sort nums ascending // group duplicates\n→ Step 2: result ← [ [] ] // initial subset\n→ Step 3: Define backtrack(start, current) // helper function\n    → Decision: If start == length(nums) ?\n        Yes → result ← result ∪ [current] // add subset\n        No  → Decision: iterate i from start to length(nums)-1 ?\n            Yes → Decision: If i > start AND nums[i] == nums[i-1] ?\n                Yes → Continue // skip duplicate starting positions\n                No  → \n                    Append nums[i] to current // include element\n                    → backtrack(i+1, current) // recurse\n                    → Remove last element from current // backtrack\n        // End loop\n→ End // finished\n\nBut each step must be separate line. Need to represent recursion and loop. Might be simpler to describe iterative DFS with stack? But recursion easier.\n\nWe must maintain \"虛擬碼步驟\" plus explanation each line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 先排序以便處理重複元素\n→ Step 2: result ← [ [] ] // 初始化結果集合，先加入空集合\n→ Step 3: Define Function backtrack(start, current) // 定義遞迴輔助函式\n    → Decision: 如果 start == length(nums) ?\n        Yes → result ← result ∪ [current] // 把目前的子集加入結果\n        No  → \n            → Step 4: For i = start to length(nums)-1 // 從 start 開始嘗試每個元素\n                → Decision: 如果 i > start AND nums[i] == nums[i-1] ?\n                    Yes → Continue // 跳過重複的起始元素\n                    No  → \n                        → Step 5: Append nums[i] to current // 加入當前元素\n                        → backtrack(i+1, current) // 進行下一層遞迴\n                        → Step 6: Remove last element from current // 回溯\n→ End // 程式執行結束\n\nBut need to ensure each line follows \"虛擬碼步驟 // 解釋\". For decision lines, use \"Decision:\" etc. Example shows indentation with spaces. Let's follow similar format:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 先排序以便處理重複元素\n→ Step 2: result ← [ [] ] // 初始化結果集合，先加入空集合\n→ Step 3: Define Function backtrack(start, current) // 定義遞迴輔助函式\n    → Decision: start == length(nums) ? // 檢查是否已遍歷完所有元素\n        Yes → result ← result ∪ [current] // 把目前子集加入結果\n        No  → \n            → Step 4: For i = start to length(nums)-1 // 依次嘗試每個剩餘元素\n                → Decision: i > start AND nums[i] == nums[i-1] ? // 判斷是否為重複起點\n                    Yes → Continue // 跳過重複的起點\n                    No  → \n                        → Step 5: Append nums[i] to current // 加入元素\n                        → backtrack(i+1, current) // 進一步遞迴\n                        → Step 6: Remove last element from current // 回溯\n→ End // 程式執行結束\n\nWe must ensure each step line includes \"→\" before it. For decisions we also use arrow before \"Decision:\" lines.\n\nWe need to include \"Start\" and \"End\". \"Step\" lines start with \"→ Step\". Decision lines start with \"→ Decision\". Indent nested lines accordingly.\n\nMake sure each line includes space between virtual code and explanation.\n\nAlso include arrow for each line maybe? In example, for nested lines they have indent spaces then \"Yes →\" etc. So we will mimic.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先排序以便處理重複元素  \n→ Step 2: result ← [ [] ] // 初始化結果集合，先加入空集合  \n→ Step 3: Define Function backtrack(start, current) // 定義遞迴輔助函式  \n    → Decision: start == length(nums) ? // 檢查是否已遍歷完所有元素  \n        Yes → result ← result ∪ [current] // 把目前子集加入結果  \n        No  →  \n            → Step 4: For i = start to length(nums)-1 // 依次嘗試每個剩餘元素  \n                → Decision: i > start AND nums[i] == nums[i-1] ? // 判斷是否為重複起點  \n                    Yes → Continue // 跳過重複的起點  \n                    No  →  \n                        → Step 5: Append nums[i] to current // 加入元素  \n                        → backtrack(i+1, current) // 進一步遞迴  \n                        → Step 6: Remove last element from current // 回溯  \n→ End // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[None,3,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[None, 3, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nrandom.seed(0)  # 確保測試結果可重現\n\nclass Solution:\n    def __init__(self, nums):\n        # 存儲原始數組\n        self.nums = nums\n\n    def pick(self, target):\n        \"\"\"\n        隨機選擇 nums 中所有等於 target 的索引，並保持每個索引\n        的選中機率相等（即 1 / count_of_target）。\n        \"\"\"\n        count = 0          # 目前已經遇到 target 的個數\n        result = -1        # 最終選中的索引\n        for i, num in enumerate(self.nums):\n            if num == target:\n                count += 1\n                # 每遇到一次 target，就以 1/count 的機率更新 result\n                if random.randint(1, count) == count:\n                    result = i\n        return result\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，示例格式為\n    # '[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]'\n    # 先找到第一個閉括號的位置，將兩個列表分開\n    first_bracket = data.find(']')\n    cmds_str = data[:first_bracket + 1]\n    args_str = data[first_bracket + 2:].strip()  # 跳過 '],'\n\n    # 使用 ast.literal_eval 進行安全解析\n    cmds = ast.literal_eval(cmds_str)\n    args = ast.literal_eval(args_str)\n\n    outputs = []\n    sol = None\n    for cmd, arg in zip(cmds, args):\n        if cmd == \"Solution\":\n            sol = Solution(*arg)  # arg 是一個列表，解包成參數\n            outputs.append(None)\n        else:\n            method = getattr(sol, cmd)\n            outputs.append(method(*arg))\n    print(outputs)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described problem, step by step, with explanations, using arrow notation and decisions, etc.\n\nWe need to design a solution class with constructor and pick method.\n\nWe need to choose algorithm: Since duplicates allowed, but we can use reservoir sampling (random selection with equal probability). For pick method: iterate through array, count occurrences, use random selection: for each index i where nums[i]==target, increment count, generate random number in [1,count], if equals count, select i.\n\nWe also need to handle initialization: store array reference.\n\nSo virtual code steps: Start, Step 1: store array, etc. Provide pick method: input target, initialize count=0, result=-1; iterate i from 0 to length-1: if nums[i]==target: count++; if random() <= 1/count: result=i; return result.\n\nNeed to show random selection: random integer in [1,count] or random float.\n\nWe'll write pseudocode with steps: \"Initialize count to 0\" etc.\n\nMake sure each line is separate: \"Start\", \"→ Step 1\" etc.\n\nAlso need to explain each line. Use \"Decision:\" only for conditions.\n\nWe need to produce output in the required format, all in Chinese (繁體). Provide comments after each line.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Solution(nums) → Store the input array `nums` in an instance variable `self.nums` // 初始化物件，保存數組供之後使用  \n→ Step 2: End // 結束建構子初始化  \n\nStart // 程式開始執行  \n→ Step 3: pick(target) // 方法入口，輸入目標值 `target`  \n→ Step 4: Initialize `count` to 0 // 用於記錄已遇到的目標值個數  \n→ Step 5: Initialize `result` to -1 // 存儲最終選中的索引，初始值 -1  \n→ Step 6: For each index `i` from 0 to length of `self.nums` - 1 // 遍歷整個數組  \n    → Decision: 如果 self.nums[i] == target? // 判斷當前元素是否為目標  \n        Yes → Step 7: Increment `count` by 1 // 已找到一個目標，統計總數  \n        Yes → Step 8: Generate a random integer `r` in [1, `count`] // 隨機數決定是否選中  \n        Yes → Decision: 如果 r == `count`? // 檢查是否恰好是最後一個位置  \n            Yes → Step 9: Set `result` to `i` // 選中當前索引  \n        No → Step 10: Continue // 不是選中，繼續遍歷  \n    No → Step 11: Continue // 當前元素不是目標，跳過  \n→ Step 12: Return `result` // 返回隨機選中的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[0,1],[1,0],[1,0],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[0, 1], [1, 0], [1, 0], [0, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立倒序字典：倒序字 -> 索引\n        rev_dict = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        for i, word in enumerate(words):\n            length = len(word)\n            for j in range(length + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                # 情況1：前綴為回文，後綴倒序存在\n                if prefix in rev_dict and rev_dict[prefix] != i and suffix == suffix[::-1]:\n                    res.append([i, rev_dict[prefix]])\n\n                # 情況2：後綴為回文，前綴倒序存在（避免 j==0 重複）\n                if j != 0 and suffix in rev_dict and rev_dict[suffix] != i and prefix == prefix[::-1]:\n                    res.append([rev_dict[suffix], i])\n\n        # 空字串特殊處理\n        if \"\" in words:\n            empty_idx = words.index(\"\")\n            for i, w in enumerate(words):\n                if i != empty_idx and w == w[::-1]:\n                    res.append([empty_idx, i])\n                    res.append([i, empty_idx])\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data.startswith(\"words\"):\n        data = data[data.find(\"=\")+1:].strip()\n    words = ast.literal_eval(data)\n\n    sol = Solution()\n    ans = sol.palindromePairs(words)\n    print(ans)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step explaining algorithm for palindrome pairs with linear time. Must use Start, End, Decision. Each line: virtual code step + space + // explanation. Need to produce lines for algorithm.\n\nWe need to provide high-level algorithm: Use dictionary of reversed words to index mapping; iterate each word, for each split position, check palindrome prefix/suffix etc. Complexity O(total length). Provide pseudocode.\n\nWe should produce each step line: Start, for each word, etc. Use arrow →.\n\nWe need to keep steps separate. Provide algorithm steps with decision branches.\n\nLet's produce.\n\nNote: Must not output real code; just pseudocode steps.\n\nWe'll produce lines:\n\nStart\n\n→ Build map: reversed_word -> index // Map each word reversed to its index\n\n→ For each word at index i // iterate words\n\n   → For split position from 0 to len(word) // check all splits\n\n        → Decision: substring(0, split) is palindrome? // check prefix palindrome\n\n            Yes → Decision: reversed substring(split) exists in map and map value != i? // if suffix reversed exists\n\n                Yes → Step: Add pair (i, map[rev_suffix]) // store pair\n\n        → Decision: substring(split, end) is palindrome? // check suffix palindrome\n\n            Yes → Decision: reversed substring(0, split) exists and map value != i? // prefix reversed\n\n                Yes → Step: Add pair (map[rev_prefix], i)\n\nAlso handle empty string separately.\n\nFinally End.\n\nNeed to use arrow syntax: → Step 1: ... etc.\n\nLet's produce each line. Use decision lines indent with spaces? We can indent but maintain arrow. Use indentation with spaces.\n\nLet's create lines:\n\nStart // 程式開始執行\n→ Build map: for each word, store reversed(word) → index // 建立單字倒序對應的索引表\n→ For each word at index i // 逐一處理每個單字\n    → For split from 0 to len(word) // 對每個單字嘗試所有分割點\n        → Decision: 前綴 substring(0, split) 是否為回文？ // 檢查前綴是否回文\n            Yes → Decision: 後綴 substring(split) 的倒序是否存在於 map 且索引 ≠ i？ // 檢查後綴倒序是否為另一個單字\n                Yes → Step: 添加 (i, map[rev_suffix]) // 將 (i, j) 加入結果\n        → Decision: 後綴 substring(split, len) 是否為回文？ // 檢查後綴是否回文\n            Yes → Decision: 前綴 substring(0, split) 的倒序是否存在於 map 且索引 ≠ i？ // 檢查前綴倒序是否為另一個單字\n                Yes → Step: 添加 (map[rev_prefix], i) // 將 (j, i) 加入結果\n→ Decision: 是否有空字串在單字表中？ // 檢查是否存在空字串\n    Yes → For each word at index k where word ≠ \"\" // 對每個非空單字\n        → Decision: 該單字本身是否為回文？ // 檢查單字是否回文\n            Yes → Step: 添加 (k, index_of_empty) // (k, empty) 與 (empty, k)\nEnd // 程式執行結束\n\nNeed to ensure lines start with \"→\" for each. Indentation: keep spaces but arrow must align? We can indent lines after decision. Use spaces before arrow but not necessary. Use indentation with 4 spaces before arrow. Let's format.\n\nWe also need to use arrow \"→\" and \"Decision:\" exactly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Build map: for each word, store reversed(word) → index // 建立單字倒序對應的索引表  \n\n→ For each word at index i // 逐一處理每個單字  \n    → For split from 0 to len(word) // 對每個單字嘗試所有分割點  \n        → Decision: 前綴 substring(0, split) 是否為回文？ // 檢查前綴是否回文  \n            Yes → Decision: 後綴 substring(split) 的倒序是否存在於 map 且索引 ≠ i？ // 檢查後綴倒序是否為另一個單字  \n                Yes → Step: 添加 (i, map[rev_suffix]) // 將 (i, j) 加入結果  \n        → Decision: 後綴 substring(split, len) 是否為回文？ // 檢查後綴是否回文  \n            Yes → Decision: 前綴 substring(0, split) 的倒序是否存在於 map 且索引 ≠ i？ // 檢查前綴倒序是否為另一個單字  \n                Yes → Step: 添加 (map[rev_prefix], i) // 將 (j, i) 加入結果  \n\n→ Decision: 是否有空字串在單字表中？ // 檢查是否存在空字串  \n    Yes → For each word at index k where word ≠ \"\" // 對每個非空單字  \n        → Decision: 該單字本身是否為回文？ // 檢查單字是否回文  \n            Yes → Step: 添加 (k, index_of_empty) // (k, empty) 與 (empty, k)  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Lexicographical Numbers",
      "source_file": "Leetcode/leetcode386.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,10,11,12,13,2,3,4,5,6,7,8,9]'\nGot (Norm):      '[1,10,11,12,13,14,15,16,17,18,19,20,21]'\n--- (Raw) ---\nRaw Expected: '[1,10,11,12,13,2,3,4,5,6,7,8,9]'\nRaw Got:      '[1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef lexical_order(n: int):\n    \"\"\"\n    Generate all integers in the range [1, n] sorted lexicographically.\n    This implementation runs in O(n) time and uses O(1) auxiliary space.\n    \"\"\"\n    result = []\n    current = 1\n\n    for _ in range(n):\n        # 1. Append the current number\n        result.append(current)\n\n        # 2. Decide how to move to the next number\n        if current * 10 <= n:\n            # Go deeper to the next level (prefix)\n            current *= 10\n        else:\n            if current % 10 != 9 and current + 1 <= n:\n                # Move to the next sibling at the same level\n                current += 1\n            else:\n                # Ascend until we find a node that is not a '9' at the end,\n                # then move to its next sibling.\n                while current // 10 % 10 == 9:\n                    current //= 10\n                current += 1\n\n    return result\n\ndef main():\n    # Read the entire input; it may contain text like \"n = 13\"\n    data = sys.stdin.read()\n    # Extract the first integer found in the input\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    # Compute the lexicographical order and output the list\n    output = lexical_order(n)\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce pseudo-code step by step. Task: given integer n, return numbers 1..n in lexicographic order. Must run in O(n) time, O(1) space. This is typical \"Lexicographical Numbers\" problem, can use DFS or next number logic: generate sequence using preorder traversal of 1-9 digits. Approach: current = 1; for i in 0 to n-1: output current; if current*10 <= n: current*=10 else: if current%10 !=9 and current+1 <= n: current+=1 else: while (current/10)%10 ==9: current/=10; current+=1. Use loop. We need pseudo code lines with explanation.\n\nWe need to output step by step lines. Use Start, End, Decision, Yes→, No→.\n\nLet's produce code:\n\nStart\n→ Step 1: Initialize current = 1, count = 0 // start from 1\n→ Decision: 是否 count < n? // loop until n numbers\n    Yes → Step 2: Output current // add to result\n    → Step 3: Increment count\n    → Decision: 是否 current*10 <= n? // can go deeper\n        Yes → Step 4: current = current * 10 // move to next prefix\n        No → Decision: 是否 current % 10 != 9 and current + 1 <= n? // can increment\n            Yes → Step 5: current = current + 1 // move to next sibling\n            No → Step 6: while (current / 10) % 10 == 9: current = current / 10 // ascend until not 9\n                 → Step 7: current = current + 1 // move to next\n    → No → (loop back to Decision)\n→ No → End\n\nBut need to ensure we maintain O(1) space: only variables.\n\nLet's structure properly with indent.\n\nUse arrows for transitions.\n\nAlso we should show each line with explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: current ← 1, count ← 0 // 設定起始數字為 1，計數器為 0  \n→ Decision: count < n? // 是否還未輸出 n 個數字？  \n    Yes → Step 2: Output current // 將 current 加入結果序列  \n    → Step 3: count ← count + 1 // 已輸出一個數字，計數遞增  \n    → Decision: current × 10 ≤ n? // 是否可以進一步往下深度優先（前綴）？  \n        Yes → Step 4: current ← current × 10 // 前進到下一層的第一個子節點  \n        No → Decision: current mod 10 ≠ 9 ∧ current + 1 ≤ n? // 能否向右移動到同一層的下一個兄弟節點？  \n            Yes → Step 5: current ← current + 1 // 直接遞增到兄弟節點  \n            No → Step 6: While (current ÷ 10) mod 10 = 9 do current ← current ÷ 10 // 往上回溯直到不是 9 的節點  \n                 → Step 7: current ← current + 1 // 在回溯後遞增到下一個兄弟節點  \n    → No → （回到 Decision: count < n?）  \n→ No → End // 所有 n 個數字已輸出，程式結束。"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\n\ndef find_lus_length(strs):\n    \"\"\"\n    找出最長不常見子序列的長度。\n    若不存在，回傳 -1。\n    \"\"\"\n    freq = {}\n    # 計算每個字串的出現次數\n    for s in strs:\n        freq[s] = freq.get(s, 0) + 1\n\n    longest = -1\n    # 只要字串唯一，長度就是候選答案\n    for s, count in freq.items():\n        if count == 1:\n            longest = max(longest, len(s))\n    return longest\n\ndef main():\n    \"\"\"\n    主程式入口：\n    1. 從標準輸入讀取整個內容。\n    2. 解析成字串陣列。\n    3. 計算並輸出最長不常見子序列長度。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 期望輸入為 JSON 格式的字串陣列\n    try:\n        strs = json.loads(data)\n    except json.JSONDecodeError:\n        # 若解析失敗，直接結束\n        return\n    result = find_lus_length(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: longest uncommon subsequence among an array of strings. The known solution: if any string is unique (not duplicate), then answer is its length; else -1. Because LUS (Longest Uncommon Subsequence) only possible if a string is unique, else cannot be subsequence of another identical string. The longest uncommon subsequence length equals the maximum length among unique strings. So algorithm: count frequencies; find unique strings; if any, answer max length; else -1. So produce pseudocode accordingly, with decision steps. Use arrows. Each line: virtual step and comment. Include Start, End. Provide decision nodes. Let's craft.\n\nWe must not output real code, just virtual code steps. Use the format. We'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化字串頻率表 // 建立空頻率字典\n\nBut we need to use virtual code arrow for each step, as per sample: \"→ Step 1: ...\". We may include Decision blocks. Each step line ends with comment.\n\nLet's produce.\n\nWe need to produce each line with explanation. Provide the algorithm.\n\nWe must not output actual code. Provide virtual code step lines.\n\nLet's craft.\n\nAlso we should include input reading: array strs. We can start with \"→ Step 1: 輸入字串陣列 strs // 取得輸入的字串集合\".\n\nThen \"→ Step 2: 建立頻率表 freq // 計算每個字串出現次數\".\n\nThen \"→ Step 3: 初始化 longest = -1 // 預設答案為 -1\".\n\nThen \"→ Step 4: 遍歷 freq 中每個字串 s\" with Decision: If freq[s] == 1? then \"Yes → Update longest = max(longest, len(s))\". Then after loop, \"→ Step 5: 回傳 longest // 輸出結果\".\n\nAdd Start, End.\n\nLet's produce the lines accordingly. Use \"Decision:\" block lines indent.\n\nEnsure each line ends with comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串陣列 strs // 取得使用者輸入的字串集合  \n→ Step 2: 建立頻率表 freq // 建立一個映射，計算每個字串在 strs 中出現的次數  \n→ Step 3: 初始化 longest = -1 // 預設最長不常見子序列長度為 -1（若無解時返回）  \n→ Step 4: 遍歷 freq 中的每個鍵值對 (str, count) // 檢查每個字串的出現次數  \n    Decision: 如果 count 等於 1? // 只要字串唯一，就可能是最長不常見子序列  \n        Yes → Step 5: 更新 longest = max(longest, len(str)) // 將長度較大的唯一字串長度記錄下來  \n        No  → Step 5: 跳過此字串 // 重複字串不可能是不常見子序列  \n→ Step 6: 回傳 longest // 將最終結果輸出（若無唯一字串則為 -1）  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        產生所有排列的回溯實作\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                # 當 start 達到陣列長度，已形成完整排列\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                # 交換並進行下一層回溯\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                # 回朔，恢復原始順序\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入格式：nums = [1,2,3]\n    # 找到等號右側並安全評估為 Python 資料結構\n    try:\n        _, expr = data.split('=', 1)\n        nums = ast.literal_eval(expr.strip())\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    # 呼叫解題方法並輸出結果\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanations. Must use virtual code with arrow and decision, start, end. So algorithm: backtracking to generate permutations. Steps: Start, define result array, define helper function backtrack(curr, remaining). If remaining empty push curr to result. Else iterate over remaining, choose element, recuse, backtrack. End, return result. Provide explanation per line. Use virtual code format: each line: step + // explanation.\n\nNeed to include arrows: e.g. → Step 1: ... So each line may start with arrow or indentation. For decision steps use Decision: If ... and Yes →, No →. We'll generate algorithm steps. Ensure no actual code.\n\nLet's create:\n\nStart\n→ Step 1: Define empty result list // 用來存儲所有排列\n→ Step 2: Define helper function backtrack(currentPermutation, remainingElements) // 回溯核心函式\n→ Decision: 是否 remainingElements 為空? // 判斷是否已排列完\n    Yes → Step 3: 將 currentPermutation 複製並加入 result // 完整排列已生成\n    No  → Step 4: 循環遍歷 remainingElements // 依次選擇下一個元素\n        → Step 5: 取出 element 並更新 newRemaining = remainingElements 去掉 element // 準備下一層\n        → Step 6: newPermutation = currentPermutation 加上 element // 新的排列進度\n        → Step 7: 呼叫 backtrack(newPermutation, newRemaining) // 深入下一層\n        → Step 8: 回到循環，繼續處理下一個 element // 完成一次回溯\n→ Step 9: 呼叫 backtrack(空, nums) // 從空排列開始\n→ Step 10: 返回 result // 所有排列完成\nEnd\n\nBut must ensure format: each line with 虛擬碼步驟 and // 解釋. Use arrow → and Decision. Indent for nested steps? Use indentation. For Decision, show Yes → and No →. Use spaces.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空列表 result 以儲存所有排列 // 用於收集最終結果  \n→ Step 2: 定義回溯函式 backtrack(current, remaining) // 進行排列生成  \n→ Decision: remaining 是否為空? // 檢查是否已完成一組排列  \n  Yes → Step 3: 將 current 的複製加入 result // 完整排列已生成  \n  No  → Step 4: 對 remaining 中的每個元素執行循環 // 選擇下一個元素  \n    → Step 5: 取出 element 並生成 newRemaining = remaining 去掉 element // 準備下一層  \n    → Step 6: newCurrent = current 加上 element // 更新當前排列  \n    → Step 7: 呼叫 backtrack(newCurrent, newRemaining) // 深入下一層回溯  \n    → Step 8: 從循環回到 Step 4 的下一個元素 // 依次嘗試所有選項  \n→ Step 9: 呼叫 backtrack([], nums) // 從空排列開始遞迴  \n→ Step 10: 回傳 result // 所有排列完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphyh0or9x.py\", line 80, in <module>\n    main()\n  File \"/tmp/tmphyh0or9x.py\", line 60, in main\n    methods, args_list = parse_input(raw_input)\n                         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmphyh0or9x.py\", line 53, in parse_input\n    args = ast.literal_eval(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    , [[], [1], [1], [2], [], [1], []]\n    ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []                     # 存放所有元素的列表\n        self.idx_map = collections.defaultdict(set)  # 值 -> 索引集合\n\n    def insert(self, val):\n        \"\"\"插入元素，返回是否首次插入\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val):\n        \"\"\"移除一個 val，若不存在則返回 False\"\"\"\n        if not self.idx_map[val]:\n            return False\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        self.data[remove_idx] = last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        self.data.pop()\n        return True\n\n    def getRandom(self):\n        \"\"\"隨機返回一個元素\"\"\"\n        return random.choice(self.data)\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入，返回方法列表和參數列表。\n    支援兩種輸入格式：\n    1. 兩行：第一行方法，第二行參數\n    2. 單行：[\"method1\", ...], [args1, ...]\n    \"\"\"\n    data = data.strip()\n    if '\\n' in data:\n        lines = data.splitlines()\n        methods = ast.literal_eval(lines[0])\n        args = ast.literal_eval(lines[1])\n    else:\n        # 找出第一個 '], [' 的位置，將兩部分分開\n        split_idx = data.find('], [')\n        if split_idx == -1:\n            raise ValueError(\"無法解析輸入\")\n        methods_part = data[:split_idx + 1]\n        args_part = data[split_idx + 1:]\n        methods = ast.literal_eval(methods_part)\n        args = ast.literal_eval(args_part)\n    return methods, args\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n    methods, args_list = parse_input(raw_input)\n    res = []\n    obj = None\n    for i, method in enumerate(methods):\n        if method == 'RandomizedCollection':\n            obj = RandomizedCollection()\n            res.append(None)\n        else:\n            args = args_list[i]\n            if method == 'insert':\n                res.append(obj.insert(*args))\n            elif method == 'remove':\n                res.append(obj.remove(*args))\n            elif method == 'getRandom':\n                res.append(obj.getRandom())\n            else:\n                raise ValueError(f\"未知方法 {method}\")\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line. For RandomizedCollection. Steps: data structures: array/list of values, hashmap from val to set of indices. Insert: push to list, add index to map, return true if new. Remove: if map empty return false. Get index to remove from set, swap with last element, update maps, pop last, return true. getRandom: random index in list. Provide pseudocode with arrows and comments. Ensure each line is separate. Use Start, End, Decision, Yes→, No→.\n\nWe produce lines like:\n\nStart // start\n\n→ Step 1: Initialize array vals and hashmap idxMap // store positions\n\n→ Decision: ...\n\nWe need to cover class definition, constructor, insert, remove, getRandom. Each function lines. We must be careful to use \"→\" for steps.\n\nLet's produce step-by-step pseudocode. Use \"Step 1\", etc. Use arrows. Provide explanation after //.\n\nMake sure each line separate. Use indentation for decisions.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告 RandomizedCollection 類別  \n    → Class RandomizedCollection  \n        → Step 2: 定義私有成員  \n            → vals: List<int> // 存放所有元素的動態陣列  \n            → idxMap: Map<int, Set<int>> // 每個值對應的索引集合  \n\n→ Step 3: 定義建構子 RandomizedCollection()  \n    → Init vals 為空列表  \n    → Init idxMap 為空映射  \n\n→ Step 4: 定義 insert(int val) -> bool  \n    → Append val 到 vals 的末尾 // 把新元素加到陣列  \n    → 新索引 = vals.length - 1  \n    → Decision: idxMap 是否包含 val? // 檢查 val 是否已存在  \n        Yes → idxMap[val].Add(newIndex) // 若存在，將新索引加入集合  \n        No  → idxMap[val] = {newIndex} // 若不存在，創建新集合  \n    → Decision: idxMap[val] 的大小是否為 1? // 判斷是否首次插入  \n        Yes → Return true // 首次插入回傳 true  \n        No  → Return false // 不是首次插入回傳 false  \n\n→ Step 5: 定義 remove(int val) -> bool  \n    → Decision: idxMap 是否包含 val? // 檢查是否有此值  \n        No  → Return false // 沒有此值，移除失敗  \n        Yes → // 有此值，執行移除  \n            → 任意取 idxMap[val] 中的任一索引 removeIdx  \n            → lastIdx = vals.length - 1  \n            → lastVal = vals[lastIdx]  \n            → Decision: removeIdx != lastIdx? // 是否不是最後一個元素  \n                Yes →  \n                    → vals[removeIdx] = lastVal // 用最後一個元素覆蓋待刪除位置  \n                    → idxMap[lastVal].Remove(lastIdx) // 更新 lastVal 的索引集合  \n                    → idxMap[lastVal].Add(removeIdx) // 加入新索引  \n                No  → // removeIdx 為最後一個，直接忽略  \n                    → // 無需覆蓋  \n            → vals.RemoveLast() // 刪除陣列最後一個元素  \n            → idxMap[val].Remove(removeIdx) // 移除被刪除的索引  \n            → Decision: idxMap[val] 是否為空? // 檢查是否還有此值  \n                Yes → idxMap.Remove(val) // 若無剩餘，刪除映射條目  \n                No  → // 留存映射  \n            → Return true // 成功移除回傳 true  \n\n→ Step 6: 定義 getRandom() -> int  \n    → randomIdx = 隨機數(0, vals.length - 1) // 隨機產生索引  \n    → Return vals[randomIdx] // 回傳隨機元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp38sknymb.py\", line 50, in main\n    params = eval(expr, {})\n             ^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'startGene' is not defined\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp38sknymb.py\", line 68, in <module>\n    main()\n  File \"/tmp/tmp38sknymb.py\", line 57, in main\n    params[key.strip()] = eval(val.strip(), {})\n                          ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n                        ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbm4zjstb.py\", line 50, in main\n    params = eval(expr, {})\n             ^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'startGene' is not defined\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpbm4zjstb.py\", line 68, in <module>\n    main()\n  File \"/tmp/tmpbm4zjstb.py\", line 57, in main\n    params[key.strip()] = eval(val.strip(), {})\n                          ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]\n                        ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list) -> int:\n        \"\"\"\n        使用 BFS 搜尋最短突變步數。\n        1. 若終點不在銀行中，直接回傳 -1。\n        2. 建立集合方便 O(1) 判斷是否存在。\n        3. BFS 時，對每個位置嘗試四種核苷酸變化，\n           若產生的新基因在銀行且未訪問，加入隊列。\n        \"\"\"\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n\n            for i in range(len(current)):\n                for g in genes:\n                    if current[i] == g:\n                        continue\n                    mutation = current[:i] + g + current[i + 1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n        return -1\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取資料，格式類似：\n        startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n    解析為字典後取得 startGene、endGene 與 bank，\n    再呼叫 Solution.minMutation，最後將結果輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將 'key = value' 轉成 'key: value' 並包成 dict 表達式\n    try:\n        expr = '{' + data.replace('=', ':') + '}'\n        params = eval(expr, {})\n    except Exception:\n        # 若 eval 失敗，嘗試逐行解析\n        params = {}\n        for line in data.splitlines():\n            if '=' in line:\n                key, val = line.split('=', 1)\n                params[key.strip()] = eval(val.strip(), {})\n\n    startGene = params.get('startGene')\n    endGene = params.get('endGene')\n    bank = params.get('bank', [])\n\n    solution = Solution()\n    result = solution.minMutation(startGene, endGene, bank)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: BFS shortest path in graph of gene strings. Steps: start gene, end gene, bank set. If end not in bank, return -1. BFS queue of gene, level, visited set. While queue, pop, if equals end return level. For each of 4 chars, change each position, if in bank and not visited add. If queue empty return -1. Also handle start equal end -> 0. Provide lines with virtual code and comment.\n\nLet's produce each line: Start, check end, visited set, queue initialization, while loop, level count, decision etc.\n\nWe need to use arrows, Decision etc. Provide each line.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 bankSet 為 bank 列表的集合 // 方便 O(1) 成員檢查\n→ Decision: 如果 endGene 不在 bankSet? // 無法到達終點直接結束\n    Yes → Step 2: 回傳 -1 // 無效終點，無法完成突變\n    No  → \n→ Decision: 如果 startGene 等於 endGene? // 起點即終點\n    Yes → Step 3: 回傳 0 // 已完成，不需要突變\n    No  → \n→ Step 4: 建立 visited 集合並加入 startGene // 追蹤已訪問的基因\n→ Step 5: 建立 queue，將 (startGene, 0) 加入 // 元素為 (基因字串, 目前突變數量)\n→ Step 6: 建立 chars = ['A', 'C', 'G', 'T'] // 四種可能的核苷酸\n→ While queue 非空 // 進行 BFS 搜尋\n    → Step 7: 從 queue 取出 (current, mutations) // 取得目前節點與已經進行的突變數量\n    → Decision: 如果 current 等於 endGene? // 找到目標基因\n        Yes → Step 8: 回傳 mutations // 回傳最短突變數量\n        No  → \n    → Step 9: 為 i 取值 0 到 7 // 遍歷每個字元位置\n        → Step 10: 為 c 取值 chars // 遍歷每種可能的核苷酸\n            → Decision: 如果 current[i] 等於 c? // 相同字元不需要改變\n                Yes → Continue // 跳過此次改變\n                No  → \n            → Step 11: newGene = current[0:i] + c + current[i+1:] // 產生新的突變基因\n            → Decision: 如果 newGene 在 bankSet 且不在 visited? // 有效且未訪問\n                Yes → Step 12: 加入 visited newGene // 標記已訪問\n                → Step 13: 將 (newGene, mutations+1) 加入 queue // 設定下一層節點\n                No  → Continue // 無效或已訪問，忽略\n→ Step 14: 回傳 -1 // 所有節點遍歷完仍未到達 endGene\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        # 小根堆存放較大的一半\n        self.large = []\n        # 大根堆（使用負值作為小根堆）存放較小的一半\n        self.small = []\n\n    def addNum(self, num: int) -> None:\n        # 先把數字放入 small\n        heapq.heappush(self.small, -num)\n        # 若 small 的最大值大於 large 的最小值，交換\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # 平衡兩堆大小：小堆可比大堆多 1 個\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將兩個列表分割開來\n    idx = data.find('],')\n    ops_str = data[:idx + 1]          # 第一個列表\n    args_str = data[idx + 2 :]        # 第二個列表，可能有前置空格\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    results = []\n    mf = None\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            mf = MedianFinder()\n            results.append(None)\n        elif op == \"addNum\":\n            mf.addNum(arg[0])\n            results.append(None)\n        elif op == \"findMedian\":\n            results.append(mf.findMedian())\n\n    # 轉換結果為 LeetCode 樣式輸出，None -> null\n    output = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MedianFinder class. Should use arrows, decision structure. Provide step-by-step algorithm: use two heaps: max-heap for lower half, min-heap for upper half. When adding number: push into appropriate heap, balance sizes. findMedian: if sizes equal, return average of top of both; else return top of larger heap.\n\nWe need to write virtual code lines, each with explanation. Use \"Start\", \"End\". Use \"Decision:\" etc.\n\nProbably we need to include class definition, constructor, addNum, findMedian methods. Steps inside.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 MedianFinder 類別 // 建立類別框架\n→ Step 2: 內部變數 lower ← 空最大堆 // 存放較小的一半\n→ Step 3: 內部變數 upper ← 空最小堆 // 存放較大的一半\n→ Step 4: 方法 addNum(num) // 新增數字\n    → Decision: num 小於等於 lower.top? // 判斷放入哪個堆\n        Yes → lower.push(num) // 放入 lower\n        No  → upper.push(num) // 放入 upper\n    → Decision: lower.size > upper.size + 1? // 檢查是否需要平衡\n        Yes → upper.push(lower.pop()) // 移動最大值到 upper\n        No → Decision: upper.size > lower.size? // 檢查另一方是否太大\n            Yes → lower.push(upper.pop()) // 移動最小值到 lower\n            No → // 已平衡\n→ Step 5: 方法 findMedian() // 計算中位數\n    → Decision: lower.size == upper.size? // 判斷兩堆是否相等\n        Yes → return (lower.top + upper.top) / 2.0 // 平均\n        No  → Decision: lower.size > upper.size? // 哪邊較大\n            Yes → return lower.top\n            No  → return upper.top\nEnd // 程式執行結束\n\nNeed to add Start and End at overall program, but also inside methods maybe not. The requirement is to output each line as \"虛擬碼步驟 // 解釋\". So each line we give.\n\nLet's produce accordingly.\n\nAlso mention that we maintain heap properties.\n\nMake sure to include indentation? The example shows indentation for decision branches. We can emulate with spaces.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MedianFinder 類別 // 建立類別框架  \n→ Step 2: 內部變數 lower ← 空最大堆 // 存放較小的一半  \n→ Step 3: 內部變數 upper ← 空最小堆 // 存放較大的一半  \n\n→ 方法 addNum(num) // 新增數字  \n    → Decision: num 小於等於 lower.top? // 判斷應放入哪個堆  \n        Yes → lower.push(num) // 放入 lower  \n        No  → upper.push(num) // 放入 upper  \n    → Decision: lower.size > upper.size + 1? // 檢查 lower 是否過大  \n        Yes → upper.push(lower.pop()) // 將 lower 的最大值移至 upper  \n        No  → Decision: upper.size > lower.size? // 檢查 upper 是否過大  \n            Yes → lower.push(upper.pop()) // 將 upper 的最小值移至 lower  \n            No → // 兩堆已平衡  \n\n→ 方法 findMedian() // 計算目前中位數  \n    → Decision: lower.size == upper.size? // 兩堆大小相等？  \n        Yes → return (lower.top + upper.top) / 2.0 // 平均兩個中間值  \n        No  → Decision: lower.size > upper.size? // 哪個堆較大？  \n            Yes → return lower.top // lower 大，返回其最大值  \n            No  → return upper.top // upper 大，返回其最小值  \n\nEnd // 程式執行結束"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,null,-1,3,4]'\nGot (Norm):      '[None,None,None,1,None,-1,None,-1,3,4]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, null, -1, 3, 4]'\nRaw Got:      '[None, None, None, 1, None, -1, None, -1, 3, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value  # move to end (most recent)\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        self.cache[key] = value  # insert as most recent\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)  # remove least recent\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split the two lists: method names and arguments\n    separator = data.find('],')\n    left = data[:separator + 1].strip()\n    right = data[separator + 2:].strip()\n    methods = ast.literal_eval(left)\n    args_list = ast.literal_eval(right)\n\n    result = []\n    cache = None\n    for method, args in zip(methods, args_list):\n        if method == \"LRUCache\":\n            cache = LRUCache(args[0])\n            result.append(None)\n        elif method == \"put\":\n            cache.put(*args)\n            result.append(None)\n        elif method == \"get\":\n            value = cache.get(*args)\n            result.append(value)\n\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step with explanations, no actual code. It's about LRU cache implementation. So need to outline steps: Use doubly linked list + hashmap. Provide steps for constructor, get, put, moveToFront, removeNode, addNode, evictIfNeeded. Provide decisions. Each line must have \"虛擬碼步驟\" + \" // 解釋/說明\". Use arrow symbols. Need to be in Traditional Chinese.\n\nLet's produce sequential steps. We'll need a Start and End block. Use Decision: ... Yes →, No →.\n\nLet's create algorithm:\n\nStart\n→ Step 1: 初始化容量, 建立空哈希表與雙向鏈表的頭尾偽節點 // 初始化\n→ Decision: 是否已設定容量? // 確認容量\n\nThen define get:\nStep 2: 定義 get 方法\n→ Step 3: 查找 key 在 map\n    Decision: 是否存在?\n        Yes → Step 4: 取得 node, 移至鏈表前 // 更新順序\n            → Step 5: 返回 node.value\n        No → Step 6: 返回 -1\n\nDefine put:\nStep 7: 定義 put 方法\n→ Step 8: 查找 key 在 map\n    Decision: 是否存在?\n        Yes → Step 9: 更新 node.value, 移至鏈表前\n        No → Step 10: 建立新 node, 加入 map, 添加到鏈表前\n            → Step 11: 檢查大小是否超過 capacity\n                Decision: 是否超過?\n                    Yes → Step 12: 找到 tail.prev 作為待移除 node\n                        → Step 13: 移除該 node 從鏈表\n                        → Step 14: 從 map 刪除其 key\n                    No → End\n\nAlso need auxiliary methods: moveToFront(node), removeNode(node), addToFront(node). Provide them as steps maybe.\n\nBut the requirement is to generate virtual code line by line for the entire structure, not just inside methods? Might just give high-level pseudocode.\n\nLet's produce:\n\nStart\n→ Step 1: 定義 LRUCache 類別 // 建立類別\n→ Step 2: 建構子 LRUCache(capacity) // 初始化\n    → Step 3: 設定 capacity, 初始化 size=0 // 尺寸\n    → Step 4: 建立 hash map keyToNode // 快速存取\n    → Step 5: 建立雙向鏈表頭尾偽節點 head, tail\n    → Step 6: 連結 head.next = tail, tail.prev = head // 空鏈表\n→ Step 7: 定義 get(key)\n    → Step 8: 若 key 在 keyToNode?\n        Yes → Step 9: node = keyToNode[key]\n            → Step 10: moveToFront(node)\n            → Step 11: 回傳 node.value\n        No  → Step 12: 回傳 -1\n→ Step 13: 定義 put(key, value)\n    → Step 14: 若 key 在 keyToNode?\n        Yes → Step 15: node = keyToNode[key]\n            → Step 16: node.value = value\n            → Step 17: moveToFront(node)\n        No  → Step 18: node = 新建 Node(key, value)\n            → Step 19: keyToNode[key] = node\n            → Step 20: addToFront(node)\n            → Step 21: size +=1\n            → Step 22: 若 size > capacity?\n                Yes → Step 23: lru = tail.prev\n                    → Step 24: removeNode(lru)\n                    → Step 25: 刪除 keyToNode[lru.key]\n                    → Step 26: size -=1\n                No  → End\n→ Step 27: 定義 moveToFront(node)\n    → Step 28: removeNode(node)\n    → Step 29: addToFront(node)\n→ Step 30: 定義 removeNode(node)\n    → Step 31: prev = node.prev, next = node.next\n    → Step 32: prev.next = next\n    → Step 33: next.prev = prev\n→ Step 34: 定義 addToFront(node)\n    → Step 35: node.next = head.next\n    → Step 36: node.prev = head\n    → Step 37: head.next.prev = node\n    → Step 38: head.next = node\nEnd\n\nEnsure each line has \"虛擬碼步驟\" and comment. Use arrows properly. Provide each line separated. Ensure we follow format: \"虛擬碼步驟 // 解釋/說明\"\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 LRUCache 類別 // 建立類別容器  \n→ Step 2: 建構子 LRUCache(capacity) // 初始化 LRU Cache  \n  → Step 3: 設定 capacity, 初始化 size = 0 // 記錄容量與目前大小  \n  → Step 4: 建立 hash map keyToNode // 用於 O(1) 存取節點  \n  → Step 5: 建立雙向鏈表頭尾偽節點 head, tail // 方便插入與刪除  \n  → Step 6: 連結 head.next = tail, tail.prev = head // 空鏈表結構  \n→ Step 7: 定義 get(key) // 查詢操作  \n  → Step 8: 若 key 在 keyToNode? // 判斷 key 是否存在  \n    Yes → Step 9: node = keyToNode[key] // 取得對應節點  \n      → Step 10: moveToFront(node) // 更新為最近使用  \n      → Step 11: 回傳 node.value // 回傳值  \n    No → Step 12: 回傳 -1 // key 不存在時的回傳  \n→ Step 13: 定義 put(key, value) // 插入或更新操作  \n  → Step 14: 若 key 在 keyToNode? // 判斷 key 是否已存在  \n    Yes → Step 15: node = keyToNode[key] // 取得節點  \n      → Step 16: node.value = value // 更新值  \n      → Step 17: moveToFront(node) // 更新為最近使用  \n    No → Step 18: node = 新建 Node(key, value) // 創建新節點  \n      → Step 19: keyToNode[key] = node // 加入映射表  \n      → Step 20: addToFront(node) // 插入至鏈表前端  \n      → Step 21: size += 1 // 大小加一  \n      → Step 22: 若 size > capacity? // 判斷是否超過容量  \n        Yes → Step 23: lru = tail.prev // 找到最舊節點  \n          → Step 24: removeNode(lru) // 從鏈表移除  \n          → Step 25: 刪除 keyToNode[lru.key] // 從映射表移除  \n          → Step 26: size -= 1 // 大小減一  \n        No → End // 不超過容量，結束操作  \n→ Step 27: 定義 moveToFront(node) // 把節點移至最前  \n  → Step 28: removeNode(node) // 先從原位置移除  \n  → Step 29: addToFront(node) // 再插入前端  \n→ Step 30: 定義 removeNode(node) // 從雙向鏈表移除節點  \n  → Step 31: prev = node.prev, next = node.next // 取得相鄰節點  \n  → Step 32: prev.next = next // 連接前後節點  \n  → Step 33: next.prev = prev // 連接前後節點  \n→ Step 34: 定義 addToFront(node) // 插入到前端  \n  → Step 35: node.next = head.next // 指向舊第一個節點  \n  → Step 36: node.prev = head // 指向頭偽節點  \n  → Step 37: head.next.prev = node // 舊第一個節點指向新節點  \n  → Step 38: head.next = node // 新節點成為第一個  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\nimport re\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []  # list of [left, right), non-overlapping, sorted by left\n\n    def addRange(self, left: int, right: int) -> None:\n        if left >= right:\n            return\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:  # overlap\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        if left >= right:\n            return True\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        if left >= right:\n            return\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main():\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    rm = None\n    results = []\n    for line in lines:\n        if line.startswith('RangeModule'):\n            rm = RangeModule()\n            results.append(None)\n        elif line.startswith('rangeModule.addRange'):\n            m = re.search(r'\\(([^,]+),\\s*([^)]+)\\)', line)\n            left, right = int(m.group(1)), int(m.group(2))\n            rm.addRange(left, right)\n            results.append(None)\n        elif line.startswith('rangeModule.removeRange'):\n            m = re.search(r'\\(([^,]+),\\s*([^)]+)\\)', line)\n            left, right = int(m.group(1)), int(m.group(2))\n            rm.removeRange(left, right)\n            results.append(None)\n        elif line.startswith('rangeModule.queryRange'):\n            m = re.search(r'\\(([^,]+),\\s*([^)]+)\\)', line)\n            left, right = int(m.group(1)), int(m.group(2))\n            res = rm.queryRange(left, right)\n            results.append(res)\n    out = '[' + ', '.join('null' if v is None else ('true' if v else 'false') for v in results) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step. No actual code. Should explain each line. Must use Start, End, Decision, arrows.\n\nWe need to design a data structure for RangeModule: likely use TreeSet of intervals or balanced BST of intervals. The steps include initialization: use e.g., SortedList of intervals. Methods: addRange: merge overlapping intervals. queryRange: check that interval is fully covered by some stored intervals. removeRange: split intervals accordingly.\n\nWe need to produce virtual code describing the algorithmic flow, not actual syntax.\n\nWe should produce lines like:\n\nStart // 初始化\n\n→ Step 1: Initialize an empty interval tree // data structure\n\n→ Step 2: Define addRange(left, right) // method\n\n→ Decision: Find intervals that overlap with [left, right) // etc.\n\nBut we need to produce line by line pseudocode for all methods.\n\nWe need to produce a virtual code flow of the entire class with methods.\n\nBetter to produce each method block with Start/End. But the sample shows \"Start\" at top of program. We can structure like:\n\nStart // Program start\n\n→ Step 1: Define class RangeModule\n\nBut maybe we need to output each line of algorithm inside methods.\n\nWe should incorporate decisions: if left > right etc.\n\nWe can produce for addRange: find leftmost interval that might overlap, iterate while intervals' start <= right, merge etc.\n\nBut since it's pseudo-code, we can use high-level operations like \"Intervals := intervals union [left,right)\" etc.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: Declare RangeModule class with an ordered list of non-overlapping intervals // 维护已追踪区间\n\n→ Step 2: In constructor, initialize empty list // 無任何追踪\n\n→ Step 3: Define addRange(left, right)\n    → Decision: if left >= right then return // 无效区间\n    → Step 4: Find the first interval that ends after left // 用二分或迭代\n    → Step 5: Set newLeft = left, newRight = right\n    → Step 6: While current interval overlaps or touches newRight\n        → Merge: newLeft = min(newLeft, current.start)\n        → newRight = max(newRight, current.end)\n        → Remove current from list\n        → Move to next interval\n    → Step 7: Insert merged interval [newLeft, newRight) into list // 保持排序\n\n→ Step 8: Define queryRange(left, right)\n    → Decision: if left >= right then return true // 空区间总是已追踪\n    → Step 9: Find interval that might contain left\n    → Decision: if interval.start > left or interval.end < right then return false // 不完全覆盖\n    → Step 10: return true // 覆盖\n\n→ Step 11: Define removeRange(left, right)\n    → Decision: if left >= right then return\n    → Step 12: Find first interval that ends after left\n    → Step 13: While current interval starts < right\n        → Decision: if current.start < left\n            → Create left part [current.start, left) // 保持\n            → If left < current.end: replace current with left part and continue\n            → else remove current\n        → Else if current.start >= left\n            → Decision: if current.end <= right\n                → Remove current // 完全被删除\n            → else\n                → Replace current with [right, current.end) // 剩余右侧\n        → Move to next interval\n    → End // End of class\n\nBut we need to produce each step line with the format: \"虛擬碼步驟 // 解釋\". We must use arrow \"→\". Also Decision lines use \"Decision:\".\n\nSo we need to output like:\n\nStart // 程式開始執行\n→ Step 1: 定義 RangeModule 類別，內部使用有序區間列表 // 用於儲存非重疊區間\n\nStart of constructor? We can treat Step 2 etc.\n\nBut the sample format shows \"Start // 程式開始執行\" then \"→ Step 1: ...\". So we can use that. For methods we can just continue with steps.\n\nWe can group by method. Use Step labels.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 RangeModule 類別，內部包含有序、非重疊的區間集合 // 追踪已加入的半開區間\n\n→ Step 2: RangeModule() 初始化空區間集合 // 建構子\n\n→ Step 3: addRange(left, right) 方法開始 // 增加區間\n\n→ Decision: if left >= right? // 檢查區間是否合法\n    Yes → Step 4: return // 無效區間，直接結束\n\n→ Step 5: 設定 newLeft = left, newRight = right // 合併新區間\n\n→ Step 6: 找到第一個與 [left, right) 有交集或相鄰的區間 // 透過二分或遍歷\n\n→ Step 7: While 目前區間與 [newLeft, newRight) 重疊或相鄰\n    → Decision: if current.start <= newRight and current.end >= newLeft? // 檢查重疊\n        Yes → Step 8: newLeft = min(newLeft, current.start)\n        Yes → Step 9: newRight = max(newRight, current.end)\n        Yes → Step 10: 刪除 current 從集合\n    → Step 11: 移動到下一個區間\n\n→ Step 12: 在合適位置插入 [newLeft, newRight) // 保持有序\n\n→ Step 13: addRange 方法結束\n\n→ Step 14: queryRange(left, right) 方法開始\n\n→ Decision: if left >= right? // 空區間總是已追踪\n    Yes → Step 15: return true\n\n→ Step 16: 找到可能包含 left 的區間\n\n→ Decision: if 区间不存在或 left < 区间.start or right > 区间.end?\n    Yes → Step 17: return false // 未完全覆蓋\n\n→ Step 18: return true // 完全覆蓋\n\n→ Step 19: queryRange 方法結束\n\n→ Step 20: removeRange(left, right) 方法開始\n\n→ Decision: if left >= right? // 空區間無需操作\n    Yes → Step 21: return\n\n→ Step 22: 找到第一個與 [left, right) 有交集的區間\n\n→ Step 23: While 目前區間開始 < right\n    → Decision: if current.start < left\n        Yes → Step 24: 生成左側保留區間 [current.start, left)\n        Yes → Step 25: 如果 left < current.end\n            Yes → Step 26: 替換 current 為左側保留區間，並設置游標在右側\n            No  → Step 27: 刪除 current\n        No  → Step 28: // current.start >= left\n            Decision: if current.end <= right\n                Yes → Step 29: 刪除 current // 完全被移除\n                No  → Step 30: 替換 current 為右側保留區間 [right, current.end)\n\n    → Step 31: 移動到下一個區間\n\n→ Step 32: removeRange 方法結束\n\nEnd // 程式執行結束\n\nBut we must ensure formatting: each line \"虛擬碼步驟 // 解釋\". Also use arrow for steps after Start. For Decision lines we need \"Decision:\" etc.\n\nWe should avoid \"Yes\" \"No\" maybe in decision but we can write:\n\nDecision: if left >= right? // 檢查區間合法性\n    Yes → Step 4: return // 無效區間\n\nBut arrow maybe not needed for the decision block but the sample uses:\n\nDecision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nSo we can replicate that. We need to indent decision blocks accordingly.\n\nThus each decision has nested sub steps with indentation.\n\nWe'll need to maintain correct indentation: 4 spaces? In sample, they use 4 spaces indent after Decision: then the Yes line has 4 spaces. We'll use similar.\n\nWe'll produce output accordingly.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 RangeModule 類別，內部使用有序、非重疊的區間列表 // 用於追踪已加入的半開區間\n→ Step 2: RangeModule() 初始化空區間集合 // 建構子\n→ Step 3: addRange(left, right) 方法開始 // 增加區間\n\nDecision: 如果 left >= right? // 檢查區間是否合法\n    Yes → Step 4: return // 無效區間，直接結束\n\n→ Step 5: 設定 newLeft = left, newRight = right // 合併新區間\n→ Step 6: 找到第一個與 [left, right) 有交集或相鄰的區間 // 透過二分或遍歷\n\n→ Step 7: While 目前區間與 [newLeft, newRight) 重疊或相鄰\n    → Decision: 如果 current.start <= newRight AND current.end >= newLeft?\n        Yes → Step 8: newLeft = min(newLeft, current.start) // 擴大左端\n        Yes → Step 9: newRight = max(newRight, current.end) // 擴大右端\n        Yes → Step 10: 刪除 current 從集合 // 移除重疊區間\n    → Step 11: 移動到下一個區間\n\n→ Step 12: 在合適位置插入 [newLeft, newRight) // 保持有序\n→ Step 13: addRange 方法結束\n\n→ Step 14: queryRange(left, right) 方法開始\n\nDecision: 如果 left >= right? // 空區間總是已追踪\n    Yes → Step 15: return true\n\n→ Step 16: 找到可能包含 left 的區間\n→ Decision: 如果 找不到 区间 OR left < 区间.start OR right > 区间.end?\n    Yes → Step 17: return false // 未完全覆蓋\n→ Step 18: return true // 完全覆蓋\n\n→ Step 19: queryRange 方法結束\n\n→ Step 20: removeRange(left, right) 方法開始\n\nDecision: 如果 left >= right? // 空區間無需操作\n    Yes → Step 21: return\n\n→ Step 22: 找到第一個與 [left, right) 有交集的區間\n→ Step 23: While 目前區間開始 < right\n    → Decision: 如果 current.start < left\n        Yes → Step 24: 生成左側保留區間 [current.start, left)\n        Yes → Decision: 如果 left < current.end\n            Yes → Step 25: 替換 current 為左側保留區間 // 保留左端\n            No  → Step 26: 刪除 current // 完全被移除\n    → Decision: 否則 // current.start >= left\n        Yes → Decision: 如果 current.end <= right\n            Yes → Step 27: 刪除 current // 完全被移除\n            No  → Step 28: 替換 current 為右側保留區間 [right, current.end) // 保留右端\n    → Step 29: 移動到下一個區間\n\n→ Step 30: removeRange 方法結束\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5hzt6ovn.py\", line 93, in <module>\n    main()\n  File \"/tmp/tmp5hzt6ovn.py\", line 62, in main\n    commands = json.loads(data[0])\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0      # index of the front element\n        self.count = 0     # current number of elements\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    obj = None\n    outputs = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MyCircularDeque\":\n            obj = MyCircularDeque(args[0])\n            outputs.append(None)  # constructor returns null\n        else:\n            method = getattr(obj, cmd)\n            if args:\n                result = method(args[0])\n            else:\n                result = method()\n            outputs.append(result)\n\n    # Format output as LeetCode-style JSON array\n    formatted = []\n    for v in outputs:\n        if v is None:\n            formatted.append(\"null\")\n        elif isinstance(v, bool):\n            formatted.append(\"true\" if v else \"false\")\n        else:\n            formatted.append(str(v))\n    print(\"[\" + \", \".join(formatted) + \"]\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrow etc. Each line: \"虛擬碼步驟 // 解釋\". Provide algorithm for circular deque with array and head/tail pointers.\n\nWe need start, end, decisions.\n\nWe'll outline initialization: create array of size k, head = -1, tail = -1.\n\nInsertFront: if full? return false. If empty? set head=tail=0. Else head=(head-1+size)%size. Set array[head]=value. return true.\n\nInsertLast: similar.\n\nDeleteFront: if empty? return false. If head==tail: empty after removal: set head=tail=-1. Else head=(head+1)%size. return true.\n\nDeleteLast: if empty? false. If head==tail: set empty. Else tail=(tail-1+size)%size.\n\ngetFront: if empty? -1 else array[head].\n\ngetRear: if empty? -1 else array[tail].\n\nisEmpty: head==-1.\n\nisFull: (head==0 && tail==size-1) || (head==tail+1).\n\nWe'll produce steps sequentially. Use Decision and arrow.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: MyCircularDeque(int k) {  \n→     初始化數組 arr[0..k-1] 為空 // 建立固定長度的陣列  \n→     設定 head = -1, tail = -1, size = k // 指標初始值與容量  \n→ } // 建構子完成  \n\n→ Step 2: boolean insertFront(int value) {  \n→     Decision: 如果 isFull()? // 檢查是否已滿  \n→         No → // 仍有空位  \n→             Decision: 如果 isEmpty()? // 判斷是否為空  \n→                 Yes → head = tail = 0 // 第一筆資料，指標同時指向 0  \n→                 No  → head = (head - 1 + size) % size // 往前移動 head  \n→             arr[head] = value // 放入新值  \n→             return true // 插入成功  \n→         Yes → return false // 已滿，插入失敗  \n→ }  \n\n→ Step 3: boolean insertLast(int value) {  \n→     Decision: 如果 isFull()?  \n→         No →  \n→             Decision: 如果 isEmpty()?  \n→                 Yes → head = tail = 0  \n→                 No  → tail = (tail + 1) % size // 往後移動 tail  \n→             arr[tail] = value  \n→             return true  \n→         Yes → return false  \n→ }  \n\n→ Step 4: boolean deleteFront() {  \n→     Decision: 如果 isEmpty()?  \n→         Yes → return false // 空，無法刪除  \n→         No  →  \n→             Decision: 如果 head == tail? // 唯一一筆資料  \n→                 Yes → head = tail = -1 // 清空後設為空  \n→                 No  → head = (head + 1) % size // 向後移動 head  \n→             return true  \n→ }  \n\n→ Step 5: boolean deleteLast() {  \n→     Decision: 如果 isEmpty()?  \n→         Yes → return false  \n→         No  →  \n→             Decision: 如果 head == tail?  \n→                 Yes → head = tail = -1  \n→                 No  → tail = (tail - 1 + size) % size // 向前移動 tail  \n→             return true  \n→ }  \n\n→ Step 6: int getFront() {  \n→     Decision: 如果 isEmpty()?  \n→         Yes → return -1  \n→         No  → return arr[head]  \n→ }  \n\n→ Step 7: int getRear() {  \n→     Decision: 如果 isEmpty()?  \n→         Yes → return -1  \n→         No  → return arr[tail]  \n→ }  \n\n→ Step 8: boolean isEmpty() {  \n→     return head == -1 // head -1 表示空  \n→ }  \n\n→ Step 9: boolean isFull() {  \n→     Decision: 如果 (head == 0 && tail == size - 1) OR (head == tail + 1)?  \n→         Yes → return true // 已滿  \n→         No  → return false  \n→ }  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"找出重複檔案並回傳其路徑群組\"\"\"\n        content_map = defaultdict(list)\n\n        for path in paths:\n            parts = path.split()\n            root = parts[0]                     # 目錄路徑\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content.rstrip(')')   # 移除右括號\n                full_path = f\"{root}/{name}\"\n                content_map[content].append(full_path)\n\n        # 只留下重複的群組\n        return [files for files in content_map.values() if len(files) > 1]\n\nif __name__ == \"__main__\":\n    # 讀取整行輸入，假設格式為: paths = [... ]\n    raw_input = sys.stdin.read().strip()\n    if raw_input.startswith(\"paths\"):\n        raw_input = raw_input.split('=', 1)[1].strip()\n    try:\n        paths = ast.literal_eval(raw_input)\n    except Exception:\n        # 若輸入不是合法的 Python 列表，直接返回空列表\n        paths = []\n\n    sol = Solution()\n    result = sol.findDuplicate(paths)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm. The algorithm: iterate over each path string, parse directory and file info, store map from content to list of file paths. After processing, collect lists of size >=2 into result. Output structure: list of lists.\n\nWe need to write step by step in virtual code, with arrows and comments. Must be in Chinese. Use Start, Decision, End. Provide each line.\n\nLet's produce something like:\n\nStart\n→ Step 1: 初始化 hash map contentMap // 用於存儲內容到文件路徑列表\n→ For each directoryInfo in paths // 逐個處理輸入\n    → Step 2: 分割 directoryInfo 為 dirPath 與 fileInfos // 用空格拆分\n    → Step 3: 循環每個 fileInfo // 處理每個文件\n        → Step 4: 解析 fileName 與 content // 拆 '('\n        → Step 5: 構造完整路徑 filePath = dirPath + \"/\" + fileName // 完整路徑\n        → Decision: contentMap 是否包含 content? // 判斷是否已存在\n            Yes → Step 6: contentMap[content].append(filePath) // 添加至現有列表\n            No  → Step 7: contentMap[content] = [filePath] // 新建列表\n→ Step 8: 初始化 result 列表 // 存儲重複文件組\n→ For each entry in contentMap // 檢查每個內容\n    → Decision: 列表長度 >= 2? // 是否有重複\n        Yes → Step 9: result.append(list) // 加入結果\n→ End // 完成\n\nAdd comments accordingly.\n\nNeed to format each line with // explanation. Use arrow for decision.\n\nBe careful with indentation: use spaces maybe.\n\nOk produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 hash map contentMap // 用於存儲內容到文件路徑列表\n→ For each directoryInfo in paths // 逐個處理輸入\n    → Step 2: 分割 directoryInfo 為 dirPath 與 fileInfos // 用空格拆分得到目錄路徑和文件資訊\n    → Step 3: 循環每個 fileInfo // 處理每個文件的名稱與內容\n        → Step 4: 解析 fileName 與 content // 拆分 '(' 與 ')' 得到檔名與內容\n        → Step 5: 構造完整路徑 filePath = dirPath + \"/\" + fileName // 形成「目錄路徑/檔名」的完整路徑\n        → Decision: contentMap 是否包含 content? // 判斷是否已有相同內容的條目\n            Yes → Step 6: contentMap[content].append(filePath) // 若已有，將路徑加入對應列表\n            No  → Step 7: contentMap[content] = [filePath] // 若無，建立新列表並存入\n→ Step 8: 初始化 result 列表 // 用於收集重複檔案組\n→ For each entry in contentMap // 檢查每個內容對應的檔案列表\n    → Decision: 列表長度 >= 2? // 判斷是否至少有兩個檔案相同\n        Yes → Step 9: result.append(list) // 若有，加入結果\n→ End // 程式執行結束\n```"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[4,10]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[4, 10]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[9,9,5]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[9, 9, 5]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\n# API rand7(): returns a uniform random integer in [1, 7]\ndef rand7() -> int:\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        Generate a uniform random integer in [1, 10] using only rand7().\n        \"\"\"\n        while True:\n            # 兩次 rand7() 組合得到 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:                      # 只使用 40 個數保持均勻\n                return 1 + (num - 1) % 10     # 將 1~40 映射到 1~10\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取內容，例如 \"n = 3\"\n    raw_input = sys.stdin.read().strip()\n    # 取得等號後的數字\n    if \"=\" in raw_input:\n        n = int(raw_input.split(\"=\")[-1].strip())\n    else:\n        n = int(raw_input)\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for rand10() using rand7(). Known solution: Use two rand7() to get 1-49 range, reject if > 40, map to 1-10. Alternatively use 2 rand7() generating 1-49. Another method: use 3 rand7() produce 1-343. Many ways. We'll provide step-by-step virtual code.\n\nWe need to output lines each with \"虛擬碼步驟 // 解釋\". Use arrows, decisions. Let's produce pseudocode:\n\nStart\n→ Step 1: repeat\n   → Step 2: x = rand7()\n   → Step 3: y = rand7()\n   → Step 4: num = (x-1)*7 + y  // num in 1..49\n   → Decision: If num <= 40?\n       Yes → Return ((num-1) mod 10) + 1\n       No  → Go back to Step 1\nEnd\n\nBut we need to use iterative loops. Use Decision with Yes/No. Also we need to mention recursion? We'll use loop.\n\nLet's structure:\n\nStart\n→ Decision: 循環 until valid\n    → Step 1: x = rand7() // 第一個隨機數\n    → Step 2: y = rand7() // 第二個隨機數\n    → Step 3: num = (x-1)*7 + y // 1-49 的整數\n    → Decision: num <= 40? // 避免偏差\n        Yes → Return ((num-1) % 10) + 1 // 轉成 1-10\n        No  → Loop back to Step 1\nEnd\n\nBut we need \"→\" arrow. We can structure as:\n\nStart\n→ Step 1: repeat loop\n   → Step 2: x = rand7()\n   → Step 3: y = rand7()\n   → Step 4: num = (x-1)*7 + y\n   → Decision: num <= 40?\n        Yes → Step 5: result = ((num-1) % 10) + 1\n        No  → Step 1\n→ Return result\nEnd\n\nBut each line must have single arrow? We can embed nested lines. We'll keep simple: one line per step.\n\nBut arrow lines: Use \"→\" preceding each step. For decisions, we indent Yes/No.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result  // 用於存放最終結果\n→ Step 2: 進入重複循環 // 直到生成有效數字\n→ Step 3: x = rand7() // 產生第一個 1-7\n→ Step 4: y = rand7() // 產生第二個 1-7\n→ Step 5: num = (x-1)*7 + y // 組合成 1-49\n→ Decision: 如果 num <= 40? // 只使用 40 個數保持均勻\n    Yes → Step 6: result = ((num-1) mod 10) + 1 // 將 1-40 轉成 1-10\n    No  → Step 2 // 超過 40 時重新循環\n→ Step 7: 返回 result // 結束函數\nEnd // 程式結束\n\nBut we need to keep \"虛擬碼步驟\" and \" // 解釋\" on each line.\n\nLet's rewrite precisely.\n\nAlso note: Use \"mod\" as placeholder.\n\nWe should keep each line distinct. For decision block, we need to indent Yes/No. We can use lines after Decision: for Yes and No.\n\nAlso, step 1 can be part of loop but okay.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result  // 用於存放最終結果  \n→ Step 2: 進入重複循環  // 直到生成有效數字  \n→ Step 3: x = rand7()  // 產生第一個 1-7  \n→ Step 4: y = rand7()  // 產生第二個 1-7  \n→ Step 5: num = (x-1)*7 + y  // 組合成 1-49 的整數  \n→ Decision: 如果 num <= 40?  // 只使用 40 個數保持均勻  \n  Yes → Step 6: result = ((num-1) mod 10) + 1  // 將 1-40 轉成 1-10  \n  No  → Step 2  // 超過 40 時重新循環  \n→ Step 7: 返回 result  // 結束函數  \nEnd // 程式結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n        return (\n            dists[0] > 0\n            and dists[0] == dists[1] == dists[2] == dists[3]\n            and dists[4] == dists[5]\n            and dists[4] == 2 * dists[0]\n        )\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) != 8:\n        print(\"false\")\n        sys.exit(0)\n\n    points = [[nums[i], nums[i + 1]] for i in range(0, 8, 2)]\n    p1, p2, p3, p4 = points\n\n    sol = Solution()\n    result = sol.validSquare(p1, p2, p3, p4)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo-code that checks if four points form a square. Provide each line with virtual code and explanation. Use Start, End, Decision, etc.\n\nWe need to consider steps: compute all pairwise distances, find unique distances, count occurrences, ensure exactly two distinct distances (side and diagonal). Side distance occurs 4 times, diagonal occurs 2 times. Distances > 0. Ensure diagonal = side * sqrt(2). But using squared distances to avoid sqrt. So diagonal squared = 2 * side squared.\n\nAlgorithm:\n\n- Input points array of 4 points\n- Create list of squared distances for all 6 pairs\n- Determine unique distances\n- If number of unique distances != 2 => not square\n- Else sort distances ascending: d1 < d2\n- If d1 == 0 => side zero => not square\n- Count occurrences: d1 occurs 4 times, d2 occurs 2 times\n- And check d2 == 2 * d1\n- Return true if all conditions satisfied\n\nNeed to output virtual code with steps. Use Start, End, Decision, arrow, etc. Let's produce each step: Start, define points, compute distances, etc. Provide line for each step.\n\nWe must follow format: each line has \"虛擬碼步驟 // 解釋\". Use Chinese explanation.\n\nWe need to use arrow like \"→\" etc.\n\nLet's craft.\n\nLine 1: Start\n\nLine 2: → Step 1: 接收四個點 p1, p2, p3, p4 // 收集輸入點\n\nBut we may need to treat input as array points. So Step 1: points = [p1, p2, p3, p4]\n\nLine 3: → Step 2: 初始化空列表 distances // 用於儲存所有兩點之間的平方距離\n\nLine 4: → Step 3: for i in 0..3: for j in i+1..3: compute dx, dy, dist2, append to distances // 計算六條邊的平方距離\n\nLine 5: → Step 4: 取得 unique_distances = set(distances) // 找出不同的距離值\n\nLine 6: → Decision: 如果 unique_distances 的大小 != 2? // 判斷是否只有兩種距離\n\n    Yes → Step 5: return False // 不是四邊形，直接返回 false\n\n    No  → Step 6: 取 min_dist, max_dist = sorted(unique_distances) // 分別為邊長與對角線長的平方\n\nLine 7: → Decision: 如果 min_dist == 0? // 檢查邊長是否為零\n\n    Yes → Step 7: return False // 零長邊不能構成正方形\n\n    No  → Continue\n\nLine 8: → Step 7: 計算 side_count = distances.count(min_dist) // 计算边长出现次数\n\nLine 9: → Step 8: 計算 diag_count = distances.count(max_dist) // 计算对角线出现次数\n\nLine 10: → Decision: 如果 side_count != 4 或 diag_count != 2? // 计数检查\n\n    Yes → Step 9: return False\n\n    No  → Continue\n\nLine 11: → Decision: 如果 max_dist != 2 * min_dist? // 对角线平方是否等于两倍边长平方\n\n    Yes → Step 10: return False\n\n    No  → Continue\n\nLine 12: → Step 11: return True // 满足所有条件，四点构成正方形\n\nLine 13: End\n\nBut we need to maintain each line with \"虛擬碼步驟\" then explanation. Use \"→\" before steps after Start. For decisions indent.\n\nWe should include indentations like 4 spaces? But example shows 4 spaces indent for nested decisions. We'll replicate.\n\nNeed to keep line numbers? Not necessary.\n\nLet's craft.\n\nWe need to produce exactly the format: each line \"虛擬碼步驟 // 解釋\".\n\nWe may include arrow and decision indentation.\n\nLet's produce:\n\n```\nStart // 程式開始執行\n→ Step 1: points = [p1, p2, p3, p4] // 將四個點收集到一個列表\n→ Step 2: distances = [] // 建立空列表存放兩點之間的平方距離\n→ Step 3: for i in range(0, 4): // 遍歷所有點\n    for j in range(i + 1, 4): // 與後續點計算距離\n        dx = points[i][0] - points[j][0] // x 差值\n        dy = points[i][1] - points[j][1] // y 差值\n        dist2 = dx * dx + dy * dy // 平方距離\n        distances.append(dist2) // 加入列表\n→ Step 4: unique_distances = set(distances) // 找出不同的平方距離\n→ Decision: if len(unique_distances) != 2: // 檢查是否只有兩種距離\n    Yes → Step 5: return False // 不是正方形\n    No  → Step 6: sorted_dists = sorted(unique_distances) // 排序得到最小與最大\n→ Step 7: min_dist, max_dist = sorted_dists[0], sorted_dists[1] // 邊長平方與對角線平方\n→ Decision: if min_dist == 0: // 邊長不能為零\n    Yes → Step 8: return False\n    No  → Continue\n→ Step 9: side_count = distances.count(min_dist) // 邊長出現次數\n→ Step 10: diag_count = distances.count(max_dist) // 對角線出現次數\n→ Decision: if side_count != 4 or diag_count != 2: // 次數檢查\n    Yes → Step 11: return False\n    No  → Continue\n→ Decision: if max_dist != 2 * min_dist: // 對角線平方是否等於兩倍邊長平方\n    Yes → Step 12: return False\n    No  → Continue\n→ Step 13: return True // 四點能構成正方形\nEnd // 程式執行結束\n```\n\nBut we need each line with \"虛擬碼步驟 // 解釋\". We used \"Step\" lines. However for nested loops we might need to indent but not separate lines? It's okay to have nested lines as separate lines. But the format may not allow indentation of loops but we can just separate each line. However we need arrow '→' for each step. For nested loops, we may have two arrows lines? Example given shows arrow for step lines and nested decisions. Loops are steps, we can just include arrow lines for each statement.\n\nBetter to maintain structure but keep each line separate.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: points = [p1, p2, p3, p4] // 將四個點收集到一個列表  \n→ Step 2: distances = [] // 建立空列表存放兩點之間的平方距離  \n→ Step 3: for i in range(0, 4): // 遍歷所有點  \n  → Step 4: for j in range(i + 1, 4): // 與後續點計算距離  \n    → Step 5: dx = points[i][0] - points[j][0] // x 差值  \n    → Step 6: dy = points[i][1] - points[j][1] // y 差值  \n    → Step 7: dist2 = dx * dx + dy * dy // 平方距離  \n    → Step 8: distances.append(dist2) // 加入列表  \n→ Step 9: unique_distances = set(distances) // 找出不同的平方距離  \n→ Decision: if len(unique_distances) != 2: // 檢查是否只有兩種距離  \n  Yes → Step 10: return False // 不是正方形  \n  No  → Step 11: sorted_dists = sorted(unique_distances) // 排序得到最小與最大  \n→ Step 12: min_dist, max_dist = sorted_dists[0], sorted_dists[1] // 邊長平方與對角線平方  \n→ Decision: if min_dist == 0: // 邊長不能為零  \n  Yes → Step 13: return False  \n  No  → Continue  \n→ Step 14: side_count = distances.count(min_dist) // 邊長出現次數  \n→ Step 15: diag_count = distances.count(max_dist) // 對角線出現次數  \n→ Decision: if side_count != 4 or diag_count != 2: // 次數檢查  \n  Yes → Step 16: return False  \n  No  → Continue  \n→ Decision: if max_dist != 2 * min_dist: // 對角線平方是否等於兩倍邊長平方  \n  Yes → Step 17: return False  \n  No  → Continue  \n→ Step 18: return True // 四點能構成正方形  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp533zkeel.py\", line 79, in <module>\n    main()\n  File \"/tmp/tmp533zkeel.py\", line 73, in main\n    price, special, needs = parse_input(data)\n                            ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp533zkeel.py\", line 64, in parse_input\n    price = ast.literal_eval(price_str)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string: None"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1jqaln84.py\", line 79, in <module>\n    main()\n  File \"/tmp/tmp1jqaln84.py\", line 73, in main\n    price, special, needs = parse_input(data)\n                            ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp1jqaln84.py\", line 64, in parse_input\n    price = ast.literal_eval(price_str)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string: None"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom functools import lru_cache\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # cost without any special offer\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef parse_input(s: str):\n    \"\"\"\n    Parse a string like:\n    'price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]'\n    into price, special, needs.\n    \"\"\"\n    def extract(name):\n        idx = s.find(name + '=')\n        if idx == -1:\n            return None\n        start = idx + len(name) + 1\n        # skip spaces\n        while start < len(s) and s[start].isspace():\n            start += 1\n        # extract until matching closing bracket for top level list\n        if s[start] != '[':\n            return None\n        depth = 0\n        end = start\n        while end < len(s):\n            ch = s[end]\n            if ch == '[':\n                depth += 1\n            elif ch == ']':\n                depth -= 1\n                if depth == 0:\n                    end += 1  # include the closing bracket\n                    break\n            end += 1\n        return s[start:end]\n\n    price_str = extract('price')\n    special_str = extract('special')\n    needs_str = extract('needs')\n\n    price = ast.literal_eval(price_str)\n    special = ast.literal_eval(special_str)\n    needs = ast.literal_eval(needs_str)\n    return price, special, needs\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    price, special, needs = parse_input(data)\n    sol = Solution()\n    result = sol.shoppingOffers(price, special, needs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps with explanations. The problem: find minimum cost to purchase required items given individual prices and special offers. This is a typical DP/backtracking problem with recursion + memoization. Approach: DFS with memoization on needs vector, try each special offer that fits (doesn't exceed needs). Compute cost: offer price + dfs(updated needs). Also consider buying remaining items at regular price. Use map< vector<int>, int > for memo. Recursion depth limited.\n\nWe need to produce pseudo-code line by line. Use Start, Decision, etc. Provide explanation comments.\n\nLet's produce steps: Start, read inputs, define function minCost(needs). Base: if all zeros, return 0. If in memo, return stored. Compute cost without offers: sum(needs[i]*price[i]). best = that. For each offer: check if can apply: for i < n: needs[i] >= offer[i]. If yes, newNeeds = needs - offer; cost = offer price + minCost(newNeeds); best = min(best, cost). Save memo and return best.\n\nThen call minCost(originalNeeds) and output. Also handle constraints: maybe limit recursion depth.\n\nLet's structure pseudo-code with arrows.\n\nWe need \"逐行\" output. Provide each line with pseudo code and comment. Use arrow arrows.\n\nLet's produce.\n\nAlso need to mention \"虛擬碼步驟\". Use \"Step 1:\" etc.\n\nLet's produce.\n\nMake sure to incorporate \"→\" etc.\n\nWe'll output line by line.\n\nLet's write:\n\nStart // 程式開始\n\n→ Step 1: 讀取 n, price[], needs[], special[][] // 初始化輸入\n\n→ Step 2: 建立 memo: Map< vector<int>, int > // 用於儲存已計算的狀態\n\n→ Step 3: 定義遞迴函式 MinCost(curNeeds) // 計算對應需求的最小成本\n\nInside MinCost: but need to produce line by line inside function using indentation maybe.\n\nWe'll produce sublines with indentation but keep \"→\" each line.\n\nLet's produce.\n\nWe'll need to use \"Decision:\" for condition.\n\nAlso for loops: \"Loop over each special offer\".\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取 n, price[0..n-1], needs[0..n-1], special[0..m-1][0..n] // 取得輸入資料\n→ Step 2: 建立 memo: Map< vector<int>, int > // 用來記錄已計算的需求組合\n→ Step 3: 定義函式 MinCost(curNeeds: vector<int>) // 計算給定需求的最小價格\n    → Decision: 若 curNeeds 全為 0? // 檢查是否已購買完所有需求\n        Yes → Return 0 // 無需再買任何物品，價格為 0\n        No  → Decision: 若 curNeeds 已在 memo 中? // 看是否已有計算結果\n            Yes → Return memo[curNeeds] // 直接回傳已存的最小價格\n            No  → Step 4: 計算直接購買的價格\n                → Step 5: directCost ← Σ (curNeeds[i] * price[i]) // 逐個物品以單價購買的總價\n                → Step 6: bestCost ← directCost // 初始最小價格為直接購買\n                → Step 7: Loop over each offer in special // 嘗試使用每個特價方案\n                    → Decision: 該 offer 是否可用? // 確認不會買到超過需求\n                        Yes → Step 8: newNeeds ← curNeeds - offer[0..n-1] // 更新剩餘需求\n                        → Step 9: offerCost ← offer[n] + MinCost(newNeeds) // 方案價格 + 後續需求價格\n                        → Step 10: bestCost ← min(bestCost, offerCost) // 更新最小價格\n                        No  → No action // 方案不可用，跳過\n                → Step 11: memo[curNeeds] ← bestCost // 存入 memo 供未來使用\n                → Return bestCost // 回傳當前需求的最小價格\n→ Step 12: result ← MinCost(needs) // 以原始需求啟動計算\n→ Step 13: 輸出 result // 顯示最低購買價格\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwqkvi967.py\", line 51, in <module>\n    results.append(obj.sumRange(arg[0], arg[1]))\n                   ^^^^^^^^^^^^\nAttributeError: 'NoneType' object has no attribute 'sumRange'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]\n        self.tree = [0] * (self.n + 1)\n        for i, v in enumerate(nums):\n            self._update_tree(i + 1, v)\n\n    def _update_tree(self, i, val):\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, i):\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Split into two parts: operations list and arguments list\n    parts = data.split('],', 1)\n    ops_part = parts[0] + ']'\n    args_part = parts[1].strip()\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    results = [None]  # First operation is always 'NumArray'\n    obj = None\n    for op, arg in zip(ops[1:], args[1:]):\n        if op == \"NumArray\":\n            obj = NumArray(arg[0])\n        elif op == \"update\":\n            obj.update(arg[0], arg[1])\n        elif op == \"sumRange\":\n            results.append(obj.sumRange(arg[0], arg[1]))\n    # Format output as LeetCode expects\n    formatted = ['null' if v is None else str(v) for v in results]\n    print('[' + ', '.join(formatted) + ']')",
      "virtual_code": "Thinking...\nThe user wants virtual code for a problem: implementing NumArray with update and sumRange. This is typical LeetCode 307. Need to produce virtual code steps. We need to produce each line: virtual code step + // explanation. Use arrow syntax. Steps include initialization, building segment tree or BIT, update, sumRange queries.\n\nWe need to produce a structured algorithm. Each line should be a step. We need to incorporate Decision nodes if necessary. The example uses Start, Decision:, Yes →, No →.\n\nWe'll produce a pseudo code:\n\nStart\n→ Step 1: Build a Binary Indexed Tree (Fenwick Tree) from the input array // build BIT for efficient updates and prefix sums\n→ Decision: Is query type 1? // Check if query is update\n    Yes → Step 2: update BIT at index with difference // perform update\n    No  → Decision: Is query type 2? // Check if sumRange\n        Yes → Step 3: compute prefixSum(right) - prefixSum(left-1) // return sum\n        No → Step 4: // handle invalid\nEnd\n\nBut the user specifically says implement NumArray class with methods. We can present virtual code that outlines the class structure, constructor, update, sumRange. Use decision for sumRange.\n\nAlso we may want to implement using segment tree or BIT. Let's pick BIT. Provide steps for building BIT, update, query prefix sum, sumRange.\n\nWe'll produce each line.\n\nLet's produce:\n\nStart // Program starts\n\n→ Step 1: Define class NumArray // main class\n    → Step 1.1: Declare array nums // store original values\n    → Step 1.2: Declare int size // length of nums\n    → Step 1.3: Declare int[] bit // Binary Indexed Tree array\n→ Step 2: NumArray(int[] input) // constructor\n    → Step 2.1: size ← length of input // store size\n    → Step 2.2: nums ← copy of input // keep original values\n    → Step 2.3: bit ← new int[size + 1] // 1-indexed BIT\n    → Step 2.4: for i from 0 to size-1\n        → Step 2.4.1: nums[i] ← input[i]\n        → Step 2.4.2: bitUpdate(i, nums[i]) // build BIT\n→ Step 3: void update(int index, int val) // update method\n    → Step 3.1: diff ← val - nums[index] // compute change\n    → Step 3.2: nums[index] ← val // update original array\n    → Step 3.3: bitUpdate(index, diff) // apply diff to BIT\n→ Step 4: int sumRange(int left, int right) // sumRange method\n    → Step 4.1: return prefixSum(right) - prefixSum(left - 1) // compute range sum\n→ Step 5: int prefixSum(int idx) // helper for BIT prefix sum\n    → Step 5.1: result ← 0\n    → Step 5.2: i ← idx + 1 // convert to 1-indexed\n    → Step 5.3: while i > 0\n        → Step 5.3.1: result ← result + bit[i]\n        → Step 5.3.2: i ← i - (i & -i) // move to parent\n    → Step 5.4: return result\n→ Step 6: void bitUpdate(int idx, int delta) // helper for BIT update\n    → Step 6.1: i ← idx + 1 // 1-indexed\n    → Step 6.2: while i <= size\n        → Step 6.2.1: bit[i] ← bit[i] + delta\n        → Step 6.2.2: i ← i + (i & -i) // move to next responsible node\nEnd // Program ends\n\nBut the user wants \"逐行地產生對應的虛擬碼 (Virtual Code)\" with each line containing virtual code step and explanation. We need to ensure we use the arrow syntax, e.g., \"→ Step 1: ... // explanation\".\n\nWe also need to ensure \"每行虛擬碼之後立即提供該行的簡短、直觀的解釋\".\n\nLet's produce each line accordingly.\n\nAlso we should not output actual code; just structure. Use \"→\" arrow at each line after the Start.\n\nWe need to produce each line. We can embed the hierarchical structure by indenting with arrow or sublines.\n\nBut the example shows each line preceded by arrow and step number. For decisions, indent with \"Yes →\" or \"No →\". But we are not using decision branches except perhaps for queries; but we can still provide simple sequence. But the problem is to implement the class and methods. So we can just produce steps.\n\nBetter to produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 NumArray // 主要資料結構\n→ Step 2: 宣告成員變數 nums, size, bit // 儲存原始陣列、長度與 BIT\n→ Step 3: 實作建構子 NumArray(nums) // 初始化\n    → Step 3.1: size ← nums.length // 記錄長度\n    → Step 3.2: bit ← new int[size+1] // BIT 使用 1-indexed\n    → Step 3.3: 對 i 從 0 到 size-1\n        → Step 3.3.1: this.nums[i] ← nums[i] // 複製原始值\n        → Step 3.3.2: bitUpdate(i, nums[i]) // 建立 BIT\n→ Step 4: 實作 update(index, val) // 更新操作\n    → Step 4.1: diff ← val - nums[index] // 差值\n    → Step 4.2: nums[index] ← val // 更新原始陣列\n    → Step 4.3: bitUpdate(index, diff) // 影響 BIT\n→ Step 5: 實作 sumRange(left, right) // 取得區間和\n    → Step 5.1: return prefixSum(right) - prefixSum(left-1) // 差值法\n→ Step 6: 定義 helper prefixSum(idx) // BIT 前綴和\n    → Step 6.1: res ← 0\n    → Step 6.2: i ← idx + 1 // 轉為 1-indexed\n    → Step 6.3: while i > 0\n        → Step 6.3.1: res ← res + bit[i]\n        → Step 6.3.2: i ← i - (i & -i)\n    → Step 6.4: return res\n→ Step 7: 定義 helper bitUpdate(idx, delta) // BIT 更新\n    → Step 7.1: i ← idx + 1\n    → Step 7.2: while i <= size\n        → Step 7.2.1: bit[i] ← bit[i] + delta\n        → Step 7.2.2: i ← i + (i & -i)\nEnd // 程式執行結束\n\nWe can include decision steps: none needed.\n\nThe user didn't ask for decision branches. But we could add a decision for the sumRange function: if left <= right? But that's trivial.\n\nOk. Ensure each line includes the arrow, step label, code, and comment.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 NumArray // 主要資料結構  \n→ Step 2: 宣告成員變數 nums, size, bit // 儲存原始陣列、長度與 BIT  \n→ Step 3: 實作建構子 NumArray(nums) // 初始化  \n    → Step 3.1: size ← nums.length // 記錄長度  \n    → Step 3.2: bit ← new int[size+1] // BIT 使用 1-indexed  \n    → Step 3.3: 對 i 從 0 到 size-1  \n        → Step 3.3.1: this.nums[i] ← nums[i] // 複製原始值  \n        → Step 3.3.2: bitUpdate(i, nums[i]) // 建立 BIT  \n→ Step 4: 實作 update(index, val) // 更新操作  \n    → Step 4.1: diff ← val - nums[index] // 差值  \n    → Step 4.2: nums[index] ← val // 更新原始陣列  \n    → Step 4.3: bitUpdate(index, diff) // 影響 BIT  \n→ Step 5: 實作 sumRange(left, right) // 取得區間和  \n    → Step 5.1: return prefixSum(right) - prefixSum(left-1) // 差值法  \n→ Step 6: 定義 helper prefixSum(idx) // BIT 前綴和  \n    → Step 6.1: res ← 0  \n    → Step 6.2: i ← idx + 1 // 轉為 1-indexed  \n    → Step 6.3: while i > 0  \n        → Step 6.3.1: res ← res + bit[i]  \n        → Step 6.3.2: i ← i - (i & -i)  \n    → Step 6.4: return res  \n→ Step 7: 定義 helper bitUpdate(idx, delta) // BIT 更新  \n    → Step 7.1: i ← idx + 1  \n    → Step 7.2: while i <= size  \n        → Step 7.2.1: bit[i] ← bit[i] + delta  \n        → Step 7.2.2: i ← i + (i & -i)  \nEnd // 程式執行結束"
    },
    {
      "title": "Count of Range Sum",
      "source_file": "Leetcode/leetcode327.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [-2,5,-1], lower = -2, upper = 2",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpi8nbc238.py\", line 38, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    nums = [-2,5,-1], lower = -2, upper = 2\n    ^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums = [0], lower = 0, upper = 0",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwz73mi00.py\", line 38, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    nums = [0], lower = 0, upper = 0\n    ^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def countRangeSum(self, nums, lower, upper):\n        # 建立前綴和陣列\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n\n        # 分治 + 計數\n        def sort_and_count(lo, hi):\n            if hi - lo <= 1:\n                return 0\n            mid = (lo + hi) // 2\n            count = sort_and_count(lo, mid) + sort_and_count(mid, hi)\n\n            i = j = mid\n            for left in prefix[lo:mid]:\n                # 找到所有右邊 prefix[j] 滿足 leftBound <= prefix[j] - left <= rightBound\n                while i < hi and prefix[i] - left < lower:\n                    i += 1\n                while j < hi and prefix[j] - left <= upper:\n                    j += 1\n                count += j - i\n\n            # 合併排序左右半區\n            prefix[lo:hi] = sorted(prefix[lo:hi])\n            return count\n\n        return sort_and_count(0, len(prefix))\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取所有內容並執行\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit()\n    # 允許輸入形如 \"nums = [...], lower = ..., upper = ...\"\n    exec(data, globals())\n\n    sol = Solution()\n    result = sol.countRangeSum(nums, lower, upper)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, not actual code. Should describe algorithm: use prefix sums and divide and conquer counting of range sums within [lower, upper], typical solution O(n log n). Provide steps: compute prefix sums, call recursive function to count and merge. Provide steps accordingly. Each line: \"虛擬碼步驟\" + \"// explanation\". Use arrows etc. Must be line by line.\n\nLet's outline steps:\n\nStart\n→ Step 1: 讀取輸入 nums, lower, upper\n→ Step 2: 建立前綴和 array prefix 其中 prefix[0]=0\n→ Step 3: for i in 0..len(nums)-1: prefix[i+1]=prefix[i]+nums[i]\n→ Step 4: 呼叫 CountAndMergeSort(prefix, 0, len(prefix)-1)\n→ Step 5: 返回結果\n\nDefine function CountAndMergeSort(arr, left, right):\n→ If left == right: return 0\n→ mid = (left+right)/2\n→ count = CountAndMergeSort(arr, left, mid) + CountAndMergeSort(arr, mid+1, right)\n→ count += CountCrossSums(arr, left, mid, right)\n→ Merge arr[left..mid] and arr[mid+1..right] ascending\n→ Return count\n\nFunction CountCrossSums(arr, left, mid, right):\n→ count = 0\n→ for each i in left..mid:\n    leftBound = lower + arr[i]\n    rightBound = upper + arr[i]\n    find number of elements in arr[mid+1..right] between leftBound and rightBound\n    (two-pointer or binary search)\n    count += that number\n→ Return count\n\nNow produce lines accordingly. Use arrow formatting: \"→\" etc. Should reflect steps. Provide concise explanation in Chinese. We'll produce each line.\n\nEnsure each line ends with \"// 解釋\".\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入 nums, lower, upper // 取得陣列與範圍界限\n→ Step 2: 初始化前綴和陣列 prefix，長度為 len(nums)+1，prefix[0]=0 // 用於快速計算區間和\n→ Step 3: 對 i 從 0 到 len(nums)-1 計算 prefix[i+1] = prefix[i] + nums[i] // 生成所有前綴和\n→ Step 4: 呼叫 CountAndMergeSort(prefix, 0, len(prefix)-1) 並將結果存入 result // 開始分治統計\n→ Step 5: 輸出 result // 給使用者答案\nEnd // 程式執行結束\n\nNow define functions as separate steps:\n\n→ Function CountAndMergeSort(arr, left, right) // 分治計算區間和個數\n    → Decision: 如果 left == right? // 只剩一個元素\n        Yes → Return 0 // 無效區間\n        No  → mid = (left + right) / 2\n    → count = CountAndMergeSort(arr, left, mid) + CountAndMergeSort(arr, mid+1, right) // 左右子區間計數\n    → count += CountCrossSums(arr, left, mid, right) // 跨越中點的區間\n    → Merge arr[left..mid] 和 arr[mid+1..right] 為升序 // 為下一層準備\n    → Return count\n\n→ Function CountCrossSums(arr, left, mid, right) // 計算跨中點的合法區間個數\n    → count = 0\n    → 初始化兩指標 l = mid+1, r = mid+1 // 用於二分\n    → For i from left to mid:\n        leftBound = arr[i] + lower\n        rightBound = arr[i] + upper\n        // 使用二分搜尋找到左邊界 l 和右邊界 r\n        l = BinarySearchFirstGreaterEqual(arr, mid+1, right, leftBound)\n        r = BinarySearchFirstGreaterThan(arr, mid+1, right, rightBound)\n        count += r - l // 匹配的元素數量\n    → Return count\n\nBut we should use virtual code steps line by line. Need to use arrow indent. Use \"→\" for each line, indent substeps with spaces maybe.\n\nEnsure each line has explanation.\n\nLet's produce final output.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取輸入 nums, lower, upper // 取得陣列與上下界\n→ Step 2: 初始化前綴和陣列 prefix，長度為 len(nums)+1，prefix[0]=0 // 用於快速計算區間和\n→ Step 3: 對 i 從 0 到 len(nums)-1 計算 prefix[i+1] = prefix[i] + nums[i] // 生成所有前綴和\n→ Step 4: 呼叫 CountAndMergeSort(prefix, 0, len(prefix)-1) 並將結果存入 result // 開始分治統計\n→ Step 5: 輸出 result // 給使用者答案\nEnd // 程式執行結束\n\n→ Function CountAndMergeSort(arr, left, right) // 分治計算區間和個數\n    → Decision: 如果 left == right? // 只剩一個元素\n        Yes → Return 0 // 無效區間\n        No  → mid = (left + right) / 2\n    → count = CountAndMergeSort(arr, left, mid) + CountAndMergeSort(arr, mid+1, right) // 左右子區間計數\n    → count += CountCrossSums(arr, left, mid, right) // 跨越中點的區間\n    → Merge arr[left..mid] 和 arr[mid+1..right] 為升序 // 為下一層準備\n    → Return count\n\n→ Function CountCrossSums(arr, left, mid, right) // 計算跨中點的合法區間個數\n    → count = 0\n    → For i 從 left 到 mid:\n        → leftBound = arr[i] + lower\n        → rightBound = arr[i] + upper\n        → l = BinarySearchFirstGreaterEqual(arr, mid+1, right, leftBound)\n        → r = BinarySearchFirstGreaterThan(arr, mid+1, right, rightBound)\n        → count += r - l // 匹配的元素數量\n    → Return count\n```"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1+2+3\",\"1*2*3\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"1+2+3\",\"1*2*3\"]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[\"1+2+3\",\"1*2*3\"]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2+3*2\",\"2*3+2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"2+3*2\",\"2*3+2\"]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[\"2+3*2\",\"2*3+2\"]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                # skip numbers with leading zeros\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp,\n                              value - last + last * curr, last * curr)\n\n        backtrack(0, \"\", 0, 0)\n        return res\n\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Convert input like: num = \"123\", target = 6  ->  {\"num\":\"123\",\"target\":6}\n    try:\n        d = ast.literal_eval(\"{\" + data + \"}\")\n    except Exception as e:\n        print(\"[]\")\n        sys.exit()\n\n    num = d.get(\"num\", \"\")\n    target = d.get(\"target\", 0)\n\n    solution = Solution()\n    result = solution.addOperators(num, target)\n\n    # Output as JSON array to match the expected format with double quotes\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: expression add operators to get target. We need to generate all valid expressions. It's typical backtracking with recursion and handling multiplication precedence. We must handle leading zeros. Provide virtual code lines with arrow etc. Must not produce actual code, just virtual steps. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, Step, etc.\n\nWe need to include algorithm: start with recursion function dfs(index, path, value, last). For each position, take substring num[i:j], if leading zero skip if len>1. Convert to long. If at index==0, start new expr; else consider +, -, *.\n\nIn virtual code we can show Start, → Step: initialize recursion, → Decision: index==len? etc.\n\nAlso we need to explain backtracking steps.\n\nLet's produce a virtual code listing. Each line starts with \"Start\" or \"→ Step\" or \"→ Decision:\" etc.\n\nWe should incorporate parameters. Might show \"→ Function DFS(index, path, value, last)\". Each line inside recursion. Use indentation.\n\nWe need to ensure each line has \"// 解釋\".\n\nWe should use arrow \"→\" before each line after start.\n\nWe should handle base case: if index==len(num) then if value==target add path to result.\n\nElse loop j from index+1 to len. Take curStr = num[index:j]; if curStr startswith '0' and len>1 skip.\n\nCompute curNum = int(curStr).\n\nIf index==0: DFS(j, curStr, curNum, curNum).\n\nElse:\n\nDFS(j, path+\"+\"+curStr, value+curNum, curNum).\n\nDFS(j, path+\"-\"+curStr, value-curNum, -curNum).\n\nDFS(j, path+\"*\"+curStr, value - last + last*curNum, last*curNum).\n\nThen after loops return.\n\nThen main: result list, call DFS, return result.\n\nAlso need to handle global result variable.\n\nWe should produce each step as a separate line.\n\nMake sure to include indentation for recursion.\n\nWe should also provide explanation for backtracking.\n\nWe'll need to include arrow for loops and decisions.\n\nLet's produce a clear virtual code.\n\nWe'll start with \"Start // 程式開始執行\".\n\nThen \"→ Function DFS(index, path, value, last) // 進行深度優先搜尋\" etc.\n\nInside function, we need to show decisions.\n\nWe'll need to show base case, for loop.\n\nLet's produce lines.\n\nWe also need to show that we need to maintain global result list.\n\nAlso note about string representation.\n\nWe should include comments: // 將結果加入列表 if match, // 循環選取子串, // 跳過含前導零的子串.\n\nWe also need to show multiplication handling: subtract last and add last*curNum.\n\nAlso show that we don't use actual code.\n\nAlright produce.\n\nWe need to output in order.\n\nLet's craft.\n\nWe might use \"→ Decision: index == len(num)?\" etc.\n\nUse arrow for each line.\n\nWe need to ensure each line contains a space between virtual code and //.\n\nLet's start.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Global result = [] // 用來儲存符合目標的表達式  \n→ Function DFS(index, path, value, last) // 進行深度優先搜尋  \n  → Decision: index == len(num) ? // 已經處理完所有數字  \n   Yes → Decision: value == target ? // 表達式值是否等於目標  \n    Yes → Append path to result // 若相等，將表達式加入結果  \n    No  → Return // 否則結束此路徑  \n   No → End // base case 完成  \n  → For j from index+1 to len(num) { // 逐個擴展子串作為下一個操作數  \n    → SubStr = num[index:j] // 取得從 index 到 j-1 的子字串  \n    → Decision: SubStr starts with '0' AND len(SubStr) > 1 ? // 前導零檢查  \n     Yes → Continue // 若有前導零且長度>1，跳過此子串  \n     No  → End  \n    → CurNum = int(SubStr) // 轉成整數  \n    → Decision: index == 0 ? // 是否為第一個操作數  \n     Yes → DFS(j, SubStr, CurNum, CurNum) // 第一次直接設定值與 last  \n     No → { // 之後依照三種運算符號遞迴  \n      → DFS(j, path + \"+\" + SubStr, value + CurNum, CurNum) // 加法  \n      → DFS(j, path + \"-\" + SubStr, value - CurNum, -CurNum) // 減法  \n      → DFS(j, path + \"*\" + SubStr, value - last + last * CurNum, last * CurNum) // 乘法（先消掉上一次加減，然後加上乘積）  \n     }  \n  }  \n  → End // 退出 DFS 函式  \n→ Call DFS(0, \"\", 0, 0) // 開始搜尋  \n→ Return result // 回傳所有符合目標的表達式集合  \nEnd // 程式執行結束"
    },
    {
      "title": "Count The Repetitions",
      "source_file": "Leetcode/leetcode466.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        # If s2 cannot be formed at all, answer is 0\n        if n1 == 0:\n            return 0\n        # If any character in s2 is not in s1, impossible\n        if any(c not in s1 for c in s2):\n            return 0\n\n        s1_count = 0      # number of s1 blocks processed\n        s2_count = 0      # number of s2 blocks formed\n        index = 0         # current position in s2\n        recall = {}       # map from index to (s1_count, s2_count)\n\n        while s1_count < n1:\n            # Process one block of s1\n            for ch in s1:\n                if ch == s2[index]:\n                    index += 1\n                    if index == len(s2):\n                        index = 0\n                        s2_count += 1\n            s1_count += 1\n\n            # Cycle detection\n            if index in recall:\n                prev_s1, prev_s2 = recall[index]\n                # Counts before the loop\n                pre_loop_s1 = prev_s1\n                pre_loop_s2 = prev_s2\n                # Counts in one loop\n                loop_s1 = s1_count - prev_s1\n                loop_s2 = s2_count - prev_s2\n\n                # Number of full loops that can still fit\n                remaining_s1 = n1 - s1_count\n                loop_times = remaining_s1 // loop_s1\n\n                # Skip over the full loops\n                s1_count += loop_times * loop_s1\n                s2_count += loop_times * loop_s2\n\n                # After skipping, finish the rest normally\n                break\n            else:\n                recall[index] = (s1_count, s2_count)\n\n        # If we exited the while without breaking (i.e., no cycle found)\n        if s1_count == n1:\n            # All s1 blocks processed\n            return s2_count // n2\n\n        # Process the remaining s1 blocks after the loops were skipped\n        remaining_s1 = n1 - s1_count\n        while s1_count < n1:\n            for ch in s1:\n                if ch == s2[index]:\n                    index += 1\n                    if index == len(s2):\n                        index = 0\n                        s2_count += 1\n            s1_count += 1\n\n        return s2_count // n2\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    # Extract strings and integers from the input\n    strings = re.findall(r'\"([^\"]*)\"', data)\n    ints = re.findall(r'(\\d+)', data)\n    s1 = strings[0] if len(strings) > 0 else \"\"\n    s2 = strings[1] if len(strings) > 1 else \"\"\n    n1 = int(ints[0]) if len(ints) > 0 else 0\n    n2 = int(ints[1]) if len(ints) > 1 else 0\n\n    solution = Solution()\n    result = solution.getMaxRepetitions(s1, n1, s2, n2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce pseudo-code lines. Problem: given s1, n1, s2, n2. Find maximum m such that str2 repeated m times can be extracted from str1 repeated n1 times. Classic Leetcode 466 or 1515? This is similar to \"Maximum number of times string s2 can be formed from s1 repeated n1 times\". Solution uses greedy counting and cycle detection. We'll produce pseudocode steps. Not actual code.\n\nWe'll produce algorithm:\n\nStart\n→ Input s1, n1, s2, n2\n→ Initialize total_s1_count = 0, total_s2_count = 0, index_in_s2 = 0\n→ Create map record for first occurrence of index_in_s2: key= index_in_s2, value = [total_s1_count, total_s2_count]\n→ While total_s1_count < n1:\n    → For each char c in s1:\n        → If c equals s2[index_in_s2]:\n            → index_in_s2 +=1\n            → If index_in_s2 == len(s2):\n                → index_in_s2 = 0\n                → total_s2_count +=1\n    → total_s1_count +=1\n    → If index_in_s2 seen before:\n        → prev_s1, prev_s2 = record[index_in_s2]\n        → loop_s1 = total_s1_count - prev_s1\n        → loop_s2 = total_s2_count - prev_s2\n        → remaining_s1 = n1 - total_s1_count\n        → num_loops = remaining_s1 // loop_s1\n        → total_s1_count += num_loops * loop_s1\n        → total_s2_count += num_loops * loop_s2\n        → Continue processing remaining s1\n        → break? we need to process remainder after loop\n        → After loops, remove record? but we can skip.\n        → Break? We'll process rest after loops\n→ After loop, result = total_s2_count // n2\n→ Output result\n\nBut need step-by-step pseudo lines. Use arrow.\n\nAlso include explanation.\n\nLet's produce lines.\n\nWe'll produce each step as one pseudo line. Might be many lines.\n\nLet's craft.\n\nWe'll start with Start. Then Step 1: Input. Then Step 2: Initialize variables. Then Step 3: Initialize map. Then Step 4: While loop. Inside while loop we have inner loop over s1 characters. We'll maybe break into steps.\n\nWe can collapse inner loop into step, but better detailed.\n\nWe'll produce:\n\nStart // program start\n→ Step 1: Read s1, n1, s2, n2 // input values\n\n→ Step 2: Set total_s1 = 0 // count of s1 blocks processed\n→ Step 3: Set total_s2 = 0 // count of s2 blocks formed\n→ Step 4: Set idx_s2 = 0 // current position in s2 to match\n→ Step 5: Create empty map repeat_map // key: idx_s2, value: [total_s1, total_s2]\n\n→ Decision: 如果 total_s1 < n1? // check if more s1 blocks remain\n\n    Yes → Step 6: For each character ch in s1 // iterate through s1 once\n        → Decision: 如果 ch == s2[idx_s2]?\n            Yes → Step 7: idx_s2 += 1 // advance in s2\n            No  → Skip\n        → Decision: 如果 idx_s2 == len(s2)?\n            Yes → Step 8: idx_s2 = 0 // restart s2\n            Yes → Step 9: total_s2 += 1 // one full s2 obtained\n        // end inner loop\n\n    → Step 10: total_s1 += 1 // finished one block of s1\n\n    → Decision: 如果 idx_s2 在 repeat_map 內? // cycle detection\n        Yes → Step 11: prev_s1, prev_s2 = repeat_map[idx_s2] // previous occurrence\n        Yes → Step 12: cycle_s1 = total_s1 - prev_s1 // number of s1 blocks in cycle\n        Yes → Step 13: cycle_s2 = total_s2 - prev_s2 // number of s2 blocks in cycle\n        Yes → Step 14: remain_s1 = n1 - total_s1 // remaining s1 blocks\n        Yes → Step 15: loop_cnt = remain_s1 // cycle_s1 // how many full cycles can fit\n        Yes → Step 16: total_s1 += loop_cnt * cycle_s1 // jump over full cycles\n        Yes → Step 17: total_s2 += loop_cnt * cycle_s2 // add corresponding s2 count\n        // after jumping, continue outer loop to process remaining s1 blocks\n        // (no need to record again, we can skip recording after cycle)\n        // But we still want to record current idx_s2 if not recorded yet\n        // Actually we should record before detecting cycle, but it's okay\n\n    → Decision: 如果 idx_s2 not in repeat_map? // record first time\n        Yes → Step 18: repeat_map[idx_s2] = [total_s1, total_s2] // store state\n\n    → Go back to outer while Decision\n\n    No → // outer loop ends\n\n→ Step 19: result = total_s2 // n2 // integer division to get how many times str2 repeated\n→ End // program ends\n\nNeed ensure explanation lines.\n\nBut maybe we can compress some steps. Also need to ensure proper indentation but it's pseudocode.\n\nWe also need to include // explanation after each line.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取 s1, n1, s2, n2 // 取得輸入參數\n→ Step 2: total_s1 ← 0 // 已處理的 s1 重複次數\n→ Step 3: total_s2 ← 0 // 已形成的 s2 重複次數\n→ Step 4: idx_s2 ← 0 // 在 s2 中目前要匹配的字元位置\n→ Step 5: repeat_map ← 空表 // 以 idx_s2 為鍵記錄前一次狀態\n→ Decision: 是否還有 s1 重複未處理? // 檢查是否已達 n1\n    Yes → Step 6: 對每個字元 ch 在 s1 中 // 逐字處理一次完整的 s1\n        → Decision: ch 等於 s2[idx_s2]?\n            Yes → Step 7: idx_s2 ← idx_s2 + 1 // 匹配成功，移至下一個位置\n            No  → Skip // 字元不匹配，保持 idx_s2\n        → Decision: idx_s2 等於 len(s2)?\n            Yes → Step 8: idx_s2 ← 0 // 完成一次 s2，重置指標\n            Yes → Step 9: total_s2 ← total_s2 + 1 // 計算一個完整的 s2\n        // 內部循環結束\n    → Step 10: total_s1 ← total_s1 + 1 // 完成一個 s1 重複\n    → Decision: idx_s2 是否已在 repeat_map 中? // 判斷是否出現循環\n        Yes → Step 11: prev_s1, prev_s2 ← repeat_map[idx_s2] // 取出之前的狀態\n        Yes → Step 12: cycle_s1 ← total_s1 - prev_s1 // 循環中 s1 的數量\n        Yes → Step 13: cycle_s2 ← total_s2 - prev_s2 // 循環中 s2 的數量\n        Yes → Step 14: remain_s1 ← n1 - total_s1 // 剩餘未處理的 s1 數量\n        Yes → Step 15: loop_cnt ← remain_s1 // cycle_s1 // 能完整執行的循環次數\n        Yes → Step 16: total_s1 ← total_s1 + loop_cnt * cycle_s1 // 跳過多個循環\n        Yes → Step 17: total_s2 ← total_s2 + loop_cnt * cycle_s2 // 加上對應的 s2 數量\n        // 從此後繼續外層循環處理剩餘的 s1\n    → Decision: idx_s2 不在 repeat_map 中?\n        Yes → Step 18: repeat_map[idx_s2] ← [total_s1, total_s2] // 記錄此時的狀態\n    // 返回外層 Decision\n    No → // 外層 while 結束\n→ Step 19: result ← total_s2 // n2 // 取整除得到最大 m\n→ End // 程式結束執行"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      \"['dogcatsdog', 'catsdogcats', 'ratcatdogcat']\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom typing import List, Set\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        # 把已處理過、可用於組合的字串存入集合\n        word_set: Set[str] = set()\n        result: List[str] = []\n\n        # 按長度排序，確保較短字串先被加入集合\n        words.sort(key=len)\n\n        def can_form(word: str, dictionary: Set[str]) -> bool:\n            \"\"\"判斷 word 是否能由 dictionary 中的字串組成。\"\"\"\n            n = len(word)\n            dp = [False] * (n + 1)\n            dp[0] = True  # 空前綴可視為可組合\n\n            for i in range(1, n + 1):\n                # 嘗試把 word 分成兩段，前段已組合，後段在 dictionary\n                for j in range(i):\n                    if dp[j] and word[j:i] in dictionary:\n                        dp[i] = True\n                        break  # 找到一次成功切分即結束內層迴圈\n            return dp[n]\n\n        for word in words:\n            if not word:  # 跳過空字串\n                continue\n            if can_form(word, word_set):\n                result.append(word)\n            word_set.add(word)  # 將此字串加入可用集合\n\n        return result\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取字串\n    raw_input = sys.stdin.read().strip()\n    # 支援「words = [...]」或直接輸入列表\n    if raw_input.lower().startswith(\"words\"):\n        _, list_part = raw_input.split(\"=\", 1)\n        raw_input = list_part.strip()\n    # 解析成 Python list\n    try:\n        words_list: List[str] = ast.literal_eval(raw_input)\n    except Exception:\n        # 若解析失敗，輸出空列表並結束\n        print(\"[]\")\n        sys.exit(0)\n\n    solution = Solution()\n    concatenated_words = solution.findAllConcatenatedWordsInADict(words_list)\n    print(concatenated_words)",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code to solve the problem: Given an array of strings words (unique), find all concatenated words. Approach: use a trie or hash set. Usually we sort by length, then for each word, check if it can be formed by smaller words using DP or recursion. Keep a set of words seen so far. For each word, if can be formed by DP with set of previous words, add to result. Then add word to set.\n\nWe need to output virtual code line by line with comments. Use Start, End, Decision. Provide arrow steps. Each line: \"→ Step ... // explanation\". Use indentation for nested decisions.\n\nLet's produce algorithm:\n\nStart\n→ Step 1: Sort words by length ascending // to ensure smaller words processed first\n→ Step 2: Initialize empty set wordSet // store words that can be used to build others\n→ Step 3: Initialize empty list result // store concatenated words\n→ Decision: For each word in words // iterate words\n    → Step 4: If word is empty string? // ignore\n        → Decision: if empty then No → (continue) etc. But we can skip.\n    → Step 5: If canForm(word, wordSet) // DP to check if word can be composed\n        → Step 6: Add word to result // it's a concatenated word\n    → Step 7: Add word to wordSet // allow future words to use it\n→ End // finished\n\nDefine canForm function:\n→ Step 8: Define canForm(word, wordSet)\n    → Step 9: Initialize boolean array dp of size len+1, dp[0]=True\n    → Decision: For i from 1 to len\n        → Step 10: For j from 0 to i-1\n            → Step 11: If dp[j] and substring word[j:i] in wordSet\n                → Step 12: dp[i] = True\n                → Decision: If dp[i] True → break inner loop\n    → Step 13: Return dp[len] // if whole word can be formed\n\nAlso need to ignore the word itself when checking if it is concatenated. Since wordSet only contains smaller words processed earlier, that's fine.\n\nEdge cases: duplicates not present.\n\nThus produce virtual code lines accordingly. Use arrows.\n\nWe'll produce:\n\nStart\n→ Step 1: Sort words by length ascending // ...\n→ Step 2: Initialize empty set wordSet\n→ Step 3: Initialize empty list result\n→ Decision: For each word in words\n    → Step 4: If word is empty string? // skip\n        → Decision: ...\n        ...\nBut we can simply skip if word empty.\n\nSimplify: For each word in words\n    → Decision: If word is empty? → No → Step 5: ...\n    → Step 5: If canForm(word, wordSet) → ...\nBut we might skip empty. Provide nested decision.\n\nLet's produce code lines.\n\nUse arrow \"→\" before each step. Use indentation with 4 spaces.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort words by length ascending // 先把字串按長度由短到長排序，確保較短字能先被加入集合  \n→ Step 2: Initialize empty set wordSet // 用來存已經處理過、可用於組合的字串  \n→ Step 3: Initialize empty list result // 存放所有被識別為「連接字」的字串  \n\n→ Decision: For each word in words // 遍歷排序後的字串  \n    → Step 4: If word == \"\" → No → Step 5: // 跳過空字串  \n        → Step 5: If canForm(word, wordSet) // 判斷此字串能否由已存的字串組成  \n            → Step 6: Add word to result // 若能，加入結果集  \n        → Step 7: Add word to wordSet // 無論是否被加入結果，將此字串加入可用集合，供後續字串使用  \n→ End // 主流程結束  \n\n→ Step 8: Define canForm(word, wordSet) // 判斷字串是否可由 wordSet 中的字串組成  \n    → Step 9: Initialize boolean array dp[0…len(word)] with all False; set dp[0] = True // dp[i] 代表前 i 個字可否被組合  \n    → Decision: For i from 1 to len(word) // 遍歷每個可能的終點位置  \n        → Decision: For j from 0 to i-1 // 嘗試每個切分點  \n            → Decision: If dp[j] == True AND word[j:i] in wordSet → Yes → Step 10: Set dp[i] = True  \n                → Step 11: Break // 找到一次成功切分就可跳出內層循環  \n        → Decision: If dp[i] == False → Continue // 若無成功切分，繼續嘗試下一個 i  \n    → Step 12: Return dp[len(word)] // 若整個字串可組成，dp[len] 為 True  \n→ End // canForm 函式結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        # Union-Find data structure\n        parent = {}\n\n        def find(x):\n            # Initialize parent if not seen\n            if x not in parent:\n                parent[x] = x\n            # Path compression\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n\n        # Build Union-Find by connecting all emails in the same account\n        for acc in accounts:\n            name = acc[0]\n            if len(acc) < 2:\n                continue\n            first_email = acc[1]\n            for email in acc[1:]:\n                # Union first_email with current email\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        # Group emails by their root parent\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        # Prepare result list\n        result = []\n        for root, emails in merged.items():\n            sorted_emails = sorted(emails)\n            result.append([email_to_name[root]] + sorted_emails)\n        return result\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # If input starts with a variable name, strip it\n    if data.startswith(\"accounts\"):\n        parts = data.split(\"=\", 1)\n        if len(parts) == 2:\n            data = parts[1].strip()\n\n    try:\n        accounts = ast.literal_eval(data)\n    except Exception:\n        # If parsing fails, exit gracefully\n        sys.exit(1)\n\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n    print(merged_accounts)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode lines with explanations. We need to consider merging accounts by email connectivity. Standard solution: use Union Find or graph DFS. We'll produce steps: Build graph of emails to each other. Then DFS to gather groups. Use map email->name. Then output sorted emails for each group. Use pseudocode with arrows.\n\nLet's produce steps line by line.\n\nInclude Start, End, Decision. Use arrows. Use indentation. Each line: \"虛擬碼步驟 // 解釋\". Let's generate.\n\nWe'll include \"Build graph\" step, \"Map emails to names\". Then \"For each account, connect emails\". Then \"DFS to collect groups\". Then \"Sort emails\". Then \"Output\".\n\nWe need to be careful to use arrow formatting: \"→ Step 1: ...\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化圖 `emailGraph` 為空字典，並初始化 `emailToName` 為空字典 // 用於儲存 email 之間的聯結與 email 與姓名的映射  \n→ Step 2: 對每筆帳戶 `account` 於 `accounts` 迴圈  \n  → Step 3: 取得姓名 `name = account[0]` // 第一個字串為姓名  \n  → Step 4: 對於 `email` 於 `account[1:]` 迴圈  \n    → Step 5: 設定 `emailToName[email] = name` // 建立 email 與姓名對應  \n    → Decision: 是否已存在 `email` 於 `emailGraph`?  \n      Yes → Step 6: 將 `email` 加入 `emailGraph[email]` 的鄰接清單  \n      No  → Step 7: 創建 `emailGraph[email] = 空集合`，然後加入 `email`  \n    → Decision: `account[1:]` 是否至少包含兩個 email?  \n      Yes → Step 8: 取第一個 email `firstEmail = account[1]`  \n       → 迭代 `otherEmail` 於 `account[2:]`  \n         → Step 9: 在 `emailGraph[firstEmail]` 加入 `otherEmail`，並在 `emailGraph[otherEmail]` 加入 `firstEmail` // 連結所有 email  \n         → Step 10: 以 `firstEmail` 為中心建立聯結，確保所有 email 同屬同一社群  \n      No → Step 11: 跳過，因為只有一個 email 沒有需連結  \n→ Step 12: 初始化集合 `visited` 為空集合，並建立結果清單 `mergedAccounts = 空列表` // 用於儲存已處理的 email 及合併後的帳戶  \n→ Step 13: 針對每個 `email` 於 `emailGraph` 迴圈  \n  → Decision: `email` 是否已在 `visited`?  \n    Yes → Step 14: 跳過此 email，已處理  \n    No  → Step 15: 建立空集合 `emailsInGroup = 空集合`  \n     → 以堆疊或遞迴 DFS 開始於 `email`  \n      → Step 16: 將 `email` 加入 `visited` 及 `emailsInGroup`  \n      → Decision: `email` 是否有鄰接 `neighbor`?  \n       Yes → 針對每個 `neighbor` 於 `emailGraph[email]`  \n         → Decision: `neighbor` 是否已在 `visited`?  \n          Yes → 步驟不做  \n          No → 將 `neighbor` 推入堆疊/遞迴進行 DFS  \n       No → 完成當前 email 的 DFS  \n    → Step 17: 將 `emailsInGroup` 轉為排序後的列表 `sortedEmails = 排序(emailsInGroup)`  \n    → Step 18: 取得姓名 `name = emailToName[開始的 email]` // 任何一個 email 的姓名皆相同  \n    → Step 19: 建立合併帳戶 `mergedAccount = [name] + sortedEmails`  \n    → Step 20: 將 `mergedAccount` 加入 `mergedAccounts`  \n→ End // 程式執行結束  \n返回 `mergedAccounts` // 回傳合併後且排序好的帳戶列表"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptpm6d8tx.py\", line 58, in <module>\n    beginWord, endWord, wordList = parse_input(raw_input)\n                                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptpm6d8tx.py\", line 51, in parse_input\n    data = eval(dict_str, {\"__builtins__\": None}, {})\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nTypeError: 'NoneType' object is not subscriptable"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_cikck6y.py\", line 58, in <module>\n    beginWord, endWord, wordList = parse_input(raw_input)\n                                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_cikck6y.py\", line 51, in parse_input\n    data = eval(dict_str, {\"__builtins__\": None}, {})\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nTypeError: 'NoneType' object is not subscriptable"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict, deque\nimport re\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS to find shortest path length and parents mapping\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c == word[i]:\n                        continue\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\ndef parse_input(input_str):\n    # Convert \"key = value\" pairs into a dict literal\n    # Replace '=' with ':' and wrap with braces\n    dict_str = \"{\" + input_str.replace('=', ':') + \"}\"\n    # Safely evaluate the dict string\n    data = eval(dict_str, {\"__builtins__\": None}, {})\n    return data['beginWord'], data['endWord'], data['wordList']\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    beginWord, endWord, wordList = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate pseudo-code steps for this problem: find all shortest transformation sequences between beginWord and endWord using wordList. Use BFS to find shortest distances, then DFS/backtrack to build paths. Steps:\n\n- Preprocess wordList to set for O(1) lookup.\n- If endWord not in set, return empty list.\n- BFS from beginWord: maintain queue, distance dict, adjacency dict (neighbors).\n- For each word, generate all possible one-letter transformations; if neighbor in set and not visited, record distance, add to queue.\n- Build adjacency mapping for edges that lead to next level (distance+1).\n- After BFS, if endWord not reached return empty.\n- Then DFS backtracking from beginWord to endWord using adjacency mapping to gather all paths.\n- Return list of paths.\n\nWe need to output step by step with virtual code arrow lines and comments. Must not output real code, just pseudo. Use arrow '→' and 'Decision:' etc. Each line has pseudo code step + comment.\n\nWe need to include Start, End. Should be clear. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 wordSet ← set(wordList) // 將字典轉成集合，方便 O(1) 查找  \n→ Decision: 如果 endWord 不在 wordSet? // 確認終點存在於字典  \n  Yes → Step 2: 回傳 [] // 無法達成，直接結束  \n  No  → Step 3: 建立 distance ← 空字典 // 記錄每個單字距離 beginWord 的步數  \n     建立 adjacency ← 空字典 // 只存入能往下走的鄰接字串  \n     建立 queue ← [beginWord] // BFS 起點  \n     distance[beginWord] ← 0  \n→ While queue 不為空: // BFS 逐層探索  \n     Step 4: current ← queue.pop_front() // 取出隊首字串  \n     Step 5: currentDist ← distance[current]  \n     For i 0 到 len(current)-1: // 對每個位置替換字母  \n       Step 6: originalChar ← current[i]  \n       For c 在 'a' 到 'z': // 26 個字母  \n         Decision: 如果 c == originalChar?  \n          Yes → Continue // 跳過相同字母  \n          No  → Step 7: nextWord ← current 前半段 + c + current 後半段 // 產生新單字  \n           Decision: 如果 nextWord 在 wordSet?  \n            Yes → Step 8: if nextWord not in distance? // 第一次見到此字  \n                Yes → distance[nextWord] ← currentDist + 1 // 記錄距離  \n                 queue.append(nextWord) // 加入下一層  \n                 adjacency.setdefault(current, []).append(nextWord) // 只存向下一層  \n                 No  → Step 9: if distance[nextWord] == currentDist + 1? // 已在同層且能進一步  \n                  Yes → adjacency[current].append(nextWord) // 加入鄰接  \n                  No  → Continue // 不是同層，忽略  \n                  // 內層字母迴圈結束  \n             // 位置迴圈結束  \n       // BFS 迴圈結束  \n→ Decision: 如果 endWord 不在 distance? // BFS 沒有到達終點  \n  Yes → Step 10: 回傳 [] // 無解  \n  No  → Step 11: 建立 results ← 空清單 // 儲存所有最短路徑  \n     → Step 12: 建立 function DFS(path, word)  \n      // path 為目前路徑，word 為目前字串  \n      Decision: 如果 word == endWord?  \n       Yes → results.append(path + [endWord]) // 完整路徑加入結果  \n       No  → For next 在 adjacency.get(word, [])? // 只走已經建好的鄰接  \n         DFS(path + [word], next) // 迭代回溯  \n     → DFS([], beginWord) // 從起點開始  \n→ Step 13: 回傳 results // 所有最短轉換序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,6,4,1,1,6,4,6]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 6, 4, 1, 1, 6, 4, 6]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # 建立映射，將小於白名單上限的黑名單數映射到合法數\n        self.mapping = {}\n        self.size = n - len(blacklist)          # 可用數量的上界\n        black = set(blacklist)                  # 方便 O(1) 查詢\n        last = n - 1                            # 從尾部開始尋找合法數\n        for b in blacklist:\n            if b < self.size:                   # 只對小於白名單上限的黑名單做映射\n                while last in black:            # 跳過尾部黑名單\n                    last -= 1\n                self.mapping[b] = last          # 建立映射\n                last -= 1                       # 移動指標\n\n    def pick(self):\n        # 隨機選取 0 ~ size-1 的索引\n        index = random.randint(0, self.size - 1)\n        # 若索引在映射中，則返回映射後的合法數，否則直接返回索引\n        return self.mapping.get(index, index)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n\n    ops = json.loads(data[0])           # 例如 [\"Solution\", \"pick\", \"pick\"]\n    args_list = json.loads(data[1])     # 例如 [[7, [2, 3, 5]], [], [], ...]\n\n    res = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            res.append(None)            # 與 LeetCode 風格保持一致，返回 null\n        elif op == \"pick\":\n            res.append(obj.pick())\n        else:\n            # 如有其他方法可自行擴充\n            res.append(None)\n\n    # 使用 json.dumps 以得到 null 而非 None 的輸出\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for the solution algorithm. Use virtual code with arrows and steps, no actual code. Provide explanation for each line. Need to design algorithm: use mapping of blacklisted numbers in [0, n-1] to valid numbers in [n-b, n-1] (where b=blacklist length). Standard approach.\n\nWe need to output \"Start // 程式開始執行\" etc. For each line, provide virtual code and comment.\n\nWe should include constructor and pick function. So pseudo-code lines: Start, Constructor: initialize mapping, etc.\n\nAlso need to include random function calls.\n\nLet's craft.\n\nWe need to follow the output format: each line: 虛擬碼步驟 + space + // 解釋\n\nUse arrows: →, Decision: etc.\n\nLet's output in order:\n\nStart\n→ Step 1: 接收 n, blacklist // 初始化\n→ Step 2: 計算 b = blacklist 長度 // 黑名單長度\n→ Step 3: 建立空的映射 dict // 用於把黑名單中小於 n-b 的數映射到合法範圍\n→ Step 4: 創建集合 skip = blacklist // 方便查詢\n→ Step 5: 初始化 white = n - b // 可選數量\n→ Step 6: 循環 i 從 n-1 下降到 white, 直到填滿映射 // 把尾部的合法數映射\n    → Decision: 如果 i 在 skip? // 判斷是否黑名單\n        Yes → Next i-- // 跳過\n        No  → Step 7: 找到下一個合法數 current = i // current\n             → Step 8: 從 skip 集合中找到最小的 > = n-b 且未被映射的數 j // 取下一個合法\n             → Step 9: 設定 dict[blacklist[idx]] = j // 建立映射\n             → Step 10: 移除 j 從 skip // 以免重複\n             → Step 11: idx++ // 移動到下一個黑名單\n→ Step 12: 定義 pick() // 隨機選擇\n    → Step 13: 生成 r = random_int(0, white-1) // 產生隨機整數\n    → Decision: 如果 r 在 dict? // 判斷是否需要映射\n        Yes → Step 14: 返回 dict[r] // 映射後的合法數\n        No  → Step 15: 返回 r // 直接合法數\nEnd\n\nBut we need to be more precise. Actually algorithm: For each blacklisted number < white, map it to a valid number >= white. Use pointer j starting from n-1 downwards, skip blacklisted numbers. For each blacklist number in sorted order < white, assign mapping.\n\nLet's craft pseudo-code accordingly.\n\nAlso note we need to use virtual code line numbering? Not required. Just each line.\n\nLet's produce step-by-step.\n\nUse \"Step X:\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化參數 n 與 blacklist // 接收建構子輸入  \n→ Step 2: 計算 b ← blacklist.size() // 黑名單長度  \n→ Step 3: 設置 white ← n - b // 可用數量的上界（不含）  \n→ Step 4: 建立空映射 map: Int → Int // 用於將小於 white 的黑名單映射到合法數  \n→ Step 5: 將 blacklist 放入集合 skip_set 以便 O(1) 查詢  \n→ Step 6: 將 blacklist 由小到大排序 // 方便一次處理  \n→ Step 7: 初始化 pointer j ← n - 1 // 從尾部尋找合法數  \n→ Step 8: 循環遍歷每個 b_i in sorted blacklist  \n    → Decision: 如果 b_i ≥ white? // 只對小於 white 的黑名單做映射  \n        Yes → Step 9: 跳過此項，繼續下一個 b_i  \n        No  → Step 10: 從 j 下降直到找到不在 skip_set 的數 y  \n            → Decision: y 在 skip_set?  \n                Yes → Step 11: j ← j - 1 // j 仍不可用，繼續搜尋  \n                No  → Step 12: map[b_i] ← y // 建立映射  \n                      → Step 13: 移除 y 從 skip_set // 防止重複使用  \n                      → Step 14: j ← j - 1 // 移動指標以備下次  \n→ Step 15: 定義 pick() 方法 // 隨機選擇合法數  \n    → Step 16: 生成 r ← random_int(0, white - 1) // 產生隨機索引  \n    → Decision: r 在 map 中? // 需要映射嗎？  \n        Yes → Step 17: 返回 map[r] // 轉為合法數  \n        No  → Step 18: 返回 r // r 本身即合法數  \nEnd // 程式執行結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprcix60q0.py\", line 90, in <module>\n    main()\n  File \"/tmp/tmprcix60q0.py\", line 66, in main\n    ops = ast.literal_eval(ops_part.strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MapSum\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    \"\"\"Trie node used by MapSum.\"\"\"\n    __slots__ = (\"children\", \"sum\")\n\n    def __init__(self):\n        self.children = {}   # child characters -> TrieNode\n        self.sum = 0         # sum of all values for keys passing through this node\n\n\nclass MapSum:\n    \"\"\"A map that supports inserting key-value pairs and summing values of keys with a given prefix.\"\"\"\n    def __init__(self):\n        self.root = TrieNode()\n        self.key_to_val = {}  # store the latest value for each key\n\n    def insert(self, key: str, val: int) -> None:\n        \"\"\"\n        Insert a key-value pair into the map.\n        If the key already exists, its value is overridden.\n        \"\"\"\n        old_val = self.key_to_val.get(key, 0)\n        delta = val - old_val          # change that must be propagated through the trie\n        self.key_to_val[key] = val\n\n        node = self.root\n        node.sum += delta              # update root sum\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += delta          # update sums along the path\n\n    def sum(self, prefix: str) -> int:\n        \"\"\"\n        Return the sum of all values of keys that start with the given prefix.\n        \"\"\"\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\n\ndef main() -> None:\n    \"\"\"\n    Read operations and arguments from stdin, execute them,\n    and print the results list to stdout.\n    Expected input format (two lines or one line with a comma):\n        [\"MapSum\", \"insert\", \"sum\", ...]\n        [[], [\"apple\", 3], [\"ap\"], ...]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split input into operations and arguments\n    if \"\\n\" in data:\n        ops_part, args_part = data.split(\"\\n\", 1)\n    else:\n        ops_part, args_part = data.split(\",\", 1)\n\n    ops = ast.literal_eval(ops_part.strip())\n    args = ast.literal_eval(args_part.strip())\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MapSum\":\n            obj = MapSum()\n            results.append(None)\n        elif op == \"insert\":\n            key, val = arg\n            obj.insert(key, val)\n            results.append(None)\n        elif op == \"sum\":\n            results.append(obj.sum(arg))\n        else:\n            # Unsupported operation – ignore or handle as needed\n            results.append(None)\n\n    print(results)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps in lines, with comments. Should design MapSum with insert and sum using trie. Steps: define MapSum class, root node with children map and sum, also map for key to val. Insert: compute delta = val - oldVal, update key map, traverse trie adding delta. Sum: traverse prefix, return node.sum. Provide step-by-step.\n\nWe need to output in the required format: each line \"虛擬碼步驟 // 解釋\". Use arrows. Let's structure:\n\nStart // Initialize\n→ Define class MapSum // 定義 MapSum 類別\n    → Define Node structure // 節點結構\n        → Attribute: children dict // 儲存子節點\n        → Attribute: sum // 該節點前綴的總和\n    → Attribute: root // 根節點\n    → Attribute: keyToVal // 儲存 key 到 val 的映射\n→ End // class 定義完成\n\nThen methods.\n\nBut we need to produce virtual code sequentially. We'll treat each logical step as a line.\n\nProbably they expect the algorithmic steps, not actual code. We'll produce pseudo-code lines.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 定義 MapSum 類別 // 建立 MapSum 的主結構\n→ Step 2: 在 MapSum 中定義 TrieNode 類別 // 用於存儲字串前綴\n    → 子步驟: 定義 children 為字典 // 儲存子節點\n    → 子步驟: 定義 sum 為 0 // 前綴累計值\n→ Step 3: 在 MapSum 中建立 root 節點 // Trie 的根節點\n→ Step 4: 在 MapSum 中建立 keyToVal 映射 // 存儲每個 key 的現有值\n→ Step 5: 實作 insert 方法 // 插入或覆蓋鍵值對\n    → 子步驟: 取得舊值 old = keyToVal.get(key, 0) // 讀取舊值\n    → 子步驟: 計算 delta = val - old // 差值\n    → 子步驟: keyToVal[key] = val // 更新映射\n    → 子步驟: node = root // 從根節點開始\n    → 子步驟: 對於每個字元 ch in key\n        → 子步驟: 如果 ch 不在 node.children 則 node.children[ch] = TrieNode() // 建立子節點\n        → 子步驟: node = node.children[ch] // 移動到子節點\n        → 子步驟: node.sum += delta // 更新此前綴的總和\n→ Step 6: 實作 sum 方法 // 計算前綴總和\n    → 子步驟: node = root // 從根節點開始\n    → 子步驟: 對於每個字元 ch in prefix\n        → 子步驟: 如果 ch 不在 node.children 則 return 0 // 前綴不存在\n        → 子步驟: node = node.children[ch] // 移動到子節點\n    → 子步驟: return node.sum // 返回前綴總和\nEnd // 程式結束\n\nBut need each line as \"虛擬碼步驟 // 解釋\". Let's separate each line accordingly. We must include arrows. For decision maybe not needed. But for loops we can indicate iteration.\n\nWe might also break down loops as Decision etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MapSum 類別 // 建立 MapSum 的主結構  \n→ Step 2: 在 MapSum 中定義 TrieNode 類別 // 用於存儲字串前綴  \n    → 子步驟: 定義 children 為字典 // 儲存子節點  \n    → 子步驟: 定義 sum 為 0 // 前綴累計值  \n→ Step 3: 在 MapSum 中建立 root 節點 // Trie 的根節點  \n→ Step 4: 在 MapSum 中建立 keyToVal 映射 // 存儲每個 key 的現有值  \n→ Step 5: 實作 insert 方法 // 插入或覆蓋鍵值對  \n    → 子步驟: 取得舊值 old = keyToVal.get(key, 0) // 讀取舊值  \n    → 子步驟: 計算 delta = val - old // 差值  \n    → 子步驟: keyToVal[key] = val // 更新映射  \n    → 子步驟: node = root // 從根節點開始  \n    → 子步驟: 對於每個字元 ch in key  \n        → 子步驟: 如果 ch 不在 node.children → node.children[ch] = TrieNode() // 建立子節點  \n        → 子步驟: node = node.children[ch] // 移動到子節點  \n        → 子步驟: node.sum += delta // 更新此前綴的總和  \n→ Step 6: 實作 sum 方法 // 計算前綴總和  \n    → 子步驟: node = root // 從根節點開始  \n    → 子步驟: 對於每個字元 ch in prefix  \n        → 子步驟: 如果 ch 不在 node.children → return 0 // 前綴不存在  \n        → 子步驟: node = node.children[ch] // 移動到子節點  \n    → 子步驟: return node.sum // 返回前綴總和  \nEnd // 程式結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.5121768128893864,-0.789571042654493],[0.9986686921541462,-0.007659255737246963],[-0.4244905184492427,-0.48322754758426983]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.5121768128893864, -0.789571042654493], [0.9986686921541462, -0.007659255737246963], [-0.4244905184492427, -0.48322754758426983]]'"
        }
      ],
      "generated_code": "import json\nimport random\nimport math\nimport sys\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())          # 確保半徑分布均勻\n        theta = random.uniform(0, 2 * math.pi)                # 隨機角度\n        x = self.x_center + r * math.cos(theta)              # 計算 X 座標\n        y = self.y_center + r * math.sin(theta)              # 計算 Y 座標\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])                                 # 讀取操作列表\n    args_list = json.loads(data[1]) if len(data) > 1 else [] # 讀取每個操作的參數\n    results = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)                            # 建構子\n            results.append(None)\n        else:\n            method = getattr(obj, op)                        # 取得方法\n            result = method()                                # 執行方法\n            results.append(result)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines: Start, steps, decisions, etc. For generating random point inside circle uniformly. Steps: get random r via sqrt(random) * radius; get angle uniform 0-2π; compute x=x_center + r*cos(angle), y=y_center + r*sin(angle). We need to show random generation: rand_uniform() returns value 0-1. Steps: Step 1: Generate u1 = rand_uniform() // 0-1\nStep 2: Generate u2 = rand_uniform()\nStep 3: Compute r = sqrt(u1)*radius\nStep 4: Compute theta = u2*2π\nStep 5: Compute x = x_center + r*cos(theta)\nStep 6: Compute y = y_center + r*sin(theta)\nReturn [x,y].\n\nInclude initialization: constructor sets radius, x_center, y_center. We might have a Step in constructor. Use Start, End. Provide virtual code with comments.\n\nMake sure each line includes \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow etc.\n\nLet's produce:\n\nStart\n→ Step: Constructor: Store radius, x_center, y_center // 初始化圓參數\n→ Step: randPoint(): Begin random point generation // 進入隨機點生成\n→ Step: u1 = rand_uniform() // 產生 0~1 隨機數\n→ Step: u2 = rand_uniform() // 產生 0~1 隨機數\n→ Step: r = sqrt(u1) * radius // 轉換為半徑分布\n→ Step: theta = u2 * 2π // 隨機角度\n→ Step: x = x_center + r * cos(theta) // 計算 x 座標\n→ Step: y = y_center + r * sin(theta) // 計算 y 座標\n→ Step: return [x, y] // 回傳隨機點\nEnd\n\nBut also include Decision? Might not need. But format says use Decision when branching. No branching needed. But we might show if radius >0? Not necessary.\n\nLet's output. Ensure each line ends with // 解釋. Use \"虛擬碼步驟\" text? They said each line must contain: virtual code step + space + comment. The example didn't prefix with \"虛擬碼步驟\". It's just code step like \"→ Step 1: 輸入使用者數字\". So we can just produce steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: Store radius, x_center, y_center // 建構子初始化圓的半徑與中心座標\n→ Step: randPoint() 開始隨機點產生流程 // 進入生成隨機點的主流程\n→ Step: u1 = rand_uniform() // 產生 0~1 之間的隨機數，用於調整半徑分布\n→ Step: u2 = rand_uniform() // 產生 0~1 之間的隨機數，用於產生隨機角度\n→ Step: r = sqrt(u1) * radius // 以平方根方式映射，使半徑分布均勻\n→ Step: theta = u2 * 2π // 生成 0~2π 之間的隨機角度\n→ Step: x = x_center + r * cos(theta) // 計算隨機點的 X 座標\n→ Step: y = y_center + r * sin(theta) // 計算隨機點的 Y 座標\n→ Step: return [x, y] // 回傳隨機點座標\nEnd // 程式執行結束"
    },
    {
      "title": "Count Different Palindromic Subsequences",
      "source_file": "Leetcode/leetcode730.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '9'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '9'"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '104860361'\nGot (Norm):      '145766854'\n--- (Raw) ---\nRaw Expected: '104860361'\nRaw Got:      '145766854'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # dp[i][j] = number of distinct palindromic subsequences in s[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    # next_pos[i] = next index after i where s[next_pos[i]] == s[i], or n if none\n    # prev_pos[i] = previous index before i where s[prev_pos[i]] == s[i], or -1 if none\n    next_pos = [n] * n\n    prev_pos = [-1] * n\n    last = [n] * 26\n    for i in range(n - 1, -1, -1):\n        idx = ord(s[i]) - 97\n        next_pos[i] = last[idx]\n        last[idx] = i\n\n    last = [-1] * 26\n    for i in range(n):\n        idx = ord(s[i]) - 97\n        prev_pos[i] = last[idx]\n        last[idx] = i\n\n    # Base case: single character substrings\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Build DP for increasing lengths\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                l = next_pos[i]\n                r = prev_pos[j]\n                if l > r:  # no same character inside\n                    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] + 1) % MOD\n                elif l == r:  # exactly one same character inside\n                    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] + 1) % MOD\n                else:  # more than one same character inside\n                    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] - dp[l + 1][r - 1]) % MOD\n            else:\n                dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]) % MOD\n            dp[i][j] %= MOD\n\n    return dp[0][n - 1] % MOD\n\n\ndef main() -> None:\n    raw_input = sys.stdin.read().strip()\n    # Try to extract a quoted string if present\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        # Remove possible leading \"s = \" and whitespace\n        s = raw_input.replace('s =', '').strip().strip('\"')\n    result = count_palindromic_subsequences(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step for algorithm: count distinct non-empty palindromic subsequences modulo 1e9+7. Standard DP O(n^2) with DP[i][j] number of distinct palindromic subsequences in s[i..j]. Recurrence: if s[i]==s[j], dp[i][j] = dp[i+1][j] + dp[i][j-1] + 1; else dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]. Actually more complex to avoid double count; the standard recurrence with mod. But distinct count requires handling duplicates: if s[i]==s[j], need to consider inner occurrences: find next i+1 <= k <= j-1 where s[k]==s[i]. If no such k, then dp[i][j] = dp[i+1][j] + dp[i][j-1] +1; if exists one k (only one), dp[i][j] = dp[i+1][j] + dp[i][j-1] +1; Wait correct formula: If s[i]==s[j]:\n  if next_i > prev_j (no same char inside), dp = dp[i+1][j] + dp[i][j-1] +1\n  else if next_i == prev_j (one same char inside), dp = dp[i+1][j] + dp[i][j-1] +1\n  else (more than one), dp = dp[i+1][j] + dp[i][j-1] - dp[next_i+1][prev_j-1]\nBut easier: dp[i][j] = dp[i+1][j] + dp[i][j-1] +1 if s[i]==s[j] else dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]. Actually correct formula for distinct palindromic subsequences with duplicate removal uses above conditions.\n\nLet's produce virtual code lines: Start, initialize n, dp array, precompute next array of next occurrence for each index, previous array for previous occurrence. Then for len from 1 to n: for i loop: j = i+len-1. compute dp. Use modulo. After loops output dp[0][n-1] mod.\n\nLet's produce stepwise explanation lines.\n\nWe'll produce lines like:\n\nStart // program start\n→ Step 1: Read string s // obtain input string\n→ Step 2: n ← length of s // number of characters\n→ Step 3: Create 2D array dp[n][n] // DP table for subsequences\n→ Step 4: Create arrays next[n] and prev[n] // track next/prev occurrences\n→ Step 5: Build next array by scanning from right // store next occurrence index\n→ Step 6: Build prev array by scanning from left // store previous occurrence index\n→ Step 7: For i from 0 to n-1: dp[i][i] ← 1 // single char is palindrome\n→ Step 8: For len from 2 to n:\n    → Step 9: For i from 0 to n-len:\n        → Step 10: j ← i + len -1 // right boundary\n        → Step 11: If s[i] == s[j] then\n            → Step 12: leftNext ← next[i] // next occurrence of s[i] after i\n            → Step 13: rightPrev ← prev[j] // previous occurrence of s[j] before j\n            → Step 14: If leftNext > rightPrev then\n                → Step 15: dp[i][j] ← dp[i+1][j] + dp[i][j-1] + 1 // no duplicate inside\n            → Step 16: Else If leftNext == rightPrev then\n                → Step 17: dp[i][j] ← dp[i+1][j] + dp[i][j-1] + 1 // one duplicate inside\n            → Step 18: Else\n                → Step 19: dp[i][j] ← dp[i+1][j] + dp[i][j-1] - dp[leftNext+1][rightPrev-1] // more than one duplicate\n            → Step 20: dp[i][j] ← dp[i][j] mod M // keep within modulo\n        → Step 21: Else // s[i] != s[j]\n            → Step 22: dp[i][j] ← dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] // remove double counted\n            → Step 23: dp[i][j] ← dp[i][j] mod M\n→ Step 24: Answer ← dp[0][n-1] mod M // final result\n→ End // program finish\n\nNeed to include explanation comment after each line. Also must use arrow notation: Start, → Step, Decision, Yes/No, End.\n\nThe \"Decision\" lines for conditions: we have if statements. Use Decision: if condition? and Yes → etc.\n\nWe need to keep each line separate. Let's produce line by line with proper formatting.\n\nWe must not output actual code but virtual steps. Use arrows and Decision. Let's produce.\n\nAlso mod constant M=1e9+7.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 s // 取得輸入的字串  \n→ Step 2: n ← length of s // 計算字串長度  \n→ Step 3: 建立 2D 陣列 dp[n][n] // 用於存放子區間內不同回文子序列數  \n→ Step 4: 建立陣列 next[n] 與 prev[n] // 追蹤每個字符的下一個與前一個出現位置  \n→ Step 5: 從右往左掃描字串，為每個 i 填入 next[i] = 最後一次出現 i 後的同字符位置，若無則為 n  \n→ Step 6: 從左往右掃描字串，為每個 i 填入 prev[i] = 最後一次出現 i 前的同字符位置，若無則為 -1  \n→ Step 7: 對 i 從 0 到 n-1：dp[i][i] ← 1 // 單一字符本身即為回文子序列  \n→ Decision: 是否需要計算更長子區間?  \n    Yes → Step 8: 對 len 從 2 到 n： // 子區間長度  \n        → Step 9: 對 i 從 0 到 n-len：  \n            → Step 10: j ← i + len - 1 // 子區間右端索引  \n            → Decision: s[i] 是否等於 s[j]?  \n                Yes → Step 11: leftNext ← next[i] // s[i] 的下一個出現位置  \n                → Step 12: rightPrev ← prev[j] // s[j] 的前一個出現位置  \n                → Decision: leftNext > rightPrev? // 在 i 與 j 之間是否沒有同字符  \n                    Yes → Step 13: dp[i][j] ← dp[i+1][j] + dp[i][j-1] + 1 // 無重複，直接加 1  \n                → No  → Decision: leftNext == rightPrev? // 只有一個重複  \n                    Yes → Step 14: dp[i][j] ← dp[i+1][j] + dp[i][j-1] + 1 // 只算一次  \n                → No  → Step 15: dp[i][j] ← dp[i+1][j] + dp[i][j-1] - dp[leftNext+1][rightPrev-1] // 多於一個重複，需減去重複部分  \n                → Step 16: dp[i][j] ← dp[i][j] mod M // 保持結果在模數範圍內  \n                No → Step 17: dp[i][j] ← dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] // s[i]!=s[j]，去除重疊計數  \n                → Step 18: dp[i][j] ← dp[i][j] mod M // 同樣取模  \n→ Step 19: Answer ← dp[0][n-1] mod M // 最終答案，對整個字串計算的回文子序列數  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Duplicates from Sorted Array",
      "source_file": "Leetcode/leetcode26.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "2, nums = [1,2,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2,nums=[1,2,_]'\nGot (Norm):      '2,nums=[1,2,\"_\"]'\n--- (Raw) ---\nRaw Expected: '2, nums = [1,2,_]'\nRaw Got:      \"2, nums = [1, 2, '_']\""
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
          "expected_output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,2,3,4,_,_,_,_,_]'\nGot (Norm):      '5,nums=[0,1,2,3,4,\"_\",\"_\",\"_\",\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,2,3,4,_,_,_,_,_]'\nRaw Got:      \"5, nums = [0, 1, 2, 3, 4, '_', '_', '_', '_', '_']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef removeDuplicates(nums):\n    \"\"\"移除已排序陣列中的重複項，並在原陣列前部留下唯一值。\"\"\"\n    if not nums:  # 空陣列直接回傳 0\n        return 0\n    slow = 0  # 指向最後一個唯一元素的位置\n    for fast in range(1, len(nums)):\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1  # 唯一元素個數\n\ndef main():\n    # 從標準輸入讀取整行文字\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入文字中擷取陣列字串\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        print(\"Invalid input\")\n        return\n    list_str = data[start:end+1]\n\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        print(\"Invalid input\")\n        return\n\n    # 執行去重\n    k = removeDuplicates(nums)\n\n    # 建立顯示用的列表，後續位置用 '_' 表示未使用\n    display_list = nums[:k] + ['_'] * (len(nums) - k)\n\n    # 輸出結果\n    print(f\"{k}, nums = {display_list}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for removing duplicates from sorted array in-place. Provide step-by-step with virtual code lines and explanation comments. Must not output actual code. Use arrow syntax.\n\nWe need to produce lines: Start, Step 1, Decision, etc. Let's design algorithm: use two pointers, slow and fast. slow at 0. iterate fast from 1 to n-1. If nums[fast] != nums[slow], increment slow, copy nums[fast] to nums[slow]. After loop, k = slow+1. Return k.\n\nWe need to output step by step. Let's produce:\n\nStart\n→ Step 1: If nums length == 0 → Return 0 // no elements\n→ Step 2: Initialize pointer slow = 0 // index of last unique element\n→ Step 3: For fast from 1 to length-1 // iterate through array\n    → Decision: If nums[fast] != nums[slow]?\n        Yes → Step 4: Increment slow // move to next unique position\n        Yes → Step 5: Set nums[slow] = nums[fast] // copy unique value\n        No → // do nothing (duplicate)\n→ Step 6: Set k = slow + 1 // number of unique elements\n→ Step 7: Return k\nEnd\n\nAdd explanations after each.\n\nEnsure each line ends with // explanation. Also include arrows: For loops maybe \"→ For fast in range(1, len(nums)) // iterate\". We'll keep simple.\n\nAlso include decisions nested.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: If nums length == 0 then Return 0 // 若陣列為空，直接回傳 0\n→ Step 2: Initialize pointer slow = 0 // 指向最後一個已找到的唯一元素索引\n→ Step 3: For fast from 1 to nums.length-1 // 循環遍歷陣列\n    → Decision: nums[fast] != nums[slow]? // 檢查當前元素是否與前一個唯一元素不同\n        Yes → Step 4: Increment slow // 移動 slow 到下一個唯一位置\n        Yes → Step 5: Set nums[slow] = nums[fast] // 把新的唯一元素複製到 slow 位置\n        No  → // 若相同則不做任何操作，繼續迴圈\n→ Step 6: Set k = slow + 1 // 計算唯一元素的個數\n→ Step 7: Return k // 回傳唯一元素數量\nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,3,1],[1,2,3],[3,2,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 3, 1], [1, 2, 3], [3, 2, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.nums = list(nums)          # 儲存原始陣列\n\n    def reset(self):\n        return list(self.nums)          # 回傳原始陣列（不改變內部狀態）\n\n    def shuffle(self):\n        arr = list(self.nums)           # 先複製一次\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)   # 隨機選取 i~n-1 的索引\n            arr[i], arr[j] = arr[j], arr[i]  # 交換\n        return arr\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入包成一個元組（兩個列表）並解析\n    methods, params = ast.literal_eval('(' + data + ')')\n    results = []\n    obj = None\n    for method, args in zip(methods, params):\n        if method == \"Solution\":\n            obj = Solution(args[0])\n            results.append(None)   # 初始化時回傳 null\n        elif method == \"reset\":\n            results.append(obj.reset())\n        elif method == \"shuffle\":\n            results.append(obj.shuffle())\n    # 以 JSON 格式輸出結果\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode lines with explanations for a virtual code for the described algorithm. We must follow format: each line with virtual code then // explanation. Must include arrow, Start, End, Decision, etc.\n\nWe need to design algorithm: using Fisher-Yates shuffle for random shuffle. Also need to store original array to reset.\n\nWe need to produce pseudocode: steps: Start, initialize original copy, copy current array etc. Provide reset and shuffle methods.\n\nProbably multiple methods: class initialization, reset, shuffle. Provide pseudocode lines representing these operations. Use arrows.\n\nWe need to present the entire design in a linear format. We might structure like:\n\nStart // start\n→ Step: Create class Solution\n    → Step: Store original array (original = copy(nums))\n    → Step: Create current array (current = copy(nums))\nEnd // initialization complete\n\nBut we need to reflect method calls? Maybe separate blocks for reset and shuffle.\n\nWe can produce like:\n\nStart // 程式開始\n→ Step 1: 定義類別 Solution\n    → Step 2: 在建構子中接收 nums // 初始化\n        → Step 3: 把 nums 複製為 original // 保存原始順序\n        → Step 4: 把 nums 複製為 current // 當前排列\n→ Step 5: 定義 reset() 方法\n    → Decision: 是否需要返回值? // 這裡返回 current\n        Yes → Step 6: 把 current 設為 original 的拷貝\n        Yes → Step 7: 返回 current\n→ Step 8: 定義 shuffle() 方法\n    → Step 9: 取得陣列長度 n\n    → Step 10: 從 i = n-1 到 1 迴圈\n        → Step 11: 隨機產生 j ∈ [0,i]\n        → Step 12: 交換 current[i] 與 current[j]\n    → Step 13: 返回 current\nEnd // 程式結束\n\nBut we need arrows properly: maybe use →, Yes →, No →.\n\nWe need to produce for each line: virtual code + // explanation. Should be line by line. Use arrow formatting.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 定義類別 Solution // 開始定義 Solution 類\n    → Step 2: 建構子: Solution(nums) // 接收輸入陣列\n        → Step 3: original ← copy(nums) // 保存原始排列\n        → Step 4: current ← copy(nums) // 初始化當前排列\n→ Step 5: 方法 reset() // 重置為原始順序\n    → Decision: 是否要重新複製 original? // 需要複製回 current\n        Yes → Step 6: current ← copy(original) // 恢復原始順序\n        Yes → Step 7: return current // 返回重置後陣列\n→ Step 8: 方法 shuffle() // 隨機打亂陣列\n    → Step 9: n ← length(current) // 取得長度\n    → Step 10: for i from n-1 downto 1 // Fisher‑Yates 迴圈\n        → Step 11: j ← random integer in [0, i] // 隨機索引\n        → Step 12: swap current[i] with current[j] // 交換元素\n    → Step 13: return current // 返回打亂後陣列\nEnd // 程式結束\n\nBut we need to follow arrow style: Start, Step 1, etc. Each line must have arrow before the step, and maybe indentation for nested steps? In the example they used indentation. So we can indent nested steps.\n\nMake sure each line ends with // explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 這個類別  \n → Step 2: 建構子: Solution(nums) // 接收輸入的整數陣列  \n  → Step 3: original ← copy(nums) // 產生 nums 的副本並存成 original，保存原始順序  \n  → Step 4: current ← copy(nums) // 產生 nums 的副本並存成 current，作為目前排列  \n→ Step 5: 方法 reset() // 重設為原始順序  \n → Decision: 需要把 current 重新設回 original?  \n  Yes → Step 6: current ← copy(original) // 用 original 的副本覆寫 current  \n  Yes → Step 7: return current // 回傳重設後的陣列  \n→ Step 8: 方法 shuffle() // 產生等機率的隨機排列  \n → Step 9: n ← length(current) // 取得陣列長度  \n → Step 10: for i from n-1 downto 1 // 依照 Fisher‑Yates 演算法進行迴圈  \n  → Step 11: j ← random integer in [0, i] // 產生範圍內的隨機整數  \n  → Step 12: swap current[i] with current[j] // 交換 i 與 j 位置的元素  \n → Step 13: return current // 回傳打亂後的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 找到第一個 '[' 和最後一個 ']'，將它們之間的內容解析為列表\n    l = data.find('[')\n    r = data.rfind(']')\n    if l == -1 or r == -1 or r < l:\n        nums = []\n    else:\n        nums = ast.literal_eval(data[l:r+1])\n\n    # 生成子集（冪集）\n    res = []\n    def backtrack(start, path):\n        res.append(path[:])          # 把目前的子集加入結果\n        for i in range(start, len(nums)):\n            path.append(nums[i])     # 選擇 nums[i]\n            backtrack(i + 1, path)   # 進一步遞迴\n            path.pop()               # 取消選擇，回溯\n\n    backtrack(0, [])\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code to compute all subsets of unique integer array. Must use Start, End, Decision, arrows. No actual code, only virtual steps.\n\nLet's design a typical algorithm: backtracking recursion. Steps: Start, set result list, call backtrack function with index 0 and current subset. In backtrack: add current subset to result. If index == len(nums) return. Else, include nums[index] in subset and recurse; exclude it and recurse. Since all elements unique, no duplicate subsets.\n\nLet's produce lines: Start // 程式開始執行. Then define function? We'll use Step to define variables.\n\nBut we need to adhere to format: each line: \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nWe can include indentation via arrow. Use \"→\" for flow.\n\nWe can write:\n\nStart // 程式開始執行\n→ Step 1: nums ← input array // 取得輸入陣列\n→ Step 2: result ← empty list // 儲存所有子集\n→ Step 3: call Backtrack(index=0, current=empty list) // 開始遞迴\nThen define Backtrack function: We'll show as separate steps:\n\n→ Function Backtrack(index, current) // 遞迴處理每個位置\n    → Step 4: result.add(copy of current) // 加入目前子集\n    → Decision: index == len(nums)? // 是否已處理完所有元素\n        Yes → Return // 結束此路徑\n        No  → Step 5: current.add(nums[index]) // 包含此元素\n        → Step 6: call Backtrack(index+1, current) // 遞迴\n        → Step 7: current.removeLast() // 移除剛加入的元素\n        → Step 8: call Backtrack(index+1, current) // 跳過此元素\n→ End // 結束程式\n\nBut need each line exactly one line of virtual code and comment. For steps inside function, we need separate lines each preceded by arrow maybe indent. Use \"→\" then maybe tab? They didn't restrict indent but we can show as arrow again.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: nums ← input array // 取得輸入陣列\n→ Step 2: result ← empty list // 建立儲存子集的列表\n→ Step 3: Backtrack(0, empty list) // 以索引0開始遞迴\n\n→ Function Backtrack(idx, curr) // 參數 idx 為目前處理位置，curr 為目前子集\n    → Step 4: result.add(copy(curr)) // 將目前子集加入結果\n    → Decision: idx == len(nums)? // 是否已到達陣列結尾\n        Yes → Return // 結束此遞迴路徑\n        No  → Step 5: curr.add(nums[idx]) // 選擇加入 nums[idx]\n        → Step 6: Backtrack(idx+1, curr) // 進一步遞迴\n        → Step 7: curr.removeLast() // 移除剛加入的元素\n        → Step 8: Backtrack(idx+1, curr) // 不選擇 nums[idx]，直接遞迴\n→ End // 程式執行結束\n\nBut each line must be: virtual code + space + comment. In function, each line should be separate. But \"Function Backtrack\" line might be a virtual code step itself.\n\nWe must ensure each line is separate.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: nums ← input array // 取得輸入陣列\n→ Step 2: result ← empty list // 建立儲存子集的列表\n→ Step 3: Backtrack(0, empty list) // 以索引0開始遞迴\n\n→ Function Backtrack(idx, curr) // 參數 idx 為目前處理位置，curr 為目前子集\n→ Step 4: result.add(copy(curr)) // 將目前子集加入結果\n→ Decision: idx == len(nums)? // 是否已到達陣列結尾\n    Yes → Return // 結束此遞迴路徑\n    No  → Step 5: curr.add(nums[idx]) // 選擇加入 nums[idx]\n→ Step 6: Backtrack(idx+1, curr) // 進一步遞迴\n→ Step 7: curr.removeLast() // 移除剛加入的元素\n→ Step 8: Backtrack(idx+1, curr) // 不選擇 nums[idx]，直接遞迴\n\nEnd // 程式執行結束\n\nWe must keep arrows. For steps inside function, use arrow as well. For decisions, use arrow and indentation.\n\nBut the format expects \"虛擬碼步驟\" + space + comment. So lines must begin with some keyword, maybe \"→\" is part of virtual code step. We can include \"→\" at beginning. But we need to include Step numbering maybe. We'll keep \"→\" at beginning of each line. For function definition, we can do \"→ Function Backtrack(idx, curr)\". For decision, \"→ Decision: idx == len(nums)?\". Then indent lines inside decision with \"    Yes →\" etc.\n\nThus final output should be something like:\n\nStart // 程式開始執行\n→ Step 1: nums ← input array // 取得輸入陣列\n→ Step 2: result ← empty list // 建立儲存子集的列表\n→ Step 3: Backtrack(0, empty list) // 以索引0開始遞迴\n\n→ Function Backtrack(idx, curr) // 參數 idx 為目前處理位置，curr 為目前子集\n→ Step 4: result.add(copy(curr)) // 將目前子集加入結果\n→ Decision: idx == len(nums)? // 是否已到達陣列結尾\n    Yes → Return // 結束此遞迴路徑\n    No  → Step 5: curr.add(nums[idx]) // 選擇加入 nums[idx]\n→ Step 6: Backtrack(idx+1, curr) // 進一步遞迴\n→ Step 7: curr.removeLast() // 移除剛加入的元素\n→ Step 8: Backtrack(idx+1, curr) // 不選擇 nums[idx]，直接遞迴\n\nEnd // 程式執行結束\n\nEnsure each line has \"虛擬碼步驟\" then space then comment. That seems fine.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums ← input array // 取得輸入陣列  \n→ Step 2: result ← empty list // 建立儲存子集的列表  \n→ Step 3: Backtrack(0, empty list) // 以索引0開始遞迴  \n\n→ Function Backtrack(idx, curr) // 參數 idx 為目前處理位置，curr 為目前子集  \n→ Step 4: result.add(copy(curr)) // 將目前子集加入結果  \n→ Decision: idx == len(nums)? // 是否已到達陣列結尾  \n    Yes → Return // 結束此遞迴路徑  \n    No → Step 5: curr.add(nums[idx]) // 選擇加入 nums[idx]  \n→ Step 6: Backtrack(idx+1, curr) // 進一步遞迴  \n→ Step 7: curr.removeLast() // 移除剛加入的元素  \n→ Step 8: Backtrack(idx+1, curr) // 不選擇 nums[idx]，直接遞迴  \n\nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdu_uspuc.py\", line 63, in <module>\n    args = ast.literal_eval(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [ [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\n    ^\nSyntaxError: '[' was never closed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpdu_uspuc.py\", line 66, in <module>\n    parts = json.loads(data)\n            ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 83 (char 82)"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict, OrderedDict\nimport ast\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        # key -> (value, freq)\n        self.key_to_val_freq = {}\n        # freq -> OrderedDict of keys (maintains LRU order)\n        self.freq_to_keys = defaultdict(OrderedDict)\n\n    def _update(self, key: int):\n        value, freq = self.key_to_val_freq[key]\n        # remove key from its current frequency list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # add key to next frequency\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # evict LRU key from the min frequency list\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Split the two lists (operations and arguments)\n    try:\n        # handle input like '[\"op1\",\"op2\"], [[arg1], [arg2]]'\n        ops_part, args_part = data.split('],', 1)\n        ops_part += ']'\n        args_part = '[' + args_part\n        ops = ast.literal_eval(ops_part)\n        args = ast.literal_eval(args_part)\n    except Exception as e:\n        # fallback: try to parse as a single JSON array\n        parts = json.loads(data)\n        ops, args = parts[0], parts[1]\n    result = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            result.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            result.append(None)\n        elif op == \"get\":\n            val = cache.get(arg[0])\n            result.append(val)\n    # Output as JSON array (None -> null)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to output virtual code with each line \"虛擬碼步驟 // 解釋\". The code should represent an algorithm to implement LFUCache with O(1) average operations. Use typical solution: Use hash maps key->node, freq->LinkedHashSet of keys or doubly linked list nodes, and minFreq variable.\n\nStructure: Start, then define class with constructor, get, put. We need virtual steps for each method. Use arrows, decisions, etc.\n\nWe need to include steps for initialization, get, put, updating frequency, eviction, etc.\n\nWe'll produce step-by-step pseudo-code.\n\nLet's design steps:\n\nStart\n→ Step 1: Initialize capacity, minFreq, keyNodeMap, freqMap\nKeyNodeMap: key -> (value, freq)\nFreqMap: freq -> Ordered set of keys (or doubly linked list)\n→ End\n\nFor get(key):\n→ Step 1: If key not in keyNodeMap, return -1\n→ Step 2: Retrieve node\n→ Step 3: Update frequency: oldFreq = node.freq\n→ Step 4: Remove key from freqMap[oldFreq]\n→ Step 5: If oldFreq == minFreq and freqMap[oldFreq] empty, minFreq += 1\n→ Step 6: node.freq += 1\n→ Step 7: Add key to freqMap[node.freq] (at end)\n→ Step 8: Return node.value\n\nFor put(key, value):\n→ Step 1: If capacity <=0, return\n→ Step 2: If key exists: update value, then perform same freq update as get\n→ Step 3: Else: if size == capacity: evict\n    → Decision: if size == capacity?\n        Yes → Step 4: Find keyToEvict = first key in freqMap[minFreq] (LRU)\n        → Step 5: Remove keyToEvict from keyNodeMap\n        → Step 6: Remove keyToEvict from freqMap[minFreq]\n    → End\n→ Step 7: Create node with value, freq=1\n→ Step 8: Add node to keyNodeMap\n→ Step 9: Add key to freqMap[1] (at end)\n→ Step 10: Set minFreq = 1\n\nWe need to output these steps with explanation.\n\nWe should use the format exactly: each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to use Start, End, Decision: and arrow.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: 定義 LFUCache 類別 // 建立資料結構\n\n→ Step 2: 在建構子中初始化 capacity, minFreq, keyNodeMap, freqMap // 先備好所需集合\n\n→ Step 3: keyNodeMap: Map<key, Node(value, freq)> // 儲存鍵值及使用頻率\n\n→ Step 4: freqMap: Map<freq, LinkedHashSet<key>> // 同頻率鍵的有序集合\n\n→ Decision: if capacity <= 0? // 檢查容量有效性\n    Yes → End // 若無效則不執行\n\n→ End // 建構子結束\n\nNow define get:\n\n→ Step 1: get(key) // 方法開始\n    → Decision: if key 不在 keyNodeMap? // 檢查鍵是否存在\n        Yes → Step 2: Return -1 // 不存在直接返回\n        No  → Step 3: node = keyNodeMap[key] // 取得節點\n\n→ Step 4: oldFreq = node.freq // 取出舊頻率\n\n→ Step 5: Remove key from freqMap[oldFreq] // 從舊頻率集合移除\n\n→ Step 6: Decision: if oldFreq == minFreq AND freqMap[oldFreq] 為空? // 檢查是否需要調整最小頻率\n        Yes → minFreq += 1 // 更新 minFreq\n        No  → // 無需改動\n\n→ Step 7: node.freq += 1 // 更新節點頻率\n\n→ Step 8: Add key to freqMap[node.freq] (at tail) // 加入新頻率集合，保持 LRU\n\n→ Step 9: Return node.value // 返回值\n\nEnd // get 方法結束\n\nDefine put:\n\n→ Step 1: put(key, value) // 方法開始\n\n→ Decision: if capacity <= 0? // 容量為0時直接返回\n    Yes → End // 無操作\n\n→ Decision: if key 在 keyNodeMap? // 已存在鍵\n    Yes →\n        → Step 2: node = keyNodeMap[key]\n        → Step 3: node.value = value // 更新值\n        → Step 4: // 進行頻率更新（與 get 相同）\n        → Step 5: oldFreq = node.freq\n        → Step 6: Remove key from freqMap[oldFreq]\n        → Step 7: Decision: if oldFreq == minFreq AND freqMap[oldFreq] 為空?\n                Yes → minFreq += 1\n                No →\n        → Step 8: node.freq += 1\n        → Step 9: Add key to freqMap[node.freq]\n        → Step 10: End // put 完成\n    No →\n        → Decision: if keyNodeMap.size == capacity? // 是否已滿\n            Yes →\n                → Step 3: keyToEvict = first key in freqMap[minFreq] // LRU 在最小頻率集合\n                → Step 4: Remove keyToEvict from keyNodeMap\n                → Step 5: Remove keyToEvict from freqMap[minFreq]\n            No →\n        → Step 6: Create node = Node(value, freq=1) // 新節點\n        → Step 7: keyNodeMap[key] = node\n        → Step 8: Add key to freqMap[1] (at tail)\n        → Step 9: minFreq = 1 // 重設最小頻率\n        → Step 10: End\n\nEnd // put 方法結束\n\nFinally End // 程式結束\n\nWe need to ensure each line with arrow or decision.\n\nAlso must use proper indentation.\n\nLet's produce the final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 LFUCache 類別 // 建立資料結構\n→ Step 2: 在建構子中初始化 capacity, minFreq, keyNodeMap, freqMap // 先備好所需集合\n→ Step 3: keyNodeMap: Map<key, Node(value, freq)> // 儲存鍵值及使用頻率\n→ Step 4: freqMap: Map<freq, LinkedHashSet<key>> // 同頻率鍵的有序集合\n→ Decision: 如果 capacity <= 0? // 檢查容量有效性\n    Yes → End // 若無效則不執行\n→ End // 建構子結束\n\n→ Step 1: get(key) // 方法開始\n    → Decision: 如果 key 不在 keyNodeMap? // 檢查鍵是否存在\n        Yes → Step 2: Return -1 // 不存在直接返回\n        No  → Step 3: node = keyNodeMap[key] // 取得節點\n→ Step 4: oldFreq = node.freq // 取出舊頻率\n→ Step 5: Remove key from freqMap[oldFreq] // 從舊頻率集合移除\n→ Decision: 如果 oldFreq == minFreq AND freqMap[oldFreq] 為空? // 檢查是否需要調整最小頻率\n    Yes → minFreq += 1 // 更新 minFreq\n    No  → // 無需改動\n→ Step 6: node.freq += 1 // 更新節點頻率\n→ Step 7: Add key to freqMap[node.freq] (at tail) // 加入新頻率集合，保持 LRU\n→ Step 8: Return node.value // 返回值\n→ End // get 方法結束\n\n→ Step 1: put(key, value) // 方法開始\n    → Decision: 如果 capacity <= 0? // 容量為0時直接返回\n        Yes → End // 無操作\n    → Decision: 如果 key 在 keyNodeMap? // 已存在鍵\n        Yes →\n            → Step 2: node = keyNodeMap[key]\n            → Step 3: node.value = value // 更新值\n            → Step 4: // 進行頻率更新（與 get 相同）\n            → Step 5: oldFreq = node.freq\n            → Step 6: Remove key from freqMap[oldFreq]\n            → Decision: 如果 oldFreq == minFreq AND freqMap[oldFreq] 為空?\n                Yes → minFreq += 1\n                No  →\n            → Step 7: node.freq += 1\n            → Step 8: Add key to freqMap[node.freq]\n            → Step 9: End // put 完成\n        No →\n            → Decision: 如果 keyNodeMap.size == capacity? // 是否已滿\n                Yes →\n                    → Step 3: keyToEvict = first key in freqMap[minFreq] // LRU 在最小頻率集合\n                    → Step 4: Remove keyToEvict from keyNodeMap\n                    → Step 5: Remove keyToEvict from freqMap[minFreq]\n                No →\n            → Step 6: Create node = Node(value, freq=1) // 新節點\n            → Step 7: keyNodeMap[key] = node\n            → Step 8: Add key to freqMap[1] (at tail)\n            → Step 9: minFreq = 1 // 重設最小頻率\n            → Step 10: End\n→ End // put 方法結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,0,1,1,0,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 0, 1, 1, 0, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    \"\"\"\n    根據權重 w 建立前綴和，並在 pickIndex 時\n    以隨機數做二分搜尋得到符合權重比例的索引。\n    \"\"\"\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 產生 1~total 之間的隨機整數\n        target = random.randint(1, self.total)\n        # 找到第一個大於等於 target 的前綴和索引\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n    # 將兩個陣列包裝成一個 JSON，方便解析\n    data = json.loads('[' + raw + ']')\n    methods = data[0]\n    args_list = data[1]\n\n    # 結果清單，Constructor 產生 None（對應 LeetCode 的 null）\n    results = []\n    obj = None\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        elif method == \"pickIndex\":\n            results.append(obj.pickIndex())\n        else:\n            # 若有其他方法，先嘗試呼叫\n            res = getattr(obj, method)(*args)\n            results.append(res)\n\n    # 輸出結果，將 None 轉成 null，整體轉成 JSON 字串\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output pseudo-code lines for the algorithm to implement pickIndex. Likely steps: preprocess to prefix sums, random number generation, binary search. Use structure Start, Decision etc. Each line: code step + // explanation. Use virtual arrow arrow. Let's produce lines. We'll start with Start. Then Step: build prefix sums. Then Step: store total. Then Step: generate random between 0 and total-1. Then Decision: use binary search. Could include loop decision. We'll produce algorithm. Ensure each line has // explanation. Use arrows: \"→\". We'll need decisions. Let's do.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空陣列 prefix = [] // 用於儲存前綴和  \n→ Decision: 若 w 為空? // 檢查輸入是否合法  \n  Yes → Step 2: 把 prefix 設為空陣列並返回 // 若沒有權重則直接返回  \n  No → Step 3: 初始化 runningSum = 0 // 用於累加權重  \n    → Loop i 從 0 到 w.length - 1 // 遍歷所有權重  \n      runningSum = runningSum + w[i] // 更新累加和  \n      prefix.append(runningSum) // 儲存到前綴和陣列  \n    → Step 4: totalWeight = runningSum // totalWeight 是所有權重總和  \n    → Step 5: randomVal = randomInt(0, totalWeight - 1) // 產生隨機整數  \n    → Decision: 在 prefix 中尋找 first index where prefix[idx] > randomVal? // 二分搜尋  \n      Yes → Step 6: return idx // 回傳找到的索引  \n      No → Step 7: return prefix.length - 1 // 若未找到，回傳最後一個索引  \nEnd // 程式執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2r450k_e.py\", line 29, in <module>\n    mat = ast.literal_eval(expr.strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpn9ql2a2y.py\", line 29, in <module>\n    mat = ast.literal_eval(expr.strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()\n        return [i for _, i in soldiers[:k]]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    mat = None\n    k = None\n    # 將輸入拆成以逗號分隔的片段，無論是單行還是多行輸入都能處理\n    parts = [p.strip() for p in data.split(',')]\n    for p in parts:\n        if p.startswith('mat'):\n            _, expr = p.split('=', 1)\n            mat = ast.literal_eval(expr.strip())\n        elif p.startswith('k'):\n            _, expr = p.split('=', 1)\n            k = int(expr.strip())\n\n    # 若輸入中 mat 與 k 不是分行，而是放在同一行，還要處理\n    if mat is None or k is None:\n        # 直接嘗試把整個輸入解析為兩個值\n        try:\n            # 例子: 'mat = [[1,1,0],[1,0,0]], k = 2'\n            for part in data.split('mat ='):\n                if 'k =' in part:\n                    mat_part, k_part = part.split('k =')\n                    mat = ast.literal_eval(mat_part.strip())\n                    k = int(k_part.strip())\n                    break\n        except Exception:\n            pass\n\n    solution = Solution()\n    result = solution.kWeakestRows(mat, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode, line by line, with explanation comment after space. Use arrows, decisions. Provide steps to compute k weakest rows. Use counting soldiers per row (binary search because rows sorted). Then sort by strength (count, index). Then take first k indices. Pseudocode steps. No actual code. Provide steps like:\n\nStart\n→ Step 1: Initialize array soldiersCount of size m\n→ For each row i from 0 to m-1:\n    → Use binary search to find first zero → assign count\n→ Step 2: Create list of pairs (count, index)\n→ Step 3: Sort list by count ascending, then index ascending\n→ Step 4: Extract first k indices\n→ End\n\nWe should incorporate decision branches. Provide details like \"Decision: If current element is 1?\" etc. Use arrow for binary search. Provide explanation.\n\nLet's output with line by line. Ensure each line includes \"虛擬碼步驟\" + space + \"// 解釋\". Use \"Start\", \"End\". Use arrow \"→\". For loops, we might indicate as \"→ For i in 0..m-1:\". Use indentation but maintain arrow. Provide decisions. Provide explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 創建陣列 soldiersCount[0…m-1] 用於存儲每行的士兵數量 // 準備儲存每行士兵數  \n→ For i in 0…m-1: // 遍歷每一行  \n  → Decision: 如果 mat[i][0] 為 0? // 檢查第一個元素是否已為平民，整行無士兵  \n    Yes → soldiersCount[i] ← 0 // 直接設為 0  \n    No → // 至少有一名士兵，使用二分搜尋找第一個 0  \n     → Step 2: low ← 0, high ← n  \n     → While low < high: // 二分搜尋  \n       → Decision: 如果 mat[i][mid] 為 1? // mid = (low+high)//2  \n         Yes → low ← mid + 1 // 士兵在右側，搜索右半段  \n         No  → high ← mid // 0 在左側，搜索左半段  \n       → End While  \n      → soldiersCount[i] ← low // low 為第一個 0 的位置，即士兵數量  \n→ End For  \n→ Step 3: 建立列表 pairs，將 (soldiersCount[i], i) 依序加入 // 創建 (士兵數, 行索引) 的對  \n→ Step 4: Sort pairs 按照第一項升序，若相同則按第二項升序 // 先依士兵數，後依行號  \n→ Step 5: 創建結果列表 weakestIndices  \n→ For j in 0…k-1: // 取前 k 個最弱行  \n  → weakestIndices ← weakestIndices ∪ [pairs[j].index] // 加入對應行索引  \n→ End For  \n→ Step 6: 返回 weakestIndices // 完成輸出  \nEnd // 程式執行結束"
    }
  ]
}