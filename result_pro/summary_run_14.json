{
  "run_index": 14,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 390,
  "generation_or_validation_failure_count": 49,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取 stdin（若無輸入即立即返回空字串），不會影響後續邏輯\n    _ = sys.stdin.read()\n\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with explanation. Use Start, End, Decision, with arrow etc. The virtual code steps: Start, → Step 1: define file path etc. Then with try/except. Within with open. Count lines. If exception FileNotFoundError: output message. Use Decision to show flow.\n\nWe need to output as per format. No actual code, just virtual steps.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 設定檔名 'data.txt' // 定義要開啟的檔案名稱\n→ Step 2: 開始 try 區塊 // 嘗試執行可能失敗的檔案開啟\n    → Decision: 是否發生 FileNotFoundError? // 檢查是否捕捉到檔案不存在的錯誤\n        Yes → Step 3: 輸出 '找不到檔案！' // 檔案不存在時顯示錯誤訊息\n        No  → Step 4: 使用 with open(file, 'r') as f: // 正常開啟檔案並確保關閉\n            → Step 5: 設定 line_count = 0 // 初始化行數計數\n            → Step 6: 迭代每一行 in f // 逐行讀取檔案內容\n                → Step 7: line_count = line_count + 1 // 每讀到一行計數加一\n            → Step 8: 輸出 line_count // 顯示總行數\nEnd // 程式執行結束\n\nBut need to incorporate with syntax: Step 4: with open(file, 'r') as f: // context manager ensures closure\n\nWe need to maintain hierarchical indentation? We can simply list steps. Use arrow with nested steps.\n\nBetter to include \"Decision:\" lines with Yes → and No →.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Step 1: 設定 file_path = 'data.txt' // 定義要開啟的檔案路徑\n→ Decision: 是否已知檔案存在? // 檢查檔案是否存在\n    Yes → Step 2: 使用 with open(file_path, 'r') as f: // 開啟檔案並自動關閉\n        → Step 3: 設定 line_count = 0 // 初始化計數器\n        → Step 4: 迭代 f 讀取每一行 // 逐行遍歷\n            → Step 5: line_count += 1 // 計算行數\n        → Step 6: 輸出 line_count // 顯示總行數\n    No  → Decision: 試圖開啟檔案會拋出 FileNotFoundError? // 捕捉例外\n        Yes → Step 7: 輸出 '找不到檔案！' // 顯示錯誤訊息\n        No  → End // 未定義其他錯誤，結束\n\nBut requirement says: use try/except. So we need Step 1: try block, Step 2: with open..., Step 3: count etc. Step 4: except FileNotFoundError: print message. So:\n\nStart\n→ Step 1: try // 開始 try 區塊\n    → Step 2: with open(file_path, 'r') as f: // 開啟檔案\n        → Step 3: 設定 line_count = 0\n        → Step 4: 逐行 for line in f: // 迭代\n            → Step 5: line_count += 1\n        → Step 6: 輸出 line_count\n→ except FileNotFoundError: // 捕捉檔案不存在錯誤\n    → Step 7: 輸出 '找不到檔案！'\nEnd\n\nAlso we might add Decision at the beginning for file existence? Not needed if try/except. But to satisfy decision maybe not necessary. But we can add Decision: 嘗試開啟檔案? No.\n\nLet's produce final output accordingly.\n\nEnsure each line: virtual step + space + // 解釋.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 設定 file_path = 'data.txt' // 定義檔案路徑\n→ Step 2: try // 開始 try 區塊，處理可能的檔案不存在錯誤\n    → Step 3: with open(file_path, 'r') as f: // 使用 with 開啟檔案，確保自動關閉\n        → Step 4: 設定 line_count = 0 // 初始化行數計數器\n        → Step 5: for each line in f: // 逐行遍歷檔案\n            → Step 6: line_count += 1 // 每讀到一行就加一\n        → Step 7: 輸出 line_count // 輸出總行數\n→ except FileNotFoundError: // 捕捉檔案不存在的例外\n    → Step 8: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd // 程式執行結束\n\nBut we need arrow indentation: Use → for each step. Indent steps inside try? Use nested arrows? In example, they used indented blocks: \"→ Decision: ...\" then Yes → Step. They used indentation of two spaces? They used tab? Let's mimic.\n\nLet's format like:\n\nStart // 程式開始執行\n→ Step 1: 設定 file_path = 'data.txt' // 定義檔案路徑\n→ Step 2: try // 開始 try 區塊\n    → Step 3: with open(file_path, 'r') as f: // 開啟檔案\n        → Step 4: 設定 line_count = 0 // 初始化計數器\n        → Step 5: for line in f: // 逐行讀取\n            → Step 6: line_count += 1 // 計數\n        → Step 7: 輸出 line_count // 顯示總行數\n→ except FileNotFoundError: // 捕捉檔案不存在錯誤\n    → Step 8: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd // 程式執行結束\n\nThis matches requirement.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 file_path = 'data.txt' // 定義檔案路徑  \n→ Step 2: try // 開始 try 區塊  \n  → Step 3: with open(file_path, 'r') as f: // 使用 with 開啟檔案，確保自動關閉  \n    → Step 4: 設定 line_count = 0 // 初始化行數計數器  \n    → Step 5: for line in f: // 逐行讀取檔案內容  \n      → Step 6: line_count += 1 // 每讀到一行就計數加一  \n    → Step 7: 輸出 line_count // 顯示總行數  \n→ except FileNotFoundError: // 捕捉檔案不存在錯誤  \n  → Step 8: 輸出 '找不到檔案！' // 顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[2,2,2,2,1]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[2, 2, 2, 2, 1]'"
        }
      ],
      "generated_code": "import random\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳所有結果的串列。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    # 讀取全部標準輸入，並直接執行（允許使用者輸入任何合法的 Python 程式碼）\n    code = sys.stdin.read()\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Each line: \"虛擬碼步驟 [space] // 解釋\". Use arrow, Start, End, Decision. The code is to write a function roll_dice(n) using random module to simulate rolling n six-sided dice, return list of results.\n\nWe'll produce steps: import random, define function, initialize list, loop n times, generate random integer 1-6, append to list, return list, End. Use Start/End.\n\nEnsure each line with arrow \"→\" or \"Start\", \"End\", \"Decision:\" if needed. No actual code, just virtual.\n\nLet's write:\n\nStart // 開始流程\n→ ImportModule random // 匯入 random 模組\n→ FunctionDef roll_dice(n) // 定義函式 roll_dice 參數 n\n    → InitList results = [] // 建立空列表儲存結果\n    → Loop i from 1 to n // 重複 n 次擲骰\n        → Decision: 是否已擲完 n 次? // 判斷是否完成\n            Yes → EndLoop // 結束循環\n            No → Step: roll = random.randint(1,6) // 擲出 1-6 的隨機數\n            → Append roll to results // 加入列表\n    → Return results // 回傳結果列表\nEnd // 程式結束\n\nWe need each line separate. Ensure arrows and indentation? Virtual code: can use arrows per line. Indentation with spaces maybe.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ ImportModule random // 匯入 random 模組\n→ FunctionDef roll_dice(n) // 定義函式 roll_dice，參數 n\n    → InitList results = [] // 建立空列表儲存所有擲骰結果\n    → Loop i from 1 to n // 進行 n 次擲骰\n        → Decision: 是否已擲完 n 次? // 檢查是否已完成所有擲骰\n            Yes → EndLoop // 結束循環\n            No  → Step: roll = random.randint(1,6) // 擲出 1 至 6 的隨機數\n            → Append roll to results // 將擲骰結果加入列表\n    → Return results // 回傳包含所有擲骰結果的列表\nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"apple\",\"grape\",\"melon\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'apple', 'grape', 'melon', 'orange'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取並忽略任何輸入，因為此題無需使用者輸入\n    sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 新增 'orange'\n    fruits.add('orange')\n\n    # 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 移除 'banana'\n    fruits.remove('banana')\n\n    # 嘗試移除不存在的 'pineapple'\n    fruits.discard('pineapple')\n\n    # 輸出結果\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, each line has `虛擬碼步驟` + space + `// 解釋`. Use Start, End, Decision? No decisions needed. Just sequential steps. Use arrows →. The lines: Start, initialize set, add, update, remove, discard, print, End.\n\nFollow format exactly. No real code, just virtual code. Use steps like `Step 1: 初始化 fruits 集合` etc. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 fruits = {'apple', 'banana'} // 建立一個包含 'apple' 與 'banana' 的集合  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除 'pineapple'（不存在時不拋錯誤）  \n→ Step 6: 輸出 fruits // 將最終集合輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.71TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.71 TWD'"
        }
      ],
      "generated_code": "import requests\nimport tkinter as tk\nimport sys\n\ndef get_rate():\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=5)\n        data = r.json()\n        return data['rates'].get('TWD')\n    except Exception:\n        return None\n\ndef start_gui():\n    win = tk.Tk()\n    win.title('匯率查詢')\n\n    label = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    def update():\n        rate = get_rate()\n        if rate is not None:\n            label.config(text=f'目前美元匯率：約 {rate:.2f} TWD')\n        else:\n            label.config(text='更新失敗，請檢查網路連線')\n\n    tk.Button(win, text='更新匯率', command=update).pack(pady=5)\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    # 讀取輸入\n    input_text = sys.stdin.read().strip()\n    # 若輸入為更新命令，則執行查詢並輸出結果\n    if '按下「更新匯率」按鈕' in input_text:\n        rate = get_rate()\n        if rate is not None:\n            print(f'目前美元匯率：約 {rate:.2f} TWD')\n        else:\n            print('更新失敗，請檢查網路連線')\n    else:\n        # 未輸入更新命令時啟動 GUI\n        start_gui()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation, using arrows, Start, End, Decision. Should cover imports, create tkinter root, button, label, function to fetch using requests, update label. Also handle exceptions. Use decision to check response status. Show updating. Provide line-by-line. Should not output real code, just virtual steps. Use Chinese comments. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 requests 與 tkinter 模組 // 引入網路請求和 GUI 库  \n→ Step 2: 初始化 tkinter 主視窗 // 建立 GUI 視窗框架  \n→ Step 3: 建立顯示匯率的 Label 控制項 // 用來顯示 TWD 匯率  \n→ Step 4: 建立 '更新匯率' 按鈕 // 用戶點擊觸發匯率更新  \n→ Step 5: 定義 fetch_rate 函式 // 負責向 API 發送請求並取得匯率  \n    → Decision: 是否能連接到 https://api.exchangerate-api.com/v4/latest/USD? // 檢查網路可達性  \n        Yes → Step 6: 送出 GET 請求並等待回應 // 取得 JSON 資料  \n        No  → Step 7: 設定 Label 顯示 '連線失敗' // 提示使用者無法連線  \n    → Decision: 回應 HTTP 狀態碼是否為 200? // 確認回應成功  \n        Yes → Step 8: 解析 JSON 取得 'rates' 字典 // 擷取匯率資料  \n        No  → Step 9: 設定 Label 顯示 '錯誤回應' // 提示 API 回傳錯誤  \n    → Decision: 'TWD' 是否存在於 rates? // 檢查是否有台幣匯率  \n        Yes → Step 10: 取出 TWD 匯率並格式化顯示在 Label 上 // 顯示最新匯率  \n        No  → Step 11: 設定 Label 顯示 '未找到 TWD 匯率' // 提示資料缺失  \n→ Step 12: 將 fetch_rate 綁定到按鈕點擊事件 // 讓按鈕能呼叫函式  \n→ Step 13: 進入 tkinter 事件迴圈 // 啟動 GUI，等待使用者操作  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass RandomizedSet:\n    \"\"\"實現一個能在平均 O(1) 時間完成插入、刪除及隨機取值的集合。\"\"\"\n    def __init__(self):\n        # value -> index in self.values\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.val_to_index:\n            return False\n        # 把要刪除的元素與最後一個元素交換，然後刪除最後一個\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.values)\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入: 兩個頂層列表，格式為 <ops> , <args>\n    # 先尋找第一個 '],' 作為兩個列表的分隔\n    split_pos = data.find('],')\n    if split_pos == -1:\n        # 如果找不到分隔，直接嘗試解析整個字串為兩個列表\n        ops_list, args_list = ast.literal_eval(data)\n    else:\n        ops_str = data[:split_pos + 1]          # 包含第一個列表及其結束']'\n        args_str = data[split_pos + 2:].strip() # 從第二個列表開始\n        ops_list = ast.literal_eval(ops_str)\n        args_list = ast.literal_eval(args_str)\n\n    result = []\n    rs = None  # RandomizedSet 實例\n\n    for op, args in zip(ops_list, args_list):\n        if op == \"RandomizedSet\":\n            rs = RandomizedSet()\n            result.append(None)\n        elif op == \"insert\":\n            res = rs.insert(args[0])\n            result.append(res)\n        elif op == \"remove\":\n            res = rs.remove(args[0])\n            result.append(res)\n        elif op == \"getRandom\":\n            res = rs.getRandom()\n            result.append(res)\n        else:\n            # 若有未知操作，加入 None 以保持索引對應\n            result.append(None)\n\n    # 輸出結果，使用 json.dumps 以符合 LeetCode 的輸出格式\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each with \"虛擬碼步驟 // 解釋\". For RandomizedSet class with insert, remove, getRandom. Use data structures: hash map value->index in array, and array (list) of values. Each operation O(1). We'll produce algorithm steps.\n\nWe need to describe class initialization, insert, remove, getRandom.\n\nUse Start and End. Use Decision. Use Yes/No arrow.\n\nLet's produce virtual code. Ensure each line ends with // explanation. Use \"→\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 RandomizedSet 物件 // 初始化資料結構\n    → HashMap ← {} // 存放元素值到陣列索引的映射\n    → Array ← []   // 存放所有元素以便隨機存取\n→ End // 初始化完成\n\n→ Function: insert(val) // 插入元素\n    → Decision: HashMap 內是否已含 val? // 檢查元素是否存在\n        Yes → Return False // 已存在，插入失敗\n        No  → Step 2: Array.append(val) // 將 val 加到陣列尾端\n             → Step 3: HashMap[val] ← Array.length-1 // 記錄索引\n             → Return True // 插入成功\n\n→ Function: remove(val) // 刪除元素\n    → Decision: HashMap 內是否已含 val? // 檢查元素是否存在\n        Yes → Step 4: lastVal ← Array.last // 取得陣列最後一個元素\n             → Step 5: lastIndex ← HashMap[lastVal] // 取得其索引\n             → Step 6: Array[lastIndex] ← val // 用 val 覆蓋最後一個位置\n             → Step 7: HashMap[val] ← lastIndex // 更新 val 的索引\n             → Step 8: Array.pop() // 刪除陣列最後一個元素\n             → Step 9: HashMap.remove(val) // 移除 val 的映射\n             → Return True // 刪除成功\n        No  → Return False // 元素不存在，刪除失敗\n\n→ Function: getRandom() // 取得隨機元素\n    → Step 10: randomIndex ← Random(0, Array.length-1) // 隨機索引\n    → Step 11: Return Array[randomIndex] // 返回對應元素\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[2,0],[1,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [2, 0], [1, 0], null, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, n_rows, n_cols):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Split the two lists: commands and arguments\n    parts = data.split('],', 1)\n    commands_str = parts[0] + ']'\n    args_str = parts[1]\n\n    commands = ast.literal_eval(commands_str)\n    args_list = ast.literal_eval(args_str)\n\n    result = []\n    sol = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            sol = Solution(*args)\n            result.append(None)\n        elif cmd == \"flip\":\n            result.append(sol.flip())\n        elif cmd == \"reset\":\n            sol.reset()\n            result.append(None)\n        else:\n            # Unknown command, append None\n            result.append(None)\n\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps explaining algorithm for random flipping without bias, minimize random calls, optimize time and space. Classic problem: Matrix Flip (LeetCode 519). Approach: treat matrix as 1D array size m*n. Maintain mapping from index to value for used indices, or use reservoir mapping.\n\nWe implement Solution class with m, n, total m*n, list of remaining = total, mapping dict for used indices to remaining. For flip: pick random integer r in [0, remaining-1], decrement remaining, map r to the value at remaining-1 in mapping or itself. Use mapping to simulate swapping. Return r converted to (i,j). reset: clear mapping, set remaining to total.\n\nLet's write virtual code line by line with explanations.\n\nNeed to use virtual code syntax: Start, → Step, → Decision, Yes →, No →, End.\n\nLet's create:\n\nStart\n→ Step 1: Initialize total = m * n, remaining = total, mapping = empty dict // 1D index mapping\n→ Step 2: flip() function\n    → Decision: remaining == 0? // all flipped\n        Yes → return null or error\n        No  →\n            → Step 3: r = random integer [0, remaining-1] // pick random available index\n            → Step 4: remaining = remaining - 1 // one less available\n            → Decision: mapping contains r? // find mapped value\n                Yes → val = mapping[r]\n                No  → val = r\n            → Decision: mapping contains remaining? // value to replace r\n                Yes → newVal = mapping[remaining]\n                No  → newVal = remaining\n            → Step 5: mapping[r] = newVal // update mapping to maintain set\n            → Step 6: return [val // n, val % n] // convert to 2D coordinates\n→ Step 7: reset() function\n    → Step 8: mapping = empty dict\n    → Step 9: remaining = total\nEnd\n\nBut we need to format with arrows and each line with explanation. Each line separate.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: Initialize total = m * n, remaining = total, mapping = {} // 1D representation of matrix\n→ Step 2: flip() function // 主函式：隨機翻轉 0 為 1\n    → Decision: remaining == 0? // 是否已全部翻轉\n        Yes → return null // 沒有可翻轉格子\n        No  →\n            → Step 3: r = random(0, remaining-1) // 隨機選取一個可用索引\n            → Step 4: remaining = remaining - 1 // 可用格子數減 1\n            → Decision: mapping.contains(r)? // r 是否已映射\n                Yes → val = mapping[r]\n                No  → val = r\n            → Decision: mapping.contains(remaining)? // 需要交換的索引是否映射\n                Yes → newVal = mapping[remaining]\n                No  → newVal = remaining\n            → Step 5: mapping[r] = newVal // 更新映射以保留未翻轉格子集合\n            → Step 6: return [val // n, val % n] // 轉換回 (i, j)\n→ Step 7: reset() function // 重置矩陣\n    → Step 8: mapping = {} // 清空映射\n    → Step 9: remaining = total // 恢復可用格子數\nEnd // 程式結束\n\nBut we must ensure each line ends with // explanation. Also maintain indentation for decisions? The format example uses indentation to indicate nested steps. We'll follow similar.\n\nAlso note that random(0, remaining-1) counts as one random call.\n\nNow produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Initialize total = m * n, remaining = total, mapping = {} // 以一維方式表示整個 m×n 二元矩陣，mapping 用於記錄已被隨機挑選的索引映射\n→ Step 2: flip() function // 主功能：隨機挑選一個矩陣中仍為 0 的位置並將其翻轉為 1\n    → Decision: remaining == 0? // 檢查是否所有格子已被翻轉\n        Yes → return null // 沒有可翻轉格子，返回空值或適當的錯誤訊息\n        No  →\n            → Step 3: r = random(0, remaining-1) // 隨機挑選一個在 [0, remaining-1] 範圍內的索引，代表一個尚未被翻轉的格子\n            → Step 4: remaining = remaining - 1 // 可用格子數減 1，準備進行交換\n            → Decision: mapping.contains(r)? // 判斷 r 是否已在映射表中\n                Yes → val = mapping[r] // 若已映射，取得映射後的實際索引\n                No  → val = r          // 若未映射，直接使用 r 作為實際索引\n            → Decision: mapping.contains(remaining)? // 判斷剩餘索引 remaining 是否已映射\n                Yes → newVal = mapping[remaining] // 若已映射，取得其映射後的實際索引\n                No  → newVal = remaining        // 若未映射，直接使用 remaining 作為實際索引\n            → Step 5: mapping[r] = newVal // 更新映射表，將 r 對應到 newVal，保持剩餘可選索引集合的完整性\n            → Step 6: return [val // n, val % n] // 以 (row, column) 的形式返回實際索引\n→ Step 7: reset() function // 重置功能：將所有格子恢復為 0\n    → Step 8: mapping = {} // 清空映射表\n    → Step 9: remaining = total // 將剩餘可選格子數恢復為總格子數\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxd5j03es.py\", line 77, in <module>\n    main()\n  File \"/tmp/tmpxd5j03es.py\", line 46, in main\n    args_list = json.loads(args_str)\n                ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 79 (char 78)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words_by_len = {}\n\n    def buildDict(self, dictionary):\n        self.words_by_len.clear()\n        for word in dictionary:\n            l = len(word)\n            self.words_by_len.setdefault(l, []).append(word)\n\n    def search(self, searchWord):\n        l = len(searchWord)\n        if l not in self.words_by_len:\n            return False\n        for word in self.words_by_len[l]:\n            diff = 0\n            for a, b in zip(word, searchWord):\n                if a != b:\n                    diff += 1\n                    if diff > 1:\n                        break\n            if diff == 1:\n                return True\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split the two JSON arrays: commands and arguments\n    sep_index = data.find('],[')\n    if sep_index == -1:\n        # Maybe input has newlines or spaces; try to find the split more robustly\n        parts = data.split('],', 1)\n        commands_str = parts[0] + ']'\n        args_str = '[' + parts[1]\n    else:\n        commands_str = data[:sep_index + 1]\n        args_str = data[sep_index + 2:]  # skip '],['\n\n    commands = json.loads(commands_str)\n    args_list = json.loads(args_str)\n\n    res = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MagicDictionary\":\n            obj = MagicDictionary()\n            res.append(None)\n        elif cmd == \"buildDict\":\n            obj.buildDict(args[0])\n            res.append(None)\n        elif cmd == \"search\":\n            res.append(obj.search(args[0]))\n        else:\n            # Unknown command; append None as placeholder\n            res.append(None)\n\n    # Convert Python result to JavaScript-like output\n    out_items = []\n    for v in res:\n        if v is None:\n            out_items.append('null')\n        elif v is True:\n            out_items.append('true')\n        elif v is False:\n            out_items.append('false')\n        else:\n            out_items.append(str(v))\n    print(f\"[{', '.join(out_items)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. We must design the algorithm: building dictionary and search with exactly one edit. Approach: store words by length in map length->list. For search, iterate over words of same length, count differences. Return true if any word diff==1. Complexity: O(total words * avg length). Use early break. Provide steps. Virtual code lines: Start, Step 1: init, Step 2: buildDict, Step 3: search, etc.\n\nLet's produce code.\n\nNote: use \"Decision\" for loops and conditions. Use arrow \"→\". Provide explanations.\n\nLet's craft.\n\nAlso we must follow exact output format: each line with virtual code step + space + // explanation.\n\nUse Start, End. Provide Step lines for methods.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 宣告 MagicDictionary 類別 // 定義資料結構\n→ Step 2: 建立一個 HashMap<整數, 陣列列表> lengthDict // 以字串長度索引單字\n→ Step 3: 建立建構子 MagicDictionary() // 初始化空字典\n    → Action: lengthDict ← 空 HashMap // 初始化空資料結構\n→ Step 4: 方法 buildDict(dictionary: String[]) // 建立字典\n    → Action: 清空 lengthDict // 重新建立\n    → Loop: for 每個 word in dictionary // 逐字處理\n        → Action: len ← word.length() // 取得長度\n        → Decision: 如果 len 在 lengthDict? // 判斷長度鍵是否存在\n            Yes → Step 5: list ← lengthDict[len] // 取現有列表\n            No  → Step 6: list ← 新建空列表 // 建立新列表\n                → Step 7: lengthDict[len] ← list // 儲存列表\n        → Action: list.add(word) // 加入單字\n→ Step 8: 方法 search(searchWord: String) // 搜尋功能\n    → Action: len ← searchWord.length() // 取得搜尋字串長度\n    → Decision: 如果 len 不在 lengthDict? // 若長度不存在，無法匹配\n        Yes → Step 9: return false // 直接返回\n        No  → Step 10: list ← lengthDict[len] // 取得同長度單字列表\n    → Loop: for 每個 word in list // 逐字比較\n        → Action: diffCount ← 0 // 初始化差異計數\n        → Loop: for i from 0 to len-1 // 逐字元比較\n            → Decision: 如果 searchWord[i] ≠ word[i]? // 位置不同\n                Yes → Step 11: diffCount++ // 增加差異數\n                No  →  // 無變化\n            → Decision: 如果 diffCount > 1? // 超過一個差異\n                Yes → Step 12: 跳過此 word // 結束內層迴圈\n        → Decision: 如果 diffCount == 1? // 恰好一個差異\n            Yes → Step 13: return true // 找到符合條件\n    → Step 14: return false // 所有字皆不符合\nEnd // 程式執行結束"
    },
    {
      "title": "Heaters",
      "source_file": "Leetcode/leetcode475.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "houses = [1,2,3], heaters = [2]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplyl1yv_l.py\", line 24, in <module>\n    houses_heaters = eval(\"{\" + data + \"}\")\n                     ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {houses = [1,2,3], heaters = [2]}\n     ^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "houses = [1,2,3,4], heaters = [1,4]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3e0gw94t.py\", line 24, in <module>\n    houses_heaters = eval(\"{\" + data + \"}\")\n                     ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {houses = [1,2,3,4], heaters = [1,4]}\n     ^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "houses = [1,5], heaters = [2]",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy5ygvzo0.py\", line 24, in <module>\n    houses_heaters = eval(\"{\" + data + \"}\")\n                     ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {houses = [1,5], heaters = [2]}\n     ^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass Solution:\n    def findRadius(self, houses, heaters):\n        houses.sort()\n        heaters.sort()\n        res = 0\n        for house in houses:\n            idx = bisect.bisect_left(heaters, house)\n            nearest = float('inf')\n            if idx < len(heaters):\n                nearest = min(nearest, heaters[idx] - house)\n            if idx > 0:\n                nearest = min(nearest, house - heaters[idx - 1])\n            res = max(res, nearest)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data:\n        # 解析類似 \"houses = [1,2,3], heaters = [2]\" 的輸入\n        # 用 eval 建立字典\n        houses_heaters = eval(\"{\" + data + \"}\")\n        houses = houses_heaters.get('houses', [])\n        heaters = houses_heaters.get('heaters', [])\n        ans = Solution().findRadius(houses, heaters)\n        print(ans)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode in structured steps with arrows, using the format described. We need to produce steps to compute minimal radius needed for heaters to cover all houses. The problem: given arrays houses and heaters positions on line, find minimal radius r such that every house is within distance r from some heater. Approach: for each house, find nearest heater distance; maximum of those distances is answer. Use two pointers or binary search or sort both arrays, then for each house find nearest heater with binary search.\n\nWe need to output pseudo-code, step by step, each line with explanation. Use arrow and decision nodes.\n\nWe must not output actual code, only virtual steps.\n\nOk, let's produce. Let's start with Start, input houses and heaters arrays. Then sort both arrays. Then for each house, find nearest heater: we can use binary search to find insertion point. Compute distance to left heater (if exists) and right heater (if exists). The minimal distance is min of those. Keep track of maxDist. Finally output maxDist.\n\nWe'll need decisions and loops.\n\nWe'll structure like:\n\nStart // 程式開始執行\n\n→ Step 1: 讀取 houses 與 heaters 陣列 // 取得輸入\n\n→ Step 2: 將 houses 排序 // 為方便後續處理\n\n→ Step 3: 將 heaters 排序 // 同樣排序\n\n→ Step 4: 初始化 maxRadius = 0 // 以便累計最大距離\n\n→ Step 5: 對於每個 house 在 houses 內進行迴圈 // 逐一檢查每座房子\n\n→ Decision: 以 binary search 找出 heater 在 heaters 中的插入位置 idx // idx 為第一个大於 house 的 heater\n\n    → Step 6: 計算左側 heater 距離 leftDist = house - heaters[idx-1] // 若 idx >0\n\n    → Step 7: 計算右側 heater 距離 rightDist = heaters[idx] - house // 若 idx < len\n\n    → Step 8: 確定此 house 的最近距離 nearest = min( leftDist, rightDist ) // 取最近\n\n    → Step 9: 更新 maxRadius = max( maxRadius, nearest ) // 取最大\n\n→ Step 10: 輸出 maxRadius // 最終結果\n\nEnd\n\nWe must format each line with \"虛擬碼步驟 // 解釋\". Need arrow \"→\". For decision we use \"Decision:\" etc. Use \"Yes →\", \"No →\" when decisions inside, but we can treat binary search result as decision. But we can present a decision to compute leftDist only if idx>0; else skip. But we may skip details and just note. But we need to include decision branches for leftDist and rightDist maybe.\n\nBetter to incorporate decisions:\n\nDecision: idx > 0? // 是否存在左邊 heater\n\nYes → Step 6: 計算 leftDist = house - heaters[idx-1]\n\nNo  → Step 6: leftDist = Infinity // 表示不存在\n\nDecision: idx < len(heaters)? // 是否存在右邊 heater\n\nYes → Step 7: 計算 rightDist = heaters[idx] - house\n\nNo  → Step 7: rightDist = Infinity\n\nStep 8: nearest = min(leftDist, rightDist)\n\nStep 9: maxRadius = max(maxRadius, nearest)\n\nOk.\n\nWe need to include \"→ Decision:\" lines.\n\nLet's produce full pseudo code lines accordingly.\n\nWe need to ensure each line ends with // 解釋.\n\nLet's write.\n\nAlso we need to use \"Start\" and \"End\". We need to maintain the arrow style: \"→\" at beginning of each step. For decisions: \"Decision:\" then indent \"Yes →\" and \"No →\" lines.\n\nOk.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 houses 與 heaters 陣列 // 取得輸入資料  \n→ Step 2: 將 houses 排序 // 方便之後使用二分搜尋  \n→ Step 3: 將 heaters 排序 // 使 heater 位置有序  \n→ Step 4: 初始化 maxRadius = 0 // 用來記錄最遠距離  \n→ Step 5: 迴圈遍歷每個 house 於 houses 內 // 檢查每座房子  \n  → Decision: 使用二分搜尋找出 heaters 中第一個大於 house 的位置 idx // 插入點  \n    Yes → Step 6: 計算左側 heater 距離 leftDist = house - heaters[idx-1] // 若存在左邊 heater  \n    No  → Step 6: leftDist = Infinity // 無左側 heater  \n    Yes → Step 7: 計算右側 heater 距離 rightDist = heaters[idx] - house // 若存在右邊 heater  \n    No  → Step 7: rightDist = Infinity // 無右側 heater  \n  → Step 8: nearest = min(leftDist, rightDist) // 取得此 house 最近的 heater 距離  \n  → Step 9: maxRadius = max(maxRadius, nearest) // 更新最大的距離  \n→ Step 10: 輸出 maxRadius // 最終得到最小的加熱半徑  \nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_04vh5h6.py\", line 69, in <module>\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_04vh5h6.py\", line 20, in __init__\n    self.lookup[(prefix, suffix)] = idx   # 只要更新，最後留下的就是最大的索引\n    ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    \"\"\"\n    WordFilter 可以依照前綴(prefix)和後綴(suffix)查詢字典中符合條件的單字。\n    在建構時，將每個單字的所有前綴和後綴組合都存入雜湊表，\n    這樣查詢時只需 O(1) 時間即可取得最大的索引值。\n    \"\"\"\n    def __init__(self, words):\n        # 建立雜湊表，鍵為 (前綴, 後綴)，值為對應單字的索引\n        self.lookup = {}\n        for idx, word in enumerate(words):\n            L = len(word)\n            # 先把前綴與後綴都列舉一次\n            for i in range(L + 1):\n                prefix = word[:i]          # 前綴可為空字串\n                for j in range(L + 1):\n                    suffix = word[j:]      # 後綴可為空字串\n                    self.lookup[(prefix, suffix)] = idx   # 只要更新，最後留下的就是最大的索引\n\n    def f(self, pref, suff):\n        \"\"\"回傳符合前綴 pref 與後綴 suff 的最大索引，若不存在則回傳 -1\"\"\"\n        return self.lookup.get((pref, suff), -1)\n\n\ndef parse_input(data):\n    \"\"\"\n    解析輸入資料，支援兩種格式：\n    1) 兩行輸入：第一行是 words 列表，第二行是 [prefix, suffix]\n    2) 單行輸入：words 列表，逗號分隔，再接 [prefix, suffix]\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], \"\", \"\"\n\n    # 嘗試以換行符號切分\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        words_str = lines[0].strip()\n        query_str = lines[1].strip()\n    else:\n        # 單行輸入，找第一個 '],'\n        split_index = data.find('],')\n        if split_index != -1:\n            words_str = data[:split_index+1].strip()\n            query_str = data[split_index+2:].strip()\n        else:\n            # 若沒有明顯分隔，視整個輸入為 words，預設空前綴後綴\n            words_str = data\n            query_str = \"['', '']\"\n\n    # 使用 literal_eval 解析成 Python 物件\n    words = ast.literal_eval(words_str)\n    query = ast.literal_eval(query_str)\n    if not isinstance(query, (list, tuple)) or len(query) != 2:\n        # 若解析失敗，給預設空值\n        pref, suff = \"\", \"\"\n    else:\n        pref, suff = query[0], query[1]\n    return words, pref, suff\n\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    input_data = sys.stdin.read()\n    words, pref, suff = parse_input(input_data)\n\n    wf = WordFilter(words)\n    result = wf.f(pref, suff)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code with line-by-line steps, explaining. It's a data structure problem. We need to design WordFilter class with constructor and f method, storing words and enabling prefix+suffix search returning largest index. Classic solution: build a trie for prefixes and suffixes? Or use hashmap of prefix+suffix combos. Usually solution: For each word, for all prefixes and suffixes, map pair to index. But we want O(1) query.\n\nSimpler: store words in array. For each query, loop through indices descending, check word startswith pref and endswith suff. Complexity O(n*len). But maybe fine.\n\nBut they want design of special dictionary searching by prefix and suffix. Provide virtual code. We'll produce generic algorithm: Use two tries (prefix and suffix). Or a hash map storing combined key. Provide explanation.\n\nWe'll produce steps:\n\nStart\n→ Step 1: WordFilter constructor receives words array\n    → For each word index i, word\n        → For each prefix length from 1 to len(word)\n            → prefix = word[0:len]\n            → For each suffix length from 1 to len(word)\n                → suffix = word[len-suffix_len:]\n                → key = prefix + '#' + suffix\n                → map[key] = i  // store largest index automatically\n        → Also store full word as key? Actually prefix and suffix can be empty? Might need support empty. So include empty prefix or suffix as possible. We'll handle by also mapping \"\" as prefix/suffix.\n\n→ Step 2: f method receives pref, suff\n    → key = pref + '#' + suff\n    → If key in map: return map[key]\n    → else return -1\n\nReturn -1 if none.\n\nLet's produce virtual code accordingly.\n\nMake sure to include decision statements and arrows.\n\nWill produce lines with comments.\n\nAlso need to include Start, End.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: WordFilter(words) // 建構子，接收單字陣列\n    → Decision: words 是否為空? // 檢查是否有任何單字\n        Yes → End // 空陣列直接結束初始化\n        No  →\n            → Step 1.1: Initialize map = {} // 建立雜湊表存放 prefix#suffix → 最大索引\n            → Step 1.2: For each (i, word) in words // 逐字索引\n                → Step 1.2.1: For pref_len = 1 to word.length\n                    → Step 1.2.1.1: pref = word.substr(0, pref_len) // 取得前綴\n                    → Step 1.2.1.2: For suff_len = 1 to word.length\n                        → Step 1.2.1.2.1: suff = word.substr(word.length - suff_len) // 取得後綴\n                        → Step 1.2.1.2.2: key = pref + \"#\" + suff // 組合鍵\n                        → Step 1.2.1.2.3: map[key] = i // 儲存目前索引，會覆蓋舊的，保留最大值\n                → Step 1.2.2: // 為了支援空前綴或後綴，額外存入空字串對應\n                    → Step 1.2.2.1: key = \"\" + \"#\" + word // 空前綴 + 完整單字作後綴\n                    → Step 1.2.2.2: map[key] = i\n                    → Step 1.2.2.3: key = word + \"#\" + \"\" // 完整單字作前綴 + 空後綴\n                    → Step 1.2.2.4: map[key] = i\n                    → Step 1.2.2.5: key = \"\" + \"#\" + \"\" // 空前綴 + 空後綴\n                    → Step 1.2.2.6: map[key] = i\nEnd // WordFilter 建構完成\n\nStart // f 方法開始執行\n→ Step 2: f(pref, suff) // 接收前綴 pref 與後綴 suff\n    → Step 2.1: key = pref + \"#\" + suff // 組合搜尋鍵\n    → Decision: key 是否在 map? // 檢查是否存在對應單字\n        Yes → Step 2.2: return map[key] // 回傳最大索引\n        No  → Step 2.3: return -1 // 沒有符合的單字\nEnd // f 方法結束執行"
    },
    {
      "title": "My Calendar III",
      "source_file": "Leetcode/leetcode732.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,2,3,3,3]'\nGot (Norm):      '[None,1,1,2,3,3,3]'\n--- (Raw) ---\nRaw Expected: '[null, 1, 1, 2, 3, 3, 3]'\nRaw Got:      '[None, 1, 1, 2, 3, 3, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MyCalendarThree:\n    def __init__(self):\n        # 使用字典存儲每個時間點的變化量，key 為時間，value 為變化量 (+1 或 -1)\n        self.timeline = {}\n\n    def book(self, start, end):\n        # 在開始時間點增加一個活動\n        self.timeline[start] = self.timeline.get(start, 0) + 1\n        # 在結束時間點減少一個活動\n        self.timeline[end] = self.timeline.get(end, 0) - 1\n\n        # 進行一次掃描，找出最大重疊數\n        active = 0\n        max_active = 0\n        for time in sorted(self.timeline):\n            active += self.timeline[time]\n            if active > max_active:\n                max_active = active\n        return max_active\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 將輸入拆分為兩個列表：方法名與對應參數\n    # 假設輸入格式為: '[\"MyCalendarThree\", \"book\", ...], [[], [10, 20], ...]'\n    idx = raw_input.find('],')\n    if idx == -1:\n        raise ValueError(\"輸入格式不正確\")\n    methods_str = raw_input[:idx + 1]\n    args_str = raw_input[idx + 2:].strip()\n\n    # 解析為 Python 對象\n    methods = ast.literal_eval(methods_str)\n    args_list = ast.literal_eval(args_str)\n\n    # 執行指令\n    result = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"MyCalendarThree\":\n            obj = MyCalendarThree()\n            result.append(None)\n        elif method == \"book\":\n            res = obj.book(*args)\n            result.append(res)\n        else:\n            raise ValueError(f\"未知方法 {method}\")\n\n    # 輸出結果列表\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for MyCalendarThree. It's similar to Leetcode 732. We need to implement with interval tree or sweep line. We'll produce simple sweep line using map of times.\n\nThe pseudocode will define class MyCalendarThree with start method, and book method. Use map times -> delta. For each booking, add +1 at start, -1 at end. Then iterate sorted times, keep current and track max.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to produce \"逐行\" output. Use structure Start, End, Decision. Let's produce steps.\n\nWe'll include:\n\nStart MyCalendarThree constructor // initialize map\n\n→ Step 1: Initialize empty ordered map timeDeltas // 存儲每個時間點的變化量\n\nEnd constructor\n\n→ Start book(startTime, endTime) // 開始預訂流程\n\n→ Step 1: Add delta +1 at startTime to map // 開始時間增加一個活動\n\n→ Step 2: Add delta -1 at endTime to map // 結束時間減少一個活動\n\n→ Step 3: Initialize current = 0, maxOverlap = 0 // 設置計數器\n\n→ Step 4: For each time, delta in sorted order of map // 按時間遍歷\n\n    → current += delta // 更新當前重疊數\n\n    → maxOverlap = max(maxOverlap, current) // 更新最大重疊\n\n→ End book // 回傳最大重疊\n\n→ Step 5: Return maxOverlap // 返回k-booking\n\nEnd\n\nWe also may need to mention that map is ordered by time.\n\nLet's produce lines with arrow \"→\" and \"Decision\" maybe not needed. We'll output as required.\n\nBe careful: \"虛擬碼步驟\" can be like \"Step 1: ...\". Use arrow \"→\" before each step.\n\nWe must follow format exactly: \"Start // 程式開始執行\" etc.\n\nOk produce.\n\nUse comment // to explain.\n\nLet's write lines:\n\nStart MyCalendarThree constructor // 建構 MyCalendarThree 時初始化資料結構\n→ Step 1: timeDeltas ← empty ordered map // 用於記錄時間點的變化量，順序依時間排列\nEnd MyCalendarThree constructor // 結束建構\n\nStart book(startTime, endTime) // 開始一次預訂\n→ Step 1: timeDeltas[startTime] ← timeDeltas[startTime] + 1 // 在開始時間加入 +1 變化\n→ Step 2: timeDeltas[endTime] ← timeDeltas[endTime] - 1 // 在結束時間加入 -1 變化\n→ Step 3: current ← 0 // 當前重疊事件數\n→ Step 4: maxOverlap ← 0 // 目前遇到的最大重疊數\n→ Step 5: For each (time, delta) in timeDeltas in ascending order // 依時間升序遍歷所有時間點\n    → current ← current + delta // 更新當前重疊數\n    → If current > maxOverlap Then maxOverlap ← current // 更新最大值\n→ End book // 完成預訂\n→ Step 6: Return maxOverlap // 回傳目前最大的 k-booking 數\n\nEnd // 程式結束\n\nBut we need to include arrows for Decision? We have an if. Use \"Decision:\" style.\n\nSo inside loop we need Decision block. Let's restructure:\n\n→ Step 5: For each (time, delta) in timeDeltas in ascending order\n    → current ← current + delta\n    → Decision: if current > maxOverlap?\n        Yes → maxOverlap ← current\n\nOk.\n\nWe need to ensure \"Decision:\" block.\n\nLet's produce final.\n\nAlso at top: \"Start MyCalendarThree constructor\" then \"End MyCalendarThree constructor\" is separate.\n\nLet's produce final output.\n...done thinking.\n\nStart MyCalendarThree constructor // 建構 MyCalendarThree 時初始化資料結構  \n→ Step 1: timeDeltas ← empty ordered map // 用於記錄時間點的變化量，順序依時間排列  \nEnd MyCalendarThree constructor // 結束建構  \n\nStart book(startTime, endTime) // 開始一次預訂  \n→ Step 1: timeDeltas[startTime] ← timeDeltas[startTime] + 1 // 在開始時間加入 +1 變化  \n→ Step 2: timeDeltas[endTime] ← timeDeltas[endTime] - 1 // 在結束時間加入 -1 變化  \n→ Step 3: current ← 0 // 當前重疊事件數  \n→ Step 4: maxOverlap ← 0 // 目前遇到的最大重疊數  \n→ Step 5: For each (time, delta) in timeDeltas in ascending order // 依時間升序遍歷所有時間點  \n    → current ← current + delta // 更新當前重疊數  \n    → Decision: current > maxOverlap? // 檢查是否更新最大值  \n        Yes → maxOverlap ← current // 更新最大重疊數  \n→ End book // 完成預訂  \n→ Step 6: Return maxOverlap // 回傳目前最大的 k-booking 數  \n\nEnd // 程式結束"
    },
    {
      "title": "Unique Substrings in Wraparound String",
      "source_file": "Leetcode/leetcode467.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef count_wraparound_substrings(s: str) -> int:\n    \"\"\"Return number of unique non‑empty substrings of s that appear\n    in the infinite wraparound string of the alphabet.\"\"\"\n    # dp[i] holds the maximum length of a wraparound substring that ends\n    # with the letter chr(ord('a') + i).\n    dp = [0] * 26\n    cur_len = 0  # length of current consecutive segment\n\n    for i, ch in enumerate(s):\n        if i > 0 and (ord(ch) - ord(s[i - 1])) % 26 == 1:\n            cur_len += 1\n        else:\n            cur_len = 1\n        idx = ord(ch) - ord('a')\n        dp[idx] = max(dp[idx], cur_len)\n\n    return sum(dp)\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    # Extract the first sequence of lowercase letters as the string s\n    matches = re.findall(r\"[a-z]+\", raw_input)\n    s = matches[0] if matches else \"\"\n\n    result = count_wraparound_substrings(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output pseudocode step by step, explaining each line. Problem: count unique non-empty substrings of s that appear in infinite wraparound string base. Known Leetcode 467. Approach: For each letter, store maximum length of substring ending with that letter that appears in s, contiguous wrap. Then answer sum of those lengths.\n\nSteps: Start, Input s, Initialize array maxLen[26] = 0, prevLen = 0, iterate i, if consecutive (prev+1)%26 == curr, prevLen++ else prevLen=1. Update maxLen[curr] = max(prevLen). End loop, sum maxLen, output. Also handle uniqueness by logic.\n\nWe'll produce virtual code lines accordingly.\n\nLet's craft lines.\n\nAlso need to mention that we only care unique substrings that appear. The logic ensures unique counts.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 取得要檢查的字串  \n→ Step 2: 建立陣列 maxLen[26]，所有元素初始化為 0 // 用於儲存每個字母結尾時可取得的最大連續長度  \n→ Step 3: 初始化 prevLen 為 0 // 追蹤前一個字元的連續長度  \n→ Step 4: 從 i = 0 到 s.length-1 逐字元迭代 // 遍歷字串中的每個位置  \n    → Decision: 是否為 wraparound 相鄰字元? // 判斷當前字元與前一字元是否在英文字母表中相鄰，考慮循環 'z' → 'a'  \n        Yes → prevLen ← prevLen + 1 // 若相鄰，延長連續長度  \n        No  → prevLen ← 1 // 若不相鄰，重設連續長度為 1（僅包含當前字元）  \n    → Step 5: idx ← s[i] 的字母序號 (0-25) // 取得目前字元在字母表中的索引  \n    → Step 6: maxLen[idx] ← max( maxLen[idx], prevLen ) // 更新該字母結尾時可取得的最大連續長度  \n→ Step 7: 變數 answer ← 0 // 用於累計所有唯一子字串的個數  \n→ Step 8: 對 j = 0 到 25 迭代  \n    → Step 9: answer ← answer + maxLen[j] // 每個字母貢獻其最大長度所代表的所有子字串  \n→ Step 10: 輸出 answer // 回傳最終計算出的唯一非空子字串個數  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[],[1],[1,2],[1,2,2],[2],[2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[], [], [1], [1, 2], [1, 2, 2], [2], [2, 2]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[0]]'\nGot (Norm):      '[[],[],[0]]'\n--- (Raw) ---\nRaw Expected: '[[],[0]]'\nRaw Got:      '[[], [], [0]]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\ndef subsets_with_dup(nums):\n    \"\"\"Return all unique subsets of the integer list `nums`.\"\"\"\n    nums.sort()                     # 排序，方便跳過重複\n    result = [[]]                   # 初始子集為空集合\n\n    def backtrack(start, path):\n        # 將目前路徑作為一個子集加入結果\n        result.append(path.copy())\n\n        for i in range(start, len(nums)):\n            # 跳過重複元素，只在第一次出現時才使用\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()             # 回溯，移除最後加入的元素\n\n    backtrack(0, [])\n    return result\n\ndef parse_input(data):\n    \"\"\"從輸入字串中抽取數字列表。\"\"\"\n    # 找出第一個包含 [] 的片段\n    match = re.search(r'\\[.*?\\]', data)\n    if match:\n        return ast.literal_eval(match.group())\n    return []\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n\n    # 計算所有不重複的子集\n    subsets = subsets_with_dup(nums)\n\n    # 輸出結果\n    print(subsets)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for generating all unique subsets of an integer array that may contain duplicates, ensuring no duplicate subsets. Use recursion/backtracking, sort array first, skip duplicates. Output steps with explanation. Should follow given format.\n\nWe need to produce lines with virtual code steps and comments. Use Start, End, Decision, etc. Provide line-by-line virtual code, not actual code. Should produce something like:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 排序以便處理重複元素\n→ Step 2: Initialize result list with empty set // 開始的子集\n→ Step 3: Call Backtrack(index=0, currentSet=[]) // 進行遞歸\n→ Decision: index < len(nums)? // 是否已經遍歷完\n  Yes → Step 4: Add currentSet to result // 加入當前子集\n  Yes → Decision: For each i from index to len(nums)-1? // 循環遍歷\n    // etc.\n\nWe need to use arrow notation and decisions. Use \"Decision:\" with Yes and No lines.\n\nLet's craft properly.\n\nWe should show steps:\n\n- Start\n- Sort nums\n- Initialize result\n- Define backtrack function with parameters idx, path\n- Backtrack steps:\n  - Add current path to result\n  - For i from idx to n-1:\n    - If i > idx and nums[i] == nums[i-1]: continue // skip duplicates\n    - Append nums[i] to path\n    - Recurse backtrack(i+1, path)\n    - Pop last element\n- End\n\nLet's write step by step.\n\nWe need to produce virtual code lines and comments. Use arrow \"→\".\n\nUse indentation? We can use indentation by prefixing spaces? But spec says use arrow \"→\". We'll use \"→\" for each step.\n\nWe need to include \"Decision:\" lines for loops? The arrow for loop might be \"Decision: 迴圈結束?\".\n\nBut better: Use \"Decision:\" for condition, \"Yes\" and \"No\".\n\nBut for loops, we could use \"Decision: i < n?\" with Yes to continue loop and No to exit. Let's keep simple.\n\nBut maybe we can present as nested steps.\n\nWe must ensure each line contains virtual code step and // explanation.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Sort the input array nums in non‑decreasing order // 先排序，方便後續去重\n→ Step 2: Create an empty list result and add an empty list // 初始化結果，包含空集合\n→ Step 3: Define recursive function Backtrack(start, path) // 用來產生子集\n    → Step 4: Add a copy of path to result // 將目前路徑視為一個子集加入結果\n    → Decision: start < len(nums)? // 是否還有元素可供選擇\n        Yes → Step 5: For i from start to len(nums)-1 // 逐一嘗試加入元素\n            → Decision: i > start AND nums[i] == nums[i-1]? // 重複元素跳過\n                Yes → Step 6: Continue to next i // 跳過重複的選擇\n                No  → Step 7: Append nums[i] to path // 把元素加入目前子集\n                → Step 8: Call Backtrack(i+1, path) // 進行下一層遞迴\n                → Step 9: Remove last element from path // 回溯，移除剛加入的元素\n        No  → End // 已經沒有更多元素可選，回溯返回\n→ Step 10: Call Backtrack(0, empty list) // 開始遞迴\n→ End // 程式結束，result 即為所有不重複子集\n\nBut we need each line separately. We need to indent appropriately. Use \"→\" for each line. For nested, we can add extra spaces then \"→\". But specification didn't mention indentation but arrow indicates step. We can use nested indentation with spaces and \"→\". That is fine.\n\nBut each line must contain virtual code step and // explanation. We need to separate explanation after //.\n\nWe need to ensure that each line ends with comment.\n\nWe need to use \"Decision:\" for conditions and \"Yes\" and \"No\". Use arrow for transitions? Actually arrow \"→\" before each step. For decisions we can do:\n\n→ Decision: i > start AND nums[i] == nums[i-1]? // 判斷是否為重複元素\n    Yes → Step 6: Continue to next i // 跳過\n    No  → Step 7: Append nums[i] to path // 加入\n\nBut we need to maintain the arrow before each step. For \"Continue to next i\" we might represent \"Continue\" as \"Continue\". But maybe \"Step 6: 跳過\" not needed? We can just do \"Yes → Step 6: 跳過 i\" but we can say \"Yes → Step 6: Skip current i\" // 跳過重複\n\nOk.\n\nAlso need to keep step numbering? Not necessary but helpful.\n\nAlso \"End\" inside recursion? We might not need \"End\" inside recursion because recursion ends automatically. But we can add \"End\" for the function.\n\nBut spec says \"End // 程式執行結束\". So we need final End.\n\nLet's produce final answer.\n\nWe should keep it concise.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 先排序以便後續去重\n→ Step 2: Initialize result = [[]] // 起始子集為空集合\n→ Step 3: Define function Backtrack(start, path) // 產生子集的遞歸\n    → Step 4: Add a copy of path to result // 每次進入時都將目前路徑視為一個子集\n    → Decision: start < len(nums)? // 是否還有可選元素\n        Yes → Step 5: For i from start to len(nums)-1 // 逐個嘗試加入\n            → Decision: i > start AND nums[i] == nums[i-1]? // 判斷是否為重複元素\n                Yes → Step 6: Continue // 跳過重複選擇\n                No  → Step 7: Append nums[i] to path // 加入元素\n                → Step 8: Backtrack(i+1, path) // 進一步遞歸\n                → Step 9: Remove last element from path // 回溯\n        No  → // 結束此分支\n→ Step 10: Call Backtrack(0, []) // 啟動遞歸\n→ End // 程式執行結束，result 為所有不重複子集\n\nBut we used \"Continue\" which may not be clear. We can say \"Step 6: 跳過 i\" // 跳過重複\n\nBetter to use \"Step 6: 跳過當前 i\" // 跳過重複元素\n\nLet's produce final answer accordingly.\n\nMake sure each line has \"→\" at beginning. For nested lines, we add a space before \"→\" to indicate depth.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先排序，以便後續處理重複元素  \n→ Step 2: Initialize result = [[]] // 起始子集為空集合  \n→ Step 3: Define function Backtrack(start, path) // 產生子集的遞歸  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: Add a copy of path to result // 每次進入時都將目前路徑視為一個子集  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: start < len(nums)? // 是否還有可選元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: For i from start to len(nums)-1 // 逐個嘗試加入  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: i > start AND nums[i] == nums[i-1]? // 判斷是否為重複元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: 跳過當前 i // 跳過重複選擇  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 7: Append nums[i] to path // 加入元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: Backtrack(i+1, path) // 進一步遞歸  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 9: Remove last element from path // 回溯  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 結束此分支  \n→ Step 10: Call Backtrack(0, []) // 啟動遞歸  \n→ End // 程式執行結束，result 為所有不重複子集"
    },
    {
      "title": "Lexicographical Numbers",
      "source_file": "Leetcode/leetcode386.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,10,11,12,13,2,3,4,5,6,7,8,9]'\nGot (Norm):      '[1,10,11,12,13,14,15,16,17,18,19,2,3]'\n--- (Raw) ---\nRaw Expected: '[1,10,11,12,13,2,3,4,5,6,7,8,9]'\nRaw Got:      '[1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef lexical_order(n: int) -> list[int]:\n    \"\"\"\n    以字典序產生 1~n 的所有整數。\n    本算法僅使用 O(1) 的額外變數（current），\n    迴圈一次就能得到下一個字典序的數字。\n    \"\"\"\n    result = []\n    cur = 1                          # 現在指向的數字\n    for _ in range(n):               # 總共要產生 n 個數字\n        result.append(cur)\n\n        # 若能往下一層（乘 10）仍在範圍內，則直接進入下一層\n        if cur * 10 <= n:\n            cur *= 10\n        else:\n            # 同層遞增（例如 12 → 13）\n            if cur % 10 != 9 and cur + 1 <= n:\n                cur += 1\n            else:\n                # 需要回溯到上一層並遞增（例如 19 → 2）\n                while cur % 10 == 9:\n                    cur //= 10\n                cur += 1\n    return result\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整數 n（支持 \"n = 13\" 或僅 \"13\" 的格式）\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        sys.exit(0)\n    n = int(nums[0])\n\n    output = lexical_order(n)\n    print(output)",
      "virtual_code": "Thinking...\nWe need produce virtual code for algorithm: Given n, produce numbers 1..n sorted lexicographically, in O(n) time, O(1) space. That's typical lexicographic DFS with next and increment logic. Virtual code lines, explanation. Use Start, Decision, etc. Must be line-by-line.\n\nWe'll produce algorithm: Use current=1; result list? But we cannot use extra space? The requirement O(1) extra space means we can output in order, not store list. So algorithm prints or yields numbers in lex order.\n\nWe'll produce virtual code lines that show logic.\n\nPseudo:\n\nStart\n→ current = 1\n→ while current <= n\n    → Output current\n    → if current *10 <= n\n        → current = current *10\n      else\n        → if current%10 !=9 and current+1 <= n\n            → current = current +1\n          else\n            → while (current/10)%10 ==9 or current/10==0\n                → current = current/10\n              → current = current/10 +1\nEnd\n\nBut we need step by step with decision blocks. Also need O(1) extra space, we just use current variable. Let's craft.\n\nWe'll create lines:\n\nStart // begin\n\n→ current = 1 // 初始化当前数字为1\n\n→ while current <= n // 遍历直到超过n\n\n    → Output current // 先输出当前数字\n\n    → Decision: 若 current*10 <= n? // 判断是否能继续进入下一层前缀\n\n        Yes → current = current*10 // 进入下一层前缀\n\n        No  → Decision: 若 current%10 != 9 且 current+1 <= n? // 能否直接递增到下一个同层数字\n\n            Yes → current = current + 1 // 递增\n\n            No  → Decision: 若 current%10 == 9? // 当前是末尾数字，需要回溯\n\n                Yes → current = current/10 // 先上层\n\n                    → Decision: 若 current%10 == 9? // 仍是末尾，需要继续上层\n\n                        Yes → loop until current%10 !=9\n\n                    → current = current + 1 // 移动到下一同层\n\n                No  → current = current/10 + 1 // 直接回到上层并递增\n\nBut we must maintain loop structure. Might be too complex but fine.\n\nWe should include indentation.\n\nAlso each line must have virtual code then comment. Let's produce final output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ current = 1 // 初始化目前指向的數字為 1\n→ Decision: current <= n? // 只要目前數字沒超過 n 就繼續\n    Yes →\n        → Output current // 先輸出目前的數字\n        → Decision: current * 10 <= n? // 能否往下一個十倍層進去\n            Yes → current = current * 10 // 進入下層前綴（例如 1 → 10）\n            No  →\n                → Decision: current % 10 != 9 AND current + 1 <= n? // 同層能否直接遞增\n                    Yes → current = current + 1 // 從 1 直接遞增到 2，或 12→13\n                    No  →\n                        → Decision: current % 10 == 9? // 是否為同層尾數，需要回溯\n                            Yes →\n                                → current = current / 10 // 先回到上一層（例如 19 → 1）\n                                → Decision: current % 10 == 9? // 上一層還是尾數，需繼續回溯\n                                    Yes →\n                                        → current = current / 10 // 迭代回溯（例如 199 → 1）\n                                        → Decision: current % 10 == 9? // 仍然尾數，持續回溯\n                                            Yes → // 以上會在隱含迴圈中處理，這裡省略重複步驟\n                                            No  → // 到達非尾數層\n                                No  → // 已回到非尾數層\n                                → current = current + 1 // 移動到下一個同層數字（例如 19 → 2）\n                            No  →\n                                → current = current / 10 + 1 // 直接回上一層並遞增（例如 109 → 11）\n    No → End // 當 current 超過 n 時結束\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Smallest Good Base",
      "source_file": "Leetcode/leetcode483.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "n = \"4681\"",
          "expected_output": "\"8\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '8'\nGot (Norm):      '4680'\n--- (Raw) ---\nRaw Expected: '\"8\"'\nRaw Got:      '4680'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef integer_nth_root(n: int, m: int) -> int:\n    \"\"\"Return the largest integer x such that x**m <= n.\"\"\"\n    low, high = 1, int(n ** (1.0 / m)) + 2  # initial bounds\n    while low < high:\n        mid = (low + high + 1) // 2\n        if pow(mid, m) <= n:\n            low = mid\n        else:\n            high = mid - 1\n    return low\n\ndef sum_of_powers(k: int, m: int, limit: int) -> int:\n    \"\"\"\n    Compute 1 + k + k^2 + ... + k^(m-1),\n    but stop early if the partial sum exceeds `limit`.\n    \"\"\"\n    total = 1\n    for _ in range(1, m):\n        total = total * k + 1\n        if total > limit:\n            break\n    return total\n\ndef smallest_good_base(n_str: str) -> str:\n    n = int(n_str)\n    if n <= 3:\n        return str(n - 1)\n\n    max_m = n.bit_length()  # 2**max_m > n\n\n    for m in range(max_m, 1, -1):\n        k_floor = integer_nth_root(n, m)\n        for k in (k_floor - 1, k_floor, k_floor + 1):\n            if k <= 1:\n                continue\n            s = sum_of_powers(k, m, n)\n            if s == n:\n                return str(k)\n\n    # Fallback: n-1 always works (representation \"11\")\n    return str(n - 1)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the numeric string, handling possible format like n = \"13\"\n    match = re.search(r'\"(\\d+)\"', data)\n    if match:\n        n_str = match.group(1)\n    else:\n        n_str = data.strip()\n\n    result = smallest_good_base(n_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for problem: Given integer n as string, find smallest good base. Known problem: Leetcode 1368. Solution: try exponent m from 64 down to 2, compute k = round(n^{1/m}), check if base representation all ones. Or direct formula: (k^m -1)/(k-1) = n. So we need algorithm.\n\nWe need to output virtual code lines step by step. No actual code, just virtual steps. We'll include Start, decisions, loops, etc.\n\nLet's design steps:\n\n1. Convert string to big integer value? Use BigInteger. But virtual.\n\n2. If n <= 3 return n-1? Actually for small n: n = 2 => base 1? But base >=2. For n=2, answer 1? Actually n=2 represented as \"10\" in base 2? Not all ones. The known answer: For n=2, smallest good base is 1? Wait base must >=2. For n=2, only representation \"10\" not all ones, so base 1? Not allowed. But actual solution: If n=2, answer 1? Hmm problem constraints: n>=3? Let's ignore small.\n\nBut we can produce general algorithm.\n\nPseudo:\n\n- parse n string to big integer N.\n\n- For m from 64 down to 2:\n    - compute approximate k as floor(N^{1/m}).\n    - For kCandidate in [k-1, k, k+1] (since rounding):\n        - if kCandidate <=1 continue\n        - compute value = 1\n        - For i from 1 to m:\n            - value = value * kCandidate + 1\n            - if value > N break\n        - if value == N: return kCandidate\n- return N-1 // fallback base (k = N-1 gives representation '11')\n\nLet's produce virtual steps.\n\nNeed to use BigInteger for multiplications.\n\nAlso include explanation after each line.\n\nLet's produce:\n\nStart\n→ Step 1: Convert input string to big integer N // 用 BigInteger 取得 n 的數值\n→ Step 2: If N <= 3 then return N-1 // 直接得到最小好基底\n→ Step 3: Set maxExponent = 64 // 因為 2^64 > 10^18，足以覆蓋所有情況\n→ Decision: 是否有更大的 m 需要考慮? // 確保覆蓋\n    No  → // 跳到後續\n→ Loop: For exponent m from maxExponent down to 2\n    → Step 4: Compute kApprox = floor( N^{1/m} ) // 近似 k\n    → Step 5: For candidate k in {kApprox-1, kApprox, kApprox+1}\n        → Decision: k > 1? // 必須大於1\n            Yes → Step 6: 初始化 value = 1 // 用來構造 (k^m -1)/(k-1)\n            → Loop: i from 1 to m\n                → Step 7: value = value * k + 1 // 逐步累加 1 的位數\n                → Decision: value > N? // 若已超過則不可能匹配\n                    Yes → Break inner loop // 跳出\n                    No  →\n            → Decision: value == N? // 成功找到基底\n                Yes → Return k // 最小好基底\n                No  → // 繼續檢查下一個 k\n        No → // k <=1，跳過\n→ Step 8: 返回 N-1 // 若沒找到，最後一種好基底 k = N-1，表示 '11'\nEnd\n\nBut we need \"逐行\" each line separate with arrow etc. Use \"→\" for sequence. \"Decision:\" lines indent.\n\nWe must also include line numbers? Not necessary.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: 將輸入字串轉成 BigInteger N // 取得 n 的數值\n→ Step 2: If N <= 3 then return N-1 // 對於小數直接返回最小好基底\n→ Step 3: 設定 maxExponent = 64 // 2^64 超過 10^18，足以覆蓋所有情況\n→ Decision: 是否需要處理更大 m? // 檢查是否有更大指數\n    No  → // 繼續\n→ Loop: for m from maxExponent down to 2\n    → Step 4: 計算 kApprox = floor( N^{1/m} ) // 近似 k 的值\n    → Step 5: for kCandidate in {kApprox-1, kApprox, kApprox+1}\n        → Decision: kCandidate > 1? // 基底必須大於 1\n            Yes →\n                → Step 6: 設 value = 1 // 初始值為 1\n                → Loop: i from 1 to m\n                    → Step 7: value = value * kCandidate + 1 // 構造 k 的 m 位全 1\n                    → Decision: value > N? // 超過目標值\n                        Yes → Break // 跳出內層循環\n                        No  →\n                → Decision: value == N? // 是否正好等於 N\n                    Yes → Return kCandidate // 找到最小好基底\n                    No  →\n            No  → // kCandidate <= 1，跳過\n→ Step 8: Return N-1 // 若未找到，最後一種好基底是 N-1，表示 '11'\nEnd // 程式結束\n\nBut we need to use \"Decision:\" for decisions, but we also need to use \"→\" before steps. Use indent for nested. Use \"Decision:\" lines with indentation. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將輸入字串轉成 BigInteger N // 取得 n 的數值  \n→ Step 2: If N <= 3 then return N-1 // 對於 2、3 直接返回最小好基底  \n→ Step 3: 設定 maxExponent = 64 // 2^64 > 10^18，足以覆蓋所有可能的指數  \n→ Decision: 是否需要處理更大 m? // 檢查是否有更大指數  \n  No → // 繼續後續步驟  \n→ Loop: for m from maxExponent down to 2  \n  → Step 4: 計算 kApprox = floor( N^{1/m} ) // 近似 k 的值  \n  → Step 5: for kCandidate in {kApprox-1, kApprox, kApprox+1}  \n    → Decision: kCandidate > 1? // 基底必須大於 1  \n      Yes →  \n       → Step 6: 設 value = 1 // 初始值為 1，代表「1」  \n       → Loop: i from 1 to m  \n         → Step 7: value = value * kCandidate + 1 // 逐步累加 1 的位數，構造全 1 的數  \n         → Decision: value > N? // 若已超過目標值，則不可能匹配  \n           Yes → Break // 跳出內層循環  \n           No  →  \n         → Decision: value == N? // 是否正好等於 N  \n           Yes → Return kCandidate // 找到最小好基底，結束程式  \n           No  → // 繼續檢查下一個 kCandidate  \n       No  → // kCandidate <= 1，跳過此候選  \n→ Step 8: Return N-1 // 若未找到任何符合的基底，最後一種好基底是 N-1，表示「11」  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nfrom ast import literal_eval\n\ndef main():\n    # 讀取整個標準輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 解析輸入，支援形如 \"nums = [1,2,3]\" 的格式\n    if raw.startswith(\"nums\"):\n        idx = raw.find('[')\n        expr = raw[idx:] if idx != -1 else raw\n    else:\n        expr = raw\n\n    nums = literal_eval(expr)\n\n    # 回溯產生所有排列\n    res = []\n\n    def backtrack(start: int) -> None:\n        if start == len(nums):\n            res.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    backtrack(0)\n\n    # 將結果輸出\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the algorithm that returns all permutations of distinct integers. We'll produce a step-by-step pseudocode with arrows, decisions etc. The user says \"逐行生成虛擬碼\" and each line with explanation. Provide Start, End, Decision, etc. Need to handle recursion/backtracking.\n\nWe should use arrow notation: `→` to show steps. Decision: if condition.\n\nSo produce something like:\n\nStart\n→ Step 1: 定義結果列表 results // 用於存放所有排列\n→ Step 2: 定義回溯函式 backtrack(current, remaining) // 產生排列\n→ Step 3: 呼叫 backtrack([], nums) // 初始呼叫\n→ Decision: 若 remaining 為空? // 是否所有元素已放入 current\n   Yes → Step 4: 複製 current 到 results // 完整排列加入結果\n   No  → For 每個元素 x in remaining\n          → Step 5: new_current = current + [x] // 新增元素到排列\n          → Step 6: new_remaining = remaining - {x} // 去掉已選元素\n          → Step 7: backtrack(new_current, new_remaining) // 遞迴\nEnd\n\nBut must use the arrow format: `→` at start of line. We need to include `Decision:` lines with indentation? The example shows indent lines after Decision, e.g.:\n\nDecision: ...\n    Yes → ...\n    No  → ...\n\nSo produce accordingly. Ensure each line has explanation after `//`. Shouldn't output actual code. So each line's \"虛擬碼步驟\" can be described like `Step 1: ...`. But we can incorporate arrow. Eg: `→ Step 1: 初始化 results 為空列表 // 用來儲存所有排列`. Then next line `→ Step 2: 定義回溯函式 backtrack(current, remaining) // 用於生成排列`. But for function definition, we might want to use `→ Step 2: 定義回溯函式 backtrack(current, remaining) // ...`. That is okay.\n\nAlternatively, we might use `→ Decision: ...` lines for base case.\n\nNeed to maintain arrow for each line.\n\nAlso we need to show recursion call: `→ Step 3: 呼叫 backtrack([], nums) // 開始回溯`.\n\nWe also need to show for each element: maybe `→ Decision: 仍有元素在 remaining? // 檢查是否還有未放入元素`. But we can integrate with base case as earlier.\n\nWe should show loop: `→ Step 4: 對 remaining 中每個 x 循環 // 選取每個剩餘元素作為下一步`. But arrow for loop may not be necessary.\n\nBetter to structure as:\n\nStart // 程式開始執行\n→ Step 1: 初始化結果列表 results 為空 // 用於存放所有排列\n→ Step 2: 定義回溯函式 backtrack(current, remaining) // 產生排列\n    → Decision: 若 remaining 為空? // 所有元素已被放入\n        Yes → Step 3: 把 current 複製到 results // 完整排列加入結果\n        No  → Step 4: 對 remaining 中的每個 x 執行\n            → Step 5: new_current = current + [x] // 加入元素\n            → Step 6: new_remaining = remaining - {x} // 去除已選\n            → Step 7: backtrack(new_current, new_remaining) // 進一步遞迴\n→ Step 8: 呼叫 backtrack([], nums) // 開始\n→ Step 9: 返回 results // 完成\n\nEnd // 程式結束\n\nBut need to ensure each line begins with arrow, except Start and End lines which have no arrow in example? In example, Start line has no arrow. So we should follow that: `Start // 程式開始執行`. Then lines with arrows. End line: `End // 程式執行結束`. So we need to ensure we start each subsequent line with `→`. Also indentation for Decision lines. Example:\n\nDecision: ... \n    Yes → ... \n    No → ...\n\nSo we must indent Yes and No lines. For Step 4: \"對 remaining 中的每個 x 執行\" maybe no arrow? We can use `→ Step 4: 循環 remaining 中的每個元素 x` but we need arrow at start.\n\nBut inside the Decision branch we want to show Step 4: For each element. So we can structure:\n\n    → Decision: 仍有元素在 remaining? // 檢查是否還有未放入元素\n        Yes → Step 4: 對 remaining 中的每個 x 執行\n            → Step 5: new_current = current + [x] // 加入元素\n            → Step 6: new_remaining = remaining - {x} // 去除已選\n            → Step 7: backtrack(new_current, new_remaining) // 遞迴\n\nBut that is a bit nested. The Decision line is part of function. It's fine.\n\nWe also need to show recursion base case: \"若 remaining 為空?\" as yes branch to add to results.\n\nSo final output:\n\nStart // 程式開始執行\n→ Step 1: 初始化 results 為空列表 // 用來儲存所有排列\n→ Step 2: 定義回溯函式 backtrack(current, remaining) // 產生排列\n    → Decision: 若 remaining 為空? // 所有元素已放入 current\n        Yes → Step 3: 把 current 複製到 results // 完整排列加入結果\n        No  → Step 4: 對 remaining 中的每個 x 執行\n            → Step 5: new_current = current + [x] // 新增元素到 current\n            → Step 6: new_remaining = remaining - {x} // 去除已選元素\n            → Step 7: backtrack(new_current, new_remaining) // 進一步遞迴\n→ Step 8: 呼叫 backtrack([], nums) // 開始回溯\n→ Step 9: 返回 results // 結果輸出\nEnd // 程式執行結束\n\nBut we need to keep indentation consistent. Example shows no indentation before Step 1. Indentation used for nested steps after Decision. So Step 2 is top-level, but inside Step 2 we have Decision. So we need to indent Step 2? In example, Step 2 is at same level as Step 1, not indented. But inside Decision they indent Yes and No. So our structure: Step 1, Step 2, then Decision inside Step 2. But we need to show that Decision is inside Step 2. We can indent Decision lines.\n\nBut maybe easier: we can treat the function body as lines with indentation. But we can also keep them as separate steps, but still inside function. The requirement didn't specify indentation for function body. It just says to use arrows and Decision structure. So we can simply write the steps in order.\n\nSimplify: Step 1: define results. Step 2: define backtrack function. Step 3: base case. Step 4: loop. Step 5: recursion call. Step 6: initial call. Step 7: return results.\n\nBut need to express recursion with Decision for base case. Let's create:\n\nStart\n→ Step 1: 初始化 results 為空 // 存放所有排列\n→ Step 2: 定義函式 backtrack(current, remaining) // 產生排列\n    → Decision: remaining 為空? // 檢查是否所有元素已放入\n        Yes → Step 3: 將 current 複製到 results // 完整排列加入結果\n        No  → Step 4: 對 remaining 中每個 x 執行\n            → Step 5: new_current = current + [x] // 加入元素\n            → Step 6: new_remaining = remaining - {x} // 去除已選\n            → Step 7: backtrack(new_current, new_remaining) // 遞迴\n→ Step 8: 呼叫 backtrack([], nums) // 開始\n→ Step 9: 回傳 results // 完成\nEnd\n\nCheck formatting: The `→` at start of each line. Indentation: The Decision and Yes/No lines need indentation relative to the preceding line. In example, they show indent using spaces. We should indent Decision lines relative to previous step. So Step 2 has no indent. Inside Step 2 we indent Decision. But in example, Decision line is at same indent as previous step? Wait, in example:\n\nStart\n→ Step 1: ...\n→ Decision: ...\n    Yes → ...\n    No  → ...\n\nSo Decision is at same level as Step 1. So the indentation of Yes and No lines relative to Decision is 4 spaces. The Decision itself is same level as Step 1. So we can mimic that.\n\nThus our output:\n\nStart // 程式開始執行\n→ Step 1: 初始化 results 為空列表 // 用於存放所有排列\n→ Step 2: 定義回溯函式 backtrack(current, remaining) // 用於產生排列\n→ Decision: 仍有剩餘元素嗎? // 檢查是否還有元素未放入 current\n    Yes → Step 3: 把 current 複製到 results // 完整排列加入結果\n    No  → Step 4: 對 remaining 中的每個 x 執行\n        → Step 5: new_current = current + [x] // 加入元素\n        → Step 6: new_remaining = remaining - {x} // 去除已選元素\n        → Step 7: backtrack(new_current, new_remaining) // 進一步遞迴\n→ Step 8: 呼叫 backtrack([], nums) // 開始回溯\n→ Step 9: 返回 results // 完成\nEnd // 程式執行結束\n\nBut this has Decision not inside function. Actually we need Decision inside function. But it's okay for pseudocode. The user didn't ask to detail function boundaries. They want a virtual code for generating permutations. So this approach should be fine.\n\nBut maybe we need to show function start and end. But not necessary.\n\nAlternatively, we can include \"→ Step 2: 定義函式 backtrack(current, remaining)\" then inside we indent steps. But example didn't indent for steps inside function. But we can indent to show inside function. But we should follow simple.\n\nBetter: Keep as:\n\nStart // 程式開始執行\n→ Step 1: 初始化 results 為空列表 // 用於存放所有排列\n→ Step 2: 定義回溯函式 backtrack(current, remaining) // 用於產生排列\n    → Decision: 仍有剩餘元素嗎? // 檢查是否還有未放入元素\n        Yes → Step 3: 把 current 複製到 results // 完整排列加入結果\n        No  → Step 4: 對 remaining 中每個 x 執行\n            → Step 5: new_current = current + [x] // 加入元素\n            → Step 6: new_remaining = remaining - {x} // 去除已選元素\n            → Step 7: backtrack(new_current, new_remaining) // 進一步遞迴\n→ Step 8: 呼叫 backtrack([], nums) // 開始\n→ Step 9: 返回 results // 完成\nEnd // 程式執行結束\n\nBut we need to keep arrow at each step. For indentation, we keep arrow inside. Example:\n\n→ Decision: 仍有剩餘元素嗎?\n    Yes → Step 3...\n    No  → Step 4...\n\nBut inside Step 4 we also have arrows.\n\nYes, but we have arrow before Step 4? The example shows Step 4 preceded by `→ Decision`. Wait, in example, the Yes and No lines start with `Yes →` and `No →`. But Step 4 is after No, not after Yes. But we want to put Step 4 under No. So we indent Step 4 inside No branch. But the example didn't show nested step under No. They had just Yes and No branches. But we need nested steps inside No. So we can indent Step 4 inside No branch like:\n\n    No  → Step 4: 對 remaining 中的每個 x 執行\n        → Step 5: ...\n        → Step 6: ...\n        → Step 7: ...\n\nBut we cannot indent further because Step 4 is already a branch. It's fine.\n\nThus final code lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 results 為空列表 // 用於存放所有排列\n→ Step 2: 定義回溯函式 backtrack(current, remaining) // 用於產生排列\n→ Decision: 仍有剩餘元素嗎? // 檢查是否還有未放入元素\n    Yes → Step 3: 把 current 複製到 results // 完整排列加入結果\n    No  → Step 4: 對 remaining 中的每個 x 執行\n        → Step 5: new_current = current + [x] // 加入元素\n        → Step 6: new_remaining = remaining - {x} // 去除已選元素\n        → Step 7: backtrack(new_current, new_remaining) // 進一步遞迴\n→ Step 8: 呼叫 backtrack([], nums) // 開始\n→ Step 9: 返回 results // 完成\nEnd // 程式執行結束\n\nBut Step 2 defines function, but Decision is after that. The Decision refers to function's internal logic. We might need to indent Decision under Step 2. But we can leave as separate step for simplicity. The requirement is to use arrows and Decision structure. It didn't require function boundaries.\n\nThus final answer. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 results 為空列表 // 用於存放所有排列  \n→ Step 2: 定義回溯函式 backtrack(current, remaining) // 用於產生排列  \n→ Decision: 仍有剩餘元素嗎? // 檢查是否還有未放入 current  \n  Yes → Step 3: 把 current 複製到 results // 完整排列加入結果  \n  No  → Step 4: 對 remaining 中的每個 x 執行  \n    → Step 5: new_current = current + [x] // 加入元素到 current  \n    → Step 6: new_remaining = remaining - {x} // 去除已選元素  \n    → Step 7: backtrack(new_current, new_remaining) // 進一步遞迴  \n→ Step 8: 呼叫 backtrack([], nums) // 開始回溯  \n→ Step 9: 返回 results // 完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Remove to Make Valid Parentheses",
      "source_file": "Leetcode/leetcode1249.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"lee(t(c)o)de)\"",
          "expected_output": "\"lee(t(c)o)de\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'lee(t(c)o)de'\nGot (Norm):      'lee(t(co)de)'\n--- (Raw) ---\nRaw Expected: '\"lee(t(c)o)de\"'\nRaw Got:      'lee(t(co)de)'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef min_remove_to_make_valid(s: str) -> str:\n    \"\"\"\n    移除最少數量的括號，使字串合法。\n    \"\"\"\n    # 第一次遍歷：計算需要刪除的右括號數量\n    right_rem = 0\n    balance = 0\n    for c in s:\n        if c == '(':\n            balance += 1\n        elif c == ')':\n            if balance > 0:\n                balance -= 1\n            else:\n                right_rem += 1\n\n    # 第二次遍歷：計算需要刪除的左括號數量\n    left_rem = 0\n    balance = 0\n    for c in reversed(s):\n        if c == ')':\n            balance += 1\n        elif c == '(':\n            if balance > 0:\n                balance -= 1\n            else:\n                left_rem += 1\n\n    # 建構結果字串，按需刪除多餘的括號\n    result = []\n    balance = 0\n    for c in s:\n        if c == '(':\n            if left_rem > 0:\n                left_rem -= 1\n                continue  # 刪除多餘左括號\n            balance += 1\n            result.append(c)\n        elif c == ')':\n            if right_rem > 0:\n                right_rem -= 1\n                continue  # 刪除多餘右括號\n            if balance > 0:\n                balance -= 1\n                result.append(c)\n        else:\n            result.append(c)\n    return ''.join(result)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n\n    # 先嘗試從引號中提取字串\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若是 's = something' 的格式\n        if '=' in data:\n            s = data.split('=', 1)[1].strip()\n        else:\n            s = data\n    # 再次去除可能存在的引號\n    s = s.strip('\"')\n\n    print(min_remove_to_make_valid(s))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines. It's a standard problem: remove invalid parentheses to make string valid. Approach: first pass left to right to mark invalid ')', second pass right to left to mark invalid '('; or use stack. Simpler: compute counts of unmatched left and right. Then iterate string, build result by skipping when needed.\n\nWe need to output pseudocode step by step with explanations. Each line: \"虛擬碼步驟 // 解釋/說明\".\n\nWe need to use arrows and structure. Format example uses \"→ Step X:\". We'll produce:\n\nStart\n→ Step 1: Initialize counter leftRem = 0, rightRem = 0 // counts of parentheses to remove\n→ Step 2: Iterate over characters in s to count mismatches\n   ... but we want step by step.\n\nBetter: Two-pass: first left to right to count rightRem; second right to left to count leftRem.\n\nWe can produce pseudocode with decisions.\n\nLet's outline:\n\nStart\n→ Step 1: Set rightRem = 0\n→ Step 2: For each char c in s:\n     Decision: If c == '('? → step increment left count? Actually we need to find unmatched ')': if c == ')', if left count >0 then decrement left count else increment rightRem. Use leftCount variable. So we need leftCount.\n\nSimplify: We'll use stack approach: iterate, push '(' onto stack; if encounter ')' and stack not empty, pop; else push ')' to stack. But we need to remove minimal parentheses. Usually two-pass removal is easier: compute rightRem and leftRem, then build result.\n\nOk.\n\nWe'll produce steps:\n\n- Count unmatched ')': iterate left to right, maintain balance. If char '(' => balance++. If char ')' => if balance >0 then balance-- else rightRem++.\n\n- Count unmatched '(': iterate right to left, maintain balance. If char ')' => balance++. If char '(' => if balance >0 then balance-- else leftRem++.\n\n- Build result: iterate s left to right, maintain balance=0, skip chars based on remaining removals.\n\nImplementation details: skip char if it's '(' and leftRem>0; else skip ')', rightRem>0; else include and adjust balance accordingly.\n\nWe'll produce pseudocode lines with arrows.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Step 1: Initialize rightRem = 0, leftRem = 0, balance = 0 // 兩個計數器\n→ Step 2: For each character c in s:\n    → Decision: 如果 c 是 '('? // 檢查左括號\n        → Yes → Step 2a: balance++ // 右括號等待\n        → No  → Decision: 如果 c 是 ')'?\n            → Yes → Step 2b: Decision: 如果 balance > 0?\n                → Yes → Step 2b1: balance-- // 匹配成功\n                → No  → Step 2b2: rightRem++ // 無左括號，記錄要刪除\n            → No  → Step 2c: // 普通字母，忽略\nEnd // 第一遍結束\n→ Step 3: 重新設定 balance = 0 // 用於右往左計算\n→ Step 4: For each character c in s reversed:\n    → Decision: 如果 c 是 ')'?\n        → Yes → Step 4a: balance++ // 需要匹配左括號\n        → No  → Decision: 如果 c 是 '('?\n            → Yes → Step 4b: Decision: 如果 balance > 0?\n                → Yes → Step 4b1: balance-- // 匹配成功\n                → No  → Step 4b2: leftRem++ // 無右括號，記錄要刪除\n            → No  → Step 4c: // 普通字母，忽略\nEnd // 第二遍結束\n→ Step 5: Initialize result as empty string, balance = 0 // 用於構建結果\n→ Step 6: For each character c in s:\n    → Decision: 如果 c 是 '('?\n        → Yes → Decision: 如果 leftRem > 0?\n            → Yes → Step 6a: leftRem-- ; Continue // 刪除多餘左括號\n            → No  → Step 6b: balance++; result += c // 保留左括號\n        → No  → Decision: 如果 c 是 ')'?\n            → Yes → Decision: 如果 rightRem > 0?\n                → Yes → Step 6c: rightRem--; Continue // 刪除多餘右括號\n                → No  → Decision: 如果 balance > 0?\n                    → Yes → Step 6d: balance--; result += c // 匹配右括號\n                    → No  → Step 6e: // 不可能，因為左括號已足夠\n            → No  → Step 6f: result += c // 普通字母\nEnd // 完成結果構建\n→ Step 7: Return result // 返回最終合法字串\nEnd // 程式結束\n\nWe must ensure each line includes arrow or Start etc. Use \"→\". For decisions we need indentation. We'll produce each line separately, with spaces. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Initialize rightRem = 0, leftRem = 0, balance = 0 // 兩個計數器，balance 用於第一次遍歷\n→ Step 2: For each character c in s:\n    → Decision: 如果 c 是 '('? // 檢查左括號\n        → Yes → Step 2a: balance++ // 進一步等待右括號匹配\n        → No  → Decision: 如果 c 是 ')'?\n            → Yes → Step 2b: Decision: 如果 balance > 0? // 有左括號可匹配\n                → Yes → Step 2b1: balance-- // 匹配成功，balance 減 1\n                → No  → Step 2b2: rightRem++ // 無可匹配左括號，記錄要刪除\n            → No  → Step 2c: // 普通字母，直接忽略\nEnd // 第一次遍歷結束\n→ Step 3: 重新設定 balance = 0 // 用於第二次從右往左遍歷\n→ Step 4: For each character c in s reversed:\n    → Decision: 如果 c 是 ')'?\n        → Yes → Step 4a: balance++ // 需要匹配左括號\n        → No  → Decision: 如果 c 是 '('?\n            → Yes → Step 4b: Decision: 如果 balance > 0? // 有右括號可匹配\n                → Yes → Step 4b1: balance-- // 匹配成功\n                → No  → Step 4b2: leftRem++ // 無可匹配右括號，記錄要刪除\n            → No  → Step 4c: // 普通字母，直接忽略\nEnd // 第二次遍歷結束\n→ Step 5: Initialize result as empty string, balance = 0 // 用於構建最終合法字串\n→ Step 6: For each character c in s:\n    → Decision: 如果 c 是 '('?\n        → Yes → Decision: 如果 leftRem > 0? // 有多餘左括號要刪除\n            → Yes → Step 6a: leftRem-- ; Continue // 刪除此左括號\n            → No  → Step 6b: balance++; result += c // 保留左括號，balance 加 1\n        → No  → Decision: 如果 c 是 ')'?\n            → Yes → Decision: 如果 rightRem > 0? // 有多餘右括號要刪除\n                → Yes → Step 6c: rightRem--; Continue // 刪除此右括號\n                → No  → Decision: 如果 balance > 0? // 有左括號可匹配\n                    → Yes → Step 6d: balance--; result += c // 匹配成功，balance 減 1\n                    → No  → Step 6e: // 理論上不會發生，因為 leftRem 已處理\n            → No  → Step 6f: result += c // 普通字母，直接加入\nEnd // 結果構建結束\n→ Step 7: Return result // 回傳最終合法字串\nEnd // 程式結束"
    },
    {
      "title": "Text Justification",
      "source_file": "Leetcode/leetcode68.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmsphg1gr.py\", line 51, in <module>\n    words, maxWidth = eval(input_data)\n                      ^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n          ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp37q5g9o6.py\", line 51, in <module>\n    words, maxWidth = eval(input_data)\n                      ^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n          ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwoq8shwr.py\", line 51, in <module>\n    words, maxWidth = eval(input_data)\n                      ^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n          ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # determine how many words can fit in the line\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            # build the line\n            line_words = words[i:j]\n            spaces_needed = maxWidth - sum(len(word) for word in line_words)\n            gaps = len(line_words) - 1\n\n            if j == n or gaps == 0:\n                # left-justify for last line or single word\n                line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n            else:\n                # fully justify\n                space, extra = divmod(spaces_needed, gaps)\n                line = ''\n                for k in range(gaps):\n                    line += line_words[k] + ' ' * (space + (1 if k < extra else 0))\n                line += line_words[-1]\n\n            res.append(line)\n            i = j\n\n        return res\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    # Evaluate the input to get words list and maxWidth\n    # Expected format: words = [...], maxWidth = ...\n    words, maxWidth = eval(input_data)\n\n    # Solve the problem\n    solution = Solution()\n    result = solution.fullJustify(words, maxWidth)\n\n    # Output the result as a list representation\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to format text. The steps: iterate over words, collect words into line until adding next would exceed maxWidth, then build line with appropriate spacing. Last line special. We'll produce steps.\n\nWe need to follow format: each line: 虛擬碼步驟 + space + // 解釋.\n\nUse arrows, Start, End, Decision. Let's design.\n\nStart\n\n→ Step 1: Initialize i = 0 // index in words\n→ Step 2: Initialize result list // to hold lines\n\n→ Decision: i < len(words)? // while loop\n\nWe can represent while loop with Decision: while i < len(words). Inside:\n\n→ Step 3: Set lineStart = i // start index of current line\n\n→ Step 4: Initialize lineLen = 0 // total length of words in line\n\n→ Step 5: While i < len(words) and lineLen + len(words[i]) + (i - lineStart) <= maxWidth: // add words until fit\n\nBut easier: we can use inner loop.\n\nWe need to maintain lineLen including words length. We'll do:\n\n→ Decision: i < len(words) and lineLen + len(words[i]) + (i - lineStart) <= maxWidth? // can add word\n\nYes → Step 5: lineLen += len(words[i]); i++\n\nNo → Step 6: Build line from words[lineStart:i] with spaces.\n\nFor building line: compute number of words = i - lineStart. If last line (i == len(words))? Use left-justified. We'll need to check.\n\nSo after selecting words, we check if i == len(words) (i.e., last line) or only one word in line: left-justified.\n\nImplement building steps:\n\n→ Decision: (i == len(words)) or (i - lineStart == 1)? // last line or single word\n\nYes → Step 7: Concatenate words with single space and pad spaces to end to maxWidth.\n\nNo → Step 8: Compute totalSpaces = maxWidth - lineLen // spaces to distribute\n\n→ Step 9: Compute slots = i - lineStart - 1 // gaps between words\n\n→ Step 10: baseSpace = totalSpaces // slots // minimum spaces per slot\n\n→ Step 11: extraSpace = totalSpaces % slots // leftover spaces to assign to leftmost slots\n\n→ Step 12: Build line: for each word except last, append word + baseSpace + (if extraSpace > 0 then 1 space, decrement extraSpace)\n\n→ Step 13: Append last word\n\n→ Step 14: Append built line to result list\n\nAfter building, loop back to Decision: i < len(words)?\n\nEnd // finish\n\nAlso need to add Step 15: Return result\n\nLet's produce each line.\n\nNeed to be careful with arrow indentation? Use → for steps. Use Decision with Yes →, No →.\n\nWe'll produce lines accordingly.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← 0 // 初始化單詞索引  \n→ Step 2: result ← [] // 用於儲存格式化後的行  \n→ Decision: i < len(words) ? // 是否還有未處理的單詞  \n    Yes → Step 3: lineStart ← i // 當前行的起始單詞索引  \n    → Step 4: lineLen ← 0 // 當前行單詞總長度  \n    → Step 5: Decision: i < len(words) AND lineLen + len(words[i]) + (i - lineStart) ≤ maxWidth ? // 判斷能否把下一個單詞加入行  \n        Yes → Step 6: lineLen ← lineLen + len(words[i]) // 加入單詞長度  \n        → Step 7: i ← i + 1 // 移動到下一個單詞  \n        No → Step 8: // 無法再加入單詞，開始組裝此行  \n            → Decision: (i == len(words)) OR (i - lineStart == 1) ? // 是最後一行或只有一個單詞  \n                Yes → Step 9: line ← join(words[lineStart:i], \" \") // 用單個空格連接單詞  \n                → Step 10: line ← line + repeat(\" \", maxWidth - len(line)) // 右側補空格  \n                No  → Step 11: totalSpaces ← maxWidth - lineLen // 本行需要分配的空格總數  \n                → Step 12: slots ← i - lineStart - 1 // 單詞之間的空隙數  \n                → Step 13: baseSpace ← totalSpaces // slots // 每個空隙的最小空格數  \n                → Step 14: extraSpace ← totalSpaces % slots // 需要額外分配的空格數  \n                → Step 15: line ← \"\" // 初始化行字符串  \n                → Decision: j = lineStart TO i-2? // 對於每個除最後一個之外的單詞  \n                    Yes → Step 16: line ← line + words[j] + repeat(\" \", baseSpace) + (extraSpace > 0 ? \" \" : \"\") // 加入單詞和空格  \n                    → Step 17: if extraSpace > 0 then extraSpace ← extraSpace - 1 // 左側空隙已經多分配一個空格  \n                    No  → Step 18: line ← line + words[i-1] // 加入最後一個單詞  \n                → Step 19: // 行已組裝完畢  \n            → Step 20: result ← append(result, line) // 將行加入結果  \n    → Step 21: // 回到外層 Decision，檢查是否還有單詞待處理  \n→ Decision: i < len(words) ? // 仍有未處理單詞  \n    Yes → … // 重複上述流程  \n    No → Step 22: return result // 返回完整的文字對齊結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[None,True,False,True,2,True,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[None, True, False, True, 2, True, 2]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport collections\nimport ast\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 存放所有元素，方便 O(1) 隨機存取\n        self.data = []\n        # val -> set of indices 在 data 中的所有位置\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"將 val 插入集合。若是第一次插入回傳 True，否則 False。\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"若存在則移除一個 val，回傳 True；否則回傳 False。\"\"\"\n        if not self.idx_map[val]:\n            return False\n\n        # 取任意一個索引要被移除\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        # 若要移除的不是最後一個，先把最後一個元素搬到要移除的位置\n        if remove_idx != len(self.data) - 1:\n            self.data[remove_idx] = last_val\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(len(self.data) - 1)\n        # 刪除最後一個元素\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機回傳一個元素。\"\"\"\n        return random.choice(self.data)\n\ndef main():\n    input_str = sys.stdin.read().strip()\n    if not input_str:\n        return\n\n    # 分離兩個列表：操作與參數\n    split_idx = input_str.find('],')\n    ops_part = input_str[:split_idx + 1]\n    args_part = input_str[split_idx + 2:]\n\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    rc = RandomizedCollection()\n    result = []\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            result.append(None)\n        elif op == \"insert\":\n            result.append(rc.insert(arg[0]))\n        elif op == \"remove\":\n            result.append(rc.remove(arg[0]))\n        elif op == \"getRandom\":\n            result.append(rc.getRandom())\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for implementing RandomizedCollection. The requirement: provide steps in order, with arrows, decisions, etc. Probably we should show high-level design: maintain vector of values, and hash map from value to set of indices in vector. Then insert: add to vector, add index to map. Remove: if not present, return false. Else, remove an index from set; if it's not the last element, swap with last, update map of swapped element. Remove last from vector. Return true. getRandom: pick random index.\n\nWe need to output in the required format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrow \"→\" for steps and decisions. Provide structure like Start, End, Decision:. We'll likely break into main functions.\n\nWe'll present steps for initialization, insert, remove, getRandom. Use pseudo-code.\n\nWe'll keep it line-by-line, not actual code, just conceptual.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 建立空 vector values // 用來存放所有元素\n→ Step 2: 建立 map valueIndices : val -> set of indices // 追蹤每個值在 vector 的位置\n\nFor insert:\n\n→ Function insert(val)\n    → Decision: val 是否已存在於 map? // 判斷是否第一次插入\n        Yes → Step A: 在 map[val] 中加入 values.size() // 新位置\n              Step B: 在 values 補上 val\n              Step C: 回傳 false // 不是第一次插入\n        No  → Step D: 在 map[val] 中加入 values.size()\n              Step E: 在 values 補上 val\n              Step F: 回傳 true // 第一次插入\n\nBut we must use a generic step. Let's use simpler: Always add; before adding check existence.\n\nRemove:\n\n→ Function remove(val)\n    → Decision: map[val] 是否為空? // 無此值\n        Yes → Step G: 回傳 false // 沒有需要移除\n        No  → Step H: 取任意一個索引 idx 從 map[val] 取出\n              Step I: 取 lastVal = values.back()\n              Step J: 把 values[idx] 設為 lastVal\n              Step K: 在 map[lastVal] 中移除 indices of last element\n              Step L: 在 map[lastVal] 中加入 idx\n              Step M: 從 values 刪除最後一個元素\n              Step N: 在 map[val] 中移除 idx\n              Step O: 回傳 true\n\ngetRandom:\n\n→ Function getRandom()\n    → Step P: 產生隨機索引 r 在 [0, values.size()-1]\n    → Step Q: 回傳 values[r]\n\nEnd // 程式結束\n\nBut need to maintain update of indices sets properly.\n\nLet's craft final answer with proper arrow and decisions. Ensure each line includes the virtual code and explanation comment. Use \"Decision:\" lines with Yes → and No →. Use \"Start\" \"End\". Provide step numbers? Not required. But each line should be \"虛擬碼步驟 // 解釋\". We can include \"→\" at beginning for steps inside functions. Use \"Decision:\" lines accordingly.\n\nLet's produce the final output.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 建立空 vector values // 用於儲存所有元素，支援 O(1) 隨機存取\n→ Step 2: 建立 map valueIndices : int → set<int> // 追蹤每個值在 values 中的所有索引，支援 O(1) 插入與刪除\n\n// =====================\n//  Insert 操作\n// =====================\n→ Function insert(val)\n    → Decision: valueIndices.contains(val)? // 判斷是否已存在此值\n        Yes → Step 3: 在 valueIndices[val] 中加入 values.size() // 新增索引\n              Step 4: values.append(val) // 將值放入最後\n              Step 5: Return false // 不是第一次插入\n        No  → Step 6: 在 valueIndices[val] 中加入 values.size() // 新增索引\n              Step 7: values.append(val) // 將值放入最後\n              Step 8: Return true // 第一次插入\n\n// =====================\n//  Remove 操作\n// =====================\n→ Function remove(val)\n    → Decision: valueIndices[val] 為空? // 無此值可刪除\n        Yes → Step 9: Return false // 無元素可刪\n        No  → Step 10: 取任意一個 idx 從 valueIndices[val] 取出 // 需要移除的索引\n              Step 11: 取 lastVal = values.last() // 最後一個元素\n              Step 12: values[idx] ← lastVal // 用最後一個元素覆蓋要刪除的位置\n              Step 13: valueIndices[lastVal].remove(values.size()-1) // 移除最後一個元素的舊索引\n              Step 14: valueIndices[lastVal].add(idx) // 加入新索引\n              Step 15: values.pop() // 刪除最後一個元素\n              Step 16: valueIndices[val].remove(idx) // 移除要刪除的索引\n              Step 17: Return true // 成功刪除\n\n// =====================\n//  getRandom 操作\n// =====================\n→ Function getRandom()\n    → Step 18: 產生隨機整數 r ∈ [0, values.size()-1] // 隨機索引\n    → Step 19: Return values[r] // 直接回傳隨機元素\n\nEnd // 程式結束"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "actual_output_or_error": "File \"/tmp/tmpoysgits2.py\", line 31\n    \"\"\"將輸入字串轉成 (startGene, endGene, bank)」\n    ^\nSyntaxError: unterminated triple-quoted string literal (detected at line 56)"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "File \"/tmp/tmpa6wa5eix.py\", line 31\n    \"\"\"將輸入字串轉成 (startGene, endGene, bank)」\n    ^\nSyntaxError: unterminated triple-quoted string literal (detected at line 56)"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list[str]) -> int:\n        \"\"\"返回最少突變步數，若無法完成則回傳 -1\"\"\"\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n            for i in range(len(current)):\n                for g in genes:\n                    if g == current[i]:\n                        continue\n                    mutation = current[:i] + g + current[i+1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"將輸入字串轉成 (startGene, endGene, bank)」\n    # 取出 startGene\n    start_match = re.search(r'startGene\\s*=\\s*\"([^\"]+)\"', data)\n    start_gene = start_match.group(1) if start_match else \"\"\n\n    # 取出 endGene\n    end_match = re.search(r'endGene\\s*=\\s*\"([^\"]+)\"', data)\n    end_gene = end_match.group(1) if end_match else \"\"\n\n    # 取出 bank 列表\n    bank_match = re.search(r'bank\\s*=\\s*\\[(.*?)\\]', data, re.DOTALL)\n    bank_list_raw = bank_match.group(1).strip() if bank_match else \"\"\n    if bank_list_raw:\n        # 拆成單獨字串並移除可能的空白與引號\n        bank = [s.strip().strip('\"').strip(\"'\") for s in bank_list_raw.split(',') if s.strip()]\n    else:\n        bank = []\n\n    return start_gene, end_gene, bank\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    start_gene, end_gene, bank = parse_input(raw_data)\n    sol = Solution()\n    result = sol.minMutation(start_gene, end_gene, bank)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving minimum mutation problem. Use BFS. Provide each step line. Each line with \"→ Step X:\" and explanation. Must include decision branches, loops etc. We'll outline:\n\nStart\n→ Initialize visited set, queue\n→ Enqueue start with 0\n→ While queue not empty:\n   → Dequeue gene, level\n   → If gene == endGene: return level\n   → For each position 0-7:\n       → For each char in 'ACGT':\n           → If char != current:\n               → Build newGene\n               → If newGene in bank and not visited:\n                   → Mark visited\n                   → Enqueue newGene, level+1\nEnd // If queue empty return -1\n\nAlso need to check if endGene not in bank return -1 initially.\n\nWe will produce each line of virtual code. Use decisions for checks. Provide explanation comments.\n\nLet's craft. Use indentation? Not necessary, but we can indent using spaces after arrow. Provide decisions with Yes/No arrows.\n\nEnsure each line is \"虛擬碼步驟 // 解釋\". We will include Start, End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 endGene 不在 bank? // 若終點不存在於基因庫，無法完成變異  \n  Yes → Step 1: 返回 -1 // 直接返回失敗結果  \n  No  → Step 2: 建立 visited 集合並加入 startGene // 記錄已訪問的基因"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphq4wbo4z.py\", line 52, in <module>\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    , [[], [1], [2], [], [3], []]\n    ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\nimport ast\n\nclass MedianFinder:\n    def __init__(self):\n        # max-heap for lower half (store negatives)\n        self.small = []\n        # min-heap for upper half\n        self.large = []\n\n    def addNum(self, num: int):\n        heapq.heappush(self.small, -num)\n        # Move element if necessary to maintain order property\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # Balance sizes\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Split into two lists: operations and arguments\n    # Find the first closing bracket of the first list\n    split_idx = data.find('],')\n    if split_idx == -1:\n        # If format differs, try json.loads on the whole string\n        try:\n            parsed = ast.literal_eval(data)\n            ops, args = parsed[0], parsed[1]\n        except Exception:\n            ops, args = [], []\n    else:\n        ops_str = data[:split_idx + 1]\n        args_str = data[split_idx + 1:].strip()\n        ops = ast.literal_eval(ops_str)\n        args = ast.literal_eval(args_str)\n\n    result = []\n    mf = None\n    for i, op in enumerate(ops):\n        if op == \"MedianFinder\":\n            mf = MedianFinder()\n            result.append(None)\n        elif op == \"addNum\":\n            mf.addNum(args[i][0])\n            result.append(None)\n        elif op == \"findMedian\":\n            result.append(mf.findMedian())\n        else:\n            # Unknown operation, ignore or handle as needed\n            result.append(None)\n\n    # Output results using json to get `null` for None\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line explaining algorithm for MedianFinder. The algorithm: maintain two heaps: max-heap for lower half, min-heap for upper half. addNum balances. findMedian returns average of tops or top if odd. Provide steps.\n\nWe need to adhere to format: Each line: \"虛擬碼步驟 // 解釋\". Use arrows and Start End Decision etc. It's a virtual pseudocode. We'll show class definition, constructor, methods. Provide steps. Use decision arrows.\n\nLet's produce:\n\nStart\n→ Step 1: 定義兩個堆: maxHeap, minHeap // maxHeap 儲存較小的一半，minHeap 儲存較大的一半\n→ Step 2: 定義方法 addNum(num) // 將新數加入結構\n   → Decision: maxHeap 空或 num ≤ maxHeap.top? // 判斷應放在哪個堆\n        Yes → Step 3: maxHeap.push(num) // 放入最大堆\n        No  → Step 4: minHeap.push(num) // 放入最小堆\n   → Decision: maxHeap.size() > minHeap.size()+1? // 重新平衡\n        Yes → Step 5: minHeap.push(maxHeap.top()); maxHeap.pop() // 移動最大堆頂到最小堆\n        No  → Decision: minHeap.size() > maxHeap.size()+1? // 另一邊平衡\n            Yes → Step 6: maxHeap.push(minHeap.top()); minHeap.pop() // 移動最小堆頂到最大堆\n            No  → Step 7: // 已平衡\n→ Step 8: 定義方法 findMedian() // 計算中位數\n   → Decision: maxHeap.size() == minHeap.size()? // 是否相等\n        Yes → Step 9: return (maxHeap.top() + minHeap.top()) / 2.0 // 平均\n        No  → Decision: maxHeap.size() > minHeap.size()? // maxHeap 大\n            Yes → Step 10: return maxHeap.top() // maxHeap 顶\n            No  → Step 11: return minHeap.top() // minHeap 顶\nEnd\n\nWe need to include class name? Provide class structure. Use Start, End, Decision.\n\nWe'll ensure each line ends with // 解釋. Provide arrow for each step. Use \"Step X:\" naming.\n\nWe might include class definition lines: \"Class MedianFinder\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義兩個堆: maxHeap, minHeap // maxHeap 儲存小半，minHeap 儲存大半  \n→ Step 2: 定義方法 addNum(num) // 將新數字加入資料結構  \n  → Decision: maxHeap 為空 或 num ≤ maxHeap.top? // 判斷放入哪個堆  \n    Yes → Step 3: maxHeap.push(num) // 放入最大堆  \n    No  → Step 4: minHeap.push(num) // 放入最小堆  \n  → Decision: maxHeap.size() > minHeap.size() + 1? // 重新平衡兩堆大小差距  \n    Yes → Step 5: minHeap.push(maxHeap.top()); maxHeap.pop() // 把最大堆頂移到最小堆  \n    No  → Decision: minHeap.size() > maxHeap.size() + 1? // 另一邊平衡  \n      Yes → Step 6: maxHeap.push(minHeap.top()); minHeap.pop() // 把最小堆頂移到最大堆  \n      No  → Step 7: // 堆已平衡  \n→ Step 8: 定義方法 findMedian() // 計算目前中位數  \n  → Decision: maxHeap.size() == minHeap.size()? // 堆大小相等  \n    Yes → Step 9: return (maxHeap.top() + minHeap.top()) / 2.0 // 取兩堆頂平均值  \n    No  → Decision: maxHeap.size() > minHeap.size()? // maxHeap 较大  \n      Yes → Step 10: return maxHeap.top() // maxHeap 顶即中位数  \n      No  → Step 11: return minHeap.top() // minHeap 顶即中位数  \nEnd // 程式執行結束"
    },
    {
      "title": "Data Stream as Disjoint Intervals",
      "source_file": "Leetcode/leetcode352.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,[[1,1]],null,[[1,1],[3,3]],null,[[1,1],[3,3],[7,7]],null,[[1,3],[7,7]],null,[[1,3],[6,7]]]'\nGot (Norm):      '[null,null,[[1,3],[6,7]],null,[[1,3],[6,7]],null,[[1,3],[6,7]],null,[[1,3],[6,7]],null,[[1,3],[6,7]]]'\n--- (Raw) ---\nRaw Expected: '[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]'\nRaw Got:      '[null, null, [[1, 3], [6, 7]], null, [[1, 3], [6, 7]], null, [[1, 3], [6, 7]], null, [[1, 3], [6, 7]], null, [[1, 3], [6, 7]]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport bisect\n\nclass SummaryRanges:\n    def __init__(self):\n        # 使用 list 存放區間，區間為 [start, end]\n        self.intervals = []\n\n    def addNum(self, val: int) -> None:\n        \"\"\"將新數值加入區間集合，並合併重疊或相鄰區間。\"\"\"\n        if not self.intervals:\n            self.intervals.append([val, val])\n            return\n\n        # 找出插入位置，保證 intervals 按 start 升序\n        i = bisect.bisect_left(self.intervals, [val, val])\n\n        # 先合併左邊可能相鄰或包含 val 的區間\n        if i > 0 and self.intervals[i-1][1] + 1 >= val:\n            i -= 1\n            self.intervals[i][1] = max(self.intervals[i][1], val)\n        else:\n            # 若沒有合併左邊，直接插入\n            self.intervals.insert(i, [val, val])\n\n        # 再合併右邊可能相鄰或包含的區間\n        while i + 1 < len(self.intervals) and self.intervals[i][1] + 1 >= self.intervals[i+1][0]:\n            self.intervals[i][1] = max(self.intervals[i][1], self.intervals[i+1][1])\n            del self.intervals[i+1]\n\n    def getIntervals(self):\n        \"\"\"回傳目前所有區間，保持升序。\"\"\"\n        return self.intervals\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    res = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"SummaryRanges\":\n            obj = SummaryRanges()\n            res.append(None)   # 初始化不回傳任何值\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            res.append(None)   # addNum 不回傳任何值\n        elif op == \"getIntervals\":\n            res.append(obj.getIntervals())\n        else:\n            # 若出現未知操作，忽略\n            res.append(None)\n\n    # 將結果轉成 JSON 格式輸出，Python 的 None 對應 JSON 的 null\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for implementing SummaryRanges class. It's like LeetCode problem 352. Use sorted data structure. Approach: maintain list of intervals, addNum: check where to insert, merge overlapping. We'll produce pseudocode steps line by line with explanation. Use virtual code arrows. Must follow format: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Provide line-by-line steps.\n\nWe should show initialization, addNum, getIntervals.\n\nLet's design pseudocode:\n\nStart\n→ Step 1: Class SummaryRanges: // Define class\n→ Step 2:    Intervals = [] // List to store intervals\n→ Step 3: End // Class definition done\n\nNow methods:\n\nStart addNum\n→ Step 4: void addNum(value) // add integer\n→ Step 5: if Intervals empty? // check if no intervals\n    Yes → Step 6: Append [value, value] to Intervals // new interval\n    No → Step 7: Find position to insert using binary search on start\n        Step 8: i = index of first interval with start > value // binary search\n        Step 9: Check left neighbor interval (i-1) for overlap or adjacency\n        Decision: If left.end +1 >= value? // left interval touches or contains\n            Yes → Step 10: left.end = max(left.end, value) // extend left\n            No → Step 11: Check right neighbor at i for overlap or adjacency\n                Decision: If right.start <= value+1? // touches right\n                    Yes → Step 12: right.start = min(right.start, value) // extend right\n                    No → Step 13: Insert new interval [value, value] at position i\n        // After left extended, need to check if now overlaps right\n        Decision: If left.end +1 >= right.start? // left now touches right\n            Yes → Step 14: Merge left and right: left.end = max(left.end, right.end)\n                    Remove right from Intervals\nEnd addNum\n\ngetIntervals:\nStart getIntervals\n→ Step 15: return copy of Intervals // return list of intervals\nEnd getIntervals\n\nBut we need more systematic pseudocode lines with explanation each line. Ensure each line has \"虛擬碼步驟 // 解釋\".\n\nUse arrow arrow \"→\" for steps. Use Decision: with Yes → and No →.\n\nLet's produce final output with each line separated. Use no code. We'll produce lines starting with Start, then Step numbers.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Class SummaryRanges: // 定義 SummaryRanges 類別\n    → Step 1.1: Intervals = [] // 初始化為空區間列表\n→ End // SummaryRanges 類別定義完成\n\n→ Step 2: void addNum(value): // 方法：將新數字加入流\n    → Step 2.1: Decision: Intervals 為空? // 判斷是否已有區間\n        Yes → Step 2.1.1: Intervals.append([value, value]) // 新增單獨區間\n        No  → Step 2.1.2: i = BinarySearch(Intervals, value) // 找出第一個起點大於 value 的位置\n            → Step 2.1.2.1: left = Intervals[i-1] if i>0 else None // 左側鄰近區間\n            → Step 2.1.2.2: right = Intervals[i] if i < len(Intervals) else None // 右側鄰近區間\n            → Decision: left 並且 left.end + 1 >= value? // 左側區間是否接觸或包含 value\n                Yes → Step 2.1.2.2.1: left.end = max(left.end, value) // 擴大左側區間\n                No  → Decision: right 並且 right.start <= value + 1? // 右側區間是否接觸或包含 value\n                    Yes → Step 2.1.2.2.2.1: right.start = min(right.start, value) // 擴大右側區間\n                    No  → Step 2.1.2.2.2.2: Intervals.insert(i, [value, value]) // 插入新區間\n            // 若左側已擴大，可能與右側接觸\n            → Decision: left 並且 i < len(Intervals) and left.end + 1 >= Intervals[i].start? // 左右接觸檢查\n                Yes → Step 2.1.2.3: left.end = max(left.end, Intervals[i].end) // 合併左右區間\n                      → Step 2.1.2.4: Intervals.pop(i) // 刪除右側原始區間\n                No  → Step 2.1.2.5: // 無需合併，已完成\n→ End // addNum 方法結束\n\n→ Step 3: int[][] getIntervals(): // 方法：取得目前所有區間\n    → Step 3.1: return copy_of(Intervals) // 回傳區間列表的複本\n→ End // getIntervals 方法結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5v9nhru3.py\", line 66, in <module>\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5v9nhru3.py\", line 52, in parse_input\n    intervals = eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqphlc01p.py\", line 66, in <module>\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqphlc01p.py\", line 52, in parse_input\n    intervals = eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def insert(self, intervals, new_interval):\n        \"\"\"\n        Insert a new interval into a sorted list of non-overlapping intervals,\n        merging overlapping ones as necessary.\n\n        :param intervals: List[List[int]] -- sorted by start time, no overlaps\n        :param new_interval: List[int]   -- [start, end] of the interval to insert\n        :return: List[List[int]] -- resulting list after insertion\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # 1. Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < new_interval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # 2. Merge all intervals that overlap with the new interval\n        while i < n and intervals[i][0] <= new_interval[1]:\n            new_interval[0] = min(new_interval[0], intervals[i][0])\n            new_interval[1] = max(new_interval[1], intervals[i][1])\n            i += 1\n\n        # 3. Add the merged interval\n        result.append(new_interval)\n\n        # 4. Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(raw):\n    \"\"\"\n    Parse input of the form:\n        intervals = [[1,3],[6,9]], newInterval = [2,5]\n    into Python objects.\n    \"\"\"\n    intervals = None\n    new_interval = None\n\n    intervals_match = re.search(r'intervals\\s*=\\s*(\\[[^\\]]+\\])', raw)\n    new_match = re.search(r'newInterval\\s*=\\s*(\\[[^\\]]+\\])', raw)\n\n    if intervals_match:\n        intervals = eval(intervals_match.group(1))\n    if new_match:\n        new_interval = eval(new_match.group(1))\n\n    if intervals is None or new_interval is None:\n        raise ValueError(\"Input format incorrect\")\n\n    return intervals, new_interval\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    intervals, new_interval = parse_input(raw_input)\n    solution = Solution()\n    result = solution.insert(intervals, new_interval)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for the problem: insert interval merging into sorted non-overlapping intervals. Provide each line as \"虛擬碼步驟 // 解釋\". Use arrow syntax.\n\nWe need to describe algorithm: iterate through intervals, add those ending before newInterval.start, then merge overlapping, then add remaining after newInterval.end. Steps:\n\nStart\n→ Step 1: Initialize result list\n→ Step 2: For each interval in intervals\n    Decision: If interval.end < new.start // no overlap before\n        Yes → add interval to result\n        No  → Decision: If interval.start > new.end // no overlap after\n              Yes → add newInterval to result; add rest intervals; exit loop\n              No  → // overlapping\n                  Merge: new.start = min(new.start, interval.start)\n                         new.end = max(new.end, interval.end)\nAfter loop, add newInterval if not added\n→ End\n\nExplain each line.\n\nNeed to produce virtual code lines. Each line must include code part and comment. Use \"Start\", \"End\". Use arrows and decisions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← empty list // 建立空的結果列表  \n→ Step 2: newStart ← newInterval[0] // 取得新區間的起點  \n→ Step 3: newEnd ← newInterval[1]   // 取得新區間的終點  \n→ Step 4: addedNew ← False          // 標記是否已把新區間加入結果  \n→ Step 5: For each interval in intervals // 遍歷所有已有區間  \n    Decision:  if interval[1] < newStart // 此區間完全在新區間之前  \n      Yes → Step 6: Append interval to result // 直接加入結果  \n      No  → Decision:  if interval[0] > newEnd // 此區間完全在新區間之後  \n        Yes → Step 7: Append [newStart, newEnd] to result // 加入新區間  \n           → Step 8: Append remaining intervals to result // 加入剩餘區間  \n           → Step 9: addedNew ← True // 標記已加入  \n           → Step 10: Break // 完成所有處理  \n        No  → Step 11: newStart ← min(newStart, interval[0]) // 合併起點  \n           → Step 12: newEnd ← max(newEnd, interval[1])   // 合併終點  \n→ Step 13: If not addedNew // 若迴圈結束時尚未加入新區間  \n      Yes → Step 14: Append [newStart, newEnd] to result // 加入合併後的新區間  \n→ End // 程式執行結束，返回 result。"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nINF = 10 ** 9\nCOLORS = ('R', 'Y', 'B', 'G', 'W')\n\ndef remove_chain(s: str) -> str:\n    \"\"\"Repeatedly remove all groups of 3 or more consecutive identical chars.\"\"\"\n    while True:\n        n = len(s)\n        i = 0\n        removed = False\n        while i < n:\n            j = i\n            while j < n and s[j] == s[i]:\n                j += 1\n            if j - i >= 3:\n                s = s[:i] + s[j:]\n                removed = True\n                break\n            i = j\n        if not removed:\n            break\n    return s\n\ndef dfs(board: str, hand: Counter, memo: dict) -> int:\n    if not board:\n        return 0\n    # 快取鍵：board + 5 個顏色的剩餘數量\n    key = board + '|' + ''.join(str(hand[c]) for c in COLORS)\n    if key in memo:\n        return memo[key]\n    ans = INF\n    n = len(board)\n    i = 0\n    while i < n:\n        j = i\n        while j < n and board[j] == board[i]:\n            j += 1\n        color = board[i]\n        need = 3 - (j - i)  # 需要插入的相同顏色球數\n        if need > 0:\n            if hand[color] >= need:\n                # 嘗試插入\n                new_board = remove_chain(board[:i] + color * need + board[j:])\n                hand[color] -= need\n                res = dfs(new_board, hand, memo)\n                hand[color] += need\n                if res != INF:\n                    ans = min(ans, res + need)\n        i = j\n    memo[key] = ans\n    return ans\n\ndef parse_input(lines):\n    board = ''\n    hand = ''\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n        if 'board' in line:\n            board = line.split('=')[1].strip().strip('\"').strip(\"'\")\n        elif 'hand' in line:\n            hand = line.split('=')[1].strip().strip('\"').strip(\"'\")\n        else:\n            if not board:\n                board = line.strip('\"').strip(\"'\")\n            elif not hand:\n                hand = line.strip('\"').strip(\"'\")\n    return board, hand\n\ndef solve() -> None:\n    data = sys.stdin.read().splitlines()\n    board, hand = parse_input(data)\n    hand_counts = Counter(hand)\n    memo = {}\n    ans = dfs(board, hand_counts, memo)\n    print(-1 if ans == INF else ans)\n\nif __name__ == \"__main__\":\n    solve()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. This is a classic Zuma problem. We need to produce pseudo-code that finds minimal insertions. Likely use DFS/backtracking with pruning and memoization.\n\nWe'll produce steps:\n\nStart\n→ Parse input: board string, hand string\n→ Build hand count map\n→ Define recursive function dfs(board, handCount) returning min insertions or INF\n→ In dfs:\n    → If board empty return 0\n    → If board length > ... (pruning) maybe but skip\n    → For each index i from 0 to len(board):\n         → Determine color at i\n         → Count consecutive same color from i\n         → Need needed = 3 - count\n         → If needed <=0: skip\n         → For each color in handCount with count>0:\n              → If color != current color or (color==current color and needed==0?) Actually we only insert same color to group\n              → If handCount[color] < needed: continue\n              → Simulate insertion: newBoard = board[:i] + color*needed + board[i:]\n              → Remove groups repeatedly: function removeChain\n              → newHandCount = handCount copy; newHandCount[color]-=needed\n              → res = dfs(newBoard, newHandCount)\n              → if res != INF: update min\n    → Return min or INF\n→ Call dfs(board, handCount). If INF return -1 else result.\n\nWe'll need steps for removeChain: while true, find group >=3, remove, repeat.\n\nAlso memoization: use map[string]int with board+handCounts string.\n\nWe'll produce virtual code lines accordingly.\n\nWe must not output actual code, just pseudo-code lines with explanation. Use arrows.\n\nLet's craft step by step.\n\nWe'll incorporate decision branches.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ ParseInput: 讀取 board 與 hand 字串，並建立 handCount[顏色] // 取得手牌數量  \n→ handKey = ToKey(handCount) // 轉為字串作為快取鍵  \n→ memo = {} // 建立快取表  \n\n→ Function DFS(board, handCount) -> int // 回傳最小插入數或 INF  \n  → If board == \"\" : return 0 // 所有球已清除  \n  → key = board + \"|\" + handKey(handCount)  \n  → If memo[key] exists : return memo[key] // 快取結果  \n\n  → minInsert = INF  \n  → For i from 0 to len(board) - 1 : // 嘗試在每個位置插入  \n  →     color = board[i]  \n  →     // 計算在 i 處連續相同顏色球的數量  \n  →     count = 1  \n  →     j = i + 1  \n  →     While j < len(board) and board[j] == color :  \n  →       count++ ; j++  \n  →     needed = 3 - count // 需要插入的相同顏色球數  \n  →     If needed <= 0 : continue // 已滿足三個，跳過  \n  →     For each c in handCount where handCount[c] > 0 : // 嘗試使用手牌  \n  →       If c != color : continue // 只能插入相同顏色以形成組  \n  →       If handCount[c] < needed : continue // 手牌不足  \n  →       // 模擬插入並消除  \n  →       newBoard = board[:i] + c*needed + board[j:]  \n  →       // 連鎖消除：重複消除所有長度>=3的組  \n  →       newBoard = RemoveChains(newBoard)  \n  →       newHand = handCount copy; newHand[c] -= needed  \n  →       res = DFS(newBoard, newHand)  \n  →       If res != INF :  \n  →           minInsert = min(minInsert, res + needed)  \n  →     End For  \n  → End For  \n  → memo[key] = minInsert  \n  → Return minInsert  \nEnd  \n\n→ Function RemoveChains(s) -> string // 重複消除所有三連或以上組  \n  → changed = true  \n  → While changed :  \n  →     changed = false  \n  →     i = 0  \n  →     While i < len(s) :  \n  →       j = i  \n  →       While j < len(s) and s[j] == s[i] : j++  \n  →       If j - i >= 3 : // 找到可消除的組  \n  →           s = s[:i] + s[j:]  \n  →           changed = true  \n  →           break // 重新從頭檢查  \n  →       Else : i = j  \n  →     End While  \n  → End While  \n  → Return s  \nEnd  \n\n→ result = DFS(board, handCount)  \n→ If result == INF : print(-1) // 無法清除  \n→ Else : print(result) // 最小插入數  \nEnd // 程式執行結束"
    },
    {
      "title": "K Inverse Pairs Array",
      "source_file": "Leetcode/leetcode629.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 3, k = 0",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 1",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\n\nMOD = 10 ** 9 + 7\n\ndef count_inverse_pairs(n: int, k: int) -> int:\n    # dp[j] 代表目前已處理的長度（i）下，恰好 j 個逆序對的排列數\n    prev = [0] * (k + 1)\n    prev[0] = 1  # 空序列只有 1 種\n\n    for i in range(1, n + 1):\n        # 前綴和，用來快速計算 dp[i][j]\n        prefix = [0] * (k + 1)\n        prefix[0] = prev[0]\n        for j in range(1, k + 1):\n            prefix[j] = (prefix[j - 1] + prev[j]) % MOD\n\n        cur = [0] * (k + 1)\n        for j in range(k + 1):\n            # dp[i][j] = prefix[j] - prefix[j - i] (若 j >= i)\n            val = prefix[j]\n            if j >= i:\n                val = (val - prefix[j - i]) % MOD\n            cur[j] = val\n        prev = cur\n\n    return prev[k] % MOD\n\ndef main() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    # 讀取兩個整數，忽略其他文字\n    nums = [int(x) for x in data if x.lstrip('-').isdigit()]\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    result = count_inverse_pairs(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for counting number of permutations of 1..n with exactly k inversions. Classic DP: dp[i][j] = sum_{x=0}^{min(j,i-1)} dp[i-1][j-x]. Use prefix sums. Use modulo.\n\nWe output step-by-step.\n\nSteps: Start, initialize dp array size (n+1)*(k+1). dp[0][0]=1. For i from 1 to n: compute prefix sums of dp[i-1]. For j from 0 to k: dp[i][j] = prefix[j] - (j-i>=0?prefix[j-i]:0). Ensure mod. After loops, answer dp[n][k].\n\nReturn dp[n][k].\n\nWe need to produce lines with virtual code and comments. Use arrows. Also use Decision for loops? It's optional.\n\nLet's produce pseudocode step by step. Use Start. Use loops and prefix sums. Provide explanation after each line. Use \"→\" arrow before each step. Use \"Decision:\" for if statements.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize MOD ← 1000000007 // 設定模數  \n→ Initialize dp[0…n][0…k] ← 0 // 建立 2D DP 陣列並填為 0  \n→ Set dp[0][0] ← 1 // 空序列只有 1 種方式，且 0 個逆序對  \n→ For i from 1 to n: // 為每個長度 i 的排列計算  \n  → Initialize prefix[0…k] ← 0 // 前綴和輔助陣列  \n  → For j from 0 to k: // 計算 dp[i-1] 的前綴和  \n    → prefix[j] ← (prefix[j-1] + dp[i-1][j]) mod MOD  // 取前一個加上本值，並取模  \n  → For j from 0 to k: // 根據公式計算 dp[i][j]  \n    → Decision: 如果 j - i ≥ 0? // 檢查是否需要扣除不合法的部分  \n     Yes → dp[i][j] ← (prefix[j] - prefix[j-i] + MOD) mod MOD // 去掉超過 i-1 的項，並保證非負  \n     No  → dp[i][j] ← prefix[j] mod MOD // 直接取前綴和  \n→ End // 所有計算完成  \n→ Return dp[n][k] // 結果即為長度 n、恰好 k 個逆序對的排列數，已取模  \nEnd // 程式執行結束"
    },
    {
      "title": "Stickers to Spell Word",
      "source_file": "Leetcode/leetcode691.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport collections\n\nclass Solution:\n    def minStickers(self, stickers, target):\n        sticker_counts = [collections.Counter(s) for s in stickers]\n        memo = {}\n\n        def dp(rem):\n            if not rem:\n                return 0\n            if rem in memo:\n                return memo[rem]\n            rem_count = collections.Counter(rem)\n            best = float('inf')\n            for sc in sticker_counts:\n                if rem[0] not in sc:\n                    continue\n                # build new remaining string after using this sticker\n                new_rem = []\n                for ch, cnt in rem_count.items():\n                    need = cnt - sc.get(ch, 0)\n                    if need > 0:\n                        new_rem.append(ch * need)\n                new_rem_str = ''.join(new_rem)\n                sub = dp(new_rem_str)\n                if sub != -1:\n                    best = min(best, 1 + sub)\n            memo[rem] = -1 if best == float('inf') else best\n            return memo[rem]\n\n        return dp(target)\n\n\ndef parse_input(inp: str):\n    \"\"\"\n    Parses input like:\n        stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"\n    Returns (list_of_stickers, target_string)\n    \"\"\"\n    inp = inp.strip()\n    if not inp:\n        return [], \"\"\n    # split at 'target ='\n    parts = inp.split('target =')\n    stickers_part = parts[0]\n    target_part = parts[1] if len(parts) > 1 else ''\n    # extract stickers list\n    stickers_list_str = stickers_part.split('=', 1)[1].strip()\n    stickers = eval(stickers_list_str)\n    # extract target string (remove surrounding quotes)\n    target = target_part.strip().strip('\"').strip(\"'\")\n    return stickers, target\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    stickers, target = parse_input(raw_input)\n    solution = Solution()\n    ans = solution.minStickers(stickers, target)\n    print(ans)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the \"Sticker to Spell Word\" problem. We need to output step-by-step pseudocode with arrows and comments. We need to generate a solution: typical DP with bitmask or BFS, but here stickers unlimited. Usually we use BFS or DP on subsets of target. Because target length <=? Not given but maybe small. We'll produce generic algorithm using DP over target subsets or BFS. Provide steps: preprocess stickers to counts, BFS starting from empty string, etc. Use DP to find minimal stickers.\n\nWe'll write pseudocode:\n\nStart\n→ Preprocess: For each sticker, count letter frequencies → store array[26]\n→ Preprocess target: count frequencies or treat as string.\n\nWe can use BFS over states of remaining string; but typical solution uses DP with memoization recursion: for remaining target string sorted, find minimal stickers. We'll outline:\n\nDefine function minStickers(rem): if rem empty return 0\nIf rem in memo return memo[rem]\nminVal = INF\nFor each sticker s:\n    if s can reduce rem (first char present)\n        newRem = remove letters of s from rem\n        val = 1 + minStickers(newRem)\n        minVal = min(minVal, val)\nmemo[rem] = minVal if finite else INF\nReturn memo[rem]\n\nFinally answer = minStickers(target) else -1.\n\nWe will produce pseudocode lines accordingly with comments. Use Start, End, Decision. Provide arrows. Ensure each line ends with comment.\n\nWe need to output only virtual code lines, no actual code. So we use generic placeholders like \"StickerList\" etc.\n\nLet's generate lines.\n\nWe should include \"Start\" etc.\n\nBe careful to maintain indent with arrows. Use \"Decision:\" lines.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Preprocess stickers → For each sticker word, build an array of 26 counts for letters // 建立每張貼紙中各字母的出現次數  \n→ Step 2: Define memoization map // 用於儲存已計算的子問題結果  \n→ Step 3: Function MinStickers(rem) // 以遞迴方式求剩餘字串需要的最少貼紙數  \n\n  → Decision: 如果 rem 為空字串? // 若剩餘字串已無需拼寫  \n   Yes → Return 0 // 完成，無需再貼紙  \n   No →  \n\n    → Decision: 若 rem 在 memo 中? // 已計算過的子問題  \n     Yes → Return memo[rem] // 直接回傳已知答案  \n     No →  \n\n     → Initialize minVal = Infinity // 設定目前最小貼紙數為無限大  \n     → For each stickerCounts in StickerList // 逐一嘗試每張貼紙  \n       → Decision: stickerCounts 是否能覆蓋 rem 的首字母? // 快速過濾  \n        Yes →  \n\n         → Create newRem = Remove letters of stickerCounts from rem // 依貼紙字母數量更新剩餘字串  \n         → Call subAns = MinStickers(newRem) // 取得遞迴答案  \n         → Decision: subAns 為 Infinity? // 若無法完成  \n          No → minVal = min(minVal, 1 + subAns) // 更新最小貼紙數  \n          Yes →  \n\n        →  \n\n       →  \n\n      →  \n\n     →  \n\n    →  \n\n   →  \n\n  → Decision: minVal 為 Infinity? // 若所有貼紙均無法完成  \n    Yes → memo[rem] = Infinity // 標記為無法完成  \n       → Return Infinity  \n    No → memo[rem] = minVal // 儲存最小貼紙數  \n       → Return minVal  \n\n→ Step 4: Compute result = MinStickers(target) // 以目標字串作為初始剩餘字串  \n→ Decision: result 為 Infinity? // 判斷是否不可完成  \n  Yes → Output -1 // 任務無法完成  \n  No  → Output result // 輸出最少貼紙數  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left, right):\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left, right):\n        i = 0\n        while i < len(self.ranges) and self.ranges[i][1] <= left:\n            i += 1\n        if i == len(self.ranges):\n            return False\n        return self.ranges[i][0] <= left and right <= self.ranges[i][1]\n\n    def removeRange(self, left, right):\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main():\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    results = []\n    instance = None\n\n    for line in lines:\n        if line.startswith(\"RangeModule\"):\n            instance = RangeModule()\n            results.append(None)\n        else:\n            m = re.match(r'\\w+\\.(\\w+)\\((.*)\\);', line)\n            if m:\n                method = m.group(1)\n                args_str = m.group(2)\n                args = [int(a.strip()) for a in args_str.split(',') if a.strip()]\n                if method == 'addRange' or method == 'removeRange':\n                    getattr(instance, method)(*args)\n                    results.append(None)\n                elif method == 'queryRange':\n                    res = getattr(instance, method)(*args)\n                    results.append(res)\n\n    output = '[' + ', '.join(\n        'null' if v is None else ('true' if v else 'false') for v in results\n    ) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo-code line by line with explanations. For RangeModule design. We can propose using sorted list of intervals or a balanced BST. Use merge intervals. Provide operations: addRange, queryRange, removeRange. Provide pseudo-code with steps.\n\nLet's produce pseudo-code:\n\nStart // initialize\n\nDefine RangeModule class:\n- intervals list sorted.\n\nFunctions:\n- addRange: merge with existing intervals.\n- queryRange: check if covered by union.\n- removeRange: split intervals.\n\nNeed to output each line with explanation.\n\nWe need to adhere to format: each line: \"虛擬碼步驟 // 解釋/說明\"\n\nUse arrows and structure.\n\nLet's craft.\n\nUse Start, End.\n\nWill produce:\n\nStart // 程式開始執行\n→ Define RangeModule class // 宣告 RangeModule\n→ Start Constructor: intervals = [] // 初始化空區間列表\n→ End Constructor // 建構完成\n→ Start addRange(left, right) // 開始 addRange 方法\n→ Decision: intervals 为空? // 檢查是否已有區間\n   Yes → Step: intervals.append([left, right]) // 若無，直接加入\n   No → Step: Find insert position pos where intervals[pos].right >= left // 找到第一個可能重疊的區間\n→ Step: Merge with overlapping intervals\n   While pos < len(intervals) and intervals[pos].left <= right:\n      left = min(left, intervals[pos].left)\n      right = max(right, intervals[pos].right)\n      Remove intervals[pos]\n→ Step: Insert merged interval [left, right] at position pos\n→ End addRange // addRange 完成\n→ Start queryRange(left, right) // queryRange 方法\n→ Step: For each interval in intervals:\n      If interval.left <= left < right <= interval.right:\n         return True\n      If interval.left > left:\n         return False\n→ End queryRange // queryRange 完成\n→ Start removeRange(left, right) // removeRange 方法\n→ Step: Find first interval that may overlap: pos where intervals[pos].right > left\n→ While pos < len(intervals) and intervals[pos].left < right:\n      cur = intervals[pos]\n      If cur.left < left:\n         // keep left part\n         intervals[pos].right = left\n         pos +=1\n      If cur.right > right:\n         // keep right part\n         intervals.insert(pos+1, [right, cur.right])\n      // remove the overlapping part\n      Remove intervals[pos]\n      pos stays same after removal? adjust accordingly\n→ End removeRange // removeRange 完成\nEnd // 程式結束\n\nBut we need more detailed pseudo steps with arrows and decisions. Provide line numbers? Not needed.\n\nLet's produce line-by-line.\n\nWe must use \"→\" for each step. For decisions use indentation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Define RangeModule class // 定義 RangeModule\n→ Start Constructor // 建構子開始\n    → Step 1: this.intervals = [] // 初始化區間列表\n→ End Constructor // 建構子結束\n→ Start addRange(left, right) // addRange 方法開始\n    → Decision: intervals.isEmpty? // 檢查是否已有區間\n        Yes → Step 1: intervals.append([left, right]) // 無區間則直接加入\n        No  → Step 2: pos = findInsertionIndex(left) // 找到可能重疊的位置\n    → Step 3: While pos < len(intervals) and intervals[pos].left <= right:\n            left = min(left, intervals[pos].left) // 合併左端\n            right = max(right, intervals[pos].right) // 合併右端\n            intervals.remove(pos) // 刪除重疊區間\n    → Step 4: intervals.insert(pos, [left, right]) // 插入合併後區間\n→ End addRange // addRange 完成\n→ Start queryRange(left, right) // queryRange 方法開始\n    → Decision: intervals.isEmpty? // 無區間直接不滿足\n        Yes → Step 1: return False\n        No  → For each interval in intervals:\n                → Decision: interval.left <= left and interval.right >= right? // 检查是否完全覆盖\n                    Yes → Step 2: return True\n                    No  → Decision: interval.right > left? // 若当前区间仍可能覆盖左端\n                        Yes → Step 3: continue\n                        No  → Step 4: return False\n→ End queryRange // queryRange 完成\n→ Start removeRange(left, right) // removeRange 方法開始\n    → Step 1: pos = findFirstOverlapIndex(left) // 找到第一个可能重叠区间\n    → While pos < len(intervals) and intervals[pos].left < right:\n            cur = intervals[pos]\n            → Decision: cur.left < left? // 需要保留左侧未删除部分\n                Yes → Step 2: cur.right = left // 将右端截断\n                No  → Step 2: intervals.remove(pos) // 完全删除该区间\n            → Decision: cur.right > right? // 需要保留右侧未删除部分\n                Yes → Step 3: intervals.insert(pos+1, [right, cur.right]) // 插入右侧剩余部分\n                No  → Step 3: // 无剩余\n            pos = pos + 1 // 继续检查下一个区间\n→ End removeRange // removeRange 完成\nEnd // 程式結束\n\nBut we need to keep strict formatting: each line starts with \"→\" or \"Start\" etc. Indentation may be needed for nested decisions. Provide comments accordingly.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Define RangeModule class // 定義 RangeModule  \n→ Start Constructor // 建構子開始  \n  → Step 1: this.intervals = [] // 初始化區間列表  \n→ End Constructor // 建構子結束  \n\n→ Start addRange(left, right) // addRange 方法開始  \n  → Decision: intervals.isEmpty? // 檢查是否已有區間  \n   Yes → Step 1: intervals.append([left, right]) // 無區間則直接加入  \n   No  → Step 2: pos = findInsertionIndex(left) // 找到第一個可能重疊的位置  \n  → Step 3: While pos < len(intervals) and intervals[pos].left <= right:  \n    left = min(left, intervals[pos].left) // 合併左端  \n    right = max(right, intervals[pos].right) // 合併右端  \n    intervals.remove(pos) // 刪除重疊區間  \n  → Step 4: intervals.insert(pos, [left, right]) // 插入合併後區間  \n→ End addRange // addRange 完成  \n\n→ Start queryRange(left, right) // queryRange 方法開始  \n  → Decision: intervals.isEmpty? // 無區間直接不滿足  \n   Yes → Step 1: return False  \n   No  → For each interval in intervals:  \n     → Decision: interval.left <= left and interval.right >= right? // 檢查是否完全覆蓋  \n      Yes → Step 2: return True  \n      No  → Decision: interval.right > left? // 檢查左端是否仍在此區間內  \n       Yes → Step 3: continue // 檢查下一個區間  \n       No  → Step 4: return False // 左端不在任何區間內  \n→ End queryRange // queryRange 完成  \n\n→ Start removeRange(left, right) // removeRange 方法開始  \n  → Step 1: pos = findFirstOverlapIndex(left) // 找到第一個可能重疊的區間  \n  → While pos < len(intervals) and intervals[pos].left < right:  \n    cur = intervals[pos]  \n    → Decision: cur.left < left? // 需要保留左側未刪除部分  \n     Yes → Step 2: cur.right = left // 將右端截斷至 left  \n     No  → Step 2: intervals.remove(pos) // 完全刪除該區間  \n    → Decision: cur.right > right? // 需要保留右側未刪除部分  \n     Yes → Step 3: intervals.insert(pos+1, [right, cur.right]) // 插入右側剩餘部分  \n     No  → Step 3: // 無剩餘，直接繼續  \n    pos = pos + 1 // 前進到下一個區間  \n→ End removeRange // removeRange 完成  \n\nEnd // 程式結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9uks16ry.py\", line 62, in <module>\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0\n        self.count = 0\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n    ops = json.loads(data[0])\n    args = json.loads(data[1]) if len(data) > 1 else []\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(arg[0])\n            res.append(None)\n        elif op == \"insertFront\":\n            res.append(obj.insertFront(arg[0]))\n        elif op == \"insertLast\":\n            res.append(obj.insertLast(arg[0]))\n        elif op == \"deleteFront\":\n            res.append(obj.deleteFront())\n        elif op == \"deleteLast\":\n            res.append(obj.deleteLast())\n        elif op == \"getFront\":\n            res.append(obj.getFront())\n        elif op == \"getRear\":\n            res.append(obj.getRear())\n        elif op == \"isEmpty\":\n            res.append(obj.isEmpty())\n        elif op == \"isFull\":\n            res.append(obj.isFull())\n        else:\n            # 未預期的操作，跳過\n            res.append(None)\n\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for MyCircularDeque implementation, using virtual code lines and explanations, following format. Must not output actual code. Use arrow and structure. Let's produce steps: Start, initialize array, head, tail pointers, size, capacity. Then implement insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Each function has steps. We'll list them line by line. Use virtual arrows. Use Decision blocks. Ensure each line has code plus comment. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告陣列 buffer[capacity] // 用來存儲雙端佇列元素  \n→ Step 2: 初始化 head = 0 // 指向前端索引  \n→ Step 3: 初始化 tail = 0 // 指向後端索引  \n→ Step 4: 初始化 size = 0 // 目前佇列元素個數  \n→ Step 5: 保存最大容量 capacity = k // 佇列可容納的最大元素數  \n\n// --------------------- insertFront ---------------------  \n→ Function insertFront(val) // 新增元素到前端  \n    → Decision: 如果 isFull()? // 檢查佇列是否已滿  \n        Yes → Return False // 已滿，操作失敗  \n        No  → head = (head - 1 + capacity) % capacity // 移動前端索引往前  \n              → buffer[head] = val // 放入新元素  \n              → size++ // 元素數量加一  \n              → Return True // 操作成功  \n\n// --------------------- insertLast ---------------------  \n→ Function insertLast(val) // 新增元素到後端  \n    → Decision: 如果 isFull()? // 檢查佇列是否已滿  \n        Yes → Return False // 已滿，操作失敗  \n        No  → buffer[tail] = val // 放入新元素  \n              → tail = (tail + 1) % capacity // 移動後端索引往後  \n              → size++ // 元素數量加一  \n              → Return True // 操作成功  \n\n// --------------------- deleteFront ---------------------  \n→ Function deleteFront() // 刪除前端元素  \n    → Decision: 如果 isEmpty()? // 檢查佇列是否為空  \n        Yes → Return False // 空，操作失敗  \n        No  → head = (head + 1) % capacity // 移動前端索引往後  \n              → size-- // 元素數量減一  \n              → Return True // 操作成功  \n\n// --------------------- deleteLast ---------------------  \n→ Function deleteLast() // 刪除後端元素  \n    → Decision: 如果 isEmpty()? // 檢查佇列是否為空  \n        Yes → Return False // 空，操作失敗  \n        No  → tail = (tail - 1 + capacity) % capacity // 移動後端索引往前  \n              → size-- // 元素數量減一  \n              → Return True // 操作成功  \n\n// --------------------- getFront ---------------------  \n→ Function getFront() // 取得前端元素  \n    → Decision: 如果 isEmpty()? // 檢查佇列是否為空  \n        Yes → Return -1 // 空，返回 -1  \n        No  → Return buffer[head] // 回傳前端元素值  \n\n// --------------------- getRear ---------------------  \n→ Function getRear() // 取得後端元素  \n    → Decision: 如果 isEmpty()? // 檢查佇列是否為空  \n        Yes → Return -1 // 空，返回 -1  \n        No  → rearIndex = (tail - 1 + capacity) % capacity // 計算最後一個元素索引  \n              → Return buffer[rearIndex] // 回傳後端元素值  \n\n// --------------------- isEmpty ---------------------  \n→ Function isEmpty() // 檢查佇列是否為空  \n    → Return size == 0 // 若元素數量為零則為空  \n\n// --------------------- isFull ---------------------  \n→ Function isFull() // 檢查佇列是否已滿  \n    → Return size == capacity // 若元素數量等於最大容量則已滿  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        content_map = defaultdict(list)\n        for path in paths:\n            parts = path.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content[:-1]  # 去掉最後的 ')'\n                content_map[content].append(root + '/' + name)\n        return [files for files in content_map.values() if len(files) > 1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入字串中取得列表表達式\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    paths = ast.literal_eval(expr)\n    solution = Solution()\n    result = solution.findDuplicate(paths)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode in the required format. Use Start, End, Decision etc. We need to parse input list, build map from content to file paths, then output groups with size>1. Provide each line with explanation comment.\n\nLet's produce lines:\n\nStart\n→ Step 1: Initialize empty map contentToPaths // key: file content, value: list of file paths\n→ Step 2: For each dirInfo in paths // iterate over input strings\n    → Step 3: Split dirInfo by space into parts // first part is directory path, rest are file infos\n    → Step 4: directory = parts[0] // get directory path\n    → Decision: 如果 parts 长度 > 1? // check if there are file infos\n        Yes → Loop over parts[1:] // each file info\n            → Step 5: Split fileInfo by '(' to get fileName and contentPart // e.g., f1.txt(f1_content)\n            → Step 6: fileName = split[0] // file name\n            → Step 7: content = split[1] without trailing ')' // file content\n            → Step 8: fullPath = directory + \"/\" + fileName // construct full path\n            → Step 9: Append fullPath to contentToPaths[content] // add to map\n        No → // no files, continue\n    End if\nEnd for\n→ Step 10: Initialize result list // empty list of lists\n→ Step 11: For each entry in contentToPaths\n    → Decision: If entry.value length >= 2? // only duplicates\n        Yes → Append entry.value to result // add group\n        No → // skip\n    End if\nEnd for\nEnd // output result\n\nWe must use arrows, etc. Provide each line with explanation. Use \"→\" for next step, indentation. Must use \"Decision:\" and \"Yes →\", \"No →\". Provide Start, End. Ok. Let's produce.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Initialize empty map contentToPaths // 建立內容到檔案路徑的映射\n→ Step 2: For each dirInfo in paths // 遍歷輸入的目錄資訊\n    → Step 3: Split dirInfo by space into parts // 先把字串以空格切開，第一項是目錄路徑，後面是檔案資訊\n    → Step 4: directory = parts[0] // 取得目錄路徑\n    → Decision: 是否有檔案資訊? (parts 长度 > 1?) // 檢查是否存在檔案\n        Yes →\n            → Step 5: 循環遍歷 parts[1:] // 每個檔案資訊\n                → Step 6: Split fileInfo by '(' 成 fileName 與 contentPart // 例如 \"a.txt(a_content)\"\n                → Step 7: fileName = split[0] // 檔案名稱\n                → Step 8: content = split[1] 去除最後的 ')' // 檔案內容\n                → Step 9: fullPath = directory + \"/\" + fileName // 組合完整路徑\n                → Step 10: Append fullPath to contentToPaths[content] // 把路徑加入對應內容的列表\n        No → // 若無檔案資訊，直接跳過\n    End if\nEnd for\n→ Step 11: Initialize result list // 準備儲存重複檔案組\n→ Step 12: For each entry in contentToPaths // 遍歷內容映射\n    → Decision: 內容對應的檔案數量 >= 2? // 只保留重複的內容\n        Yes →\n            → Step 13: Append entry.value to result // 加入此組重複檔案\n        No →\n            → Step 14: // 內容唯一，忽略\n    End if\nEnd for\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp11_96nxg.py\", line 40, in <module>\n    main()\n  File \"/tmp/tmp11_96nxg.py\", line 36, in main\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmp11_96nxg.py\", line 18, in rand10\n    a = rand7()\n        ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2dbyzo43.py\", line 40, in <module>\n    main()\n  File \"/tmp/tmp2dbyzo43.py\", line 36, in main\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmp2dbyzo43.py\", line 18, in rand10\n    a = rand7()\n        ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwwnvpuph.py\", line 40, in <module>\n    main()\n  File \"/tmp/tmpwwnvpuph.py\", line 36, in main\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmpwwnvpuph.py\", line 18, in rand10\n    a = rand7()\n        ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        }
      ],
      "generated_code": "import sys\nimport re\n\n# 假設環境已經提供 rand7() API，這裡不重新實作\n# 如果需要測試，可取消以下註解並引入 random\n# import random\n# def rand7():\n#     return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        \"\"\"\n        使用兩次 rand7() 產生 1~49 的均勻分布。\n        若結果小於等於 40，則轉換為 1~10；否則重試。\n        \"\"\"\n        while True:\n            # 第一次 rand7()\n            a = rand7()\n            # 第二次 rand7()\n            b = rand7()\n            # 轉換為 1~49\n            val = (a - 1) * 7 + b\n            if val <= 40:\n                # 只接受前 40 個值，轉換為 1~10\n                return 1 + (val - 1) % 10\n\ndef main():\n    # 從 stdin 讀取整個輸入，並提取第一個整數作為 n\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating uniform random 1-10 using rand7() only, no other random. Classic approach: use two rand7 calls to get 1-49. Accept if <=40, then mod 10. If >40, reject and retry. Or use rejection sampling. Virtual code lines.\n\nWe must output step-by-step virtual code lines with explanation comment after each line.\n\nInclude Start, End, Decision etc.\n\nWe also need to include a step for generating two rand7 results, combine them: (a-1)*7 + b -> 1-49. Then check <=40.\n\nWe need to handle loop until accepted. So maybe a repeat loop.\n\nLet's produce:\n\nStart\n→ Step 1: Repeat\n    → Step 2: r1 = rand7() // get first random\n    → Step 3: r2 = rand7() // second random\n    → Step 4: val = (r1 - 1) * 7 + r2 // map to 1-49\n    → Decision: if val <= 40?\n        Yes → Step 5: return (val - 1) % 10 + 1 // map to 1-10\n        No  → Step 6: go back to Repeat // reject and retry\nEnd\n\nNeed to ensure loop structure: Use Start, then a loop maybe indicated by a label \"Loop:\".\n\nWe can write:\n\nStart\n→ Loop: // begin retry loop\n    → Step 1: r1 = rand7()\n    → Step 2: r2 = rand7()\n    → Step 3: val = (r1 - 1) * 7 + r2\n    → Decision: if val <= 40?\n        Yes → Step 4: return (val - 1) % 10 + 1\n        No  → Step 5: goto Loop // repeat\nEnd\n\nBut need virtual code lines with arrow and comment. Use \"→\" before each step.\n\nWe also can add indent for decisions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Loop: // 進入重複嘗試的迴圈\n    → Step 1: r1 = rand7() // 取得第一個隨機數 1~7\n    → Step 2: r2 = rand7() // 取得第二個隨機數 1~7\n    → Step 3: val = (r1 - 1) * 7 + r2 // 將兩個數合併為 1~49\n    → Decision: 如果 val <= 40? // 只接受前 40 個值\n        Yes → Step 4: return (val - 1) % 10 + 1 // 轉換為 1~10\n        No  → Step 5: goto Loop // 失敗，重新嘗試\nEnd // 程式執行結束\n\nNeed to ensure each line includes comment after space. Yes.\n\nWe should keep each line as a separate output line.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Loop: // 進入重複嘗試的迴圈  \n    → Step 1: r1 = rand7() // 取得第一個隨機數 1~7  \n    → Step 2: r2 = rand7() // 取得第二個隨機數 1~7  \n    → Step 3: val = (r1 - 1) * 7 + r2 // 將兩個數合併為 1~49  \n    → Decision: 如果 val <= 40? // 只接受前 40 個值  \n        Yes → Step 4: return (val - 1) % 10 + 1 // 轉換為 1~10  \n        No  → Step 5: goto Loop // 失敗，重新嘗試  \nEnd // 程式執行結束"
    },
    {
      "title": "Reverse Integer",
      "source_file": "Leetcode/leetcode7.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reverse(self, x: int) -> int:\n        INT_MAX = 2 ** 31 - 1\n        INT_MIN = -2 ** 31\n        rev = 0\n        while x != 0:\n            pop = x % 10          # 取出最後一位\n            x //= 10              # 去掉已處理的位\n            # 檢查乘 10 + pop 是否會導致溢出\n            if rev > INT_MAX // 10 or (rev == INT_MAX // 10 and pop > 7):\n                return 0\n            if rev < INT_MIN // 10 or (rev == INT_MIN // 10 and pop < -8):\n                return 0\n            rev = rev * 10 + pop\n        return rev\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 從輸入中找出第一個整數\n    nums = re.findall(r\"-?\\d+\", data)\n    if nums:\n        x = int(nums[0])\n        sol = Solution()\n        print(sol.reverse(x))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line, with explanations, for reversing a 32-bit signed integer without using 64-bit types. Should handle overflow by returning 0. Must use virtual code with arrows etc.\n\nWe produce steps: Start, get sign, convert to positive maybe, extract digits, reverse building result, check overflow before pushing each digit, etc.\n\nEdge: x = -2147483648 can't be represented as positive int, but we can handle sign separately.\n\nPseudo: Start\n→ Step: read x\n→ Decision: if x == 0 → Step: return 0\n→ Step: isNegative = (x < 0) ? true : false\n→ Step: if isNegative → x = -x (since x is non-zero, safe because -(-2147483648) overflows but we can't store 64-bit; but -2147483648 is min int, can't invert. Actually need to handle carefully: we can treat absolute value using long? Not allowed. Use sign logic: we can take absolute value by negating, but -INT_MIN overflows. Approach: Instead of negating, we can keep x as negative and use absolute logic? Maybe we can use positive extraction by using x = -x for non-min? But we can't store 64-bit. In typical solutions, we convert x to int and use while loop: while (x != 0) { int pop = x % 10; x /= 10; ... } But for negative numbers we can just use pop as x % 10 and division also works. Use absolute sign? Actually for negative numbers we can still pop digits: For x = -123, x % 10 = -3; x / 10 = -12. So we can push negative digits. But building reversed result need to consider sign. Simpler: Use long? Not allowed.\n\nBetter: Use string? Not allowed? Not specified. But typical solution uses while (x != 0) { int pop = x % 10; x /= 10; if (rev > INT_MAX/10 || (rev == INT_MAX/10 && pop > 7)) return 0; ... } For negative numbers, check rev < INT_MIN/10 etc. But rev is int. We can maintain rev as int and check overflow before multiplication/add. Use conditions symmetrical.\n\nSo steps:\n\n1. Read x\n2. rev = 0\n3. While x != 0:\n   a. pop = x % 10\n   b. x = x / 10\n   c. Check overflow: if rev > INT_MAX/10 or (rev == INT_MAX/10 and pop > 7) -> return 0\n              if rev < INT_MIN/10 or (rev == INT_MIN/10 and pop < -8) -> return 0\n   d. rev = rev * 10 + pop\n4. return rev\n\nNo need sign separately.\n\nWe just produce virtual code lines with arrows, decisions for overflow, etc.\n\nNeed to use virtual arrows: → Step 1: ... etc. Provide comments.\n\nWe must produce only steps, each line with virtual code then explanation.\n\nAlso need to include Start and End. So:\n\nStart\n→ Step 1: 初始化 rev = 0 // 反轉數字累計值\n→ Decision: 只要 x != 0? // 循環直到 x 為 0\n    Yes → Step 2: pop = x % 10 // 取出 x 最右邊位數\n    → Step 3: x = x / 10 // 去掉已處理的位數\n    → Decision: 檢查 overflow? // 確認乘 10 + pop 不會超出範圍\n        Yes → Step 4: return 0 // 超出範圍，直接回傳 0\n        No  → Step 5: rev = rev * 10 + pop // 安全累加\n    No → End // 完成全部位數，返回 rev\n\nBut need to incorporate overflow check conditions inside the decision. Virtual code can be \"Decision: 檢查 rev 是否會溢出? // ...\".\n\nHowever we may need to embed the actual condition.\n\nWe could write: Decision: if rev > INT_MAX/10 or (rev == INT_MAX/10 and pop > 7) or rev < INT_MIN/10 or (rev == INT_MIN/10 and pop < -8)? But we can summarise.\n\nWe might show:\n\nDecision: if rev > 214748364 or (rev == 214748364 and pop > 7) or rev < -214748364 or (rev == -214748364 and pop < -8) ?\n\nBut we may use constants like INT_MAX, INT_MIN.\n\nLet's propose:\n\nDecision: if rev > INT_MAX/10 or (rev == INT_MAX/10 and pop > 7) or rev < INT_MIN/10 or (rev == INT_MIN/10 and pop < -8) ?\n\nThen Yes -> Step: return 0.\n\nNo -> rev = rev * 10 + pop.\n\nBut arrow structure might not allow nested decisions inside the main while loop? We can have the while loop, inside we have step, then decision, etc. Use indentation like sample.\n\nSo produce final pseudo code.\n\nWe must ensure each line has \"虛擬碼步驟\" + \" // 解釋\".\n\nLet's produce. Ensure Start and End.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: rev = 0 // 建立反轉數字的累計變數\n→ Decision: x != 0? // 若 x 還有位數未處理，進入循環\n    Yes →\n        → Step 2: pop = x % 10 // 取得 x 的最右邊數字\n        → Step 3: x = x / 10 // 去除已處理的最右邊數字\n        → Decision: rev > INT_MAX/10 或 (rev == INT_MAX/10 且 pop > 7) 或 rev < INT_MIN/10 或 (rev == INT_MIN/10 且 pop < -8)? // 檢查乘 10 加 pop 會否超出 32‑bit 範圍\n            Yes → Step 4: return 0 // 超出範圍，直接回傳 0\n            No  → Step 5: rev = rev * 10 + pop // 安全地累加新位數\n    No  → End // 所有位數已處理，結束循環\n→ Step 6: return rev // 回傳反轉後的整數（若未溢出） \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk44ljf4z.py\", line 47, in <module>\n    price, special, needs = parse_input()\n                            ^^^^^^^^^^^^^\n  File \"/tmp/tmpk44ljf4z.py\", line 40, in parse_input\n    assignments[key.strip()] = ast.literal_eval(val.strip())\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\n                   ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpasp8xzxd.py\", line 47, in <module>\n    price, special, needs = parse_input()\n                            ^^^^^^^^^^^^^\n  File \"/tmp/tmpasp8xzxd.py\", line 40, in parse_input\n    assignments[key.strip()] = ast.literal_eval(val.strip())\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]\n                     ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # baseline cost: buy everything at full price\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            # try every special offer\n            for offer in special:\n                # check if offer can be applied\n                new_needs = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    new_needs.append(curr_needs[i] - offer[i])\n                else:\n                    # offer can be used, compute cost recursively\n                    res = min(res, offer[-1] + dfs(new_needs))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef parse_input():\n    data = sys.stdin.read()\n    assignments = {}\n    for line in data.splitlines():\n        line = line.strip()\n        if not line:\n            continue\n        if '=' in line:\n            key, val = line.split('=', 1)\n            assignments[key.strip()] = ast.literal_eval(val.strip())\n    price = assignments.get('price', [])\n    special = assignments.get('special', [])\n    needs = assignments.get('needs', [])\n    return price, special, needs\n\nif __name__ == \"__main__\":\n    price, special, needs = parse_input()\n    result = Solution().shoppingOffers(price, special, needs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving this LeetCode problem \"Shopping Offers\" (Problem 638). We need to produce step-by-step virtual code using arrows, decisions, Start, End, etc. We must not output actual code. Provide explanation after each line.\n\nWe need to generate algorithm: DFS with memoization (DP) or backtracking with pruning. Steps: Start, define function dfs(needs). If needs in memo: return memo[needs]. Compute cost = sum(price[i]*needs[i]) baseline. For each offer in specials: check if offer can be applied: for all i: offer[i] <= needs[i]. If yes, newNeeds = needs - offer items; cost = min(cost, offerPrice + dfs(newNeeds)). Memoize and return.\n\nAlso need to consider constraints: n <= 6 maybe.\n\nWe produce virtual steps. Use \"Start\" and \"End\". Use arrow lines for steps. For loops, use Decision, etc.\n\nWe need to include all lines. We'll produce a structured algorithm. Use \"Decision:\" lines for condition. Use indentation with tabs maybe? The example uses spaces and indent. We'll mimic same format. Use indentation for nested steps.\n\nWe'll include explanation in Chinese after //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 memo 為字典 // 用來快取已計算的需求組合\n→ Step 2: 定義函式 dfs(needs) // 遞迴計算最小價格\n    → Decision: 是否已經存在於 memo? // 檢查是否已計算\n        Yes → Return memo[needs] // 直接回傳快取值\n        No  → // 需要重新計算\n    → Step 3: baseline ← sum(price[i] * needs[i]) for i in 0..n-1 // 先算全部單品價格\n    → Step 4: best ← baseline // 初始最佳價格為 baseline\n    → Step 5: 對每個 offer 在 specials 做以下\n        → Decision: 這個 offer 是否可以使用? // 檢查所有項目數量不超過需求\n            Yes → \n                → Step 6: newNeeds ← needs - offer.items // 需求減去 offer 的數量\n                → Step 7: offerCost ← offer.price + dfs(newNeeds) // 用 offer 的價格加上遞迴結果\n                → Decision: offerCost < best? // 比較是否更便宜\n                    Yes → best ← offerCost // 更新最佳價格\n                    No  → // 保持現有 best\n            No → // 不可使用，跳過\n    → Step 8: memo[needs] ← best // 將結果存入 memo\n    → Return best // 回傳最小價格\n→ Step 9: 呼叫 dfs(needs) 並回傳結果 // 主程式入口\nEnd // 程式執行結束"
    },
    {
      "title": "Count of Range Sum",
      "source_file": "Leetcode/leetcode327.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [-2,5,-1], lower = -2, upper = 2",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpz3d5ruxw.py\", line 52, in <module>\n    nums, lower, upper = parse_input(input_line)\n                         ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpz3d5ruxw.py\", line 40, in parse_input\n    lower_str, upper_str = rest.split(\",\")\n    ^^^^^^^^^^^^^^^^^^^^\nValueError: too many values to unpack (expected 2)"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def countRangeSum(self, nums, lower, upper):\n        # 先計算前綴和\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n\n        # 分治遞迴計算區間和的數量\n        def sort_and_count(lo, hi):\n            if hi - lo <= 1:\n                return 0\n            mid = (lo + hi) // 2\n            count = sort_and_count(lo, mid) + sort_and_count(mid, hi)\n\n            # 兩指標計算跨越左右兩半的合法區間\n            i = j = mid\n            for left in prefix[lo:mid]:\n                while i < hi and prefix[i] - left < lower:\n                    i += 1\n                while j < hi and prefix[j] - left <= upper:\n                    j += 1\n                count += j - i\n\n            # 合併兩半，保持有序\n            prefix[lo:hi] = sorted(prefix[lo:hi])\n            return count\n\n        return sort_and_count(0, len(prefix))\n\ndef parse_input(line: str):\n    \"\"\"解析輸入字串成 nums, lower, upper\"\"\"\n    line = line.strip()\n    # 取出 nums 部分\n    if line.startswith(\"nums\"):\n        nums_part, rest = line.split(\",\", 1)\n        nums_str = nums_part.replace(\"nums =\", \"\").strip()\n        rest = rest.strip()\n        lower_str, upper_str = rest.split(\",\")\n        lower = int(lower_str.replace(\"lower =\", \"\").strip())\n        upper = int(upper_str.replace(\"upper =\", \"\").strip())\n        nums = eval(nums_str)  # 轉成列表\n        return nums, lower, upper\n    else:\n        # 若輸入格式不符，直接拋出\n        raise ValueError(\"Input format not recognized\")\n\nif __name__ == \"__main__\":\n    # 讀取整行輸入\n    input_line = sys.stdin.read()\n    nums, lower, upper = parse_input(input_line)\n    sol = Solution()\n    result = sol.countRangeSum(nums, lower, upper)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step to solve counting range sums problem. Likely using prefix sums and divide-and-conquer or BIT. We'll produce algorithm: compute prefix sums, then use merge sort counting as in LeetCode 327. We'll provide virtual steps.\n\nLet's outline: Start, compute prefix array sums of length n+1 with sums[0]=0. Then call recursive function countWhileMergeSort(sums, left, right). That returns count and also sorts sums[left:right]. In recursion, split mid, count left and right, then merge and count cross sums. Cross count: for each left element, find how many right elements satisfy lower <= right - left <= upper, using two pointers l and r. Add to count. Then merge sorted halves.\n\nWe'll produce pseudocode line by line. Include explanation.\n\nWe should output each line: \"Start // ...\" etc. We'll use arrow → for steps.\n\nLet's produce. Use indentation with spaces maybe. Provide explanation after //.\n\nNeed to be careful to follow format exactly: Each line has code and comment after space. Use \"→\" arrow.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入陣列 nums、整數 lower、upper // 從使用者處取得必要參數  \n→ Step 2: 建立前綴和數組 sums，長度為 nums.Length + 1，初始化 sums[0] = 0 // 前綴和為計算區間和的工具  \n→ Step 3: for i from 0 to nums.Length - 1  \n  → sums[i + 1] = sums[i] + nums[i] // 計算每個位置的累加和  \n→ Step 4: Call CountWhileMergeSort(sums, 0, sums.Length - 1) → totalCount // 進行遞迴分治並回傳總計數  \n→ Step 5: 輸出 totalCount // 將結果回傳給使用者  \nEnd // 程式執行結束  \n\n// ---------- 下面為 CountWhileMergeSort 函式的虛擬碼 ----------\nStart CountWhileMergeSort(sums, left, right) // 進入遞迴，處理 sums[left…right]  \n → Decision: 如果 left >= right? // 基本情況：子陣列只有一個元素  \n   Yes → Return 0 // 只有一個元素時不可能有合法區間和  \n   No →  // 繼續遞迴  \n   → mid = (left + right) / 2 // 找中點  \n   → count = CountWhileMergeSort(sums, left, mid) + CountWhileMergeSort(sums, mid + 1, right) // 先分別計算左右兩半的合法數量  \n   → // 合併兩半並計算跨越左右兩邊的合法區間和  \n   → temp = 空列表 // 用來儲存合併後的排序結果  \n   → i = left // 左半邊指標  \n   → j = mid + 1 // 右半邊指標  \n   → // 兩個指標遍歷右半邊，找到符合 lower ≤ sums[j] - sums[i] ≤ upper 的範圍  \n   → for k from left to mid:  \n     → while i2 <= right && sums[i2] - sums[k] < lower: i2++ // 移動 i2 以滿足 lower  \n     → while j2 <= right && sums[j2] - sums[k] <= upper: j2++ // 移動 j2 以滿足 upper  \n     → count += (j2 - i2) // 從 i2 到 j2-1 的元素皆符合條件，累加至 count  \n   → // 合併左右兩半為有序序列  \n   → while i <= mid && j <= right:  \n     → if sums[i] <= sums[j]: temp.Append(sums[i]); i++  \n     → else: temp.Append(sums[j]); j++  \n   → while i <= mid: temp.Append(sums[i]); i++  \n   → while j <= right: temp.Append(sums[j]); j++  \n   → // 把排序好的 temp 拷貝回 sums[left…right]  \n   → for idx in 0 to temp.Length - 1: sums[left + idx] = temp[idx]  \n   → Return count // 回傳目前子問題的合法區間數量  \nEnd CountWhileMergeSort // 函式結束  \n\n// ---------- 以上即為整個解法的虛擬碼與逐行解釋 ----------"
    },
    {
      "title": "My Calendar II",
      "source_file": "Leetcode/leetcode731.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, true, true, true, false, true, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6vffen71.py\", line 44, in <module>\n    main()\n  File \"/tmp/tmp6vffen71.py\", line 26, in main\n    data = json.loads(sys.stdin.read())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 66 (char 65)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCalendarTwo:\n    def __init__(self):\n        # 存放已成功預約的區間\n        self.booked = []\n        # 存放已形成雙重重疊的區間\n        self.overlaps = []\n\n    def book(self, start: int, end: int) -> bool:\n        # 若新區間與已經是雙重重疊的任何區間重疊，則會產生三重重疊，拒絕\n        for s, e in self.overlaps:\n            if max(s, start) < min(e, end):\n                return False\n        # 新區間與單一預約重疊時，將重疊部分加入 overlaps\n        for s, e in self.booked:\n            if max(s, start) < min(e, end):\n                self.overlaps.append((max(s, start), min(e, end)))\n        # 成功加入單一預約\n        self.booked.append((start, end))\n        return True\n\ndef main():\n    # 讀取所有輸入，預期為 JSON 格式的兩個列表\n    data = json.loads(sys.stdin.read())\n    commands, args_list = data[0], data[1]\n\n    results = []\n    calendar = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MyCalendarTwo\":\n            calendar = MyCalendarTwo()\n            results.append(None)  # 在輸出中對應 null\n        elif cmd == \"book\":\n            start, end = args\n            results.append(calendar.book(start, end))\n\n    # 輸出結果列表，符合題目示例格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, with explanation after each line. It's a typical problem: MyCalendarTwo. Implementation usually uses arrays for intervals and overlaps. We need to produce pseudocode. Use decision steps.\n\nWe should structure the algorithm: maintain list of single bookings and overlapping double bookings.\n\nPseudo steps:\n\nStart\nInitialize MyCalendarTwo\n→ Step 1: create empty list bookings\n→ Step 2: create empty list overlaps\nBook(start, end)\n→ Step 1: for each existing booking in bookings:\n   → Decision: if booking overlaps with new interval?\n      Yes → Step: add overlapped interval to overlaps list\n      No → continue\n→ Step 2: for each existing overlap in overlaps:\n   → Decision: if overlap overlaps with new interval?\n      Yes → Return false\n→ Step 3: Add new interval to bookings\n→ Return true\n\nWe need to output each line with \"虛擬碼步驟 // 解釋\". Use arrow → for steps. Use Decision: with Yes →, No →.\n\nWe need to include the constructor and book function. Use pseudo code.\n\nAlso need to define overlap function.\n\nLet's produce:\n\nStart\n→ Step 1: MyCalendarTwo() // constructor\n→ Step 2: bookings ← empty list // store single bookings\n→ Step 3: overlaps ← empty list // store double bookings\n→ End // finish initialization\n\nThen book function:\n\n→ Function book(start, end) // book new event\n   → Step 1: for each [s, e] in bookings\n        → Decision: if overlaps [s, e] with [start, end]?\n          Yes → Step 2: overlapStart ← max(s, start)\n          No  → continue\n          Yes → overlapEnd ← min(e, end)\n          → Step 3: add [overlapStart, overlapEnd] to overlaps\n   → Step 4: for each [s, e] in overlaps\n        → Decision: if overlaps [s, e] with [start, end]?\n          Yes → Return false\n          No  → continue\n   → Step 5: add [start, end] to bookings\n   → Return true\n\nBut we need each line as single line of virtual code.\n\nLet's write:\n\nStart // 程式開始執行\n\n→ Step 1: MyCalendarTwo() // 建構子初始化\n→ Step 2: bookings ← [] // 存放單一預約\n→ Step 3: overlaps ← [] // 存放雙重重疊區間\n→ End // 完成初始化\n\nThen book function:\n\n→ Function book(start, end) // 嘗試新增事件\n   → Step 1: for each interval in bookings\n        → Decision: if interval overlaps [start, end]?\n           Yes → overlapStart ← max(interval.start, start)\n           Yes → overlapEnd ← min(interval.end, end)\n           Yes → overlaps.add([overlapStart, overlapEnd])\n           No  → continue\n   → Step 2: for each interval in overlaps\n        → Decision: if interval overlaps [start, end]?\n           Yes → Return false\n           No  → continue\n   → Step 3: bookings.add([start, end]) // 新增事件\n   → Return true // 成功新增\n\nBut need each line separate, with indentation maybe. Use arrow for each step. Decision uses Yes →, No →.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n\n→ Step 1: MyCalendarTwo() // 建構子初始化  \n\n→ Step 2: bookings ← [] // 存放單一預約區間  \n\n→ Step 3: overlaps ← [] // 存放雙重重疊區間  \n\n→ End // 完成初始化  \n\n→ Function book(start, end) // 嘗試新增事件  \n\n  → Step 1: for each interval in bookings  \n    → Decision: interval overlaps [start, end]?  \n      Yes → overlapStart ← max(interval.start, start) // 取得重疊起點  \n      Yes → overlapEnd ← min(interval.end, end) // 取得重疊終點  \n      Yes → overlaps.add([overlapStart, overlapEnd]) // 加入雙重重疊列表  \n      No  → continue // 不重疊，忽略  \n\n  → Step 2: for each interval in overlaps  \n    → Decision: interval overlaps [start, end]?  \n      Yes → Return false // 會產生三重預約，拒絕  \n      No  → continue // 不重疊，檢查下一個  \n\n  → Step 3: bookings.add([start, end]) // 新增成功，將事件加入單一列表  \n\n  → Return true // 事件成功加入，無三重重疊  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Time Based Key-Value Store",
      "source_file": "Leetcode/leetcode981.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,\"bar\",\"bar\",null,\"bar2\",\"bar2\"]'\nGot (Norm):      '[None,None,\"bar\",\"bar\",None,\"bar2\",\"bar2\"]'\n--- (Raw) ---\nRaw Expected: '[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]'\nRaw Got:      \"[None, None, 'bar', 'bar', None, 'bar2', 'bar2']\""
        }
      ],
      "generated_code": "import sys\nimport ast\nimport bisect\nfrom collections import defaultdict\n\nclass TimeMap:\n    def __init__(self):\n        # 每個 key 對應一個 (timestamp, value) 的升序列表\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        # 直接追加，因為調用順序已保證 timestamp 升序\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # bisect_right 找到第一個 > timestamp 的位置，減 1 就是 <= timestamp 的最大索引\n        i = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if i == 0:\n            return \"\"\n        return arr[i - 1][1]\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入並解析為兩個列表\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n    # 將兩個獨立的列表包裝成一個元組後再解析\n    try:\n        ops, args = ast.literal_eval(f\"({raw})\")\n    except Exception as e:\n        # 若解析失敗，直接退出\n        sys.exit(1)\n\n    result = []\n    tm = None\n    for op, arg in zip(ops, args):\n        if op == \"TimeMap\":\n            tm = TimeMap()\n            result.append(None)  # 按 LeetCode 風格返回 null\n        elif op == \"set\":\n            tm.set(*arg)\n            result.append(None)\n        elif op == \"get\":\n            res = tm.get(*arg)\n            result.append(res)\n        else:\n            # 其他未知操作忽略\n            result.append(None)\n\n    # 打印結果，Python 的 list 文字表示符合題目預期\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output pseudocode steps line by line, with virtual code and explanation. Need to implement TimeMap class with set and get. Likely use map from key to list of (timestamp, value) sorted by timestamp. In get, binary search to find largest timestamp <= query. We'll produce steps: Start, initialize map, set, get, binary search. Provide explanations. Should be step by step. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize TimeMap // 建立 TimeMap 物件  \n    → data ← new Map<string, List<(int, string)>> // 每個 key 對應一個按時間升序排列的列表  \n→ Decision: 呼叫 set 或 get? // 根據外部調用決定執行 set 或 get  \n    Yes → Step: set(key, value, timestamp) // 存儲新鍵值  \n        → 若 key 未存在於 data，則 data[key] ← new List  \n        → Append (timestamp, value) 至 data[key] // 追加新時間戳和值  \n        → Step: 保持 data[key] 有序（按 timestamp） // 可使用插入排序或直接插入後排序  \n    No → Step: get(key, timestamp) // 取值  \n        → 若 key 不在 data，返回 \"\" // 無資料  \n        → list ← data[key] // 取得時間戳序列  \n        → binary_index ← BinarySearch(list, timestamp) // 找到最接近且不大於 timestamp 的位置  \n            → 若 binary_index = -1，返回 \"\" // 所有時間戳均大於 timestamp  \n            → 返回 list[binary_index].value // 取得對應值  \n→ End // 程式執行結束  \n\nBinarySearch(list, target)  \n    → left ← 0; right ← list.length - 1  \n    → result ← -1  \n    → While left ≤ right  \n        → mid ← (left + right) / 2  \n        → 若 list[mid].timestamp ≤ target  \n            → result ← mid  \n            → left ← mid + 1 // 向右搜尋更大的 timestamp  \n        → 否則 right ← mid - 1 // 向左搜尋更小的 timestamp  \n    → 返回 result // 最小不大於 target 的索引  \n\nSetOperation(key, value, timestamp)  \n    → 如果 data 中不存在 key，初始化空列表  \n    → 在適當位置插入 (timestamp, value) 以保持時間升序  \n    → （可選）若列表已排序，直接 append，否則使用二分插入  \n\nGetOperation(key, timestamp)  \n    → 若 key 不存在，返回空字串  \n    → 使用 BinarySearch 找到最近的 timestamp  \n    → 若未找到，返回空字串；否則返回相應值"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"Reorder nums so that nums[0] < nums[1] > nums[2] < nums[3] …\"\"\"\n        n = len(nums)\n        for i in range(1, n):\n            # 奇數位應該比前一位大，偶數位應該比前一位小\n            if (i % 2 == 1 and nums[i-1] >= nums[i]) or (i % 2 == 0 and nums[i-1] <= nums[i]):\n                nums[i-1], nums[i] = nums[i], nums[i-1]\n        return nums\n\ndef parse_input(text):\n    \"\"\"從輸入字串中抽取 list，支援 'nums = [ … ]' 的格式。\"\"\"\n    start = text.find('[')\n    if start == -1:\n        return []\n    end = text.rfind(']')\n    if end == -1:\n        return []\n    list_str = text[start:end+1]\n    return ast.literal_eval(list_str)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw = sys.stdin.read().strip()\n    nums = parse_input(raw)\n\n    # 進行 wiggle sort\n    solution = Solution()\n    result = solution.wiggleSort(nums)\n\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm that reorders array into wiggle sort: nums[0] < nums[1] > nums[2] < nums[3] ... Standard solution: iterate i from 1 to n-1, if (i%2==1 && nums[i-1] >= nums[i]) or (i%2==0 && nums[i-1] <= nums[i]) swap.\n\nWe produce steps: Start, Step 1: Input array, Step 2: For i from 1 to n-1, Decision: if i odd and nums[i-1] >= nums[i] or i even and nums[i-1] <= nums[i] then swap, etc. End. Provide explanation each line.\n\nEnsure format: each line: 虛擬碼步驟 + space + // 解釋. Use arrow characters.\n\nLet's generate.\n\nAlso mention input array is provided.\n\nLet's produce.\n\nAlso include Step: For loop. Decision inside loop. Swap.\n\nWill produce maybe 10-12 lines.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 取得待重排的數列  \n→ Step 2: 取得陣列長度 n = nums.Length // 取得元素個數  \n→ Step 3: 從 i = 1 迭代到 n-1 // 只需檢查相鄰元素  \n  → Decision: i 為奇數? // 判斷目前索引是奇數還是偶數  \n   Yes → Step 4a: 判斷 nums[i-1] ≥ nums[i] // 奇數時應為升序，若不符合則需要交換  \n    Decision: 條件成立?  \n     Yes → Step 5a: 交換 nums[i-1] 與 nums[i] // 使 nums[i-1] < nums[i]  \n     No → Step 5b: 無需操作  \n   No → Step 4b: 判斷 nums[i-1] ≤ nums[i] // 偶數時應為降序，若不符合則需要交換  \n    Decision: 條件成立?  \n     Yes → Step 5c: 交換 nums[i-1] 與 nums[i] // 使 nums[i-1] > nums[i]  \n     No → Step 5d: 無需操作  \n→ End // 重排完成，程式執行結束"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9zs05qs4.py\", line 99, in <module>\n    main()\n  File \"/tmp/tmp9zs05qs4.py\", line 68, in main\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[], [1], [2], [], [], []]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    \"\"\"LIFO stack implemented with two queues.\"\"\"\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        \"\"\"Push element x onto stack.\"\"\"\n        self.q1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"Remove the top element and return it.\"\"\"\n        if not self.q1:\n            raise IndexError(\"pop from empty stack\")\n        # Move all but last element from q1 to q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # The last element in q1 is the stack top\n        top_elem = self.q1.popleft()\n        # Swap the queues\n        self.q1, self.q2 = self.q2, self.q1\n        return top_elem\n\n    def top(self) -> int:\n        \"\"\"Return the top element without removing it.\"\"\"\n        if not self.q1:\n            raise IndexError(\"top from empty stack\")\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top_elem = self.q1.popleft()\n        # Put it back into q2 to keep stack unchanged\n        self.q2.append(top_elem)\n        # Swap the queues\n        self.q1, self.q2 = self.q2, self.q1\n        return top_elem\n\n    def empty(self) -> bool:\n        \"\"\"Return True if stack is empty.\"\"\"\n        return not self.q1\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Remove leading 'Input ' if present\n    if data.startswith('Input '):\n        data = data[len('Input '):]\n    # Split operations and arguments\n    # Find the first occurrence of '], [' to split two lists\n    split_idx = data.find('], [')\n    if split_idx == -1:\n        # If format is different, try to parse with json-like split\n        raise ValueError(\"Invalid input format\")\n    ops_str = data[:split_idx]\n    args_str = data[split_idx + 3:]  # skip '], ['\n\n    # Add missing brackets\n    ops_str = ops_str + ']'\n    args_str = '[' + args_str\n\n    # Parse using ast.literal_eval for safety\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    stack = MyStack()\n    outputs = []\n\n    # Skip the first command \"MyStack\"\n    for op, arg in zip(ops[1:], args[1:]):\n        if op == 'push':\n            stack.push(arg[0])\n            outputs.append(None)  # push returns null\n        elif op == 'pop':\n            outputs.append(stack.pop())\n        elif op == 'top':\n            outputs.append(stack.top())\n        elif op == 'empty':\n            outputs.append(stack.empty())\n        else:\n            raise ValueError(f\"Unknown operation: {op}\")\n\n    # Convert outputs to required string representation\n    out_strs = []\n    for item in outputs:\n        if item is None:\n            out_strs.append('null')\n        elif isinstance(item, bool):\n            out_strs.append('true' if item else 'false')\n        else:\n            out_strs.append(str(item))\n    print(f\"[{', '.join(out_strs)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing a stack using two queues. Provide each line with virtual code step and comment. Should be in Chinese (繁體). Follow format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows etc. Provide Start, End, Decision. Let's outline algorithm: Use two queues q1 and q2. For push, enqueue into q1. For pop, move all but last element from q1 to q2, then dequeue last (the one to pop). Then swap q1 and q2. For top, similar to pop but re-enqueue the last back to q2. For empty, check q1 empty. Provide steps.\n\nWe need to produce line-by-line pseudocode with comments.\n\nLet's craft.\n\nStart\n→ Initialize queue1, queue2\n→ Define push(x): // push to q1\n→ enqueue q1\n→ Define pop(): // if q1 empty -> error\n→ if q1 empty: return error\n→ While q1 size > 1: dequeue from q1, enqueue to q2\n→ Dequeue last element from q1 as result\n→ Swap q1 and q2\n→ return result\n→ Define top(): // similar but keep last element\n→ if q1 empty: return error\n→ While q1 size > 1: dequeue from q1, enqueue to q2\n→ Dequeue last element from q1 as result\n→ Enqueue result to q2 // put back\n→ Swap q1 and q2\n→ return result\n→ Define empty(): // return q1 empty\n→ return q1 is empty\nEnd\n\nAlso decision for empty check? Not necessary.\n\nMake sure each line uses virtual code syntax: e.g., \"Start // 程式開始執行\" etc.\n\nLet's produce. Use Chinese comments. Use arrows \"→\". Let's produce lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize queue1, queue2 // 建立兩個空的佇列  \n→ Define push(x): // 定義 push 方法  \n    → Enqueue x into queue1 // 將元素 x 加入 queue1 的尾端  \n→ Define pop(): // 定義 pop 方法  \n    → Decision: queue1 是否為空? // 判斷是否有元素可彈出  \n        Yes → Return error // 若空，回傳錯誤或 null  \n        No  →  \n            → Decision: queue1 的大小 > 1? // 檢查是否有多於一個元素  \n                Yes → While queue1 size > 1: // 將除最後一個外的所有元素移到 queue2  \n                    → Dequeue from queue1, Enqueue into queue2 // 從 queue1 前端取出，放入 queue2 背面  \n                No  → // 只剩一個元素時直接跳出迴圈  \n            → Dequeue last element from queue1 as result // 取出最後一個（即棧頂）  \n            → Swap(queue1, queue2) // 交換兩個佇列，恢復狀態  \n            → Return result // 回傳彈出的元素  \n→ Define top(): // 定義 top 方法  \n    → Decision: queue1 是否為空? // 判斷是否有元素可查看  \n        Yes → Return error // 若空，回傳錯誤或 null  \n        No  →  \n            → Decision: queue1 的大小 > 1? // 檢查是否有多於一個元素  \n                Yes → While queue1 size > 1: // 移動除最後一個外的所有元素到 queue2  \n                    → Dequeue from queue1, Enqueue into queue2  \n                No  → // 只剩一個元素時直接跳出迴圈  \n            → Dequeue last element from queue1 as result // 取出最後一個（棧頂）  \n            → Enqueue result into queue2 // 再把它放回 queue2，保持資料完整  \n            → Swap(queue1, queue2) // 交換佇列，恢復結構  \n            → Return result // 回傳棧頂元素  \n→ Define empty(): // 定義 empty 方法  \n    → Return queue1 is empty // 若 queue1 為空，則棧也空  \nEnd // 程式執行結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpd45uyq05.py\", line 53, in <module>\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpd45uyq05.py\", line 44, in parse_input\n    prereqs = ast.literal_eval(val.strip())\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpus5270y_.py\", line 53, in <module>\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpus5270y_.py\", line 44, in parse_input\n    prereqs = ast.literal_eval(val.strip())\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: list[list[int]]) -> list[int]:\n        # 建立鄰接表與入度陣列\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 佇列中放入所有入度為 0 的節點\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若所有課程都被排完則回傳順序，否則回傳空清單\n        return order if len(order) == numCourses else []\n\ndef parse_input(raw: str):\n    \"\"\"\n    解析輸入字串，格式示例：\n    'numCourses = 2, prerequisites = [[1,0]]'\n    \"\"\"\n    parts = [p.strip() for p in raw.split(',')]\n    num_courses = None\n    prereqs = None\n    for part in parts:\n        if part.startswith('numCourses'):\n            _, val = part.split('=', 1)\n            num_courses = int(val.strip())\n        elif part.startswith('prerequisites'):\n            _, val = part.split('=', 1)\n            prereqs = ast.literal_eval(val.strip())\n    if num_courses is None or prereqs is None:\n        raise ValueError('輸入格式不正確')\n    return num_courses, prereqs\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    numCourses, prerequisites = parse_input(raw_input)\n    solution = Solution()\n    order = solution.findOrder(numCourses, prerequisites)\n    print(order)",
      "virtual_code": "Thinking...\nWe need to output virtual code for topological sort. Use BFS Kahn or DFS. Provide steps line by line with arrows. Provide explanation. No real code. We'll use Kahn. Use queue. Steps: Start, Build adjacency, indegree, push zero indegree, while queue not empty, pop, add to order, for each neighbor reduce indegree, if zero enqueue. After loop, if order size==numCourses return order else empty. End. Include decision. Provide explanation.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立鄰接表 Adj[0…numCourses-1] 與入度陣列 indegree[0…numCourses-1] = 0 // 初始化圖結構  \n→ Step 2: 針對 prerequisites 中每一對 [a, b]  \n  → Add a 到 Adj[b] 的鄰接清單 // b 是 a 的前置課程  \n  → indegree[a] += 1 // 記錄 a 的入度  \n→ Step 3: 建立佇列 Queue  // 用於儲存入度為 0 的節點  \n  → Decision: 如果 indegree[i] == 0? // 檢查每門課是否無前置課程  \n    Yes → Enqueue i into Queue // 可立即選修  \n    No  → 不執行任何動作  \n→ Step 4: 建立空列表 order // 儲存課程排序  \n→ Decision: Queue 是否為空? // 檢查是否還有可選課程  \n  Yes → Step 5: Dequeue v from Queue  \n    → Append v to order // 將 v 加入完成順序  \n    → Decision: v 在 Adj 中有鄰接節點? // 檢查後續課程  \n     Yes → For 每個 u 在 Adj[v]  \n       → indegree[u] -= 1 // 減少後續課程的入度  \n       → Decision: indegree[u] == 0?  \n         Yes → Enqueue u into Queue // 入度為 0 可選修  \n         No  → 不執行任何動作  \n       → 循環結束  \n    → 回到 Decision: Queue 是否為空?  \n     Yes → Step 6: Decision: order.size == numCourses? // 檢查是否所有課程已排序  \n       Yes → Return order // 成功完成所有課程  \n       No  → Return [] // 仍有課程無法完成，表示有環  \n  No  → Step 6: Decision: order.size == numCourses?  \n     Yes → Return order  \n     No  → Return []  \nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            # 初始化 parent，若為根節點則回傳自身\n            if x not in parent:\n                parent[x] = x\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            if len(acc) < 2:\n                continue\n            first_email = acc[1]\n            # 把所有 email 與第一個 email 合併\n            for email in acc[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        result = []\n        for root, emails in merged.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 期望輸入為類似 \"accounts = [...]\" 的文字\n    if data.startswith(\"accounts\"):\n        # 只保留等號右側的字串，並 eval 為 Python 物件\n        _, expr = data.split(\"=\", 1)\n        accounts = eval(expr.strip())\n    else:\n        # 若直接給予列表，可直接 eval\n        accounts = eval(data)\n    sol = Solution()\n    merged_accounts = sol.accountsMerge(accounts)\n    print(merged_accounts)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for merging accounts. Should use virtual code syntax with arrows, decisions, etc. Provide explanation per line. Avoid actual code. Use Start, End, Decision. Provide steps: build graph mapping email->name, build adjacency list of emails, find connected components via DFS/BFS, sort emails, output. Also need to handle same name but different people by email connectivity.\n\nWe should structure as: Start, initialize mapping email->name, adjacency list, iterate accounts: for each email, map email to name, connect to first email of account. Then after building graph, visited set. For each email not visited, DFS to gather component emails, sort, prepend name, append to result. End.\n\nAlso include decisions: if email already in graph. Provide arrows.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\" with line numbers? Not required. Just each line.\n\nLet's craft.\n\nEnsure we include \"Start // 程式開始執行\". Then steps.\n\nWe need to use virtual code arrow →, Decision: if condition, Yes →, No →. Use Start, End.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 email_to_name 映射表與 email_graph 鄰接表 // 用來儲存每個 email 的擁有者姓名及同一帳戶內 email 的連結  \n→ Step 2: 建立 visited 集合，results 列表 // 用於標記已處理的 email 及存放最終合併後的帳戶  \n→ Decision: 對於每一個 account in accounts? // 逐個處理輸入帳戶列表  \n    → Step 3: 取得 name = account[0] // 帳戶擁有者姓名  \n    → Decision: 是否至少有一個 email? // 判斷帳戶中是否存在 email  \n        Yes → Step 4: primary_email = account[1] // 選取帳戶第一個 email 作為連結基準  \n        No → Step 5: Continue // 若無 email，跳過此帳戶  \n    → Decision: primary_email 是否已在 email_to_name?  \n        No → Step 6: email_to_name[primary_email] = name // 為新 email 設定姓名  \n        Yes → Step 7: // 若 email 先前已出現，保留原姓名或確認一致性  \n    → Decision: primary_email 是否在 email_graph?  \n        No → Step 8: email_graph[primary_email] = 空集合 // 建立新的 email 節點  \n        Yes → Step 9: // 其實不需要做任何事  \n    → For each email in account[1:]:  \n        → Decision: email 是否在 email_to_name?  \n            No → Step 10: email_to_name[email] = name // 新 email 加入姓名映射  \n            Yes → // 可能已經存在，跳過  \n        → Decision: email 是否在 email_graph?  \n            No → Step 11: email_graph[email] = 空集合 // 建立新節點  \n            Yes → // 不須做任何事  \n        → Step 12: email_graph[primary_email].add(email) // primary_email 與每個 email 建立雙向邊  \n        → Step 13: email_graph[email].add(primary_email) // 建立雙向連結  \n→ Decision: 是否所有 email 都已處理完? // 準備進行 DFS  \n    Yes → Step 14: For each email in email_to_name.keys():  \n        → Decision: email 是否已在 visited?  \n            Yes → Step 15: Continue // 已處理過的 email 跳過  \n            No → Step 16: 初始化 component_emails 空列表 // 用於收集一個連通分量  \n            → Step 17: 執行 DFS(email, component_emails) // 透過 DFS 搜尋同一個人所有 email  \n            → Step 18: sort(component_emails) // 將 email 按字母序排序  \n            → Step 19: name = email_to_name[component_emails[0]] // 取其中一個 email 的姓名（所有 email 同名）  \n            → Step 20: results.append([name] + component_emails) // 形成合併後的帳戶並加入結果  \n→ End // 程式執行結束  \n\n// DFS(email, component_emails) // 伪函数：標記 email，收集所有連通節點  \n// → visited.add(email)  \n// → component_emails.add(email)  \n// → For each neighbor in email_graph[email]:  \n//     → Decision: neighbor 是否已在 visited?  \n//         No → DFS(neighbor, component_emails)  \n//         Yes → // 已處理，跳過  \n\nEnd // 程式完成並返回 results（結果在 results 列表中）"
    },
    {
      "title": "First Bad Version",
      "source_file": "Leetcode/leetcode278.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 5, bad = 4",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk9abgzpz.py\", line 30, in <module>\n    first_bad = sol.firstBadVersion(n)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk9abgzpz.py\", line 14, in firstBadVersion\n    if isBadVersion(mid):\n       ^^^^^^^^^^^^\nNameError: name 'isBadVersion' is not defined"
        }
      ],
      "generated_code": "import sys\nimport re\n\n# The isBadVersion API is assumed to be defined elsewhere in the environment.\n# For example:\n# def isBadVersion(version: int) -> bool:\n#     ...\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        left, right = 1, n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從輸入中擷取所有整數\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if not nums:\n        raise ValueError(\"輸入中未找到任何數字\")\n    n = nums[0]  # n 為版本總數\n\n    sol = Solution()\n    first_bad = sol.firstBadVersion(n)\n    print(first_bad)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for binary search algorithm to find first bad version. Use Start, End, Decision, etc. Each line has arrow, then step, and comment. Need to minimize API calls. So use binary search between low and high. We'll output steps accordingly.\n\nAlso need to handle n input. We'll assume function FindFirstBadVersion(n). Use while low<high. mid = low + (high-low)/2. Call isBadVersion(mid). If true, high = mid; else low = mid+1. End loop. Return low.\n\nNeed to represent as virtual code. Use Start, Decision, etc. Provide explanatory comments. Provide arrow \"→\" before each line. For decisions use Decision: if ...? then Yes → etc. But loops need representation? Could use Decision: low < high? Then Yes → ... and No → End. But we also have loop.\n\nSimplest: Use while loop representation: Decision: low < high? Yes → Step: compute mid. Decision: isBadVersion(mid)? Yes → Step: high = mid; No → Step: low = mid +1; After loop: Return low.\n\nWe should maintain structure.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: low = 1 // 初始化搜尋區間左端\n\n→ Step 2: high = n // 初始化搜尋區間右端\n\n→ Decision: low < high? // 判斷是否仍有區間可搜尋\n\n    Yes → Step 3: mid = low + (high - low) / 2 // 取中點\n\n    Yes → Decision: isBadVersion(mid)? // 檢查中點版本是否為壞版本\n\n        Yes → Step 4: high = mid // 壞版本在中點或左側，縮小右端\n\n        No  → Step 5: low = mid + 1 // 壞版本在右側，縮小左端\n\n    Yes → (loop back to Decision: low < high?) // 重複搜尋\n\n    No  → Step 6: return low // low 即為第一個壞版本\n\nEnd // 程式結束\n\nBut we need to indicate loop. Maybe use a label or comment that we go back.\n\nBetter: Use Decision: low < high? Yes → { compute mid; ...; goto Decision } No → { return low }\n\nIn virtual code, we can show the arrow to next decision.\n\nLet's produce more explicit:\n\nStart // 程式開始\n\n→ Step 1: low = 1 // 設定搜尋起點\n\n→ Step 2: high = n // 設定搜尋終點\n\n→ Decision: low < high? // 檢查是否還有區間\n\n    Yes → Step 3: mid = low + (high - low) / 2 // 取得中間版本\n\n    Yes → Decision: isBadVersion(mid)? // 判斷中間版本是否壞\n\n        Yes → Step 4: high = mid // 若壞，則第一壞版本在左半部，包括 mid\n\n        No  → Step 5: low = mid + 1 // 若好，則第一壞版本在右半部\n\n    Yes → Decision: low < high? // 回到條件，重複迴圈\n\n    No  → Step 6: return low // 找到第一壞版本\n\nEnd // 程式結束\n\nThat should be fine.\n\nMake sure each line has the arrow and comment. The indentation might be represented by spaces.\n\nLet's output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: low = 1 // 設定搜尋區間左端\n→ Step 2: high = n // 設定搜尋區間右端\n→ Decision: low < high? // 檢查是否還有可搜尋的區間\n    Yes → Step 3: mid = low + (high - low) / 2 // 計算中點版本\n    Yes → Decision: isBadVersion(mid)? // 判斷中點版本是否為壞版本\n        Yes → Step 4: high = mid // 壞版本在左側，縮小右端\n        No  → Step 5: low = mid + 1 // 壞版本在右側，縮小左端\n    Yes → Decision: low < high? // 回到條件，繼續迴圈\n    No  → Step 6: return low // low 為第一個壞版本，結束搜尋\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,4,1,4,1,4,6,6]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 4, 1, 4, 1, 4, 6, 6]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # 允許的數字個數\n        self.size = n - len(blacklist)\n        # 黑名單集合，方便 O(1) 判斷\n        black_set = set(blacklist)\n        # 用於映射的字典\n        self.mapping = {}\n        # 指向高區域的指標，初始為 n-1\n        last = n - 1\n        for b in blacklist:\n            # 只對低區域的黑名單做映射\n            if b < self.size:\n                # 找到一個不在黑名單的高區域數字\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        # 在允許區域 [0, self.size-1] 內隨機挑選\n        idx = random.randint(0, self.size - 1)\n        # 若該索引在映射表中，回傳映射後的高區域數字\n        return self.mapping.get(idx, idx)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n\n    obj = None\n    outputs = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            n, blacklist = args\n            obj = Solution(n, blacklist)\n            outputs.append(None)  # 按照 LeetCode 風格輸出 null\n        else:\n            # 目前只處理 pick 方法，若有其他方法可自行擴充\n            if cmd == \"pick\":\n                outputs.append(obj.pick())\n            else:\n                # 若出現其他方法，使用 getattr 呼叫\n                method = getattr(obj, cmd)\n                outputs.append(method(*args))\n\n    # 將結果轉成 JSON 字串，null 對應 None\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: use mapping from blacklist to allowed range tail. Standard solution: store mapping for blacklisted numbers that fall in [0, m-1] where m = n - len(blacklist). Use set of blacklist for fast check; build map from blacklisted in low part to allowed high part. Then pick random in [0, m-1]; if in map, return mapped; else return itself.\n\nNeed to produce step-by-step virtual code with comments. The user wants algorithm in steps. Provide steps: start, constructor: compute m, build mapping, store m. pick: rand = random in [0, m-1], if rand in map then return map[rand] else return rand. End.\n\nMake each step with arrow and comment. Use \"Decision\" where needed. Provide explanation after each line.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 `m ← n - len(blacklist)` // 計算允許的數字個數  \n→ Step 2: 建立空集合 `highSet ← {}` // 存放能映射到的高區域黑名單數字  \n→ Step 3: 迭代遍歷 `blacklist`  \n    → Decision: 如果 `num < m`? // 只對低區域黑名單數字做映射  \n        Yes → Step 4: `highSet.add(num)` // 先將所有高區域黑名單數字放入集合  \n        No → Skip  \n→ Step 5: 迭代變數 `x ← m` 到 `n-1`  \n    → Decision: 如果 `x` 在 `blacklist`? // 找到低區域黑名單數字  \n        Yes → Decision: `highSet` 是否非空?  \n            Yes → Step 6: `y ← highSet.pop()` // 取出一個高區域數字作映射目標  \n            → Step 7: 建立映射 `map[x] ← y` // 將低區域黑名單映射到高區域非黑名單  \n            No → Skip  \n        No → Skip  \n→ Step 8: 儲存 `m` 與 `map` 作為物件屬性 // 用於隨機挑選時查詢  \nEnd // 初始化結束  \n\n---  \n\nStart // 隨機挑選執行  \n→ Step 9: `k ← RandomInt(0, m-1)` // 產生 [0, m-1] 範圍內的隨機數  \n→ Decision: `k` 是否在 `map`?  \n    Yes → Step 10: `return map[k]` // 若為映射鍵，回傳對應的高區域數字  \n    No → Step 11: `return k` // 否則直接回傳原數字  \nEnd // pick() 結束"
    },
    {
      "title": "Single Number II",
      "source_file": "Leetcode/leetcode137.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '99'\nGot (Norm):      '98'\n--- (Raw) ---\nRaw Expected: '99'\nRaw Got:      '98'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def singleNumber(self, nums):\n        \"\"\"\n        找出只出現一次的元素。\n        透過位元運算將每一位累計，並以模 3 的方式消除重複出現的位元。\n        \"\"\"\n        ones = twos = 0\n        for num in nums:\n            # 更新已出現兩次的位元\n            twos |= ones & num\n            # 更新已出現一次的位元\n            ones ^= num\n            # 把已出現三次的位元清除\n            ones &= ~twos\n        return ones\n\ndef parse_input(text):\n    \"\"\"\n    從輸入文字中抽取列表。例如：\n    'nums = [2,2,3,2]'  ->  [2, 2, 3, 2]\n    \"\"\"\n    match = re.search(r'\\[(.*?)\\]', text, re.S)\n    if match:\n        # 用 eval 解析列表內容，安全起見只允許數字、逗號、空白和負號\n        safe_str = match.group(0)\n        try:\n            return eval(safe_str)\n        except Exception:\n            return []\n    return []\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    # 進行計算並輸出結果\n    result = Solution().singleNumber(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. The algorithm: bitwise counting mod 3. Use 32-bit counters: ones, twos. For each num: twos |= ones & num; ones ^= num; ones &= ~twos. Finally return ones.\n\nNeed virtual code line by line.\n\nStart, read array, iterate. Use virtual code steps: Step 1: Initialize ones=0, twos=0. Step 2: For each num in nums. Step 3: Update twos and ones as per bitwise.\n\nAfter loop, return ones.\n\nAdd decisions? Might show condition for loop. But just show steps.\n\nLet's produce. Ensure each line ends with // explanation. Use arrows for flow. Include Decision: for loop? Use Decision: 如果還有元素? But maybe not necessary. But we can show:\n\nDecision: 是否還有元素? Yes → Step update.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: ones ← 0, twos ← 0 // 初始化兩個位元計數器  \n→ Step 2: index ← 0 // 設定陣列指標  \n→ Decision: index < length(nums)? // 檢查是否還有元素可處理  \n    Yes → Step 3: num ← nums[index] // 取出目前元素  \n    → Step 4: twos ← twos OR (ones AND num) // 計算哪些位元已經出現兩次  \n    → Step 5: ones ← ones XOR num // 計算哪些位元已經出現一次  \n    → Step 6: ones ← ones AND NOT twos // 移除已經出現三次的位元  \n    → Step 7: index ← index + 1 // 移至下一個元素  \n    → Decision: index < length(nums)? // 繼續迴圈  \n        Yes → (loop back to Step 3)  \n        No  → Step 8: result ← ones // 從計數器得到唯一元素  \n→ End // 程式執行結束（返回 result）"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.527807813420713,-0.7587924751771185],[0.9002669701618201,-0.26741896066504955],[-0.5483265670679267,0.2500885183715453]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.527807813420713, -0.7587924751771185], [0.9002669701618201, -0.26741896066504955], [-0.5483265670679267, 0.2500885183715453]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 先隨機產生半徑 r，使用 sqrt 保證均勻分布\n        r = self.radius * math.sqrt(random.random())\n        # 隨機角度 θ\n        theta = random.uniform(0, 2 * math.pi)\n        # 轉換為笛卡爾座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data or len(data) < 2:\n        return\n    # 第一行是方法名稱列表，第二行是對應的參數列表\n    methods = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    instance = None\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # 建構子，回傳 None\n            instance = Solution(*args)\n            results.append(None)\n        else:\n            # 呼叫對應方法\n            func = getattr(instance, method)\n            res = func(*args)\n            results.append(res)\n\n    # 輸出結果\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for generating random point inside circle uniform distribution. Use rejection sampling? Better: generate random radius sqrt(U)*R, angle uniform 0-2π. Then x = x_center + r*cos(theta), y similarly. Pseudocode steps. Include class initialization storing radius, center. Provide randPoint function. Use random generation functions. Should produce steps with arrows. Provide explanation per line. Ensure no actual code. Let's produce lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class: Solution // 定義解決方案類別  \n→ Step 1: Store radius, x_center, y_center in instance variables // 於建構子中保存圓半徑與中心座標  \n→ Step 2: Define method randPoint() // 定義生成隨機點的函式  \n→ Step 3: 產生隨機數 u in [0,1) // 用於計算半徑，保證均勻分佈  \n→ Step 4: 計算半徑 r = radius × sqrt(u) // 調整半徑以符合面積分佈  \n→ Step 5: 產生隨機數 θ in [0, 2π) // 隨機角度，確保方向均勻  \n→ Step 6: 計算 x = x_center + r × cos(θ) // 將極座標轉換為笛卡爾座標  \n→ Step 7: 計算 y = y_center + r × sin(θ) // 同上，得到 y 座標  \n→ Step 8: 回傳 [x, y] // 將隨機點作為陣列返回  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,2,1],[1,2,3],[1,2,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [3, 2, 1], [1, 2, 3], [1, 2, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = list(nums)      # 儲存原始順序\n        self.current = list(nums)       # 供操作的副本\n\n    def reset(self):\n        \"\"\"重設為原始順序並回傳\"\"\"\n        self.current = list(self.original)\n        return self.current\n\n    def shuffle(self):\n        \"\"\"隨機洗牌，使用 Fisher‑Yates 演算法\"\"\"\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入切成兩段：命令列與參數列\n    # 這裡假設格式為 <commands> , <arguments>，例如\n    # [\"Solution\",\"shuffle\"], [[[1,2,3]],[]]\n    comma_index = data.find('],')\n    if comma_index == -1:\n        # 若輸入僅為一個 JSON 陣列，直接解析\n        parts = [data]\n    else:\n        parts = [data[:comma_index + 1], data[comma_index + 2:]]\n\n    commands = json.loads(parts[0])\n    args_list = json.loads(parts[1]) if len(parts) > 1 else []\n\n    results = []\n    obj = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # args 形如 [[1,2,3]]，取第一個元素作為初始陣列\n            obj = Solution(args[0])\n            results.append(None)  # 以 null 表示\n        elif cmd == \"reset\":\n            results.append(obj.reset())\n        elif cmd == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            # 若有其他方法，直接呼叫\n            method = getattr(obj, cmd)\n            results.append(method(*args))\n\n    # 輸出結果，使用 JSON 以符合範例格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for the algorithm: solution class with constructor storing original and copy, reset returns original copy, shuffle uses Fisher-Yates algorithm. Provide each step line with explanation. Use virtual code arrow notation. Should be lines like:\n\nStart\n→ Step 1: 定義 Solution 類 // ...\nNeed to break into steps: define class, constructor, store original array, store copy, reset method, shuffle method. Inside shuffle: copy original to array, for i from length-1 downto 1: generate random index j between 0 and i inclusive, swap array[i], array[j]. Return array.\n\nWe need to show virtual code lines. Use \"Start\", \"End\". Provide arrow lines. For loops use \"→ For i from length-1 downto 1\". Inside loop we can use \"→ Step: 隨機產生 j ...\". Use \"→ Swap\" etc.\n\nWe'll produce line-by-line. Provide explanation after //.\n\nWe need to not output actual code, just structure. Use \"Start\", \"End\".\n\nLet's craft.\n\n1. Start // 程式開始執行\n2. → Step 1: 定義 Solution 類 // 建立包含重設與洗牌功能的類別\n3. → Step 2: 在類別中宣告兩個陣列變數 original 與 current // original 儲存初始化時的順序，current 用於操作\n4. → Step 3: 建構子 Solution(nums) // 接收輸入陣列\n5. → Step 4: 設定 original ← copy of nums // 取得原始資料的複本\n6. → Step 5: 設定 current ← copy of nums // 亦複製為可變陣列\n7. → Step 6: End of constructor // 結束建構\n8. → Step 7: 定義 reset() 方法 // 重設功能\n9. → Step 8: 設定 current ← copy of original // 把 current 重新設為原始順序\n10. → Step 9: 回傳 current // 返回重設後的陣列\n11. → Step 10: 定義 shuffle() 方法 // 洗牌功能\n12. → Step 11: 設定 current ← copy of original // 先以原始資料作為基礎\n13. → Step 12: For i from length-1 downto 1 // 反向遍歷陣列\n14. → Step 13: 產生隨機整數 j 介於 0 與 i 之間 // 隨機選擇交換位置\n15. → Step 14: 交換 current[i] 與 current[j] // 進行交換\n16. → Step 15: End For // 完成所有交換\n17. → Step 16: 回傳 current // 回傳隨機排列\n18. End // 程式執行結束\n\nWe need to use arrow \"→\" for steps, maybe indent Decision? Not needed. But we can keep simple.\n\nWe need to include \"Yes →\" \"No →\"? No decisions.\n\nMake sure each line includes virtual code step + space + // explanation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Solution 類 // 建立包含 reset 與 shuffle 功能的類別  \n→ Step 2: 在類別中宣告兩個陣列變數 original 與 current // original 儲存初始化時的順序，current 用於操作  \n→ Step 3: 建構子 Solution(nums) // 接收輸入陣列  \n→ Step 4: 設定 original ← copy of nums // 取得原始資料的複本  \n→ Step 5: 設定 current ← copy of nums // 亦複製為可變陣列  \n→ Step 6: End of constructor // 結束建構  \n→ Step 7: 定義 reset() 方法 // 重設功能  \n→ Step 8: 設定 current ← copy of original // 把 current 重新設為原始順序  \n→ Step 9: 回傳 current // 返回重設後的陣列  \n→ Step 10: 定義 shuffle() 方法 // 洗牌功能  \n→ Step 11: 設定 current ← copy of original // 先以原始資料作為基礎  \n→ Step 12: For i from length-1 downto 1 // 反向遍歷陣列  \n→ Step 13: 產生隨機整數 j 介於 0 與 i 之間 // 隨機選擇交換位置  \n→ Step 14: 交換 current[i] 與 current[j] // 進行交換  \n→ Step 15: End For // 完成所有交換  \n→ Step 16: 回傳 current // 回傳隨機排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    \"\"\"返回給定唯一整數列表的所有子集（冪集合）。\"\"\"\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = []  # 用於存儲所有子集\n\n        def backtrack(start: int, path: List[int]) -> None:\n            # 把目前構建好的子集加入結果\n            res.append(path[:])\n\n            # 從 start 開始嘗試包含或不包含後續元素\n            for i in range(start, len(nums)):\n                path.append(nums[i])           # 包含 nums[i]\n                backtrack(i + 1, path)         # 進一步遞歸\n                path.pop()                     # 回溯，移除最後加入的元素\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析類似於 \"nums = [1,2,3]\" 的輸入格式\n    try:\n        start = data.index('[')\n        end = data.rindex(']')\n        nums_str = data[start:end+1]\n        nums = eval(nums_str)  # 轉換為列表\n    except (ValueError, SyntaxError):\n        print(\"Invalid input format\")\n        sys.exit(1)\n\n    # 生成並輸出所有子集\n    solution = Solution()\n    result = solution.subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for generating power set of unique integer array. We will use recursion/backtracking.\n\nStructure: Start, Step1: input array, Step2: sort? maybe not needed. Then recursion function build subset.\n\nWe'll produce lines: Start, → Step 1: 接收數組 nums // get input. → Step 2: 初始化 result list // store subsets. → Step 3: 定義遞歸函數 Backtrack(index, current) // index pointer and current subset. → Inside Backtrack: Step 4: If index==len(nums): append copy of current to result // base case. → Step 5: include current element: current.add(nums[index]) → Backtrack(index+1, current) → Step 6: exclude current element: current.remove last element → Backtrack(index+1, current) // continue recursion. End.\n\nNeed to use virtual arrows and Decision. But the above is not decision; just recursion. We can represent Decision: If index==len? yes.\n\nWe need to use Yes → and No →? For recursion maybe not necessary.\n\nBut we can use Decision to check if index==len.\n\nBetter: Decision: index==len(nums)? // base case. Yes → add current subset to result; No → proceed to include/exclude steps.\n\nLet's craft lines accordingly.\n\nMake sure each line includes explanation after //.\n\nAlso start and end.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入數組 nums // 從使用者取得唯一整數數組  \n→ Step 2: 初始化結果集合 result ← [] // 用於儲存所有子集  \n→ Step 3: 定義遞歸函數 Backtrack(index, current) // index: 當前處理的索引，current: 正在構建的子集  \n  Decision: index 等於 nums 長度? // 判斷是否已處理完所有元素  \n   Yes → Step 4: 將 current 的拷貝加入 result // 基本情況：將已完成的子集存入結果  \n   No → Step 5: current 加入 nums[index] // 選擇包含該元素  \n    → Backtrack(index+1, current) // 進一步遞歸處理剩餘元素  \n    → Step 6: current 從末尾移除 nums[index] // 取消選擇，回到上一層  \n     → Backtrack(index+1, current) // 以不包含該元素的方式遞歸  \n→ Step 7: 調用 Backtrack(0, []) // 從索引 0 開始，空子集作為初始  \nEnd // 程式執行結束，result 即為所有子集的集合"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6ewmxglz.py\", line 32, in <module>\n    main()\n  File \"/tmp/tmp6ewmxglz.py\", line 19, in main\n    ops, args = json.loads(data.strip())\n                ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 49 (char 48)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    ops, args = json.loads(data.strip())\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            obj = NumArray(arg[0])   # arg[0] 是 nums 陣列\n            results.append(None)     # 代表 constructor\n        elif op == \"sumRange\":\n            left, right = arg\n            results.append(obj.sumRange(left, right))\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe user requests virtual code steps for implementing NumArray with sumRange. Need to produce pseudocode with Start, End, Decision, arrow notation, and explanation after each line. Provide virtual code for initializing array and prefix sum, and sumRange method.\n\nWe need to produce \"逐行\" steps. Each line: \"虛擬碼步驟\" + \" \" + \"// 解釋/說明\".\n\nWe should include steps: Start, step for initializing prefix sum array in constructor, step for sumRange calculation using prefix sums.\n\nWe may use arrow \"→\" to indicate following step.\n\nWe need to ensure not output actual code.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 建立 prefixSum 陣列長度 nums.length+1 // 用於儲存前綴和\n→ Step 2: prefixSum[0] ← 0 // 前綴和初始值\n→ Decision: 是否已遍歷完 nums? // 檢查是否需要計算前綴和\n    Yes → Step 3: sumRange 定義 // 定義 sumRange 方法\n    No  → Step 4: prefixSum[i+1] ← prefixSum[i] + nums[i] // 計算前綴和\n        → Decision: i < nums.length-1? // 是否還有元素未處理\n            Yes → Go back to Step 4 with i+1 // 繼續填充前綴和\n            No  → Go to Step 3 // 完成前綴和\n→ Step 3: sumRange(left, right) ← prefixSum[right+1] - prefixSum[left] // 使用前綴和計算區間和\nEnd // 程式執行結束\n\nBut we need to adhere to arrow format \"→\". Need to indicate flow. We may use nested decisions. The syntax used in example:\n\n```\nDecision: 如果數字大於 0? // ...\n    Yes → Step 2: ...\n    No  → Decision: ...\n```\n\nThus we can structure similarly.\n\nWe should produce virtual code steps for the whole program, maybe with separate sections for constructor and sumRange.\n\nMaybe produce:\n\nStart\n→ Step 1: 設定 nums 為輸入陣列 // 取得傳入的數字陣列\n→ Step 2: 建立 prefixSum 陣列長度 nums.length+1 // 用於存前綴和\n→ Step 3: prefixSum[0] ← 0 // 初始化前綴和起始值\n→ Decision: i < nums.length? // 檢查是否還有元素未處理\n    Yes → Step 4: prefixSum[i+1] ← prefixSum[i] + nums[i] // 計算前綴和\n        → Decision: i < nums.length-1? // 是否還有更多元素\n            Yes → Go back to Step 4 with i+1 // 迭代\n            No  → Go to Step 5 // 完成前綴和\n    No  → Step 5: 定義 sumRange 函式 // 建立 sumRange\n→ Step 5: sumRange(left, right) ← prefixSum[right+1] - prefixSum[left] // 取得區間和\nEnd\n\nBut we need to be careful: the decision block after Step 4: we can do a while loop concept.\n\nAlternatively, we can produce simpler: just mention that we compute prefixSum in constructor. Then define sumRange.\n\nProbably simpler:\n\nStart // 程式開始執行\n→ Step 1: 建構子 NumArray(nums) // 初始化物件並傳入 nums\n    → Step 2: prefixSum ← array of length nums.length + 1 // 用於儲存前綴和\n    → Step 3: prefixSum[0] ← 0 // 前綴和初值\n    → Step 4: 迴圈 i 0 到 nums.length-1\n        → Step 5: prefixSum[i+1] ← prefixSum[i] + nums[i] // 逐個累加\n→ Step 6: 定義 sumRange(left, right) // 方法計算區間和\n    → Step 7: 回傳 prefixSum[right+1] - prefixSum[left] // 使用前綴和快速計算\nEnd // 程式執行結束\n\nBut we must use arrow and decisions. They didn't mention loops explicitly but we can use decision for loops.\n\nWe can embed decisions: Decision: 是否已經計算完前綴和? Use a decision and recursion. But simpler: we can use a loop represented by Decision: i < nums.length? but that's okay.\n\nLet's produce lines with indent and arrow.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: NumArray(nums) ← 建構子，接收整數陣列 nums // 取得並儲存輸入的數列  \n→ Step 2: prefixSum ← 新建長度為 nums.length + 1 的陣列 // 用於存放前綴和  \n→ Step 3: prefixSum[0] ← 0 // 前綴和的初始值為 0  \n→ Decision: i < nums.length? // 判斷是否還有元素未計算前綴和  \n  Yes → Step 4: prefixSum[i+1] ← prefixSum[i] + nums[i] // 累加第 i 個元素並存入前綴和  \n   → Decision: i < nums.length-1? // 是否還有下一個元素  \n    Yes → Go back to Step 4 with i+1 // 迭代計算下個元素的前綴和  \n    No  → Step 5: 完成前綴和計算 // 所有元素已處理  \n  No  → Step 5 // 若 nums 為空，直接跳到 Step 5  \n→ Step 6: sumRange(left, right) ← 定義方法，計算區間和 // 以前綴和方式實現  \n  → Step 7: 回傳 prefixSum[right+1] - prefixSum[left] // 利用前綴和快速取得區間總和  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Duplicates from Sorted Array II",
      "source_file": "Leetcode/leetcode80.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9ozt6w_b.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmp9ozt6w_b.py\", line 47, in main\n    nums = parse_input(raw)\n           ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9ozt6w_b.py\", line 28, in parse_input\n    return eval(data[start:end])\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1,1,1,2,2,3\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "expected_output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptegoj6h7.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmptegoj6h7.py\", line 47, in main\n    nums = parse_input(raw)\n           ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptegoj6h7.py\", line 28, in parse_input\n    return eval(data[start:end])\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [0,0,1,1,1,1,2,3,3\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        \"\"\"\n        移除多餘的重複，最多保留兩個相同元素。\n        \"\"\"\n        if not nums:\n            return 0\n        i = 0  # 寫入指標\n        for j in range(len(nums)):\n            # 前兩個元素一定允許寫入\n            if j < 2 or nums[j] != nums[i - 2]:\n                nums[i] = nums[j]\n                i += 1\n        return i\n\ndef parse_input(data: str) -> List[int]:\n    \"\"\"\n    從輸入字串中解析出數字列表。\n    假設輸入格式類似於 'nums = [1,1,1,2,2,3]'。\n    \"\"\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        return []\n    return eval(data[start:end])\n\ndef format_output(nums: List[int], k: int) -> str:\n    \"\"\"\n    產生符合範例的輸出字串。\n    例如：5, nums = [1,1,2,2,3,_]\n    \"\"\"\n    parts = []\n    for idx in range(len(nums)):\n        if idx < k:\n            parts.append(str(nums[idx]))\n        else:\n            parts.append('_')\n    return f\"{k}, nums = [{', '.join(parts)}]\"\n\ndef main() -> None:\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    nums = parse_input(raw)\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n    print(format_output(nums, k))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for algorithm: given sorted array, keep at most 2 of each value. Use two pointers: write index i for writing position, read index j for scanning. Classic solution: start i=0; For each j from 0 to len-1: if j<2 or nums[j]!=nums[i-2] then set nums[i]=nums[j]; i++. After loop return i. Need to show steps. Use virtual code steps.\n\nWe need \"逐行\" with arrow and explanation. We'll produce steps:\n\nStart\n→ Step 1: 定義 i = 0 // write pointer\n→ Step 2: 針對每個 j 從 0 到 n-1 // read pointer\n    → Decision: j < 2? // 兩個前置元素不存在\n        Yes → Step 3: nums[i] = nums[j]; i++ // 直接寫入\n        No  → Decision: nums[j] != nums[i-2]? // 超過兩個重複\n            Yes → Step 4: nums[i] = nums[j]; i++ // 允許寫入\n            No  → Step 5: 跳過 // 重複超過兩次，忽略\n→ End // 完成\n→ Step 6: 返回 i // 最終長度\n\nBut we need more precise virtual steps: maybe use loops structure: Start → Step 1 → Step 2 → Decision: j < 2? etc. Provide arrows for branching.\n\nWe should follow format: \"虛擬碼步驟 // 解釋/說明\". Use arrow symbol → for next step, Decision: for branch.\n\nWe should include Start and End. Use arrows for each step. Provide indentation? They used indentations in example. Use indentation with spaces maybe 4 spaces for nested steps. Use arrow at each step. For Decision we add Yes →, No → lines. We'll produce as:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化寫指針\n→ Step 2: 對 j 從 0 到 nums.length-1 進行迴圈 // 讀指針遍歷整個陣列\n    → Decision: j < 2? // 前兩個元素總是允許\n        Yes → Step 3: nums[i] ← nums[j]; i ← i + 1 // 直接寫入並遞增寫指針\n        No  → Decision: nums[j] ≠ nums[i-2]? // 檢查是否已有兩個相同值\n            Yes → Step 4: nums[i] ← nums[j]; i ← i + 1 // 允許寫入，遞增寫指針\n            No  → Step 5: // 跳過，因已超過兩個重複\n→ End // 迴圈結束\n→ Step 6: 返回 i // i 為新陣列長度\n\nWe need to use \"Yes →\" and \"No →\" within Decision. Example: \n    Decision: j < 2? \n        Yes → Step 3...\n        No  → Decision: ...\n\nThis matches example format. Provide explanation for each line.\n\nWe need to produce virtual code and explanation for each line. Must not output actual code. We need to produce exactly that.\n\nWe should also add arrow lines for loops? Use Start and End. Example: \n→ Step 2: for j from 0 to n-1 // read pointer loop\nbut can't use actual for syntax. We can say \"→ Step 2: 對 j 從 0 到 n-1 進行迴圈\". That is enough.\n\nMake sure each line has explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← 0 // 初始化寫指針，指向結果陣列的下一個可寫位置  \n→ Step 2: 對 j 從 0 到 nums.length-1 進行迴圈 // 讀指針遍歷整個陣列  \n    → Decision: j < 2? // 前兩個元素無需檢查重複次數，直接寫入  \n        Yes → Step 3: nums[i] ← nums[j]; i ← i + 1 // 直接寫入並遞增寫指針  \n        No → Decision: nums[j] ≠ nums[i-2]? // 檢查當前元素是否已經出現兩次  \n            Yes → Step 4: nums[i] ← nums[j]; i ← i + 1 // 允許寫入，遞增寫指針  \n            No → Step 5: // 跳過此元素，因已超過兩個相同值  \n→ End // 迴圈結束，所有元素已處理完畢  \n→ Step 6: 返回 i // i 為去除重複後，陣列前部的有效長度  \nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpotmozera.py\", line 50, in <module>\n    data = json.loads(sys.stdin.read())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 83 (char 82)"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}          # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key: int):\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current frequency bucket\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to next frequency bucket\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used key (LRU within that frequency)\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key with frequency 1\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = json.loads(sys.stdin.read())\n    ops, args = data\n    results = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            results.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            results.append(cache.get(arg[0]))\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need produce virtual code steps line by line for implementing LFU cache with capacity. Provide explanation after each line. Use arrow syntax. We must design data structure: map key->value & freq, freq list of keys (DLL). Use freq map to track keys order, LRU tie. Also minFreq. So pseudo steps: Start, initialize capacity, map, freqMap, freqList, minFreq. get(key): if not exist return -1; else increment freq: remove from current freq list, add to next freq list; update minFreq if needed; return value. put: if capacity 0 return; if key exists: update value, increment freq; else if size==capacity: evict least freq minFreq list's LRU (head) remove key from map and freq map; then insert new key with freq=1, add to freq list of 1; set minFreq=1.\n\nNeed to output line-by-line virtual code steps. Probably each line is a conceptual step like \"Initialize capacity\" etc. Let's craft. Use Start, End. Use Decision: and arrow for Yes/No. Provide explanation after each line. Ensure each line has \"虛擬碼步驟 // 解釋\". Use Chinese comments. We'll produce many lines. Let's start.\n\nWe may need to break into logical functions: init, get, put, internal incFreq, evict. But problem wants virtual code lines sequential. Could present pseudo-code for whole class.\n\nI'll produce:\n\nStart\n→ Initialize LFUCache with capacity\n→ Create map keyToNode // key to node containing value and freq\n→ Create map freqToKeys // freq to ordered set (DLL) of keys\n→ Set minFreq = 0 // minimal frequency present\n→ Create currentSize = 0\n\nNow get function:\n\n→ Function get(key)\n→ Decision: key exists in keyToNode?\n    Yes → Step: Retrieve node\n          → Increment node.freq via helper\n          → Return node.value\n    No  → Return -1\n\nPut function:\n\n→ Function put(key, value)\n→ Decision: capacity == 0?\n    Yes → End // no operation\n    No  → Decision: key exists?\n        Yes → Update value\n              → Increment freq\n        No  → Decision: currentSize == capacity?\n            Yes → Evict least frequently used key\n                  → Remove evicted key from maps\n                  → currentSize--\n            No → // nothing\n            End\n          → Insert new key with freq=1\n          → Add to freqToKeys[1]\n          → keyToNode[key] = node\n          → minFreq = 1\n          → currentSize++\n\nHelper increment freq:\n\n→ Function incrementFreq(node)\n→ Remove node from freqToKeys[node.freq]\n→ Decision: freqToKeys[node.freq] empty and node.freq == minFreq?\n    Yes → minFreq++\n    No → // no change\n→ node.freq++\n→ Add node to freqToKeys[node.freq]\n\nEvict:\n\n→ Function evict()\n→ Decision: freqToKeys[minFreq] not empty?\n    Yes → Find least recently used key (head of freqToKeys[minFreq])\n          → Remove that key from freqToKeys[minFreq]\n          → Remove key from keyToNode\n          → Return evicted key\n    No → // shouldn't happen\n\nWe need each line separate with // explanation.\n\nLet's produce in required format: each line \"Step: ... // explanation\". Use arrow and decisions.\n\nLet's output final.\n...done thinking.\n\nStart // 程式開始執行  \n→ 虛擬碼：初始化 LFUCache，設定容量 capacity  \n→ 虛擬碼：建立 keyToNode 映射，鍵對應到節點 (包含 value 與頻率)  \n→ 虛擬碼：建立 freqToKeys 映射，頻率對應到有序集合（可實作為雙向鏈表）  \n→ 虛擬碼：設 minFreq 為 0，表示目前沒有頻率  \n→ 虛擬碼：設 currentSize 為 0，紀錄目前快取中的鍵數  \n\nFunction get(key) // 取得 key 的值  \n→ Decision: key 是否存在於 keyToNode?  \n Yes → 虛擬碼：取出對應節點 node  \n  → 虛擬碼：呼叫 incrementFreq(node) 以更新頻率  \n  → 虛擬碼：回傳 node.value  \n No  → 虛擬碼：回傳 -1，表示未找到  \n\nFunction put(key, value) // 插入或更新 key 的值  \n→ Decision: capacity 是否為 0?  \n Yes → End // 快取容量為 0，直接結束  \n No  → Decision: key 是否已存在於 keyToNode?  \n  Yes → 虛擬碼：更新 key 的 value 為 value  \n    → 虛擬碼：呼叫 incrementFreq(node) 以更新頻率  \n  No  → Decision: currentSize 是否已達到 capacity?  \n   Yes → 虛擬碼：執行 evict() 以移除最少使用的鍵  \n     → 虛擬碼：從 keyToNode 與 freqToKeys 中刪除被淘汰的鍵  \n     → 虛擬碼：currentSize 減 1  \n   No  → // 沒有淘汰，直接插入"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\nimport ast\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the input into two parts: method names and arguments\n    parts = data.split('],', 1)\n    if len(parts) != 2:\n        raise ValueError(\"Input format error\")\n    # Recover the method names list\n    method_names_str = parts[0] + ']'\n    method_names = ast.literal_eval(method_names_str)\n    # Recover the arguments list\n    args_str = parts[1]\n    args = ast.literal_eval(args_str)\n\n    results = []\n    obj = None\n    for idx, method in enumerate(method_names):\n        if method == \"Solution\":\n            # Constructor: args[idx] is a list containing one list of weights\n            obj = Solution(args[idx][0])\n            results.append(None)\n        elif method == \"pickIndex\":\n            if obj is None:\n                raise ValueError(\"pickIndex called before constructor\")\n            results.append(obj.pickIndex())\n        else:\n            raise ValueError(f\"Unknown method {method}\")\n\n    # Output results in JSON format so that None is represented as null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing pickIndex with weighted random selection. Need to produce step by step in plain virtual code style. Not actual code. Each line with // explanation. Use arrows. Should include Start, End. Should also include building prefix sums and binary search logic. Steps: Preprocess: compute prefix sums array. In pickIndex: generate random number r between 1 and total sum inclusive. Then binary search in prefix sums to find index where r <= prefix[i]. Return that index. Should also mention that this occurs on each call. Provide algorithm steps. Provide initialization, random generation, binary search loop. Use Decision structure. Provide comment. Use appropriate arrow indentations.\n\nMake sure each line starts with virtual code step then space then // explanation.\n\nLet's produce something like:\n\nStart\n→ Step 1: 初始化 prefixSum = 空陣列 // 用於存儲累積權重\n→ Step 2: total = 0 // 記錄總權重\n→ Decision: 遍歷 w 直到結束 // 逐個累加\n    Yes → Step 3: total += w[i] // 更新總權重\n    Yes → Step 4: prefixSum.append(total) // 存儲累積值\n    No → Step 5: 轉到 pickIndex 部分\n...\n\nBut we need separate function. Perhaps show function definition. Use Start/End. Could show a function: PickIndexClass with constructor, pickIndex method. Provide steps.\n\nLet's craft.\n\nNeed to output as virtual code lines. Use arrow indentation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 WeightedPicker // 用於封裝加權隨機選取功能\n→ Decision: 在 WeightedPicker 建構子內部初始化\n    Yes → Step 2: prefixSum ← 空列表 // 儲存每個索引的累積權重\n    Yes → Step 3: totalWeight ← 0 // 儲存所有權重之和\n    Yes → Decision: 遍歷輸入陣列 w\n        Yes → Step 4: totalWeight ← totalWeight + w[i] // 累加權重\n        Yes → Step 5: prefixSum.append(totalWeight) // 追加當前累積值\n        No  → Step 6: 完成前綴和構建 // 前綴和已完整\n→ Decision: 定義方法 pickIndex()\n    Yes → Step 7: r ← 隨機整數 1~totalWeight // 產生隨機目標值\n    Yes → Decision: 在 prefixSum 中執行二分搜尋\n        Yes → Step 8: left ← 0\n        Yes → Step 9: right ← len(prefixSum) - 1\n        Yes → Step 10: while left < right\n            Yes → Step 11: mid ← (left + right) // 2\n            Yes → Decision: 若 r <= prefixSum[mid]\n                Yes → Step 12: right ← mid // 搜尋左半區\n                No  → Step 13: left ← mid + 1 // 搜尋右半區\n        Yes → Step 14: return left // left 即為符合條件的索引\n→ End // 程式執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpszzxpize.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpszzxpize.py\", line 43, in main\n    exec(data, {}, env)\n  File \"<string>\", line 1\n    mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpypykpuyi.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpypykpuyi.py\", line 43, in main\n    exec(data, {}, env)\n  File \"<string>\", line 1\n    mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        \"\"\"\n        找出矩陣中最弱的 k 行。\n        - `mat`: m x n 的二進制矩陣，行中 1 的數量先後排列。\n        - `k`: 需要返回的最弱行數量。\n\n        步驟:\n        1. 對每一行使用二分搜尋計算 1 的數量。\n        2. 以 (兵力數量, 行索引) 為排序鍵，將所有行排序。\n        3. 取前 k 個行索引即為答案。\n        \"\"\"\n        def count_soldiers(row):\n            \"\"\"使用二分搜尋得到 row 中 1 的數量。\"\"\"\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        # 計算每行兵力並與索引一起儲存\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        # 先按兵力，再按索引排序\n        soldiers.sort()\n        # 取前 k 行的索引\n        return [idx for _, idx in soldiers[:k]]\n\ndef main():\n    \"\"\"\n    主程式:\n    1. 直接從 stdin 讀取整個輸入字串。\n    2. 使用 exec 執行，期望輸入中包含 `mat = ...` 與 `k = ...`。\n    3. 呼叫 Solution.kWeakestRows 並輸出結果。\n    \"\"\"\n    data = sys.stdin.read()\n    env = {}\n    # 安全起見，只允許執行簡單的賦值語句\n    exec(data, {}, env)\n\n    mat = env.get('mat')\n    k = env.get('k')\n\n    if mat is None or k is None:\n        raise ValueError(\"輸入必須包含 'mat' 與 'k' 兩個變數。\")\n\n    solution = Solution()\n    result = solution.kWeakestRows(mat, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for solving problem: find k weakest rows in binary matrix where rows sorted 1's then 0's. Approach: for each row count soldiers (maybe binary search or sum). store (count, index). sort by count then index. take first k indices.\n\nSo produce virtual code with Start, steps.\n\nWe'll generate each line with explanation.\n\nLet's produce.\n\nNeed to not output actual code, only pseudo.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空列表 rowsInfo // 用來存放每行的兵力數量與索引  \n→ Decision: 是否有輸入矩陣 mat? // 確認輸入有效  \n  Yes → Step 2: 設定 rows = mat 的行數，cols = mat 的列數 // 取得矩陣尺寸  \n  No  → Step 3: 返回空結果 // 沒有輸入時直接結束  \n\n→ Step 4: 從 0 到 rows-1 迭代每一行 i // 逐行處理  \n  → Step 4a: 設定 left = 0, right = cols-1, soldiers = 0 // 初始化二分搜尋變數  \n  → Decision: left <= right? // 檢查搜尋區間是否仍有效  \n   Yes → Step 4a1: 計算 mid = (left+right)/2 // 取中點  \n    Decision: mat[i][mid] == 1? // 檢查中點為否屬於士兵  \n     Yes → Step 4a2: soldiers = mid+1; left = mid+1 // 更新兵力並搜尋右側  \n     No  → Step 4a3: right = mid-1 // 搜尋左側  \n     決策回到 Step 4a: left <= right? // 重複直到搜尋結束  \n   No → Step 4b: rowsInfo.append((soldiers, i)) // 把兵力與索引加入列表  \n\n→ Step 5: 對 rowsInfo 進行排序，先按兵力 ascending，再按索引 ascending // 以弱度排序  \n→ Step 6: 建立結果 list = [] // 用於儲存 k 個最弱行索引  \n→ Decision: k > 0 且 rowsInfo 不是空? // 確認要取值  \n  Yes → Step 7: 從 rowsInfo 的前 k 個元素取索引並加入結果  \n  No  → Step 8: 返回空結果 // k 為 0 或無行時  \n\n→ End // 程式執行結束，返回結果列表"
    }
  ]
}