{
  "run_index": 48,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 396,
  "generation_or_validation_failure_count": 43,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[3,5,5,3,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[3, 5, 5, 3, 3]'"
        }
      ],
      "generated_code": "import random\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰子，回傳結果列表。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        # 隨機產生 1 ~ 6 的整數\n        results.append(random.randint(1, 6))\n    return results\n\ndef main():\n    \"\"\"\n    讀取標準輸入，執行其中的 Python 程式碼。\n    \"\"\"\n    import sys\n    code = sys.stdin.read()\n    # 執行輸入的程式碼（預期包含對 roll_dice 的呼叫）\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, following the format. Use Start, End, Decision, Step. Must be in Traditional Chinese. Use \"→\". Use \"Yes →\", \"No →\" for decisions. Since it's just a function, we can structure it. Steps: Start, define function roll_dice(n), declare empty list results, loop i from 1 to n, generate random int 1-6, append, return results, End.\n\nAdd decision maybe for validating n > 0? Could include optional. We'll produce steps.\n\nLet's write.\n\nOutput: lines with \"虛擬碼步驟\" then comment.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 roll_dice(n) // 建立擲骰子功能  \n→ Step 2: 初始化 results 為空串列 // 用來儲存每次擲骰結果  \n→ Step 3: Decision: 若 n > 0? // 檢查擲骰次數是否有效  \n  Yes → Step 4: 進行迴圈 for i in 1 到 n // 逐次擲骰  \n    → Step 5: rand = 隨機整數 1 到 6 // 模擬一次六面骰擲出結果  \n    → Step 6: 把 rand 加到 results 串列中 // 收集結果  \n    → Decision: 是否還有未完成的擲骰? // 判斷是否結束迴圈  \n      Yes → Step 4 // 回到 Step 4 繼續下一擲  \n      No  → Step 7: 回傳 results // 所有結果完成後返回  \n  No  → Step 8: 回傳空串列 // n 非正數時直接回傳空結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量 func 執行所需秒數，並四捨五入到小數點 3 位。\n    \"\"\"\n    start = time.perf_counter()\n    func(*args)\n    end = time.perf_counter()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"\n    讀取整個 stdin，將其作為程式碼執行。\n    在執行環境中提供 measure_time 以及 time 模組。\n    \"\"\"\n    # 讀取全部輸入\n    code = sys.stdin.read()\n\n    # 建立執行環境，預先注入 measure_time 及 time\n    exec_namespace = {\n        'measure_time': measure_time,\n        'time': time\n    }\n\n    # 執行輸入程式碼\n    exec(code, exec_namespace)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code, line by line, following format: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc. Provide steps for function measure_time(func, *args) that uses time module to measure execution time, round to 3 decimal places, return result. Need to include import time. Steps: import, define function, record start time, call func with args, record end time, compute elapsed, round, return. Possibly handle exception? Not necessary. We'll produce simple steps.\n\nWe need to use arrow characters: → for steps, Yes→ No→ for decisions. We need to include Start and End.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: import time // 引入 time 模組\n→ Step 2: 定義函式 measure_time(func, *args) // 定義測量時間的函式\n    → Step 3: start = time.perf_counter() // 記錄開始時間\n    → Step 4: result = func(*args) // 執行傳入的函式並傳回結果\n    → Step 5: end = time.perf_counter() // 記錄結束時間\n    → Step 6: elapsed = end - start // 計算耗時\n    → Step 7: elapsed_rounded = round(elapsed, 3) // 四捨五入到小數點 3 位\n    → Step 8: return result, elapsed_rounded // 回傳結果與耗時\nEnd // 程式執行結束\n\nBut we need to follow structure with arrow for decisions? No decision needed. But we can still include Step 1: import time; etc.\n\nMake sure each line has arrow before step or not? Format example: \"Start //\", \"→ Step 1:\" etc. For nested steps, indent? Probably no indent needed but we can indent to show nested. Use arrow for each line.\n\nWe need to ensure every line has arrow or \"Start\"/\"End\". Let's produce:\n\nStart // 程式開始執行\n→ Step 1: import time // 引入 time 模組\n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函式\n→ Step 3: start = time.perf_counter() // 記錄開始時間\n→ Step 4: result = func(*args) // 執行傳入的函式並取得結果\n→ Step 5: end = time.perf_counter() // 記錄結束時間\n→ Step 6: elapsed = end - start // 計算耗時\n→ Step 7: elapsed_rounded = round(elapsed, 3) // 四捨五入到小數點 3 位\n→ Step 8: return result, elapsed_rounded // 回傳結果與耗時\nEnd // 程式執行結束\n\nBut we need to maintain function block. But we can't use braces; just conceptual.\n\nWe might need Decision if needed; no.\n\nBut we can show Step 2: define function.\n\nProbably enough.\n\nReturn result, elapsed_rounded.\n\nAll good.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: import time // 引入 time 模組  \n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函式  \n→ Step 3: start = time.perf_counter() // 記錄開始時間  \n→ Step 4: result = func(*args) // 執行傳入的函式並取得結果  \n→ Step 5: end = time.perf_counter() // 記錄結束時間  \n→ Step 6: elapsed = end - start // 計算耗時  \n→ Step 7: elapsed_rounded = round(elapsed, 3) // 四捨五入到小數點 3 位  \n→ Step 8: return result, elapsed_rounded // 回傳結果與耗時  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.78TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.78 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef get_rate():\n    \"\"\"\n    向匯率 API 取得 USD 對 TWD 的匯率。\n    成功時回傳浮點數；失敗時回傳 None。\n    \"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=10)\n        data = r.json()\n        return data['rates']['TWD']\n    except Exception:\n        return None\n\ndef run_gui():\n    \"\"\"\n    建立 tkinter 視窗並提供按鈕更新匯率的功能。\n    \"\"\"\n    win = tk.Tk()\n    win.title('匯率查詢')\n\n    label = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    def update_label():\n        rate = get_rate()\n        if rate is not None:\n            label.config(text=f'目前美元匯率：約 {rate:.2f} TWD')\n        else:\n            label.config(text='更新失敗，請檢查網路連線')\n\n    tk.Button(win, text='更新匯率', command=update_label).pack(pady=5)\n    win.mainloop()\n\ndef main():\n    \"\"\"\n    主程式入口：從標準輸入讀取指令，若為「更新匯率」則直接輸出結果；\n    否則啟動 GUI 介面。\n    \"\"\"\n    # 讀取整個 stdin，並去除首尾空白\n    cmd = sys.stdin.read().strip()\n\n    if '更新匯率' in cmd:\n        # 直接在命令列回傳匯率\n        rate = get_rate()\n        if rate is not None:\n            print(f'目前美元匯率：約 {rate:.2f} TWD')\n        else:\n            print('更新失敗，請檢查網路連線')\n    else:\n        # 其他情況啟動 GUI\n        run_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanation each line. The user wants: use requests to call API, get USD to TWD rate, display in tkinter window, button to refresh.\n\nWe must produce virtual code lines: Start, → Step, Decision, etc. No real code, just virtual steps. Each line: virtual code step + space + // explanation.\n\nWe must not output actual code, only structured steps. Must be in Traditional Chinese.\n\nWe need to include steps for imports, initializing tkinter, setting up button, function to fetch rate, display label, update. Use Decision for error handling maybe. Provide line by line.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 載入 requests 與 tkinter 模組 // 準備必要的函式庫\n→ Step 2: 初始化 Tk() 視窗並設定標題 // 建立 GUI 視窗\n→ Step 3: 建立 Label 用於顯示匯率訊息 // 顯示目前匯率\n→ Step 4: 建立 Button，標籤為「更新匯率」並指派 callback // 觸發更新匯率\n→ Step 5: 定義 fetch_rate() 函式以串接匯率 API // 抓取最新匯率\n    → Decision: API 呼叫成功? // 判斷是否成功取得資料\n        Yes → Step 6: 從 JSON 取出 rates.TWD 值 // 取得美元兌台幣匯率\n        → Step 7: 更新 Label 文字為「1 USD = X TWD」 // 顯示匯率\n        No  → Step 8: 更新 Label 文字為「無法取得匯率」 // 顯示錯誤訊息\n→ Step 9: 將 fetch_rate() 指派給 Button 的 command // 連結按鈕功能\n→ Step 10: 執行 fetch_rate() 初次載入時取得匯率 // 顯示初始匯率\n→ Step 11: 呼叫 mainloop() 開始事件循環 // 開啟 GUI\nEnd // 程式執行結束\n\nBut need to use virtual code arrow style: \"→ Step X:\" etc. Ensure each line has explanation. Also include Decision block lines with indentation maybe. Use \"Decision:\" etc. Provide indentation.\n\nLet's format exactly like sample: Start // ... and each line with \"→ Step\". For Decision block: \"→ Decision: ...?\" etc. And indent the Yes/No lines with 4 spaces? In sample they used tabs. We can use indentation spaces. For each branch, write \"Yes → ...\" etc. Provide explanation.\n\nWe need to adhere to output format exactly: each line with \"虛擬碼步驟\" + space + \"// 解釋\". So each line must have explanation after double slash. Indentation lines should still follow that format: \"    Yes → Step ...\" + space + \"//\".\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 載入 requests 與 tkinter 模組 // 準備必要的函式庫\n→ Step 2: 初始化 Tk() 視窗並設定標題 // 建立 GUI 視窗\n→ Step 3: 建立 Label 用於顯示匯率訊息 // 顯示目前匯率\n→ Step 4: 建立 Button，標籤為「更新匯率」並指派 callback // 觸發更新匯率\n→ Step 5: 定義 fetch_rate() 函式以串接匯率 API // 抓取最新匯率\n    → Decision: API 呼叫成功? // 判斷是否成功取得資料\n        Yes → Step 6: 從 JSON 取出 rates.TWD 值 // 取得美元兌台幣匯率\n            → Step 7: 更新 Label 文字為「1 USD = X TWD」 // 顯示匯率\n        No  → Step 8: 更新 Label 文字為「無法取得匯率」 // 顯示錯誤訊息\n→ Step 9: 將 fetch_rate() 指派給 Button 的 command // 連結按鈕功能\n→ Step 10: 執行 fetch_rate() 初次載入時取得匯率 // 顯示初始匯率\n→ Step 11: 呼叫 mainloop() 開始事件循環 // 開啟 GUI\nEnd // 程式執行結束\n\nCheck: Each line has \"虛擬碼步驟\" + space + \"//\". In indentation lines, we need also have a space before //, but we need to maintain format. Let's rewrite properly:\n\nStart // 程式開始執行\n→ Step 1: 載入 requests 與 tkinter 模組 // 準備必要的函式庫\n→ Step 2: 初始化 Tk() 視窗並設定標題 // 建立 GUI 視窗\n→ Step 3: 建立 Label 用於顯示匯率訊息 // 顯示目前匯率\n→ Step 4: 建立 Button，標籤為「更新匯率」並指派 callback // 觸發更新匯率\n→ Step 5: 定義 fetch_rate() 函式以串接匯率 API // 抓取最新匯率\n    → Decision: API 呼叫成功? // 判斷是否成功取得資料\n        Yes → Step 6: 從 JSON 取出 rates.TWD 值 // 取得美元兌台幣匯率\n            → Step 7: 更新 Label 文字為「1 USD = X TWD」 // 顯示匯率\n        No  → Step 8: 更新 Label 文字為「無法取得匯率」 // 顯示錯誤訊息\n→ Step 9: 將 fetch_rate() 指派給 Button 的 command // 連結按鈕功能\n→ Step 10: 執行 fetch_rate() 初次載入時取得匯率 // 顯示初始匯率\n→ Step 11: 呼叫 mainloop() 開始事件循環 // 開啟 GUI\nEnd // 程式執行結束\n\nCheck indent: For indentation lines we have spaces before Yes →, etc. But each line still has \"//\". That should be fine.\n\nBut sample uses \"Yes → Step 2:\" not with extra space after Yes? They had \"Yes → Step 2:\". So maintain same style.\n\nNow output only those lines. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 載入 requests 與 tkinter 模組 // 準備必要的函式庫\n→ Step 2: 初始化 Tk() 視窗並設定標題 // 建立 GUI 視窗\n→ Step 3: 建立 Label 用於顯示匯率訊息 // 顯示目前匯率\n→ Step 4: 建立 Button，標籤為「更新匯率」並指派 callback // 觸發更新匯率\n→ Step 5: 定義 fetch_rate() 函式以串接匯率 API // 抓取最新匯率\n    → Decision: API 呼叫成功? // 判斷是否成功取得資料\n        Yes → Step 6: 從 JSON 取出 rates.TWD 值 // 取得美元兌台幣匯率\n            → Step 7: 更新 Label 文字為「1 USD = X TWD」 // 顯示匯率\n        No  → Step 8: 更新 Label 文字為「無法取得匯率」 // 顯示錯誤訊息\n→ Step 9: 將 fetch_rate() 指派給 Button 的 command // 連結按鈕功能\n→ Step 10: 執行 fetch_rate() 初次載入時取得匯率 // 顯示初始匯率\n→ Step 11: 呼叫 mainloop() 開始事件循環 // 開啟 GUI\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpily4t5q2.py\", line 83, in <module>\n    main()\n  File \"/tmp/tmpily4t5q2.py\", line 60, in main\n    args = ast.literal_eval(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[], [1], [2], [2], [], [1], [2], []]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass RandomizedSet:\n    \"\"\"\n    RandomizedSet 的實作使用兩個資料結構：\n    1. self.values : list，儲存所有元素，允許用索引存取。\n    2. self.val_to_index : dict，記錄每個元素對應在 list 的索引。\n    這樣可以確保 insert、remove、getRandom 均為平均 O(1) 時間。\n    \"\"\"\n    def __init__(self):\n        self.values = []          # 儲存元素的動態陣列\n        self.val_to_index = {}    # value -> index in self.values\n\n    def insert(self, val: int) -> bool:\n        \"\"\"若 val 未存在，插入並回傳 True；否則回傳 False。\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"若 val 存在，移除並回傳 True；否則回傳 False。\"\"\"\n        if val not in self.val_to_index:\n            return False\n        # 取得要移除的索引\n        idx = self.val_to_index[val]\n        # 取最後一個元素，填補空缺\n        last_val = self.values[-1]\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        # 刪除最後一個元素\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回 current set 中的一個元素。\"\"\"\n        return random.choice(self.values)\n\ndef main() -> None:\n    \"\"\"\n    main 讀取標準輸入，格式為兩個列表：\n        [\"op1\", \"op2\", ...], [[arg1], [arg2], ...]\n    之後依次執行操作，並以 JSON 格式輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 分離兩個列表\n    parts = data.split('],', 1)\n    ops_part = parts[0] + ']'          # 加回右括號\n    args_part = '[' + parts[1].lstrip()  # 確保開頭為 '['\n\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == 'RandomizedSet':\n            obj = RandomizedSet()\n            results.append(None)          # 對應 LeetCode 的 null\n        elif op == 'insert':\n            results.append(obj.insert(arg[0]))\n        elif op == 'remove':\n            results.append(obj.remove(arg[0]))\n        elif op == 'getRandom':\n            results.append(obj.getRandom())\n        else:\n            # 若有未知操作，可忽略或拋錯\n            results.append(None)\n\n    # 輸出為 JSON 格式，能得到 null/true/false 的表示\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code with explanation line by line, no actual code. Use arrows, decision, etc. For RandomizedSet. Provide steps: use array/list and hash map. Insert, remove, getRandom.\n\nWe must produce pseudo-code lines with explanation.\n\nStructure: Start, then Step definitions, etc. We need to output per line: \"虛擬碼步驟 // 解釋\". Use arrow lines. Use Decision lines.\n\nWe'll create steps: initialization, insert, remove, getRandom. Each method includes decisions and loops.\n\nWe should not output actual code but pseudocode steps. For example: \"Step 1: Insert val\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 RandomizedSet // 建立兩個空結構: list 用於儲存元素, map 用於查詢索引  \n→ Decision: 需要使用什麼資料結構? // 只需要 list 與 hash map  \n\nStart Insert // 執行 insert(val)  \n→ Step 2: 檢查 val 是否已在 map 中  \n→ Decision: val 存在? // 判斷是否重複  \n    Yes → Step 3: 返回 false // 已存在，插入失敗  \n    No  → Step 4: 將 val 加入 list 的尾部  \n→ Step 5: 在 map 中記錄 val 的索引為 list 末端位置  \n→ Step 6: 返回 true // 成功插入  \n\nStart Remove // 執行 remove(val)  \n→ Step 7: 檢查 val 是否存在於 map 中  \n→ Decision: val 不存在?  \n    Yes → Step 8: 返回 false // 無法移除，元素不存在  \n    No  → Step 9: 取得 val 在 list 中的索引 idx  \n→ Step 10: 取得 list 最後一個元素 lastVal  \n→ Step 11: 將 lastVal 移動到 idx 位置 (list[idx] = lastVal)  \n→ Step 12: 更新 map[lastVal] 為 idx  \n→ Step 13: 移除 list 最後一個元素 (list.pop())  \n→ Step 14: 刪除 map 中的 val 鍵  \n→ Step 15: 返回 true // 成功移除  \n\nStart GetRandom // 執行 getRandom()  \n→ Step 16: 產生一個隨機索引 r 在 [0, list.size-1] 之間  \n→ Step 17: 回傳 list[r] // 隨機元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[1,0],[0,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [1, 0], [0, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\nimport json\n\nclass Solution:\n    \"\"\"\n    Binary matrix of size m x n.  All entries start at 0.\n    flip() randomly selects an entry that is 0, flips it to 1,\n    and returns its coordinates.  All zero entries are equally\n    likely to be chosen.\n    reset() turns all entries back to 0.\n    \"\"\"\n    def __init__(self, n_rows: int, n_cols: int) -> None:\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols        # remaining zeros\n        self.flipped = {}                  # mapping for swapped indices\n\n    def flip(self) -> list:\n        # Pick a random index among the remaining zeros\n        r = random.randint(0, self.total - 1)\n        # Actual position that r refers to\n        x = self.flipped.get(r, r)\n        # Reduce the number of zeros left\n        self.total -= 1\n        # Map the chosen index to the last available index\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        # Convert linear index to 2‑D coordinates\n        return [x // self.cols, x % self.cols]\n\n    def reset(self) -> None:\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\n\nif __name__ == \"__main__\":\n    # Read the entire input string\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Parse the two top‑level lists as a tuple\n    ops, args = ast.literal_eval(f\"({data})\")\n\n    result = []\n    obj = None\n    for i, op in enumerate(ops):\n        if i == 0:          # First operation must be 'Solution'\n            obj = Solution(*args[i])\n            result.append(None)\n        elif op == \"flip\":\n            res = obj.flip()\n            result.append(res)\n        elif op == \"reset\":\n            obj.reset()\n            result.append(None)\n        else:\n            # Unsupported operation; skip or raise error\n            result.append(None)\n\n    # Output the results in JSON format (None -> null)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need produce virtual code lines. The algorithm: typical leetcode 501. Use reservoir mapping: total cells m*n, maintain list of available cells as indices. Use dictionary mapping for swapped indices. Keep count of remaining zeros. flip picks random integer k from [0, remaining-1]. map to actual index using map dict if exists else itself. Then update mapping: swap last available cell to position k: map[k] = lastIndex; remove last by reducing remaining. reset: clear map and reset remaining. Provide virtual code lines accordingly.\n\nWe need to include Start, End, Decision. Use virtual code style. Provide line by line. For each line include // explanation.\n\nWe need to cover initialization, flip, reset.\n\nWe'll produce virtual code for class Solution with methods.\n\nWe need to include Start at beginning of constructor maybe? The entire algorithm can be described as steps.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 m, n, total = m*n // 記錄矩陣尺寸及總格數\n→ Step 2: 初始化剩餘數 count = total // 代表還未翻轉的 0 的數量\n→ Step 3: 初始化 map = 空字典 // 用於存放已翻轉位置的對應關係\n→ Decision: 是否需要 reset? // 用於 reset() 方法\n    Yes → Step 4: clear map // 清空映射\n        → Step 5: 設 count = total // 重置剩餘數\n    No  → ...\n\nBut better to separate methods.\n\nWe can do:\n\nStart // 程式開始\n→ Step 1: 建構函式 Solution(m,n) // 初始化\n    → Step 2: total ← m*n // 總格數\n    → Step 3: remaining ← total // 還未翻轉的格數\n    → Step 4: map ← 空映射 // 用於追蹤映射\n→ Step 5: flip() // 產生一個隨機 0 並翻轉為 1\n    → Step 6: idx ← 隨機整數 [0, remaining-1] // 隨機選取索引\n    → Step 7: real ← map.get(idx, idx) // 若已映射則取映射值\n    → Step 8: last ← remaining-1 // 最後一個可用索引\n    → Step 9: lastVal ← map.get(last, last) // 取得最後一個實際位置\n    → Step 10: map[idx] ← lastVal // 將 idx 映射到 last 的實際位置\n    → Step 11: 如果 idx == last then map.erase(idx) // 若相同則刪除映射\n    → Step 12: remaining ← remaining-1 // 減少剩餘數\n    → Step 13: i ← real / n // 行\n    → Step 14: j ← real % n // 列\n    → Step 15: return [i, j] // 回傳位置\n→ Step 16: reset() // 重置矩陣\n    → Step 17: map.clear() // 清空映射\n    → Step 18: remaining ← total // 重置剩餘數\nEnd // 程式結束\n\nAdd Decision arrows accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建構函式 Solution(m, n) // 初始化物件  \n    → Step 2: total ← m × n // 計算矩陣總格數  \n    → Step 3: remaining ← total // 剩餘未翻轉的 0 的數量  \n    → Step 4: map ← 空映射 // 用於追蹤已翻轉位置的對應關係  \n\n→ Step 5: flip() // 取得一個隨機且尚未翻轉的 0  \n    → Step 6: idx ← 隨機整數 [0, remaining – 1] // 隨機選取可用索引  \n    → Step 7: real ← map.get(idx, idx) // 取得 idx 對應的實際位置（若已映射則取映射值）  \n    → Step 8: last ← remaining – 1 // 最後一個可用索引  \n    → Step 9: lastVal ← map.get(last, last) // 取得最後一個位置的實際值  \n    → Step 10: map[idx] ← lastVal // 把 idx 映射到 last 的實際位置  \n    → Decision: 如果 idx == last? // 判斷是否需要刪除映射  \n        Yes → Step 11: map.erase(idx) // 若相同則移除映射，避免多餘空間  \n    → Step 12: remaining ← remaining – 1 // 減少剩餘可選格數  \n    → Step 13: i ← real ÷ n // 計算行索引  \n    → Step 14: j ← real mod n // 計算列索引  \n    → Step 15: return [i, j] // 回傳翻轉後的位置  \n\n→ Step 16: reset() // 重置矩陣至全 0  \n    → Step 17: map.clear() // 清空映射表  \n    → Step 18: remaining ← total // 重設剩餘格數為總數  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Search in Rotated Sorted Array",
      "source_file": "Leetcode/leetcode33.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,5,6,7,0,1,2], target = 0",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpeufv_s5d.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpeufv_s5d.py\", line 47, in main\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpeufv_s5d.py\", line 39, in parse_input\n    target_part = parts[1].split('=')[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2], target = 3",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo769oq2o.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpo769oq2o.py\", line 47, in main\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpo769oq2o.py\", line 39, in parse_input\n    target_part = parts[1].split('=')[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def search(self, nums, target):\n        \"\"\"搜尋旋轉後升序陣列中是否存在目標值，若存在則回傳其索引，否則回傳 -1。\"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            # 判斷哪一側為有序區段\n            if nums[left] <= nums[mid]:  # 左半段有序\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:  # 右半段有序\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"\n    將形如 'nums = [4,5,6,7,0,1,2], target = 0' 的字串解析成\n    (nums_list, target_value) 的元組。\n    \"\"\"\n    # 只取第一行，並移除首尾空白\n    line = data.strip()\n    if not line:\n        return [], None\n    # 以逗號分隔兩個賦值語句\n    parts = line.split(',')\n    if len(parts) < 2:\n        return [], None\n    nums_part = parts[0].split('=')[1].strip()\n    target_part = parts[1].split('=')[1].strip()\n    nums = ast.literal_eval(nums_part)            # 安全解析列表\n    target = int(target_part)                    # 轉成整數\n    return nums, target\n\ndef main():\n    # 從標準輸入讀取所有資料\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n    if target is None:\n        return\n    solution = Solution()\n    result = solution.search(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for solving the rotated sorted array search. Should output line by line with comments. Use Start, End, Decision. We need to include algorithm steps: set left=0, right=n-1, while left<=right, mid=(left+right)//2, if nums[mid]==target return mid, else decide which side is sorted: if nums[left]<=nums[mid], left side sorted, check if target in [nums[left], nums[mid]), adjust right=mid-1 else left=mid+1; else right side sorted, check if target in (nums[mid], nums[right]] adjust left=mid+1 else right=mid-1. After loop return -1.\n\nWe should ensure each line of virtual code with comment. Use \"→\" arrow for steps. Use Decision blocks with Yes/No. Also include Start, End.\n\nLet's craft. Use proper indentation.\n\nLine by line:\n\nStart\n→ Step 1: Initialize left = 0, right = length(nums) - 1 // 定義搜尋區間\n→ Decision: while left <= right? // 只要左指標未超過右指標繼續\n    Yes →\n        → Step 2: mid = (left + right) // 2 // 計算中點\n        → Decision: nums[mid] == target? // 檢查中點是否為目標\n            Yes → Step 3: return mid // 找到目標，返回其索引\n            No  →\n                → Decision: nums[left] <= nums[mid]? // 判斷左半段是否有序\n                    Yes →\n                        → Decision: target >= nums[left] AND target < nums[mid]? // 目標是否在左半段\n                            Yes → Step 4: right = mid - 1 // 限縮搜尋至左半段\n                            No  → Step 5: left = mid + 1 // 目標在右半段\n                    No  →\n                        → Decision: target > nums[mid] AND target <= nums[right]? // 目標是否在右半段\n                            Yes → Step 6: left = mid + 1 // 限縮搜尋至右半段\n                            No  → Step 7: right = mid - 1 // 目標在左半段\n        → Decision: loop again? // 迴圈結束條件會自行判斷\n        No →\n→ Step 8: return -1 // 未找到目標，返回 -1\nEnd\n\nNeed to ensure proper indentation and line breaks.\n\nMake sure each line ends with comment. Provide comments in Chinese.\n\nWe might need to separate the Decision blocks properly.\n\nUse arrow for steps: \"→ Step\". For decisions: \"→ Decision:\".\n\nYes → and No → lines inside.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0, right = length(nums) - 1 // 設定搜尋範圍\n→ Decision: left <= right? // 是否還有區間可搜尋？\n    Yes →\n        → Step 2: mid = (left + right) // 2 // 取中點索引\n        → Decision: nums[mid] == target? // 判斷中點是否為目標\n            Yes → Step 3: return mid // 找到目標，返回索引\n            No  →\n                → Decision: nums[left] <= nums[mid]? // 判斷左半段是否為升序有序\n                    Yes →\n                        → Decision: target >= nums[left] AND target < nums[mid]? // 目標是否落在左半段\n                            Yes → Step 4: right = mid - 1 // 收縮搜尋至左半段\n                            No  → Step 5: left = mid + 1 // 目標在右半段\n                    No  →\n                        → Decision: target > nums[mid] AND target <= nums[right]? // 目標是否落在右半段\n                            Yes → Step 6: left = mid + 1 // 收縮搜尋至右半段\n                            No  → Step 7: right = mid - 1 // 目標在左半段\n        → Decision: 迴圈再次執行? // 迴圈結束條件自動判斷\n        No →\n→ Step 8: return -1 // 未找到目標，回傳 -1\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp64u7e8qa.py\", line 73, in <module>\n    main()\n  File \"/tmp/tmp64u7e8qa.py\", line 57, in main\n    obj.buildDict(arg)\n  File \"/tmp/tmp64u7e8qa.py\", line 10, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        # 把所有單字存到集合，方便 O(1) 查詢\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        # 檢查是否存在一個字可以改成字典中的單字\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\ndef parse_input(s: str):\n    \"\"\"\n    將輸入字串分成兩個列表：操作名和對應的參數\n    \"\"\"\n    depth = 0\n    split_idx = None\n    for i, ch in enumerate(s):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            split_idx = i\n            break\n    if split_idx is None:\n        raise ValueError(\"輸入格式錯誤\")\n    ops_str = s[:split_idx].strip()\n    args_str = s[split_idx + 1:].strip()\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    ops, args = parse_input(raw_input)\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MagicDictionary\":\n            obj = MagicDictionary()\n            result.append(None)      # 代表 null\n        elif op == \"buildDict\":\n            obj.buildDict(arg)\n            result.append(None)\n        elif op == \"search\":\n            res = obj.search(arg)\n            result.append(res)\n        else:\n            raise ValueError(f\"未知操作 {op}\")\n\n    # 將結果轉成 LeetCode 所需的 JSON 風格字串\n    out = '[' + ', '.join(\n        'null' if r is None else 'true' if r else 'false'\n        for r in result\n    ) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code, line by line, with explanation comments, using arrow notation. Not actual code.\n\nNeed to design algorithm: typical MagicDictionary uses hash map of patterns with one wildcard. But we can just implement simple search.\n\nBut we produce virtual steps, not code. Provide steps for initialization, buildDict, search.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize data structure (e.g., dictionary set)\n→ Step 2: BuildDict: store words into set and also map each word to list of patterns with one char replaced by '*'.\n→ Step 3: Search: for each position in searchWord replace char with '*', check if pattern exists in map. If found, but must ensure exactly one change. Also need to check that original word not same as searchWord, because change must be exactly one char. Or if the pattern maps to multiple words, etc.\n\nWe'll produce lines.\n\nNeed to include arrow and indent for decisions.\n\nLet's produce step-by-step:\n\nStart\n→ Step 1: 定義空集合 words // 儲存所有單字\n→ Step 2: 定義空映射 patternMap // 鍵為模式（'*'表示被替換字符），值為所有對應單字的集合\n\nDecision: BuildDict called? but BuildDict is a method. We'll show steps inside BuildDict.\n\n→ Step 3: Method BuildDict(dictionary) // 設定字典\n    → For each word in dictionary\n        → Add word to words // 存入單字集合\n        → For each index i in word\n            → Create pattern = word with i-th char replaced by '*'\n            → If patternMap does not contain pattern, add new set\n            → Add word to patternMap[pattern] // 讓該模式映射到單字\n\nReturn\n\nThen Search method:\n\n→ Step 4: Method Search(searchWord)\n    → For each index i in searchWord\n        → Create pattern = searchWord with i-th char replaced by '*'\n        → If patternMap contains pattern\n            → For each candidate in patternMap[pattern]\n                → If candidate ≠ searchWord // 確保改變了一個字\n                    → Return true\n    → Return false\n\nEnd\n\nWe can also incorporate decisions on early return.\n\nAdd indentation for decisions.\n\nMake sure each line has virtual code then comment.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 words 集合 // 用於存放所有字典中的單字  \n→ Step 2: 初始化 patternMap 映射 // 鍵為帶有「*」的模式，值為對應的單字集合  \n\n// ================= BuildDict 方法 =================  \n→ Step 3: BuildDict(dictionary) // 設定字典  \n  → For each word in dictionary  \n    → Add word to words // 先把單字存進集合  \n    → For each index i from 0 to word.length-1  \n      → pattern ← word，將第 i 個字元替換為 '*' // 產生模式  \n      → If patternMap 不包含 pattern，則 patternMap[pattern] ← 空集合  \n      → Add word 到 patternMap[pattern] // 將單字加入該模式對應集  \n\nEnd // 字典建構完畢  \n\n// ================= Search 方法 =================  \n→ Step 4: Search(searchWord) // 搜尋是否能改一個字元匹配字典  \n  → For each index i from 0 to searchWord.length-1  \n    → pattern ← searchWord，將第 i 個字元替換為 '*' // 產生候選模式  \n    → If patternMap 包含 pattern  \n      → For each candidate in patternMap[pattern]  \n        → If candidate ≠ searchWord // 必須改變至少一個字元  \n          → Return true // 找到符合條件的單字  \n  → Return false // 沒有符合條件的單字  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Bulb Switcher II",
      "source_file": "Leetcode/leetcode672.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "n = 2, presses = 1",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '4'"
        },
        {
          "example_index": 2,
          "input": "n = 3, presses = 1",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '8'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '8'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef compute_status(n, subset):\n    \"\"\"Return the bulb status after applying the buttons in `subset`.\"\"\"\n    status = [1] * n  # all bulbs are initially ON\n\n    # Button 1: flip all bulbs\n    if subset & 1:\n        status = [1 - s for s in status]\n\n    # Button 2: flip bulbs with even labels (2,4,6,...)\n    if subset & 2:\n        for j in range(1, n, 2):  # 0‑based index: 1,3,5,...\n            status[j] ^= 1\n\n    # Button 3: flip bulbs with odd labels (1,3,5,...)\n    if subset & 4:\n        for j in range(0, n, 2):  # 0‑based index: 0,2,4,...\n            status[j] ^= 1\n\n    # Button 4: flip bulbs with labels j = 3k + 1 (1,4,7,...)\n    if subset & 8:\n        for j in range(0, n, 3):  # 0‑based index: 0,3,6,...\n            status[j] ^= 1\n\n    return tuple(status)  # tuples can be used as keys in a set\n\n\ndef solve(n, presses):\n    if presses == 0:\n        return 1  # only the initial state\n\n    # Containers for unique results according to parity of subset size\n    even_results = set()\n    odd_results = set()\n\n    # Enumerate all 2^4 possible subsets of buttons\n    for subset in range(16):\n        parity = bin(subset).count('1') & 1  # 0 for even, 1 for odd\n        status = compute_status(n, subset)\n        if parity == 0:\n            even_results.add(status)\n        else:\n            odd_results.add(status)\n\n    # Only subsets whose total number of presses has the same parity as\n    # the required number of presses can be used.\n    target_set = even_results if presses % 2 == 0 else odd_results\n    return len(target_set)\n\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, presses = nums[0], nums[1]\n    result = solve(n, presses)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solution. We need to explain. Approach: state space of bulb statuses; but n up to? unknown. We can model each button as a bitmask operation. Since bulbs all on initially. For each sequence of presses, resulting status is XOR of button masks applied odd number times. Equivalent to selecting multiset of presses; order irrelevant. So we need number of distinct XOR results of up to 'presses' button presses. Buttons represented as vectors in GF(2)^n. Only 4 buttons. So the set of achievable vectors is the linear span of these button masks. But with limited number of presses, we need number of distinct vectors that can be expressed as sum of exactly presses buttons (not less). However because buttons can repeat, effectively we count number of solutions of sum mod 2. If presses is large, we can press any button any number times. But parity matters. So we only care about number of distinct XOR combinations achievable by choosing any multiset of size presses. Since pressing same button twice cancels (since flip twice returns to original). So pressing button twice is like no press. So effectively we can press each button either 0 or 1 times mod 2, but total presses count matters: we need to choose multiset of size presses such that the XOR sum is some vector. Equivalent to: we want to count number of distinct vectors achievable as XOR of a subset of buttons where the subset size parity matches presses modulo 2? Wait if presses is say 3, we can press same button thrice; effect same as pressing once (since 3 mod2=1). But pressing twice same button cancels. However pressing button A twice and B once gives same as pressing B once (since A twice cancels). So essentially the effect depends only on parity of times each button pressed. But also the number of presses modulo 2 must equal sum of parities? The total presses count modulo 2 equals parity of number of buttons pressed odd times (since each button pressed odd times contributes 1 mod2 to total). So if presses parity is p, then number of buttons chosen with odd presses must have same parity as p. Because total number of presses = sum over buttons (times pressed). Mod 2, that's sum of times mod 2 (since 2*k contributes 0). So parity condition.\n\nThus the set of reachable vectors is all XOR of subset of buttons where subset size parity matches presses parity. So number of distinct statuses is number of distinct XOR sums from subsets with that parity. But some subsets may produce same XOR if buttons linearly dependent. We need to compute rank of button vectors.\n\nDefine button masks: B1= all ones; B2= even positions; B3= odd positions; B4= positions 1 mod3. They are 4 vectors in GF(2)^n. We can compute rank r. Then number of distinct XOR sums of all subsets is 2^r. But we restrict to parity constraint: subsets with size parity p. How many distinct XOR sums among those? If r=0: only zero vector. parity constraint may reduce but still only 0. In general, when r>=1, the set of sums with size parity p may be either 2^{r-1} or 2^r depending if there is a subset of size parity p producing each vector? Typically if we have at least one vector that is odd parity, we can adjust. But easier: The number of distinct vectors achievable with parity constraint equals 2^{r-1} if there exists a vector of odd cardinality in the generating set? Wait.\n\nLet S be set of all XOR sums of any subset. That's a subspace of size 2^r. The subset with parity condition forms a coset? Actually subset parity depends on number of chosen generators. But XOR sum of subset does not determine size parity. There can be multiple subsets mapping to same vector with different sizes. So counting distinct vectors with subset size parity constraint may equal either 2^{r-1} or 2^r depending if all vectors can be represented by subsets of both parities. For each vector v, consider minimal subset size representation? We can check if there exists two subsets that differ by one generator? If we have at least one generator with weight 1? but not.\n\nSimpler: If r>=1, the mapping from subset to XOR sum is surjective onto subspace. For any vector v, there exist subsets mapping to v. Some subsets have odd cardinality, some even. If there exists at least one generator g such that g itself is linearly independent? For any vector v, we can choose representation of v of some parity. Since we can toggle inclusion of any generator that is zero vector? Not.\n\nGiven small fixed 4 generators, we can brute force 2^4 subsets: compute XOR sum and parity. Then for given parity condition, we count distinct sums. So we don't need rank formula; just enumerate all 16 subsets. That suffices regardless of n size. Complexity trivial.\n\nThus algorithm: For each subset mask from 0 to 15:\n- Compute XOR of buttons included\n- Record parity of subset size (number of bits in mask)\n- Record resulting status vector representation: could use bitmask for n? But n can be large; but we can use pattern representation using formula? Actually vector of length n, but we can represent via type of pattern: maybe just track which of the 4 generators used. But we need to count distinct resulting statuses. We can treat status as function: the XOR of certain generator vectors. Since generators are deterministic patterns, we can characterize resulting status by which generators selected: the XOR result is B1* (a1) XOR B2*(a2) XOR B3*(a3) XOR B4*(a4). We can compute this as integer vector representation maybe using hash of pattern.\n\nSimpler: Use boolean array of size n to compute each vector for each subset. n could be up to maybe 1e9? unknown. But 4 vectors have simple formulas; we can compute final status per subset via analytic rule rather than array. But for virtual code, we don't implement details. We'll produce pseudo algorithm enumerating subsets.\n\nSo steps:\n1. Start\n2. Input n, presses\n3. Initialize set results_even, results_odd\n4. For mask 0..15:\n   - parity = popcount(mask) mod 2\n   - compute status vector from included buttons\n   - add to corresponding set\n5. If presses mod2 ==0: use results_even else results_odd\n6. Output size of chosen set\n7. End\n\nWe also need explanation per line. Let's produce virtual code accordingly.\n\nWe will not output actual code but pseudo steps. We'll use arrow.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取 n 與 presses // 取得燈泡總數與按鍵總次數\n→ Step 2: 建立四個按鈕模式 B1,B2,B3,B4 // 這四個向量描述各按鈕翻轉的燈泡集合\n→ Step 3: 初始化兩個集合 ResEven, ResOdd // 依照子集大小奇偶性儲存不同狀態\n→ Step 4: 從 mask=0 到 15 逐一處理所有 4 位子集 // 共 16 種按鈕選擇組合\n    → Step 4a: 計算 mask 的 popcount mod 2 為 parity // 判斷子集大小的奇偶性\n    → Step 4b: 依 mask 中每個 1 位對應的按鈕，將其模式 XOR 成 status // 得到此組合的燈泡狀態\n    → Step 4c: 若 parity=0，將 status 加入 ResEven；否則加入 ResOdd // 分別存入偶數/奇數子集結果\n→ Step 5: 若 presses mod 2 = 0，選擇 ResultSet = ResEven；否則 ResultSet = ResOdd // 只允許與按鍵總次數奇偶相符的子集\n→ Step 6: 回傳 ResultSet 的大小 // 這即是可達到的不同燈泡狀態數量\nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp75inm9fk.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmp75inm9fk.py\", line 51, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp75inm9fk.py\", line 20, in __init__\n    self.lookup[(pref, suff)] = weight\n    ~~~~~~~~~~~^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass WordFilter:\n    \"\"\"\n    WordFilter 支援根據前綴(prefix)和後綴(suffix)搜尋字典中最大的索引。\n    這裡使用簡單的映射方式：對每個單詞的所有前綴與後綴組合存入字典。\n    \"\"\"\n    def __init__(self, words):\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            # 對每個可能的前綴長度\n            for i in range(L + 1):\n                pref = word[:i]\n                # 對每個可能的後綴長度\n                for j in range(L + 1):\n                    suff = word[j:]\n                    self.lookup[(pref, suff)] = weight\n\n    def f(self, prefix, suffix):\n        \"\"\"\n        回傳符合前綴和後綴的最大索引。\n        若不存在則回傳 -1。\n        \"\"\"\n        return self.lookup.get((prefix, suffix), -1)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，期望形式類似:\n    # [words], [prefix, suffix]\n    # 例如: [[\"apple\"]], [\"a\", \"e\"]\n    # 為了方便，我們把整段文字包在括號，使用 literal_eval 解析為 tuple\n    try:\n        words, params = ast.literal_eval('(' + data + ')')\n    except Exception:\n        # 如果括號方式失敗，嘗試其他簡易分割方式\n        parts = data.split('],', 1)\n        words = ast.literal_eval(parts[0] + ']')\n        params = ast.literal_eval(parts[1].strip())\n\n    if not isinstance(params, (list, tuple)) or len(params) < 2:\n        print(-1)\n        return\n\n    pref, suff = params[0], params[1]\n    wf = WordFilter(words)\n    print(wf.f(pref, suff))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for designing a data structure that supports prefix-suffix queries returning largest index. Likely we use a Trie with combined prefix-suffix. Approach: build a trie of combined strings of suffix + '#' + prefix or something. Classic solution: for each word with index i, for all prefixes and suffixes we build mapping of combined key to index. Or use a trie where each node stores max index for words passing through. Use nested loops: for each word, for each prefix (0..len) and each suffix (0..len) we insert key = prefix + '#' + suffix? Actually common approach: For each word, iterate over all suffixes and prefixes: for each suffix, for each prefix, insert into map with combined string (prefix + '#' + suffix) mapping to max index. That can be heavy.\n\nBetter: Use Trie where we store combined key: word reversed + '#' + word. Then for query pref, suff, we traverse the trie with suff reversed + '#' + pref. That returns max index. That's known solution for Leetcode 745.\n\nBut we just need virtual code: outline building trie, storing max index. Provide steps.\n\nLet's produce code structure: Start, Step 1: Build trie root. For each word with index i: set node = root; for each character c in reversed word: go to child; set node.maxIndex = max(node.maxIndex, i). After finishing suffix, add special char '#', then for each char in prefix: go to child; set node.maxIndex = max(node.maxIndex, i). Done.\n\nThen query: given pref, suff, we traverse: for char in reversed suff: node = node.child[char] if null return -1. then char '#' node = node.child['#'] else return -1. then for char in pref: node = node.child[char] if null return -1. Finally return node.maxIndex.\n\nWe need to produce virtual code line by line with explanation.\n\nAlso we need to include class initialization and method. Use virtual code statements like \"WordFilter Constructor\", \"f Method\".\n\nOk.\n\nLet's produce:\n\nStart\n\n→ Step 1: 定義 TrieNode { map char->child, int maxIndex } // Node structure\n\n→ Step 2: WordFilter Constructor(words) // 初始化\n    → Step 3: root = new TrieNode() // 根節點\n\n    → Decision: For each word w with index i\n        Yes → Step 4: node = root\n        → Step 5: for each char c in reverse(w) // 建立 suffix 結構\n            → Step 6: if node.child[c] null → create\n            → Step 7: node = node.child[c]\n            → Step 8: node.maxIndex = max(node.maxIndex, i) // 更新最大索引\n        → Step 9: node = node.child['#'] // 分隔符\n            → Step 10: if null → create\n            → Step 11: node = node.child['#']\n            → Step 12: node.maxIndex = max(node.maxIndex, i) // 更新\n        → Step 13: for each char c in w // prefix\n            → Step 14: if node.child[c] null → create\n            → Step 15: node = node.child[c]\n            → Step 16: node.maxIndex = max(node.maxIndex, i)\n        → Step 17: // 完成一個單詞的插入\n    End // 建立完成\n\n→ f Method(pref, suff)\n    → Step 18: node = root\n    → Decision: for each char c in reverse(suff)\n        Yes → Step 19: if node.child[c] null → return -1\n        → Step 20: node = node.child[c]\n    → Step 21: if node.child['#'] null → return -1\n    → Step 22: node = node.child['#']\n    → Decision: for each char c in pref\n        Yes → Step 23: if node.child[c] null → return -1\n        → Step 24: node = node.child[c]\n    → Step 25: return node.maxIndex // 最終索引\n\nEnd\n\nWe should incorporate Start and End markers.\n\nLet's produce final output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義 TrieNode { map char->child, int maxIndex } // 建立節點結構，存子節點與最大索引\n→ Step 2: WordFilter Constructor(words) // 初始化函式\n    → Step 3: root = new TrieNode() // 建立根節點\n    → Decision: 遍歷每個單詞 w 及其索引 i\n        Yes →\n            → Step 4: node = root // 從根節點開始\n            → Step 5: for each char c in reverse(w) // 先處理後綴\n                → Step 6: if node.child[c] is null → create new TrieNode\n                → Step 7: node = node.child[c] // 進入下一節點\n                → Step 8: node.maxIndex = max(node.maxIndex, i) // 更新最大索引\n            → Step 9: node = node.child['#'] // 插入分隔符\n                → Step 10: if node is null → create new TrieNode\n                → Step 11: node = node.child['#']\n                → Step 12: node.maxIndex = max(node.maxIndex, i) // 更新索引\n            → Step 13: for each char c in w // 接著處理前綴\n                → Step 14: if node.child[c] is null → create new TrieNode\n                → Step 15: node = node.child[c]\n                → Step 16: node.maxIndex = max(node.maxIndex, i) // 更新索引\n            → Step 17: // 完成單詞 w 的插入\n        No →\n    → End // 建立所有單詞結束\n→ f Method(pref, suff) // 查詢函式\n    → Step 18: node = root // 從根節點開始\n    → Decision: for each char c in reverse(suff) // 依次遍歷後綴（逆序）\n        Yes →\n            → Step 19: if node.child[c] is null → return -1 // 無匹配\n            → Step 20: node = node.child[c]\n    → Step 21: if node.child['#'] is null → return -1 // 缺少分隔符\n    → Step 22: node = node.child['#']\n    → Decision: for each char c in pref // 依次遍歷前綴\n        Yes →\n            → Step 23: if node.child[c] is null → return -1 // 無匹配\n            → Step 24: node = node.child[c]\n    → Step 25: return node.maxIndex // 回傳最大的符合索引\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()()\", \"(a())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\nfrom typing import List, Set\n\nclass Solution:\n    \"\"\"\n    依照題意，使用深度優先搜尋（DFS）搭配回溯\n    來找出最少刪除括號後能得到的所有合法字串。\n    \"\"\"\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        # 結果集合，避免重複\n        res: Set[str] = set()\n\n        # 先計算需刪除的左括號和右括號數量\n        lrem, rrem = 0, 0\n        for ch in s:\n            if ch == '(':\n                lrem += 1\n            elif ch == ')':\n                if lrem == 0:\n                    rrem += 1\n                else:\n                    lrem -= 1\n\n        def dfs(index: int, left: int, right: int,\n                lrem: int, rrem: int, path: List[str]) -> None:\n            \"\"\"\n            index: 當前處理的位置\n            left/right: 目前已經放入的左、右括號數\n            lrem/rrem: 仍可刪除的左、右括號數\n            path: 當前已經組成的字串 (用 list 儲存以降低字串連接成本)\n            \"\"\"\n            # 終止條件：已經到字串尾部\n            if index == len(s):\n                # 只有在已經刪除完必要數量且左右括號平衡時才加入結果\n                if lrem == 0 and rrem == 0 and left == right:\n                    res.add(''.join(path))\n                return\n\n            ch = s[index]\n\n            # 1. 目前字元為左括號\n            if ch == '(':\n                # ① 刪除左括號（若還有可刪除數量）\n                if lrem > 0:\n                    dfs(index + 1, left, right, lrem - 1, rrem, path)\n                # ② 保留左括號\n                path.append(ch)\n                dfs(index + 1, left + 1, right, lrem, rrem, path)\n                path.pop()\n\n            # 2. 目前字元為右括號\n            elif ch == ')':\n                # ① 刪除右括號（若還有可刪除數量）\n                if rrem > 0:\n                    dfs(index + 1, left, right, lrem, rrem - 1, path)\n                # ② 保留右括號（只能在右括號數小於左括號數時）\n                if right < left:\n                    path.append(ch)\n                    dfs(index + 1, left, right + 1, lrem, rrem, path)\n                    path.pop()\n\n            # 3. 其它字元（字母等）直接保留\n            else:\n                path.append(ch)\n                dfs(index + 1, left, right, lrem, rrem, path)\n                path.pop()\n\n        # 從字串起始位置啟動 DFS\n        dfs(0, 0, 0, lrem, rrem, [])\n        # 轉成列表回傳\n        return list(res)\n\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    從輸入字串中抓取第一個被雙引號包住的內容。\n    若沒有符合，則直接回傳整個輸入（去除首尾空白）。\n    \"\"\"\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        return match.group(1)\n    # 也可能輸入純字串\n    return data.strip()\n\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    s = parse_input(raw)\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n    # 使用 json.dumps 以確保輸出雙引號符合題目要求\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm. Should describe steps: find number of left/right parentheses to remove via counting mismatches; then DFS/backtracking generating all valid strings with minimal removals; avoid duplicates using set. Provide explanation per line.\n\nLet's produce lines with Start, steps.\n\nWe need to ensure \"逐行\". So each line separate.\n\nWe'll produce algorithm steps:\n\nStart\n→ Step 1: 計算要刪除的左括號數 lrem\n→ Step 2: 計算要刪除的右括號數 rrem\n→ Step 3: 定義遞迴函數 dfs(index, left_count, right_count, lrem, rrem, current_string)\n→ Step 4: Base case: 如果 index == len(s)\n    → Decision: 如果 lrem == 0 and rrem == 0 and left_count == right_count\n        Yes → Step 5: 把 current_string 加入結果集合\n→ Step 5: 否則返回\n→ Step 6: Get current char c = s[index]\n→ Step 7: If c == '('\n    → Decision: 如果 lrem > 0\n        Yes → dfs(index+1, left_count, right_count, lrem-1, rrem, current_string) // 刪除此左括號\n    → Decision: Always include\n        Yes → dfs(index+1, left_count+1, right_count, lrem, rrem, current_string + c) // 保留左括號\n→ Step 8: Else if c == ')'\n    → Decision: 如果 rrem > 0\n        Yes → dfs(index+1, left_count, right_count, lrem, rrem-1, current_string) // 刪除右括號\n    → Decision: 如果 right_count < left_count\n        Yes → dfs(index+1, left_count, right_count+1, lrem, rrem, current_string + c) // 保留右括號\n→ Step 9: Else // letter\n    → dfs(index+1, left_count, right_count, lrem, rrem, current_string + c) // 保留字母\nEnd // 返回結果列表\n\nAlso need to call dfs(0,0,0,lrem,rrem,\"\").\n\nLet's produce accordingly.\n\nNeed to include start and end lines.\n\nMake sure each line uses arrow with indentation for decisions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算要刪除的左括號數 lrem ← count the number of '(' that must be removed to balance the string  \n→ Step 2: 計算要刪除的右括號數 rrem ← count the number of ')' that must be removed to balance the string  \n→ Step 3: 定義遞迴函數 dfs(index, left_count, right_count, lrem, rrem, current_string) ← 用來遍歷字串並構造合法字串  \n→ Decision: 如果 index == len(s) ? ← 已經處理完所有字元  \n  Yes → Decision: 如果 lrem == 0 and rrem == 0 and left_count == right_count ? ← 目前字串合法且已刪除最少數量  \n   Yes → Step 4: 把 current_string 加入結果集合 ← 儲存一個合法答案  \n   No  → Step 5: 返回 ← 不合法，停止此分支  \n  No  → Step 6: 取當前字元 c = s[index] ← 進入下一個字元的處理  \n→ Decision: 如果 c == '(' ? ← 左括號  \n  Yes → Decision: 如果 lrem > 0 ? ← 仍有左括號可以刪除  \n   Yes → dfs(index+1, left_count, right_count, lrem-1, rrem, current_string) ← 刪除此左括號  \n  No  → Decision: 永遠包含  \n   Yes → dfs(index+1, left_count+1, right_count, lrem, rrem, current_string + c) ← 保留左括號  \n→ Decision: 否則如果 c == ')' ? ← 右括號  \n  Yes → Decision: 如果 rrem > 0 ? ← 仍有右括號可以刪除  \n   Yes → dfs(index+1, left_count, right_count, lrem, rrem-1, current_string) ← 刪除此右括號  \n  No  → Decision: 如果 right_count < left_count ? ← 右括號數少於左括號才能保留  \n   Yes → dfs(index+1, left_count, right_count+1, lrem, rrem, current_string + c) ← 保留右括號  \n→ Decision: 否則 (c 為字母) ? ← 普通字母  \n  Yes → dfs(index+1, left_count, right_count, lrem, rrem, current_string + c) ← 直接保留字母  \n→ End // 回傳結果集合（轉成列表返回）"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立一個字典，把每個數字對應到它在 nums 中所有索引的清單\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        # 從對應的索引清單中隨機挑選一個\n        return random.choice(self.num_indices[target])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 把輸入切成兩個部分：操作列表與對應的參數列表\n    parts = data.split('],', 1)\n    ops_str = parts[0] + ']'          # 還原第一部分的結尾括號\n    args_str = parts[1]              # 第二部分已經以 '[' 開頭\n\n    ops = ast.literal_eval(ops_str)\n    args_list = ast.literal_eval(args_str)\n\n    results = []\n    obj = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            # 建構子，args 是一個列表，例如 [[1, 2, 3]]\n            obj = Solution(args[0])\n            results.append(None)  # 建構子返回 null\n        elif op == \"pick\":\n            # pick 方法，args 是一個列表，例如 [3]\n            res = obj.pick(args[0])\n            results.append(res)\n\n    # 使用 json.dumps 可以得到類似 Leetcode 的輸出格式，例如 [null, 4, 0, 2]\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps with explanations. Steps: start, constructor store array, maybe precompute mapping of target to indices? But requirement: random index each call, uniform among occurrences. Simplest: store array and use pick: iterate to find indices, collect, then random choose. Complexity O(n) each pick. That's fine.\n\nVirtual code steps: Start, Step 1: Store nums in instance variable. Step 2: pick: initialize empty list indices. For i in 0..len-1: if nums[i]==target: append i. After loop, choose random from indices. Return.\n\nInclude random generator. Use arrow.\n\nLet's produce lines accordingly.\n\nAlso need Start and End.\n\nEnsure each line has \"虛擬碼步驟\" + space + \"// 解釋\". We'll follow format: e.g., \"Start // 程式開始執行\".\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Solution(nums)  \n  Store nums in instance variable this.nums // 將輸入陣列保存起來以供之後使用  \n→ End // 構造完成  \n\n→ Step 2: pick(target)  \n  Initialize empty list indices // 用來存放所有符合目標值的索引  \n  For i from 0 to this.nums.length - 1  \n   If this.nums[i] == target  \n    Append i to indices // 找到目標值的索引後加入列表  \n  Randomly select one element idx from indices using uniform distribution // 以等概率選擇一個索引  \n  Return idx // 回傳選中的索引  \n→ End // pick 方法結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[0,1],[1,0],[0,1],[1,0],[0,1],[1,0],[3,2],[2,4]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[0, 1], [1, 0], [0, 1], [1, 0], [0, 1], [1, 0], [3, 2], [2, 4]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[0,1],[1,0],[0,1],[1,0],[0,1],[1,0]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[0, 1], [1, 0], [0, 1], [1, 0], [0, 1], [1, 0]]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立單字到其索引的映射表\n        word_to_index = {word: i for i, word in enumerate(words)}\n        res = []\n\n        for i, word in enumerate(words):\n            # 直接跳過空字串，之後再特殊處理\n            if word == \"\":\n                continue\n\n            # 完全反轉的情況\n            rev = word[::-1]\n            if rev in word_to_index:\n                j = word_to_index[rev]\n                if j != i:\n                    res.append([i, j])\n\n            # 依照所有切分位置檢查\n            for k in range(len(word) + 1):\n                prefix = word[:k]\n                suffix = word[k:]\n\n                # 前半部為回文，後半部可配對\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in word_to_index:\n                        j = word_to_index[rev_suffix]\n                        if j != i and k != len(word):\n                            res.append([j, i])\n\n                # 後半部為回文，前半部可配對\n                if suffix == suffix[::-1]:\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in word_to_index:\n                        j = word_to_index[rev_prefix]\n                        if j != i and k != 0:\n                            res.append([i, j])\n\n        # 空字串的特殊處理\n        if \"\" in word_to_index:\n            empty_idx = word_to_index[\"\"]\n            for j, w in enumerate(words):\n                if j == empty_idx:\n                    continue\n                if w == w[::-1]:\n                    res.append([empty_idx, j])\n                    res.append([j, empty_idx])\n\n        return res\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if data.startswith(\"words\"):\n        # 只取 = 後面的部分\n        parts = data.split(\"=\", 1)\n        expr = parts[1].strip() if len(parts) > 1 else \"\"\n    else:\n        expr = data\n\n    # 將字串轉成真正的 Python 物件\n    words = ast.literal_eval(expr)\n\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode step-by-step with explanations. Use arrow syntax. The algorithm with O(total length) likely uses a hash map from word to index and check reverse etc. We produce high-level steps. Provide virtual code lines with explanations. Use Start, End. Provide Decision lines. Should not produce real code.\n\nWe need to show steps: build map, for each word, for each split, check conditions. Provide complexity commentary. Provide decision steps.\n\nLet's outline:\n\nStart\n→ Step 1: Build map from word to its index // O(total length)\n→ Step 2: Initialize result list // O(1)\n→ Decision: Iterate over each word index i // loop\n    → For each split position k from 0 to len(word) // iterate\n        → Decision: if prefix is palindrome // check\n            → Step: add pair (i, index of reversed suffix) if exists and not i\n        → Decision: if suffix is palindrome and k != len(word)\n            → Step: add pair (index of reversed prefix, i)\n→ Step: Handle empty string separately // add pairs with all palindromes\n→ End\n\nAdd explanation lines.\n\nWe need to ensure virtual code arrow formatting. Use → for sequential lines. Use Decision. Each line has code and comment.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ BuildHashMap words → // 建立單字到索引的映射表，耗時 O(total字長)\n\nUse arrow for next lines.\n\nUse Decision: If word exists in map and not same index.\n\nLet's produce.\n\nAlso include logic for reversed word. Use Step: Find reverse of suffix/prefix.\n\nWe might break into substeps.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ BuildHashMap: 建立字典 wordToIndex，把每個單字映射到其索引 // O(總字長)  \n\n→ Initialize ResultList // 用來存所有符合的 (i, j) // O(1)  \n\n→ Decision: For i in 0 .. words.length-1 // 逐一處理每個單字  \n    → Step 1: word ← words[i] // 取得目前的單字  \n    → Step 2: revWord ← Reverse(word) // 取得單字的完全反轉  \n    → Decision: 如果 revWord 在 wordToIndex 且 wordToIndex[revWord] ≠ i  \n        Yes → Append (i, wordToIndex[revWord]) to ResultList // 完全反轉形成回文  \n    → For splitPos from 0 to len(word) // 依照各個切分位置  \n        → Step 3: prefix ← word[0:splitPos] // 取得前半部  \n        → Step 4: suffix ← word[splitPos:] // 取得後半部  \n\n        → Decision: 如果 prefix 是回文 // 前半部回文，後半部可配對  \n            Yes → revSuffix ← Reverse(suffix)  \n            → Decision: 如果 revSuffix 在 wordToIndex 且 wordToIndex[revSuffix] ≠ i  \n                Yes → Append (i, wordToIndex[revSuffix]) to ResultList // i 在前，配對後半部  \n        → Decision: 如果 splitPos < len(word) 且 suffix 是回文 // 後半部回文，前半部可配對  \n            Yes → revPrefix ← Reverse(prefix)  \n            → Decision: 如果 revPrefix 在 wordToIndex 且 wordToIndex[revPrefix] ≠ i  \n                Yes → Append (wordToIndex[revPrefix], i) to ResultList // 配對前半部  \n\n→ Decision: 如果有空字串 \"\" 在 words  \n    Yes → emptyIndex ← wordToIndex[\"\"]  \n    → For k in 0 .. words.length-1, k ≠ emptyIndex  \n        → Decision: 如果 words[k] 是回文  \n            Yes → Append (emptyIndex, k) to ResultList  \n            Yes → Append (k, emptyIndex) to ResultList  \n\nEnd // 程式執行結束，ResultList 為所有符合條件的索引對"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\ndef longest_uncommon_subsequence_length(strs):\n    \"\"\"\n    只要有一個字串在陣列中唯一，答案就是那個字串的長度。\n    若所有字串皆重複，則不存在「uncommon subsequence」。\n    \"\"\"\n    # 計算每個字串出現次數\n    counts = Counter(strs)\n\n    # 收集所有唯一字串的長度，並找出最大值\n    unique_lengths = [len(s) for s, cnt in counts.items() if cnt == 1]\n    if unique_lengths:\n        return max(unique_lengths)\n    return -1\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行資料（可能包含換行）\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        # 空輸入直接輸出 -1\n        print(-1)\n        sys.exit(0)\n\n    try:\n        # 使用 json.loads 解析輸入字串列表\n        strs = json.loads(raw_input)\n        if not isinstance(strs, list):\n            raise ValueError\n    except Exception:\n        # 如果解析失敗，視為輸入格式錯誤，直接輸出 -1\n        print(-1)\n        sys.exit(0)\n\n    result = longest_uncommon_subsequence_length(strs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code lines. Steps: Input array of strings. We need find longest uncommon subsequence length. Known solution: if there exists a string that is not equal to any other string, answer is its length. If all strings equal, return -1. But more generally, check each string if not equal to any other; if unique, its length is candidate. Longest among them. Return -1 if none unique. That's algorithm. Virtual code: Start, Step1: Read array, Step2: Determine if any string appears only once, gather lengths, etc. Provide decision branches.\n\nWe should produce step-by-step pseudo-code with arrows and decisions. Use Start/End. Use \"Decision:\" lines. Use \"→\" arrows.\n\nLet's craft. Ensure each line has \"虛擬碼步驟\" and comment. We need to use arrow arrow. For example:\n\nStart // 程式開始\n\n→ Step 1: Input strs // 讀取字串陣列\n\n→ Step 2: 建立字典 counts // 計算每個字串出現次數\n\n→ Decision: 有至少一個字串 counts[x]==1? // 判斷是否存在唯一字串\n\nYes → Step 3: 收集所有唯一字串的長度並取最大值 // 找出長度最大者\n\n→ Step 4: Return 最大長度 // 回傳結果\n\nNo → Step 5: Return -1 // 沒有唯一字串\n\nEnd // 程式結束\n\nBut we need to ensure that we handle duplicate array length? Implementation: For each string in array, if string not equal to any other string, answer its length. But we can implement counts.\n\nAlso we might include step to compute longest. Use variable maxLen. Also handle scenario where there are no unique strings.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Input strs // 讀取輸入的字串陣列\n→ Step 2: Initialize counts ← empty dictionary // 建立字典以記錄每個字串出現次數\n→ Step 3: For each s in strs:\n    → counts[s] ← counts.get(s, 0) + 1 // 計算各字串的出現頻率\n→ Decision: 有至少一個字串 counts[s] == 1? // 判斷是否存在唯一字串\n    Yes → Step 4: maxLen ← 0 // 記錄目前最大長度\n        → For each s in strs:\n            → If counts[s] == 1:\n                → maxLen ← max(maxLen, len(s)) // 取得唯一字串中的最大長度\n        → Step 5: Return maxLen // 回傳最大長度\n    No  → Step 6: Return -1 // 沒有唯一字串時回傳 -1\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Subarray Product Less Than K",
      "source_file": "Leetcode/leetcode713.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [10,5,2,6], k = 100",
          "expected_output": "8",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9l36kfge.py\", line 49, in <module>\n    main()\n  File \"/tmp/tmp9l36kfge.py\", line 29, in main\n    nums = eval(val.strip())\n           ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [10\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3], k = 0",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp39137b1a.py\", line 49, in <module>\n    main()\n  File \"/tmp/tmp39137b1a.py\", line 29, in main\n    nums = eval(val.strip())\n           ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def numSubarrayProductLessThanK(self, nums, k):\n        if k <= 1:\n            return 0\n        prod = 1\n        left = 0\n        count = 0\n        for right, val in enumerate(nums):\n            prod *= val\n            while prod >= k and left <= right:\n                prod //= nums[left]\n                left += 1\n            count += right - left + 1\n        return count\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，格式類似: 'nums = [10,5,2,6], k = 100'\n    parts = [p.strip() for p in data.split(',')]\n    nums = None\n    k = None\n    for part in parts:\n        if part.lower().startswith('nums'):\n            _, val = part.split('=', 1)\n            nums = eval(val.strip())\n        elif part.lower().startswith('k'):\n            _, val = part.split('=', 1)\n            k = int(val.strip())\n    # 若輸入格式不符，嘗試直接使用 eval\n    if nums is None or k is None:\n        try:\n            parsed = eval(data)\n            nums = parsed.get('nums')\n            k = parsed.get('k')\n        except Exception:\n            pass\n    if nums is None or k is None:\n        print(0)\n        return\n    sol = Solution()\n    result = sol.numSubarrayProductLessThanK(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the sliding window algorithm to count subarrays with product less than k. Each line: virtual step + comment. Use arrows, decisions. No actual code. We'll produce a series of steps. We'll consider edge cases: if k <=1, return 0. Then use two pointers left,right, product=1, count=0. For each right, multiply product by nums[right]. While product >= k and left <= right, divide by nums[left] and left++. Then count += right-left+1. After loop, return count.\n\nWe need to produce step-by-step lines. We'll format as per example: Start, → Step 1: ... // comment, → Decision: ... etc. Use Yes →, No →. We need to include End.\n\nLet's craft the virtual steps.\n\n1. Start\n2. → Decision: 是否 k <= 1? // check if threshold too small\n   Yes → Step 1: 返回 0 // If k <=1, no subarray can satisfy product<k\n   No  → Step 2: 初始化 left=0, right=0, product=1, count=0 // prepare variables\n3. → Step 3: 進入主迴圈 while right < length(nums) // iterate through array\n4. → Step 4: 乘以 nums[right]  // update product with new element\n5. → Decision: product >= k? // check if product too large\n   Yes → Step 5: while product >= k and left <= right\n            → Step 5a: 除以 nums[left] // shrink window from left\n            → Step 5b: left++ // move left pointer\n   No → // no action\n6. → Step 6: count += right - left + 1 // add number of valid subarrays ending at right\n7. → Step 7: right++ // move right pointer\n8. → Decision: right < length(nums)? // loop condition\n   Yes → 回到 Step 3\n   No  → Step 8: 返回 count // finished\n9. End\n\nBut we need each line as separate. Use arrow syntax. We must indent decisions properly? In example, decisions indent with spaces and then Yes/No lines indented. We'll follow similar.\n\nWe need \"虛擬碼步驟\" maybe in Chinese. Use Step or Decision. We'll produce lines:\n\nStart // 程式開始執行\n→ Decision: 是否 k <= 1? // 檢查 k 是否小於等於 1\n    Yes → Step 1: 返回 0 // 如果 k <= 1，無符合條件的子陣列\n    No  → Step 2: 初始化 left=0, right=0, product=1, count=0 // 設定滑動視窗參數\n→ Step 3: 進入主迴圈 while right < len(nums) // 遍歷陣列\n→ Step 4: product *= nums[right] // 加入右端元素\n→ Decision: product >= k? // 檢查產品是否超過 k\n    Yes → While product >= k and left <= right:\n            → Step 5a: product /= nums[left] // 移除左端元素\n            → Step 5b: left++ // 左指標右移\n    No  → // 不做任何縮小動作\n→ Step 6: count += right - left + 1 // 加入符合條件的子陣列數\n→ Step 7: right++ // 右指標右移\n→ Decision: right < len(nums)? // 判斷是否還有元素\n    Yes → 回到 Step 3\n    No  → Step 8: 返回 count // 結束並回傳結果\nEnd // 程式結束執行\n\nBut we need each line separate. We'll format accordingly. Also note we need \"Start\" as separate line. Use arrow for each step. Let's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 是否 k <= 1? // 檢查 k 是否小於等於 1  \n  Yes → Step 1: 返回 0 // 如果 k <= 1，無符合條件的子陣列  \n  No  → Step 2: 初始化 left=0, right=0, product=1, count=0 // 設定滑動視窗參數  \n→ Step 3: 進入主迴圈 while right < len(nums) // 遍歷陣列  \n→ Step 4: product *= nums[right] // 加入右端元素到積  \n→ Decision: product >= k? // 檢查目前產品是否已經不符合條件  \n  Yes → While product >= k and left <= right:  \n    → Step 5a: product /= nums[left] // 移除左端元素以縮小視窗  \n    → Step 5b: left++ // 左指標向右移動  \n  No  → // 若產品已低於 k，保持視窗不變  \n→ Step 6: count += right - left + 1 // 所有以 right 為結尾且符合條件的子陣列數量  \n→ Step 7: right++ // 右指標向右移動，進入下一個子陣列  \n→ Decision: right < len(nums)? // 判斷是否還有元素可處理  \n  Yes → 回到 Step 3  \n  No  → Step 8: 返回 count // 所有子陣列已計算完畢，回傳結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        \"\"\"\n        找出 DNA 序列中所有重複出現的 10 字母長子序列。\n        \"\"\"\n        if len(s) < 10:\n            return []\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        print(json.dumps([]))\n        return\n\n    # 解析輸入，支援 \"s = 'DNASEQ'\" 或僅輸入 DNASEQ\n    if \"='\" in data or '=\"' in data:\n        # 找出第一個單引號或雙引號的起始位置\n        start_quote = data.find(\"'\")\n        if start_quote == -1:\n            start_quote = data.find('\"')\n        end_quote = data.rfind(\"'\") if start_quote != -1 else data.rfind('\"')\n        if start_quote != -1 and end_quote != -1 and end_quote > start_quote:\n            s = data[start_quote+1:end_quote]\n        else:\n            # 無法正確切割，直接使用整個字串（不含引號）\n            s = data.replace(\"s =\", \"\").strip().strip(\"'\").strip('\"')\n    else:\n        s = data\n\n    sol = Solution()\n    result = sol.findRepeatedDnaSequences(s)\n    # 使用 JSON 格式輸出，符合範例要求\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm: find all 10-letter substrings that appear more than once in a given string s. Approach: sliding window of length 10, use hashmap to count. After scanning, output keys with count>1. Use virtual code.\n\nWe output each line with step and explanation.\n\nWe need Start, End, Decision, etc. We need to include arrow and decision arrows.\n\nWe'll produce something like:\n\nStart\n→ Step 1: Input string s\n→ Decision: s.length < 10? // if shorter, no substrings\n    Yes → Step 2: Return empty list\n    No  → Step 3: Initialize dictionary countMap\n    → Step 4: For i from 0 to s.length-10\n          → Step 5: Extract substring sub = s[i:i+10]\n          → Step 6: countMap[sub] = countMap.get(sub,0)+1\n    → Step 7: Initialize result list\n    → Step 8: For each entry in countMap\n          → Decision: entry.value > 1?\n               Yes → Step 9: Add entry.key to result\n               No  → skip\n    → Step 10: Return result\nEnd\n\nNeed to adhere to format with arrow and // explanation.\n\nMake sure each line has \"虛擬碼步驟\" then space then \"// explanation\".\n\nAlso include arrows like →, Yes →, No →, Decision:. Ensure structure.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者處取得 DNA 序列  \n→ Decision: s.length < 10? // 判斷字串是否足夠長以形成 10 字母子序列  \n    Yes → Step 2: 回傳空列表 [] // 若不足 10，直接返回空結果  \n    No  → Step 3: 初始化字典 countMap 為 {} // 用於儲存子序列出現次數  \n→ Step 4: 循環 i 從 0 到 s.length - 10  \n    → Step 5: 取子序列 sub = s[i : i+10] // 取得當前 10 字母窗口  \n    → Step 6: countMap[sub] = countMap.get(sub, 0) + 1 // 記錄次數  \n→ Step 7: 初始化結果列表 result 為 [] // 用於儲存重複子序列  \n→ Step 8: 遍歷 countMap 的每個 (sub, cnt)  \n    → Decision: cnt > 1? // 判斷是否重複  \n        Yes → Step 9: result.append(sub) // 若重複，加入結果  \n        No  → Skip // 否則忽略  \n→ Step 10: 回傳 result // 返回所有出現超過一次的 10 字母子序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"返回 nums 的所有排列。\"\"\"\n        res = []\n\n        def backtrack(start):\n            # 決定：是否已經選完所有位置\n            if start == len(nums):\n                res.append(nums[:])   # 把目前的排列加入結果\n                return\n            # 迭代：嘗試把每個剩餘元素放在 current 的 start 位置\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # 交換\n                backtrack(start + 1)                         # 深入下一層\n                nums[start], nums[i] = nums[i], nums[start]  # 回溯，還原\n\n        backtrack(0)\n        return res\n\ndef main():\n    \"\"\"從 stdin 讀取輸入，計算排列，輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中抽取列表\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums_str = match.group(0)\n        nums = eval(nums_str, {})\n    else:\n        nums = []\n\n    sol = Solution()\n    result = sol.permute(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all permutations of an array of distinct integers. Use steps, decisions. Should be simple backtracking algorithm. Must follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrows. Start, End, Decision. Let's outline:\n\nStart\n→ Initialize result list\n→ Define backtrack(current, remaining)\n    → Decision: 是否 remaining 为空?\n        Yes → Add current copy to result\n        No  → For each i in remaining:\n                → Append remaining[i] to current\n                → Remove i from remaining (create new list)\n                → Call backtrack(current, new_remaining)\n                → Remove last from current\n→ Call backtrack(empty, nums)\n→ Return result\nEnd\n\nBut need to be line-by-line. Each step maybe separate lines. Use arrows for nested lines. Format: `Start // 程式開始執行`. Use `→` before each step, indent for nested decisions. Use `Decision:` with Yes/No lines. Use `End // 程式執行結束`. Let's produce.\n\nNote: Should we include variable names? Yes.\n\nAlso we should avoid actual code, just steps. Provide explanation.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Initialize result = [] // 用於存放所有排列\n→ Define function backtrack(current, remaining) // 回溯遞迴函式\n    → Decision: remaining 是否為空? // 判斷是否已排列完畢\n        Yes → Append copy of current to result // 完整排列加入結果\n        No  → For each index i in 0..remaining.length-1:\n            → Append remaining[i] 到 current // 將元素加到目前排列\n            → newRemaining = remaining 刪除索引 i 的元素 // 創建新的剩餘清單\n            → Call backtrack(current, newRemaining) // 繼續遞迴\n            → Remove last element from current // 回溯，撤銷加入的元素\n→ Call backtrack([], nums) // 開始回溯，從空排列與完整數列開始\n→ Return result // 回傳所有排列\nEnd // 程式執行結束\n\nWe need to use `Decision:` lines properly with Yes/No lines.\n\nMake sure to use `→` for each line, and indent nested lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize result = [] // 用於存放所有排列\n→ Define function backtrack(current, remaining) // 回溯遞迴函式\n    → Decision: remaining 是否為空? // 判斷是否已排列完畢\n        Yes → Append copy of current to result // 完整排列加入結果\n        No  → For each index i in 0..remaining.length-1:\n            → Append remaining[i] 到 current // 將元素加到目前排列\n            → newRemaining = remaining 刪除索引 i 的元素 // 創建新的剩餘清單\n            → Call backtrack(current, newRemaining) // 繼續遞迴\n            → Remove last element from current // 回溯，撤銷加入的元素\n→ Call backtrack([], nums) // 開始回溯，從空排列與完整數列開始\n→ Return result // 回傳所有排列\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprcmhiivg.py\", line 43, in <module>\n    raise ValueError(\"Invalid input format\")\nValueError: Invalid input format"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport re\nimport ast\n\nclass MedianFinder:\n    def __init__(self):\n        # 小根堆存放較小的一半數字，使用負數實現大根堆\n        self.small = []  # max-heap (store negatives)\n        self.large = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        # 先把 num 放到小根堆（max-heap）\n        heapq.heappush(self.small, -num)\n\n        # 保證兩堆之間的最大值不大於最小值\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 重新平衡大小，讓小根堆大小最多比大根堆多 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將輸入拆成兩個列表：方法名列表和參數列表\n    parts = re.split(r'\\],\\s*\\[', data)\n    if len(parts) != 2:\n        raise ValueError(\"Invalid input format\")\n\n    first = parts[0] + ']'   # 完整方法名列表\n    second = '[' + parts[1]  # 完整參數列表\n\n    ops = ast.literal_eval(first)\n    args = ast.literal_eval(second)\n\n    obj = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            outputs.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0] if isinstance(arg, (list, tuple)) else arg)\n            outputs.append(None)\n        elif op == \"findMedian\":\n            outputs.append(obj.findMedian())\n        else:\n            raise ValueError(f\"Unknown operation: {op}\")\n\n    print(outputs)",
      "virtual_code": "Thinking...\nWe need to generate virtual code (pseudocode) for implementing MedianFinder class with addNum and findMedian using two heaps method. Provide step-by-step pseudo-code with comments. Use Start, End, Decision etc. Each line: virtual code step + space + // explanation. Use arrows →. Use \"Yes →\" \"No →\" for decisions. Must not output actual code, only structure steps. So we produce a virtual algorithm: Initialize two heaps: maxHeap for lower half, minHeap for upper half. In addNum: push to maxHeap if empty or num <= maxHeap.peek else push to minHeap. Rebalance: if size difference >1, move top from larger to smaller. In findMedian: if sizes equal, median = (maxHeap.peek + minHeap.peek)/2. else median = top of larger. Provide pseudo code lines with explanations.\n\nWe need to format exactly: Each line like:\n\nStart // 程式開始執行\n\n→ Step 1: ... // explanation\n\nIf decision:\n\n→ Decision: 如果 maxHeap size > minHeap size + 1? // explanation\n\n    Yes → Step X: ... // explanation\n\n    No  → Step Y: ... // explanation\n\nWe should keep each step line distinct.\n\nAlso we need to include class definition pseudo-code lines maybe: MedianFinder() initialization.\n\nWe can include: Step 1: Define class MedianFinder // explanation\n\nStep 2: 初始化 maxHeap, minHeap // explanation\n\nAddNum method lines: Step 3: If maxHeap empty or num <= maxHeap.peek then push to maxHeap else push to minHeap // explanation\n\nStep 4: Rebalance heaps // explanation\n\nWithin rebalance: Decision if maxHeap size > minHeap size + 1, then move top to minHeap. Or if minHeap size > maxHeap size, move top to maxHeap.\n\nThen findMedian: Step: If sizes equal then compute average else return top of larger heap.\n\nEnd // 程式結束\n\nWe also need to produce for each method separately or integrate? We'll produce steps sequentially but maybe separate methods.\n\nThe output must be purely virtual code lines.\n\nWe should adhere to the format exactly. Each line: \"虛擬碼步驟\" + space + \"// 解釋/說明\". So we cannot include any actual code syntax. Use pseudo-code words: \"Define class\", \"Initialize\", \"AddNum()\", \"FindMedian()\", \"Push to heap\", etc. We should also include decision lines.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: Define class MedianFinder // 建立 MedianFinder 類別\n→ Step 2: 於構造函式中初始化兩個堆疊: maxHeap, minHeap // 用於存放較小半段與較大半段\n→ Step 3: 定義 addNum(num) 方法 // 用於插入新數字\n→ Step 4: 於 addNum 中判斷 num 與 maxHeap 最大值關係\n    Yes → Step 5: Push num 到 maxHeap // 若 num <= maxHeap.peek 則放入下限堆\n    No  → Step 6: Push num 到 minHeap // 否則放入上限堆\n→ Step 7: 呼叫 RebalanceHeaps() // 平衡兩個堆\n→ Step 8: 定義 findMedian() 方法 // 取得目前所有數字的中位數\n→ Step 9: 若 maxHeap.size == minHeap.size? // 判斷兩堆大小是否相等\n    Yes → Step 10: 返回 (maxHeap.peek + minHeap.peek) / 2.0 // 均為偶數個數，取平均\n    No  → Decision: 若 maxHeap.size > minHeap.size? // 若下限堆較大\n        Yes → Step 11: 返回 maxHeap.peek // 下限堆頂即為中位數\n        No  → Step 12: 返回 minHeap.peek // 上限堆頂即為中位數\n→ Step 13: 定義 RebalanceHeaps() 方法 // 重新平衡堆的大小\n→ Step 14: 若 maxHeap.size > minHeap.size + 1? // 下限堆過大\n    Yes → Step 15: 取出 maxHeap.peek 並 Push 到 minHeap // 將最大值移至上限堆\n    No  → Decision: 若 minHeap.size > maxHeap.size? // 上限堆過大\n        Yes → Step 16: 取出 minHeap.peek 並 Push 到 maxHeap // 將最小值移至下限堆\n        No  → Step 17: 堆已平衡 // 無需調整\nEnd // 程式執行結束\n\nNeed to ensure each line follows format: \"虛擬碼步驟\" + space + \"// 解釋/說明\". For decision lines we need to indent? Example in spec: \n```\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\n```\nThus we should mimic that formatting: use \"→ Decision:\" line, then indent Yes / No lines. We'll keep consistent spacing maybe 4 spaces? Example shows 4 spaces before Yes. We will replicate.\n\nAlso include \"Start\" line and \"End\" line. We need each line to start with \"Start\", \"→\" etc. Let's produce.\n\nWe'll need to decide the indentation: For \"Yes →\" lines, start with 4 spaces then \"Yes →\". For \"No →\", similar.\n\nOk produce final output.\n\nAlso we need to include that it's a virtual code, so not actual code. We'll use words like \"Push\" not \"push\". We'll use \"Return\" instead of \"return\".\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class MedianFinder // 建立 MedianFinder 類別  \n→ Step 2: 於構造函式中初始化兩個堆疊: maxHeap, minHeap // 用於存放較小半段與較大半段  \n\n→ Step 3: 定義 addNum(num) 方法 // 用於插入新數字  \n→ Step 4: 若 maxHeap 為空 或 num ≤ maxHeap.peek? // 判斷數字與下限堆頂的大小關係  \n  Yes → Step 5: Push num 到 maxHeap // 若符合條件，放入下限堆  \n  No  → Step 6: Push num 到 minHeap // 否則放入上限堆  \n→ Step 7: 呼叫 RebalanceHeaps() // 平衡兩個堆的大小  \n\n→ Step 8: 定義 findMedian() 方法 // 取得目前所有數字的中位數  \n→ Step 9: 若 maxHeap.size == minHeap.size? // 判斷兩堆大小是否相等  \n  Yes → Step 10: Return (maxHeap.peek + minHeap.peek) / 2.0 // 均為偶數個數，取平均  \n  No  → Decision: 若 maxHeap.size > minHeap.size? // 下限堆較大  \n    Yes → Step 11: Return maxHeap.peek // 下限堆頂即為中位數  \n    No  → Step 12: Return minHeap.peek // 上限堆頂即為中位數  \n\n→ Step 13: 定義 RebalanceHeaps() 方法 // 重新平衡堆的大小  \n→ Step 14: 若 maxHeap.size > minHeap.size + 1? // 下限堆過大  \n  Yes → Step 15: Pop maxHeap.peek 並 Push 到 minHeap // 將最大值移至上限堆  \n  No  → Decision: 若 minHeap.size > maxHeap.size? // 上限堆過大  \n    Yes → Step 16: Pop minHeap.peek 並 Push 到 maxHeap // 將最小值移至下限堆  \n    No  → Step 17: 堆已平衡 // 無需調整  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Substring with Concatenation of All Words",
      "source_file": "Leetcode/leetcode30.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[6,9,12]'\nGot (Norm):      '[6]'\n--- (Raw) ---\nRaw Expected: '[6,9,12]'\nRaw Got:      '[6]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findSubstring(self, s, words):\n        \"\"\"\n        Find starting indices of concatenated substrings in s.\n        \"\"\"\n        if not words:\n            return []\n\n        n = len(s)\n        k = len(words)\n        word_len = len(words[0])\n        total_len = word_len * k\n\n        if n < total_len:\n            return []\n\n        target = Counter(words)\n        res = []\n\n        # Process each possible offset\n        for offset in range(word_len):\n            left = offset\n            right = offset\n            window = {}\n            matched = 0\n\n            while right + word_len <= n:\n                word = s[right:right + word_len]\n                right += word_len\n\n                if word in target:\n                    window[word] = window.get(word, 0) + 1\n                    if window[word] <= target[word]:\n                        matched += 1\n                    else:\n                        # Shrink window until counts are valid\n                        while window[word] > target[word]:\n                            left_word = s[left:left + word_len]\n                            left += word_len\n                            window[left_word] -= 1\n                            if left_word == word:\n                                matched -= 1\n                else:\n                    # Reset window\n                    window.clear()\n                    matched = 0\n                    left = right\n\n                if matched == k:\n                    res.append(left)\n\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Assume the first non-empty line contains the input\n    for raw_line in data.splitlines():\n        line = raw_line.strip()\n        if line:\n            break\n    else:\n        line = \"\"\n\n    # Extract s value\n    s_pattern = r's\\s*=\\s*\"([^\"]*)\"'\n    s_match = re.search(s_pattern, line)\n    s_value = s_match.group(1) if s_match else \"\"\n\n    # Extract words list\n    words_pattern = r'words\\s*=\\s*\\[(.*?)\\]'\n    words_match = re.search(words_pattern, line)\n    words_value = words_match.group(1) if words_match else \"\"\n\n    # Convert string representation of list to Python list\n    if words_value:\n        try:\n            words_list = ast.literal_eval('[' + words_value + ']')\n        except Exception:\n            # Fallback simple split if literal_eval fails\n            words_list = [w.strip().strip('\"').strip(\"'\") for w in words_value.split(',') if w.strip()]\n    else:\n        words_list = []\n\n    sol = Solution()\n    result = sol.findSubstring(s_value, words_list)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for solving the problem: given string s, array words all same length, find starting indices of substrings in s that are concatenation of all words exactly once. Classic LeetCode 30: Substring with Concatenation of All Words. We need to produce pseudo-code step by step.\n\nWe should produce lines: Start, then steps: compute word length, total length, count of words, map of word counts, iterate through s positions, maintain sliding window, etc.\n\nEach line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nWe need to adhere to example: lines start with \"Start\" or \"→\" etc. We must not output real code.\n\nLet's produce pseudo algorithm:\n\nStart // begin\n\n→ Step 1: 计算单词长度 wordLen = length of words[0] // 每个单词的长度\n\n→ Step 2: 计算总长度 concatLen = wordLen * number of words // 需要匹配的子串总长度\n\n→ Decision: 如果 concatLen > length of s? // 若总长度大于字符串长度则无匹配\n\n    Yes → End // 结束\n\n    No → 继续\n\n→ Step 3: 建立字典 targetCount，统计每个单词出现次数 // 记录目标单词频率\n\n→ Step 4: 初始化结果列表 result // 存放起始索引\n\n→ Step 5: 对于每个偏移 offset 从 0 到 wordLen-1 // 处理不同的窗口起点\n\n    → Step 5.1: 初始化滑动窗口左边 left = offset, right = offset\n\n    → Step 5.2: 初始化当前窗口计数 windowCount = 空字典\n\n    → Step 5.3: 初始化已匹配单词数 matched = 0 // 当前窗口内符合计数的单词数\n\n    → Decision: 当 right + wordLen <= s.length? // 继续滑动\n\n        While ...\n\nBut we should present each step as a line. We can use nested indentation: 5.1 etc.\n\nWe can use \"Decision:\" lines for loops or conditions.\n\nBut need to keep each line as a separate line with a single arrow? In example, they used indentation with spaces and arrow lines. For loops, they use Decision with Yes/No. For while loops, we can just use Decision: While condition? Yes → ... No → ...\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: wordLen ← length(words[0]) // 每個單詞長度\n\n→ Step 2: concatLen ← wordLen × length(words) // 所需子串總長度\n\n→ Decision: 如果 concatLen > length(s)? // 若無法匹配\n\n    Yes → End // 結束\n\n    No → 继续\n\n→ Step 3: targetCount ← map of words frequencies // 目標單詞出現次數\n\n→ Step 4: result ← empty list // 存放符合條件的起始索引\n\n→ Decision: 對 offset 在 0 至 wordLen-1? // 針對每個模組化起點\n\n    Yes → \n\n        → Step 5.1: left ← offset; right ← offset // 滑動窗口左右端\n\n        → Step 5.2: windowCount ← empty map // 當前窗口單詞頻率\n\n        → Step 5.3: matched ← 0 // 已匹配的單詞數量\n\n        → Decision: 當 right + wordLen ≤ length(s)? // 繼續滑動窗口\n\n            Yes →\n\n                → Step 6: word ← substring(s, right, right + wordLen) // 從右端取單詞\n\n                → Step 6.1: right ← right + wordLen // 右端向前移動\n\n                → Decision: 是否 word 在 targetCount? // 是否是需要的單詞\n\n                    Yes →\n\n                        → Step 6.2: windowCount[word] ← windowCount[word] + 1\n\n                        → Decision: windowCount[word] ≤ targetCount[word]? // 仍在允許範圍內\n\n                            Yes → matched ← matched + 1\n\n                            No →\n\n                                → Step 6.3: while windowCount[word] > targetCount[word] do\n\n                                    → Step 6.3.1: leftWord ← substring(s, left, left + wordLen) // 左端單詞\n\n                                    → Step 6.3.2: left ← left + wordLen\n\n                                    → Step 6.3.3: windowCount[leftWord] ← windowCount[leftWord] - 1\n\n                                    → Decision: leftWord == word? // 下降的單詞是否是同一個\n\n                                        Yes → matched ← matched - 1\n\n                                        No → // nothing\n\n                    No →\n\n                        → Step 6.4: while left < right do\n\n                            → Step 6.4.1: leftWord ← substring(s, left, left + wordLen)\n\n                            → Step 6.4.2: left ← left + wordLen\n\n                            → Step 6.4.3: windowCount[leftWord] ← windowCount[leftWord] - 1\n\n                            → Decision: leftWord == word? // 如果剛剛移除的是不在 targetCount\n\n                                Yes → // nothing\n\n                                No → // nothing\n\n                → Decision: matched == length(words)? // 完全匹配\n\n                    Yes → result.append(left) // 記錄起始位置\n\n                    No → // nothing\n\n            No → // loop end\n\n    No → // offset loop end\n\n→ End // 程式執行結束\n\nBut maybe some lines need to be split. Ensure each line has arrow or Step.\n\nAlso use \"Decision:\" for loops? In example, they used Decision: if >0? etc. For while loop, can use Decision: while right+... ≤ len? Yes → ... No → End? But we need to end the loop.\n\nBut easier: use a loop indicator: Decision: while right + wordLen ≤ len(s)? ... No → ... That is okay.\n\nAlso after while loop, we need to break? But we can just end the loop.\n\nNeed to produce a concise yet complete pseudo-code.\n\nWe need to ensure that each line ends with // 解釋.\n\nLet's craft final answer.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: wordLen ← length(words[0]) // 每個單詞長度\n→ Step 2: concatLen ← wordLen × length(words) // 需要匹配子串總長度\n→ Decision: 如果 concatLen > length(s)? // 若整體長度超過 s\n    Yes → End // 沒有任何答案，結束\n    No → 继续\n→ Step 3: targetCount ← map frequencies of words // 目標單詞出現頻率\n→ Step 4: result ← empty list // 存放符合條件的起始索引\n→ Decision: 對 offset 在 0 至 wordLen-1? // 每個可能的窗口起點\n    Yes →\n        → Step 5.1: left ← offset; right ← offset // 初始化滑動窗口\n        → Step 5.2: windowCount ← empty map // 當前窗口單詞頻率\n        → Step 5.3: matched ← 0 // 符合目標頻率的單詞數\n        → Decision: while right + wordLen ≤ length(s)? // 直到右端超出範圍\n            Yes →\n                → Step 6: word ← substring(s, right, right + wordLen) // 取右端單詞\n                → Step 6.1: right ← right + wordLen // 右端向前移\n                → Decision: word 是否在 targetCount? // 不是目標單詞\n                    Yes →\n                        → Step 6.2: windowCount[word] ← windowCount[word] + 1\n                        → Decision: windowCount[word] ≤ targetCount[word]? // 在允許範圍內\n                            Yes → matched ← matched + 1\n                            No →\n                                → Step 6.3: while windowCount[word] > targetCount[word] do\n                                    → Step 6.3.1: leftWord ← substring(s, left, left + wordLen) // 左端單詞\n                                    → Step 6.3.2: left ← left + wordLen\n                                    → Step 6.3.3: windowCount[leftWord] ← windowCount[leftWord] - 1\n                                    → Decision: leftWord == word? // 若剛剛移除的單詞是多餘的\n                                        Yes → matched ← matched - 1\n                                        No → // nothing\n                    No →\n                        → Step 6.4: while left < right do // 清空窗口\n                            → Step 6.4.1: leftWord ← substring(s, left, left + wordLen)\n                            → Step 6.4.2: left ← left + wordLen\n                            → Step 6.4.3: windowCount[leftWord] ← windowCount[leftWord] - 1\n                → Decision: matched == length(words)? // 完全匹配\n                    Yes → result.append(left) // 記錄起始索引\n                    No → // nothing\n            No → // 右端已超出範圍，結束本 offset 的迴圈\n    No → // offset 迴圈結束\nEnd // 程式執行結束\n\nCheck formatting: Each line must start with either \"Start\" or \"→\" or \"Decision:\" etc. Must include the explanation after \"//\".\n\nAlso need to ensure no real code, but pseudo only. We used ← and × etc; that's okay.\n\nWe need to keep each line as separate line.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: wordLen ← length(words[0]) // 取得單詞的長度  \n→ Step 2: concatLen ← wordLen × length(words) // 計算所有單詞連接後的總長度  \n→ Decision: 如果 concatLen > length(s)? // 若總長度超過 s 的長度  \n    Yes → End // 沒有可行解，結束程式  \n    No → 继续  \n→ Step 3: targetCount ← map frequencies of words // 建立每個單詞的目標頻率表  \n→ Step 4: result ← empty list // 用於儲存符合條件的起始索引  \n→ Decision: 對 offset 在 0 至 wordLen-1? // 針對每個模組化起點  \n    Yes →  \n        → Step 5.1: left ← offset; right ← offset // 初始化滑動窗口位置  \n        → Step 5.2: windowCount ← empty map // 當前窗口內單詞頻率  \n        → Step 5.3: matched ← 0 // 已符合目標頻率的單詞數量  \n        → Decision: while right + wordLen ≤ length(s)? // 右端未超過 s 的範圍  \n            Yes →  \n                → Step 6: word ← substring(s, right, right + wordLen) // 取右端單詞  \n                → Step 6.1: right ← right + wordLen // 右端往右移動  \n                → Decision: word 是否在 targetCount? // 不是目標單詞  \n                    Yes →  \n                        → Step 6.2: windowCount[word] ← windowCount[word] + 1  \n                        → Decision: windowCount[word] ≤ targetCount[word]? // 在允許範圍內  \n                            Yes → matched ← matched + 1  \n                            No →  \n                                → Step 6.3: while windowCount[word] > targetCount[word] do  \n                                    → Step 6.3.1: leftWord ← substring(s, left, left + wordLen) // 左端單詞  \n                                    → Step 6.3.2: left ← left + wordLen  \n                                    → Step 6.3.3: windowCount[leftWord] ← windowCount[leftWord] - 1  \n                                    → Decision: leftWord == word? // 若剛剛移除的單詞是多餘的  \n                                        Yes → matched ← matched - 1  \n                                        No → // nothing  \n                    No →  \n                        → Step 6.4: while left < right do // 清空窗口直到右端  \n                            → Step 6.4.1: leftWord ← substring(s, left, left + wordLen)  \n                            → Step 6.4.2: left ← left + wordLen  \n                            → Step 6.4.3: windowCount[leftWord] ← windowCount[leftWord] - 1  \n                → Decision: matched == length(words)? // 是否已完整匹配所有單詞  \n                    Yes → result.append(left) // 記錄起始索引  \n                    No → // nothing  \n            No → // 右端已超出範圍，結束本 offset 的迴圈  \n    No → // offset 迴圈結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def findMinStep(self, board: str, hand: str) -> int:\n        colors = \"RYBGW\"\n\n        # Count balls in hand\n        hand_counts = [0] * 5\n        for ch in hand:\n            hand_counts[colors.index(ch)] += 1\n        hand_counts = tuple(hand_counts)\n\n        INF = 10 ** 9\n        memo = {}\n\n        def collapse(s: str) -> str:\n            \"\"\"Remove all groups of 3 or more same-colored balls repeatedly.\"\"\"\n            while True:\n                n = len(s)\n                i = 0\n                removed = False\n                parts = []\n                while i < n:\n                    j = i\n                    while j < n and s[j] == s[i]:\n                        j += 1\n                    if j - i >= 3:\n                        removed = True\n                        # skip this group\n                    else:\n                        parts.append(s[i:j])\n                    i = j\n                if not removed:\n                    return ''.join(parts)\n                s = ''.join(parts)\n\n        def dfs(cur_board: str, cur_hand: tuple) -> int:\n            if not cur_board:\n                return 0\n            key = (cur_board, cur_hand)\n            if key in memo:\n                return memo[key]\n            best = INF\n            # try inserting each color from hand\n            for idx, cnt in enumerate(cur_hand):\n                if cnt == 0:\n                    continue\n                c = colors[idx]\n                # try every insertion position\n                for i in range(len(cur_board) + 1):\n                    # skip positions that cannot create a group of 3\n                    left_count = 0\n                    j = i - 1\n                    while j >= 0 and cur_board[j] == c:\n                        left_count += 1\n                        j -= 1\n                    right_count = 0\n                    j = i\n                    while j < len(cur_board) and cur_board[j] == c:\n                        right_count += 1\n                        j += 1\n                    if left_count + right_count + 1 < 3:\n                        continue\n                    new_board = cur_board[:i] + c + cur_board[i:]\n                    new_board = collapse(new_board)\n                    new_hand = list(cur_hand)\n                    new_hand[idx] -= 1\n                    res = dfs(new_board, tuple(new_hand))\n                    if res != INF:\n                        best = min(best, res + 1)\n            memo[key] = best\n            return best\n\n        ans = dfs(board, hand_counts)\n        return -1 if ans == INF else ans\n\ndef parse_input(data: str):\n    \"\"\"Parse board and hand from the input string.\"\"\"\n    # Try to match pattern board = \"xxx\", hand = \"yyy\"\n    m = re.search(r'board\\s*=\\s*\"([^\"]*)\"\\s*,\\s*hand\\s*=\\s*\"([^\"]*)\"', data)\n    if m:\n        return m.group(1), m.group(2)\n    # Fallback: first non-empty line is board, second is hand\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    # As a last resort, split by comma\n    parts = [p.strip() for p in data.split(',')]\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    raise ValueError(\"Unable to parse input\")\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    board_str, hand_str = parse_input(data)\n    sol = Solution()\n    result = sol.findMinStep(board_str, hand_str)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines for algorithm to solve Zuma-like puzzle: given board string, hand string, return min inserts or -1. This is classic Leetcode 488 Zuma Game. Approach: DFS with memoization, state: board string + hand counts. At each recursion, try to insert ball of each color that exists in hand into board at appropriate positions to merge groups. Use removal logic: after insertion, repeatedly remove consecutive groups of >=3.\n\nWe need virtual code lines step-by-step with explanation, not actual code. Use arrow syntax. We need to produce a structured pseudocode that explains algorithm.\n\nWe need to cover: parse hand counts; DFS function; base case; recursion; removal; caching; result min; if impossible return -1.\n\nWe will produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化手牌顏色計數 // 將手牌字串轉換為顏色-數量映射\n\nThen DFS. Use Decision: etc.\n\nLet's produce a sequence maybe 40-50 lines.\n\nLet's craft:\n\n- Step 1: build handCount dict\n- Step 2: define dfs(board, handCount) returns min inserts or INF\n- Decision: If board empty → return 0\n- Decision: If no hand left → return INF\n- Memoization: key = board + handCounts; if key in memo → return memo[key]\n- For each color in handCount with >0:\n   - For each position i from 0 to len(board):\n      - Determine if insertion at i can create a group of >=3.\n      - Insert char color at i\n      - Reduce handCount[color]\n      - Call collapse(board after insertion)\n      - Recursively call dfs(newBoard, newHandCount)\n      - If result != INF → update min\n      - Restore handCount[color]\n- After loop, store memo[key] = minVal\n- Return minVal\n\nCollapse function:\n- Loop while True:\n   - Scan board for runs of same color length >=3\n   - If none found break\n   - Remove each run\n   - Continue\n\nReturn INF sentinel.\n\nFinally, call dfs(initialBoard, handCount). If result == INF → -1 else result.\n\nAlso handle INF sentinel like large number.\n\nLet's produce pseudocode accordingly.\n\nMake sure each line has \"虛擬碼步驟 // 解釋\".\n\nLet's create step numbering maybe not needed but keep arrow style.\n\nWe'll use \"Start\" and \"End\". Use \"Decision:\" with Yes/No.\n\nUse indentation maybe with spaces or tab? Format not strict but use arrows.\n\nWe'll include decisions for loops.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立手牌顏色計數字典 handCount ← CountColors(hand) // 將手牌字串轉為顏色→數量映射  \n\n→ Step 2: 定義遞迴函式 dfs(board, handCount) → int // 回傳清空 board 所需最少插入數，無法則回傳 INF  \n\n → Decision: 如果 board 為空? // 所有球已被清除  \n  Yes → Return 0 // 不需要再插入任何球  \n  No → Decision: 如果 handCount 所有數量為 0? // 手牌已用完  \n   Yes → Return INF // 無法清空，標記為無解  \n   No → Decision: 如果 (board, handCount) 已存在於 memo? // 先前已計算過  \n    Yes → Return memo[(board, handCount)] // 直接回傳緩存結果  \n    No → 進入主演算法  \n\n    → Step 3: 初始化 minInsert ← INF // 儲存目前找到的最小插入數  \n\n    → Loop: 對於每一個顏色 color 使 handCount[color] > 0 // 嘗試使用此顏色  \n     → Step 4: 對於每個位置 pos 從 0 到 len(board) // 在此位置插入球  \n      → Step 5: 插入 color 至 pos 並得到新串 newBoard ← board[:pos] + color + board[pos:]  \n      → Step 6: 降低手牌計數 handCount[color] ← handCount[color] - 1  \n      → Step 7: 呼叫 collapse(newBoard) 以移除所有三連以上組  \n       → Step 8: result ← dfs(newBoard, handCount) // 進一步遞迴  \n       → Decision: 如果 result ≠ INF? // 有解  \n        Yes → minInsert ← min(minInsert, result + 1) // 加上本次插入  \n        No → 什麼也不做 // 這條路徑無法清空  \n      → Step 9: 回復手牌計數 handCount[color] ← handCount[color] + 1  \n     → End Loop  \n    → Step 10: memo[(board, handCount)] ← minInsert // 存入快取  \n    → Return minInsert  \n\n → Step 11: 定義 collapse(board) → string // 反覆移除 3+ 同色連續群組  \n   → Loop:  \n    → Step 12: 設 flag ← False // 是否有群組被移除  \n    → Step 13: 建立 newBoard ← \"\" // 新的字串  \n    → Step 14: index ← 0 // 指標  \n    → Loop: 當 index < len(board)? // 逐段掃描  \n      → Step 15: 計算同色區塊長度 runLen 與顏色 color  \n      → Decision: 如果 runLen ≥ 3? // 有可移除群組  \n       Yes → flag ← True; index ← index + runLen // 跳過該群組  \n       No → newBoard ← newBoard + board[index:index+runLen]; index ← index + runLen // 保留  \n     → End Loop  \n    → Decision: 如果 flag? // 有移除  \n     Yes → board ← newBoard; 重新進入 Loop // 再次檢查  \n     No → Return board // 無更多群組，返回最終字串  \n\n→ Step 12: 呼叫 dfs(initialBoard, handCount) 並存結果 ans  \n→ Decision: 如果 ans = INF? // 沒有解  \n  Yes → Return -1 // 不能清空  \n  No → Return ans // 最小插入數  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Delete Operation for Two Strings",
      "source_file": "Leetcode/leetcode583.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "word1 = \"sea\", word2 = \"eat\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '7'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '7'"
        },
        {
          "example_index": 1,
          "input": "word1 = \"leetcode\", word2 = \"etco\"",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '8'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '8'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef min_deletions_to_equal(word1: str, word2: str) -> int:\n    \"\"\"Return the minimum number of deletions required to make word1 and word2 equal.\"\"\"\n    m, n = len(word1), len(word2)\n    # dp[i][j] = LCS length of word1[:i] and word2[:j]\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    lcs = dp[m][n]\n    return m + n - 2 * lcs\n\n\ndef parse_input(text: str) -> tuple[str, str]:\n    \"\"\"Extract the first two words (alphabetic strings) from the input.\"\"\"\n    words = re.findall(r'[A-Za-z]+', text)\n    if len(words) < 2:\n        raise ValueError(\"Input must contain at least two words.\")\n    return words[0], words[1]\n\n\ndef main() -> None:\n    raw = sys.stdin.read()\n    word1, word2 = parse_input(raw)\n    result = min_deletions_to_equal(word1, word2)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for minimal deletions to make two strings equal. Equivalent to computing longest common subsequence (LCS). Minimum deletions = len(word1)+len(word2)-2*LCS(word1,word2). So algorithm: compute LCS length via DP. Steps: input strings, compute DP table, get LCS, compute steps.\n\nWe need to produce step-by-step virtual code with arrows and explanations, following the format: \"虛擬碼步驟 // 解釋\". Each line separate. Use Start, End, Decision. We must avoid actual code, use pseudocode-like structure.\n\nWe'll produce:\n\nStart // Start\n→ Step 1: Read word1 and word2 // Input strings\n→ Step 2: Let m = length(word1), n = length(word2) // Get lengths\n→ Step 3: Initialize 2D array dp of size (m+1) x (n+1) with zeros // DP table\n→ Step 4: For i from 1 to m\n    → For j from 1 to n\n        → Decision: If word1[i-1] == word2[j-1]?\n            Yes → dp[i][j] = dp[i-1][j-1] + 1 // Extend LCS\n            No → dp[i][j] = max(dp[i-1][j], dp[i][j-1]) // Take best of excluding one char\n→ Step 5: Let lcs = dp[m][n] // LCS length\n→ Step 6: Let deletions = m + n - 2 * lcs // Minimum steps\n→ Step 7: Output deletions // Return result\nEnd // End\n\nWe need to format each line accordingly. For nested loops and decision we indent? The format shows indentation with spaces. We'll keep indentation with 4 spaces maybe. The arrow after Decision lines: \"Yes →\" etc.\n\nWe must provide each line with the arrow. For the nested loops, we need to start a block: \"→ Step 4: For i from 1 to m\" then next line \"    → Step 4.1: For j from 1 to n\" etc. Or \"→ Step 4: For i from 1 to m\" then \"    → Step 4.1: For j from 1 to n\". But the format may require indentation as spaces. In example, they indent with 4 spaces before inner lines. We'll replicate.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 word1 與 word2 // 取得兩個字串輸入  \n→ Step 2: 設定 m = length(word1), n = length(word2) // 取得兩字串長度  \n→ Step 3: 初始化 2D 陣列 dp[m+1][n+1] 為 0 // 用於儲存 LCS 長度  \n→ Step 4: For i 從 1 到 m  \n  → Step 4.1: For j 從 1 到 n  \n    → Decision: word1[i-1] == word2[j-1]? // 比較當前字元  \n      Yes → dp[i][j] = dp[i-1][j-1] + 1 // 字元相同，擴增 LCS  \n      No  → dp[i][j] = max(dp[i-1][j], dp[i][j-1]) // 字元不同，取較大子問題答案  \n→ Step 5: 設定 lcs = dp[m][n] // LCS 長度  \n→ Step 6: 計算 deletions = m + n - 2 * lcs // 最小刪除步驟  \n→ Step 7: 輸出 deletions // 回傳結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum IV",
      "source_file": "Leetcode/leetcode377.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpd5q_kl08.py\", line 27, in <module>\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef combination_sum_4(nums, target):\n    # dp[i] 表示總和為 i 的排列數\n    dp = [0] * (target + 1)\n    dp[0] = 1  # 只有空序列可以得到總和 0\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n    return dp[target]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，假設格式為 \"nums = [...], target = ...\"\n    parts = [p.strip() for p in data.split(',')]\n    nums_part = parts[0]\n    target_part = parts[1]\n\n    # 取出列表字串並安全評估\n    nums_str = nums_part.split('=', 1)[1].strip()\n    nums = ast.literal_eval(nums_str)\n\n    # 取出目標值\n    target_str = target_part.split('=', 1)[1].strip()\n    target = int(target_str)\n\n    result = combination_sum_4(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: count combinations of distinct integers that sum to target. Since distinct numbers, but combinations order matters? Problem: \"number of possible combinations that add up to target\". Usually combination sum problem variations. If order matters, it's number of sequences. But typical LeetCode \"Combination Sum IV\" counts permutations. But with distinct integers maybe no repetition? The array distinct; each integer can be used unlimited times? Not specified. Probably each integer can be used unlimited times? But if distinct array, each integer can be used unlimited times. Count number of combinations (order matters). We can use DP: dp[0]=1, for i from 1 to target: for num in nums: if num<=i: dp[i] += dp[i-num]. Output dp[target].\n\nWe need virtual code. Start, Step: input array nums, target. Decision? Not needed. We will iterate.\n\nReturn dp[target]. End.\n\nLet's produce lines with explanation. Use arrow for steps. Use Decision: maybe none.\n\nWe will use \"Step 1: Initialize dp array of size target+1 with zeros\" etc. Let's output accordingly.\n\nAlso need to mention that nums distinct.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 nums 與目標值 target // 取得需要計算的資料  \n→ Step 2: 建立長度為 target+1 的 dp 陣列，並將 dp[0] 設為 1 // dp[i] 代表總和為 i 的排列數  \n→ Decision: 是否為 target 0? // 若 target 為 0，直接返回 1  \n    Yes → Step 3: 輸出 1 // 只有空序列可達 0  \n    No  →  \n→ Step 4: 從 1 到 target 逐一計算 dp[i]  \n    → Loop i in 1..target  \n        → Loop num in nums  \n            → Decision: num <= i? // 只有能加入的數字才計算  \n                Yes → dp[i] += dp[i-num] // 加入 num 後剩餘部分的排列數  \n                No  → // 跳過此 num  \n→ Step 5: 輸出 dp[target] // 結果即為總組合數  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left, right):\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left, right):\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left, right):\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    obj = None\n    results = []\n\n    for line in data:\n        line = line.strip()\n        if not line or line.endswith(';'):\n            line = line.rstrip(';')\n        if line.startswith('RangeModule'):\n            # initialise the object\n            obj = RangeModule()\n            results.append(None)\n        elif line.startswith('rangeModule.'):\n            # method call\n            _, rest = line.split('.', 1)\n            method, rest = rest.split('(', 1)\n            args_str = rest.rstrip(');')\n            args = [int(a.strip()) for a in args_str.split(',')] if args_str else []\n            if method == 'addRange' or method == 'removeRange':\n                getattr(obj, method)(*args)\n                results.append(None)\n            elif method == 'queryRange':\n                res = getattr(obj, method)(*args)\n                results.append(res)\n    # output results in JSON format (null, true, false)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code lines for designing a RangeModule data structure. Probably using an interval tree or sorted list of intervals. We need step-by-step pseudocode, with explanation comments. Each line: virtual code step + space + // explanation. Use arrows. Let's design: Start, maintain a list of non-overlapping intervals. addRange merges intervals; queryRange checks coverage; removeRange splits.\n\nWe'll produce pseudo:\n\nStart\n→ Init: intervals = empty list // list of [l,r)\n→ Method addRange(left,right)\n   → Merge: find insert position, iterate over intervals overlapping, merge to new interval, remove overlapped, insert merged\n→ Method queryRange(left,right)\n   → Find interval that could cover left, check coverage\n→ Method removeRange(left,right)\n   → For each overlapping interval, split into left part if any, right part if any, remove original, insert parts\nEnd\n\nBut we need per-line. Use Decision nodes etc. Provide each step.\n\nLet's structure.\n\nStart // Program start\n→ Initialize intervals list // holds disjoint, sorted intervals\n→ Define method addRange(left,right) // add interval\n    → Find index where left <= interval.right and right >= interval.left\n    → If no overlapping, insert and return\n    → Else, merge all overlapping intervals with new [left,right]\n    → Remove overlapped intervals\n    → Insert merged interval\n→ Define method queryRange(left,right)\n    → Find interval with start <= left and end >= right\n    → If found return true else false\n→ Define method removeRange(left,right)\n    → Find overlapping intervals\n    → For each, remove it\n    → If interval.start < left, insert [interval.start, left)\n    → If interval.end > right, insert [right, interval.end)\n→ End // end\n\nBut we must include decisions and arrows. Let's produce with indentation maybe.\n\nI'll produce:\n\nStart // 程式開始執行\n→ Init: intervals ← empty list // 儲存已追蹤的不重疊區間\n→ Define Function addRange(left, right) // 新增區間\n    → Decision: 有無重疊區間? // 檢查 intervals 是否與 [left,right) 有重疊\n        Yes → Step: 合併所有重疊區間並加入 [left,right) // 把重疊的區間合併成一個新的區間\n        No  → Step: 插入 [left, right) 至正確位置 // 直接將新區間插入排序列表\n    → End Function\n→ Define Function queryRange(left, right) // 查詢區間是否全部被追蹤\n    → Step: 找到最接近 left 的區間 // 在 intervals 中尋找可覆蓋 left 的區間\n    → Decision: 区间起点 <= left 且终点 >= right? // 檢查該區間是否覆蓋整個 [left,right)\n        Yes → Return true // 完全覆蓋，回傳真\n        No  → Return false // 未完全覆蓋，回傳假\n    → End Function\n→ Define Function removeRange(left, right) // 移除區間\n    → Step: 取得所有與 [left,right) 重疊的區間 // 找出 intervals 中所有重疊的區間\n    → For Each interval in 重疊區間:\n        → Decision: interval.start < left? // 有左側剩餘區間\n            Yes → Step: 插入 [interval.start, left) // 保留左側未被移除的區間\n        → Decision: interval.end > right? // 有右側剩餘區間\n            Yes → Step: 插入 [right, interval.end) // 保留右側未被移除的區間\n        → Step: 從 intervals 刪除 interval // 移除原始重疊區間\n    → End Function\nEnd // 程式結束\n\nWe need to ensure each line ends with // explanation. Provide arrow and decision lines. Provide \"Start\" and \"End\". For decisions, use \"Decision:\" lines. Provide indentation with arrow. Ensure each line is separate.\n\nLet's output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Init: intervals ← empty list // 儲存已追蹤的不重疊區間\n→ Define Function addRange(left, right) // 新增區間\n    → Decision: intervals 有與 [left, right) 重疊的區間? // 檢查是否存在重疊\n        Yes → Step: 合併所有重疊區間與 [left, right) 成一個新的區間 newL,newR // 合併成最大覆蓋範圍\n        No  → Step: 插入 [left, right) 至 intervals 正確位置 // 直接加入排序列表\n    → End Function\n→ Define Function queryRange(left, right) // 查詢區間是否完全被追蹤\n    → Step: 在 intervals 中尋找最接近 left 的區間 idx // 找出可能覆蓋 left 的區間\n    → Decision: intervals[idx].start ≤ left 且 intervals[idx].end ≥ right? // 檢查是否覆蓋整個 [left, right)\n        Yes → Return true // 完全覆蓋，回傳真\n        No  → Return false // 未完全覆蓋，回傳假\n    → End Function\n→ Define Function removeRange(left, right) // 移除區間\n    → Step: 取得所有與 [left, right) 重疊的區間 list // 找出 intervals 中所有重疊區間\n    → For Each interval in list:\n        → Decision: interval.start < left? // 是否存在左側剩餘區間\n            Yes → Step: 插入 [interval.start, left) 至 intervals // 保留左側未被移除的區間\n        → Decision: interval.end > right? // 是否存在右側剩餘區間\n            Yes → Step: 插入 [right, interval.end) 至 intervals // 保留右側未被移除的區間\n        → Step: 從 intervals 刪除 interval // 移除原始重疊區間\n    → End Function\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp55f_f16b.py\", line 71, in <module>\n    commands = ast.literal_eval(data[0])\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n                                                                                                                                                ^\nSyntaxError: unexpected character after line continuation character"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        # 最大容量\n        self.k = k\n        # 循環緩衝區\n        self.buf = [0] * k\n        # 指向前端元素的索引\n        self.head = 0\n        # 現有元素個數\n        self.count = 0\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        # 循環向前移動 head\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        # 循環向後移動 head\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入\n    commands = ast.literal_eval(data[0])\n    arguments = ast.literal_eval(data[1])\n\n    results = []\n    obj = None\n\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"MyCircularDeque\":\n            # 建構子，arguments 為 [k]\n            obj = MyCircularDeque(args[0])\n            results.append(None)\n        elif cmd == \"insertFront\":\n            results.append(obj.insertFront(args[0]))\n        elif cmd == \"insertLast\":\n            results.append(obj.insertLast(args[0]))\n        elif cmd == \"deleteFront\":\n            results.append(obj.deleteFront())\n        elif cmd == \"deleteLast\":\n            results.append(obj.deleteLast())\n        elif cmd == \"getFront\":\n            results.append(obj.getFront())\n        elif cmd == \"getRear\":\n            results.append(obj.getRear())\n        elif cmd == \"isEmpty\":\n            results.append(obj.isEmpty())\n        elif cmd == \"isFull\":\n            results.append(obj.isFull())\n        else:\n            # 任何未知指令\n            results.append(None)\n\n    # 輸出結果，None 會轉為 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. Should be sequential. Use Start, End, Decision. Provide virtual steps for class definition and methods. Use arrow notation. We'll outline initialization, insert front/back, delete front/back, get front/rear, isEmpty, isFull. Need to use decisions for full/empty checks. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCircularDeque 類別 // 建立類別框架\n    → Step 1.1: 建立成員變數 head, tail, size, capacity, data[capacity] // 用於循環佇列的指標與儲存空間\n→ Step 2: MyCircularDeque(int k) // 建構子，設定最大容量\n    → Step 2.1: capacity ← k\n    → Step 2.2: head ← 0\n    → Step 2.3: tail ← 0\n    → Step 2.4: size ← 0\n    → Step 2.5: data ← new int[capacity] // 初始化儲存陣列\n→ Decision: 是否已滿? // 在 insert 前先檢查容量\n    Yes → Step 3: 返回 false // 無法新增，已滿\n    No  → Step 4: data[head] ← value // 將值放在前端\n        → Step 5: head ← (head - 1 + capacity) mod capacity // 循環向前移動 head\n        → Step 6: size ← size + 1\n        → Step 7: 返回 true // 成功插入\n→ Decision: 是否已滿? // 在 insertLast 前先檢查容量\n    Yes → Step 8: 返回 false // 無法新增，已滿\n    No  → Step 9: data[tail] ← value // 將值放在尾端\n        → Step 10: tail ← (tail + 1) mod capacity // 循環向後移動 tail\n        → Step 11: size ← size + 1\n        → Step 12: 返回 true // 成功插入\n→ Decision: 是否為空? // 在 deleteFront 前先檢查是否有元素\n    Yes → Step 13: 返回 false // 無法刪除，已空\n    No  → Step 14: head ← (head + 1) mod capacity // 循環向後移動 head\n        → Step 15: size ← size - 1\n        → Step 16: 返回 true // 成功刪除\n→ Decision: 是否為空? // 在 deleteLast 前先檢查是否有元素\n    Yes → Step 17: 返回 false // 無法刪除，已空\n    No  → Step 18: tail ← (tail - 1 + capacity) mod capacity // 循環向前移動 tail\n        → Step 19: size ← size - 1\n        → Step 20: 返回 true // 成功刪除\n→ Decision: 是否為空? // 在 getFront 前先檢查是否有元素\n    Yes → Step 21: 返回 -1 // 佇列為空，無前端值\n    No  → Step 22: index ← (head + 1) mod capacity // 計算實際前端位置\n        → Step 23: 返回 data[index] // 取得前端值\n→ Decision: 是否為空? // 在 getRear 前先檢查是否有元素\n    Yes → Step 24: 返回 -1 // 佇列為空，無尾端值\n    No  → Step 25: index ← (tail - 1 + capacity) mod capacity // 計算實際尾端位置\n        → Step 26: 返回 data[index] // 取得尾端值\n→ Decision: size == 0? // 判斷是否為空\n    Yes → Step 27: 返回 true // 空\n    No  → Step 28: 返回 false // 不空\n→ Decision: size == capacity? // 判斷是否為滿\n    Yes → Step 29: 返回 true // 滿\n    No  → Step 30: 返回 false // 未滿\nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef find_duplicate(paths):\n    \"\"\"找出所有重複內容的檔案路徑，並以列表形式回傳。\"\"\"\n    content_map = defaultdict(list)\n\n    for entry in paths:\n        parts = entry.split()\n        root = parts[0]                     # 目錄路徑\n        for file_info in parts[1:]:\n            name, content = file_info.split('(')\n            content = content[:-1]          # 去掉尾端 ')'\n            full_path = f\"{root}/{name}\"\n            content_map[content].append(full_path)\n\n    # 只保留重複 (至少兩個) 的組\n    return [files for files in content_map.values() if len(files) > 1]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n\n    # 若輸入包含 \"paths =\"，先切除關鍵字\n    if raw_input.startswith(\"paths\"):\n        _, raw_input = raw_input.split(\"=\", 1)\n        raw_input = raw_input.strip()\n\n    # 轉成 Python 物件（安全）\n    try:\n        paths = ast.literal_eval(raw_input)\n    except Exception:\n        # 若解析失敗，直接輸出空列表\n        print([])\n        sys.exit(0)\n\n    result = find_duplicate(paths)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, with arrow and explanation. It should represent algorithm for finding duplicate files from directory info strings. Provide steps: parse each string, extract directory path and file name with content, group by content, output groups with size >=2.\n\nWe must produce virtual code steps, not actual code. Use Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Probably we need to use \"→\" as in example. We'll write like:\n\nStart // 開始執行\n→ Step 1: 初始化 map contentToPaths ← empty // 建立內容到路徑的映射\n→ For each dirInfo in paths // 遍歷輸入的每一條目\n→ Decision: 是否包含空格? // 確認字符串格式\n    Yes → ...\nBut better: parse each string into directory and files: split by space. The first part is directory path, rest are file entries.\n\nWe can produce pseudocode:\n\n→ For each dirInfo in paths\n    → Split dirInfo by space into parts\n    → Set dirPath = parts[0]\n    → For each fileEntry in parts[1..]\n        → Parse fileName and content: find '(' and ')'\n        → fileName = substring before '('\n        → content = substring inside parentheses\n        → fullPath = dirPath + '/' + fileName\n        → Append fullPath to contentToPaths[content]\n→ After loop, initialize result ← empty list\n→ For each entry in contentToPaths\n    → If length(entry.value) >= 2\n        → Append entry.value to result\n→ End // 結束\n\nWe should use Decision blocks for checking conditions.\n\nAlso we can show grouping steps.\n\nUse arrow: \"→\" before each step, and indentation for decisions.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 contentToPaths ← 空集合 // 用來存儲相同內容對應的檔案路徑  \n→ For each dirInfo in paths // 逐一處理輸入的每個目錄資訊  \n  → Step 2: 將 dirInfo 以空格拆分為 parts // 取得目錄路徑與檔案資訊  \n  → Decision: parts 是否至少有兩個元素? // 檢查是否有檔案存在  \n    Yes → Step 3: dirPath ← parts[0] // 目錄完整路徑  \n    No  → Step 4: 繼續處理下一個 dirInfo // 此目錄無檔案，略過  \n      ←  \n              \n  → For each fileEntry in parts[1..] // 逐個處理該目錄下的檔案  \n    → Decision: fileEntry 是否含有 '('? // 確認格式正確  \n      Yes → Step 5: fileName ← substring before '('"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[1]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[1]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[9,10]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[9, 10]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[10,9,5]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[10, 9, 5]'"
        }
      ],
      "generated_code": "import os\nimport re\n\ndef rand7() -> int:\n    \"\"\"\n    產生 1~7 的均勻隨機數。\n    使用 os.urandom 產生一個隨機字節，若字節值小於 245\n    則可用作為均勻分布；否則重試以消除取餘數的偏差。\n    \"\"\"\n    while True:\n        byte = os.urandom(1)[0]\n        if byte < 245:  # 245 = 7 * 35\n            return byte % 7 + 1\n\ndef rand10() -> int:\n    \"\"\"\n    使用 rand7() 產生 1~10 的均勻隨機數。\n    兩次呼叫 rand7() 產生 1~49 的數，若大於 40 則捨棄並重試。\n    \"\"\"\n    while True:\n        # 兩次 rand7() 組合得到 1~49\n        num = (rand7() - 1) * 7 + rand7()\n        if num <= 40:\n            return 1 + (num - 1) % 10\n\ndef main() -> None:\n    \"\"\"\n    主程式：從標準輸入讀取測試用例 n，呼叫 rand10() n 次，\n    並將結果以列表形式輸出到標準輸出。\n    \"\"\"\n    data = os.sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入字串中擷取第一個整數\n    match = re.search(r'(\\d+)', data)\n    if not match:\n        return\n    n = int(match.group(1))\n\n    results = [rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for rand10() using rand7(). Classic method: use two rand7 to get 1-49. If >40, reject; else map to 1-10 via (x-1)%10 +1. So pseudocode: Start, Step 1: repeat loop, generate x = (rand7()-1)*7 + rand7(); if x > 40 continue; else return (x-1)%10+1; End. Also we may need to call rand10() n times? The requirement: Each test case will have one internal argument n, number of times rand10() will be called. But we just implement function. So the virtual code for calling rand10 n times maybe separate. But we just need to implement rand10().\n\nWe'll output each line with explanation. Use arrows.\n\nLet's produce: \nStart // 程式開始執行\n→ Step 1: 定義函式 rand10() // 建立函式\n→ Loop:  // 重複直到得到有效結果\n    → Step 2: 產生 x = (rand7()-1)*7 + rand7() // 兩次 rand7() 組合得到 1-49\n    → Decision: 如果 x > 40? // 40 為最大的可接受值，對應 40 結果\n        Yes → Continue // 超過 40 時捨棄並重新生成\n        No → Step 3: return (x-1)%10 + 1 // 將 1-40 映射到 1-10\n→ End // 函式結束\n\nWe also might need to show for loop of n times: but that's not part of function.\n\nBut maybe we need to show test harness: for i in 1..n: rand10().\n\nLet's produce separate part: Main: Start // 主程序\n→ Step 1: 讀取 n // 取得測試次數\n→ Loop i=1 to n:\n    → Step 2: rand10() // 呼叫 rand10()\n→ End // 完成\n\nLet's produce virtual code accordingly.\n\nMake sure to use arrow for decision: \"Decision:\" lines with Yes →, No →.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 rand10() // 建立產生 1-10 隨機數的函式  \n→ Loop // 重複產生直到得到有效值  \n  → Step 2: 產生 x = (rand7()-1)*7 + rand7() // 兩次 rand7() 組合得到 1-49  \n  → Decision: x > 40? // 40 是能完整映射到 1-10 的最大值  \n    Yes → Continue // 超過 40 時捨棄並重新產生  \n    No  → Step 3: return (x-1)%10 + 1 // 將 1-40 映射到 1-10，返回結果  \n→ End // rand10() 函式結束  \n\n// 測試主程序（每個測試用例會呼叫 rand10() n 次）  \nStart // 主程序開始  \n→ Step 1: 讀取 n // 取得要呼叫 rand10() 的次數  \n→ Loop i = 1 to n  \n  → Step 2: rand10() // 呼叫 rand10() 取得一個隨機數  \n→ End // 主程序結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0gg0vung.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmp0gg0vung.py\", line 16, in main\n    special = ast.literal_eval(special_match.group(1))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[3,0,5]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpj5fy9d6k.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpj5fy9d6k.py\", line 16, in main\n    special = ast.literal_eval(special_match.group(1))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,4]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom functools import lru_cache\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 用正則表達式取出三個列表\n    price_match = re.search(r'price\\s*=\\s*(\\[.*?\\])', data)\n    special_match = re.search(r'special\\s*=\\s*(\\[.*?\\])', data)\n    needs_match = re.search(r'needs\\s*=\\s*(\\[.*?\\])', data)\n    if not (price_match and special_match and needs_match):\n        return\n\n    price = ast.literal_eval(price_match.group(1))\n    special = ast.literal_eval(special_match.group(1))\n    needs = ast.literal_eval(needs_match.group(1))\n\n    n = len(price)\n    memo = {}\n\n    def dfs(curr_needs):\n        key = tuple(curr_needs)\n        if key in memo:\n            return memo[key]\n        # 基本價格：不使用優惠，直接購買\n        res = sum(curr_needs[i] * price[i] for i in range(n))\n        # 嘗試每個優惠\n        for offer in special:\n            temp = []\n            for i in range(n):\n                if offer[i] > curr_needs[i]:\n                    break\n                temp.append(curr_needs[i] - offer[i])\n            else:\n                # 所有項目都可以使用此優惠\n                res = min(res, offer[-1] + dfs(temp))\n        memo[key] = res\n        return res\n\n    answer = dfs(needs)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: compute minimal cost to buy specified quantities with special offers, no overbuy. This is typical \"Shopping Offers\" LeetCode problem. We'll produce algorithm: DFS with memoization using needs state as tuple. For each state, compute min(cost without special) = sum(needs[i]*price[i]). Then try each special: if special can be applied (needs >= special items counts), compute cost = special_price + dfs(new_needs). Keep min. Memoize. Also we can prune using DP. We output pseudocode lines with arrows.\n\nWe need to output line by line with arrow, start, decision, etc.\n\nWe must provide brief explanation after each line.\n\nLet's produce step-by-step. We'll start with Start, then define function minCost(need). Use recursion, memo. Use array special, price. For each state compute base cost, loop offers, decide if applicable, compute new state, recursive call, update min. Return min. Then in main: call minCost(needs) return.\n\nWe need to show loops, decisions, recursion.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ 定義函式 MinCost(need) // 取得目前需求量的最小購買價格  \n → Decision: 是否已經在 Memo 中？ // 檢查是否已計算過此需求組合  \n  Yes → Return Memo[need] // 直接回傳記憶體中的結果  \n  No  → // 尚未計算，先計算不使用優惠的成本  \n   Step: base = Σ need[i] * price[i] // 基本價格，單品購買  \n   best = base // 初始化最小價格為基礎價格  \n   → Loop for each offer in special // 嘗試每一個優惠套裝  \n    Decision: 是否可以使用此優惠？ // 檢查需求量是否足夠購買此套裝  \n     Yes → // 套裝可用  \n      Step: new_need[i] = need[i] - offer[i] for all i // 更新需求量  \n      Step: cost = offer[n] + MinCost(new_need) // 套裝價格 + 其餘需求最小成本  \n      Step: best = min(best, cost) // 取較小的價格  \n     No  → // 套裝不可用，跳過  \n    → End Loop // 完成所有優惠嘗試  \n   → Memo[need] = best // 存入記憶體  \n   → Return best // 回傳此需求量的最小價格  \n→ Step: ans = MinCost(needs) // 以給定需求量開始計算  \n→ End // 程式執行結束，答案已在 ans 中。"
    },
    {
      "title": "Rotate Function",
      "source_file": "Leetcode/leetcode396.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '26'\nGot (Norm):      '34'\n--- (Raw) ---\nRaw Expected: '26'\nRaw Got:      '34'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxRotateFunction(self, A):\n        n = len(A)\n        if n == 0:\n            return 0\n        total = sum(A)\n        # Initial rotation function F(0)\n        F = sum(i * num for i, num in enumerate(A))\n        max_val = F\n        # Iterate through k = 1 to n-1\n        for k in range(1, n):\n            # Update F(k) based on F(k-1)\n            F = F + total - n * A[k - 1]\n            if F > max_val:\n                max_val = F\n        return max_val\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Remove leading variable assignment if present\n    if data.startswith('nums'):\n        idx = data.find('[')\n        if idx != -1:\n            data = data[idx:]\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        nums = []\n    result = Solution().maxRotateFunction(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step explanation for algorithm: find max rotation function. Standard approach: compute initial F(0), then iterative update: F(k) = F(k-1) + sum(nums) - n * arrk-1[0]. We can compute sum and initial. Complexity O(n). Provide virtual steps.\n\nWe need to output each line with `虛擬碼步驟 // 解釋/說明`. Use arrows. Ensure Start and End.\n\nLet's produce.\n\nSteps:\n\nStart\n\n→ Step 1: 計算總和 sum = sum(nums) // 求數組所有元素總和\n\n→ Step 2: 計算初始旋轉函數 F = 0 // 初始值 F(0)\n\n→ Step 3: 計算初始 F(0) 迴圈 i 0..n-1: F += i * nums[i] // 根據公式計算 F(0)\n\n→ Step 4: 設 maxF = F // 先把最大值設為初始 F\n\n→ Step 5: 取得 n = len(nums) // 取得數組長度\n\n→ Step 6: 迴圈 k 1..n-1: // 依序計算每個旋轉\n\n    → Step 7: 更新 F = F + sum - n * nums[k-1] // 根據遞推公式更新\n\n    → Step 8: 更新 maxF = max(maxF, F) // 比較是否為新最大值\n\n→ Step 9: 返回 maxF // 結果\n\nEnd\n\nNeed to follow arrow notation. Use `→` for each step. Use indentation for nested steps.\n\nAlso need `Decision:`? Not necessary. But we can show condition.\n\nLet's format each line accordingly. Use virtual code: `Start // 程式開始執行` etc.\n\nBe careful: Step 3: use a loop. Show as `→ Step 3: For i from 0 to n-1: F += i * nums[i] // 計算初始 F(0)`.\n\nSimilarly Step 6 loop.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: sum ← 0 // 初始總和為 0  \n→ Step 2: n ← len(nums) // 取得陣列長度  \n→ Step 3: For i from 0 to n-1: sum ← sum + nums[i] // 計算所有元素的總和  \n→ Step 4: F ← 0 // 初始旋轉函數 F(0)  \n→ Step 5: For i from 0 to n-1: F ← F + i * nums[i] // 依公式計算 F(0)  \n→ Step 6: maxF ← F // 設定目前最大值為 F(0)  \n→ Step 7: For k from 1 to n-1: // 逐一計算 F(1) … F(n-1)  \n  → Step 7a: F ← F + sum - n * nums[k-1] // 遞推公式更新 F  \n  → Step 7b: maxF ← max(maxF, F) // 更新最大值  \n→ Step 8: Return maxF // 回傳最大旋轉函數值  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,9,null,8]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, 9, null, 8]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]\n        self.tree = [0] * (self.n + 1)\n        for i, val in enumerate(nums):\n            self._update_tree(i + 1, val)\n\n    def _update_tree(self, idx, delta):\n        while idx <= self.n:\n            self.tree[idx] += delta\n            idx += idx & -idx\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, idx):\n        res = 0\n        while idx > 0:\n            res += self.tree[idx]\n            idx -= idx & -idx\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split the two top‑level lists\n    sep_index = data.find('],')\n    if sep_index == -1:\n        # Malformed input\n        return\n    ops_part = data[:sep_index + 1]            # includes the closing ]\n    args_part = data[sep_index + 1:].strip()   # starts with [\n\n    # Ensure proper JSON formatting\n    ops_json = ops_part\n    args_json = args_part\n    if not ops_json.startswith('['):\n        ops_json = '[' + ops_json\n    if not ops_json.endswith(']'):\n        ops_json += ']'\n    if not args_json.startswith('['):\n        args_json = '[' + args_json\n    if not args_json.endswith(']'):\n        args_json += ']'\n\n    try:\n        operations = json.loads(ops_json)\n        arguments = json.loads(args_json)\n    except json.JSONDecodeError:\n        return\n\n    obj = None\n    results = []\n    for op, args in zip(operations, arguments):\n        if op == \"NumArray\":\n            obj = NumArray(args[0])\n            results.append(None)\n        elif op == \"update\":\n            obj.update(args[0], args[1])\n            results.append(None)\n        elif op == \"sumRange\":\n            res = obj.sumRange(args[0], args[1])\n            results.append(res)\n\n    # Output results as JSON array (None -> null)\n    print(json.dumps(results, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing a class with update and range sum queries. Likely using a Binary Indexed Tree or Segment Tree. Provide steps: Initialize tree, update, query sum.\n\nWe need to output line by line virtual code with explanation. Use Start, End, Decision. Provide arrow. The virtual code steps: Start, Build tree, Update, Query, End.\n\nLet's structure:\n\nStart\n→ Step 1: Build Fenwick tree from nums // initialize tree\n→ Step 2: Define update function\n    → Step 2a: Compute delta = val - nums[index]\n    → Step 2b: Update nums[index] = val\n    → Step 2c: While idx <= n: tree[idx] += delta; idx += idx & -idx\n→ Step 3: Define sumPrefix function\n    → Step 3a: result = 0\n    → Step 3b: While idx > 0: result += tree[idx]; idx -= idx & -idx\n    → Step 3c: Return result\n→ Step 4: Define sumRange(left, right)\n    → Step 4a: Return sumPrefix(right+1) - sumPrefix(left)\nEnd\n\nBut we need to use arrow and decision? There's no decision needed except maybe check boundaries.\n\nWe'll produce lines with comments.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空陣列 tree[1..n] 為 0 // 用於 Fenwick 樹存儲前綴和  \n→ Step 2: 對於 i 從 0 到 n-1  \n  → Step 2a: tree[i+1] += nums[i] // 初始值插入樹  \n  → Decision: 需要向上傳遞更新?  \n   Yes → Step 2b: j = (i+1) + ((i+1) & -(i+1))  \n    While j <= n: tree[j] += nums[i]; j += j & -j  \n   No → Step 2c: 跳過  \n→ Step 3: 定義 function update(index, val)  \n  → Step 3a: delta = val - nums[index] // 計算變動量  \n  → Step 3b: nums[index] = val // 更新原始陣列  \n  → Step 3c: idx = index + 1  \n   While idx <= n: tree[idx] += delta; idx += idx & -idx // Fenwick 更新  \n→ Step 4: 定義 function sumPrefix(idx)  \n  → Step 4a: res = 0  \n  → Step 4b: while idx > 0: res += tree[idx]; idx -= idx & -idx // 前綴和  \n  → Step 4c: return res  \n→ Step 5: 定義 function sumRange(left, right)  \n  → Step 5a: return sumPrefix(right+1) - sumPrefix(left) // 区间和  \nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar II",
      "source_file": "Leetcode/leetcode731.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, true, true, true, false, true, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpv6tlzws1.py\", line 68, in <module>\n    main()\n  File \"/tmp/tmpv6tlzws1.py\", line 49, in main\n    ops, args = parse_input(data)\n                ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpv6tlzws1.py\", line 40, in parse_input\n    ops = ast.literal_eval(first)\n          ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nimport json\n\nclass MyCalendarTwo:\n    def __init__(self):\n        # single bookings\n        self.booked = []\n        # intervals that are already double-booked\n        self.overlaps = []\n\n    def book(self, start: int, end: int) -> bool:\n        # If new interval overlaps with any existing double-booked interval, reject\n        for s, e in self.overlaps:\n            if max(s, start) < min(e, end):\n                return False\n        # Record new overlaps created by this interval\n        for s, e in self.booked:\n            if max(s, start) < min(e, end):\n                self.overlaps.append((max(s, start), min(e, end)))\n        # Accept the new interval\n        self.booked.append((start, end))\n        return True\n\ndef parse_input(raw: str):\n    \"\"\"Parse the stdin input which can be either two lines or one line with two lists.\"\"\"\n    raw = raw.strip()\n    if not raw:\n        return [], []\n\n    lines = raw.splitlines()\n    if len(lines) == 1:\n        # One line containing both lists, split on '], [' pattern\n        parts = re.split(r'\\],\\s*\\[', lines[0], maxsplit=1)\n        if len(parts) != 2:\n            raise ValueError(\"Input format incorrect.\")\n        first = parts[0]\n        second = '[' + parts[1]  # add missing '['\n        ops = ast.literal_eval(first)\n        args = ast.literal_eval(second)\n    else:\n        ops = ast.literal_eval(lines[0])\n        args = ast.literal_eval(lines[1])\n    return ops, args\n\ndef main():\n    data = sys.stdin.read()\n    ops, args = parse_input(data)\n\n    results = []\n    calendar = None\n    for op, arg in zip(ops, args):\n        if op == \"MyCalendarTwo\":\n            calendar = MyCalendarTwo()\n            results.append(None)\n        elif op == \"book\":\n            res = calendar.book(arg[0], arg[1])\n            results.append(res)\n        else:\n            # In case of other operations, we simply ignore\n            results.append(None)\n\n    # Output in JSON-like format (null, true, false)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for MyCalendarTwo with logic. Standard solution: keep array of single bookings and double bookings. On book, for each existing single, if overlap add overlap to double list. Then check double overlaps with new event, if any overlap => triple, reject. Else add to single list and double list. We'll produce steps.\n\nUse virtual code lines.\n\nLet's create steps:\n\nStart\n→ Step: Initialize singleBookings list\n→ Step: Initialize doubleBookings list\n\nMethod book(start, end)\n→ Decision: For each interval in singleBookings\n    → If overlap? → Step: Add overlap interval to doubleBookings\n\n→ Decision: For each interval in doubleBookings\n    → If overlap? → Return false\n\n→ Step: Add new event to singleBookings\n→ Return true\n\nEdge: Overlap function.\n\nWe can include helper functions as steps.\n\nLet's produce with virtual code. Use indentation as per example. Use arrow etc. We'll keep simple.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 singleBookings 為空清單 // 用於儲存所有單一預訂  \n→ Step 2: 初始化 doubleBookings 為空清單 // 用於儲存所有雙重重疊區間  \n\n→ Step 3: 定義方法 book(start, end) // 嘗試新增預訂  \n  → Decision: 若 start >= end → Return false // 無效時間區間  \n  → Step 4: 對於每個 (s, e) 於 singleBookings  \n    → Decision: 若 s < end 且 e > start? // 檢查是否有重疊  \n      Yes → Step 5: 計算 overlapStart = max(s, start)  \n        Step 6: 計算 overlapEnd = min(e, end)  \n        Step 7: 將 (overlapStart, overlapEnd) 加入 doubleBookings // 產生雙重重疊區間  \n        No → // 無重疊，跳過  \n  → Step 8: 對於每個 (s2, e2) 於 doubleBookings  \n    → Decision: 若 s2 < end 且 e2 > start? // 檢查是否再有三重重疊  \n      Yes → Step 9: Return false // 發現 triple booking，拒絕新增  \n      No → // 無 triple booking，繼續  \n  → Step 10: 將 (start, end) 加入 singleBookings // 成功新增預訂  \n  → Step 11: Return true // 返回成功訊息  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Time Based Key-Value Store",
      "source_file": "Leetcode/leetcode981.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcu4gsasu.py\", line 64, in <module>\n    main()\n  File \"/tmp/tmpcu4gsasu.py\", line 36, in main\n    ops = json.loads(lines[0])\n          ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 54 (char 53)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport bisect\nfrom collections import defaultdict\n\nclass TimeMap:\n    def __init__(self):\n        # key -> list of (timestamp, value) tuples, stored in insertion order\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        # append the new entry; timestamps are given in increasing order\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        # if key not present, return empty string\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # find the rightmost index where (timestamp, value) <= (timestamp, chr(127))\n        # chr(127) is higher than any normal ASCII char, so we get the largest\n        # timestamp <= given timestamp\n        idx = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if idx == 0:\n            return \"\"  # no timestamp <= given\n        return arr[idx - 1][1]  # return the associated value\n\n\ndef main() -> None:\n    # Read all input lines\n    lines = sys.stdin.read().strip().splitlines()\n    if not lines:\n        return\n\n    # Parse the two lists: operations and arguments\n    ops = json.loads(lines[0])\n    args_list = json.loads(lines[1]) if len(lines) > 1 else []\n\n    results = []\n    tm = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"TimeMap\":\n            tm = TimeMap()\n            results.append(None)          # constructor returns None -> null\n        elif op == \"set\":\n            tm.set(*args)                 # args: key, value, timestamp\n            results.append(None)          # set returns None -> null\n        elif op == \"get\":\n            val = tm.get(*args)           # args: key, timestamp\n            results.append(val)           # value or empty string\n\n    # Format the output as required: null for None, quoted strings otherwise\n    output_parts = []\n    for r in results:\n        if r is None:\n            output_parts.append(\"null\")\n        else:\n            output_parts.append(f'\"{r}\"')\n    print(f'[{\", \".join(output_parts)}]')\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code description for implementing a TimeMap class with set and get. The requirement is to produce step by step pseudocode, each line with // explanation. Use arrow →, Decision etc. Must not output actual code.\n\nWe should design structure: Store map from key to list of (timestamp, value) sorted by timestamp. set: append to list. get: binary search for greatest timestamp <= given. If none, return \"\". Need to use decision.\n\nLet's produce pseudocode lines:\n\nStart\n→ Step 1: Initialize data structure: keyMap = empty dictionary // map key to list of (timestamp, value)\n→ Step 2: Define method set(key, value, timestamp) // store key-value pair\n    → Append (timestamp, value) to keyMap[key] // maintain order\n→ Step 3: Define method get(key, timestamp) // retrieve value for timestamp\n    → Decision: 如果 key 存在於 keyMap? // check if key present\n        Yes → Step 4: list = keyMap[key] // get list of entries\n        No  → Step 5: Return \"\" // key not present\n    → Step 6: Binary search list for largest timestamp <= input // find index\n    → Decision: 如果找到有效索引? // found\n        Yes → Step 7: Return list[index].value // return value\n        No  → Step 8: Return \"\" // no timestamp <= input\nEnd\n\nBut need to use decision arrow syntax. Provide each line with explanation after //.\n\nAlso, need to reflect steps for binary search.\n\nAlso include Step numbers maybe optional.\n\nLet's output as lines.\n\nWe can format:\n\nStart // 程式開始執行\n→ Step 1: keyMap ← empty dictionary // 初始化鍵值對存儲\n\nDefine set:\n→ Step 2: Method set(key, value, timestamp) // 定義 set 方法\n    → Step 2.1: 若 key 於 keyMap 中不存在則 keyMap[key] ← empty list // 確保列表存在\n    → Step 2.2: keyMap[key].append((timestamp, value)) // 儲存時間戳和值，保持升序\n\nDefine get:\n→ Step 3: Method get(key, timestamp) // 定義 get 方法\n    → Decision: key 是否在 keyMap 中? // 檢查 key 是否存在\n        Yes → Step 3.1: entries ← keyMap[key] // 取得該 key 的所有時間戳\n        No  → Step 3.2: Return \"\" // 若不存在，返回空字串\n    → Step 3.3: idx ← BinarySearch(entries, timestamp) // 找到最大時間戳 <= timestamp\n    → Decision: idx 是否有效? // 是否找到符合條件的時間戳\n        Yes → Step 3.4: Return entries[idx].value // 回傳對應值\n        No  → Step 3.5: Return \"\" // 沒有符合條件，回傳空字串\nEnd // 程式執行結束\n\nNeed to add explanation after // on each line. Also note indentation? We can just list lines sequentially.\n\nMake sure each line contains arrow or indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: keyMap ← empty dictionary // 初始化鍵對應資料結構，存儲 key → list of (timestamp, value)  \n\n→ Step 2: Method set(key, value, timestamp) // 定義 set 方法，接收 key、value 與 timestamp  \n&nbsp;&nbsp;→ Step 2.1: 若 key 於 keyMap 中不存在則 keyMap[key] ← empty list // 確保該 key 有對應的清單  \n&nbsp;&nbsp;→ Step 2.2: keyMap[key].append((timestamp, value)) // 把 (timestamp, value) 加入清單，保持時間戳遞增  \n\n→ Step 3: Method get(key, timestamp) // 定義 get 方法，根據 timestamp 取得最近的值  \n&nbsp;&nbsp;→ Decision: key 是否在 keyMap 中? // 判斷 key 是否存在  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3.1: entries ← keyMap[key] // 取得該 key 的所有 (timestamp, value) 清單  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 3.2: Return \"\" // 若不存在，直接回傳空字串  \n&nbsp;&nbsp;→ Step 3.3: idx ← BinarySearch(entries, timestamp) // 在清單中尋找最大 timestamp <= timestamp  \n&nbsp;&nbsp;→ Decision: idx 是否有效? // 判斷是否找到符合條件的索引  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3.4: Return entries[idx].value // 回傳對應的 value  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 3.5: Return \"\" // 沒有符合條件的 timestamp，回傳空字串  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Super Pow",
      "source_file": "Leetcode/leetcode372.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "a = 2, b = [1,0]",
          "expected_output": "1024",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqupw8f6n.py\", line 42, in <module>\n    a_val, b_list = parse_input(raw_input)\n                    ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqupw8f6n.py\", line 32, in parse_input\n    b = ast.literal_eval(val)\n        ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "a = 1, b = [4,3,3,8,5,2]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpoqyvljdg.py\", line 42, in <module>\n    a_val, b_list = parse_input(raw_input)\n                    ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpoqyvljdg.py\", line 32, in parse_input\n    b = ast.literal_eval(val)\n        ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [4\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef super_pow(a: int, b: list[int]) -> int:\n    \"\"\"\n    Compute a^b mod 1337, where b is a list of decimal digits of the exponent.\n    \"\"\"\n    MOD = 1337\n    result = 1\n    for digit in b:\n        # (result^10 * a^digit) % MOD\n        result = (pow(result, 10, MOD) * pow(a, digit, MOD)) % MOD\n    return result\n\ndef parse_input(text: str):\n    \"\"\"\n    Parse the input string which is expected in the format:\n    a = <int>, b = [<int>, <int>, ...]\n    \"\"\"\n    parts = [p.strip() for p in text.split(',')]\n    a = None\n    b = None\n    for part in parts:\n        if not part:\n            continue\n        var, val = part.split('=', 1)\n        var = var.strip()\n        val = val.strip()\n        if var == 'a':\n            a = int(val)\n        elif var == 'b':\n            b = ast.literal_eval(val)\n    if a is None or b is None:\n        raise ValueError(\"Input must contain both 'a' and 'b'.\")\n    return a, b\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    a_val, b_list = parse_input(raw_input)\n    result = super_pow(a_val, b_list)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm to compute a^b mod 1337 where a positive integer a, b is extremely large given as array of digits? Probably array of digits representing exponent. Standard problem: exponentiation modulo with big exponent given as array of digits. Approach: use modular exponent with repeated squaring and process digits: result = 1; for each digit d in b: result = powmod(result, 10, mod) * powmod(a, d, mod) % mod. Use powmod for base^exp mod mod. So algorithm steps: start, read a, read b array. mod=1337. result=1. For each digit d in b: result = powmod(result,10,mod); temp = powmod(a,d,mod); result = (result * temp)%mod. End. Provide virtual code lines with explanation.\n\nNeed to use arrows, decision etc. The array digits are processed sequentially. Might need a function powmod.\n\nWe will produce lines accordingly. Use Start, End, Decision, etc. Provide explanation after each line.\n\nLet's craft:\n\nStart // 開始程式\n→ Read a // 取得底數 a\n→ Read b // 取得大指數陣列 b\n→ Set mod = 1337 // 設定模數\n→ Set result = 1 // 初始結果\n→ For each digit d in b // 依序處理指數陣列\n    → Compute power1 = powmod(result, 10, mod) // 先把現有結果提升到10次方模\n    → Compute power2 = powmod(a, d, mod) // 計算 a 的 d 次方模\n    → Set result = (power1 * power2) % mod // 更新結果\n→ Output result // 輸出最終模數\nEnd // 程式結束\n\nNeed to show decision? We don't have any. But we can show for loop as a decision? Might not need. But can use Decision for loop? We'll keep simple.\n\nMake sure each line has virtual code and comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Read a // 取得底數 a  \n→ Read b // 取得大指數陣列 b  \n→ Set mod = 1337 // 設定模數  \n→ Set result = 1 // 初始化累積結果為 1  \n→ For each digit d in b // 逐位處理指數陣列  \n    → Compute power1 = powmod(result, 10, mod) // 把目前結果提升到 10 次方再取模  \n    → Compute power2 = powmod(a, d, mod) // 計算 a 的 d 次方後取模  \n    → Set result = (power1 * power2) % mod // 更新結果，合併兩部分的模值  \n→ Output result // 顯示最終 a^b mod 1337 的結果  \nEnd // 程式結束執行"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      \"['dogcatsdog', 'catsdogcats', 'ratcatdogcat']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        找出 words 中所有能由至少兩個較短單詞組合而成的字串。\n        \"\"\"\n        # 先按長度排序，確保較短單詞先加入集合\n        words.sort(key=len)\n        word_set = set()      # 已處理且可用來斷詞的單詞\n        result = []\n\n        for word in words:\n            if not word:          # 空字串不可能成為連接詞\n                continue\n            if self._can_form(word, word_set):\n                result.append(word)\n            word_set.add(word)    # 把目前單詞加入字典，供之後的檢查使用\n        return result\n\n    def _can_form(self, word, word_set):\n        \"\"\"\n        使用 DP 判斷 word 是否能被 word_set 內的單詞斷成至少兩個片段。\n        \"\"\"\n        if not word_set:\n            return False\n\n        n = len(word)\n        dp = [False] * (n + 1)\n        dp[0] = True  # 空前綴總是可斷\n\n        for i in range(1, n + 1):\n            for j in range(0, i):\n                if not dp[j]:\n                    continue\n                if word[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[n]\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 若輸入包含 \"words =\"，去除前綴\n    if raw_input.lower().startswith(\"words\"):\n        raw_input = raw_input.split(\"=\", 1)[1].strip()\n    # 解析成 Python 列表\n    words = ast.literal_eval(raw_input)\n\n    sol = Solution()\n    concatenated = sol.findAllConcatenatedWordsInADict(words)\n    # 輸出為 Python 文字表示的清單\n    print(concatenated)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step. For the problem: given array of strings words without duplicates, return all concatenated words: words that can be formed by concatenating at least two other words in the list. Approach: use a Trie or dictionary. Sort words by length. Use DP to check each word if can be segmented using earlier words. Build set of words added. For each word, run word break DP with the set. Add to result if true. Then add word to set.\n\nWe produce virtual code lines. Use structure: Start, Decision, Step, End.\n\nWe'll produce pseudo-code lines with arrow → etc. Each line includes explanation comment after //.\n\nLet's produce code:\n\nStart\n→ Step 1: Sort words by ascending length // 確保較短字先處理\n→ Step 2: Initialize empty set dictionaryWords // 用於快速查詢已處理的單詞\n→ Step 3: Initialize empty list result // 存儲所有連接詞\n→ Decision: 是否還有未處理單詞? // 開始循環\n    Yes → Step 4: 取出下一個單詞 currentWord // 取出下一個待檢查字\n    → Step 5: If currentWord 可以被 dictionaryWords 斷詞 (wordBreak) // 檢查是否為連接詞\n        Yes → Step 6: 把 currentWord 加入 result // 若是連接詞，存入結果\n    → Step 7: 把 currentWord 加入 dictionaryWords // 將它納入已知字典\n    → Decision: 是否還有未處理單詞? // 回到循環\n        Yes → 迴圈繼續\n        No  → End // 完成\n\nBut need to include implementation of wordBreak DP: inside Step 5 we might need to break into substeps.\n\nWe can define a sub-procedure: wordBreak(word, dictionary). We'll pseudo-code inside.\n\nBetter:\n\n→ Decision: 是否可以用 dictionaryWords 斷詞 currentWord? // 需要 wordBreak 函式\n    Yes → ...\n    No  → ...\n\nBut we need to show the DP steps. So we can include sub-steps:\n\n→ Step 5a: 定義 dp array of length currentWord.length + 1，dp[0] = true // DP基礎\n→ Step 5b: 迭代 i 1..len\n→ Step 5c: 迭代 j 0..i-1\n→ Step 5d: If dp[j] 且 substring j..i 在 dictionaryWords // 找到分割\n→ Step 5e: dp[i] = true，break 循環 // 設置成功\n→ Decision: dp[len] 是否 true? // 若為 true，則為連接詞\n\nBut we might embed inside.\n\nLet's produce structured pseudo-code accordingly.\n\nAlso ensure we use arrow symbols correctly. Use indentation for nested decisions.\n\nLet's craft final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Sort words by ascending length // 先處理較短的單詞\n→ Step 2: 初始化 dictionaryWords 為空集合 // 儲存已檢查過的單詞\n→ Step 3: 初始化 result 為空列表 // 儲存所有連接詞\n→ Decision: words 仍有未處理項目? // 檢查是否還有單詞要處理\n    Yes → Step 4: 取出第一個單詞 currentWord // 取出待檢查的單詞\n    → Step 5: // 呼叫斷詞檢查，若能以 dictionaryWords 斷詞則視為連接詞\n        → Step 5a: 定義 dp 陣列長度為 currentWord.length + 1，dp[0] = true // DP 基礎\n        → Step 5b: 對 i 從 1 到 currentWord.length 迭代\n            → Step 5b1: 對 j 從 0 到 i-1 迭代\n                → Decision: dp[j] 為 true 且 currentWord[j:i] 在 dictionaryWords? // 檢查子字串是否已知\n                    Yes → Step 5b1a: dp[i] = true，break 迴圈 // 成功斷詞，設定 dp[i]\n                    No  → 迭代 j 繼續\n            → Step 5c: 迭代 i 繼續\n        → Decision: dp[currentWord.length] 為 true? // 若最後 dp 為 true，整個字串可斷\n            Yes → Step 5d: 把 currentWord 加入 result // 存入連接詞結果\n            No  → Step 5e: 不做任何事 // 不是連接詞\n    → Step 6: 把 currentWord 加入 dictionaryWords // 把本詞加入已知字典\n    → Decision: words 仍有未處理項目? // 重複迴圈\n        Yes → 重複 Step 4\n        No  → End // 所有單詞已處理，結束\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6_z5fww0.py\", line 57, in <module>\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6_z5fww0.py\", line 47, in parse_input\n    prereqs = ast.literal_eval(part.split('=')[1].strip())\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfeh2_6hu.py\", line 57, in <module>\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfeh2_6hu.py\", line 47, in parse_input\n    prereqs = ast.literal_eval(part.split('=')[1].strip())\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立鄰接清單與入度陣列\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 依照 prerequisites 更新圖形結構\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 以入度為 0 的節點開始\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # Kahn 演算法進行拓樸排序\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若所有課程都被安排，回傳順序；否則回傳空清單\n        return order if len(order) == numCourses else []\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，取得 numCourses 與 prerequisites。\n    輸入範例：'numCourses = 2, prerequisites = [[1,0]]'\n    \"\"\"\n    parts = data.split(',')\n    num_courses = 0\n    prereqs = []\n\n    for part in parts:\n        part = part.strip()\n        if part.startswith('numCourses'):\n            num_courses = int(part.split('=')[1].strip())\n        elif part.startswith('prerequisites'):\n            # 直接用 literal_eval 解析 Python literal\n            prereqs = ast.literal_eval(part.split('=')[1].strip())\n    return num_courses, prereqs\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        # 若沒有輸入則輸出空清單\n        print([])\n    else:\n        numCourses, prerequisites = parse_input(raw_input)\n        sol = Solution()\n        result = sol.findOrder(numCourses, prerequisites)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for topological sort using Kahn's algorithm or DFS. Provide step-by-step lines with explanation comments. Use Start, End, Decision, etc. No actual code. Just pseudocode. Provide explanation for each line.\n\nWe need to output line by line. Use arrow \"→\". Provide the virtual code step with explanation.\n\nWe must handle input: numCourses, prerequisites array. Output ordering or empty.\n\nLet's produce:\n\nStart\n→ Step 1: Build adjacency list and indegree array // 初始化圖\n→ Step 2: Initialize queue with courses having indegree 0 // 無前置課程\n→ Decision: queue 非空? // 是否有可開始課程\n    Yes → Step 3: Dequeue course c, append to result // 拆除並記錄\n    → Step 4: For each neighbor n of c: decrement indegree[n]\n    → Step 5: If indegree[n] becomes 0, enqueue n // 新可開始課程\n    → Loop back to Decision\n    No  → Step 6: If result size == numCourses? // 是否完成所有課程\n        Yes → Step 7: Return result // 有效順序\n        No  → Step 8: Return empty list // 無法完成\nEnd\n\nWe should include indentation for nested steps.\n\nUse arrow \"→\" at start of each step. For decision, include nested arrows. Also include comments after //.\n\nWe need to keep each line separate, with explanation. Ensure no actual code, only virtual steps. Provide line breaks.\n\nLet's craft.\n\nAlso we may mention variable names. But no code.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立鄰接清單 adj 與入度陣列 indeg // 依 prerequisites 建立圖形結構  \n→ Step 2: 初始化佇列 queue，將 indeg 為 0 的課程加入 // 無前置課程可先修  \n→ Decision: queue 是否非空？ // 判斷是否還有課程可安排  \n Yes → Step 3: 從 queue 拆除一個課程 c，將 c 加入結果順序 list // 記錄已修課程  \n  → Step 4: 取得 c 的所有鄰接課程 n，將 indeg[n] 減 1 // 更新依賴數量  \n  → Step 5: 若 indeg[n] 變成 0，將 n 加入 queue // 新可修課程  \n  → Decision: queue 是否非空？ // 重新檢查是否還有可修課程  \n   Yes → 回到 Step 3  \n   No → Step 6: 判斷 list 的長度是否等於 numCourses？ // 檢查是否所有課程已完成  \n    Yes → Step 7: 回傳 list // 成功得到有效順序  \n    No → Step 8: 回傳空清單 // 無法完成所有課程，存在循環  \nNo → Step 9: 判斷 list 的長度是否等於 numCourses？ // 初始階段即無可修課程時的檢查  \n  Yes → Step 10: 回傳 list // 例如 numCourses 為 0 時可直接回傳空清單  \n  No → Step 11: 回傳空清單 // 仍然無法完成  \nEnd // 程式執行結束"
    },
    {
      "title": "3Sum Closest",
      "source_file": "Leetcode/leetcode16.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [-1,2,1,-4], target = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp12l1q7sh.py\", line 48, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp12l1q7sh.py\", line 42, in parse_input\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [-1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,0], target = 1",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpteky42va.py\", line 48, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpteky42va.py\", line 42, in parse_input\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [0\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport math\n\nclass Solution:\n    def threeSumClosest(self, nums, target):\n        nums.sort()\n        n = len(nums)\n        best_sum = nums[0] + nums[1] + nums[2]\n        for i in range(n - 2):\n            left, right = i + 1, n - 1\n            while left < right:\n                current = nums[i] + nums[left] + nums[right]\n                if abs(current - target) < abs(best_sum - target):\n                    best_sum = current\n                if current == target:\n                    return current\n                if current < target:\n                    left += 1\n                else:\n                    right -= 1\n        return best_sum\n\ndef parse_input(data: str):\n    \"\"\"\n    解析類似 'nums = [-1,2,1,-4], target = 1' 這樣的輸入字串。\n    \"\"\"\n    # 移除可能的換行與空白\n    data = data.replace('\\n', ' ').replace('\\r', ' ')\n    # 找出 nums 部分\n    nums_start = data.find('nums')\n    target_start = data.find('target')\n    if nums_start == -1 or target_start == -1:\n        raise ValueError(\"輸入格式錯誤\")\n    # 提取 list 字串\n    nums_str = data[nums_start:data.find(',', nums_start)]\n    nums_str = nums_str[nums_str.find('=') + 1:].strip()\n    # 提取 target 數字\n    target_str = data[target_start:target_start + 50]\n    target_str = target_str[target_str.find('=') + 1:].strip()\n    # 轉成 Python 物件\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n    sol = Solution()\n    result = sol.threeSumClosest(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step pseudocode for the 3Sum Closest problem. Use virtual code with arrows. No actual code. Provide explanation after each line. Must output in Traditional Chinese.\n\nNeed to produce a solution algorithm: sort array, iterate first pointer i, then two pointers left, right, compute sum, track best diff, update answer, adjust pointers. Complexity O(n^2). So produce step-by-step.\n\nLet's produce:\n\nStart // begin\n\n→ Step 1: Sort nums ascending // Sort array to use two pointers\n\n→ Step 2: Initialize bestSum = nums[0]+nums[1]+nums[2] // set initial best sum\n\n→ Step 3: For i from 0 to n-3 // iterate first element\n\n→ Decision: If i > 0 and nums[i] == nums[i-1]? // skip duplicates? Not necessary for problem but we can skip.\n\nBut we can skip duplicates but not essential. We can keep simple.\n\n→ Step 4: left = i+1, right = n-1 // set pointers\n\n→ Decision: While left < right? // loop to examine sums\n\n    → Step 5: currentSum = nums[i]+nums[left]+nums[right] // compute current sum\n\n    → Step 6: If abs(currentSum - target) < abs(bestSum - target)? // check closeness\n\n        → Step 7: bestSum = currentSum // update best\n\n    → Decision: If currentSum == target? // exact match\n\n        → Yes → Return bestSum // solution found\n\n        → No\n\n            → Decision: If currentSum < target? // need larger sum\n\n                → Yes → left++ // move left pointer\n\n                → No → right-- // move right pointer\n\n→ Step 8: End For\n\n→ Step 9: Return bestSum // after loops\n\n→ End\n\nLet's produce with arrows and explanation.\n\nEnsure each line includes virtual code and // explanation.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 將陣列遞增排序，以便後續使用雙指標技巧  \n→ Step 2: Initialize bestSum = nums[0] + nums[1] + nums[2] // 先取前三個數作為最佳答案的初始值  \n→ Step 3: For i from 0 to n-3 // 依序挑選第一個數字作為三元組的首位  \n→ Decision: If i > 0 and nums[i] == nums[i-1]? // 如需避免重複計算，可跳過相同的首位數字  \n  Yes → Continue to next i // 跳過重複的首位  \n  No  →  \n   left = i + 1, right = n - 1 // 設定左、右兩指標，分別指向首位右側和最後一位  \n   Decision: While left < right? // 當左指標未超過右指標時持續搜尋  \n    → Step 5: currentSum = nums[i] + nums[left] + nums[right] // 計算當前三個數字的總和  \n    → Step 6: If abs(currentSum - target) < abs(bestSum - target)? // 檢查是否比目前最佳答案更接近目標  \n      Yes → bestSum = currentSum // 更新最佳答案  \n      No → // 仍保持最佳答案不變  \n         \n     Decision: If currentSum == target? // 完全等於目標則即為最佳答案  \n      Yes → Return bestSum // 直接回傳答案，結束程式  \n      No  \n       Decision: If currentSum < target? // 若總和較小，需要提升總和  \n        Yes → left++ // 左指標右移，選擇更大的數字  \n        No  → right-- // 右指標左移，選擇更小的數字"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                parent_email = find(first_email)\n                parent_email2 = find(email)\n                parent[parent_email2] = parent_email\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        return [[email_to_name[root]] + sorted(emails) for root, emails in merged.items()]\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    # Find the first '[' to get the list literal\n    start = raw_input.find('[')\n    if start == -1:\n        accounts = []\n    else:\n        accounts = ast.literal_eval(raw_input[start:])\n\n    result = Solution().accountsMerge(accounts)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line for merging accounts with DSU or graph. Provide explanation per line. Use arrow and Decision. Let's produce steps:\n\nStart\n→ Build mapping email->name\n→ Build graph adjacency for emails\n→ For each account: for emails[1:] add edges between first email and others\n→ After graph, traverse each email visited: DFS to gather connected emails\n→ Sort emails, prepend name\n→ Add to result list\n→ End\n\nInclude decision if email already visited.\n\nLet's output lines with explanation. Use \"Start\" \"End\". For loops we might have Decision lines. Let's craft.\n\nWe need to include arrow lines: \"→ Step X:\" etc. Provide explanations. Use \"Decision:\" when checking visited. Use \"Yes →\" etc.\n\nLet's create:  \n\nStart\n\n→ Step 1: 建立空映射 emailToName // 用於儲存每個 email 的名稱  \n→ Step 2: 建立空鄰接表 graph // 用於儲存 email 之間的連結  \n\n→ Decision: 逐筆處理每個帳戶 accounts[i]  \n    Yes → Step 3: 取得 name = accounts[i][0] // 取得帳戶名稱  \n    Yes → Step 4: 取得 emails = accounts[i][1:] // 取得該帳戶所有 email  \n    Yes → Decision: 對每個 email e 在 emails  \n        Yes → Step 5: emailToName[e] ← name // 將 email 與名稱對應  \n        Yes → Decision: 如果 i == 0? // 首個 email  \n            Yes → Step 6: first ← e // 記錄首個 email  \n            No  → Step 7: graph[first].append(e) // 建立第一個與其他 email 的邊  \n            No  → Step 7: graph[e].append(first) // 建立對向邊  \n\n→ Step 8: 建立空集合 visited // 記錄已訪問的 email  \n\n→ Decision: 逐個 email e 在 graph.keys()  \n    Yes → Decision: e 是否已訪問?  \n        Yes → Step 9: 跳過 // 已處理過  \n        No  → Step 10: 建立空列表 component // 用於收集連通分量  \n        No  → Step 11: 執行 DFS(e)  \n            DFS(e):  \n                → Step 12: 將 e 加入 visited  \n                → Step 13: component.append(e)  \n                → Step 14: 對每個鄰居 nei in graph[e]  \n                    → Decision: nei 是否已訪問?  \n                        Yes → 继续  \n                        No  → DFS(nei)  \n        No  → Step 15: component.sort() // 依序排列 email  \n        No  → Step 16: name = emailToName[component[0]] // 取得該分量的名稱  \n        No  → Step 17: result.append([name] + component) // 加入結果  \n\n→ End\n\nBut we need arrow lines and \"→\". Use format: \"→ Step X: ... // explanation\". For decision we indent. Let's produce final output with proper formatting.\n\nEnsure each line includes arrow or start/end. Use \"Start\" line.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空映射 emailToName // 用來記錄每個 email 對應的姓名  \n→ Step 2: 建立空鄰接表 graph // 用來存儲 email 之間的連結  \n\n→ Decision: 逐筆處理每個帳戶 accounts[i]  \n    Yes → Step 3: name ← accounts[i][0] // 取得該帳戶的名稱  \n    Yes → Step 4: emails ← accounts[i][1:] // 取得該帳戶的所有 email  \n    Yes → Decision: 逐個 email e 在 emails  \n        Yes → Step 5: emailToName[e] ← name // 建立 email 與姓名的映射  \n        Yes → Decision: i == 0? // 判斷是否為第一個 email  \n            Yes → Step 6: first ← e // 記錄首個 email  \n            No  → Step 7: graph[first].append(e) // 建立首個 email 與其他 email 的邊  \n            No  → Step 7: graph[e].append(first) // 建立對向邊  \n\n→ Step 8: 建立空集合 visited // 記錄已被訪問過的 email  \n\n→ Decision: 逐個 email e 在 graph.keys()  \n    Yes → Decision: e 是否已訪問?  \n        Yes → Step 9: 跳過 // 已經處理過的分量不再重複  \n        No  → Step 10: 建立空列表 component // 用來收集當前連通分量的 email  \n        No  → Step 11: 執行 DFS(e) // 深度優先搜尋收集整個分量  \n            DFS(e):  \n                → Step 12: visited.add(e) // 標記為已訪問  \n                → Step 13: component.append(e) // 加入分量列表  \n                → Step 14: 逐個鄰居 nei in graph[e]  \n                    → Decision: nei 是否已訪問?  \n                        Yes → 继续 // 若已訪問則不再遞迴  \n                        No  → DFS(nei) // 深入探索鄰居  \n        No  → Step 15: component.sort() // 將收集到的 email 進行字典序排序  \n        No  → Step 16: name ← emailToName[component[0]] // 取分量中任一 email 的姓名（皆相同）  \n        No  → Step 17: result.append([name] + component) // 將合併後的帳戶加入結果列表  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Super Washing Machines",
      "source_file": "Leetcode/leetcode517.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[0,3,0]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMinMoves(self, machines):\n        total = sum(machines)\n        n = len(machines)\n        if total % n != 0:\n            return -1\n        target = total // n\n        prefix = 0\n        moves = 0\n        for i, load in enumerate(machines):\n            prefix += load\n            expected = (i + 1) * target\n            diff = abs(prefix - expected)\n            if diff > moves:\n                moves = diff\n        return moves\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    machines = ast.literal_eval(data)\n    sol = Solution()\n    result = sol.findMinMoves(machines)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm. Problem: Leetcode 641. Minimum Moves to Equalize Array II? Actually \"Super Washing Machines\" problem: We need minimal moves to equalize dresses. Known solution: Compute prefix sums, track max of abs(prefix - i*target). So algorithm: if total% n !=0 return -1; target=total/n. For each i from0 to n-1 compute prefix sum. moves = max(moves, abs(prefix - (i+1)*target)). return moves.\n\nWe need virtual code step by step with arrows and explanation each line. We'll produce steps: Start, Step 1: compute total. Step 2: check divisibility. Step 3: target. Step 4: initialize prefix=0, moves=0. Step 5: loop i. Step 6: prefix += machines[i]. Step 7: expected = (i+1)*target. Step 8: diff = abs(prefix-expected). Step 9: moves = max(moves, diff). End. Return moves.\n\nAlso include decision if not possible. Let's write. Use arrow syntax. Provide each line with explanation. Let's do.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算總衣服數 total ← sum(machines) // 取得所有洗衣機衣服總數  \n→ Decision: 若 total mod n ≠ 0? // 檢查衣服數是否能平均分配  \n    Yes → Step 2: 回傳 -1 // 無法平均，直接返回失敗  \n    No  → Step 3: 計算目標數目 target ← total / n // 每台洗衣機應有的衣服數  \n→ Step 4: 初始化 prefix ← 0, moves ← 0 // prefix 用於累計前綴和，moves 用於儲存最大移動次數  \n→ Step 5: 循環 i 取 0 到 n-1 // 逐一處理每台洗衣機  \n    → Step 6: prefix ← prefix + machines[i] // 更新前綴和，包含第 i 台衣服數  \n    → Step 7: expected ← (i + 1) * target // 前 i+1 台總預期衣服數  \n    → Step 8: diff ← abs(prefix - expected) // 實際前綴和與預期之差的絕對值  \n    → Step 9: moves ← max(moves, diff) // 記錄目前需要的最大移動次數  \n→ End // 迴圈結束  \n→ Step 10: 回傳 moves // 返回最小移動步數以達成平均分配"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[None,4,4,6,0,1,6,0]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[None, 4, 4, 6, 0, 1, 6, 0]'"
        }
      ],
      "generated_code": "import json\nimport random\nimport sys\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # Number of allowed integers\n        self.size = n - len(blacklist)\n        self.mapping = {}\n        black_set = set(blacklist)\n        last = n - 1\n\n        # Map each blacklisted number in the lower part to a valid number in the upper part\n        for b in blacklist:\n            if b < self.size:\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        # Pick a random index in [0, size-1]\n        idx = random.randint(0, self.size - 1)\n        # Return the mapped value if idx is blacklisted, otherwise idx itself\n        return self.mapping.get(idx, idx)\n\ndef main():\n    # 讀取整個輸入\n    lines = sys.stdin.read().strip().splitlines()\n    if not lines:\n        return\n\n    # 第一行為操作列表，第二行為對應的參數列表\n    ops = json.loads(lines[0])\n    args = json.loads(lines[1])\n\n    results = []\n    obj = None\n\n    for op, param in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*param)\n            results.append(None)      # constructor returns null\n        elif op == \"pick\":\n            results.append(obj.pick())\n        else:\n            results.append(None)      # 其它未定義操作\n\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Provide algorithm: use mapping from first m numbers to allowed numbers in upper part. Steps: compute m = n - len(blacklist). Create set B for blacklist numbers < m. Build map for each b in B: assign next available number >= m that not in blacklist. pick(): generate random int k in [0, m-1], if k in map, return map[k], else return k. Need to explain. Provide step by step with arrows.\n\nWe need to produce the virtual code lines. We need to include Start, End, Decision. We should not provide actual code but steps. Use virtual code steps. Let's produce:\n\nStart\n→ Step 1: Input n, blacklist // initialization\n→ Step 2: m ← n - len(blacklist) // compute size of allowed range\n→ Step 3: Create empty set B // blacklisted numbers less than m\n→ Step 4: For each b in blacklist:\n        If b < m:\n            add b to B // collect blacklisted in first segment\n→ Step 5: Create empty map M // mapping from blacklisted to allowed numbers\n→ Step 6: x ← m // pointer to next candidate in upper range\n→ Step 7: While x < n:\n        If x in blacklist:\n            x ← x + 1 // skip blacklisted in upper segment\n        Else:\n            For each b in B:\n                If b not yet mapped:\n                    M[b] ← x // map b to x\n                    x ← x + 1\n                    break\n→ Step 8: Define pick() // function to return random number\n→ Step 9: k ← random_int(0, m-1) // generate random index in allowed segment\n→ Decision: If k in M?\n        Yes → return M[k] // mapped value\n        No  → return k // allowed number itself\nEnd\n\nBut we need to ensure virtual code line by line. Maybe we can condense loops.\n\nLet's produce steps more succinctly.\n\nWe can show decision steps.\n\nAlso, we need to mention \"Optimize to minimize calls to random\" – we only call once per pick.\n\nWe need to produce virtual code with arrow notation, but each line is a step. Use `→` arrow. For decisions use `Decision:` and indent. Also include Start and End.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 接收參數 n 與 blacklist // 初始化物件\n\n→ Step 2: m ← n - len(blacklist) // 允許選擇的數量\n\n→ Step 3: B ← 空集合 // 用來存放位於 [0, m-1] 內的黑名單\n\n→ Step 4: For each b in blacklist:\n        If b < m:\n            B ← B ∪ {b} // 收集第一段內的黑名單\n\n→ Step 5: M ← 空映射 // 將第一段黑名單對應到合法的上段數字\n\n→ Step 6: x ← m // 從上段起點開始掃描\n\n→ Step 7: For each b in B:\n        While x ∈ blacklist:\n            x ← x + 1 // 跳過上段中的黑名單\n        M[b] ← x // 把 b 映射到第一個合法的上段數字\n        x ← x + 1 // 移到下一個候選數字\n\n→ Step 8: 定義 pick() 函式 // 產生隨機合法數字\n\n→ Step 9: k ← random_int(0, m-1) // 只呼叫一次隨機函式\n\n→ Decision: k 是否在 M 中?\n        Yes → return M[k] // 若 k 是黑名單，回傳映射後的合法數字\n        No  → return k // 若 k 本身合法，直接回傳\n\nEnd // 程式執行結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,3,null,5]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, null, 3, null, 5]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.old_vals = {}\n\n    def insert(self, key: str, val: int) -> None:\n        # Calculate delta from previous value if key exists\n        old = self.old_vals.get(key, 0)\n        delta = val - old\n        self.old_vals[key] = val\n\n        node = self.root\n        node.sum += delta\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += delta\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef main():\n    lines = [line.strip() for line in sys.stdin if line.strip() != '']\n    if len(lines) < 2:\n        return\n    ops = ast.literal_eval(lines[0])\n    args = ast.literal_eval(lines[1])\n\n    obj = None\n    results = []\n    for op, arg in zip(ops, args):\n        if op == 'MapSum':\n            obj = MapSum()\n            results.append(None)\n        elif op == 'insert':\n            key, val = arg\n            obj.insert(key, val)\n            results.append(None)\n        elif op == 'sum':\n            prefix = arg[0]\n            results.append(obj.sum(prefix))\n        else:\n            # Unsupported operation, skip\n            results.append(None)\n\n    # Convert results to required output format\n    output = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for MapSum class operations. Use virtual code with arrows, decisions, etc. Should be line-by-line. We'll produce steps like:\n\nStart // ...\n→ Step 1: 定義 MapSum 類別 // etc.\n\nWe need to design structure: Use Trie with sum field? Provide pseudocode for insert and sum. Provide initialization. Provide algorithm steps. We'll produce lines for constructor, insert, sum. Each line with explanation. Use arrow style. Probably like:\n\nStart\n→ Step 1: 建立 MapSum 物件 // ...\n→ Step 2: insert key, val // ...\nBut we need to detail algorithm.\n\nWe can break into functions: Start, Step: define class MapSum with trie node containing children and sum, and dictionary for old values. Then Insert steps: update trie, subtract old value if key existed, add new val. Sum: traverse prefix.\n\nWe'll produce pseudocode with decisions. Provide each line with explanation.\n\nLet's output lines sequentially: starting from Start. We'll include comment lines. Each line ends with // explanation.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 MapSum 類別 // 建立 MapSum 物件\n→   Decision: 需要儲存舊 key‑value? // 檢查是否需要跟蹤已存在的 key\n        Yes → Step 2: 建立字典 oldVals: Map<string, int> // 用於記錄每個 key 的現有值\n        No  → Skip // 若不需要覆寫，則略過此步驟\n→ Step 3: 建立 TrieNode 類別 // Trie 節點\n        → Node 內含:\n            → children: Map<char, TrieNode> // 子節點\n            → sum: int // 從此節點起始的所有 key 的值總和\n→ Step 4: MapSum 建構子\n        → Step 5: root ← 新建 TrieNode() // Trie 根節點\n→ Decision: 需要初始化 oldVals? // 檢查是否已建立字典\n        Yes → Step 6: oldVals ← 新建 Map<string, int>() // 空字典\n        No  → Skip\n→ Step 7: insert(key, val) 函式\n        → Step 8: old ← oldVals[key] 若存在，否則 0 // 取得舊值\n        → Step 9: delta ← val - old // 計算值變動\n        → Step 10: current ← root // 從根節點開始\n        → Decision: key 為空字串? // 檢查 key 是否為空\n                Yes → Step 11: current.sum ← current.sum + delta // 更新根節點 sum\n                No  → Skip\n        → Decision: key 為空? // 若 key 不為空，遍歷每個字元\n                Yes → No action\n                No  → Loop 每個字符 c in key\n                        → Step 12: 若 current.children 不包含 c 則建立新 TrieNode 為 current.children[c]\n                        → Step 13: current ← current.children[c]\n                        → Step 14: current.sum ← current.sum + delta // 更新此節點 sum\n        → Step 15: oldVals[key] ← val // 儲存新值\n→ Step 16: sum(prefix) 函式\n        → Step 17: current ← root // 從根節點開始\n        → Loop 每個字符 c in prefix\n                → Decision: current.children 包含 c? // 檢查子節點是否存在\n                        Yes → Step 18: current ← current.children[c] // 移至子節點\n                        No  → Step 19: return 0 // 前綴不存在，返回 0\n        → Step 20: return current.sum // 返迴前綴節點的 sum\nEnd // 程式執行結束"
    },
    {
      "title": "Single Number II",
      "source_file": "Leetcode/leetcode137.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '99'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '99'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNumber(self, nums):\n        ones, twos = 0, 0\n        for num in nums:\n            # Update 'twos' before updating 'ones' to avoid interference\n            twos = (twos ^ num) & ~ones\n            ones = (ones ^ num) & ~twos\n        return ones\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Remove any 'nums =' prefix if present\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n\n    # Safely evaluate the list expression\n    try:\n        nums = ast.literal_eval(data)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        return\n\n    # Ensure we have a list of integers\n    if not isinstance(nums, list):\n        print(\"Input must be a list of integers.\", file=sys.stderr)\n        return\n\n    solution = Solution()\n    result = solution.singleNumber(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The problem: find element appearing once when others appear three times. Use bit manipulation: count bits mod 3. We need linear runtime, constant space.\n\nWe will produce steps: start, initialize variables bit0 and bit1 (or ones, twos). Use algorithm: for each number, update twos = twos | (ones & num); ones = ones ^ num; then mask = ~(ones & twos); ones &= mask; twos &= mask. Finally return ones.\n\nWe'll generate virtual steps line by line.\n\nWe should use \"Start\" and \"End\". Use decision if needed? There's no loops with decisions except bit operations. But we might show loop with each number.\n\nLet's create:\n\nStart\n\n→ Step 1: 初始化 ones = 0, twos = 0 // 用於記錄位出現 1 次和 2 次的位\n\n→ Step 2: 循環遍歷 nums // 逐個處理每個數字\n\n    → For each num in nums:\n\n        → Step 3: 更新 twos = twos | (ones & num) // 將位先出現一次再兩次的位加入 twos\n\n        → Step 4: 更新 ones = ones ^ num // 切換位的出現次數\n\n        → Step 5: mask = ~(ones & twos) // 找到需要重置的位\n\n        → Step 6: ones = ones & mask // 清除已出現三次的位\n\n        → Step 7: twos = twos & mask // 同理清除 twos 中的位\n\n→ Step 8: 返回 ones // ones 中保存的即為唯一數字\n\nEnd\n\nWe need each line with virtual code and explanation.\n\nWe can use \"→\" arrow. Also for loop we can show \"For each num in nums:\" but that's not typical pseudo. Might use \"→ Step 2: For each num in nums:\" then sub steps. Use indentation? Use spaces to indent.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: ones ← 0, twos ← 0 // 初始化記錄位出現 1 次和 2 次的變數\n→ Step 2: For each num in nums: // 循環處理每個數字\n    → Step 3: twos ← twos ∣ (ones ∧ num) // 將同時在 ones 和 num 中為 1 的位加入 twos\n    → Step 4: ones ← ones ⊕ num // 將 num 的位在 ones 中取反（模 2 的加法）\n    → Step 5: mask ← ¬(ones ∧ twos) // 需要清零的位（已出現三次）\n    → Step 6: ones ← ones ∧ mask // 清除 ones 中已完成三次的位\n    → Step 7: twos ← twos ∧ mask // 清除 twos 中已完成三次的位\n→ Step 8: Return ones // ones 內剩下的位即為唯一元素\nEnd // 程式執行結束\n\nMake sure each line has virtual code then // explanation. Use consistent arrow style. Provide indentation with spaces. Provide explanation in Traditional Chinese.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: ones ← 0, twos ← 0 // 初始化記錄位出現 1 次和 2 次的變數  \n→ Step 2: For each num in nums: // 循環處理每個數字  \n  → Step 3: twos ← twos ∣ (ones ∧ num) // 將同時在 ones 和 num 中為 1 的位加入 twos  \n  → Step 4: ones ← ones ⊕ num // 將 num 的位在 ones 中取反（模 2 的加法）  \n  → Step 5: mask ← ¬(ones ∧ twos) // 需要清零的位（已出現三次）  \n  → Step 6: ones ← ones ∧ mask // 清除 ones 中已完成三次的位  \n  → Step 7: twos ← twos ∧ mask // 清除 twos 中已完成三次的位  \n→ Step 8: Return ones // ones 內剩下的位即為唯一元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.6728779876799941,0.10504318480429505],[0.0246329919277122,0.2166626767356923],[0.17788713174310042,-0.5678570425900711]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.6728779876799941, 0.10504318480429505], [0.0246329919277122, 0.2166626767356923], [0.17788713174310042, -0.5678570425900711]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport math\nimport random\n\nclass Solution:\n    \"\"\"生成圓內均勻隨機點的類別。\"\"\"\n\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        \"\"\"\n        產生一個圓內均勻分布的隨機點。\n        - r 透過 sqrt(random()) * radius 取得均勻半徑。\n        - theta 以 [0, 2π) 之範圍內隨機選取。\n        - 轉換為直角座標並加上圓心位置。\n        \"\"\"\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    \"\"\"\n    主程式讀取標準輸入，格式為：\n    第一行：操作序列，形如 [\"Solution\", \"randPoint\", ...]\n    第二行：對應的參數，形如 [[1.0, 0.0, 0.0], [], ...]\n    執行後輸出結果列表，使用 JSON 形式（None 轉為 null）。\n    \"\"\"\n    raw = sys.stdin.read().strip().splitlines()\n    if not raw:\n        return\n\n    ops = ast.literal_eval(raw[0])\n    args_list = ast.literal_eval(raw[1]) if len(raw) > 1 else []\n\n    obj = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            method = getattr(obj, op)\n            out = method(*args)\n            results.append(out)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for generating uniform random point inside a circle. The class has constructor and randPoint method. We need virtual steps including generating random radius with sqrt to ensure uniform distribution, random angle, compute coordinates offset from center, return array. Use pseudo random generator. Provide steps with decision maybe not needed. Use Start, End.\n\nLet's produce lines:\n\nStart\n→ Step 1: 取得半徑 radius, 中心座標 x_center, y_center // 初始化變數\n→ Step 2: 在 randPoint 中, 產生隨機角度 θ ∈ [0, 2π) // 使用亂數\n→ Step 3: 產生隨機半徑 r' = sqrt( random() ) * radius // 讓分布均勻\n→ Step 4: 計算偏移 dx = r' * cos(θ), dy = r' * sin(θ) // 坐標偏移\n→ Step 5: 計算點坐標 x = x_center + dx, y = y_center + dy // 加上中心\n→ Step 6: 回傳 [x, y] // 回傳點\nEnd\n\nAdd Start/End markers. Might include Decision? Not necessary. Provide each line with comment.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得半徑 radius, 中心座標 x_center, y_center // 初始化必要變數\n→ Step 2: 在 randPoint 中, 產生隨機角度 θ ∈ [0, 2π) // 產生均勻分佈的角度\n→ Step 3: 產生隨機半徑 r' = sqrt( random() ) * radius // 使半徑分佈均勻，避免集中在中心\n→ Step 4: 計算偏移 dx = r' * cos(θ), dy = r' * sin(θ) // 根據角度計算相對座標\n→ Step 5: 計算點座標 x = x_center + dx, y = y_center + dy // 加上圓心座標得到絕對座標\n→ Step 6: 回傳 [x, y] // 回傳隨機點\nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,2,1],[1,2,3],[3,2,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [3, 2, 1], [1, 2, 3], [3, 2, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\nimport json\n\nclass Solution:\n    \"\"\"\n    這個類別用來實作數組的重設與隨機洗牌功能。\n    \"\"\"\n\n    def __init__(self, nums):\n        \"\"\"\n        初始化時儲存原始數組的副本，後續的 reset() 與 shuffle() 會依此復原。\n        \"\"\"\n        # 使用 list(nums) 可以避免傳入的可變物件被修改\n        self.original = list(nums)\n\n    def reset(self):\n        \"\"\"\n        把數組恢復成原始順序，並回傳結果。\n        \"\"\"\n        # 直接回傳原始數組的複製，避免外部修改影響內部狀態\n        return list(self.original)\n\n    def shuffle(self):\n        \"\"\"\n        隨機洗牌，採用 Fisher-Yates 演算法，確保所有排列等機率。\n        \"\"\"\n        # 先複製一次原始陣列，然後在副本上進行交換\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n - 1, 0, -1):\n            # 隨機選取 0~i 的索引\n            j = random.randint(0, i)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入，並剔除多餘空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 使用 ast.literal_eval 解析成 (operations, arguments) 的 tuple\n    # 這裡把整個輸入包成 '(' + raw + ')' 以符合 tuple 語法\n    ops, args = ast.literal_eval('(' + raw_input + ')')\n\n    # 用來儲存各次呼叫的結果\n    outputs = []\n    obj = None\n\n    # 逐一執行操作\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # arg 形如 [[1, 2, 3]]，取第一個元素作為 nums\n            obj = Solution(arg[0])\n            outputs.append(None)          # Constructor 沒有回傳值\n        elif op == \"reset\":\n            outputs.append(obj.reset())\n        elif op == \"shuffle\":\n            outputs.append(obj.shuffle())\n        else:\n            # 如果遇到未知操作，略過\n            outputs.append(None)\n\n    # 使用 json.dumps 以符合題目所示的輸出格式（null、list 等）\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem. The problem is about shuffling an array. Virtual code should include steps: storing original array, shuffle using Fisher-Yates, etc. We need to produce each line with arrow. Let's design algorithm.\n\nStart\n→ Step: Save a copy of original array in 'original'\n→ Step: Set current array 'nums' to given input\n→ End class initialization\n\nreset:\n→ Step: Copy 'original' to 'nums'\n→ Step: Return 'nums'\n\nshuffle:\n→ Step: Create a copy of 'nums' as 'shuffled'\n→ Step: For i from length-1 downto 1:\n→   Decision: Generate random index j from 0 to i\n→   Swap shuffled[i] with shuffled[j]\n→ End loop\n→ Step: Return shuffled\n\nAlso mention random generator.\n\nLet's produce virtual code with Start/End maybe inside class? Let's represent each method. Use arrow lines.\n\nWe need to produce each line with arrow and comment.\n\nWe also need to incorporate random generator.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: Solution(nums) // 建構子：接收原始整數陣列\n    → Step: original ← copy(nums) // 把原始陣列備份到 'original'\n    → Step: current ← copy(nums) // 把目前陣列設為輸入陣列\n→ End // 建構子完成\n\n→ Step: reset() // 重設陣列\n    → Step: current ← copy(original) // 把備份的原始陣列複製回 'current'\n    → Step: return current // 回傳重設後的陣列\n→ End // reset 方法完成\n\n→ Step: shuffle() // 隨機打亂陣列\n    → Step: shuffled ← copy(current) // 先複製一次目前陣列\n    → Step: for i from length(shuffled)-1 down to 1 // 從尾端向前遍歷\n        → Decision: j = random integer in [0, i] // 隨機選擇 0~i 的索引\n            → Step: swap shuffled[i] with shuffled[j] // 交換元素\n    → Step: return shuffled // 回傳打亂後的新陣列\n→ End // shuffle 方法完成\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入，支援形如 \"nums = [1,2,3]\" 或僅 \"[1,2,3]\"\n    if '=' in data:\n        _, arr_str = data.split('=', 1)\n    else:\n        arr_str = data\n    arr_str = arr_str.strip()\n    nums = ast.literal_eval(arr_str)\n\n    solution = Solution()\n    subsets = solution.subsets(nums)\n    # 用 json.dumps 產生不帶空格的列表字串\n    print(json.dumps(subsets, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm generating all subsets of unique integers array. Standard approach: backtracking or iterative. Use recursive DFS generating subsets. Output in any order. Provide explanation after each line.\n\nWe must not output actual code. Just virtual code steps.\n\nWe must follow format: each line \"虛擬碼步驟 // 解釋/說明\".\n\nUse arrows: \"→\", \"Yes →\", \"No →\", and structure: Start, End, Decision:\n\nStart // 程式開始執行\n→ Step: define result list // 存放所有子集\n→ Step: call backtrack(0, []) // 從索引0開始回溯\n... inside backtrack(index, current):\n- Append copy of current to result\n- For i from index to len(nums)-1:\n    - add nums[i] to current\n    - backtrack(i+1, current)\n    - remove last element\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step: result = [] // 初始化結果列表\n→ Step: nums_sorted = nums // 可選：排序，保證順序一致\n→ Step: call backtrack(0, []) // 開始回溯\n\nThen we need to show the backtrack function body:\n\nStep: backtrack(index, current): // 定義回溯函數\n\nBut we might need to include indentation. But the format requires each line separate.\n\nWe can represent function body with sub-indentation? Not necessary.\n\nWe can produce:\n\n→ Step: backtrack(index, current): // 定義回溯函數\n    → Step: add copy of current to result // 把當前子集加入結果\n    → Step: for i from index to len(nums)-1: // 遍歷剩餘元素\n        → Step: current.append(nums[i]) // 選擇元素\n        → Step: backtrack(i+1, current) // 進入下一層\n        → Step: current.pop() // 取消選擇\n\nEnd // 程式結束\n\nBut we must keep arrow indentation: We can use \"→\" before each step. For nested steps, we could use \"    →\" (with spaces). The example shows indentation by spaces: \"Yes →\" etc. We can replicate.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: result = [] // 初始化結果列表\n→ Step 2: nums_sorted = nums // 可選：保持原順序或排序\n→ Step 3: call backtrack(0, []) // 從索引0開始回溯\n→ Step 4: backtrack(index, current): // 定義回溯函數\n    → Step 4.1: result.append(copy of current) // 把當前子集加入結果\n    → Step 4.2: for i in range(index, len(nums_sorted)): // 遍歷剩餘元素\n        → Step 4.2.1: current.append(nums_sorted[i]) // 選擇元素\n        → Step 4.2.2: backtrack(i+1, current) // 深入下一層\n        → Step 4.2.3: current.pop() // 取消選擇\nEnd // 程式結束\n\nWe might add Decision step? Not necessary as algorithm deterministic.\n\nBut per output format we can include Decision: if we want to show if condition, but not needed.\n\nBut maybe we can show Decision: if index == len(nums_sorted) -> just add subset and return. But easier to just always add copy before exploring.\n\nWe can show Decision: if index == len(nums_sorted) // 這裡已經完成一個子集\n\nBut not needed.\n\nLet's keep simple.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result = [] // 初始化儲存所有子集的結果列表  \n→ Step 2: nums_sorted = nums // 保持原始元素順序（或可先排序以確保一致性）  \n→ Step 3: call backtrack(0, []) // 從索引 0 開始進行回溯  \n→ Step 4: backtrack(index, current): // 定義回溯函數  \n  → Step 4.1: result.append(copy of current) // 把目前的子集加入結果  \n  → Step 4.2: for i in range(index, len(nums_sorted)): // 遍歷剩餘未處理的元素  \n     → Step 4.2.1: current.append(nums_sorted[i]) // 選擇此元素加入子集  \n     → Step 4.2.2: backtrack(i+1, current) // 進一步回溯，處理後續元素  \n     → Step 4.2.3: current.pop() // 取消選擇，回到上一層  \nEnd // 程式執行結束，result 即為所有可能的子集集合"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,0,1,0,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 0, 1, 0, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport random\nimport bisect\n\nclass Solution:\n    \"\"\"\n    使用前綴和 + 二分搜尋來實作權重隨機選取。\n    \"\"\"\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 隨機產生 1 ~ total 的整數\n        target = random.randint(1, self.total)\n        # 找到第一個 prefix_sum 大於等於 target 的索引\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 解析輸入格式：[\"Method1\",\"Method2\",...], [[[args1]], [[args2]], ...]\n    # 先把整個字串包裝成 Python list，再用 ast.literal_eval 解析\n    data = ast.literal_eval(f'[{raw_input}]')\n    methods, args = data\n\n    instance = None\n    outputs = []\n\n    for method_name, arg_list in zip(methods, args):\n        if method_name == \"Solution\":\n            # 建構子，arg_list 形如 [[1,3]]，取第一個元素\n            instance = Solution(arg_list[0])\n            outputs.append(None)          # 建構子返回 null\n        else:\n            # 其它方法直接呼叫\n            func = getattr(instance, method_name)\n            result = func(*arg_list)\n            outputs.append(result)\n\n    # 以 JSON 格式輸出結果\n    print(json.dumps(outputs, ensure_ascii=False))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. The algorithm: Precompute prefix sums, total sum. pickIndex uses random uniform [0,total) and binary search or linear scan to find index. We'll output step by step. Use Start, End, Decision, etc. Provide lines with explanation. Should be in Traditional Chinese. Let's craft.\n\nStructure:\n\nStart\n→ Step 1: 建立前綴和陣列 prefix[0..n-1] // 先計算每個位置累計重量\n→ Step 2: 計算 totalWeight = prefix[n-1] // 總重量\n→ Step 3: 定義函式 pickIndex()\n→   Decision: 進入 pickIndex 邏輯? (Always yes)\n   Yes → Step 4: 產生隨機數 r 在 [0, totalWeight) // 隨機選擇一個重點\n   Yes → Step 5: 使用二分搜尋找出最小 index i 使 prefix[i] > r // 根據隨機數決定索引\n   Yes → Step 6: 回傳 index i\nEnd\n\nWe need each line with arrow and explanation. Use arrow for decisions too. Use indent? In example, they used indentation for nested steps. We'll replicate.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 計算前綴和 prefix[0..n-1] // 為每個索引累加重量，以便快速查找區間\n→ Step 2: 設定 totalWeight = prefix[n-1] // 取得整體重量總和\n→ Step 3: 定義函式 pickIndex() // 進入隨機選取邏輯\n→   Decision: 進入 pickIndex 邏輯? // 本例始終進入\n    Yes → Step 4: 產生隨機數 r 介於 0 與 totalWeight 之間 // 以總重量為範圍產生隨機數\n    Yes → Step 5: 用二分搜尋找到最小索引 i 使 prefix[i] > r // 根據 r 確定選擇的索引\n    Yes → Step 6: 回傳 index i // 返回隨機選擇的索引\nEnd // 程式執行結束"
    }
  ]
}