{
  "run_index": 19,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 387,
  "generation_or_validation_failure_count": 52,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "def main():\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrows etc. Use Start, End, Decision. Each line: virtual code step + space + // explanation.\n\nWe need to read file data.txt, count lines, output count, handle file not found with message. Use with syntax, try/except. So structure:\n\nStart\n→ Step 1: 試圖開啟 'data.txt' // 開始嘗試讀取檔案\n    → Decision: 檔案是否開啟成功? // 判斷是否進入 with 區塊\n        Yes → Step 2: 用 with 讀取檔案內容 // 以 with 開啟檔案\n        No → Step 3: 輸出 '找不到檔案！' // 檔案不存在\nBut we need to handle try/except: We wrap with try. So:\n\n→ Step 1: try\n→ Step 2: with open('data.txt', 'r') as f: // 打開檔案\n→ Step 3: count = sum(1 for line in f) // 計算行數\n→ Step 4: print(count) // 輸出行數\n→ Decision: 是否發生例外? // 判斷是否有例外\n    No → End\n    Yes → Step 5: except FileNotFoundError: // 檔案不存在\n    Step 6: print('找不到檔案！')\n→ End\n\nBut we need to include arrow lines. Use \"Decision:\" for exception? The decision arrow may be \"Decision: 是否發生 FileNotFoundError?\" Then Yes branch for exception.\n\nBut we need to reflect try/except. We could structure like:\n\n→ Step 1: try // 進入 try 區塊\n    → Decision: 檔案是否存在? // 這裡假設 try will raise if not\n        Yes → Step 2: with open('data.txt', 'r') as f: // 開啟檔案\n        No  → Step 3: 轉到 except\n→ Step 4: count = sum(1 for line in f) // 計算行數\n→ Step 5: print(count) // 輸出行數\n→ Decision: 是否發生例外? // 判斷是否進入 except\n    No → End\n    Yes → Step 6: except FileNotFoundError: // 捕捉檔案不存在錯誤\n    Step 7: print('找不到檔案！')\n→ End\n\nBut we need to keep each step one line. We cannot embed nested steps inside same line. Use indent? They used indentation in example: Indented lines inside decision. So we need to indent lines accordingly.\n\nLet's produce final output lines:\n\nStart // 程式開始執行\n→ Step 1: try // 進入 try 區塊\n    → Decision: 是否成功執行以下程式碼? // 判斷是否進入 with\n        Yes → Step 2: with open('data.txt', 'r') as f: // 用 with 開啟檔案\n            → Step 3: count = sum(1 for line in f) // 計算檔案行數\n            → Step 4: print(count) // 輸出行數\n        No  → Step 5: except FileNotFoundError: // 檔案不存在時進入 except\n            → Step 6: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式執行結束\n\nBut need to express decision about exception. Maybe easier:\n\nStart\n→ Step 1: try // 嘗試執行以下程式碼\n    → Step 2: with open('data.txt', 'r') as f: // 打開檔案\n        → Step 3: count = sum(1 for line in f) // 計算行數\n        → Step 4: print(count) // 輸出行數\n    → Decision: 是否發生 FileNotFoundError? // 判斷是否拋出例外\n        No  → End // 正常結束\n        Yes → Step 5: except FileNotFoundError: // 捕捉檔案不存在\n            → Step 6: print('找不到檔案！') // 顯示錯誤訊息\n→ End\n\nWe need to ensure each line has only one step and comment. The decision line counts as step. The indentation indicates branches.\n\nLet's produce final.\n\nMake sure each line uses the format: virtual code step + space + // explanation.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: try // 進入 try 區塊，嘗試執行以下程式碼\n    → Step 2: with open('data.txt', 'r') as f: // 用 with 語法開啟檔案\n        → Step 3: count = sum(1 for line in f) // 計算檔案中行數\n        → Step 4: print(count) // 輸出總行數\n    → Decision: 是否發生 FileNotFoundError? // 判斷是否有例外\n        No  → End // 正常結束程式\n        Yes → Step 5: except FileNotFoundError: // 捕捉檔案不存在例外\n            → Step 6: print('找不到檔案！') // 顯示錯誤訊息\n→ End // 程式執行結束\n\nCheck if indentation is consistent: In example, indentation is 4 spaces before sub-lines. Use that.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: try // 進入 try 區塊，嘗試執行以下程式碼  \n&nbsp;&nbsp;→ Step 2: with open('data.txt', 'r') as f: // 用 with 語法開啟檔案  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3: count = sum(1 for line in f) // 計算檔案中行數  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: print(count) // 輸出總行數  \n&nbsp;&nbsp;→ Decision: 是否發生 FileNotFoundError? // 判斷是否有例外  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → End // 正常結束程式  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: except FileNotFoundError: // 捕捉檔案不存在例外  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: print('找不到檔案！') // 顯示錯誤訊息  \n→ End // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[2,2,6,4,6]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[2, 2, 6, 4, 6]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\ndef main():\n    code = sys.stdin.read()\n    # execute the input code in the current global namespace\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step by step, each line with arrow and comment. Use Start, End, Decision, Step. The function roll_dice(n). Steps: import random, define function, create list, loop n times, generate random int 1-6, append to list, after loop return list. Provide in lines. Use 虛擬碼步驟.\n\nLet's output lines: Start, import, define function, Step: create list, Step: loop start, Decision? Actually we can use For loop. We might use Decision: 0? maybe not necessary. Just use loop. But we need arrow lines. Use \"→ For i from 1 to n:\".\n\nWe can do:\n\nStart // 程式開始執行\n→ Import random module // 載入 random 模組\n→ Function: roll_dice(n) // 定義 roll_dice 函數，參數 n\n    → Step: results = [] // 初始化結果列表\n    → For i in 1 to n: // 循環擲骰 n 次\n        → Step: roll = random.randint(1, 6) // 擲出 1-6 的隨機整數\n        → Step: results.append(roll) // 加入結果列表\n    → Step: return results // 回傳所有擲骰結果\nEnd // 程式結束\n\nBut we must keep formatting: each line preceded by \"→\" except function header maybe no arrow? They used \"→ Step 1:\" etc. The function header likely \"→ Function: roll_dice(n)\"? Or maybe \"→ Step: 定義函式 roll_dice\" . Let's replicate example: They used \"→ Step 1:\" etc. So we should maintain arrow on each step. Indentation? They didn't include indentation but used \"Yes →\" under Decision. So we can indent by 4 spaces for nested lines.\n\nThus:\n\nStart // 程式開始執行\n→ Import random module // 載入 random 模組\n→ Function: roll_dice(n) // 定義函數 roll_dice，參數 n\n    → Step: results = [] // 初始化結果列表\n    → For i from 1 to n: // 循環 n 次\n        → Step: roll = random.randint(1, 6) // 擲骰\n        → Step: results.append(roll) // 添加結果\n    → Step: return results // 回傳列表\nEnd // 程式結束\n\nMake sure each line has arrow and comment. Indentation shows nested. Provide as plain text. Use Traditional Chinese. Let's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import random module // 載入 random 模組  \n→ Function: roll_dice(n) // 定義函數 roll_dice，參數 n  \n → Step: results = [] // 初始化結果列表  \n → For i from 1 to n: // 循環 n 次擲骰  \n  → Step: roll = random.randint(1, 6) // 擲出 1 到 6 的隨機整數  \n  → Step: results.append(roll) // 將擲骰結果加入列表  \n → Step: return results // 回傳所有擲骰結果  \nEnd // 程式結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"測量傳入函式執行時間，回傳秒數，四捨五入至小數點第三位。\"\"\"\n    start = time.perf_counter()\n    func(*args)\n    end = time.perf_counter()\n    return round(end - start, 3)\n\ndef main():\n    # 從標準輸入讀取整個程式碼\n    script = sys.stdin.read()\n    # 建立執行環境，確保 measure_time 可用\n    namespace = {\"measure_time\": measure_time}\n    # 執行讀入的程式碼\n    exec(script, namespace)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step. Use Start, End, Decision, arrow. Provide explanation. Format: each line: 虛擬碼步驟 + space + // 解釋. Use arrows. Should include imports? The function measure_time. We need to measure time before and after, compute elapsed, round to 3 decimal places, return result.\n\nWe should include steps: import time, define function, record start, call func with args, record end, compute elapsed, round, return. That's it.\n\nMake sure to include function signature: Step: 定義函數 measure_time(func, *args) // 定義測試函數\n\nUse Step numbering.\n\nAlso include decision? Not necessary. Use arrow. So produce lines:\n\nStart\n→ Step 1: 匯入 time 模組 // 引入時間測量工具\n→ Step 2: 定義函數 measure_time(func, *args) // 建立測量時間的函式\n→ Step 3: 取得開始時間 start_time = time.perf_counter() // 記錄函式開始執行時間\n→ Step 4: 執行目標函式 result = func(*args) // 呼叫傳入的函式並傳遞參數\n→ Step 5: 取得結束時間 end_time = time.perf_counter() // 記錄函式結束時間\n→ Step 6: 計算耗時 elapsed = end_time - start_time // 兩時間相減得到秒數\n→ Step 7: 四捨五入到小數點 3 位 rounded = round(elapsed, 3) // 調整精度\n→ Step 8: 回傳 rounded // 傳回測量結果\nEnd\n\nWe might also include return of result? The function should return time only. So fine.\n\nMake sure each line ends with // explanation. Provide arrow before each step.\n\nWe need to include decision? Not needed. But we can show Decision: if needed? Not necessary.\n\nSo output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 time 模組 // 引入時間測量工具  \n→ Step 2: 定義函數 measure_time(func, *args) // 建立測量時間的函式  \n→ Step 3: 取得開始時間 start_time = time.perf_counter() // 記錄函式開始執行時間  \n→ Step 4: 執行目標函式 result = func(*args) // 呼叫傳入的函式並傳遞參數  \n→ Step 5: 取得結束時間 end_time = time.perf_counter() // 記錄函式結束時間  \n→ Step 6: 計算耗時 elapsed = end_time - start_time // 兩時間相減得到秒數  \n→ Step 7: 四捨五入到小數點 3 位 rounded = round(elapsed, 3) // 調整精度  \n→ Step 8: 回傳 rounded // 傳回測量結果  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"orange\",\"melon\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'orange', 'melon', 'apple'}\""
        }
      ],
      "generated_code": "def process_fruits():\n    \"\"\"\n    建立並操作水果集合，最後回傳結果。\n    \"\"\"\n    fruits = {'apple', 'banana'}          # 初始集合\n    fruits.add('orange')                  # 新增 orange\n    fruits.update(['grape', 'melon'])     # 同時新增 grape 與 melon\n    fruits.remove('banana')               # 移除 banana（元素存在）\n    fruits.discard('pineapple')           # 嘗試移除 pineapple（不會拋錯）\n    return fruits\n\ndef main():\n    import sys\n    # 讀取標準輸入（本題不需要任何輸入，僅保留此行符合通用要求）\n    _ = sys.stdin.read()\n    # 執行集合操作並輸出結果\n    result = process_fruits()\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. For each line: \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows, Start, End, Decision if needed. It's a set operations.\n\nWe don't need decision structure? But we could show removal that might fail; maybe use Decision: If element present? But we can simply show discard always works; we can show Decision to illustrate no error. Let's include Decision for remove, as it may raise error if missing, but we know banana exists. So maybe Decision: 是否存在 'banana'? Yes -> remove.\n\nSimilarly for discard: No error even if missing, but we could show decision to illustrate no error.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義集合 fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'\n→ Decision: 'banana' 是否在 fruits? // 檢查要移除的元素是否存在\n    Yes → Step 4: fruits.remove('banana') // 移除 'banana'\n→ Decision: 'pineapple' 是否在 fruits? // 檢查要 discard 的元素是否存在\n    No → Step 5: fruits.discard('pineapple') // discard() 會忽略不存在的元素\n→ Step 6: 輸出 fruits // 最終輸出集合\nEnd // 程式執行結束\n\nWe should use \"→\" arrow for steps. Decision block indented. Use 4 spaces indent maybe. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義集合 fruits = {'apple', 'banana'} // 初始化集合  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Decision: 'banana' 是否在 fruits? // 檢查要移除的元素是否存在  \n    Yes → Step 4: fruits.remove('banana') // 移除 'banana'  \n→ Decision: 'pineapple' 是否在 fruits? // 檢查要 discard 的元素是否存在  \n    No → Step 5: fruits.discard('pineapple') // discard() 會忽略不存在的元素  \n→ Step 6: 輸出 fruits // 最終輸出集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef get_rate_from_api() -> float:\n    \"\"\"從匯率 API 取得 USD → TWD 的匯率。\"\"\"\n    url = 'https://api.exchangerate-api.com/v4/latest/USD'\n    response = requests.get(url, timeout=10)\n    response.raise_for_status()                     # 若 HTTP 錯誤直接拋出\n    data = response.json()\n    return data['rates']['TWD']\n\ndef create_gui():\n    \"\"\"建立 tkinter GUI，並提供按鈕更新匯率。\"\"\"\n    win = tk.Tk()\n    win.title('匯率查詢')\n\n    label = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    def update_label():\n        try:\n            rate = get_rate_from_api()\n            label.config(text=f'目前美元匯率：約 {rate} TWD')\n        except Exception:\n            label.config(text='更新失敗，請檢查網路連線')\n\n    tk.Button(win, text='更新匯率', command=update_label).pack(pady=5)\n    win.mainloop()\n\ndef main():\n    \"\"\"從 stdin 讀取資料，若有輸入則即時印出最新匯率，最後啟動 GUI。\"\"\"\n    # 讀取整個輸入，移除前後空白\n    user_input = sys.stdin.read().strip()\n    if user_input:\n        try:\n            rate = get_rate_from_api()\n            # 只要有任何輸入，就輸出匯率資訊\n            print(f'目前美元匯率：約 {rate} TWD')\n        except Exception:\n            print('更新失敗，請檢查網路連線')\n    # 執行 GUI 介面\n    create_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each with \"→\" or \"Decision:\" etc. We cannot produce actual code, only pseudo steps. So we need to produce a step-by-step algorithm: Start, import modules, define function to fetch rate, set up tkinter root, label, button, function to update label, mainloop, End.\n\nWe need to follow the format: each line with \"虛擬碼步驟\" then space then comment. Use arrows, Start, End, Decision.\n\nWe must ensure each line is separate. Use Chinese explanation.\n\nLet's craft.\n\n1. Start\n2. → Step 1: Import requests and tkinter modules // 引入所需模組\n3. → Step 2: 定義函式 fetch_rate() // 用於呼叫 API 並回傳 TWD 匯率\n4. → Step 3: 在 fetch_rate() 中 ① 呼叫 requests.get(URL) // 取得 API 回應\n5. → Step 4: 在 fetch_rate() 中 ② 解析 JSON 取得 rates.TWD // 擷取台幣匯率\n6. → Step 5: 在 fetch_rate() 中 ③ 回傳匯率 // 送出結果\n7. → Step 6: 初始化 tkinter 視窗 root // 建立主畫面\n8. → Step 7: 建立 Label label_rate 並加入 root // 顯示匯率\n9. → Step 8: 建立 Button btn_update 並加入 root // 更新按鈕\n10. → Step 9: 定義函式 update_display() // 按鈕點擊時呼叫\n11. → Step 10: 在 update_display() 中 ① 取得 fetch_rate() // 取得最新匯率\n12. → Step 11: 在 update_display() 中 ② 更新 label_rate 文字為 'USD/TWD: rate' // 顯示\n13. → Step 12: 將 btn_update 的 command 指定為 update_display // 連結按鈕\n14. → Step 13: 在程式啟動時呼叫 update_display() // 初始顯示\n15. → Step 14: 執行 root.mainloop() // 開始事件迴圈\n16. End // 程式結束\n\nNeed to ensure each line is preceded by arrow or decision. There are no decisions. We just use arrows.\n\nWe should format exactly as sample: \"Start // 程式開始執行\".\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests, tkinter modules // 引入所需模組  \n→ Step 2: 定義函式 fetch_rate() // 用於呼叫 API 並回傳 TWD 匯率  \n→ Step 3: 在 fetch_rate() 中 ① 呼叫 requests.get('https://api.exchangerate-api.com/v4/latest/USD') // 取得 API 回應  \n→ Step 4: 在 fetch_rate() 中 ② 解析 JSON 並取得 rates.TWD // 擷取台幣匯率  \n→ Step 5: 在 fetch_rate() 中 ③ 回傳匯率 // 送出結果  \n→ Step 6: 初始化 tkinter 視窗 root // 建立主畫面  \n→ Step 7: 建立 Label label_rate 並加入 root // 顯示匯率  \n→ Step 8: 建立 Button btn_update 並加入 root // 更新按鈕  \n→ Step 9: 定義函式 update_display() // 按鈕點擊時呼叫  \n→ Step 10: 在 update_display() 中 ① 取得 fetch_rate() // 取得最新匯率  \n→ Step 11: 在 update_display() 中 ② 更新 label_rate 文字為 'USD/TWD: {rate}' // 顯示  \n→ Step 12: 將 btn_update 的 command 指定為 update_display // 連結按鈕  \n→ Step 13: 在程式啟動時呼叫 update_display() // 初始顯示  \n→ Step 14: 執行 root.mainloop() // 開始事件迴圈  \nEnd // 程式結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5q8zd054.py\", line 81, in <module>\n    main()\n  File \"/tmp/tmp5q8zd054.py\", line 50, in main\n    ops, args = parse_input(raw)\n                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5q8zd054.py\", line 45, in parse_input\n    args = ast.literal_eval(lines[1].strip())\n                            ~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val):\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        if val not in self.val_to_index:\n            return False\n        index = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[index] = last_val\n        self.val_to_index[last_val] = index\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.values)\n\ndef parse_input(data: str):\n    data = data.strip()\n    if not data:\n        return [], []\n    # Try splitting on the first '],'\n    if '],[' in data:\n        parts = data.split('],', 1)\n        left = parts[0] + ']'\n        right = '[' + parts[1]\n        ops = ast.literal_eval(left)\n        args = ast.literal_eval(right)\n    else:\n        lines = data.splitlines()\n        ops = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip())\n    return ops, args\n\ndef main():\n    raw = sys.stdin.read()\n    ops, args = parse_input(raw)\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            result.append(None)\n        elif op == \"insert\":\n            res = obj.insert(arg[0])\n            result.append(res)\n        elif op == \"remove\":\n            res = obj.remove(arg[0])\n            result.append(res)\n        elif op == \"getRandom\":\n            res = obj.getRandom()\n            result.append(res)\n        else:\n            # Unsupported operation\n            result.append(None)\n    # Convert to required output format\n    out_strs = []\n    for val in result:\n        if val is None:\n            out_strs.append(\"null\")\n        elif isinstance(val, bool):\n            out_strs.append(\"true\" if val else \"false\")\n        else:\n            out_strs.append(str(val))\n    print(f\"[{', '.join(out_strs)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for implementing RandomizedSet. We'll produce a structured algorithm: maintain vector and hashmap. Each operation: insert O(1) by checking map, push to vector, update map. Remove O(1) by swapping with last element, pop_back, update map. getRandom O(1) by random index. We'll provide virtual code line by line with comments. Use Start, End, Decision, etc. Probably we need separate steps for class initialization and methods. Each method could be separate block. We'll output a linear representation. Let's craft.\n\nWe'll do:\n\nStart // 程式開始\n\n→ Step: 定義 RandomizedSet 物件 // 設置資料結構\n\nBut we need line by line for all methods.\n\nLet's produce like:\n\nStart // 程式開始\n→ Step: 定義 RandomizedSet // 建立類別\n    → Field: list // 儲存元素的陣列\n    → Field: map // 值到索引的映射\n    → Constructor: RandomizedSet() // 初始化空結構\n        → list ← 空陣列 // 設為空陣列\n        → map ← 空字典 // 設為空映射\n    → Method: insert(val) // 插入元素\n        → Decision: map 中是否包含 val? // 判斷是否已存在\n            Yes → Return false // 已存在，插入失敗\n            No  → \n                → list.追加 val // 將值追加至陣列尾端\n                → map[val] ← list.長度 - 1 // 將索引存入映射\n                → Return true // 插入成功\n    → Method: remove(val) // 移除元素\n        → Decision: map 中是否包含 val? // 判斷是否存在\n            Yes →\n                → idx ← map[val] // 取得該值的索引\n                → last ← list.最後一個元素 // 取得最後一個元素\n                → list[idx] ← last // 將最後元素移至被刪除位置\n                → map[last] ← idx // 更新最後元素的索引\n                → list.移除最後一個元素 // 刪除尾端\n                → map.刪除(val) // 移除映射\n                → Return true // 成功移除\n            No  → Return false // 不存在，移除失敗\n    → Method: getRandom() // 取得隨機元素\n        → idx ← 隨機整數 [0, list.長度-1] // 隨機索引\n        → Return list[idx] // 回傳對應元素\nEnd // 程式結束\n\nBut the output format: each line must contain virtual code step + space + comment.\n\nWe need to keep indentation perhaps but the arrow lines.\n\nWe should not use actual code like list.最後一個元素; but we use natural language pseudo code.\n\nWe also must include arrows.\n\nWe'll produce like:\n\nStart // 程式開始\n→ Step: 定義 RandomizedSet // 建立類別\n    → Field: list // 用於儲存元素\n    → Field: map // 用於存儲元素到索引的映射\n    → Constructor: RandomizedSet() // 初始化\n        → list ← 空陣列 // 初始化為空\n        → map ← 空字典 // 初始化為空\n    → Method: insert(val) // 插入元素\n        → Decision: map 包含 val? // 判斷是否已存在\n            Yes → Return false // 已存在，插入失敗\n            No  → \n                → list 追加 val // 將 val 放入尾部\n                → map[val] ← list.長度 - 1 // 記錄索引\n                → Return true // 插入成功\n    → Method: remove(val) // 移除元素\n        → Decision: map 包含 val? // 判斷是否存在\n            Yes →\n                → idx ← map[val] // 取得索引\n                → last ← list.最後一個元素 // 取得最後元素\n                → list[idx] ← last // 把最後元素移到 idx\n                → map[last] ← idx // 更新映射\n                → list.移除最後一個元素 // 刪除尾部\n                → map.刪除(val) // 刪除映射\n                → Return true // 成功\n            No  → Return false // 不存在，移除失敗\n    → Method: getRandom() // 取得隨機元素\n        → idx ← 隨機整數 0 到 list.長度-1 // 隨機索引\n        → Return list[idx] // 回傳元素\nEnd // 程式結束\n\nWe need to ensure each line ends with comment after space.\n\nBut the structure with indentation may confuse. Each line must be a step; we might need to avoid nested arrows but use indentation to show nested steps. The example shows indentation under Decision. So we can replicate.\n\nWe must ensure each line uses the arrow (→) for steps, Decision lines have \"Decision:\" preceding. For the indentation inside Decision, lines start with appropriate arrow indent but we need to maintain arrow. For Yes / No we can use \"Yes →\" and \"No →\". The example shows \"Yes → Step 2:\" etc. So we replicate.\n\nThus we will produce lines as:\n\nStart // 程式開始\n→ Step: 定義 RandomizedSet // 建立類別\n    → Field: list // 用於儲存元素\n    → Field: map // 用於儲存元素到索引的映射\n    → Constructor: RandomizedSet() // 初始化空結構\n        → list ← 空陣列 // 初始化為空\n        → map ← 空字典 // 初始化為空\n    → Method: insert(val) // 插入元素\n        → Decision: map 包含 val? // 判斷是否已存在\n            Yes → Return false // 已存在，插入失敗\n            No  → \n                → list 追加 val // 將 val 放入尾部\n                → map[val] ← list.長度 - 1 // 記錄索引\n                → Return true // 插入成功\n    → Method: remove(val) // 移除元素\n        → Decision: map 包含 val? // 判斷是否存在\n            Yes → \n                → idx ← map[val] // 取得索引\n                → last ← list.最後一個元素 // 取得最後元素\n                → list[idx] ← last // 把最後元素移到 idx\n                → map[last] ← idx // 更新映射\n                → list.移除最後一個元素 // 刪除尾部\n                → map.刪除(val) // 刪除映射\n                → Return true // 成功\n            No → Return false // 不存在，移除失敗\n    → Method: getRandom() // 取得隨機元素\n        → idx ← 隨機整數 0 到 list.長度-1 // 隨機索引\n        → Return list[idx] // 回傳元素\nEnd // 程式結束\n\nBut the indentation should be with 4 spaces maybe. Each line after indentation still starts with arrow. The example uses \"→ Decision:\" line, then indent the Yes / No lines with spaces then \"Yes →\". So we should follow that.\n\nThus the final output will be as above.\n\nDouble-check: Each line must contain the virtual code step and comment. The comment must start after a space and after the step. For the lines inside decision, we need to include \"Decision:\" then maybe the condition. For Yes and No, we have \"Yes →\" lines with step.\n\nWe should keep \"Decision:\" before condition? Example: \"→ Decision: 如果數字大於 0?\" So we should write \"→ Decision: map 包含 val?\" So we need \"Decision:\" with condition after. Good.\n\nFor the nested steps after Yes/No, we start with \"→\" but we also used \"Yes →\" for the line? The example uses \"Yes → Step 2: ...\". So we should prefix with \"Yes →\" but the step after Yes. In our code, we had \"Yes → Return false\". That is correct. For No case, we had \"No  →\" then nested. But inside No branch we had a step \"→ list 追加 val\". That's fine.\n\nWe need to keep alignment: \"No  →\" with two spaces maybe. Example shows \"No  → Decision:\" with two spaces between No and arrow? They used \"No  → Decision:\" with two spaces between No and arrow. So we replicate.\n\nThus final output.\n...done thinking.\n\nStart // 程式開始  \n→ Step: 定義 RandomizedSet // 建立類別  \n → Field: list // 用於儲存元素  \n → Field: map // 用於儲存元素到索引的映射  \n → Constructor: RandomizedSet() // 初始化空結構  \n  → list ← 空陣列 // 初始化為空  \n  → map ← 空字典 // 初始化為空  \n → Method: insert(val) // 插入元素  \n  → Decision: map 包含 val? // 判斷是否已存在  \n   Yes → Return false // 已存在，插入失敗  \n   No  →  \n    → list 追加 val // 將 val 放入尾部  \n    → map[val] ← list.長度 - 1 // 記錄索引  \n    → Return true // 插入成功  \n → Method: remove(val) // 移除元素  \n  → Decision: map 包含 val? // 判斷是否存在  \n   Yes →  \n    → idx ← map[val] // 取得索引  \n    → last ← list.最後一個元素 // 取得最後元素  \n    → list[idx] ← last // 把最後元素移到 idx  \n    → map[last] ← idx // 更新映射  \n    → list.移除最後一個元素 // 刪除尾部  \n    → map.刪除(val) // 刪除映射  \n    → Return true // 成功  \n   No → Return false // 不存在，移除失敗  \n → Method: getRandom() // 取得隨機元素  \n  → idx ← 隨機整數 0 到 list.長度-1 // 隨機索引  \n  → Return list[idx] // 回傳元素  \nEnd // 程式結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[1,0],[2,0],[0,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [1, 0], [2, 0], [0, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\nimport json\n\nclass Solution:\n    \"\"\"\n    這個類別用來模擬一個 m x n 的二元矩陣，最初全為 0。\n    flip() 會隨機選擇一個還為 0 的位置並把它改成 1，並回傳該位置。\n    reset() 會把所有位置都重設回 0。\n    \"\"\"\n\n    def __init__(self, m, n):\n        # 行列數\n        self.rows = m\n        self.cols = n\n        # 總位置數量\n        self.total = m * n\n        # 用來映射已被選過的位置的字典\n        self.flipped = {}\n\n    def flip(self):\n        \"\"\"\n        隨機挑選一個仍為 0 的位置，將其轉為 1，並回傳其行列座標。\n        \"\"\"\n        # 在剩餘未被選的位置中隨機挑選一個索引\n        r = random.randint(0, self.total - 1)\n        # 取得真正的線性索引，如果映射表中已有對應則取映射值\n        x = self.flipped.get(r, r)\n        # 把已選的位置從可用總數中移除\n        self.total -= 1\n        # 把 r 這個位置映射到一個可用的「最後一個」位置\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        # 轉換回行列座標\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        \"\"\"\n        把整個矩陣重設為全 0。\n        \"\"\"\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 分離兩個列表：方法名稱與對應參數\n    split_idx = data.find('],')\n    if split_idx == -1:\n        raise ValueError(\"Invalid input format\")\n    methods_part = data[:split_idx + 1]\n    args_part = data[split_idx + 2:].strip()\n\n    # 轉成 Python 物件\n    methods = ast.literal_eval(methods_part)\n    args = ast.literal_eval(args_part)\n\n    result = []\n    sol = None\n    for name, param in zip(methods, args):\n        if name == 'Solution':\n            sol = Solution(*param)\n            result.append(None)\n        elif name == 'flip':\n            result.append(sol.flip())\n        elif name == 'reset':\n            sol.reset()\n            result.append(None)\n\n    # 輸出結果，使用 JSON 以符合示例中的 null 表示\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the algorithm. The algorithm: use reservoir style mapping or mapping from 0..m*n-1 indices; maintain available count and map. For flip: choose random k from 0..available-1; map to actual index using map; decrement available; if mapping contains index, use mapped value else same; then map random index to that value. For reset: clear map and reset available to m*n.\n\nWe need to output steps line by line with virtual code and explanation.\n\nLet's produce algorithm steps:\n\nStart class Solution\n\nInitialize: m, n, total=m*n, available=total, map empty\n\nflip(): if available==0 throw error or maybe return? but not needed. choose randIdx = random integer between 0 and available-1. get actualIdx = map.getOrDefault(randIdx, randIdx). Then decrement available. if available in map? then set map.put(randIdx, map.getOrDefault(available, available)). else map.put(randIdx, available). Then compute row = actualIdx / n, col = actualIdx % n. return [row, col].\n\nreset(): available=total; clear map.\n\nWe need to format each line: \"Start //...\" etc. Use arrow syntax.\n\nLet's output in order:\n\nStart // 程式開始執行\n→ Step 1: 定義 Solution 類別 // 建立類別\n→ Step 2: Solution(int m, int n) 初始化 m, n, total = m*n, available = total, map = 空映射 // 初始化變數\n→ Decision: 是否需要額外操作？ // 這裡直接完成初始化\n    No → End // 初始化結束\n\nThen flip:\n\n→ Step 3: flip() // 產生隨機位置\n→ Decision: 如果 available == 0? // 檢查是否還有空位\n    Yes → Step 4: 返回錯誤或 null // 無空位\n    No  → Step 5: 隨機產生 randIdx 介於 0 與 available-1 // 隨機選擇可用索引\n→ Step 6: actualIdx = map.getOrDefault(randIdx, randIdx) // 取得實際索引\n→ Step 7: available = available - 1 // 從可用數量中扣除\n→ Step 8: If map.containsKey(available) then map.put(randIdx, map.get(available)) else map.put(randIdx, available) // 更新映射\n→ Step 9: row = actualIdx / n; col = actualIdx % n // 轉換為行列\n→ Step 10: return [row, col] // 回傳位置\n\nreset:\n\n→ Step 11: reset() // 重置矩陣\n→ Step 12: available = total // 重新設為全數\n→ Step 13: map.clear() // 清空映射\n→ End // 完成\n\nNeed to keep each line with \"虛擬碼步驟 // 解釋\". Ensure arrow syntax as specified: \"Start\", \"End\", \"Decision:\" etc.\n\nAlso we need to maintain consistent indent style with arrow.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Solution 類別 // 建立類別  \n→ Step 2: Solution(int m, int n) 初始化 m, n, total = m*n, available = total, map = 空映射 // 初始化變數  \n→ Decision: 是否需要額外操作？ // 這裡直接完成初始化  \n    No → End // 初始化結束  \n\n→ Step 3: flip() // 產生隨機位置  \n→ Decision: 是否還有空位? // 檢查可用索引是否為零  \n    Yes → Step 4: 返回錯誤或 null // 無空位可選  \n    No  → Step 5: 隨機產生 randIdx 介於 0 與 available-1 // 選取可用範圍內的隨機索引  \n→ Step 6: actualIdx = map.getOrDefault(randIdx, randIdx) // 取得實際映射索引  \n→ Step 7: available = available - 1 // 可用數量減一  \n→ Step 8: If map.containsKey(available) Then map.put(randIdx, map.get(available)) Else map.put(randIdx, available) // 更新映射以保留剩餘空位  \n→ Step 9: row = actualIdx / n; col = actualIdx % n // 將線性索引轉換為行列座標  \n→ Step 10: return [row, col] // 回傳選取的座標  \n\n→ Step 11: reset() // 重置矩陣  \n→ Step 12: available = total // 重新設為全數  \n→ Step 13: map.clear() // 清空映射  \n→ End // 程式執行結束"
    },
    {
      "title": "Teemo Attacking",
      "source_file": "Leetcode/leetcode495.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2x47cqj1.py\", line 35, in <module>\n    timeSeries, duration = parse_input(raw_input)\n                           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2x47cqj1.py\", line 26, in parse_input\n    values['timeSeries'] = ast.literal_eval(val)\n                           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzo9n0hf5.py\", line 35, in <module>\n    timeSeries, duration = parse_input(raw_input)\n                           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzo9n0hf5.py\", line 26, in parse_input\n    values['timeSeries'] = ast.literal_eval(val)\n                           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries, duration):\n        total = 0\n        last_end = 0\n        for t in timeSeries:\n            if t >= last_end:\n                total += duration\n            else:\n                total += t + duration - last_end\n            last_end = t + duration\n        return total\n\ndef parse_input(raw):\n    \"\"\"\n    解析輸入字串，支持類似\n    \"timeSeries = [1,4], duration = 2\" 的格式。\n    \"\"\"\n    parts = raw.replace(' ', '').split(',')\n    values = {}\n    for part in parts:\n        key, val = part.split('=')\n        if key == 'timeSeries':\n            values['timeSeries'] = ast.literal_eval(val)\n        elif key == 'duration':\n            values['duration'] = int(val)\n    return values['timeSeries'], values['duration']\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    timeSeries, duration = parse_input(raw_input)\n    sol = Solution()\n    result = sol.findPoisonedDuration(timeSeries, duration)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve problem. Provide line-by-line explanation.\n\nAlgorithm: iterate through timeSeries, accumulate total. For each attack time t, compute overlap with previous attack tPrev. If t - tPrev >= duration, add duration to total. Else add t + duration - tPrev? Actually add (duration - (t - tPrev))? Let's think: If t - prev < duration, overlap. The new effective poison extends to t + duration - 1. The new added time is (t + duration - 1) - prev - duration + 1? Wait simpler: maintain last_end. Initially 0. For each t, if t >= last_end, total += duration; else total += t + duration - last_end. Update last_end = t + duration. Finally return total.\n\nSo produce virtual code.\n\nWe need to output in format each line with virtual code and explanation. Use arrows and decisions.\n\nLet's craft:\n\nStart\n→ Declare total = 0\n→ Declare last_end = 0\n→ For each t in timeSeries:\n    → Decision: If t >= last_end?\n        Yes → total += duration\n        No  → total += t + duration - last_end\n    → Update last_end = t + duration\n→ Return total\nEnd\n\nNeed comments.\n\nLet's produce each line. Use proper indentation.\n\nNote: Use Start, End markers.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ total ← 0 // 初始化總毒秒數  \n→ last_end ← 0 // 之前毒效結束時間的初始化  \n\n→ For each attack_time in timeSeries: // 遍歷每一次攻擊時間  \n  Decision: attack_time ≥ last_end? // 判斷此次攻擊是否在上一個毒效結束之後  \n   Yes → total ← total + duration // 沒重疊，直接加上完整毒持續時間  \n   No  → total ← total + (attack_time + duration - last_end) // 有重疊，僅加上未被覆蓋的時間  \n  last_end ← attack_time + duration // 更新毒效結束時間為此次攻擊後 duration 秒  \n\n→ Return total // 回傳總毒秒數  \nEnd // 程式結束執行"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpumhf2p38.py\", line 57, in <module>\n    main()\n  File \"/tmp/tmpumhf2p38.py\", line 36, in main\n    args = ast.literal_eval(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\n                                                                              ^\nSyntaxError: unmatched ']'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split the two lists: operations and arguments\n    try:\n        ops_part, args_part = data.split('],', 1)\n    except ValueError:\n        # If input is malformed, exit\n        return\n    ops_part += ']'\n    args_part = '[' + args_part.lstrip(' [')  # ensure proper brackets\n\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    result = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MagicDictionary\":\n            obj = MagicDictionary()\n            result.append(None)          # null in JSON\n        elif op == \"buildDict\":\n            obj.buildDict(arg[0] if isinstance(arg, list) else arg)\n            result.append(None)\n        elif op == \"search\":\n            res = obj.search(arg[0] if isinstance(arg, list) else arg)\n            result.append(res)\n        else:\n            result.append(None)\n\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudo code for the described class and methods, step-by-step, using arrow style. Provide each line with explanation comment after //.\n\nWe should include building dict, storing words maybe in a trie or a set, but we can also store length groups. For search: iterate over dictionary or generate all variants by changing one character.\n\nPseudo code must not be actual code; but structure lines with steps. We'll produce algorithm description.\n\nWe'll produce like:\n\nStart // 初始化\n→ MagicDictionary() // 建構子\n    → Step: 初始化空的集合 or trie // \n→ buildDict(dictionary) // 設定字典\n    → Step: For each word in dictionary\n        → Add word to data structure // \n→ search(searchWord) // 搜尋\n    → Step: For each index i in searchWord\n        → For each letter 'a' to 'z'\n            → If letter != searchWord[i]\n                → Construct newWord = replace char at i with letter\n                → If newWord exists in dictionary\n                    → Return true\n    → Return false\nEnd\n\nAlso maybe store words in a set for O(1) lookup.\n\nWe must produce each line with \"虛擬碼步驟\" and comment. Let's produce lines accordingly.\n\nWe'll need to use arrow lines.\n\nWe'll also include decision steps.\n\nLet's create pseudo code:\n\nStart // 程式開始執行\n→ MagicDictionary() // 建構子：初始化資料結構\n    → Step: 定義空集合 dictionarySet // 用來存放單字\n→ buildDict(dictArray) // 建立字典\n    → Decision: 是否為空陣列? // 檢查輸入是否為空\n        Yes → End // 空則結束\n        No → Step: For each word in dictArray\n            → Step: dictionarySet.add(word) // 加入集合\n→ search(searchWord) // 搜尋功能\n    → Step: For i from 0 to length of searchWord - 1\n        → Step: originalChar = searchWord[i] // 取得原字元\n        → Step: For each c in 'a'..'z'\n            → Decision: c == originalChar? // 是否相同\n                Yes → No → // 跳過相同字元\n                No  → Step: newWord = searchWord with char at i replaced by c // 生成變體\n                    → Decision: newWord 在 dictionarySet? // 判斷是否存在\n                        Yes → Return true // 找到符合條件\n                        No  → // 繼續\n    → Return false // 未找到\nEnd // 程式結束\n\nWe need to maintain arrow for decision and branches.\n\nAlso mention that we use set lookup.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ MagicDictionary() // 建構子：初始化資料結構  \n    → Step: dictionarySet ← 空集合 // 用來存放字典中的單字  \n→ buildDict(dictArray) // 建立字典  \n    → Decision: 如果 dictArray 為空? // 檢查輸入是否為空陣列  \n        Yes → End // 空則結束本方法  \n        No  → Step: 循環遍歷 dictArray 中每個 word  \n            → Step: dictionarySet.add(word) // 將單字加入集合以便 O(1) 查詢  \n→ search(searchWord) // 搜尋功能：判斷是否能改一個字元得到字典中的單字  \n    → Step: 對 searchWord 的每個位置 i 從 0 到 length-1  \n        → Step: 原始字元 originalChar ← searchWord[i]  \n        → Step: 循環字母 c 從 'a' 到 'z'  \n            → Decision: c 是否等於 originalChar? // 不改動則跳過  \n                Yes → No → // 跳過相同字元  \n                No  → Step: newWord ← searchWord，將位置 i 的字元改為 c // 產生一個變體  \n                    → Decision: newWord 是否存在於 dictionarySet? // 判斷是否匹配  \n                        Yes → Return true // 找到符合條件，立即返回  \n                        No  → // 繼續嘗試下一個字母  \n    → Return false // 所有變體都未匹配，返回假  \nEnd // 程式執行結束"
    },
    {
      "title": "Find K Closest Elements",
      "source_file": "Leetcode/leetcode658.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "arr = [1,2,3,4,5], k = 4, x = 3",
          "expected_output": "[1,2,3,4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpft55xrhb.py\", line 44, in <module>\n    arr, k, x = parse_input()\n                ^^^^^^^^^^^^^\n  File \"/tmp/tmpft55xrhb.py\", line 34, in parse_input\n    arr = eval(arr_str)      # 安全性可自行強化\n          ^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "arr = [1,1,2,3,4,5], k = 4, x = -1",
          "expected_output": "[1,1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp718m403o.py\", line 44, in <module>\n    arr, k, x = parse_input()\n                ^^^^^^^^^^^^^\n  File \"/tmp/tmp718m403o.py\", line 34, in parse_input\n    arr = eval(arr_str)      # 安全性可自行強化\n          ^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\ndef find_closest_elements(arr, k, x):\n    \"\"\"\n    找出陣列 arr 中最接近 x 的 k 個整數。\n    參考解法：二分搜尋找最小起始位置。\n    \"\"\"\n    n = len(arr)\n    left, right = 0, n - k          # 搜尋窗口的左端點\n    while left < right:\n        mid = (left + right) // 2\n        # 比較左右兩端距離 x 的差值\n        if x - arr[mid] > arr[mid + k] - x:\n            left = mid + 1\n        else:\n            right = mid\n    return arr[left:left + k]       # 從 left 開始取 k 個元素\n\ndef parse_input():\n    \"\"\"\n    讀取並解析輸入，預期格式類似：\n    arr = [1,2,3,4,5], k = 4, x = 3\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return None, None, None\n    parts = [p.strip() for p in data.split(',')]\n    arr = []\n    k = None\n    x = None\n    for part in parts:\n        if part.startswith('arr'):\n            arr_str = part.split('=', 1)[1].strip()\n            arr = eval(arr_str)      # 安全性可自行強化\n        elif part.startswith('k'):\n            k_str = part.split('=', 1)[1].strip()\n            k = int(k_str)\n        elif part.startswith('x'):\n            x_str = part.split('=', 1)[1].strip()\n            x = int(x_str)\n    return arr, k, x\n\nif __name__ == \"__main__\":\n    arr, k, x = parse_input()\n    if arr is not None and k is not None and x is not None:\n        result = find_closest_elements(arr, k, x)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve problem: given sorted array, k and x, find k closest integers to x, return sorted ascending.\n\nWe need to produce step-by-step pseudocode lines with comments.\n\nWe need to think algorithm: Since array sorted, we can find position of x via binary search to get insertion point. Then use two pointers to expand window of size k. Complexity O(log n + k). Steps: binary search to find index of first element >= x (lower bound). Then left pointer = idx-1, right pointer = idx. While window size < k, compare left and right values closeness to x; choose closer one (if one side out of bounds choose other). After selecting, move pointer accordingly. Finally, gather selected indices sorted ascending. Since we may collect unsorted order but we can sort at end or just output subarray from left+1 to right. Because we are expanding outward, the resulting subarray between left+1 and right is contiguous and sorted ascending. So we can simply output arr[left+1: right+1].\n\nEdge cases: left < 0 or right >= n.\n\nSo produce pseudocode:\n\nStart\n→ Step: n = length(arr)\n→ Step: find idx via binary search lower bound of x // index of first element >= x\n→ Decision: if idx == n? // x greater than all elements\n    Yes → left = n-1; right = n; // no right side\n    No → left = idx-1; right = idx; // initial window\n→ Step: selectedCount = 0\n→ While selectedCount < k:\n    → Decision: left < 0? // no left element\n        Yes → right = right + 1; // take from right\n        No → Decision: right >= n? // no right element\n            Yes → left = left - 1; // take from left\n            No → Decision: |arr[left] - x| <= |arr[right] - x|? // left closer or tie\n                Yes → left = left - 1; // take left\n                No  → right = right + 1; // take right\n    → selectedCount = selectedCount + 1\n→ Step: result = arr[left+1 : right] // slice subarray\n→ End\n\nNeed to output each line with arrow or indentation. Use arrow for decision branches. Provide comments.\n\nLet's craft.\n\nBe careful with syntax: we need to use arrows for decision branches. Indentation with tabs? Use spaces.\n\nWe need to produce each line with \"虛擬碼步驟\" then space then comment.\n\nLet's produce.\n\nWe'll need to indicate steps like:\n\nStart // ...\n→ Step: n ← length(arr) // ...\n→ Step: idx ← binarySearchLowerBound(arr, x) // ...\n\nIn decision branches, use indentation.\n\nMake sure each line ends with // comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: n ← length(arr) // 取得陣列長度  \n→ Step: idx ← binarySearchLowerBound(arr, x) // 找到第一個 ≥ x 的索引  \n→ Decision: 如果 idx == n? // x 大於所有元素  \n  Yes → left ← n-1; right ← n // 只可以往左取  \n  No  → left ← idx-1; right ← idx // 初始化左右指標  \n→ Step: selectedCount ← 0 // 已選取元素數量  \n→ While selectedCount < k: // 仍需再選 k 個元素  \n  → Decision: 如果 left < 0? // 沒有左邊可取  \n    Yes → right ← right + 1 // 從右邊取  \n    No  → Decision: 如果 right ≥ n? // 沒有右邊可取  \n      Yes → left ← left - 1 // 從左邊取  \n      No  → Decision: |arr[left]-x| ≤ |arr[right]-x|? // 左右距離相同或左較近  \n        Yes → left ← left - 1 // 從左邊取  \n        No  → right ← right + 1 // 從右邊取  \n  → Step: selectedCount ← selectedCount + 1 // 更新已選取數量  \n→ Step: result ← arr[left+1 : right] // 取左+1 到 right-1 的子陣列（已升序）  \nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxot8rbl_.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmpxot8rbl_.py\", line 37, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpxot8rbl_.py\", line 14, in __init__\n    self.lookup[(pref, suff)] = weight\n    ~~~~~~~~~~~^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    def __init__(self, words):\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            # Store all combinations of prefixes and suffixes\n            for i in range(L + 1):\n                pref = word[:i]\n                for j in range(L + 1):\n                    suff = word[j:]\n                    self.lookup[(pref, suff)] = weight\n\n    def f(self, prefix, suffix):\n        return self.lookup.get((prefix, suffix), -1)\n\ndef main():\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Ensure the string can be parsed as a tuple of (words, [pref, suff])\n    if not data.startswith('('):\n        data = '(' + data\n    if not data.endswith(')'):\n        data = data + ')'\n    try:\n        words, params = ast.literal_eval(data)\n    except Exception:\n        # Fallback: split by the first comma separating the two top-level lists\n        parts = data.split(',', 1)\n        words = ast.literal_eval(parts[0].strip())\n        params = ast.literal_eval(parts[1].strip())\n    pref, suff = params\n    wf = WordFilter(words)\n    result = wf.f(pref, suff)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this problem. The user says \"Design a special dictionary that searches the words in it by a prefix and a suffix. Implement WordFilter class: WordFilter(string[] words) initializes object. f(string pref, string suff) returns index of word with prefix and suffix, largest index if multiple, else -1.\"\n\nWe need to output virtual code steps, each line with explanation, using arrows etc. Not actual code.\n\nSo produce steps: Start, initialize data structure: maybe use Trie for prefixes and suffixes combined with index. Common solution: Build a hash map from combined prefix + \"#\" + suffix to max index. Or use a combined trie.\n\nSimplify: Use a dictionary mapping combined key to max index. For each word, for each prefix i and suffix j compute key, store max index. For query, look up pref + \"#\" + suff. Complexity large but okay.\n\nAlternatively, build a trie of reversed words and another trie of words, then traverse both and find intersection.\n\nBut virtual code just outlines high-level algorithm.\n\nWe need step-by-step, with decision arrows etc. Not actual code, but algorithm skeleton.\n\nLet's outline:\n\nStart\n→ Step 1: Store words array // keep original words\n→ Step 2: For each word index i, generate all prefixes and suffixes // precompute keys\n→ Step 3: For each prefix and suffix, create key = prefix + \"#\" + suffix\n→ Step 4: In hashmap, set key to max(i, current value) // ensure largest index\nEnd initialization\n\nf function:\nStart\n→ Step 5: Build key = pref + \"#\" + suff\n→ Decision: If key in hashmap?\n    Yes → Step 6: Return hashmap[key] // largest index\n    No  → Step 7: Return -1\nEnd\n\nBut also need to handle no such word: return -1.\n\nMaybe also discuss complexity.\n\nLet's produce virtual code lines accordingly, with explanations.\n\nWe should incorporate arrow \"→\" for each step, indentation for decisions.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 儲存輸入 words 陣列 // 方便後續索引查詢\n→ Step 2: 初始化空哈希表 keyToIndex // 用於快速查找 (prefix#suffix → index)\n→ Decision: 迭代 words 陣列？\n    Yes → Step 3: 取出索引 i 與對應 word\n        → Step 4: 產生所有可能前綴 prefList // 逐字符累加\n        → Step 5: 產生所有可能後綴 suffList // 逐字符累加\n        → Step 6: 迭代 prefList 和 suffList 形成 key = pref + \"#\" + suff\n            → Step 7: 更新 keyToIndex[key] = max(current, i) // 取最大索引\n        → End Step 6\n    No  → End // 初始化結束\nEnd // 初始化完成\n\nNow function f:\n\nStart // f 方法執行\n→ Step 8: 形成查詢 key = pref + \"#\" + suff\n→ Decision: key 是否存在於 keyToIndex？\n    Yes → Step 9: 回傳 keyToIndex[key] // 最大符合索引\n    No  → Step 10: 回傳 -1 // 無符合字\nEnd // f 方法結束\n\nThat's the virtual code.\n\nWe should maintain line numbers? Not required.\n\nJust output each line with explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 儲存輸入 words 陣列 // 方便後續索引查詢  \n→ Step 2: 初始化空哈希表 keyToIndex // 用於快速查找 (prefix#suffix → index)  \n→ Decision: 迭代 words 陣列？  \n    Yes → Step 3: 取出索引 i 與對應 word // 為每個單字產生所有鍵  \n        → Step 4: 產生所有可能前綴 prefList // 逐字符累加  \n        → Step 5: 產生所有可能後綴 suffList // 逐字符累加  \n        → Step 6: 迭代 prefList 和 suffList 形成 key = pref + \"#\" + suff  \n            → Step 7: 更新 keyToIndex[key] = max(current, i) // 取最大索引  \n        → End Step 6  \n    No → End // 初始化結束  \nEnd // 初始化完成  \n\nStart // f 方法執行  \n→ Step 8: 形成查詢 key = pref + \"#\" + suff // 直接拼接前綴與後綴  \n→ Decision: key 是否存在於 keyToIndex？  \n    Yes → Step 9: 回傳 keyToIndex[key] // 最大符合索引  \n    No  → Step 10: 回傳 -1 // 無符合字  \nEnd // f 方法結束"
    },
    {
      "title": "IPO",
      "source_file": "Leetcode/leetcode502.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdj98ip5v.py\", line 26, in <module>\n    parsed_val = ast.literal_eval(val)\n                 ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpdj98ip5v.py\", line 29, in <module>\n    parsed_val = eval(val, {}, {})\n                 ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqrnffn6x.py\", line 26, in <module>\n    parsed_val = ast.literal_eval(val)\n                 ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpqrnffn6x.py\", line 29, in <module>\n    parsed_val = eval(val, {}, {})\n                 ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\n\n# ----------------------------------------------------------\n# 主程式：從標準輸入讀取資料、計算最大資本並輸出\n# ----------------------------------------------------------\nif __name__ == \"__main__\":\n    # 讀取所有輸入文字\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析類似 'k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]'\n    # 轉成 dict: {'k': 2, 'w': 0, 'profits': [1,2,3], 'capital': [0,1,1]}\n    vars_dict = {}\n    for part in raw_input.split(','):\n        part = part.strip()\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        try:\n            # 安全解析字面值\n            parsed_val = ast.literal_eval(val)\n        except Exception:\n            # 如字面值解析失敗，直接 eval (只允許安全字面值)\n            parsed_val = eval(val, {}, {})\n        vars_dict[key] = parsed_val\n\n    # 提取必要變數\n    k = vars_dict.get('k', 0)\n    w = vars_dict.get('w', 0)\n    profits = vars_dict.get('profits', [])\n    capital = vars_dict.get('capital', [])\n\n    # ----------------------------------------------------------\n    # 計算最大可達資本\n    # ----------------------------------------------------------\n    # 將專案按需資本排序，方便一次性加入所有可執行專案\n    projects = sorted(zip(capital, profits))\n    max_profit_heap = []  # 優先選取最高利潤的專案\n    idx = 0\n    n = len(profits)\n\n    for _ in range(k):\n        # 把所有當前資本能負擔的專案推進最大堆疊\n        while idx < n and projects[idx][0] <= w:\n            # 用負數模擬最大堆疊（heapq 只實作最小堆疊）\n            heapq.heappush(max_profit_heap, -projects[idx][1])\n            idx += 1\n\n        # 若沒有可選擇的專案，結束迴圈\n        if not max_profit_heap:\n            break\n\n        # 選取最高利潤的專案，完成後資本增加\n        w += -heapq.heappop(max_profit_heap)\n\n    # 輸出最終最大資本\n    print(w)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for solving the classic Leetcode problem \"Maximum Capital\" (LeetCode 502). We should design algorithm: use min-heap for capital, max-heap for profits. Steps: sort projects by capital, push profits of eligible projects into max-heap. For k times, if no projects available, break. Pop max profit, add to capital. Continue.\n\nWe output each line with comment. Use Start, End, Decision, etc. Use arrow. Provide explanation after each line.\n\nWe need to produce step-by-step pseudocode with comments.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 建立兩個堆疊  // 用於管理可執行專案\n    →  minCapitalHeap ← 空堆疊（按 capital 排序）\n    →  maxProfitHeap ← 空堆疊（按 profits 最大優先）\n    // minCapitalHeap 讓我們快速找到最小 capital 的專案\n    // maxProfitHeap 讓我們快速挑選最高 profit 的專案\n\n→ Step 2: 將所有專案以 (capital, profit) 放入 minCapitalHeap  \n    // 這樣可以根據需要的最小資本快速挑選可執行的專案\n\n→ Step 3: 取 w ← 初始資本  \n    // 這是我們開始時可用的資本\n\n→ Step 4: 取 k ← 可執行的最多專案數  \n    // 這是限制的上限\n\n→ Step 5: 為 i 從 1 到 k 做以下步驟  \n    // 逐個選擇最多 k 個專案\n\n    → Decision: 若 minCapitalHeap 為空? // 無任何專案可執行\n        No  → Break // 無需再進行選擇，直接結束\n\n    → While minCapitalHeap 的最小 capital ≤ w 做以下  \n        // 把所有當前可負擔的專案搬到 maxProfitHeap\n        → Step 6: Pop top (c, p) 從 minCapitalHeap  \n            // 取得最小 capital 的專案\n        → Step 7: Push p 到 maxProfitHeap  \n            // 將其 profit 加入可選擇池\n\n    → Decision: 若 maxProfitHeap 為空? // 仍無可選擇專案\n        No  → Break // 無法再提升資本，結束循環\n\n    → Step 8: Pop max profit pMax 從 maxProfitHeap  \n        // 選擇目前能帶來最大利潤的專案\n\n    → Step 9: w ← w + pMax  \n        // 完成專案後將利潤加入資本\n\nEnd // 程式執行結束，w 即為最終最大資本值\n\n// 輸出 w 作為答案（已在 Step 9 更新）"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\ndef remove_invalid_parentheses(s: str):\n    # 先計算需要刪除的左括號和右括號數量\n    left_rem, right_rem = 0, 0\n    for ch in s:\n        if ch == '(':\n            left_rem += 1\n        elif ch == ')':\n            if left_rem == 0:\n                right_rem += 1\n            else:\n                left_rem -= 1\n\n    result_set = set()\n\n    def dfs(idx, left_rem, right_rem, open_cnt, path):\n        if idx == len(s):\n            if left_rem == 0 and right_rem == 0 and open_cnt == 0:\n                result_set.add(path)\n            return\n\n        ch = s[idx]\n\n        # 1. 若是左括號，可選擇刪除或保留\n        if ch == '(':\n            if left_rem > 0:\n                dfs(idx + 1, left_rem - 1, right_rem, open_cnt, path)\n            dfs(idx + 1, left_rem, right_rem, open_cnt + 1, path + '(')\n\n        # 2. 若是右括號，可選擇刪除或保留（前提是有未配對的左括號）\n        elif ch == ')':\n            if right_rem > 0:\n                dfs(idx + 1, left_rem, right_rem - 1, open_cnt, path)\n            if open_cnt > 0:\n                dfs(idx + 1, left_rem, right_rem, open_cnt - 1, path + ')')\n\n        # 3. 若是字母，直接保留\n        else:\n            dfs(idx + 1, left_rem, right_rem, open_cnt, path + ch)\n\n    dfs(0, left_rem, right_rem, 0, \"\")\n    return list(result_set)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並嘗試去除前綴 's = ' 和引號\n    raw_input = sys.stdin.read().strip()\n    if '=' in raw_input:\n        _, value = raw_input.split('=', 1)\n        raw_input = value.strip()\n    raw_input = raw_input.strip('\"').strip(\"'\")\n    result = remove_invalid_parentheses(raw_input)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code, with lines like \"Start\", \"→ Step ...\", etc. We must not output real code, only the virtual steps. The algorithm: remove minimum parentheses, produce all valid strings. Standard solution: BFS exploring removal states or DFS with counting. We'll produce pseudo-code: compute counts of left and right to remove, then DFS backtracking generating valid strings.\n\nWe must produce virtual steps line by line, with explanations. We'll include Start, end, decision branches, etc. Let's produce a BFS approach:\n\n- Start\n- Step 1: Compute remove counts L and R by scanning string.\n- Step 2: Define DFS function.\n- Step 3: In DFS, if index == length: if leftCount==0 && rightCount==0: add result to set.\n- Step 4: Decision: current char is '('? if leftCount>0 then explore removing it.\n- Step 5: Decision: current char is ')'? if rightCount>0 then explore removing it.\n- Step 6: Decision: if char is '(' -> add char and decrement leftCount.\n- Step 7: Decision: if char is ')' -> add char only if leftCount>rightCount? Actually we need maintain balance; we keep count of opened parentheses in the string being built. So we need param openCount. So DFS has params index, leftRem, rightRem, openCount, path.\n- Step 8: If char is letter: always add.\n- etc.\n\nLet's produce a clear virtual code.\n\nWe'll incorporate Decision nodes.\n\nLet's produce lines:\n\nStart\n→ Step 1: Count leftRem and rightRem to remove // compute number of '(' and ')' to delete\n→ Step 2: Initialize resultSet // 存放所有唯一合法字串\n→ Step 3: Define function DFS(idx, leftRem, rightRem, openCnt, current) // 回溯\n    → Decision: idx == len(s)? // 已處理完字串\n        Yes → Decision: leftRem==0 and rightRem==0 and openCnt==0? // 無剩餘括號\n            Yes → Step 4: Add current to resultSet // 收錄合法字串\n            No  → Step 5: Return // 不是合法狀態，回退\n        No  → Step 6: Let c = s[idx] // 取當前字元\n        → Decision: c == '('?\n            Yes → \n                → Decision: leftRem > 0? // 先嘗試刪除 '('\n                    Yes → Step 7: DFS(idx+1, leftRem-1, rightRem, openCnt, current) // 刪除並遞迴\n                → Step 8: DFS(idx+1, leftRem, rightRem, openCnt+1, current + '(') // 保留 '('\n            No  → \n                → Decision: c == ')'\n                    Yes →\n                        → Decision: rightRem > 0? // 嘗試刪除 ')'\n                            Yes → Step 9: DFS(idx+1, leftRem, rightRem-1, openCnt, current) // 刪除\n                        → Decision: openCnt > 0? // 若有未匹配 '(' 則可保留 ')'\n                            Yes → Step 10: DFS(idx+1, leftRem, rightRem, openCnt-1, current + ')')\n                    No  → // c 是字母\n                        → Step 11: DFS(idx+1, leftRem, rightRem, openCnt, current + c) // 直接加入字母\n    // end of DFS\n→ Step 12: Call DFS(0, leftRem, rightRem, 0, \"\") // 開始遞歸\n→ Step 13: Return list(resultSet) // 把集合轉成清單回傳\nEnd\n\nWe need each line prefixed with \"→\" for steps inside but we can use indentation. We'll show each line separately.\n\nWe must ensure each line is \"虛擬碼步驟 [空格] // 解釋\". Use arrow where appropriate.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: Compute leftRem and rightRem by scanning s // 先算需要刪除的左右括號數量\n→ Step 2: Initialize resultSet // 用於存放唯一合法字串\n→ Step 3: Define function DFS(idx, leftRem, rightRem, openCnt, current) // 回溯搜索\n    → Decision: idx == len(s) ?\n        Yes → Decision: leftRem==0 and rightRem==0 and openCnt==0 ?\n            Yes → Step 4: Add current to resultSet // 收集合法字串\n            No  → Step 5: Return // 不是合法結構，回退\n        No  → Step 6: Let c = s[idx] // 取得當前字元\n        → Decision: c == '(' ?\n            Yes →\n                → Decision: leftRem > 0 ?\n                    Yes → Step 7: DFS(idx+1, leftRem-1, rightRem, openCnt, current) // 刪除 '('\n                → Step 8: DFS(idx+1, leftRem, rightRem, openCnt+1, current + '(') // 保留 '('\n            No →\n                → Decision: c == ')' ?\n                    Yes →\n                        → Decision: rightRem > 0 ?\n                            Yes → Step 9: DFS(idx+1, leftRem, rightRem-1, openCnt, current) // 刪除 ')'\n                        → Decision: openCnt > 0 ?\n                            Yes → Step 10: DFS(idx+1, leftRem, rightRem, openCnt-1, current + ')') // 保留 ')'\n                    No →\n                        → Step 11: DFS(idx+1, leftRem, rightRem, openCnt, current + c) // 加入字母\n// End of DFS definition\n→ Step 12: Call DFS(0, leftRem, rightRem, 0, \"\") // 開始回溯\n→ Step 13: Return list(resultSet) // 把集合轉成清單回傳\nEnd // 程式執行結束\n\nNeed each line separate. Use proper indentation maybe but not required. Ensure each line has the pattern.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Compute leftRem and rightRem by scanning s // 先算需要刪除的左右括號數量  \n→ Step 2: Initialize resultSet // 用於存放唯一合法字串  \n→ Step 3: Define function DFS(idx, leftRem, rightRem, openCnt, current) // 回溯搜索  \n    → Decision: idx == len(s) ?  \n        Yes → Decision: leftRem==0 and rightRem==0 and openCnt==0 ?  \n            Yes → Step 4: Add current to resultSet // 收集合法字串  \n            No  → Step 5: Return // 不是合法結構，回退  \n        No  → Step 6: Let c = s[idx] // 取得當前字元  \n        → Decision: c == '(' ?  \n            Yes →  \n                → Decision: leftRem > 0 ?  \n                    Yes → Step 7: DFS(idx+1, leftRem-1, rightRem, openCnt, current) // 刪除 '('  \n                → Step 8: DFS(idx+1, leftRem, rightRem, openCnt+1, current + '(') // 保留 '('  \n            No →  \n                → Decision: c == ')' ?  \n                    Yes →  \n                        → Decision: rightRem > 0 ?  \n                            Yes → Step 9: DFS(idx+1, leftRem, rightRem-1, openCnt, current) // 刪除 ')'  \n                        → Decision: openCnt > 0 ?  \n                            Yes → Step 10: DFS(idx+1, leftRem, rightRem, openCnt-1, current + ')') // 保留 ')'  \n                    No →  \n                        → Step 11: DFS(idx+1, leftRem, rightRem, openCnt, current + c) // 加入字母  \n→ Step 12: Call DFS(0, leftRem, rightRem, 0, \"\") // 開始回溯  \n→ Step 13: Return list(resultSet) // 把集合轉成清單回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar III",
      "source_file": "Leetcode/leetcode732.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,2,3,3,3]'\nGot (Norm):      '[None,1,1,2,3,3,3]'\n--- (Raw) ---\nRaw Expected: '[null, 1, 1, 2, 3, 3, 3]'\nRaw Got:      '[None, 1, 1, 2, 3, 3, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport bisect\n\nclass MyCalendarThree:\n    def __init__(self):\n        # timeline stores (time, delta) where delta is +1 for start and -1 for end\n        self.timeline = []\n\n    def book(self, start, end):\n        # insert start and end markers in sorted order\n        bisect.insort(self.timeline, (start, 1))\n        bisect.insort(self.timeline, (end, -1))\n        active = 0\n        max_active = 0\n        # sweep through timeline to find max concurrent events\n        for time, delta in self.timeline:\n            active += delta\n            if active > max_active:\n                max_active = active\n        return max_active\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Expect input like: ['MyCalendarThree', 'book', ...], [[...], [...], ...]\n    ops, args_list = ast.literal_eval(data)\n    calendar = None\n    results = []\n    for op, args in zip(ops, args_list):\n        if op == \"MyCalendarThree\":\n            calendar = MyCalendarThree()\n            results.append(None)\n        elif op == \"book\":\n            res = calendar.book(*args)\n            results.append(res)\n        else:\n            # ignore unknown operations\n            results.append(None)\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for MyCalendarThree class with method book that tracks maximum overlap count. Approach: use sweep line with difference array or segment tree. Simpler: maintain list of events and count overlapping intervals each time? For each book call, we can increment counters in a map of start and end events. Keep track of maximum concurrent events via map of time -> delta.\n\nPseudo: On book(start,end): map[start]++ ; map[end]-- ; iterate map sorted keys to compute running sum and track max. Complexity O(N log N). Provide virtual code lines.\n\nLet's produce Start, Decision etc. Probably we need to handle method call and return value.\n\nWe'll produce:\n\nStart\n→ Step 1: 初始化空的有序映射 timeDelta // 用於儲存時間點差值\n→ Step 2: Method book(start, end) // 開始預訂\n→ Step 3: timeDelta[start] += 1 // 起始時間增加一次\n→ Step 4: timeDelta[end] -= 1 // 結束時間減少一次\n→ Step 5: current = 0 // 當前同時預訂數\n→ Step 6: maxOverlap = 0 // 最大重疊數\n→ Step 7: Decision: 是否存在剩餘時間點? // 迭代時間順序\n        Yes → Step 8: current += timeDelta[time] // 更新計數\n        Yes → Step 9: maxOverlap = max(maxOverlap, current) // 更新最大值\n        No  → Step 10: return maxOverlap // 返回結果\nEnd\n\nWe need to fit the required format: each line with \"虛擬碼步驟 // 解釋\". Use \"→\" arrow for steps. Use Decision lines as indicated.\n\nAlso include Start and End lines.\n\nMake sure each line is separate. Provide explanation after space.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空的有序映射 timeDelta // 用於儲存時間點的增量與減量  \n→ Step 2: Method book(start, end) // 開始處理一次預訂  \n→ Step 3: timeDelta[start] += 1 // 在開始時間點記錄一次預訂增量  \n→ Step 4: timeDelta[end] -= 1 // 在結束時間點記錄一次預訂減量  \n→ Step 5: current = 0 // 初始化目前同時預訂的數量  \n→ Step 6: maxOverlap = 0 // 初始化最大重疊數量  \n→ Decision: 是否還有時間點要處理? // 循環遍歷時間點以計算重疊  \n  Yes → Step 7: current += timeDelta[time] // 更新目前同時預訂數  \n  Yes → Step 8: maxOverlap = max(maxOverlap, current) // 如有需要更新最大值  \n  No  → Step 9: return maxOverlap // 所有時間點處理完畢，回傳最大 k-booking  \nEnd // 程式執行結束"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprfdolxab.py\", line 41, in <module>\n    args = json.loads(args_str)\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 4 (char 3)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self):\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        if self.min_stack and val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self):\n        if not self.stack:\n            return None\n        return self.stack[-1]\n\n    def getMin(self):\n        if not self.min_stack:\n            return None\n        return self.min_stack[-1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Split the input into two parts: operations and arguments\n    parts = data.split('],[')\n    ops_str = parts[0] + ']'\n    args_str = '[' + parts[1] + ']'\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    stack = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MinStack\":\n            stack = MinStack()\n            results.append(None)\n        elif op == \"push\":\n            stack.push(arg[0])\n            results.append(None)\n        elif op == \"pop\":\n            stack.pop()\n            results.append(None)\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"getMin\":\n            results.append(stack.getMin())\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output pseudo-code lines with comments, using the specified format. We must design a MinStack with O(1) operations. The standard approach: maintain two stacks: main stack and min stack. On push, push val to stack, and push min(val, current min) to min stack. On pop, pop both. On top, return top of main stack. On getMin, return top of min stack.\n\nNeed to use Start, End, Decision etc. The requirement: each line \"虛擬碼步驟\" + space + \"// 解釋\". Use arrows → and decision.\n\nLet's produce pseudo-code. Should we include class definitions? Likely need to show initialization and methods.\n\nWe'll format:\n\nStart // 程式開始執行\n→ Step 1: 建立 MinStack 物件 // 初始化兩個堆疊\n...\n\nBut need to show functions.\n\nLet's create pseudo-code:\n\nStart // 程式開始執行\n→ Step 1: 定義 MinStack 類別 // 建立資料結構\n    → Step 2: 內部變數: mainStack, minStack // 兩個堆疊\n→ Step 3: 定義 Constructor MinStack() // 建構子\n    → Step 4: 初始化 mainStack 為空 // 主堆疊\n    → Step 5: 初始化 minStack 為空 // 最小值堆疊\n→ Step 6: 定義 Method push(val) // 入棧\n    → Step 7: mainStack.push(val) // 將值加入主堆疊\n    → Decision: minStack 是否為空? // 檢查 minStack\n        Yes → Step 8: minStack.push(val) // 若為空，push val\n        No  → Step 9: currentMin = minStack.top() // 取得目前最小值\n             → Step 10: minStack.push(min(val, currentMin)) // 推入較小值\n→ Step 11: 定義 Method pop() // 出棧\n    → Decision: mainStack 是否為空? // 檢查堆疊\n        Yes → Step 12: return // 若空，直接返回\n        No  → Step 13: mainStack.pop() // 移除主堆疊頂部\n             → Step 14: minStack.pop() // 同時移除 minStack\n→ Step 15: 定義 Method top() // 取得頂部\n    → Decision: mainStack 是否為空? // 檢查堆疊\n        Yes → Step 16: return null // 空時返回 null\n        No  → Step 17: return mainStack.top() // 返回主堆疊頂部\n→ Step 18: 定義 Method getMin() // 取得最小值\n    → Decision: minStack 是否為空? // 檢查堆疊\n        Yes → Step 19: return null // 空時返回 null\n        No  → Step 20: return minStack.top() // 返回 minStack 頂部\nEnd // 程式執行結束\n\nBut we need each line as \"虛擬碼步驟\" + space + \"// 解釋\". So we need to prefix each with \"Start\", \"→ Step 1:\" etc. And we should include arrows. The arrows are in the pseudo-code steps like \"→\". So each line should begin with \"Start\" or \"→ Step X:\" or \"Decision:\". We need to maintain structure.\n\nThe decision lines: \"Decision: minStack 是否為空?\" and then the two branches: \"Yes → Step 8:\" etc. Should each branch be a separate line. The sample shows \"Decision: 如果數字大於 0?\" and then indented lines \"Yes → Step 2:\" etc. They use indentation maybe but not necessary. Use spaces or maybe tabs. We'll replicate: \"Decision:\" line then indented lines.\n\nBut we must maintain each line as one line: each step with comment.\n\nWe may include indentation but it's still a line. The sample uses indentation but still each line is separate.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MinStack 類別 // 建立資料結構  \n&nbsp;&nbsp;→ Step 2: 內部變數: mainStack, minStack // 兩個堆疊，分別儲存數值與最小值  \n→ Step 3: 定義 Constructor MinStack() // 建構子  \n&nbsp;&nbsp;→ Step 4: mainStack = 空堆疊 // 初始化主堆疊  \n&nbsp;&nbsp;→ Step 5: minStack = 空堆疊 // 初始化最小值堆疊  \n→ Step 6: 定義 Method push(val) // 入棧操作  \n&nbsp;&nbsp;→ Step 7: mainStack.push(val) // 把值加入主堆疊  \n&nbsp;&nbsp;→ Decision: minStack 是否為空? // 判斷最小值堆疊是否已有元素  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 8: minStack.push(val) // 若為空，直接把 val 作為最小值  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 9: currentMin = minStack.top() // 取得目前最小值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 10: minStack.push( min(val, currentMin) ) // 把較小者推入最小值堆疊  \n→ Step 11: 定義 Method pop() // 出棧操作  \n&nbsp;&nbsp;→ Decision: mainStack 是否為空? // 檢查是否有可出棧的元素  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 12: return // 若空，直接返回  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 13: mainStack.pop() // 移除主堆疊頂部  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 14: minStack.pop() // 同時移除最小值堆疊頂部  \n→ Step 15: 定義 Method top() // 取得頂部元素  \n&nbsp;&nbsp;→ Decision: mainStack 是否為空? // 檢查堆疊是否有元素  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 16: return null // 空時回傳 null  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 17: return mainStack.top() // 返回主堆疊頂部  \n→ Step 18: 定義 Method getMin() // 取得最小值  \n&nbsp;&nbsp;→ Decision: minStack 是否為空? // 檢查最小值堆疊是否有元素  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 19: return null // 空時回傳 null  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 20: return minStack.top() // 返回最小值堆疊頂部  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder",
      "source_file": "Leetcode/leetcode127.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: list[str]) -> int:\n        # 若起點即為終點，最短路徑長度為 1\n        if beginWord == endWord:\n            return 1\n\n        word_set = set(wordList)\n        # 目標字若不在字典，無法轉換\n        if endWord not in word_set:\n            return 0\n\n        queue = deque([(beginWord, 1)])  # (當前單字, 目前路徑長度)\n\n        while queue:\n            word, length = queue.popleft()\n            # 將已使用的單字移除，避免重複訪問\n            if word in word_set:\n                word_set.remove(word)\n\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c == word[i]:\n                        continue\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word == endWord:\n                        return length + 1\n                    if new_word in word_set:\n                        queue.append((new_word, length + 1))\n        return 0\n\ndef solve() -> None:\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入格式轉成 dict：{beginWord: \"hit\", endWord: \"cog\", wordList: [...]}\n    try:\n        parsed = ast.literal_eval('{' + data + '}')\n    except Exception as e:\n        # 若解析失敗，直接輸出 0\n        print(0)\n        return\n\n    beginWord = parsed.get('beginWord')\n    endWord = parsed.get('endWord')\n    wordList = parsed.get('wordList', [])\n\n    # 取得答案並輸出\n    solution = Solution()\n    result = solution.ladderLength(beginWord, endWord, wordList)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: Word Ladder problem, find length of shortest transformation sequence. Use BFS. Steps: check endWord in wordList; create set; BFS queue; visited; while queue; for each word, for each position generate all possible single-letter changes; if neighbor equals endWord, return level+1; if in set and not visited, enqueue and mark visited. If none, return 0. Also beginWord may not be in list but we treat accordingly. Need to produce each line with explanation.\n\nUse virtual code arrows and decisions. Let's produce steps:\n\nStart\n→ Check endWord in wordList // if not, return 0\n→ Build wordSet from wordList // for O(1) lookup\n→ Initialize queue with beginWord and level 1 // level counts words\n→ Mark beginWord visited (optional)\n→ While queue not empty // BFS loop\n    → Dequeue currentWord, level\n    → For each position i in currentWord\n        → For each letter c from 'a' to 'z'\n            → If c same as currentWord[i] continue\n            → Build nextWord by replacing char\n            → If nextWord == endWord return level+1\n            → If nextWord in wordSet and not visited\n                → Enqueue nextWord with level+1\n                → Mark visited\n→ End // not found\n→ Return 0\n\nAlso need to handle visited set.\n\nWe must format each line: Virtual code step followed by space then // explanation.\n\nUse arrows: \"→\" before step. For decision: \"Decision:\".\n\nMake sure to include Start, End. Use \"Start\" at top and \"End\" at bottom. For loops and condition, we use \"Decision:\" lines.\n\nAlso use indentation maybe? Not necessary but can.\n\nLet's craft.\n\nNeed to keep consistent formatting: \"→ Step: ...\" etc.\n\nBetter to use \"→\" before each step. For loops, can embed inside \"Decision:\".\n\nLet's produce.\n\nWe'll start:\n\nStart // 程式開始執行\n\n→ Decision: 是否 endWord 於 wordList? // 檢查目標字在字典中\n    Yes → // 若存在，繼續\n    No  → End // 若不存在，直接結束返回 0\n\nBut we need to return 0 if not found. So we can have:\n\n→ Decision: endWord 在 wordList 內? // 判斷是否可達\n    No  → End // 若不在，直接輸出 0\n    Yes → // 繼續\n\nBut we cannot return value in End? We'll just treat End as returning 0. But we need to show the return step.\n\nMaybe we include \"→ Return 0 // 目標字不在字典，無法轉換\" then \"End\".\n\nBut the output is virtual code, not actual code.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Decision: endWord 於 wordList? // 檢查是否可達\n    No  → Step: Return 0 // 無法轉換，直接結束\n    Yes → // 繼續\n\nBut we need to maintain flow.\n\nLet's produce more structured:\n\nStart // 程式開始執行\n→ Decision: endWord 於 wordList 內? // 先確認目標字存在\n    No  → Step: Return 0 // 目標字不存在，無法完成轉換\n    Yes → // 目標字存在，繼續執行\n\n→ Step: 建立 wordSet = set(wordList) // 用於快速查找\n→ Step: 初始化 queue = [(beginWord, 1)] // 以元組儲存字與層級\n→ Step: visited = set([beginWord]) // 記錄已訪問字\n\n→ Decision: queue 非空? // BFS 主迴圈\n    No  → Step: Return 0 // 未找到目標，結束\n    Yes → // 進入迴圈\n\nInside loop:\n\n→ Step: currentWord, level = queue.pop(0) // 取出隊首字\n→ Step: for i in range(len(currentWord)) // 遍歷每個位置\n    → Step: for c in 'abcdefghijklmnopqrstuvwxyz' // 替換字母\n        → Decision: c == currentWord[i]? // 若相同則跳過\n            Yes → // skip\n            No  → // 產生新字\n        → Step: nextWord = currentWord[:i] + c + currentWord[i+1:] // 生成新字\n        → Decision: nextWord == endWord? // 檢查是否已到目標\n            Yes → Step: Return level + 1 // 找到最短路徑\n            No  → // 進一步處理\n        → Decision: nextWord in wordSet AND nextWord not in visited? // 可行且未訪問\n            Yes → Step: queue.append((nextWord, level + 1)) // 加入隊列\n                     Step: visited.add(nextWord) // 標記已訪問\n            No  → // 不加入\n\nAfter loop finishes, return 0.\n\nLet's produce final lines. Ensure each line ends with // explanation. Use \"→\" before each step, and \"Decision:\" lines. Use indentation maybe not necessary but we can indent under Decision branches for readability.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: endWord 於 wordList 內? // 首先檢查目標字是否存在於字典  \n No  → Step: Return 0 // 若不存在，無法完成轉換，直接結束  \n Yes → // 若存在，繼續往下進行  \n→ Step: 建立 wordSet = set(wordList) // 用 set 方便 O(1) 查找  \n→ Step: 初始化 queue = [(beginWord, 1)] // 以元組儲存字與當前層級（含 beginWord）  \n→ Step: visited = set([beginWord]) // 記錄已訪問字以避免重複  \n→ Decision: queue 非空? // 進入 BFS 主迴圈  \n No  → Step: Return 0 // 若無任何可處理項目，結束並返回 0  \n Yes → // 進入迴圈  \n  → Step: currentWord, level = queue.pop(0) // 取出隊首字和其層級  \n  → Step: for i in range(len(currentWord)) // 遍歷字的每個位置  \n    → Step: for c in 'abcdefghijklmnopqrstuvwxyz' // 嘗試所有字母替換  \n      → Decision: c == currentWord[i]? // 若相同則跳過  \n       Yes → // skip  \n       No  → // 生成新的可能字  \n        → Step: nextWord = currentWord[:i] + c + currentWord[i+1:] // 生成新字  \n        → Decision: nextWord == endWord? // 檢查是否已到目標  \n         Yes → Step: Return level + 1 // 找到最短轉換序列，返回其長度  \n         No  → // 進一步判斷是否可加入隊列  \n         → Decision: nextWord in wordSet AND nextWord not in visited? // 可行且未訪問  \n          Yes → Step: queue.append((nextWord, level + 1)) // 加入隊列繼續搜尋  \n            Step: visited.add(nextWord) // 標記為已訪問  \n          No  → // 若不符合條件，則不加入  \n→ Step: Return 0 // 若 BFS 完結仍未找到 endWord，返回 0  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # Build a mapping from number to list of indices\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        # Randomly choose one of the indices where nums[i] == target\n        return random.choice(self.num_indices[target])\n\ndef parse_input(data):\n    \"\"\"\n    Split the input string into two parts: commands list and arguments list.\n    The split is performed at the first comma that is not nested inside brackets.\n    \"\"\"\n    depth = 0\n    split_index = None\n    for i, ch in enumerate(data):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            split_index = i\n            break\n    if split_index is None:\n        raise ValueError(\"Input format is incorrect.\")\n    left = data[:split_index].strip()\n    right = data[split_index + 1:].strip()\n    commands = ast.literal_eval(left)\n    args = ast.literal_eval(right)\n    return commands, args\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    commands, args = parse_input(raw_input)\n\n    outputs = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            # Initialize the object\n            obj = Solution(arg[0])\n            outputs.append(None)\n        elif cmd == \"pick\":\n            # Call pick method and store result\n            result = obj.pick(arg[0])\n            outputs.append(result)\n        else:\n            # In case of unknown command, append None\n            outputs.append(None)\n\n    # Convert Python None to JSON null\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step.\n\nWe need to show initialization and pick method. Use Start, End, Decision. Each line with // explanation.\n\nWe must not produce real code, just steps.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize Solution with nums // store array\n→ Step 2: Build mapping from number to list of indices? But random choose on the fly? Approach: Use reservoir sampling on the fly.\n\nSimpler: in pick, we iterate array, maintain count of matches and when match occurs, randomly select with probability 1/count.\n\nLet's produce steps for pick.\n\nAlso maybe we precompute mapping for fast? The problem typical uses reservoir sampling.\n\nWe'll produce generic virtual code:\n\nSolution constructor:\n- Store array nums\n- Could build dictionary mapping from number to list of indices if want O(1). But we can just store.\n\nPick method:\n- Initialize result = -1\n- Initialize count = 0\n- For i from 0 to length-1:\n  - If nums[i] == target:\n    - count += 1\n    - With probability 1/count choose i as result\n- Return result\n\nOk produce steps.\n\nUse Decision: probability test? We'll include: Decision: generate random number r between 0 and 1; if r < 1/count.\n\nBut we can say: Decision: Randomly decide whether to select current index with probability 1/count.\n\nLet's produce code lines.\n\nMake sure each line starts with '→' except Start/End. Provide explanation.\n\nLet's produce:\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Solution(int[] nums) ← Store reference to nums // 保存傳入的陣列以供後續使用\n→ Step 2: End // 建構子結束\n\nStart // pick 方法執行\n→ Step 3: int pick(int target) ← 初始化 result = -1 // 記錄最終選取的索引\n→ Step 4: int count = 0 // 計算目前為止遇到的目標值個數\n→ Step 5: for i from 0 to nums.length-1 do // 逐個檢查陣列元素\n    → Decision: nums[i] == target? // 是否為目標值\n        Yes → Step 6: count += 1 // 增加匹配數量\n        → Decision: 隨機選擇本索引的概率是否為 1/count? // 檢查是否選中\n            Yes → Step 7: result = i // 本次選中，更新結果索引\n            No  → // 保持現有結果\n        No  → // 非目標值，跳過\n→ Step 8: return result // 回傳等機率選中的索引\nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[1,0],[0,1],[3,2],[2,4]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[1, 0], [0, 1], [3, 2], [2, 4]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        word_to_index = {word: i for i, word in enumerate(words)}\n        res = []\n        seen = set()\n\n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                # If prefix is palindrome, check reverse of suffix\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in word_to_index:\n                        idx = word_to_index[rev_suffix]\n                        if idx != i and (idx, i) not in seen:\n                            res.append([idx, i])\n                            seen.add((idx, i))\n\n                # If suffix is palindrome, check reverse of prefix\n                # Avoid duplicate when suffix is empty (j == len(word))\n                if j != len(word) and suffix == suffix[::-1]:\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in word_to_index:\n                        idx = word_to_index[rev_prefix]\n                        if idx != i and (i, idx) not in seen:\n                            res.append([i, idx])\n                            seen.add((i, idx))\n\n        # Special handling for empty string\n        if '' in word_to_index:\n            empty_idx = word_to_index['']\n            for j, w in enumerate(words):\n                if j == empty_idx:\n                    continue\n                if (empty_idx, j) not in seen:\n                    res.append([empty_idx, j])\n                    seen.add((empty_idx, j))\n                if (j, empty_idx) not in seen:\n                    res.append([j, empty_idx])\n                    seen.add((j, empty_idx))\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Extract the list part between the first '[' and the last ']'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        words = []\n    else:\n        list_str = data[start:end + 1]\n        words = ast.literal_eval(list_str)\n\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm to find all palindrome pairs in array words, unique strings. We need O(total length) runtime. This is typical solution: build map of word to index, reverse words, etc. Use suffix/prefix splits. Steps: build map from word to index. For each word, for each split (including empty) check palindrome prefix/suffix and reverse matches. Also handle empty string special. Also duplicates? unique.\n\nWe need to produce virtual code lines with explanations, not actual code. Use arrow structure. Let's produce algorithm steps.\n\nWe'll include Start, End, Decision nodes.\n\nWe need to produce steps line by line. Let's outline:\n\nStart\n→ Build map word_to_index\n→ For each word with index i\n   → For each split position k from 0 to len(word)\n        → Let prefix = word[0:k], suffix = word[k:]\n        → Decision: prefix is palindrome?\n            Yes → Let rev_suffix = reverse(suffix)\n                → Decision: rev_suffix in map and map[rev_suffix] != i\n                    Yes → Add pair (map[rev_suffix], i)\n        → Decision: suffix is palindrome? and k != len(word) // avoid duplicate empty\n            Yes → Let rev_prefix = reverse(prefix)\n                → Decision: rev_prefix in map and map[rev_prefix] != i\n                    Yes → Add pair (i, map[rev_prefix])\n   → Decision: word == \"\" (empty)\n        Yes → For each j not equal i\n             → Add pair (i, j) and (j, i)\nEnd\n\nBut we need O(total length) complexity. Splitting loops over len(word) each word, total O(total length). Good.\n\nWe'll produce virtual code lines accordingly.\n\nNeed to include Decision nodes for each check.\n\nLet's format:\n\nStart // 程式開始\n→ Build map word_to_index from each word to its index // 建立字串到索引的對照表\n→ For each word with index i\n    → For each split position k from 0 to length(word)\n        → Define prefix = word[0:k], suffix = word[k:]\n        → Decision: prefix is palindrome?\n            Yes → rev_suffix = reverse(suffix)\n                → Decision: rev_suffix in map AND rev_suffix_index != i?\n                    Yes → Append pair (rev_suffix_index, i)\n        → Decision: suffix is palindrome? AND k < length(word) // avoid empty suffix duplication\n            Yes → rev_prefix = reverse(prefix)\n                → Decision: rev_prefix in map AND rev_prefix_index != i?\n                    Yes → Append pair (i, rev_prefix_index)\n    → Decision: word is empty string?\n        Yes → For each j from 0 to words.length-1\n            Decision: j != i?\n                Yes → Append pair (i, j) and (j, i)\nEnd // 程式結束\n\nBut we need each line as \"虛擬碼步驟 // 解釋\". Use arrow for flow. Use indentation perhaps. Use \"Decision:\" and \"Yes →\" \"No →\". We'll write each line accordingly.\n\nLet's produce.\n...done thinking.\n\n```\nStart // 程式開始\n→ Build map word_to_index // 建立字串對應索引表\n→ For each word with index i // 逐字檢查\n    → For each split position k from 0 to length(word) // 依字長分割\n        → Define prefix = word[0:k], suffix = word[k:] // 取得前後片段\n        → Decision: prefix is palindrome? // 前半段是否為迴文\n            Yes → rev_suffix = reverse(suffix) // 反轉後半段\n                → Decision: rev_suffix exists in map AND map[rev_suffix] != i? // 反向後半段是否為已有字串\n                    Yes → Append pair (map[rev_suffix], i) // 加入 (j,i) 對\n        → Decision: suffix is palindrome? AND k < length(word) // 後半段為迴文且非空\n            Yes → rev_prefix = reverse(prefix) // 反轉前半段\n                → Decision: rev_prefix exists in map AND map[rev_prefix] != i? // 反向前半段是否為已有字串\n                    Yes → Append pair (i, map[rev_prefix]) // 加入 (i,j) 對\n    → Decision: word is empty string? // 空字串特殊處理\n        Yes → For each j from 0 to words.length-1\n            → Decision: j != i? // 不能配對自身\n                Yes → Append pair (i, j) // (空, 其他)\n                Yes → Append pair (j, i) // (其他, 空)\nEnd // 程式結束\n```"
    },
    {
      "title": "Implement Queue using Stacks",
      "source_file": "Leetcode/leetcode232.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpen_lv3n5.py\", line 67, in <module>\n    main()\n  File \"/tmp/tmpen_lv3n5.py\", line 43, in main\n    ops = ast.literal_eval(lines[0])   # 例如 [\"MyQueue\", \"push\", ...]\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7e901a2225d0>"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []   # 用於存放進隊列的元素\n        self.stack_out = []  # 用於出隊列的元素\n\n    def push(self, x):\n        \"\"\"把元素 x 放入隊列尾端\"\"\"\n        self.stack_in.append(x)\n\n    def _transfer(self):\n        \"\"\"把 stack_in 的所有元素轉移到 stack_out，使 stack_out 的頂端為隊列前端\"\"\"\n        while self.stack_in:\n            self.stack_out.append(self.stack_in.pop())\n\n    def pop(self):\n        \"\"\"移除並回傳隊列前端的元素\"\"\"\n        if not self.stack_out:\n            self._transfer()\n        return self.stack_out.pop()\n\n    def peek(self):\n        \"\"\"回傳隊列前端的元素但不移除\"\"\"\n        if not self.stack_out:\n            self._transfer()\n        return self.stack_out[-1]\n\n    def empty(self):\n        \"\"\"判斷隊列是否為空\"\"\"\n        return not self.stack_in and not self.stack_out\n\n\ndef main():\n    # 讀取所有非空行\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if len(lines) < 2:\n        return\n\n    # 解析操作與參數\n    ops = ast.literal_eval(lines[0])   # 例如 [\"MyQueue\", \"push\", ...]\n    args = ast.literal_eval(lines[1])  # 例如 [[], [1], [2], [], [], []]\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyQueue\":\n            obj = MyQueue()\n            results.append(None)          # 建構子不回傳值，對應輸出為 null\n        elif op == \"push\":\n            obj.push(arg[0])              # arg 是一個列表，push 只取第一個元素\n            results.append(None)\n        elif op == \"pop\":\n            results.append(obj.pop())\n        elif op == \"peek\":\n            results.append(obj.peek())\n        elif op == \"empty\":\n            results.append(obj.empty())\n\n    # 使用 json.dumps 以符合題目輸出格式（null、true/false）\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for a MyQueue class with push, pop, peek, empty, using two stacks. Provide each line with // explanation. Use arrow notation. We need to include Start and End. Provide steps of algorithm: use two stacks: input stack and output stack. push(x): push to input. pop(): if output empty, transfer all from input to output, then pop from output. peek similar. empty returns both empty. We need stepwise pseudocode. Provide each step as a line.\n\nLet's outline:\n\nStart\n→ Step: Initialize stack1 and stack2 // two stacks\n→ Step: push(x) // push to stack1\n→ Step: pop() // if stack2 empty, transfer from stack1\n    → Decision: stack2 empty?\n        Yes → Step: Transfer all from stack1 to stack2\n            → Loop: while stack1 not empty\n                → Step: stack2.push(stack1.pop())\n        No → ...\n    → Step: return stack2.pop()\n→ Step: peek() // similar but return top\n    → Decision: stack2 empty?\n        Yes → Transfer\n    → Step: return stack2.peek()\n→ Step: empty() // check both stacks\n    → Decision: stack1 empty and stack2 empty?\n        Yes → return true\n        No → return false\nEnd\n\nBut we need to produce step-by-step lines. We might need separate blocks for each function. Provide lines like:\n\nStart // 程式開始執行\n→ Step: 宣告 Stack input, Stack output // 兩個堆疊\n\nThen for push function:\n\n→ Function push(x) // push element to queue\n    → input.push(x) // 直接放進輸入堆疊\n\nSimilarly for pop:\n\n→ Function pop() // 移除並返回前端\n    → Decision: 如果 output 為空?\n        Yes → Transfer() // 將所有元素從 input 轉移到 output\n        No → ...\n    → Return output.pop() // 從 output 彈出\n\nTransfer function:\n\n→ Function transfer()\n    → While input not empty\n        → output.push(input.pop())\n\nSimilarly peek:\n\n→ Function peek()\n    → Decision: output 空?\n        Yes → transfer()\n    → Return output.peek()\n\nempty:\n\n→ Function empty()\n    → Return input.isEmpty() 且 output.isEmpty()\n\nBut we need to maintain format: each line with virtual code step and explanation.\n\nWe might need to separate functions as blocks but still each line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step: 初始化兩個堆疊 input, output // 用於實作 FIFO\n\n→ Function push(x) // 將元素加入隊列尾部\n    → input.push(x) // 直接放到輸入堆疊\n\n→ Function transfer() // 將 input 中的所有元素轉移到 output，使輸出堆疊頂端為前端元素\n    → While input not empty\n        → output.push(input.pop()) // 先彈出 input，再推進 output\n\n→ Function pop() // 從隊列前端移除並回傳元素\n    → Decision: output.isEmpty()？ // 若 output 为空，需要先转移\n        Yes → transfer()\n    → Return output.pop() // 取出前端元素\n\n→ Function peek() // 查看隊列前端元素但不移除\n    → Decision: output.isEmpty()？\n        Yes → transfer()\n    → Return output.peek() // 返回前端元素\n\n→ Function empty() // 判斷隊列是否為空\n    → Return input.isEmpty() 且 output.isEmpty() // 兩堆疊皆空即隊列空\n\nEnd // 程式結束\n\nWe need to ensure each line is separate and uses arrows. Indentation? The format example uses indentation for decisions. Use arrows for each step. Use \"→\" at start of each step. For nested lines we can use indentation.\n\nLet's format accordingly. Use \"Decision:\" and arrow for Yes/No branches.\n\nIn \"Function pop()\", decision branch: Yes -> transfer(); No -> nothing. We need to show Yes and No branches. But we can combine: \n    → Decision: output.isEmpty()？\n        Yes → transfer()\n        No → // nothing\n\nThen return.\n\nWe can use comment after each line. Provide explanation in Chinese. Provide consistent formatting. For transfer function, while loop: \n    → While input.notEmpty()\n        → output.push(input.pop())\n\nMake sure each line has // explanation.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化兩個堆疊 input, output // 用於實作 FIFO  \n\n→ Function push(x) // 將元素加入隊列尾部  \n    → input.push(x) // 直接放到輸入堆疊  \n\n→ Function transfer() // 將 input 中的所有元素轉移到 output，使輸出堆疊頂端為前端元素  \n    → While input.notEmpty() // 當輸入堆疊不空時  \n        → output.push(input.pop()) // 先彈出 input，再推進 output  \n\n→ Function pop() // 從隊列前端移除並回傳元素  \n    → Decision: output.isEmpty()？ // 若 output 为空，需要先轉移  \n        Yes → transfer() // 將所有元素從 input 轉移到 output  \n        No  → // output 已有前端元素，無需轉移  \n    → Return output.pop() // 取出並返回前端元素  \n\n→ Function peek() // 查看隊列前端元素但不移除  \n    → Decision: output.isEmpty()？ // 若 output 为空，需要先轉移  \n        Yes → transfer() // 將所有元素從 input 轉移到 output  \n        No  → // output 已有前端元素，無需轉移  \n    → Return output.peek() // 返回前端元素  \n\n→ Function empty() // 判斷隊列是否為空  \n    → Return input.isEmpty() 且 output.isEmpty() // 兩堆疊皆空即隊列空  \n\nEnd // 程式結束執行"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "class Solution:\n    def permute(self, nums):\n        \"\"\"\n        產生 nums 的所有排列。\n        使用回溯 + 原地交換的技巧，避免重複建立子序列。\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # 基本情況：已經選完所有位置\n            if start == len(nums):\n                res.append(nums[:])  # 加入一份複製的結果\n                return\n            # 嘗試把每一個可用的元素放在 start 位置\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # 交換\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # 回溯，還原\n\n        backtrack(0)\n        return res\n\n\nif __name__ == \"__main__\":\n    import sys\n    import re\n\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n\n    # 從字串中找出第一個完整的列表表達式\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if match:\n        nums = eval(match.group())\n    else:\n        nums = []\n\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation. For permutation algorithm: typical backtracking. Steps: start, initialize result list, call backtrack(current, used). We'll describe array input, recursion. Provide lines with arrows and decision.\n\nWe need \"逐行\" output. Use arrows like \"→\" for sequence, \"Decision:\" for if statements. Include Start, End. Provide explanation comments. Provide all steps of algorithm. Must not output actual code, only virtual steps. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收陣列 nums // 取得輸入的整數陣列  \n→ Step 2: 建立空列表 result 用於儲存所有排列結果 // 初始化結果容器  \n→ Step 3: 建立布林陣列 used，長度與 nums 相同，全部設為 false // 追蹤元素是否已被使用  \n\n→ Step 4: 呼叫函式 Backtrack(目前排列 current = [], 已選元素索引 count = 0) // 開始遞迴  \n    　Backtrack(current, count) // 定義遞迴流程  \n\n    　Decision: 是否已選完所有元素? // 檢查是否完成一個排列  \n      Yes → Step 5: 複製 current 並加入 result // 完整排列加入結果  \n      No  → Step 6: 針對每個索引 i 從 0 到 nums.length-1 進行  \n        Decision: used[i] 為 false? // 判斷此元素是否已被使用  \n         Yes → Step 7: 將 nums[i] 加入 current，設置 used[i] = true // 使用此元素  \n           → 呼叫 Backtrack(current, count + 1) // 進一步遞迴  \n           → Decision: 回溯時  \n             → Step 8: 移除 current 中最後一個元素，將 used[i] = false // 回到上一層  \n             → End // 完成此索引 i 的處理  \n\n→ End // 程式執行結束，result 為所有排列結果的集合"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpexe74tdh.py\", line 98, in <module>\n    main()\n  File \"/tmp/tmpexe74tdh.py\", line 61, in main\n    ops, args = parse_input(raw)\n                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpexe74tdh.py\", line 53, in parse_input\n    ops = json.loads(ops_str)\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 92 (char 91)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport collections\nimport re\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 所有元素的列表\n        self.data = []\n        # 每個值對應的索引集合\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入元素。若該值之前不存在則返回 True，否則 False。\"\"\"\n        is_new = len(self.idx_map[val]) == 0\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return is_new\n\n    def remove(self, val: int) -> bool:\n        \"\"\"移除一個 val。若存在則返回 True，否則 False。\"\"\"\n        if not self.idx_map[val]:\n            return False\n\n        # 任取一個索引\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n\n        # 如果不是最後一個元素，將最後一個元素移到被刪位置\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            self.idx_map[last_val].remove(last_idx)\n            self.idx_map[last_val].add(remove_idx)\n\n        # 移除最後一個元素\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素。\"\"\"\n        return random.choice(self.data)\n\ndef parse_input(inp: str):\n    \"\"\"將輸入字串解析為兩個列表：操作名稱與參數列表。\"\"\"\n    # 先把首尾的括號加上\n    parts = re.split(r'\\],\\s*\\[', inp, maxsplit=1)\n    if len(parts) != 2:\n        raise ValueError(\"輸入格式錯誤\")\n    ops_str = '[' + parts[0] + ']'\n    args_str = '[' + parts[1]\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n    return ops, args\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    ops, args = parse_input(raw)\n\n    obj = None\n    outputs = []\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            outputs.append(None)          # null\n        elif op == \"insert\":\n            res = obj.insert(arg[0])\n            outputs.append(res)           # true/false\n        elif op == \"remove\":\n            res = obj.remove(arg[0])\n            outputs.append(res)\n        elif op == \"getRandom\":\n            res = obj.getRandom()\n            outputs.append(res)\n        else:\n            raise ValueError(f\"未知操作: {op}\")\n\n    # 將結果轉成符合題目要求的字串格式\n    out_str = '['\n    first = True\n    for item in outputs:\n        if not first:\n            out_str += ', '\n        first = False\n        if item is None:\n            out_str += 'null'\n        elif isinstance(item, bool):\n            out_str += 'true' if item else 'false'\n        else:\n            out_str += str(item)\n    out_str += ']'\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for implementation. The requirement: produce virtual code with arrows, Start, End, Decision, etc. Provide step-by-step for each function. Since it's a data structure, we can outline overall algorithm: Use vector to store values, and hashmap from val to set of indices. For insert, push_back to vector, add index to set. Return whether val was new (set empty before). For remove: if val not in map or empty set, return false. Else, get an index from set; remove that index. To keep vector compact, swap last element into removed index, update its indices set. Remove last from vector. Return true. For getRandom: pick random index from 0..vector.size-1. Return element. We'll produce virtual code as a flowchart-like list.\n\nWe need to produce \"逐行虛擬碼\" each line with arrow. Might be long. Let's structure as high-level class definition, then each method. Provide steps for initialization, insert, remove, getRandom.\n\nLet's produce:\n\nStart // 開始\n\n→ Step 1: 定義 RandomizedCollection 類別 // 建立類別\n\n→ Step 2: 初始化 vector values, map indices\n\n→ Step 3: Insert method: ...\nWe need to show algorithm steps inside method. Provide decisions.\n\nMake sure to include arrow for decisions: \"Decision: 是否存在 val?\" etc.\n\nWe need to be careful to not output real code, but steps.\n\nLet's produce as:\n\nStart // 程式開始執行\n→ Class RandomizedCollection // 定義資料結構\n\nThen inside class, define fields:\n\n→ Field values: vector of int // 存放所有元素\n→ Field indices: map int → set of int // 每個值對應的索引集合\n\nThen methods:\n\n→ Method RandomizedCollection() // 建構子\n    → Step: 初始化 values 為空\n    → Step: 初始化 indices 為空\n    → Return\n\n→ Method insert(val)\n    → Step: 在 indices 中查找 val 的集合\n    → Decision: 集合是否存在? // 檢查 val 是否新\n        Yes → Step: 新集合空 -> val 新\n            → Step: 插入 true 旗標\n        No  → Step: val 以前已存在\n            → Step: 插入 false 旗標\n    → Step: 將 val 放到 values 的尾部，取得索引 i\n    → Step: 將索引 i 加入 indices[val]\n    → Return true/false 旗標\n\nBut we must return true if item was not present before; false if existed. So we need flag isNew = (indices[val].size == 0) before insertion.\n\nOk.\n\nRemove(val):\n    → Step: 查找 indices[val]\n    → Decision: 集合是否為空? // 是否存在\n        Yes → Return false\n        No  →\n            → Step: 取得任意索引 idx 從集合中\n            → Step: 移除 idx 從集合\n            → Step: 如果 idx != values.size-1\n                → Step: 取最後元素 lastVal = values.back()\n                → Step: values[idx] = lastVal\n                → Step: 更新 indices[lastVal]：移除 lastIdx，加入 idx\n            → Step: 從 values.pop_back()\n            → Return true\n\ngetRandom():\n    → Step: 生成隨機整數 r 在 [0, values.size-1]\n    → Step: 返回 values[r]\n\nNow produce lines with arrows and explanation.\n\nWe'll use the format: \"→ Step: ...\" and for decisions \"Decision:\" lines.\n\nAlso indent decisions with 4 spaces? The sample uses indentation of decisions but we can use 4 spaces indent.\n\nWe'll output step-by-step. Each line: Virtual Code Step + \" // \" + explanation.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class RandomizedCollection // 定義隨機集合資料結構  \n\n    → Field values: vector<int> // 存放所有元素的陣列  \n    → Field indices: map<int, set<int>> // 每個值對應的索引集合  \n\n    → Method RandomizedCollection() // 建構子  \n        → Step: 初始化 values 為空陣列 // 建立空的元素列表  \n        → Step: 初始化 indices 為空映射 // 建立空的索引字典  \n        → Return // 建構子結束  \n\n    → Method insert(val) // 插入元素  \n        → Step: 判斷 indices[val] 是否存在或為空 // 檢查 val 是否為新元素  \n            Decision: indices[val] 是否存在?  \n                Yes → Step: setNotEmpty = true // 已存在  \n                No  → Step: setNotEmpty = false // 新元素  \n        → Step: 在 values 的尾部添加 val，取得索引 idx = values.size() // 將元素加入列表  \n        → Step: indices[val].add(idx) // 在索引集合中加入該索引  \n        → Decision: setNotEmpty 是否為 false? // 判斷返回值  \n            Yes → Step: return true // 先前不存在  \n            No  → Step: return false // 先前已存在  \n\n    → Method remove(val) // 刪除元素  \n        → Step: 找到 indices[val] 的集合 set // 取得索引集合  \n        → Decision: set 是否為空?  \n            Yes → Step: return false // 無此元素可刪  \n            No  →  \n                → Step: 取得 set 中任意索引 idx // 隨機取一個索引  \n                → Step: set.remove(idx) // 從集合中移除該索引  \n                → Decision: idx 與 values.size() - 1 是否相等?  \n                    Yes → // 刪除的是最後一個元素  \n                        → Step: values.pop_back() // 直接移除最後元素  \n                    No  → // 刪除非最後元素，需要移動最後元素填補空缺  \n                        → Step: lastVal = values.back() // 取得最後一個元素  \n                        → Step: values[idx] = lastVal // 用最後元素覆蓋被刪位置  \n                        → Step: indices[lastVal].remove(values.size() - 1) // 移除舊索引  \n                        → Step: indices[lastVal].add(idx) // 加入新索引  \n                        → Step: values.pop_back() // 移除原最後元素  \n                → Step: return true // 刪除成功  \n\n    → Method getRandom() // 隨機取值  \n        → Step: 生成隨機整數 r 在範圍 [0, values.size() - 1] // 隨機索引  \n        → Step: return values[r] // 回傳該索引位置的值  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Coin Change",
      "source_file": "Leetcode/leetcode322.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6kmr6ugy.py\", line 22, in <module>\n    params = eval(f\"{{{data}}}\")\n             ^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {coins= [1,2,5], amount= 11}\n     ^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "coins = [2], amount = 3",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdo5gj4ys.py\", line 22, in <module>\n    params = eval(f\"{{{data}}}\")\n             ^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {coins= [2], amount= 3}\n     ^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "coins = [1], amount = 0",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptsbw66gi.py\", line 22, in <module>\n    params = eval(f\"{{{data}}}\")\n             ^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {coins= [1], amount= 0}\n     ^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def coinChange(self, coins, amount):\n        # 初始化 dp 陣列，dp[i] 表示湊成金額 i 所需最少硬幣數\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n\n        return dp[amount] if dp[amount] != float('inf') else -1\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入，解析 coins 與 amount\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 轉換成 Python 可評估的字典\n    data = data.replace('coins =', 'coins=').replace('amount =', 'amount=')\n    params = eval(f\"{{{data}}}\")\n    coins = params.get('coins', [])\n    amount = params.get('amount', 0)\n\n    solution = Solution()\n    result = solution.coinChange(coins, amount)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for coin change problem. Use DP. Steps: Start, Initialize DP array size amount+1 with Infinity, dp[0]=0. For each coin, for each amt from coin to amount, update dp[amt]=min(dp[amt], dp[amt-coin]+1). After loop, if dp[amount]==Infinity return -1 else dp[amount]. Use virtual code lines with explanation.\n\nFollow format: each line with \"虛擬碼步驟 // 解釋\". Use arrow arrows. Ensure we use Start, End, Decision. Use Indentation? They used indentation via spaces. Provide structure.\n\nWe must use arrow \"→\" before each step. Decision lines.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 設定 dp 陣列長度為 amount+1 且全部初值為無限大 // 初始化 DP 表\n→ Step 2: 設定 dp[0] = 0 // 零金額不需要硬幣\n→ Step 3: 針對每個 coin in coins\n    → Step 3.1: 針對 amt 從 coin 到 amount\n        → Step 3.1.1: dp[amt] = min(dp[amt], dp[amt-coin]+1) // 更新最小硬幣數\n→ Decision: dp[amount] 是否等於無限大? // 判斷是否可組成目標金額\n    Yes → Step 4: 回傳 -1 // 無法達成\n    No  → Step 5: 回傳 dp[amount] // 回傳最小硬幣數\nEnd // 程式結束\n\nNeed to maintain format exactly: each line separate, include \"虛擬碼步驟\" maybe like \"Step 1:\" etc. We can write as:\n\nStart // 程式開始執行\n→ Step 1: Initialize dp array of size amount+1 with Infinity // 初始化 dp 表\n→ Step 2: Set dp[0] = 0 // 零金額不需要硬幣\n→ Step 3: For each coin in coins\n    → Step 3.1: For amt from coin to amount\n        → Step 3.1.1: dp[amt] = min(dp[amt], dp[amt-coin] + 1) // 更新 dp\n→ Decision: dp[amount] == Infinity? // 判斷是否可達\n    Yes → Step 4: Return -1 // 不可達\n    No  → Step 5: Return dp[amount] // 最小硬幣數\nEnd // 程式結束\n\nMake sure each line has arrow \"→\" except Decision block? They used \"Decision:\" lines without arrow. In example: \"Decision: 如果數字大於 0?\" So we should follow same. So for Decision, no arrow.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: Initialize dp array of size amount+1 with Infinity // 初始化 dp 表\n→ Step 2: Set dp[0] = 0 // 零金額不需要硬幣\n→ Step 3: For each coin in coins\n    → Step 3.1: For amt from coin to amount\n        → Step 3.1.1: dp[amt] = min(dp[amt], dp[amt-coin] + 1) // 更新 dp\nDecision: dp[amount] 等於 Infinity? // 判斷是否可達\n    Yes → Step 4: Return -1 // 不可達\n    No  → Step 5: Return dp[amount] // 最小硬幣數\nEnd // 程式結束\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Initialize dp array of size amount+1 with Infinity // 初始化 dp 表\n→ Step 2: Set dp[0] = 0 // 零金額不需要硬幣\n→ Step 3: For each coin in coins\n    → Step 3.1: For amt from coin to amount\n        → Step 3.1.1: dp[amt] = min(dp[amt], dp[amt-coin] + 1) // 更新 dp\nDecision: dp[amount] 等於 Infinity? // 判斷是否可達\n    Yes → Step 4: Return -1 // 不可達\n    No  → Step 5: Return dp[amount] // 最小硬幣數\nEnd // 程式結束"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\ndef min_mutation(start: str, end: str, bank: list[str]) -> int:\n    \"\"\"Return the minimum number of mutations to transform start into end\n    using only genes from bank.  Return -1 if impossible.\"\"\"\n    if end not in bank:\n        return -1\n\n    bank_set = set(bank)\n    genes = ('A', 'C', 'G', 'T')\n    queue = deque([(start, 0)])\n    visited = {start}\n\n    while queue:\n        current, steps = queue.popleft()\n        if current == end:\n            return steps\n        for i in range(len(current)):\n            for g in genes:\n                if g == current[i]:\n                    continue\n                mutation = current[:i] + g + current[i + 1:]\n                if mutation in bank_set and mutation not in visited:\n                    visited.add(mutation)\n                    queue.append((mutation, steps + 1))\n    return -1\n\ndef parse_input(raw: str) -> tuple[str, str, list[str]]:\n    \"\"\"Parse the input string into startGene, endGene and bank list.\"\"\"\n    # Extract startGene\n    start_match = re.search(r'startGene\\s*=\\s*\"([^\"]+)\"', raw)\n    start = start_match.group(1) if start_match else \"\"\n\n    # Extract endGene\n    end_match = re.search(r'endGene\\s*=\\s*\"([^\"]+)\"', raw)\n    end = end_match.group(1) if end_match else \"\"\n\n    # Extract bank list\n    bank_match = re.search(r'bank\\s*=\\s*\\[([^\\]]*)\\]', raw)\n    bank_str = bank_match.group(1) if bank_match else \"\"\n    # Split by commas and strip quotes and whitespace\n    bank = []\n    for item in re.split(r',(?![^\"]*\")', bank_str):\n        item = item.strip()\n        if item.startswith('\"') and item.endswith('\"'):\n            bank.append(item[1:-1])\n    return start, end, bank\n\ndef main() -> None:\n    raw_input = sys.stdin.read().strip()\n    start_gene, end_gene, bank = parse_input(raw_input)\n    result = min_mutation(start_gene, end_gene, bank)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudocode steps line by line with explanations. The problem: Minimum mutations from start to end using BFS. Steps: create set bank, visited set, queue, etc. Provide steps. Use arrows. Provide each line with explanation. Must not output actual code. Let's craft.\n\nWe'll include Start, End, Decision. Use arrows.\n\nBe mindful to show BFS loop. Provide pseudocode.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 bankSet ← 將 bank 中所有基因字串加入集合 // 方便 O(1) 查詢  \n→ Step 2: 如果 endGene 不在 bankSet, 返回 -1 // 無法達到目標  \n→ Step 3: 建立 queue ← (startGene, 0) // (基因字串, 已經變異的次數)  \n→ Step 4: 建立 visitedSet ← {startGene} // 記錄已處理的基因  \n→ Decision: queue 是否為空? // 判斷是否還有待處理基因  \n    No  → Step 5: 取出 queue 前一項 (currentGene, steps) // 取下一個待處理基因  \n    → Step 6: 如果 currentGene 等於 endGene, 返回 steps // 找到目標，回傳最小步數  \n    → Step 7: 建立變異集合 nextGenes ← 空集合 // 存放所有合法下一步  \n    → Step 8: 對每個位置 i 從 0 到 7  \n        → Step 9: 對每個字母 c 在 {'A', 'C', 'G', 'T'}  \n            → Decision: c 與 currentGene[i] 是否相同? // 避免無效變異  \n                Yes → Continue // 跳過相同字母  \n                No  → Step 10: 產生 newGene ← currentGene 在位置 i 替換為 c // 生成新基因  \n                → Decision: newGene 是否在 bankSet 且不在 visitedSet?  \n                    Yes → Step 11: 將 newGene 加入 nextGenes // 有效且未處理的變異  \n                    No  → Continue // 無效或已處理，忽略  \n    → Step 12: 對 nextGenes 中的每個 newGene  \n        → Step 13: 將 (newGene, steps+1) 加入 queue // 探索下一層  \n        → Step 14: 將 newGene 加入 visitedSet // 標記已探索  \n    → Step 15: 回到 Decision: queue 是否為空? // 迴圈結束判斷  \n    Yes → End // queue 為空，無法到達 endGene，程式結束  \n    No  → 回到 Step 5 // 取下一項進行探索  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\nimport json\n\nclass MedianFinder:\n    \"\"\"\n    使用兩個堆（最大堆與最小堆）來動態維護中位數。\n    - small  : max-heap（以負值存放，實現最大堆）\n    - large  : min-heap\n    \"\"\"\n    def __init__(self):\n        self.small = []  # 存放較小的一半，最大堆\n        self.large = []  # 存放較大的一半，最小堆\n\n    def addNum(self, num: int) -> None:\n        \"\"\"把新數字加入資料結構，並保持兩個堆的大小差不超過 1\"\"\"\n        # 先把數字放進小堆（最大堆）\n        heapq.heappush(self.small, -num)\n\n        # 如果兩堆都不空且小堆頂大於大堆頂，則交換兩者的頂部元素\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡兩堆大小\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        \"\"\"返回目前所有數字的中位數\"\"\"\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main() -> None:\n    \"\"\"主程式：讀取輸入、執行指令、輸出結果\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析兩個列表：命令列表與對應的參數列表\n    # 例：'[\"MedianFinder\", \"addNum\"], [[], [1]]'\n    first, second = data.split('],', 1)\n    first = first.strip() + ']'\n    second = second.strip()\n    commands = ast.literal_eval(first)\n    arguments = ast.literal_eval(second)\n\n    obj = None\n    outputs = []\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"MedianFinder\":\n            obj = MedianFinder()\n            outputs.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(arg[0])\n            outputs.append(None)\n        elif cmd == \"findMedian\":\n            median = obj.findMedian()\n            outputs.append(median)\n        else:\n            # 若遇到未知指令，忽略或視情況處理\n            outputs.append(None)\n\n    # 以 JSON 格式輸出，將 None 轉為 null\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for MedianFinder class implementing median find with addNum and findMedian. Use two heaps: max-heap for lower half, min-heap for upper half. Steps: Initialize both. addNum: push into appropriate heap then balance sizes. findMedian: if size odd take top of larger heap else average. Use virtual code. Each line with // explanation. Use arrows, Start, End, Decision. Provide each line. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個優先隊列 // 低值最大堆 maxHeap， 高值最小堆 minHeap  \n→ Decision: 如果 maxHeap 及 minHeap 尚未建立? // 檢查資料結構是否已建立  \n  Yes → Step 2: 建立 maxHeap（最大堆） // 用於存放小半段的最大值  \n  Yes → Step 3: 建立 minHeap（最小堆） // 用於存放大半段的最小值  \n→ Step 4: 完成構造函式 // 兩個堆已就緒，可供 addNum 使用  \nEnd // 構造完成  \n\nStart // addNum 方法開始執行  \n→ Step 5: 判斷 num 是否小於等於 maxHeap 最高值? // 決定放入哪個堆  \n  Decision: 若 maxHeap 為空或 num ≤ maxHeap.top()? // 若小半段仍可接收  \n   Yes → Step 6: 將 num 插入 maxHeap // 低值堆新增元素  \n   No → Step 7: 將 num 插入 minHeap // 高值堆新增元素  \n→ Step 8: 平衡堆大小 // 保持兩堆大小差 ≤ 1  \n  Decision: 若 maxHeap.size > minHeap.size + 1? // 低值堆太大  \n   Yes → Step 9: 將 maxHeap.top() 移至 minHeap // 移動元素以平衡  \n  Decision: 若 minHeap.size > maxHeap.size + 1? // 高值堆太大  \n   Yes → Step 10: 將 minHeap.top() 移至 maxHeap // 移動元素以平衡  \n→ Step 11: addNum 完成 // 所有元素已正確放置  \nEnd // addNum 執行結束  \n\nStart // findMedian 方法開始執行  \n→ Step 12: 判斷兩堆大小是否相等? // 先決定是否需要平均  \n  Decision: 若 maxHeap.size == minHeap.size? // 兩堆相等  \n   Yes → Step 13: 取 maxHeap.top() 與 minHeap.top() 之平均值 // 兩中位數平均  \n    → Step 14: 返回 (maxHeap.top() + minHeap.top()) / 2.0 // 結果為 double  \n  Decision: 若 maxHeap.size > minHeap.size? // 低值堆較大  \n   Yes → Step 15: 返回 maxHeap.top() // 低值堆頂即中位數  \n  Decision: 否則 // 高值堆較大  \n   Yes → Step 16: 返回 minHeap.top() // 高值堆頂即中位數  \n→ Step 17: findMedian 完成  \nEnd // findMedian 執行結束\n\nEnd // 程式結束執行"
    },
    {
      "title": "Data Stream as Disjoint Intervals",
      "source_file": "Leetcode/leetcode352.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,[[1,1]],null,[[1,1],[3,3]],null,[[1,1],[3,3],[7,7]],null,[[1,3],[7,7]],null,[[1,3],[6,7]]]'\nGot (Norm):      '[null,null,[[1,3],[6,7]],null,[[1,3],[6,7]],null,[[1,3],[6,7]],null,[[1,3],[6,7]],null,[[1,3],[6,7]]]'\n--- (Raw) ---\nRaw Expected: '[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]'\nRaw Got:      '[null, null, [[1, 3], [6, 7]], null, [[1, 3], [6, 7]], null, [[1, 3], [6, 7]], null, [[1, 3], [6, 7]], null, [[1, 3], [6, 7]]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass SummaryRanges:\n    def __init__(self):\n        self.intervals = []\n\n    def addNum(self, val):\n        new_start, new_end = val, val\n        i = 0\n        while i < len(self.intervals):\n            start, end = self.intervals[i]\n            if end + 1 < new_start:\n                i += 1\n                continue\n            if start - 1 > new_end:\n                break\n            new_start = min(new_start, start)\n            new_end = max(new_end, end)\n            self.intervals.pop(i)\n        self.intervals.insert(i, [new_start, new_end])\n\n    def getIntervals(self):\n        return self.intervals\n\ndef main():\n    lines = sys.stdin.read().splitlines()\n    if not lines:\n        return\n    ops = ast.literal_eval(lines[0])\n    args = ast.literal_eval(lines[1]) if len(lines) > 1 else []\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"SummaryRanges\":\n            obj = SummaryRanges()\n            result.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            result.append(None)\n        elif op == \"getIntervals\":\n            result.append(obj.getIntervals())\n\n    output_parts = []\n    for r in result:\n        output_parts.append('null' if r is None else str(r))\n    print('[' + ', '.join(output_parts) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this problem, step by step, with explanations. It's like a design of a data structure: SummaryRanges class with addNum and getIntervals. We need to produce virtual pseudocode, line by line, using arrow notation, etc. We cannot output actual code, but structure.\n\nWe need to describe how to maintain intervals, adding numbers, merging etc. Use virtual code steps. Provide each line with // explanation.\n\nWe need to use Start, End, Decision, etc.\n\nSo produce lines like:\n\nStart // 程式開始\n→ Step 1: 初始化 intervals_list as empty list // 以列表存儲區間\n\nThen method definitions: But maybe each method as separate sections.\n\nWe should show the main class initialization and methods.\n\nProbably:\n\nStart // SummaryRanges 初始化\n→ Step 1: intervals ← empty list // 內部區間列表\n\nThen addNum(value):\n→ Step 2: 在 intervals 中尋找插入位置 // 二分查找\n→ Decision: if value already in intervals? // 判斷是否已存在\n    Yes → End // 已存在，不做改動\n    No  → Find left index l such that intervals[l].end +1 < value\n         Find right index r such that intervals[r].start -1 > value\n         // Actually we need to merge adjacent or overlapping\nBut we can keep simple: loop through intervals to find where to merge.\n\nMaybe we show simpler linear search.\n\nBut the instruction: Virtual code, each line with explanation. So we should present algorithmic steps, not necessarily optimized.\n\nThus for addNum:\n\n→ Step 3: 创建 new_interval = [value, value] // 初始區間\n\n→ Step 4: 合併左側相鄰區間 // 若有 intervals[i].end +1 == value, merge\n\n→ Step 5: 合併右側相鄰區間 // 若有 intervals[j].start -1 == value, merge\n\n→ Step 6: 將 new_interval 插入到 intervals 且維持排序 // remove merged ones\n\nThen getIntervals: just return intervals copy.\n\nWe need to produce pseudocode lines.\n\nProbably structure like:\n\nClass SummaryRanges:\n→ Start // class constructor\n    → Step 1: intervals ← [] // empty list of intervals\n→ End\n\nMethod addNum:\n→ Step 1: If intervals empty then insert [value,value] // 直接加入\n→ Decision: 任何區間? // else\n\nBut it's better to show generic algorithm.\n\nLet's design:\n\nStart // SummaryRanges 初始化\n→ Step 1: intervals ← empty list // 用於存儲不相交區間\n\nEnd // 初始化完成\n\nMethod addNum(value):\n\nStart // addNum 開始\n→ Step 1: left ← 0; right ← length(intervals)-1 // 二分索引初始化\n→ Step 2: // 找到可能覆蓋或相鄰的區間\n→ Decision: 如果 intervals 為空? // 判斷是否有區間\n    Yes → Step 3: intervals.append([value,value]) // 新增單值區間\n    No → Step 4: // 搜尋左邊界\n        → While left <= right:\n            → mid ← (left+right)/2\n            → Decision: intervals[mid].end +1 < value? // 需要往右\n                Yes → left ← mid+1\n                No → Decision: intervals[mid].start -1 > value? // 需要往左\n                    Yes → right ← mid-1\n                    No → // intervals[mid] 可能覆蓋 value\n                        → Decision: value between intervals[mid].start and intervals[mid].end? // 已存在\n                            Yes → End // 不需要新增\n                            No → // value 在 intervals[mid] 左右\n→ Step 5: // 合併左側相鄰區間\n    → i ← left-1\n    → While i >=0 and intervals[i].end +1 >= value:\n        → value ← min(value, intervals[i].start)\n        → intervals.pop(i) // remove merged\n        → i ← i-1\n→ Step 6: // 合併右側相鄰區間\n    → i ← left\n    → While i < length(intervals) and intervals[i].start -1 <= value:\n        → value ← max(value, intervals[i].end)\n        → intervals.pop(i) // remove merged (do not increment i)\n→ Step 7: intervals.insert(left, [value, value]) // 新增合併後區間\nEnd // addNum 結束\n\nBut this pseudocode is complex. We need to keep simple.\n\nAlternatively, we can use list of intervals, linear scan to merge. That might be simpler.\n\nLet's produce simpler steps:\n\naddNum(value):\n→ Step 1: new_start ← value; new_end ← value\n→ Step 2: i ← 0\n→ While i < length(intervals):\n    → If intervals[i].end +1 < new_start:\n        → i ← i+1 // 跳過\n    → Else if intervals[i].start -1 > new_end:\n        → Break // 後續區間不相鄰\n    → Else:\n        → // 覆蓋或相鄰，合併\n        → new_start ← min(new_start, intervals[i].start)\n        → new_end ← max(new_end, intervals[i].end)\n        → intervals.remove(i) // 移除已合併區間\n        → // 不增加 i，因為已移除\n→ Step 3: intervals.insert(i, [new_start, new_end]) // 插入合併後區間\n→ Step 4: // 保持 intervals 排序 (i 已在合適位置)\n\ngetIntervals:\n→ Step 1: return copy of intervals\n\nWe'll produce virtual code lines accordingly.\n\nWe should use Start, End, Decision.\n\nWe need to produce each line as \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nThus produce something like:\n\nStart // SummaryRanges 初始化\n→ intervals ← [] // 初始化空區間列表\nEnd // 初始化完成\n\nAddNum method:\n\nStart // addNum 開始\n→ new_start ← value // 設定新區間起始\n→ new_end ← value // 設定新區間結束\n→ i ← 0 // 從頭開始遍歷區間\n→ Decision: i < length(intervals)? // 是否還有區間需要檢查\n    Yes →\n        → If intervals[i].end +1 < new_start? // 與新區間無交集且在前面\n            Yes → i ← i+1 // 跳過該區間\n            No →\n                → If intervals[i].start -1 > new_end? // 與新區間無交集且在後面\n                    Yes → Break // 後續區間不可能相鄰，結束循環\n                    No →\n                        → // 相鄰或重疊，合併\n                        → new_start ← min(new_start, intervals[i].start) // 更新起始\n                        → new_end ← max(new_end, intervals[i].end) // 更新結束\n                        → intervals.remove(i) // 移除已合併區間\n                        → // i 不變，因為列表已縮短\n        → // 回到決策判斷 i < length(intervals)\n    No →\n        → // 迴圈結束\n→ intervals.insert(i, [new_start, new_end]) // 在正確位置插入合併後區間\nEnd // addNum 結束\n\nGetIntervals method:\n\nStart // getIntervals 開始\n→ return copy(intervals) // 直接回傳目前的區間列表\nEnd // getIntervals 結束\n\nWe need to keep each line separate. Use Start and End only at top-level, not inside methods? But we can use Start/End inside methods for clarity.\n\nLet's produce final answer.\n...done thinking.\n\nStart // SummaryRanges 初始化\n→ intervals ← [] // 用於存放不重疊、已排序的區間\nEnd // 初始化完成\n\nStart // addNum(value) 開始\n→ new_start ← value // 新區間的起點\n→ new_end ← value   // 新區間的終點\n→ i ← 0             // 從第一個區間開始掃描\n→ Decision: i < length(intervals)? // 是否還有區間可以檢查\n    Yes →\n        → If intervals[i].end + 1 < new_start? // 與新區間相距太遠，且在前面\n            Yes → i ← i + 1 // 跳過此區間，繼續掃描\n            No →\n                → If intervals[i].start - 1 > new_end? // 與新區間相距太遠，且在後面\n                    Yes → Break // 後續區間不可能相鄰，結束掃描\n                    No →\n                        → // 覆蓋或相鄰，進行合併\n                        → new_start ← min(new_start, intervals[i].start) // 更新起點\n                        → new_end   ← max(new_end,   intervals[i].end)   // 更新終點\n                        → intervals.remove(i) // 移除已合併的舊區間\n                        → // i 不變，因為列表已縮短，接續掃描\n        → // 回到「i < length(intervals)」的決策判斷，繼續迴圈\n    No →\n        → // 已掃描完所有區間，結束迴圈\n→ intervals.insert(i, [new_start, new_end]) // 在正確位置插入合併後的新區間\nEnd // addNum 結束\n\nStart // getIntervals() 開始\n→ return copy(intervals) // 直接回傳目前已排序、無重疊的區間清單\nEnd // getIntervals 結束"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "board = \"WRRBBW\", hand = \"RB\"",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvi525qma.py\", line 90, in <module>\n    main()\n  File \"/tmp/tmpvi525qma.py\", line 86, in main\n    result = solve(board, hand)\n             ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvi525qma.py\", line 72, in solve\n    ans = dfs(board, hand_tuple)\n          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvi525qma.py\", line 49, in dfs\n    cnt = cur_hand[c]\n          ~~~~~~~~^^^\nTypeError: tuple indices must be integers or slices, not tuple"
        },
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_vxmcl3o.py\", line 90, in <module>\n    main()\n  File \"/tmp/tmp_vxmcl3o.py\", line 86, in main\n    result = solve(board, hand)\n             ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_vxmcl3o.py\", line 72, in solve\n    ans = dfs(board, hand_tuple)\n          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_vxmcl3o.py\", line 49, in dfs\n    cnt = cur_hand[c]\n          ~~~~~~~~^^^\nTypeError: tuple indices must be integers or slices, not tuple"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp23yhletk.py\", line 90, in <module>\n    main()\n  File \"/tmp/tmp23yhletk.py\", line 86, in main\n    result = solve(board, hand)\n             ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp23yhletk.py\", line 72, in solve\n    ans = dfs(board, hand_tuple)\n          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp23yhletk.py\", line 49, in dfs\n    cnt = cur_hand[c]\n          ~~~~~~~~^^^\nTypeError: tuple indices must be integers or slices, not tuple"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\ndef solve(board: str, hand: str) -> int:\n    INF = 10 ** 9\n    # Count balls in hand\n    hand_cnt = defaultdict(int)\n    for c in hand:\n        hand_cnt[c] += 1\n\n    memo = {}\n\n    # Helper to collapse board after insertion\n    def collapse(s: str) -> str:\n        changed = True\n        while changed:\n            changed = False\n            i = 0\n            n = len(s)\n            while i < n:\n                j = i\n                while j < n and s[j] == s[i]:\n                    j += 1\n                if j - i >= 3:\n                    s = s[:i] + s[j:]\n                    changed = True\n                    break\n                i = j\n        return s\n\n    def dfs(cur_board: str, cur_hand: tuple) -> int:\n        key = (cur_board, cur_hand)\n        if key in memo:\n            return memo[key]\n        if not cur_board:\n            memo[key] = 0\n            return 0\n        result = INF\n        n = len(cur_board)\n        i = 0\n        while i < n:\n            j = i\n            while j < n and cur_board[j] == cur_board[i]:\n                j += 1\n            color = cur_board[i]\n            seg_len = j - i\n            for c in cur_hand:\n                cnt = cur_hand[c]\n                if cnt == 0:\n                    continue\n                need = 3 - seg_len\n                if need <= 0:\n                    # segment already removable by collapse\n                    continue\n                if need > cnt:\n                    continue\n                # Create new state after inserting 'need' balls of color c\n                new_board = cur_board[:i] + cur_board[j:]\n                new_board = collapse(new_board)\n                new_hand = dict(cur_hand)\n                new_hand[c] -= need\n                sub = dfs(new_board, tuple(sorted((k, v) for k, v in new_hand.items() if v > 0)))\n                if sub != INF:\n                    result = min(result, 1 + sub)\n            i = j\n        memo[key] = result\n        return result\n\n    # Convert hand_cnt to tuple sorted for hashing\n    hand_tuple = tuple(sorted((k, v) for k, v in hand_cnt.items() if v > 0))\n    ans = dfs(board, hand_tuple)\n    return -1 if ans == INF else ans\n\ndef main():\n    data = sys.stdin.read()\n    # Extract strings inside double quotes\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        board, hand = matches[0], matches[1]\n    else:\n        # Fallback: split by whitespace\n        parts = data.strip().split()\n        board = parts[0]\n        hand = parts[1] if len(parts) > 1 else ''\n    result = solve(board, hand)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the Zuma variant problem. The code will find minimal insertions to clear board using hand balls. Typical solution uses DFS with memoization, state = board + hand counts, returns min steps or INF.\n\nWe need to produce step-by-step pseudocode with explanations, using the format specified.\n\nLet's craft: Start, define function minInsertions(board, hand). Then transform hand into counts. Use DFS helper.\n\nWe need to include decisions, loops, recursion, memoization.\n\nWe'll produce a linear pseudo-code with explanations. Use arrow notation.\n\nWe'll need to manage states: board string, hand counts (e.g., dict). For memoization key: board + hand counts string.\n\nIn DFS: if board empty return 0. If state in memo return memo. Else set result = INF.\n\nLoop over board positions to find runs of same color: find segment start and end indices.\n\nFor each segment, if segment length + needed <= 3? Actually need to remove if after insertion we can get 3 or more. For each color c, if hand[c] > 0, compute need = 3 - lenSegment. If need <= hand[c], then we can insert need balls at that position: create new board by removing that segment and merging left and right after removal. We need to simulate removal recursively: After insertion, we might trigger chain reaction, so we call DFS on new board after collapse.\n\nSo pseudocode: for each i over board indices, find j such that board[i:j] same color. Let color = board[i]. For each color in hand, if hand[color]>0, if need <= hand[color], then create newBoard = board[:i] + board[j:] (but after insertion, we need to consider we inserted need balls, so the segment after insertion has length >=3 and is removed; we can just remove it). But actually after insertion, the segment length becomes lenSegment + need; since it's >=3, it will be removed, and the rest of board will collapse. So we form newBoard = board[:i] + board[j:] (since inserted balls fill segment). But we need to consider merging of adjacent same color after removal: we can call collapse function to remove consecutive groups of 3+.\n\nWe can implement collapse recursively: while True: find any segment length >=3, remove it, then continue.\n\nSimplify: after removal of the segment, we can recursively call collapse until no more removal. But we can just call DFS on the collapsed board. The DFS will handle removal if there are groups initially? Actually we should collapse before passing to DFS to ensure board has no groups.\n\nThus we need collapse function.\n\nBut in pseudocode, we can just state: collapse newBoard recursively.\n\nWe also need to track remaining hand: newHand = hand copy, subtract need from hand[color].\n\nThen steps = 1 + DFS(newBoard, newHand). Update result.\n\nAfter loop, store memo[state] = result or INF.\n\nIf result INF return -1 else result.\n\nEdge: if no possible insertion return INF.\n\nNow produce pseudocode lines with explanations.\n\nUse arrow notation: \"→ Step: ...\".\n\nWe need to structure decisions.\n\nLet's produce:\n\nStart\n→ Function minInsertions(board, hand) // entry\n    → Convert hand to countMap // e.g., {'R':2,...}\n    → Return DFS(board, countMap) // start recursion\n→ End\n\nDefine DFS\n    → Input board, handCount\n    → If board empty // all cleared\n        Yes → Return 0 // no more insertions needed\n    → Create key = board + handCount string // for memo\n    → If key in memo\n        Yes → Return memo[key]\n    → Set result = INF\n    → For i from 0 to len(board)-1\n        → Find j such that board[i:j] same color\n        → color = board[i]\n        → segLen = j-i\n        → For each c in handCount\n            → If handCount[c] == 0\n                No → continue\n            → need = 3 - segLen\n            → If need <= 0 // segment already removable? But we should collapse first\n                No → // handled by collapse earlier\n            → If need > handCount[c]\n                No → continue\n            → newHand = copy(handCount)\n            → newHand[c] -= need\n            → newBoard = board[:i] + board[j:] // after inserting need balls, segment removed\n            → newBoard = collapse(newBoard) // remove any new groups\n            → sub = DFS(newBoard, newHand)\n            → If sub != INF\n                Yes → result = min(result, 1 + sub)\n    → If result == INF\n        Yes → memo[key] = INF\n        No → memo[key] = result\n    → Return memo[key] // either INF or min steps\n\nDefine collapse\n    → Input board\n    → While True\n        → flag = False\n        → i=0\n        → While i < len(board)\n            → j=i\n            → While j < len(board) and board[j]==board[i]\n                → j++\n            → If j-i >=3\n                → board = board[:i] + board[j:]\n                → flag = True\n                → Break // restart scan from beginning\n            → i = j\n        → If flag == False\n            → Break\n    → Return board\n\nAt the end, call minInsertions and if result INF return -1 else result.\n\nBut we need to produce each line with arrow and comment.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function minInsertions(board, hand) // 主函式，接收棋盤與手牌  \n    → Convert hand to countMap // 把手牌字串轉成每顏色球數量的字典  \n    → Return DFS(board, countMap) // 開始遞迴搜索最少插入數  \n→ End // 程式結束  \n\nFunction DFS(board, handCount) // 以棋盤狀態與手牌數量作為參數  \n    → If board is empty // 棋盤已清空  \n        Yes → Return 0 // 無需再插入球  \n    → key = board + serialize(handCount) // 將狀態序列化作為 memo 的鍵  \n    → If key in memo  \n        Yes → Return memo[key] // 直接回傳已計算的結果  \n    → result = INF // 初始最小步數設為無窮大  \n    → For i from 0 to len(board)-1  \n        → Find j such that board[i:j] 為相同顏色的連續球段  \n        → color = board[i] // 這段球的顏色  \n        → segLen = j - i // 這段球的長度  \n        → For each c in handCount keys // 遍歷手牌中的顏色  \n            → If handCount[c] == 0  \n                No → Continue // 該顏色球已無可用  \n            → need = 3 - segLen // 需要插入的球數才能使該段可被移除  \n            → If need <= 0  \n                No → Continue // 這段已可直接移除，已在 collapse 處理  \n            → If need > handCount[c]  \n                No → Continue // 手牌中此顏色不足以插入  \n            → newHand = copy(handCount) // 複製手牌數量  \n            → newHand[c] -= need // 消耗 need 顏色球  \n            → newBoard = board[:i] + board[j:] // 插入球後即移除整段，得到新棋盤  \n            → newBoard = collapse(newBoard) // 進行連鎖移除  \n            → sub = DFS(newBoard, newHand) // 遞迴求解子問題  \n            → If sub != INF  \n                Yes → result = min(result, 1 + sub) // 更新最小步數  \n    → If result == INF  \n        Yes → memo[key] = INF // 這個狀態無解  \n    → Else  \n        No → memo[key] = result // 記錄最小步數  \n    → Return memo[key] // 回傳此狀態的結果  \n\nFunction collapse(board) // 連鎖移除相同顏色的 3 個以上球  \n    → While True  \n        → flag = False // 旗標判斷是否有移除發生  \n        → i = 0  \n        → While i < len(board)  \n            → j = i  \n            → While j < len(board) and board[j] == board[i]  \n                → j++  \n            → If j - i >= 3  \n                → board = board[:i] + board[j:] // 移除該段  \n                → flag = True // 觸發移除  \n                → Break // 重新從頭掃描  \n            → i = j  \n        → If flag == False  \n            → Break // 無更多可移除段  \n    → Return board // 回傳已消除後的棋盤  \n\n// 主程式執行流程  \n→ ans = minInsertions(board, hand)  \n→ If ans == INF  \n    Yes → Output -1 // 無法清空棋盤  \n→ Else  \n    No → Output ans // 最少插入球數  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Can Place Flowers",
      "source_file": "Leetcode/leetcode605.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "flowerbed = [1,0,0,0,1], n = 1",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjx0os877.py\", line 29, in <module>\n    n_part = parts[1].split('=')[1].strip()\n             ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "flowerbed = [1,0,0,0,1], n = 2",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6umzlsnb.py\", line 29, in <module>\n    n_part = parts[1].split('=')[1].strip()\n             ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canPlaceFlowers(self, flowerbed, n):\n        count = 0\n        length = len(flowerbed)\n        i = 0\n        while i < length:\n            if flowerbed[i] == 0:\n                empty_prev = (i == 0) or (flowerbed[i - 1] == 0)\n                empty_next = (i == length - 1) or (flowerbed[i + 1] == 0)\n                if empty_prev and empty_next:\n                    flowerbed[i] = 1\n                    count += 1\n                    if count >= n:\n                        return True\n                    i += 1  # skip the next spot because we just planted\n            i += 1\n        return count >= n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Expect format: \"flowerbed = [1,0,0,0,1], n = 1\"\n    parts = data.split(',')\n    fb_part = parts[0].split('=')[1].strip()\n    n_part = parts[1].split('=')[1].strip()\n    flowerbed = ast.literal_eval(fb_part)\n    n = int(n_part)\n    result = Solution().canPlaceFlowers(flowerbed, n)\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for this problem: given flowerbed array of 0/1 and n, check if can plant n flowers no adjacent. Classic solution: iterate over array, if current 0 and neighbors 0, plant and decrement n. Finally return n <= 0. But we need to produce virtual code lines. Use Start, Decision, etc. Provide each step. Must not output actual code. Use virtual code arrow →. Each line: \"虛擬碼步驟 // 解釋\". We'll produce a flowchart style. Might include initialization. Use decision for bounds. Steps: Start, Step: set i=0. Step: while i < len(flowerbed) // loop over plots. Decision: if flowerbed[i]==0? else go to next. If 0, check left and right: left_ok = (i==0 or flowerbed[i-1]==0); right_ok = (i==len-1 or flowerbed[i+1]==0). Decision: if left_ok and right_ok? Yes → plant: flowerbed[i]=1; n=n-1. Then Decision: if n==0? Yes → return true. Continue. End loop. After loop, return false (or n<=0). Use Decision after loop: if n<=0? Yes return true else false. But we may embed after loop. Let's structure.\n\nWe'll produce lines:\n\nStart // 程式開始\n→ Step 1: i ← 0 // 初始化索引\n→ Decision: i < len(flowerbed)? // 是否還有未檢查的地點\n    Yes → Step 2: 如果 flowerbed[i] == 0? // 檢查當前地點是否空\n        Yes → Step 3: left_ok ← (i == 0 or flowerbed[i-1] == 0) // 檢查左鄰是否空\n              → Step 4: right_ok ← (i == len(flowerbed)-1 or flowerbed[i+1] == 0) // 檢查右鄰是否空\n              → Decision: left_ok and right_ok? // 是否兩邊皆可種\n                    Yes → Step 5: flowerbed[i] ← 1 // 種植花\n                          → Step 6: n ← n - 1 // 新花數量減 1\n                          → Decision: n == 0? // 是否已種完所有需要的花\n                                Yes → End // 返回 true（即程式結束）\n                                No → // 轉到下一個索引\n                    No → // 不能種，直接跳到下一個索引\n            No → // 當前地點已被佔用，直接跳到下一個索引\n        → Step 7: i ← i + 1 // 移到下一個位置\n        → Decision: i < len(flowerbed)? // 重新判斷是否還有位置\n            Yes → // 迴圈繼續\n            No → // 迴圈結束\n→ Decision: n <= 0? // 最後檢查是否已種完\n    Yes → End // 返回 true\n    No → End // 返回 false\n\nBut the \"End\" is ambiguous: we need to specify return true/false. We can include: End // 程式結束，返回 true/false. Or separate \"End // 程式執行結束\". Provide explanation.\n\nHowever, we need to output \"虛擬碼步驟\" then comment. Let's produce lines accordingly. Use arrow at beginning of each step. The format: \"→ Step X: ...\" with comment after //. For decisions, use \"Decision: ...\". Provide indentation maybe. But we need each line as a separate output line. Use line breaks. Provide final End.\n\nWe might not need to write \"End // 返回 true\" multiple times; we can have a single end after decision. But for clarity, we can produce a step \"Return true\" or \"Return false\" before End.\n\nBut the output format says: \"虛擬碼步驟 [空格] // 解釋\". So each line starts with either Start, → Step, Decision, End. Provide comment. For decisions, we include indent with Yes → etc. Provide each line as separate.\n\nLet's write:\n\nStart // 程式開始\n→ Step 1: i ← 0 // 初始化索引\n→ Decision: i < len(flowerbed)? // 仍有未檢查的位置？\n    Yes → Step 2: if flowerbed[i] == 0? // 檢查當前地點是否空\n        Yes → Step 3: left_ok ← (i == 0 or flowerbed[i-1] == 0) // 檢查左鄰是否空\n              → Step 4: right_ok ← (i == len(flowerbed)-1 or flowerbed[i+1] == 0) // 檢查右鄰是否空\n              → Decision: left_ok and right_ok? // 是否兩邊皆可種？\n                    Yes → Step 5: flowerbed[i] ← 1 // 種植花\n                          → Step 6: n ← n - 1 // 新花數量減 1\n                          → Decision: n == 0? // 已種完所有需要的花？\n                                Yes → End // 返回 true，程式結束\n                                No → // 仍需種，繼續\n                    No → // 無法種植，跳過\n        No → // 當前地點已佔用，跳過\n    → Step 7: i ← i + 1 // 移至下一個位置\n    → Decision: i < len(flowerbed)? // 再次檢查是否有剩餘位置？\n        Yes → // 回到最前面\n        No → // 迴圈結束\n→ Decision: n <= 0? // 檢查剩餘需要的花是否為 0 或負\n    Yes → End // 可種植，返回 true\n    No → End // 無法種植，返回 false\n\nBut we must ensure each line is separate; indent lines for nested decisions? Probably yes but not mandatory. But we need to produce each line as separate line of text. The arrow indicates nested steps. For clarity, we can indent with tabs or spaces. The format sample uses indentation with spaces. We'll use spaces for nested.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: i ← 0 // 初始化索引，從第一個地點開始檢查\n→ Decision: i < len(flowerbed)? // 是否還有未檢查的地點？\n    Yes → Step 2: if flowerbed[i] == 0? // 當前地點是否為空？\n        Yes → Step 3: left_ok ← (i == 0 or flowerbed[i-1] == 0) // 檢查左鄰是否為空\n              → Step 4: right_ok ← (i == len(flowerbed)-1 or flowerbed[i+1] == 0) // 檢查右鄰是否為空\n              → Decision: left_ok and right_ok? // 左右兩邊都可以種花？\n                    Yes → Step 5: flowerbed[i] ← 1 // 種植花\n                          → Step 6: n ← n - 1 // 剩餘需要種植的新花數量減 1\n                          → Decision: n == 0? // 已經種完所有需要的新花？\n                                Yes → End // 成功完成，返回 true，程式結束\n                                No → // 還有花需要種植，繼續檢查\n                    No → // 這個位置無法種植，跳過\n        No → // 這個地點已被佔用，跳過\n    → Step 7: i ← i + 1 // 移到下一個地點\n    → Decision: i < len(flowerbed)? // 再次判斷是否還有地點可檢查？\n        Yes → // 重新進入迴圈的第一個 Decision\n        No → // 迴圈結束，進入最終判斷\n→ Decision: n <= 0? // 檢查剩餘需要種植的花是否已經為 0 或負數\n    Yes → End // 可以種植完畢，返回 true\n    No → End // 無法滿足需求，返回 false"
    },
    {
      "title": "K-diff Pairs in an Array",
      "source_file": "Leetcode/leetcode532.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[3,1,4,1,5], 2",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvip1eciu.py\", line 39, in <module>\n    main()\n  File \"/tmp/tmpvip1eciu.py\", line 35, in main\n    result = solution.findPairs(nums, k)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvip1eciu.py\", line 10, in findPairs\n    freq = Counter(nums)          # 建立頻率映射\n           ^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/collections/__init__.py\", line 607, in __init__\n    self.update(iterable, **kwds)\n  File \"/usr/lib/python3.12/collections/__init__.py\", line 699, in update\n    _count_elements(self, iterable)\nTypeError: unhashable type: 'list'"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4,5], 1",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpstug0u_j.py\", line 39, in <module>\n    main()\n  File \"/tmp/tmpstug0u_j.py\", line 35, in main\n    result = solution.findPairs(nums, k)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpstug0u_j.py\", line 10, in findPairs\n    freq = Counter(nums)          # 建立頻率映射\n           ^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/collections/__init__.py\", line 607, in __init__\n    self.update(iterable, **kwds)\n  File \"/usr/lib/python3.12/collections/__init__.py\", line 699, in update\n    _count_elements(self, iterable)\nTypeError: unhashable type: 'list'"
        },
        {
          "example_index": 2,
          "input": "[1,3,1,5,4], 0",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5shu3btj.py\", line 39, in <module>\n    main()\n  File \"/tmp/tmp5shu3btj.py\", line 35, in main\n    result = solution.findPairs(nums, k)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5shu3btj.py\", line 10, in findPairs\n    freq = Counter(nums)          # 建立頻率映射\n           ^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/collections/__init__.py\", line 607, in __init__\n    self.update(iterable, **kwds)\n  File \"/usr/lib/python3.12/collections/__init__.py\", line 699, in update\n    _count_elements(self, iterable)\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findPairs(self, nums, k):\n        \"\"\"返回数组中所有唯一的 k-diff 对数目\"\"\"\n        if k < 0:\n            return 0\n        freq = Counter(nums)          # 建立頻率映射\n        if k == 0:\n            # k == 0 時，只計算出現次數>1 的數字對\n            return sum(v > 1 for v in freq.values())\n        # k > 0 時，檢查每個數字是否存在相差 k 的另一個數字\n        return sum(n + k in freq for n in freq)\n\ndef main():\n    # 讀取整個輸入，支援多行\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 以最後一個 ',' 為分隔符，左邊是列表字串，右邊是 k\n    idx = data.rfind(',')\n    if idx == -1:\n        raise ValueError(\"輸入格式錯誤，請提供 '[list], k'\")\n    nums_str = data[:idx+1]        # 包含結尾的 ']'\n    k_str = data[idx+1:].strip()   # 可能含有空格\n    try:\n        nums = ast.literal_eval(nums_str)\n        k = int(k_str)\n    except Exception as e:\n        raise ValueError(\"無法解析輸入\") from e\n\n    solution = Solution()\n    result = solution.findPairs(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to count unique k-diff pairs. Use set or hashmap. Steps: if k<0? then return 0. Build frequency map. Then if k==0: count numbers with freq>1. Else: for each num in map keys, if num+k exists, count++. End. Provide step lines with comments. Use Start, Decision. Use arrow syntax. Ensure each line has \"// 解釋/說明\". Provide lines for Start, build freq map, decision for k<0, etc. Provide End. Ensure each line ends with comment. Ensure format. Let's craft.\n\nWe need to show lines like:\n\nStart // 程式開始執行\n→ Step 1: 建立頻率映射 freq ← 空字典 // 將每個數字的出現次數記錄\n→ Step 2: 對 nums 中每個 num: freq[num] ← freq.get(num, 0) + 1 // 計算頻率\n→ Decision: k < 0? // k 差值負數時無解\n    Yes → Step 3: Return 0 // 直接結束\n    No  → Step 4: 如果 k == 0? // 特殊情況\n        Yes → Step 5: count ← 0\n        → Step 6: 對 freq 中每個 (num, count) 若 count > 1: count ← count + 1 // 有重複則算一對\n        → End? // ...\nBut better to use structured decisions: use Decision: k == 0? and else block.\n\nWe need to maintain End at bottom.\n\nLet's produce.\n\nBe careful about arrows and indentation. The example uses spaces indentation for nested lines: \"    Yes → Step 2:\" etc. Use same.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: freq ← 空字典 // 建立一個字典來記錄每個數字的出現次數  \n→ Step 2: 對 nums 中的每個 num 做: freq[num] ← freq.get(num, 0) + 1 // 將頻率累加  \n→ Decision: k < 0? // k 差值為負無法成立  \n  Yes → Step 3: Return 0 // 直接返回 0，結束程式  \n  No → Decision: k == 0? // 特殊處理 k 為 0 的情況  \n    Yes → Step 4: count ← 0 // 初始化計數器  \n     → Step 5: 對 freq 中每個 (num, cnt) 做:  \n        If cnt > 1? // 至少出現兩次才能成對  \n         Yes → count ← count + 1 // 計入一對  \n         No  → 死循環不執行 // 無需處理  \n     → Step 6: Return count // 返回符合條件的對數  \n    No → Step 7: count ← 0 // 初始化計數器，處理 k > 0 的情況  \n     → Step 8: 對 freq 中每個 num 做:  \n        If num + k 在 freq 中? // 檢查相差 k 的另一個數字是否存在  \n         Yes → count ← count + 1 // 成功配對，計數加一  \n         No  → 死循環不執行 // 無對可配  \n     → Step 9: Return count // 返回最終計數  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp32eqs8n1.py\", line 95, in <module>\n    main()\n  File \"/tmp/tmp32eqs8n1.py\", line 62, in main\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0\n        self.count = 0\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    res = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(args[0])\n            res.append(\"null\")\n        elif op == \"insertFront\":\n            res.append(str(obj.insertFront(args[0]).lower()))\n        elif op == \"insertLast\":\n            res.append(str(obj.insertLast(args[0]).lower()))\n        elif op == \"deleteFront\":\n            res.append(str(obj.deleteFront().lower()))\n        elif op == \"deleteLast\":\n            res.append(str(obj.deleteLast().lower()))\n        elif op == \"getFront\":\n            res.append(str(obj.getFront()))\n        elif op == \"getRear\":\n            res.append(str(obj.getRear()))\n        elif op == \"isEmpty\":\n            res.append(str(obj.isEmpty().lower()))\n        elif op == \"isFull\":\n            res.append(str(obj.isFull().lower()))\n        else:\n            # unknown operation, skip\n            pass\n\n    print(f\"[{', '.join(res)}]\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation, line by line. We need to design the implementation of a circular deque. The virtual code should be a step-by-step representation of the algorithm. Not actual code, but pseudocode. Use arrows, decisions. We need to output per line: \"虛擬碼步驟 // 解釋\". So each line includes code-like step and comment. Use structure Start, End, Decision: etc.\n\nWe need to design the implementation of the class with methods. Provide steps for constructor, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.\n\nWe should produce the virtual code for each method, but perhaps group as steps? The user wants \"逐行地產生對應的虛擬碼\". Probably each method's steps. But we could provide high-level algorithm: initialize array, front, rear pointers, etc. For each operation, show steps. Use Decision nodes to check conditions.\n\nWe'll output something like:\n\nStart // 初始化\n→ Step: MyCircularDeque(k) // 建立大小k的循環陣列\n→ Set array = new int[k]\n→ Set front = 0\n→ Set rear = -1\n→ Set size = 0\n→ End // 建構完成\n\nThen for insertFront: check if full, else adjust front, put value, size++.\n\nWe'll need to include the value parameter but not actual code. Maybe \"insertFront(value)\"? The requirement: insertFront() Adds an item at the front, returns bool. It expects a value param. But signature missing value? Usually insertFront(int value). We'll include placeholder. Provide steps.\n\nSimilarly for insertLast(value).\n\nAlso deleteFront: check empty.\n\nAlso getFront: return front value or -1.\n\nAll functions.\n\nWe'll present each method's steps as separate sequences, with Start/End. We'll keep the format.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: MyCircularDeque(k) // 建立大小為 k 的循環雙端佇列\n    → Allocate array[0…k-1] // 用固定長度陣列儲存資料\n    → Set front = 0      // 前端指標指向最前面位置\n    → Set rear = k-1      // 後端指標指向最後面位置，因循環而設為 k-1\n    → Set count = 0      // 目前佇列中元素個數\n→ End // 佇列初始化完成\n\nStart // insertFront(value) // 將值插入佇列前端\n    → Decision: 若 count == k? // 檢查佇列是否已滿\n        Yes → Return false // 無法插入，佇列已滿\n        No  → front = (front - 1 + k) % k // 前端指標倒退，保持循環\n              → array[front] = value      // 將值存入新前端\n              → count++                  // 元素數量加一\n              → Return true              // 插入成功\n→ End // insertFront 執行結束\n\nStart // insertLast(value) // 將值插入佇列後端\n    → Decision: 若 count == k? // 檢查佇列是否已滿\n        Yes → Return false // 無法插入，佇列已滿\n        No  → rear = (rear + 1) % k // 後端指標前進，保持循環\n              → array[rear] = value   // 將值存入新後端\n              → count++               // 元素數量加一\n              → Return true           // 插入成功\n→ End // insertLast 執行結束\n\nStart // deleteFront() // 刪除佇列前端元素\n    → Decision: 若 count == 0? // 檢查佇列是否為空\n        Yes → Return false // 無法刪除，佇列為空\n        No  → front = (front + 1) % k // 前端指標前進，移除前端元素\n              → count--                // 元素數量減一\n              → Return true            // 刪除成功\n→ End // deleteFront 執行結束\n\nStart // deleteLast() // 刪除佇列後端元素\n    → Decision: 若 count == 0? // 檢查佇列是否為空\n        Yes → Return false // 無法刪除，佇列為空\n        No  → rear = (rear - 1 + k) % k // 後端指標倒退，移除後端元素\n              → count--                 // 元素數量減一\n              → Return true             // 刪除成功\n→ End // deleteLast 執行結束\n\nStart // getFront() // 取得佇列前端元素\n    → Decision: 若 count == 0? // 檢查佇列是否為空\n        Yes → Return -1 // 空佇列回傳 -1\n        No  → Return array[front] // 回傳前端元素\n→ End // getFront 執行結束\n\nStart // getRear() // 取得佇列後端元素\n    → Decision: 若 count == 0? // 檢查佇列是否為空\n        Yes → Return -1 // 空佇列回傳 -1\n        No  → Return array[rear] // 回傳後端元素\n→ End // getRear 執行結束\n\nStart // isEmpty() // 檢查佇列是否為空\n    → Decision: 若 count == 0? // 若元素數量為零\n        Yes → Return true   // 佇列為空\n        No  → Return false  // 佇列非空\n→ End // isEmpty 執行結束\n\nStart // isFull() // 檢查佇列是否已滿\n    → Decision: 若 count == k? // 若元素數量等於最大容量\n        Yes → Return true   // 佇列已滿\n        No  → Return false  // 佇列未滿\n→ End // isFull 執行結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmmoycxgo.py\", line 40, in <module>\n    result = Solution().complexNumberMultiply(a_str, b_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmmoycxgo.py\", line 20, in complexNumberMultiply\n    a_real, a_imag = parse(a)\n                     ^^^^^^^^\n  File \"/tmp/tmpmmoycxgo.py\", line 17, in parse\n    imag = int(s[sep_index:])\n           ^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '+-1'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        \"\"\"將兩個複數字串相乘，回傳字串形式\"\"\"\n        def parse(s: str):\n            \"\"\"解析 'real+imagi' 或 'real-imagi' 形式的字串，回傳 (real, imag)\"\"\"\n            s = s.rstrip('i')                     # 去掉尾端的 i\n            # 找到實部與虛部的分隔符號，從第二個字元起搜尋 + 或 -\n            sep_index = -1\n            for i in range(1, len(s)):\n                if s[i] in '+-':\n                    sep_index = i\n                    break\n            real = int(s[:sep_index])\n            imag = int(s[sep_index:])\n            return real, imag\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        # (a+bi)(c+di) = (ac-bd) + (ad+bc)i\n        real_part = a_real * b_real - a_imag * b_imag\n        imag_part = a_real * b_imag + a_imag * b_real\n\n        return f\"{real_part}+{imag_part}i\"\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取兩個複數字串，格式如 \"1+1i\", \"1+1i\"\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # 用 ast.literal_eval 解析成兩個字串\n    try:\n        a_str, b_str = ast.literal_eval(f\"({raw_input})\")\n    except Exception:\n        # 若輸入格式不符，直接結束\n        sys.exit()\n    result = Solution().complexNumberMultiply(a_str, b_str)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode for multiplying two complex numbers represented as strings \"a+bi\". Need to parse, multiply, format back. Use virtual code lines with arrow and comments. Must follow format. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision.\n\nOk produce steps: Start, parse num1, parse num2, multiply: (a+bi)*(c+di)= (ac - bd) + (ad+bc)i. Then format string: real + (sign) imaginary + 'i'. End.\n\nWe need step by step: maybe parse function: extract real and imag. Could split on '+' or '-' but handle negative imag. Simpler: replace 'i' and split. But virtual code: Step: ParseComplex(str) returns real, imag. Then multiplication.\n\nWe should include decision if imaginary negative? But formatting sign. Use Step: If imag < 0? produce '-' else '+'. etc.\n\nLet's produce.\n\nWe'll use \"Step 1: ParseComplex(num1)\" etc.\n\nWill use arrow lines.\n\nMake sure each line ends with comment.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: ParseComplex(num1) → real1, imag1 // 解析第一個複數字串，取得實部與虛部  \n→ Step 2: ParseComplex(num2) → real2, imag2 // 解析第二個複數字串，取得實部與虛部  \n→ Step 3: Calculate product  \n  → realPart = real1 * real2 - imag1 * imag2 // 實部計算 (ac - bd)  \n  → imagPart = real1 * imag2 + imag1 * real2 // 虛部計算 (ad + bc)  \n→ Step 4: Format result string  \n  → Decision: 如果 imagPart < 0? // 判斷虛部符號  \n    Yes → sign = \"-\" // 虛部為負  \n    No  → sign = \"+\" // 虛部為正  \n  → result = realPart + sign + abs(imagPart) + \"i\" // 組合成 \"real±imagi\"  \n→ Step 5: Return result // 回傳乘積的字串表示  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        # Map file content to list of full file paths\n        content_map = defaultdict(list)\n\n        for path in paths:\n            parts = path.split()\n            root = parts[0]  # directory path\n            for file_info in parts[1:]:\n                # file_info format: name(content)\n                name, content = file_info.split('(')\n                content = content[:-1]  # remove trailing ')'\n                full_path = f\"{root}/{name}\"\n                content_map[content].append(full_path)\n\n        # Keep only groups with at least two files\n        return [files for files in content_map.values() if len(files) > 1]\n\ndef main():\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # Expect input like: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\", ...]\n    if raw_input.startswith(\"paths\"):\n        # Remove the leading variable assignment\n        raw_input = raw_input.split(\"=\", 1)[1].strip()\n\n    try:\n        # Safely evaluate the list representation\n        paths = ast.literal_eval(raw_input)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        return\n\n    solution = Solution()\n    result = solution.findDuplicate(paths)\n    # Print the result in Python list syntax\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation. Problem: Given list of strings representing directory info, find duplicate files based on content. Need algorithm: parse each string, extract directory path, then for each file get name and content. Map content to list of full paths. After processing all, collect lists with len>1. Return those lists.\n\nWe output virtual code steps.\n\nWe need to use Start, End, Decision: arrows. Provide line per step.\n\nLet's design pseudocode.\n\nStart\n\n→ Step 1: Initialize map content_to_paths = empty map // 存放內容到檔案路徑清單\n\n→ Step 2: For each dir_info in paths // 逐一處理輸入字串\n\n→ Decision: 是否為空? // skip if empty\n\n    Yes → continue\n\n    No  → Step 3: Split dir_info by space into parts // 第一個為目錄，後面是檔案資訊\n\n→ Step 4: Set dir_path = parts[0] // 取得目錄路徑\n\n→ Step 5: For each file_desc in parts[1:] // 逐個檔案描述\n\n→ Decision: 是否含 '('? // 檢查檔案描述格式\n\n    Yes → Step 6: 解析 file_name = substring before '(' // 取得檔名\n\n    → Step 7: 解析 content = substring between '(' and ')' // 取得內容\n\n    → Step 8: 構建 full_path = dir_path + \"/\" + file_name // 組成完整路徑\n\n    → Step 9: If content not in map, map[content] = empty list\n\n    → Step 10: Append full_path to map[content] // 存檔案路徑\n\n    No → Step 11: // 若格式不符，跳過\n\n→ Step 12: End For file_desc\n\n→ Step 13: End For dir_info\n\n→ Step 14: Initialize result = empty list // 儲存重複檔案組\n\n→ Step 15: For each paths_list in map.values // 遍歷內容對應的路徑清單\n\n→ Decision: paths_list length > 1? // 有重複\n\n    Yes → Step 16: Append paths_list to result // 加入結果\n\n    No  → Step 17: // 跳過單檔\n\n→ Step 18: End For\n\n→ Step 19: Return result // 結果\n\n→ End\n\nAdd comments accordingly.\n\nWe must ensure each line includes arrow and explanation. Also indentation: for Decision: sub-steps with indent.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: content_to_paths ← empty map // 建立內容到檔案路徑的對應表\n→ Step 2: For each dir_info in paths // 逐一處理每條目錄資訊\n    → Decision: dir_info 為空? // 檢查是否為空字串\n        Yes → continue // 空字串直接跳過\n        No  → Step 3: parts ← split dir_info by space // 以空格切割得到目錄與檔案描述\n    → Step 4: dir_path ← parts[0] // 取得目錄路徑\n    → Step 5: For each file_desc in parts[1:] // 逐個處理檔案描述\n        → Decision: file_desc 包含 '('? // 檢查格式是否符合\n            Yes →\n                → Step 6: file_name ← substring before '(' in file_desc // 取得檔名\n                → Step 7: content ← substring between '(' and ')' in file_desc // 取得檔案內容\n                → Step 8: full_path ← dir_path + \"/\" + file_name // 組合完整檔案路徑\n                → Step 9: If content not in content_to_paths, content_to_paths[content] ← empty list // 初始化清單\n                → Step 10: Append full_path to content_to_paths[content] // 加入此內容的檔案路徑\n            No → Step 11: // 若格式不符，忽略此檔案描述\n        → End Decision\n    → End For // file_desc\n→ End For // dir_info\n→ Step 12: result ← empty list // 用於儲存重複檔案組\n→ Step 13: For each paths_list in content_to_paths.values // 逐一檢查每個內容對應的路徑清單\n    → Decision: length of paths_list > 1? // 判斷是否有重複\n        Yes → Step 14: Append paths_list to result // 加入結果\n        No  → // 單檔案，忽略\n    → End Decision\n→ End For\n→ Step 15: Return result // 回傳所有重複檔案組\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[7]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[7]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[3,7]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[3, 7]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[3,1,1]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[3, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport random\n\n# 本範例提供 rand7 的簡易實作\n# 在正式測試環境下，平台通常會提供自己的 rand7 API，這裡僅作示範\ndef rand7() -> int:\n    \"\"\"返回 1~7 的均勻隨機整數（使用內建 random 供示範）\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    \"\"\"使用 rand7 產生 1~10 的均勻隨機整數\"\"\"\n    def rand10(self) -> int:\n        while True:\n            # 兩次 rand7 產生 1~49 的均勻分佈\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:                     # 只保留 1~40，避免偏差\n                return 1 + (num - 1) % 10     # 映射到 1~10\n\ndef main() -> None:\n    # 讀取標準輸入，格式可能為 \"n = 3\" 或類似\n    data = sys.stdin.read().strip()\n    match = re.search(r'n\\s*=\\s*(\\d+)', data)\n    if not match:\n        return\n    n = int(match.group(1))\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for rand10() using rand7(). Classic solution: use two rand7() to generate numbers 1-49. Rejection sampling: if result <= 40, map to 1-10. If >40, repeat. Alternatively use base-7 expansion, but simplest is 2 calls.\n\nWe produce step-by-step virtual code with Start, Decision, etc. Each line: Virtual code step + // explanation.\n\nInclude loop for rejection.\n\nAlso need to mention number of calls to rand7 per rand10 call: expected ~2.8.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 function rand10() // 開始定義 rand10 函式  \n→   Step 2: 進入 loop  // 進行重複嘗試直到得到合法結果  \n→     Step 3: x ← rand7() // 呼叫 rand7 產生 1-7 的隨機數  \n→     Step 4: y ← rand7() // 再呼叫一次 rand7 產生 1-7 的隨機數  \n→     Step 5: num ← (x-1) * 7 + y // 轉換成 1-49 的整數  \n→     Decision: 如果 num ≤ 40? // 檢查是否落在可映射區間 1-40  \n→       Yes → Step 6: result ← (num-1) mod 10 + 1 // 映射到 1-10  \n→       Yes → Step 7: return result // 返回隨機數  \n→       No  → Step 8: 跳回 Step 3 // 重新嘗試，忽略 41-49  \nEnd // 程式執行結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n        dists.sort()\n\n        return (\n            dists[0] > 0 and\n            dists[0] == dists[1] == dists[2] == dists[3] and\n            dists[4] == dists[5] and\n            dists[4] == 2 * dists[0]\n        )\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) != 8:\n        print(\"false\")\n        sys.exit(0)\n    p1 = [nums[0], nums[1]]\n    p2 = [nums[2], nums[3]]\n    p3 = [nums[4], nums[5]]\n    p4 = [nums[6], nums[7]]\n    sol = Solution()\n    result = sol.validSquare(p1, p2, p3, p4)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm to determine if four points form a square. Provide step-by-step with arrows and comments. Should be structured. Use decision branches.\n\nWe need to consider input order not guaranteed, so algorithm should compute all pairwise distances squared, find 6 distances; there should be 2 unique distances: the smaller one (side) appears 4 times, larger one (diagonal) appears 2 times, and larger distance is double the side distance (property of square). Also ensure non-zero side length. Provide steps accordingly.\n\nAlso need to compute distance squared between points to avoid floating error.\n\nWe will produce steps:\n\nStart\n→ Step: Read points p1, p2, p3, p4 // input points\n→ Step: Compute list of all pairwise squared distances between the 4 points // 6 distances\n→ Step: Count occurrences of each unique distance in list // frequency map\n→ Decision: Are there exactly 2 distinct distances? // check uniqueness\n    Yes → Step: Let d1, d2 be the two distances (order them)\n    No  → Step: Return false // not a square\n→ Decision: Does the smaller distance appear 4 times and larger 2 times? // side vs diagonal count\n    Yes → Step: Check if larger distance equals 2 * smaller distance // right triangle property\n    No  → Step: Return false\n→ Decision: Is smaller distance > 0? // positive length\n    Yes → Step: Return true\n    No  → Step: Return false\nEnd\n\nNeed to include arrow syntax: Start, → Step 1: etc. Use arrow after decisions.\n\nAlso include comments with //.\n\nLet's write virtual code with step numbers maybe.\n\nImportant: Each line must contain \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取四個點 p1, p2, p3, p4 // 從輸入取得座標\n→ Step 2: 建立空列表 distList // 用來存儲六個距離平方\n→ Step 3: 對每對不同點計算距離平方並加入 distList // 生成六個距離值\n→ Step 4: 建立字典 freq 以記錄每個距離平方的出現頻率 // 方便統計\n→ Step 5: 遍歷 distList 更新 freq // 完成頻率統計\n→ Decision: freq 的鍵數是否等於 2? // 檢查是否只有兩種距離\n    Yes → Step 6: 將兩個距離排序得到 side, diag // side < diag\n    No  → Step 7: 回傳 false // 不是正方形\n→ Decision: side 的頻率是否為 4 且 diag 的頻率是否為 2? // 端點與對角線的數量\n    Yes → Step 8: 判斷 diag 是否等於 2 * side // 正方形對角線關係\n    No  → Step 9: 回傳 false // 數量不符\n→ Decision: side > 0? // 確保邊長正\n    Yes → Step 10: 回傳 true // 四個點構成正方形\n    No  → Step 11: 回傳 false // 兩點重合或零邊長\nEnd // 程式結束\n\nNeed to keep the structure exactly. Use \"→\" and indentation maybe.\n\nAlso ensure that the \"Step\" numbers or names are consistent; it's fine.\n\nReturn true/false accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取四個點 p1, p2, p3, p4 // 從輸入取得座標  \n→ Step 2: 建立空列表 distList // 用來存儲六個距離平方  \n→ Step 3: 對每對不同點計算距離平方並加入 distList // 生成六個距離值  \n→ Step 4: 建立字典 freq 以記錄每個距離平方的出現頻率 // 方便統計  \n→ Step 5: 遍歷 distList 更新 freq // 完成頻率統計  \n→ Decision: freq 的鍵數是否等於 2? // 檢查是否只有兩種距離  \n  Yes → Step 6: 將兩個距離排序得到 side, diag // side < diag  \n  No  → Step 7: 回傳 false // 不是正方形  \n→ Decision: side 的頻率是否為 4 且 diag 的頻率是否為 2? // 端點與對角線的數量  \n  Yes → Step 8: 判斷 diag 是否等於 2 * side // 正方形對角線關係  \n  No  → Step 9: 回傳 false // 數量不符  \n→ Decision: side > 0? // 確保邊長正  \n  Yes → Step 10: 回傳 true // 四個點構成正方形  \n  No  → Step 11: 回傳 false // 兩點重合或零邊長  \nEnd // 程式結束"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8gwfpdqp.py\", line 36, in <module>\n    ops = json.loads(data[0].strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 47 (char 46)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]                     # 原始陣列\n        self.tree = [0] * (self.n + 1)          # Fenwick 樹\n        for i, val in enumerate(nums):\n            self._update_tree(i + 1, val)       # 建構樹\n\n    def _update_tree(self, i, val):\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, i):\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    ops = json.loads(data[0].strip())\n    args = json.loads(data[1].strip()) if len(data) > 1 else []\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            obj = NumArray(arg[0])\n            result.append(None)\n        elif op == \"update\":\n            obj.update(arg[0], arg[1])\n            result.append(None)\n        elif op == \"sumRange\":\n            result.append(obj.sumRange(arg[0], arg[1]))\n\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing a NumArray class with update and sumRange, supporting multiple queries. Likely using Fenwick tree or segment tree. Provide step-by-step. We should output lines of virtual code with arrow and explanation. Use Start, End, Decision. We'll structure pseudo-code for constructor, update, sumRange using BIT. Provide lines like:\n\nStart\n→ Step 1: Initialize tree array of size n+1 with zeros\n→ Step 2: Build tree by adding each element via internal add function\n...\n\nWe need to provide separate steps for query handling maybe. But ask to produce virtual code and explanation for the algorithm. Use Decision: maybe not needed.\n\nWe should adhere to format. Provide each line with virtual code step, then // explanation. Ensure use of arrow arrows. Use \"→\" for steps. For decisions, use Decision. End. Use blank lines? Format example shows each line with arrow. We'll produce.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告變數 n ← nums.length // 取得陣列長度  \n→ Step 2: 建立大小為 n+1 的樹陣列 tree ← new int[n+1] // Fenwick 樹用  \n→ Step 3: 迭代 i 從 0 到 n-1  \n  → Sub-step: call add(i, nums[i]) // 把原始數值加入樹中  \n→ Step 4: 定義函式 add(index, delta)  \n  → Decision: index < n?  \n   Yes → 內部迴圈 while index+1 ≤ n  \n    → tree[index+1] ← tree[index+1] + delta // 更新樹節點  \n    → index ← index + (index & -index) // 移動到父節點  \n   No → 退出迴圈  \n→ Step 5: 定義函式 prefixSum(index)  \n  → 設 sum ← 0  \n  → Decision: index ≥ 0?  \n   Yes → 內部迴圈 while index+1 > 0  \n    → sum ← sum + tree[index+1] // 累加至答案  \n    → index ← index - (index & -index) // 移動到上一個節點  \n   No → 退出迴圈  \n  → Return sum  \n→ Step 6: 實作 update(index, val)  \n  → Sub-step: oldVal ← nums[index]  \n  → Sub-step: nums[index] ← val  \n  → Sub-step: delta ← val - oldVal  \n  → Sub-step: call add(index, delta) // 更新 Fenwick 樹  \n→ Step 7: 實作 sumRange(left, right)  \n  → Sub-step: result ← prefixSum(right) - prefixSum(left-1) // 取區間和  \n  → Return result  \nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar II",
      "source_file": "Leetcode/leetcode731.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, true, true, true, false, true, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpccm7z8c7.py\", line 39, in <module>\n    main()\n  File \"/tmp/tmpccm7z8c7.py\", line 26, in main\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 66 (char 65)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCalendarTwo:\n    def __init__(self):\n        self.booked = []\n        self.overlaps = []\n\n    def book(self, start, end):\n        # 檢查新事件是否與已經形成的雙重區間重疊\n        for s, e in self.overlaps:\n            if max(s, start) < min(e, end):\n                return False\n        # 收集與新事件重疊的區間，並加入 overlaps\n        for s, e in self.booked:\n            if max(s, start) < min(e, end):\n                self.overlaps.append((max(s, start), min(e, end)))\n        # 新事件可加入\n        self.booked.append((start, end))\n        return True\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    ops, args = json.loads(data)\n    result = []\n    calendar = None\n    for op, arg in zip(ops, args):\n        if op == \"MyCalendarTwo\":\n            calendar = MyCalendarTwo()\n            result.append(None)\n        elif op == \"book\":\n            result.append(calendar.book(*arg))\n    # 輸出時使用 JSON，None 對應 null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for a class MyCalendarTwo with book method. Use virtual steps. We need to outline algorithm: maintain list of events, and overlapping counts. Common approach: track intervals and overlap intervals. We'll produce steps: Start, add event to list, check overlaps, track double bookings. We'll need to implement algorithm using event list and double-book intervals. For each new event, iterate existing events to find overlap. For each overlap, create double interval. Then check if any double interval overlaps with new event. If so, reject. Else, add event to event list and add double intervals to double list. Return true.\n\nWe'll output each line with explanation. Use Start, End. Use Decision. Also maybe use loop. Provide structure.\n\nLet's write steps. Use virtual code:\n\nStart\n→ Step 1: 初始化空列表 events // 存放所有已預約事件\n→ Step 2: 初始化空列表 overlaps // 存放已形成雙重預約的區間\n→ End (constructor)\n\nMethod book(start, end)\n→ Step 1: 设定 flag = true // 标记是否可预订\n→ Decision: 若 events 为空? // 简化\n    Yes → Return true // 无冲突\n    No  → // 继续检查\n→ Step 2: 新增一个临时列表 newOverlaps // 用于收集与新事件重叠的区间\n→ Step 3: 遍历每个事件 in events\n    → Decision: 如果事件与新事件有重叠? // 计算 max(start, event.start) < min(end, event.end)\n        Yes → 计算 overlapStart = max(start, event.start)\n              overlapEnd   = min(end, event.end)\n              // 新事件与该事件产生双重预订区间\n              Append (overlapStart, overlapEnd) to newOverlaps\n        No  → // 无重叠，继续\n→ Step 4: 遍历每个区间 in newOverlaps\n    → Decision: 是否与已有 overlaps 区间重叠? // 同样判断\n        Yes → flag = false; Break\n        No  → // 继续\n→ Decision: flag?\n    Yes → // 允许预订\n        → Append (start, end) to events\n        → Append each interval in newOverlaps to overlaps\n        → Return true\n    No  → Return false\n\nLet's format with arrows and explanation.\n\nWe also need End for method.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 events 為空列表 // 儲存所有已成功預約的事件  \n→ Step 2: 初始化 overlaps 為空列表 // 儲存所有雙重預約的區間  \n→ End // 建構子完成初始化  \n\n---\n\nMyCalendarTwo.book(start, end) // 開始預約檢查  \n\n→ Step 1: 設定 flag 為 true // 假設此事件可以被加入  \n→ Decision: 如果 events 為空? // 無任何預約可直接允許  \n  Yes → Return true // 直接回傳成功  \n  No  → // 進一步檢查與現有事件的重疊  \n\n→ Step 2: 建立 newOverlaps 為空列表 // 用於暫存與本事件重疊的雙重區間  \n→ Step 3: 針對 events 中每一個 event  \n  Decision: 是否存在重疊? // 判斷 max(start, event.start) < min(end, event.end)  \n   Yes →  \n    → 計算 overlapStart = max(start, event.start)  \n    → 計算 overlapEnd   = min(end, event.end)  \n    → 將 (overlapStart, overlapEnd) 加入 newOverlaps // 新雙重區間  \n    No → // 無重疊，跳過  \n\n→ Step 4: 針對 newOverlaps 中每一個 interval  \n  Decision: interval 與 overlaps 中是否有重疊? // 同樣判斷 max(interval.start, overlap.start) < min(interval.end, overlap.end)  \n   Yes →  \n    → 設定 flag 為 false  \n    → 跳出循環 // 發現會形成三重預約，直接拒絕  \n    No → // 沒有三重重疊，繼續檢查  \n\n→ Decision: flag 為 true? // 可以成功預約  \n  Yes →  \n   → 將 (start, end) 加入 events // 存入新事件  \n   → 將 newOverlaps 中所有 interval 加入 overlaps // 更新雙重區間  \n   → Return true // 預約成功  \n  No →  \n   → Return false // 三重預約，拒絕  \n\n→ End // 方法執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"\n        Reorder nums in-place so that nums[0] < nums[1] > nums[2] < nums[3] ...\n        \"\"\"\n        n = len(nums)\n        for i in range(n - 1):\n            if i % 2 == 0:  # even index: want nums[i] < nums[i+1]\n                if nums[i] >= nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n            else:          # odd index: want nums[i] > nums[i+1]\n                if nums[i] <= nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Parse input string of the form 'nums = [1,5,1,1,6,4]' or just '[1,5,1,1,6,4]'.\n    \"\"\"\n    input_str = input_str.strip()\n    # Extract the part inside brackets\n    match = re.search(r'\\[.*\\]', input_str)\n    if not match:\n        raise ValueError(\"Invalid input format\")\n    list_str = match.group(0)\n    return ast.literal_eval(list_str)\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    nums = parse_input(data)\n    Solution().wiggleSort(nums)\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, for algorithm: reorder array into wiggle sort (nums[0] < nums[1] > nums[2] < ...). Known algorithm: iterate i from 0 to len-2, if i even, ensure nums[i] < nums[i+1], else ensure nums[i] > nums[i+1]. If not, swap. That's simple. Alternatively use sorting and partition. But easiest: one pass O(n). We'll output virtual steps: Start, Step1: Input array, Step2: For i from 0 to n-2, Decision: If i even? then need nums[i] < nums[i+1] else nums[i] > nums[i+1]. If condition fails, swap. Then loop. End.\n\nWe'll output each line with explanation. Use virtual code arrows. Use indentation for decisions.\n\nLet's craft. Use \"Start // ...\". Then \"→ Step 1: 取得輸入陣列 nums // 從使用者取得整數陣列\" etc. Use arrow \"→\". For loop use \"→ Step 2: 取得陣列長度 n // 計算長度\". Then \"→ Step 3: 對 i 從 0 到 n-2 迭代 // 開始逐個元素檢查\". Then inside loop we need decision: \"→ Decision: i%2==0? // 檢查索引為偶數\" Then \"Yes → Decision: nums[i] < nums[i+1]? // 確認左小右大\" \"Yes → ... No → Step 4: 交換 nums[i] 與 nums[i+1] // 交換以滿足條件\". Similarly for odd branch: \"No → Decision: nums[i] > nums[i+1]? // 確認左大右小\" \"Yes → ... No → Step 4: 交換 nums[i] 與 nums[i+1]\".\n\nWe need to indent accordingly. Also need \"End\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 從使用者取得整數陣列\n→ Step 2: 取得陣列長度 n // 計算陣列的總長度\n→ Step 3: 對 i 從 0 到 n-2 迭代 // 開始逐個元素檢查並調整\n    → Decision: i%2==0? // 判斷索引 i 是否為偶數\n        Yes → Decision: nums[i] < nums[i+1]? // 若為偶數，檢查左側是否小於右側\n            Yes → // 條件已滿足，繼續下一個 i\n            No  → Step 4: 交換 nums[i] 與 nums[i+1] // 交換以使 nums[i] < nums[i+1]\n        No  → Decision: nums[i] > nums[i+1]? // 若為奇數，檢查左側是否大於右側\n            Yes → // 條件已滿足，繼續下一個 i\n            No  → Step 4: 交換 nums[i] 與 nums[i+1] // 交換以使 nums[i] > nums[i+1]\nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmph4bxflna.py\", line 38, in <module>\n    data = eval(raw)\n           ^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'equations' is not defined"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0270tsjz.py\", line 38, in <module>\n    data = eval(raw)\n           ^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'equations' is not defined"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcfndtdz4.py\", line 38, in <module>\n    data = eval(raw)\n           ^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'equations' is not defined"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    # Transform input string into a dictionary\n    raw = raw.replace('equations = ', 'equations:').replace('values = ', 'values:').replace('queries = ', 'queries:')\n    raw = '{' + raw + '}'\n    data = eval(raw)\n\n    equations = data.get('equations', [])\n    values = data.get('values', [])\n    queries = data.get('queries', [])\n\n    solution = Solution()\n    answers = solution.calcEquation(equations, values, queries)\n\n    formatted = ['%.5f' % ans for ans in answers]\n    print('[' + ','.join(formatted) + ']')",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving this problem: Given equations of division between variables, and queries, compute answer or -1. This is standard \"evaluate division\" problem. We can use graph and DFS or union-find with weights. Virtual code lines with explanation.\n\nWe need to output step-by-step virtual code lines with arrow symbols. Let's structure:\n\nStart\n→ Build graph: adjacency list mapping variable to neighbors with weight\n→ For each query: if either variable not in graph → answer -1\n→ Else DFS from numerator to denominator: maintain visited, current product\n→ If found → record product\n→ Else → -1\nEnd\n\nInclude decision steps.\n\nWe should include arrow and explanation. Also include details like \"Decision: numerator exists?\" etc.\n\nWe need to produce each line with explanation. Use \"Start\" and \"End\". Use arrow arrows.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立鄰接圖 graph = {} // 用於儲存每個變量與其相鄰變量的比值  \n→ Decision: 迭代每個 equation in equations? // 逐一處理給定的方程式  \n  Yes → Step 2: 取出變量 a, b 與值 val // a / b = val  \n   → Step 3: 若 a 不在 graph, 建立空列表 // 確保 a 有節點  \n   → Step 4: 若 b 不在 graph, 建立空列表 // 確保 b 有節點  \n   → Step 5: graph[a].append((b, val)) // a → b 的比值  \n   → Step 6: graph[b].append((a, 1/val)) // b → a 的逆比值  \n→ Step 7: 初始化答案列表 ans = [] // 用於儲存所有查詢結果  \n→ Decision: 迭代每個 query in queries? // 逐一處理查詢  \n  Yes → Step 8: 取出變量 x, y 與查詢索引 i // x / y 的問題  \n   → Decision: x 與 y 均在 graph? // 判斷是否已知  \n    Yes → Step 9: 呼叫 DFS 函式 search(x, y, visited=set(), product=1)  \n     → Step 10: 若 DFS 回傳值為 None? // 無路徑可達  \n      No → ans.append(-1.0) // 回傳 -1.0  \n      Yes → ans.append(returned_value) // 回傳計算出的比值  \n    No  → Step 11: ans.append(-1.0) // 其中一個變量未定義  \n→ End // 程式執行結束\n\n// DFS 函式定義（在程式中作為輔助子程序）  \n→ Function search(node, target, visited, product):  \n  → Decision: node == target? // 到達目標  \n   Yes → Return product // 完成比值計算  \n   No → visited.add(node) // 標記已訪問  \n   → Decision: graph[node] 是否有鄰居?  \n    Yes → For 每個 (nbr, w) in graph[node]  \n     → Decision: nbr 未在 visited?  \n      Yes → result = search(nbr, target, visited, product * w)  \n       → Decision: result 是否非 None?  \n        Yes → Return result // 找到路徑，返回值  \n        No → 繼續尋找  \n     → Return None // 所有鄰居都已檢查且未找到  \n   No → Return None // 無鄰居可探索  \nEnd Function // 子程序結束"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_31s3q4t.py\", line 95, in <module>\n    main()\n  File \"/tmp/tmp_31s3q4t.py\", line 70, in main\n    commands, args = parse_input(data)\n                     ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_31s3q4t.py\", line 59, in parse_input\n    commands = ast.literal_eval(commands_str)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Subscript object at 0x749a49b0d090>"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import deque\n\nclass MyStack:\n    \"\"\"LIFO stack implemented with two queues.\"\"\"\n\n    def __init__(self):\n        self.q1 = deque()  # 主佇列\n        self.q2 = deque()  # 暫存佇列\n\n    def push(self, x):\n        \"\"\"把元素 x 推到堆疊頂端。\"\"\"\n        self.q1.append(x)\n\n    def pop(self):\n        \"\"\"移除並回傳堆疊頂端元素。\"\"\"\n        if not self.q1:\n            return None\n        # 把 q1 的所有元素搬到 q2，除了最後一個\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # 最後一個元素就是頂端\n        res = self.q1.popleft()\n        # 交換兩個佇列，q1 重新成為主佇列\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def top(self):\n        \"\"\"回傳堆疊頂端元素但不移除。\"\"\"\n        if not self.q1:\n            return None\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top_val = self.q1.popleft()\n        # 把頂端元素放回 q2，保持佇列順序\n        self.q2.append(top_val)\n        self.q1, self.q2 = self.q2, self.q1\n        return top_val\n\n    def empty(self):\n        \"\"\"判斷堆疊是否為空。\"\"\"\n        return not self.q1\n\n\ndef parse_input(text):\n    \"\"\"把輸入字串解析成兩個列表：commands 與 arguments。\"\"\"\n    lines = text.strip().splitlines()\n    if not lines:\n        return [], []\n\n    # 若輸入只佔一行，且兩個列表用逗號分隔\n    if len(lines) == 1 and ',' in lines[0]:\n        raw = lines[0]\n        split_index = raw.index('],')\n        commands_str = raw[:split_index + 1]\n        args_str = raw[split_index + 2:].strip()\n        commands = ast.literal_eval(commands_str)\n        args = ast.literal_eval(args_str)\n    else:\n        commands = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip()) if len(lines) > 1 else []\n\n    return commands, args\n\n\ndef main():\n    data = sys.stdin.read()\n    commands, args = parse_input(data)\n\n    results = []\n    stack = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MyStack\":\n            stack = MyStack()\n            results.append(None)\n        elif cmd == \"push\":\n            # arg 是一個單元素列表\n            stack.push(arg[0])\n            results.append(None)\n        elif cmd == \"pop\":\n            results.append(stack.pop())\n        elif cmd == \"top\":\n            results.append(stack.top())\n        elif cmd == \"empty\":\n            results.append(stack.empty())\n\n    # 使用 JSON 格式輸出，讓 None、True、False 分別顯示為 null、true、false\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line with explanation. It's about implementing stack using two queues. Virtual code steps like Start, Step etc. Provide explanation per line. Need to avoid actual code. Use arrows, decision, etc. Should output each line as \"虛擬碼步驟 // 解釋\".\n\nWe need to define operations: push, pop, top, empty. Use two queues q1 and q2.\n\nWe can decide to implement push by enqueuing to q1, or do more complex transfer. Simpler: push by enqueue to q1; pop by moving all but last from q1 to q2 then pop last from q1. Then swap q1 and q2. Similarly top: peek last element. We'll need auxiliary variable maybe.\n\nWe'll produce pseudocode for class initialization, push, pop, top, empty.\n\nMake sure to use queue operations: enqueue, dequeue, front, size, isEmpty.\n\nWe'll present each step line with explanation.\n\nLet's craft:\n\nStart\n→ Initialize queue1 as empty // q1\n→ Initialize queue2 as empty // q2\n\nThen define methods.\n\nFor push(x):\n→ Enqueue x to queue1 // add new element to q1\n\nFor pop():\n→ Decision: If queue1 is empty? // Check if stack empty\n    Yes → Return null // or error\n    No  →\n        → While queue1 size > 1? // Move all but last\n            Yes → temp = dequeue from queue1\n                → Enqueue temp to queue2 // transfer\n            No  →\n        → result = dequeue from queue1 // last element\n        → Swap queue1 and queue2 // prepare for next op\n        → Return result\n\nSimilarly top(): similar but without removing last. We can peek.\n\nBut we need to use only queue operations: peek from front. To get last, we can pop all but last, but keep last, then requeue it.\n\nSimplify: For top():\n→ Decision: if queue1 empty? ...\n    No →\n        → While queue1 size > 1\n            Yes → temp=dequeue(queue1); enqueue temp to queue2\n            No  →\n        → topVal = front(queue1) // peek last element\n        → temp=dequeue(queue1); enqueue temp to queue2 // move it to q2\n        → Swap queue1 and queue2\n        → Return topVal\n\nEmpty: return queue1 empty AND queue2 empty? Actually after each operation, we maintain q1 as active. So empty is q1.isEmpty.\n\nOk produce pseudocode lines.\n\nLet's output.\n\nAlso mention that after pop or top we swap.\n\nWe'll produce a line for Swap.\n\nMake sure to use \"Decision:\" lines.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize queue1 as empty // q1 用來儲存資料\n→ Initialize queue2 as empty // q2 作為暫存佇列\n\n// push 方法：將元素推到 stack 的頂端\n→ Step: push(x) // 接收要推入的元素\n    → Enqueue x to queue1 // 只使用佇列的後端入隊操作\n\n// pop 方法：移除並回傳 stack 的頂端元素\n→ Step: pop() // 開始 pop 程序\n    → Decision: queue1 is empty? // 檢查 stack 是否為空\n        Yes → Return null // 空堆疊時回傳 null 或錯誤\n        No  →\n            → While queue1 size > 1? // 移動除最後一個以外的所有元素\n                Yes → temp = dequeue from queue1\n                    → Enqueue temp to queue2 // 轉移至暫存佇列\n                No  →\n            → result = dequeue from queue1 // 取得最後一個元素（頂端）\n            → Swap queue1 and queue2 // 重新設置 q1 為主佇列\n            → Return result\n\n// top 方法：回傳 stack 的頂端元素但不移除\n→ Step: top() // 開始 top 程序\n    → Decision: queue1 is empty? // 檢查 stack 是否為空\n        Yes → Return null\n        No  →\n            → While queue1 size > 1? // 移動除最後一個以外的所有元素\n                Yes → temp = dequeue from queue1\n                    → Enqueue temp to queue2\n                No  →\n            → topVal = front of queue1 // 取得最後一個元素的值\n            → temp = dequeue from queue1 // 將最後一個元素取出\n                → Enqueue temp to queue2 // 並立即放回暫存佇列\n            → Swap queue1 and queue2 // 重新設置 q1 為主佇列\n            → Return topVal\n\n// empty 方法：判斷 stack 是否為空\n→ Step: empty() // 開始 empty 程序\n    → Return queue1 is empty // 若主佇列為空則 stack 為空\n\nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      '[[\"Gabe\", \"Gabe0@m.co\", \"Gabe1@m.co\", \"Gabe3@m.co\"], [\"Kevin\", \"Kevin0@m.co\", \"Kevin3@m.co\", \"Kevin5@m.co\"], [\"Ethan\", \"Ethan0@m.co\", \"Ethan4@m.co\", \"Ethan5@m.co\"], [\"Hanzo\", \"Hanzo0@m.co\", \"Hanzo1@m.co\", \"Hanzo3@m.co\"], [\"Fern\", \"Fern0@m.co\", \"Fern1@m.co\", \"Fern5@m.co\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        result = []\n        for root, emails in merged.items():\n            name = email_to_name[root]\n            result.append([name] + sorted(emails))\n        return result\n\ndef parse_input(data: str):\n    data = data.strip()\n    if data.lower().startswith('accounts'):\n        # Remove \"accounts =\" part if present\n        parts = data.split('=', 1)\n        if len(parts) == 2:\n            data = parts[1].strip()\n    # Use ast.literal_eval for safe evaluation\n    try:\n        accounts = ast.literal_eval(data)\n    except Exception as e:\n        # Fallback: try eval (less safe but handles some cases)\n        accounts = eval(data)\n    return accounts\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    accounts = parse_input(raw_input)\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n    # Use json.dumps to output double-quoted strings as in examples\n    print(json.dumps(merged_accounts))",
      "virtual_code": "Thinking...\nWe need to produce virtual code that merges accounts based on shared emails. Steps: build graph, union find, map emails to names, then build result. Provide line-by-line pseudocode with explanation. Use Start, Decision, Yes, No, End, etc. No actual code. Provide lines like \"→ Step: Build email to index mapping\". We'll need to show loops. Let's produce a comprehensive pseudocode. Ensure each line has arrow and explanation.\n\nWe'll format each line with \"→\". Some lines like Decision with Yes → and No →.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 UnionFind 物件，元素數量等於 accounts 列表長度 // 用來合併同一個人不同帳號  \n→ Step 2: 建立 map emailToIndex：email → 其所屬帳號索引 // 方便快速查找同一 email 所屬帳號  \n→ Decision: 是否已處理完所有帳號?  \n    No  → Step 3: 取得目前帳號 i 的名字 name = accounts[i][0]  \n    → Step 4: 對於帳號 i 的每個 email e (從索引 1 開始)  \n    → Decision: e 是否已在 emailToIndex?  \n        Yes → Step 5: 取得先前索引 prev = emailToIndex[e]  \n        → Step 6: Union(i, prev) // 合併兩個帳號因為共有相同 email  \n        No  → Step 7: emailToIndex[e] = i // 將此 email 先前映射到 i  \n    → Step 8: i = i + 1 // 移動到下一個帳號  \n    → Go to Decision  \n\n→ Step 9: 建立 map rootToEmails：根索引 → 所有屬於此根的 email 清單 // 以根索引區分不同人  \n→ Decision: 是否已遍歷所有帳號?  \n    No  → Step 10: 取得帳號 i 的名字 name = accounts[i][0]  \n    → Step 11: 取得根索引 root = Find(i) // 找到此帳號的代表  \n    → Step 12: 若 root 不在 rootToEmails，則新增空清單  \n    → Step 13: 對於帳號 i 的每個 email e（索引 1 開始）  \n    → Step 14: 將 e 加入 rootToEmails[root]  \n    → Step 15: i = i + 1 // 移動到下一個帳號  \n    → Go to Decision  \n\n→ Step 16: 建立結果 list result // 儲存最終合併後的帳號  \n→ Decision: 是否已遍歷所有根索引?  \n    No  → Step 17: 取得根索引 root  \n    → Step 18: 取得名稱 name = accounts[root][0] // 根帳號的名字  \n    → Step 19: 取得 emails = rootToEmails[root]  \n    → Step 20: 將 emails 排序  \n    → Step 21: 建立合併後帳號 merged = [name] + emails  \n    → Step 22: 加入 result  \n    → Step 23: 移動到下一個根索引  \n    → Go to Decision  \n\n→ End // 程式執行結束，result 為合併後的帳號列表"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS 以找最短距離並記錄每個單詞的前驅節點\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將輸入格式轉成 dict，例如：beginWord=\"hit\",endWord=\"cog\",wordList=[\"hot\",\"dot\"]\n    # 加上大括號後 eval 就能得到 dict\n    try:\n        data_dict = eval(\"{\" + data + \"}\")\n    except Exception:\n        # 若解析失敗，直接輸出空列表\n        print([])\n        sys.exit()\n\n    beginWord = data_dict.get(\"beginWord\")\n    endWord = data_dict.get(\"endWord\")\n    wordList = data_dict.get(\"wordList\", [])\n\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code for algorithm: Find all shortest transformation sequences (Word Ladder II). Steps: BFS to build graph levels, then DFS to backtrack all paths. We'll produce pseudocode line by line with comments. Must use arrow and decision syntax. Provide explanation after each line. We can't output actual code but virtual steps. Ensure lines like \"Start // 程式開始執行\". Use \"→ Step X:\" etc. Provide explanation in Chinese. We'll produce something like:\n\nStart // start program\n→ Step 1: if endWord not in wordList then Return [] // no path\n→ Step 2: build adjacency map using BFS from beginWord to endWord\n    → Step 2a: initialize queue with beginWord\n    → Step 2b: visited set, distance map\n    → Step 2c: while queue not empty ...\nWe need to show building neighbors, BFS level by level.\n\nThen Step 3: After BFS, if endWord not visited return []\nStep 4: DFS from beginWord to endWord using adjacency map, collecting paths.\nWe'll produce recursive DFS steps.\n\nWe need to keep line-by-line format. Use \"Decision:\" for condition checks.\n\nLet's craft lines. Provide explanation after each.\n\nAlso must use arrow \"→\" for each step. Indentation for nested steps: maybe use spaces before arrow? In example they indent for nested decisions.\n\nLet's produce.\n\nLet's start.\n\n```\nStart // 程式開始執行\n→ Step 1: if endWord not in wordList then return [] // 若目標字不在字典中則無可行路徑\n→ Decision: 建立空的鄰接表 neighbours? // 用於存放同一層中可由字母替換得到的字\n    Yes → Step 2: neighbours = empty map // key: word, value: list of neighbour words\n    No  → Step 2: // 若字典已空，仍初始化 neighbours 為空\n→ Step 3: 初始化 BFS 結構\n    → Step 3a: queue = new Queue()\n    → Step 3b: queue.enqueue(beginWord)\n    → Step 3c: visited = set containing beginWord\n    → Step 3d: distance = map with beginWord: 0 // 追蹤每個字到起點的最短距離\n→ Decision: BFS 進行至結束? // 當 queue 為空\n    Yes → Step 4: // BFS 結束，若未訪問 endWord 則回傳空列表\n        → Decision: endWord in visited? // 檢查是否找到目標\n            Yes → Step 5: // 目標已找到，繼續下一階段\n            No  → Step 6: return [] // 未找到，直接回傳空列表\n    No  → Step 7: 取 queue 頭部 current = queue.dequeue()\n        → Step 8: currentDist = distance[current]\n        → Step 9: 生成所有可能的下一個字\n            → Step 9a: for each character position i in current\n                → Step 9b: for each letter ch from 'a' to 'z'\n                    → Decision: 替換後的 word != current? // 確保不是同一字\n                        Yes →\n                            → Step 9c: newWord = replace current[i] with ch\n                            → Decision: newWord in wordList? // 必須在字典中\n                                Yes →\n                                    → Decision: newWord not in visited? // 未曾訪問\n                                        Yes →\n                                            → Step 9d: queue.enqueue(newWord)\n                                            → Step 9e: visited.add(newWord)\n                                            → Step 9f: distance[newWord] = currentDist + 1\n                                            → Step 9g: neighbours[current].append(newWord) // 建立邊\n                                        No →\n                                            → Decision: distance[newWord] == currentDist + 1? // 同層\n                                                Yes → Step 9h: neighbours[current].append(newWord) // 加入同層鄰居\n                                                No → // 若已在更短層，忽略\n                                    // 以上處理已完成\n                                No  → // newWord 不在字典，忽略\n                            // 以上替換流程完成\n                    No  → // 替換後字跟原字相同，忽略\n                // i 迴圈結束\n            // 生成所有可能字完畢\n        → Decision: queue 是否空? // 回到 BFS 判斷\n            Yes → // 轉回 Decision: BFS 進行至結束? 之下\n            No  → // 轉回 BFS 迴圈\n→ Step 10: // BFS 完成且 endWord 已被訪問\n→ Step 11: 初始化結果列表 results = []\n→ Step 12: 定義遞迴函式 dfs(currentPath, currentWord)\n    → Step 12a: currentPath.append(currentWord)\n    → Decision: currentWord == endWord? // 到達目標\n        Yes → Step 12b: results.append(copy of currentPath) // 收集一條完整路徑\n        No  → Step 12c: for each neighbor in neighbours[currentWord]\n                    → Step 12d: dfs(currentPath, neighbor) // 深度優先遞迴\n    → Step 12e: currentPath.pop() // 回溯\n→ Step 13: 呼叫 dfs([], beginWord) // 從起點開始回溯\n→ End // 程式執行結束\n```\n\nBut we need each line exactly one step and arrow at start. The example shows nested indentation but each line starts with arrow and maybe spaces.\n\nAlso we need decision lines with Yes → or No → lines. Ensure correct formatting.\n\nLet's produce final output.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: if endWord not in wordList then return [] // 若目標字不在字典中則無可行路徑\n→ Decision: 是否建立鄰接表 neighbours? // 用於存放同一層中可由字母替換得到的字\n    Yes → Step 2: neighbours = empty map // key: word, value: list of neighbour words\n    No  → Step 2: // 若字典已空，仍初始化 neighbours 為空\n→ Step 3: 初始化 BFS 結構\n    → Step 3a: queue = new Queue()\n    → Step 3b: queue.enqueue(beginWord)\n    → Step 3c: visited = set containing beginWord\n    → Step 3d: distance = map with beginWord: 0 // 追蹤每個字到起點的最短距離\n→ Decision: BFS 進行至結束? // 當 queue 為空\n    Yes → Step 4: // BFS 結束，若未訪問 endWord 則回傳空列表\n        → Decision: endWord in visited? // 檢查是否找到目標\n            Yes → Step 5: // 目標已找到，繼續下一階段\n            No  → Step 6: return [] // 未找到，直接回傳空列表\n    No  → Step 7: current = queue.dequeue()\n        → Step 8: currentDist = distance[current]\n        → Step 9: 生成所有可能的下一個字\n            → Step 9a: for each character position i in current\n                → Step 9b: for each letter ch from 'a' to 'z'\n                    → Decision: 替換後的 word != current? // 確保不是同一字\n                        Yes →\n                            → Step 9c: newWord = replace current[i] with ch\n                            → Decision: newWord in wordList? // 必須在字典中\n                                Yes →\n                                    → Decision: newWord not in visited? // 未曾訪問\n                                        Yes →\n                                            → Step 9d: queue.enqueue(newWord)\n                                            → Step 9e: visited.add(newWord)\n                                            → Step 9f: distance[newWord] = currentDist + 1\n                                            → Step 9g: neighbours[current].append(newWord) // 建立邊\n                                        No →\n                                            → Decision: distance[newWord] == currentDist + 1? // 同層\n                                                Yes → Step 9h: neighbours[current].append(newWord) // 加入同層鄰居\n                                                No → // 已在更短層，忽略\n                                    // 以上處理已完成\n                                No  → // newWord 不在字典，忽略\n                            // 以上替換流程完成\n                    No  → // 替換後字跟原字相同，忽略\n                // i 迴圈結束\n            // 生成所有可能字完畢\n        → Decision: queue 是否空? // 回到 BFS 判斷\n            Yes → // 轉回 Decision: BFS 進行至結束? 之下\n            No  → // 轉回 BFS 迴圈\n→ Step 10: // BFS 完成且 endWord 已被訪問\n→ Step 11: results = [] // 存放所有最短路徑\n→ Step 12: 定義遞迴函式 dfs(currentPath, currentWord)\n    → Step 12a: currentPath.append(currentWord)\n    → Decision: currentWord == endWord? // 到達目標\n        Yes → Step 12b: results.append(copy of currentPath) // 收集一條完整路徑\n        No  → Step 12c: for each neighbor in neighbours[currentWord]\n                    → Step 12d: dfs(currentPath, neighbor) // 深度優先遞迴\n    → Step 12e: currentPath.pop() // 回溯\n→ Step 13: 呼叫 dfs([], beginWord) // 從起點開始回溯\n→ End // 程式執行結束\n```"
    },
    {
      "title": "My Calendar I",
      "source_file": "Leetcode/leetcode729.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpr00il74p.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmpr00il74p.py\", line 33, in main\n    ops, args = parse_input(raw_input)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpr00il74p.py\", line 26, in parse_input\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[], [10, 20], [15, 25], [20, 30]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyCalendar:\n    def __init__(self):\n        self.bookings = []\n\n    def book(self, start, end):\n        for s, e in self.bookings:\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\ndef parse_input(data: str):\n    # Remove leading/trailing whitespace\n    data = data.strip()\n    # Find the separator between the two lists\n    sep_index = data.find('], [')\n    if sep_index == -1:\n        raise ValueError(\"Input format is incorrect.\")\n    ops_str = data[:sep_index + 1]          # include the closing bracket of the first list\n    args_str = '[' + data[sep_index + 3:]   # add opening bracket for the second list\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    ops, args = parse_input(raw_input)\n\n    results = [None]  # first result corresponds to the constructor\n    calendar = None\n\n    for op, arg in zip(ops[1:], args[1:]):\n        if op == \"book\":\n            start, end = arg\n            results.append(calendar.book(start, end))\n        else:\n            # In case there are other operations, extend here\n            results.append(None)\n\n    # Convert Python None/True/False to JSON null/true/false\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, no actual code, just structure. Provide steps for MyCalendar class: initialization, book method logic: maintain list of bookings. For each new event, check overlap with existing events; if no overlap add to list and return true else return false. Use decision nodes. Provide steps. No actual code. Provide comments. Format exactly like example: line by line, each line: virtual code step + space + // explanation. Use arrow symbol and decision. Provide Start, End.\n\nLet's produce.\n\nAlso we might need to represent data structure: an array or list. But we can just conceptual.\n\nSteps:\n\nStart // 程式開始\n\n→ Step 1: 建立 MyCalendar 物件 // 初始化日曆\n→ Step 2: 內部變數: events = [] // 儲存已預訂事件\n\nDefine book method:\n\n→ Step 3: 方法 book(start, end) // 進入預訂流程\n→ Decision: 是否已有事件? // 若沒有任何事件，直接加入\n    Yes → Step 4: 將 [start, end) 加入 events // 新事件加入\n        → Step 5: 回傳 true // 成功預訂\n    No → Step 6: 初始化 flag = true // 假設可加入\n→ Step 7: 對於每個 (s, e) in events // 檢查衝突\n    → Decision: 是否相交? // 若相交，設 flag = false，跳出\n        Yes → Step 8: flag = false // 發現衝突\n        No  → Step 9: 繼續檢查下一個\n→ Decision: flag 為 true? // 是否無衝突\n    Yes → Step 10: 將 [start, end) 加入 events\n        → Step 11: 回傳 true\n    No  → Step 12: 回傳 false // 不加入\n\nEnd // 程式結束\n\nBut we need to output line by line. Use arrow for steps, decision with indentation.\n\nThe example uses indentation: decision with Yes → and No →. We should replicate.\n\nSo each line start with \"→\" or \"    Yes →\" etc.\n\nLet's produce.\n\nNeed to start with Start line.\n\nLet's craft:\n\nStart // 程式開始\n\n→ Step 1: 建立 MyCalendar 物件 // 初始化日曆\n\n→ Step 2: 定義內部資料結構 events 為空列表 // 儲存已預訂的時間段\n\nDefine book method as steps:\n\n→ Step 3: 定義方法 book(start, end) // 接收新事件時間\n\n→ Decision: events 為空? // 若日曆空無任何事件\n    Yes → Step 4: 將 [start, end) 加入 events // 新事件直接加入\n        → Step 5: 回傳 true // 成功\n    No  → Step 6: flag = true // 預設可加入\n\n→ Step 7: 循環檢查每個已存在事件 (s, e) 在 events\n    → Decision: start < e AND end > s? // 檢查是否相交\n        Yes → Step 8: flag = false // 發現衝突\n        No  → Step 9: 繼續下一個\n\n→ Decision: flag 為 true? // 是否無衝突\n    Yes → Step 10: 將 [start, end) 加入 events // 加入成功\n        → Step 11: 回傳 true\n    No  → Step 12: 回傳 false // 不加入\n\nEnd // 程式結束\n\nWe also need to maintain indentation exactly as example: Each decision block indent: after Decision: ...; Yes →, No → lines are indented with spaces? In example they indent 4 spaces before Yes →. They use `    Yes →` inside Decision. So we will mimic.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 建立 MyCalendar 物件 // 初始化日曆  \n→ Step 2: 定義內部資料結構 events 為空列表 // 儲存已預訂的時間段  \n\n→ Step 3: 定義方法 book(start, end) // 接收新事件時間  \n→ Decision: events 為空? // 若日曆空無任何事件  \n    Yes → Step 4: 將 [start, end) 加入 events // 新事件直接加入  \n        → Step 5: 回傳 true // 成功預訂  \n    No  → Step 6: flag = true // 預設可加入  \n\n→ Step 7: 循環檢查每個已存在事件 (s, e) 在 events  \n    → Decision: start < e AND end > s? // 檢查是否相交  \n        Yes → Step 8: flag = false // 發現衝突  \n        No  → Step 9: 繼續下一個  \n\n→ Decision: flag 為 true? // 是否無衝突  \n    Yes → Step 10: 將 [start, end) 加入 events // 加入成功  \n        → Step 11: 回傳 true  \n    No  → Step 12: 回傳 false // 不加入  \n\nEnd // 程式結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[None,1,6,6,1,4,0,1]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[None, 1, 6, 6, 1, 4, 0, 1]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.size = n - len(blacklist)\n        black_set = set(blacklist)\n        mapping = {}\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black_set:\n                    last -= 1\n                mapping[b] = last\n                last -= 1\n        self.mapping = mapping\n\n    def pick(self):\n        idx = random.randint(0, self.size - 1)\n        return self.mapping.get(idx, idx)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().splitlines()\n    if not data:\n        sys.exit()\n    commands = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1]) if len(data) > 1 else []\n\n    outputs = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            outputs.append(None)\n        elif cmd == \"pick\":\n            outputs.append(obj.pick())\n        else:\n            # Unknown command; skip or raise error\n            outputs.append(None)\n\n    print(outputs)",
      "virtual_code": "Thinking...\nWe need to output virtual code for solution. The algorithm: mapping from 0..n-1 minus blacklist to 0..N-1 where N=n - len(blacklist). Preprocess: store mapping of blacklisted numbers < N to a whitelist of available numbers >= N. Use hashmap. pick: generate random int r in [0,N-1], if r in mapping, return mapping[r] else r.\n\nWe must output line by line virtual code with explanations. Use arrow \"→\". Provide steps for class init and pick. Use Decision etc.\n\nLet's craft. Ensure no actual code. Just virtual. Use structure: Start, → Step etc.\n\nAlso include mapping building process.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入 n 與 blacklist // 初始化參數  \n→ Step 2: 計算 N = n - blacklist 長度 // 可用數字總數  \n→ Step 3: 建立空哈希表 map // 用於映射黑名單內的數到可用數  \n→ Decision: 是否有黑名單？ // 檢查是否需要預處理  \n  Yes → Step 4: 取出所有大於等於 N 的黑名單數，存入 list allowLarge // 可用大數列表  \n  No  → Step 5: 跳過預處理 // 若無黑名單則不需要映射  \n→ Step 6: 對每個黑名單數 b  \n  Decision: b < N? // 只映射小於 N 的黑名單  \n   Yes → Step 7: 從 allowLarge 取一個值 v，移除它  \n    → Step 8: map[b] = v // 將黑名單數映射到一個可用大數  \n   No  → Step 9: 不做任何事 // 大於等於 N 的黑名單已被剔除  \n→ Step 10: 完成預處理，準備 pick() // 導致 map 完整  \n\nStart pick() // 呼叫 pick 方法  \n→ Step 11: 隨機產生整數 r 在 [0, N-1] 之間 // 一次性調用隨機函數  \n→ Decision: r 是否在 map 中？ // 判斷是否需要映射  \n  Yes → Step 12: 回傳 map[r] // 取映射後的可用數  \n  No  → Step 13: 回傳 r // 直接回傳  \nEnd // pick 方法結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,3,null,5]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[null, null, 3, null, 5]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass TrieNode:\n    \"\"\"Trie 節點，儲存子節點與前綴累加值\"\"\"\n    def __init__(self):\n        self.children = {}  # char -> TrieNode\n        self.sum = 0        # 以此節點為前綴的所有 key 的值之和\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.val_map = {}  # key -> value，用於處理覆寫\n\n    def insert(self, key: str, val: int) -> None:\n        # 先取得舊值，計算差值\n        old_val = self.val_map.get(key, 0)\n        diff = val - old_val\n        self.val_map[key] = val\n\n        # 逐字串更新 Trie\n        node = self.root\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += diff\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 允許輸入分為多行，第一行為操作列表，第二行為參數列表\n    lines = data.splitlines()\n    ops_line = lines[0]\n    args_line = lines[1] if len(lines) > 1 else '[]'\n\n    ops = ast.literal_eval(ops_line)\n    args = ast.literal_eval(args_line)\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MapSum\":\n            obj = MapSum()\n            res.append(None)\n        elif op == \"insert\":\n            key, val = arg\n            obj.insert(key, val)\n            res.append(None)\n        elif op == \"sum\":\n            res.append(obj.sum(arg))\n\n    # 使用 json.dumps 將 None 轉為 null，符合範例輸出格式\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with comments. The algorithm: use Trie with sum values. Steps: Create class MapSum. Data: root node with child map, sum. For insert: traverse, update sums along path subtract old value if key existed. We'll need a dictionary to store key->value. Implementation steps. Provide virtual code line by line with comments. Ensure use Start End Decision etc. Use arrow notation. Should be in Traditional Chinese. No actual code. Provide virtual code steps. Let's outline:\n\nStart\n→ Step 1: Initialize MapSum // constructor: root node, map for key values\n→ Step 2: insert(key, val) // insertion process\n    → Step 2.1: diff = val - oldVal (oldVal = keyValMap.get(key, 0))\n    → Step 2.2: keyValMap[key] = val\n    → Step 2.3: node = root\n    → Step 2.4: for each char in key:\n        → Step 2.4.1: if char not in node.children: node.children[char] = new Node()\n        → Step 2.4.2: node = node.children[char]\n        → Step 2.4.3: node.sum += diff\n→ Step 3: sum(prefix) // sum of values with prefix\n    → Step 3.1: node = root\n    → Step 3.2: for each char in prefix:\n        → Decision: 如果 node.children 沒有 char? // if prefix not present\n            → Yes → Return 0\n            → No → node = node.children[char]\n    → Step 3.3: Return node.sum\nEnd\n\nNeed to follow format: each line with \"虛擬碼步驟 // 解釋\". Use arrows. Start/End. Use Decision. Let's produce each line. For nested steps, indent or include arrow? The sample shows indentation with spaces. Use spaces for hierarchy. We'll produce line for Decision: use \"Decision: if ...?\" with Yes → and No → lines indented. Each line must include arrow or \"→\". For Start: \"Start\". For End: \"End\". Provide explanation after //.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 MapSum // 建立 MapSum 物件，包含根節點與 key-值對儲存表\n→ Step 2: insert(key, val) // 新增或覆寫 key 的值\n    → Step 2.1: oldVal ← keyValMap.get(key, 0) // 取得舊值，若不存在則為 0\n    → Step 2.2: diff ← val - oldVal // 計算差值，用於更新 Trie\n    → Step 2.3: keyValMap[key] ← val // 更新 key 的新值\n    → Step 2.4: node ← root // 從 Trie 根節點開始\n    → Step 2.5: for each char in key\n        → Step 2.5.1: if char not in node.children\n            → Yes → node.children[char] ← new Node() // 若不存在子節點則建立\n            → No  → // 子節點已存在，直接進入\n        → Step 2.5.2: node ← node.children[char] // 移動至子節點\n        → Step 2.5.3: node.sum ← node.sum + diff // 更新路徑上所有節點的 sum\n→ Step 3: sum(prefix) // 取得所有以 prefix 為前綴的 key 的值之和\n    → Step 3.1: node ← root // 從 Trie 根節點開始\n    → Step 3.2: for each char in prefix\n        → Decision: node.children 是否包含 char? // 檢查前綴是否存在\n            → Yes → node ← node.children[char] // 移動至下一節點\n            → No  → return 0 // 前綴不存在，直接回傳 0\n    → Step 3.3: return node.sum // 前綴完整，回傳該節點累積的 sum\nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.7626799819249898,0.07069523363559087],[0.17790384757487518,-0.007851970427611647],[0.4772079015460151,0.4216849141789183]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.7626799819249898, 0.07069523363559087], [0.17790384757487518, -0.007851970427611647], [0.4772079015460151, 0.4216849141789183]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機生成半徑與角度，確保點均勻分佈於圓內\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    methods = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    outputs = []\n    obj = None\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            outputs.append(None)  # constructor returns None\n        elif method == \"randPoint\":\n            outputs.append(obj.randPoint())\n        else:\n            # 若未實作的其他方法，直接呼叫\n            func = getattr(obj, method)\n            outputs.append(func(*args))\n\n    # 輸出結果，將 None 轉成 JSON 的 null\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for the described functionality. It should use Start, End, Decision, etc. Each line: virtual code step + // explanation. We need to produce the algorithm for generating uniform random point inside circle. Steps: Initialize radius and center; randPoint: generate random angle uniformly between 0 and 2π; generate random radius r with sqrt uniform distribution: r = sqrt(rand()) * radius; compute x = center_x + r * cos(angle), y = center_y + r * sin(angle). Return [x,y]. Also ensure use random generator. In virtual code we might have steps like:\n\nStart\n→ Step 1: Store radius, center coordinates // initialization\nEnd\n\nBut we need to provide the implementation of class and method. Virtual code lines should show steps. So we need to outline:\n\nStart\n→ Step 1: Save radius, x_center, y_center // constructor\n→ Step 2: Define randPoint method // method definition\n    → Step 2.1: Generate random number u in [0,1] // uniform\n    → Step 2.2: Compute r = sqrt(u) * radius // radius with correct distribution\n    → Step 2.3: Generate random number theta in [0, 2π] // uniform angle\n    → Step 2.4: x = x_center + r * cos(theta)\n    → Step 2.5: y = y_center + r * sin(theta)\n    → Step 2.6: Return [x, y] // array\nEnd\n\nAlso maybe include decision: but not needed. But we might include a decision for generating random numbers.\n\nAlso need to show the constructor and method.\n\nLet's produce a structured virtual code with Start and End and steps. Use arrow '→'.\n\nMake sure each line includes the code step and comment.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution，構造函式接受 radius, x_center, y_center // 存儲圓半徑與中心座標\n    → Step 1.1: this.radius = radius\n    → Step 1.2: this.cx = x_center\n    → Step 1.3: this.cy = y_center\n→ Step 2: 定義方法 randPoint() // 產生隨機點\n    → Step 2.1: 生成隨機數 u ∈ [0,1] // 用於計算半徑\n    → Step 2.2: r = sqrt(u) * this.radius // 保證點均勻分布\n    → Step 2.3: 生成隨機角度 θ ∈ [0, 2π] // 均勻分布\n    → Step 2.4: x = this.cx + r * cos(θ)\n    → Step 2.5: y = this.cy + r * sin(θ)\n    → Step 2.6: return [x, y] // 返回隨機點\nEnd // 程式結束\n\nNeed to ensure each line ends with // explanation. Use arrow formatting. Good.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\".\n\nThus produce:\n\nStart // 程式開始\n→ Step 1: 定義類別 Solution // ...\n    → Step 1.1: this.radius = radius // ...\n... etc.\n\nWe also need to include maybe Decision? Not necessary.\n\nWill produce exactly.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution，構造函式接受 radius, x_center, y_center // 初始化圓的半徑與中心座標  \n  → Step 1.1: this.radius = radius // 存放半徑  \n  → Step 1.2: this.cx = x_center // 存放中心的 x 座標  \n  → Step 1.3: this.cy = y_center // 存放中心的 y 座標  \n→ Step 2: 定義方法 randPoint() // 產生一個均勻分布於圓內的隨機點  \n  → Step 2.1: 生成隨機數 u ∈ [0,1] // 用於調整半徑的分布  \n  → Step 2.2: r = sqrt(u) * this.radius // 計算半徑，保證點均勻分布  \n  → Step 2.3: 生成隨機角度 θ ∈ [0, 2π] // 均勻分布的角度  \n  → Step 2.4: x = this.cx + r * cos(θ) // 計算點的 x 座標  \n  → Step 2.5: y = this.cy + r * sin(θ) // 計算點的 y 座標  \n  → Step 2.6: return [x, y] // 返回隨機點的座標陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Ones and Zeroes",
      "source_file": "Leetcode/leetcode474.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy2cpy8ls.py\", line 24, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    strs= [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m= 5, n= 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfxogkvpt.py\", line 24, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    strs= [\"10\",\"0\",\"1\"], m= 1, n= 1\n    ^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 逆序遍歷，避免重複使用同一個字串\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Normalize the input format: replace spaces around '='\n    data = data.replace('strs =', 'strs=').replace('m =', 'm=').replace('n =', 'n=')\n    # Execute the assignment statements safely\n    local_vars = {}\n    exec(data, {}, local_vars)\n    strs = local_vars['strs']\n    m = local_vars['m']\n    n = local_vars['n']\n    solution = Solution()\n    result = solution.findMaxForm(strs, m, n)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining solution for largest subset of binary strings with constraints m zeros and n ones. Classic DP 0/1 knapsack 2D. So virtual code: Start, initialize DP array (m+1)x(n+1) zeros. Loop each string, count zeros and ones, iterate i from m down to zeros, j from n down to ones: DP[i][j] = max(DP[i][j], DP[i-zeros][j-ones] + 1). After all strings, answer DP[m][n]. End. Also maybe handle early skip if count > m or n. Also explanation lines. Use decision etc? Not many decisions, just loops. Provide virtual code lines accordingly.\n\nWe'll output each line as \"虛擬碼步驟 // 解釋\" lines. Use arrow and indentation. Use \"→\" for steps. Use Decision if needed? Maybe decision: if zeros>m or ones>n skip? Could use Decision. We'll do.\n\nLet's craft lines:\n\nStart // 程式開始\n→ Step 1: 初始化 DP[m+1][n+1] 為 0 // 建立二維 DP 表格\n→ Step 2: 迭代每個字串 s in strs // 逐個處理字串\n    → Step 2.1: 計算 zeros = s.count('0'), ones = s.count('1') // 計算字串中的 0 與 1 數量\n    → Decision: 如果 zeros > m 或 ones > n? // 超過限制則不考慮\n        Yes → Step 2.2: 跳過本字串 // 忽略無法使用的字串\n        No  → Step 2.3: 由 i=m downto zeros\n            → Step 2.3.1: 由 j=n downto ones\n                → Step 2.3.2: DP[i][j] = max(DP[i][j], DP[i-zeros][j-ones] + 1) // 更新 DP\n→ Step 3: 回傳 DP[m][n] // 最大子集大小\nEnd // 程式結束\n\nMake sure formatting matches: \"虛擬碼步驟\" etc. We'll produce as required.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 初始化 DP[m+1][n+1] 為 0 // 建立二維 DP 表格\n→ Step 2: 迭代每個字串 s in strs // 逐個處理字串\n    → Step 2.1: 計算 zeros = s.count('0'), ones = s.count('1') // 計算字串中的 0 與 1 數量\n    → Decision: 如果 zeros > m 或 ones > n? // 超過限制則不考慮\n        Yes → Step 2.2: 跳過本字串 // 忽略無法使用的字串\n        No  → Step 2.3: 由 i = m downto zeros\n            → Step 2.3.1: 由 j = n downto ones\n                → Step 2.3.2: DP[i][j] = max(DP[i][j], DP[i-zeros][j-ones] + 1) // 更新 DP\n→ Step 3: 回傳 DP[m][n] // 最大子集大小\nEnd // 程式結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,2,1],[1,2,3],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [3, 2, 1], [1, 2, 3], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"保存原始陣列並初始化可變陣列\"\"\"\n        self.original = list(nums)       # 原始陣列\n        self.curr = list(nums)           # 當前陣列，用於 shuffle\n\n    def reset(self):\n        \"\"\"將陣列重設為原始配置並回傳\"\"\"\n        self.curr = list(self.original)\n        return self.curr\n\n    def shuffle(self):\n        \"\"\"使用 Fisher–Yates 演算法隨機打亂陣列並回傳\"\"\"\n        arr = list(self.curr)\n        n = len(arr)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            arr[i], arr[j] = arr[j], arr[i]\n        self.curr = arr\n        return arr\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析為兩個列表：命令與對應參數\n    commands, arguments = ast.literal_eval(raw_input)\n\n    obj = None\n    outputs = []\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"Solution\":\n            # 建構子：參數為 [nums]\n            obj = Solution(arg[0])\n            outputs.append(None)           # 建構子回傳 null\n        elif cmd == \"reset\":\n            outputs.append(obj.reset())\n        elif cmd == \"shuffle\":\n            outputs.append(obj.shuffle())\n\n    # 用 json.dumps 讓 None 變成 null，符合 LeetCode 輸出格式\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: initialization, reset, shuffle. Use Fisher-Yates. Provide each line with explanation. Use Start, End, Decision etc. Should be lines of virtual code. Let's design.\n\nStart // Initialize\n\n→ Step 1: Store original array copy // Save original for reset\n\n→ Step 2: Initialize current array copy of original // For shuffle operations\n\n→ Step 3: Define reset() // method to reset\n\n→ Step 4: current array = copy of original // Reset state\n\n→ Step 5: Return current array // Return reset array\n\n→ Step 6: Define shuffle() // method to shuffle\n\n→ Step 7: For i from length-1 down to 1: // Fisher-Yates loop\n\n→ Step 8:   Generate random index j in [0,i] // Random index\n\n→ Step 9:   Swap current[i] with current[j] // Swap\n\n→ Step 10: Return current array // Return shuffled\n\nAlso ensure each line preceded by virtual code step. Use arrows? In sample, arrows at each step. Use \"→\". Also \"Decision:\" etc not needed. Provide explanation comments after //.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: Save nums into originalArray // 儲存原始陣列以便重設  \n→ Step 2: Copy originalArray into currentArray // 初始化目前陣列，用於 shuffle  \n→ Step 3: Define method reset() // 定義重設方法  \n → Step 4: currentArray = copy of originalArray // 將目前陣列重置為原始值  \n → Step 5: Return currentArray // 回傳重設後的陣列  \n→ Step 6: Define method shuffle() // 定義隨機打亂方法  \n → Step 7: For i from length(currentArray)-1 downto 1: // Fisher‑Yates 迴圈  \n   → Step 8: Generate random integer j in range [0, i] // 隨機選取索引  \n   → Step 9: Swap currentArray[i] with currentArray[j] // 交換兩個元素  \n → Step 10: Return currentArray // 回傳已打亂的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    \"\"\"\n    回傳 nums 的所有子集（冪集）。\n    \"\"\"\n    res = []\n\n    def backtrack(start, path):\n        # 把目前子集加入結果\n        res.append(path[:])\n        # 從 start 開始遞迴，嘗試把後續元素加入子集\n        for i in range(start, len(nums)):\n            path.append(nums[i])          # 選擇元素\n            backtrack(i + 1, path)        # 進一步遞迴\n            path.pop()                    # 回溯，移除剛才加入的元素\n\n    backtrack(0, [])\n    return res\n\n\ndef main():\n    \"\"\"\n    讀取 stdin，解析 nums，輸出所有子集。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 假設輸入格式為「nums = [1,2,3]」或直接是陣列字串\n    if '=' in data:\n        _, nums_part = data.split('=', 1)\n        nums_part = nums_part.strip()\n    else:\n        nums_part = data\n\n    # 使用 ast.literal_eval 以安全方式解析列表字串\n    nums = ast.literal_eval(nums_part)\n\n    result = subsets(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudocode line by line. The requirement: use arrows →, Decision:, Start, End. Each line with explanation comment after //. Must not output actual code, only virtual code structure. It's the typical subset generation problem: generate all subsets of a set. Use recursion or iterative bitmask. We need to show steps: Start, Step 1: Initialize result list, Step 2: define recursive function or iterative. Use recursion: backtrack with index. Steps: Step 3: Backtrack function with parameters idx, current subset. If idx equals length, add copy of current subset to result. Else: include nums[idx] in current subset, backtrack(idx+1), exclude nums[idx], backtrack(idx+1). Then after recursion, return result. Or iterative: for each number, for each existing subset, add new subset with number. But maybe use recursion.\n\nWe need to produce pseudo-code with lines like:\n\nStart // start program\n→ Step 1: Input array nums // obtain input array\n→ Step 2: Initialize result as empty list // store all subsets\n→ Step 3: Define function backtrack(index, current) // recursive helper\n    → Decision: If index == length(nums)? // all elements processed\n        Yes → Step 4: Add copy of current to result // store subset\n        No  → Step 5: Append nums[index] to current // include element\n        → Step 6: backtrack(index+1, current) // recurse\n        → Step 7: Remove last element from current // backtrack\n        → Step 8: backtrack(index+1, current) // recurse without element\n→ Step 9: Call backtrack(0, empty list) // start recursion\n→ Step 10: Return result // output all subsets\nEnd // finish\n\nBut need to maintain arrow style consistent. Each line with virtual code step and comment. Use arrows for flow lines. For decisions, indent with spaces and Yes → and No →. Ensure lines are sequential. Should we include braces? Probably not. Just plain pseudocode. Also maybe show that at each step we use recursion.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input array nums // 取得唯一元素的整數陣列  \n→ Step 2: Initialize result ← [] // 用來儲存所有子集的結果集合  \n→ Step 3: 定義 function Backtrack(index, current) // 回溯輔助函式  \n  → Decision: index == length(nums)? // 檢查是否已處理完所有元素  \n   Yes → Step 4: Append copy of current to result // 把目前子集加入結果  \n   No  → Step 5: Append nums[index] to current // 選擇把當前元素加入子集  \n    → Step 6: Call Backtrack(index+1, current) // 進一步遞迴處理剩餘元素  \n    → Step 7: Remove last element from current // 回溯：移除剛才加入的元素  \n    → Step 8: Call Backtrack(index+1, current) // 不選擇當前元素，繼續遞迴  \n→ Step 9: Call Backtrack(0, []) // 從第一個元素開始，子集初始為空  \n→ Step 10: Return result // 回傳所有可能的子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Twitter",
      "source_file": "Leetcode/leetcode355.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqdm985mn.py\", line 90, in <module>\n    main()\n  File \"/tmp/tmpqdm985mn.py\", line 61, in main\n    ops = json.loads(parts[0].strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 11 (char 10)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0                          # 全局時間戳\n        self.tweets = defaultdict(list)        # userId -> list of (time, tweetId)\n        self.following = defaultdict(set)      # userId -> set of followeeIds\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        # 讓使用者自己自動 follow\n        if userId not in self.following[userId]:\n            self.following[userId].add(userId)\n\n    def getNewsFeed(self, userId: int) -> list[int]:\n        if userId not in self.following:\n            return []\n        res = []\n        heap = []\n\n        # 對每個 followee 取其最新推文\n        for fid in self.following[userId]:\n            posts = self.tweets.get(fid, [])\n            if posts:\n                idx = len(posts) - 1\n                ttime, tid = posts[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n\n        # 取 10 個最新推文\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx - 1 >= 0:\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            return\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            return\n        self.following[followerId].discard(followeeId)\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：兩個列表，使用 json 解析即可\n    parts = data.split(',', 1)\n    ops = json.loads(parts[0].strip())\n    args = json.loads(parts[1].strip())\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Twitter\":\n            obj = Twitter()\n            results.append(None)\n        elif op == \"postTweet\":\n            obj.postTweet(*arg)\n            results.append(None)\n        elif op == \"follow\":\n            obj.follow(*arg)\n            results.append(None)\n        elif op == \"unfollow\":\n            obj.unfollow(*arg)\n            results.append(None)\n        elif op == \"getNewsFeed\":\n            res = obj.getNewsFeed(*arg)\n            results.append(res)\n        else:\n            results.append(None)  # 未知操作，回傳 None\n\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line with explanations. For a Twitter class with operations. We need to design simplified version: store tweets list per user with timestamps, following relationships. Provide methods. We need step-by-step pseudocode, not actual code. We'll include initialization, posting, following, unfollowing, get news feed. Use Start, End, Decision, arrow notation. Provide explanation after each line. Must be in Traditional Chinese.\n\nWe'll structure as: Start // Initialize Twitter object.\n\nWe might break into multiple blocks: class definition, data structures, methods. But we need line by line pseudocode. Let's do:\n\nStart // 程式開始執行\n→ Step 1: 定義 Twitter 類別 // 建立 Twitter 物件的封裝\n→ Step 2: 在類別中宣告變數: userTweets, followings, globalTime // 用來儲存推文、關注關係與全局時間戳\n...\n\nWe need to explain each step.\n\nWe need to keep each line separate with arrow. For control flows we use Decision.\n\nFor getNewsFeed: need to merge tweets from followees and self, get top 10 by timestamp. We'll simulate using a priority queue.\n\nWe must keep simple pseudocode: no actual code, just steps.\n\nWe'll produce maybe 30-40 lines.\n\nLet's craft.\n\nWe will produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 Twitter() // 初始化\n→ Step 2: userTweets ← 空映射 (userId → 迴圈列表 of (tweetId, time)) // 儲存每個使用者的推文\n→ Step 3: followings ← 空映射 (userId → 集合 of followeeId) // 儲存每個使用者關注的對象\n→ Step 4: currentTime ← 0 // 全局時間戳\n\nThen methods:\n\n→ Step 5: 方法 postTweet(userId, tweetId)\n    → Step 6: currentTime ← currentTime + 1 // 生成時間戳\n    → Step 7: 如果 userId 不在 userTweets 中，則 userTweets[userId] ← 空列表 // 建立新清單\n    → Step 8: 將 (tweetId, currentTime) 添加到 userTweets[userId] 的前面 // 最新推文先\n    → Step 9: End 方法 // 完成\n\nFollow/unfollow:\n\n→ Step 10: 方法 follow(followerId, followeeId)\n    → Step 11: 如果 followerId 不在 followings 中，則 followings[followerId] ← 空集合 // 初始化\n    → Step 12: 加入 followeeId 到 followings[followerId] // 追蹤\n    → Step 13: End 方法\n\n→ Step 14: 方法 unfollow(followerId, followeeId)\n    → Step 15: 如果 followerId 在 followings 中，且 followeeId 在集合中，則移除\n    → Step 16: End 方法\n\ngetNewsFeed:\n\n→ Step 17: 方法 getNewsFeed(userId) → 返回 List<Integer>\n    → Step 18: feedCandidates ← 空優先佇列 (按時間戳從大到小)\n    → Step 19: 取 self 推文：for each (id, time) in userTweets[userId]，將其加入 feedCandidates，直到 10 個\n    → Step 20: 取得 followingsList ← followings[userId]（若無，為空集合）\n    → Step 21: 對於每個 followeeId in followingsList：\n        → Step 22: 取其推文：for each (id, time) in userTweets[followeeId]，將其加入 feedCandidates，直到 10 個\n    → Step 23: 建立 result ← 空列表\n    → Step 24: 當 feedCandidates 不是空且 result 大小 < 10 時：\n        → Step 25: pop 最早（或最新）元素，將其 tweetId 加入 result\n    → Step 26: 逆序 result 以符合從最新到最舊 // 如果使用小頂堆，需調整\n    → Step 27: 返回 result\n    → Step 28: End 方法\n\nBut we need to incorporate Decision blocks for existence checks etc.\n\nSimplify: Use pseudo loops.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Twitter 類別 // 建立 Twitter 物件的封裝  \n→ Step 2: 在類別中宣告變數 userTweets, followings, globalTime // 以儲存推文、關注關係與全局時間戳  \n\n**初始化**  \n→ Step 3: Twitter() // 建構子，初始化資料結構  \n→ Step 4: userTweets ← 空映射 (userId → 迴圈列表 of (tweetId, time)) // 每位使用者的推文列表  \n→ Step 5: followings ← 空映射 (userId → 集合 of followeeId) // 每位使用者關注的對象集合  \n→ Step 6: globalTime ← 0 // 全局時間戳，確保推文按時間排序  \n\n**發佈推文**  \n→ Step 7: 方法 postTweet(userId, tweetId) // 產生新推文  \n  → Step 8: globalTime ← globalTime + 1 // 時間戳遞增，確保唯一性  \n  → Step 9: Decision: 若 userId 不在 userTweets 中? // 判斷是否需要初始化列表  \n    Yes → Step 10: userTweets[userId] ← 空列表 // 建立新使用者的推文清單  \n    No → 空操作  \n  → Step 11: 將 (tweetId, globalTime) 插入 userTweets[userId] 的前面 // 以時間倒序存儲  \n  → Step 12: End 方法 // 完成推文發佈  \n\n**關注操作**  \n→ Step 13: 方法 follow(followerId, followeeId) // 開始關注  \n  → Step 14: Decision: 若 followerId 不在 followings 中?  \n    Yes → Step 15: followings[followerId] ← 空集合 // 初始化關注集合  \n    No → 空操作  \n  → Step 16: followings[followerId].加入(followeeId) // 加入關注對象  \n  → Step 17: End 方法  \n\n**取消關注**  \n→ Step 18: 方法 unfollow(followerId, followeeId) // 停止關注  \n  → Step 19: Decision: 若 followerId 在 followings 中且 followeeId 在集合中?  \n    Yes → Step 20: followings[followerId].移除(followeeId) // 刪除關注對象  \n    No → 空操作  \n  → Step 21: End 方法  \n\n**新聞推送**  \n→ Step 22: 方法 getNewsFeed(userId) // 取得最新 10 篇推文  \n  → Step 23: feedCandidates ← 空優先佇列 (按時間戳從大到小) // 儲存候選推文  \n  → Step 24: Decision: 若 userTweets[userId] 存在?  \n    Yes → Step 25: 循環遍歷 userTweets[userId] 的前 10 個項目  \n     → Step 26: feedCandidates.插入(推文) // 加入自已的推文  \n    No → 空操作  \n  → Step 27: followList ← followings[userId] // 取得關注列表，若無則為空集合  \n  → Step 28: 循環遍歷 followList 中的每個 followeeId  \n    → Step 29: Decision: 若 userTweets[followeeId] 存在?  \n     Yes → Step 30: 循環遍歷該使用者的前 10 個推文  \n      → Step 31: feedCandidates.插入(推文) // 加入關注者的推文  \n     No → 空操作  \n  → Step 32: result ← 空列表 // 儲存最終回傳的推文 ID  \n  → Step 33: Decision: 若 feedCandidates 不空且 result 長度 < 10?  \n    Yes → Step 34: pop 最前面的推文（時間最大）並將 tweetId 加入 result  \n    No → 空操作  \n  → Step 35: End 方法 // 返回 result，順序已從最新到最舊  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Duplicates from Sorted Array II",
      "source_file": "Leetcode/leetcode80.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[1,1,2,2,3,_]'\nGot (Norm):      '5,nums=[1,1,2,2,3,\"_\"]'\n--- (Raw) ---\nRaw Expected: '5, nums = [1,1,2,2,3,_]'\nRaw Got:      \"5, nums = [1, 1, 2, 2, 3, '_']\""
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "expected_output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '7,nums=[0,0,1,1,2,3,3,_,_]'\nGot (Norm):      '7,nums=[0,0,1,1,2,3,3,\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '7, nums = [0,0,1,1,2,3,3,_,_]'\nRaw Got:      \"7, nums = [0, 0, 1, 1, 2, 3, 3, '_', '_']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        if not nums:\n            return 0\n        write = 0\n        for i in range(len(nums)):\n            if i < 2 or nums[i] != nums[write - 2]:\n                nums[write] = nums[i]\n                write += 1\n        return write\n\ndef parse_input(data: str):\n    \"\"\"Parse input of the form 'nums = [1,2,3]'.\"\"\"\n    if '=' in data:\n        _, arr_str = data.split('=', 1)\n    else:\n        arr_str = data\n    arr_str = arr_str.strip()\n    return ast.literal_eval(arr_str)\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    nums = parse_input(raw)\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n    # Prepare display list with '_' placeholders\n    display = nums[:k] + ['_' for _ in range(len(nums) - k)]\n    print(f\"{k}, nums = {display}\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code for LeetCode problem 80: Remove Duplicates from Sorted Array II. Need to output line by line with explanation after a space and comment style. Use Start, End, Decision. Must not output actual code. Provide steps in pseudo-code. Let's produce algorithm: two-pointer approach. We'll maintain write index. For each read index i from 0 to n-1, if i<2 or nums[i] != nums[write-2], then write nums[i] to nums[write] and increment write. At end return write.\n\nWe need to produce virtual steps with comments. Use arrow → for continuation. Use Decision: for conditions. Provide explanation after //.\n\nWe should produce like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 write = 0, n = length(nums) // 設定寫入指標與陣列長度\n→ Step 2: 迭代 i 從 0 到 n-1 // 逐個檢查每個元素\n    → Decision: i < 2? // 前兩個元素一定允許出現\n        Yes → Step 3: nums[write] = nums[i]; write++ // 複製並移動寫入指標\n        No  → Decision: nums[i] != nums[write-2]? // 檢查是否超過兩個重複\n            Yes → Step 4: nums[write] = nums[i]; write++ // 複製並移動寫入指標\n            No  → Step 5: 跳過 // 重複超過兩個，直接跳過\n→ Step 6: Return write // 回傳有效長度 k\nEnd // 程式結束\n\nBut we need each line with virtual code and explanation. Must maintain arrow indentation. Use proper indentation. Use \"Step\" numbering or description. Provide all steps.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums ← input array // 取得給定的排序後陣列  \n→ Step 2: n ← length(nums) // 取得陣列長度  \n→ Step 3: write ← 0 // 設定寫入位置指標，初始為 0  \n\n→ Step 4: 迴圈 i 從 0 到 n-1 // 逐一檢查每個元素  \n    → Decision: i < 2? // 前兩個元素一定可保留  \n        Yes → Step 5: nums[write] ← nums[i]; write ← write + 1 // 複製並遞增寫入指標  \n        No → Decision: nums[i] ≠ nums[write-2]? // 檢查當前元素是否與寫入位置前兩個元素不同  \n            Yes → Step 6: nums[write] ← nums[i]; write ← write + 1 // 可保留，複製並遞增寫入指標  \n            No → Step 7: 跳過 // 重複超過兩次，直接忽略  \n\n→ Step 8: Return write // write 即為移除重複後的有效長度 k  \n\nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,3,null,-1,3,4]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, 3, null, -1, 3, 4]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}          # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key: int):\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current freq list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to next freq list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and freq\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict the least frequently used key (and LRU if tie)\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n    ops = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1]) if len(data) > 1 else []\n\n    results = []\n    cache = None\n\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            results.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            res = cache.get(arg[0])\n            results.append(res)\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing LFU cache with O(1) operations. Provide line-by-line virtual code with comments. Must not output actual code, only structure. Use arrow notation and Decision: etc. So outline algorithm: use hash map for key to node (value, freq, timestamp). Use freq list map: freq -> linked list of keys (ordered by recency). Maintain minFreq. For get: if key not exist return -1; else increment freq: remove from old freq list, add to new freq list; update minFreq if needed; return value. For put: if capacity 0 return. If key exists: update value, call get to update freq. Else: if size == capacity: evict key with minFreq and oldest node from that freq list; remove from key map. Then insert new node with freq=1; add to freq list 1; minFreq=1.\n\nWe need to write virtual steps. Each step: e.g., \"Start // 程式開始執行\". We must represent data structures as steps maybe initialization. Also show loops, conditions. Provide short explanations.\n\nWe will produce a fairly comprehensive flow. But need to be linear steps? We can break into initialization block, get, put. Use decision nodes.\n\nWe must output only virtual code lines; no actual code.\n\nLet's produce something like:\n\nStart\n→ Step 1: 初始化容量 capacity, 建立 keyMap, freqMap, minFreq=0 // 建立基本資料結構\n→ Decision: 如果 capacity <=0? \n    Yes → Step 2: 結束 // 失效容量無效\n    No  → ...\n\nBut maybe skip that.\n\nSimpler: Steps for get and put as functions.\n\nWe can produce two subroutines: get(key) and put(key,value). Use \"Function get\" etc.\n\nBut the format expects each line like \"虛擬碼步驟 // 解釋\".\n\nThus each line will be like \"→ Step: ... // explanation\".\n\nWe'll produce for get and put.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 初始化 capacity, keyMap, freqMap, minFreq = 0 // 佈建資料結構\n→ End // 初始化完成\n\nFunction get(key) // get 方法開始\n    → Decision: 如果 key 不在 keyMap? \n        Yes → Step 2: 返回 -1 // key 不存在\n        No  → Step 3: node = keyMap[key] // 取得節點\n              → Step 4: freq = node.freq\n              → Step 5: 移除 node 從 freqMap[freq] 列表\n              → Decision: 如果 freqMap[freq] 變空? \n                  Yes → Step 6: 移除 freqMap[freq]\n                      → Decision: 如果 freq == minFreq? \n                          Yes → Step 7: minFreq += 1 // 更新最小頻率\n              → Step 8: node.freq += 1 // 更新頻率\n              → Step 9: 加入 node 到 freqMap[node.freq] 列表\n              → Step 10: 返回 node.value // 返回值\nEnd get\n\nFunction put(key, value)\n    → Decision: 如果 capacity == 0? \n        Yes → Step 11: 返回 // 無法存儲\n        No  → \n    → Decision: 如果 key 已在 keyMap? \n        Yes → Step 12: node = keyMap[key]\n              → Step 13: node.value = value // 更新值\n              → Step 14: 呼叫 get(key) // 更新頻率\n              → End put\n        No  → \n            → Decision: 如果 keyMap.size == capacity? \n                Yes → Step 15: minFreqKey = freqMap[minFreq].最舊的 key // 找到最舊\n                      → Step 16: 刪除 minFreqKey 從 keyMap\n                      → Step 17: 移除 minFreqKey 從 freqMap[minFreq] 列表\n                      → Decision: 如果 freqMap[minFreq] 變空? \n                          Yes → Step 18: 移除 freqMap[minFreq]\n                No  → \n            → Step 19: 新建 node = (value, freq=1) // 新節點\n                  → Step 20: keyMap[key] = node\n                  → Step 21: 加入 node 到 freqMap[1] 列表\n                  → Step 22: minFreq = 1 // 重設最小頻率\nEnd put\n\nEnd // 程式結束\n\nNeed to ensure each line has \"虛擬碼步驟 [space] // 解釋\". We'll format accordingly.\n\nLet's produce lines with appropriate indentation? Not necessary but can indent inside function. But each line is separate. We can denote function blocks with lines starting \"Function get(key) // ...\". And inside indent lines maybe with \"→\" prefix to denote step. But it's fine.\n\nWe'll produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 capacity, keyMap, freqMap, minFreq = 0 // 建立基本資料結構  \n→ End // 初始化結束  \n\nFunction get(key) // 開始 get 方法  \n    → Decision: 如果 key 不在 keyMap? // 檢查 key 是否存在  \n        Yes → Step 2: 返回 -1 // key 不存在，回傳 -1  \n        No  → Step 3: node = keyMap[key] // 取得節點資料  \n              → Step 4: freq = node.freq // 取得目前頻率  \n              → Step 5: 移除 node 從 freqMap[freq] 列表 // 從舊頻率列表中移除  \n              → Decision: 如果 freqMap[freq] 變空? // 檢查舊頻率列表是否為空  \n                  Yes → Step 6: 移除 freqMap[freq] // 刪除空的頻率列表  \n                      → Decision: 如果 freq == minFreq? // 判斷是否為最小頻率  \n                          Yes → Step 7: minFreq += 1 // 更新最小頻率  \n              → Step 8: node.freq += 1 // 使節點頻率加 1  \n              → Step 9: 加入 node 到 freqMap[node.freq] 列表 // 加入新頻率列表  \n              → Step 10: 返回 node.value // 回傳對應值  \nEnd get // get 方法結束  \n\nFunction put(key, value) // 開始 put 方法  \n    → Decision: 如果 capacity == 0? // 檢查容量是否為 0  \n        Yes → Step 11: 返回 // 無法存儲，直接返回  \n        No  →  \n    → Decision: 如果 key 已在 keyMap? // 檢查 key 是否已存在  \n        Yes → Step 12: node = keyMap[key] // 取得節點  \n              → Step 13: node.value = value // 更新值  \n              → Step 14: 呼叫 get(key) // 更新頻率  \n              → End put // 結束 put 方法  \n        No  →  \n            → Decision: 如果 keyMap.size == capacity? // 檢查是否已滿  \n                Yes → Step 15: minFreqKey = freqMap[minFreq].最舊的 key // 找到最舊的 key  \n                      → Step 16: 刪除 minFreqKey 從 keyMap // 從 keyMap 刪除  \n                      → Step 17: 移除 minFreqKey 從 freqMap[minFreq] 列表 // 從頻率列表移除  \n                      → Decision: 如果 freqMap[minFreq] 變空? // 檢查是否為空  \n                          Yes → Step 18: 移除 freqMap[minFreq] // 刪除空的頻率列表  \n                No  →  \n            → Step 19: 新建 node = (value, freq=1) // 新節點，頻率設為 1  \n                  → Step 20: keyMap[key] = node // 加入 keyMap  \n                  → Step 21: 加入 node 到 freqMap[1] 列表 // 加入頻率 1 列表  \n                  → Step 22: minFreq = 1 // 重設最小頻率為 1  \nEnd put // put 方法結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,0,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 0, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport bisect\nimport json\n\nclass Solution:\n    def __init__(self, w):\n        # 建立前綴和陣列\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 隨機挑選 1 ~ total 的整數\n        target = random.randint(1, self.total)\n        # 在前綴和中找出第一個大於等於 target 的索引\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入解析為兩個列表：操作序列與對應參數\n    ops_and_args = ast.literal_eval('[' + data + ']')\n    ops, args_list = ops_and_args[0], ops_and_args[1]\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args_list):\n        if op == \"Solution\":\n            # 建構物件，arg 是一個包裝在列表中的 w\n            obj = Solution(arg[0])\n            res.append(None)\n        else:\n            # 呼叫方法並將結果加入回傳列表\n            method = getattr(obj, op)\n            res.append(method(*arg))\n    # 以 JSON 形式輸出結果\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with step-by-step explanation. Steps: build prefix sums, total weight. Then pick random number between 0 and totalWeight, find index using binary search. Provide explanation. Use Start, End, Decision arrows. Provide per line.\n\nWe need to avoid actual code. Use pseudocode. Provide step names. Use arrows. Format: each line: \"Step X: ...\" // explanation. Use Start, End. Use Decision: arrow. Use Yes/No. We'll generate.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入陣列 w // 從使用者或函式呼叫取得權重陣列  \n→ Step 2: 建立前綴和陣列 prefix[0…n-1]  \n    → Loop i from 0 to n-1  \n        → If i = 0: prefix[0] ← w[0] // 前綴和的第一個元素為第一個權重  \n        → Else: prefix[i] ← prefix[i-1] + w[i] // 累加前一個前綴和  \n→ Step 3: 計算總權重 total ← prefix[n-1] // 前綴和最後一項即為所有權重之和  \n→ Step 4: 產生一個隨機實數 r，範圍為 [0, total) // r 為隨機權重點  \n→ Decision: 找到最小的 index j 使得 prefix[j] > r // 確定 r 落在哪個區間  \n    Yes → Step 5: 回傳 j // 返回符合權重機率的索引  \n    No  → Step 5: 回傳 j // 如果 r 等於前綴和（極少數），仍返回該索引  \nEnd // 程式執行結束"
    },
    {
      "title": "H-Index II",
      "source_file": "Leetcode/leetcode275.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef h_index(citations):\n    \"\"\"\n    計算給定排序後的 citations 數組的 h-index。\n    使用二分搜尋，時間複雜度為 O(log n)。\n    \"\"\"\n    n = len(citations)\n    left, right = 0, n - 1\n    result = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        h_candidate = n - mid  # 以 mid 為分界，估計的 h 值\n        if citations[mid] >= h_candidate:\n            result = h_candidate       # 找到一個合法的 h\n            left = mid + 1             # 嘗試更大的 h\n        else:\n            right = mid - 1            # 需要更小的 h\n\n    return result\n\ndef parse_input(raw):\n    \"\"\"\n    將輸入字串轉換為 citations 清單。\n    支援類似 'citations = [0,1,3,5,6]' 或僅給出清單 '[0,1,3,5,6]' 的情況。\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return []\n\n    # 若有 'citations' 這個字串，分割取得右側\n    if 'citations' in raw:\n        _, _, list_part = raw.partition('=')\n    else:\n        list_part = raw\n\n    list_part = list_part.strip()\n    try:\n        return ast.literal_eval(list_part)\n    except Exception:\n        # 若轉換失敗，回傳空清單\n        return []\n\ndef main():\n    raw_input = sys.stdin.read()\n    citations = parse_input(raw_input)\n    print(h_index(citations))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step, using Start, Decision, etc. Algorithm: given sorted array citations non-decreasing. Need h-index. Use binary search on index i representing number of papers with citations >= h. We can consider reverse index. Approach: let n = length. We search for minimal index where citations[i] >= n-i. That gives h. Or use binary search to find largest h such that citations[n-h] >= h. We'll produce steps: Start, Get n, set low=0 high=n-1, result=0. While low<=high: mid=(low+high)/2; hCandidate = n-mid; if citations[mid] >= hCandidate: result = hCandidate; low = mid+1; else high = mid-1. After loop, output result. Provide each line with virtual code and explanation.\n\nLet's produce.\n\nUse integer division etc. Provide each step. Use indentation? Use arrow. Provide comments. Should adhere to format: \"虛擬碼步驟 // 解釋\". We'll use steps like \"Start // 程式開始\". For decision use \"Decision: ...\". Use arrow.\n\nWe'll produce.\n\nMake sure no actual code, just pseudo.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 識別數組長度 n = citations 的元素數量 // 取得論文總數  \n→ Decision: 如果 n == 0? // 無論有無論文  \n  Yes → Step 2: 回傳 0 // 沒有論文 h-index 為 0  \n  No  → Step 3: 初始化 low = 0, high = n - 1, result = 0 // 進行二分搜尋  \n→ Decision: low <= high? // 二分搜尋條件  \n  Yes → Step 4: 計算 mid = (low + high) / 2 // 取中間索引  \n   → Step 5: 計算 hCandidate = n - mid // 估計 h 值  \n   → Decision: citations[mid] >= hCandidate? // 判斷是否滿足 h-index 條件  \n     Yes → Step 6: 更新 result = hCandidate // 找到一個合法 h  \n        → Step 7: low = mid + 1 // 嘗試更大的 h  \n     No  → Step 8: high = mid - 1 // 需要更小的 h  \n  No  → Step 9: 回傳 result // 所有可能已檢查完畢，輸出最大 h-index  \nEnd // 程式執行結束"
    }
  ]
}