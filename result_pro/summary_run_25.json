{
  "run_index": 25,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 396,
  "generation_or_validation_failure_count": 43,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[3,2,4,3,6]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[3, 2, 4, 3, 6]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"擲 n 次六面骰，回傳所有結果的串列\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個程式碼，並執行\n    code = sys.stdin.read()\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step. Must include virtual code steps with arrow syntax. For function roll_dice(n) using random module, simulate n times 1-6, return list. We must adhere to format: each line: virtual code step + space + // explanation.\n\nUse Start, End, Decision. We need steps: import random, define function, initialize list, loop n times, generate random int 1-6, append, return list. No actual code, just pseudo. Use \"→\" arrow for flow.\n\nLet's produce:\n\nStart\n→ Step 1: Import random module // 引入 random 模組\n→ Step 2: Define function roll_dice(n) // 定義 roll_dice 函式，參數為 n\n→ Step 3: Initialize results = [] // 建立空列表儲存骰子結果\n→ Step 4: For i from 1 to n // 進行 n 次擲骰\n    → Step 5: Generate roll = random.randint(1, 6) // 產生 1~6 的隨機整數\n    → Step 6: Append roll to results // 把結果加入列表\n→ Step 7: Return results // 回傳所有結果列表\nEnd\n\nWe need to add \"Decision:\"? We could have no decision. But might use loop as decision? But we can express loop via \"Decision: i <= n?\" but simpler. Use arrow for loop start and end. Provide explanation. Should be fine. Ensure each line has arrow. For lines inside loop indent. Use \"→\" inside. Provide explanation after //.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 引入 random 模組  \n→ Step 2: Define function roll_dice(n) // 定義 roll_dice 函式，參數為 n  \n→ Step 3: Initialize results = [] // 建立空列表儲存骰子結果  \n→ Step 4: For i from 1 to n // 進行 n 次擲骰  \n  → Step 5: Generate roll = random.randint(1, 6) // 產生 1~6 的隨機整數  \n  → Step 6: Append roll to results // 把結果加入列表  \n→ Step 7: Return results // 回傳所有結果列表  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    start = time.time()\n    result = func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code with arrows, each line includes comment. We'll produce step-by-step. Let's include imports etc. We'll produce Start, import, define function, start time, call, end time, compute duration, round, return. We'll adhere to format. Use 'Decision' only if needed; no decision needed. Use \"Step\" lines.\n\nEnsure each line has format: \"虛擬碼步驟 // 解釋\".\n\nWe'll produce lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import: time 模組 // 引入 time 模組以便取得時間戳  \n→ Step 1: 定義函數 measure_time(func, *args) // 建立可變參數的測量函式  \n    → Step 2: start = time.time() // 取得呼叫前的時間戳  \n    → Step 3: result = func(*args) // 執行傳入的函式並傳遞參數  \n    → Step 4: end = time.time() // 取得呼叫後的時間戳  \n    → Step 5: duration = end - start // 計算執行所用時間  \n    → Step 6: rounded_duration = round(duration, 3) // 將時間四捨五入到小數點第三位  \n    → Step 7: return rounded_duration, result // 回傳四捨五入後的秒數與函式結果  \nEnd // 程式執行結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "class Student:\n    def __init__(self, name, score):\n        # 初始化姓名與分數\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        # 輸出「姓名 的分數是 分數」的格式\n        print(f'{self.name} 的分數是 {self.score}')\n\n\ndef main():\n    import sys\n\n    # 讀取所有非空行\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n\n    students = []\n\n    if not lines:\n        # 若輸入為空，使用預設兩個學生\n        students = [Student('Alice', 90), Student('Bob', 80)]\n    else:\n        # 若有輸入，每行預期為「姓名 分數」或「姓名 分數 其它資料」\n        for line in lines:\n            parts = line.split()\n            if len(parts) < 2:\n                continue  # 無法解析成姓名與分數，略過\n            name = parts[0]\n            try:\n                score = int(parts[1])\n            except ValueError:\n                continue  # 分數非整數，略過\n            students.append(Student(name, score))\n\n    # 顯示所有學生資訊\n    for student in students:\n        student.show_info()\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Use Start, → Step, Decision etc. For the requirement, no decision. Just class definition, constructor, method, instantiate two objects, call method. Provide line by line. Ensure format: line: virtual code + space + // explanation. Use arrows. Use Start, End. Use \"→\". Use \"Step\" for each. Provide two objects. We must not output real code but virtual code steps. Eg:\n\nStart\n→ Step 1: Define class Student // 開始定義 Student 類別\n→ Step 2: In constructor, create name and score attributes // 初始化屬性\n→ Step 3: Define method show_info() // 方法\n→ Step 4: Inside show_info(), output formatted string // 顯示資訊\n→ Step 5: Create object student1 with name='Alice', score=90 // 物件實例化\n→ Step 6: Call student1.show_info() // 呼叫方法\n→ Step 7: Create object student2 with name='Bob', score=75 // 物件實例化\n→ Step 8: Call student2.show_info() // 呼叫方法\nEnd\n\nMake sure each line uses \"→ Step X:\" or \"Start\", \"End\". Provide explanation after //. Use no actual code. Use plain description. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Student // 開始定義 Student 類別  \n→ Step 2: 在 __init__() 建構子中初始化 name 與 score 兩個屬性 // 設定初始值  \n→ Step 3: 定義方法 show_info() // 建立顯示資訊的函式  \n→ Step 4: 在 show_info() 內輸出「{name} 的分數是 {score}」 // 顯示姓名與分數  \n→ Step 5: 建立 student1 物件並傳入姓名 'Alice' 與分數 90 // 實例化第一個學生  \n→ Step 6: 呼叫 student1.show_info() // 顯示第一個學生資訊  \n→ Step 7: 建立 student2 物件並傳入姓名 'Bob' 與分數 75 // 實例化第二個學生  \n→ Step 8: 呼叫 student2.show_info() // 顯示第二個學生資訊  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"melon\",\"apple\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'melon', 'apple', 'orange'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取所有輸入（若有輸入則忽略，因題目無實際輸入需求）\n    sys.stdin.read()\n\n    # 建立集合並進行操作\n    fruits = {'apple', 'banana'}\n    fruits.add('orange')            # 新增 'orange'\n    fruits.update({'grape', 'melon'})  # 同時新增 'grape' 與 'melon'\n    fruits.remove('banana')          # 移除 'banana'\n    fruits.discard('pineapple')      # 嘗試移除不存在的 'pineapple'，不會拋錯\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps following the formatting. Must use Start, → Step etc. Each line: virtual code step + space + // explanation. Must use arrows. Use 'Decision:' maybe not needed. Just sequence. Provide each operation as Step lines. Provide End at end.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits ← {'apple', 'banana'} // 建立集合並加入兩個水果  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'（不會拋錯）  \n→ Step 6: print(fruits) // 輸出最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import requests\nimport tkinter as tk\nimport sys\n\ndef fetch_rate() -> str:\n    \"\"\"取得美元兌台幣匯率並回傳顯示用字串。\"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        r = requests.get(url, timeout=10)\n        data = r.json()\n        rate = data[\"rates\"][\"TWD\"]\n        return f\"目前美元匯率：約 {rate} TWD\"\n    except Exception:\n        return \"更新失敗，請檢查網路連線\"\n\ndef update_label() -> None:\n    \"\"\"按鈕回呼，更新 Label 上的匯率文字。\"\"\"\n    text = fetch_rate()\n    label.config(text=text)\n\n# 建立 GUI 視窗\nwin = tk.Tk()\nwin.title(\"匯率查詢\")\n\nlabel = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\nlabel.pack(pady=10)\n\ntk.Button(win, text=\"更新匯率\", command=update_label).pack(pady=5)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取一行（不做實際處理）\n    _ = sys.stdin.readline()\n\n    # 立即取得匯率並列印到標準輸出\n    print(fetch_rate())\n\n    # 啟動 Tkinter 主循環，顯示視窗\n    win.mainloop()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps with explanation, one per line, with structure. Need to cover tasks: import modules, fetch API, parse JSON, create Tkinter window, label to show rate, button to refresh, callback fetch, update label. Use arrow for steps. Use decision for error handling? Might include.\n\nWe must not output actual code, only virtual code steps. Format: each line like \"Start // 程式開始執行\". Use \"→\" for steps. Use \"Decision:\" for conditional.\n\nLet's create steps:\n\nStart\n→ Step 1: Import requests and tkinter modules // 引入必要模組\n→ Step 2: Define function fetch_rate() // 建立取得匯率的函式\n    → Step 2.1: 發送 GET 請求至 API URL // 使用 requests 取得資料\n    → Decision: 如果請求成功且狀態碼 200? // 檢查回應是否有效\n        Yes → Step 2.2: 解析 JSON 並取出 TWD 匯率 // 取得台幣匯率\n        No  → Step 2.3: 設定匯率為 '無法取得' // 當失敗時顯示錯誤訊息\n    → Step 2.4: 返回匯率值 // 結果傳回\n→ Step 3: 建立 tkinter 主視窗 // 初始化 GUI\n    → Step 3.1: 設定視窗標題為 '美元兌台幣匯率' // 標題\n    → Step 3.2: 建立 Label 控制項以顯示匯率 // 文字顯示\n    → Step 3.3: 建立 Button 控制項並綁定 fetch_rate 以更新匯率 // 互動\n→ Step 4: 呼叫 fetch_rate 並更新 Label 初始值 // 首次顯示\n→ Step 5: 啟動 tkinter 事件迴圈 // 進入主循環\nEnd\n\nWe need to include arrow and explanations. Also \"→ Decision:\" lines may need indentation? The example uses indentation. We'll mimic: indent with spaces? Use four spaces before nested steps. Format: \"→ Decision:\" line with indent? Example shows: `Decision:` line with indent. They indent nested Yes/No lines with 4 spaces more. We should follow. Use consistent indentation.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests and tkinter modules // 引入 requests 與 tkinter 模組  \n→ Step 2: Define function fetch_rate() // 建立取得匯率的函式  \n → Step 2.1: Send GET request to https://api.exchangerate-api.com/v4/latest/USD // 透過 requests 取得 API 資料  \n → Decision: If response status code is 200? // 檢查回應是否成功  \n  Yes → Step 2.2: Parse JSON and extract TWD rate // 解析 JSON 並取得台幣匯率  \n  No  → Step 2.3: Set rate to '無法取得' // 失敗時顯示錯誤訊息  \n → Step 2.4: Return the rate value // 傳回匯率結果  \n→ Step 3: Create Tkinter main window // 初始化 GUI  \n → Step 3.1: Set window title to '美元兌台幣匯率' // 設定視窗標題  \n → Step 3.2: Create a Label widget to display the rate // 建立文字顯示元件  \n → Step 3.3: Create a Button widget and bind fetch_rate to update rate // 建立更新按鈕並綁定功能  \n→ Step 4: Call fetch_rate and update the Label with the initial rate // 首次載入匯率  \n→ Step 5: Start the Tkinter main event loop // 進入主事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Open the Lock",
      "source_file": "Leetcode/leetcode752.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '-1'"
        },
        {
          "example_index": 1,
          "input": "deadends = [\"8888\"], target = \"0009\"",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def openLock(self, deadends, target):\n        dead = set(deadends)\n        if '0000' in dead:\n            return -1\n        if target == '0000':\n            return 0\n\n        queue = deque([('0000', 0)])\n        visited = {'0000'}\n\n        while queue:\n            state, steps = queue.popleft()\n            if state == target:\n                return steps\n            for i in range(4):\n                digit = int(state[i])\n                for move in (-1, 1):\n                    new_digit = (digit + move) % 10\n                    new_state = state[:i] + str(new_digit) + state[i+1:]\n                    if new_state in dead or new_state in visited:\n                        continue\n                    if new_state == target:\n                        return steps + 1\n                    visited.add(new_state)\n                    queue.append((new_state, steps + 1))\n        return -1\n\ndef parse_input():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return [], '0000'\n    try:\n        # Accept input like: deadends = [\"0201\",\"0101\"], target = \"0202\"\n        args = eval(\"{\" + raw + \"}\")\n        deadends = args.get('deadends', [])\n        target = args.get('target', '0000')\n    except Exception:\n        # Fallback: each line contains one value\n        lines = raw.splitlines()\n        if len(lines) >= 2:\n            deadends = eval(lines[0])\n            target = lines[1].strip().strip('\"').strip(\"'\")\n        else:\n            # Try JSON format\n            try:\n                import json\n                obj = json.loads(raw)\n                deadends = obj.get('deadends', [])\n                target = obj.get('target', '0000')\n            except Exception:\n                deadends = []\n                target = raw.strip('\"').strip(\"'\")\n    return deadends, target\n\nif __name__ == \"__main__\":\n    deadends, target = parse_input()\n    solution = Solution()\n    result = solution.openLock(deadends, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for solving the lock problem: typical BFS shortest path with deadends. We'll produce step-by-step pseudocode with explanations. Ensure each line has virtual code + // explanation. Use arrows etc.\n\nWe need to produce for the user request. Should cover initialization, BFS queue, visited set, deadends set, check target. Implementation details: use queue of tuples (state, depth). For each state, generate 8 neighbors by rotating each wheel +1 or -1. Skip deadends and visited. If target reached return depth. If queue empty return -1.\n\nMake sure to output each line individually. Use arrow \"→\" for steps inside. Use indentation for decisions.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 deadendsSet ← Set(deadends) // 將所有死結轉為集合，方便 O(1) 判斷  \n→ Step 2: 若 '0000' 為 deadendsSet → End with -1 // 初始位置即死結，直接失敗  \n→ Step 3: 若 target = '0000' → End with 0 // 已解鎖，無需任何操作  \n→ Step 4: 建立 queue ← [( '0000', 0 )] // 佇列存放 (狀態, 已走步數)  \n→ Step 5: 建立 visitedSet ← Set(['0000']) // 記錄已探訪的狀態  \n→ Decision: queue 是否為空? // 檢查是否還有未探索的狀態  \n    No → Step 6: 取出 frontState, frontDepth ← queue.pop_front() // 取得佇列前端元素  \n    → Step 7: 為 i in 0..3 迴圈 // 遍歷每個轉盤  \n        → Step 8: 生成 next1 ← rotate(frontState, i, +1) // 轉一格正向  \n        → Decision: next1 是否為 deadendsSet 或 visitedSet?  \n            Yes → Skip // 若是死結或已訪問，略過  \n            No  → 若 next1 = target → End with frontDepth+1 // 找到最短路徑  \n                → 否則 → queue.append((next1, frontDepth+1))  \n                → visitedSet.add(next1)  \n        → Step 9: 生成 next2 ← rotate(frontState, i, -1) // 轉一格反向  \n        → Decision: next2 是否為 deadendsSet 或 visitedSet?  \n            Yes → Skip  \n            No  → 若 next2 = target → End with frontDepth+1  \n                → 否則 → queue.append((next2, frontDepth+1))  \n                → visitedSet.add(next2)  \n    → 回到 Decision: queue 是否為空? // 若仍有元素則重複  \n        Yes → End with -1 // 佇列空，無法到達目標  \n        No  → 重新進入循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[1,0],[0,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [1, 0], [0, 0], null, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    \"\"\"隨機翻轉 0 為 1 的二元矩陣，所有 0 的位置等機會被選到。\"\"\"\n    def __init__(self, n_rows: int, n_cols: int):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols          # 目前可翻轉的格子數量\n        self.mapping = {}                     # 用於動態映射隨機索引到實際位置\n\n    def flip(self) -> list[int]:\n        \"\"\"隨機選一個仍為 0 的位置，翻轉成 1 並回傳其座標 [i, j]。\"\"\"\n        # 產生隨機索引 r\n        r = random.randint(0, self.total - 1)\n\n        # 找到 r 對應的實際索引 idx\n        idx = self.mapping.get(r, r)\n\n        # 取得最後一個可用格子 idx_last\n        last = self.mapping.get(self.total - 1, self.total - 1)\n\n        # 更新映射，將 last 放到 r 位置，模擬刪除 r\n        self.mapping[r] = last\n\n        # 已翻轉一格，減少可用格子數量\n        self.total -= 1\n\n        # 轉回行列座標\n        return [idx // self.cols, idx % self.cols]\n\n    def reset(self) -> None:\n        \"\"\"重設矩陣為全 0，所有格子再次可被翻轉。\"\"\"\n        self.total = self.rows * self.cols\n        self.mapping.clear()\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入解析為兩個列表：操作名稱和對應參數\n    # 例：'[\"Solution\",\"flip\"],[[3,1],[]]' 會被解析成\n    # ops = [\"Solution\",\"flip\"]，args = [[3,1],[]]\n    ops, args = ast.literal_eval('(' + data + ')')\n\n    result = []\n    sol = None\n    for op, arg in zip(ops, args):\n        if op == 'Solution':\n            sol = Solution(*arg)\n            result.append(None)          # Solution 之後不回傳任何值\n        elif op == 'flip':\n            res = sol.flip()\n            result.append(res)\n        elif op == 'reset':\n            sol.reset()\n            result.append(None)\n        else:\n            raise ValueError(f'Unknown operation: {op}')\n\n    # 使用 json.dumps 以將 None 轉成 null，符合題目示例格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing algorithm: Use reservoir? Actually typical solution uses list of all available indices mapping via hash map. Approach: maintain mapping from 0..m*n-1 to indices, treat as list of unflipped cells. When flip called: pick random r from 0 to remaining-1. Map r to actual index via map, then swap last available index to r position (simulate removal). decrement remaining. Map stores mapping for indices that were swapped. Return [i,j] from number mapping. reset: clear mapping, set remaining=m*n. Complexity O(1) per flip and reset O(m*n) or O(1). Minimizes random calls to 1 per flip.\n\nWe need to produce virtual code steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. We'll produce steps for class definition, init, flip, reset. Use pseudo steps.\n\nLet's produce:\n\nStart // 初始化\n→ Step 1: 定義變數 m, n, total, available, mapping\n→ Step 2: available = total = m * n\n→ Step 3: mapping = empty hash map\n→ End // 初始化完成\n\nThen flip method:\n\nStart // flip()\n→ Decision: 如果 available == 0? // 檢查是否已全部翻轉\n    Yes → Error // 沒有空位可供選取\n    No  → Step 1: r = random(0, available-1) // 產生隨機索引\n        → Step 2: idx = mapping.get(r) if exists else r // 對應實際索引\n        → Step 3: last = mapping.get(available-1) if exists else available-1 // 取最後可用索引\n        → Step 4: mapping.put(r, last) // 更新映射，將最後索引放到 r 位置\n        → Step 5: available-- // 移除已選索引\n        → Step 6: i = idx / n, j = idx % n // 轉換為行列\n        → Step 7: return [i, j] // 返回結果\nEnd // flip 結束\n\nReset:\n\nStart // reset()\n→ Step 1: available = m * n // 重置可用數量\n→ Step 2: clear mapping // 清空映射\n→ End // reset 結束\n\nAlso we might include class structure.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義變數 m, n, total, available, mapping // 初始化矩陣尺寸、總數、剩餘可翻轉數與映射表\n→ Step 2: total = m * n // 計算總格子數\n→ Step 3: available = total // 初始時所有格子都可被選取\n→ Step 4: mapping = 空哈希表 // 用於動態映射隨機索引到實際位置\n→ End // 初始化結束\n\nStart // flip() // 隨機翻轉一個 0 並返回其座標\n→ Decision: 如果 available == 0? // 檢查是否已無可用格子\n    Yes → Step 1: throw Error // 無可選位置，觸發錯誤\n    No  → Step 2: r = random(0, available - 1) // 產生隨機索引\n        → Step 3: idx = mapping.get(r) if 存在則取 mapping[r] else r // 找到實際格子索引\n        → Step 4: last = mapping.get(available - 1) if 存在則取 mapping[available-1] else available-1 // 取得最後一個可用格子索引\n        → Step 5: mapping.put(r, last) // 將最後格子移至 r 位置，模擬刪除\n        → Step 6: available-- // 減少可用格子數\n        → Step 7: i = idx / n, j = idx % n // 把一維索引轉回行列\n        → Step 8: return [i, j] // 回傳隨機選取且已翻轉的格子座標\nEnd // flip 結束\n\nStart // reset() // 重設矩陣為全 0\n→ Step 1: available = total // 恢復可用格子數\n→ Step 2: mapping.clear() // 清空映射表\n→ End // reset 結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpn_1y28fb.py\", line 68, in <module>\n    main()\n  File \"/tmp/tmpn_1y28fb.py\", line 41, in main\n    ops = ast.literal_eval(parts[0].strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MagicDictionary\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MagicDictionary:\n    def __init__(self):\n        # 每個模式對應可匹配的單詞集合\n        self.pattern_map = {}\n\n    def buildDict(self, dictionary):\n        \"\"\"建立字典，預處理所有單字的所有位置為 '*' 的模式\"\"\"\n        self.pattern_map.clear()\n        for word in dictionary:\n            for i in range(len(word)):\n                # 用 '*' 替換第 i 個字元\n                pattern = word[:i] + '*' + word[i+1:]\n                if pattern not in self.pattern_map:\n                    self.pattern_map[pattern] = set()\n                self.pattern_map[pattern].add(word)\n\n    def search(self, searchWord):\n        \"\"\"搜尋是否可以改變正好一個字元得到字典中的某個單詞\"\"\"\n        for i in range(len(searchWord)):\n            pattern = searchWord[:i] + '*' + searchWord[i+1:]\n            if pattern in self.pattern_map:\n                # 若同一個模式對應的集合中至少有一個與原字不同，則成立\n                for word in self.pattern_map[pattern]:\n                    if word != searchWord:\n                        return True\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 依照 LeetCode 的輸入格式：兩行，第一行操作列表，第二行參數列表\n    lines = data.splitlines()\n    if len(lines) == 1:\n        # 兩個列表可能被放在同一行，以逗號分隔\n        parts = data.split(',', 1)\n        ops = ast.literal_eval(parts[0].strip())\n        args = ast.literal_eval(parts[1].strip())\n    else:\n        ops = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip())\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MagicDictionary\":\n            obj = MagicDictionary()\n            results.append(None)\n        elif op == \"buildDict\":\n            # arg 為 [[...]] 的形式，取第一個元素即字典列表\n            obj.buildDict(arg[0])\n            results.append(None)\n        elif op == \"search\":\n            res = obj.search(arg[0])\n            results.append(res)\n        else:\n            # 若有未知操作，視為 None\n            results.append(None)\n\n    # 使用 json.dumps 以取得 LeetCode 風格的輸出 (true/false/null)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step. The user wants algorithm. Should output lines like:\n\nStart // 程式開始\n→ Step 1: 定義類別 MagicDictionary // 定義資料結構\n... and so on. We'll design the algorithm: build dictionary into a map from word to set of patterns with wildcard at each position. Then search by generating patterns and checking map. Implementation steps: buildDict: iterate each word, for each position create pattern with '*' at that index, add word to map[pattern]. In search: for each position, create pattern with '*' and if any pattern in map and if there's more than 1 word or word not equal to searchWord etc. Actually we want exactly one modification. So pattern matching ensures at least one word different from searchWord. So algorithm: for each position, create pattern; if pattern in map: for each word in map[pattern], if word != searchWord return true. After loop return false.\n\nWe'll write pseudo-code accordingly. Output line by line. Ensure format: each line: \"虛擬碼步驟 // 解釋\". Use arrow and decisions.\n\nLet's produce.\n\nNote: Provide \"Start\" and \"End\". Use Decision to check conditions. Should show steps of building dictionary and searching.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告類別 MagicDictionary // 定義資料結構  \n→ Step 2: 宣告成員變數 dictMap: Map<string, Set<string>> // 存放模式與符合字串集合  \n\n// 建立字典  \n→ Step 3: 方法 buildDict(dictionary) // 接收單字陣列  \n→     Step 4: 清空 dictMap // 重新初始化  \n→     Step 5: Decision: dictionary 是否為空?  \n→         Yes → End // 若無字，直接結束  \n→         No  → Loop over each word in dictionary // 逐個字進行處理  \n→             Step 6: Loop index i from 0 to word.length-1 // 每個位置  \n→                 Step 7: 生成 pattern = word[0..i-1] + \"*\" + word[i+1..] // 替換第 i 個字元為 '*'  \n→                 Step 8: Decision: dictMap 是否已含 pattern?  \n→                     Yes → Add word 到 dictMap[pattern] 的 Set  \n→                     No  → 建立新 Set，加入 word，並存入 dictMap[pattern]  \n\n// 搜尋功能  \n→ Step 9: 方法 search(searchWord) // 回傳布林值  \n→     Step 10: Decision: searchWord 是否為空?  \n→         Yes → Return false // 空字不符合條件  \n→         No  → Loop over each index i in searchWord // 逐位置生成模式  \n→             Step 11: 生成 pattern = searchWord[0..i-1] + \"*\" + searchWord[i+1..]  \n→             Step 12: Decision: dictMap 是否含 pattern?  \n→                 Yes → Step 13: 從 dictMap[pattern] 的 Set 取出所有候選字串  \n→                     Step 14: Decision: 是否存在候選字串不等於 searchWord?  \n→                         Yes → Return true // 找到可單一改字可匹配的字串  \n→                         No  → 繼續下一個位置  \n→                 No  → 繼續下一個位置  \n→     Step 15: Return false // 所有位置皆無符合條件  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplhti08pf.py\", line 35, in <module>\n    main()\n  File \"/tmp/tmplhti08pf.py\", line 25, in main\n    words = ast.literal_eval(lists[0])\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"apple\"]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass WordFilter:\n    def __init__(self, words):\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):\n                for j in range(L + 1):\n                    self.lookup[(word[:i], word[j:])] = weight\n\n    def f(self, prefix, suffix):\n        return self.lookup.get((prefix, suffix), -1)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 提取兩個列表: words 與 query\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) < 2:\n        return\n    words = ast.literal_eval(lists[0])\n    query = ast.literal_eval(lists[1])\n    if not isinstance(query, (list, tuple)) or len(query) < 2:\n        return\n    pref, suff = query[0], query[1]\n    wf = WordFilter(words)\n    result = wf.f(pref, suff)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code describing solution. It's for WordFilter class with prefix and suffix search. Usually solution uses Trie or combine prefix+suffix. For this problem (Leetcode 745). We'll design two tries: prefix trie storing indices for each node, suffix trie storing indices for reversed words. Then query: we can iterate over common indices: we need largest index that appears in both prefix and suffix lists. Approach: For each node, store vector of indices sorted ascending. For query, get list for prefix, list for suffix reversed, then two-pointer from end to find common. Complexity O(len(prefix)+len(suffix)+intersection). Provide pseudocode.\n\nWe need to output line by line virtual code with explanations. Use structure arrows. Use Start, End, Decision.\n\nLet's produce steps:\n\nStart\n→ Step 1: Define Node class with children map and indices list // Node for trie\n→ Step 2: Define Trie class with root node // Trie for prefix or suffix\n→ Step 3: Trie Insert(word, index) // Insert word into trie storing indices at each node\n→ Step 4: Trie Search(word) // Return indices list for node corresponding to word\n\nThen WordFilter constructor:\n\n→ Step 5: Initialize prefixTrie and suffixTrie // Two tries\n→ Step 6: For each word in words with index i:\n    → Decision: if i exists // always true\n        → Step 7: prefixTrie.Insert(word, i) // Insert original word\n        → Step 8: suffixTrie.Insert(reversed word, i) // Insert reversed word\n\nThen f(pref, suff):\n\n→ Step 9: Get prefixIndices = prefixTrie.Search(pref) // indices for prefix\n→ Step 10: Get suffixIndices = suffixTrie.Search(reverse(suff)) // indices for suffix reversed\n→ Decision: If either list empty? // return -1\n    Yes → Step 11: Return -1 // No match\n    No → Step 12: Initialize pointer p = prefixIndices.size()-1, q = suffixIndices.size()-1 // start from largest\n→ Step 13: While p>=0 and q>=0:\n    → Decision: If prefixIndices[p] == suffixIndices[q] // found common largest\n        Yes → Step 14: Return prefixIndices[p] // answer\n        No → Decision: If prefixIndices[p] > suffixIndices[q]\n            Yes → Step 15: p-- // move prefix pointer down\n            No  → Step 16: q-- // move suffix pointer down\n→ Step 17: Return -1 // no common\n\nEnd\n\nWe need to include arrow lines properly. Format: each line starts with something like \"Start\" or \"→ Step X: ... //\". Use Decision lines.\n\nLet's output each line.\n\nMake sure each line has \"虛擬碼步驟\" and comment.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n\n→ Step 1: 定義 Node 類別，含 children (映射) 與 indices (索引清單) // Trie 的節點  \n→ Step 2: 定義 Trie 類別，含 root 為 Node // 用於前綴與後綴  \n→ Step 3: Trie.Insert(word, idx)  \n    → Decision: 如果字串不為空？ // 確保有效插入  \n        Yes → For 每個字符 c 在 word  \n            → Step 4: 取得或創建 child 節點 for c  \n            → Step 5: 將 idx 加入 child.indices // 存放此索引  \n→ Step 6: Trie.Search(prefix)  \n    → Decision: 從 root 開始遍歷 prefix  \n        Yes → 若路徑不存在 → Return 空清單  \n        No  → 返回最後節點的 indices 清單 // 前綴匹配索引  \n\n→ Step 7: WordFilter 建構子  \n    → Decision: 初始化 prefixTrie 與 suffixTrie // 兩棵 Trie  \n        Yes → prefixTrie = 新 Trie()  \n        No  → suffixTrie = 新 Trie()  \n    → Decision: 遍歷 words 並取得索引 i  \n        Yes → For each word, index i  \n            → Step 8: prefixTrie.Insert(word, i) // 正向插入  \n            → Step 9: suffixTrie.Insert(reverse(word), i) // 反向插入  \n\n→ Step 10: WordFilter.f(pref, suff)  \n    → Step 11: prefixIndices = prefixTrie.Search(pref) // 前綴索引列表  \n    → Step 12: suffixIndices = suffixTrie.Search(reverse(suff)) // 後綴索引列表  \n    → Decision: 若 prefixIndices 或 suffixIndices 為空？ // 無匹配  \n        Yes → Step 13: Return -1  \n        No  → Step 14: p = prefixIndices.size()-1 // 指向最大索引  \n               → Step 15: q = suffixIndices.size()-1 // 指向最大索引  \n    → Step 16: While p >= 0 且 q >= 0  \n        → Decision: 若 prefixIndices[p] == suffixIndices[q]？ // 找到共同最大索引  \n            Yes → Step 17: Return prefixIndices[p]  \n            No  → Decision: 若 prefixIndices[p] > suffixIndices[q]？  \n                Yes → Step 18: p-- // 前綴索引更大，向下調整  \n                No  → Step 19: q-- // 後綴索引更大，向下調整  \n    → Step 20: Return -1 // 未找到任何共同索引  \n\nEnd // 程式執行結束"
    },
    {
      "title": "IPO",
      "source_file": "Leetcode/leetcode502.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp82quciqa.py\", line 37, in <module>\n    main()\n  File \"/tmp/tmp82quciqa.py\", line 29, in main\n    k, w = map(int, data[0].split())\n    ^^^^\nValueError: invalid literal for int() with base 10: 'k'"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpewy4svqi.py\", line 37, in <module>\n    main()\n  File \"/tmp/tmpewy4svqi.py\", line 29, in main\n    k, w = map(int, data[0].split())\n    ^^^^\nValueError: invalid literal for int() with base 10: 'k'"
        }
      ],
      "generated_code": "import sys\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, W: int, Profits: list[int], Capital: list[int]) -> int:\n        # 將專案按資本需求排序\n        projects = sorted(zip(Capital, Profits))\n        max_heap = []  # 儲存可執行專案的利潤，取最大\n        idx = 0\n        n = len(Profits)\n\n        for _ in range(k):\n            # 把所有目前可執行的專案加入最大堆\n            while idx < n and projects[idx][0] <= W:\n                heapq.heappush(max_heap, -projects[idx][1])  # 負號做最大堆\n                idx += 1\n            # 若沒有可選專案則結束\n            if not max_heap:\n                break\n            # 取最大利潤的專案\n            W += -heapq.heappop(max_heap)\n        return W\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 解析輸入：假設第一行為 k 和 w，第二行為 profits，第三行為 capital\n    k, w = map(int, data[0].split())\n    profits = list(map(int, data[1].split())) if len(data) > 1 else []\n    capital = list(map(int, data[2].split())) if len(data) > 2 else []\n    solution = Solution()\n    result = solution.findMaximizedCapital(k, w, profits, capital)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, with arrow arrows and decisions, no real code. We need to produce solution algorithm: basically use priority queue to select projects with capital <= current capital, keep max profits. Use min-heap for capital, max-heap for profit. But we need virtual code. Steps: Sort projects by capital ascending. Use two heaps. For i from 0..k-1, push all projects with capital <= current capital to max-heap, then if max-heap empty break, pop max profit, add to capital. Finally return capital.\n\nWe must output line by line, each line: \"虛擬碼步驟 // 解釋\". Include Start, End, Decision, etc. Use arrows: → Step ... etc.\n\nLet's produce.\n\nWe need to ensure each line includes \"虛擬碼步驟\" meaning the step, then space, then comment.\n\nWe'll produce:\n\nStart // 程式開始執行\n\n→ Step 1: Sort projects by required capital in ascending order // 將所有專案按最低資本需求排序，方便後續掃描\n\n→ Step 2: 初始化 min-heap capitalHeap 為排序後的專案清單 // 方便取得資本要求最小的專案\n\n→ Step 3: 初始化 max-heap profitHeap 為空 // 用於儲存目前可執行專案的利潤，取最大值\n\n→ Step 4: 將初始資本 w 存入 currentCapital 變數 // 從這個資本開始挑選專案\n\n→ Step 5: 進行迴圈 i 從 1 到 k // 最高允許執行 k 個專案\n\n    → Decision: 是否有尚未處理且資本需求 ≤ currentCapital? // 檢查可執行專案是否存在\n\n        Yes → While 有此種專案:\n            → Step 5a: 從 capitalHeap 取出資本需求最小的專案\n            → Step 5b: 將其利潤加入 profitHeap\n            → Step 5c: 重複直到無更多可加入\n        No  → 直接跳過此步\n\n    → Decision: profitHeap 是否非空? // 確認是否還有可選擇的專案\n\n        Yes → Step 5d: 從 profitHeap 取出最大利潤\n        → Step 5e: 加到 currentCapital\n        No  → Step 5f: 既無可用專案也無利潤，提前結束迴圈\n\n→ End // 程式執行結束，currentCapital 即為最大化後資本\n\nBut each line must have \"虛擬碼步驟\". So we need to include arrow with Step and then comment.\n\nWe must be careful that each line follows pattern:\n\n\"Start // 程式開始執行\"\n\n\"→ Step 1: ...\" etc.\n\nAlso we need to ensure arrow or indentation. Use the arrow \"→\" preceding step lines. For decisions, use \"Decision:\".\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort all projects by required capital in ascending order // 方便後續按資本需求逐一加入可執行清單  \n→ Step 2: 初始化 min-heap capitalHeap 為排序後的專案清單 // 以便快速取得資本需求最小的專案  \n→ Step 3: 初始化 max-heap profitHeap 為空 // 用於存放目前可執行專案的利潤，並取得最大值  \n→ Step 4: 設定 currentCapital 為初始資本 w // 從這個資本開始挑選專案  \n→ Step 5: 進行迴圈 i 從 1 到 k // 最多執行 k 個專案  \n  Decision: 是否有尚未處理且資本需求 ≤ currentCapital? // 檢查是否還有可執行專案  \n   Yes → While 有此種專案  \n     Step 5a: 從 capitalHeap 取出資本需求最小的專案 // 取得最小資本需求的專案  \n     Step 5b: 將該專案的利潤加入 profitHeap // 將其利潤加入可選利潤池  \n     Step 5c: 重複直到無更多符合條件的專案  \n   No → 直接跳過此步，因為沒有可執行專案  \n  Decision: profitHeap 是否非空? // 確認還有可選擇的利潤  \n   Yes → Step 5d: 從 profitHeap 取出最大利潤 // 取得目前最有利可得的專案  \n    Step 5e: 加到 currentCapital // 更新資本  \n   No → Step 5f: 無可用專案且利潤池為空，提前結束迴圈  \nEnd // 程式執行結束，currentCapital 即為最大化後的資本值"
    },
    {
      "title": "Contains Duplicate II",
      "source_file": "Leetcode/leetcode219.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], k = 3",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9t4t9uya.py\", line 26, in <module>\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1], k = 1",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpx_aqgott.py\", line 26, in <module>\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,1,2,3], k = 2",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpf0fe2xpe.py\", line 26, in <module>\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums, k):\n        index_map = {}\n        for i, num in enumerate(nums):\n            if num in index_map and i - index_map[num] <= k:\n                return True\n            index_map[num] = i\n        return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 分割為 nums 部分與 k 部分\n    parts = data.split(',', 1)\n    nums_part = parts[0].strip()\n    k_part = parts[1].strip() if len(parts) > 1 else \"\"\n\n    # 取得 nums 列表\n    if nums_part.lower().startswith(\"nums\"):\n        nums_part = nums_part.split('=', 1)[1].strip()\n    nums = ast.literal_eval(nums_part)\n\n    # 取得 k 整數\n    if k_part.lower().startswith(\"k\"):\n        k_part = k_part.split('=', 1)[1].strip()\n    k = int(k_part) if k_part else 0\n\n    sol = Solution()\n    result = sol.containsNearbyDuplicate(nums, k)\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nWe need to generate virtual code for problem: contains duplicate within k indices. We'll produce steps: Start, input array, k. Use a hashmap to store last index of each value. Iterate through array with index i. For each element value, check if value seen before and if difference <= k, return true. Else store/update index. After loop, return false. Provide End. Need to use decision arrows. Provide explanation after each line.\n\nLet's craft. Ensure each line has virtual code and explanation. Use \"Start\" at top, \"End\" bottom. Use arrow \"→\". Use Decision with Yes → and No →. Also we need to produce boolean result. Use variable result. For return we can do \"Step X: return result\". Also maybe \"Step X: 結束\". Let's craft.\n\nWe'll also need step for input: \"Step 1: 取得 nums 與 k\". Then loop: \"Step 2: For i from 0 to length-1\". Then inside loop: \"Step 3: current = nums[i]\". Decision: \"Decision: current 已存在於 map?\" If yes, compute diff: \"Step 4: diff = i - map[current]\". Decision: diff <= k? If yes, set result true and break. Else update map[current] = i. If no, set map[current] = i. After loop, return result.\n\nLet's produce lines accordingly. Use arrow.\n\nWe must ensure each line contains \"虛擬碼步驟\" + space + \"// 解釋/說明\". We'll not output code but steps. Provide each line. Let's write.\n\nCheck formatting: no code block, just plain lines. Use indentation? The example uses indentation for nested steps. We'll use indentation with spaces.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入陣列 nums 與整數 k // 取得問題參數\n→ Step 2: 建立空的哈希表 map (value → last index) // 用於快速查找\n→ Step 3: 設定結果 result 為 false // 預設沒有符合條件\n→ Step 4: 循環 i 從 0 到 nums.length - 1 // 遍歷每個元素\n    → Step 5: current ← nums[i] // 取得當前值\n    → Decision: current 是否存在於 map? // 判斷是否已有同值\n        Yes →\n            → Step 6: diff ← i - map[current] // 計算索引差\n            → Decision: diff <= k? // 檢查距離是否符合\n                Yes →\n                    → Step 7: result ← true // 找到符合條件\n                    → Step 8: 跳出循環 // 結束搜尋\n                No  →\n                    → Step 9: map[current] ← i // 更新最新索引\n        No  →\n            → Step 10: map[current] ← i // 將新值加入哈希表\n→ Step 11: return result // 返回判斷結果\nEnd // 程式執行結束\n\nCheck indentation: use spaces. Good. Provide as final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入陣列 nums 與整數 k // 取得問題參數\n→ Step 2: 建立空的哈希表 map (value → last index) // 用於快速查找\n→ Step 3: 設定結果 result 為 false // 預設沒有符合條件\n→ Step 4: 循環 i 從 0 到 nums.length - 1 // 遍歷每個元素\n    → Step 5: current ← nums[i] // 取得當前值\n    → Decision: current 是否存在於 map? // 判斷是否已有同值\n        Yes →\n            → Step 6: diff ← i - map[current] // 計算索引差\n            → Decision: diff <= k? // 檢查距離是否符合\n                Yes →\n                    → Step 7: result ← true // 找到符合條件\n                    → Step 8: 跳出循環 // 結束搜尋\n                No  →\n                    → Step 9: map[current] ← i // 更新最新索引\n        No  →\n            → Step 10: map[current] ← i // 將新值加入哈希表\n→ Step 11: return result // 返回判斷結果\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,null,3,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, null, 3, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\nimport ast\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立從數值到其所有索引的映射\n        self.indices_map = defaultdict(list)\n        for idx, val in enumerate(nums):\n            self.indices_map[val].append(idx)\n\n    def pick(self, target):\n        # 隨機挑選一個對應目標的索引\n        return random.choice(self.indices_map[target])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：兩個列表，分別為操作序列和對應參數\n    split_index = data.find('],')\n    ops_str = data[:split_index+1]\n    args_str = data[split_index+2:].strip()\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    res = [None]  # 第一次呼叫 \"Solution\" 會返回 null\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0])  # arg[0] 為整個數字列表\n            res.append(None)\n        elif op == \"pick\":\n            res.append(obj.pick(arg[0]))\n        else:\n            # 若有其他方法可在此擴充\n            res.append(None)\n\n    # 將結果輸出為 JSON 風格，None 會轉成 null\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the solution. Outline:\n\nStart\nInitialize: store nums array.\nOption: build map from target to list of indices, or use reservoir sampling each call.\n\nGiven we need random index among all positions equal to target with equal probability. Implementation: In constructor, build a map from target to vector of indices. In pick, return random from vector.\n\nVirtual code lines with explanation.\n\nUse decision? Not needed.\n\nLet's produce steps.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize empty map targetToIndices // map from number to list of indices\n→ Step 2: For each index i in nums // iterate over array\n    → Step 3: Append i to targetToIndices[nums[i]] // record index\nEnd constructor\nThen pick function:\n\nStart pick\n→ Step 4: indices = targetToIndices[target] // retrieve list\n→ Step 5: randomIndex = Random integer between 0 and indices.size()-1 // generate random\n→ Step 6: return indices[randomIndex] // output chosen index\nEnd pick\n\nNeed to include Start/End markers.\n\nProbably need two Start blocks: one for constructor, one for pick. The example had End only once. We'll use Start for whole algorithm then End.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 初始化 targetToIndices 為空哈希表 // 建立目標到索引的映射\n→ Decision: 遍歷 nums 中每個索引 i // 逐個處理數組元素\n    → Step 2: key = nums[i] // 取得當前元素值\n    → Step 3: 將 i 加入 targetToIndices[key] 的列表 // 將索引存入對應目標的列表\nEnd // 建構完成\n\nStart pick // pick 函式開始\n→ Step 4: indices = targetToIndices[target] // 取得所有等於 target 的索引\n→ Step 5: randIdx = 隨機整數 0 到 indices.size()-1 // 隨機選擇一個位置\n→ Step 6: return indices[randIdx] // 返回隨機索引\nEnd // pick 結束\n\nBut we need each line with \"→\". In decision block, we use indentation. Use \"Decision:\" lines. The example uses \"Decision: 如果數字大於 0?\" then Yes / No. We don't need that.\n\nSimplify: Just use steps. Use indentation.\n\nLet's output:\n\nStart // 程式開始\n→ Step 1: targetToIndices ← 空哈希表 // 建立目標到索引的映射\n→ Step 2: 對 nums 中每個索引 i 執行\n    → Step 2.1: key ← nums[i] // 取得當前元素\n    → Step 2.2: targetToIndices[key].append(i) // 將索引加入對應列表\nEnd // 建構完成\n\nStart pick // pick 方法開始\n→ Step 3: indices ← targetToIndices[target] // 取得所有等於 target 的索引\n→ Step 4: r ← 隨機整數 0..len(indices)-1 // 隨機選擇\n→ Step 5: return indices[r] // 返回隨機索引\nEnd // pick 結束\n\nWe need each line with // explanation.\n\nEnsure we use \"虛擬碼步驟\" text. Use \"→\" lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: targetToIndices ← 空哈希表 // 建立目標到索引的映射\n→ Step 2: 對 nums 中每個索引 i 執行 // 逐個處理數組元素\n    → Step 2.1: key ← nums[i] // 取得當前元素\n    → Step 2.2: targetToIndices[key].append(i) // 將索引加入對應列表\nEnd // 建構完成\n\nStart pick // pick 方法開始\n→ Step 3: indices ← targetToIndices[target] // 取得所有等於 target 的索引\n→ Step 4: r ← 隨機整數 0..len(indices)-1 // 隨機選擇\n→ Step 5: return indices[r] // 返回隨機索引\nEnd // pick 結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      \"['CCCCCAAAAA', 'AAAAACCCCC']\""
        }
      ],
      "generated_code": "import sys\n\ndef findRepeatedDnaSequences(s: str):\n    \"\"\"返回 DNA 字串中長度為 10 且出現超過一次的子字串。\"\"\"\n    if len(s) < 10:\n        return []\n\n    seen = set()\n    repeated = set()\n    # 迭代所有可能的 10 字母子序列\n    for i in range(len(s) - 9):\n        seq = s[i:i+10]\n        if seq in seen:\n            repeated.add(seq)\n        else:\n            seen.add(seq)\n    return list(repeated)\n\ndef parse_input(data: str) -> str:\n    \"\"\"從輸入資料中抽取 DNA 字串。\"\"\"\n    data = data.strip()\n    if not data:\n        return \"\"\n    # 假設輸入格式為：s = 'DNA字串'\n    # 取得等號右邊的字串並安全 eval 成字串\n    try:\n        _, expr = data.split('=', 1)\n        return eval(expr.strip())\n    except Exception:\n        # 若解析失敗，回傳空字串\n        return \"\"\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    dna_seq = parse_input(raw)\n    result = findRepeatedDnaSequences(dna_seq)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: find all 10-letter-long sequences that occur more than once in a string s (DNA sequence). It's essentially Leetcode 187. Need to use sliding window or hash map. We'll produce pseudocode. Ensure each line is \"虛擬碼步驟 // 解釋\". Use arrow. Let's craft step-by-step: Start, set length = 10, if len(s) < 10 return empty. Use dictionary to count. Iterate i from 0 to len(s)-len. Extract substring. Count. After loop, collect those with count>1. Return list. Use End. Add decision for length check. Also mention storing result list. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: s長度 < 10? // 若 DNA 長度不足 10，無法有重複子序列  \n Yes → Step 1: 回傳空列表 // 直接返回空結果  \n No  → Step 2: 初始化字典 countMap // 用來記錄每個 10 字母序列出現的次數  \n→ Step 3: 初始化結果列表 result // 存放出現超過一次的序列  \n→ Step 4: 迴圈 i 從 0 到 len(s)-10  // 遍歷所有可能的 10 字母子序列  \n  → SubStep: 取 substring = s[i : i+10] // 取得當前 10 字母子序列  \n  → SubStep: countMap[substring] = countMap.get(substring, 0) + 1 // 更新計數  \n→ Step 5: 再次迴圈遍歷 countMap  \n  → SubStep: 若 countMap[seq] > 1  \n    → SubStep: result.append(seq) // 加入重複序列到結果  \n→ End // 程式執行結束，返回 result 內的所有 10 字母長子序列 (順序任意)"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Return all permutations of the list nums.\n        Uses backtracking with element swapping.\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # If we have placed all elements, store a copy of the permutation\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            # Try each element in the current position\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]   # choose\n                backtrack(start + 1)                          # recurse\n                nums[start], nums[i] = nums[i], nums[start]   # backtrack\n\n        backtrack(0)\n        return res\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read()\n    # Extract the list literal from the input, e.g. \"nums = [1,2,3]\"\n    match = re.search(r'\\[.*?\\]', data, re.S)\n    if match:\n        # Safely evaluate the list literal\n        nums = eval(match.group(0))\n    else:\n        nums = []\n\n    solution = Solution()\n    permutations = solution.permute(nums)\n    print(permutations)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for algorithm: generate all permutations of array of distinct integers. Should output step-by-step virtual code. Use Start, End, Decision, etc. Must produce per line: \"虛擬碼步驟 // 解釋/說明\". Use arrow →.\n\nWe must not output actual code, just pseudocode.\n\nLet's think: algorithm: backtracking. Steps: Start, define function permute(nums), call helper(curr, used). We'll produce all permutations.\n\nWe'll produce step-by-step: Start, Input array, Initialize result list, Define backtrack(current permutation, visited). Decision: if current length equals nums length? then add copy. Else iterate over each index. Decision: if not visited? then choose element, add to current, mark visited, backtrack, unmark visited, remove from current.\n\nFinally End.\n\nWe need to produce virtual code lines with comments.\n\nLet's design:\n\nStart // 程式開始執行\n→ Step 1: 輸入陣列 nums // 取得使用者輸入的整數陣列\n→ Step 2: 初始化結果集 res 為空列表 // 用來存放所有排列\n→ Step 3: 定義遞迴函式 backtrack(path, visited) // path: 目前排列, visited: 標記已使用元素\n→ Decision: 如果 path 長度等於 nums 長度? // 檢查是否已生成完整排列\n    Yes → Step 4: 將 path 複製並加入 res // 保存完整排列\n    No  → Decision: 迭代 i 從 0 到 nums 長度-1? // 遍歷所有元素\n        → Step 5: Decision: 如果 visited[i] 為 False? // 檢查元素是否已使用\n            Yes → Step 6: 將 nums[i] 加入 path // 選擇元素\n            → Step 7: 設置 visited[i] 為 True // 標記已使用\n            → Step 8: 調用 backtrack(path, visited) // 繼續遞迴\n            → Step 9: 設置 visited[i] 為 False // 回溯，取消使用\n            → Step 10: 從 path 移除最後一個元素 // 回到上一層\n        No  → Step 11: 继续循环 // 跳过已使用的元素\n→ Step 12: 呼叫 backtrack([], [False]*len(nums)) // 開始遞迴\n→ Step 13: 回傳 res // 回傳所有排列結果\nEnd // 程式執行結束\n\nBut we need to maintain arrow structure: → Step. For Decision, we need indent maybe? In example, indentation with four spaces before nested. We can mimic.\n\nWe should maintain arrow for each step: Start, Decision: etc. For nested we can indent.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入陣列 nums // 取得使用者輸入的整數陣列  \n→ Step 2: 初始化結果集 res 為空列表 // 用來存放所有排列  \n→ Step 3: 定義遞迴函式 backtrack(path, visited) // path: 目前排列, visited: 標記已使用元素  \n    → Decision: 如果 path 長度等於 nums 長度? // 檢查是否已生成完整排列  \n        Yes → Step 4: 將 path 複製並加入 res // 保存完整排列  \n        No  → Decision: 迭代 i 從 0 到 nums 長度-1? // 遍歷所有元素  \n            → Step 5: Decision: 如果 visited[i] 為 False? // 檢查元素是否已使用  \n                Yes → Step 6: 將 nums[i] 加入 path // 選擇元素  \n                → Step 7: 設置 visited[i] 為 True // 標記已使用  \n                → Step 8: 調用 backtrack(path, visited) // 繼續遞迴  \n                → Step 9: 設置 visited[i] 為 False // 回溯，取消使用  \n                → Step 10: 從 path 移除最後一個元素 // 回到上一層  \n            No  → Step 11: 继续循环 // 跳過已使用的元素  \n→ Step 12: 呼叫 backtrack([], [False]*len(nums)) // 開始遞迴  \n→ Step 13: 回傳 res // 回傳所有排列結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Text Justification",
      "source_file": "Leetcode/leetcode68.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1fj5o3ge.py\", line 59, in parse_input\n    words = ast.literal_eval(words_part)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\n          ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp1fj5o3ge.py\", line 76, in <module>\n    words, maxWidth = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp1fj5o3ge.py\", line 61, in parse_input\n    words = eval(words_part, {\"__builtins__\": None}, {})\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\n          ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4frlniuu.py\", line 59, in parse_input\n    words = ast.literal_eval(words_part)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\n          ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp4frlniuu.py\", line 76, in <module>\n    words, maxWidth = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4frlniuu.py\", line 61, in parse_input\n    words = eval(words_part, {\"__builtins__\": None}, {})\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\n          ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprpx4qdmj.py\", line 59, in parse_input\n    words = ast.literal_eval(words_part)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]\n          ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmprpx4qdmj.py\", line 76, in <module>\n    words, maxWidth = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmprpx4qdmj.py\", line 61, in parse_input\n    words = eval(words_part, {\"__builtins__\": None}, {})\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]\n          ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "#!/usr/bin/env python3\nimport sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \"\"\"\n        依據給定的 words 與 maxWidth，做文字左右對齊。\n        \"\"\"\n        res = []\n        i, n = 0, len(words)\n\n        while i < n:\n            # 1. 找出當前行能容納的單詞數\n            line_len = len(words[i])          # 本行已經放入的字串總長\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])  # 加一個空格與下個單詞長度\n                j += 1\n\n            line_words = words[i:j]\n            spaces_needed = maxWidth - sum(len(w) for w in line_words)\n            gaps = len(line_words) - 1\n\n            # 2. 產生本行字串\n            if j == n or gaps == 0:           # 最後一行或只有一個單詞，左對齊\n                line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n            else:                             # 全部對齊\n                space, extra = divmod(spaces_needed, gaps)\n                line_parts = []\n                for k in range(gaps):\n                    line_parts.append(line_words[k])\n                    line_parts.append(' ' * (space + (1 if k < extra else 0)))\n                line_parts.append(line_words[-1])\n                line = ''.join(line_parts)\n\n            res.append(line)\n            i = j\n\n        return res\n\n\ndef parse_input(raw: str):\n    \"\"\"\n    解析輸入字串，例如：\n    'words = [\"This\", \"is\", \"an\"], maxWidth = 16'\n    \"\"\"\n    raw = raw.strip()\n    # 先把兩個參數分開\n    if ', maxWidth =' not in raw:\n        raise ValueError('輸入格式不正確')\n    words_part, width_part = raw.split(', maxWidth =', 1)\n    words_part = words_part.strip()\n    width_part = width_part.strip()\n\n    # 解析單詞列表\n    try:\n        words = ast.literal_eval(words_part)\n    except Exception:\n        words = eval(words_part, {\"__builtins__\": None}, {})\n    # 解析寬度\n    try:\n        maxWidth = int(width_part)\n    except Exception:\n        maxWidth = int(eval(width_part, {\"__builtins__\": None}, {}))\n    return words, maxWidth\n\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit(0)\n\n    words, maxWidth = parse_input(raw_input)\n    solution = Solution()\n    output = solution.fullJustify(words, maxWidth)\n    print(output)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for text justification algorithm. Provide step-by-step pseudocode lines with explanations. Use arrow syntax.\n\nWe need to include Start, End, Decision etc. The algorithm: iterate words, group into lines, compute spaces, distribute, handle last line. Provide greedy.\n\nWe'll output each line with \"→ Step X:\" etc.\n\nLet's produce. Use step numbers? Not necessary but helpful. We'll do \"Step 1\", etc.\n\nEnsure each line: \"虛擬碼步驟 // 解釋\". Use \"→\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 列表、currentLine 空列表、currentLen 為 0 // 準備儲存結果、當前行字串及其總長度  \n→ Step 2: 循環遍歷 words 中每個 word // 逐個處理每個單詞  \n    → Decision: 若 currentLen + word.length + currentLine.size() ≤ maxWidth? // 判斷是否能加入當前行  \n        Yes → Step 3: 將 word 加入 currentLine，更新 currentLen += word.length // 加入單詞並更新行長  \n        No → Step 4: 處理已填滿的 currentLine  \n            → Step 5: 計算 totalSpaces = maxWidth - currentLen // 需要補足的空格總數  \n            → Decision: 如果 currentLine.size() == 1? // 行只有一個單詞，全部靠左  \n                Yes → Step 6: 將該單詞後面補足 totalSpaces 個空格，加入 result  \n                No → Step 7: 计算 gaps = currentLine.size() - 1  \n                    → Step 8: baseSpace = totalSpaces / gaps // 每個空格間的最小數量  \n                    → Step 9: extraSpace = totalSpaces % gaps // 需要額外分配的空格數  \n                    → Step 10: 用 loop i from 0 to currentLine.size()-1  \n                        → Step 11: 將 currentLine[i] 加入 lineStr  \n                        → Decision: 若 i < gaps? // 不是最後一個單詞  \n                            Yes → Step 12: 在 lineStr 後面加 baseSpace + (i < extraSpace ? 1 : 0) 個空格  \n                            No → Step 13: 跳過空格插入（最後一個單詞）  \n                    → Step 14: 將 lineStr 加入 result  \n            → Step 15: 重置 currentLine 為 [word]，currentLen = word.length // 開始新行，包含當前單詞  \n→ Step 16: 循環結束後，處理最後一行 (currentLine)  \n    → Step 17: 用空格將 currentLine 連接起來，並在末尾補足空格使長度為 maxWidth // 左對齊  \n    → Step 18: 將最後一行加入 result  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,1]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 1]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport collections\nimport json\nimport ast\n\nclass RandomizedCollection:\n    \"\"\"隨機集合，允許重複元素。\"\"\"\n\n    def __init__(self):\n        # 存放所有元素，方便隨機取值\n        self.data = []\n        # value -> 所有索引集合，允許 O(1) 查找和更新\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val):\n        \"\"\"插入元素，若為新元素回傳 True，否則 False。\"\"\"\n        self.data.append(val)                        # 把元素加到尾端\n        self.idx_map[val].add(len(self.data) - 1)    # 索引加入集合\n        # 若此值剛剛新增，集合長度為 1，返回 True\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val):\n        \"\"\"移除一個 val，若存在返回 True，否則 False。\"\"\"\n        if not self.idx_map[val]:                    # 沒有此值\n            return False\n\n        remove_idx = self.idx_map[val].pop()         # 任取一個索引\n        last_val = self.data[-1]                    # 最後一個元素\n\n        # 把最後一個元素移到要刪除的位置\n        self.data[remove_idx] = last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(len(self.data) - 1)\n\n        self.data.pop()                              # 刪除最後一個元素\n        return True\n\n    def getRandom(self):\n        \"\"\"隨機返回一個元素，概率與出現次數成正比。\"\"\"\n        return random.choice(self.data)\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 解析輸入：兩個列表 (ops, args)\n    try:\n        ops, args = ast.literal_eval('(' + raw + ')')\n    except Exception:\n        # 若 ast 失敗，使用 eval（假設輸入安全）\n        ops, args = eval('(' + raw + ')', {})\n\n    obj = None\n    output = []\n\n    for op, arg in zip(ops, args):\n        if op == 'RandomizedCollection':\n            obj = RandomizedCollection()\n            output.append(None)           # 建構子對應 null\n        elif op == 'insert':\n            output.append(obj.insert(arg[0]))\n        elif op == 'remove':\n            output.append(obj.remove(arg[0]))\n        elif op == 'getRandom':\n            output.append(obj.getRandom())\n        else:\n            # 忽略未知操作\n            pass\n\n    # json.dumps 將 None, True, False 分別轉為 null, true, false\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the RandomizedCollection class with insert, remove, getRandom. We should provide pseudocode with step-by-step logic, explaining each line. Use arrows. Should not output actual code. We'll design algorithm: use vector for values and hashmap from val to set of indices. Insert: append to vector, add index to set. Return true if set size 1 after insert? Actually insert returns true if val not present before. So check if val existed: if set empty then true else false.\n\nRemove: if val not present return false. Else get an index from set, remove it. To maintain O(1), swap last element into that index, update indices sets accordingly. Pop last from vector. Return true.\n\ngetRandom: choose random index in vector.\n\nWe need to produce step-by-step pseudocode.\n\nLet's produce structure: Start of class? We'll treat methods.\n\nWe may define structure of RandomizedCollection initialization: create vector, map.\n\nThen each method.\n\nWe need to output lines like:\n\nStart // 初始化 RandomizedCollection\n→ Step 1: 建立 values 數組 // 用於儲存所有元素\n→ Step 2: 建立 indexMap 字典 // key: 值, value: 集合 of 位置\n\nEnd // 完成初始化\n\nBut we may treat methods individually.\n\nGiven requirement: produce virtual code for class and methods. We'll output separate blocks? We can output one block covering all steps, but better separate.\n\nLet's produce:\n\nStart // RandomizedCollection 初始化\n→ Step 1: values ← 空動態陣列 // 存放所有元素\n→ Step 2: indexMap ← 空字典 // 每個值對應其在 values 中的索引集合\nEnd // 初始化完成\n\nThen for insert:\n\nStart // 插入 val\n→ Decision: 若 val 已存在於 indexMap? // 判斷是否第一次插入\n    Yes → result ← false // 不是新值\n    No  → result ← true  // 新值\n→ Step: idx ← values.length // 新元素將放置的索引\n→ Step: values.append(val) // 把 val 加到陣列\n→ Step: 若 indexMap[val] 不存在 則 indexMap[val] ← 空集合 // 初始化集合\n→ Step: indexMap[val].add(idx) // 將索引加入集合\n→ Return result // 回傳是否為新元素\nEnd\n\nRemove:\n\nStart // 刪除 val\n→ Decision: 若 val 未在 indexMap? // 無此元素\n    Yes → Return false\n    No  → // 有此元素\n→ Step: idx_to_remove ← 任取 indexMap[val] 中任一索引 // 取要刪除的索引\n→ Step: last_idx ← values.length - 1 // 最後一個元素索引\n→ Step: last_val ← values[last_idx] // 最後一個元素值\n→ Step: values[idx_to_remove] ← last_val // 把最後一個元素放到要刪除的位置\n→ Step: indexMap[last_val].remove(last_idx) // 移除最後一個元素原本索引\n→ Step: 若 last_val ≠ val: indexMap[last_val].add(idx_to_remove) // 更新最後一個元素的新索引\n→ Step: indexMap[val].remove(idx_to_remove) // 移除被刪除索引\n→ Step: values.pop() // 移除最後一個元素\n→ Decision: 若 indexMap[val] 變空? // 之後是否仍有此值\n    Yes → delete indexMap[val] // 刪除空集合\n    No  → // 留著\n→ Return true\nEnd\n\nGetRandom:\n\nStart // 取得隨機元素\n→ Step: random_index ← 隨機整數 0~values.length-1 // 隨機索引\n→ Step: Return values[random_index]\nEnd\n\nNeed to ensure each line with virtual code and explanation.\n\nWe must output all steps. Let's produce.\n\nWe'll use arrow \"→\" for steps, \"Decision:\" for decisions. Use Yes/No branches. Each line ends with comment after \"//\".\n\nOk.\n...done thinking.\n\n```\nStart // 初始化 RandomizedCollection\n→ Step 1: values ← 空動態陣列 // 用來存放所有元素，允許重複\n→ Step 2: indexMap ← 空字典 // key: 數值, value: 存放該數值在 values 中所有索引的集合\nEnd // 初始化完成\n\nStart // insert(val) - 插入元素\n→ Decision: 若 val 已存在於 indexMap? // 判斷是否為首次插入\n    Yes → result ← false // val 已存在，返回 false\n    No  → result ← true  // val 為新值，返回 true\n→ Step: idx ← values.length // 新元素將放在 values 的最後\n→ Step: values.append(val) // 把 val 加到 values\n→ Step: 若 indexMap[val] 不存在 則 indexMap[val] ← 空集合 // 初始化集合\n→ Step: indexMap[val].add(idx) // 把新索引加入集合\n→ Return result // 回傳是否為新元素\nEnd\n\nStart // remove(val) - 刪除元素\n→ Decision: 若 val 未在 indexMap? // 無此元素可刪除\n    Yes → Return false\n    No  → // 有此元素，繼續刪除\n→ Step: idx_to_remove ← 任取 indexMap[val] 中任一索引 // 要刪除的位置\n→ Step: last_idx ← values.length - 1 // 最後一個元素的索引\n→ Step: last_val ← values[last_idx] // 最後一個元素的值\n→ Step: values[idx_to_remove] ← last_val // 把最後一個元素移到要刪除的位置\n→ Step: indexMap[last_val].remove(last_idx) // 移除 last_val 原本的最後索引\n→ Decision: 若 last_val ≠ val? // 只有在不是同一個值時才需更新索引\n    Yes → Step: indexMap[last_val].add(idx_to_remove) // 把新索引加入集合\n    No  → // 不需要\n→ Step: indexMap[val].remove(idx_to_remove) // 移除被刪除元素的索引\n→ Step: values.pop() // 從 values 刪除最後一個元素\n→ Decision: 若 indexMap[val] 變空? // 該值是否還存在\n    Yes → Step: delete indexMap[val] // 刪除空集合\n    No  → // 留著\n→ Return true // 成功刪除\nEnd\n\nStart // getRandom() - 取得隨機元素\n→ Step: random_index ← 隨機整數 0 ~ values.length-1 // 隨機選擇索引\n→ Return values[random_index] // 回傳該索引的元素\nEnd\n```"
    },
    {
      "title": "Merge k Sorted Lists",
      "source_file": "Leetcode/leetcode23.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
          "expected_output": "[1,1,2,3,4,4,5,6]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvz2smvyw.py\", line 70, in <module>\n    data = parse_input(input_str)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvz2smvyw.py\", line 65, in parse_input\n    return eval(s, {}, {})\n           ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    lists = [[1,4,5],[1,3,4],[2,6]]\n          ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "lists = []",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp13cylxe7.py\", line 70, in <module>\n    data = parse_input(input_str)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp13cylxe7.py\", line 65, in parse_input\n    return eval(s, {}, {})\n           ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    lists = []\n          ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "lists = [[]]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbss4tuw2.py\", line 70, in <module>\n    data = parse_input(input_str)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbss4tuw2.py\", line 65, in parse_input\n    return eval(s, {}, {})\n           ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    lists = [[]]\n          ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport heapq\n\n# Definition for singly-linked list node.\nclass ListNode:\n    __slots__ = ('val', 'next')\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists):\n        \"\"\"\n        Merge k sorted linked lists using a min-heap.\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if not lists:\n            return None\n\n        # Dummy head to simplify list construction\n        dummy = ListNode()\n        tail = dummy\n\n        # Min-heap: (node value, list index, node reference)\n        min_heap = []\n        for i, node in enumerate(lists):\n            if node:\n                heapq.heappush(min_heap, (node.val, i, node))\n\n        # Merge until heap is empty\n        while min_heap:\n            val, idx, node = heapq.heappop(min_heap)\n            tail.next = node\n            tail = node\n            if node.next:\n                heapq.heappush(min_heap, (node.next.val, idx, node.next))\n\n        return dummy.next\n\ndef build_linked_list(nums):\n    \"\"\"Create a linked list from a list of numbers.\"\"\"\n    dummy = ListNode()\n    cur = dummy\n    for num in nums:\n        cur.next = ListNode(num)\n        cur = cur.next\n    return dummy.next\n\ndef linked_list_to_list(head):\n    \"\"\"Convert a linked list back to a Python list.\"\"\"\n    res = []\n    cur = head\n    while cur:\n        res.append(cur.val)\n        cur = cur.next\n    return res\n\ndef parse_input(s):\n    \"\"\"Parse the input string into a Python dictionary.\"\"\"\n    s = s.strip()\n    # Remove surrounding quotes if present\n    if (s.startswith(\"'\") and s.endswith(\"'\")) or (s.startswith('\"') and s.endswith('\"')):\n        s = s[1:-1]\n    return eval(s, {}, {})\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    input_str = sys.stdin.read()\n    data = parse_input(input_str)\n    raw_lists = data.get('lists', [])\n\n    # Convert each sublist to a linked list\n    list_nodes = [build_linked_list(sublist) for sublist in raw_lists]\n\n    # Merge and output result\n    solution = Solution()\n    merged_head = solution.mergeKLists(list_nodes)\n    result = linked_list_to_list(merged_head)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for merging k sorted linked lists into one sorted linked list. Use priority queue approach. Steps: Create min-heap, push first nodes, then pop smallest, add to result, push next node from same list. Provide each line with comment. Use Start, End, Decision. Need to produce line-by-line. Ensure to include arrow. Format: `→ Step ...` etc.\n\nLet's design steps:\n\nStart\n→ Initialize result dummy head and tail pointer\n→ Initialize min-heap (priority queue) // store nodes with value and list index\n→ For each list i in lists:\n    If list[i] not null:\n        Insert (list[i].val, i, node pointer) into heap\nDecision: If heap empty? \n    Yes → End // no nodes, return null\n    No → continue\n\n→ While heap not empty:\n    Pop smallest element (val, idx, node)\n    Set tail.next = node\n    tail = node\n    If node.next not null:\n        Push (node.next.val, idx, node.next) into heap\nEnd\n\nWe need to output each line with comment. We might separate decisions with indentation. Provide each step.\n\nWe need to ensure no actual code, just virtual code steps. Use `Decision: ...?` etc. Use arrows. Provide comments after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 dummy 頭節點 dummyHead // 用來簡化尾部連接  \n→ Step 2: 指定 tail = dummyHead // tail 指向目前已建立的尾節點  \n→ Step 3: 建立最小堆 minHeap // 儲存 (節點值, 清單索引, 節點指標)  \n→ Step 4: 對於每個清單 i:  \n  Decision: 如果 lists[i] 為空? // 檢查清單是否有節點  \n   Yes → Skip i // 無節點直接跳過  \n   No  → Step 5: 將 (lists[i].val, i, lists[i]) 插入 minHeap // 把首節點加入堆  \nDecision: 如果 minHeap 為空? // 若所有清單均為空  \n  Yes → End // 無節點可合併，回傳 null  \n  No  → Continue // 有節點可處理  \n→ While minHeap 不為空: // 逐步合併節點  \n  Decision: 從 minHeap 取出最小元素 (val, idx, node) // 取得最小值節點  \n   Yes → Step 6: tail.next = node // 將節點接到結果鏈表  \n       tail = node // 更新尾節點  \n       Decision: 如果 node.next 不為空? // 檢查是否還有後續節點  \n        Yes → Step 7: 將 (node.next.val, idx, node.next) 插入 minHeap // 把後續節點加入堆  \n        No  → Skip  \nEnd // 程式執行結束，回傳 dummyHead.next 為合併後的有序鏈表"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport heapq\n\nclass MedianFinder:\n    \"\"\"\n    用兩個堆來維持數字的中位數。\n    small  : 儲存較小半部的數字，使用負數來實作最大堆\n    large  : 儲存較大半部的數字，最小堆\n    \"\"\"\n    def __init__(self):\n        self.small = []   # max heap (存負數)\n        self.large = []   # min heap\n\n    def addNum(self, num):\n        \"\"\"\n        新增一個數字到資料結構，並保持兩堆大小差不超過 1。\n        \"\"\"\n        heapq.heappush(self.small, -num)          # 先放進 small\n        # 如果兩堆中最大值在 small 里大於 large 的最小值，交換\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡堆的大小\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self):\n        \"\"\"\n        回傳目前所有數字的中位數。\n        \"\"\"\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main():\n    \"\"\"\n    主程式入口，從 stdin 讀取指令與參數，執行 MedianFinder 操作，最後輸出結果列表。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入拆成兩個 list：指令和參數\n    # 例：'[\"MedianFinder\", \"addNum\"], [[], [1]]'\n    idx = data.find('],')\n    if idx == -1:\n        # 如果沒有找到 '],'，直接按逗號分割（備用）\n        parts = data.split(',', 1)\n    else:\n        parts = [data[:idx + 1], data[idx + 2:].strip()]\n\n    cmds = ast.literal_eval(parts[0].strip())\n    args = ast.literal_eval(parts[1].strip())\n\n    outputs = []\n    obj = None\n\n    for cmd, arg in zip(cmds, args):\n        if cmd == \"MedianFinder\":\n            obj = MedianFinder()\n            outputs.append(None)          # constructor 產生的結果為 null\n        elif cmd == \"addNum\":\n            obj.addNum(arg[0])           # arg 為 [value]\n            outputs.append(None)\n        elif cmd == \"findMedian\":\n            median = obj.findMedian()\n            outputs.append(median)\n\n    # json.dumps 會將 None 轉成 null，符合題目示例輸出格式\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for MedianFinder class with operations addNum and findMedian. Use virtual code steps. Probably using two heaps: max heap for lower half, min heap for upper half. Ensure size difference <=1. median accordingly. Provide virtual code lines. Use Start, End, Decision etc. We'll produce a high-level algorithm. Each line includes explanation. Ensure to use \"→\" arrow etc. Provide as per format.\n\nLet's produce:\n\nStart\n→ Step 1: 定義 MaxHeap lowerHalf // 儲存較小半部的數字\n→ Step 2: 定義 MinHeap upperHalf // 儲存較大半部的數字\n→ Step 3: 定義 Variable size // 紀錄總元素數\n→ Step 4: 初始化 MedianFinder() // 建構子：初始化堆、大小\n→ Decision: addNum 的流程\n   → Step 5: addNum(num)\n      → Decision: 如果 lowerHalf 為空 或 num <= max(lowerHalf)\n          → Step 6: lowerHalf.push(num) // 將數字放入 lowerHalf\n          → Decision: lowerHalf.size() > upperHalf.size() + 1\n              → Step 7: upperHalf.push(lowerHalf.popMax()) // 平衡，將最大移到 upperHalf\n      → No  → Step 8: upperHalf.push(num) // 將數字放入 upperHalf\n          → Decision: upperHalf.size() > lowerHalf.size() + 1\n              → Step 9: lowerHalf.push(upperHalf.popMin()) // 平衡，將最小移到 lowerHalf\n      → Step 10: size++ // 更新總數\n   → End\n→ Decision: findMedian 的流程\n   → Step 11: findMedian()\n      → Decision: size 為偶數?\n          → Yes → Step 12: median = (lowerHalf.peekMax() + upperHalf.peekMin()) / 2.0 // 兩個中位數平均\n          → No  → Step 13: median = lowerHalf.peekMax() // 取較大堆的最大值\n      → Step 14: return median\n   → End\nEnd\n\nWe need each line with \"虛擬碼步驟 [space] // 解釋\". The virtual code includes Start, End, Decision. Use arrows. Provide each line.\n\nLet's format:\n\nStart // 程式開始\n→ Step 1: 定義 MaxHeap lowerHalf // 用於儲存較小半部的數字，最大堆\n→ Step 2: 定義 MinHeap upperHalf // 用於儲存較大半部的數字，最小堆\n→ Step 3: 定義 int size // 總元素個數\n→ Step 4: 初始化 MedianFinder() // 建構子：初始化兩個堆與 size\n→ Decision: addNum 的流程\n    Yes → Step 5: addNum(num) // 新增數字到資料結構\n        → Decision: lowerHalf 為空 或 num <= lowerHalf.peekMax() ?\n            Yes → Step 6: lowerHalf.push(num) // 把數字放進較小半部\n            → Decision: lowerHalf.size() > upperHalf.size() + 1 ?\n                Yes → Step 7: upperHalf.push(lowerHalf.popMax()) // 平衡：移最大到較大半部\n            No  → Step 8: upperHalf.push(num) // 把數字放進較大半部\n                → Decision: upperHalf.size() > lowerHalf.size() + 1 ?\n                    Yes → Step 9: lowerHalf.push(upperHalf.popMin()) // 平衡：移最小到較小半部\n        → Step 10: size++ // 更新總數\n    No → // 無其他操作\n→ Decision: findMedian 的流程\n    Yes → Step 11: findMedian() // 計算並回傳目前中位數\n        → Decision: size % 2 == 0 ?\n            Yes → Step 12: median = (lowerHalf.peekMax() + upperHalf.peekMin()) / 2.0 // 偶數個數，取兩個中位數平均\n            No  → Step 13: median = lowerHalf.peekMax() // 奇數個數，取較大堆最大值\n        → Step 14: return median // 回傳結果\n    No → // 無其他操作\nEnd // 程式結束\n\nBut need to maintain indentation? The example shows indented lines with decision sub-steps. Use same style: \"Decision: ... //\", then lines under with arrow. Provide each step with arrow. Should be acceptable.\n\nEnsure each line has 虛擬碼步驟 + space + // explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MaxHeap lowerHalf // 用於儲存較小半部的數字，最大堆  \n→ Step 2: 定義 MinHeap upperHalf // 用於儲存較大半部的數字，最小堆  \n→ Step 3: 定義 int size // 總元素個數  \n→ Step 4: 初始化 MedianFinder() // 建構子：初始化兩個堆與 size  \n→ Decision: addNum 的流程  \n    Yes → Step 5: addNum(num) // 新增數字到資料結構  \n        → Decision: lowerHalf 為空 或 num <= lowerHalf.peekMax()？ // 判斷放入哪一堆  \n            Yes → Step 6: lowerHalf.push(num) // 把數字放進較小半部  \n            → Decision: lowerHalf.size() > upperHalf.size() + 1？ // 檢查是否需要平衡  \n                Yes → Step 7: upperHalf.push(lowerHalf.popMax()) // 移最大到較大半部  \n            No  → Step 8: upperHalf.push(num) // 把數字放進較大半部  \n                → Decision: upperHalf.size() > lowerHalf.size() + 1？ // 檢查是否需要平衡  \n                    Yes → Step 9: lowerHalf.push(upperHalf.popMin()) // 移最小到較小半部  \n        → Step 10: size++ // 更新總數  \n    No → // 無其他操作  \n→ Decision: findMedian 的流程  \n    Yes → Step 11: findMedian() // 計算並回傳目前中位數  \n        → Decision: size % 2 == 0？ // 判斷元素數是否為偶數  \n            Yes → Step 12: median = (lowerHalf.peekMax() + upperHalf.peekMin()) / 2.0 // 偶數個數，取兩個中位數平均  \n            No  → Step 13: median = lowerHalf.peekMax() // 奇數個數，取較大堆最大值  \n        → Step 14: return median // 回傳結果  \n    No → // 無其他操作  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbiap6tx2.py\", line 43, in <module>\n    raise ValueError(\"Input format incorrect. Expected: 'intervals = [...], newInterval = [...]'\")\nValueError: Input format incorrect. Expected: 'intervals = [...], newInterval = [...]'"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpeaa4fcv1.py\", line 43, in <module>\n    raise ValueError(\"Input format incorrect. Expected: 'intervals = [...], newInterval = [...]'\")\nValueError: Input format incorrect. Expected: 'intervals = [...], newInterval = [...]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Insert a new interval into a sorted, non-overlapping list of intervals\n        and merge any overlapping intervals.\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # 1. Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # 2. Merge all intervals that overlap with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # 3. Add the merged (or original) new interval\n        result.append(newInterval)\n\n        # 4. Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\nif __name__ == \"__main__\":\n    # Read entire input\n    data = sys.stdin.read().strip()\n\n    # Extract intervals and newInterval using regex\n    pattern = r'intervals\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*newInterval\\s*=\\s*(\\[.*\\])'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"Input format incorrect. Expected: 'intervals = [...], newInterval = [...]'\")\n\n    intervals_str, new_interval_str = match.group(1), match.group(2)\n\n    # Safely evaluate the string representations of the lists\n    intervals = eval(intervals_str)\n    new_interval = eval(new_interval_str)\n\n    # Perform the insertion and merging\n    solution = Solution()\n    result = solution.insert(intervals, new_interval)\n\n    # Output the result\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for merging intervals. Provide line by line. Let's craft a pseudo algorithm:\n\n- Start\n- Input intervals, newInterval\n- Initialize result list\n- Iterate through intervals\n  - If current interval ends before newInterval starts, append current\n  - Else if current interval starts after newInterval ends, append newInterval then append rest and break\n  - Else overlap: merge by updating newInterval start = min(start,current start), end = max(end,current end)\n- After loop, append newInterval if not added\n- Return result\n\nInclude decisions.\n\nWe must produce each line with virtual code and comment. Use arrow. Let's do.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入 intervals, newInterval // 取得原始區間列與新插入區間\n→ Step 2: 建立空的結果陣列 result = [] // 用來存放合併後的區間\n→ Step 3: 設定 flag added = False // 標記 newInterval 是否已加入結果\n→ Decision: 是否還有未處理的原始區間? // 檢查迴圈是否結束\n    Yes → Step 4: 取出第一個原始區間 cur = intervals[0] // 取得當前處理的區間\n    → Decision: cur.end < newInterval.start? // 原始區間完全在新區間左側\n        Yes → Step 5: result.append(cur) // 直接加入結果\n        No  → Decision: cur.start > newInterval.end? // 原始區間完全在新區間右側\n            Yes → Step 6: result.append(newInterval) // 先加入新區間\n                → Step 7: added = True // 標記已加入\n                → Step 8: 移除已處理區間並將其餘區間一次性加入 result // 將剩餘區間加入結果\n                → Step 9: 跳出迴圈 // 合併完成，結束迴圈\n            No  → Step 10: newInterval.start = min(newInterval.start, cur.start) // 合併重疊區間\n                → Step 11: newInterval.end = max(newInterval.end, cur.end) // 更新新區間的終點\n    → 移除已處理的 cur 並返回決策點 // 進行下一個原始區間的處理\n→ Decision: 所有原始區間已處理完畢? // 判斷是否需要再加入 newInterval\n    Yes → Decision: added? // 新區間是否已加入？\n        Yes → Step 12: 返回 result // 完成，直接返回結果\n        No  → Step 13: result.append(newInterval) // 加入最後一個新區間\n            → Step 14: 返回 result // 完成，返回結果\n    No  → 跳回到 Step 4 // 繼續處理下一個原始區間\nEnd // 程式執行結束"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,null,-1,3,4]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, null, -1, 3, 4]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value  # move to most recent\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)  # remove least recent\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the two list literals from the input\n    list_strings = re.findall(r'\\[.*?\\]', data, re.DOTALL)\n    if len(list_strings) != 2:\n        return\n\n    ops = ast.literal_eval(list_strings[0])\n    args = ast.literal_eval(list_strings[1])\n\n    outputs = []\n    cache = None\n\n    for op, arg in zip(ops, args):\n        if op == \"LRUCache\":\n            cache = LRUCache(arg[0])\n            outputs.append(\"null\")\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            outputs.append(\"null\")\n        elif op == \"get\":\n            res = cache.get(arg[0])\n            outputs.append(str(res))\n        else:\n            # ignore unknown operations\n            continue\n\n    print(\"[\" + \", \".join(outputs) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for LRU Cache design. Use arrow etc. Should be line by line. Each line: Virtual code step + space + // explanation. Use Start, End, Decision, etc.\n\nWe need to design data structures: probably a doubly linked list + hash map. Steps for initialization, get, put. Need to show O(1) operations.\n\nWe need to output just the virtual code, not actual code. Each line must have arrow etc.\n\nWe should structure: Start, Step 1: Initialize structures. Then implement get and put. Use decisions.\n\nProbably separate functions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義容量變數 capacity ← 參數 // 存儲最大容量\n→ Step 2: 建立空的雙向鏈表 head ↔ tail // 用於維護最近使用順序\n→ Step 3: 建立雜湊表 keyToNode // 存儲 key → 鏈表節點的映射\n→ Step 4: 建立目前大小 size ← 0 // 追蹤已存鍵數\n\n// 定義內部節點結構\n→ Step 5: 定義 Node { key, value, prev, next } // 每個節點存 key/value 並鏈接\n\n// 將節點移到鏈表頭\n→ Step 6: 定義 moveToHead(node) // 把 node 移到最近使用位置\n    → Step 7: 移除 node 從原位置 // O(1)\n    → Step 8: 插入 node 到 head 後面 // O(1)\n\n// 插入節點到頭部\n→ Step 9: 定義 addToHead(node) // 新節點插入頭部\n    → Step 10: node.prev ← head\n    → Step 11: node.next ← head.next\n    → Step 12: head.next.prev ← node\n    → Step 13: head.next ← node\n\n// 移除尾部節點\n→ Step 14: 定義 removeTail() // 移除最舊節點\n    → Step 15: node ← tail.prev // 取得尾節點\n    → Step 16: 移除 node 從鏈表 // O(1)\n    → Step 17: return node\n\n// 移除節點\n→ Step 18: 定義 removeNode(node)\n    → Step 19: node.prev.next ← node.next\n    → Step 20: node.next.prev ← node.prev\n\n// Get 操作\n→ Step 21: Function get(key)\n    → Decision: key 是否存在於 keyToNode?\n        Yes → Step 22: node ← keyToNode[key] // 找到節點\n        → Step 23: moveToHead(node) // 更新使用順序\n        → Step 24: return node.value // 返回值\n        No  → Step 25: return -1 // 未找到\n\n// Put 操作\n→ Step 26: Function put(key, value)\n    → Decision: key 是否存在於 keyToNode?\n        Yes → Step 27: node ← keyToNode[key]\n            → Step 28: node.value ← value // 更新值\n            → Step 29: moveToHead(node) // 更新順序\n        No  → Step 30: node ← 新 Node(key, value)\n            → Step 31: addToHead(node)\n            → Step 32: keyToNode[key] ← node\n            → Step 33: size ← size + 1\n            → Decision: size > capacity?\n                Yes → Step 34: tailNode ← removeTail() // 淘汰最舊\n                    → Step 35: 從 keyToNode 刪除 tailNode.key\n                    → Step 36: size ← size - 1\n                No  → // 不超容量\nEnd // 程式執行結束\n\nWe need to ensure each line ends with // explanation. Also, we should use arrows for decisions and yes/no. Provide exactly as required.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: capacity ← input_capacity // 儲存最大容量  \n→ Step 2: head ← 新 Node(-1, -1) // 建立虛擬頭節點  \n→ Step 3: tail ← 新 Node(-1, -1) // 建立虛擬尾節點  \n→ Step 4: head.next ← tail ; tail.prev ← head // 連接頭尾  \n→ Step 5: keyToNode ← 新 Map() // key → 节点映射  \n→ Step 6: size ← 0 // 当前键数量  \n\n// 定义内部节点结构  \n→ Step 7: 定义 Node(key, value)  \n → Step 8: this.key ← key  \n → Step 9: this.value ← value  \n → Step 10: this.prev ← null  \n → Step 11: this.next ← null  \n\n// 把节点移到链表头  \n→ Step 12: moveToHead(node)  \n → Step 13: removeNode(node) // 从原位置拆除  \n → Step 14: addToHead(node) // 插入头部  \n\n// 在链表头插入新节点  \n→ Step 15: addToHead(node)  \n → Step 16: node.prev ← head  \n → Step 17: node.next ← head.next  \n → Step 18: head.next.prev ← node  \n → Step 19: head.next ← node  \n\n// 移除链表尾部节点（最旧）  \n→ Step 20: removeTail()  \n → Step 21: node ← tail.prev // 取得尾节点  \n → Step 22: removeNode(node)  \n → Step 23: return node  \n\n// 直接从链表中移除节点  \n→ Step 24: removeNode(node)  \n → Step 25: node.prev.next ← node.next  \n → Step 26: node.next.prev ← node.prev  \n\n// get 操作  \n→ Step 27: get(key)  \n → Decision: key 於 keyToNode?  \n  Yes → Step 28: node ← keyToNode[key]  \n   → Step 29: moveToHead(node) // 更新最近使用  \n   → Step 30: return node.value  \n  No  → Step 31: return -1 // 未找到  \n\n// put 操作  \n→ Step 32: put(key, value)  \n → Decision: key 於 keyToNode?  \n  Yes → Step 33: node ← keyToNode[key]  \n   → Step 34: node.value ← value // 更新值  \n   → Step 35: moveToHead(node)  \n  No  → Step 36: node ← 新 Node(key, value)  \n   → Step 37: addToHead(node)  \n   → Step 38: keyToNode[key] ← node  \n   → Step 39: size ← size + 1  \n   → Decision: size > capacity?  \n    Yes → Step 40: tailNode ← removeTail() // 淘汰最旧  \n     → Step 41: keyToNode.remove(tailNode.key)  \n     → Step 42: size ← size - 1  \n    No  → // 维持容量  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Index Sum of Two Lists",
      "source_file": "Leetcode/leetcode599.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]",
          "expected_output": "[\"Shogun\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpr7v0ck8f.py\", line 40, in <module>\n    result = find_restaurant(list1, list2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpr7v0ck8f.py\", line 6, in find_restaurant\n    index_map = {name: i for i, name in enumerate(list1)}\n                 ^^^^^^^\nTypeError: unhashable type: 'list'"
        },
        {
          "example_index": 1,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]",
          "expected_output": "[\"Shogun\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpq7q88sa5.py\", line 40, in <module>\n    result = find_restaurant(list1, list2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpq7q88sa5.py\", line 6, in find_restaurant\n    index_map = {name: i for i, name in enumerate(list1)}\n                 ^^^^^^^\nTypeError: unhashable type: 'list'"
        },
        {
          "example_index": 2,
          "input": "list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]",
          "expected_output": "[\"sad\",\"happy\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4x5eku_k.py\", line 40, in <module>\n    result = find_restaurant(list1, list2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4x5eku_k.py\", line 6, in find_restaurant\n    index_map = {name: i for i, name in enumerate(list1)}\n                 ^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\ndef find_restaurant(list1, list2):\n    index_map = {name: i for i, name in enumerate(list1)}\n    min_sum = float('inf')\n    res = []\n    for j, name in enumerate(list2):\n        if name in index_map:\n            total = j + index_map[name]\n            if total < min_sum:\n                min_sum = total\n                res = [name]\n            elif total == min_sum:\n                res.append(name)\n    return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Remove newlines for easier processing\n    data = data.replace('\\n', ' ')\n    # Find positions of the list assignments\n    idx1 = data.find('list1 =')\n    idx2 = data.find('list2 =')\n    if idx1 == -1 or idx2 == -1:\n        print(\"[]\")\n        sys.exit(0)\n    # Extract the list literals\n    list1_str = data[idx1 + len('list1 ='):idx2].strip()\n    list2_str = data[idx2 + len('list2 ='):].strip()\n    # Evaluate the list literals safely\n    try:\n        list1 = ast.literal_eval(list1_str)\n        list2 = ast.literal_eval(list2_str)\n    except Exception:\n        print(\"[]\")\n        sys.exit(0)\n    # Compute result\n    result = find_restaurant(list1, list2)\n    # Output as JSON string to match required format\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this algorithm: find common strings with least index sum. Steps: Build map of string->index for list1, iterate list2 and compute sum; track min sum and result list. Provide virtual code lines with explanation. Ensure each line ends with // explanation. Use arrow etc. Format as given. We'll include Start, End. Ensure each line includes virtual code step and comment. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 indexMap // 用於儲存 list1 中每個字串及其索引  \n→ Decision: list1 是否非空?  \n Yes → Step 2: 對每個索引 i 與字串 s 迭代 list1  \n  → Step 2a: indexMap[s] ← i // 將字串與其索引儲存到字典  \n No → Step 2b: 直接跳至 Step 3 // 若 list1 為空，索引表保持空  \n\n→ Step 3: 建立變數 minSum ← ∞ // 追蹤最小索引和  \n→ Step 4: 建立空列表 result // 儲存所有最小和的共同字串  \n\n→ Decision: list2 是否非空?  \n Yes → Step 5: 對每個索引 j 與字串 t 迭代 list2  \n  → Decision: t 是否在 indexMap?  \n   Yes → Step 5a: sum ← j + indexMap[t] // 計算兩個索引之和  \n    → Decision: sum < minSum?  \n     Yes → Step 5b: minSum ← sum // 更新最小和  \n      → Step 5b1: result ← [t] // 重置結果列表只保留新最小和字串  \n       // 重新開始儲存最小和的字串  \n         \n      No → Step 5c: sum == minSum?  \n        Yes → Step 5d: result.append(t) // 若相同最小和，加入結果  \n        No → Step 5e: // 無需處理，保持現狀  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n  insured system<|channel|><|channel|>analysis<|message|>We need to produce code for problem: compute number of nodes visited before termination given start, target, operations. But we have to output just number of distinct nodes visited (unique). Wait \"count all the nodes visited\". Do we count repeated visits? The example: 7 nodes visited, path: 1->2->4->3->6->5->7, each node unique. So they counted distinct nodes visited. But what if the path loops? The rule: if we encounter previously visited node, terminate; count all nodes visited before termination, including the repeated node? Problem statement: \"terminate if it visits a previously visited node\" -> we should stop upon first repeated visit. The counting: \"Your task is to determine the number of nodes that the computer will visit before it stops or until it repeats a previously visited node\" (maybe?). The sample: path visited nodes 1 2 4 3 6 5 7 (7 nodes). That path visited 7 distinct nodes; but we must output number of nodes visited before stopping. If we had loop, we count distinct nodes visited before the loop; if the loop starts at node that was visited earlier, we stop before visiting it again. For counting nodes visited, we include the node that was visited again? Let's interpret: \"number of nodes that the computer will visit before it stops or until it repeats a previously visited node\". That phrase ambiguous. But typical approach: number of distinct nodes visited until loop occurs (the first repeated node triggers stop). Example: Suppose we start at node that goes to itself: a=1,b=0. Starting at node 1: we visit node 1, then next is 1 again. At this point, we have visited node 1 again. According to rule: \"stop when visiting a previously visited node\" - We already visited node 1 earlier, so we should stop at that point. But do we count node 1 again? We visited node 1 again before termination. So we would have visited 2 nodes? That would count duplicate. But maybe they mean distinct nodes visited. Hard to guess. Usually such problems (like UVA 1185? maybe 1185 \"Little Red Riding Hood\"? Not). I recall a known problem: \"1002 - 1002\"? Actually there is UVA 1185 \"Little Red Riding Hood\"? Not. Another known problem: \"Number of nodes visited before cycle\" (like UVA 100? no). There is UVA 1010? Wait: I know UVA 10079? Not. Let's search memory: The problem is similar to UVA 11098 \"Little Red Riding Hood\"? Not. Hmm.\n\nLet's look at sample: path 1->2->4->3->6->5->7. All distinct. That doesn't clarify counting repeated nodes.\n\nConsider scenario: Suppose operations a=0,b=1 (always 1). Starting node 1: path 1->1 again. Would we output 1 or 2? Let's think typical algorithm for \"count of distinct nodes visited until first repeat\" would output 1. But \"count of nodes visited before termination (including repeated node)\" would output 2. Which is more likely? Let's analyze problem statement again: \"You need to figure out how many nodes the computer will visit before it stops or until it repeats a previously visited node.\" Means \"how many nodes will the computer visit before it stops\" (which can be due to repetition). So if it repeats a node, that's when it stops. But does it stop immediately after revisiting? Probably yes. So we should count nodes visited until the repeated node is visited. That includes the repeated node itself, since it visits it before stopping. In the sample, there's no repeat before reaching target, so we count all nodes visited including the target node (since target is the first repeated? Wait we stop when reaching target; but we don't repeat a node. So we visited 7 nodes until reaching target (node 7). That includes the target node. So count includes target node.\n\nTherefore if we had a loop, we would stop upon revisiting the node; that node counts. So we would count distinct nodes visited before the repetition, plus the repeated node? But repeated node was visited earlier; it's visited again; we count this second visit? That would result in number of nodes visited (not distinct). But the problem may define \"number of nodes visited\" as distinct nodes visited? Let's examine the typical UVA problem \"Number of nodes visited before first repeat\" is known as UVA 1185? Wait there is UVA 100? Let's search memory: There is UVA 100 \"The 3n + 1 Problem\"? Not. UVA 104 \"Arbitrage\"? Not.\n\nBut I recall a UVA problem 1011 \"Little Red Riding Hood\" again not. Let's search memory: I know there is UVA 1185 \"Little Red Riding Hood\" but I'm not sure.\n\nBetter: Let's think about algorithm: They ask to compute number of nodes visited until we either hit target or we revisit a node. We can simulate until visited again. Complexity small (N up to 50). So just simulate. The visited set we can store. For counting nodes visited: If we count number of nodes visited before termination, we can simply increment counter each time we visit a node, including the repeated node and target. Example: Starting at 1, visited 1, visited 2, visited 4, visited 3, visited 6, visited 5, visited 7; visited counter 7. If we had loop: Starting at 1, operations: 1+1=2 (a=1,b=1). Suppose N=3, start=1, target=4? Not.\n\nLet's design test: N=2, start=1, target=2, a=0,b=0: next=0%2+1=1? Actually (0*1+0)%2+1 = 0+1=1. So next always 1. Path: 1 visited, then 1 again (repeated). We would stop. Count nodes visited: visited 1, then visited 1 again, stop. Count=2. But if they expected 1, they'd treat repeated node not counted. But which is more plausible? I'd guess they want count of distinct nodes visited until repeat? Let's analyze typical problem from UVA: There is UVA 1181 \"Little Red Riding Hood\" maybe? I'm not sure.\n\nLet's look up memory: I recall UVA 1002 \"Little Red Riding Hood\"? Hmm.\n\nAnother known problem is \"UVA 1185 - Little Red Riding Hood\" might involve computing number of nodes visited until reaching target or repeating a node. Actually I think I've seen problem UVA 1185 \"Little Red Riding Hood\". The typical solution is to simulate and keep visited set; count steps until hitting target or loop; steps count includes start and target; if we loop, we output number of distinct nodes visited before loop? Wait the problem statement might say \"count number of distinct nodes visited before we stop or encounter a node that was visited before.\" But I'm not sure.\n\nLet's google memory: UVA 1185 \"Little Red Riding Hood\" maybe the same as UVA 1185 \"Little Red Riding Hood\"? I'm not sure. Let's recall known UVA problems: 1185 \"Little Red Riding Hood\" might be about computing nodes visited? I think I recall UVA 1185 - \"Little Red Riding Hood\" indeed about BFS? Not.\n\nBut I can search memory: I recall UVA 1185 \"Little Red Riding Hood\" uses Floyd's cycle detection? Actually there is UVA 11098 \"Little Red Riding Hood\" maybe about \"Little Red Riding Hood (LRH)\".\n\nWait: I think there is UVA 1185 \"Little Red Riding Hood\" which uses Floyd cycle detection to find number of nodes visited before hitting target or loop. The typical solution uses Floyd's cycle detection algorithm to find loop length? Hmm.\n\nLet's google in memory: UVA 1185 \"Little Red Riding Hood\" may be a UVA problem number 1185? Not sure.\n\nBut typical solution: we can just simulate and maintain visited set; complexity small. Many solutions use array visited of size N+1, mark visited. When we encounter visited node, break. Count visited nodes. Implementation: visited array bool[51]; count=0; cur=start; while true: if visited[cur] then break; visited[cur]=true; count++; if cur==target then break; cur=next(cur); That counts distinct nodes visited, not counting repeated node. Because we break before marking visited again. But they said \"terminates if it visits a previously visited node\" -> we would stop before visiting again. So we don't count repeated node. So algorithm above counts number of distinct nodes visited before encountering repeat (i.e., the number of unique nodes visited). That's likely the intended answer.\n\nThus for scenario start=1, target=2, a=0,b=0: visited 1, cur=1; visited[1]==false => visited[1]=true; count=1; cur==target? no; cur=next=1; loop again: visited[1]==true => break. Output count=1. So we output 1. That seems plausible.\n\nHence answer: number of distinct nodes visited until hitting target or encountering repeat; counting includes target node if visited before repetition; else stop at repeat before visiting it again.\n\nEdge: start==target. Then we visit start node; we check visited? false; mark visited; count=1; cur==target? yes, break; output 1. That is correct.\n\nOk.\n\nNow implement.\n\nConstraints small; use simulation.\n\nTime limit 1s, but trivial.\n\nC++ code: read N, start, target, a, b. Use vector<bool> visited(N+1,false). Use long long to compute next maybe; but all small.\n\nwhile(true):\n    if visited[cur] break\n    visited[cur]=true\n    count++\n    if cur==target: break\n    cur = ((a*cur + b)%N)+1\n\nReturn count.\n\nOk.\n\nNow produce final answer. Include explanation.\n\nEdge cases: ensure use long long for multiplication: a*cur may fit in 32-bit (a <=49, cur <=50, product <=2450). So int is fine.\n\nImplementation details: 1-indexed nodes.\n\nNow produce final message.**Solution Explanation**\n\nFor every computer we have\n\n* `N` – number of computers in the ring, numbered `1 … N`\n* `S` – start computer (the computer where the packet is first sent)\n* `T` – target computer (the computer that should receive the packet)\n* two integers `a , b`  \n  the packet is forwarded from computer `c` to\n\n```\nnext(c) = ((a · c + b) mod N) + 1            (1)\n```\n\nThe packet is transmitted until one of the following happens\n\n1. it reaches the target `T`\n2. it reaches a computer that it has already visited before\n\nThe problem asks for the number of **distinct** computers that are visited\nuntil the transmission stops.\n\n\n\n--------------------------------------------------------------------\n\n#### 1.  Observations\n\n* `N ≤ 50`, therefore a straightforward simulation is more than fast enough.\n* While forwarding the packet we only need to know whether a computer\n  has already been visited – a boolean array of size `N+1` is sufficient.\n* As soon as we would visit a computer that is already marked,\n  the process stops **before** that computer is counted again.\n  Hence we have to count a computer only once.\n\n\n\n--------------------------------------------------------------------\n\n#### 2.  Algorithm\n```\nread N, S, T, a, b\nvisited[1 … N] = false\ncount = 0\ncurrent = S\n\nwhile true\n        if visited[current]          // a computer that was seen before\n                break                // transmission stops\n        visited[current] = true\n        count += 1\n        if current == T              // target reached\n                break\n        current = ((a * current + b) % N) + 1   // (1)\n\noutput count\n```\n\n--------------------------------------------------------------------\n\n#### 3.  Correctness Proof  \n\nWe prove that the algorithm outputs the required number of distinct\ncomputers visited.\n\n---\n\n##### Lemma 1  \nDuring the execution of the `while` loop, `current` always holds the\ncomputer that the packet is currently at, and the set\n`{ c | visited[c] = true }` is exactly the set of distinct computers\nalready visited.\n\n**Proof.**\n\n*Initialization* – before the first iteration `current = S` and all\n`visited` values are `false`.  \nThus `current` is the computer where the packet starts, and the set of\nvisited computers is empty, which is correct.\n\n*Maintenance* – Assume the lemma holds at the start of an iteration.\nIf `visited[current]` is true, the packet would visit an already visited\ncomputer and the algorithm terminates – which is exactly the required\nbehaviour.  \nOtherwise we set `visited[current] = true` and increase `count`.  \nNow `current` is added to the visited set, so the invariant holds.\nIf `current == T`, the packet has reached the target and the loop\nterminates – also correct.  \nIf not, `current` is updated to `next(current)` according to formula\n(1).  This is exactly the computer the packet will move to next.  ∎\n\n\n\n##### Lemma 2  \nWhen the algorithm terminates, `count` equals the number of distinct\ncomputers visited during the packet transmission.\n\n**Proof.**\n\nBy Lemma&nbsp;1, in each iteration the packet visits a computer that\nhas not been visited before.  \nThe algorithm increments `count` once per such visit.  \nThe loop stops either when the packet would visit a previously visited\ncomputer (in which case that computer is not counted) or when the target\nis reached (the target computer has just been counted).  \nThus `count` is exactly the number of distinct computers that were\nvisited until the process stopped. ∎\n\n\n\n##### Theorem  \nThe algorithm outputs the correct answer for every test case.\n\n**Proof.**\n\nBy Lemma&nbsp;2, at termination `count` equals the number of distinct\ncomputers visited during the packet transmission, which is the requested\nquantity.  \nThe algorithm prints this value, hence it always outputs the correct\nanswer. ∎\n\n\n\n--------------------------------------------------------------------\n\n#### 4.  Complexity Analysis\n\n`N ≤ 50`, the packet visits at most `N` distinct computers before\nstopping.  \nEach iteration performs O(1) work.\n\n```\nTime   :  O(N)   (at most 50 operations)\nMemory :  O(N)   (boolean array of size N+1)\n```\n\nBoth are easily within the limits.\n\n\n\n--------------------------------------------------------------------\n\n#### 5.  Reference Implementation  (GNU‑C++17)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int N, S, T, a, b;\n    if (!(cin >> N >> S >> T >> a >> b)) return 0;\n    \n    vector<bool> visited(N + 1, false);\n    int count = 0;\n    int current = S;\n    \n    while (true) {\n        if (visited[current]) break;          // already visited – stop\n        visited[current] = true;\n        ++count;\n        if (current == T) break;              // target reached – stop\n        current = ((a * current + b) % N) + 1;\n    }\n    \n    cout << count << '\\n';\n    return 0;\n}\n```\n\nThe program follows exactly the algorithm proven correct above and\nconforms to the GNU++17 compiler standard."
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpeh78f_nb.py\", line 24, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcqfkrwpn.py\", line 24, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    matrix = [[-5]], k = 1\n    ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def kthSmallest(self, matrix, k):\n        n = len(matrix)\n        low, high = matrix[0][0], matrix[-1][-1]\n        while low < high:\n            mid = (low + high) // 2\n            count = 0\n            for row in matrix:\n                j = n - 1\n                while j >= 0 and row[j] > mid:\n                    j -= 1\n                count += j + 1\n            if count >= k:\n                high = mid\n            else:\n                low = mid + 1\n        return low\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    local_vars = {}\n    exec(data, {}, local_vars)\n    matrix = local_vars[\"matrix\"]\n    k = local_vars[\"k\"]\n    sol = Solution()\n    result = sol.kthSmallest(matrix, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: find k-th smallest in sorted matrix n x n, each row/column sorted ascending. Use memory complexity better than O(n^2). Standard solution: binary search on value range with count <= mid using row-wise binary search (or two-pointer). Complexity O(n log(max-min)). Memory O(1). Virtual code steps, each line with arrow and comment. Let's produce algorithm: Start, read matrix, k. Determine low = matrix[0][0], high = matrix[n-1][n-1]. While low < high: mid = (low+high)/2. Count elements <= mid by scanning each row using binary search or pointer. If count >= k, high=mid else low=mid+1. After loop, return low. Provide steps. Also we need to define functions like CountLessOrEqual. Provide pseudocode. Use virtual code.\n\nWe need to produce each line of pseudocode with explanation.\n\nLet's craft lines:\n\nStart // program start\n→ Input n, k, matrix // get matrix and k\n→ low ← matrix[0][0] // minimum element\n→ high ← matrix[n-1][n-1] // maximum element\n→ While low < high: // binary search loop\n    → mid ← (low + high) // 2 // middle value\n    → count ← 0 // counter for <= mid\n    → For i from 0 to n-1: // iterate rows\n        → j ← n-1 // start from last column\n        → While j >= 0 and matrix[i][j] > mid:\n            → j ← j - 1 // move left until value <= mid\n        → count ← count + (j + 1) // number of elements <= mid in this row\n    → Decision: If count ≥ k? // enough elements\n        Yes → high ← mid // search lower half\n        No  → low ← mid + 1 // search upper half\n→ End While // binary search finished\n→ Result ← low // k-th smallest\n→ Output Result // return\n\nNeed each line as \"虛擬碼步驟 // 解釋\". Use arrow for decisions. Also we need indentation for decision branches. Use Start, End etc. Provide lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n, k, matrix // 讀取矩陣大小、k 以及矩陣本身  \n→ low ← matrix[0][0] // 設定搜尋範圍下界為矩陣最小值  \n→ high ← matrix[n-1][n-1] // 設定搜尋範圍上界為矩陣最大值  \n→ While low < high: // 二分搜尋迴圈，直到範圍縮為單一值  \n → mid ← (low + high) // 2 // 計算中間值  \n → count ← 0 // 初始化小於等於 mid 的元素個數  \n → For i ← 0 to n-1: // 遍歷每一行  \n  → j ← n-1 // 從行尾開始搜尋  \n  → While j >= 0 and matrix[i][j] > mid: // 尋找第 i 行中小於等於 mid 的最右邊位置  \n    → j ← j - 1 // 向左移動  \n  → count ← count + (j + 1) // 加上此行中符合條件的元素數量  \n → Decision: 如果 count ≥ k? // 判斷目前範圍內是否已包含足夠多元素  \n  Yes → high ← mid // 若足夠，繼續搜尋較小的半區  \n  No  → low ← mid + 1 // 若不足，向較大的半區移動  \n→ End While // 二分搜尋結束，low == high 為第 k 小元素  \n→ Result ← low // 取得答案  \n→ Output Result // 將結果輸出  \nEnd // 程式結束執行"
    },
    {
      "title": "Maximum Gap",
      "source_file": "Leetcode/leetcode164.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [3,6,9,1]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      'inf'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      'inf'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maximumGap(self, nums):\n        n = len(nums)\n        if n < 2:\n            return 0\n\n        min_val = min(nums)\n        max_val = max(nums)\n\n        if min_val == max_val:\n            return 0\n\n        # bucket size at least 1\n        bucket_size = max(1, (max_val - min_val) // (n - 1))\n        bucket_count = (max_val - min_val) // bucket_size + 1\n\n        min_bucket = [float('inf')] * bucket_count\n        max_bucket = [float('-inf')] * bucket_count\n\n        for num in nums:\n            idx = (num - min_val) // bucket_size\n            min_bucket[idx] = min(min_bucket[idx], num)\n            max_bucket[idx] = max(max_bucket[idx], num)\n\n        prev_max = -float('inf')\n        max_gap = 0\n\n        for i in range(bucket_count):\n            if min_bucket[i] == float('inf'):  # empty bucket\n                continue\n            max_gap = max(max_gap, min_bucket[i] - prev_max)\n            prev_max = max_bucket[i]\n\n        return max_gap\n\nif __name__ == \"__main__\":\n    # Read entire input\n    data = sys.stdin.read().strip()\n\n    # Extract the list from the input\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1:\n        nums_str = data[start:end+1]\n        try:\n            nums = ast.literal_eval(nums_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    # Compute and output the result\n    solution = Solution()\n    result = solution.maximumGap(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm that finds maximum gap between sorted consecutive elements. We need linear time, linear space. Use bucket sort idea: compute min, max, bucket size etc. Use virtual code lines with arrows. Provide explanation. Each line: \"虛擬碼步驟 // 解釋\". We need Start, End, Decision etc.\n\nWe need to produce algorithm steps: Check length < 2, return 0. Find minVal, maxVal. If min==max, return 0. Compute bucketSize = max(1, (max-min)/(n-1)). bucketCount = (max-min)/bucketSize + 1. Initialize arrays minBucket and maxBucket with size bucketCount, set to Infinity/-Infinity. For each num: idx = (num - minVal)/bucketSize; update minBucket[idx], maxBucket[idx]. Then iterate buckets: keep prevMax, maxGap, for each bucket if minBucket[i]==Infinity continue; else gap = minBucket[i]-prevMax; update maxGap; prevMax = maxBucket[i]. End return maxGap.\n\nNow produce virtual code lines. Use arrows. Provide decision nodes. Use \"Start\", \"End\". Provide arrow indentations. Each line ends with \"// 解釋\". We must not output actual code. Just pseudo. Use \"Step\". Use \"Decision\". Use \"→\" arrow. Provide line numbers? Not necessary.\n\nWe must produce each line sequentially. Provide explanation after each line. Use \"Start // 程式開始執行\".\n\nWe'll produce steps like:\n\nStart // 程式開始執行\n→ Step 1: If length(nums) < 2: Return 0 // 少於兩個元素直接返回 0\n\nBut we can't have \"If\" inside Step? Could use Decision. Use Decision: if length <2? etc. Let's produce:\n\n→ Decision: 如果 nums 的長度 < 2? // 檢查是否少於兩個元素\n    Yes → Step 2: 回傳 0 // 少於兩個元素，最大差距為 0\n    No  → Step 3: 計算最小值 minVal 和最大值 maxVal // 確定數組範圍\n\nWe need to compute min, max: Step 3: minVal = min(nums), maxVal = max(nums). Explanation: 獲取最小最大值\n\nIf minVal == maxVal: return 0 (all elements equal). Use Decision. Then compute bucketSize, bucketCount. Step 4: bucketSize = max(1, floor((maxVal - minVal)/(n-1))) // 確保桶大小至少 1\nStep 5: bucketCount = floor((maxVal - minVal)/bucketSize) + 1 // 計算桶數\n\nInitialize arrays: Step 6: 初始化 minBucket[bucketCount] 為 +∞，maxBucket[bucketCount] 為 -∞ // 每個桶存放內部最小最大\n\nInsert numbers into buckets: Step 7: For each num in nums: idx = (num - minVal) / bucketSize // 將數字映射到桶\nStep 8: 更新 minBucket[idx] = min(minBucket[idx], num), maxBucket[idx] = max(maxBucket[idx], num) // 更新桶內最小最大\n\nCompute max gap: Step 9: prevMax = -∞，maxGap = 0 // 初始化\nStep 10: For i from 0 to bucketCount-1:\n   Decision: 如果 minBucket[i] 為 +∞? // 空桶跳過\n        Yes → continue // 跳過空桶\n        No  → Step 11: gap = minBucket[i] - prevMax // 計算當前桶最小與前一桶最大之差\n        Step 12: maxGap = max(maxGap, gap) // 更新最大差距\n        Step 13: prevMax = maxBucket[i] // 設為當前桶最大\n\nEnd // 程式執行結束\n→ Step 14: 回傳 maxGap // 返回最終計算的最大差距\n\nMake sure arrow indent. Use \"Yes →\" etc.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Decision: 如果 nums 的長度 < 2? // 檢查是否少於兩個元素\n    Yes → Step 2: 回傳 0 // 少於兩個元素，最大差距為 0\n    No  → Step 3: minVal = 最小值(nums), maxVal = 最大值(nums) // 取得數列的最小值與最大值\n→ Decision: 如果 minVal == maxVal? // 所有元素相同時差距為 0\n    Yes → Step 4: 回傳 0\n    No  → Step 5: bucketSize = max(1, floor((maxVal - minVal) / (n - 1))) // 計算桶大小，至少為 1\n    → Step 6: bucketCount = floor((maxVal - minVal) / bucketSize) + 1 // 依桶大小算出桶數\n    → Step 7: 初始化 minBucket[0..bucketCount-1] 為 +∞，maxBucket[0..bucketCount-1] 為 -∞ // 每個桶存放內部最小最大\n    → Step 8: 對 nums 中的每個 num:\n          → idx = floor((num - minVal) / bucketSize) // 取得對應桶索引\n          → minBucket[idx] = min(minBucket[idx], num) // 更新桶內最小值\n          → maxBucket[idx] = max(maxBucket[idx], num) // 更新桶內最大值\n    → Step 9: prevMax = -∞，maxGap = 0 // 初始化上一個桶的最大值與最大差距\n    → Step 10: 從 i = 0 到 bucketCount - 1:\n          → Decision: 如果 minBucket[i] 為 +∞? // 空桶\n              Yes → continue // 跳過空桶\n              No  → Step 11: gap = minBucket[i] - prevMax // 計算相鄰桶之間的差距\n              → Step 12: maxGap = max(maxGap, gap) // 更新最大差距\n              → Step 13: prevMax = maxBucket[i] // 更新上一桶最大值為當前桶最大\n    → Step 14: 回傳 maxGap // 返回最終計算的最大差距\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcos2av2h.py\", line 94, in <module>\n    main()\n  File \"/tmp/tmpcos2av2h.py\", line 73, in main\n    ops = ast.literal_eval(data[0].strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n                                                                                                                                                ^\nSyntaxError: unexpected character after line continuation character"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k):\n        \"\"\"初始化容量為 k 的循環雙端佇列\"\"\"\n        self.k = k\n        self.buf = [0] * k      # 固定長度的儲存陣列\n        self.head = 0           # 前指標（指向第一個有效元素）\n        self.count = 0          # 當前元素個數\n\n    def insertFront(self, value):\n        \"\"\"在前面插入元素，若佇列已滿則回傳 False\"\"\"\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value):\n        \"\"\"在後面插入元素，若佇列已滿則回傳 False\"\"\"\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self):\n        \"\"\"刪除前面元素，若佇列為空則回傳 False\"\"\"\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self):\n        \"\"\"刪除後面元素，若佇列為空則回傳 False\"\"\"\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self):\n        \"\"\"取得前面元素，若佇列為空則回傳 -1\"\"\"\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self):\n        \"\"\"取得後面元素，若佇列為空則回傳 -1\"\"\"\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self):\n        \"\"\"判斷佇列是否為空\"\"\"\n        return self.count == 0\n\n    def isFull(self):\n        \"\"\"判斷佇列是否已滿\"\"\"\n        return self.count == self.k\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 讀取操作與參數\n    ops = ast.literal_eval(data[0].strip())\n    params = ast.literal_eval(data[1].strip())\n\n    res = []\n    deque = None\n    for i, op in enumerate(ops):\n        if op == \"MyCircularDeque\":\n            # 建構子，參數是 [k]\n            deque = MyCircularDeque(params[i][0])\n            res.append(None)  # 代表 null\n        else:\n            # 其它方法不帶參數\n            if op in (\"insertFront\", \"insertLast\"):\n                val = params[i][0]\n                res.append(getattr(deque, op)(val))\n            else:\n                res.append(getattr(deque, op)())\n    # 輸出結果，使用 json.dumps 以符合 LeetCode 風格\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudocode steps line by line with explanations, no actual code. Use Start, End, Decision, arrows. Provide steps for implementing circular deque with size k. Provide operations. Let's design pseudocode: initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Also need internal state: array of size k, front, rear, count. Or use circular indexing. Provide pseudocode for each method. Should we break down each method into steps. For each step include explanation.\n\nWe need to output lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCircularDeque 類別 // 建立類別\n...\n\nWe need to include all methods. Use arrow to show each step inside methods. Let's produce pseudocode like:\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCircularDeque(int k) // 初始化容量\n    → Step 2: 建立 array size k // 存儲元素\n    → Step 3: 設定 front = 0, rear = 0, count = 0 // 初始化指標\n→ Step 4: 定義 insertFront(value) // 前插入\n    → Decision: 如果 isFull()? // 判斷是否已滿\n        Yes → Step 5: return false // 無法插入\n        No  → Step 6: front = (front - 1 + k) mod k // 往前移動指標\n            → Step 7: array[front] = value // 放入值\n            → Step 8: count++ // 更新計數\n            → Step 9: return true // 成功\n... and similarly for other methods.\n\nNeed to ensure each line includes code text and explanation. Use \"Step\" maybe. Use arrow \"→\". For decision use \"Decision:\" with Yes/No.\n\nLet's produce about maybe 40-50 lines.\n\nLet's write in Traditional Chinese. Use Chinese for explanation. Also code part maybe like pseudo-code in English? It's okay, as long as we include explanation. Let's produce.\n\nWe also need to indicate class definition. Use \"Class MyCircularDeque\". Use \"Function\" etc. Let's produce.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Class MyCircularDeque // 定義循環雙端佇列類別  \n\n→ Step 2: Function MyCircularDeque(int k) // 建構子：傳入最大容量  \n    → Step 3: Set this.capacity = k // 儲存容量  \n    → Step 4: Create array items[capacity] // 佔用固定長度陣列  \n    → Step 5: Set this.front = 0 // 前指標初始化  \n    → Step 6: Set this.rear = 0 // 後指標初始化  \n    → Step 7: Set this.size = 0 // 當前元素數量  \n\n→ Step 8: Function insertFront(int value) // 從前面插入元素  \n    → Decision: If isFull()？ // 判斷佇列是否已滿  \n        Yes → Step 9: Return false // 插入失敗  \n        No  → Step 10: front = (front - 1 + capacity) % capacity // 往前移動指標  \n            → Step 11: items[front] = value // 放入新值  \n            → Step 12: size++ // 计数加一  \n            → Step 13: Return true // 成功  \n\n→ Step 14: Function insertLast(int value) // 從後面插入元素  \n    → Decision: If isFull()？  \n        Yes → Step 15: Return false // 插入失敗  \n        No  → Step 16: items[rear] = value // 放入新值  \n            → Step 17: rear = (rear + 1) % capacity // 往後移動指標  \n            → Step 18: size++ // 计数加一  \n            → Step 19: Return true // 成功  \n\n→ Step 20: Function deleteFront() // 刪除前面元素  \n    → Decision: If isEmpty()？ // 判斷佇列是否為空  \n        Yes → Step 21: Return false // 刪除失敗  \n        No  → Step 22: front = (front + 1) % capacity // 往後移動前指標  \n            → Step 23: size-- // 计数減一  \n            → Step 24: Return true // 成功  \n\n→ Step 25: Function deleteLast() // 刪除後面元素  \n    → Decision: If isEmpty()？  \n        Yes → Step 26: Return false // 刪除失敗  \n        No  → Step 27: rear = (rear - 1 + capacity) % capacity // 往前移動後指標  \n            → Step 28: size-- // 计数減一  \n            → Step 29: Return true // 成功  \n\n→ Step 30: Function getFront() // 取得前面元素  \n    → Decision: If isEmpty()？  \n        Yes → Step 31: Return -1 // 佇列為空  \n        No  → Step 32: Return items[front] // 回傳前指標元素  \n\n→ Step 33: Function getRear() // 取得後面元素  \n    → Decision: If isEmpty()？  \n        Yes → Step 34: Return -1 // 佇列為空  \n        No  → Step 35: Index = (rear - 1 + capacity) % capacity // 找到最後一個元素索引  \n            → Step 36: Return items[Index] // 回傳後指標元素  \n\n→ Step 37: Function isEmpty() // 判斷是否為空  \n    → Step 38: Return size == 0 // 若大小為 0 則為空  \n\n→ Step 39: Function isFull() // 判斷是否已滿  \n    → Step 40: Return size == capacity // 若大小等於容量則已滿  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe7euksil.py\", line 78, in <module>\n    main()\n  File \"/tmp/tmpe7euksil.py\", line 55, in main\n    args = ast.literal_eval(args_line)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, idx: int) -> bool:\n            if idx == len(word):\n                return node.is_end\n            ch = word[idx]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, idx + 1):\n                        return True\n                return False\n            else:\n                if ch not in node.children:\n                    return False\n                return dfs(node.children[ch], idx + 1)\n        return dfs(self.root, 0)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，支持兩行或一行的格式\n    if '\\n' in data:\n        ops_line, args_line = data.splitlines()[:2]\n    else:\n        # 一行時用分隔符分割\n        parts = data.split('],[')\n        ops_line = parts[0] + ']'\n        args_line = '[' + parts[1]\n        if not args_line.endswith(']'):\n            args_line += ']'\n\n    ops = ast.literal_eval(ops_line)\n    args = ast.literal_eval(args_line)\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"WordDictionary\":\n            obj = WordDictionary()\n            results.append(None)\n        elif op == \"addWord\":\n            obj.addWord(arg[0])\n            results.append(None)\n        elif op == \"search\":\n            res = obj.search(arg[0])\n            results.append(res)\n        else:\n            # 不支援的操作，直接忽略或拋出錯誤\n            results.append(None)\n\n    # 使用 json.dumps 以符合 LeetCode 的輸出格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. We must not output actual code. The logic: implement WordDictionary with a Trie. Provide addWord and search, with search supporting '.' wildcard. So we produce pseudocode steps for initialization, adding, searching. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and decisions. So we produce steps:\n\nStart\n→ Step 1: Initialize root node // root of trie\n→ End\n\nThen for addWord:\n→ Step 2: For each character c in word\n    → Decision: Node has child c? \n        Yes → Move to child\n        No → Create new node for c, add as child, move to it\n→ Step 3: Mark current node as end_of_word\n\nSearch:\n→ Step 4: Define recursive function dfs(node, index)\n    → Decision: index == len(word)?\n        Yes → Return node.is_end\n        No → char = word[index]\n            Decision: char == '.'?\n                Yes → For each child in node.children:\n                        If dfs(child, index+1) true → return true\n                    return false\n                No → Decision: node has child char?\n                    Yes → return dfs(node.children[char], index+1)\n                    No → return false\n\n→ Step 5: Return dfs(root, 0)\n\nNeed to output in the required format: each line with arrow and explanation. Use Start, End. We can structure with nested decisions using indentation.\n\nWe must not output code. Just pseudocode lines. Each line must be single line? The example shows nested decisions with indentation. We can mimic that.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 Trie 根節點 root，並將 root.is_end 設為 False // 初始化字典資料結構  \n→ End // 初始化完成  \n\n--- addWord(word) ---  \nStart // addWord 方法開始  \n→ Step 2: 以 currentNode 指向 root，依序遍歷 word 中每個字元 c  \n    → Decision: currentNode 是否已有子節點 c？  \n        Yes → currentNode ← currentNode.children[c] // 移到已存在的子節點  \n        No  → Step 3: 建立新節點 node，並加入 currentNode.children[c] = node  \n              currentNode ← node // 移到新建立的子節點  \n→ Step 4: 設定 currentNode.is_end = True // 標記單字結束位置  \n→ End // addWord 方法結束  \n\n--- search(word) ---  \nStart // search 方法開始  \n→ Step 5: 定義遞迴函式 dfs(node, idx)  \n    → Decision: idx 是否等於 word 長度？  \n        Yes → Return node.is_end // 若到達字串末端，檢查是否為完整單字  \n        No  → char ← word[idx]  \n            Decision: char 是否為 '.'？  \n                Yes → Step 6: 對 node 所有子節點 child 逐一遞迴  \n                        → If dfs(child, idx+1) 為 True，立即回傳 True  \n                      Return False // 所有子節點均不匹配  \n                No  → Decision: node.children 是否含 char？  \n                    Yes → Return dfs(node.children[char], idx+1) // 直接遞迴到對應子節點  \n                    No  → Return False // 字元不匹配且無子節點  \n→ Step 7: Return dfs(root, 0) // 從根節點開始搜尋  \n→ End // search 方法結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef find_duplicate(paths):\n    \"\"\"\n    找出重複檔案的完整路徑。\n    :param paths: list[str]，每個字串包含目錄路徑與檔案資訊\n    :return: list[list[str]]，每個子 list 為相同內容的檔案完整路徑\n    \"\"\"\n    content_map = defaultdict(list)\n\n    for entry in paths:\n        parts = entry.split()\n        if not parts:\n            continue\n        dir_path = parts[0]\n        for file_info in parts[1:]:\n            # file_info 格式為 \"filename(content)\"\n            name, content = file_info.split('(')\n            content = content[:-1]  # 去除尾端的 ')'\n            full_path = f\"{dir_path}/{name}\"\n            content_map[content].append(full_path)\n\n    # 只保留重複的組別\n    return [paths for paths in content_map.values() if len(paths) > 1]\n\ndef read_input():\n    \"\"\"\n    從標準輸入讀取資料，並解析成 list[str]。\n    支援兩種常見格式：\n      1. 以 \"paths = [...]\" 形式給出整個 list\n      2. 每行一個路徑字串\n    \"\"\"\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return []\n\n    # 若以 \"paths =\" 開頭，去除前綴\n    if raw.startswith('paths'):\n        equal_pos = raw.find('=')\n        if equal_pos != -1:\n            raw = raw[equal_pos + 1:].strip()\n\n    try:\n        # 安全地解析 python literal\n        parsed = ast.literal_eval(raw)\n        if isinstance(parsed, list):\n            return [str(item) for item in parsed]\n    except Exception:\n        pass\n\n    # 若解析失敗，視為每行一個項目\n    return [line.strip() for line in raw.splitlines() if line.strip()]\n\nif __name__ == \"__main__\":\n    paths = read_input()\n    duplicates = find_duplicate(paths)\n    print(duplicates)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanation after //.\n\nWe need to think about algorithm: parse input list of strings, each contains dir path and files with contents. For each file, build full path and content. Use map content->list of paths. After processing all, filter map for lists size>=2 and output as list of lists.\n\nWe will produce virtual code using Start, Decision, etc.\n\nLet's design steps:\n\nStart\n→ Step 1: Initialize empty map ContentMap // map from string content to list of file paths\n→ Step 2: For each dirInfo in paths // iterate over input list\n    → Step 2a: Split dirInfo by space // separate directory path and file info\n    → Step 2b: dirPath = first part // directory path string\n    → Step 2c: fileInfos = remaining parts // each file with content\n    → Step 2d: For each fileInfo in fileInfos // process each file\n        → Step 2d1: Extract fileName and fileContent from fileInfo // parse using '(' and ')'\n        → Step 2d2: fullPath = dirPath + \"/\" + fileName // construct full file path\n        → Step 2d3: If fileContent not in ContentMap // check map\n            Yes → Step 2d3a: Create new list with fullPath // initialize\n            No  → Step 2d3b: Append fullPath to existing list // add to list\n→ Step 3: Initialize result list // list of groups\n→ Step 4: For each entry in ContentMap // iterate over map\n    → Step 4a: If list size >= 2 // duplicate\n        Yes → Step 4a1: Add list to result // collect group\n        No  → Step 4a2: Skip // ignore unique\n→ End // finished, result ready\n\nWe need to show output? Not actual code, just virtual steps. Use decision arrows.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 ContentMap // 用來將內容對應到所有相同內容的檔案路徑  \n→ Step 2: 對於每一個 directoryInfo 於 paths 中  \n  → Decision: 是否已遍歷完所有 directoryInfo? // 檢查是否還有未處理的資料  \n   Yes → End // 全部處理完畢  \n   No → Step 2a: 將 directoryInfo 用空格拆分為 parts // 取得路徑與檔案資訊  \n    → Step 2b: dirPath = parts[0] // 獲取目錄路徑  \n    → Step 2c: fileInfos = parts[1…] // 取得所有檔案描述字串  \n    → Step 2d: 對於每一個 fileInfo 於 fileInfos 中  \n      → Decision: 是否已處理完所有 fileInfo?  \n       Yes → Back to Step 2a // 回到下一個 directoryInfo  \n       No → Step 2d1: 解析 fileInfo 以取得檔名與內容 // 以 '(' 和 ')' 分隔  \n        → Step 2d2: fileName = 前半部去除 '(' 之前的字串  \n        → Step 2d3: fileContent = 內容位於 '(' 與 ')' 之間  \n        → Step 2d4: fullPath = dirPath + \"/\" + fileName // 組成完整路徑  \n        → Decision: ContentMap 是否已有 fileContent?  \n         Yes → Step 2d5: 把 fullPath 加入 ContentMap[fileContent] // 附加路徑  \n         No → Step 2d6: ContentMap[fileContent] = [fullPath] // 建立新列表"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[10]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[10]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[1,3]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[1, 3]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[6,4,4]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[6, 4, 4]'"
        }
      ],
      "generated_code": "import random\nimport sys\nimport re\n\n# 生成 1~7 的均勻隨機數\ndef rand7() -> int:\n    return random.randint(1, 7)\n\n# 生成 1~10 的均勻隨機數\ndef rand10() -> int:\n    while True:\n        # 兩次 rand7 組合得到 1~49 的等概率數\n        num = (rand7() - 1) * 7 + rand7()\n        if num <= 40:  # 1~40 可直接映射\n            return 1 + (num - 1) % 10\n\ndef main() -> None:\n    # 從 stdin 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 從輸入中提取數字 n\n    match = re.search(r'n\\s*=\\s*(\\d+)', data)\n    if not match:\n        print(\"[]\")\n        return\n    n = int(match.group(1))\n    # 生成 n 個 rand10 結果\n    results = [rand10() for _ in range(n)]\n    # 輸出為 Python 列表格式\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating rand10 using rand7. Classic method: use two rand7 calls to generate 49 outcomes; use rejection sampling for 40 or 10 leftover etc. For 1-10. Standard: generate 1-49 via (rand7-1)*7 + rand7. If <= 40, return ((value-1) mod 10)+1. If > 40, repeat.\n\nThus produce steps: Start, Step1: repeat loop, Step2: r1=rand7, Step3: r2=rand7, Step4: combined= (r1-1)*7 + r2, Step5: Decision: if combined <= 40? Yes -> compute result; No -> repeat. Step6: Return result.\n\nAlso we may show rejection for 41-49. Explanation.\n\nWe should output line by line: \"Start // 程式開始執行\", \"→ Step 1: 進入重複循環直到成功 // 以保證最終返回合法數字\", etc.\n\nNeed to include \"Decision:\" lines with Yes → and No →.\n\nAlso \"End // 程式執行結束\".\n\nMake sure to follow format: \"虛擬碼步驟 // 解釋\". Use Chinese.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 循環直到生成合法值 // 使用重複采樣以保證均勻分佈\n\nLine 3: →     Step 2: r1 ← rand7() // 第一次調用隨機 API 生成 1~7\n\nLine 4: →     Step 3: r2 ← rand7() // 第二次調用隨機 API 生成 1~7\n\nLine 5: →     Step 4: val ← (r1-1)*7 + r2 // 組合兩個結果得到 1~49 的等概率數\n\nLine 6: →     Decision: val ≤ 40? // 判斷是否在可直接映射的範圍內\n\nLine 7: →         Yes → Step 5: result ← ((val-1) mod 10) + 1 // 將 1~40 映射到 1~10\n\nLine 8: →         No  → Step 6: 轉回 Step 1 // 超出 40 時重試，消除偏差\n\nLine 9: → Step 7: 返回 result // 產生最終的隨機數\n\nLine 10: End // 程式執行結束\n\nBut need to ensure we maintain hierarchical indent. Use \"→\" and indent with spaces.\n\nOk. Ensure each line has // comment after. Provide Chinese explanation.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 進入重複循環直到成功 // 使用重複采樣以保證最終返回合法且均勻分佈的數字  \n → Step 2: r1 ← rand7() // 第一次調用 rand7() 產生 1~7  \n → Step 3: r2 ← rand7() // 第二次調用 rand7() 產生 1~7  \n → Step 4: val ← (r1-1)*7 + r2 // 組合兩個結果得到 1~49 的等概率數  \n → Decision: val ≤ 40? // 判斷是否落在可直接映射的範圍內  \n  Yes → Step 5: result ← ((val-1) mod 10) + 1 // 將 1~40 映射到 1~10，得到均勻分佈的 rand10()  \n  No  → Step 6: 轉回 Step 1 // 超出 40 時重試，消除偏差  \n→ Step 7: 返回 result // 輸出最終的隨機數 1~10  \nEnd // 程式執行結束"
    },
    {
      "title": "Reverse Integer",
      "source_file": "Leetcode/leetcode7.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reverse(self, x: int) -> int:\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        result = 0\n        while x != 0:\n            pop = x % 10\n            x //= 10\n            if result > INT_MAX // 10 or (result == INT_MAX // 10 and pop > 7):\n                return 0\n            if result < INT_MIN // 10 or (result == INT_MIN // 10 and pop < -8):\n                return 0\n            result = result * 10 + pop\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if match:\n        x = int(match.group())\n        sol = Solution()\n        print(sol.reverse(x))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, step by step, with explanation. It's essentially LeetCode Reverse Integer problem. We must avoid using 64-bit integers. So we need to use 32-bit operations. Approach: handle sign, then reverse digits using modulo and division, check overflow before appending each digit: if result > (INT_MAX - digit)/10 then overflow. In 32-bit, INT_MAX = 2^31 -1 = 2147483647, INT_MIN = -2^31 = -2147483648. For negative numbers, we can take abs or use negative logic. But easiest: use positive reverse and apply sign later; but abs may overflow for INT_MIN because abs(INT_MIN) can't be represented. So we need to handle negative case by using negative arithmetic: while x != 0: pop = x % 10 (but in C++ modulo negative results negative? In C, remainder sign follows dividend; but in many languages, we need to adjust. But we can just use pop = x % 10, and x = x / 10; with integer division rounding toward zero. That works for negative. Then we need to reverse: result = result*10 + pop; but need to check overflow: before multiplication, check if result > INT_MAX/10 or (result == INT_MAX/10 and pop > 7) for positive; for negative: result < INT_MIN/10 or (result == INT_MIN/10 and pop < -8). Because when result negative, multiply by 10 will still be negative; but using same logic as LeetCode: before result = result*10 + pop; check if result > INT_MAX/10 or (result == INT_MAX/10 and pop > 7) OR result < INT_MIN/10 or (result == INT_MIN/10 and pop < -8) => overflow => return 0. Since we don't use 64-bit, result stays within 32-bit. We must avoid using 64-bit intermediate. Use 32-bit ints.\n\nThus virtual steps:\n\nStart\n→ Step 1: 初始化 result = 0 // 用於累積反轉後的數值\n→ Decision: 如果 x 為 0? // 檢查輸入是否為 0\n    Yes → Step 2: 返回 0 // 直接返回\n    No  → Loop: while x ≠ 0 // 逐位取出 x 的最後一位\n        → Step 3: pop = x % 10 // 取得 x 的最後一位\n        → Step 4: x = x / 10 // 移除最後一位\n        → Decision: 檢查是否會溢出? // 在進一步累積前檢查 overflow\n            Yes → Step 5: 返回 0 // overflow, 立即返回\n            No  → Step 6: result = result * 10 + pop // 累積結果\n        End Loop\n→ Step 7: 返回 result // 反轉完成\n\nBut we need explicit overflow check: So in Step 3 we need to compute conditions.\n\nBetter: Provide sub-steps: \n\nStep 4: Check overflow: If result > INT_MAX/10 OR (result == INT_MAX/10 AND pop > 7) OR result < INT_MIN/10 OR (result == INT_MIN/10 AND pop < -8) Then overflow.\n\nThus we need to implement that check as separate step.\n\nAlso we must note: we cannot use 64-bit. All operations remain 32-bit.\n\nLet's produce each line with explanation. Use \"Start\", \"End\". Use \"Decision:\" for branching. For loops we can show \"While x ≠ 0:\" etc.\n\nWe can use arrow notation: \"→\" indicates next step, indent for nested.\n\nWe need to include the decision with Yes →, No →.\n\nWe must avoid actual code but produce virtual steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 用於儲存反轉後的整數\n→ Decision: x = 0? // 檢查輸入是否為 0\n    Yes → Step 2: return 0 // 如果為 0，直接回傳 0\n    No  → Step 3: While x ≠ 0 // 只要 x 還有位數就持續執行\n        → Step 4: pop ← x % 10 // 取得 x 的最後一位\n        → Step 5: x ← x / 10 // 去掉最後一位\n        → Decision: Overflow? // 檢查將 pop 加入 result 會不會超出 32 位範圍\n            Yes → Step 6: return 0 // 發生溢出，立即回傳 0\n            No  → Step 7: result ← result * 10 + pop // 正常累積\n        End While\n→ Step 8: return result // 迴圈結束後回傳反轉結果\nEnd // 程式結束\n\nBut we need to be more explicit in overflow check: The condition: if result > INT_MAX/10 or (result == INT_MAX/10 and pop > 7) or result < INT_MIN/10 or (result == INT_MIN/10 and pop < -8) then overflow.\n\nSo we need to detail that in the Decision step.\n\nThus Step 7: Check: if result > INT_MAX/10 OR (result == INT_MAX/10 AND pop > 7) OR result < INT_MIN/10 OR (result == INT_MIN/10 AND pop < -8)\n\nWe can embed that in Decision: Overflow? So we can write: Decision: (result > INT_MAX/10 OR (result == INT_MAX/10 AND pop > 7) OR result < INT_MIN/10 OR (result == INT_MIN/10 AND pop < -8))?\n\nLet's include that as part of Decision.\n\nAlso need to mention INT_MAX and INT_MIN values as constants.\n\nWe also need to ensure we didn't use 64-bit ints. All operations are 32-bit. The multiplication result*10 is 32-bit; check overflow before performing multiplication.\n\nLet's produce final virtual code lines with detailed explanation.\n\nAlso include \"Start\" and \"End\" markers.\n\nAlso use indentation for nested decisions. Use \"→\" for steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← 0 // 用於儲存反轉後的整數  \n→ Decision: x = 0? // 檢查輸入是否為 0  \n Yes → Step 2: return 0 // 直接回傳 0  \n No  → Step 3: While x ≠ 0 // 只要 x 還有位數就持續執行  \n  → Step 4: pop ← x % 10 // 取得 x 的最後一位  \n  → Step 5: x ← x / 10 // 去掉最後一位  \n  → Decision: 是否會溢出? // 檢查將 pop 加入 result 後是否超出 32‑bit 範圍  \n   Yes → Step 6: return 0 // 發生溢出，立即回傳 0  \n   No  → Step 7: result ← result * 10 + pop // 正常累積  \n  End While  \n→ Step 8: return result // 迴圈結束後回傳反轉結果  \nEnd // 程式執行結束  \n\n// 其中「是否會溢出」的判斷條件為  \n// (result > INT_MAX/10) OR  \n// (result == INT_MAX/10 AND pop > 7) OR  \n// (result < INT_MIN/10) OR  \n// (result == INT_MIN/10 AND pop < -8)   // INT_MAX = 2147483647, INT_MIN = -2147483648"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n        dists.sort()\n        return (\n            dists[0] > 0\n            and dists[0] == dists[1] == dists[2] == dists[3]\n            and dists[4] == dists[5]\n            and dists[4] == 2 * dists[0]\n        )\n\ndef parse_points(data: str):\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) != 8:\n        raise ValueError(\"Invalid input: expected 8 integers.\")\n    return [\n        [nums[0], nums[1]],\n        [nums[2], nums[3]],\n        [nums[4], nums[5]],\n        [nums[6], nums[7]],\n    ]\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    try:\n        p1, p2, p3, p4 = parse_points(raw_input)\n    except Exception:\n        print(\"false\")\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.validSquare(p1, p2, p3, p4)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps. We need to compute distances between all pairs of points, sort them, then check first 4 equal (sides) and last 2 equal (diagonals) and diagonals > side. Also ensure no zero length. Steps: Input points, compute all pairwise distances, sort, check side>0, side equal, diag equal, diag>side. So produce virtual code. Use arrows. Let's produce step by step. We'll include decision nodes.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input 4 points p1, p2, p3, p4 // 取得四個座標  \n→ Compute all 6 pairwise squared distances d1..d6 // 用平方距離避免平方根  \n    d1 ← SquaredDistance(p1, p2) // 兩點距離平方  \n    d2 ← SquaredDistance(p1, p3)  \n    d3 ← SquaredDistance(p1, p4)  \n    d4 ← SquaredDistance(p2, p3)  \n    d5 ← SquaredDistance(p2, p4)  \n    d6 ← SquaredDistance(p3, p4)  \n→ Store distances in list D = [d1, d2, d3, d4, d5, d6] // 集合所有距離  \n→ Sort D ascending // 由小到大排列  \n→ Decision: Check first 4 distances are equal and greater than 0? // 四條邊相等且正長  \n    Yes → Decision: Check last 2 distances are equal? // 兩條對角線相等  \n        Yes → Decision: Check last 2 > first 4? // 對角線長度大於邊長  \n            Yes → Step 1: Return true // 符合正方形條件  \n            No  → Step 2: Return false // 對角線不長於邊  \n        No  → Step 3: Return false // 對角線長度不相等  \n    No  → Step 4: Return false // 邊長不相等或零  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_f1o27vy.py\", line 49, in <module>\n    price, special, needs = parse_input(input_text)\n                            ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_f1o27vy.py\", line 43, in parse_input\n    special = ast.literal_eval(special_match.group(1))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[3,0,5]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpico0ybkz.py\", line 49, in <module>\n    price, special, needs = parse_input(input_text)\n                            ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpico0ybkz.py\", line 43, in parse_input\n    special = ast.literal_eval(special_match.group(1))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,4]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # price without any special offer\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            # try every special offer\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef parse_input(text):\n    \"\"\"\n    Parse a line like:\n    price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\n    \"\"\"\n    price_match = re.search(r'price\\s*=\\s*(\\[[^\\]]*\\])', text)\n    special_match = re.search(r'special\\s*=\\s*(\\[[^\\]]*\\])', text)\n    needs_match = re.search(r'needs\\s*=\\s*(\\[[^\\]]*\\])', text)\n\n    if not (price_match and special_match and needs_match):\n        raise ValueError(\"Input format is incorrect\")\n\n    price = ast.literal_eval(price_match.group(1))\n    special = ast.literal_eval(special_match.group(1))\n    needs = ast.literal_eval(needs_match.group(1))\n    return price, special, needs\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read()\n    price, special, needs = parse_input(input_text)\n    result = Solution().shoppingOffers(price, special, needs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step by step with explanation lines. The problem is the classic Leetcode \"638. Shopping Offers\". We need minimal price for required needs given special offers, unlimited use, cannot exceed needs. The standard solution is DFS with memoization, exploring offers usage. So we produce virtual code: Start, Step 1: Define DFS function. Step 2: Check memo. Step 3: Compute normal price sum. Step 4: Iterate offers. Step 5: For each offer, check if can apply. Step 6: Compute new needs, call DFS recursively. Step 7: Keep minimal price. Step 8: Store memo. Step 9: Return min price. End. Also main function calls DFS with needs.\n\nNeed to include virtual code arrows and decision blocks.\n\nMake sure each line has \"虛擬碼步驟\" followed by comment.\n\nLet's construct lines:\n\nStart // 程式開始執行\n→ Step 1: 定義 DFS(需求) // 進行深度優先搜索以計算最小價格\n→ Decision: 是否已在 memo 中? // 檢查是否已計算過該需求\n    Yes → Return memo[需求] // 若已計算則直接回傳\n    No  → \n        → Step 2: 計算不使用任何特價的總價 // 僅按單價購買全部需求\n        → Step 3: 初始化 min_price 為上述總價 // 預設最小價格為不使用優惠\n        → Step 4: 遍歷每個特價 offer // 為每個特價嘗試使用\n            → Decision: offer 是否可用於當前需求? // 確保不買多於需求\n                Yes → \n                    → Step 5: 計算新的需求 after 用此 offer 一次 // 減去 offer 含量\n                    → Step 6: min_price = min(min_price, offer 價格 + DFS(新的需求)) // 以遞歸方式更新最小價格\n                No  →  // 此 offer 無法使用，跳過\n        → Step 7: memo[需求] = min_price // 將結果緩存\n        → Step 8: Return min_price // 回傳計算出的最小價格\nEnd // 程式結束\n\nWe need to include arrows \"→\" before each step. For decision branches, indent or use sub-indentation with \"Yes →\" and \"No →\".\n\nAlso ensure each line after arrow and step has comment.\n\nLet's format exactly: Each line with \"虛擬碼步驟\" replaced by the step itself. So first line \"Start\". Next line \"→ Step 1: ...\". Good.\n\nWe need to ensure no actual code. So just pseudo.\n\nWe need to output step lines. Provide the pseudo-code as per requirement.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義 DFS(需求) // 進行深度優先搜索以計算最小價格\n→ Decision: 是否已在 memo 中? // 檢查是否已計算過該需求\n    Yes → Return memo[需求] // 若已計算則直接回傳\n    No  → \n        → Step 2: 計算不使用任何特價的總價 // 僅按單價購買全部需求\n        → Step 3: 初始化 min_price 為上述總價 // 預設最小價格為不使用優惠\n        → Step 4: 遍歷每個特價 offer // 為每個特價嘗試使用\n            → Decision: offer 是否可用於當前需求? // 確保不買多於需求\n                Yes → \n                    → Step 5: 計算新的需求 after 用此 offer 一次 // 減去 offer 含量\n                    → Step 6: min_price = min(min_price, offer 價格 + DFS(新的需求)) // 以遞歸方式更新最小價格\n                No  → // 此 offer 無法使用，跳過\n        → Step 7: memo[需求] = min_price // 將結果緩存\n        → Step 8: Return min_price // 回傳計算出的最小價格\nEnd // 程式結束\n```"
    },
    {
      "title": "Rotate Function",
      "source_file": "Leetcode/leetcode396.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '26'\nGot (Norm):      '34'\n--- (Raw) ---\nRaw Expected: '26'\nRaw Got:      '34'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef maxRotateFunction(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    total = sum(nums)\n    # initial rotation function F(0)\n    F = sum(i * num for i, num in enumerate(nums))\n    max_val = F\n    # iterate over rotations 1 .. n-1\n    for i in range(1, n):\n        # update F(i) from F(i-1)\n        F = F + total - n * nums[i - 1]\n        if F > max_val:\n            max_val = F\n    return max_val\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit()\n\n    # extract list part from input, e.g. \"nums = [4,3,2,6]\" or \"[4,3,2,6]\"\n    start = input_data.find('[')\n    end = input_data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        nums = []\n    else:\n        list_str = input_data[start:end + 1]\n        try:\n            nums = ast.literal_eval(list_str)\n            if not isinstance(nums, list):\n                nums = []\n        except Exception:\n            nums = []\n\n    result = maxRotateFunction(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. This is the classic Leetcode 1487 Max Rotation Function. We need to produce steps: compute sum of nums, compute initial rotation function value F(0). Then iterate i from 1 to n-1 compute F(i) = F(i-1) + sum - n*nums[i-1] (or F(i) = F(i-1) + sum - n*nums[i-1] ). Keep max. Then output max.\n\nNeed to produce step-by-step with Start, Decision, End etc. The format: \"虛擬碼步驟 // 解釋\". So each line is a step. Use arrow →.\n\nWe need to use decision nodes for loops etc.\n\nLet's produce:\n\nStart\n→ Step 1: 計算陣列長度 n // 取得陣列長度\n→ Step 2: 計算 total = sum(nums) // 所有元素總和\n→ Step 3: 計算 current = 0 // 初始化 F(0)\n    → Loop over idx from 0 to n-1\n        → current = current + idx * nums[idx] // 逐項累加 F(0)\n→ Step 4: 設 maxVal = current // 初始最大值\n→ Step 5: 循環 i from 1 to n-1\n    → Decision: i <= n-1? // 是否還有旋轉\n        Yes →\n            → current = current + total - n * nums[i-1] // 公式更新 F(i)\n            → Decision: current > maxVal? // 檢查是否更新最大值\n                Yes → maxVal = current // 更新最大值\n                No  → (保持 maxVal)\n        No →\n→ End // 回傳 maxVal\n\nBut the output format requires each line as \"虛擬碼步驟 // 解釋\". So we need to list each step line. Indentation and arrows for decisions. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 計算陣列長度 n = length(nums) // 取得陣列長度\n→ Step 2: 計算 total = sum(nums) // 所有元素總和\n→ Step 3: 計算 current = 0 // 初始化 F(0) 值\n    → Loop idx from 0 to n-1\n        → current = current + idx * nums[idx] // 逐項累加計算 F(0)\n→ Step 4: 設 maxVal = current // 初始最大值\n→ Step 5: 循環 i 從 1 到 n-1\n    → Decision: i <= n-1? // 是否仍有旋轉\n        Yes →\n            → current = current + total - n * nums[i-1] // 使用公式更新 F(i)\n            → Decision: current > maxVal? // 判斷是否更新最大值\n                Yes → maxVal = current // 更新最大值\n                No  → (不變) // 保持原值\n        No →\n→ End // 回傳 maxVal\n\nWe need to ensure each line is a separate line. The \"Loop\" and \"Decision\" lines might be nested. Provide each line as separate.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算陣列長度 n = length(nums) // 取得陣列長度  \n→ Step 2: 計算 total = sum(nums) // 所有元素總和  \n→ Step 3: 計算 current = 0 // 初始化 F(0) 值  \n    → Loop idx from 0 to n-1 // 逐項處理每個索引  \n        → current = current + idx * nums[idx] // 逐項累加計算 F(0)  \n→ Step 4: 設 maxVal = current // 初始最大值  \n→ Step 5: 循環 i 從 1 到 n-1 // 處理剩餘旋轉  \n    → Decision: i <= n-1? // 是否仍有旋轉  \n        Yes →  \n            → current = current + total - n * nums[i-1] // 使用公式更新 F(i)  \n            → Decision: current > maxVal? // 判斷是否更新最大值  \n                Yes → maxVal = current // 更新最大值  \n                No  → (保持原值) // 無需更新  \n        No →  \n→ End // 回傳 maxVal"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy3m17vk3.py\", line 43, in <module>\n    parsed = json.loads(data_json)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 12 (char 11)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpy3m17vk3.py\", line 46, in <module>\n    parsed = eval(data)\n             ^^^^^^^^^^\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n              ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmm82j9_c.py\", line 43, in <module>\n    parsed = json.loads(data_json)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 12 (char 11)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpmm82j9_c.py\", line 46, in <module>\n    parsed = eval(data)\n             ^^^^^^^^^^\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n              ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2xzc3951.py\", line 43, in <module>\n    parsed = json.loads(data_json)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 12 (char 11)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp2xzc3951.py\", line 46, in <module>\n    parsed = eval(data)\n             ^^^^^^^^^^\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n              ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Convert the input format into valid JSON\n    data_json = (\n        data\n        .replace(\"equations =\", '\"equations\":')\n        .replace(\"values =\", '\"values\":')\n        .replace(\"queries =\", '\"queries\":')\n    )\n    # Parse JSON\n    try:\n        parsed = json.loads(data_json)\n    except json.JSONDecodeError:\n        # Fallback: try eval for non-JSON friendly input\n        parsed = eval(data)\n    equations = parsed[\"equations\"]\n    values = parsed[\"values\"]\n    queries = parsed[\"queries\"]\n\n    solution = Solution()\n    results = solution.calcEquation(equations, values, queries)\n\n    output = '[' + ','.join(f'{x:.5f}' for x in results) + ']'\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The task is to solve division equations problem typical Leetcode 399. Use graph with weights, DFS/BFS to compute ratios.\n\nWe produce step-by-step pseudo-code: Build graph, for each query perform DFS to find path product, else -1.0. Use recursion or stack.\n\nWe need to produce each line with \"虛擬碼步驟\" plus comment.\n\nUse Start, End, Decision, etc.\n\nWe need to include variable pair mapping.\n\nLet's produce:\n\nStart\n→ Build graph from equations // create adjacency list with weights\n→ For each query in queries // iterate queries\n    → If either variable not in graph\n        Yes → Output -1.0 // undefined\n    → Else\n        → Initialize visited set\n        → Result ← DFS(Cj, Dj, visited, 1) // recursive search\n        → If Result == -1.0\n            Yes → Output -1.0\n        → Else\n            Yes → Output Result\nEnd\n\nNeed to produce DFS pseudo-code lines separately.\n\nLet's produce:\n\nDFS(node, target, visited, acc)\n    → Decision: node == target?\n        Yes → Return acc // found ratio\n        No  → Mark visited\n            → For each neighbor, weight\n                → If neighbor not visited\n                    → Recursive call DFS(neighbor, target, visited, acc * weight)\n                    → Decision: result != -1.0?\n                        Yes → Return result\n            → Return -1.0 // no path\n\nWrap in pseudo.\n\nAdd comments.\n\nMake sure each line has // explanation after space.\n\nLet's output accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ 建立圖 graph // 用 map<string, list<pair<string, double>>> 代表每個變量及其相對比例  \n→ Decision: 是否有 equations？  \n    Yes → For each equation (Ai, Bi) with value v  \n        → graph[Ai].append((Bi, v)) // Ai / Bi = v  \n        → graph[Bi].append((Ai, 1/v)) // Bi / Ai = 1/v  \n    No  → // 若 equations 為空，直接跳到查詢處理  \n→ For each query (Cj, Dj) in queries // 逐個處理查詢  \n    → Decision: graph 內是否含有 Cj 或 Dj？  \n        Yes →  \n            → Decision: Cj == Dj？  \n                Yes → Output 1.0 // 相同變量商為 1  \n                No  →  \n                    → Initialize visited set // 防止循環  \n                    → Result ← DFS(Cj, Dj, visited, 1.0) // 計算 Cj / Dj  \n                    → Decision: Result == -1.0？  \n                        Yes → Output -1.0 // 無路徑可得比例  \n                        No  → Output Result // 有效比例  \n        No  → Output -1.0 // 變量未定義  \nEnd // 程式執行結束  \n\nDFS(node, target, visited, acc) // 以遞迴方式搜尋路徑，acc 儲存目前累積的商  \n    → Decision: node == target？  \n        Yes → Return acc // 找到目標，回傳累積比例  \n        No  →  \n            → visited.add(node) // 記錄已訪問  \n            → For each (neighbor, weight) in graph[node]  \n                → Decision: neighbor not in visited？  \n                    Yes →  \n                        → 子結果 ← DFS(neighbor, target, visited, acc * weight) // 進一步搜尋  \n                        → Decision: 子結果 != -1.0？  \n                            Yes → Return 子結果 // 早停，已找到路徑  \n                    No  → // 已訪問，跳過  \n            → Return -1.0 // 所有相鄰節點都沒路徑到 target，回傳失敗  \n---"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,2,2,false]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, null, null, 2, 2, false]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        \"\"\"將元素推入佇列 q1\"\"\"\n        self.q1.append(x)\n\n    def pop(self):\n        \"\"\"從 q1 中取出最後一個元素，並恢復佇列順序\"\"\"\n        if not self.q1:\n            return None\n        # 移動除最後一個以外的所有元素到 q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # 取出最後一個元素\n        result = self.q1.popleft()\n        # 交換兩個佇列\n        self.q1, self.q2 = self.q2, self.q1\n        return result\n\n    def top(self):\n        \"\"\"取得堆疊頂部元素但不移除\"\"\"\n        if not self.q1:\n            return None\n        # 移動除最後一個以外的所有元素到 q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # 取得最後一個元素\n        result = self.q1.popleft()\n        # 再次放回 q2\n        self.q2.append(result)\n        # 交換兩個佇列\n        self.q1, self.q2 = self.q2, self.q1\n        return result\n\n    def empty(self) -> bool:\n        \"\"\"判斷堆疊是否為空\"\"\"\n        return not self.q1\n\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 可能存在前置文字，例如 \"Input\"\n    if data.lower().startswith('input'):\n        # 找到第一個 '[' 作為命令列表的開始\n        idx = data.find('[')\n        if idx != -1:\n            data = data[idx:]\n\n    # 使用正則分割兩個列表\n    import re\n    parts = re.split(r'\\],\\s*\\[', data)\n    if len(parts) != 2:\n        return\n    commands_str = parts[0] + ']'\n    args_str = '[' + parts[1]\n    commands = ast.literal_eval(commands_str)\n    args = ast.literal_eval(args_str)\n\n    result = []\n    stack = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == 'MyStack':\n            stack = MyStack()\n            result.append(None)\n        elif cmd == 'push':\n            # arg 形如 [1]\n            stack.push(arg[0])\n            result.append(None)\n        elif cmd == 'pop':\n            result.append(stack.pop())\n        elif cmd == 'top':\n            result.append(stack.top())\n        elif cmd == 'empty':\n            result.append(stack.empty())\n\n    # 將結果轉成指定格式\n    out_items = []\n    for v in result:\n        if v is None:\n            out_items.append('null')\n        elif isinstance(v, bool):\n            out_items.append('true' if v else 'false')\n        else:\n            out_items.append(str(v))\n    print('[' + ', '.join(out_items) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing a stack using two queues. We should provide each line with virtual code step followed by comment explanation. Use arrows and decisions. Should be structured steps. We need to represent logic of push, pop, top, empty. Use two queues q1, q2. Typical approach: push to q1; pop: move all but last from q1 to q2, pop last, then swap queues. For top similar but without removing. Or we can maintain top element variable. But requirement only standard queue operations. We'll produce steps for each method.\n\nWe need to produce \"Start\" then for each method maybe separate. Or provide overall structure? Provide pseudo-code for class definition and methods. Each line with comment. Use arrows. Let's craft.\n\nWe'll start with class MyStack // Start\n\nDefine two queues: q1, q2 // Step: initialize empty\n\nMethod push(x): \n- enqueue x to q1 // push to back\n\nMethod pop():\n- While size(q1)>1:\n    - temp = dequeue q1\n    - enqueue temp to q2\n- res = dequeue q1 // last element\n- swap q1 and q2\n- return res\n\nMethod top():\n- While size(q1)>1:\n    - temp = dequeue q1\n    - enqueue temp to q2\n- res = dequeue q1\n- enqueue res to q2\n- swap q1 and q2\n- return res\n\nMethod empty():\n- return isEmpty(q1) // since q2 always empty\n\nEnd // End\n\nBut we need to use arrow lines.\n\nWe need each line with \"虛擬碼步驟\" plus comment. Eg: \"Start // 程式開始執行\" etc. For arrows use \"→\". For decision, use \"Decision:\" etc.\n\nWe need to structure each method separately with arrows.\n\nLet's write:\n\nStart // 程式開始執行\n→ Initialize q1 ← empty queue // 建立第一個佇列\n→ Initialize q2 ← empty queue // 建立第二個佇列\n\n→ Method push(x) // 進行推入操作\n    → Enqueue x to q1 // 把元素放到第一個佇列尾部\n\n→ Method pop() // 進行彈出操作\n    → Decision: If q1 is empty? // 檢查是否為空\n        No → Decision: q1 size > 1? // 確定是否需要搬移元素\n            Yes → While q1 size > 1:\n                → temp ← Dequeue q1 // 從前端取出\n                → Enqueue temp to q2 // 放到第二個佇列尾部\n            → EndWhile\n        No → // 這裡無元素，直接返回空\n    → res ← Dequeue q1 // 取出最後一個元素\n    → Swap q1 and q2 // 交換兩個佇列，保持 q1 為工作佇列\n    → Return res // 返回彈出的元素\n\n→ Method top() // 取得堆疊頂部元素\n    → Decision: If q1 is empty? // 檢查是否為空\n        No → Decision: q1 size > 1? // 是否需要搬移\n            Yes → While q1 size > 1:\n                → temp ← Dequeue q1\n                → Enqueue temp to q2\n            → EndWhile\n    → res ← Dequeue q1 // 取出最後一個元素\n    → Enqueue res to q2 // 再次放回，保持元素不丟失\n    → Swap q1 and q2 // 交換佇列\n    → Return res // 返回頂部元素\n\n→ Method empty() // 判斷堆疊是否為空\n    → Return isEmpty(q1) // 只看第一個佇列是否為空\n\nEnd // 程式結束\n\nBut need each line with \"虛擬碼步驟\" and comment. Also each arrow uses \"→\". For nested decisions we can indent? But we need each line separate. Use indentation maybe not necessary but can use spaces.\n\nWe must avoid actual code syntax like \"return\", \"if\". Use words.\n\nWe need to ensure each line is unique line of virtual code.\n\nAlso must include \"Start\" and \"End\" lines.\n\nWe must produce the final answer accordingly. Use Chinese comments.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ q1 ← EmptyQueue // 初始化第一個佇列  \n→ q2 ← EmptyQueue // 初始化第二個佇列  \n\n→ Method push(x) // 推入操作  \n → Enqueue(x, q1) // 把元素放到 q1 的尾部  \n\n→ Method pop() // 彈出操作  \n → Decision: q1 is empty? // 檢查是否為空  \n  Yes → Return null // 若空，直接回傳空值  \n  No  → Decision: size(q1) > 1? // 是否需要搬移元素  \n   Yes → While size(q1) > 1:  \n     → temp ← Dequeue(q1) // 從 q1 前端取出  \n     → Enqueue(temp, q2) // 放入 q2 的尾部  \n    EndWhile  \n   No  → // 不需要搬移，直接操作  \n → result ← Dequeue(q1) // 取出最後一個元素（頂部）  \n → Swap(q1, q2) // 交換兩個佇列，q1 再次為工作佇列  \n → Return result // 回傳彈出的元素  \n\n→ Method top() // 取得頂部元素  \n → Decision: q1 is empty? // 檢查是否為空  \n  Yes → Return null // 若空，回傳空值  \n  No  → Decision: size(q1) > 1? // 是否需要搬移元素  \n   Yes → While size(q1) > 1:  \n     → temp ← Dequeue(q1)  \n     → Enqueue(temp, q2)  \n    EndWhile  \n → result ← Dequeue(q1) // 取出最後一個元素（頂部）  \n → Enqueue(result, q2) // 再次放回 q2，保持元素不丟失  \n → Swap(q1, q2) // 交換兩個佇列  \n → Return result // 回傳頂部元素  \n\n→ Method empty() // 判斷堆疊是否為空  \n → Return isEmpty(q1) // 只看 q1 是否為空  \n\nEnd // 程式結束執行"
    },
    {
      "title": "Median of Two Sorted Arrays",
      "source_file": "Leetcode/leetcode4.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,3], nums2 = [2]",
          "expected_output": "2.00000",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1j9fhbn2.py\", line 66, in <module>\n    print(f\"{median:.5f}\")\n            ^^^^^^^^^^^^\nTypeError: unsupported format string passed to NoneType.__format__"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,2], nums2 = [3,4]",
          "expected_output": "2.50000",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy2ljls6r.py\", line 66, in <module>\n    print(f\"{median:.5f}\")\n            ^^^^^^^^^^^^\nTypeError: unsupported format string passed to NoneType.__format__"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nimport math\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        # 確保 nums1 為較短的陣列\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        m, n = len(nums1), len(nums2)\n        if m == 0:  # 若短陣列為空，直接取長陣列的中位數\n            return self._median_of_single_array(nums2)\n\n        total = m + n\n        half = (total + 1) // 2  # 左半段的元素個數（對於偶數長度含右半段最小值）\n\n        low, high = 0, m\n        while low <= high:\n            i = (low + high) // 2          # nums1 的分割點\n            j = half - i                   # nums2 的對應分割點\n\n            left_max = max(\n                nums1[i - 1] if i > 0 else -math.inf,\n                nums2[j - 1] if j > 0 else -math.inf\n            )\n            right_min = min(\n                nums1[i] if i < m else math.inf,\n                nums2[j] if j < n else math.inf\n            )\n\n            if left_max <= right_min:\n                # 找到正確分割\n                if total % 2 == 1:\n                    return right_min\n                return (left_max + right_min) / 2.0\n            elif left_max > right_min:\n                high = i - 1\n            else:\n                low = i + 1\n\n    @staticmethod\n    def _median_of_single_array(arr):\n        n = len(arr)\n        if n % 2 == 1:\n            return arr[n // 2]\n        return (arr[n // 2 - 1] + arr[n // 2]) / 2.0\n\ndef parse_input(data):\n    # 從字串中提取兩個 list\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) != 2:\n        raise ValueError(\"輸入格式不正確\")\n    nums1 = ast.literal_eval(lists[0])\n    nums2 = ast.literal_eval(lists[1])\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    nums1, nums2 = parse_input(data)\n    sol = Solution()\n    median = sol.findMedianSortedArrays(nums1, nums2)\n    print(f\"{median:.5f}\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for finding median of two sorted arrays in O(log(m+n)). Classic algorithm: binary search on smaller array. Steps: handle if one empty, else do binary search partition. We'll produce pseudo steps with decisions. Should be line by line with explanations. Use Start, End, Decision. We'll produce generic steps not actual code. Provide enough steps. Ensure each line has \"虛擬碼步驟 // 解釋\".\n\nLet's craft.\n\nStart\n\n→ Determine smaller array (A) and larger array (B) // 方便二分搜索\n\n→ Set low = 0, high = length(A) // 初始搜索區間\n\n→ Decision: While low <= high? // 開始二分循環\n\n   Yes → Calculate partitionA = (low + high) // 2 // 中點\n\n   → Calculate partitionB = (m + n + 1)/2 - partitionA // 另一分割點\n\n   → Decision: partitionA < len(A) and nums1[partitionA] < nums2[partitionB-1]? // check if A's right part too small\n\n        Yes → low = partitionA + 1 // move right\n\n        No → Decision: partitionA > 0 and nums1[partitionA-1] > nums2[partitionB]? // A's left part too big\n\n              Yes → high = partitionA - 1 // move left\n\n              No → // correct partition found\n\n                 → Determine maxLeft // max of left halves\n\n                 → Decision: (m+n) % 2 == 0? // total even?\n\n                    Yes → Determine minRight // min of right halves\n\n                          → Output median = (maxLeft + minRight)/2\n\n                    No → Output median = maxLeft\n\n→ End\n\nBut need to format exactly. Also include step numbers maybe.\n\nLet's write each line. Ensure each line ends with // explanation.\n\nLet's produce a structured pseudo algorithm. Let's use \"Decision:\" for if statements, \"Yes →\" \"No →\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Set A = nums1, B = nums2, m = len(nums1), n = len(nums2) // 定義兩個陣列與其長度  \n→ Decision: 如果 m > n? // 確保 A 為較短陣列  \n    Yes → Swap A 和 B, m 和 n // 交換以便二分搜尋在較短陣列上  \n→ Set low = 0, high = m // 搜尋區間設為短陣列的索引範圍  \n→ Decision: low <= high? // 開始二分搜尋循環  \n    Yes → Set partitionA = (low + high) // 2 // A 的分割點  \n    → Set partitionB = (m + n + 1) // 2 - partitionA // B 的對應分割點  \n    → Decision: partitionA < m 且 A[partitionA] < B[partitionB - 1]? // A 的右側元素太小  \n        Yes → low = partitionA + 1 // 向右移動搜尋區間  \n        No → Decision: partitionA > 0 且 A[partitionA - 1] > B[partitionB]? // A 的左側元素太大  \n              Yes → high = partitionA - 1 // 向左移動搜尋區間  \n              No → // 正確的分割已找到  \n                 → Decision: partitionA == 0? // A 左側是否為空  \n                     Yes → maxLeft = B[partitionB - 1] // 取 B 左側最大值  \n                     No → Decision: partitionB == 0? // B 左側是否為空  \n                         Yes → maxLeft = A[partitionA - 1] // 取 A 左側最大值  \n                         No → maxLeft = max(A[partitionA - 1], B[partitionB - 1]) // 取兩邊最大值  \n                 → Decision: (m + n) % 2 == 0? // 總長度為偶數嗎  \n                     Yes → Decision: partitionA == m? // A 右側是否為空  \n                         Yes → minRight = B[partitionB] // 取 B 右側最小值  \n                         No → Decision: partitionB == n? // B 右側是否為空  \n                             Yes → minRight = A[partitionA] // 取 A 右側最小值  \n                             No → minRight = min(A[partitionA], B[partitionB]) // 取兩邊最小值  \n                         → Output median = (maxLeft + minRight) / 2 // 計算偶數情況的中位數  \n                     No → Output median = maxLeft // 奇數情況直接取左側最大值  \n    No → End // 二分搜尋結束，輸出中位數  \nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            rest = acc[2:]\n            # Ensure first_email is in parent\n            find(first_email)\n            for email in [first_email] + rest:\n                find(email)\n                parent[find(email)] = find(first_email)\n                email_to_name[email] = name\n\n        merged = {}\n        for email in email_to_name:\n            root = find(email)\n            merged.setdefault(root, []).append(email)\n\n        result = []\n        for root, emails in merged.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Handle possible \"accounts = ...\" prefix\n    if data.startswith(\"accounts\"):\n        eq_index = data.find(\"=\")\n        if eq_index != -1:\n            data = data[eq_index + 1:].strip()\n    try:\n        accounts = ast.literal_eval(data)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)\n\n    sol = Solution()\n    merged_accounts = sol.accountsMerge(accounts)\n    print(merged_accounts)",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines step-by-step for merging accounts problem. Provide in Chinese. Use Start, Decision, arrow, etc. Each line: virtual step + // explanation. Let's produce algorithm: use DSU or graph. We'll produce pseudo code using DSU for simplicity. Steps: build mapping email->index; union emails of same account; then group emails by root; output sorted emails. Provide lines. Ensure each line ends with comment. Use arrow format. Let's create lines:\n\nStart\n→ Step 1: 初始化 DSU 結構，並為每個 email 建立唯一索引 // 建立聯結集並為每個 email 取代 ID\n→ Step 2: 建立 email→索引 映射表 // 方便快速查找 email 對應的節點\n→ Step 3: 遍歷每個帳號，對帳號內所有 email 執行 union 操作 // 將同一帳號內所有 email 合併到同一集合\n    → Decision: 計算帳號中 email 數量? // 判斷是否至少有一個 email\n        Yes → Step 4: 對所有 email 執行 union(首個 email, 其餘 email) // 以第一個 email 為根\n        No  → Step 5: 跳過此帳號 // 若帳號僅有名字則不影響合併\n→ Step 6: 建立根節點→email 列表 映射表 // 用於聚集同一集合下的所有 email\n→ Step 7: 遍歷所有 email，找到其根節點，並將 email 加入對應列表 // 群組化\n→ Step 8: 準備最終結果列表 // 初始化返回結果\n→ Step 9: 對每個根節點的 email 列表進行排序並組成帳號 // 先按字典序排序\n    → Step 10: 取得對應名稱 // 從原始帳號映射獲取名稱\n    → Step 11: 建立新帳號列表 [名稱] + 已排序 email // 形成最終帳號\n    → Step 12: 將新帳號加入結果列表 // 收集\n→ Step 13: 返回結果列表 // 結束\n\nBut we need to be more step-by-step with arrows.\n\nWe need to use Decision only where conditional. Might need nested decisions. But keep simple.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 建立 DSU 物件並初始化 parent 和 rank // 用於維護聯結集\n→ Step 2: 初始化空字典 email_to_id // 存放 email → 唯一 ID\n→ Step 3: 初始化 id_counter = 0 // 用於給每個 email 編號\n→ Decision: 是否有帳號? // 檢查輸入列表是否為空\n    Yes → Step 4: 循環遍歷每個帳號 in accounts // 處理每個帳號\n        → Step 5: name = 帳號[0] // 取得帳號名稱\n        → Step 6: 取出 email_list = 帳號[1:] // 取得所有 email\n        → Decision: email_list 是否為空? // 判斷是否至少有一個 email\n            Yes → Step 7: 若 email_list 為空，則繼續下一個帳號 // 沒有 email 的帳號不影響合併\n            No → Step 8: 對 email_list 進行處理\n                → Step 9: 對每個 email in email_list\n                    → Decision: email 是否在 email_to_id? // 判斷是否已經編號\n                        Yes → Step 10: id = email_to_id[email] // 取已編號\n                        No  → Step 11: email_to_id[email] = id_counter // 新增編號\n                            → Step 12: id = id_counter\n                            → Step 13: id_counter += 1\n                    → Step 14: 若此 email 為第一個 email_in_list\n                        → Step 15: base_id = id // 設為基準 ID\n                        → Step 16: 繼續下一個 email\n                    → Step 17: 若非第一個 email\n                        → Step 18: DSU.union(base_id, id) // 合併到同一集合\n        → Step 19: // 完成此帳號的 union 操作\n    → Step 20: // 所有帳號已處理完畢\n→ Step 21: 建立空字典 root_to_emails // 以根節點為鍵，存放所有 email\n→ Step 22: 循環遍歷 email_to_id.items()\n    → Step 23: root = DSU.find(id) // 找到 email 的根節點\n    → Decision: root 是否在 root_to_emails? // 判斷是否已有集合\n        Yes → Step 24: root_to_emails[root].append(email) // 加入集合\n        No  → Step 25: root_to_emails[root] = [email] // 建立新集合\n→ Step 26: 建立結果列表 res = [] // 用於儲存最終帳號\n→ Step 27: 循環遍歷 root_to_emails.items()\n    → Step 28: emails = sorted(列表) // 對 email 進行字典序排序\n    → Step 29: 找到任何一個 email 對應的名稱 // 從原始帳號資料中取得 name\n        → Step 30: name = accounts_dict[email] // 需事先建立 email→name 映射\n    → Step 31: res.append([name] + emails) // 組合並加入結果\n→ End // 程式執行結束\n\nWe might need mapping email→name earlier. We can build during traversal. Let's add Step 32: email_to_name mapping. We'll include that earlier.\n\nBut we must keep each line simple. Provide explanation after //.\n\nLet's refine steps.\n\nWe will produce pseudo code with DSU.\n\nLet's craft final answer with lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 DSU 物件並初始化 parent 與 rank // 用於維護聯結集  \n→ Step 2: 初始化空字典 email_to_id // 存放 email → 唯一 ID  \n→ Step 3: 初始化空字典 email_to_name // 存放 email → 名稱  \n→ Step 4: 初始化 id_counter = 0 // 用於給每個 email 編號  \n→ Decision: 是否有帳號? // 檢查輸入列表是否為空  \n    Yes → Step 5: 循環遍歷每個帳號 in accounts // 處理每個帳號  \n        → Step 6: name = 帳號[0] // 取得帳號名稱  \n        → Step 7: email_list = 帳號[1:] // 取得所有 email  \n        → Decision: email_list 是否為空? // 判斷是否至少有一個 email  \n            Yes → Step 8: 若 email_list 為空，則繼續下一個帳號 // 沒有 email 的帳號不影響合併  \n            No → Step 9: 對 email_list 進行處理  \n                → Step 10: 取出第一個 email 為 base_email // 作為 union 的基準  \n                → Step 11: 若 base_email 不在 email_to_id  \n                    → Step 12: email_to_id[base_email] = id_counter  \n                    → Step 13: email_to_name[base_email] = name  \n                    → Step 14: id_counter += 1  \n                → Step 15: base_id = email_to_id[base_email] // 基準 ID  \n                → Step 16: 循環遍歷剩餘的 email in email_list[1:]  \n                    → Decision: email 是否在 email_to_id? // 判斷是否已編號  \n                        Yes → Step 17: id = email_to_id[email]  \n                        No  → Step 18: email_to_id[email] = id_counter  \n                            → Step 19: email_to_name[email] = name  \n                            → Step 20: id = id_counter  \n                            → Step 21: id_counter += 1  \n                    → Step 22: DSU.union(base_id, id) // 合併到同一集合  \n        → Step 23: // 完成此帳號的 union 操作  \n    → Step 24: // 所有帳號已處理完畢  \n→ Step 25: 建立空字典 root_to_emails // 以根節點為鍵，存放所有 email  \n→ Step 26: 循環遍歷 email_to_id.items()  \n    → Step 27: root = DSU.find(id) // 找到 email 的根節點  \n    → Decision: root 是否在 root_to_emails?  \n        Yes → Step 28: root_to_emails[root].append(email) // 加入集合  \n        No  → Step 29: root_to_emails[root] = [email] // 建立新集合  \n→ Step 30: 建立結果列表 res = [] // 用於儲存最終帳號  \n→ Step 31: 循環遍歷 root_to_emails.items()  \n    → Step 32: sorted_emails = sorted(列表) // 對 email 進行字典序排序  \n    → Step 33: 取第一個 email 的 name = email_to_name[第一個 email] // 取得對應名稱  \n    → Step 34: res.append([name] + sorted_emails) // 組合並加入結果  \n→ End // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,0,4,6,6,6,0,0]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 0, 4, 6, 6, 6, 0, 0]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    \"\"\"\n    Random integer picker that excludes blacklisted values.\n    \"\"\"\n    def __init__(self, n, blacklist):\n        \"\"\"\n        初始化：建立一個映射表，將需要映射的低值指向合法高值。\n        :param n: 整數範圍上限（不包含）\n        :param blacklist: 黑名單（唯一整數列表）\n        \"\"\"\n        self.mapping = {}                 # 映射字典\n        self.size = n - len(blacklist)    # 可被選到的數量\n        black_set = set(blacklist)        # 為 O(1) 查詢\n        last = n - 1                      # 最高可用數字\n\n        # 只對小於 size 的黑名單項目做映射\n        for b in blacklist:\n            if b < self.size:\n                # 找到不在黑名單且在 size 範圍內的最大值\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        \"\"\"\n        隨機返回一個非黑名單的整數。\n        :return: 隨機整數\n        \"\"\"\n        idx = random.randint(0, self.size - 1)   # 先在 [0, size-1] 隨機\n        return self.mapping.get(idx, idx)        # 若映射，返回映射值；否則返回自身\n\ndef main():\n    \"\"\"\n    主函式：從 stdin 讀取指令與參數，執行相應方法並輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n\n    # 第一行：方法名稱列表；第二行：對應參數列表\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)  # 建構子返回 None\n        else:\n            method = getattr(obj, cmd)\n            res = method(*args)\n            results.append(res)\n\n    # 使用 json.dumps 以確保 None 轉為 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode that describes algorithm: mapping from [0, n - 1] minus blacklist to [0, m-1] where m = n - len(blacklist). Use dictionary mapping: For each blacklisted number < m, map it to some whitelisted number >= m. During initialization, create mapping. Then pick returns random in [0,m-1], then map if exists. Provide line by line pseudocode with explanations. Ensure each line has arrow arrow. Use Start, End, Decision. Use steps. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收參數 n 與 blacklist // 初始化資料  \n→ Step 2: 計算 m = n - blacklist.length // 可選取的合法數字個數  \n→ Step 3: 建立空映射 dict // 用於將被遮蔽的低值映射至高值  \n→ Decision: blacklist 是否為空？  \n    Yes → Step 4: 跳至 6 // 無需映射，直接使用  \n    No  → Step 5: 將 blacklist 依序排序並放入集合 BSet // 方便查詢  \n→ Step 6: 初始化 white = n - 1 // 最後一個可能的合法值  \n→ Decision: 是否存在 blacklist 中小於 m 的數字？  \n    Yes → Step 7: 取首個 black = blacklist[0] // 低於 m 的遮蔽數  \n    No  → Step 8: 跳至 10 // 已無需映射  \n→ Decision: white 是否在 BSet？  \n    Yes → Step 9: 減少 white, 重複此決策 // 找到不在黑名單的高值  \n    No  → Step 10: 建立映射 dict[black] = white // 將低值指向高值  \n→ Step 11: 移除已處理的 black 從 BSet 並移動至下一個 black // 迭代所有需要映射的低值  \n→ Decision: 有無更多低於 m 的 black？  \n    Yes → 迴圈回 7  \n    No  → End // 初始化完成  \n\nStart // pick 方法開始執行  \n→ Step 12: randomIndex = randomInt(0, m-1) // 產生 [0, m-1] 的隨機數  \n→ Decision: randomIndex 是否存在於 dict？  \n    Yes → Step 13: result = dict[randomIndex] // 替換為映射的高值  \n    No  → Step 14: result = randomIndex // 直接使用  \n→ Step 15: return result // 回傳合法隨機整數  \nEnd // 程式結束執行"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.12572679167280593,0.6481519277760178],[0.5632007359026343,0.722892761911114],[-0.27468935203441464,-0.21289940872580812]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.12572679167280593, 0.6481519277760178], [0.5632007359026343, 0.722892761911114], [-0.27468935203441464, -0.21289940872580812]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 生成均勻分佈的半徑\n        r = self.radius * math.sqrt(random.random())\n        # 生成均勻分佈的角度\n        theta = random.uniform(0, 2 * math.pi)\n        # 轉換為笛卡兒座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    obj = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            method = getattr(obj, op)\n            results.append(method(*args))\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. No actual code. Just pseudo steps.\n\nRequirement: Implement Solution class with constructor taking radius, x_center, y_center, and method randPoint generating uniform random point inside circle. Use approach: random radius sqrt(rand()*radius^2), random angle 0-2π. Then x = x_center + r*cos(theta), y = y_center + r*sin(theta). Return array.\n\nSo virtual steps: Start, Step: define class Solution, Step: constructor assigns radius, center, precompute radius^2 maybe. randPoint method: generate random number u uniform [0,1], compute r = sqrt(u)*radius. generate random angle a uniform [0, 2π], compute x, y. Return [x,y]. End.\n\nWe need to output each line with virtual code + comment.\n\nLet's produce lines:\n\nStart\n→ Step 1: 定義類別 Solution // 定義主類別\n→ Step 2: Constructor: Solution(radius, x_center, y_center) // 初始化半徑及中心座標\n    → Step 3: 設定 this.radius = radius\n    → Step 4: 設定 this.xc = x_center\n    → Step 5: 設定 this.yc = y_center\n    → Step 6: 計算 this.r2 = radius * radius // 方便後續使用\n→ Step 7: 方法 randPoint() // 產生隨機點\n    → Step 8: 產生 u = 隨機數 [0,1] // 生成 0~1 的隨機數\n    → Step 9: 計算 r = sqrt(u) * this.radius // 均勻分佈半徑\n    → Step 10: 產生 θ = 隨機數 [0, 2π] // 生成 0~2π 的隨機角\n    → Step 11: 計算 x = this.xc + r * cos(θ) // 組成 x 座標\n    → Step 12: 計算 y = this.yc + r * sin(θ) // 組成 y 座標\n    → Step 13: 回傳 [x, y] // 回傳點座標\nEnd\n\nMake sure each line with arrow and comment. Use \"→\" for steps, \"→\" with indent? Use \"    \" for nested. Decision not needed.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 定義主要類別  \n→ Step 2: Constructor: Solution(radius, x_center, y_center) // 初始化半徑及中心座標  \n    → Step 3: 設定 this.radius = radius // 存放半徑  \n    → Step 4: 設定 this.xc = x_center // 存放中心 x 座標  \n    → Step 5: 設定 this.yc = y_center // 存放中心 y 座標  \n    → Step 6: 計算 this.r2 = radius * radius // 事先算出平方值以供使用  \n→ Step 7: 方法 randPoint() // 產生隨機點  \n    → Step 8: 產生 u = 隨機數 [0,1] // 產生 0~1 的隨機數  \n    → Step 9: 計算 r = sqrt(u) * this.radius // 轉換為均勻分佈的半徑  \n    → Step 10: 產生 θ = 隨機數 [0, 2π] // 產生 0~2π 的隨機角度  \n    → Step 11: 計算 x = this.xc + r * cos(θ) // 組成 x 座標  \n    → Step 12: 計算 y = this.yc + r * sin(θ) // 組成 y 座標  \n    → Step 13: 回傳 [x, y] // 回傳隨機點座標  \nEnd // 程式執行結束"
    },
    {
      "title": "Reverse Words in a String",
      "source_file": "Leetcode/leetcode151.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"the sky is blue\"",
          "expected_output": "\"blue is sky the\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'blueisskythe'\nGot (Norm):      'blue\"issky\"the=s'\n--- (Raw) ---\nRaw Expected: '\"blue is sky the\"'\nRaw Got:      'blue\" is sky \"the = s'"
        },
        {
          "example_index": 1,
          "input": "s = \"  hello world  \"",
          "expected_output": "\"world hello\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'worldhello'\nGot (Norm):      '\"worldhello\"=s'\n--- (Raw) ---\nRaw Expected: '\"world hello\"'\nRaw Got:      '\" world hello \" = s'"
        },
        {
          "example_index": 2,
          "input": "s = \"a good   example\"",
          "expected_output": "\"example good a\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'examplegooda'\nGot (Norm):      'example\"good\"a=s'\n--- (Raw) ---\nRaw Expected: '\"example good a\"'\nRaw Got:      'example\" good \"a = s'"
        }
      ],
      "generated_code": "import sys\n\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    先去除前後多餘空格，再以空格分割，過濾掉多餘空格，\n    最後將單詞順序倒轉並以單空格連接。\n    \"\"\"\n    words = s.strip().split()\n    return ' '.join(words[::-1])\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取原始字串，解析出真正的文字內容，\n    呼叫 reverse_words，並將結果輸出到標準輸出。\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n\n    # 若輸入形式為: s = \"some text\"\n    if ('=\"' in data) or (\"='\" in data):\n        # 找出第一個引號\n        first_quote = data.find('\"')\n        if first_quote == -1:\n            first_quote = data.find(\"'\")\n        # 找出最後一個引號\n        last_quote = data.rfind('\"')\n        if last_quote == -1:\n            last_quote = data.rfind(\"'\")\n        # 取得引號之間的內容\n        s = data[first_quote + 1:last_quote]\n    else:\n        # 直接使用整行文字\n        s = data\n\n    result = reverse_words(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code line by line, with explanations. The task: given input string s, reverse words, strip spaces. Steps: split by spaces, filter non-empty, reverse array, join by single space. Virtual code: Start, Step1: input string, Step2: split by space, Step3: filter non-empty, Step4: reverse list, Step5: join, Step6: output. Use Decision? Possibly not needed. Provide virtual code lines with arrow. Use Start, End. Use \"→ Step X\". Provide explanation after comment. Ensure each line has one line. Use format: \"虛擬碼步驟 // 解釋\". So e.g.:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 s // 取得原始文字\n→ Step 2: 將 s 以空白切割為字串陣列 words // 拆解為單詞與空白\n→ Step 3: 過濾 words 中非空字串 // 移除多餘空格\n→ Step 4: 反轉 words 陣列 // 變成倒序\n→ Step 5: 用單一空白連接 words 為結果 string result // 產生回傳字串\n→ Step 6: 輸出 result // 結束\n\nEnd // 程式執行結束\n\nBut requirement: \"虛擬碼步驟\" might be descriptive like \"Step 1: ...\". Should we include \"Step\"? It's fine. Also arrow \"→\". Ensure each line has only one step. Add \"Start\" and \"End\". No decision needed.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 取得使用者輸入的原始文字  \n→ Step 2: 將 s 以空白字元切割成陣列 words // 將文字拆分成單個字元或空白分隔  \n→ Step 3: 過濾 words 陣列中空字串 // 去除多餘空格，僅保留實際單詞  \n→ Step 4: 反轉 words 陣列 // 使單詞順序倒轉  \n→ Step 5: 用單一空白字元連接 words 成為字串 result // 產生符合格式的輸出  \n→ Step 6: 輸出 result // 回傳最終字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,2,1],[1,2,3],[2,1,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [3, 2, 1], [1, 2, 3], [2, 1, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列的複本，避免外部修改\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列\n        return list(self.original)\n\n    def shuffle(self):\n        # 使用 Fisher‑Yates 洗牌演算法\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 轉成元組 (ops, args)\n    try:\n        raw_input = \"(\" + raw_input + \")\"\n        ops, args = ast.literal_eval(raw_input)\n    except Exception as e:\n        raise ValueError(\"輸入格式錯誤\") from e\n\n    outputs = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # 建構子只接收第一個元素作為陣列\n            obj = Solution(arg[0])\n            outputs.append(None)  # 建構子回傳 null\n        elif op == \"reset\":\n            outputs.append(obj.reset())\n        elif op == \"shuffle\":\n            outputs.append(obj.shuffle())\n        else:\n            raise ValueError(f\"未知方法: {op}\")\n\n    # 輸出結果\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for the algorithm: Fisher-Yates shuffle, with reset and shuffle methods. Use virtual code with Start, End, Decision. Provide step-by-step. Must be line by line. Each line: virtual code + space + // explanation. Use arrow. Provide steps like initialization, reset returns original array, shuffle copies array then loops. Also need to store original array. Use copy of array for shuffle. For random selection use random index.\n\nWe must not output actual code but pseudocode steps. So something like:\n\nStart\n→ Step 1: Store original array in originalNums // Save for reset\n→ Step 2: Set currentNums to a copy of originalNums // Working copy\n→ Decision: ... etc.\n\nBut we need to design class. So maybe include class definition? Use pseudocode: Class Solution { ... }\n\nBut instructions: produce virtual code steps. So maybe start with Start, then steps. Use Decision nodes for random. Provide line numbers? Not necessary.\n\nLet's produce:\n\nStart\n→ Step 1: 接收輸入陣列 nums // 構造函式\n→ Decision: 如果 nums 為空? // 檢查\n    Yes → Step 2: 初始化 originalNums 為空陣列 // 空處理\n    No  → Step 3: 原始陣列 originalNums ← nums 的複製 // 儲存原始順序\n→ Step 4: 初始化 currentNums ← originalNums 的複製 // 工作陣列\n→ Step 5: 定義 reset() // 回傳原始陣列\n→     Step 6: currentNums ← originalNums 的複製 // 重置\n→     Step 7: Return currentNums // 返回\n→ Step 8: 定義 shuffle() // 隨機打亂\n→     Step 9: currentNums ← originalNums 的複製 // 從原始複製\n→     Step 10: For i from 0 to length-1\n→         Decision: 隨機產生 j ∈ [i, length-1] // 隨機索引\n→         Step 11: Swap currentNums[i] 與 currentNums[j] // 交換\n→     Step 12: Return currentNums // 返回打亂結果\nEnd\n\nBut need arrow formatting: Use \"→\" before step labels. Indent decisions.\n\nUse \"Yes →\", \"No →\" for decisions.\n\nWe also need to ensure each line ends with // explanation.\n\nWe also might need to separate methods.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建構子 Solution(nums) 接收整數陣列 // 用於初始化\n→ Decision: 若 nums 為空? // 檢查是否有資料\n    Yes → Step 2: originalNums ← 空陣列 // 空陣列情況\n    No  → Step 3: originalNums ← nums 的複製 // 儲存原始順序以備 reset\n→ Step 4: currentNums ← originalNums 的複製 // 建立工作副本\n→ Step 5: 定義 reset() 方法 // 回傳原始順序\n→     Step 6: currentNums ← originalNums 的複製 // 重置工作副本\n→     Step 7: Return currentNums // 回傳原始陣列\n→ Step 8: 定義 shuffle() 方法 // 隨機打亂\n→     Step 9: currentNums ← originalNums 的複製 // 從原始陣列開始\n→     Step 10: For i 於 0 直至 currentNums.length-1\n→         Decision: 產生隨機整數 j 於 [i, currentNums.length-1] // Fisher‑Yates 隨機索引\n            Yes → Step 11: Swap currentNums[i] 與 currentNums[j] // 交換位置\n        No  → // (無需操作，跳過交換)\n→     Step 12: Return currentNums // 回傳隨機排列\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            # 把目前的子集加入結果\n            res.append(path[:])\n            # 遞迴探索後續元素\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n\n        backtrack(0, [])\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中擷取整數列表\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    solution = Solution()\n    result = solution.subsets(numbers)\n\n    # 輸出符合範例格式（無空格）\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with explanations. Must use Start, End, Decision:, arrow. For subset generation, typical recursive backtracking or iterative. Use Start, Step1: sort? but unique. We'll produce algorithm: backtrack(index, current). If index == len(nums) -> add current to results. else: include nums[index] and exclude. Provide lines. Need to be clear. Let's produce step-by-step pseudo-code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義結果列表 subsets ← [] // 用來存放所有子集  \n→ Step 2: 定義遞迴函式 Backtrack(index, current) // index 為目前考慮的元素索引，current 為已選取的子集  \n→ Step 3:     Decision: 如果 index == length(nums) ? // 已處理完所有元素  \n  Yes → Step 4:     Add copy of current to subsets // 把完整子集加入結果  \n  No  → Step 5:     Decision: 是否選取 nums[index]？ // 決定是否把當前元素包含進子集  \n    Yes → Step 6:     Append nums[index] to current // 把元素加入子集  \n      → Step 7:     Call Backtrack(index + 1, current) // 進行下一層遞迴  \n      → Step 8:     Remove last element from current // 回溯，移除剛加入的元素  \n    No  → Step 9:     Call Backtrack(index + 1, current) // 不選取該元素，直接遞迴  \n→ Step 10: Call Backtrack(0, []) // 從第一個元素開始遞迴  \n→ Step 11: Return subsets // 回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Twitter",
      "source_file": "Leetcode/leetcode355.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphibslfq5.py\", line 78, in <module>\n    main()\n  File \"/tmp/tmphibslfq5.py\", line 50, in main\n    data_str = sys.stdin.read().strip()\n               ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        }
      ],
      "generated_code": "import json\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0                     # 全局時間戳，用於排序\n        self.tweets = defaultdict(list)   # userId -> [(time, tweetId), ...]\n        self.following = defaultdict(set) # userId -> set(followeeId)\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        # 確保使用者自己也會出現在自己的動態中\n        if userId not in self.following[userId]:\n            self.following[userId].add(userId)\n\n    def getNewsFeed(self, userId: int) -> list[int]:\n        res = []\n        if userId not in self.following:\n            return res\n        heap = []  # 優先佇列，按時間戳遞減排序\n        for fid in self.following[userId]:\n            tws = self.tweets.get(fid)\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx - 1 >= 0:\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].add(followeeId)\n        # 自己也保持為自己跟蹤對象\n        if followerId not in self.following[followerId]:\n            self.following[followerId].add(followerId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            return\n        self.following[followerId].discard(followeeId)\n\n\ndef main() -> None:\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        return\n    # 將兩個 JSON 陣列包裝成一個陣列，以便使用 json.loads 解析\n    ops, args = json.loads('[' + data_str + ']')\n    twitter = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Twitter\":\n            twitter = Twitter()\n            outputs.append(None)\n        elif op == \"postTweet\":\n            twitter.postTweet(arg[0], arg[1])\n            outputs.append(None)\n        elif op == \"getNewsFeed\":\n            outputs.append(twitter.getNewsFeed(arg[0]))\n        elif op == \"follow\":\n            twitter.follow(arg[0], arg[1])\n            outputs.append(None)\n        elif op == \"unfollow\":\n            twitter.unfollow(arg[0], arg[1])\n            outputs.append(None)\n\n    # json.dumps 會自動將 None 轉為 null\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. We need to design a simplified Twitter. Should include data structures: tweet list per user, following map, global timestamp. We'll output steps in pseudo code. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe'll create Start, End. Use arrows. Provide decisions. Use simplified structure. Let's produce pseudo algorithm steps for each method. Let's produce for initialization, postTweet, getNewsFeed, follow, unfollow. Use decision for getNewsFeed: gather tweets, sort by timestamp, return top 10. We'll use a global timestamp counter to order tweets. Use data structures: map userId->list of tweets (each tweet record contains tweetId and timestamp). Map userId->set of followees. On getNewsFeed, we gather tweets from user and followees, use priority queue or sorting. We'll pseudo-code.\n\nMake sure each line has explanation after //.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 定義全域時間戳記 timestamp ← 0 // 用來記錄每則推文的發佈順序\n→ Step 2: 建立用戶關係映射 follows ← Map<userId, Set<followeeId>> // 存儲每個使用者所追蹤的對象\n→ Step 3: 建立推文存儲映射 tweets ← Map<userId, List<(tweetId, ts)>> // 存儲每個使用者發佈的推文與時間戳\n\n→ End // 初始化結束\n\n---\n\nStart // postTweet 方法執行\n→ Step 4: timestamp ← timestamp + 1 // 為本次推文分配遞增的時間戳\n→ Step 5: 若 tweets[userId] 不存在則 tweets[userId] ← 空清單 // 初始化使用者推文清單\n→ Step 6: tweets[userId].append((tweetId, timestamp)) // 將推文加入使用者清單\n→ End // postTweet 結束\n\n---\n\nStart // getNewsFeed 方法執行\n→ Step 7: feedTweets ← 空清單 // 用於暫存所有候選推文\n→ Decision: 若 follows[userId] 不存在? // 檢查是否已有追蹤關係\n    Yes → follows[userId] ← 空集合 // 初始化空集合\n→ Step 8: 向 feedTweets 添加 tweets[userId] // 加入使用者自己的推文\n→ Step 9: 對於 每個 followee 在 follows[userId] 中\n    → Step 10: 若 tweets[followee] 存在則\n        → Step 11: 向 feedTweets 添加 tweets[followee] // 加入追蹤對象的推文\n→ Step 12: 按時間戳降序排列 feedTweets // 由最近到最舊排序\n→ Step 13: 返回 feedTweets 前 10 個 tweetId // 取前 10 個最新推文\n→ End // getNewsFeed 結束\n\n---\n\nStart // follow 方法執行\n→ Decision: 若 follows[followerId] 不存在? // 初始化追蹤集合\n    Yes → follows[followerId] ← 空集合\n→ Step 14: follows[followerId].add(followeeId) // 加入追蹤對象\n→ End // follow 結束\n\n---\n\nStart // unfollow 方法執行\n→ Decision: 若 follows[followerId] 存在且包含 followeeId? // 確認可刪除\n    Yes → follows[followerId].remove(followeeId) // 移除追蹤對象\n→ End // unfollow 結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,0,0,1,0,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 0, 0, 1, 0, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        # 建立前綴和\n        self.prefix = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 隨機產生 1~total 的整數，對應前綴和\n        target = random.randint(1, self.total)\n        # bisect_left 找到最小的索引使得 prefix[idx] >= target\n        return bisect.bisect_left(self.prefix, target)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入格式 [\"Solution\",\"pickIndex\"], [[[1]],[]]\n    # 找第一個 '],' 之後分割\n    split_idx = data.find('],')\n    methods_str = data[:split_idx+1]\n    args_str = data[split_idx+2:].strip()\n    methods = json.loads(methods_str)\n    args = json.loads(args_str)\n\n    results = []\n    obj = None\n    for method, arg in zip(methods, args):\n        if method == \"Solution\":\n            # arg 為 [[1]]，取第一個元素作為 w\n            obj = Solution(arg[0])\n            results.append(None)  # constructor 沒有返回值\n        elif method == \"pickIndex\":\n            results.append(obj.pickIndex())\n        else:\n            # 若有其他方法可在此處擴充\n            pass\n\n    # 輸出結果為 JSON 列表，例如 [null,0]\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm. The algorithm: build prefix sums array, then in pickIndex generate random number in [0,total), binary search to find index. Provide steps line by line with explanation. No actual code. Use arrow etc.\n\nLet's craft. Include initialization: Start, Step 1: Input w, compute prefix sums, compute total. Then pickIndex: Step: generate random r, Step: binary search to find smallest index with prefix > r. Return index. End.\n\nInclude Decision? maybe not necessary. But we can include Decision: if r < prefix[0]? But binary search loop can be included.\n\nWe'll output:\n\nStart // program start\n→ Step 1: Accept array w // input array\n→ Step 2: Create empty prefix array // prepare cumulative weights\n→ Step 3: For each weight, add to cumulative sum and store in prefix // compute prefix sums\n→ Step 4: Store total sum of weights // total weight\nEnd // initialization complete\n\nThen pickIndex function steps:\n\nStart // pickIndex called\n→ Step 5: Generate random number r in [0, total) // random value\n→ Step 6: Set low = 0, high = length-1 // binary search bounds\n→ Decision: While low < high? // loop to find index\n    Yes → Step 7: mid = (low + high) // 2 // mid point\n        Yes → Decision: If prefix[mid] > r? // check condition\n            Yes → Step 8: high = mid // search left half\n            No  → Step 9: low = mid + 1 // search right half\n        No → ... (loop continues)\n→ Step 10: Return low // found index\nEnd // function ends\n\nWe need to ensure \"逐行\" means each line output individually. Provide each line with // explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入陣列 w // 取得重量陣列  \n→ Step 2: 初始化空陣列 prefix // 用於儲存累積重量  \n→ Step 3: 變數 sum ← 0 // 用於累加總重量  \n→ Step 4: 對於 w 的每個元素 weight:  \n    sum ← sum + weight // 累加至總重量  \n    prefix.append(sum) // 儲存當前累積值到 prefix  \n→ Step 5: 保存 totalWeight ← sum // 總重量供後續使用  \nEnd // 初始化完成  \n\nStart // 呼叫 pickIndex() 時執行  \n→ Step 6: 產生隨機數 r ∈ [0, totalWeight) // 隨機值  \n→ Step 7: low ← 0, high ← len(prefix) - 1 // 二分搜尋上下界  \n→ Decision: while low < high? // 繼續搜尋  \n  Yes → Step 8: mid ← (low + high) // 2 // 中點索引  \n    Decision: prefix[mid] > r? // 檢查 r 是否小於中點累積值  \n     Yes → Step 9: high ← mid // r 在左半段，縮小右界  \n     No  → Step 10: low ← mid + 1 // r 在右半段，縮小左界  \n→ Step 11: Return low // 找到對應索引並返回  \nEnd // 函式結束執行"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,0,3]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[2,0,3]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()\n        return [i for _, i in soldiers[:k]]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將輸入字串分成兩部份：mat 部分和 k 部分\n    # 假設輸入形如 \"mat = [[1,1,0], [1,0,0]], k = 2\"\n    parts = data.split('k =')\n    mat_part = parts[0].replace('mat', '').strip()\n    k_part = parts[1].strip() if len(parts) > 1 else ''\n\n    # 解析矩陣\n    try:\n        mat = ast.literal_eval(mat_part)\n    except Exception:\n        mat = []\n\n    # 解析 k\n    try:\n        k = int(k_part)\n    except Exception:\n        k = 0\n\n    result = Solution().kWeakestRows(mat, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm to find k weakest rows in binary matrix. Use binary search per row to count ones. Then sort rows by (count, index). Return first k indices.\n\nWe'll produce line-by-line virtual code with comments. Use Start, End, Decision, etc. Provide each step. Probably need loops. We'll keep generic.\n\nWe must not output actual code; just virtual steps with explanation.\n\nLet's craft.\n\n- Start\n- Step: Initialize empty list rowsInfo\n- For each row index r from 0 to m-1:\n    - Step: Use binary search to find first 0 in row\n    - Step: count = position of first 0 (or n if all 1)\n    - Step: Append (count, r) to rowsInfo\n- Step: Sort rowsInfo by count asc, then index asc\n- Step: Extract first k indices\n- End\n\nAdd decisions for binary search. Provide each line.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空列表 rowsInfo // 用來存放每一行的「士兵數」和「索引」\n→ Step 2: 對於每個行索引 r 從 0 到 m-1 執行\n    → Step 3: 設定 low = 0, high = n // 為二分搜尋設定界限\n    → Decision: low <= high? // 確定還有未搜尋的區間\n        Yes → Step 4: mid = (low + high) / 2 // 取中點\n        → Decision: mat[r][mid] == 1? // 中點為士兵\n            Yes → Step 5: low = mid + 1 // 士兵在左側，搜尋右半邊\n            No  → Step 6: high = mid - 1 // 右側為士兵，搜尋左半邊\n        → Go back to Decision: low <= high? // 重新判斷是否還有區間\n    → Step 7: count = low // low 位置即為第一個 0 的索引，亦即士兵數\n    → Step 8: 將 (count, r) 添加到 rowsInfo // 記錄行的強度與索引\n→ Step 9: 將 rowsInfo 按 count 升序，若 count 相同則按 r 升序排序 // 以「弱」排序\n→ Step 10: 取前 k 個元素的 r 值作為結果 // 提取最弱的 k 行索引\nEnd // 程式執行結束"
    }
  ]
}