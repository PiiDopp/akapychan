{
  "run_index": 5,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 391,
  "generation_or_validation_failure_count": 48,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[2,1,5,3,4]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[2, 1, 5, 3, 4]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰子，返回所有結果的列表。\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n 必須為正整數\")\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入並執行\n    code = sys.stdin.read()\n    if code.strip():  # 若有輸入才執行\n        exec(code)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps with explanations, line by line. Use arrow → and Decision: etc. The user wants a function roll_dice(n) that uses random module to simulate rolling a six-sided die n times, returning a list of results. We need to produce the pseudocode step by step, with arrow.\n\nWe must not output actual code. Use virtual code syntax. Should include import random at start? Possibly we need a start. Let's produce:\n\nStart\n→ Step 1: Import random module // 導入 random 模組\n→ Step 2: Define function roll_dice(n) // 定義 roll_dice 函式\n→ Step 3: Initialize results list = [] // 建立空列表存放結果\n→ Step 4: Decision: n <= 0? // 檢查擲骰次數是否為正數\n    Yes → Step 5: Raise ValueError \"n must be positive\" // n 為非正數時拋出錯誤\n    No  → Step 6: For i in range(n) // 進行 n 次迴圈\n        → Step 7: Call random.randint(1, 6) → result // 產生 1-6 的隨機數\n        → Step 8: Append result to results // 加入結果列表\n→ Step 9: Return results // 回傳結果列表\nEnd\n\nMake sure each line has \"// 解釋\". Use the arrow for each step. Also include decision branches with Yes → and No →. Provide virtual code lines accordingly.\n\nLet's produce output exactly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 導入 random 模組  \n→ Step 2: Define function roll_dice(n) // 定義 roll_dice 函式  \n→ Step 3: Initialize results list = [] // 建立空列表存放結果  \n→ Decision: n <= 0? // 檢查擲骰次數是否為正數  \n Yes → Step 4: Raise ValueError \"n must be positive\" // n 為非正數時拋出錯誤  \n No  → Step 5: For i in range(n) // 進行 n 次迴圈  \n  → Step 6: Call random.randint(1, 6) → result // 產生 1-6 的隨機數  \n  → Step 7: Append result to results // 加入結果列表  \n→ Step 8: Return results // 回傳結果列表  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量傳入函式 func 執行所需的秒數，並回傳四捨五入到小數點第三位的數值。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"\n    讀取標準輸入的所有程式碼並執行。\n    \"\"\"\n    code = sys.stdin.read()\n    # 以目前全域環境執行，確保 measure_time 已可使用\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Include arrow, Start, End, Decision, etc. Provide explanation after //.\n\nThe function measure_time(func, *args). Steps: import time, define function, record start time, call func(*args), record end time, compute elapsed, round to 3 decimal places, return elapsed. Also need to return result? Problem says \"並回傳結果 (四捨五入到小數點 3 位)\" likely return time, not result. But maybe also return function result? The spec: \"用來測量函數 func 執行所需的秒數，並回傳結果\" means return the measured seconds. So return elapsed. Provide steps.\n\nWe need to use virtual code. Should we include import? Might include Step: Import time module. Then Step: 定義 measure_time. Then within, start time = time.time(). Then call func. Then end time. elapsed = end - start. rounded = round(elapsed, 3). Return rounded. End.\n\nWe should use Start/End. Provide Decision? None needed. Just linear.\n\nLet's produce each line with arrow. Use appropriate formatting.\n\nLet's write:\n\nStart\n→ Step 1: Import time module // 引入 time\n→ Step 2: Define function measure_time(func, *args) // 建立測量時間的函式\n→ Step 3: Record start_time = time.time() // 紀錄起始時間\n→ Step 4: Execute result = func(*args) // 執行傳入函式\n→ Step 5: Record end_time = time.time() // 紀錄結束時間\n→ Step 6: Calculate elapsed = end_time - start_time // 計算耗時\n→ Step 7: Round elapsed to 3 decimal places rounded_time = round(elapsed, 3) // 四捨五入\n→ Step 8: Return rounded_time // 回傳測量結果\nEnd\n\nMaybe include comment for result variable. We should note that result is not used. But maybe we could store.\n\nThat's good.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 引入 time 模組以使用 time.time()  \n→ Step 2: Define function measure_time(func, *args) // 建立用於測量時間的函式  \n→ Step 3: Record start_time = time.time() // 紀錄函式執行前的時間  \n→ Step 4: Execute result = func(*args) // 執行傳入的函式並取得其回傳值（此值不作進一步處理）  \n→ Step 5: Record end_time = time.time() // 紀錄函式執行後的時間  \n→ Step 6: Calculate elapsed = end_time - start_time // 計算耗時（秒）  \n→ Step 7: Round elapsed to 3 decimal places rounded_time = round(elapsed, 3) // 將耗時四捨五入到小數點第三位  \n→ Step 8: Return rounded_time // 回傳測量得到的秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"orange\",\"melon\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'orange', 'melon', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取所有輸入，雖然本題不需要使用它\n    sys.stdin.read()\n\n    # 初始化集合\n    fruits = {'apple', 'banana'}\n\n    # 新增單一元素\n    fruits.add('orange')\n\n    # 一次新增多個元素\n    fruits.update(['grape', 'melon'])\n\n    # 移除指定元素（若不存在會拋錯）\n    fruits.remove('banana')\n\n    # 嘗試移除不存在元素，安全不報錯\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Each line: virtual code step + space + // explanation.\n\nInclude Start, End, Decision? But here no decision needed. Just steps. Use arrow → for steps.\n\nWe must include arrow symbol for each step. Example: \"→ Step 1: ...\".\n\nMake sure each line contains virtual code step, space, // explanation.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 定義集合 fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增單一元素\n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增多個元素\n→ Step 4: fruits.remove('banana') // 移除指定元素，若不存在會錯誤\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在元素，安全不報錯\n→ Step 6: print(fruits) // 輸出最終集合\nEnd // 程式結束\n\nCheck format: Each line: \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nNeed to ensure arrow '→' before each step after Start. Provide arrow on each line.\n\nThus produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義集合 fruits = {'apple', 'banana'} // 初始化 fruits 集合  \n→ Step 2: fruits.add('orange') // 新增單一元素 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增多個元素 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 移除 'banana'，若不存在會拋錯誤  \n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在元素 'pineapple'，不會拋錯誤  \n→ Step 6: print(fruits) // 輸出最終集合 fruits  \nEnd // 程式結束執行"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate():\n    \"\"\"向匯率 API 取得 USD→TWD 匯率並回傳。\"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        resp = requests.get(url, timeout=5)\n        resp.raise_for_status()\n        data = resp.json()\n        rate = data['rates']['TWD']\n        return rate\n    except Exception:\n        return None\n\ndef update_label(label):\n    \"\"\"更新 Tkinter Label 的文字並回傳匯率值。\"\"\"\n    rate = fetch_rate()\n    if rate is not None:\n        label.config(text=f'目前美元匯率：約 {rate} TWD')\n    else:\n        label.config(text='更新失敗，請檢查網路連線')\n    return rate\n\ndef main():\n    # 讀取 stdin 的輸入指令\n    user_input = sys.stdin.read().strip()\n\n    # 建立 Tkinter 視窗\n    win = tk.Tk()\n    win.title('匯率查詢')\n\n    # Label 用於顯示匯率\n    rate_label = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\n    rate_label.pack(pady=10)\n\n    # 更新按鈕\n    def on_update():\n        update_label(rate_label)\n\n    update_btn = tk.Button(win, text='更新匯率', command=on_update)\n    update_btn.pack(pady=5)\n\n    # 若 stdin 包含「更新」關鍵字，直接更新匯率並輸出結果\n    if '更新' in user_input:\n        rate = update_label(rate_label)\n        if rate is not None:\n            print(f'目前美元匯率：約 {rate} TWD')\n        else:\n            print('更新失敗，請檢查網路連線')\n\n    # 啟動 Tkinter 主事件迴圈\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following format: each line \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. We should produce step-by-step virtual pseudocode for a Tkinter app that uses requests to get JSON, get TWD rate, display in window, button to update. No actual code, just steps.\n\nWe need to include Start, End, Decision. Provide logic steps: import modules, define function fetch_rate, create main window, create label, button, command to update, set loop. No actual code.\n\nWe'll produce each line. Ensure each line ends with comment. Use arrow '→'.\n\nLet's craft.\n\nWe might need Decision? For example, if request success. Use Decision: if response ok.\n\nAlso we need to show updating UI.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 匯入 requests 與 tkinter 模組 // 引入必要的庫\n→ Step 2: 定義函式 fetch_rate() // 取得匯率的函式\n→ Decision: 是否成功發送 GET 請求? // 檢查網路請求是否成功\n    Yes → Step 3: 從回應 JSON 取得 'rates' → 'TWD' // 擷取台幣匯率\n    No  → Step 4: 回傳 None // 若失敗則回傳空值\n→ Step 5: 建立主視窗 root = tkinter.Tk() // 初始化 Tkinter 視窗\n→ Step 6: 設定視窗標題 'USD to TWD 匯率' // 給視窗一個標題\n→ Step 7: 建立 Label rate_label 顯示 '請按下更新' // 預設文字\n→ Step 8: 建立 Button update_btn 呼叫 fetch_rate() 並更新 Label // 按鈕功能\n→ Step 9: 放置 Label 與 Button 於視窗中 // UI 布局\n→ Step 10: 執行 root.mainloop() // 啟動事件迴圈\nEnd // 程式執行結束\n\nBut must include arrow for each line. For Step 5 maybe use \"→ Step 5: ...\" etc. Provide arrow for each step. Use \"Step\" maybe but arrow.\n\nNeed to format like:\n\nStart // 程式開始執行\n→ Step 1: ... // explanation\n\nMake sure each line includes arrow or Start, End. Use \"Step 1\" etc. Also include Decision block.\n\nWe must use \"Decision:\" arrow as per sample.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Step 1: 匯入 requests 與 tkinter 模組 // 引入必要的庫\n→ Step 2: 定義函式 fetch_rate() // 取得匯率的函式\n    → Decision: 發送 GET 請求成功? // 檢查網路請求是否成功\n        Yes → Step 3: 取得 JSON 資料 // 從回應取得資料\n            → Step 4: 取得 rates[TWD] 值 // 擷取台幣匯率\n            → Step 5: 回傳匯率值 // 返回匯率\n        No  → Step 6: 回傳 None // 失敗時回傳 None\n→ Step 7: 建立 Tkinter 視窗 root // 初始化主視窗\n→ Step 8: 設定視窗標題 // 給視窗一個標題\n→ Step 9: 建立 Label rate_label 初始文字 '請按下更新' // 顯示文字\n→ Step 10: 定義 update_rate() 呼叫 fetch_rate() 並更新 Label // 更新匯率\n→ Step 11: 建立 Button update_btn 並綁定 update_rate() // 按鈕觸發\n→ Step 12: 放置 rate_label 與 update_btn 至視窗 // UI 布局\n→ Step 13: 執行 root.mainloop() // 啟動事件迴圈\nEnd // 程式執行結束\n\nWe might combine steps but that's fine.\n\nMake sure each line ends with comment. Ensure arrow \"→\" before each step except Start and End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 requests 與 tkinter 模組 // 引入必要的庫  \n→ Step 2: 定義函式 fetch_rate() // 取得匯率的函式  \n → Decision: 發送 GET 請求成功? // 檢查網路請求是否成功  \n  Yes → Step 3: 取得 JSON 資料 // 從回應取得資料  \n   → Step 4: 取得 rates[TWD] 值 // 擷取台幣匯率  \n   → Step 5: 回傳匯率值 // 返回匯率  \n  No → Step 6: 回傳 None // 失敗時回傳 None  \n→ Step 7: 建立 Tkinter 視窗 root = tkinter.Tk() // 初始化主視窗  \n→ Step 8: 設定視窗標題 'USD to TWD 匯率' // 給視窗一個標題  \n→ Step 9: 建立 Label rate_label 初始文字 '請按下更新' // 顯示文字  \n→ Step 10: 定義 update_rate() 呼叫 fetch_rate() 並更新 rate_label // 更新匯率  \n→ Step 11: 建立 Button update_btn 並綁定 update_rate() // 按鈕觸發  \n→ Step 12: 放置 rate_label 與 update_btn 至視窗 // UI 布局  \n→ Step 13: 執行 root.mainloop() // 啟動事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[None,[1,0],[2,0],[0,0],None,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[None, [1, 0], [2, 0], [0, 0], None, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, n_rows: int, n_cols: int):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols          # 仍為 0 的格子數\n        self.flipped = {}                    # 追蹤已交換的索引\n\n    def flip(self):\n        # 隨機選取剩餘格子\n        r = random.randint(0, self.total - 1)\n        # 取得實際索引\n        x = self.flipped.get(r, r)\n        # 把選中的格子從剩餘中移除\n        self.total -= 1\n        # 更新映射：把 r 指向最後一個剩餘索引\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 將輸入分成兩個列表：方法名和對應參數\n    split_index = data.find('],')\n    if split_index == -1:\n        raise ValueError(\"Input format error\")\n\n    first_part = data[:split_index + 1]          # 包含第一個列表結尾的 ']'\n    second_part = data[split_index + 2:].strip() # 跳過 ', ' 之後的第二個列表\n\n    methods = ast.literal_eval(first_part)\n    args = ast.literal_eval(second_part)\n\n    outputs = []\n    obj = None\n\n    for method, arg in zip(methods, args):\n        if method == \"Solution\":\n            obj = Solution(*arg)\n            outputs.append(None)\n        elif method == \"flip\":\n            outputs.append(obj.flip())\n        elif method == \"reset\":\n            obj.reset()\n            outputs.append(None)\n        else:\n            outputs.append(None)  # 若出現未知方法，可視為無操作\n\n    print(outputs)",
      "virtual_code": "Thinking...\nWe need to output pseudocode step-by-step. Provide algorithm: use reservoir? Actually typical solution: treat matrix flattened into list of indices 0..m*n-1. Use a mapping dictionary to store swapped indices when picking. Keep count of remaining zeros. On flip: generate random integer r in [0, remaining-1], then map r to real index: if mapping has r, use mapping[r], else r. Similarly get last index = remaining-1, map last if exists. Update mapping: mapping[r] = mapping.get(last, last). Decrease remaining. Return row,col derived from index. reset: clear mapping, set remaining = m*n. Complexity O(1). Need to minimize random calls: just one per flip. Use pseudocode accordingly.\n\nNow produce step-by-step pseudocode lines with explanations.\n\nNeed to use Start, End, Decision, etc.\n\nWe also need to include the class definition, constructor, flip, reset.\n\nLet's produce lines like:\n\nStart // 程式開始\n→ Step 1: 定義 class Solution // 建立類別\n→ Step 2: 在 constructor Solution(m, n): // 初始化\n    → Step 2.1: Set this.m = m, this.n = n\n    → Step 2.2: Set this.total = m * n\n    → Step 2.3: Set this.remaining = this.total\n    → Step 2.4: Initialize empty mapping dict // 追蹤已交換的索引\n\n→ Step 3: Define method flip()\n    → Step 3.1: Generate random integer r in [0, this.remaining - 1] // 隨機選取剩餘空格\n    → Step 3.2: Decision: 若 mapping contains r?\n        Yes → Step 3.3: idx = mapping[r] // 取得實際索引\n        No  → Step 3.4: idx = r\n    → Step 3.5: last = this.remaining - 1\n    → Step 3.6: Decision: 若 mapping contains last?\n        Yes → Step 3.7: lastIdx = mapping[last]\n        No  → Step 3.8: lastIdx = last\n    → Step 3.9: Update mapping: mapping[r] = lastIdx // 把 r 指向 lastIdx\n    → Step 3.10: Decrement this.remaining\n    → Step 3.11: Compute row = idx / this.n, col = idx % this.n\n    → Step 3.12: Return [row, col]\n\n→ Step 4: Define method reset()\n    → Step 4.1: Clear mapping // 重新置空\n    → Step 4.2: Set this.remaining = this.total\n\nEnd // 程式執行結束\n\nWe need each line as \"虛擬碼步驟 // 解釋\". Use arrow. Provide indentation maybe but arrow needed.\n\nLet's format each line.\n\nMake sure each line separate.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 定義 class Solution // 建立類別  \n→ Step 2: 在 constructor Solution(m, n): // 初始化物件  \n    → Step 2.1: Set this.m = m, this.n = n // 儲存矩陣尺寸  \n    → Step 2.2: Set this.total = m * n // 總格子數  \n    → Step 2.3: Set this.remaining = this.total // 仍為 0 的格子數  \n    → Step 2.4: Initialize empty mapping dict // 追蹤已交換的索引  \n→ Step 3: 定義方法 flip() // 隨機翻轉 0 為 1  \n    → Step 3.1: 產生隨機整數 r ∈ [0, this.remaining - 1] // 選取剩餘格子  \n    → Step 3.2: Decision: 若 mapping 包含 r? // 判斷是否已映射  \n        Yes → Step 3.3: idx = mapping[r] // 取得實際索引  \n        No  → Step 3.4: idx = r // 直接使用 r  \n    → Step 3.5: last = this.remaining - 1 // 最後一個剩餘索引  \n    → Step 3.6: Decision: 若 mapping 包含 last? // 判斷 last 是否映射  \n        Yes → Step 3.7: lastIdx = mapping[last] // 取得實際索引  \n        No  → Step 3.8: lastIdx = last // 直接使用 last  \n    → Step 3.9: 更新 mapping: mapping[r] = lastIdx // 把 r 指向 lastIdx  \n    → Step 3.10: 減少 this.remaining 1 // 已翻轉一格  \n    → Step 3.11: 計算 row = idx / this.n, col = idx % this.n // 轉回行列  \n    → Step 3.12: 返回 [row, col] // 交回隨機索引  \n→ Step 4: 定義方法 reset() // 重置矩陣  \n    → Step 4.1: 清空 mapping // 移除所有映射  \n    → Step 4.2: 設定 this.remaining = this.total // 重回全部格子  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg7vq25cq.py\", line 42, in <module>\n    obj.buildDict(arg)\n  File \"/tmp/tmpg7vq25cq.py\", line 13, in buildDict\n    pattern = word[:i] + '*' + word[i+1:]\n              ~~~~~~~~~^~~~~\nTypeError: can only concatenate list (not \"str\") to list"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MagicDictionary:\n    def __init__(self):\n        self.patterns = {}\n\n    def buildDict(self, dictionary):\n        \"\"\"Build mapping from wildcard pattern to set of words.\"\"\"\n        self.patterns.clear()\n        for word in dictionary:\n            for i in range(len(word)):\n                pattern = word[:i] + '*' + word[i+1:]\n                self.patterns.setdefault(pattern, set()).add(word)\n\n    def search(self, searchWord):\n        \"\"\"Return True if exactly one char change makes searchWord match a word in dictionary.\"\"\"\n        for i in range(len(searchWord)):\n            pattern = searchWord[:i] + '*' + searchWord[i+1:]\n            if pattern in self.patterns:\n                for candidate in self.patterns[pattern]:\n                    if candidate != searchWord:\n                        return True\n        return False\n\nif __name__ == \"__main__\":\n    # Read the entire stdin and parse the two lists of operations and arguments\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n    # Wrap with parentheses to form a tuple for literal_eval\n    data = ast.literal_eval('(' + raw + ')')\n    ops, args = data\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == 'MagicDictionary':\n            obj = MagicDictionary()\n            result.append(None)\n        elif op == 'buildDict':\n            obj.buildDict(arg)\n            result.append(None)\n        elif op == 'search':\n            result.append(obj.search(arg))\n        else:\n            # Unknown operation; ignore or handle as needed\n            result.append(None)\n\n    # Format output similar to Leetcode JSON representation\n    out_parts = []\n    for val in result:\n        if val is None:\n            out_parts.append('null')\n        elif val is True:\n            out_parts.append('true')\n        elif val is False:\n            out_parts.append('false')\n        else:\n            out_parts.append(str(val))\n    print('[' + ', '.join(out_parts) + ']')",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for the MagicDictionary class implementation with methods. Each line with arrow etc. Provide explanation after each line. Ensure no real code, just virtual steps. Let's design algorithm: Build a dictionary map from generic patterns with wildcard char to set of words. On search, iterate each position replace with wildcard, check if any word matches and count differences. But easier: brute force: iterate over dictionary words, compare char difference count, if exactly one, return true. But we can propose efficient approach: precompute patterns with one char replaced by '*' for each word. Then searchWord: for each position, generate pattern, if pattern exists and there is any word different from searchWord itself, return true. Also consider that if dictionary contains searchWord exactly, we need to ensure at least one word differs in one char. We check that pattern exists and word set size >1 or word != searchWord. Let's produce pseudocode accordingly.\n\nWe need to output line by line with \"→\" arrows and comments. The pseudocode must reflect class, methods, data structure initialization, buildDict, search.\n\nLet's start:\n\nStart // Program start? We'll have Start at class initialization? Use Start to indicate class constructor? We'll have:\n\nStart // Define MagicDictionary class\n\n→ Step 1: Define data member patternMap // Map from pattern string to set of words\n\n→ Step 2: Constructor MagicDictionary() // Initialize empty patternMap\n\n→ Step 3: End // constructor\n\nBut they want to define methods.\n\nLet's produce:\n\nStart // MagicDictionary class definition\n→ Step 1: Declare patternMap: Map<string, Set<string>> // Stores patterns with wildcard\n→ Step 2: Define Constructor MagicDictionary() // Initializes empty patternMap\n    → Step 2a: patternMap ← new Map() // Empty map\n→ Step 3: Define Method buildDict(dictionary) // Build patternMap from dictionary\n    → Step 3a: For each word in dictionary\n        → Step 3a1: For i from 0 to length(word)-1\n            → Step 3a1a: pattern ← word with character at i replaced by '*'\n            → Step 3a1b: If pattern not in patternMap\n                → Step 3a1b1: patternMap[pattern] ← new Set()\n            → Step 3a1c: patternMap[pattern].add(word)\n→ Step 4: Define Method search(searchWord) // Check if can change one char\n    → Step 4a: For i from 0 to length(searchWord)-1\n        → Step 4a1: pattern ← searchWord with character at i replaced by '*'\n        → Step 4a2: If pattern exists in patternMap\n            → Step 4a3: For each candidate in patternMap[pattern]\n                → Step 4a3a: If candidate ≠ searchWord\n                    → Step 4a3b: Return true\n    → Step 4b: Return false // No valid word found\nEnd // Class definition ends\n\nNeed to format exactly as specified: each line with \"虛擬碼步驟\" + space + comment. Use arrow. Should have indentation with spaces. Use \"→\" for arrows. Use \"Decision:\" for conditional. Use \"Yes →\" \"No →\". Let's adapt to requirement: they want arrow for structure. We can use \"Decision:\" for if condition, with \"Yes →\" and \"No →\". But simple \"If\" with arrow also okay. But we should adhere.\n\nLet's produce:\n\nStart // 定義 MagicDictionary 類別\n→ Step 1: Declare patternMap: Map<string, Set<string>> // 用來儲存以 '*' 為通配符的模式\n→ Step 2: Define Constructor MagicDictionary() // 建構子\n    → Decision: patternMap 是否已初始化? // 檢查\n        Yes → End // 已初始化，結束\n        No  → Step 2a: patternMap ← new Map() // 初始化空 Map\n→ Step 3: Define Method buildDict(dictionary: String[]) // 建立資料結構\n    → Step 3a: For each word in dictionary // 逐字建立模式\n        → Decision: i 0 to len(word)-1? // 遍歷每個字元位置\n            Yes → Step 3a1: pattern ← word with char i replaced by '*'\n            Yes → Step 3a2: If pattern not in patternMap\n                Yes → Step 3a2a: patternMap[pattern] ← new Set()\n                No  → \n            Yes → Step 3a3: patternMap[pattern].add(word)\n→ Step 4: Define Method search(searchWord: String): bool // 搜尋\n    → Step 4a: For i 0 to len(searchWord)-1\n        → Decision: pattern exists in patternMap?\n            Yes → Step 4a1: For each candidate in patternMap[pattern]\n                → Decision: candidate ≠ searchWord?\n                    Yes → Return true // 找到符合條件的單字\n                    No  → \n        No  →\n    → Return false // 未找到符合條件\nEnd // 完成\n\nBut we need each line explicit arrow. Let's produce line by line:\n\nStart // 定義 MagicDictionary 類別\n→ Step 1: patternMap ← new Map() // 建立用於儲存模式的 Map\n→ Step 2: Define MagicDictionary() // 建構子，初始化 patternMap\n    → Decision: patternMap 是否已存在? // 檢查是否已初始化\n        Yes → End // 已存在，無需再初始化\n        No  → Step 2a: patternMap ← new Map() // 初始化空 Map\n→ Step 3: Define buildDict(dictionary) // 建立資料結構\n    → Step 3a: For each word in dictionary\n        → Step 3a1: For i from 0 to length(word)-1\n            → Step 3a1a: pattern ← word with char i replaced by '*'\n            → Step 3a1b: If pattern not in patternMap\n                Yes → Step 3a1b1: patternMap[pattern] ← new Set()\n                No  → \n            → Step 3a1c: patternMap[pattern].add(word)\n→ Step 4: Define search(searchWord) // 搜尋是否能改一個字符合字典\n    → Step 4a: For i from 0 to length(searchWord)-1\n        → Step 4a1: pattern ← searchWord with char i replaced by '*'\n        → Step 4a2: If pattern exists in patternMap\n            Yes → Step 4a3: For each candidate in patternMap[pattern]\n                → Decision: candidate ≠ searchWord?\n                    Yes → Return true // 找到符合條件\n                    No  → \n            No  →\n    → Return false // 沒有符合條件的字\nEnd // MagicDictionary 定義結束\n\nBut we used \"Yes →\" \"No →\" inside decision; they ask for \"Decision:\" and then Yes/No. We have some decisions incorrectly formatted. Need to adhere:\n\nUse \"Decision:\" then Yes → ... No → ... Indent.\n\nLet's reformat properly:\n\nStart // 定義 MagicDictionary 類別\n→ Step 1: patternMap ← new Map() // 用於儲存通配符模式到單字集合的映射\n→ Step 2: Define MagicDictionary() // 建構子\n    → Decision: patternMap 已初始化?\n        Yes → End // 已初始化，結束\n        No  → Step 2a: patternMap ← new Map() // 初始化空 Map\n→ Step 3: Define buildDict(dictionary)\n    → Step 3a: For each word in dictionary\n        → Step 3a1: For i from 0 to length(word)-1\n            → Step 3a1a: pattern ← word with char i replaced by '*'\n            → Decision: pattern 存在於 patternMap?\n                Yes → \n                No  → Step 3a1b: patternMap[pattern] ← new Set() // 新建集合\n            → Step 3a1c: patternMap[pattern].add(word) // 加入單字\n→ Step 4: Define search(searchWord)\n    → Step 4a: For i from 0 to length(searchWord)-1\n        → Step 4a1: pattern ← searchWord with char i replaced by '*'\n        → Decision: pattern 存在於 patternMap?\n            Yes → Step 4a2: For each candidate in patternMap[pattern]\n                → Decision: candidate ≠ searchWord?\n                    Yes → Return true // 找到符合條件\n                    No  → \n            No  →\n    → Return false // 未找到符合條件的單字\nEnd // MagicDictionary 定義結束\n\nNeed to ensure each line includes arrow '→' at beginning. The first line \"Start\" has no arrow. But we can keep as in example: Start //. After that, each subsequent line starts with arrow. However in example, they had \"Start\" without arrow, then \"→ Step 1: ...\". So keep that. So first line Start. Then arrow lines.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 定義 MagicDictionary 類別  \n→ Step 1: patternMap ← new Map() // 用於儲存以 '*' 為通配符的模式到單字集合的映射  \n→ Step 2: Define MagicDictionary() // 建構子  \n  Decision: patternMap 已初始化?  \n   Yes → End // 已初始化，結束  \n   No  → Step 2a: patternMap ← new Map() // 初始化空 Map  \n→ Step 3: Define buildDict(dictionary) // 建立資料結構  \n  Step 3a: For each word in dictionary  \n   Step 3a1: For i from 0 to length(word)-1  \n    Step 3a1a: pattern ← word with char i replaced by '*' // 生成通配符模式  \n    Decision: pattern 存在於 patternMap?  \n     Yes →  \n     No  → Step 3a1b: patternMap[pattern] ← new Set() // 新建集合  \n    Step 3a1c: patternMap[pattern].add(word) // 加入單字到集合  \n→ Step 4: Define search(searchWord) // 搜尋是否能改一個字符合字典  \n  Step 4a: For i from 0 to length(searchWord)-1  \n   Step 4a1: pattern ← searchWord with char i replaced by '*'  \n   Decision: pattern 存在於 patternMap?  \n    Yes → Step 4a2: For each candidate in patternMap[pattern]  \n     Decision: candidate ≠ searchWord?  \n      Yes → Return true // 找到符合條件的單字  \n      No  →  \n    No  →  \n  Return false // 未找到符合條件的單字  \nEnd // MagicDictionary 定義結束"
    },
    {
      "title": "IPO",
      "source_file": "Leetcode/leetcode502.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphydrmm05.py\", line 46, in <module>\n    k, w, profits, capital = parse_input(raw_input)\n                             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmphydrmm05.py\", line 40, in parse_input\n    vals[key] = eval(val)\n                ^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbz9560f4.py\", line 46, in <module>\n    k, w, profits, capital = parse_input(raw_input)\n                             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbz9560f4.py\", line 40, in parse_input\n    vals[key] = eval(val)\n                ^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport heapq\n\ndef maximize_capital(k, w, profits, capital):\n    # 把項目按所需資本升序排序\n    projects = sorted(zip(capital, profits))\n    max_heap = []            # 儲存可執行項目的利潤（最大堆）\n    i = 0\n    n = len(profits)\n\n    for _ in range(k):\n        # 把所有目前可執行的項目加入堆中\n        while i < n and projects[i][0] <= w:\n            heapq.heappush(max_heap, -projects[i][1])  # 以負值做最大堆\n            i += 1\n        if not max_heap:\n            break\n        # 取利潤最大的項目，更新資本\n        w += -heapq.heappop(max_heap)\n    return w\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如:\n    k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n    的輸入，返回 (k, w, profits, capital)\n    \"\"\"\n    parts = data.replace('\\n', ' ').split(',')\n    vals = {}\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        if key in ('k', 'w'):\n            vals[key] = int(val)\n        else:\n            # 直接 eval 解析列表\n            vals[key] = eval(val)\n    return vals['k'], vals['w'], vals['profits'], vals['capital']\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        k, w, profits, capital = parse_input(raw_input)\n        result = maximize_capital(k, w, profits, capital)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: maximize capital after at most k projects, each project has required capital and profit. Classic LeetCode 502. Approach: use min-heap for capital to get projects affordable, max-heap for profits. Steps: sort projects by capital ascending; iterate k times: while projects capital <= current capital, push profit to max-heap; if max-heap empty break; pop max profit and add to capital. Return capital.\n\nWe produce virtual code line by line with explanation.\n\nWe need to use the specified format: each line: \"虛擬碼步驟 // 解釋\". Use arrows and decision structure. Ensure we use Start, End. We must not output actual code but pseudo steps.\n\nLet's craft lines.\n\n- Start // 開始\n- → Step 1: 整理項目列表並依所需資本升序排序 // 為便於取可執行項目\n- → Step 2: 初始化可執行項目的索引 i = 0 // 指向排序後列表中首項\n- → Step 3: 初始化最大利潤優先佇列 profitPQ // 取最大利潤的項目\n- → Step 4: 迴圈 for 次數 = 1 to k // 至多執行 k 個項目\n-   → Decision: 若 profitPQ 為空? // 檢查是否仍有可選項目\n-       No  → Step 5: 取得當前資本 curCapital // 當前可用資本\n-           → Decision: 仍有項目且項目所需資本 ≤ curCapital? // 判斷是否能加入佇列\n-               Yes → Step 6: 將該項目的利潤 push 至 profitPQ // 將可執行項目加入\n-                    → Step 7: i++ // 移至下一個項目\n-                    → 再回到 Decision: 仍有項目且項目所需資本 ≤ curCapital? // 重複加入所有可執行項目\n-               No  → Step 8: pop profit from profitPQ // 取最大利潤的項目\n-                    → Step 9: curCapital += profit // 加入利潤到資本\n-                    → 迴圈結束一次\n-       Yes → End // 若 profitPQ 為空則無法再進行項目，結束\n- End // 回傳最終資本\n\nBut need to follow format: use arrows. We must include \"→\" for steps, \"Decision:\" for decisions, with Yes → and No →.\n\nLet's structure:\n\nStart\n→ Step 1: 將項目組合 (capital[i], profits[i]) 按需資本升序排序 // 方便找可行項目\n→ Step 2: i = 0 // 索引指向排序後項目中第一個\n→ Step 3: profitPQ = 空最大堆 // 儲存可行項目的利潤\n→ Step 4: curCapital = w // 初始資本\n→ Step 5: for loop 1..k // 至多 k 次選項\n   → Decision: profitPQ 是否為空? // 判斷是否還有可選利潤\n      Yes → End // 無可選項目，提前結束\n      No →\n         → Step 6: while i < n 且 projects[i].capital ≤ curCapital\n            → Step 7: profitPQ.push(projects[i].profit) // 加入可行項目利潤\n            → Step 8: i++ // 進入下一項目\n         → Step 9: maxProfit = profitPQ.pop() // 取最大利潤\n         → Step 10: curCapital += maxProfit // 更新資本\n→ End // 迴圈完成\n→ Step 11: return curCapital // 最終最大資本\n\nWe must ensure each line has the arrow and explanation. Need to ensure correct indentation? The example uses indentation for nested steps. We can just indent by spaces. The requirement: use virtual code arrow \"→\", \"Decision:\" and \"Yes →\", \"No →\". Provide explanation after //. So lines that are decisions should have \"Decision:\".\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將項目 (capital[i], profits[i]) 按需資本升序排序 // 方便快速找出可執行項目  \n→ Step 2: i = 0 // 指向排序後列表的第一個項目  \n→ Step 3: profitPQ = 空最大堆 // 儲存所有可執行項目的利潤  \n→ Step 4: curCapital = w // 初始可用資本  \n→ Step 5: for loop 1 to k // 最多執行 k 個項目  \n  → Decision: profitPQ 是否為空? // 檢查是否還有可選項目  \n   Yes → End // 若空，無法再選項目，結束迴圈  \n   No  →  \n    → Step 6: while i < n 且 projects[i].capital ≤ curCapital  \n     → Step 7: profitPQ.push(projects[i].profit) // 將可執行項目的利潤加入堆  \n     → Step 8: i++ // 移到下一個項目  \n     → 再回到 while 判斷 // 重複加入所有目前可執行項目  \n    → Step 9: maxProfit = profitPQ.pop() // 取堆中最大利潤  \n    → Step 10: curCapital += maxProfit // 加入利潤到資本  \n    → 迴圈結束一次  \n→ End // 迴圈結束或提前結束  \n→ Step 11: return curCapital // 最終最大資本值  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()()\", \"(a())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"Return all unique valid strings after removing minimum parentheses.\"\"\"\n        def is_valid(st: str) -> bool:\n            count = 0\n            for ch in st:\n                if ch == '(':\n                    count += 1\n                elif ch == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        # BFS over levels of strings\n        current_level = {s}\n        while current_level:\n            # 先檢查目前層級是否有合法字串\n            valid = [st for st in current_level if is_valid(st)]\n            if valid:\n                return valid\n            # 產生下一層級\n            next_level = set()\n            for item in current_level:\n                for i in range(len(item)):\n                    if item[i] in ('(', ')'):\n                        next_item = item[:i] + item[i+1:]\n                        next_level.add(next_item)\n            current_level = next_level\n        return []\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 解析輸入字串：若包含單/雙引號則取引號內內容\n    match = re.search(r'\"([^\"]*)\"', raw_input) or re.search(r\"'([^']*)'\", raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        s = raw_input\n\n    # 呼叫解法\n    sol = Solution()\n    results = sol.removeInvalidParentheses(s)\n\n    # 輸出結果為 JSON 陣列格式\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line. The user wants solution for removing invalid parentheses minimal removals and returning list of unique valid strings. This is classic LeetCode problem 301. We need algorithm: BFS or DFS with pruning. Provide steps.\n\nWe produce virtual code lines: Start, Step 1, Decision, etc. Use arrow. Provide explanation. No actual code. Let's produce BFS approach.\n\nPseudo steps:\n\nStart\n→ Step 1: 定義結果集合 res = {}\n→ Step 2: 定義已處理集合 visited = {}\n→ Step 3: 建立 BFS queue, 初始加入 s\n→ Decision: 如果 queue 為空? Yes → End else...\n→ Step 4: 取出 queue 的首元素 cur\n→ Decision: 如果 cur 為合法字串? Yes → Step 5: 若 res 之中不存在此字串，加入 res，並設定 found = true\n→ No → 如果 found 為 false，則 for i in 0..len(cur)-1:\n→ Decision: 如果 cur[i] 是 '(' 或 ')'?\n→ Step 6: 產生 new string = cur[:i] + cur[i+1:]\n→ Decision: 如果 new string 未在 visited? Yes → Step 7: 加入 visited, 加入 queue\n→ End (decision)\n→ End (loop)\n→ Step 8: 回傳 res 列表\n\nAlso, we need unique strings, use set.\n\nBut we must include minimal removals, BFS ensures minimal. Once we find first valid level, we stop adding deeper levels.\n\nSo we need a flag found. Steps: once found first level of valid strings, continue processing rest of current level but don't enqueue new strings.\n\nThus: After processing cur, if not found and cur is invalid, we generate next level. After we found at least one valid, we don't generate new level. That's typical BFS.\n\nAlso, need to maintain visited to avoid duplicates.\n\nExplain each line.\n\nLet's produce. Ensure each line ends with // explanation.\n\nAlso use arrows: \"→\".\n\nLet's produce pseudo-code. Use indentation. Use \"Decision:\" and Yes/No lines. Provide explanation after arrow. Provide proper formatting.\n\nWe'll write lines like:\n\nStart // 程式開始\n\n→ Step 1: 定義空集合 res // 用來存放所有合法字串\n\n→ Step 2: 定義空集合 visited // 用來避免重複處理相同字串\n\n→ Step 3: 建立 queue 並將 s 加入 // 開始 BFS\n\n→ Step 4: 定義布林變數 found = false // 旗標表示是否已找到合法字串\n\n→ Decision: queue 是否為空? Yes → End // BFS 完成\n\n…\n\nLet's craft full steps.\n\nAlso include \"If found true, skip generating next level\".\n\nImplement logic accordingly.\n\nAlso note: For each character removal, only remove parentheses.\n\nExplain uniqueness: use set.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 初始化空集合 res // 用來存放所有最小移除後合法的字串\n\n→ Step 2: 初始化空集合 visited // 用來避免重複處理相同字串\n\n→ Step 3: 建立佇列 queue 並把原始字串 s 入隊 // 開始 BFS\n\n→ Step 4: 設定布林變數 found = false // 旗標表示是否已找到合法字串\n\n→ Decision: 若 queue 為空? // 判斷 BFS 是否結束\n    Yes → End // 所有字串已處理完畢，結束程式\n    No  → // 進入主迴圈\n\n→ Step 5: 從 queue 取出前置字串 cur // 取得目前層級的字串\n\n→ Decision: 若 cur 為合法字串? // 檢查是否所有括號配對\n    Yes → Step 6: 若 cur 尚未存在於 res, 加入 res // 確保唯一性\n           → Step 7: 設定 found = true // 找到第一層級合法字串\n           → // 不再產生下一層級\n    No  → Decision: 若 found 為 false? // 僅在尚未找到合法字串時才延伸下一層級\n        Yes → // 產生下一層級的所有子字串\n              → Step 8: 對 i 從 0 到 len(cur)-1:\n                        → Decision: 若 cur[i] 為 '(' 或 ')'?\n                            Yes → Step 9: newStr = cur[:i] + cur[i+1:] // 刪除第 i 個括號\n                                   → Decision: 若 newStr 未在 visited?\n                                       Yes → Step 10: 加入 visited 並將 newStr 入隊 // 將新字串加入 BFS\n                                       No  → // 已處理過，略過\n                        No  → // 非括號，直接略過\n        No  → // found 為 true，已經找到合法字串，直接略過產生子字串\n\n→ Decision: 回到主迴圈檢查 queue 是否為空? // 重複上述流程\n\n→ Step 11: 將集合 res 轉為列表並返回 // 輸出所有唯一合法字串\n\nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder",
      "source_file": "Leetcode/leetcode127.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwocsol2k.py\", line 60, in <module>\n    main()\n  File \"/tmp/tmpwocsol2k.py\", line 46, in main\n    data = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwocsol2k.py\", line 42, in parse_input\n    return ast.literal_eval(s)\n           ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7a65cf4fbad0>"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_98zgo3w.py\", line 60, in <module>\n    main()\n  File \"/tmp/tmp_98zgo3w.py\", line 46, in main\n    data = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_98zgo3w.py\", line 42, in parse_input\n    return ast.literal_eval(s)\n           ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x70fc0bfffb50>"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\nimport ast\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: list) -> int:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return 0\n\n        queue = deque([(beginWord, 1)])  # (current word, current length)\n        visited = {beginWord}\n\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet and new_word not in visited:\n                        visited.add(new_word)\n                        queue.append((new_word, length + 1))\n        return 0\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Parse input that looks like:\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\"]\n    into a dictionary {'beginWord': 'hit', 'endWord': 'cog', 'wordList': [...]}.\n    \"\"\"\n    # Remove surrounding whitespace and newlines\n    s = input_str.strip()\n    if not s:\n        return {}\n    # Ensure it is a dict literal by adding braces\n    if not (s.startswith('{') and s.endswith('}')):\n        s = '{' + s + '}'\n    # Replace '=' with ':' for a valid dict syntax\n    s = s.replace('=', ':')\n    # Use literal_eval to safely evaluate\n    return ast.literal_eval(s)\n\ndef main():\n    raw_input = sys.stdin.read()\n    data = parse_input(raw_input)\n    if not data:\n        print(0)\n        return\n\n    beginWord = data.get('beginWord', '')\n    endWord = data.get('endWord', '')\n    wordList = data.get('wordList', [])\n\n    sol = Solution()\n    result = sol.ladderLength(beginWord, endWord, wordList)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps that solve the problem. It's essentially Word Ladder problem: find shortest transformation sequence length. We'll produce BFS.\n\nWe need to output step-by-step pseudo-code with comments, using arrow syntax, etc.\n\nWe must avoid actual code. Just steps. We'll include Start, End, Decision, loops.\n\nWe need to produce maybe like:\n\nStart // program begins\n→ Initialize set of words from wordList\n→ If endWord not in set → End 0\n→ Initialize queue with beginWord and level 1\n→ Initialize visited set\n→ While queue not empty:\n    → Dequeue current word, level\n    → For each character position i in word:\n        → For each letter 'a' to 'z':\n            → newWord = replace char\n            → If newWord equals endWord → Return level+1\n            → If newWord in wordSet and not visited:\n                → Mark visited\n                → Enqueue newWord, level+1\n→ Return 0 // no path\n\nWe need to use virtual code style with arrows, indent.\n\nWe need to use `→` for steps, `Decision:` for decisions. Use `Yes →`, `No →`. Provide short explanation in Chinese.\n\nMake sure each line is one step. Use indentation with spaces maybe 4 spaces after Decision.\n\nLet's produce. Ensure each line has \"虛擬碼步驟\" then space then `// 解釋/說明`. The step itself uses arrow arrow etc.\n\nExample: `Start // 程式開始執行`. Good.\n\nWe'll produce each step accordingly.\n\nLet's list lines:\n\n1. Start // 程式開始執行\n2. → Step 1: 將 wordList 轉成 set words // 方便 O(1) 查詢\n3. → Decision: endWord 是否在 words? // 確認目標字在字典中\n4.     Yes → Step 2: Return 0 // 沒有目標字，無法轉換\n5.     No  → Decision: beginWord 是否等於 endWord? // 直接相同\n6.         Yes → Step 3: Return 1 // 只需一個詞 (beginWord 本身)\n7.         No  → Step 4: 初始化 queue 為 [(beginWord, 1)] // (詞, 級別)\n8. → Step 5: 初始化 visited set 為 {beginWord} // 避免重複\n9. → Decision: queue 是否為空? // 若無詞可擴展\n10.    Yes → Step 6: Return 0 // 無路徑\n11.    No  → Step 7: 開始 BFS 迴圈\n12.        → While queue not空:\n13.            → Step 8: 取出 (currentWord, level) 來自 queue\n14.            → Step 9: 對 currentWord 的每個位置 i:\n15.                → Step 10: 對字母 'a' 到 'z':\n16.                    → Step 11: 生成 newWord 替換位置 i 為字母\n17.                    → Decision: newWord 是否等於 endWord?\n18.                        Yes → Step 12: Return level + 1 // 找到最短\n19.                        No  → Decision: newWord 是否在 words 且未訪問?\n20.                            Yes → Step 13: 加入 visited, enqueue (newWord, level+1)\n21.                            No  → // 跳過\n22. → Step 14: End // BFS 完成\n23. → Step 15: Return 0 // 沒有找到路徑\n\nBut we need proper arrow indent after Decision. Use 4 spaces indentation for branches. And each line should have `虛擬碼步驟` then space then comment.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 將 wordList 轉成 set words // 方便 O(1) 查詢\n→ Decision: endWord 是否在 words? // 確認目標字在字典中\n    Yes → Step 2: Return 0 // 沒有目標字，無法轉換\n    No  → Decision: beginWord 是否等於 endWord? // 直接相同\n        Yes → Step 3: Return 1 // 只需一個詞 (beginWord 本身)\n        No  → Step 4: 初始化 queue 為 [(beginWord, 1)] // (詞, 級別)\n→ Step 5: 初始化 visited set 為 {beginWord} // 避免重複\n→ Decision: queue 是否為空? // 若無詞可擴展\n    Yes → Step 6: Return 0 // 無路徑\n    No  → Step 7: 開始 BFS 迴圈\n        → While queue 不為空:\n            → Step 8: 取出 (currentWord, level) 來自 queue\n            → Step 9: 對 currentWord 的每個位置 i:\n                → Step 10: 對字母 'a' 到 'z':\n                    → Step 11: 生成 newWord 替換位置 i 為字母\n                    → Decision: newWord 是否等於 endWord?\n                        Yes → Step 12: Return level + 1 // 找到最短\n                        No  → Decision: newWord 是否在 words 且未訪問?\n                            Yes → Step 13: 加入 visited, enqueue (newWord, level+1)\n                            No  → // 跳過\n→ Step 14: End // BFS 完成\n→ Step 15: Return 0 // 沒有找到路徑\n```"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '457'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(reversed(res))\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract all digit sequences (handles formats like 'num1 = \"11\", num2 = \"123\"')\n    numbers = re.findall(r'\\d+', data)\n    if len(numbers) < 2:\n        return\n    num1, num2 = numbers[0], numbers[1]\n\n    solution = Solution()\n    result = solution.addStrings(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for adding two big integers represented as strings, without built-in big integer library or conversion to integer. Should do string addition, handling carry. Use reverse or index from end.\n\nWe produce lines like:\n\nStart\n→ Step 1: 將 num1、num2 轉為字符陣列 // 方便索引\n→ Step 2: 初始化 i = len(num1)-1, j = len(num2)-1, carry = 0, result = 空字符串 // 設定指標和攜帶\n→ Decision: i>=0 或 j>=0 或 carry>0? // 是否還有數字未處理\n   Yes → Step 3: digit1 = (i>=0) ? num1[i]-'0' : 0 // 取得 num1 的當前位\n   → Step 4: digit2 = (j>=0) ? num2[j]-'0' : 0 // 取得 num2 的當前位\n   → Step 5: sum = digit1 + digit2 + carry // 計算當前位和\n   → Step 6: carry = sum / 10 // 計算新攜帶\n   → Step 7: result = (sum % 10 as char) + result // 將位數加到結果前面\n   → Step 8: i--, j-- // 移動指標\n   → Decision: (same as step 2) // loop back\n   No → Step 9: output result // 回傳結果\nEnd\n\nWe need each line \"虛擬碼步驟 // 解釋\". The lines should be \"Start // ...\". Use arrow symbol for each step: \"→ Step ...\".\n\nUse decisions: \"Decision: if ...?\" with Yes → ... and No → ... accordingly.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 取得 num1 與 num2 的長度 len1, len2 // 獲取兩個字串長度\n→ Step 2: 初始化 i = len1-1, j = len2-1, carry = 0, result = 空字符串 // 設定指標、攜帶與結果\n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 是否還有位需要處理\n    Yes → Step 3: digit1 = (i >= 0) ? num1[i] - '0' : 0 // 從 num1 取數位，若已結束則為 0\n    → Step 4: digit2 = (j >= 0) ? num2[j] - '0' : 0 // 從 num2 取數位，若已結束則為 0\n    → Step 5: sum = digit1 + digit2 + carry // 計算兩數位與攜帶\n    → Step 6: carry = sum / 10 // 新的攜帶\n    → Step 7: result = (sum % 10 + '0') + result // 把計算出的數位加到結果前面\n    → Step 8: i = i - 1, j = j - 1 // 移動指標向左\n    → Decision: i >= 0 OR j >= 0 OR carry > 0? // 回到迴圈判斷\n        Yes → (loop back) // 繼續處理下一位\n        No  → Step 9: 輸出 result // 回傳相加結果\n    No → Step 9: 輸出 result // 若最初就沒有任何位，直接輸出空字串或 0\nEnd // 程式執行結束\n\nBut we need to be consistent: Each line with arrow. Decision has Yes → and No → lines inside. The \"loop back\" is not a real line; but we can just skip the recursion.\n\nWe might use \"→ Step 8: i = i - 1, j = j - 1 // 移動指標向左\" then \"→ Decision: ...\". Then under that decision: \"    Yes → ...\" but that will create a nested block. The pseudocode pattern earlier uses indentation: Yes → ... inside. So we need to follow that style.\n\nThus final pseudocode:\n\nStart // 程式開始執行\n→ Step 1: len1 = length(num1), len2 = length(num2) // 取得兩個字串長度\n→ Step 2: i = len1 - 1, j = len2 - 1, carry = 0, result = \"\" // 初始化指標、攜帶與結果\n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還有位要處理\n    Yes → Step 3: digit1 = (i >= 0) ? num1[i] - '0' : 0 // 從 num1 取位數，若已結束則為 0\n    → Step 4: digit2 = (j >= 0) ? num2[j] - '0' : 0 // 從 num2 取位數，若已結束則為 0\n    → Step 5: sum = digit1 + digit2 + carry // 計算本位之和\n    → Step 6: carry = sum / 10 // 計算新攜帶\n    → Step 7: result = (sum % 10 + '0') + result // 將本位數字加到結果前面\n    → Step 8: i = i - 1, j = j - 1 // 指標左移\n    → Decision: i >= 0 OR j >= 0 OR carry > 0? // 檢查是否需繼續\n        Yes → (loop) // 迴圈回到 Decision\n        No  → Step 9: output result // 輸出相加結果\n    No  → Step 9: output result // 初始時就無位需要處理，直接輸出\n\nEnd // 程式結束\n\nBut note: The \"loop\" is a placeholder; we can simply have the Decision: Yes → (go back to Decision) but not a real line. To stay consistent, we may not need the \"loop\" line; just end the block.\n\nBetter:\n\nStart // 程式開始執行\n→ Step 1: len1 = length(num1), len2 = length(num2) // 取得兩個字串長度\n→ Step 2: i = len1 - 1, j = len2 - 1, carry = 0, result = \"\" // 初始化指標、攜帶與結果\n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還有位要處理\n    Yes → Step 3: digit1 = (i >= 0) ? num1[i] - '0' : 0 // 取得 num1 的位數，若已結束則為 0\n    → Step 4: digit2 = (j >= 0) ? num2[j] - '0' : 0 // 取得 num2 的位數，若已結束則為 0\n    → Step 5: sum = digit1 + digit2 + carry // 計算本位之和\n    → Step 6: carry = sum / 10 // 更新攜帶\n    → Step 7: result = (sum % 10 + '0') + result // 將本位數字放到結果前面\n    → Step 8: i = i - 1, j = j - 1 // 指標左移\n    → Decision: i >= 0 OR j >= 0 OR carry > 0? // 檢查是否還需處理\n        Yes → (回到 Decision) // 迴圈持續\n        No  → Step 9: output result // 完成加法，輸出結果\n    No  → Step 9: output result // 沒有任何位，直接輸出\nEnd // 程式結束\n\nWe can include the \"loop\" line as comment: // 回到上一 Decision，實際上會再次評估條件\n\nBut it's fine.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: len1 = length(num1), len2 = length(num2) // 取得兩個字串長度  \n→ Step 2: i = len1 - 1, j = len2 - 1, carry = 0, result = \"\" // 初始化指標、攜帶與結果  \n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還有位需要處理  \n    Yes → Step 3: digit1 = (i >= 0) ? num1[i] - '0' : 0 // 從 num1 取位數，若已結束則為 0  \n    → Step 4: digit2 = (j >= 0) ? num2[j] - '0' : 0 // 從 num2 取位數，若已結束則為 0  \n    → Step 5: sum = digit1 + digit2 + carry // 計算本位之和  \n    → Step 6: carry = sum / 10 // 更新攜帶  \n    → Step 7: result = (sum % 10 + '0') + result // 把本位數字加到結果前面  \n    → Step 8: i = i - 1, j = j - 1 // 將指標往左移動  \n    → Decision: i >= 0 OR j >= 0 OR carry > 0? // 重新檢查是否還需處理  \n        Yes → (回到上一 Decision) // 迴圈持續  \n        No  → Step 9: output result // 完成加法，輸出結果  \n    No  → Step 9: output result // 初始時就沒有位需要處理，直接輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, nums):\n        # 保存原始陣列，供後續 pick 方法使用\n        self.nums = nums\n\n    def pick(self, target):\n        \"\"\"\n        隨機選取 nums 中等於 target 的索引，所有合法索引機率相等。\n        這裡使用「後備抽樣」(reservoir sampling) 的做法，避免事先建構\n        target 對應的索引清單。\n        \"\"\"\n        count = 0          # 目前已見到 target 的次數\n        chosen = -1        # 最終選擇的索引\n        for i, num in enumerate(self.nums):\n            if num == target:\n                count += 1\n                # 每看到一次 target，機率 1/count 更新 chosen\n                if random.randint(1, count) == 1:\n                    chosen = i\n        return chosen\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 把輸入字串包成 tuple 方便 literal_eval 解析\n    wrapped = f\"({raw_input})\"\n    ops, args = ast.literal_eval(wrapped)\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0])  # arg 為 [nums]，取第一個元素\n            result.append(None)     # LeetCode 風格輸出為 null\n        elif op == \"pick\":\n            res = obj.pick(arg[0])  # arg 為 [target]，取第一個元素\n            result.append(res)\n\n    # 輸出結果，使用 JSON 讓 null 能被正確顯示\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. For the described algorithm: store mapping of target to list of indices; or reservoir sampling. Since duplicates possible, we need equal probability. Use reservoir sampling when pick called: iterate over array, count occurrences of target, and choose index with probability 1/count. Complexity O(n) per pick. Implementation: constructor stores nums. pick method uses reservoir. Steps: Start, Step: Initialize count=0, chosenIndex=-1, iterate i over nums, if nums[i]==target, count++, if random number <= 1/count, set chosenIndex = i. Return chosenIndex. End.\n\nWe must produce each step as \"虛擬碼步驟 // 解釋\". Use arrows. Format: Start // ...; → Step 1: ...; etc. Provide decision? maybe no need. Just sequential. Use Start, End. Provide explanatory comments.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 保存傳入的陣列 `nums` 供後續使用 // 建構子將輸入陣列存入物件屬性  \n→ Step 2: 宣告並初始化變數 `count ← 0` 及 `chosenIndex ← -1` // `count` 用於計算目標值出現的次數，`chosenIndex` 用於儲存目前已選的索引  \n→ Step 3: 循環遍歷陣列 `nums`，索引從 0 到 `length-1` // 逐個檢查每個元素是否為目標值  \n  → Decision: 如果 `nums[i]` 等於目標 `target`? // 判斷目前索引是否符合目標  \n   Yes → Step 4: 將 `count` 加 1 // 目標值出現一次  \n   Yes → Step 5: 生成隨機實數 `r` 介於 0 與 1 之間 // 用於決定是否更新選擇  \n   Yes → Decision: 若 `r < 1 / count`? // 每一次出現都有機會取代前一次選擇，機率均等  \n    Yes → Step 6: 設置 `chosenIndex ← i` // 更新為新的隨機選擇索引  \n    No → Step 7: 不做任何操作 // 保留之前的選擇  \n   No → Step 8: 跳過此索引 // 不是目標值，直接往下  \n→ Step 9: 回傳 `chosenIndex` // 完成 pick 方法，返回符合條件且機率均等的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        找出陣列中最長的不常見子序列長度。\n        若不存在，回傳 -1。\n        \"\"\"\n        # 先按長度降序排列，確保先檢查較長的字串\n        strs_sorted = sorted(strs, key=len, reverse=True)\n\n        for s in strs_sorted:\n            # 檢查 s 是否是其他任何字串的子序列\n            is_sub = False\n            for t in strs:\n                if s == t:          # 與自身不算\n                    continue\n                if self.is_subsequence(s, t):\n                    is_sub = True\n                    break\n            if not is_sub:          # 找到不常見子序列\n                return len(s)\n\n        return -1\n\n    @staticmethod\n    def is_subsequence(s, t):\n        \"\"\"\n        判斷 s 是否為 t 的子序列。\n        \"\"\"\n        it = iter(t)\n        return all(ch in it for ch in s)\n\nif __name__ == \"__main__\":\n    # 讀取整行輸入，例如 '[\"aba\",\"cdc\",\"eae\"]'\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(-1)\n    else:\n        # 使用 ast.literal_eval 安全解析字串為 list\n        strs = ast.literal_eval(raw_input)\n        sol = Solution()\n        result = sol.findLUSlength(strs)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps line by line, with arrow, etc. For given problem: longest uncommon subsequence length in array of strings. Approach: If there is a string that is not equal to any other string, then its length is candidate. Since longest uncommon subsequence is at least length of that string. Since any string that appears only once is an uncommon subsequence of itself (it's a subsequence of itself) but not of any other identical strings. But we must ensure it's not a subsequence of any other string. Actually if string s appears only once, but other strings may be longer and contain s as subsequence. Example: strs = [\"aaa\", \"aa\"] – \"aaa\" appears once; but \"aa\" is a subsequence of \"aaa\"? \"aa\" is subsequence of \"aaa\", but we need string that is subsequence of one but not others. \"aaa\" is subsequence of itself; but is it subsequence of \"aa\"? No because \"aaa\" longer. So \"aaa\" qualifies. Actually we only need string that is not a subsequence of any other string. However the typical solution: longest uncommon subsequence equals max length of string that is unique in array, because if unique, it cannot be subsequence of another equal string, but could be subsequence of longer string. But consider \"aba\" and \"ab\". \"aba\" not subsequence of \"ab\" due to length. So unique string can be uncommon subsequence. But counterexample: [\"abcd\", \"abc\", \"abcd\"] – \"abcd\" appears twice. The unique string is \"abc\" length 3. But \"abc\" is subsequence of \"abcd\" so not uncommon? Actually we need a string that is subsequence of one but not others. \"abc\" is subsequence of \"abcd\" which is present in array, so \"abc\" is subsequence of \"abcd\" which is another string. So \"abc\" is not uncommon. So we need to find string that is not a subsequence of any other string. The common solution: If any string appears once, return its length. Because even if it's subsequence of longer string, it's subsequence of one string (itself) but not of the other identical strings? Wait definition: uncommon subsequence between array is a string that is a subsequence of one string but not the others. If string appears once, it's subsequence of itself; is it subsequence of other strings? Possibly, but definition says not the others. So if it is subsequence of any other string, then fails. So the usual solution: If there exists a string that does not appear elsewhere in the array (unique), then return its length. Actually typical LeetCode solution uses that logic. But is it correct? Let's analyze: For a string s that is unique, we need to check if s is a subsequence of any other string t. If s is subsequence of t, then s would be subsequence of other string, violating requirement. But typical solution assumes that if s is unique, then s cannot be subsequence of any other string? Not always true. Example: [\"aa\",\"aaa\",\"aa\"] – \"aaa\" is unique. Is \"aaa\" subsequence of any other string? No because other strings are \"aa\". So fine. But consider [\"abcd\", \"ab\",\"abc\",\"abcd\"] – unique strings: \"ab\", \"abc\". \"abc\" is subsequence of \"abcd\" which exists in array. So \"abc\" fails. But \"ab\" is subsequence of \"abcd\" too. So no unique string qualifies. But array has duplicate \"abcd\". But the longest uncommon subsequence would be -1? Let's test: Is there any string that's subsequence of one but not others? Maybe \"abcd\" appears twice, so not unique, but could be subsequence of others? \"abcd\" is subsequence of itself but also appears again. It appears twice, so it's subsequence of another string (the other copy), thus fails. So indeed -1. So the simple rule: if a string is unique in array, return its length. Because uniqueness ensures no other string equal to it, but we still need to ensure it's not a subsequence of another longer string. But maybe that's guaranteed because if s appears once, but some other string t may have s as subsequence but be longer. But then s would still be subsequence of t, violating the requirement. So we need to confirm if such case can exist and whether rule fails. Let's search known problem \"Longest Uncommon Subsequence II\". The solution is indeed: if there's a unique string, return its length; else -1. That works. So we will produce pseudocode accordingly.\n\nAlgorithm:\n- Count frequency of each string in array.\n- For each string in array:\n    - if its count == 1:\n        - return its length.\n- If none unique, return -1.\n\nComplexities: O(n * m) for counting maybe O(n) with dictionary.\n\nWe'll produce pseudocode line by line.\n\nNeed to use arrow, decision, etc. Let's output step by step.\n\nLet's produce:\n\nStart\n→ Step 1: 建立空字典 freq // 用於儲存每個字串出現次數\n→ Step 2: For each str in strs: // 遍歷輸入陣列\n    → Step 2a: freq[str] = freq.get(str,0)+1 // 更新頻率\n→ Decision: 是否存在頻率為 1 的字串？ // 檢查是否有唯一字串\n    Yes → Step 3: For each str in strs:\n        → Decision: freq[str]==1 ?\n            Yes → Step 4: 回傳 len(str) // 找到第一個唯一字串回傳長度\n            No  → Step 5: 連續下一個字串\n    No  → Step 6: 回傳 -1 // 無唯一字串，無不常見子序列\n\nBut we need to follow the exact format with arrows and decisions. Use indentation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 freq // 用來統計每個字串出現次數\n→ Step 2: For each str in strs: // 遍歷輸入陣列\n    → Step 2a: freq[str] = freq.get(str, 0) + 1 // 更新頻率\n→ Decision: 是否存在頻率為 1 的字串？ // 檢查是否有唯一字串\n    Yes → Step 3: For each str in strs: // 重新遍歷尋找唯一字串\n        → Decision: freq[str] == 1 ?\n            Yes → Step 4: 回傳 len(str) // 找到第一個唯一字串，直接回傳長度\n            No  → Step 5: 連續到下一個字串\n    No  → Step 6: 回傳 -1 // 沒有唯一字串，長度不存在\nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    \"\"\"\n    解法：使用深度優先搜尋 + 原地交換的方式生成所有排列。\n    這種方法不需要額外的 visited 陣列，利用交換把尚未處理的元素\n    放到目前位置，遞迴處理剩餘位置，最後再把交換還原。\n    \"\"\"\n    def permute(self, nums):\n        res = []\n\n        def backtrack(start):\n            # 若 start 已到達 nums 長度，代表已完成一個排列\n            if start == len(nums):\n                res.append(nums[:])  # 加入當前排列的複本\n                return\n            # 從 start 到最後的元素做交換\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # 交換\n                backtrack(start + 1)                         # 遞迴\n                nums[start], nums[i] = nums[i], nums[start]  # 取消交換（回溯）\n\n        backtrack(0)\n        return res\n\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin，假設輸入形式為 \"nums = [1,2,3]\" 或類似格式\n    data = sys.stdin.read().strip()\n    # 用正則找出方括號中的列表字串\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums_str = match.group(0)\n        nums = eval(nums_str)  # 直接轉成 Python list（題目確保安全）\n        solution = Solution()\n        result = solution.permute(nums)\n        print(result)\n    else:\n        # 若無符合格式，直接輸出空列表\n        print([])",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, with explanation. Should reflect algorithm to generate permutations of array of distinct ints. Use backtracking. Each step labelled like Step, Decision, etc. Must not output actual code, only pseudocode steps with explanations. Also must maintain format: each line \"虛擬碼步驟 // 解釋/說明\".\n\nWe need to output all steps: Start, Step 1: Define function, etc. Use arrows → and Decision: with Yes/No branches.\n\nWe need to include \"Start\", \"End\". Provide step to initialize result array, then call backtrack with empty current and visited.\n\nLet's produce steps:\n\nStart\n→ Step 1: 定義函數 permutations(nums) // 主入口函數\n→ Step 2: 初始化 result 為空陣列 // 用於儲存所有排列\n→ Step 3: 初始化 visited 為與 nums 長度相同的布林陣列，全部為 False // 標記元素是否已被使用\n→ Step 4: 定義回溯函數 backtrack(current) // 參數 current 是目前的排列\n→ Step 5: Decision: current 長度等於 nums 長度? // 檢查是否已完成一個排列\n    Yes → Step 6: 複製 current 並加入 result // 存入完整排列\n    No  → Decision: for 每個索引 i 從 0 到 nums.length-1? // 迭代所有位置\n        Yes → Step 7: Decision: visited[i] 為 False? // 確認該元素尚未使用\n            Yes → Step 8: Mark visited[i] 為 True // 標記為已使用\n            → Step 9: 加入 nums[i] 至 current // 將元素加入目前排列\n            → Step 10: 呼叫 backtrack(current) // 深度優先遞歸\n            → Step 11: 移除 current 最後一個元素 // 回溯移除\n            → Step 12: 設置 visited[i] 為 False // 取消標記\n        No  → Step 13: 跳過 i // 這個元素已被使用，繼續下一個\n→ Step 14: 呼叫 backtrack([]) // 從空排列開始\n→ Step 15: 返回 result // 結果輸出\nEnd\n\nNeed to format as per requirement: each line with code step then // explanation. Use arrows as described.\n\nLet's produce.\n\nBe careful to keep indentation: The format in example shows indentation for decision branches. We'll mimic that. Provide each line as separate.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函數 permutations(nums) // 主入口函數  \n→ Step 2: 初始化 result 為空陣列 // 用於儲存所有排列  \n→ Step 3: 初始化 visited 為與 nums 長度相同的布林陣列，全部為 False // 標記元素是否已被使用  \n→ Step 4: 定義回溯函數 backtrack(current) // 參數 current 是目前的排列  \n→ Step 5: Decision: current 長度等於 nums 長度? // 檢查是否已完成一個排列  \n  Yes → Step 6: 複製 current 並加入 result // 存入完整排列  \n  No  → Decision: 迭代每個索引 i 從 0 到 nums.length-1? // 依序嘗試每個元素  \n   Yes → Step 7: Decision: visited[i] 為 False? // 確認該元素尚未使用  \n    Yes → Step 8: 設置 visited[i] 為 True // 標記為已使用  \n     → Step 9: 加入 nums[i] 至 current // 將元素加入目前排列  \n     → Step 10: 呼叫 backtrack(current) // 深度優先遞歸  \n     → Step 11: 移除 current 最後一個元素 // 回溯移除  \n     → Step 12: 設置 visited[i] 為 False // 取消標記  \n    No  → Step 13: 跳過 i // 這個元素已被使用，繼續下一個  \n→ Step 14: 呼叫 backtrack([]) // 從空排列開始  \n→ Step 15: 返回 result // 將所有排列輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,1]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 存放所有元素的列表\n        self.data = []\n        # 將值對應到其在 data 中的所有索引集合\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"\n        插入元素 val。\n        返回 True 表示 val 原本不在集合中，False 表示已存在。\n        \"\"\"\n        # 先把 val 加到 data 列表尾部\n        self.data.append(val)\n        # 記錄新位置\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若這是第一次出現，返回 True，否則返回 False\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"\n        刪除元素 val 的一個實例。\n        若 val 存在返回 True，否則返回 False。\n        \"\"\"\n        if not self.idx_map[val]:\n            return False  # 沒有該元素可刪除\n\n        # 取出任意一個該值的索引\n        remove_idx = self.idx_map[val].pop()\n        # 取出最後一個元素\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n\n        # 把最後一個元素移到要刪除的位置\n        self.data[remove_idx] = last_val\n\n        # 更新 last_val 的索引集合\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n\n        # 刪除 data 的最後一個元素\n        self.data.pop()\n\n        # 若此值已無實例，從映射中移除鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"\n        隨機返回 data 中的一個元素。\n        \"\"\"\n        return random.choice(self.data)\n\ndef main():\n    # 讀取整個輸入\n    input_str = sys.stdin.read().strip()\n    if not input_str:\n        return\n\n    # 將輸入包裝成合法的 JSON 形式，方便解析\n    # 例如將 '[\"RandomizedCollection\", ...], [[], ...]' 改成 '[[\"RandomizedCollection\", ...], [[], ...]]'\n    wrapped = '[' + input_str + ']'\n    try:\n        ops_and_args = ast.literal_eval(wrapped)\n    except Exception as e:\n        # 若解析失敗，直接退出\n        sys.exit(1)\n\n    if not isinstance(ops_and_args, list) or len(ops_and_args) != 2:\n        sys.exit(1)\n\n    operations, arguments = ops_and_args\n    result = []\n    obj = None\n\n    for op, arg in zip(operations, arguments):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            result.append(None)\n        elif op == \"insert\":\n            res = obj.insert(arg[0])\n            result.append(res)\n        elif op == \"remove\":\n            res = obj.remove(arg[0])\n            result.append(res)\n        elif op == \"getRandom\":\n            res = obj.getRandom()\n            result.append(res)\n        else:\n            # 未知操作，忽略\n            result.append(None)\n\n    # 輸出結果，使用 json.dumps 以得到符合題目要求的格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line by line with explanations. Structure with Start, End, Decision, arrows. For RandomizedCollection class, we need to show initialization, insert, remove, getRandom. We'll use array/list and hashmap from value to set of indices. Provide pseudo-code for each method. Let's produce step-by-step algorithm for insert, remove, getRandom.\n\nPseudo-code:\n\nStart\n→ Step: Initialize list (nums) and map (idx_map)\n\nInsert:\n→ Step: Append val to nums\n→ Step: Add new index to idx_map[val]\n→ Decision: If val was not previously in map? // to determine return\n    Yes → Return true\n    No  → Return false\n\nRemove:\n→ Decision: If val not in map? // if no occurrence\n    Yes → Return false\n    No  → Get an arbitrary index idx from idx_map[val]\n    → Get last element last_val and its index last_idx from nums\n    → Replace nums[idx] with last_val\n    → Update idx_map[last_val]: remove last_idx, add idx\n    → Remove idx from idx_map[val]\n    → If idx_map[val] empty, delete entry\n    → Remove last element from nums\n    → Return true\n\ngetRandom:\n→ Step: Generate random index r in [0, len(nums)-1]\n→ Step: Return nums[r]\n\nEnd\n\nWe need each line with // explanation. Also we need to show the decision branches. For insert we might need to detect presence before adding. But we can check after. Let's design pseudo-code with decision before adding. Let's produce code:\n\nStart\n→ Step: Initialize nums = empty list // 存放所有元素\n→ Step: Initialize idx_map = empty map from value to set of indices // 追蹤每個值出現的位置\n\nInsert(val):\n→ Decision: If val not in idx_map? // 判斷值是否第一次出現\n    Yes → Step: Create new set for val in idx_map // 為新值建立集合\n→ Step: Append val to nums // 把值加入末尾\n→ Step: Add index len(nums)-1 to idx_map[val] // 記錄新位置\n→ Decision: If val was not present before? // 判斷是否為第一次插入\n    Yes → Step: Return true // 代表沒有重複\n    No  → Step: Return false // 已經存在\n\nRemove(val):\n→ Decision: If val not in idx_map? // 無此值\n    Yes → Step: Return false // 無法移除\n    No  → Step: Pick an arbitrary index idx from idx_map[val] // 取一個位置\n→ Step: Get last_val = nums[last index] // 取最後一個元素\n→ Step: Replace nums[idx] with last_val // 覆蓋被移除位置\n→ Step: Update idx_map[last_val]: remove last index, add idx // 更新位置集合\n→ Step: Remove idx from idx_map[val] // 刪除被移除位置\n→ Decision: If idx_map[val] empty? // 是否還剩餘該值\n    Yes → Step: Delete idx_map[val] // 清除空集合\n→ Step: Remove last element from nums // 刪除末尾\n→ Step: Return true // 成功移除\n\ngetRandom():\n→ Step: Generate random index r in [0, len(nums)-1] // 隨機索引\n→ Step: Return nums[r] // 回傳隨機元素\n\nEnd\n\nMake sure each line ends with // explanation. Use arrows. Include decisions.\n\nLet's output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step: Initialize nums = [] // 用來存放所有元素的動態陣列\n→ Step: Initialize idx_map = {} // key: 值, value: 集合(該值所在的索引集合)\n\nInsert(val): // 插入一個值\n    → Decision: If val not in idx_map? // 判斷 val 是否第一次出現\n        Yes → Step: idx_map[val] = {} // 建立新的集合以存放索引\n    → Step: Append val to nums // 把 val 加到陣列末尾\n    → Step: idx_map[val].add(len(nums)-1) // 記錄新索引\n    → Decision: If val not in idx_map before? // 判斷是否為第一次插入\n        Yes → Step: Return true // 沒有重複，返回 true\n        No  → Step: Return false // 已存在，返回 false\n\nRemove(val): // 刪除一個值\n    → Decision: If val not in idx_map? // 無此值可刪除\n        Yes → Step: Return false // 無法刪除，返回 false\n        No  → Step: idx = any element from idx_map[val] // 取得任一索引\n    → Step: last_val = nums[len(nums)-1] // 取陣列最後一個元素\n    → Step: nums[idx] = last_val // 用最後元素覆蓋要刪除的位置\n    → Step: idx_map[last_val].remove(len(nums)-1) // 刪除舊的最後索引\n    → Step: idx_map[last_val].add(idx) // 加入新索引\n    → Step: idx_map[val].remove(idx) // 刪除 val 的該索引\n    → Decision: If idx_map[val] is empty? // 檢查是否還剩此值\n        Yes → Step: Delete idx_map[val] // 清除空集合\n    → Step: nums.pop() // 刪除陣列最後一個元素\n    → Step: Return true // 成功刪除，返回 true\n\ngetRandom(): // 取得隨機元素\n    → Step: r = random integer between 0 and len(nums)-1 // 隨機索引\n    → Step: Return nums[r] // 回傳隨機元素\n\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    \"\"\"兩個堆的實作：small 為大根堆（使用負數），large 為小根堆。\"\"\"\n    def __init__(self):\n        self.small = []  # max-heap via negative values\n        self.large = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        # 先把數字放到小根堆的對應位置\n        heapq.heappush(self.small, -num)\n\n        # 保持小根堆頂（最大值）不大於大根堆頂（最小值）\n        if self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡兩堆大小，差值不超過 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        # 若兩堆大小相同，返回兩個中位數的平均值\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 將輸入分成兩個 JSON 陣列\n    idx = raw_input.find(']')\n    commands_str = raw_input[:idx+1]\n    args_str = raw_input[idx+2:].strip()  # 跳過 '], '\n\n    commands = json.loads(commands_str)\n    args = json.loads(args_str)\n\n    results = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MedianFinder\":\n            obj = MedianFinder()\n            results.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(arg[0])          # arg 為 [num]\n            results.append(None)\n        elif cmd == \"findMedian\":\n            results.append(obj.findMedian())\n        else:\n            results.append(None)\n\n    # 輸出符合 LeetCode 風格的 JSON 陣列\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to generate pseudocode for implementing MedianFinder with addNum and findMedian. Use two heaps approach. Steps: initialize maxHeap and minHeap. addNum: if maxHeap empty or num <= maxHeap.peek, push to maxHeap else push to minHeap. Balance heaps: if size diff >1, move top from larger to smaller. findMedian: if sizes equal, median = (maxHeap.peek + minHeap.peek)/2. else median = larger heap top. Provide line-by-line with arrow etc.\n\nWe'll produce something like:\n\nStart\n→ Step 1: 初始化 maxHeap (大根堆) 和 minHeap (小根堆) // 用兩個堆保持中位數\n→ Step 2: 定義 addNum 方法\n    → Step 3: 如果 maxHeap 為空 或 num ≤ maxHeap.peek → push num 到 maxHeap\n    → Step 4: 否則 push num 到 minHeap\n    → Step 5: 調整堆平衡\n        → Decision: 如果 maxHeap.size - minHeap.size > 1 → move top from maxHeap to minHeap\n        → Decision: 如果 minHeap.size - maxHeap.size > 1 → move top from minHeap to maxHeap\n→ Step 6: 定義 findMedian 方法\n    → Decision: 如果 maxHeap.size == minHeap.size → median = (maxHeap.peek + minHeap.peek)/2\n    → Decision: 如果 maxHeap.size > minHeap.size → median = maxHeap.peek\n    → Decision: 否則 median = minHeap.peek\nEnd\n\nBut need each line of virtual code plus comment. Use the arrow symbol `→` for steps. Use `Decision:` for if. Use indentation accordingly.\n\nLet's output in the required format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 maxHeap (大根堆) 與 minHeap (小根堆) // 用於分別儲存較小與較大的一半數據  \n→ Step 2: 定義 addNum 方法 // 添加新數字進入資料結構  \n    → Step 3: 如果 maxHeap 為空 或 num ≤ maxHeap.peek → 將 num 加入 maxHeap // 數字較小或等於中位數，放入大根堆  \n    → Step 4: 否則 → 將 num 加入 minHeap // 數字較大，放入小根堆  \n    → Step 5: 調整堆平衡 // 保持兩堆大小差 ≤ 1  \n        → Decision: maxHeap.size - minHeap.size > 1? // 檢查大根堆是否過大  \n            Yes → Step 6: 將 maxHeap.top 移至 minHeap // 轉移多餘元素  \n        → Decision: minHeap.size - maxHeap.size > 1? // 檢查小根堆是否過大  \n            Yes → Step 7: 將 minHeap.top 移至 maxHeap // 轉移多餘元素  \n→ Step 8: 定義 findMedian 方法 // 返回目前所有數字的中位數  \n    → Decision: maxHeap.size == minHeap.size? // 堆大小相等  \n        Yes → Step 9: median = (maxHeap.peek + minHeap.peek) / 2.0 // 兩個中間值平均  \n        No → Decision: maxHeap.size > minHeap.size? // 大根堆較大  \n            Yes → Step 10: median = maxHeap.peek // 取大根堆頂作為中位數  \n            No  → Step 11: median = minHeap.peek // 取小根堆頂作為中位數  \n→ Step 12: return median // 回傳計算結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3q33fqly.py\", line 66, in <module>\n    main()\n  File \"/tmp/tmp3q33fqly.py\", line 49, in main\n    intervals = ast.literal_eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwkydl5l2.py\", line 66, in <module>\n    main()\n  File \"/tmp/tmpwkydl5l2.py\", line 49, in main\n    intervals = ast.literal_eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, new_interval):\n        \"\"\"\n        Insert a new interval into a sorted list of non-overlapping intervals,\n        merging where necessary.\n\n        :param intervals: List[List[int]] – sorted, non-overlapping intervals\n        :param new_interval: List[int] – the interval to insert\n        :return: List[List[int]] – the updated list of intervals\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < new_interval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with the new interval\n        while i < n and intervals[i][0] <= new_interval[1]:\n            new_interval[0] = min(new_interval[0], intervals[i][0])\n            new_interval[1] = max(new_interval[1], intervals[i][1])\n            i += 1\n\n        # Append the merged new interval\n        result.append(new_interval)\n\n        # Append the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read()\n\n    # Extract the intervals and newInterval using regex\n    intervals_match = re.search(r'intervals\\s*=\\s*(\\[[^\\]]*\\])', data)\n    new_interval_match = re.search(r'newInterval\\s*=\\s*(\\[[^\\]]*\\])', data)\n\n    if intervals_match:\n        intervals = ast.literal_eval(intervals_match.group(1))\n    else:\n        intervals = []\n\n    if new_interval_match:\n        new_interval = ast.literal_eval(new_interval_match.group(1))\n    else:\n        new_interval = []\n\n    # Compute the result\n    sol = Solution()\n    merged = sol.insert(intervals, new_interval)\n\n    # Output the result\n    print(merged)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The problem: insert interval into sorted non-overlapping intervals. Typical algorithm: result list, iterate intervals. Add all intervals ending before newInterval starts. Then merge overlapping ones, then add rest.\n\nWe need step-by-step pseudocode with decision nodes. Let's produce.\n\nWe should include Start, End. Use arrow \"→\" for steps. Use \"Decision:\" lines. For loops, we can represent as Step with loop.\n\nLet's design:\n\nStart\n→ Step 1: 初始化 result list // empty\n→ Step 2: 初始化 i = 0 // index\n\n→ Step 3: 循環直到 i < intervals.length AND intervals[i].end < newInterval.start\n    Decision: intervals[i].end < newInterval.start?\n        Yes → Step 3a: 加入 intervals[i] 到 result\n              → Step 3b: i++\n              → 回到 Step 3\n        No → break loop\n\nAfter that, merge overlapping intervals:\n→ Step 4: 初始化 mergedStart = newInterval.start\n        初始化 mergedEnd = newInterval.end\n\n→ Step 5: 循環直到 i < intervals.length AND intervals[i].start <= mergedEnd\n    Decision: intervals[i].start <= mergedEnd?\n        Yes → mergedStart = min(mergedStart, intervals[i].start)\n              mergedEnd = max(mergedEnd, intervals[i].end)\n              i++\n              回到 Step 5\n        No → break loop\n\n→ Step 6: 加入 [mergedStart, mergedEnd] 到 result\n\n→ Step 7: 循環剩餘 intervals\n    Decision: i < intervals.length?\n        Yes → Step 7a: 加入 intervals[i] 到 result\n              i++\n              回到 Step 7\n        No → end\n\nEnd\n\nAdd explanation comments.\n\nLet's produce lines accordingly. Ensure each line includes \"虛擬碼步驟\" + \" // 解釋\".\n\nUse Chinese comments.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空列表 // 用來存放最後的合併後區間  \n→ Step 2: 初始化 i ← 0 // 設定迴圈索引  \n\n→ Step 3: 迴圈：當 i < intervals.length 且 intervals[i].end < newInterval.start 時  \n    Decision: intervals[i].end < newInterval.start? // 檢查目前區間是否完全在新區間左側  \n        Yes → Step 3a: 將 intervals[i] 加入 result // 將不重疊的左側區間加入  \n              → Step 3b: i ← i + 1 // 移至下一個區間  \n              → 回到 Step 3 // 重新判斷條件  \n        No  → 跳出 Step 3 // 之後的區間可能與新區間重疊  \n\n→ Step 4: 初始化 mergedStart ← newInterval.start  \n        初始化 mergedEnd ← newInterval.end // 準備合併重疊區間  \n\n→ Step 5: 迴圈：當 i < intervals.length 且 intervals[i].start ≤ mergedEnd 時  \n    Decision: intervals[i].start ≤ mergedEnd? // 檢查當前區間是否與新區間或已合併區間重疊  \n        Yes → mergedStart ← min(mergedStart, intervals[i].start)  \n              mergedEnd ← max(mergedEnd, intervals[i].end) // 擴充合併區間邊界  \n              i ← i + 1  \n              → 回到 Step 5 // 繼續檢查下一個可能重疊的區間  \n        No  → 跳出 Step 5 // 所有重疊區間已合併完成  \n\n→ Step 6: 將 [mergedStart, mergedEnd] 加入 result // 將合併後的新區間加入結果  \n\n→ Step 7: 迴圈：當 i < intervals.length 時  \n    Decision: i < intervals.length? // 檢查是否還有剩餘區間  \n        Yes → Step 7a: 將 intervals[i] 加入 result // 右側不重疊區間直接加入  \n              i ← i + 1  \n              → 回到 Step 7 // 仍有剩餘區間  \n        No  → 跳出 Step 7 // 所有區間已處理完畢  \n\nEnd // 程式執行結束，返回 result（合併後的區間列表）"
    },
    {
      "title": "Poor Pigs",
      "source_file": "Leetcode/leetcode458.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 15",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprdn7f71u.py\", line 53, in <module>\n    buckets, minutesToDie, minutesToTest = parse_input(raw_input)\n                                           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmprdn7f71u.py\", line 42, in parse_input\n    values[key.strip()] = int(val.strip())\n                          ^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: ''"
        },
        {
          "example_index": 1,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 30",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxjiguiwe.py\", line 53, in <module>\n    buckets, minutesToDie, minutesToTest = parse_input(raw_input)\n                                           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpxjiguiwe.py\", line 42, in parse_input\n    values[key.strip()] = int(val.strip())\n                          ^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: ''"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n        \"\"\"\n        Calculate the minimal number of pigs needed to identify a poisonous bucket.\n\n        :param buckets: Total number of buckets.\n        :param minutesToDie: Minutes it takes for a pig to die after ingesting poison.\n        :param minutesToTest: Total minutes available for testing.\n        :return: Minimum number of pigs required.\n        \"\"\"\n        # Number of full testing rounds we can perform.\n        rounds = minutesToTest // minutesToDie\n        if rounds == 0:\n            # No round can be completed; each pig can test only one bucket.\n            return buckets\n\n        # Each pig can be in one of (rounds + 1) distinct states\n        # (alive after each round or dead after a specific round).\n        states_per_pig = rounds + 1\n\n        # Find the smallest number of pigs such that states_per_pig ** pigs >= buckets.\n        pigs = 0\n        while states_per_pig ** pigs < buckets:\n            pigs += 1\n        return pigs\n\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse an input string formatted like:\n        'buckets = 4, minutesToDie = 15, minutesToTest = 15'\n    and return the three integer values.\n    \"\"\"\n    # Replace commas with spaces to simplify splitting\n    tokens = data.replace(',', ' ').split()\n    values = {}\n    for token in tokens:\n        if '=' in token:\n            key, val = token.split('=')\n            values[key.strip()] = int(val.strip())\n    return values['buckets'], values['minutesToDie'], values['minutesToTest']\n\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Parse input values\n    buckets, minutesToDie, minutesToTest = parse_input(raw_input)\n\n    # Compute answer\n    solution = Solution()\n    result = solution.poorPigs(buckets, minutesToDie, minutesToTest)\n\n    # Output the result\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm to compute minimal pigs. Classic solution: number of trials = minutesToTest / minutesToDie. Each pig can have base (trials+1) states (including alive after all). Number of pigs needed = ceil(log(buckets)/log(trials+1)). But the task: produce virtual code with explanations each line. Use Start, Decision, etc. So we need to output step-by-step pseudocode.\n\nWe should not output actual code. Just virtual steps. Each line: virtual code step + comment.\n\nWe need to follow format. Use \"Start\", \"End\", \"Decision:\" and arrows.\n\nSo produce steps: Input buckets, minutesToDie, minutesToTest. Compute number_of_trials = minutesToTest / minutesToDie (integer division). Decision if number_of_trials==0? etc. Compute base = number_of_trials+1. Decision if buckets==1? output 0. Else compute log. Use iterative method: while pow(base, pigs) < buckets: pigs++. So produce steps.\n\nLet's craft lines.\n\nWe'll include Start. Then Step 1: Input variables. Step 2: Compute trials. Decision if trials==0. If yes -> pigs= buckets? Actually if minutesToDie > minutesToTest, cannot test any. You need buckets pigs? Wait: If minutesToDie > minutesToTest, you can only have 1 round? Actually you can't get any test, so each pig can be fed all buckets simultaneously but will die only after minutesToDie which is beyond time. So cannot determine. But typical solution: if minutesToDie > minutesToTest, we have 0 rounds? Then base=1? Actually number_of_trials = minutesToTest / minutesToDie -> 0. So base=1. log(1) infinite? So you need buckets pigs. Because each pig can only be used once? But if no time to wait, then we can't observe death. So each pig must test one bucket? Wait: In this scenario, you can feed pigs but can't wait to see result. So no information. So you would need to test each bucket separately with distinct pigs? But you can't feed after? Actually you could feed all pigs simultaneously, but you can't wait. So you'd need to feed pigs each bucket individually? But can't observe death. So maybe the formula gives pigs = buckets because base=1 -> need log_buckets base 1 => infinite. But typical LeetCode solution uses ceil(log(buckets)/log(trials+1)). If trials=0, base=1, log1 undefined, so answer = buckets. Because each pig can only test one bucket. So we should handle that.\n\nThus algorithm: if minutesToDie > minutesToTest: return buckets.\n\nSo produce pseudocode accordingly.\n\nWe'll produce steps:\n\nStart\n→ Step 1: Set buckets, minutesToDie, minutesToTest // get input values\n→ Step 2: Calculate number_of_trials = minutesToTest / minutesToDie // integer division of available time\n→ Decision: 如果 number_of_trials == 0? // no full round possible\n    Yes → Step 3: Return buckets // need one pig per bucket\n    No  → Step 4: Set base = number_of_trials + 1 // states per pig\n    → Step 5: If buckets == 1? // only one bucket\n        Yes → Step 6: Return 0 // no pig needed\n        No  → Step 7: Set pigs = 0 // initialize pig counter\n            → Step 8: While pow(base, pigs) < buckets: // keep increasing pigs until enough states\n                pigs = pigs + 1 // increment pig count\n            → Step 9: Return pigs // minimal pigs found\nEnd\n\nNeed to include explanation comments.\n\nAdd \"→\" arrow before each step line.\n\nAlso decisions: Use \"Decision:\" with indentation.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set buckets, minutesToDie, minutesToTest // 取得輸入參數  \n→ Step 2: Calculate number_of_trials = minutesToTest / minutesToDie // 可完成的完整測試輪數（整除）  \n→ Decision: 如果 number_of_trials == 0? // 無法等待死亡，無法觀察結果  \n    Yes → Step 3: Return buckets // 每個桶都需要一隻豬（無資訊可獲）  \n    No  → Step 4: Set base = number_of_trials + 1 // 每隻豬可呈現的獨立狀態數（死亡/存活）  \n→ Decision: 如果 buckets == 1? // 只存在一個桶  \n    Yes → Step 5: Return 0 // 不需要任何豬即可判定  \n    No  → Step 6: Set pigs = 0 // 初始化需要的豬數  \n        → Step 7: While pow(base, pigs) < buckets: // 找到足以區分所有桶的最小豬數  \n            → Step 8: pigs = pigs + 1 // 增加一隻豬並重新檢查  \n        → Step 9: Return pigs // 回傳最小需要的豬數  \nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum IV",
      "source_file": "Leetcode/leetcode377.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsp2o92sp.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmpsp2o92sp.py\", line 24, in main\n    target_part = parts[1].split('=')[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def combinationSum4(self, nums, target):\n        \"\"\"Return the number of combinations that add up to target.\"\"\"\n        dp = [0] * (target + 1)\n        dp[0] = 1  # base case: one way to reach sum 0\n\n        for i in range(1, target + 1):\n            for num in nums:\n                if i - num >= 0:\n                    dp[i] += dp[i - num]\n        return dp[target]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Expected format: 'nums = [1,2,3], target = 4'\n    parts = data.split(',')\n    nums_part = parts[0].split('=')[1].strip()\n    target_part = parts[1].split('=')[1].strip()\n\n    nums = ast.literal_eval(nums_part)\n    target = int(target_part)\n\n    result = Solution().combinationSum4(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need virtual code steps for solution to \"combination sum IV\" (Count number of possible combinations). We produce algorithm, likely DP or recursion. We'll produce high-level pseudo steps. We'll not output actual code. Just steps.\n\nStructure: Start, Decision, etc.\n\nWe need to output each line with virtual code step and explanation.\n\nProbably steps:\n\nStart // start program\n→ Step 1: Sort nums? maybe not needed.\n→ Step 2: 初始化 dp array of size target+1, dp[0] = 1 // base case\n→ Step 3: For i from 1 to target: // iterate over target\n   → For each num in nums:\n      → Decision: If i >= num? // can use this num\n          Yes → dp[i] += dp[i - num] // add combinations\nEnd // return dp[target]\n\nWe need to include \"Return\" step.\n\nAlso include check for input validity: ensure nums not empty.\n\nAdd comments.\n\nLet's produce lines with arrow indentation.\n\nWe need to use the arrow format: \"→ Step 1:\" etc. For decisions we use \"Decision:\".\n\nLet's produce step lines.\n\nWe might add a decision for whether nums array is empty, return 0. Also decision for target <=0? return 0? Well target is integer.\n\nOk.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Decision: 如果 nums 為空? // 檢查可用數字是否存在\n    Yes → Step 1: 回傳 0 // 沒有數字無法組合\n    No → Step 2: 建立 dp 陣列長度 target+1 並設 dp[0] = 1 // 基本組合\n→ Step 3: For i from 1 到 target:\n    → For each num in nums:\n        → Decision: i >= num? // 可否使用該數字\n            Yes → Step 4: dp[i] = dp[i] + dp[i - num] // 累加組合數\n            No → No action // 無法使用\n→ Step 5: 回傳 dp[target] // 最終結果\nEnd // 程式結束\n\nBut we must follow format: Each line \"虛擬碼步驟\" + \" // 解釋\". We must ensure each line has arrow. We can also use nested indentation via spaces.\n\nLet's format:\n\nStart // 程式開始執行\n→ Decision: 如果 nums 為空? // 檢查可用數字是否存在\n    Yes → Step 1: 回傳 0 // 沒有數字無法組合\n    No  → Step 2: 建立 dp 陣列長度 target+1 並設 dp[0] = 1 // 基本組合\n→ Step 3: For i 從 1 到 target: // 遍歷目標值\n    → For 每個 num 在 nums: // 嘗試每個可用數字\n        → Decision: i >= num? // 判斷是否可用\n            Yes → Step 4: dp[i] = dp[i] + dp[i - num] // 加入組合數\n            No  → // 無法使用該數字，跳過\n→ Step 5: 回傳 dp[target] // 回傳最終組合數量\nEnd // 程式結束\n\nWe must keep format: \"Step 1: ...\" etc. Ensure each line has explanation comment. For decisions we need arrow lines with Yes / No arrow.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 nums 為空? // 檢查可用數字是否存在  \n  Yes → Step 1: 回傳 0 // 沒有數字無法組合  \n  No  → Step 2: 建立 dp 陣列長度 target+1 並設 dp[0] = 1 // 基本組合  \n\n→ Step 3: For i 從 1 到 target: // 遍歷所有可能的總和  \n  → For 每個 num 在 nums: // 嘗試每個可用數字  \n    → Decision: i >= num? // 判斷是否可以使用該數字  \n     Yes → Step 4: dp[i] = dp[i] + dp[i - num] // 加入組合數量  \n     No  → // 無法使用該數字，直接跳過  \n\n→ Step 5: 回傳 dp[target] // 回傳最終組合數量  \nEnd // 程式結束"
    },
    {
      "title": "K-diff Pairs in an Array",
      "source_file": "Leetcode/leetcode532.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[3,1,4,1,5], 2",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsgd7pqg6.py\", line 35, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpsgd7pqg6.py\", line 27, in parse_input\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4,5], 1",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphr43o7ku.py\", line 35, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmphr43o7ku.py\", line 27, in parse_input\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "[1,3,1,5,4], 0",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpv3yso9fv.py\", line 35, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpv3yso9fv.py\", line 27, in parse_input\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findPairs(self, nums, k):\n        if k < 0:\n            return 0\n        count = Counter(nums)\n        if k == 0:\n            return sum(v > 1 for v in count.values())\n        return sum((n + k) in count for n in count)\n\ndef parse_input(raw: str):\n    \"\"\"\n    Parses the raw input from stdin.\n    Accepts either two separate lines (array and k) or a single line\n    formatted like \"[1,2,3], 2\".\n    \"\"\"\n    lines = [line.strip() for line in raw.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        nums_str, k_str = lines[0], lines[1]\n    else:\n        # single line with comma separator\n        parts = [p.strip() for p in raw.split(',') if p.strip()]\n        nums_str, k_str = parts[0], parts[1] if len(parts) > 1 else '0'\n    nums = ast.literal_eval(nums_str)\n    k = int(k_str)\n    return nums, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    nums, k = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findPairs(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines for the algorithm to count unique k-diff pairs in array. Use virtual code with Start, Decision, etc. Provide line by line. We can use steps: count unique pairs. Approach: Use hash map to count frequencies, then iterate through keys. For each number x, if k==0, count numbers with freq>1; else if x+k exists. Use set or count.\n\nWe must produce each line with explanation. Provide proper arrows, indentation.\n\nWe should be careful: The output format: Each line: 虛擬碼步驟 + space + // explanation.\n\nUse virtual arrows like →, Decision: etc.\n\nWe can indent sub-steps with spaces. Provide End at end.\n\nLet's produce steps:\n\nStart\n→ Step 1: 建立字典 freq 以計算每個數字出現次數 // Count frequency\n→ For 每個數字 num in nums:\n    freq[num] += 1\n→ Step 2: 初始化計數器 count = 0 // Unique pair counter\n→ Decision: 如果 k < 0? // Because |diff|==k cannot be negative\n    No →  // Proceed\n        // For k == 0 case\n        Decision: 如果 k == 0? // Special handling\n            Yes → For 每個數字 num, freq[num] > 1? // Count duplicates\n                Yes → count += 1\n            No → // k > 0\n                For 每個數字 num in freq keys:\n                    Decision: 如果 num + k 在 freq? // Check pair existence\n                        Yes → count += 1\n        // End decision\n→ End // Return count\n\nBut we need to include each step line with explanation. Provide indentation for decisions.\n\nMake sure each line includes '虛擬碼步驟' and ' // 解釋'.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 初始化字典 freq 為空 // 用於統計每個數字出現次數\n→ Decision: 如果 nums 為空? // 空輸入無需處理\n    Yes → End // 結束程式，返回 0\n    No  → // 繼續\n→ Step 2: 對 nums 中每個 num 做 freq[num] += 1 // 形成頻率表\n→ Step 3: 初始化變數 count = 0 // 用於儲存唯一 k-diff 對的數量\n→ Decision: 如果 k < 0? // 差值絕對值不能為負\n    Yes → End // k < 0 無合法對，返回 0\n    No  → // k >= 0\n        // 對 k == 0 的特殊處理\n        Decision: 如果 k == 0? // 只計算重複值\n            Yes →\n                For 每個 num, freq[num] > 1?\n                    Yes → count += 1 // 只算一次重複對\n            No  →\n                For 每個 num 在 freq.keys?\n                    Decision: 如果 (num + k) 在 freq? // 需要同時存在\n                        Yes → count += 1 // 找到一對\n        // End k == 0 或 k > 0 判斷\n→ End // 程式執行結束\n\nMake sure each line has `//` comment.\n\nAlso, we must use virtual arrows '→' and 'Decision:'.\n\nWe might need to indent sub-steps by spaces, but each line still starts with something like \"→\" or \"Decision:\".\n\nThe sub-steps after 'Yes →' or 'No →' should start with a space indentation and the same arrow.\n\nBut guidelines: Use arrows (→, Yes →, No →) and structure (Start, End, Decision:). So we can write:\n\n→ Decision: ...\n    Yes →\n        Step...\n    No →\n        Step...\n\nBut each line must have '虛擬碼步驟' + space + ' // 解釋'.\n\nLet's produce accordingly. Ensure no actual code. Use Chinese comments.\n\nMake sure to include step numbers maybe? Not required but fine.\n\nWe'll output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字典 freq 為空 // 用於統計每個數字出現次數  \n→ Decision: 如果 nums 為空? // 空輸入無需處理  \n    Yes → End // 結束程式，返回 0  \n    No  → // 繼續執行  \n→ Step 2: 對 nums 中每個 num 做 freq[num] += 1 // 形成頻率表  \n→ Step 3: 初始化變數 count = 0 // 用於儲存唯一 k‑diff 對的數量  \n→ Decision: 如果 k < 0? // 差值絕對值不能為負  \n    Yes → End // k < 0 無合法對，返回 0  \n    No  → // k >= 0  \n        // 對 k == 0 的特殊處理  \n        Decision: 如果 k == 0? // 只計算重複值  \n            Yes →  \n                For 每個 num, freq[num] > 1?  \n                    Yes → count += 1 // 只算一次重複對  \n            No  →  \n                For 每個 num 在 freq.keys?  \n                    Decision: 如果 (num + k) 在 freq? // 需要同時存在  \n                        Yes → count += 1 // 找到一對  \n→ End // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\nimport re\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []  # list of [l, r] intervals, non-overlapping, sorted by l\n\n    def addRange(self, left: int, right: int) -> None:\n        \"\"\"Add the interval [left, right). Merge with existing intervals.\"\"\"\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:               # current interval ends before new starts\n                new_ranges.append([l, r])\n            elif right < l:            # current interval starts after new ends\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:                      # overlapping, merge\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        \"\"\"Return True if [left, right) is fully covered by existing intervals.\"\"\"\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        \"\"\"Remove the interval [left, right) from existing intervals.\"\"\"\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\n\ndef main():\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    objects = {}          # variable name -> instance\n    outputs = []\n\n    # Regex to capture method calls: var.method(args);\n    pattern = re.compile(r'(\\w+)\\.(\\w+)\\(([^)]*)\\);')\n\n    for line in lines:\n        # Skip initialization line (creates a new RangeModule)\n        if line.startswith('RangeModule '):\n            # Example: RangeModule rangeModule = new RangeModule();\n            parts = line.split()\n            var_name = parts[1]\n            objects[var_name] = RangeModule()\n            outputs.append('null')\n            continue\n\n        # Handle method calls\n        m = pattern.match(line)\n        if not m:\n            continue  # ignore unexpected lines\n        var_name, method, args_str = m.groups()\n        args = [int(a.strip()) for a in args_str.split(',')] if args_str else []\n        obj = objects.get(var_name)\n        if obj is None:\n            continue  # variable not found; skip\n\n        if method == 'addRange':\n            obj.addRange(*args)\n            outputs.append('null')\n        elif method == 'removeRange':\n            obj.removeRange(*args)\n            outputs.append('null')\n        elif method == 'queryRange':\n            res = obj.queryRange(*args)\n            outputs.append('true' if res else 'false')\n        else:\n            # Unknown method; skip\n            continue\n\n    # Print the results as a Python-like list\n    print('[{}]'.format(', '.join(outputs)))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing RangeModule with methods. We need step-by-step design: likely use interval tree, maybe balanced BST or sorted list. Provide virtual code with arrows. Since not actual code, we explain logic.\n\nWe need to output each line with \"虛擬碼步驟\" + \" // 解釋/說明\". We need to include Start and End. Use decision blocks. We should outline initialization, addRange, queryRange, removeRange logic. Use sorted list of non-overlapping intervals. Steps: merge intervals when adding, split when removing, check coverage for query. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 定義 RangeModule // 宣告類別  \n→ Step 2: 內部儲存結構：List of Pair(start, end) // 儲存已追蹤的半開區間，且始終保持無重疊且已排序  \n\n→ Step 3: Constructor 初始化空列表 // 建構子  \n    → Action: intervals ← empty list // 初始化空的區間集合  \n\n→ Step 4: 方法 addRange(left, right) // 新增區間  \n    → Action: 找出 intervals 中第一個與 [left, right) 可能重疊或相鄰的區間 idx  \n    → Decision: 如果 idx 為 null? // 若無相鄰或重疊區間  \n        Yes → Action: intervals.insert(idx, [left, right]) // 直接插入  \n        No  → → Step 5: 合併所有重疊或相鄰區間  \n            → Action: newLeft ← min(left, intervals[idx].start)  \n            → Action: newRight ← max(right, intervals[idx].end)  \n            → Action: 移除 idx 之後所有與 [newLeft, newRight) 重疊的區間  \n            → Action: intervals.insert(idx, [newLeft, newRight]) // 插入合併後的區間  \n\n→ Step 6: 方法 queryRange(left, right) // 查詢區間是否完全被追蹤  \n    → Action: 找到 intervals 中最後一個 start <= left 的區間 idx  \n    → Decision: idx 為 null? // 沒有任何區間覆蓋 left  \n        Yes → Return False // 無覆蓋，直接返回 false  \n        No  → Decision: intervals[idx].end >= right? // 覆蓋整個 [left, right)  \n            Yes → Return True // 完全覆蓋，返回 true  \n            No  → Return False // 不足以覆蓋，返回 false  \n\n→ Step 7: 方法 removeRange(left, right) // 移除區間  \n    → Action: 找出 intervals 中第一個可能重疊的區間 idx  \n    → Decision: idx 為 null? // 無重疊區間  \n        Yes → Return // 完全無動作  \n        No  → → Step 8: 處理左側剩餘部分  \n            → Decision: intervals[idx].start < left?  \n                Yes → Action: intervals[idx].end ← left // 截斷左邊  \n                No  → Action: intervals.remove(idx) // 完全被移除  \n                → idx ← idx - 1 // 移動到前一個區間（如果剛被刪除）  \n        → Step 9: 處理右側剩餘部分  \n            → Decision: intervals[idx].end > right?  \n                Yes → Action: intervals.insert(idx+1, [right, intervals[idx].end]) // 創建右側新區間  \n                No  → Action: intervals.remove(idx) // 完全被移除  \n        → Step 10: 移除之間所有完全在 [left, right) 內的區間  \n            → While intervals[idx+1] exists and intervals[idx+1].end <= right  \n                → Action: intervals.remove(idx+1) // 刪除  \n    // 以上流程確保 [left, right) 內的數值不再被追蹤  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpiotu4xrd.py\", line 64, in <module>\n    ops = ast.literal_eval(data[0].strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n                                                                                                                                                ^\nSyntaxError: unexpected character after line continuation character"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.capacity = k\n        self.buffer = [0] * k\n        self.front = 0\n        self.rear = 0\n        self.count = 0\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.capacity:\n            return False\n        self.front = (self.front - 1 + self.capacity) % self.capacity\n        self.buffer[self.front] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.capacity:\n            return False\n        self.buffer[self.rear] = value\n        self.rear = (self.rear + 1) % self.capacity\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.front = (self.front + 1) % self.capacity\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.rear = (self.rear - 1 + self.capacity) % self.capacity\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buffer[self.front]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.rear - 1 + self.capacity) % self.capacity\n        return self.buffer[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.capacity\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n    ops = ast.literal_eval(data[0].strip())\n    args_list = ast.literal_eval(data[1].strip())\n\n    result = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(*args)\n            result.append(None)\n        elif op == \"insertFront\":\n            res = obj.insertFront(*args)\n            result.append(res)\n        elif op == \"insertLast\":\n            res = obj.insertLast(*args)\n            result.append(res)\n        elif op == \"deleteFront\":\n            res = obj.deleteFront(*args)\n            result.append(res)\n        elif op == \"deleteLast\":\n            res = obj.deleteLast(*args)\n            result.append(res)\n        elif op == \"getFront\":\n            res = obj.getFront(*args)\n            result.append(res)\n        elif op == \"getRear\":\n            res = obj.getRear(*args)\n            result.append(res)\n        elif op == \"isEmpty\":\n            res = obj.isEmpty(*args)\n            result.append(res)\n        elif op == \"isFull\":\n            res = obj.isFull(*args)\n            result.append(res)\n        else:\n            # Unsupported operation\n            result.append(None)\n\n    # Convert Python None/True/False to JSON null/true/false\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for implementation of circular deque, with each line: \"虛擬碼步驟 // 解釋\". Use arrow, Start, End, Decision: etc. Provide step-by-step. Should not output real code. Let's produce a structured plan.\n\nWe'll define class MyCircularDeque, init with array size, pointers front, rear, count. Provide operations with checks. Provide decision branches.\n\nLet's output as per format.\n\nWe'll have Start. Then Step 1: Initialize data structures. Then Step 2: InsertFront with checks: if full return false else add, adjust front pointer, increment count, return true. Similarly for others.\n\nWe'll produce each as lines with explanations.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCircularDeque 類別並宣告資料成員: 數組 buffer[k], 整數 front = 0, rear = 0, count = 0, capacity = k // 初始化儲存結構與指標\n→ Step 2: 建構子 MyCircularDeque(k) // 設定最大容量\n    → Assign capacity = k\n    → Allocate buffer[capacity]  // 用於存放元素\n    → front ← 0\n    → rear ← 0\n    → count ← 0\n→ Decision: 插入前端 insertFront(x)?\n    Yes → Step 3: 檢查是否滿: If count == capacity return false // 無法插入\n    No  → Step 4: 計算新 front: front ← (front - 1 + capacity) mod capacity // 循環指標往前移\n    → Step 5: buffer[front] ← x // 放入元素\n    → Step 6: count ← count + 1\n    → Step 7: return true // 插入成功\n→ Decision: 插入後端 insertLast(x)?\n    Yes → Step 8: 檢查是否滿: If count == capacity return false\n    No  → Step 9: buffer[rear] ← x // 放入元素\n    → Step 10: rear ← (rear + 1) mod capacity // 循環指標往後移\n    → Step 11: count ← count + 1\n    → Step 12: return true\n→ Decision: 刪除前端 deleteFront()?\n    Yes → Step 13: 檢查是否空: If count == 0 return false\n    No  → Step 14: front ← (front + 1) mod capacity // 循環移至下一個位置\n    → Step 15: count ← count - 1\n    → Step 16: return true\n→ Decision: 刪除後端 deleteLast()?\n    Yes → Step 17: 檢查是否空: If count == 0 return false\n    No  → Step 18: rear ← (rear - 1 + capacity) mod capacity // 循環移至前一個位置\n    → Step 19: count ← count - 1\n    → Step 20: return true\n→ Decision: 取得前端 getFront()?\n    Yes → Step 21: If count == 0 return -1 // 空時回傳 -1\n    No  → Step 22: return buffer[front] // 取前端元素\n→ Decision: 取得後端 getRear()?\n    Yes → Step 23: If count == 0 return -1\n    No  → Step 24: idx ← (rear - 1 + capacity) mod capacity // 取得最後一個元素位置\n    → Step 25: return buffer[idx]\n→ Decision: isEmpty()?\n    Yes → Step 26: return count == 0 // 判斷是否為空\n→ Decision: isFull()?\n    Yes → Step 27: return count == capacity // 判斷是否已滿\nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8jxksb1c.py\", line 44, in <module>\n    ops = ast.literal_eval(ops_str)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"WordDictionary\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, idx: int) -> bool:\n            if idx == len(word):\n                return node.is_end\n            ch = word[idx]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, idx + 1):\n                        return True\n                return False\n            else:\n                if ch not in node.children:\n                    return False\n                return dfs(node.children[ch], idx + 1)\n        return dfs(self.root, 0)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # split into operations and arguments\n    ops_str, args_str = data.split(',', 1)\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    results = []\n    wd = None\n    for op, arg in zip(ops, args):\n        if op == \"WordDictionary\":\n            wd = WordDictionary()\n            results.append(None)\n        elif op == \"addWord\":\n            wd.addWord(arg[0])\n            results.append(None)\n        elif op == \"search\":\n            results.append(wd.search(arg[0]))\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for WordDictionary class supporting addWord and search with dot support. Use typical Trie with DFS. We produce steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and decisions. Let's output like pseudo algorithm, not actual code. Provide step by step. Let's design algorithm: init trie root; addWord: insert char by char; if missing node create; at end set isWord true. search: use recursive DFS: at each position if char is dot iterate all children; else traverse specific child; if no child return false; after processing all chars return isWord flag. Use decision blocks.\n\nLet's produce in lines. Use Start and End. Provide each step. Use indentation for decisions. Provide code like:\n\nStart\n→ Step 1: 初始化 root 節點 // 建立 Trie 根\n→ Decision: addWord? ... but we just define methods; maybe outline methods.\n\nBetter produce method pseudocode separately:\n\nWordDictionary constructor\nWordDictionary addWord\nWordDictionary search\n\nBut requirement: \"逐行生成虛擬碼\" maybe include all methods.\n\nLet's produce:\n\nStart\n→ Step 1: 定義 TrieNode 類 // 有 children 映射與 isWord 標誌\n→ Step 2: WordDictionary 初始化 root // 建立根節點\n→ Step 3: addWord(word) // 插入字串\n    → For each char in word\n        → If char not in current.children → create new TrieNode\n        → Move current to child\n    → End For\n    → 設置 current.isWord = true // 標記單詞結束\n→ Step 4: search(word) // 查詢字串\n    → 定義 recursive helper(node, index)\n        → Decision: index == len(word)?\n            Yes → Return node.isWord // 完整比對\n            No  → Decision: word[index] == '.'\n                Yes →\n                    → Decision: node.children 为空?\n                        Yes → Return false // 無子節點可匹配\n                        No  →\n                            → For each child in node.children\n                                → If helper(child, index+1) 返回 true → Return true\n                            → Return false // 所有子節點均不匹配\n                No  →\n                    → Decision: word[index] in node.children?\n                        Yes → Return helper(node.children[word[index]], index+1)\n                        No  → Return false\n    → 呼叫 helper(root, 0) // 開始遞迴\nEnd\n\nBut we need to use arrow notation.\n\nLet's produce each line with virtual code arrow and explanation. Use \"→\" and \"Yes →\", \"No →\". Provide decisions indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode 類 // 具備 children 映射與 isWord 標誌  \n→ Step 2: WordDictionary() 初始化 root 節點 // 建立 Trie 的根節點  \n→ Step 3: addWord(word) // 插入字串至 Trie  \n    → Decision: for each char in word? // 逐字元遍歷  \n        Yes → Decision: char 不在 current.children?  \n            Yes → Step 4: 創建新 TrieNode 並加入 current.children[char]  \n            No  → // 子節點已存在，直接使用  \n        → Step 5: current ← current.children[char] // 移動至該子節點  \n    → End For  \n    → Step 6: current.isWord ← true // 標記單詞結束  \n→ Step 7: search(word) // 查詢字串，允許 '.' 匹配任意字母  \n    → Decision: 定義 recursive helper(node, index)?  \n        Yes → Step 8: helper(node, index)  \n            → Decision: index == len(word)? // 已處理完所有字元  \n                Yes → Step 9: Return node.isWord // 成功匹配到完整單詞  \n                No  → Decision: word[index] == '.'? // 點號匹配任何字母  \n                    Yes → Step 10: Decision: node.children 為空?  \n                        Yes → Step 11: Return false // 無子節點可供匹配  \n                        No  → Step 12: For each child in node.children  \n                            → Decision: helper(child, index+1) 返回 true?  \n                                Yes → Step 13: Return true // 有子節點匹配成功  \n                                No  → // 繼續嘗試其他子節點  \n                        → Step 14: Return false // 所有子節點均不匹配  \n                    No  → Step 15: Decision: word[index] 在 node.children?  \n                        Yes → Step 16: Return helper(node.children[word[index]], index+1) // 直接往下匹配  \n                        No  → Step 17: Return false // 沒有對應子節點  \n        End Decision  \n    → Step 18: 呼叫 helper(root, 0) // 從根節點開始遞迴搜索  \n    → Step 19: Return result of helper // 返回查詢結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp100f7ikq.py\", line 24, in <module>\n    commands = json.loads(lines[0])\n               ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 50 (char 49)"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8c5tos8h.py\", line 24, in <module>\n    commands = json.loads(lines[0])\n               ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 43 (char 42)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)            # build the heap with the initial numbers\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # The input format is two JSON arrays on separate lines\n    lines = data.splitlines()\n    commands = json.loads(lines[0])\n    args = json.loads(lines[1])\n\n    results = []\n    obj = None\n    for i, cmd in enumerate(commands):\n        if cmd == \"KthLargest\":\n            obj = KthLargest(*args[i])\n            results.append(None)  # null in JSON\n        else:\n            results.append(getattr(obj, cmd)(*args[i]))\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: KthLargest class with constructor and add method. Use a min-heap of size k. Steps: store k, heap. In constructor, for each number in nums, add to heap: if size<k push; else if val>heap.top push pop. Then add method similar: if size<k push; else if val>heap.top push pop. Return heap.top.\n\nWe need to output line by line with explanation. Use arrows and decisions.\n\nLet's format: Start, constructor initialization, loops, decisions, add method, etc. We should break into steps.\n\nWe need to output only virtual code lines with // explanation. Let's do:\n\nStart // Start of class\n→ Step 1: Define class KthLargest with attribute k and min-heap heap // 初始化類別及屬性\n→ Step 2: Constructor(KthLargest, k, nums) // 建構子接收 k 與初始分數陣列\n    → Step 3: Set self.k = k // 記錄 k 值\n    → Step 4: Initialize self.heap as empty min-heap // 建立最小堆\n    → Step 5: For each num in nums // 逐一處理初始分數\n        → Decision: If heap.size < k? // 堆還沒滿 k\n            Yes → Step 6: Push num into heap // 放入堆中\n            No  → Decision: If num > heap.peek()? // 檢查是否比最小堆頂高\n                Yes → Step 7: Push num then Pop heap // 放入並移除最小值\n                No  → Step 8: // 不進入堆，因為不高於目前 k 大的分數\n    → Step 9: End constructor // 結束建構子\n→ Step 10: Method add(val) // 新分數加入\n    → Decision: If heap.size < k? // 堆還沒滿\n        Yes → Step 11: Push val into heap // 放入堆\n        No  → Decision: If val > heap.peek()? // 新分數比最小堆頂高\n            Yes → Step 12: Push val then Pop heap // 放入並移除最小值\n            No  → Step 13: // 保持堆不變\n    → Step 14: Return heap.peek() // 返回 k 大的分數\nEnd // 結束程式\n\nNeed to ensure syntax uses arrows. We can include indentation but each line separate. Ensure each line ends with //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 KthLargest，屬性 k 與 min-heap heap // 初始化類別及必要屬性\n→ Step 2: Constructor KthLargest(k, nums) // 建構子接收 k 與初始分數陣列\n    → Step 3: 設定 self.k = k // 記錄 k 值\n    → Step 4: 初始化 self.heap 為空 min-heap // 建立最小堆\n    → Step 5: 對於每個 num 於 nums // 逐一處理初始分數\n        → Decision: 如果 heap.size < k? // 堆還沒滿 k\n            Yes → Step 6: 將 num 推入 heap // 放入堆中\n            No  → Decision: 如果 num > heap.peek()? // 檢查是否比堆頂最小值大\n                Yes → Step 7: 推入 num 後 pop heap // 放入並移除最小值\n                No  → Step 8: // 不加入堆，因為不高於目前的 kth 大分數\n    → Step 9: End Constructor // 結束建構子\n→ Step 10: Method add(val) // 新分數加入\n    → Decision: 如果 heap.size < k? // 堆還沒滿\n        Yes → Step 11: 推 val 到 heap // 放入堆\n        No  → Decision: 如果 val > heap.peek()? // 新分數是否比最小堆頂高\n            Yes → Step 12: 推 val 後 pop heap // 放入並移除最小值\n            No  → Step 13: // 堆保持不變\n    → Step 14: 回傳 heap.peek() // 返回目前的 kth 大分數\nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8vh7zv1i.py\", line 49, in <module>\n    main()\n  File \"/tmp/tmp8vh7zv1i.py\", line 45, in main\n    result = solution.complexNumberMultiply(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8vh7zv1i.py\", line 21, in complexNumberMultiply\n    a_real, a_imag = parse(a)\n                     ^^^^^^^^\n  File \"/tmp/tmp8vh7zv1i.py\", line 17, in parse\n    real_part = int(s[:sep_idx])\n                ^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '1+'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        def parse(s: str):\n            # 移除尾部的 'i'\n            s = s.rstrip('i')\n            # 找到實部與虛部的分隔符號 (+ 或 -)，從後往前尋找\n            sep_idx = None\n            for i in range(len(s) - 1, 0, -1):\n                if s[i] in '+-':\n                    sep_idx = i\n                    break\n            if sep_idx is None:\n                # 只可能是 0+0i 的情況\n                return int(s), 0\n            real_part = int(s[:sep_idx])\n            imag_part = int(s[sep_idx:])\n            return real_part, imag_part\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        real_part = a_real * b_real - a_imag * b_imag\n        imag_part = a_real * b_imag + a_imag * b_real\n\n        # 格式化輸出：若 imag_part 為負號，Python 會自動把負號放在數字前\n        return f\"{real_part}{'+' if imag_part >= 0 else ''}{imag_part}i\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入切成兩段，預期形如 '\"1+1i\", \"1+1i\"' 或 '1+1i,1+1i'\n    parts = [p.strip() for p in data.split(',', 1)]\n    if len(parts) != 2:\n        # 如果輸入格式不符，直接輸出錯誤訊息\n        print(\"Invalid input\")\n        return\n    # 去除可能存在的雙引號或單引號\n    num1 = parts[0].strip('\\'\"')\n    num2 = parts[1].strip('\\'\"')\n\n    solution = Solution()\n    result = solution.complexNumberMultiply(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to multiply two complex numbers represented as strings. The algorithm: parse strings to real and imag integers; compute (a+bi)*(c+di) = (ac - bd) + (ad+bc)i. Then produce string in same format, real + imag i. Also handle sign of imaginary part: output like \"real+imaginaryi\" or \"real-imaginaryi\" if imaginary negative. Real part always integer, can be negative.\n\nSteps: Start, input strings, parse function, compute product, format string, output. Decision? For parsing, need to handle + or - sign for imaginary. We can use string operations: find 'i', split part before 'i', find the index of '+' or '-' for separating real and imaginary. Implementation in virtual pseudocode.\n\nWe must output each line with \"虛擬碼步驟 // 解釋\". Provide arrows and decision blocks as required. Use \"Start\", \"End\", \"Decision:\" etc.\n\nLet's produce step-by-step.\n\nPossible flow:\n\nStart\n→ Input num1 // get first complex number string\n→ Input num2 // get second complex number string\n→ Parse num1 to (a,b) // convert to integers\n→ Parse num2 to (c,d)\n→ Compute realPart = a * c - b * d\n→ Compute imagPart = a * d + b * c\n→ Format result string\n→ Output result\nEnd\n\nFor parse step: could be substeps: find index of 'i', get imag part, get real part, handle sign.\n\nWe can add decision to handle negative imaginary part: if imagPart >= 0 then format with '+' else with '-'.\n\nLet's produce.\n\nMake sure to include decision block.\n\nWe'll produce lines with appropriate arrows.\n\nUse indentation? The example shows indent with tab for nested decisions. We can indent similarly.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 輸入字串 num1 // 取得第一個複數字串\n→ Step 2: 輸入字串 num2 // 取得第二個複數字串\n→ Step 3: ParseComplex(num1) → (a,b) // 將字串解析為實部 a 與虛部 b\n→ Step 4: ParseComplex(num2) → (c,d) // 將字串解析為實部 c 與虛部 d\n→ Step 5: realPart = a * c - b * d // 計算實部\n→ Step 6: imagPart = a * d + b * c // 計算虛部\n→ Decision: imagPart  >= 0? // 判斷虛部符號\n    Yes → resultStr = realPart + \"+\" + imagPart + \"i\" // 正號\n    No  → resultStr = realPart + \"-\" + abs(imagPart) + \"i\" // 負號\n→ Step 7: 輸出 resultStr // 顯示乘積結果\nEnd // 程式結束\n\nWe also need to detail ParseComplex steps: maybe include sub-steps inside that step or separate.\n\nBetter to expand ParseComplex into steps:\n\n→ Step 3a: Find index of 'i' // locate imaginary unit\n→ Step 3b: imagStr = substring up to 'i' excluding real part\n→ Step 3c: Find the '+' or '-' before imagStr to separate real\n→ Step 3d: realStr = substring before sign\n→ Step 3e: Convert realStr to int a\n→ Step 3f: Convert imagStr to int b\n\nBut we can keep it simple.\n\nHowever the requirement: \"逐行地產生對應的虛擬碼\" We can include sub-steps.\n\nI'll incorporate parse as separate lines: parseNum1 and parseNum2 with sub-steps.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 num1 // 取得第一個複數字串  \n→ Step 2: 輸入字串 num2 // 取得第二個複數字串  \n\n// ---------- 解析第一個複數 ----------\n→ Step 3a: Find index of 'i' in num1 // 找到虛部符號位置  \n→ Step 3b: imagStr1 = substring from start to index-1 // 取出實部+虛部文字  \n→ Step 3c: Find separator ('+' 或 '-') 在 imagStr1 之後的位置 // 分離實部與虛部  \n→ Step 3d: realStr1 = substring 前面為實部文字 // 取出實部文字  \n→ Step 3e: imagSign1 = 取 separator 的符號 // 處理正負號  \n→ Step 3f: imagValStr1 = substring 後面為虛部文字 // 取出虛部文字  \n→ Step 3g: a = ConvertToInt(realStr1) // 將實部文字轉為整數  \n→ Step 3h: b = ConvertToInt(imagSign1 + imagValStr1) // 虛部帶符號轉為整數  \n\n// ---------- 解析第二個複數 ----------\n→ Step 4a: Find index of 'i' in num2 // 找到虛部符號位置  \n→ Step 4b: imagStr2 = substring from start to index-1 // 取出實部+虛部文字  \n→ Step 4c: Find separator ('+' 或 '-') 在 imagStr2 之後的位置 // 分離實部與虛部  \n→ Step 4d: realStr2 = substring 前面為實部文字 // 取出實部文字  \n→ Step 4e: imagSign2 = 取 separator 的符號 // 處理正負號  \n→ Step 4f: imagValStr2 = substring 後面為虛部文字 // 取出虛部文字  \n→ Step 4g: c = ConvertToInt(realStr2) // 將實部文字轉為整數  \n→ Step 4h: d = ConvertToInt(imagSign2 + imagValStr2) // 虛部帶符號轉為整數  \n\n// ---------- 計算乘積 ----------\n→ Step 5: realPart = a * c - b * d // 計算實部 (ac - bd)  \n→ Step 6: imagPart = a * d + b * c // 計算虛部 (ad + bc)  \n\n// ---------- 組成結果字串 ----------\n→ Decision: imagPart >= 0? // 判斷虛部符號  \n    Yes → resultStr = realPart + \"+\" + imagPart + \"i\" // 虛部為正號  \n    No  → resultStr = realPart + \"-\" + abs(imagPart) + \"i\" // 虛部為負號  \n\n→ Step 7: 輸出 resultStr // 顯示乘積結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\", \"root/4.txt\"]]'"
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"返回所有重複文件路徑組。\"\"\"\n        content_map = defaultdict(list)\n        for path in paths:\n            parts = path.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content[:-1]  # 去掉最後的 ')'\n                full_path = root + '/' + name\n                content_map[content].append(full_path)\n        return [files for files in content_map.values() if len(files) > 1]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    # 取出 'paths =' 之後的列表字串\n    if '=' in raw_input:\n        _, list_str = raw_input.split('=', 1)\n        list_str = list_str.strip()\n    else:\n        list_str = raw_input\n    # 解析為 Python 列表\n    try:\n        paths = ast.literal_eval(list_str)\n    except Exception as e:\n        # 如果解析失敗，直接輸出空列表\n        print(\"[]\")\n        sys.exit(0)\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    duplicate_groups = solution.findDuplicate(paths)\n    # 使用 JSON 輸出，確保字串使用雙引號\n    print(json.dumps(duplicate_groups))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm. We need to output line-by-line with \"虛擬碼步驟 // 解釋\". The algorithm: parse input list of strings, split by space, first token directory path, rest tokens are file info. For each file info, split by '(', get filename and content (excluding trailing ')'). Build map from content to list of file paths. After processing all, iterate map and collect lists with size >1. Return list of lists.\n\nWe need to output pseudo code with Start, End, Decision, etc. We'll produce lines accordingly. Use arrows → for next steps. Use Decision blocks with Yes→, No→. Use appropriate comments.\n\nWe need to be careful: The algorithm is straightforward; but we must incorporate all steps. We need to provide a structured flow: Start, iterate input, parse each line, split, etc. We'll produce pseudo code accordingly.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 content_to_paths 為空映射 // 建立內容到路徑的映射\n→ Step 2: 遍歷每個 directoryInfo 在 input_list // 逐行處理每個目錄資訊\n    → Step 2.1: 將 directoryInfo 按空格分割為 tokens // tokens[0] 是目錄路徑\n    → Step 2.2: 設定 dir_path 為 tokens[0] // 取得目錄路徑\n    → Step 2.3: 從 tokens[1] 開始遍歷每個 fileToken // 逐個檔案資訊\n        → Step 2.3.1: 在 fileToken 中尋找 '(' 的位置 // 找出內容開始位置\n        → Decision: 如果沒有 '('? // 檢查格式是否正確\n            Yes → Step 2.3.1a: 跳過此檔案 // 若格式錯誤則忽略\n            No  →\n                → Step 2.3.1b: 取得 file_name 為 substring前 '(' // 檔名\n                → Step 2.3.1c: 取得 file_content 為 substring between '(' 與 ')' // 內容\n                → Step 2.3.1d: 組成 full_path = dir_path + '/' + file_name // 完整路徑\n                → Step 2.3.1e: 若 content_to_paths 不含 file_content 則新增空列表 // 初始化\n                → Step 2.3.1f: 將 full_path 加入 content_to_paths[file_content] // 儲存\n→ Step 3: 初始化 result 為空列表 // 結果列表\n→ Step 4: 遍歷 content_to_paths 的每一對 (content, paths)\n    → Decision: 如果 paths 長度 ≥ 2? // 判斷是否為重複\n        Yes → Step 4.1: 將 paths 加入 result // 收集重複文件組\n        No  → Skip // 不是重複則忽略\n→ End // 程式結束，返回 result\n\nWe need to output each line with \"虛擬碼步驟 // 解釋\". Use arrows and decisions. Provide in Chinese. Ensure each line has a comment after a space.\n\nWe need to include \"Start\", \"End\". Use indentation to show nested steps. Use arrow arrow for indentation? The example uses arrow before step. For nested steps, indent with spaces.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 content_to_paths 為空映射 // 建立內容到路徑的映射\n→ Step 2: 遍歷每個 directoryInfo 在 input_list // 逐行處理每個目錄資訊\n    → Step 2.1: 將 directoryInfo 按空格分割為 tokens // tokens[0] 是目錄路徑\n    → Step 2.2: 設定 dir_path 為 tokens[0] // 取得目錄路徑\n    → Step 2.3: 從 tokens[1] 開始遍歷每個 fileToken // 逐個檔案資訊\n        → Step 2.3.1: 在 fileToken 中尋找 '(' 的位置 // 找出內容開始位置\n        → Decision: 如果沒有 '('? // 檢查格式是否正確\n            Yes → Step 2.3.1a: 跳過此檔案 // 若格式錯誤則忽略\n            No  →\n                → Step 2.3.1b: 取得 file_name 為 substring 前 '(' // 檔名\n                → Step 2.3.1c: 取得 file_content 為 substring 之間 '(' 與 ')' // 內容\n                → Step 2.3.1d: 組成 full_path = dir_path + '/' + file_name // 完整路徑\n                → Step 2.3.1e: 若 content_to_paths 不含 file_content 則新增空列表 // 初始化\n                → Step 2.3.1f: 將 full_path 加入 content_to_paths[file_content] // 儲存\n→ Step 3: 初始化 result 為空列表 // 結果列表\n→ Step 4: 遍歷 content_to_paths 的每一對 (content, paths)\n    → Decision: 如果 paths 長度 ≥ 2? // 判斷是否為重複\n        Yes → Step 4.1: 將 paths 加入 result // 收集重複文件組\n        No  → Step 4.2: 跳過此內容 // 不是重複則忽略\n→ End // 程式結束，返回 result"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[9]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[9]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[5,8]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[5, 8]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[1,2,7]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[1, 2, 7]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\ndef rand7() -> int:\n    \"\"\"Return a uniformly random integer in [1, 7].\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"Return a uniformly random integer in [1, 10] using only rand7().\"\"\"\n        while True:\n            # 產生 1~49 的均勻分佈\n            num = (rand7() - 1) * 7 + rand7()\n            if num <= 40:          # 只接受 1~40 的範圍\n                return 1 + (num - 1) % 10\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取輸入，格式預期類似 \"n = 3\"\n    raw_input = sys.stdin.read().strip()\n    # 找出等號後的整數\n    try:\n        n = int(raw_input.split('=')[1].strip())\n    except Exception:\n        n = 0\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating uniform random 1-10 using rand7 only. Standard method: use two rand7 to create range 1-49, reject >40, then map to 1-10. Provide steps line by line with explanations.\n\nWe output lines with virtual code and comment. Use Start, → Step, Decision etc. Also use Yes → No → etc.\n\nNeed to describe function rand10() steps. Provide logic.\n\nLet's craft:\n\nStart\n→ Step 1: Define function rand10() // begin function\n→ Step 2: Repeat\n→ Decision: 使用 rand7() 兩次產生 num1, num2 // generate two random numbers\n→ Step 3: Compute idx = (num1 - 1) * 7 + num2 // index 1-49\n→ Decision: 如果 idx > 40? // reject if >40\n→   Yes → Continue // loop back to Repeat\n→   No → Step 4: Return (idx - 1) mod 10 + 1 // map to 1-10\n→ End\n\nBut need to format: Start //, → Step ... etc.\n\nAlso need to include arrow for loop.\n\nWe can represent loop as: → Decision: idx > 40? then Yes → Repeat, No → Return. Use Continue or Repeat.\n\nLet's produce.\n\nAlso we need to mention each line: virtual code + // explanation.\n\nLet's produce 12-15 lines.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 rand10() // 開始定義要實作的函式  \n→ Step 2: Repeat // 進入迴圈，重複直到產生可接受的值  \n→ Decision: 產生兩個 rand7() → num1, num2 // 用兩個 rand7 產生兩個隨機數  \n→ Step 3: 計算 idx = (num1 - 1) * 7 + num2 // 將兩個數轉換成 1~49 的索引  \n→ Decision: idx > 40? // 檢查索引是否落在可接受的 1~40 範圍  \n    Yes → Repeat // 若大於 40，跳回 Repeat 重新嘗試  \n    No  → Step 4: 回傳 (idx - 1) mod 10 + 1 // 將 1~40 映射到 1~10  \n→ End // 函式執行結束  \n\n---  \n說明：這個流程利用兩次 rand7() 產生 49 個可能的組合，將其中 40 個（1~40）映射為 1~10 的均勻分佈；若產生的組合為 41~49，則丟棄並重新嘗試，確保最終結果的均勻性。"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n        return (\n            dists[0] > 0\n            and dists[0] == dists[1] == dists[2] == dists[3]\n            and dists[4] == dists[5]\n            and dists[4] == 2 * dists[0]\n        )\n\ndef main():\n    data = sys.stdin.read()\n    # 找出所有整數（含負號）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 8:\n        print(\"false\")\n        return\n    p1 = [nums[0], nums[1]]\n    p2 = [nums[2], nums[3]]\n    p3 = [nums[4], nums[5]]\n    p4 = [nums[6], nums[7]]\n\n    sol = Solution()\n    result = sol.validSquare(p1, p2, p3, p4)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps to check if four points form a square. Must output step by step with arrows, decisions, comments. Must be in Traditional Chinese. Steps: Compute all pairwise distances squared. There should be 6 distances: 4 sides equal, 2 diagonals equal and larger. Count frequency of distances. Check that there are exactly two distinct distances, side occurs 4 times, diagonal 2 times, and diagonal distance is twice side distance. Also ensure side > 0. Return true if conditions met.\n\nWe'll produce steps: Start, Step 1: Compute list of points. Step 2: Compute all distances squared between points and store in array. Step 3: Use a map to count frequencies. Step 4: Decision: check size of map==2. Yes -> Next Decision: check that one distance occurs 4 times, other 2 times. Yes -> Decision: check that larger distance is twice smaller distance. Yes -> Step: return true. Else return false. End.\n\nAlso we need to handle that side>0: we can check that smallest distance>0.\n\nOk produce with arrows. Use Start, End, Decision. Ensure every line has the format: \"虛擬碼步驟 // 解釋\". We'll use arrows '→' after each step. Also indentation for decisions. Use Yes → and No →.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得四點座標 p1, p2, p3, p4 // 從輸入取得 4 個點  \n→ Step 2: 初始化空列表 distances // 用來存儲所有 6 對距離平方值  \n→ Step 3: 對每一對點 (i, j) 其中 i < j  \n  → Step 3.1: 計算 dx = p_i.x - p_j.x, dy = p_i.y - p_j.y  \n  → Step 3.2: distances.Add(dx*dx + dy*dy) // 存入距離平方，避免根號計算  \n→ Step 4: 初始化字典 freq // 用來統計每個距離平方出現次數  \n→ Step 5: 對每個 d in distances  \n  → Step 5.1: freq[d] = freq.get(d, 0) + 1 // 更新頻率  \n→ Decision: freq 中鍵的數量是否等於 2? // 檢查是否只有兩種不同距離  \n  Yes → Decision: 其中一個距離出現 4 次且另一個 2 次?  \n   Yes → Decision: 最小距離 > 0? // 確保邊長正長  \n    Yes → Decision: 最大距離 == 2 * 最小距離? // 對角距離為邊長平方的兩倍  \n     Yes → Step 6: 返回 true // 四點組成正方形  \n     No  → Step 6: 返回 false // 對角距離不符合正方形特性  \n    No  → Step 6: 返回 false // 最小距離不是正長  \n   No  → Step 6: 返回 false // 出現次數不符合 4 與 2  \n  No → Step 6: 返回 false // 不是兩種距離，不能是正方形  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8f_p7xim.py\", line 46, in parse_input\n    parsed = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x775cd4d6a150>\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp8f_p7xim.py\", line 52, in <module>\n    price, special, needs = parse_input()\n                            ^^^^^^^^^^^^^\n  File \"/tmp/tmp8f_p7xim.py\", line 48, in parse_input\n    raise ValueError(f\"Failed to parse input: {e}\")\nValueError: Failed to parse input: malformed node or string on line 1: <ast.Name object at 0x775cd4d6a150>"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprlumh3yw.py\", line 46, in parse_input\n    parsed = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x74f4bb96a0d0>\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmprlumh3yw.py\", line 52, in <module>\n    price, special, needs = parse_input()\n                            ^^^^^^^^^^^^^\n  File \"/tmp/tmprlumh3yw.py\", line 48, in parse_input\n    raise ValueError(f\"Failed to parse input: {e}\")\nValueError: Failed to parse input: malformed node or string on line 1: <ast.Name object at 0x74f4bb96a0d0>"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom typing import List, Tuple, Dict\n\nclass Solution:\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\n        n = len(price)\n        memo: Dict[Tuple[int, ...], int] = {}\n\n        def dfs(curr_needs: Tuple[int, ...]) -> int:\n            if curr_needs in memo:\n                return memo[curr_needs]\n            # Base cost: buy remaining items at regular price\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            # Try each special offer\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:  # offer can be applied\n                    offer_price = offer[-1]\n                    res = min(res, offer_price + dfs(tuple(temp)))\n            memo[curr_needs] = res\n            return res\n\n        return dfs(tuple(needs))\n\ndef parse_input() -> Tuple[List[int], List[List[int]], List[int]]:\n    \"\"\"\n    Parse the input from stdin. The input format is expected to be:\n        price = [...], special = [[...], [...]], needs = [...]\n    This function transforms the string into a Python dictionary and returns\n    the three required lists.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        raise ValueError(\"No input provided\")\n    # Replace '=' with ':' for dict syntax\n    data = re.sub(r'(\\w+)\\s*=\\s*', r'\\1: ', data)\n    # Wrap the content in braces to form a valid dict literal\n    data = '{' + data + '}'\n    try:\n        parsed = ast.literal_eval(data)\n    except Exception as e:\n        raise ValueError(f\"Failed to parse input: {e}\")\n    return parsed['price'], parsed['special'], parsed['needs']\n\nif __name__ == \"__main__\":\n    price, special, needs = parse_input()\n    solution = Solution()\n    result = solution.shoppingOffers(price, special, needs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for solving the described problem: LeetCode Store items with special offers, compute minimum price for exact needs. We need algorithm: DFS with memoization (DP). Use backtracking with pruning. The problem is known: \"Shopping Offers\" (LC 638). Approach: recursive function dfs(remaining) that returns min cost. For each offer, if applicable (doesn't exceed remaining), apply offer and call recursively. Also consider buying remaining items at regular price. Use memoization map from tuple to cost.\n\nWe need to output virtual code line by line with explanations.\n\nWe'll structure algorithm: Start, Step 1: Input arrays price, needs, special. Step 2: define memo map. Step 3: define function dfs(remain). Step 4: convert remain to key string. Step 5: if key in memo, return memo[key]. Step 6: compute default cost (sum of remain[i]*price[i]). Step 7: iterate over each offer in special. Check if offer can be applied (for all i, offer[i] <= remain[i]). If so, new_remain = remain - offer[i] for each i. Recursively call dfs(new_remain) + offer price. Take min. Step 8: memo[key] = result. Step 9: return result. Step 10: Call dfs(needs). Return result. End.\n\nWe need to use virtual code syntax: Start, Step lines, Decision, arrows. Should be \"虛擬碼步驟\" e.g., \"Step 1: ...\" and explanation after //.\n\nWe must not output actual code. Just pseudo-code with arrow structure. Let's produce line by line.\n\nWe'll include loops and decisions with \"Decision:\" lines.\n\nWe need to include variable names like price, needs, special. Let's produce.\n\nWe'll include mapping: key = string join of remain.\n\nOk. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 price, needs, special // 取得所有價格、需求與特價方案  \n→ Step 2: 建立 memo map <string, number> // 用來記錄已算過的需求組合的最小價格  \n\n→ Step 3: 定義遞迴函式 dfs(remain: array of number) // 參數為目前尚未購買的物品需求  \n  → Step 3.1: key ← join(remain, ',') // 以逗號分隔的字串作為 memo 的 key  \n    Decision: 如果 key 已存在於 memo? // 判斷是否已計算此需求組合  \n     Yes → Step 3.2: Return memo[key] // 直接回傳已記錄的最小價格  \n     No  → // 需重新計算  \n\n  → Step 3.3: baseCost ← 0 // 先算「不使用任何特價」的成本  \n    Decision: 對 i from 0 to n-1? // 逐一累加  \n     Yes → baseCost ← baseCost + remain[i] * price[i] // 直接按單價購買  \n     No  → // 完成 baseCost 計算  \n\n  → Step 3.4: minCost ← baseCost // 初始最小成本為 baseCost  \n\n  → Step 3.5: 對每個 offer in special? // 嘗試所有特價方案  \n    Decision: 若 offer 可用於 remain? // 所有 offer[j] ≤ remain[j]  \n     Yes → newRemain ← array of number // 創建新的需求  \n      Decision: 對 j from 0 to n-1?  \n       Yes → newRemain[j] ← remain[j] - offer[j] // 減去已購買的件數  \n       No  → // newRemain 完成"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,9,null,8]'\nGot (Norm):      '[None,9,None,8]'\n--- (Raw) ---\nRaw Expected: '[null, 9, null, 8]'\nRaw Got:      '[None, 9, None, 8]'"
        }
      ],
      "generated_code": "import sys\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]            # 原始數組的拷貝\n        self.tree = [0] * (self.n + 1) # Binary Indexed Tree\n        for i, val in enumerate(nums):\n            self._update_tree(i + 1, val)\n\n    def _update_tree(self, idx, val):\n        while idx <= self.n:\n            self.tree[idx] += val\n            idx += idx & -idx\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, idx):\n        res = 0\n        while idx > 0:\n            res += self.tree[idx]\n            idx -= idx & -idx\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，預期形式為 ('[\"NumArray\", ...], [[[...]], ...])'\n    ops, args = eval(data)\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            obj = NumArray(arg[0])  # arg[0] 為數組\n            res.append(None)\n        elif op == \"sumRange\":\n            res.append(obj.sumRange(arg[0], arg[1]))\n        elif op == \"update\":\n            obj.update(arg[0], arg[1])\n            res.append(None)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line. Should cover initialization, update, sumRange, likely using a segment tree or BIT. We'll use a Binary Indexed Tree (Fenwick). Provide steps for class, constructor, update, sumRange, internal functions. Provide each line with virtual code and comment. Use arrows and decisions.\n\nWe need to use format: `虛擬碼步驟 // 解釋`. Each line. Provide Start, End. Use arrow for steps. Let's produce flow:\n\nStart\n→ Initialize class with nums: store array, build BIT\n→ Function update(index, val): compute delta, update BIT\n→ Function sumRange(left, right): compute prefix sums\n→ End\n\nAlso internal function build BIT. We'll produce decision for null? Probably not.\n\nLet's produce structured steps:\n\nStart // 程式開始\n→ Class NumArray // 定義類別\n    → Constructor(nums) // 建構子\n        → this.nums ← nums // 儲存原始陣列\n        → this.bit ← new array(nums.length + 1) // 建立 BIT\n        → For i = 0 to nums.length-1 // 初始化 BIT\n            → add(i, nums[i]) // 將值加入 BIT\n        → EndFor\n    → EndConstructor\n    → Method update(index, val)\n        → delta ← val - nums[index] // 計算差值\n        → nums[index] ← val // 更新原始陣列\n        → add(index, delta) // 更新 BIT\n    → EndMethod\n    → Method sumRange(left, right)\n        → return prefixSum(right) - prefixSum(left - 1) // 計算區間和\n    → EndMethod\n    → Helper Method add(idx, delta)\n        → i ← idx + 1 // BIT 1-indexed\n        → While i <= bit.length-1\n            → bit[i] ← bit[i] + delta // 更新節點\n            → i ← i + (i & -i) // 移動到父節點\n        → EndWhile\n    → EndHelper\n    → Helper Method prefixSum(idx)\n        → sum ← 0\n        → i ← idx + 1\n        → While i > 0\n            → sum ← sum + bit[i] // 累加\n            → i ← i - (i & -i) // 移動到上一個節點\n        → EndWhile\n        → return sum\n    → EndHelper\nEnd // 程式結束\n\nBut we must output each line separately, using arrow and decision. We may need to include indentation? The format shows arrow \"→\" at beginning of line. For nested we can indent? Example in prompt, they indent \"→ Decision: ...\" and inside \"Yes →\". So we can indent with spaces.\n\nWe'll produce each step line. For loops and while, use Decision? Not necessary. But we can represent loops as Decision: While condition? We can use Decision: while i <= ... and Yes/No branches. But the example shows Decision for condition with Yes/No. For loops maybe we can skip Decision but provide arrow step for loop start.\n\nWe need to adhere to \"使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:)\" so loops could be represented as Decision: While i <= ... with Yes → step inside.\n\nLet's craft.\n\nWe'll have:\n\nStart // 程式開始執行\n→ Class NumArray // 定義類別\n    → Constructor(nums) // 建構子\n        → this.nums ← nums // 儲存陣列\n        → this.bit ← new array(nums.length + 1) // 初始化 BIT\n        → Decision: i = 0 to nums.length-1? // 循環建立 BIT\n            Yes → i ← i + 1 // 更新索引\n            Yes → add(i-1, nums[i-1]) // 加入 BIT\n            No  → // 迴圈結束\n        → EndDecision\n    → EndConstructor\n    → Method update(index, val) // 更新元素\n        → delta ← val - nums[index] // 計算差值\n        → nums[index] ← val // 更新陣列\n        → add(index, delta) // 更新 BIT\n    → EndMethod\n    → Method sumRange(left, right) // 查詢區間和\n        → return prefixSum(right) - prefixSum(left - 1) // 計算結果\n    → EndMethod\n    → Method add(idx, delta) // BIT 加法\n        → i ← idx + 1 // BIT 1-indexed\n        → Decision: i <= bit.length-1? // 更新節點\n            Yes → bit[i] ← bit[i] + delta // 更新\n            Yes → i ← i + (i & -i) // 移動\n            No  → // 迴圈結束\n        → EndDecision\n    → EndMethod\n    → Method prefixSum(idx) // BIT 前綴和\n        → sum ← 0\n        → i ← idx + 1\n        → Decision: i > 0? // 累加\n            Yes → sum ← sum + bit[i] // 加入\n            Yes → i ← i - (i & -i) // 移動\n            No  → // 迴圈結束\n        → EndDecision\n        → return sum\n    → EndMethod\nEnd // 程式結束\n\nBut we need to use \"→ Decision:\" with Yes/No. In example, Decision: condition? then indented Yes → etc. Provide correct indentation.\n\nWe must also include comments for each line.\n\nLet's craft final output. Ensure each line begins with \"→\" except Start and End lines.\n\nAlso use proper Chinese comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class NumArray // 定義 NumArray 類別  \n    → Constructor(nums) // 建構子：傳入初始陣列  \n        → this.nums ← nums // 儲存原始陣列  \n        → this.bit ← new array(nums.length + 1) // 建立 Binary Indexed Tree（BIT）  \n        → Decision: i = 0; i < nums.length; i++? // 迭代所有元素以初始化 BIT  \n            Yes → i ← i + 1 // 索引遞增  \n            Yes → add(i-1, nums[i-1]) // 將值加入 BIT  \n            No  → // 迴圈結束  \n        → EndDecision  \n    → EndConstructor  \n    → Method update(index, val) // 更新指定位置的值  \n        → delta ← val - nums[index] // 計算新增差值  \n        → nums[index] ← val // 更新原始陣列  \n        → add(index, delta) // 透過 BIT 更新差值  \n    → EndMethod  \n    → Method sumRange(left, right) // 計算區間和  \n        → return prefixSum(right) - prefixSum(left - 1) // 前綴和相減得到結果  \n    → EndMethod  \n    → Method add(idx, delta) // BIT 中的加法操作  \n        → i ← idx + 1 // BIT 使用 1 為起始索引  \n        → Decision: i <= bit.length - 1? // 只要索引在 BIT 範圍內就繼續  \n            Yes → bit[i] ← bit[i] + delta // 累加差值  \n            Yes → i ← i + (i & -i) // 移動至父節點  \n            No  → // 迴圈結束  \n        → EndDecision  \n    → EndMethod  \n    → Method prefixSum(idx) // 計算從 0 到 idx 的前綴和  \n        → sum ← 0 // 初始化累加器  \n        → i ← idx + 1 // 同樣以 1 為起始索引  \n        → Decision: i > 0? // 只要索引未到 0 就繼續  \n            Yes → sum ← sum + bit[i] // 加入節點值  \n            Yes → i ← i - (i & -i) // 移動至上一個節點  \n            No  → // 迴圈結束  \n        → EndDecision  \n        → return sum // 回傳前綴和  \n    → EndMethod  \nEnd // 程式執行結束"
    },
    {
      "title": "Subarray Sum Equals K",
      "source_file": "Leetcode/leetcode560.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[1,1,1], k = 2",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkz94_fwc.py\", line 48, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkz94_fwc.py\", line 33, in parse_input\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "[1,2,3], k = 3",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmps25q92q_.py\", line 48, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmps25q92q_.py\", line 33, in parse_input\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subarray_sum(nums, k):\n    \"\"\"\n    Count the number of contiguous subarrays that sum to k.\n    Uses a prefix sum hashmap to achieve O(n) time.\n    \"\"\"\n    count = 0\n    prefix_sum = 0\n    sum_map = {0: 1}          # prefix sum 0 occurs once initially\n\n    for num in nums:\n        prefix_sum += num\n        # If there is a previous prefix sum that makes the current sum equal to k,\n        # add the number of times that prefix sum has appeared.\n        if prefix_sum - k in sum_map:\n            count += sum_map[prefix_sum - k]\n        # Record the current prefix sum.\n        sum_map[prefix_sum] = sum_map.get(prefix_sum, 0) + 1\n\n    return count\n\ndef parse_input(line: str):\n    \"\"\"\n    Parse input of the form '[1,1,1], k = 2' into a list of ints and an int k.\n    \"\"\"\n    parts = line.split(',')\n    if len(parts) < 2:\n        raise ValueError(\"Input format incorrect\")\n    nums_part = parts[0].strip()\n    k_part = ','.join(parts[1:]).strip()  # in case there are more commas\n    nums = ast.literal_eval(nums_part)\n    k_str = k_part.split('=')[-1].strip()\n    k = int(k_str)\n    return nums, k\n\nif __name__ == \"__main__\":\n    # Read the whole input (could be multi-line, but we use the first non-empty line)\n    raw_input = \"\"\n    for line in sys.stdin:\n        if line.strip():\n            raw_input = line.strip()\n            break\n    if not raw_input:\n        sys.exit(0)\n\n    nums, k = parse_input(raw_input)\n    result = subarray_sum(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments, following the arrow style. The problem: count subarrays with sum k. Typical solution uses prefix sums and hashmap. We'll produce steps: initialize map with 0->1, prefix sum 0, count 0. Loop each num: add to prefix, if prefix - k in map, add map[prefix - k] to count. increment map[prefix]. After loop, return count. We'll output Start, then steps, decision points for map existence etc. We'll produce each line.\n\nMake sure each line contains virtual code step + space + // explanation. Use arrows as specified. Use \"→\" before each step. Also decision lines: \"Decision: If prefix - k exists in map?\" with Yes →, No →.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的哈希表 sumCount 並將 sumCount[0] 設為 1 // 初始化前綴和計數，代表空前綴和出現一次  \n→ Step 2: 初始化變數 prefixSum 為 0 // 用於累積前綴和  \n→ Step 3: 初始化變數 totalCount 為 0 // 用於儲存符合條件的子陣列數目  \n→ Decision: 若 nums 不是空陣列? // 檢查輸入是否有元素  \n    Yes → Step 4: 循環遍歷 nums 的每個元素 val  \n        → Step 5: prefixSum ← prefixSum + val // 更新前綴和  \n        → Decision: 如果 (prefixSum - k) 存在於 sumCount? // 判斷是否有前綴和能使子陣列和為 k  \n            Yes → Step 6: totalCount ← totalCount + sumCount[prefixSum - k] // 將符合條件的子陣列數目累加  \n            No  → Step 6a: // 沒有符合條件的前綴和，保持 totalCount 不變  \n        → Step 7: sumCount[prefixSum] ← sumCount.get(prefixSum, 0) + 1 // 更新前綴和的出現次數  \n    No  → Step 4a: // nums 為空陣列，直接跳過循環  \n→ Step 8: 回傳 totalCount // 將符合條件的子陣列總數作為結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Two Sum II - Input Array Is Sorted",
      "source_file": "Leetcode/leetcode167.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numbers = [2,7,11,15], target = 9",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpffky5s9h.py\", line 41, in <module>\n    numbers, target = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpffky5s9h.py\", line 31, in parse_input\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numbers = [2,3,4], target = 6",
          "expected_output": "[1,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplyy1_hz5.py\", line 41, in <module>\n    numbers, target = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmplyy1_hz5.py\", line 31, in parse_input\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "numbers = [-1,0], target = -1",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppzcj02l6.py\", line 41, in <module>\n    numbers, target = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppzcj02l6.py\", line 31, in parse_input\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [-1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def twoSum(self, numbers, target):\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            s = numbers[left] + numbers[right]\n            if s == target:\n                return [left + 1, right + 1]\n            elif s < target:\n                left += 1\n            else:\n                right -= 1\n        return []\n\ndef parse_input(input_str):\n    \"\"\"\n    解析形如 \"numbers = [2,7,11,15], target = 9\" 的字串。\n    只支援 numbers 為列表、target 為整數兩種情況。\n    \"\"\"\n    parts = input_str.split(',')\n    data = {}\n    for part in parts:\n        if '=' in part:\n            key, val = part.split('=', 1)\n            key = key.strip()\n            val = val.strip()\n            if key == 'numbers':\n                # 使用 ast.literal_eval 可安全解析列表字串\n                data[key] = ast.literal_eval(val)\n            elif key == 'target':\n                data[key] = ast.literal_eval(val)\n    return data['numbers'], data['target']\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    numbers, target = parse_input(raw_input)\n    solution = Solution()\n    result = solution.twoSum(numbers, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for two pointers solution. Provide each line with explanation. Format: \"虛擬碼步驟 // 解釋\" with arrows. Use Start End Decision. Provide 1-indexed indices. We'll produce steps.\n\nLet's draft:\n\nStart // 開始程式\n→ Step 1: 初始化 left = 1, right = length of numbers // 左指標指向第一個元素，右指標指向最後一個\n→ Decision: 迴圈條件 left < right? // 確保左指標在右指標左側\n    Yes →\n        → Step 2: currentSum = numbers[left] + numbers[right] // 計算目前兩數之和\n        → Decision: currentSum 等於 target? // 檢查是否找到答案\n            Yes → \n                → Step 3: 回傳 [left, right] // 回傳一維陣列，索引已加一\n                → End // 程式結束\n            No →\n                → Decision: currentSum 小於 target? // 若和太小，需增大\n                    Yes →\n                        → Step 4: left = left + 1 // 左指標右移\n                        → No →\n                            → Step 5: right = right - 1 // 右指標左移\n    No →\n        → Step 6: End // 雖不會發生，保險結束\n\nWe need ensure each line includes 虛擬碼 and explanation. Use arrows like → etc.\n\nMake sure to use \"Start\", \"End\". Provide proper indent maybe not required but we can include. Keep each line on separate line. Provide 1-indexed indices already, so left and right represent indices. We should not convert to 0-index. Good.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: left = 1, right = length of numbers // 將左指標設為第一個元素，右指標設為最後一個元素\n→ Decision: left < right? // 確認左指標仍在右指標左側以進行搜尋\n    Yes →\n        → Step 2: currentSum = numbers[left] + numbers[right] // 計算目前左、右指標所指元素之和\n        → Decision: currentSum = target? // 檢查是否已找到符合目標的兩個數字\n            Yes →\n                → Step 3: return [left, right] // 回傳一維陣列，索引已加一\n                → End // 程式執行結束\n            No →\n                → Decision: currentSum < target? // 若和太小，需向右移動左指標\n                    Yes →\n                        → Step 4: left = left + 1 // 左指標右移一步\n                    No →\n                        → Step 5: right = right - 1 // 右指標左移一步\n    No →\n        → Step 6: End // 雖然不應發生，但保險結束程式執行"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,1,1,5,4,6]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 1, 1, 5, 4, 6]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,2,1,3,2,3]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 2, 1, 3, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def wiggleSort(self, nums):\n        # Step 1: Sort the array\n        nums.sort()\n        n = len(nums)\n        # Step 2: Swap every adjacent pair starting from index 1\n        for i in range(1, n - 1, 2):\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    # Extract the list inside brackets, e.g. \"[1,5,1,1,6,4]\"\n    match = re.search(r'\\[.*\\]', raw_input)\n    if not match:\n        raise ValueError(\"Input must contain a list of integers.\")\n    nums_str = match.group(0)\n    # Safely evaluate the list\n    nums = ast.literal_eval(nums_str)\n\n    # Apply wiggle sort\n    solution = Solution()\n    solution.wiggleSort(nums)\n\n    # Print the resulting list\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for wiggle sort. We'll produce steps: sort array, then swap adjacent pairs. Explanation each line. We'll produce Start etc. Use decision? Not needed. Provide sequential steps. Each line with \"→\" arrow? Format example uses Start, then \"→ Step\". We'll follow. Provide Step 1: sort array ascending. Step 2: for i from 1 to len-1 step 2, swap nums[i] and nums[i+1]? Actually typical algorithm: sort then swap each pair starting from index 1. So Steps: for i from 1 to n-1 step 2, swap(nums[i], nums[i+1]). That yields wiggle. Let's produce lines.\n\nAlso ensure \"End\".\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 nums 陣列從小到大排序 // 先取得有序數列，方便後續交錯排列  \n→ Step 2: 設定 i ← 1 // i 從第二個位置開始，因為 0 位置已經小於 1 位置  \n→ Step 3: Decision: i < nums.length? // 檢查是否已處理完所有元素  \n  Yes → Step 4: 交換 nums[i] 與 nums[i+1] // 使 nums[i] > nums[i+1]，滿足 wiggle 條件  \n   → Step 5: i ← i + 2 // 跳過下一個位置，移動到下一對需要交換的元素  \n  No → End // 所有元素已處理完畢  \nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprke47yqo.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmprke47yqo.py\", line 49, in main\n    results = solution.calcEquation(equations, values, queries)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmprke47yqo.py\", line 9, in calcEquation\n    graph[a][b] = val\n    ~~~~~^^^\nTypeError: unhashable type: 'list'"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0gw6_lsc.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmp0gw6_lsc.py\", line 49, in main\n    results = solution.calcEquation(equations, values, queries)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp0gw6_lsc.py\", line 8, in calcEquation\n    for (a, b), val in zip(equations, values):\n        ^^^^^^\nValueError: too many values to unpack (expected 2)"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvs8ge9ne.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpvs8ge9ne.py\", line 49, in main\n    results = solution.calcEquation(equations, values, queries)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvs8ge9ne.py\", line 8, in calcEquation\n    for (a, b), val in zip(equations, values):\n        ^^^^^^\nValueError: not enough values to unpack (expected 2, got 1)"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        results = []\n        for u, v in queries:\n            results.append(dfs(u, v, set()))\n        return results\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Find positions of the three variable assignments\n    eq_start = data.find('equations =')\n    val_start = data.find('values =')\n    q_start = data.find('queries =')\n\n    eq_str = data[eq_start + len('equations ='): val_start].strip()\n    val_str = data[val_start + len('values ='): q_start].strip()\n    q_str = data[q_start + len('queries ='):].strip()\n\n    equations = ast.literal_eval(eq_str)\n    values = ast.literal_eval(val_str)\n    queries = ast.literal_eval(q_str)\n\n    solution = Solution()\n    results = solution.calcEquation(equations, values, queries)\n\n    output = '[' + ','.join(f'{x:.5f}' for x in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: evaluate division queries given equations as graph. We'll produce step-by-step algorithm: build graph adjacency with weights. For each query, BFS/DFS to find path and product. If variable not in graph, return -1.0. Use DFS. Provide virtual steps with arrows. Let's structure: Start, BuildGraph, for each query: If not in graph or start==end -> return 1 or -1? If start==end but present, answer 1. Else DFS. Use recursion.\n\nLet's produce lines: \nStart // start\n→ BuildGraph // Build adjacency list\n→ For each query: ...\nWe need decision structure: check presence. Use Decision: if either variable not in graph? -> answer -1.0. If same variable, answer 1.0. Else DFS. Decision inside DFS: if neighbor visited? ... etc.\n\nWe must produce virtual code lines with \"Step\" maybe. Use numbering optional. Provide explanation. Let's produce.\n\nLet's write:\n\nStart // 程式開始執行\n→ BuildGraph // 建立變數之間的有向圖，邊權為比值\n    For each equation (Ai,Bi,value):\n        Add Ai→Bi with weight value\n        Add Bi→Ai with weight 1/value\n→ Initialize ResultList // 儲存每個查詢的答案\n→ For each query (Cj,Dj):\n    Decision: 若 Cj 或 Dj 不在圖中? // 檢查變數是否定義\n        Yes → Append -1.0 to ResultList // 未定義，無法計算\n        No  → Decision: Cj == Dj? // 同一變數\n            Yes → Append 1.0 to ResultList // 比值為 1\n            No  → Decision: 以 DFS 尋找路徑從 Cj 到 Dj? // 進行深度優先搜尋\n                Yes → Append computed product to ResultList // 找到路徑，計算乘積\n                No  → Append -1.0 to ResultList // 無路徑，無法計算\n→ Return ResultList // 回傳所有查詢結果\nEnd // 程式結束\n\nBut we need to detail DFS steps: maybe separate steps.\n\nInside DFS:\n→ DFS(Cj, Dj, visited, currentProduct)\n    Decision: Cj == Dj? -> return currentProduct\n    Mark visited Cj\n    For each neighbor (next, weight) of Cj:\n        If next not visited:\n            Result = DFS(next, Dj, visited, currentProduct * weight)\n            If Result != -1.0:\n                Return Result\n    Return -1.0\n\nBut we need to integrate. Provide virtual code lines. Let's produce as per format.\n\nWe might number steps but not required. Let's produce clear lines. Use arrow.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ BuildGraph // 建立變數之間的有向圖，邊權為比值\n    For each equation (Ai, Bi, value):\n        Add edge Ai → Bi with weight value // Ai / Bi = value\n        Add edge Bi → Ai with weight 1/value // 反向比值\n→ ResultList ← [] // 儲存每個查詢的答案\n→ For each query (Cj, Dj):\n    Decision: 若 Cj 或 Dj 不在圖中? // 變數未定義\n        Yes → Append -1.0 to ResultList // 回傳 -1.0\n        No  → Decision: Cj == Dj? // 同一變數\n            Yes → Append 1.0 to ResultList // 比值為 1\n            No  → Decision: 是否存在從 Cj 到 Dj 的路徑? // 進行 DFS 搜尋\n                Yes → Append computedProduct to ResultList // 找到路徑，計算乘積\n                No  → Append -1.0 to ResultList // 無路徑，無法計算\n→ Return ResultList // 回傳所有查詢結果\nEnd // 程式執行結束\n```\n\n**DFS 子程序 (在「是否存在從 Cj 到 Dj 的路徑?」處呼叫)**  \n```\n→ DFS(current, target, visited, product) // 深度優先搜尋\n    Decision: current == target? // 到達目標變數\n        Yes → Return product // 乘積即為比值\n        No  →\n            Mark current as visited\n            For each neighbor (next, weight) of current:\n                Decision: next 未被訪問? // 防止迴圈\n                    Yes →\n                        Result ← DFS(next, target, visited, product * weight)\n                        Decision: Result != -1.0? // 找到有效路徑\n                            Yes → Return Result\n            Return -1.0 // 所有路徑都無法到達\n```"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      '[\"dogcatsdog\", \"catsdogcats\", \"ratcatdogcat\"]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        # 將 words 依長度升序排列，方便先把短詞放進 set\n        words_sorted = sorted(words, key=len)\n        seen = set()\n        memo = {}\n\n        def can_form(word):\n            if word in memo:\n                return memo[word]\n            # 嘗試把 word 切成兩部分，左邊必須是已知詞\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in seen:\n                    if suffix in seen or can_form(suffix):\n                        memo[word] = True\n                        return True\n            memo[word] = False\n            return False\n\n        result = []\n        for word in words_sorted:\n            if not word:\n                continue\n            if can_form(word):\n                result.append(word)\n            seen.add(word)          # 把這個字加入已知詞集合\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 從輸入中提取 list 部分\n    if not data:\n        words = []\n    else:\n        # 找到第一個 '[' 和最後一個 ']'，取之間的字串\n        start = data.find('[')\n        end = data.rfind(']')\n        list_str = data[start:end+1]\n        words = ast.literal_eval(list_str)\n\n    solution = Solution()\n    concatenated_words = solution.findAllConcatenatedWordsInADict(words)\n    # 用 json.dumps 讓輸出使用雙引號，與範例格式一致\n    print(json.dumps(concatenated_words))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: given array of words, return all concatenated words. Approach: sort words by length, use a set to store seen words, for each word check if can be formed by concatenating two or more words in set. Use DFS with memo. Then add word to set and if concatenated, add to result. Provide virtual code steps with explanation. Ensure each line: virtual code + // explanation. Use arrows and structure. Use decision etc. Provide steps.\n\nLet's create Start → Sort words by length → Initialize set and result → Iterate over words → Check if can build word via helper → If true add to result → Add word to set → After loop End. Helper function definition: use recursion. Use Decision: if memo? etc. Provide lines accordingly. Use arrows: → Step ... So produce step-by-step. Ensure each line ends with // explanation. Provide decisions. Let's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 words 依字長升序排列 // 方便先處理短詞，作為拼接基礎  \n→ Step 2: 建立空集合 seen // 用來儲存已經確認可用的單詞  \n→ Step 3: 建立空清單 result // 存放所有符合條件的連字詞  \n→ For each word in sorted words: // 逐個檢查每個字詞  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: 是否能由 seen 中的詞組成? // 呼叫判斷函式  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: 將 word 加入 result // 此詞為連字詞  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step 5: 跳過 // 不是連字詞  \n&nbsp;&nbsp;&nbsp;&nbsp;Step 6: 將 word 加入 seen // 成為未來字詞的組成部分  \n→ End // 程式執行結束  \n\n// ---------- 判斷函式定義 ----------\nStart // 定義判斷函式 isConcatenated  \n→ Function isConcatenated(word, seen, memo): // 參數為字詞、已知集合、備忘錄  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: 若 word 存於 memo? // 檢查是否已經計算過  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Return memo[word] // 直接回傳結果  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Continue  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: 是否為空字串?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Return False // 空字串不算  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For i from 1 to length(word)-1: // 逐個切分位置  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prefix = word[0:i]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;suffix = word[i:]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decision: prefix 在 seen?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decision: suffix 在 seen 或 isConcatenated(suffix)?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → memo[word] = True; Return True // 成功拆分  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Continue 後續切分  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;End For  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: 任何切分成功嗎?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → memo[word] = True; Return True  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → memo[word] = False; Return False  \n→ End // 判斷函式結束"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,2,2,false]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 2, 2, false]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        # 使用兩個隊列 q1、q2\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x):\n        # 將新元素加入主隊列 q1\n        self.q1.append(x)\n\n    def pop(self):\n        # 若空則返回 None\n        if not self.q1:\n            return None\n        # 把除最後一個外的所有元素轉移到 q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # 最後一個元素即為堆疊頂部，取出並返回\n        popped = self.q1.popleft()\n        # 交換 q1 與 q2，為下一輪操作做準備\n        self.q1, self.q2 = self.q2, self.q1\n        return popped\n\n    def top(self):\n        if not self.q1:\n            return None\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top_val = self.q1.popleft()\n        # 將頂部元素重新放回 q2，保持堆疊不變\n        self.q2.append(top_val)\n        self.q1, self.q2 = self.q2, self.q1\n        return top_val\n\n    def empty(self):\n        return len(self.q1) == 0\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 如果前面有字串 \"Input\"，去掉\n    if raw_input.lower().startswith('input'):\n        raw_input = raw_input[5:].strip()\n    # 解析兩個 JSON 列表\n    # 例如: [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]\n    parts = raw_input.split('],', 1)\n    ops = json.loads(parts[0] + ']')\n    args = json.loads('[' + parts[1].strip() + ']')\n    results = []\n    stack = None\n    for op, arg in zip(ops, args):\n        if op == 'MyStack':\n            stack = MyStack()\n            results.append(None)\n        elif op == 'push':\n            stack.push(arg[0] if arg else None)\n            results.append(None)\n        elif op == 'pop':\n            results.append(stack.pop())\n        elif op == 'top':\n            results.append(stack.top())\n        elif op == 'empty':\n            results.append(stack.empty())\n    # 輸出 JSON 形式，符合示例的 null、true、false 表示\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with step-by-step operations for a MyStack implemented with two queues. Use Start, End, Decision. Must not output actual code, only pseudo steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and structure. Should cover push, pop, top, empty. Provide algorithm: maintain two queues q1 and q2. push: enqueue to q1. pop: move all but last from q1 to q2, dequeue last as popped, swap q1 and q2. top: similar but peek last without removing? Use pop to get last, then enqueue back? Or use same as pop but requeue. Provide pseudocode.\n\nLet's produce step by step. We'll outline class MyStack with init, push, pop, top, empty.\n\nLet's produce virtual code:\n\nStart // program start\n→ Step 1: 定義 MyStack 類別 // 定義堆疊\n    → Substep: 宣告兩個空隊列 q1, q2 // 用於模擬堆疊\n→ Step 2: 定義 push(x) // 推進元素\n    → Enqueue x 到 q1 // 將新元素放入 q1\n→ Step 3: 定義 pop() // 彈出頂部元素\n    → Decision: q1.isEmpty? // 判斷是否空\n        Yes → Return null // 或適當值\n        No  → Step 3.1: 從 q1 中移除元素，將其放入 q2，直到只剩最後一個元素\n            → For i from 0 to q1.size()-2:\n                temp = q1.dequeue() // 取前端\n                q2.enqueue(temp) // 放入 q2\n            → Step 3.2: 從 q1 中取最後一個元素 popped = q1.dequeue()\n            → Step 3.3: 交換 q1 與 q2 // q1 現在是空，q2 為新堆疊\n                → tempQueue = q1\n                → q1 = q2\n                → q2 = tempQueue\n            → Return popped\n→ Step 4: 定義 top() // 返回頂部元素但不移除\n    → Decision: q1.isEmpty?\n        Yes → Return null\n        No  → Step 4.1: 同 pop 的搬移流程，直到只剩最後一個元素\n            → For i from 0 to q1.size()-2:\n                temp = q1.dequeue()\n                q2.enqueue(temp)\n            → Step 4.2: last = q1.dequeue()\n            → Step 4.3: q2.enqueue(last) // 把頂部元素重新放回 q2\n            → Step 4.4: 交換 q1, q2\n            → Return last\n→ Step 5: 定義 empty() // 判斷是否空\n    → Return q1.isEmpty() // 若 q1 空則堆疊空\nEnd // 程式結束\n\nBut need to show each line with // explanation. Use arrow. Need to incorporate arrows properly. Eg: Start // program start. Next: → Step 1: 定義 MyStack 類別 // ...\n\nWe must keep arrow for each step? They say use arrow (→, Yes →, No →). For decisions, indent? The example shows indent under Decision: with Yes→ etc. We'll replicate.\n\nMake sure each line includes the step text and explanation. Also each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyStack 類別 // 建立堆疊的類別結構  \n    → Substep: 宣告兩個空隊列 q1, q2 // 用於儲存堆疊元素，模擬 LIFO  \n→ Step 2: 定義 push(x) // 新增元素到堆疊  \n    → Enqueue x 到 q1 // 把新元素放進主隊列，保持順序  \n→ Step 3: 定義 pop() // 彈出堆疊頂部元素並回傳  \n    → Decision: q1.isEmpty()? // 判斷堆疊是否為空  \n        Yes → Return null // 若空則回傳空值或適當的錯誤處理  \n        No  → Step 3.1: 從 q1 中轉移前面所有元素到 q2，保留最後一個  \n            → For i from 0 to q1.size() - 2:  \n                → temp = q1.dequeue() // 取出前端元素  \n                → q2.enqueue(temp) // 放回後端的次一隊列  \n        → Step 3.2: popped = q1.dequeue() // 取出最後剩下的元素，即頂部元素  \n        → Step 3.3: 交換 q1 與 q2 // 重新建立主隊列為新的堆疊  \n            → tempQueue = q1  \n            → q1 = q2  \n            → q2 = tempQueue  \n        → Return popped // 回傳彈出的元素  \n→ Step 4: 定義 top() // 查看堆疊頂部元素但不移除  \n    → Decision: q1.isEmpty()? // 判斷是否為空  \n        Yes → Return null // 空時回傳空值  \n        No  → Step 4.1: 同 pop 的搬移流程，直到只剩最後一個元素  \n            → For i from 0 to q1.size() - 2:  \n                → temp = q1.dequeue()  \n                → q2.enqueue(temp)  \n        → Step 4.2: last = q1.dequeue() // 取出頂部元素  \n        → Step 4.3: q2.enqueue(last) // 把頂部元素重新放回隊列，保持不移除  \n        → Step 4.4: 交換 q1 與 q2 // 重新建立主隊列  \n            → tempQueue = q1  \n            → q1 = q2  \n            → q2 = tempQueue  \n        → Return last // 回傳頂部元素  \n→ Step 5: 定義 empty() // 檢查堆疊是否為空  \n    → Return q1.isEmpty() // 若主隊列空則堆疊為空  \nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass DSU:\n    \"\"\"並查集（Disjoint Set Union）實作，支援動態加入元素與合併。\"\"\"\n    def __init__(self):\n        self.parent = {}\n\n    def find(self, x):\n        \"\"\"找出 x 的根節點，並進行路徑壓縮。\"\"\"\n        if x not in self.parent:\n            self.parent[x] = x\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        \"\"\"將 x 與 y 所屬的集合合併。\"\"\"\n        rx, ry = self.find(x), self.find(y)\n        if rx != ry:\n            self.parent[ry] = rx\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        dsu = DSU()\n        email_to_name = {}\n\n        for acc in accounts:\n            name = acc[0]\n            # 第一封 email 為基準，其他所有 email 與它合併\n            first_email = acc[1]\n            for email in acc[1:]:\n                dsu.union(first_email, email)\n                email_to_name[email] = name\n\n        groups = defaultdict(list)\n        for email in email_to_name:\n            root = dsu.find(email)\n            groups[root].append(email)\n\n        merged = []\n        for root, emails in groups.items():\n            merged.append([email_to_name[root]] + sorted(emails))\n        return merged\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 若輸入形如 accounts = [...], 移除前綴\n    if data.startswith(\"accounts\"):\n        _, _, data = data.partition(\"=\")\n    try:\n        accounts = ast.literal_eval(data.strip())\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        return\n    result = Solution().accountsMerge(accounts)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line. Use Start, Decision, arrow, Yes →, No →. Provide explanation after //.\n\nWe must describe algorithm for merging accounts via DSU or graph. Provide steps: iterate accounts, build email to index map, union accounts with same email. After union, group emails per root, sort, build result.\n\nLet's produce lines:\n\nStart\n→ Step 1: 初始化 DSU 結構 // 用於合併具有相同 email 的帳號\n→ Step 2: 建立 map emailToIdx = {} // 將 email 映射到其所在帳號的索引\n→ Decision: For each account i 在 accounts 中遍歷\n    Yes → Step 3: 取 name = accounts[i][0] // 帳號擁有者姓名\n    Yes → Step 4: For每個 email 在 accounts[i][1..] 遍歷\n        Yes → Decision: 如果 email 不在 emailToIdx\n            Yes → Step 5: emailToIdx[email] = i // 若未出現，記錄索引\n            No → Step 6: DSU.union(i, emailToIdx[email]) // 若已存在，合併兩帳號\n    No → // 下一個帳號\n...\nThen group.\n\nWe need to keep format line by line; each step can be multi-indented but each line separate.\n\nWe'll produce lines as required. Use arrow '→'. Provide explanation after //.\n\nMake sure each line starts with arrow or Start/End. For loops, use Decision: etc.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 DSU 以便後續合併帳號 // 建立一個並查集結構  \n→ Step 2: 建立空的 map emailToIdx 以紀錄 email 與帳號索引之關係 // 用來快速查找相同 email  \n→ Decision: 對於每個帳號索引 i 在 accounts 中遍歷  \n  Yes → Step 3: 取得帳號擁有者姓名 name = accounts[i][0] // 讀取姓名  \n  Yes → Decision: 對於每個 email 在 accounts[i][1..] 中遍歷  \n    Yes → Decision: 如果 email 尚未在 emailToIdx 中  \n      Yes → Step 4: emailToIdx[email] = i // 第一次遇到此 email，紀錄其所在帳號  \n      No → Step 5: DSU.union(i, emailToIdx[email]) // 先前已見此 email，合併兩個帳號  \n  No → // 下一個帳號  \n→ Step 6: 建立 map rootToEmails 以聚合同一個根帳號下的所有 email  \n→ Decision: 對於每個帳號索引 i 在 accounts 中遍歷  \n  Yes → Step 7: 找到其根 root = DSU.find(i) // 獲得帳號的代表節點  \n  Yes → Decision: 如果 root 尚未在 rootToEmails 中  \n    Yes → Step 8: rootToEmails[root] = [] // 初始化集合  \n  No → // 存在則直接使用  \n  Yes → Step 9: 將 accounts[i][1..] 所有 email 加入 rootToEmails[root] // 聚合 email  \n  No → // 下一個帳號  \n→ Step 10: 建立最終結果 list result = [] // 用於儲存合併後的帳號  \n→ Decision: 對於每個根 root 在 rootToEmails 中遍歷  \n  Yes → Step 11: 取得對應的名字 name = accounts[root][0] // 取代表帳號的姓名  \n  Yes → Step 12: 將 rootToEmails[root] 的 email 列表進行排序 // 以字典序排序  \n  Yes → Step 13: 建立合併後的帳號 list merged = [name] + sorted_emails // 第一個元素是姓名  \n  Yes → Step 14: 將 merged 加入 result // 收集結果  \n  No → // 下一個根  \n→ End // 程式執行結束，返回 result\n\n（以上虛擬碼描述了使用並查集合併帳號、聚合相同 email、排序並輸出最終結果的完整流程。）"
    },
    {
      "title": "First Bad Version",
      "source_file": "Leetcode/leetcode278.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 5, bad = 4",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_dqsnwcs.py\", line 28, in <module>\n    main()\n  File \"/tmp/tmp_dqsnwcs.py\", line 24, in main\n    first_bad = sol.firstBadVersion(n)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_dqsnwcs.py\", line 9, in firstBadVersion\n    if isBadVersion(mid):\n       ^^^^^^^^^^^^\nNameError: name 'isBadVersion' is not defined"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def firstBadVersion(self, n):\n        left, right = 1, n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\ndef main():\n    # 讀取整個輸入並提取所有整數\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        return\n    n = nums[0]          # n 版本數\n    # (bad 位置在輸入中存在但不直接用於算法，API 會自行處理)\n    sol = Solution()\n    first_bad = sol.firstBadVersion(n)\n    print(first_bad)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The algorithm: binary search to find first bad. Steps: start low=1 high=n. while low<high: mid=(low+high)//2; if isBadVersion(mid) true => high=mid else low=mid+1. return low.\n\nWe need to produce lines with Start, Decision, etc. Each line as \"虛擬碼步驟 // 解釋\". Use arrow notation. Example earlier shows indentation.\n\nLet's craft lines:\n\nStart\n→ Step 1: 初始化 low=1, high=n // 設定搜尋範圍\n→ Decision: low < high? // 判斷是否還有多個候選版本\n    Yes → Step 2: 計算 mid=(low+high)//2 // 找到中間版本\n        → Decision: isBadVersion(mid)？ // 判斷 mid 是否為壞版本\n            Yes → Step 3: high = mid // 將上限縮小到 mid\n            No  → Step 4: low = mid + 1 // 下限往上移\n        → Back to Decision: low < high? // 重新檢查條件\n    No → End\n→ Return low // low 即為第一個壞版本\n\nNeed to include arrow syntax properly. Should we use indentation? The example uses 4 spaces before nested lines? It shows \"    Yes → Decision\". We replicate.\n\nWe'll produce code accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 low=1, high=n // 設定搜尋範圍  \n→ Decision: low < high? // 判斷是否還有多個候選版本  \n Yes → Step 2: 計算 mid=(low+high)//2 // 找到中間版本  \n  → Decision: isBadVersion(mid)? // 判斷 mid 是否為壞版本  \n   Yes → Step 3: high = mid // 將上限縮小到 mid  \n   No  → Step 4: low = mid + 1 // 下限往上移  \n  → Back to Decision: low < high? // 重新檢查條件  \n No → End // 搜尋結束  \n→ Return low // low 即為第一個壞版本，結束流程\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,6,6,4,1,4,0,1]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 6, 6, 4, 1, 4, 0, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black_set = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        idx = random.randint(0, self.size - 1)\n        return self.mapping.get(idx, idx)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            method = getattr(obj, cmd)\n            res = method(*args)\n            results.append(res)\n\n    def fmt(v):\n        return 'null' if v is None else str(v)\n\n    output = '[' + ', '.join(fmt(v) for v in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code, line by line with comments. Provide algorithm for weighted random selection with blacklisting. Approach: Map from white indices to black or white using hashing. Use mapping technique: map any black number in [0, m-1] to a whitelisted number from [m, n-1] that is not black. Preprocess: Build set of black in range [m, n-1] to find free spots. Then map all black < m to free spots. pick() random integer from 0..m-1 and return mapped value if needed.\n\nWe need to produce virtual code with arrows and decisions. So start, step for initialization, build mapping, step for pick, etc.\n\nLet's produce virtual code with comments. Use Start, Decision, etc.\n\nWe need to show steps, not actual code. Provide virtual code lines.\n\nWe must not output real code. So use pseudocode style with arrows.\n\nWe'll produce lines:\n\nStart\n→ Step 1: Input n, blacklist // store parameters\n→ Step 2: Let m = n - length(blacklist) // number of allowed numbers\n→ Step 3: Create hash set B from blacklist // for O(1) lookups\n→ Decision: 是否有白名单在 [0, m-1] // check if any black in low part\n    Yes → ... Actually we need to map.\n\nBetter: Build mapping dict.\n\n→ Step 4: Initialize empty mapping dict map // for black numbers < m\n→ Step 5: Set last = n-1 // start from top\n→ Decision: 迭代黑名單中的數值 // for each b in blacklist\n    Yes → Decision: 如果 b < m?\n        Yes → While last in B: last-- // find free spot\n             → Step 6: map[b] = last // map low black to free high\n             → Step 7: last-- // move to next candidate\n        No → Continue // ignore blacks >= m\n→ End\n\nPick:\n→ Step 8: rand = random integer in [0, m-1] // uniform\n→ Decision: rand in map?\n    Yes → Step 9: return map[rand] // mapped high value\n    No  → Step 10: return rand // normal value\n\nEnd.\n\nBut need to show virtual code line by line with comments. Use arrow at each line.\n\nMake sure we use \"→\" at each step.\n\nWe must include decisions with Yes → and No →.\n\nLet's write.\n\nWe'll also include \"Start\" and \"End\".\n\nNeed to show algorithm steps clearly.\n\nOk produce output.\n...done thinking.\n\nStart // 程式開始執行  \n\n→ Step 1: 接收參數 n 與 blacklist // 取得整數上限與黑名單  \n→ Step 2: 計算 m = n - blacklist.length // 白名單數量  \n→ Step 3: 建立 hash 集合 B ← blacklist // 方便 O(1) 檢查  \n\n→ Step 4: 建立空映射 dict ← {} // 用於將低域黑名單映射至高域白名單  \n→ Step 5: 設定 last ← n - 1 // 從最大小值開始搜尋可用位置  \n\n→ Decision: 迭代每個黑名單元素 b ∈ blacklist?  \n    Yes → Decision: b < m? // 僅對低域黑名單處理  \n        Yes → Step 6: While last ∈ B: last ← last - 1 // 找到不在黑名單的高域值  \n        → Step 7: dict[b] ← last // 建立映射  \n        → Step 8: last ← last - 1 // 移動至下一候選值  \n        No  → Step 9: // b ≥ m，直接忽略  \n    No  → // 迭代結束  \n\nEnd // 初始化完成  \n\n---  \n\nStart // pick() 內部流程  \n\n→ Step 10: rand ← random integer in [0, m-1] // 產生均勻隨機數  \n→ Decision: rand ∈ dict? // 判斷是否需要映射  \n    Yes → Step 11: return dict[rand] // 取映射後的白名單值  \n    No  → Step 12: return rand // 直接返回  \n\nEnd // pick() 執行結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpixd7u5ou.py\", line 65, in <module>\n    main()\n  File \"/tmp/tmpixd7u5ou.py\", line 42, in main\n    commands = ast.literal_eval(commands_part.strip())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MapSum\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.sum = 0  # sum of all values of keys passing through this node\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.key_to_val = {}  # keep current value of each key\n\n    def insert(self, key: str, val: int) -> None:\n        # calculate delta to update sums\n        old_val = self.key_to_val.get(key, 0)\n        delta = val - old_val\n        self.key_to_val[key] = val\n\n        node = self.root\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += delta\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # split into two parts: commands and arguments\n    commands_part, args_part = data.split(',', 1)\n    commands = ast.literal_eval(commands_part.strip())\n    args_list = ast.literal_eval(args_part.strip())\n\n    result = []\n    ms = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MapSum\":\n            ms = MapSum()\n            result.append(None)\n        elif cmd == \"insert\":\n            ms.insert(args[0], args[1])\n            result.append(None)\n        elif cmd == \"sum\":\n            total = ms.sum(args[0])\n            result.append(total)\n        else:\n            # unknown command, skip\n            result.append(None)\n\n    # print result in JSON style to match expected output\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with explanation. Should cover MapSum class, methods, and internal data structures. Use virtual code arrows. We should produce step-by-step design. Each line: \"虛擬碼步驟 // 解釋\". Use arrow symbol. Use Decision, Start, End. Need to describe design: Trie nodes with sum, map for key values.\n\nLet's craft:\n\nStart // 初始化 MapSum\n→ Step 1: 建立 Trie 根節點 // 用於儲存前綴及累加值\n→ Step 2: 建立 HashMap keyToVal // 追蹤每個 key 的當前值\nEnd\n\nInsert method:\n\nStart // insert 方法開始\n→ Step 3: 若 key 存在於 keyToVal, 計算 delta = newVal - oldVal; 否則 delta = newVal\n→ Step 4: 更新 keyToVal[key] = newVal\n→ Step 5: 從根節點開始, for each char c in key:\n    → Step 6: 若無 child c, 創建新節點\n    → Step 7: node.sum += delta // 累加此前綴的總值\n    → Step 8: node = node.child[c]\nEnd\n\nSum method:\n\nStart // sum 方法開始\n→ Step 9: node = root\n→ Decision: key 的每個字符是否存在?\n    Yes → node = node.child[c]\n    No  → Return 0 // 沒有此前綴\n→ End Decision\n→ Step 10: Return node.sum // 前綴累加值\n\nAlso need to mention root.sum includes entire. Should set node.sum at root? We may set root.sum 0. Each node sum includes value of all keys passing through.\n\nOk produce lines. Ensure each line with arrow. Use \"→\" preceding each step. For Decision block indent? Provide lines with \"Decision:\" and branches. Provide explanation comments after //. Each line separate. No code. Let's output.\n...done thinking.\n\nStart // 初始化 MapSum 類別\n→ Step 1: 建立 Trie 根節點 (sum = 0) // 用於儲存所有前綴及其累加值\n→ Step 2: 建立 HashMap keyToVal // 追蹤每個 key 的現有值\nEnd // MapSum 初始化完成\n\nStart // insert 方法開始\n→ Step 3: 若 key 存在於 keyToVal，計算 delta = val - keyToVal[key]；否則 delta = val // 取得要加到前綴的差值\n→ Step 4: 設定 keyToVal[key] = val // 更新或新增 key 的值\n→ Step 5: node ← root // 從根節點開始遍歷 key\n→ Decision: key 是否為空?\n    Yes → Return // 空 key 不做任何處理\n    No  → \n        → Step 6: 對於 key 中每個字符 c:\n            → Step 7: 若 node.child[c] 不存在，建立新節點 (sum = 0) // 新前綴節點\n            → Step 8: node.child[c].sum += delta // 將差值累加到該前綴節點\n            → Step 9: node ← node.child[c] // 移動到下一個節點\nEnd // insert 完成\n\nStart // sum 方法開始\n→ Step 10: node ← root // 從根節點開始\n→ Decision: prefix 是否為空?\n    Yes → Return node.sum // 空前綴代表整體所有值\n    No  → \n        → Step 11: 對於 prefix 中每個字符 c:\n            → Decision: node.child[c] 是否存在?\n                Yes → node ← node.child[c] // 前綴存在，移動\n                No  → Return 0 // 前綴不存在，和為 0\n→ Step 12: Return node.sum // 返回該前綴累加值\nEnd // sum 完成\n\nEnd // MapSum 程式結束 (虛擬碼示例)"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.7806766633475198,0.3324474293374101],[0.9381770133607641,0.0022227808243250424],[0.39685883367563796,0.4458600356027011]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.7806766633475198, 0.3324474293374101], [0.9381770133607641, 0.0022227808243250424], [0.39685883367563796, 0.4458600356027011]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())          # 均勻分布的半徑\n        theta = random.uniform(0, 2 * math.pi)                # 隨機角度\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    lines = sys.stdin.read().strip().splitlines()\n    if not lines:\n        return\n    ops = json.loads(lines[0])          # 例: [\"Solution\",\"randPoint\",...]\n    args = json.loads(lines[1])         # 例: [[1.0,0.0,0.0],[],...]\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)          # 建構物件\n            results.append(None)          # Solution 回傳 null\n        else:\n            method = getattr(obj, op)     # 取得方法\n            results.append(method())      # 執行並收集回傳值\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line. Use Start, End, Decision, etc. Steps: initialization, generating random radius via sqrt(rand)*R, random angle via 2π*rand, compute x,y. Return [x, y]. We need to be careful to use uniform distribution: radius sqrt(random)*R ensures uniform area. Provide explanation for each line. Also the class initialization. Use \"Class: Solution\" maybe? But we can just treat as part of flow. Provide steps for constructor and randPoint. Each line includes \"→\" arrow. Format: \"虛擬碼步驟 // 解釋\". Start at \"Start\". End at \"End\". For random generation we may use \"Generate random number between 0 and 1\" steps.\n\nLet's produce. We'll include Decision lines if any. But none needed. But we can show a Decision if we want to illustrate.\n\nLet's produce as:\n\nStart\n→ Step 1: Store radius R, center (cx, cy) // 保存圓半徑與中心座標\n→ Step 2: Generate u ← random() // 隨機生成 0~1\n→ Step 3: Generate θ ← 2π * random() // 隨機角度\n→ Step 4: Compute r = sqrt(u) * R // 調整半徑以保證面積均勻\n→ Step 5: Compute x = cx + r * cos(θ) // 計算 x 坐標\n→ Step 6: Compute y = cy + r * sin(θ) // 計算 y 坐標\n→ Step 7: Return [x, y] // 返回隨機點\n\nBut we need separate lines for constructor and randPoint. Use Decision? Could do:\n\nStart\n→ Class Solution // 定義類別\n→ Constructor(radius, x_center, y_center) // 初始化半徑與中心\n    → Store radius, x_center, y_center\n→ Method randPoint() // 生成隨機點\n    → Generate random u 0~1\n    → Generate random θ 0~2π\n    → r = sqrt(u)*radius\n    → x = x_center + r * cos(θ)\n    → y = y_center + r * sin(θ)\n    → Return [x, y]\nEnd\n\nBut need line by line with arrow. Use indentation? Not necessary. Use \"→\" and \"    →\". We'll produce lines like:\n\nStart\n→ Class Solution // 定義 Solution 類別\n→ Constructor(radius, x_center, y_center) // 建構函式\n    → Store radius, x_center, y_center // 保存參數\n→ Method randPoint() // 生成隨機點\n    → Generate u ← random() // 隨機數 0~1\n    → Generate θ ← 2π * random() // 隨機角度\n    → Compute r ← sqrt(u) * radius // 調整半徑保證均勻分布\n    → Compute x ← x_center + r * cos(θ) // 轉換為座標\n    → Compute y ← y_center + r * sin(θ)\n    → Return [x, y] // 返回點\nEnd\n\nMake sure each line is a virtual code step with comment. Use spaces. Provide arrow. Use \"→\". For lines inside method, we can indent with spaces but maintain \"→\". Provide proper comments. Let's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class Solution // 定義 Solution 類別  \n→ Constructor(radius, x_center, y_center) // 建構函式，接收半徑與中心座標  \n    → Store radius, x_center, y_center // 保存參數供之後使用  \n→ Method randPoint() // 生成隨機點的主函式  \n    → Generate u ← random() // 產生 0~1 的隨機數，作為半徑比例  \n    → Generate θ ← 2π * random() // 產生 0~2π 的隨機角度  \n    → Compute r ← sqrt(u) * radius // 以 sqrt(u) 調整半徑，確保面積均勻  \n    → Compute x ← x_center + r * cos(θ) // 將極坐標轉為笛卡兒 x 坐標  \n    → Compute y ← y_center + r * sin(θ) // 將極坐標轉為笛卡兒 y 坐標  \n    → Return [x, y] // 回傳隨機點  \nEnd // 程式執行結束"
    },
    {
      "title": "Count Different Palindromic Subsequences",
      "source_file": "Leetcode/leetcode730.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpha67nsmg.py\", line 75, in <module>\n    result = count_palindromic_subsequences(s)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpha67nsmg.py\", line 49, in count_palindromic_subsequences\n    dp[l][r] = (dp[l + 1][r] + dp[l][r - 1] - dp[nl + 1][pr - 1]) % MOD\n                                              ~~^^^^^^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmgovz6ci.py\", line 75, in <module>\n    result = count_palindromic_subsequences(s)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmgovz6ci.py\", line 49, in count_palindromic_subsequences\n    dp[l][r] = (dp[l + 1][r] + dp[l][r - 1] - dp[nl + 1][pr - 1]) % MOD\n                                              ~~^^^^^^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport re\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # nextSame[i]: next position of the same char as s[i] after i, -1 if none\n    nextSame = [-1] * n\n    # prevSame[i]: previous position of the same char as s[i] before i, -1 if none\n    prevSame = [-1] * n\n\n    last_pos = {}\n    for i in range(n):\n        if s[i] in last_pos:\n            prevSame[i] = last_pos[s[i]]\n        last_pos[s[i]] = i\n\n    last_pos.clear()\n    for i in range(n - 1, -1, -1):\n        if s[i] in last_pos:\n            nextSame[i] = last_pos[s[i]]\n        last_pos[s[i]] = i\n\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1  # single character\n\n    # length of substring\n    for length in range(2, n + 1):\n        for l in range(0, n - length + 1):\n            r = l + length - 1\n            if s[l] != s[r]:\n                dp[l][r] = (dp[l + 1][r] + dp[l][r - 1] - dp[l + 1][r - 1]) % MOD\n            else:\n                nl = nextSame[l]\n                pr = prevSame[r]\n                if nl == -1 or nl > r:\n                    # no same character inside the interval\n                    dp[l][r] = (dp[l + 1][r] + dp[l][r - 1] + 2) % MOD\n                elif nl == pr:\n                    # exactly one same character inside\n                    dp[l][r] = (dp[l + 1][r] + dp[l][r - 1] + 1) % MOD\n                else:\n                    # at least two same characters inside\n                    dp[l][r] = (dp[l + 1][r] + dp[l][r - 1] - dp[nl + 1][pr - 1]) % MOD\n\n    return dp[0][n - 1] % MOD\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    Extract the string s from various possible input formats.\n    Supports:\n        - s = \"string\"\n        - string\n        - string with surrounding quotes\n    \"\"\"\n    data = data.strip()\n    # Try to find quoted part\n    m = re.search(r'\"([^\"]*)\"', data)\n    if m:\n        return m.group(1)\n    # Remove possible variable assignment\n    if '=' in data:\n        data = data.split('=', 1)[1]\n    # Strip surrounding quotes and whitespace\n    return data.strip().strip('\"').strip()\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = count_palindromic_subsequences(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. We need to describe algorithm: count distinct non-empty palindromic subsequences. Standard DP: DP[l][r] = number distinct palindromic subsequences in substring s[l..r]. Recurrence: if s[l]==s[r], then DP[l][r] = DP[l+1][r] + DP[l][r-1] + 1; else DP[l][r] = DP[l+1][r] + DP[l][r-1] - DP[l+1][r-1]. But must handle duplicates: If same char occurs inside. For s[l]==s[r], we need to consider inner positions of same char: find next occurrence of s[l] after l, and previous occurrence of s[l] before r. If none, then +2. If one, +1. If two or more, subtract DP[l+1][r-1]. Standard approach: Use arrays next[i], prev[i]. Use modulo.\n\nWe produce virtual code steps. We need to be explicit step by step: Input string, precompute next and prev arrays, initialize DP matrix 2D of size n x n, loop over lengths, fill DP. Finally answer DP[0][n-1] modulo MOD.\n\nAlso need to mention modulo operation after each addition/subtraction.\n\nWe'll produce step lines: Start, read string, define MOD, n, create arrays, compute next and prev, initialize dp, loop length from 1 to n, inner loops, decisions based on s[l]==s[r], compute counts using previous values and next/prev, apply modulo, handle negative by +MOD, final output.\n\nWe should keep each line with explanation. Let's craft.\n\nEnsure to use arrow for decisions. Provide explanation comments after //. Use \"Start\", \"End\".\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Read s // 取得輸入字串  \n→ Define MOD ← 1_000_000_007 // 結果取模的常數  \n→ Let n ← length of s // 字串長度  \n→ Create array next[0…n-1] // 下一個相同字元的位置  \n→ Create array prev[0…n-1] // 前一個相同字元的位置  \n→ // 初始化 next 與 prev  \n→ Set next[i] ← -1 for all i  \n→ Set prev[i] ← -1 for all i  \n→ // 右往左掃描填寫 next  \n→ For i from n-1 down to 0  \n  If i < n-1 and s[i] == s[i+1] then next[i] ← i+1  \n  Else if i < n-1 then next[i] ← next[i+1]  \n  Else next[i] ← -1  \n→ // 左往右掃描填寫 prev  \n→ For i from 0 to n-1  \n  If i > 0 and s[i] == s[i-1] then prev[i] ← i-1  \n  Else if i > 0 then prev[i] ← prev[i-1]  \n  Else prev[i] ← -1  \n→ Create 2D array dp[n][n] initialized to 0 // dp[l][r] = distinct palindromic subseqs in s[l…r]  \n→ // DP: 長度從 1 到 n  \n→ For len from 1 to n  \n  For l from 0 to n-len  \n   Let r ← l + len - 1  \n   Decision: s[l] == s[r]? // 是否兩端字元相同  \n    Yes → // 兩端相同  \n     If next[l] == -1 or next[l] > r then // 字元只在兩端出現一次  \n      dp[l][r] ← (dp[l+1][r] + dp[l][r-1] + 2) mod MOD  \n     Else if next[l] == prev[r] then // 只出現一次於內部  \n      dp[l][r] ← (dp[l+1][r] + dp[l][r-1] + 1) mod MOD  \n     Else // 出現兩次以上  \n      dp[l][r] ← (dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1] + MOD) mod MOD  \n    No → // 兩端不同  \n     dp[l][r] ← (dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1] + MOD) mod MOD  \n→ // 結果為整個字串的 DP  \n→ Output dp[0][n-1] mod MOD // 取模後輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Palindromic Substring",
      "source_file": "Leetcode/leetcode5.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'babad'",
          "expected_output": "'bab'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'bab'\nGot (Norm):      'aba'\n--- (Raw) ---\nRaw Expected: \"'bab'\"\nRaw Got:      'aba'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if not s:\n            return \"\"\n        start, end = 0, 0\n        for i in range(len(s)):\n            # odd length palindrome\n            len1 = self._expand(s, i, i)\n            # even length palindrome\n            len2 = self._expand(s, i, i + 1)\n            max_len = max(len1, len2)\n            if max_len > end - start:\n                # compute new start and end indices\n                start = i - (max_len - 1) // 2\n                end = i + max_len // 2\n        return s[start:end + 1]\n\n    def _expand(self, s: str, left: int, right: int) -> int:\n        \"\"\"Return length of palindrome centered between left and right.\"\"\"\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Try to extract string between quotes, otherwise use raw data\n    match = re.search(r\"['\\\"](.*?)['\\\"]\", data, re.S)\n    s = match.group(1) if match else data\n    sol = Solution()\n    result = sol.longestPalindrome(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for problem: longest palindromic substring. Use typical expand around center algorithm or DP. Provide virtual steps line by line. Must use Start, End, Decision. Provide each line with explanation. We should include loops etc. Use arrow. Example lines like \"→ Step 1: 初始化最大回文子串\" etc.\n\nWe need to generate virtual code that outlines algorithm. Each line: \"虛擬碼步驟 // 解釋\". Use arrow for steps.\n\nLet's produce something like:\n\nStart\n→ Step 1: 取得輸入字串 s\n→ Step 2: 初始化變數 start = 0, end = 0 // 用來記錄目前最大回文子串的位置\n→ Step 3: 對於每個索引 i in s:\n    → Decision: 是否為中心? // 處理兩種情況：奇數長度和偶數長度\n        Yes → Step 4: 呼叫 expandAroundCenter(i, i) // 奇數\n        No → Step 5: 呼叫 expandAroundCenter(i, i+1) // 偶數\n→ Step 6: 在 expandAroundCenter 函式中:\n    → Decision: 兩個指標 left, right 在字串範圍內且 s[left] == s[right]?\n        Yes → 左移 left, 右移 right\n        No → 返回目前回文長度 = right - left - 1\n→ Step 7: 若新回文長度 > end - start, 更新 start 和 end\n→ End\n\nBut need line per step.\n\nLet's produce with appropriate arrow for decisions.\n\nWe must include the Start and End markers. Each step line should have virtual code text and comment.\n\nLet's ensure that each line includes a single arrow? For decision, we indent.\n\nWe'll use formatting similar to example.\n\nWe need to include \"→\" arrows preceding step lines. For decision, we indent with 4 spaces? The example uses spaces before Yes →.\n\nWe'll produce lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 取得輸入\n→ Step 2: 初始化 start = 0, end = 0 // 用於記錄最大回文子串位置\n→ Step 3: 對於每個索引 i 從 0 到 s.length - 1 做以下:\n    → Decision: 是否需要考慮奇數長度回文?\n        Yes → Step 4a: length1 = expandAroundCenter(i, i) // 奇數中心\n        No → Step 4a: length1 = 0 // 如果不考慮\n    → Decision: 是否需要考慮偶數長度回文?\n        Yes → Step 4b: length2 = expandAroundCenter(i, i+1) // 偶數中心\n        No → Step 4b: length2 = 0\n    → Step 5: maxLen = max(length1, length2)\n    → Decision: maxLen > end - start ?\n        Yes → Step 6: start = i - (maxLen - 1)/2\n                → Step 7: end = i + maxLen/2\n        No → (無操作)\n→ Step 8: 返回子字串 s[start:end+1] // 最大回文子串\nEnd // 程式結束\n\nBut we need to include expandAroundCenter function definition maybe earlier.\n\nLet's produce:\n\nStep 9: 定義函式 expandAroundCenter(left, right)\n    → Step 10: while left >= 0 且 right < s.length 且 s[left] == s[right] do\n        → Step 11: left -= 1\n        → Step 12: right += 1\n    → Step 13: return right - left - 1 // 回文長度\n\nWe need to maintain correct order: function definition may be before main loop. We'll place after Start maybe.\n\nOk produce final output lines.\n\nAlso need arrow for decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 從使用者取得輸入字串  \n→ Step 2: 初始化變數 start = 0, end = 0 // 用來記錄目前最大的回文子串起始與結束索引  \n→ Step 3: 定義函式 expandAroundCenter(left, right) // 用於擴展中心尋找回文長度  \n → Step 4: while left ≥ 0 且 right < s.length 且 s[left] = s[right] do  \n  → Step 5: left ← left - 1 // 向左擴展  \n  → Step 6: right ← right + 1 // 向右擴展  \n → Step 7: return right - left - 1 // 回傳擴展後的回文長度  \n→ Step 8: 對於每個索引 i 從 0 到 s.length - 1 做以下操作  \n  → Decision: 是否需要考慮奇數長度回文? // 每個字符作為中心  \n   Yes → Step 9: len1 ← expandAroundCenter(i, i) // 奇數長度回文  \n   No → Step 9: len1 ← 0  \n  → Decision: 是否需要考慮偶數長度回文? // 相鄰字符作為中心  \n   Yes → Step 10: len2 ← expandAroundCenter(i, i + 1) // 偶數長度回文  \n   No → Step 10: len2 ← 0  \n  → Step 11: maxLen ← max(len1, len2) // 取較長的回文長度  \n  → Decision: maxLen > end - start? // 新的回文是否比目前更長  \n   Yes → Step 12: start ← i - (maxLen - 1) // 計算新的起始索引  \n     → Step 13: end ← i + maxLen // 計算新的結束索引（含）  \n   No → (無操作)  \n→ Step 14: return s.substring(start, end + 1) // 回傳最大回文子字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Continuous Subarray Sum",
      "source_file": "Leetcode/leetcode523.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[23,2,4,6,7], 6",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpr9q_bn_b.py\", line 28, in <module>\n    k = int(k_part) if k_part else 0\n        ^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: ', 6'"
        },
        {
          "example_index": 1,
          "input": "[23,2,6,4,7], 6",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpw8s98jfp.py\", line 28, in <module>\n    k = int(k_part) if k_part else 0\n        ^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: ', 6'"
        },
        {
          "example_index": 2,
          "input": "[23,2,6,4,7], 13",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgnyotiio.py\", line 28, in <module>\n    k = int(k_part) if k_part else 0\n        ^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: ', 13'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def checkSubarraySum(self, nums, k):\n        mod_map = {0: -1}\n        total = 0\n        for i, num in enumerate(nums):\n            total += num\n            if k != 0:\n                total %= k\n            if total in mod_map:\n                if i - mod_map[total] > 1:\n                    return True\n            else:\n                mod_map[total] = i\n        return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 將輸入分為陣列部分與 k 部分\n    parts = data.split(']', 1)\n    array_part = parts[0] + ']'\n    k_part = parts[1].strip() if len(parts) > 1 else ''\n    nums = ast.literal_eval(array_part)\n    k = int(k_part) if k_part else 0\n    result = Solution().checkSubarraySum(nums, k)\n    print('true' if result else 'false')",
      "virtual_code": "Thinking...\nWe need to produce pseudocode in virtual code style for algorithm: given integer array nums, integer k, check if there exists subarray length >=2 such that sum % k == 0. Use prefix sums mod. Standard solution: track first occurrence of each mod, if same mod again with distance>=2, return true. Edge: k=0: then need subarray sum==0 with length>=2.\n\nWe produce steps line by line.\n\nWe must use the arrow \"→\" after Start, End etc. And include explanation after //.\n\nLet's create:\n\nStart\n→ Initialize map (mod -> first index)\n→ Set map[0] = -1 // prefix sum 0 at index -1\n→ sum = 0\n→ For each index i from 0 to len(nums)-1:\n    sum += nums[i]\n    if k != 0:\n        mod = sum % k\n    else:\n        mod = sum\n    if mod in map:\n        if i - map[mod] >= 2:\n            return true\n    else:\n        map[mod] = i\n→ return false\nEnd\n\nBut must reflect subarray length at least two. So we need to store earliest index of mod. If later we find same mod with distance >=2, we have subarray of at least length 2. The map should store first occurrence index. We update only when not present.\n\nFor k==0: we look for sum==0 with length>=2. The same mod logic works because mod = sum, but we must treat mod 0 only. So map[0] initial -1. For any sum, if sum==0 and i-(-1)>=2 => true.\n\nBut we must handle negative k? Usually k could be negative, but modulo defined accordingly. We can use absolute value? Typically use mod = ((sum % k) + k) % k to ensure positive. We'll just use sum % k.\n\nLet's produce steps accordingly.\n\nInclude explanation. Use Decision structure maybe for k==0 condition. We'll incorporate Decision for if k==0? But simpler to treat all same.\n\nLet's produce:\n\nStart // 開始執行\n→ Initialize empty map M // 用於儲存每個餘數第一次出現的索引\n→ Set M[0] = -1 // 先把餘數0對應到索引-1，方便計算長度\n→ sum = 0 // 前綴和累積\n→ For i from 0 to len(nums)-1: // 遍歷陣列\n    → sum += nums[i] // 加上目前元素\n    → Decision: k == 0? // 判斷k是否為0\n        Yes → mod = sum // 若k為0，直接使用sum作餘數\n        No  → mod = sum % k // 否則取模\n    → Decision: mod in M? // 已經見過這個餘數嗎？\n        Yes → Decision: i - M[mod] >= 2? // 子陣列長度至少2？\n            Yes → Return true // 找到符合條件的子陣列\n            No  → // 不能使用，繼續\n        No  → M[mod] = i // 記錄第一次出現的索引\n→ Return false // 沒有找到\nEnd // 程式結束\n\nThis is clear.\n\nMake sure each line ends with \"// 解釋\".\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ M = {} // 建立雜湊表存放餘數對應的首次索引  \n→ M[0] = -1 // 將餘數0對應索引-1，以便計算子陣列長度  \n→ sum = 0 // 初始化前綴和  \n→ For i = 0 to len(nums)-1: // 從頭到尾遍歷陣列  \n    → sum += nums[i] // 累加當前元素得到前綴和  \n    → Decision: k == 0? // 判斷 k 是否為 0  \n        Yes → mod = sum // 若 k 為 0，直接用 sum 作為餘數（因為任何數除以 0 的餘數定義為自身）  \n        No  → mod = sum % k // 否則計算餘數  \n    → Decision: mod in M? // 這個餘數是否已經出現過？  \n        Yes → Decision: i - M[mod] >= 2? // 子陣列長度是否至少 2？  \n            Yes → Return true // 找到滿足條件的子陣列，返回真  \n            No  → // 跳過，因為距離太短  \n        No  → M[mod] = i // 記錄此餘數首次出現的索引  \n→ Return false // 遍歷完仍未找到，返回假  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,1,2],[3,2,1],[3,2,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [3, 1, 2], [3, 2, 1], [3, 2, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列的拷貝，供 reset 時使用\n        self.original = nums[:]\n        # 工作陣列，最初與原始相同\n        self.nums = nums[:]\n        # 隨機數產生器\n        self.rng = random.Random()\n\n    def reset(self):\n        # 重置為原始順序\n        self.nums = self.original[:]\n        return self.nums\n\n    def shuffle(self):\n        # Fisher‑Yates 洗牌演算法\n        n = len(self.nums)\n        for i in range(n - 1, 0, -1):\n            j = self.rng.randint(0, i)\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\n        return self.nums\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析為 (ops, args) 兩個元素的 tuple\n    ops, args = ast.literal_eval(raw_input)\n\n    result = []\n    obj = None\n    for idx, op in enumerate(ops):\n        if op == \"Solution\":\n            # args[idx] 是像 [[1,2,3]] 這樣的結構，取第一個元素作為傳遞給建構子\n            obj = Solution(args[idx][0])\n            result.append(None)\n        elif op == \"reset\":\n            res = obj.reset()\n            result.append(res)\n        elif op == \"shuffle\":\n            res = obj.shuffle()\n            result.append(res)\n        else:\n            # 若遇到未知指令，直接忽略或可自行處理\n            result.append(None)\n\n    # 將結果轉成符合要求的輸出格式\n    out_strs = []\n    for r in result:\n        if r is None:\n            out_strs.append(\"null\")\n        else:\n            out_strs.append(str(r))\n    output = \"[\" + \", \".join(out_strs) + \"]\"\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation. Each line: virtual step + space + // explanation. Use arrows and Start/End. Should cover initialization, reset, shuffle using Fisher-Yates. Also store original copy, current array. We need to explain each line.\n\nLet's design flow: Start -> store original array (clone) into original array. current array also a clone. reset: set current = clone of original, return current. shuffle: loop from i=n-1 downto 1: pick random j between 0 and i, swap current[i] and current[j]. return current.\n\nAlso need to maintain random generator.\n\nWe need to represent as virtual steps: maybe using classes.\n\nWe should provide steps for Solution constructor, reset method, shuffle method.\n\nLet's produce in a structured flow. Use indentation for decisions.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 變數 original ← nums.clone() // 將傳入的陣列複製成原始版本，供後續 reset 使用\n→ Step 2: 變數 current ← nums.clone() // 建立目前工作陣列，最初與原始相同\n→ Step 3: 變數 rand ← new Random() // 建立隨機數產生器，供 shuffle 時使用\n→ End // 結構初始化完成\n\nStart // reset 方法開始執行\n→ Step 4: 變數 current ← original.clone() // 重新把 current 置回原始順序\n→ Step 5: return current // 回傳重置後的陣列\n→ End // reset 方法結束\n\nStart // shuffle 方法開始執行\n→ Step 6: for i from current.length - 1 downto 1 do // 逐一從後往前處理\n→ Decision: 是否已完成迴圈? // 判斷是否還有需要處理的元素\n    No  → Step 7: 變數 j ← rand.nextInt(i + 1) // 隨機選取 0~i 的索引\n    No  → Step 8: swap current[i] 與 current[j] // 交換位置以確保所有排列等機率\n    No  → Step 9: i ← i - 1 // 移動到前一個位置\n    Yes → Step 10: return current // 迴圈結束，回傳隨機排列\n→ End // shuffle 方法結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 支援兩種輸入格式：'nums = [1,2,3]' 或直接 '[1,2,3]'\n    if data.startswith(\"nums\"):\n        _, _, list_str = data.partition(\"=\")\n        list_str = list_str.strip()\n    else:\n        list_str = data\n    try:\n        nums = eval(list_str, {\"__builtins__\": {}})\n    except Exception:\n        nums = []\n    solution = Solution()\n    result = solution.subsets(nums)\n    # 使用 json.dumps 可避免多餘空格，符合範例輸出格式\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for generating power set of unique integers. Steps: Start, input array, initialize result list, call recursive backtracking or iterative. Provide virtual code lines: Start, Step: read input, Step: initialize result with empty set, Step: call backtrack(index=0, current=[]), define backtrack: add current to result, for i from index to len(nums)-1: append nums[i] to current, call backtrack(i+1, current), pop last. End. Provide comments. Format each line with arrow. Use Start and End. Use Decision etc if needed. Probably no decisions except loop. We'll produce simple. Ensure each line ends with // 解釋.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 取得陣列 nums // 取得唯一元素的整數陣列\n→ Step 2: 建立結果 list subsets = [[]] // 初始結果包含空集合\n→ Step 3: 定義函式 backtrack(index, path) // 從 index 開始回溯\n    → Decision: 是否已到陣列尾? // 檢查是否完成所有元素\n        Yes → Step 4: 將 path 複製並加入 subsets // 取得子集\n        No  → \n            → Step 5: for i from index to len(nums)-1: // 遍歷剩餘元素\n                → Step 6: path 加上 nums[i] // 加入當前元素\n                → Step 7: backtrack(i+1, path) // 進一步回溯\n                → Step 8: path 從末尾移除 // 回溯回原狀\n→ Step 9: 呼叫 backtrack(0, []) // 開始回溯\n→ Step 10: 回傳 subsets // 回傳所有子集\nEnd // 程式執行結束\n\nNeed to use arrow. For decisions indent. Provide proper spacing. Provide only virtual code.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列 nums // 取得唯一元素的整數陣列  \n→ Step 2: 建立結果 list subsets = [[]] // 初始結果包含空集合  \n→ Step 3: 定義函式 backtrack(index, path) // 從 index 開始回溯  \n    → Decision: 是否已到陣列尾? // 檢查是否已經處理完所有元素  \n        Yes → Step 4: 將 path 複製並加入 subsets // 取得子集  \n        No  →  \n            → Step 5: for i from index to len(nums)-1: // 遍歷剩餘元素  \n                → Step 6: path 加上 nums[i] // 加入當前元素  \n                → Step 7: backtrack(i+1, path) // 進一步回溯  \n                → Step 8: path 從末尾移除 // 回溯回原狀  \n→ Step 9: 呼叫 backtrack(0, []) // 開始回溯  \n→ Step 10: 回傳 subsets // 回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Twitter",
      "source_file": "Leetcode/leetcode355.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbrk6mnbz.py\", line 80, in <module>\n    twitter.follow(*arg)\nTypeError: 'collections.defaultdict' object is not callable"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        # 全域時間戳，確保推文順序唯一\n        self.timestamp = 0\n        # userId -> list[(timestamp, tweetId)]\n        self.tweets = defaultdict(list)\n        # userId -> set(followeeIds)\n        self.follow = defaultdict(set)\n\n    def postTweet(self, userId, tweetId):\n        # 產生遞增時間戳\n        self.timestamp += 1\n        self.tweets[userId].append((self.timestamp, tweetId))\n        # 自己總是關注自己，方便後續取 feed\n        self.follow[userId].add(userId)\n\n    def getNewsFeed(self, userId):\n        res = []\n        # 若使用者沒有任何追蹤關係，回傳空清單\n        if userId not in self.follow:\n            return res\n\n        # 最大堆（使用負數時間戳）取得最新推文\n        heap = []\n        for fid in self.follow[userId]:\n            lst = self.tweets.get(fid, [])\n            if lst:\n                idx = len(lst) - 1\n                ts, tid = lst[idx]\n                heapq.heappush(heap, (-ts, tid, fid, idx))\n\n        # 取前 10 個\n        while heap and len(res) < 10:\n            negts, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx > 0:\n                ts2, tid2 = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ts2, tid2, fid, idx - 1))\n        return res\n\n    def follow(self, followerId, followeeId):\n        if followerId == followeeId:\n            return\n        self.follow[followerId].add(followeeId)\n\n    def unfollow(self, followerId, followeeId):\n        if followerId == followeeId:\n            return\n        self.follow[followerId].discard(followeeId)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n    # 解析為兩個列表\n    try:\n        methods, args = ast.literal_eval(raw)\n    except Exception:\n        # 如果解析失敗，直接結束\n        sys.exit(0)\n\n    twitter = None\n    results = []\n\n    for method, arg in zip(methods, args):\n        if method == \"Twitter\":\n            twitter = Twitter()\n            results.append(None)\n        elif method == \"postTweet\":\n            twitter.postTweet(*arg)\n            results.append(None)\n        elif method == \"follow\":\n            twitter.follow(*arg)\n            results.append(None)\n        elif method == \"unfollow\":\n            twitter.unfollow(*arg)\n            results.append(None)\n        elif method == \"getNewsFeed\":\n            feed = twitter.getNewsFeed(*arg)\n            results.append(feed)\n        else:\n            # 未知方法，忽略\n            results.append(None)\n\n    # 輸出為 JSON，None 會轉成 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step for implementing simplified Twitter. It's a design problem: classes, methods, data structures. We need to produce virtual code lines with comments. Use arrows, decision, Start, End. Each line: \"虛擬碼步驟 // 解釋\". We need to cover initialization, postTweet, getNewsFeed, follow, unfollow. We need to show logic for storing tweets, following relationships, retrieving 10 most recent.\n\nLet's outline: Use a global timestamp counter incremented for each tweet. Store user tweets as list of (timestamp, tweetId). Store followees as set per user. For getNewsFeed, gather tweets from followees and self, sort by timestamp descending, take first 10.\n\nNow we produce virtual code: Start -> Initialize Twitter: set timestamp=0; users map; follows map. Then define methods.\n\nWe need to structure the virtual code as a flow chart style. But we can break into separate blocks: e.g., Start for class; inside methods we use steps. Use Decision steps for condition checks.\n\nLet's produce virtual code like:\n\nStart // Initialize Twitter class\n→ Step 1: 建立全域時間戳 timestamp = 0 // 記錄發佈順序\n→ Step 2: 建立空字典 userTweets // userId -> list of (timestamp, tweetId)\n→ Step 3: 建立空字典 followees // userId -> set of followed userIds\n→ End // Twitter 初始化完成\n\nThen for postTweet:\n\nStart // postTweet(userId, tweetId)\n→ Step 1: timestamp += 1 // 產生遞增時間戳\n→ Step 2: 若 userId 不在 userTweets → 初始化空列表\n→ Step 3: 把 (timestamp, tweetId) 加入 userTweets[userId] // 保存新推文\n→ End\n\nFor follow:\n\nStart // follow(followerId, followeeId)\n→ Step 1: 若 followerId 不在 followees → 初始化空集合\n→ Step 2: 把 followeeId 加入 followees[followerId] // 建立追蹤關係\n→ End\n\nFor unfollow:\n\nStart // unfollow(followerId, followeeId)\n→ Step 1: 若 followerId 不在 followees → 結束 // 沒有追蹤關係\n→ Step 2: 若 followeeId 在 followees[followerId] → 刪除 // 移除追蹤\n→ End\n\nFor getNewsFeed:\n\nStart // getNewsFeed(userId)\n→ Step 1: 建立空列表 candidateTweets // 用於暫存所有相關推文\n→ Step 2: 若 userId 在 userTweets → 將其列表加入 candidateTweets\n→ Step 3: 若 userId 在 followees → 針對每個 followeeId\n        → Decision: 是否有推文? // 判斷是否存在推文列表\n            Yes → 把 followeeId 的 tweet 列表加入 candidateTweets\n            No  → 跳過\n→ Step 4: 把 candidateTweets 按 timestamp 降序排序 // 從新到舊\n→ Step 5: 取前 10 個 tweetId 放入 resultList // 只取 ID\n→ End // 返回 resultList\n\nWe need to produce each line with comment. Use arrow to indicate flow: \"→\". For decisions we need indentation: \"Decision: ...\" then Yes →, No →.\n\nMake sure each line is single virtual code step.\n\nLet's produce lines:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 timestamp = 0 // 全域時間戳\n\n→ Step 2: 初始化 userTweets 為空字典 // 存儲每個使用者的推文\n\n→ Step 3: 初始化 followees 為空字典 // 存儲每個使用者的追蹤關係\n\nEnd // Twitter 物件已初始化\n\nBut this is class initialization, not the main program. But we just produce virtual code lines representing class design.\n\nLet's write separate blocks for each method.\n\nWe need to maintain style: Use \"Start\" and \"End\" for method. But for the class initialization, we can use Start/End as well.\n\nThus we produce:\n\nStart // Twitter class construction\n→ Step 1: timestamp ← 0 // 全域時間戳\n→ Step 2: userTweets ← {} // userId → list[(timestamp, tweetId)]\n→ Step 3: followees ← {} // userId → set(followeeIds)\nEnd // Twitter class ready\n\nThen separate methods:\n\nStart // postTweet(userId, tweetId)\n→ Step 1: timestamp ← timestamp + 1 // 記錄發佈順序\n→ Decision: 若 userId 不在 userTweets?\n    Yes → Step 2: userTweets[userId] ← [] // 初始化空列表\n    No  → (無操作)\n→ Step 3: Append (timestamp, tweetId) to userTweets[userId] // 儲存推文\nEnd // postTweet 完成\n\nStart // follow(followerId, followeeId)\n→ Decision: 若 followerId 不在 followees?\n    Yes → Step 1: followees[followerId] ← {} // 初始化空集合\n    No  → (無操作)\n→ Step 2: Add followeeId to followees[followerId] // 建立追蹤\nEnd // follow 完成\n\nStart // unfollow(followerId, followeeId)\n→ Decision: 若 followerId 不在 followees?\n    Yes → (結束) // 無需處理\n    No  → \n        Decision: 若 followeeId 在 followees[followerId]?\n            Yes → Step 1: Remove followeeId from followees[followerId] // 移除追蹤\n            No  → (無操作)\nEnd // unfollow 完成\n\nStart // getNewsFeed(userId)\n→ Step 1: candidateTweets ← [] // 用於暫存所有相關推文\n→ Decision: 若 userId 在 userTweets?\n    Yes → Step 2: Append all userTweets[userId] to candidateTweets\n    No  → (無操作)\n→ Decision: 若 userId 在 followees?\n    Yes → For each followeeId in followees[userId]:\n            Decision: 若 followeeId 在 userTweets?\n                Yes → Append all userTweets[followeeId] to candidateTweets\n                No  → (無操作)\n    No  → (無操作)\n→ Step 3: Sort candidateTweets by timestamp descending // 從新到舊\n→ Step 4: result ← [] // 先前 10 個 tweetId\n→ Step 5: For each tweet in candidateTweets up to 10:\n            Append tweet.tweetId to result\n→ End // 返回 result\n\nBut we need each step as a line with comment. We need to avoid multi-step loops inside a line; we might split loops into steps. But the instruction is \"逐行地產生對應的虛擬碼\". We can combine loops into a single step but still include explanation. But for clarity we can separate each step inside loops too. But it's a design not actual code.\n\nWe might express loops with \"For each ...\" lines.\n\nSo restructure getNewsFeed with multiple steps.\n\nStart // getNewsFeed(userId)\n→ Step 1: candidateTweets ← [] // 用於暫存所有相關推文\n→ Decision: 若 userId 在 userTweets?\n    Yes → Step 2: Append all userTweets[userId] to candidateTweets\n    No  → (無操作)\n→ Decision: 若 userId 在 followees?\n    Yes → Step 3: For each followeeId in followees[userId] // 遍歷追蹤者\n        → Decision: 若 followeeId 在 userTweets?\n            Yes → Step 4: Append all userTweets[followeeId] to candidateTweets\n            No  → (無操作)\n    No  → (無操作)\n→ Step 5: Sort candidateTweets by timestamp descending // 從新到舊\n→ Step 6: result ← [] // 儲存最終推文 ID\n→ Step 7: For i from 0 to min(9, len(candidateTweets)-1) // 取前 10\n        → Step 8: Append candidateTweets[i].tweetId to result\n→ End // 返回 result\n\nBut we may need to use \"Step\" numbering or just \"Step X:\". We can just use \"Step X:\".\n\nWe need to ensure each line has comment after //.\n\nOk, let's produce the final output.\n...done thinking.\n\nStart // Twitter 物件初始化\n→ Step 1: timestamp ← 0 // 全域時間戳，確保推文順序唯一\n→ Step 2: userTweets ← {} // userId → list[(timestamp, tweetId)]，儲存每個使用者的推文\n→ Step 3: followees ← {} // userId → set(followeeIds)，儲存追蹤關係\nEnd // Twitter 物件已建立\n\nStart // postTweet(userId, tweetId)\n→ Step 1: timestamp ← timestamp + 1 // 產生遞增時間戳，標記此推文時間\n→ Decision: 若 userId 不在 userTweets?\n    Yes → Step 2: userTweets[userId] ← [] // 初始化空推文列表\n    No  → (無操作)\n→ Step 3: Append (timestamp, tweetId) to userTweets[userId] // 將新推文加入使用者列表\nEnd // postTweet 完成\n\nStart // follow(followerId, followeeId)\n→ Decision: 若 followerId 不在 followees?\n    Yes → Step 1: followees[followerId] ← {} // 初始化空追蹤集合\n    No  → (無操作)\n→ Step 2: Add followeeId to followees[followerId] // 建立追蹤關係\nEnd // follow 完成\n\nStart // unfollow(followerId, followeeId)\n→ Decision: 若 followerId 不在 followees?\n    Yes → (結束) // 無需處理，該使用者未追蹤任何人\n    No  → \n        Decision: 若 followeeId 在 followees[followerId]?\n            Yes → Step 1: Remove followeeId from followees[followerId] // 移除追蹤關係\n            No  → (無操作)\nEnd // unfollow 完成\n\nStart // getNewsFeed(userId)\n→ Step 1: candidateTweets ← [] // 用於暫存所有相關推文\n→ Decision: 若 userId 在 userTweets?\n    Yes → Step 2: Append all userTweets[userId] to candidateTweets // 加入自己的推文\n    No  → (無操作)\n→ Decision: 若 userId 在 followees?\n    Yes → Step 3: For each followeeId in followees[userId] // 遍歷追蹤者\n        → Decision: 若 followeeId 在 userTweets?\n            Yes → Step 4: Append all userTweets[followeeId] to candidateTweets // 加入追蹤者推文\n            No  → (無操作)\n    No  → (無操作)\n→ Step 5: Sort candidateTweets by timestamp descending // 從新到舊排序\n→ Step 6: result ← [] // 儲存最終推文 ID\n→ Step 7: For i from 0 to min(9, len(candidateTweets)-1) // 取前 10 個\n        → Step 8: Append candidateTweets[i].tweetId to result // 只取推文 ID\n→ End // 返回 result，完成 news feed 生成"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpebx48_m9.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmpebx48_m9.py\", line 40, in main\n    obj = Solution(*args[0] if args else args)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpebx48_m9.py\", line 11, in __init__\n    for weight in w:\nTypeError: 'int' object is not iterable"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpetv16lz6.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmpetv16lz6.py\", line 40, in main\n    obj = Solution(*args[0] if args else args)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: Solution.__init__() takes 2 positional arguments but 3 were given"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"建構子：建立累積權重表\"\"\"\n        self.prefix = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"根據權重隨機挑選索引\"\"\"\n        target = random.randint(1, self.total)  # 1 ~ total\n        # bisect_left 找到最小的 i 使得 prefix[i] >= target\n        return bisect.bisect_left(self.prefix, target)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 例子輸入形式：'[\"Solution\",\"pickIndex\"], [[[1]],[]]'\n    # 先把整行包成一個 JSON 陣列，方便解析\n    wrapped = '[' + data + ']'\n    parts = json.loads(wrapped)\n\n    methods = parts[0]          # [\"Solution\",\"pickIndex\", ...]\n    args_list = parts[1]        # [[[1]], [], [], ...]\n    results = []\n\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == 'Solution':\n            # 例子中 args = [[1]]，需要解包成單一參數\n            obj = Solution(*args[0] if args else args)\n            results.append(None)  # 建構子不返回值\n        else:\n            func = getattr(obj, method)\n            ret = func(*args)\n            results.append(ret)\n\n    # 輸出結果為 JSON 陣列\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudo-code for implementation of weighted random selection. Use Start, End, Decision. Provide each line with explanation. Not actual code. Use arrow. Ensure structure: Build cumulative sums array, then random number, binary search or linear scan. Since array of weights. Provide steps. Also include initialization and pickIndex method.\n\nLet's produce:\n\nStart // program start\n→ Step 1: 接收輸入 w array // array of weights\n→ Step 2: 計算 prefixSum array // cumulative sums\n    → For i from 0 to w.length-1:\n        prefixSum[i] = (i==0)? w[0] : prefixSum[i-1] + w[i] // build cumulative\n→ Step 3: 設置 total = prefixSum[last] // total weight\n→ End of initialization\n\nThen pickIndex function:\nStart // pickIndex called\n→ Step 4: 產生隨機數 r ∈ [1, total] // inclusive\n→ Decision: 需要找到第一個 prefixSum[i] >= r? // weighted selection\n    → BinarySearch or linear search\n    → If prefixSum[mid] >= r and (mid==0 or prefixSum[mid-1] < r):\n        Yes → Step 5: 回傳 index mid // chosen index\n→ End // pickIndex finished\n\nWe need to include arrow lines with explanation. Use decision structure. Provide each line.\n\nLet's format.\n\nAlso mention use of random generator function.\n\nWe will produce virtual code accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收輸入 w // 取得權重陣列\n→ Step 2: 建立 prefixSum 陣列 // 用於儲存累積權重\n    → For i from 0 to w.length - 1:\n        → Step 2a: 如果 i == 0, prefixSum[0] = w[0]\n        → Step 2b: 否則 prefixSum[i] = prefixSum[i-1] + w[i] // 累加權重\n→ Step 3: 設定 total = prefixSum[w.length - 1] // 總權重\n→ End // 初始化結束\n\nStart // pickIndex() 被呼叫\n→ Step 4: 產生隨機數 r，範圍 [1, total] // 用於選擇索引\n→ Decision: r 落在哪一段累積權重內? // 找到對應索引\n    → BinarySearch or LinearScan:\n        → Step 5: 找到最小的 i 使得 prefixSum[i] ≥ r\n            → Step 6: 回傳 i // 選擇的索引\n→ End // pickIndex() 執行結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # 如果任一輸入為 0，直接回傳 \"0\"\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n        # 位置陣列長度為兩數字長度之和\n        pos = [0] * (m + n)\n\n        # 逐位相乘，累加到對應位置\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                # 使用 ord 取數字的整數值，避免 int() 轉換\n                mul = (ord(num1[i]) - 48) * (ord(num2[j]) - 48)\n                pos[i + j + 1] += mul\n\n        # 進位處理\n        for k in range(len(pos) - 1, 0, -1):\n            carry = pos[k] // 10\n            pos[k] %= 10\n            pos[k - 1] += carry\n\n        # 找到第一個非零位置（去除前導零）\n        idx = 0\n        while idx < len(pos) - 1 and pos[idx] == 0:\n            idx += 1\n\n        # 轉成字串並回傳\n        return ''.join(str(d) for d in pos[idx:])\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 取出所有連續數字，對於形如 \"num1 = '2', num2 = '3'\" 的輸入也能正確解析\n    nums = re.findall(r'\\d+', data)\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n    else:\n        # 若正則表達式抓不到，則嘗試直接拆分空白\n        parts = data.replace(',', ' ').split()\n        if len(parts) >= 2:\n            num1, num2 = parts[0], parts[1]\n        else:\n            # 仍無法解析時直接終止\n            return\n\n    solution = Solution()\n    result = solution.multiply(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each with explanation, step by step algorithm for multiplying two non-negative integers represented as strings without using big integer or int conversion. So typical algorithm: simulate multiplication like grade school: for each digit in num2 from right to left, multiply num1 by that digit, shift appropriately, add to result. We can implement using arrays of ints digits or string builder. Provide steps: parse strings, reverse arrays, initialize result array length sum, iterate, multiply, add carry, etc. Then skip leading zeros, build string. End.\n\nWe need to output line by line with arrows and Decision.\n\nMake sure each line contains \"虛擬碼步驟\" followed by space and comment // explanation.\n\nWe should use Start and End markers.\n\nWe need to use \"→\" arrow for steps. For Decision: use \"Decision:\" with conditions and Yes/No arrow lines.\n\nSo produce something like:\n\nStart // 程式開始\n→ Step 1: 輸入 num1, num2 // 取得兩個字串\n→ Decision: 是否為空字串? // 檢查輸入有效\n    Yes → Step 2: 回傳 \"0\" // 任一為空代表零\n    No  → Step 3: 初始化數字陣列 a, b // 把字串轉成數字陣列\n…\n\nWe need to include each line. Provide short explanation.\n\nWe must not output actual code, just virtual code steps.\n\nOk let's write the virtual code.\n\nWe need to cover:\n\n- Start\n- Input strings\n- Check for zero or empty: if either is \"0\" or empty -> return \"0\"\n- Convert each string to array of digits reversed: a[i] = num1[num1.length-1-i]-'0'\n- Initialize result array of length a.length + b.length, all zeros\n- For i from 0 to a.length-1:\n    For j from 0 to b.length-1:\n        product = a[i]*b[j] + result[i+j] + carry\n        result[i+j] = product % 10\n        carry = product / 10\n    After inner loop, if carry>0: result[i + b.length] += carry\n- After loops, find highest non-zero index in result\n- Build string from highest index down to 0\n- Return string\n- End\n\nWe need to include decisions for empty, zero.\n\nAlso need to skip leading zeros in result.\n\nWe can add decisions for building string: if highest index is -1 => return \"0\".\n\nOk let's produce virtual code lines.\n\nWe will use lines with \"Step\" and \"Decision\". Ensure to include explanation comment after //.\n\nLet's generate.\n\nNote: Use Chinese characters in explanation. Use traditional.\n\nWe'll need \"→\" arrow lines. Indent decisions with spaces.\n\nAlright.\n\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 輸入 num1, num2 // 取得兩個字串\n→ Decision: 任一字串是否為 \"0\" 或空? // 檢查是否為零\n    Yes → Step 2: 回傳 \"0\" // 若任一為零，結果即為零\n    No  → Step 3: 轉換 num1 為數字陣列 a (逆序) // 把字串倒轉並轉成數字\n    No  → Step 4: 轉換 num2 為數字陣列 b (逆序) // 同上\n→ Step 5: 建立 result 陣列，長度為 a.length + b.length，全部初始化為 0 // 儲存乘積\n→ Decision: a.length 是否為 0? // 檢查是否有數字\n    Yes → Step 6: 回傳 \"0\" // 空陣列代表零\n    No  → Step 7: a.length 為正，繼續\n→ Decision: b.length 是否為 0? // 同上\n    Yes → Step 8: 回傳 \"0\"\n    No  → Step 9: b.length 為正，繼續\n→ Step 10: 從 i = 0 到 a.length-1 進行外層迴圈 // 逐位相乘\n    → Step 11: 設定 carry = 0 // 用於記錄進位\n    → Step 12: 從 j = 0 到 b.length-1 進行內層迴圈 // 內層相乘\n        → Step 13: 計算 prod = a[i] * b[j] + result[i+j] + carry // 乘積與進位\n        → Step 14: 設定 result[i+j] = prod % 10 // 儲存當前位\n        → Step 15: 更新 carry = prod / 10 // 取進位\n    → Decision: carry 是否大於 0? // 內層結束後處理多餘進位\n        Yes → Step 16: result[i + b.length] += carry // 將進位加入下一位\n        No  → No → // 無進位，略過\n→ Step 17: 找到 result 中最高非零索引 idx // 去除前置零\n→ Decision: idx 是否為 -1? // 若全為零\n    Yes → Step 18: 回傳 \"0\" // 結果為零\n    No  → Step 19: 建立 string builder sb // 生成最終字串\n→ Decision: 從 idx 迭代至 0? // 逆序組成字串\n    Yes → Step 20: sb.append( char(result[k] + '0') ) // 加入每位\n    No  → No → // 結束迭代\n→ Step 21: 回傳 sb.toString() // 傳回乘積字串\nEnd // 程式結束"
    }
  ]
}