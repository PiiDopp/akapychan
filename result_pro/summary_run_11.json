{
  "run_index": 11,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 391,
  "generation_or_validation_failure_count": 48,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取標準輸入 (stdin) 的所有內容，並寫入 data.txt\n    file_content = sys.stdin.read()\n    try:\n        with open('data.txt', 'w', encoding='utf-8') as f:\n            f.write(file_content)\n    except Exception:\n        # 若寫入失敗，仍然嘗試讀取檔案以回報錯誤\n        pass\n\n    # 讀取 data.txt 並計算行數\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print('檔案共有', len(lines), '行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step as per format. Use virtual code arrows and Decision etc. Must include try/except with file existence. Steps: Start, Decision whether file exists? Actually try open file, catch FileNotFoundError. Within try, with open as f: read lines into list; count lines; output count. Except: output message. End.\n\nWe must output each line with virtual code step and comment. Use Start, Decision. Use indentation? Provide arrow? Use format example: \"Start // 程式開始執行\" etc.\n\nWe need to include with syntax? We'll show virtual step \"Step 1: 開啟檔案 data.txt\" inside try block. Use Decision? Actually Decision is whether file exists but handled by exception. But we can use Decision: 是否發生例外? No. Use Decision: Try open? But we can show Decision: 是否成功開啟? No → except.\n\nMaybe structure:\n\nStart\n→ Step 1: 嘗試開啟 'data.txt' 並使用 with 語法 // 開啟檔案並確保自動關閉\n→ Decision: 是否出現 FileNotFoundError? // 檢查是否成功開啟\n    Yes → Step 2: 輸出 '找不到檔案！' // 檔案不存在\n    No  → Step 3: 讀取所有行並計算行數 // 成功讀取\n        → Step 4: 輸出行數 // 顯示總行數\nEnd\n\nBut we need to represent try/except. Virtual code can include Decision: try成功? No → except. Use Yes and No.\n\nWe need to show \"with\" as a step. We'll show \"with open('data.txt', 'r') as file\" inside the try. Represented as Step 3: 讀取 file.readlines() etc.\n\nThus produce step list.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 嘗試開啟 'data.txt' 並使用 with 語法 // 進入 try 區塊並確保檔案自動關閉  \n→ Decision: 是否發生 FileNotFoundError? // 檢查檔案是否存在  \n Yes → Step 2: 輸出 '找不到檔案！' // 檔案不存在時顯示錯誤訊息  \n No  → Step 3: 讀取檔案所有行並存入 list // 成功開啟後取得每一行的內容  \n  → Step 4: 計算 list 的長度並儲存為 line_count // 獲得總行數  \n  → Step 5: 輸出 line_count // 顯示總行數  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[1,4,5,5,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[1, 4, 5, 5, 3]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳所有結果的串列。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    code = sys.stdin.read()\n    # 執行輸入的程式碼（如 'print(roll_dice(5))'）\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with explanation. Use random module, function roll_dice(n) returns list of results. We'll do steps: Start, import random, define function, initialize results list, loop n times, generate random int 1-6, append to list, end loop, return list, End. Use arrow. Provide each line.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: import random // 導入 random 模組以產生隨機數\n→ Step 2: define function roll_dice(n) // 宣告 roll_dice 函式，參數 n 為擲骰次數\n→ Step 3:   results ← empty list // 建立空列表以存放每次擲骰的結果\n→ Step 4:   for i from 1 to n do // 迴圈執行 n 次\n→ Step 5:       outcome ← random.randint(1, 6) // 產生 1 到 6 的隨機整數，模擬擲骰\n→ Step 6:       append outcome to results // 將擲骰結果加入列表\n→ Step 7:   end for // 結束迴圈\n→ Step 8:   return results // 回傳所有擲骰結果的列表\nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"測量函式執行時間，並回傳四捨五入到小數點第三位的秒數。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入中的完整程式碼\n    source_code = sys.stdin.read()\n    # 執行時提供 measure_time 供使用\n    exec_globals = {\"measure_time\": measure_time, \"time\": time}\n    exec(source_code, exec_globals)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines per spec. The requirement: use time module, function measure_time(func,*args) measure execution time in seconds, return result (rounded to 3 decimals). Provide virtual code lines with arrows, decisions, etc. We should include import time, define function, record start time, call func(*args), record end, compute elapsed, round to 3 decimals, return result. The user wants virtual code only, no actual code. So we must produce lines like:\n\nStart\n→ Import time module\n→ Step 1: 定義函數 measure_time(func, *args)\n    → Step 1.1: 記錄開始時間\n    → Step 1.2: 執行 func(*args) 並存結果\n    → Step 1.3: 記錄結束時間\n    → Step 1.4: 計算 elapsed 秒數\n    → Step 1.5: 四捨五入到小數點3位\n    → Step 1.6: 回傳結果\nEnd\n\nBut they ask for arrow format: Start, End, Decision: etc. Use \"→\". No decisions needed here. Just linear steps.\n\nLet's produce as per format: each line \"虛擬碼步驟 // 解釋\".\n\nInclude import, function definition etc.\n\nUse \"Start // 程式開始執行\".\n\nUse \"→ Step 1: 載入 time 模組 // 引入 time 函式庫\".\n\nBut maybe we can compress into a single step? They want \"逐行\" so each step on a line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Import time module // 引入 time 模組以便測量時間\n→ Step 2: Define measure_time(func, *args) // 建立函式接收目標函式與其參數\n    → Step 2.1: start_time ← time.time() // 紀錄開始時間\n    → Step 2.2: result ← func(*args) // 執行傳入函式並取得返回值\n    → Step 2.3: end_time ← time.time() // 紀錄結束時間\n    → Step 2.4: elapsed ← end_time - start_time // 計算執行所用秒數\n    → Step 2.5: rounded_elapsed ← round(elapsed, 3) // 四捨五入至小數點第三位\n    → Step 2.6: return rounded_elapsed, result // 回傳時間與函式結果\nEnd // 程式結束\n\nBut note they said \"回傳結果 (四捨五入到小數點 3 位)\"—the result maybe the result of func? Or the elapsed time? The phrasing: \"用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)\" Means return the time measurement. So maybe return rounded elapsed, not result. But some may want both. To be safe, we can return time. But also might want the function's result. But the wording: \"回傳結果\" could refer to time measurement.\n\nLet's just return the rounded elapsed. And optionally we could mention we ignore the function result or not needed. We'll do:\n\n→ Step 2.6: return rounded_elapsed // 回傳測量到的秒數\n\nBut if they want function result too, we can add separate line to return result. But not specified.\n\nWe can also provide both: \"return rounded_elapsed, result\" with explanation.\n\nLet's produce both: It returns the time and optionally the result. But we will explain.\n\nLet's final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 引入 time 模組以便測量時間  \n→ Step 2: Define measure_time(func, *args) // 建立測時函式，接收目標函式與任意參數  \n  → Step 2.1: start_time ← time.time() // 記錄開始時間  \n  → Step 2.2: result ← func(*args) // 執行傳入函式並取得回傳值  \n  → Step 2.3: end_time ← time.time() // 記錄結束時間  \n  → Step 2.4: elapsed ← end_time - start_time // 計算執行所需秒數  \n  → Step 2.5: rounded_elapsed ← round(elapsed, 3) // 將秒數四捨五入到小數點第三位  \n  → Step 2.6: return rounded_elapsed, result // 回傳測得秒數（已四捨五入）以及函式結果  \nEnd // 程式結束執行"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "class Student:\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        print(f'{self.name} 的分數是 {self.score}')\n\n\ndef main():\n    import sys\n\n    # 讀取所有輸入並按行分割\n    raw = sys.stdin.read()\n    lines = raw.strip().splitlines()\n\n    # 若輸入為空，使用預設的兩個學生\n    if not lines or all(not line.strip() for line in lines):\n        students = [Student('Alice', 90), Student('Bob', 80)]\n    else:\n        students = []\n        for line in lines:\n            if not line.strip():\n                continue\n            parts = line.split()\n            if len(parts) >= 2:\n                name = parts[0]\n                try:\n                    score = int(parts[1])\n                except ValueError:\n                    continue\n                students.append(Student(name, score))\n\n    # 顯示所有學生資訊\n    for student in students:\n        student.show_info()\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step with explanations. Must not produce actual code. Use Start, End, Decision: maybe not needed. Just linear steps.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義 Student 類別 // 建立一個 Student 類別\n→ Step 2: 定義 __init__() 方法並接受 name 與 score 參數 // 建構子初始化屬性\n→ Step 3: 在 __init__() 內設定 self.name = name, self.score = score // 存儲屬性\n→ Step 4: 定義 show_info() 方法 // 方法用於輸出資訊\n→ Step 5: 在 show_info() 裡輸出 f\"{self.name} 的分數是 {self.score}\" // 顯示姓名與分數\n→ Step 6: 建立第一個 Student 物件 student1 = Student(\"張三\", 95) // 實例化物件\n→ Step 7: 呼叫 student1.show_info() // 顯示第一個物件資訊\n→ Step 8: 建立第二個 Student 物件 student2 = Student(\"李四\", 88) // 實例化第二個物件\n→ Step 9: 呼叫 student2.show_info() // 顯示第二個物件資訊\nEnd // 程式執行結束\n\nMake sure each line has `虛擬碼步驟` + space + `// 解釋`. Use arrow →. Use Start, End. No actual code. Use Step n: but it's fine. Also include `Step` maybe.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 Student 類別 // 建立一個 Student 類別\n→ Step 2: 定義 __init__() 方法並接受 name 與 score 參數 // 建構子初始化屬性\n→ Step 3: 在 __init__() 內設定 self.name = name, self.score = score // 存儲屬性\n→ Step 4: 定義 show_info() 方法 // 方法用於輸出資訊\n→ Step 5: 在 show_info() 裡輸出 f\"{self.name} 的分數是 {self.score}\" // 顯示姓名與分數\n→ Step 6: 建立第一個 Student 物件 student1 = Student(\"張三\", 95) // 實例化物件\n→ Step 7: 呼叫 student1.show_info() // 顯示第一個物件資訊\n→ Step 8: 建立第二個 Student 物件 student2 = Student(\"李四\", 88) // 實例化第二個物件\n→ Step 9: 呼叫 student2.show_info() // 顯示第二個物件資訊\nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"melon\",\"orange\",\"apple\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'melon', 'orange', 'apple', 'grape'}\""
        }
      ],
      "generated_code": "def main():\n    import sys\n    # 讀取並忽略所有輸入，確保程式可從 stdin 接收資料\n    sys.stdin.read()\n\n    # 初始集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 同時新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'（不會拋錯）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate a virtual code step-by-step with arrows, Start, End, decisions etc. But operations are straightforward. No decisions maybe except maybe check if element exists before discard? The requirement: use discard() to attempt removal of 'pineapple' which does not exist; discard doesn't raise error. So no decision needed.\n\nBut we could add a Decision to check existence before discard? But requirement says \"嘗試移除 'pineapple'（此元素不存在）\" - just use discard. So just call discard.\n\nWe need to produce each line with step and comment.\n\nFormat: \"Start // 程式開始執行\" then arrow lines. Use \"→\" for steps. For decisions use \"Decision:\".\n\nWe have: create set, add, update, remove, discard, print.\n\nWe can treat printing as step.\n\nLet's produce lines:\n\nStart\n→ Step 1: Initialize fruits = {'apple', 'banana'} // 建立初始集合\n→ Step 2: Call fruits.add('orange') // 新增 'orange'\n→ Step 3: Call fruits.update({'grape', 'melon'}) // 同時新增 'grape' 與 'melon'\n→ Step 4: Call fruits.remove('banana') // 移除 'banana'\n→ Step 5: Call fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'\n→ Step 6: Output fruits // 顯示最終集合\nEnd\n\nCheck formatting: each line \"虛擬碼步驟 // 解釋\". Use \"→\" arrow lines. Start line no arrow? Example shows \"Start // 程式開始執行\". So we follow same.\n\nNeed to ensure each line separate. Provide final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize fruits = {'apple', 'banana'} // 建立初始集合  \n→ Step 2: Call fruits.add('orange') // 新增 'orange' 至集合  \n→ Step 3: Call fruits.update({'grape', 'melon'}) // 同時新增 'grape' 與 'melon'  \n→ Step 4: Call fruits.remove('banana') // 移除集合中的 'banana'  \n→ Step 5: Call fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'，不會產生錯誤  \n→ Step 6: Output fruits // 顯示最終的集合內容  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.71TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.71 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\nAPI_URL = \"https://api.exchangerate-api.com/v4/latest/USD\"\n\ndef fetch_rate():\n    \"\"\"從 API 取得 USD→TWD 匯率，成功回傳浮點數，失敗回傳 None。\"\"\"\n    try:\n        response = requests.get(API_URL, timeout=10)\n        response.raise_for_status()\n        data = response.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\ndef gui_main():\n    \"\"\"建立 tkinter GUI，顯示匯率並可按鈕更新。\"\"\"\n    root = tk.Tk()\n    root.title(\"匯率查詢\")\n\n    label = tk.Label(root, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update_rate():\n        rate = fetch_rate()\n        if rate is not None:\n            label.config(text=f\"USD→TWD: {rate:.2f} TWD\")\n        else:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n\n    tk.Button(root, text=\"更新匯率\", command=update_rate).pack(pady=5)\n\n    # 取得並顯示初始匯率\n    update_rate()\n    root.mainloop()\n\ndef cli_main():\n    \"\"\"讀取標準輸入，若有指令則直接輸出匯率。\"\"\"\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return False  # 沒有輸入，回傳 False 讓主程式啟動 GUI\n    rate = fetch_rate()\n    if rate is not None:\n        print(f\"目前美元匯率：約 {rate:.2f} TWD\")\n    else:\n        print(\"更新失敗，請檢查網路連線\")\n    return True\n\nif __name__ == \"__main__\":\n    # 若從 stdin 讀取到任何資料就直接以 CLI 方式輸出，否則啟動 GUI\n    if not cli_main():\n        gui_main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines, each line: step plus explanation, with arrow symbols, decisions, etc. Should cover import, creating window, label, button, function to fetch, update label, mainloop. Use decision? maybe none. Provide structure. Let's output each line following format: \"Start // 程式開始執行\" etc. Use arrow lines. We'll include Start, End, steps. Also we can show Decision: maybe checking response status. Provide arrow for yes/no. But not necessary. Provide virtual steps.\n\nLet's produce:\n\nStart\n→ Step 1: import requests, tkinter\n→ Step 2: 定義 fetch_rate 函式\n    → Step 2.1: 發送 GET 請求至 API URL\n    → Decision: 若回應成功? // status code 200\n        Yes → Step 2.2: 解析 JSON 取得 rates['TWD'] // 提取匯率\n        No  → Step 2.3: 回傳 None // 失敗\n    → Step 2.4: 回傳匯率值或錯誤訊息\n→ Step 3: 建立主視窗 root\n→ Step 4: 建立 Label 顯示匯率訊息\n→ Step 5: 建立 Button 按鈕，點擊時執行 update_rate\n    → Step 5.1: 在 update_rate 內呼叫 fetch_rate\n    → Decision: 若匯率不為 None? // 有有效值\n        Yes → Step 5.2: 更新 Label 文字為 \"USD→TWD: {rate}\"\n        No  → Step 5.3: 更新 Label 文字為 \"匯率取得失敗\"\n→ Step 6: 呼叫 update_rate 以顯示初始匯率\n→ Step 7: 執行 root.mainloop()\nEnd\n\nMake sure each line ends with // 解釋. Use arrow for nested steps? Provide indentation? Use arrows and \"Yes →\", \"No →\". Let's format accordingly.\n\nLet's produce lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: import requests, tkinter // 匯入 requests 以發送 HTTP 請求、tkinter 以建立 GUI  \n→ Step 2: 定義 fetch_rate() 函式 // 取得 USD→TWD 匯率的功能  \n&nbsp;&nbsp;→ Step 2.1: url = \"https://api.exchangerate-api.com/v4/latest/USD\" // API 端點  \n&nbsp;&nbsp;→ Step 2.2: response = requests.get(url) // 送出 GET 請求  \n&nbsp;&nbsp;→ Decision: 如果 response.status_code == 200? // 檢查請求是否成功  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2.3: data = response.json() // 解析 JSON  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2.4: rate = data[\"rates\"][\"TWD\"] // 取得 TWD 匯率  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2.5: return rate // 回傳匯率  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 2.6: return None // 回傳 None 表示失敗  \n→ Step 3: root = tkinter.Tk() // 建立主視窗  \n→ Step 4: label = tkinter.Label(root, text=\"請點擊更新匯率\") // 顯示訊息的標籤  \n→ Step 5: 定義 update_rate() 函式 // 更新匯率顯示  \n&nbsp;&nbsp;→ Step 5.1: rate = fetch_rate() // 取得最新匯率  \n&nbsp;&nbsp;→ Decision: 如果 rate is not None? // 檢查是否成功取得  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5.2: label.config(text=f\"USD→TWD: {rate}\") // 更新標籤內容  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 5.3: label.config(text=\"匯率取得失敗\") // 顯示失敗訊息  \n→ Step 6: button = tkinter.Button(root, text=\"更新匯率\", command=update_rate) // 按鈕觸發更新  \n→ Step 7: layout: label.pack(pady=10) // 放置標籤  \n&nbsp;&nbsp;&nbsp;&nbsp;button.pack(pady=5) // 放置按鈕  \n→ Step 8: update_rate() // 取得並顯示初始匯率  \n→ Step 9: root.mainloop() // 啟動 GUI 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[0,0],[1,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null,[2,0],[0,0],[1,0],null,[0,0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n\n        self._remaining = self.total\n        self._indices = list(range(self.total))  # 1D mapping of cells\n\n    def flip(self):\n        # Randomly pick an index among the remaining ones\n        idx = random.randint(0, self._remaining - 1)\n        pos = self._indices[idx]\n        # Move the chosen index to the end of the pool\n        self._indices[idx], self._indices[self._remaining - 1] = (\n            self._indices[self._remaining - 1],\n            self._indices[idx],\n        )\n        self._remaining -= 1\n        # Convert back to 2D coordinates\n        return [pos // self.n, pos % self.n]\n\n    def reset(self):\n        self._remaining = self.total\n        self._indices = list(range(self.total))\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split the input into the operations list and the arguments list\n    split_idx = data.find('],')\n    if split_idx == -1:\n        # If no comma separator found, treat the whole input as a single JSON array\n        ops = json.loads(data)\n        args = []\n    else:\n        ops_part = data[:split_idx + 1]\n        args_part = data[split_idx + 2 :]\n        ops = json.loads(ops_part)\n        args = json.loads(args_part)\n\n    result = []\n    solution_obj = None\n    for i, op in enumerate(ops):\n        if op == \"Solution\":\n            m, n = args[i]\n            solution_obj = Solution(m, n)\n            result.append(None)\n        elif op == \"flip\":\n            res = solution_obj.flip()\n            result.append(res)\n        elif op == \"reset\":\n            solution_obj.reset()\n            result.append(None)\n        else:\n            # Unknown operation; skip or raise error\n            result.append(None)\n\n    # Output the result list in JSON format (null for None)\n    print(json.dumps(result, separators=(\",\", \":\")))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, with explanation comments. Must not output actual code. Just pseudocode. Use Start, End, Decision, arrow. Need to cover initialization, flip, reset, algorithm. Minimizing random calls: typical solution: maintain list of all indices in 1D flattened, random pick index, swap with last, pop. We'll produce algorithm steps accordingly.\n\nWe need to produce a full design of solution class, with methods and internal data structures.\n\nWe'll write: Start, Step 1: Initialize m,n, totalCells = m*n; array = [0..totalCells-1]; remaining = totalCells.\n\nMethod flip: Decision: if remaining==0? No. randomIndex = random(0, remaining-1). index = array[randomIndex]. Compute i=index//n, j=index%n. Swap array[randomIndex] with array[remaining-1]; remaining--. Return [i,j].\n\nMethod reset: Reinitialize array with 0..totalCells-1; remaining=totalCells.\n\nAlso include explanation. Use proper formatting. Ensure each line ends with // explanation. Use spaces. Let's craft.\n\nWe'll include class definition lines as steps too. Use \"Start\" and \"End\".\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 Solution(m, n) // 建立物件並存放矩陣尺寸\n    → Step 2: 設定 total = m * n // 總格數\n    → Step 3: 建立 array = [0, 1, …, total-1] // 1D 位置映射\n    → Step 4: 設定 remaining = total // 可用格子數量\n\n→ Step 5: 定義 flip() 方法 // 隨機選取未翻轉的格子並翻轉\n    → Decision: 如果 remaining == 0? // 檢查是否所有格子已翻轉\n        Yes → Step 6: 回傳空陣列 [] // 或拋出例外表示無法再翻轉\n        No  → Step 7: 隨機選取 randIdx ∈ [0, remaining-1] // 只呼叫一次 random\n            → Step 8: pos = array[randIdx] // 取得對應的 1D 索引\n            → Step 9: i = pos // n // 轉為 2D 行座標\n            → Step 10: j = pos % n // 轉為 2D 列座標\n            → Step 11: Swap array[randIdx] 與 array[remaining-1] // 置換已選格子至末尾\n            → Step 12: remaining-- // 減少可用格子數\n            → Step 13: 回傳 [i, j] // 回傳已翻轉的格子座標\n\n→ Step 14: 定義 reset() 方法 // 將所有格子重設為 0\n    → Step 15: 重建 array 為 [0, 1, …, total-1] // 重新填充所有索引\n    → Step 16: 設定 remaining = total // 重設可用格子數\n\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjpjmjbz3.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmpjpjmjbz3.py\", line 49, in main\n    obj.buildDict(arg)\n  File \"/tmp/tmpjpjmjbz3.py\", line 10, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 支援兩行或單行以逗號分隔的輸入\n    parts = data.splitlines()\n    if len(parts) >= 2:\n        cmds = ast.literal_eval(parts[0].strip())\n        args = ast.literal_eval(parts[1].strip())\n    else:\n        # 假設輸入為兩個表達式，用逗號分隔\n        comma_index = data.find('],')\n        if comma_index != -1:\n            first = data[:comma_index+1]\n            second = data[comma_index+2:].strip()\n            cmds = ast.literal_eval(first)\n            args = ast.literal_eval(second)\n        else:\n            raise ValueError(\"輸入格式不正確\")\n\n    outputs = []\n    obj = None\n    for cmd, arg in zip(cmds, args):\n        if cmd == \"MagicDictionary\":\n            obj = MagicDictionary()\n            outputs.append(None)\n        elif cmd == \"buildDict\":\n            obj.buildDict(arg)\n            outputs.append(None)\n        elif cmd == \"search\":\n            res = obj.search(arg)\n            outputs.append(res)\n        else:\n            raise ValueError(f\"未知指令 {cmd}\")\n\n    # 使用 json.dumps 以符合 LeetCode 的輸出格式\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for MagicDictionary class with buildDict and search. Use virtual steps with arrows, decisions. Must be line-by-line. Provide explanation after each line. Let's think of algorithm: For searchWord, we need to see if changing exactly one character yields a word in dictionary. Approach: store dictionary words. For each word in dictionary, check if len same, and count differing characters. If exactly 1, return true. But efficient: Precompute all patterns with one wildcard. But since we just need virtual code, we can present algorithmic approach: building dictionary, search logic. Let's produce steps:\n\nStart\n→ Initialize MagicDictionary object // constructor\n    → Create empty set dictionarySet // store words\nEnd // constructor ends\n\n→ buildDict(dictionary) // input array of words\n    → For each word in dictionary\n        → Add word to dictionarySet\nEnd // buildDict ends\n\n→ search(searchWord)\n    → For each word in dictionarySet\n        → If length differs, continue\n        → Count mismatches between word and searchWord\n        → If mismatchCount == 1, return true\n    → Return false\nEnd // search ends\n\nBut we need decision steps: decision if length equal, if mismatchCount==1.\n\nWe also can precompute patterns: For each word, generate all strings with one character replaced by wildcard '*' and map to list of words. But let's keep simple.\n\nThe virtual code lines with arrows and explanations. Use Decision: and Yes/No branches. Each line: \"虛擬碼步驟 // 解釋\". Ensure each line separate. Let's craft.\n\nWe need to use arrow \"→\" at start of each step after start? In example, \"→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\". So start line: \"Start // 程式開始執行\". Then arrow lines.\n\nSo produce:\n\nStart // 程式開始執行\n→ Class MagicDictionary // 定義 MagicDictionary 類別\n    → Constructor MagicDictionary() // 建構子\n        → Create empty set dictionarySet // 用於存放字典詞彙\n    → End // 建構子結束\n→ End // 類別定義結束\n\nBut maybe too granular. Let's produce main methods.\n\nLet's propose structure:\n\nStart // 程式開始執行\n→ Step 1: 定義 MagicDictionary 類別 // 建立資料結構\n    → Step 1.1: 建構子 MagicDictionary() // 初始化\n        → Step 1.1.1: dictionarySet ← empty set // 儲存字典\n    → Step 2: buildDict(dictionary) // 設定字典\n        → Step 2.1: For each word in dictionary\n            → Step 2.1.1: Add word to dictionarySet // 存入集合\n    → Step 3: search(searchWord) // 搜尋是否能正好改一字符合字典\n        → Step 3.1: For each word in dictionarySet\n            → Decision: if length(word) != length(searchWord) // 檢查長度\n                → No → Continue to next word // 長度不同則不符合\n                → Yes → Proceed to compare\n            → Step 3.2: mismatchCount ← 0\n            → Step 3.3: For i from 0 to length-1\n                → Decision: if word[i] != searchWord[i]\n                    → Yes → mismatchCount ← mismatchCount + 1\n            → Decision: if mismatchCount == 1\n                → Yes → Return true // 找到符合\n                → No → Continue loop\n        → Return false // 未找到符合\nEnd // 程式結束\n\nBut ensure each line has arrow and explanation. Need to maintain formatting: \"虛擬碼步驟 [space] // 解釋\". Let's format:\n\nStart // 程式開始執行\n→ Define MagicDictionary class // 建立 MagicDictionary 類別\n    → Constructor MagicDictionary() // 初始化物件\n        → dictionarySet ← empty set // 用來存放字典詞彙\n    → End // 建構子結束\n→ buildDict(dictionary) // 設定字典\n    → For each word in dictionary\n        → Add word to dictionarySet // 將詞彙加入集合\n→ End // buildDict 結束\n→ search(searchWord) // 搜尋是否能正好改一字符合字典\n    → For each word in dictionarySet\n        → Decision: if length(word) != length(searchWord) // 檢查長度是否相同\n            → No → Continue to next word // 不相同則跳過\n            → Yes → Proceed to compare characters\n        → mismatchCount ← 0 // 初始化差異數量\n        → For i from 0 to length(word)-1\n            → Decision: if word[i] != searchWord[i] // 比較每個字符\n                → Yes → mismatchCount ← mismatchCount + 1 // 差異加一\n        → Decision: if mismatchCount == 1 // 檢查是否恰好一個差異\n            → Yes → Return true // 找到符合的字\n            → No → Continue loop // 否則檢查下一個字\n    → Return false // 沒有符合的字\nEnd // 程式結束\n\nBut the example used \"→ Step 1:\" etc. Here we can use similar. Use arrow before each step. Let's produce a final answer. Ensure no actual code, just virtual steps. Use Chinese explanation. Use indentation.\n\nLet's output exactly lines. Ensure each line ends with comment. Provide indentation for readability.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define MagicDictionary class // 建立 MagicDictionary 類別  \n&nbsp;&nbsp;→ Constructor MagicDictionary() // 初始化物件  \n&nbsp;&nbsp;&nbsp;&nbsp;→ dictionarySet ← empty set // 用來存放字典詞彙  \n&nbsp;&nbsp;→ End // 建構子結束  \n→ buildDict(dictionary) // 設定字典  \n&nbsp;&nbsp;→ For each word in dictionary  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Add word to dictionarySet // 將詞彙加入集合  \n→ End // buildDict 結束  \n→ search(searchWord) // 搜尋是否能正好改一字符合字典  \n&nbsp;&nbsp;→ For each word in dictionarySet  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: if length(word) != length(searchWord) // 檢查長度是否相同  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ No → Continue to next word // 不相同則跳過  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Yes → Proceed to compare characters // 長度相同時進行比較  \n&nbsp;&nbsp;&nbsp;&nbsp;→ mismatchCount ← 0 // 初始化差異數量  \n&nbsp;&nbsp;&nbsp;&nbsp;→ For i from 0 to length(word)-1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: if word[i] != searchWord[i] // 比較每個字符  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Yes → mismatchCount ← mismatchCount + 1 // 差異加一  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: if mismatchCount == 1 // 檢查是否恰好一個差異  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Yes → Return true // 找到符合的字  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ No → Continue loop // 否則檢查下一個字  \n&nbsp;&nbsp;→ Return false // 沒有符合的字  \nEnd // 程式結束"
    },
    {
      "title": "Bulb Switcher II",
      "source_file": "Leetcode/leetcode672.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "n = 3, presses = 1",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef count_states(n: int, presses: int) -> int:\n    # Determine which bulb types exist among 1..n\n    # Types: 0 = even & not 1mod3, 1 = even & 1mod3,\n    #        2 = odd & not 1mod3, 3 = odd & 1mod3\n    types_exist = [False] * 4\n    for i in range(1, n + 1):\n        even = (i % 2 == 0)\n        mod3 = (i % 3 == 1)\n        if even:\n            t = 1 if mod3 else 0\n        else:\n            t = 3 if mod3 else 2\n        types_exist[t] = True\n\n    unique_patterns = set()\n\n    # Iterate over all 16 parity combinations of the 4 buttons\n    for p in range(16):\n        p1 = (p >> 0) & 1  # Button 1\n        p2 = (p >> 1) & 1  # Button 2\n        p3 = (p >> 2) & 1  # Button 3\n        p4 = (p >> 3) & 1  # Button 4\n\n        sum_pi = p1 + p2 + p3 + p4\n        # Feasibility check: presses must be at least sum_pi and have same parity\n        if presses < sum_pi or (presses - sum_pi) % 2 != 0:\n            continue\n\n        pattern_bits = []\n        for t in range(4):\n            if not types_exist[t]:\n                continue\n            # Determine which buttons affect this type\n            b2 = 1 if t % 2 == 0 else 0          # even bulbs\n            b3 = 1 if t % 2 == 1 else 0          # odd bulbs\n            b4 = 1 if t in (1, 3) else 0         # 1 mod 3 bulbs\n            toggle = (p1 + p2 * b2 + p3 * b3 + p4 * b4) % 2\n            final_bit = '1' if toggle == 0 else '0'  # '1' for ON, '0' for OFF\n            pattern_bits.append(final_bit)\n\n        pattern_str = ''.join(pattern_bits)\n        unique_patterns.add(pattern_str)\n\n    return len(unique_patterns)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, presses = nums[0], nums[1]\n    result = count_states(n, presses)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step. The user wants the virtual code for solving the problem. We must not output actual code, only steps. The code should handle counting distinct statuses after exactly presses button presses on n bulbs. We need algorithm: Since pressing a button twice cancels its effect (flips twice). The order of pressing doesn't matter, only counts modulo 2. So we can consider each button pressed 0 or 1 time? Wait exactly presses button presses, but we can press same button multiple times; but effect depends on parity. So we need to count number of combinations of presses of 4 buttons such that total presses equals given number, and the resulting configuration differs. Equivalent to choose counts c1..c4 >=0, sum ci = presses. Resulting effect is XOR of ci parity for each button. The effective state is determined by parity vector p = (c1 mod 2, c2 mod 2, c3 mod 2, c4 mod 2). But different count combos with same parity produce same final state. So number of distinct statuses is number of distinct parity vectors achievable with sum ci = presses. For each parity vector we can check if there is nonnegative integer solution to c1..c4 with that parity and sum = presses.\n\nThus we need to compute how many parity vectors are feasible.\n\nWe can iterate over all 16 parity combinations; for each, check feasibility: need to find integers x1..x4 >=0 such that xi mod 2 = pi, and sum xi = presses. Equivalent to existence of solution: Let yi = (xi - pi)/2 must be integer >=0. Then sum xi = sum pi + 2*sum yi = presses. So sum yi = (presses - sum pi)/2. This requires presses >= sum pi and (presses - sum pi) even. Also need sum yi >=0 integer. So condition: presses >= sum pi and parity condition.\n\nThus number of feasible parity vectors is number of subsets of {1,2,3,4} such that sum pi <= presses and (presses - sum pi) even.\n\nHence output number of different possible statuses.\n\nThe virtual code should include steps: input n, presses, compute answer via formula, output.\n\nNeed to handle n? Actually n not used except maybe to compute statuses? Wait bulbs labelled 1..n but we only need number of distinct final states. The number of bulbs may matter if some buttons affect subset; but the final status is determined by which bulbs turned on/off. But different parity vectors might produce same final status? For example, if n is small, some button combinations may produce same effect. Wait we must compute number of different possible statuses, i.e., distinct configurations of bulbs on/off. The set of bulbs is finite; different parity vectors may produce same configuration if the actions are not independent. For example, button 2 flips even bulbs, button 3 flips odd bulbs. Combined, pressing both flips all bulbs, same as button 1. So there may be dependencies. So our earlier assumption of independence fails.\n\nWe must compute distinct statuses after pressing combination of buttons with given parities. The resulting status can be represented as a vector of n bits: each bulb i toggled if sum over buttons affecting it of parity is odd. We need count of distinct vectors.\n\nWe can treat each button as vector over GF(2)^n. Buttons: 1: all ones; 2: even indices ones; 3: odd indices ones; 4: indices 3k+1 ones. We need number of distinct sums of subset of these vectors with weights (parities). But we also need constraint of presses sum = presses.\n\nSo the set of reachable states = {p1*v1 XOR p2*v2 XOR p3*v3 XOR p4*v4 | p1..p4 in {0,1}, exists ci >=0 sum ci = presses with parity pi=ci mod2}. So the same as earlier but states are linear combinations of button vectors. Distinct states equal number of distinct linear combinations that satisfy the feasibility constraints. So we need to compute rank of the set of vectors to determine number of distinct combinations.\n\nBut we also have parity constraints on total presses. So for each parity vector p, if feasible, state is S(p) = XOR over buttons with pi=1 of vector. Distinct S(p) may coincide for different p if linear dependence. So we need to count number of distinct S(p) among feasible parity vectors.\n\nThus algorithm: compute all 16 parity vectors, filter feasible ones. Then compute resulting state vector for each, count unique. But n up to maybe large; we can represent state by parity of each bulb, but we only need count unique; we can compute effect on bulbs by formula.\n\nWe can derive that for a given parity vector, each bulb i's state = initial ON toggled by number of buttons affecting it with pi=1. Since all bulbs initially ON, final state ON if toggled even times; OFF if toggled odd times.\n\nSo we can compute for each bulb parity of toggles: toggles = (p1) + (p2 if i even) + (p3 if i odd) + (p4 if i mod3 ==1). So final ON if toggles mod2 ==0.\n\nThus state vector determined by parity of toggles for each i.\n\nTo count distinct states, we can categorize bulbs by their toggle parity pattern across buttons. But n may be large, but we can compute number of distinct states by counting number of distinct combinations of toggle parity patterns across i. Since bulbs are symmetric except for labeling, but the button pattern may produce same toggling for different i.\n\nWe can compute equivalence classes of bulb indices based on which buttons affect them: For each i, define mask bits: even? odd? (redundant), mod3==1? Actually even and odd partition but parity. Let's compute mask for i: m(i) = (i even?1:0)*2 + (i odd?1:0)*? Actually we need separate bits for buttons 2 and 3. So mask bits: b2= i%2==0, b3= i%2==1, b4= i%3==1. Button1 always affects. So final toggle parity for state defined by p1+p2*b2+p3*b3+p4*b4 mod2.\n\nThus each bulb's behavior depends on (b2,b3,b4). There are at most 2*2*2=8 combinations, but note b2 and b3 are complementary: if i even then b2=1, b3=0; if odd then b2=0,b3=1. So only 4 possibilities? Actually we can still treat as 8 but some impossible: combinations where both b2=1 and b3=1 cannot happen. Also both 0 cannot happen. So there are 4 possible patterns: even, odd, even with mod3==1? Wait mod3 condition independent.\n\nSo each bulb falls into one of 4 types: even not 1 mod3, even 1 mod3, odd not 1 mod3, odd 1 mod3.\n\nThus final state vector determined by parity for each type.\n\nSo we can compute for each parity vector p, the resulting state pattern: for each type, final ON/OFF. So we can represent state as 4 bits (ON/OFF for each type). So at most 16 distinct states.\n\nThus we can enumerate all feasible parity vectors (at most 16), compute the 4-bit pattern, count unique.\n\nThus algorithm: input n, presses; compute feasible parity vectors; for each, compute pattern for 4 types; use set to count unique.\n\nWe don't need n except to decide number of bulbs per type maybe but final ON/OFF pattern depends on p only, not n. Unless some type has zero bulbs: e.g., if n small, some types may not exist, then some patterns may be same? If a type has zero bulbs, that bit irrelevant. So we should consider only types present in [1,n]. So pattern uniqueness may be reduced. So we need to consider only bulbs that exist. So we can treat pattern bits for types that exist; others don't matter.\n\nThus we can compute which of the 4 types exist for given n. Then use pattern of those types to identify state.\n\nImplementation: For i from 1 to n, compute type index: t=0..3: 0=even & not mod3=1, 1=even & mod3=1, 2=odd & not mod3=1, 3=odd & mod3=1. Mark exist[t]=true.\n\nThen for each parity vector, compute for each type t: toggle parity = p1 + p2*b2 + p3*b3 + p4*b4 where b2,b3,b4 derived from type. Since type already encodes b2,b3,b4: For t: b2 = 1 if type even else 0; b3=1 if type odd else 0; b4=1 if type mod3=1 else 0. Then final state bit = (toggle parity %2==0)?1:0 (ON if even toggles). So pattern as string of bits for types that exist.\n\nCount distinct patterns.\n\nEdge case: if n=0? Not given. So proceed.\n\nThus final virtual code steps: read n presses; compute feasible parity vectors; compute existence types; loop parity vectors, compute pattern, add to set, count.\n\nWe must output virtual code lines.\n\nLet's produce virtual code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 n 與 presses // 取得房間燈數與按鈕按壓總數  \n\n→ Step 2: 定義 types_exist[4] 為 false // 標記四種燈型別是否存在  \n→ Step 3: for i = 1 to n  \n  → Step 3.1: 判斷 i 為偶數、奇數與 (i mod 3 == 1)  \n  → Step 3.2: 計算 type_index (0:偶且非1mod3, 1:偶且1mod3, 2:奇且非1mod3, 3:奇且1mod3)  \n  → Step 3.3: types_exist[type_index] ← true // 標記此型別存在  \n\n→ Step 4: 初始化 set<string> unique_patterns // 用於存放不同的燈狀態模式  \n\n→ Step 5: for each parity vector p in 0..15 (四個按鈕的 0/1 狀態)  \n  → Step 5.1: 取得 p1,p2,p3,p4 的位元  \n  → Step 5.2: 檢查 feasibility  \n    → Step 5.2.1: sum_pi ← p1+p2+p3+p4  \n    → Step 5.2.2: 若 presses < sum_pi 或 (presses - sum_pi) % 2 ≠ 0  \n      → Step 5.2.3: continue // 此 parity vector 無法用給定 presses 實現  \n  → Step 5.3: 初始化 string pattern = \"\" // 以存在的型別為順序存儲 ON/OFF 狀態  \n  → Step 5.4: for t = 0 to 3  \n    → Step 5.4.1: 若 types_exist[t] 為 false，跳過此型別  \n    → Step 5.4.2: 取得 b2,b3,b4 來自型別 t  \n      b2 = (t % 2 == 0) ? 1 : 0 // 偶數型別有按鈕2  \n      b3 = (t % 2 == 1) ? 1 : 0 // 奇數型別有按鈕3  \n      b4 = (t == 1 || t == 3) ? 1 : 0 // 1mod3型別有按鈕4  \n    → Step 5.4.3: toggle_parity ← (p1 + p2*b2 + p3*b3 + p4*b4) % 2  \n    → Step 5.4.4: final_bit ← (toggle_parity == 0) ? '1' : '0' // 1表示燈亮  \n    → Step 5.4.5: pattern ← pattern + final_bit // 將此型別的結果加入模式字串  \n  → Step 5.5: unique_patterns.insert(pattern) // 將模式加入集合  \n\n→ Step 6: answer ← unique_patterns.size() // 不同可能的燈狀態數量  \n\n→ Step 7: 輸出 answer // 顯示結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Heaters",
      "source_file": "Leetcode/leetcode475.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "houses = [1,2,3], heaters = [2]",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      'Invalidinput'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      'Invalid input'"
        },
        {
          "example_index": 1,
          "input": "houses = [1,2,3,4], heaters = [1,4]",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      'Invalidinput'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      'Invalid input'"
        },
        {
          "example_index": 2,
          "input": "houses = [1,5], heaters = [2]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      'Invalidinput'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      'Invalid input'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findRadius(self, houses, heaters):\n        houses.sort()\n        heaters.sort()\n        res = 0\n        i = 0  # 指向最近的右邊加熱器\n\n        for house in houses:\n            # 找到離 house 最近的右邊加熱器\n            while i < len(heaters) - 1 and abs(heaters[i+1] - house) <= abs(heaters[i] - house):\n                i += 1\n            # 記錄最遠距離\n            res = max(res, abs(heaters[i] - house))\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 轉換為字典字面量，方便解析\n    expr = '{' + data.replace('\\n', '') + '}'\n    try:\n        parsed = ast.literal_eval(expr)\n    except Exception as e:\n        # 若解析失敗，直接終止\n        print(\"Invalid input\")\n        return\n    houses = parsed.get('houses', [])\n    heaters = parsed.get('heaters', [])\n    sol = Solution()\n    radius = sol.findRadius(houses, heaters)\n    print(radius)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode for the problem: given positions of houses and heaters on a horizontal line, find minimum radius such that heaters cover all houses. This is a classic problem: For each house, find distance to nearest heater; radius is max of these distances. So algorithm: sort houses and heaters, iterate houses, for each house find nearest heater using two-pointer or binary search; compute distance; keep max. Complexity O((n+m) log(n+m)). Provide step-by-step pseudocode.\n\nWe need to output step-by-step lines with \"→\" arrow etc. Each line: Virtual code step + \" // explanation\".\n\nWe must not output actual code; just pseudocode lines.\n\nLet's craft.\n\nStart\n→ Step 1: Read list of house positions into array H\n→ Step 2: Read list of heater positions into array T\n→ Step 3: Sort array H ascending // ordering simplifies distance calculation\n→ Step 4: Sort array T ascending // heaters sorted too\n→ Step 5: Initialize pointer i = 0 // index for houses\n→ Step 6: Initialize pointer j = 0 // index for heaters\n→ Step 7: Initialize variable maxRadius = 0 // will store maximum minimal distance\n→ Decision: While i < length(H) // iterate each house\n    → Step 7a: While j < length(T)-1 AND abs(H[i]-T[j]) >= abs(H[i]-T[j+1]) // move heater pointer to nearest heater\n        → Step 7a1: j = j + 1 // shift to next heater if closer\n    → Step 7b: Compute distance d = abs(H[i]-T[j]) // nearest heater distance\n    → Step 7c: If d > maxRadius\n        → Step 7c1: maxRadius = d // update maximum radius needed\n    → Step 7d: i = i + 1 // move to next house\n→ End // after loop all houses processed\n→ Step 8: Output maxRadius // this is minimal radius required\n\nNeed to make each line with arrow and explanation. Use \"Decision:\" etc. Should include indentation.\n\nMake sure to include \"→\" before each step and \"Decision:\" lines. For loops use \"Decision:\"? The example uses Decision for condition. We can use \"Decision: While i < length(H)?\" then Yes→ etc. But simpler: use \"Decision:\" for while loops. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取房屋座標陣列 H // 收集所有房屋位置\n→ Step 2: 讀取加熱器座標陣列 T // 收集所有加熱器位置\n→ Step 3: 將陣列 H 依升序排序 // 方便之後尋找最近加熱器\n→ Step 4: 將陣列 T 依升序排序 // 同樣整理加熱器位置\n→ Step 5: 設定指標 i = 0 // 房屋索引\n→ Step 6: 設定指標 j = 0 // 加熱器索引\n→ Step 7: 設定 maxRadius = 0 // 目前已知需要的最大半徑\n→ Decision: i < length(H) ? // 是否還有未處理的房屋\n    Yes → Step 8: While j < length(T)-1 AND abs(H[i]-T[j]) >= abs(H[i]-T[j+1]) ?\n        Yes → Step 8a: j = j + 1 // 移到更靠近的加熱器\n        No  → Step 8b: 跳出\n    No  → Step 9: 跳出主迴圈\n→ Decision: // 以上為尋找最近加熱器的子迴圈\n→ Step 10: 計算 d = abs(H[i]-T[j]) // 當前房屋到最近加熱器的距離\n→ Decision: d > maxRadius ? // 是否需要擴大半徑\n    Yes → Step 11: maxRadius = d // 更新最大半徑\n    No  → Step 12: 保持不變\n→ Step 13: i = i + 1 // 進入下一個房屋\n→ End // 主迴圈結束\n→ Step 14: 輸出 maxRadius // 結果即為最小標準半徑\n\nBut the structure should be simpler. Use nested Decision properly.\n\nAlternatively we can avoid nested Decision for while loops; but requirement: use Decision: with Yes→ No→. We need to show loop with Decision. Let's craft more clean pseudocode:\n\nStart\n→ Step 1: 讀取房屋座標陣列 H\n→ Step 2: 讀取加熱器座標陣列 T\n→ Step 3: 排序 H\n→ Step 4: 排序 T\n→ Step 5: i = 0\n→ Step 6: j = 0\n→ Step 7: maxRadius = 0\n→ Decision: i < len(H) ?\n    Yes → Step 8: Decision: j < len(T)-1 AND abs(H[i]-T[j]) >= abs(H[i]-T[j+1]) ?\n        Yes → Step 8a: j = j + 1\n        No  → Step 8b: // 移動完成\n    No  → Step 9: // 進行距離計算\n→ Step 9: d = abs(H[i]-T[j])\n→ Decision: d > maxRadius ?\n    Yes → Step 10: maxRadius = d\n    No  → Step 11: // 仍然保持\n→ Step 12: i = i + 1\n→ End // loop end\n→ Step 13: 輸出 maxRadius\n\nBut the above incorrectly places Step 9 under No branch of Decision. Let's restructure:\n\nStart\n→ Step 1: 讀取 H\n→ Step 2: 讀取 T\n→ Step 3: 排序 H\n→ Step 4: 排序 T\n→ Step 5: i = 0\n→ Step 6: j = 0\n→ Step 7: maxRadius = 0\n→ Decision: i < len(H) ?\n    Yes → // 主迴圈內\n        → Decision: j < len(T)-1 AND abs(H[i]-T[j]) >= abs(H[i]-T[j+1]) ?\n            Yes → j = j + 1\n            No  → // 繼續後續\n        → d = abs(H[i]-T[j])\n        → Decision: d > maxRadius ?\n            Yes → maxRadius = d\n            No  → // 保持\n        → i = i + 1\n        → // 回到主迴圈判斷\n    No  → // 完成\n→ End\n→ Step 14: 輸出 maxRadius\n\nThat seems correct. We need to ensure each line has arrow. Use \"Decision:\" lines. Also include explanation comments.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取房屋座標陣列 H // 收集所有房屋的位置\n→ Step 2: 讀取加熱器座標陣列 T // 收集所有加熱器的位置\n→ Step 3: 排序 H  // 使房屋位置升序，方便後續搜尋\n→ Step 4: 排序 T  // 使加熱器位置升序，方便兩指標搜尋\n→ Step 5: i = 0    // 房屋指標初始化\n→ Step 6: j = 0    // 加熱器指標初始化\n→ Step 7: maxRadius = 0 // 目前已知需要的最大半徑\n→ Decision: i < len(H) ? // 是否還有未處理的房屋？\n    Yes → // 主迴圈內\n        → Decision: j < len(T)-1 AND abs(H[i]-T[j]) >= abs(H[i]-T[j+1]) ? // 是否可以往右移動加熱器指標以找到更近的加熱器？\n            Yes → j = j + 1 // 移到更靠近的加熱器\n            No  → // 已找到最近的加熱器，跳出子迴圈\n        → d = abs(H[i]-T[j]) // 當前房屋到最近加熱器的距離\n        → Decision: d > maxRadius ? // 需要調整最大半徑嗎？\n            Yes → maxRadius = d // 更新最大半徑\n            No  → // 保持現有值\n        → i = i + 1 // 進入下一個房屋\n        → // 回到主迴圈判斷\n    No  → // 所有房屋已處理，結束主迴圈\n→ End // 程式執行結束\n→ Step 8: 輸出 maxRadius // 這即為最小的標準半徑，使所有加熱器覆蓋所有房屋\n\n--- End ---"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprxbrhgpd.py\", line 31, in <module>\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmprxbrhgpd.py\", line 11, in __init__\n    self.lookup[(word[:i], word[j:])] = weight\n    ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass WordFilter:\n    def __init__(self, words):\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):\n                for j in range(L + 1):\n                    self.lookup[(word[:i], word[j:])] = weight\n\n    def f(self, prefix, suffix):\n        return self.lookup.get((prefix, suffix), -1)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析兩個 JSON 陣列，格式為 '[[\"word1\",\"word2\",...]], [\"prefix\",\"suffix\"]'\n    # 先將可能的 ', [' 換成換行符號，方便拆分\n    parts = data.replace('], [', ']\\n[').splitlines()\n\n    # 轉成真正的 Python 物件\n    words = json.loads(parts[0])\n    queries = json.loads(parts[1])\n\n    # 建立字典並執行查詢\n    wf = WordFilter(words)\n    # 只處理單一查詢（prefix, suffix）\n    pref, suff = queries\n    result = wf.f(pref, suff)\n\n    # 將結果輸出\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation. The user wants design of special dictionary for prefix and suffix search, implementing WordFilter class with constructor and method f. We need to produce virtual code steps for algorithm. Probably use Trie for prefix and suffix reversed. Or use hash map of combined prefix and suffix. But we just need pseudocode steps. Provide step-by-step algorithm. The structure uses Start, End, Decision, etc.\n\nWe'll produce steps:\n\nStart\n→ Step 1: WordFilter(words) // initialize\n→ Decision: if words empty? etc. But maybe just build data structure.\n\nImplementation: Build a trie for prefixes and suffixes? Or build a combined map: For each word, for each prefix and suffix pair store index? That could be huge. Better use Trie of reversed words and a combined structure: For each word, insert into trie where keys are pref + \"#\" + suff? But for suffix search we need reversed suffix.\n\nSimpler: Build a map from pref+suffix to index? but might be too big. But pseudocode can just say Build a combined map storing the largest index for each (prefix, suffix) pair.\n\nWe need to produce lines with arrow and explanation. Should be simple.\n\nLet's propose algorithm: For each word, for each prefix length 0..len, for each suffix length 0..len, record pair. That's O(n*l^2). Might be okay for demonstration.\n\nBetter: Build prefix trie and suffix trie, then intersect.\n\nBut given the context, we can propose building a map of combined prefix and suffix to index using a delimiter. For each word, iterate all prefixes and suffixes, create key, and set max index.\n\nThen f(pref, suff): look up key pref + \"#\" + suff, if exists return index else -1.\n\nOk.\n\nWe output pseudocode steps for constructor and f.\n\nLet's craft:\n\nStart\n→ Step 1: WordFilter(words) // 初始化 WordFilter\n    → Step 1.1: 建立空 Map prefixSuffixIndex // 用來存儲 (前綴#後綴) -> 最大索引\n    → Step 1.2: For i, word in words\n        → Step 1.2.1: prefix = \"\"\n        → Step 1.2.2: For p in 0..len(word)\n            → Step 1.2.2.1: prefix += word[p]\n            → Step 1.2.2.2: suffix = \"\"\n            → Step 1.2.2.3: For s in 0..len(word)\n                → Step 1.2.2.3.1: suffix = word[len(word)-1-s] + suffix\n                → Step 1.2.2.3.2: key = prefix + \"#\" + suffix\n                → Step 1.2.2.3.3: prefixSuffixIndex[key] = max(prefixSuffixIndex[key], i)\n→ Step 2: f(pref, suff)\n    → Decision: 若 prefixSuffixIndex 里有 key pref + \"#\" + suff?\n        Yes → Return prefixSuffixIndex[key]\n        No  → Return -1\nEnd\n\nBut need to format with arrows and spaces.\n\nWe also need to keep each line with \"虛擬碼步驟 // 解釋\". Use the arrow \"→\" and \"Decision:\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ WordFilter(words) // 建構 WordFilter，傳入單字陣列  \n    → 建立空 Map prefixSuffixIndex // 用來儲存 (前綴#後綴) → 最大索引  \n    → Decision: words 迭代？ // 檢查是否有單字可處理  \n        Yes → For i, word in words // 逐個處理每個單字  \n            → prefix ← \"\" // 初始前綴為空  \n            → Decision: 生成所有前綴？  \n                Yes → For p from 0 to len(word) // 循環每個前綴長度  \n                    → prefix ← prefix + word[p] // 擴充前綴  \n                    → suffix ← \"\" // 初始後綴為空  \n                    → Decision: 生成所有後綴？  \n                        Yes → For s from 0 to len(word) // 循環每個後綴長度  \n                            → suffix ← word[len(word)-1-s] + suffix // 從尾部往前擴充後綴  \n                            → key ← prefix + \"#\" + suffix // 組合鍵（前綴#後綴）  \n                            → Update: prefixSuffixIndex[key] ← max(prefixSuffixIndex[key], i) // 記錄最大索引  \n                    → End // 後綴循環結束  \n            → End // 前綴循環結束  \n        No  → // 若 words 為空，無需處理  \n→ End // 建構完成  \n\n→ f(pref, suff) // 查詢方法，返回符合前綴 pref 與後綴 suff 的最大索引  \n    → key ← pref + \"#\" + suff // 組合查詢鍵  \n    → Decision: prefixSuffixIndex 包含 key？ // 檢查是否存在匹配  \n        Yes → Return prefixSuffixIndex[key] // 返還最大索引  \n        No  → Return -1 // 無符合單字，回傳 -1  \nEnd // 程式執行結束"
    },
    {
      "title": "Two Sum",
      "source_file": "Leetcode/leetcode1.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,7,11,15], target = 9",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfdz_gmgh.py\", line 42, in <module>\n    nums, target = parse_input(input_data)\n                   ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfdz_gmgh.py\", line 34, in parse_input\n    nums = ast.literal_eval(part.split('=', 1)[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,4], target = 6",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvtx2vm7c.py\", line 42, in <module>\n    nums, target = parse_input(input_data)\n                   ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvtx2vm7c.py\", line 34, in parse_input\n    nums = ast.literal_eval(part.split('=', 1)[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3], target = 6",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1tw45fph.py\", line 42, in <module>\n    nums, target = parse_input(input_data)\n                   ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp1tw45fph.py\", line 34, in parse_input\n    nums = ast.literal_eval(part.split('=', 1)[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        Find two indices i, j such that nums[i] + nums[j] == target.\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        lookup = {}  # value -> index\n        for i, val in enumerate(nums):\n            complement = target - val\n            if complement in lookup:\n                return [lookup[complement], i]\n            lookup[val] = i\n        # According to the problem statement there will always be a solution,\n        # so this line should never be reached.\n        return []\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Parse input of the form:\n        'nums = [2,7,11,15], target = 9'\n    into a list of numbers and a target integer.\n    \"\"\"\n    parts = [p.strip() for p in input_str.split(',')]\n    nums = None\n    target = None\n    for part in parts:\n        if part.startswith('nums'):\n            # Use ast.literal_eval for safe evaluation of the list\n            nums = ast.literal_eval(part.split('=', 1)[1].strip())\n        elif part.startswith('target'):\n            target = int(part.split('=', 1)[1].strip())\n    return nums, target\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    input_data = sys.stdin.read().strip()\n    nums, target = parse_input(input_data)\n\n    sol = Solution()\n    result = sol.twoSum(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments. Must use Start, End, Decision. We have to produce virtual steps: input array, target, iterate, dictionary mapping value to index. We'll produce line by line. Provide explanation after //. Use arrow style. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入陣列 nums 與目標值 target // 從使用者取得輸入資料  \n→ Step 2: 初始化空字典 hashMap // 用來記錄已遇到的數值與其索引  \n→ Decision: 遍歷陣列 nums 之每個元素 nums[i] // 開始逐一檢查每個數  \n  Yes → Step 3: 計算 complement = target - nums[i] // 求出剩餘需要的數值  \n   Decision: 是否存在 complement 並且 hashMap[complement] ≠ i? // 檢查是否已經看到對應數值且不是同一個索引  \n    Yes → Step 4: 回傳索引 [hashMap[complement], i] // 找到符合條件的兩個索引，結束程式  \n    No  → Step 5: 將 nums[i] 存入 hashMap 並記錄索引 i // 更新字典以備後續比對  \n→ End // 程式執行結束（若已找到答案則提前結束）"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpn8gc_g3j.py\", line 42, in <module>\n    arguments = ast.literal_eval(second)\n                ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[],[-2],[0],[-3],[],[],[],[]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self):\n        if self.stack:\n            val = self.stack.pop()\n            if val == self.min_stack[-1]:\n                self.min_stack.pop()\n\n    def top(self):\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self):\n        return self.min_stack[-1] if self.min_stack else None\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 支援「命令陣列, 參數陣列」或「\\n分隔」兩種輸入格式\n    data = data.replace(\"\\n\", \"\").strip()\n    if '],[' in data:\n        first, second = data.split('],', 1)\n        first += ']'\n        second = '[' + second\n    else:\n        parts = data.split(',', 1)\n        first, second = parts[0], parts[1]\n\n    commands = ast.literal_eval(first)\n    arguments = ast.literal_eval(second)\n\n    obj = None\n    res = []\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"MinStack\":\n            obj = MinStack()\n            res.append(None)\n        elif cmd == \"push\":\n            obj.push(arg[0])\n            res.append(None)\n        elif cmd == \"pop\":\n            obj.pop()\n            res.append(None)\n        elif cmd == \"top\":\n            res.append(obj.top())\n        elif cmd == \"getMin\":\n            res.append(obj.getMin())\n    # 將 None 轉成 null，其他值保持原樣\n    out = '[' + ','.join('null' if v is None else str(v) for v in res) + ']'\n    print(out)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode with line by line steps. Need to design MinStack operations in constant time.\n\nWe should produce pseudocode that outlines the logic, using two stacks: one main stack, one min stack. Show initialization, push, pop, top, getMin.\n\nWe must follow output format: each line \"虛擬碼步驟 [空格] // 解釋\". Use arrow → for steps. Decision blocks with Yes→, No→.\n\nWe can write:\n\nStart // start\n→ Step 1: 定義兩個空堆疊 mainStack, minStack // 儲存元素和當前最小值\n...\n\nWe need to include operations as separate steps or methods. Let's structure:\n\nDefine class MinStack\n→ Step: 初始化\n...\nThen operations:\n\npush(val)\n→ Step: push val onto mainStack\n→ Decision: 若 minStack empty 或 val <= minStack.top?\n    Yes → push val onto minStack // 更新最小值\n    No  → No action\npop()\n→ Step: 若 mainStack 非空\n    Yes → pop mainStack; let popped = popped value\n    No → Error\n→ Decision: 若 popped == minStack.top?\n    Yes → pop minStack // 同時移除最小值\n    No → No action\ntop()\n→ Step: 返回 mainStack.top()\ngetMin()\n→ Step: 返回 minStack.top()\n\nWe need to produce these as lines. Use arrow indentation. For Decision, we need sublines.\n\nBe careful: need to output sequential steps. Maybe each operation as a block with comments.\n\nWe'll produce pseudo code lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義兩個空堆疊 mainStack, minStack // 用於儲存元素與對應的最小值\n→ Step 2: 定義方法 push(val) // 推入元素\n    → Step 2.1: mainStack.push(val) // 將值加入主堆疊\n    → Decision: 是否 minStack 為空 或 val <= minStack.top()? // 判斷是否需要更新最小值\n        Yes → minStack.push(val) // 新的最小值入堆疊\n        No  → No action // 不更新\n→ Step 3: 定義方法 pop() // 移除頂部元素\n    → Decision: mainStack 是否非空? // 確保有元素可彈\n        Yes → let removed = mainStack.pop() // 彈出主堆疊頂部\n            → Decision: removed == minStack.top()? // 檢查是否為當前最小值\n                Yes → minStack.pop() // 同時移除最小值\n                No  → No action\n        No  → Error // 空堆疊時的錯誤處理\n→ Step 4: 定義方法 top() // 取得頂部元素\n    → Return mainStack.top() // 回傳主堆疊頂部\n→ Step 5: 定義方法 getMin() // 取得最小值\n    → Return minStack.top() // 回傳最小堆疊頂部\nEnd // 程式執行結束\n\nWe should ensure each line has one arrow and comment. Need to indent substeps with arrow maybe two arrows.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: 建立空主堆疊 mainStack // 儲存所有元素\n→ Step 2: 建立空輔助堆疊 minStack // 儲存對應的最小值\n→ Step 3: 定義 push(val) 方法 // 推入元素\n    → Step 3.1: mainStack.push(val) // 主堆疊加入 val\n    → Decision: minStack 為空 或 val <= minStack.top()? // 判斷是否更新最小值\n        Yes → minStack.push(val) // 把 val 作為新的最小值\n        No  → No action // 不更新\n→ Step 4: 定義 pop() 方法 // 彈出頂部元素\n    → Decision: mainStack 非空? // 確保可以彈出\n        Yes → let popped = mainStack.pop() // 彈出主堆疊頂部\n            → Decision: popped == minStack.top()? // 檢查是否為最小值\n                Yes → minStack.pop() // 同時彈出 minStack\n                No  → No action\n        No  → Error // 空堆疊\n→ Step 5: 定義 top() 方法 // 取得頂部元素\n    → Return mainStack.top() // 返回主堆疊頂部\n→ Step 6: 定義 getMin() 方法 // 取得最小值\n    → Return minStack.top() // 返回 minStack 頂部\nEnd // 程式執行結束\n\nMake sure arrow formatting: use \"→\" for steps, and indent substeps with \"→\". For decisions, we might use \"Decision:\" with indent and Yes →, No → lines.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空主堆疊 mainStack // 儲存所有元素  \n→ Step 2: 建立空輔助堆疊 minStack // 儲存對應的最小值  \n\n→ Step 3: 定義 push(val) 方法 // 推入元素  \n    → Step 3.1: mainStack.push(val) // 主堆疊加入 val  \n    → Decision: minStack 為空 或 val <= minStack.top()? // 判斷是否更新最小值  \n        Yes → minStack.push(val) // 把 val 作為新的最小值  \n        No  → No action // 不更新  \n\n→ Step 4: 定義 pop() 方法 // 彈出頂部元素  \n    → Decision: mainStack 非空? // 確保可以彈出  \n        Yes → let popped = mainStack.pop() // 彈出主堆疊頂部  \n            → Decision: popped == minStack.top()? // 檢查是否為最小值  \n                Yes → minStack.pop() // 同時彈出 minStack  \n                No  → No action  \n        No  → Error // 空堆疊  \n\n→ Step 5: 定義 top() 方法 // 取得頂部元素  \n    → Return mainStack.top() // 返回主堆疊頂部  \n\n→ Step 6: 定義 getMin() 方法 // 取得最小值  \n    → Return minStack.top() // 返回 minStack 頂部  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find All Anagrams in a String",
      "source_file": "Leetcode/leetcode438.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"cbaebabacd\", p = \"abc\"",
          "expected_output": "[0,6]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,6]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0,6]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "s = \"abab\", p = \"ab\"",
          "expected_output": "[0,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,1,2]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0,1,2]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> list[int]:\n        ns, np = len(s), len(p)\n        if ns < np:\n            return []\n\n        # Frequency of each letter in pattern p\n        freq = [0] * 26\n        for ch in p:\n            freq[ord(ch) - 97] += 1\n\n        # Frequency of current window in s (initially first np-1 chars)\n        window = [0] * 26\n        for i in range(np - 1):\n            window[ord(s[i]) - 97] += 1\n\n        res = []\n\n        # Helper to compare two frequency arrays\n        def same() -> bool:\n            for i in range(26):\n                if window[i] != freq[i]:\n                    return False\n            return True\n\n        # Check the first window (starting at index 0)\n        if same():\n            res.append(0)\n\n        if np == ns:          # only one window possible\n            return res\n\n        # Slide the window over the rest of the string\n        for i in range(np, ns):\n            out_idx = ord(s[i - np]) - 97  # character leaving the window\n            window[out_idx] -= 1\n\n            in_idx = ord(s[i]) - 97        # character entering the window\n            window[in_idx] += 1\n\n            if same():\n                res.append(i - np + 1)\n\n        return res\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n\n    # Try to extract two quoted strings (handles format like: s = \"abc\", p = \"bca\")\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        s, p = matches[0], matches[1]\n    else:\n        # Fallback: if input is two lines or space separated values\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            s = lines[0].strip()\n            p = lines[1].strip()\n        else:\n            parts = data.split()\n            s = parts[0]\n            p = parts[1] if len(parts) > 1 else \"\"\n\n    solution = Solution()\n    result = solution.findAnagrams(s, p)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: find all anagram indices of pattern p in string s. Use sliding window, frequency array, etc. Provide each line with explanation comment. No actual code. Use arrows and decisions.\n\nLet's design algorithm:\n\nStart\n→ Input s, p\n→ Initialize result array\n→ If length of p > length of s, return empty // not needed but handle\n→ Create array freq[26] = count of chars in p\n→ Create windowCount[26] = counts for current window of size len(p) in s\n→ For i from 0 to len(p)-1: update windowCount\n→ If windowCount == freq: add 0 to result\n→ For i from len(p) to len(s)-1:\n    → Remove char s[i-len(p)] from windowCount\n    → Add char s[i] to windowCount\n    → If windowCount == freq: add i-len(p)+1 to result\n→ Return result\nEnd\n\nBut need to use Decision structure: maybe use comparison of arrays.\n\nWe'll use a counter diffCount to optimize, but for clarity we can use arrays.\n\nWe need to output step by step with explanations.\n\nLet's produce.\n\nWe need to maintain arrow formatting: `→ Step X: ...` and `Decision:` lines.\n\nWe should include `Start` and `End`.\n\nLet's craft the virtual code:\n\nStart // 程式開始執行\n→ Input s, p // 取得待搜尋字串與模式字串\n→ Initialize result = [] // 用於儲存所有符合條件的起始索引\n→ Decision: 若 len(p) > len(s)? // 若模式長度大於搜尋字串長度，無法找到任何排列\n    Yes → End // 直接結束，返回空陣列\n    No  → // 繼續執行\n→ Step 1: 建立 freq[26] = 0 // 先定義 26 個元素對應英文字母頻率\n→ Step 2: 對 p 的每個字元 c: freq[ascii(c)-'a']++ // 計算模式字串中每個字母出現次數\n→ Step 3: 建立 window[26] = 0 // 用於滑動窗口中的字母頻率\n→ Step 4: 對 s 的前 len(p)-1 個字元 c: window[ascii(c)-'a']++ // 初始化窗口，包含前 len(p)-1 個字元\n→ Decision: 若 window == freq? // 首個窗口是否已經是排列\n    Yes → Step 5: result.add(0) // 若相等，加入起始索引 0\n    No  → // 不加入\n→ Decision: 若 len(s) == len(p)? // 只剩一個窗口，已檢查完畢\n    Yes → End // 結束，返回結果\n    No  → // 繼續滑動窗口\n→ Step 6: 從 i = len(p) 到 len(s)-1 執行以下步驟 // 逐步滑動窗口\n    → Step 6a: outChar = s[i-len(p)] // 需要移除的左端字元\n    → Step 6b: window[ascii(outChar)-'a']-- // 減少窗口中對應字母數量\n    → Step 6c: inChar = s[i] // 新進入窗口的右端字元\n    → Step 6d: window[ascii(inChar)-'a']++ // 增加窗口中對應字母數量\n    → Decision: 若 window == freq? // 判斷新窗口是否為排列\n        Yes → Step 6e: result.add(i-len(p)+1) // 若相等，加入起始索引\n        No  → // 不加入\n→ End // 程式執行結束，返回 result\n\nWe need each line separate. Use arrow each line.\n\nLet's format properly.\n\nCheck: Use `Step` numbering; after each line, comment. Use arrow `→`.\n\nMake sure each line has virtual code then `// 解釋`.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Input s, p // 取得待搜尋字串與模式字串\n→ Initialize result = [] // 用於儲存所有符合條件的起始索引\n→ Decision: 若 len(p) > len(s)? // 若模式長度大於搜尋字串長度，無法找到任何排列\n    Yes → End // 直接結束，返回空陣列\n    No  → // 繼續執行\n→ Step 1: 建立 freq[26] = 0 // 先定義 26 個元素對應英文字母頻率\n→ Step 2: 對 p 的每個字元 c: freq[ascii(c)-'a']++ // 計算模式字串中每個字母出現次數\n→ Step 3: 建立 window[26] = 0 // 用於滑動窗口中的字母頻率\n→ Step 4: 對 s 的前 len(p)-1 個字元 c: window[ascii(c)-'a']++ // 初始化窗口，包含前 len(p)-1 個字元\n→ Decision: 若 window == freq? // 首個窗口是否已經是排列\n    Yes → Step 5: result.add(0) // 若相等，加入起始索引 0\n    No  → // 不加入\n→ Decision: 若 len(s) == len(p)? // 只剩一個窗口，已檢查完畢\n    Yes → End // 結束，返回結果\n    No  → // 繼續滑動窗口\n→ Step 6: 從 i = len(p) 到 len(s)-1 執行以下步驟 // 逐步滑動窗口\n    → Step 6a: outChar = s[i-len(p)] // 需要移除的左端字元\n    → Step 6b: window[ascii(outChar)-'a']-- // 減少窗口中對應字母數量\n    → Step 6c: inChar = s[i] // 新進入窗口的右端字元\n    → Step 6d: window[ascii(inChar)-'a']++ // 增加窗口中對應字母數量\n    → Decision: 若 window == freq? // 判斷新窗口是否為排列\n        Yes → Step 6e: result.add(i-len(p)+1) // 若相等，加入起始索引\n        No  → // 不加入\nEnd // 程式執行結束，返回 result"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo68qe_76.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmpo68qe_76.py\", line 25, in main\n    commands = ast.literal_eval(parts[0].strip())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"Solution\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立字典，將每個數字對應到所有出現的索引\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機挑選一個符合 target 的索引\n        return random.choice(self.num_indices[target])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入拆成兩部分：命令列表和參數列表\n    # 例子：'[\"Solution\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [3]]'\n    parts = data.split(',', 1)\n    commands = ast.literal_eval(parts[0].strip())\n    args_list = ast.literal_eval(parts[1].strip())\n\n    res = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            res.append(None)          # Constructor 的返回值為 null\n        else:\n            method = getattr(obj, cmd)\n            res.append(method(*args))\n\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode lines explaining solution. Should use Start, Decision etc. Use \"虛擬碼步驟\" with explanations. No actual code. Provide steps. Need to cover initialization: store array, maybe pre-process mapping from target to indices? But requirement: random pick, each index equal probability. Approach: In constructor, create hash map from target to list of indices. In pick, randomly choose index from list. Provide pseudocode lines.\n\nWe'll use Start, → etc.\n\nLet's produce lines:\n\nStart // start\n→ Step 1: 初始化空哈希表 target_to_indices // store mapping\n→ For each index i from 0 to len(nums)-1: // iterate array\n    → Step 2: key = nums[i]\n    → Decision: 是否已存在 key? // check map\n        Yes → Step 3: 將 i 加入 key 的索引列表\n        No  → Step 4: 建立 key 的新列表並加入 i\n→ End Constructor // 完成初始化\n\nThen pick method:\n\nStart pick(target)\n→ Decision: 是否在 target_to_indices 中有 target? // should exist\n    Yes → Step 5: list = target_to_indices[target]\n    → Step 6: n = len(list)\n    → Step 7: rand_index = 隨機整數 0 ~ n-1\n    → Step 8: 返回 list[rand_index]\n    No  → Step 9: 返回 -1 // but assumption ensures exists\nEnd pick\n\nBut also need class structure: Start, class definition? Use Virtual code. Provide line by line.\n\nAlso need include \"Solution(int[] nums) // 初始化\" etc.\n\nLet's craft.\n\nAlso need \"Decision:\" lines for loops? But loops can be represented as Step with loop structure.\n\nWe'll produce something like:\n\nStart // 程式開始\n→ Step 1: 定義類別 Solution\n    → Step 2: 成員變數: nums, target_to_indices // 存儲原始陣列與索引映射\n    → Step 3:  Constructor: Solution(nums)\n        → Step 4: 將傳入陣列複製到 成員 nums\n        → Step 5: 初始化 空哈希表 target_to_indices\n        → Decision: 遍歷 nums 中每個索引 i\n            Yes → Step 6: key = nums[i]\n            → Decision: key 是否已存在於 target_to_indices?\n                Yes → Step 7: target_to_indices[key].append(i)\n                No  → Step 8: target_to_indices[key] = [i]\n        → End // Constructor 完成\n    → Step 9: 方法 pick(target)\n        → Decision: target 是否在 target_to_indices\n            Yes → Step 10: idx_list = target_to_indices[target]\n            → Step 11: n = len(idx_list)\n            → Step 12: r = 隨機整數 0..n-1\n            → Step 13: 返回 idx_list[r]\n            No  → Step 14: 返回 -1\n        → End // pick 完成\nEnd // 程式結束\n\nBut need to follow the specified format: each line \"虛擬碼步驟 [空格] // 解釋/說明\". Use arrow \"→\". Use \"Decision:\" etc. Use Start/End.\n\nThus produce each line as separate. Provide no extra text.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: 成員變數: nums, target_to_indices // 存儲原始陣列與索引映射表  \n→ Step 3: Constructor: Solution(nums) // 初始化方法  \n  → Step 4: 複製輸入陣列至 成員變數 nums // 保留原始資料  \n  → Step 5: 初始化 空哈希表 target_to_indices // 用於存索引列表  \n  → Decision: 遍歷 nums 中每個索引 i // 逐一處理陣列元素  \n    Yes → Step 6: key = nums[i] // 取得當前元素值  \n    → Decision: key 是否已存在於 target_to_indices? // 檢查映射  \n     Yes → Step 7: target_to_indices[key].append(i) // 已有列表，加入索引  \n     No  → Step 8: target_to_indices[key] = [i] // 新建列表，加入索引  \n  → End // Constructor 完成  \n→ Step 9: 方法 pick(target) // 隨機選擇索引  \n  → Decision: target 是否在 target_to_indices? // 確認存在  \n    Yes → Step 10: idx_list = target_to_indices[target] // 取得索引列表  \n    → Step 11: n = len(idx_list) // 列表長度  \n    → Step 12: r = 隨機整數 0..n-1 // 生成隨機位置  \n    → Step 13: 返回 idx_list[r] // 回傳隨機索引  \n    No  → Step 14: 返回 -1 // 假設不存在的情況 (理論上不會發生)  \n  → End // pick 方法結束  \nEnd // 程式結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[0,1],[1,0],[2,4],[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[0, 1], [1, 0], [2, 4], [3, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # Trie node definition\n        class TrieNode:\n            __slots__ = ('children', 'idx', 'pal_suffix')\n            def __init__(self):\n                self.children = {}\n                self.idx = -1          # index of word ending at this node (-1 if none)\n                self.pal_suffix = []   # indices of words whose suffixes (from this node) are palindromes\n\n        def is_pal(s, l, r):\n            \"\"\"Check if s[l:r+1] is a palindrome.\"\"\"\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n\n        root = TrieNode()\n\n        # ---------- Build reversed Trie ----------\n        for i, w in enumerate(words):\n            node = root\n            rev = w[::-1]\n            for pos, ch in enumerate(rev):\n                # If the remaining part of the original word (from start to pos-1) is palindrome,\n                # then the current node can match this word when the suffix is used.\n                if is_pal(w, 0, len(w) - pos - 1):\n                    node.pal_suffix.append(i)\n                if ch not in node.children:\n                    node.children[ch] = TrieNode()\n                node = node.children[ch]\n            node.idx = i\n            # Entire word itself is a palindrome suffix for empty suffix\n            node.pal_suffix.append(i)\n\n        # ---------- Search for pairs ----------\n        res_set = set()\n\n        for i, w in enumerate(words):\n            node = root\n            for j, ch in enumerate(w):\n                # If current node marks the end of another word and the remaining suffix is palindrome,\n                # we found a valid pair.\n                if node.idx != -1 and node.idx != i and is_pal(w, j, len(w) - 1):\n                    res_set.add((i, node.idx))\n\n                if ch not in node.children:\n                    break\n                node = node.children[ch]\n            else:\n                # Full word matched in the Trie.\n                # All words stored in node.pal_suffix can form a pair with the current word.\n                for idx in node.pal_suffix:\n                    if idx != i:\n                        res_set.add((i, idx))\n\n        # Convert set to sorted list of lists for consistent output\n        result = [list(pair) for pair in res_set]\n        result.sort()\n        return result\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list after '=' if present\n    if '=' in data:\n        _, value = data.split('=', 1)\n        value = value.strip()\n    else:\n        value = data.strip()\n    # Safely evaluate the list\n    words = ast.literal_eval(value)\n\n    sol = Solution()\n    pairs = sol.palindromePairs(words)\n    print(pairs)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm with O(total length) runtime. We must output virtual code line by line with explanation, using arrows, Start, End, Decision, etc.\n\nGoal: Return all palindrome pairs. Known solution uses Trie with reversed words and checks for splits where left or right part palindrome.\n\nWe need to produce virtual code for algorithm. Provide step by step pseudocode. Each line with explanation comment.\n\nWe should produce lines like:\nStart\n→ Build reversed trie of words, store indices and palindrome suffix indices...\nBut need to maintain O(total length). We'll describe building trie.\n\nSimplify: Use dictionary mapping word to index. Build reverse Trie. For each word, traverse trie to match reversed prefixes, check palindrome suffixes.\n\nWe'll write pseudocode accordingly. Use arrays etc. We can also mention helper function isPalindrome(s, l, r). Keep O(total length) via each word processed linear.\n\nWe'll produce virtual code steps, each line with comment.\n\nWe need to use decision structure.\n\nWe'll produce pseudocode in steps:\n\n1. Start\n2. Step: Build a mapping from word to its index (word_to_index).\n3. Step: Build a Trie where each node has children map, end_of_word index, and list of palindrome_suffix_indices.\n4. For each word with index i, reverse word and insert into Trie:\n   - traverse characters\n   - if remaining substring is palindrome, add i to node.palindrome_suffix_indices\n   - if node marks end of a word j (j != i), add pair (i,j)\n5. For each word with index i, search in Trie:\n   - traverse characters of word\n   - when reached node:\n       if node.end_of_word != -1 and node.end_of_word != i, add pair (i, node.end_of_word)\n   - for remaining suffix, if remaining is palindrome, add pair (i, node.end_of_word)\n   - after traversal, for each idx in node.palindrome_suffix_indices, add pair (i, idx)\n6. End\n\nBut need to ensure O(total length). Use helper isPalindrome.\n\nWe'll produce pseudocode lines.\n\nWe must use arrows and decisions.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 word_to_index map // 將每個單詞與其索引對應，方便 O(1) 查詢  \n→ Step 2: 定義 TrieNode // 子節點 dict、end_of_word index、pal_suffix list (儲存以此節點結束的單詞，且此節點到單詞末尾的子串為回文)  \n→ Step 3: 建立空 Trie root // Trie 之根節點  \n→ Decision: 對每個單詞 words[i] 執行插入操作? // 遍歷所有單詞以建立 Trie  \n  Yes → Step 4: 取得 words[i] 的反向字串 rev = reverse(words[i]) // 插入時使用反向字串  \n   → Step 5: current = root // 從根節點開始  \n   → Step 6: 循環遍歷 rev 的每個字符 c, 並維持 index pos  \n    → Decision: pos 到結尾子串是回文? // 檢查目前已走到的字串後面是否為回文  \n      Yes → Step 7: current.pal_suffix.append(i) // 若是，將此單詞索引加入 pal_suffix 清單  \n      No → (do nothing)  \n    → Step 8: 若 c 不在 current.children, 則新增子節點 // 建構 Trie 形狀  \n    → Step 9: current = current.children[c] // 進一步前進  \n   → Step 10: current.end_of_word = i // 標記此節點為單詞結束位置  \n→ Decision: 對每個單詞 words[i] 執行搜尋操作? // 找出所有符合的 palindrome pair  \n  Yes → Step 11: current = root // 從根節點開始搜尋  \n   → Step 12: 循環遍歷 words[i] 的每個字符 c, 並維持 index pos  \n    → Decision: current.end_of_word ≠ -1 且 current.end_of_word ≠ i? // 目前節點已經是另一個單詞結束且不是自己  \n      Yes → Step 13: 結果.append((i, current.end_of_word)) // (i, j) 為一個 palindrome pair  \n      No → (do nothing)  \n    → Decision: pos 到結尾子串是回文? // 若剩下的子串為回文，則 (i, current.end_of_word) 亦為一對  \n      Yes → Step 14: 若 current.end_of_word ≠ -1 且 current.end_of_word ≠ i,  \n        → Step 15: 結果.append((i, current.end_of_word))  \n      No → (do nothing)  \n    → Step 16: 若 c 不在 current.children, 則終止搜尋 // 沒有進一步匹配  \n    → Step 17: current = current.children[c] // 前進  \n   → Step 18: // 搜尋結束後，處理剩餘節點的 pal_suffix 列表  \n    → Decision: current is not null?  \n      Yes → Step 19: 對於每個 idx 在 current.pal_suffix  \n        → Step 20: 結果.append((i, idx)) // 加入所有以此節點結束且剩餘子串為回文的索引  \n      No → (do nothing)  \n→ End // 程式執行結束，返回結果列表\n\n// 以上流程確保每個字串只被讀取一次，整體時間複雜度為 O(∑|words[i]|)。"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        找到陣列中所有字串的頻率。\n        若有唯一字串，回傳最大長度；否則回傳 -1。\n        \"\"\"\n        freq = Counter(strs)          # 計算每個字串出現次數\n        max_len = -1\n        for s in strs:\n            if freq[s] == 1:          # 只出現一次的字串\n                max_len = max(max_len, len(s))\n        return max_len                # 若沒有唯一字串則回傳 -1\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容，並解析成字串列表\n    data = sys.stdin.read().strip()\n    if not data:\n        print(-1)\n        sys.exit()\n    try:\n        strs = json.loads(data)\n    except json.JSONDecodeError:\n        # 若輸入不是合法 JSON，嘗試使用 eval\n        import ast\n        strs = ast.literal_eval(data)\n\n    solution = Solution()\n    result = solution.findLUSlength(strs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. We must not output actual code. Use Start, End, Decision, arrows. We need to consider algorithm: Given array of strings strs, we want longest uncommon subsequence. Known solution: If any string appears only once, answer is its length; else answer -1. Because if a string appears multiple times, no uncommon subsequence can be longer than length of any unique string. So steps: Start, compute frequency map of strings, find any string with freq=1, return its length. If none, return -1. Also we need to handle that subsequence can be the string itself because it's a subsequence of itself. So we need to check uniqueness. So pseudo-code lines:\n\nStart\n→ Step 1: Count frequencies of each string in strs\n→ Step 2: For each string in strs:\n    Decision: if frequency of this string == 1?\n        Yes → Step 3: Return length of this string // unique string gives longest uncommon subsequence\n        No  → continue\n→ Step 4: Return -1 // no unique string\n\nBut we need to be careful about order: If multiple unique strings, return the length of the longest? Wait: The known solution says if there's at least one string that is unique, the longest uncommon subsequence is that string itself. But if there are multiple unique strings, we need the longest one. However, we can simply return the maximum length among unique strings. But algorithm can check for max length. So modify:\n\nStep 2: Initialize maxLen = -1\nStep 3: For each string:\n    if freq==1: maxLen = max(maxLen, length of string)\nAfter loop:\nDecision: if maxLen == -1? Yes → Return -1 else → Return maxLen\n\nWe'll produce lines accordingly. We need arrow formatting. We'll use indentation for decisions. Also use Yes/No arrows. Provide explanation after each line.\n\nAlso we need to output no actual code, just virtual steps.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字串頻率表 freqMap // 建立每個字串出現次數的計數表  \n→ Step 2: 迭代 strs 以計算 freqMap  \n  → Decision: 是否已計算完所有字串？ // 檢查是否已累加所有字串次數  \n    Yes → Step 3: 設定 maxLen = -1 // 用於記錄唯一字串的最大長度  \n→ Step 4: 迭代 strs  \n  → Decision: freqMap[字串] == 1? // 判斷此字串是否只出現一次  \n    Yes → Step 5: maxLen = max(maxLen, len(字串)) // 更新最大長度  \n    No  → continue // 不是唯一字串，跳過  \n→ Step 6: Decision: maxLen == -1? // 是否還沒有唯一字串？  \n  Yes → Step 7: Return -1 // 沒有長度不共通的子序列  \n  No  → Step 8: Return maxLen // 回傳最大唯一字串長度  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        返回 nums 的所有排列\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])  # 完整排列加入結果\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # 交換\n                backtrack(start + 1)                         # 進行遞迴\n                nums[start], nums[i] = nums[i], nums[start]  # 回溯\n\n        backtrack(0)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，例如 \"nums = [1,2,3]\"\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n    else:\n        list_str = data\n    list_str = list_str.strip()\n    nums = ast.literal_eval(list_str)\n\n    solution = Solution()\n    permutations = solution.permute(nums)\n\n    # 直接打印，不帶空格，符合範例輸出格式\n    print(str(permutations).replace(' ', ''))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for generating all permutations of an array of distinct integers. Output must be line by line, each line: virtual code step + space + // explanation. Use arrows, Start, End, Decision:. We need to produce a structured pseudocode using the arrow style. The output should be in Traditional Chinese.\n\nWe need to produce pseudocode for backtracking algorithm.\n\nLet's outline steps:\n\nStart\n\n→ Step 1: 定義函式 permute(nums) // 主函式，接收整數陣列\n\n→ Step 2: 初始化結果 list permutations // 存放所有排列\n\n→ Step 3: 定義遞迴函式 backtrack(current, remaining) // current: 目前排列; remaining: 尚未使用的數字\n\n→ Decision: remaining 是否為空? // 判斷是否已生成完整排列\n\n    Yes → Step 4: 複製 current 並加入 permutations // 把完整排列加入結果\n\n    No  → For 每個元素 val in remaining:\n\n        → Step 5: 產生 newCurrent = current + val // 將 val 加入目前排列\n\n        → Step 6: 產生 newRemaining = remaining - val // 移除 val\n\n        → Step 7: 呼叫 backtrack(newCurrent, newRemaining) // 進一步遞迴\n\n→ Step 8: 呼叫 backtrack([], nums) // 從空排列開始\n\n→ Step 9: 回傳 permutations // 回傳所有排列\n\nEnd\n\nMake sure each line with arrow or indentation? Use arrow \"→\" for steps and \"Decision:\" with Yes →, No →.\n\nNeed to maintain indentation for decision branches.\n\nWe should produce each line. Example:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 permute(nums) // 主函式，接收整數陣列\n...\n\nBut we might want to indent lines after decision. Use spaces.\n\nWe need to ensure each line has virtual code + space + // explanation.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 permute(nums) // 主函式，接收整數陣列  \n→ Step 2: 初始化結果 list permutations // 存放所有排列  \n→ Step 3: 定義遞迴函式 backtrack(current, remaining) // current: 目前排列; remaining: 尚未使用的數字  \n→ Decision: remaining 是否為空? // 判斷是否已生成完整排列  \n  Yes → Step 4: 複製 current 並加入 permutations // 把完整排列加入結果  \n  No  → For 每個元素 val in remaining: // 遍歷未使用的數字  \n   → Step 5: 產生 newCurrent = current + val // 將 val 加入目前排列  \n   → Step 6: 產生 newRemaining = remaining - val // 移除 val  \n   → Step 7: 呼叫 backtrack(newCurrent, newRemaining) // 進一步遞迴  \n→ Step 8: 呼叫 backtrack([], nums) // 從空排列開始  \n→ Step 9: 回傳 permutations // 回傳所有排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3dds1xmy.py\", line 121, in <module>\n    main()\n  File \"/tmp/tmp3dds1xmy.py\", line 99, in main\n    commands, args = parse_input(raw_input)\n                     ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp3dds1xmy.py\", line 93, in parse_input\n    commands = json.loads(cmd_str)\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 91 (char 90)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport collections\nimport re\n\nclass RandomizedCollection:\n    \"\"\"\n    多重集合，支援 O(1) 平均時間的 insert、remove、getRandom。\n    內部使用:\n        - list `data` 存儲所有元素，允許快速取索引與隨機存取。\n        - dict `idx_map` (value -> set of indices) 追蹤每個值在 `data` 中的位置。\n    \"\"\"\n    def __init__(self):\n        self.data = []                     # 存放所有元素\n        self.idx_map = collections.defaultdict(set)  # value -> set of indices\n\n    def insert(self, val: int) -> bool:\n        \"\"\"\n        插入 val。若 val 首次出現回傳 True，否則回傳 False。\n        \"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若此集合在插入前為空，表示第一次插入\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"\n        移除一個 val（若存在）。若成功回傳 True，否則回傳 False。\n        \"\"\"\n        if not self.idx_map[val]:\n            return False\n\n        # 取得一個待移除的索引\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n\n        # 把最後一個元素放到要移除的位置\n        self.data[remove_idx] = last_val\n        # 更新 last_val 的索引集合\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n\n        # 刪除最後一個元素\n        self.data.pop()\n\n        # 若 val 沒有剩餘實例，刪除其鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"\n        隨機返回一個元素，概率與其重複數成正比。\n        \"\"\"\n        return random.choice(self.data)\n\ndef parse_input(raw: str):\n    \"\"\"\n    解析 LeetCode 風格的輸入。輸入可以是\n    1. 兩行分別為 commands 和 arguments 列表\n    2. 單行由 ', ' 分隔的兩個列表\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return [], []\n\n    # 嘗試用正則分離兩個列表\n    match = re.match(r'^\\s*\\[(.*)\\]\\s*,\\s*\\[(.*)\\]\\s*$', raw)\n    if match:\n        cmd_str = '[' + match.group(1) + ']'\n        arg_str = '[' + match.group(2) + ']'\n    else:\n        # 假設是兩行\n        parts = [line.strip() for line in raw.splitlines() if line.strip()]\n        if len(parts) >= 2:\n            cmd_str, arg_str = parts[0], parts[1]\n        else:\n            # 直接分割第一個逗號\n            idx = raw.find(',')\n            cmd_str, arg_str = raw[:idx].strip(), raw[idx+1:].strip()\n            if not cmd_str.startswith('['):\n                cmd_str = '[' + cmd_str\n            if not arg_str.startswith('['):\n                arg_str = '[' + arg_str\n            if not cmd_str.endswith(']'):\n                cmd_str += ']'\n            if not arg_str.endswith(']'):\n                arg_str += ']'\n\n    commands = json.loads(cmd_str)\n    args = json.loads(arg_str)\n    return commands, args\n\ndef main():\n    raw_input = sys.stdin.read()\n    commands, args = parse_input(raw_input)\n\n    obj = None\n    results = []\n    for cmd, arg in zip(commands, args):\n        if cmd == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            results.append(None)\n        elif cmd == \"insert\":\n            results.append(obj.insert(arg[0]))\n        elif cmd == \"remove\":\n            results.append(obj.remove(arg[0]))\n        elif cmd == \"getRandom\":\n            results.append(obj.getRandom())\n        else:\n            # 若有其他未知指令，直接忽略或拋錯\n            raise ValueError(f\"Unknown command {cmd}\")\n\n    # 輸出結果列表，使用 json.dumps 以符合題目輸出格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudocode steps for the class RandomizedCollection with methods. Each line should be step. We'll structure with Start, End. Use Decision, Yes→, No→. We'll provide explanation after each line.\n\nNeed to cover data structures: list for elements, map from value to set of indices.\n\nImplement insert, remove, getRandom. Complexity O(1).\n\nLet's produce pseudocode: \nStart // Initialize data structures\n→ Step: Initialize list elements // array to hold values\n→ Step: Initialize map valIndices // map value -> set of positions in list\nEnd\n\nFor insert:\nStart\n→ Step: If val not in valIndices? // check presence\n    Yes → Step: add val to valIndices with empty set\n    No → No action\n→ Step: Append val to elements\n→ Step: Add index (len(elements)-1) to valIndices[val]\n→ Step: Return True if this was first occurrence else False\n\nRemove:\nStart\n→ Step: If val not in valIndices or valIndices[val] empty? // no occurrence\n    No → Return False\n→ Decision: If valIndices[val] has only one index? // single occurrence\n    Yes → Step: Remove index from valIndices[val]\n        Step: Remove last element from elements? Wait if index is last. handle swap.\nBut we need to handle removal by swapping with last element for O(1). So logic: get index to remove, get last element, swap positions, update valIndices for last element, pop last, remove index from valIndices[val]. If after removal set empty, delete entry.\n\nReturn True\n\ngetRandom:\nStart\n→ Step: Generate random integer r in [0, len(elements)-1]\n→ Step: Return elements[r]\n\nAlso need explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: Initialize list `elements` // 用來儲存所有插入的數值  \n→ Step: Initialize map `valIndices` // key: 數值，value: 其在 `elements` 中所有索引的集合  \nEnd // 初始結構完成  \n\n---  \n\nInsert(val)  \nStart // 進入 insert 方法  \n→ Decision: 如果 `val` 尚未存在於 `valIndices`? // 判斷此數值是否第一次插入  \n    Yes → Step: 在 `valIndices` 新增 `val` 並以空集合做值 // 為新數值建立索引集合  \n    No → // 已存在，直接跳過  \n→ Step: 將 `val` 加入 `elements` 列表尾部  \n→ Step: 將 `elements` 的新索引（`len(elements)-1`）加入 `valIndices[val]` 集合  \n→ Step: Return `True` 若此為首次插入（即 `valIndices[val]` 先前為空），否則回傳 `False` // 表示是否為第一次出現  \nEnd // insert 方法結束  \n\n---  \n\nRemove(val)  \nStart // 進入 remove 方法  \n→ Decision: 如果 `val` 不在 `valIndices` 或其集合為空? // 無此數值可移除  \n    Yes → Step: Return `False` // 表示無法移除  \n    No → // 可以移除一個實例  \n→ Step: 從 `valIndices[val]` 取得任意索引 `idxToRemove`（通常取集合中的任一元素）  \n→ Step: 取得 `elements` 最後一個元素 `lastVal` 及其索引 `lastIdx = len(elements)-1`  \n→ Step: 把 `lastVal` 移到 `idxToRemove` 的位置  \n    → Step: `elements[idxToRemove] = lastVal`  \n→ Step: 更新 `valIndices[lastVal]`  \n    → Step: 移除 `lastIdx` 從 `valIndices[lastVal]` 集合  \n    → Step: 加入 `idxToRemove` 至 `valIndices[lastVal]` 集合  \n→ Step: 從 `elements` 刪除最後一個元素（pop）  \n→ Step: 在 `valIndices[val]` 集合中移除 `idxToRemove`  \n→ Decision: 如果 `valIndices[val]` 現在為空? // 該數值已全部移除  \n    Yes → Step: 刪除 `valIndices[val]` 這個鍵值對  \n    No → // 保留剩餘索引集合  \n→ Step: Return `True` // 成功移除一個實例  \nEnd // remove 方法結束  \n\n---  \n\nGetRandom()  \nStart // 進入 getRandom 方法  \n→ Step: 產生隨機整數 `r`，範圍為 `0` 到 `len(elements)-1`  \n→ Step: 取得 `elements[r]` 并返回 // 隨機選取元素，概率與其重複數成正比  \nEnd // getRandom 方法結束  \n\n---  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpaszlei9t.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpaszlei9t.py\", line 33, in main\n    parts = json.loads(data[0])\n            ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 75 (char 74)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (store negatives)\n        self.large = []  # min-heap\n\n    def addNum(self, num):\n        heapq.heappush(self.small, -num)\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self):\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # Support input in one or two lines\n    if len(data) == 1:\n        parts = json.loads(data[0])\n        commands, args = parts[0], parts[1]\n    else:\n        commands = json.loads(data[0])\n        args = json.loads(data[1])\n\n    res = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MedianFinder\":\n            obj = MedianFinder()\n            res.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(arg[0])\n            res.append(None)\n        elif cmd == \"findMedian\":\n            res.append(obj.findMedian())\n    # Output using JSON to match 'null' representation\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo-code for MedianFinder class, with steps, using Start, End, Decision, etc. It must be line-by-line, each line includes \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow → etc. Should not output actual code, only pseudocode.\n\nWe need to produce a structured algorithm for MedianFinder that supports addNum and findMedian. The common solution uses two heaps: max-heap for lower half, min-heap for upper half, balancing sizes. We'll produce pseudocode accordingly.\n\nWe should include class initialization, adding number with balancing, findMedian.\n\nWe need to produce line-by-line. Probably need to use \"Start\" and \"End\" for methods? For each method, we can start with Start, then steps, End. And use Decision: lines for balancing, etc.\n\nLet's produce pseudo-code:\n\nClass MedianFinder:\n- fields: maxHeap (lower), minHeap (upper)\n- methods: Constructor, addNum, findMedian\n\nLet's produce pseudo-code for each method.\n\nThe main logic:\n\nConstructor:\n- initialize maxHeap, minHeap\n\naddNum(num):\n- if maxHeap empty or num <= top(maxHeap):\n    push num into maxHeap\n- else:\n    push num into minHeap\n- balance heaps: if size(maxHeap) > size(minHeap)+1: move top of maxHeap to minHeap\n- if size(minHeap) > size(maxHeap): move top of minHeap to maxHeap\n\nfindMedian:\n- if sizes equal: return (top(maxHeap)+top(minHeap))/2.0\n- else: return top(maxHeap)\n\nNeed to include pseudocode arrows.\n\nWe'll structure as:\n\nStart // Start of addNum\n→ Decision: If maxHeap empty or num <= top(maxHeap)?\n    Yes → Step: push num into maxHeap\n    No  → Step: push num into minHeap\n→ Decision: size(maxHeap) > size(minHeap)+1?\n    Yes → Step: move top(maxHeap) to minHeap\n→ Decision: size(minHeap) > size(maxHeap)?\n    Yes → Step: move top(minHeap) to maxHeap\nEnd // End of addNum\n\nSimilarly for findMedian.\n\nLet's produce full pseudo-code lines.\n\nWe'll also include class and constructor.\n\nWe need to output each line with arrow where appropriate.\n\nLet's write:\n\nStart // Define MedianFinder class\n\n→ Step: Declare maxHeap // Max-heap for lower half\n→ Step: Declare minHeap // Min-heap for upper half\n\n→ Start // Constructor\n    → Step: Initialize maxHeap\n    → Step: Initialize minHeap\n→ End // End of Constructor\n\n→ Start // addNum method\n    → Decision: If maxHeap is empty OR num <= top(maxHeap)?\n        Yes → Step: Push num into maxHeap\n        No  → Step: Push num into minHeap\n    → Decision: size(maxHeap) > size(minHeap) + 1?\n        Yes → Step: Move top(maxHeap) to minHeap\n    → Decision: size(minHeap) > size(maxHeap)?\n        Yes → Step: Move top(minHeap) to maxHeap\n→ End // End of addNum\n\n→ Start // findMedian method\n    → Decision: size(maxHeap) == size(minHeap)?\n        Yes → Step: Return (top(maxHeap)+top(minHeap))/2.0\n        No  → Step: Return top(maxHeap)\n→ End // End of findMedian\n\nEnd // End of class\n\nBut each line must include \"虛擬碼步驟\" and explanation. So we need to keep arrow \"→\" for substeps.\n\nWe need to ensure each line is separate. Use indentation maybe.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 定義 MedianFinder 類別  \n→ Step: 宣告 maxHeap // 儲存較小一半數值的最大堆  \n→ Step: 宣告 minHeap // 儲存較大一半數值的最小堆  \n\n→ Start // 建構子  \n    → Step: 初始化 maxHeap // 先建立空的最大堆  \n    → Step: 初始化 minHeap // 再建立空的最小堆  \n→ End // 結束建構子  \n\n→ Start // addNum 方法  \n    → Decision: maxHeap 為空 或 num ≤ top(maxHeap) ? // 判斷 num 應歸入哪一堆  \n        Yes → Step: 將 num push 進 maxHeap // 小於等於中位數，放入左半堆  \n        No  → Step: 將 num push 進 minHeap // 大於中位數，放入右半堆  \n    → Decision: size(maxHeap) > size(minHeap) + 1 ? // 左堆是否過大  \n        Yes → Step: 把 maxHeap.top() pop 出來並 push 進 minHeap // 重新平衡，左堆最多比右堆大 1  \n    → Decision: size(minHeap) > size(maxHeap) ? // 右堆是否過大  \n        Yes → Step: 把 minHeap.top() pop 出來並 push 進 maxHeap // 重新平衡，左堆比右堆多 1  \n→ End // 結束 addNum 方法  \n\n→ Start // findMedian 方法  \n    → Decision: size(maxHeap) == size(minHeap) ? // 堆大小相等  \n        Yes → Step: 回傳 (top(maxHeap) + top(minHeap)) / 2.0 // 兩個中間值的平均  \n        No  → Step: 回傳 top(maxHeap) // 左堆多一個元素，直接回傳中位數  \n→ End // 結束 findMedian 方法  \n\nEnd // 結束 MedianFinder 類別。"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpt_rap6dz.py\", line 55, in parse_input\n    data = ast.literal_eval(expr)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x783dcbdfba50>\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpt_rap6dz.py\", line 74, in <module>\n    main()\n  File \"/tmp/tmpt_rap6dz.py\", line 66, in main\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpt_rap6dz.py\", line 60, in parse_input\n    intervals = ast.literal_eval(parts[0].strip())\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    intervals = [[1\n              ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmbgt1_1y.py\", line 55, in parse_input\n    data = ast.literal_eval(expr)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7fe6310f7a50>\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpmbgt1_1y.py\", line 74, in <module>\n    main()\n  File \"/tmp/tmpmbgt1_1y.py\", line 66, in main\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmbgt1_1y.py\", line 60, in parse_input\n    intervals = ast.literal_eval(parts[0].strip())\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    intervals = [[1\n              ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Insert the merged (or original) new interval\n        result.append(newInterval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(raw):\n    \"\"\"\n    Parses input that can be in one of two forms:\n    1. Two lines: first line is a list of intervals, second line is the new interval.\n    2. One line: 'intervals = [[...], ...], newInterval = [...]'\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return [], []\n\n    # Case 1: two separate lines\n    lines = [line.strip() for line in raw.splitlines() if line.strip()]\n    if len(lines) == 2:\n        intervals = ast.literal_eval(lines[0])\n        new_interval = ast.literal_eval(lines[1])\n        return intervals, new_interval\n\n    # Case 2: single line with 'intervals =' and 'newInterval ='\n    # Convert to a dict literal\n    try:\n        # Replace the assignment syntax with dictionary syntax\n        expr = raw.replace('intervals =', 'intervals:').replace('newInterval =', 'newInterval:')\n        expr = expr.replace('=', ':')\n        expr = '{' + expr + '}'\n        data = ast.literal_eval(expr)\n        return data['intervals'], data['newInterval']\n    except Exception:\n        # Fallback: try to split by comma at top level\n        parts = raw.split(',', 1)\n        intervals = ast.literal_eval(parts[0].strip())\n        new_interval = ast.literal_eval(parts[1].strip())\n        return intervals, new_interval\n\ndef main():\n    raw_input = sys.stdin.read()\n    intervals, new_interval = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.insert(intervals, new_interval)\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm of inserting interval and merging.\n\nWe will produce step-by-step pseudocode.\n\nLet's outline algorithm: iterate intervals, collect result. Cases: interval ends before new interval start -> add to result. If interval starts after new interval end -> add new interval if not added yet then add interval. Else overlap: merge start = min(interval start, new start), end = max(interval end, new end). Update new interval. After loop, if new interval not added, add it.\n\nNow produce line-by-line virtual code with arrow and decision nodes. Provide explanation after each line.\n\nWe should be careful to keep consistent format.\n\nWe start with Start. Then define result array. newStart, newEnd variables. Then for each interval in intervals: decision: if interval end < newStart: add interval; else if interval start > newEnd: add newInterval if not added; add interval; else merge.\n\nAfter loop, add newInterval if not added.\n\nEnd.\n\nWe need to use the arrow formatting: \"→ Step ...\".\n\nLet's produce.\n\nNeed to show array creation: \"→ Step 1: result ← empty list // 初始化結果容器\".\n\nAlso variables newStart, newEnd: \"→ Step 2: newStart ← newInterval[0] // 新區間起點\". Similarly.\n\nLoop: \"→ Step 3: For each interval in intervals\". Then Decision: \"→ Decision: If interval[1] < newStart?\" etc.\n\nIn pseudocode we can use Yes → and No →.\n\nAlso need to indicate adding to result: \"→ Step X: Append interval to result // 直接加入無重疊區間\".\n\nMerge: \"→ Step X: newStart ← min(newStart, interval[0]) // 合併區間起點\" and similarly for newEnd.\n\nAfter loop, check if newInterval not added: we can use a flag.\n\nSimplify: We can set a boolean added = false; set when added.\n\nAlternatively, we can just after loop if newStart <= newEnd: add newInterval.\n\nBetter to track flag: added.\n\nBut we can also add newInterval when encountering condition where interval start > newEnd and newInterval not added.\n\nWe need to include that logic.\n\nLet's produce.\n\nWe need to produce only virtual code lines, no actual code.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← [] // 初始化結果陣列  \n→ Step 2: newStart ← newInterval[0] // 取新區間的起點  \n→ Step 3: newEnd ← newInterval[1]   // 取新區間的終點  \n→ Step 4: added ← false // 標記是否已將 newInterval 加入結果  \n\n→ Step 5: For each interval in intervals // 逐一檢視已有區間  \n&nbsp;&nbsp;→ Decision: 如果 interval[1] < newStart? // 若目前區間結束於新區間起點之前  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: Append interval to result // 直接加入，無重疊  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Decision: 如果 interval[0] > newEnd? // 若目前區間開始於新區間結束之後  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Decision: 如果 added 為 false? // 是否還沒把新區間加入  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 7: Append [newStart, newEnd] to result // 加入新區間  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 8: added ← true // 標記已加入  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 9: // 已加入，直接跳過  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 10: Append interval to result // 加入原區間  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Decision: 如果 interval[0] <= newEnd AND interval[1] >= newStart? // 有重疊  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 11: newStart ← min(newStart, interval[0]) // 合併起點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 12: newEnd ← max(newEnd, interval[1])   // 合併終點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 13: // 無重疊且不符合前兩種情況，實際上不會發生  \n\n→ Step 14: Decision: 如果 added 為 false? // 循環結束後還沒加入新區間  \n&nbsp;&nbsp;&nbsp;Yes → Step 15: Append [newStart, newEnd] to result // 加入剩餘的新區間  \n&nbsp;&nbsp;&nbsp;No  → Step 16: // 已在循環中加入  \n\nEnd // 程式執行結束，返回 result"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new = []\n        i = 0\n        n = len(self.ranges)\n        # 先加入不重疊且位於新區間左側的區間\n        while i < n and self.ranges[i][1] < left:\n            new.append(self.ranges[i])\n            i += 1\n        # 合併所有與新區間重疊的區間\n        while i < n and self.ranges[i][0] <= right:\n            left = min(left, self.ranges[i][0])\n            right = max(right, self.ranges[i][1])\n            i += 1\n        new.append([left, right])\n        # 加入其後仍不重疊的區間\n        while i < n:\n            new.append(self.ranges[i])\n            i += 1\n        self.ranges = new\n\n    def queryRange(self, left: int, right: int) -> bool:\n        for l, r in self.ranges:\n            if l <= left < r:\n                return right <= r\n            if l > left:\n                break\n        return False\n\n    def removeRange(self, left: int, right: int) -> None:\n        new = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                # 完全不重疊\n                new.append([l, r])\n            else:\n                # 左側剩餘\n                if l < left:\n                    new.append([l, left])\n                # 右側剩餘\n                if r > right:\n                    new.append([right, r])\n        self.ranges = new\n\n\ndef parse_args(arg_str: str):\n    args = [int(x.strip()) for x in arg_str.strip('()').split(',')]\n    return args\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    outputs = []\n    rng = None\n    for line in data:\n        line = line.strip()\n        if not line:\n            continue\n        # 移除可能的尾隨分號\n        if line.endswith(';'):\n            line = line[:-1]\n        if line.startswith('RangeModule'):\n            # 建構子\n            rng = RangeModule()\n            outputs.append(None)\n        else:\n            # 解析方法呼叫\n            var, rest = line.split('.', 1)\n            method_part = rest\n            method_name = method_part.split('(')[0]\n            args = parse_args(method_part[method_part.index('('):])\n            if method_name == 'addRange':\n                rng.addRange(*args)\n                outputs.append(None)\n            elif method_name == 'removeRange':\n                rng.removeRange(*args)\n                outputs.append(None)\n            elif method_name == 'queryRange':\n                res = rng.queryRange(*args)\n                outputs.append(res)\n            else:\n                # 若有其他方法，忽略\n                outputs.append(None)\n    # 產生輸出字串\n    out_strs = []\n    for val in outputs:\n        if val is None:\n            out_strs.append('null')\n        else:\n            out_strs.append(str(val).lower())\n    print('[' + ', '.join(out_strs) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps line by line. The requirement: a virtual code with arrows, decisions, start, end. We need to design a data structure to support addRange, queryRange, removeRange. The typical solution is using an ordered set of intervals, like a list or BST storing non-overlapping intervals. Pseudocode can outline operations: adding merges, removing splits, query by checking intervals covering.\n\nWe need to output line by line, each line \"虛擬碼步驟 // 解釋\". Use arrows like →, Decision:.\n\nWe need to produce algorithm steps, not code. So we need to write pseudocode describing the methods. We'll do a high-level description:\n\nStart\n→ Initialize RangeModule // create empty interval list\n→ Method addRange(left,right):\n   → Find first interval that may overlap or next after left\n   → Merge overlapping intervals and insert new merged interval\n→ Method queryRange(left,right):\n   → Find interval covering left\n   → If found and its right >= right then true else false\n→ Method removeRange(left,right):\n   → Find intervals overlapping [left,right)\n   → Remove fully covered intervals\n   → Adjust partial overlaps by splitting\n\nBut we need step-by-step. We can present each method as sub-blocks with decisions.\n\nWe must not output real code. Just structure.\n\nWe'll produce like:\n\nStart // 程式開始執行\n→ RangeModule() 初始化 // 建立空間存儲區間\n→ Decision: 需要使用有序集合存儲區間? // 確定資料結構\n    Yes →  Set intervals as BST 或 有序清單 // 選擇 BST\n\nThen define methods:\n\n→ Method addRange(left,right) // 添加區間\n   → Decision: 找到第一個可能重疊的區間? // 確定插入位置\n      Yes → while intervals overlap with [left,right):\n                merge intervals -> update left/right\n                remove overlapped interval\n            EndWhile\n      No → // 沒重疊\n   → 插入合併後的新區間 // 更新集合\n\nSimilarly for queryRange, removeRange.\n\nWe need to include decisions and arrows.\n\nLet's produce about 20-30 lines.\n\nEnsure each line has \"虛擬碼步驟 // 解釋\".\n\nUse arrows: → for normal, Decision: etc.\n\nWe should maintain indentation via spaces maybe.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ RangeModule() // 建立 RangeModule 物件，初始化空區間集合\n→ Decision: 需要哪種資料結構存儲區間? // 選擇有序集合便於搜尋\n    Yes → Use BST/ordered list for intervals // 儲存為非重疊半開區間\n→ End // 初始化完成\n\nMethod addRange(left, right)\n    → Decision: 找到第一個開始點 >= left 的區間? // 定位潛在重疊\n        Yes → idx = lower_bound(left) // index of first interval that may overlap\n        No  → idx = intervals.size() // 沒找到，直接插入\n    → Set new_left = left, new_right = right\n    → While idx < intervals.size() and intervals[idx].left <= new_right:\n            // 當前區間與 [left,right) 有重疊\n            new_left = min(new_left, intervals[idx].left)\n            new_right = max(new_right, intervals[idx].right)\n            remove intervals[idx] // 刪除被合併的區間\n        EndWhile\n    → 插入區間 [new_left, new_right] // 把合併後的區間加入集合\n    → End // addRange 完成\n\nMethod queryRange(left, right)\n    → Decision: 找到 interval that covers left?\n        Yes → interval = intervals[lower_bound(left) - 1]\n        No  → return False // 左邊未被覆蓋\n    → Decision: interval.right >= right?\n        Yes → return True // 整個區間被覆蓋\n        No  → return False // 右邊不足覆蓋\n    → End\n\nMethod removeRange(left, right)\n    → Decision: 找到第一個開始點 >= left 的區間?\n        Yes → idx = lower_bound(left)\n        No  → idx = intervals.size() // 無重疊\n    → While idx < intervals.size() and intervals[idx].left < right:\n            // 當前區間與 [left,right) 有重疊\n            If intervals[idx].left < left:\n                // 左側保留\n                left_part = [intervals[idx].left, left)\n                replace intervals[idx] with left_part\n                idx = idx + 1\n            Else:\n                remove intervals[idx] // 完全被刪除\n            EndIf\n            If intervals[idx].right > right:\n                // 右側保留\n                right_part = [right, intervals[idx].right)\n                insert right_part after current\n                break\n            EndIf\n        EndWhile\n    → End // removeRange 完成\n\nEnd // 程式結束\n\nBut we need each line with a line break, arrows etc. We need to format exactly. For clarity, we may indent by spaces. Each line \"虛擬碼步驟 // 解釋\".\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ RangeModule() // 建立 RangeModule 物件，初始化空區間集合  \n→ Decision: 需要哪種資料結構存儲區間? // 選擇有序集合便於搜尋  \n    Yes → Use BST/ordered list for intervals // 儲存為非重疊半開區間  \n→ End // 初始化完成  \n\nMethod addRange(left, right) // 添加區間  \n    → Decision: 找到第一個開始點 >= left 的區間? // 定位潛在重疊  \n        Yes → idx = lower_bound(left) // index of first interval that may overlap  \n        No  → idx = intervals.size() // 沒找到，直接插入  \n    → Set new_left = left, new_right = right  \n    → While idx < intervals.size() and intervals[idx].left <= new_right:  \n            // 當前區間與 [left,right) 有重疊  \n            new_left = min(new_left, intervals[idx].left)  \n            new_right = max(new_right, intervals[idx].right)  \n            remove intervals[idx] // 刪除被合併的區間  \n        EndWhile  \n    → 插入區間 [new_left, new_right] // 把合併後的區間加入集合  \n    → End // addRange 完成  \n\nMethod queryRange(left, right) // 查詢區間是否完全被覆蓋  \n    → Decision: 找到 interval that covers left?  \n        Yes → interval = intervals[lower_bound(left) - 1] // 找到左側區間  \n        No  → return False // 左邊未被覆蓋  \n    → Decision: interval.right >= right?  \n        Yes → return True // 整個區間被覆蓋  \n        No  → return False // 右邊不足覆蓋  \n    → End  \n\nMethod removeRange(left, right) // 移除區間  \n    → Decision: 找到第一個開始點 >= left 的區間?  \n        Yes → idx = lower_bound(left)  \n        No  → idx = intervals.size() // 無重疊  \n    → While idx < intervals.size() and intervals[idx].left < right:  \n            // 當前區間與 [left,right) 有重疊  \n            If intervals[idx].left < left:  \n                // 左側保留  \n                left_part = [intervals[idx].left, left)  \n                replace intervals[idx] with left_part  \n                idx = idx + 1  \n            Else:  \n                remove intervals[idx] // 完全被刪除  \n            EndIf  \n            If intervals[idx].right > right:  \n                // 右側保留  \n                right_part = [right, intervals[idx].right)  \n                insert right_part after current  \n                break  \n            EndIf  \n        EndWhile  \n    → End // removeRange 完成  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9trc5ob2.py\", line 73, in <module>\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        \"\"\"初始化，設置容量、緩衝區、頭指標與元素數量\"\"\"\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0          # 代表前端位置\n        self.count = 0         # 目前儲存的元素數量\n\n    def insertFront(self, value: int) -> bool:\n        \"\"\"在前端插入元素，若已滿則失敗\"\"\"\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        \"\"\"在後端插入元素，若已滿則失敗\"\"\"\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        \"\"\"刪除前端元素，若為空則失敗\"\"\"\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        \"\"\"刪除後端元素，若為空則失敗\"\"\"\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        \"\"\"取得前端元素，若為空返回 -1\"\"\"\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        \"\"\"取得後端元素，若為空返回 -1\"\"\"\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        \"\"\"判斷是否為空\"\"\"\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        \"\"\"判斷是否已滿\"\"\"\n        return self.count == self.k\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入：兩行，第一行是操作名稱列表，第二行是參數列表\n    ops = json.loads(data[0])\n    params = json.loads(data[1])\n\n    result = []\n    dq = None\n    for op, arg in zip(ops, params):\n        if op == \"MyCircularDeque\":\n            dq = MyCircularDeque(arg[0])\n            result.append(None)          # constructor 返回 null\n        elif op == \"insertFront\":\n            result.append(dq.insertFront(arg[0]))\n        elif op == \"insertLast\":\n            result.append(dq.insertLast(arg[0]))\n        elif op == \"deleteFront\":\n            result.append(dq.deleteFront())\n        elif op == \"deleteLast\":\n            result.append(dq.deleteLast())\n        elif op == \"getFront\":\n            result.append(dq.getFront())\n        elif op == \"getRear\":\n            result.append(dq.getRear())\n        elif op == \"isEmpty\":\n            result.append(dq.isEmpty())\n        elif op == \"isFull\":\n            result.append(dq.isFull())\n\n    # 輸出結果，使用 json.dumps 以符合期望的格式\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MyCircularDeque class. Must be line-by-line, each line: virtual code step + space + // explanation. Use arrow notation.\n\nWe need to outline initialization, methods, logic for circular buffer with head/tail pointers. Should cover array creation, pointers, size, capacity. Provide steps for each method.\n\nWe need to produce sequential virtual code steps that represent algorithm.\n\nWe should start with Start, then define class, constructor, etc. Use arrows to show flow.\n\nLet's produce steps like:\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCircularDeque 類別 // 建立類別框架\n→ Step 2: 宣告 成員變數: arr, k, size, front, rear // 用於儲存資料與指標\n→ Step 3: 定義 Constructor(MyCircularDeque(int k)) // 初始化\n    → Assign arr = new int[k]\n    → Assign capacity = k\n    → Set size = 0\n    → Set front = 0\n    → Set rear = 0\n→ Step 4: 定義 insertFront() // 方法\n    → If isFull() → return false\n    → front = (front - 1 + capacity) % capacity // 往前移動\n    → arr[front] = value // 這裡假設傳入參數，需補充\n    → size++\n    → return true\n...\n\nBut we need to mention parameter. The description didn't include value param, but typical API includes value. We can include param value.\n\nLet's produce complete pseudo code.\n\nWe need to ensure no actual code, just pseudo. Use arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCircularDeque 類別 // 建立類別框架  \n→ Step 2: 宣告成員變數：arr, capacity, size, front, rear // 用於儲存元素與指標  \n→ Step 3: 定義 Constructor(MyCircularDeque(int k)) // 初始化資料結構  \n    → Set capacity ← k  \n    → Set arr ← new array of size k  \n    → Set size ← 0  \n    → Set front ← 0  \n    → Set rear ← 0  \n→ Step 4: 定義 isFull() // 檢查是否已滿  \n    → Return size == capacity  \n→ Step 5: 定義 isEmpty() // 檢查是否為空  \n    → Return size == 0  \n→ Step 6: 定義 insertFront(int value) // 在前端插入元素  \n    → Decision: If isFull()? // 先判斷是否已滿  \n        Yes → Return false // 無法插入  \n        No  → front ← (front - 1 + capacity) % capacity // 往前移動指標  \n              arr[front] ← value // 放入資料  \n              size ← size + 1  \n              Return true // 成功插入  \n→ Step 7: 定義 insertLast(int value) // 在後端插入元素  \n    → Decision: If isFull()?  \n        Yes → Return false  \n        No  → arr[rear] ← value // 放入資料  \n              rear ← (rear + 1) % capacity // 往後移動指標  \n              size ← size + 1  \n              Return true  \n→ Step 8: 定義 deleteFront() // 刪除前端元素  \n    → Decision: If isEmpty()?  \n        Yes → Return false // 無法刪除  \n        No  → front ← (front + 1) % capacity // 前移指標  \n              size ← size - 1  \n              Return true  \n→ Step 9: 定義 deleteLast() // 刪除後端元素  \n    → Decision: If isEmpty()?  \n        Yes → Return false  \n        No  → rear ← (rear - 1 + capacity) % capacity // 後移指標  \n              size ← size - 1  \n              Return true  \n→ Step 10: 定義 getFront() // 取得前端值  \n    → Decision: If isEmpty()?  \n        Yes → Return -1 // 空時返回 -1  \n        No  → Return arr[front]  \n→ Step 11: 定義 getRear() // 取得後端值  \n    → Decision: If isEmpty()?  \n        Yes → Return -1  \n        No  → rearIndex ← (rear - 1 + capacity) % capacity // 先算出最後一個位置  \n              Return arr[rearIndex]  \nEnd // 程式執行結束"
    },
    {
      "title": "Split Array Largest Sum",
      "source_file": "Leetcode/leetcode410.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [7,2,5,10,8], k = 2",
          "expected_output": "18",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpas3v621m.py\", line 46, in <module>\n    result = Solution().splitArray(nums, k)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpas3v621m.py\", line 16, in splitArray\n    left, right = max(nums), sum(nums)\n                             ^^^^^^^^^\nTypeError: unsupported operand type(s) for +: 'int' and 'str'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,5], k = 2",
          "expected_output": "9",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpd4pzcs9s.py\", line 46, in <module>\n    result = Solution().splitArray(nums, k)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpd4pzcs9s.py\", line 16, in splitArray\n    left, right = max(nums), sum(nums)\n                             ^^^^^^^^^\nTypeError: unsupported operand type(s) for +: 'int' and 'str'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def splitArray(self, nums, k):\n        def can_split(limit):\n            count, curr = 1, 0\n            for num in nums:\n                if curr + num > limit:\n                    count += 1\n                    curr = num\n                else:\n                    curr += num\n            return count <= k\n\n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if can_split(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，例如: \"nums = [7,2,5,10,8], k = 2\"\n    parts = [p.strip() for p in data.split(',')]\n    params = {}\n    for part in parts:\n        if '=' in part:\n            key, val = part.split('=', 1)\n            key = key.strip()\n            val = val.strip()\n            try:\n                params[key] = ast.literal_eval(val)\n            except Exception:\n                params[key] = val\n\n    nums = params.get('nums')\n    k = params.get('k')\n\n    result = Solution().splitArray(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code algorithm for the split array largest sum minimized problem. This is classic Leetcode 410 Split Array Largest Sum. Approach: binary search on answer range [max(nums), sum(nums)] and greedy check if can split into <= k subarrays with max sum <= mid.\n\nWe output step by step lines with arrows and decisions. Provide explanation per line. Should include Start, End, Decision, etc.\n\nWe need to produce lines: Start, calculate low, high, loop while low < high, compute mid, decision: if can split into <=k -> high=mid else low=mid+1. End return low.\n\nAlso include functions? Might just describe steps.\n\nLet's craft.\n\nWe should include comments in Chinese.\n\nAlso ensure arrow formatting: `→` preceding step lines. For Decision lines, `Decision:` then conditions. For Yes/No arrow.\n\nLet's produce.\n\nPotential lines:\n\nStart\n→ Step 1: 計算 low 為 nums 中最大值 // 最小可能最大子陣列和\n→ Step 2: 計算 high 為 nums 所有元素總和 // 最大可能最大子陣列和\n→ Decision: low < high? // 若範圍還可收窄\n    Yes → Step 3: 計算 mid = (low + high) / 2 // 取中間作為測試上限\n    → Step 4: 以 mid 為上限檢查能否將 nums 分成 <= k 個子陣列\n    → Decision: 若能分割成功?\n        Yes → Step 5: high = mid // 將上限降低，尋找更小最大和\n        No  → Step 6: low = mid + 1 // 上限太小，需增大下限\n    No  → Step 7: 返回 low // 範圍已收窄，低值即最小化的最大和\nEnd\n\nBut need to show loop. Could do while low < high. So we can express with Decision for loop.\n\nLet's produce full.\n\nAlso may show function Check(mid). We can include a sub-step: Step 4a etc.\n\nBetter:\n\nStart\n→ Step 1: low = max(nums) // 下界\n→ Step 2: high = sum(nums) // 上界\n→ Decision: low < high? // 是否仍有範圍可探索\n    Yes → Step 3: mid = (low + high) / 2 // 取中間\n    → Step 4: count = 1, current = 0 // 初始化計數器\n    → Decision: 對每個數字 num in nums?\n        Yes → Step 5: 如果 current + num > mid?\n            Yes → Step 6: count += 1; current = num // 開啟新子陣列\n            No  → Step 7: current += num // 加入現有子陣列\n        No  → Step 8: Decision: count <= k?\n            Yes → Step 9: high = mid // 可行，縮小上界\n            No  → Step 10: low = mid + 1 // 不可行，增大下界\n    No  → Step 11: return low // 已得到最小化最大和\nEnd\n\nBut we need to ensure indentation lines properly with arrow. The arrow before each step. For decisions we indent substeps.\n\nLet's craft final answer accordingly.\n\nWe must produce only virtual code lines, no extra text. Each line must contain \"虛擬碼步驟\" and comment. But we have to keep the lines exactly as format: `Start // ...` etc.\n\nWe must keep each line with `→` and indentation for decisions. The sample shows indentation with spaces and arrows. We'll replicate.\n\nSo produce something like:\n\n```\nStart // 程式開始執行\n→ Step 1: low = max(nums) // 計算最小可能的最大子陣列和\n→ Step 2: high = sum(nums) // 計算最大可能的最大子陣列和\n→ Decision: low < high? // 判斷是否還有範圍可以搜尋\n    Yes → Step 3: mid = (low + high) // 取中點作為測試上限\n    → Step 4: count = 1; current = 0 // 初始化分段計數與當前子陣列和\n    → Decision: 對 nums 中每個 num?\n        Yes → Step 5: If current + num > mid?\n            Yes → Step 6: count += 1; current = num // 需要新子陣列\n            No  → Step 7: current += num // 加入當前子陣列\n        No  → Step 8: Decision: count <= k?\n            Yes → Step 9: high = mid // 可行，縮小上界\n            No  → Step 10: low = mid + 1 // 不可行，增大下界\n    No  → Step 11: return low // 搜尋完成，low 為最小化最大和\nEnd // 程式執行結束\n```\n\nBut we need to ensure proper indentation and arrow usage. The sample shows indentation for substeps under decision: spaces then arrow. Eg:\n\n```\nDecision: 如果數字大於 0?\n    Yes → Step 2: 輸出 '正數'\n    No  → Decision: 如果數字等於 0?\n        Yes → Step 3: 輸出 '零'\n```\n\nThus we need to mimic: indent by 4 spaces maybe. So produce:\n\n```\nStart // 程式開始執行\n→ Step 1: low = max(nums) // ...\n→ Step 2: high = sum(nums) // ...\n→ Decision: low < high? // ...\n    Yes → Step 3: mid = (low + high) // ...\n    → Step 4: count = 1; current = 0 // ...\n    → Decision: for each num in nums?\n        Yes → Step 5: If current + num > mid?\n            Yes → Step 6: count += 1; current = num // ...\n            No  → Step 7: current += num // ...\n        No  → Step 8: Decision: count <= k?\n            Yes → Step 9: high = mid // ...\n            No  → Step 10: low = mid + 1 // ...\n    No  → Step 11: return low // ...\nEnd // 程式執行結束\n```\n\nBut we also need to show that the loop continues until low >= high. The decision for low < high handles loop. But inside, we don't need another loop step, just the decision again. But we need to show iteration repeated automatically. That is fine.\n\nHowever, we might need to include a 'Loop' concept. We could have a Decision for loop: While low < high.\n\nBetter:\n\n```\nStart // 程式開始執行\n→ Step 1: low = max(nums) // 計算最小可能最大子陣列和\n→ Step 2: high = sum(nums) // 計算最大可能最大子陣列和\n→ Decision: low < high? // 是否仍有範圍可搜尋\n    Yes → Loop:\n        → Step 3: mid = (low + high) // 取中點作為測試上限\n        → Step 4: count = 1; current = 0 // 初始化計數與當前子陣列和\n        → Decision: 遍歷 nums 中每個 num?\n            Yes → Step 5: If current + num > mid?\n                Yes → Step 6: count += 1; current = num // 開新子陣列\n                No  → Step 7: current += num // 加入現有子陣列\n            No  → Step 8: Decision: count <= k?\n                Yes → Step 9: high = mid // 可行，縮小上界\n                No  → Step 10: low = mid + 1 // 不可行，增大下界\n        → Decision: low < high? // 繼續迴圈\n            Yes → (loop again)\n            No  → Step 11: return low // 搜尋完成，low 為最小化最大和\nEnd // 程式執行結束\n```\n\nBut the format might be messy.\n\nSimplify: Use iterative structure: While low < high, inside compute mid etc.\n\nRepresent with Decision: low < high? and inside.\n\nWe can present:\n\n```\nStart // 程式開始執行\n→ Step 1: low = max(nums) // 下界\n→ Step 2: high = sum(nums) // 上界\n→ Decision: low < high? // 判斷是否還有範圍可搜尋\n    Yes → Step 3: mid = (low + high) // 取中點\n    → Step 4: count = 1; current = 0 // 初始化\n    → Decision: 逐個遍歷 nums?\n        Yes → Step 5: If current + num > mid?\n            Yes → Step 6: count += 1; current = num // 新子陣列\n            No  → Step 7: current += num // 加入\n        No  → Step 8: Decision: count <= k?\n            Yes → Step 9: high = mid // 可行\n            No  → Step 10: low = mid + 1 // 不可行\n    → Decision: low < high? // 是否需要繼續\n        Yes → (loop again)\n        No  → Step 11: return low // 結束\nEnd // 程式結束\n```\n\nBut we need \"逐行\" output. We'll produce each line as separate. Indentation should be 4 spaces for nested lines.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = max(nums) // 計算最小可能的最大子陣列和  \n→ Step 2: high = sum(nums) // 計算最大可能的最大子陣列和  \n→ Decision: low < high? // 判斷是否還有範圍可搜尋  \n Yes → Step 3: mid = (low + high) // 取中點作為測試上限  \n  → Step 4: count = 1; current = 0 // 初始化子陣列計數與目前和  \n  → Decision: 遍歷 nums 中每個 num?  \n   Yes → Step 5: If current + num > mid?  \n    Yes → Step 6: count += 1; current = num // 需要新子陣列  \n    No  → Step 7: current += num // 加入目前子陣列  \n   No → Step 8: Decision: count <= k? // 判斷是否符合分段數量限制  \n    Yes → Step 9: high = mid // 可行，縮小上界  \n    No  → Step 10: low = mid + 1 // 不可行，增大下界  \n  → Decision: low < high? // 是否需要繼續迴圈  \n   Yes → (loop again)  \n   No  → Step 11: return low // 搜尋完成，low 為最小化最大和  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphm_x0i2l.py\", line 60, in <module>\n    main()\n  File \"/tmp/tmphm_x0i2l.py\", line 43, in main\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 85 (char 84)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    \"\"\"Trie 節點，包含子節點字典和結束標記。\"\"\"\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    \"\"\"可加入單字並支援包含 '.' 的搜尋。\"\"\"\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, i: int) -> bool:\n            if i == len(word):\n                return node.is_end\n            ch = word[i]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                if ch not in node.children:\n                    return False\n                return dfs(node.children[ch], i + 1)\n        return dfs(self.root, 0)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    ops, args = json.loads(data)\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"WordDictionary\":\n            obj = WordDictionary()\n            results.append(None)\n        elif op == \"addWord\":\n            obj.addWord(arg[0])\n            results.append(None)\n        elif op == \"search\":\n            results.append(obj.search(arg[0]))\n    # 輸出結果，None 會被轉成 null，布林值保持 true/false\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrows, decisions, steps, start/end, etc. The code should describe design: using trie node, add word, search with recursion handling dot. The virtual code should be step-by-step. No actual code, just steps. Use Start, End, Decision. Use arrow → and Yes → No → etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to design WordDictionary class. Steps: Start, create root node. addWord(word): traverse or create nodes. search(word): recursion over nodes, handle dot. Provide explanation per line.\n\nLet's produce a structured approach: start, define Node class, root, addWord function, search function with helper. We'll produce lines like:\n\nStart // 程式開始執行\n→ Define class TrieNode // 建立 Trie 節點類別\n→ Define class WordDictionary // 建立 WordDictionary 類別\n→ WordDictionary() Initializes the object // 構造函式\n    → Create root TrieNode // 建立根節點\n→ void addWord(word) // 加入單字\n    → Set current = root // 從根節點開始\n    → For each character ch in word:\n        → If current.children[ch] not exist → create new TrieNode // 建立新節點\n        → current = current.children[ch] // 移動到子節點\n    → Mark current.isEnd = true // 標記單字結束\n→ bool search(word) // 查詢單字\n    → Return dfs(root, 0, word) // 呼叫遞迴搜尋\n→ bool dfs(node, index, word) // 內部遞迴函式\n    → If index == length of word:\n        → Return node.isEnd // 若到達字尾，判斷是否為有效單字\n    → ch = word[index]\n    → If ch != '.':\n        → If node.children[ch] exists:\n            → Return dfs(node.children[ch], index+1, word) // 直接搜尋\n        → Else: Return false\n    → Else (ch == '.'):\n        → For each child in node.children:\n            → If dfs(child, index+1, word) == true: Return true // 任意字母匹配\n        → Return false\nEnd // 程式執行結束\n\nWe need to use Decision lines for branching. Use arrow and Yes/No. We'll produce lines like:\n\n→ Decision: ch == '.'? // 檢查當前字元是否為點\n    Yes → ... No → ...\n\nWe need to ensure each line ends with // 解釋. Provide concise explanation.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Define class TrieNode // 建立 Trie 節點類別\n→ Define class WordDictionary // 建立 WordDictionary 類別\n→ WordDictionary() Initializes the object // 建構子：初始化字典\n    → Create root TrieNode // 建立根節點\n→ void addWord(word) // 加入單字\n    → Set current = root // 從根節點開始\n    → For each character ch in word:\n        → Decision: current.children[ch] exists? // 檢查子節點是否已存在\n            Yes → current = current.children[ch] // 移動到已存在子節點\n            No  → Create new TrieNode, assign to current.children[ch] // 新增子節點\n              → current = current.children[ch] // 移動到新建子節點\n    → Set current.isEnd = true // 標記單字結束\n→ bool search(word) // 查詢單字\n    → Return dfs(root, 0, word) // 呼叫遞迴搜尋\n→ bool dfs(node, index, word) // 內部遞迴函式\n    → Decision: index == length of word? // 判斷是否已到字串結尾\n        Yes → Return node.isEnd // 若到結尾，回傳是否為完整單字\n        No  → \n            → Set ch = word[index] // 取得當前字元\n            → Decision: ch == '.'? // 檢查字元是否為通配符\n                Yes → \n                    → For each childNode in node.children:\n                        → Decision: dfs(childNode, index+1, word) == true? // 試試每個子節點\n                            Yes → Return true // 找到匹配\n                            No  → Continue迴圈\n                    → Return false // 所有子節點均不匹配\n                No  → \n                    → Decision: node.children[ch] exists? // 檢查對應子節點\n                        Yes → Return dfs(node.children[ch], index+1, word) // 直接遞迴\n                        No  → Return false // 沒有對應子節點，搜尋失敗\nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpv2sbhl6m.py\", line 50, in <module>\n    result = solution.complexNumberMultiply(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpv2sbhl6m.py\", line 20, in complexNumberMultiply\n    a_real, a_imag = parse(a)\n                     ^^^^^^^^\n  File \"/tmp/tmpv2sbhl6m.py\", line 18, in parse\n    return int(real_part), int(imag_part)\n           ^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '1+'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        def parse(s: str):\n            # Split at the last '+' or '-' that separates real and imaginary parts\n            # The string ends with 'i', so remove it first\n            s = s.rstrip('i')\n            # Find the separator (the last '+' or '-' that is not the first character)\n            for i in range(len(s)-1, 0, -1):\n                if s[i] in '+-':\n                    real_part = s[:i]\n                    imag_part = s[i:]\n                    break\n            else:\n                # Should not happen for valid input\n                real_part, imag_part = s, '0'\n            return int(real_part), int(imag_part)\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        real_part = a_real * b_real - a_imag * b_imag\n        imag_part = a_real * b_imag + a_imag * b_real\n\n        return f\"{real_part}+{imag_part}i\"\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Try to split by comma; if only one part, split by newline\n    parts = [p.strip() for p in data.split(',')]\n    if len(parts) == 1:\n        parts = [p.strip() for p in data.splitlines()]\n\n    # Remove surrounding quotes if present\n    def clean(p: str) -> str:\n        return p.strip().strip('\"').strip(\"'\")\n\n    if len(parts) < 2:\n        sys.exit()\n\n    num1 = clean(parts[0])\n    num2 = clean(parts[1])\n\n    solution = Solution()\n    result = solution.complexNumberMultiply(num1, num2)\n\n    # Output with double quotes as shown in examples\n    print(f'\"{result}\"')",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The user wants algorithm: multiply two complex numbers given as strings in form \"a+bi\" where a and b ints in [-100,100]. Return string \"real+imaginaryi\". Need steps: parse string to get real and imaginary parts, multiply using formula (ac - bd) + (ad + bc)i, build string.\n\nWe need to produce line-by-line pseudocode with explanation. Use Start, Decision, End, arrow. Also need steps for parsing: find '+' or '-' before 'i', but string can be \"a+bi\" or \"a-bi\". Could parse by removing 'i', then split on last '+' or '-' sign between real and imaginary. But simpler: find index of 'i', remove it, then find last '+' or '-' before that index (starting from index 0). Then split.\n\nWe'll include decision to handle negative sign for imaginary part: if the second sign is '-' then imaginary negative.\n\nLet's outline steps:\n\nStart\n→ Step 1: Receive num1, num2 // input strings\n→ Step 2: ParseComplex(num1) → (r1, i1) // parse into integers\n→ Step 3: ParseComplex(num2) → (r2, i2)\n→ Step 4: realPart = r1 * r2 - i1 * i2 // multiplication formula\n→ Step 5: imagPart = r1 * i2 + i1 * r2\n→ Step 6: result = BuildString(realPart, imagPart)\n→ End\n\nNeed to detail ParseComplex: Could be a sub-step.\n\n→ SubStep: ParseComplex(str)\n   → Decision: find position of 'i' // always at end\n       Yes → remove 'i'\n   → Decision: find last '+' or '-' before 'i' that separates real and imaginary\n       Yes → split into realStr, imagStr\n   → Step: Convert realStr to integer r\n   → Step: Convert imagStr to integer i\n   → Return (r,i)\n\nWe need to produce pseudocode lines accordingly.\n\nLet's produce a full step-by-step with explanation.\n\nUse arrow and decisions. Use indentation to show substeps. We'll include decision steps: e.g., Decision: 是否包含 '-'? But simpler.\n\nLet's craft.\n\nUse '→' for next step.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: Input num1, num2 // 取得兩個複數字串\n\n→ Step 2: (r1, i1) = ParseComplex(num1) // 解析第一個複數\n→ Step 3: (r2, i2) = ParseComplex(num2) // 解析第二個複數\n\n→ Step 4: realPart = r1 * r2 - i1 * i2 // 計算實部\n→ Step 5: imagPart = r1 * i2 + i1 * r2 // 計算虛部\n\n→ Step 6: result = BuildString(realPart, imagPart) // 轉成字串\n\n→ End // 程式結束\n\nNow define ParseComplex:\n\n→ SubStep: ParseComplex(str)\n   → Step A: idxI = FindLastIndex(str, 'i') // 找到 'i' 的位置\n   → Step B: strNoI = Substring(str, 0, idxI) // 刪除 'i'\n   → Decision: 是否存在 '+' 在 strNoI 的中間位置？ // 判斷分隔符號\n       Yes → sepIdx = LastIndexOf('+', strNoI)\n       No → sepIdx = LastIndexOf('-', strNoI) // 只在負數情況\n   → Step C: realStr = Substring(strNoI, 0, sepIdx)\n   → Step D: imagStr = Substring(strNoI, sepIdx, Length(strNoI)-sepIdx)\n   → Step E: r = ConvertToInt(realStr)\n   → Step F: i = ConvertToInt(imagStr)\n   → Return (r, i)\n\nAnd BuildString:\n\n→ SubStep: BuildString(real, imag)\n   → Step G: imagSign = if imag >= 0 then '+' else '-' // 虛部符號\n   → Step H: imagAbs = Absolute(imag) // 虛部絕對值\n   → Step I: resultStr = Concatenate(ConvertToString(real), imagSign, ConvertToString(imagAbs), 'i')\n   → Return resultStr\n\nNow produce final output with each line.\n\nMake sure to keep format: \"虛擬碼步驟 [空格] // 解釋/說明\". Use arrow before step.\n\nWill list each step on its own line. Use indentation? Not required but can show. Use arrow and decision.\n\nWe should keep line per step. For substeps, we might still have lines starting with arrow. For decisions, we show 'Decision:' etc.\n\nLet's construct final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input num1, num2 // 取得兩個複數字串  \n\n→ Step 2: (r1, i1) = ParseComplex(num1) // 解析第一個複數  \n→ Step 3: (r2, i2) = ParseComplex(num2) // 解析第二個複數  \n\n→ Step 4: realPart = r1 * r2 - i1 * i2 // 計算實部  \n→ Step 5: imagPart = r1 * i2 + i1 * r2 // 計算虛部  \n\n→ Step 6: result = BuildString(realPart, imagPart) // 轉成字串  \n\n→ End // 程式結束  \n\n---  \n\nParseComplex(str) // 解析字串為 (real, imag)  \n→ Step A: idxI = FindLastIndex(str, 'i') // 找到字串最後的 'i'  \n→ Step B: strNoI = Substring(str, 0, idxI) // 刪除 'i'  \n\n→ Decision: 是否存在 '+' 作為分隔符？ // 判斷複數字串中 real 與 imag 的分隔符號  \n    Yes → sepIdx = LastIndexOf('+', strNoI) // 直接使用 '+'  \n    No  → sepIdx = LastIndexOf('-', strNoI) // 只在負數情況下使用 '-'  \n\n→ Step C: realStr = Substring(strNoI, 0, sepIdx) // 取得實部字串  \n→ Step D: imagStr = Substring(strNoI, sepIdx, Length(strNoI)-sepIdx) // 取得虛部字串  \n\n→ Step E: r = ConvertToInt(realStr) // 將實部字串轉為整數  \n→ Step F: i = ConvertToInt(imagStr) // 將虛部字串轉為整數  \n\n→ Return (r, i) // 返回解析後的 (real, imag)  \n\n---  \n\nBuildString(real, imag) // 將實部與虛部轉回複數字串  \n→ Step G: imagSign = if imag >= 0 then '+' else '-' // 決定虛部符號  \n→ Step H: imagAbs = Absolute(imag) // 虛部的絕對值  \n\n→ Step I: resultStr = Concatenate(ConvertToString(real), imagSign, ConvertToString(imagAbs), 'i') // 組合成字串  \n→ Return resultStr // 回傳最終字串"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef find_duplicate(paths):\n    \"\"\"找出所有重複檔案，回傳以內容為鍵的檔案路徑清單。\"\"\"\n    content_map = defaultdict(list)\n\n    for path in paths:\n        # 以空格分隔：第一個為目錄路徑，其餘為檔案資訊\n        parts = path.split()\n        root = parts[0]\n        for file_info in parts[1:]:\n            # 檔案資訊為 \"name(content)\"\n            name, content = file_info.split('(')\n            content = content[:-1]          # 去除右括號\n            full_path = f\"{root}/{name}\"\n            content_map[content].append(full_path)\n\n    # 只保留重複的組（長度 >= 2）\n    return [files for files in content_map.values() if len(files) > 1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 如果輸入格式為 \"paths = [...]\"，則去除前綴\n    if data.lower().startswith('paths'):\n        _, _, data = data.partition('=')\n        data = data.strip()\n\n    # 轉成 Python 物件\n    try:\n        paths = ast.literal_eval(data)\n    except Exception:\n        # 若解析失敗，直接輸出空清單\n        print([])\n        return\n\n    result = find_duplicate(paths)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode line by line with explanation. Use the specified format with Start, End, Decision. Should include steps to parse input, map content to file paths, then collect duplicates. Let's produce steps accordingly. Use arrow \"→\". Use indentation for decisions. Provide explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 hashMap[內容] = 內容對應的檔案路徑清單 // 用來存儲相同內容的檔案路徑  \n→ Step 2: 遍歷每一個輸入字串 dirInfo 在 paths 中 // 逐一處理每個目錄資訊  \n→     Step 3: 以空格分割 dirInfo 取得 tokens // tokens[0] 為目錄路徑，後面每項為檔案資訊  \n→         Step 4: 取 tokens[0] 為 directoryPath // 目錄完整路徑  \n→         Step 5: 對 tokens[1:] 做遍歷，每個 token 形如 fileName(content)  \n→             Step 6: 以 '(' 分割取得 fileName 與 contentWithParen // fileName 為檔名，contentWithParen 為內容及右括號  \n→                 Step 7: 取 contentWithParen 去除最後一個 ')' 得到 fileContent // 正確的檔案內容  \n→                 Step 8: 組合 fullPath = directoryPath + \"/\" + fileName // 完整檔案路徑  \n→                 Step 9: 若 fileContent 不在 hashMap 中，則 hashMap[fileContent] = 空清單  \n→                 Step 10: 在 hashMap[fileContent] 補充 fullPath // 把路徑加入對應內容的清單  \n→ Step 11: 建立空清單 result // 儲存所有重複檔案組  \n→ Step 12: 遍歷 hashMap 的每個 (content, pathsList)  \n→     Decision: pathsList 長度 >= 2? // 只保留重複檔案組  \n→         Yes → Step 13: 把 pathsList 加入 result // 將重複組加入最終結果  \n→         No  → 跳過 // 內容唯一，忽略  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnoxz95kr.py\", line 22, in <module>\n    main()\n  File \"/tmp/tmpnoxz95kr.py\", line 18, in main\n    results = [rand10() for _ in range(n)]\n               ^^^^^^^^\n  File \"/tmp/tmpnoxz95kr.py\", line 8, in rand10\n    num = (rand7() - 1) * 7 + rand7()  # 1~49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'rand10'?"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4260stq7.py\", line 22, in <module>\n    main()\n  File \"/tmp/tmp4260stq7.py\", line 18, in main\n    results = [rand10() for _ in range(n)]\n               ^^^^^^^^\n  File \"/tmp/tmp4260stq7.py\", line 8, in rand10\n    num = (rand7() - 1) * 7 + rand7()  # 1~49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'rand10'?"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsr3aukqo.py\", line 22, in <module>\n    main()\n  File \"/tmp/tmpsr3aukqo.py\", line 18, in main\n    results = [rand10() for _ in range(n)]\n               ^^^^^^^^\n  File \"/tmp/tmpsr3aukqo.py\", line 8, in rand10\n    num = (rand7() - 1) * 7 + rand7()  # 1~49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'rand10'?"
        }
      ],
      "generated_code": "import sys\nimport re\n\n# 假設環境已提供 rand7() API，這裡不使用任何內建隨機函式\ndef rand10():\n    while True:\n        # 兩次呼叫 rand7() 產生 1~49 的均勻分布\n        num = (rand7() - 1) * 7 + rand7()  # 1~49\n        if num <= 40:                     # 只保留前 40 個值\n            return 1 + (num - 1) % 10     # 轉換為 1~10\n\ndef main():\n    # 讀取輸入，尋找第一個整數作為 n\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    results = [rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with steps and explanation. We need to design rand10() using rand7(). Standard solution: Use two calls to generate 49 outcomes, use rejection sampling for first 40, map 1-40 to 1-10 by (n-1)%10+1. If n>40, repeat. So pseudo code: Start, generate a=rand7(), b=rand7(), compute result = (a-1)*7 + b; if result <= 40 then return (result-1)%10 +1 else repeat. Provide step by step lines with explanations.\n\nWe should include while loop or decision. Use \"Decision:\" for if condition. Also we may use \"Loop\" but not required. Use \"Step\" for generating numbers. Provide arrow and explanation.\n\nWe must adhere to format: Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow → before each step. Use Start, End.\n\nLet's produce:\n\nStart // 開始執行 rand10 函式\n→ Step 1: a ← rand7() // 產生第一個 1~7 的隨機數\n→ Step 2: b ← rand7() // 產生第二個 1~7 的隨機數\n→ Step 3: combined ← (a - 1) * 7 + b // 將兩個數轉換為 1~49 的等可能值\n→ Decision: 如果 combined ≤ 40? // 只保留前 40 個值，確保可均勻映射至 1~10\n    Yes → Step 4: result ← (combined - 1) % 10 + 1 // 轉換為 1~10\n    No  → Step 5: 返回到 Step 1 重新產生 // 超過 40 則重新試一次\nEnd // 函式結束\n\nBut we need to indicate loops. Use \"Loop\" maybe? But we can express as recursive or re-enter Step 1. We could express as \"→ Step 5: Go to Step 1\" but we need arrow. Use \"→ Step 5: Repeat Steps 1-4\" maybe.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: a ← rand7() // 取得第一個隨機數\n→ Step 2: b ← rand7() // 取得第二個隨機數\n→ Step 3: combined ← (a - 1) * 7 + b // 組合為 1~49\n→ Decision: combined ≤ 40? // 是否在可接受範圍內\n    Yes → Step 4: result ← (combined - 1) % 10 + 1 // 轉換為 1~10\n    No  → Step 5: Go back to Step 1 // 超過 40，重新開始\n→ Step 4: Return result // 返回隨機數\nEnd // 程式結束\n\nBut Step 4 is return, but we had Step 4 earlier. Need unique names. Maybe:\n\nStart\n→ Step 1: a ← rand7()\n→ Step 2: b ← rand7()\n→ Step 3: combined ← (a - 1) * 7 + b\n→ Decision: combined ≤ 40?\n    Yes → Step 4: result ← (combined - 1) % 10 + 1\n    No  → Step 5: Goto Step 1\n→ Step 4: Return result\nEnd\n\nBut Step 4 appears twice: once inside Yes branch and then again after. We can rename: Inside Yes branch we go to Step 4: result assignment. Then outside we have Step 6: Return result. Let's just keep simple: After Yes, go to Return. But need to keep unique step names. Use \"Step 4: result ← ...\", \"Step 5: Return result\".\n\nThen for No, we go back to Step 1.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: a ← rand7() // 產生第一個 1~7 的隨機數\n→ Step 2: b ← rand7() // 產生第二個 1~7 的隨機數\n→ Step 3: combined ← (a - 1) * 7 + b // 將兩個數合併為 1~49\n→ Decision: combined ≤ 40? // 檢查是否在可接受範圍\n    Yes → Step 4: result ← (combined - 1) % 10 + 1 // 轉換為 1~10\n    No  → Step 5: Goto Step 1 // 超過 40，重新產生\n→ Step 4: Return result // 返回隨機數\nEnd // 程式結束\n\nBut if No branch goes to Step 1, we skip Step 4? Shouldn't. So we may need to loop until success, then return. Let's adjust: Instead of Step 4 as return, we could place Return after the decision, but only if success. But easier: after Yes, go to Step 4: result assignment, then after that go to Step 5: Return result. So restructure:\n\nStart\n→ Step 1: a ← rand7()\n→ Step 2: b ← rand7()\n→ Step 3: combined ← (a - 1) * 7 + b\n→ Decision: combined ≤ 40?\n    Yes → Step 4: result ← (combined - 1) % 10 + 1\n    No  → Step 5: Goto Step 1\n→ Step 4: Return result\nEnd\n\nThis flows: If No, go to Step 5 which goes back to Step 1. But Step 4: Return result is after the decision block; but if No, we don't execute Step 4 because we go to Step 5. That's fine.\n\nBut we need \"Goto Step 1\" representation. We can use arrow \"→ Step 5: Go back to Step 1\". And we can use \"→ Step 5: Goto Step 1\".\n\nOk.\n\nNow produce final output with each line.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: a ← rand7() // 產生第一個 1~7 的隨機數\n→ Step 2: b ← rand7() // 產生第二個 1~7 的隨機數\n→ Step 3: combined ← (a - 1) * 7 + b // 將兩個數合併為 1~49\n→ Decision: combined ≤ 40? // 檢查是否在可接受範圍內\n    Yes → Step 4: result ← (combined - 1) % 10 + 1 // 轉換為 1~10\n    No  → Step 5: Go back to Step 1 // 超過 40，重新產生\n→ Step 4: Return result // 返回隨機數\nEnd // 程式結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef valid_square(p1, p2, p3, p4):\n    def dist_sq(a, b):\n        return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n    points = [p1, p2, p3, p4]\n    dists = []\n    for i in range(4):\n        for j in range(i + 1, 4):\n            dists.append(dist_sq(points[i], points[j]))\n    dists.sort()\n\n    # 四條邊相等且>0，兩條對角線相等且為兩倍邊長\n    return (\n        dists[0] > 0\n        and dists[0] == dists[1] == dists[2] == dists[3]\n        and dists[4] == dists[5]\n        and dists[4] == 2 * dists[0]\n    )\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 提取所有整數（負號也會被抓取）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) != 8:\n        # 如果輸入格式不符合預期，直接輸出 false\n        print(\"false\")\n        sys.exit(0)\n    p1 = [nums[0], nums[1]]\n    p2 = [nums[2], nums[3]]\n    p3 = [nums[4], nums[5]]\n    p4 = [nums[6], nums[7]]\n    result = valid_square(p1, p2, p3, p4)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line. Should handle computing distances between all pairs, check distances count. Approach: compute all pairwise squared distances. For square, there should be exactly two distinct distances: side and diagonal. The side distance occurs 4 times, diagonal occurs 2 times. All distances positive. Also need to ensure diagonal is twice side (distance squared). Steps: read 4 points, compute all 6 distances squared. Count frequencies. Check conditions. Return true/false. Use decision blocks. Use Start/End. Let's produce lines. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". We'll start with Start. We'll need variable names: points, distances, freq map. Implementation in pseudocode. Provide step for computing pairwise distances. Then decision: if freq size !=2 or counts mismatched -> return false. Then check diagonal=2*side? But square: diagonal squared = 2 * side squared. Use decision. Finally return true. Let's produce steps. Ensure no actual code. Use generic steps. Let's create:\n\nStart\n→ Step 1: 定義 points 為 p1,p2,p3,p4 // 取得輸入四點\n→ Step 2: 初始化 distances 為空列表 // 用來存所有距離平方\n→ Step 3: For each unordered pair of points (6 pairs) // 迭代所有點對\n    → Step 3a: 計算 dx = x_i - x_j, dy = y_i - y_j // 差值\n    → Step 3b: 計算 distSq = dx*dx + dy*dy // 距離平方\n    → Step 3c: Append distSq 到 distances // 收集距離\n→ Step 4: 建立距離頻率表 freq // 將距離映射到出現次數\n    → Step 4a: For each d in distances\n        → Step 4a1: Increment freq[d] // 統計次數\n→ Step 5: Decision: freq 只包含兩個不同距離且其中一個頻次為4且另一個為2? // 檢查頻率分布\n    Yes → Step 6: 取兩個距離值 sideDist, diagDist // 分別指代邊距離和對角距離\n        → Decision: diagDist == 2 * sideDist? // 確認對角距離為兩倍邊距離\n            Yes → Step 7: 返回 true // 兩條條件均滿足，為正方形\n            No  → Step 8: 返回 false // 對角距離不符，非正方形\n    No  → Step 9: 返回 false // 頻率分布不符合正方形特徵\nEnd\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Let's write them. Use arrow \"→\" for nested steps. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 points 為 p1, p2, p3, p4 // 取得輸入的四個點  \n→ Step 2: 初始化 distances 為空列表 // 用於儲存所有點對的距離平方  \n→ Step 3: 對所有 6 個不重複點對 (i < j) 進行迴圈 // 產生所有可能的距離  \n  → Step 3a: 計算 dx = points[i].x - points[j].x, dy = points[i].y - points[j].y // 求座標差  \n  → Step 3b: 計算 distSq = dx * dx + dy * dy // 計算距離平方，避免浮點誤差  \n  → Step 3c: 將 distSq 加入 distances 列表 // 收集距離資料  \n→ Step 4: 建立距離頻率表 freq 為空字典 // 用於統計各距離出現次數  \n  → Step 4a: 對每個 d in distances  \n    → Step 4a1: 若 d 在 freq 中則 freq[d] += 1 否則 freq[d] = 1 // 統計次數  \n→ Step 5: Decision: freq 只包含兩個不同距離且其中一個頻次為 4、另一個為 2? // 檢查是否符合正方形的四邊和兩對角的特徵  \n  Yes → Step 6: 取兩個距離值 sideDist, diagDist // sideDist 為邊長平方，diagDist 為對角線平方  \n    → Decision: diagDist == 2 * sideDist? // 對角距離是否等於兩倍邊距離（符合直角三角形）  \n     Yes → Step 7: 返回 true // 四條邊相等且角度為 90°，為正方形  \n     No  → Step 8: 返回 false // 對角距離不符合，非正方形  \n  No  → Step 9: 返回 false // 直至符合兩種距離分布，否則非正方形  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp30nb9y7l.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmp30nb9y7l.py\", line 20, in main\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4llq5uzq.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmp4llq5uzq.py\", line 20, in main\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef main():\n    # 讀取整行輸入，例如\n    # price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\n    line = sys.stdin.read().strip()\n    if not line:\n        return\n\n    # 把每個變數拆開並用 literal_eval 解析為 Python 物件\n    parts = [p.strip() for p in line.split(',')]\n    data = {}\n    for part in parts:\n        if not part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        data[key] = ast.literal_eval(val)\n\n    price = data.get('price', [])\n    special = data.get('special', [])\n    needs = data.get('needs', [])\n\n    n = len(price)\n    memo = {}\n\n    def dfs(curr_needs):\n        key = tuple(curr_needs)\n        if key in memo:\n            return memo[key]\n        # 基本情況：直接按單價購買\n        res = sum(curr_needs[i] * price[i] for i in range(n))\n        # 嘗試每個優惠\n        for offer in special:\n            temp = []\n            for i in range(n):\n                if offer[i] > curr_needs[i]:\n                    break\n                temp.append(curr_needs[i] - offer[i])\n            else:\n                res = min(res, offer[-1] + dfs(temp))\n        memo[key] = res\n        return res\n\n    result = dfs(needs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step algorithm in virtual code for this problem. We need to output each line with the virtual code step followed by // explanation.\n\nWe should give a solution approach: use DFS with memoization / DP on needs state. Since n <=? Not specified but typical LeetCode 638: n <= 6. We can encode needs as key.\n\nSteps: Start, preprocess specials to remove useless ones that cost more or equal to buying items individually, recursively compute min cost.\n\nWe need to provide each line. We'll structure:\n\nStart\n→ Step 1: 定義函式 dfs(currentNeeds) // 递归求最小价格\n→ Step 2: 轉成 key string // 用於 memo\n→ Step 3: 若 key 已存在則回傳 memo[key] // memoization\n→ Step 4: 計算不使用任何優惠的成本 // 基础价格\n→ Step 5: 對於每個優惠 offer:\n    → Decision: 是否可以套用 offer? // 檢查每個 item 不超過需求\n        Yes → Step 6: 生成 newNeeds = currentNeeds - offerItems\n            → Step 7: cost = offerPrice + dfs(newNeeds)\n            → Step 8: 更新 minCost\n→ Step 9: memo[key] = minCost\n→ Step 10: 回傳 minCost\n→ Step 11: 主流程：調用 dfs(needs)\nEnd\n\nAlso include preprocessing: filter offers that are not beneficial.\n\nAdd steps for filtering:\n\n→ Step A: 定義 function filterOffers() // 去除不划算的优惠\n→ Step B: For each offer:\n    → Decision: 計算單品購買成本 vs offerPrice\n        Yes → 把 offer 加入 filtered list\nAfter filtering, set specials to filtered.\n\nAdd input reading steps.\n\nGiven that we only produce virtual code, we need to include the preprocessing and the recursion.\n\nWe need to maintain that each line includes \"虛擬碼步驟 [space] // 解釋\".\n\nLet's create a list of lines.\n\nWe need to include Start, End.\n\nWe'll produce the steps in a logical order.\n\nWe can number steps or not; just use arrow.\n\nMake sure to use \"→\" for steps, \"Decision:\" lines.\n\nLet's draft.\n\nStart // 程式開始\n\n→ Step 1: 讀取 price array, needs array, specials array // 將輸入資料載入\n\n→ Step 2: 呼叫 filterOffers() // 先過濾不划算的優惠\n\n→ Step 3: 定義 memo 為字典 // 用於儲存已計算狀態\n\n→ Step 4: 定義函式 dfs(currentNeeds) // 主要遞迴求解\n\nInside dfs, we list steps.\n\nBut each step should be a separate line. So we can indent with tabs? But we need just lines; we can just keep arrow lines; but we need to indicate scope? It's okay.\n\nWe can just continue arrows.\n\nBetter to indent by adding spaces: \"    →\" but arrow lines still start with \"→\". It's fine.\n\nWe'll show:\n\n→ Decision: 是否已經在 memo? // 檢查是否已計算過\n\n    Yes → Step: return memo[key] // 回傳已存值\n\n    No  → continue\n\n→ Step: 轉成 key string from currentNeeds // 用於 memo\n\nBut we need to handle order: first generate key, then check memo.\n\nWe need to produce each step as separate line. Might be easier to list sequentially.\n\nLet's produce:\n\nStart\n\n→ Step 1: 讀取 price, needs, specials // 輸入\n\n→ Step 2: specials ← filterOffers(price, specials) // 去除無效優惠\n\n→ Step 3: memo ← 空字典 // 用於 memo\n\n→ Step 4: 定義函式 dfs(needs) // 递归求解\n\nInside:\n\n→ Step 4.1: key ← join(needs) // 轉成字串作 key\n\n→ Decision: key 是否在 memo? // 檢查已計算\n\n    Yes → Step: return memo[key] // 回傳\n\n    No  → 進行計算\n\n→ Step 4.2: minCost ← sum(needs[i] * price[i]) // 不使用優惠的成本\n\n→ Decision: 對每個 offer in specials? // 遍歷優惠\n\n    → Step 4.3: 可用 ← True\n\n    → Decision: 對每項 i: if needs[i] < offer[i] then 可用 ← False // 不足以使用\n\n        Yes/No accordingly\n\n    → If 可用:\n\n        → Step 4.4: newNeeds ← needs - offerItems\n\n        → Step 4.5: cost ← offerPrice + dfs(newNeeds) // 递归\n\n        → Step 4.6: minCost ← min(minCost, cost) // 更新\n\n→ Step 4.7: memo[key] ← minCost // 記錄\n\n→ Step 4.8: return minCost // 回傳\n\n→ Step 5: result ← dfs(needs) // 求解\n\n→ Step 6: 輸出 result // 回傳答案\n\nEnd\n\nAlso include filterOffers function steps.\n\nLet's add earlier:\n\n→ Step 2.1: 定義函式 filterOffers(price, specials) // 过滤无效优惠\n\n→ Step 2.1.1: filtered ← 空列表\n\n→ Decision: 對每個 offer in specials?\n\n    → Step 2.1.2: 直接成本 ← sum(offer[i] * price[i]) // 单品成本\n\n    → Decision: 直接成本 <= offerPrice? // 如果优惠更贵或等价\n\n        Yes → continue // 跳过此优惠\n\n        No  → 添加到 filtered\n\n→ Step 2.1.3: return filtered\n\nThus incorporate.\n\nMake sure each line uses \"→\" and includes explanation after //.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 price, needs, specials // 載入所有輸入資料  \n→ Step 2: specials ← filterOffers(price, specials) // 去除無法帶來折扣的優惠  \n→ Step 3: memo ← 空字典 // 用於快取已計算的需求狀態  \n\n// ------------------------------------------------------------  \n→ Step 4: 定義函式 filterOffers(price, specials) // 過濾不划算的優惠  \n→ Step 4.1: filtered ← 空列表 // 用來儲存有效優惠  \n→ Decision: 對每個 offer in specials? // 遍歷所有優惠  \n    → Step 4.2: directCost ← sum(offer[i] * price[i] for i in 0..n-1) // 計算按單品購買的成本  \n    → Decision: directCost <= offer[n]? // 若單品成本不高於優惠價格  \n        Yes → continue // 此優惠不划算，跳過  \n        No → filtered ← filtered + [offer] // 儲存有效優惠  \n→ Step 4.3: return filtered // 回傳有效優惠列表  \n\n// ------------------------------------------------------------  \n→ Step 5: 定義函式 dfs(currentNeeds) // 主要遞迴求解最小價格  \n→ Step 5.1: key ← join(currentNeeds, \",\") // 將需求轉成字串做為 memo key  \n→ Decision: key 在 memo? // 檢查是否已計算過  \n    Yes → return memo[key] // 若已計算則直接回傳結果  \n    No  → 進行後續計算  \n→ Step 5.2: minCost ← sum(currentNeeds[i] * price[i] for i in 0..n-1) // 不使用任何優惠的成本  \n→ Decision: 對每個 offer in specials? // 嘗試使用每個優惠  \n    → Step 5.3: 可用 ← True  \n    → Decision: 對每個 i in 0..n-1? // 檢查需求是否足夠使用此優惠  \n        If currentNeeds[i] < offer[i] → 可用 ← False // 不足以使用  \n    → Decision: 可用?  \n        Yes →  \n            → Step 5.4: newNeeds ← currentNeeds - offer[0..n-1] // 需求減去優惠份量  \n            → Step 5.5: cost ← offer[n] + dfs(newNeeds) // 以此優惠為基礎的總成本  \n            → Step 5.6: minCost ← min(minCost, cost) // 更新最小成本  \n        No → continue // 該優惠不可用，跳過  \n→ Step 5.7: memo[key] ← minCost // 記錄此需求狀態的最小成本  \n→ Step 5.8: return minCost // 回傳計算結果  \n\n// ------------------------------------------------------------  \n→ Step 6: result ← dfs(needs) // 從原始需求開始遞迴  \n→ Step 7: 輸出 result // 回傳最小購買價格  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Break II",
      "source_file": "Leetcode/leetcode140.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']",
          "expected_output": "['cats and dog','cat sand dog']",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsanddog\",\"catsanddog\"]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: \"['cats and dog','cat sand dog']\"\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']",
          "expected_output": "['pine apple pen apple','pineapple pen apple','pine applepen apple']",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"pineapplepenapple\",\"pineapplepenapple\",\"pineapplepenapple\"]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: \"['pine apple pen apple','pineapple pen apple','pine applepen apple']\"\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        word_set = set(wordDict)\n        memo = {}\n\n        def backtrack(start):\n            if start in memo:\n                return memo[start]\n            if start == len(s):\n                return [\"\"]\n            res = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in word_set:\n                    for sub in backtrack(end):\n                        if sub:\n                            res.append(word + \" \" + sub)\n                        else:\n                            res.append(word)\n            memo[start] = res\n            return res\n\n        return backtrack(0)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Find position of 'wordDict'\n    idx = data.find('wordDict')\n    if idx == -1:\n        # Fallback: try eval\n        local = {}\n        exec(data, {}, local)\n        s = local.get('s', '')\n        wordDict = local.get('wordDict', [])\n    else:\n        # Extract s part\n        s_part = data[:idx].strip()\n        s_value = s_part.split('=', 1)[1].strip()\n        # Remove surrounding quotes\n        if s_value.startswith((\"'\", '\"')) and s_value.endswith((\"'\", '\"')):\n            s = s_value[1:-1]\n        else:\n            s = s_value\n        # Extract dict part\n        dict_part = data[idx:].split('=', 1)[1].strip()\n        wordDict = ast.literal_eval(dict_part)\n    sol = Solution()\n    res = sol.wordBreak(s, wordDict)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for word break problem: all possible sentences. Likely recursion with memoization (DP). Virtual code lines.\n\nWe need to produce step-by-step explanation.\n\nWe should design algorithm: DFS with memo.\n\nPseudo:\n\nStart\n→ Initialize memo dictionary\n→ Define function dfs(start):\n→   If start == len(s): return ['']\n→   If start in memo: return memo[start]\n→   results = []\n→   For end from start+1 to len(s):\n→     word = s[start:end]\n→     If word in wordDict:\n→        subSentences = dfs(end)\n→        For sub in subSentences:\n→           sentence = word + ('' if sub=='' else ' '+sub)\n→           results.append(sentence)\n→   memo[start] = results\n→   Return results\n→ Call dfs(0) -> allSentences\n→ Return allSentences\nEnd\n\nBut need to output each line as virtual code with explanation.\n\nWe must include arrows. Use \"Start\" and \"End\".\n\nAlso include decisions: if word in dict, etc.\n\nUse \"Decision:\" for condition checks.\n\nAlso need \"Yes →\" \"No →\" for loops? Usually for if else. For for loops, just show iteration steps.\n\nLet's craft.\n\nLine 1: Start // 程式開始\n\nLine 2: → Step 1: Define memo = {} // 用於記錄已計算過的子問題結果\n\nLine 3: → Step 2: Define function dfs(start) // 計算從起始位置到結尾的所有句子\n\nLine 4: → Decision: If start == len(s) // 檢查是否已到字串結束\n\nLine 5:    Yes → Step 3: Return [''] // 回傳空句子作為基底\n\nLine 6:    No → Decision: If start in memo // 檢查是否已計算過此起始位置\n\nLine 7:        Yes → Step 4: Return memo[start] // 直接回傳已存的結果\n\nLine 8:        No → Step 5: Initialize results = [] // 用於收集所有可能的句子\n\nLine 9: → Step 6: For end from start+1 to len(s) // 遍歷所有可能的切分點\n\nLine 10: → Step 7: word = s[start:end] // 取子字串\n\nLine 11: → Decision: If word in wordDict // 判斷子字串是否為字典單詞\n\nLine 12:          Yes → Step 8: subSentences = dfs(end) // 取得從 end 到結尾的所有句子\n\nLine 13:          Yes → Step 9: For each sub in subSentences // 組合前後句子\n\nLine 14:          Yes → Step 10: sentence = word + ('' if sub == '' else ' ' + sub) // 加上空格分隔\n\nLine 15:          Yes → Step 11: results.append(sentence) // 將完整句子加入結果\n\nLine 16: → Decision: End of loop // (implicitly)\n\nLine 17: → Step 12: memo[start] = results // 记忆化存储\n\nLine 18: → Step 13: Return results // 返回從 start 開始的所有句子\n\nLine 19: → Step 14: Call dfs(0) -> allSentences // 計算整個字串的所有句子\n\nLine 20: → Step 15: Return allSentences // 輸出結果\n\nLine 21: End // 程式結束\n\nCheck formatting: Each line has \"虛擬碼步驟\" + space + \"// 解釋\". Ensure arrow \"→\" included. For Decision lines: \"Decision:\" then spaces then \"If ...\".\n\nAlso indentation? Use indent for nested decisions? Not necessary but can show via indent.\n\nBetter to show:\n\nStart // 程式開始執行\n→ Step 1: memo = {} // 用於記錄已計算過的子問題結果\n→ Step 2: Define function dfs(start) // 計算從起始位置到結尾的所有句子\n    → Decision: 如果 start == len(s)? // 檢查是否已到字串結束\n        Yes → Step 3: Return [''] // 回傳空句子作為基底\n        No → Decision: 如果 start 在 memo? // 檢查是否已計算過此起始位置\n            Yes → Step 4: Return memo[start] // 直接回傳已存的結果\n            No  → Step 5: results = [] // 用於收集所有可能的句子\n                → Step 6: For end from start+1 to len(s) // 遍歷所有可能的切分點\n                    → Step 7: word = s[start:end] // 取子字串\n                    → Decision: 如果 word 在 wordDict? // 判斷子字串是否為字典單詞\n                        Yes → Step 8: subSentences = dfs(end) // 取得從 end 到結尾的所有句子\n                        Yes → Step 9: For sub in subSentences // 組合前後句子\n                            → Step 10: sentence = word + ('' if sub == '' else ' ' + sub) // 加上空格分隔\n                            → Step 11: results.append(sentence) // 將完整句子加入結果\n                → Step 12: memo[start] = results // 记忆化存储\n                → Step 13: Return results // 返回從 start 開始的所有句子\n→ Step 14: allSentences = dfs(0) // 計算整個字串的所有句子\n→ Step 15: Return allSentences // 輸出結果\nEnd // 程式結束\n\nBut each line must have single statement, not nested block? The format example shows nested decisions with indentation but still each line. So we can use indentation for clarity.\n\nNeed to ensure each line ends with comment.\n\nLet's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: memo = {} // 用於記錄已計算過的子問題結果\n→ Step 2: Define function dfs(start) // 計算從起始位置到結尾的所有句子\n    → Decision: 如果 start == len(s)? // 檢查是否已到字串結束\n        Yes → Step 3: Return [''] // 回傳空句子作為基底\n        No  → Decision: 如果 start 在 memo? // 檢查是否已計算過此起始位置\n            Yes → Step 4: Return memo[start] // 直接回傳已存的結果\n            No  → Step 5: results = [] // 用於收集所有可能的句子\n                → Step 6: For end from start+1 to len(s) // 遍歷所有可能的切分點\n                    → Step 7: word = s[start:end] // 取子字串\n                    → Decision: 如果 word 在 wordDict? // 判斷子字串是否為字典單詞\n                        Yes → Step 8: subSentences = dfs(end) // 取得從 end 到結尾的所有句子\n                        Yes → Step 9: For sub in subSentences // 組合前後句子\n                            → Step 10: sentence = word + ('' if sub == '' else ' ' + sub) // 加上空格分隔\n                            → Step 11: results.append(sentence) // 將完整句子加入結果\n                → Step 12: memo[start] = results // 記憶化存儲\n                → Step 13: Return results // 返回從 start 開始的所有句子\n→ Step 14: allSentences = dfs(0) // 計算整個字串的所有句子\n→ Step 15: Return allSentences // 輸出結果\nEnd // 程式結束\n```"
    },
    {
      "title": "Subarray Sum Equals K",
      "source_file": "Leetcode/leetcode560.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[1,1,1], k = 2",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpligzkn3l.py\", line 23, in <module>\n    nums = ast.literal_eval(nums_part.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "[1,2,3], k = 3",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp43v0mxuw.py\", line 23, in <module>\n    nums = ast.literal_eval(nums_part.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subarraySum(self, nums, k):\n        count = 0\n        prefix_sum = 0\n        sum_map = {0: 1}\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum - k in sum_map:\n                count += sum_map[prefix_sum - k]\n            sum_map[prefix_sum] = sum_map.get(prefix_sum, 0) + 1\n        return count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Expected format: \"[1,1,1], k = 2\"\n    nums_part, k_part = data.split(',', 1)\n    nums = ast.literal_eval(nums_part.strip())\n    k = int(k_part.split('=', 1)[1].strip())\n\n    solution = Solution()\n    result = solution.subarraySum(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line for the problem: count subarrays with sum k. Classic prefix sum + hash map. We'll output step lines with comments. Use structure Start, End, Decision: with arrows. Provide each line with a comment. Use virtual code lines. For example:\n\nStart\n→ Step 1: 初始化哈希表 countMap，將0映射到1 // 前缀和为0出现一次\n→ Step 2: 初始化变量 currentSum=0, result=0 // 用于遍历数组\n→ Step 3: 对 nums 中的每个 num 进行循环 // 遍历数组\n    → Step 4: currentSum += num // 更新前缀和\n    → Decision: 如果 countMap 含有 key currentSum - k? // 检查是否存在前缀和满足条件\n        Yes → Step 5: result += countMap[currentSum - k] // 增加匹配子数组计数\n        No  → // 什么也不做\n    → Step 6: countMap[currentSum] = countMap.get(currentSum, 0) + 1 // 更新前缀和计数\n→ Step 7: 返回 result // 最终结果\nEnd\n\nBut we need to adhere to the format: each line must be \"虛擬碼步驟 // 解釋/說明\". Indentation might use spaces. The decision block needs Yes → and No → lines. So we produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 hash map countMap，並把 0 映射為 1 // 前缀和为0出现一次，表示空前缀\n→ Step 2: 初始化变量 currentSum = 0, result = 0 // 用于累加前缀和和计数\n→ Step 3: 遍历 nums 中的每个元素 num // 逐个处理数组元素\n    → Step 4: currentSum += num // 更新当前前缀和\n    → Decision: 是否存在 countMap 中的 key (currentSum - k)? // 检查是否已有满足条件的前缀\n        Yes → Step 5: result += countMap[currentSum - k] // 计数匹配子数组\n        No  → // 不做任何操作\n    → Step 6: countMap[currentSum] = countMap.get(currentSum, 0) + 1 // 记录当前前缀和出现次数\n→ Step 7: 返回 result // 输出总计数\nEnd // 程式結束\n\nWe should maintain the exact format. Also we might need indentation for steps inside loop. Use arrow arrow '→'. Each line includes arrow '→' except Start and End. For nested steps, maybe indent with spaces.\n\nAlso \"Step 3: 遍历\" but inside we need to indent steps. We can indent by 4 spaces or maybe two spaces. Example: \"    → Step 4...\" etc. The requirement: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\". So yes.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 hash map countMap，並把 0 映射為 1 // 前缀和為 0 出現一次，表示空前缀  \n→ Step 2: 初始化變數 currentSum = 0, result = 0 // 用於累加前缀和與計數  \n→ Step 3: 遍歷 nums 中的每個元素 num // 逐個處理數組元素  \n    → Step 4: currentSum += num // 更新當前前缀和  \n    → Decision: 是否存在 countMap 中的 key (currentSum - k)? // 檢查是否已有滿足條件的前缀  \n        Yes → Step 5: result += countMap[currentSum - k] // 加上匹配子陣列的數量  \n        No  → // 無匹配，保持結果不變  \n    → Step 6: countMap[currentSum] = countMap.get(currentSum, 0) + 1 // 記錄當前前缀和出現次數  \n→ Step 7: 返回 result // 輸出子陣列總數  \nEnd // 程式結束執行"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        # Build graph: email -> set of connected emails\n        graph = defaultdict(set)\n        email_to_name = {}\n\n        for account in accounts:\n            name = account[0]\n            first_email = account[1]\n            for email in account[1:]:\n                email_to_name[email] = name\n                graph[first_email].add(email)\n                graph[email].add(first_email)\n\n        visited = set()\n        merged = []\n\n        for email in graph:\n            if email in visited:\n                continue\n            # DFS to collect all emails in the same component\n            stack = [email]\n            component = []\n            while stack:\n                cur = stack.pop()\n                if cur in visited:\n                    continue\n                visited.add(cur)\n                component.append(cur)\n                for nei in graph[cur]:\n                    if nei not in visited:\n                        stack.append(nei)\n            component.sort()\n            merged.append([email_to_name[component[0]]] + component)\n\n        return merged\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse input; support format \"accounts = [...]\", or just \" [...]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        accounts = ast.literal_eval(expr.strip())\n    else:\n        accounts = ast.literal_eval(data)\n    sol = Solution()\n    result = sol.accountsMerge(accounts)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for merging accounts. We must output line by line, each line: \"虛擬碼步驟 // 解釋\". Use arrows. Steps include building graph, DFS/BFS, mapping emails to names, collecting components, sorting emails, building result.\n\nWe need to produce algorithm pseudocode.\n\nLet's outline:\n\nStart\n→ Step 1: Initialize empty graph adjacency dict email->set of emails\n→ Step 2: For each account in accounts:\n    → Step 2a: name = account[0]\n    → Step 2b: first_email = account[1]\n    → Step 2c: For each email in account[1:]:\n        → Step 2c1: Add name mapping email->name\n        → Step 2c2: Add edges between first_email and email in graph\n→ Step 3: Initialize visited set\n→ Step 4: Initialize result list\n→ Step 5: For each email in graph keys:\n    → Decision: 如果 email not in visited?\n        Yes → Step 5a: Initialize stack with email\n              → Step 5b: Initialize component list\n              → Step 5c: While stack not empty:\n                    → Step 5c1: Pop cur\n                    → Decision: 如果 cur in visited?\n                        No → Step 5c2: Add cur to visited\n                             → Step 5c3: Add cur to component\n                             → Step 5c4: For each neighbor in graph[cur]:\n                                     → Step 5c4a: If neighbor not in visited:\n                                         → Step 5c4b: Push neighbor onto stack\n              → Step 5d: Sort component\n              → Step 5e: name = name_map[component[0]]\n              → Step 5f: Append [name] + component to result\n        No → Step 5g: Continue\n→ End // 完成\n\nWe should include arrow style. Ensure each line has \"虛擬碼步驟\" maybe \"Start\" etc.\n\nNeed to use decision with Yes →, No → etc.\n\nLet's produce lines.\n\nRemember to use \"→\" for steps, \"Decision:\" lines. The format: each line is \"虛擬碼步驟 // 解釋\".\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化空的鄰接表 graph(email→集合) // 建立圖結構以表示相同帳號的電子郵件\n→ Step 2: 初始化空字典 email_to_name // 以電子郵件對應姓名\n→ Step 3: 循環遍歷每個帳號 accounts[i]\n    → Step 3a: name = accounts[i][0] // 取得帳號擁有者姓名\n    → Step 3b: first_email = accounts[i][1] // 取第一個電子郵件作為連結基準\n    → Step 3c: 循環遍歷該帳號的每個電子郵件 email in accounts[i][1:]\n        → Step 3c1: email_to_name[email] = name // 記錄姓名對應\n        → Step 3c2: 若 first_email 不在 graph 中則 graph[first_email] = 空集合 // 初始化\n        → Step 3c3: 若 email 不在 graph 中則 graph[email] = 空集合 // 初始化\n        → Step 3c4: graph[first_email].add(email) // 建立雙向邊\n        → Step 3c5: graph[email].add(first_email)\n→ Step 4: visited = 空集合 // 記錄已訪問的電子郵件\n→ Step 5: result = 空列表 // 儲存最終合併後的帳號\n→ Step 6: 循環遍歷 graph 的每個鍵 email\n    → Decision: 如果 email 未在 visited? // 判斷是否已處理過\n        Yes → Step 6a: stack = [email] // 使用堆疊進行 DFS\n        → Step 6b: component = 空列表 // 儲存當前連通分量的電子郵件\n        → Step 6c: 循環 while stack 不空\n            → Step 6c1: cur = stack.pop() // 取出頂部節點\n            → Decision: 如果 cur 未在 visited? \n                No → Continue // 已處理，跳過\n                Yes → Step 6c2: visited.add(cur) // 標記已訪問\n                    → Step 6c3: component.append(cur) // 加入組件\n                    → Step 6c4: 循環遍歷 graph[cur] 的每個 neighbor\n                        → Decision: 如果 neighbor 未在 visited? \n                            Yes → stack.append(neighbor) // 往堆疊加入未訪問的鄰居\n                            No → Pass\n        → Step 6d: component.sort() // 對電子郵件進行升序排序\n        → Step 6e: name = email_to_name[component[0]] // 取得此組件對應的姓名\n        → Step 6f: result.append([name] + component) // 形成合併後的帳號並加入結果\n        → Step 6g: Continue // 進入下一個 email\n        No → Step 6h: Pass // 已處理，跳過\n→ End // 程式執行結束\n\nNeed to ensure arrows correct. The Decision line: \"Decision: ...?\" and then indentation.\n\nWe also need to keep each line separate with // explanation.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空的鄰接表 graph(email → 集合) // 建立圖結構以表示相同帳號的電子郵件  \n→ Step 2: 初始化空字典 email_to_name // 以電子郵件對應姓名  \n→ Step 3: 循環遍歷每個帳號 accounts[i]  \n → Step 3a: name = accounts[i][0] // 取得帳號擁有者姓名  \n → Step 3b: first_email = accounts[i][1] // 取第一個電子郵件作為連結基準  \n → Step 3c: 循環遍歷該帳號的每個電子郵件 email in accounts[i][1:]  \n  → Step 3c1: email_to_name[email] = name // 記錄姓名對應  \n  → Step 3c2: 若 first_email 不在 graph 中則 graph[first_email] = 空集合 // 初始化  \n  → Step 3c3: 若 email 不在 graph 中則 graph[email] = 空集合 // 初始化  \n  → Step 3c4: graph[first_email].add(email) // 建立雙向邊  \n  → Step 3c5: graph[email].add(first_email) // 建立雙向邊  \n→ Step 4: visited = 空集合 // 記錄已訪問的電子郵件  \n→ Step 5: result = 空列表 // 儲存最終合併後的帳號  \n→ Step 6: 循環遍歷 graph 的每個鍵 email  \n → Decision: 如果 email 未在 visited?  \n  Yes → Step 6a: stack = [email] // 使用堆疊進行 DFS  \n   → Step 6b: component = 空列表 // 儲存當前連通分量的電子郵件  \n   → Step 6c: 循環 while stack 不空  \n    → Step 6c1: cur = stack.pop() // 取出頂部節點  \n    → Decision: 如果 cur 未在 visited?  \n     No → Continue // 已處理，跳過  \n     Yes → Step 6c2: visited.add(cur) // 標記已訪問  \n      → Step 6c3: component.append(cur) // 加入組件  \n      → Step 6c4: 循環遍歷 graph[cur] 的每個 neighbor  \n       → Decision: 如果 neighbor 未在 visited?  \n        Yes → stack.append(neighbor) // 加入未訪問的鄰居  \n        No → Pass  \n     → Step 6d: component.sort() // 對電子郵件進行升序排序  \n    → Step 6e: name = email_to_name[component[0]] // 取得此組件對應的姓名  \n    → Step 6f: result.append([name] + component) // 形成合併後的帳號並加入結果  \n    → Step 6g: Continue // 進入下一個 email  \n  No → Step 6h: Pass // 已處理，跳過  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcobasxb2.py\", line 49, in <module>\n    params = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7e601acf7950>"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjvi1ue7s.py\", line 49, in <module>\n    params = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7646564f7950>"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        layer = {beginWord: 0}          # word -> distance from beginWord\n        parents = defaultdict(list)    # word -> list of predecessors\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Convert the input into a dictionary using eval-safe approach\n    data = \"{\" + data.replace('=', ':') + \"}\"\n    params = ast.literal_eval(data)\n    beginWord = params['beginWord']\n    endWord = params['endWord']\n    wordList = params['wordList']\n\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find all shortest transformation sequences (Word Ladder II). Use BFS to build graph layers, then DFS/backtrack.\n\nWe need line-by-line virtual code, with arrows and decisions. Provide explanation after each line. Use Start, End.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize queue with beginWord and path list containing beginWord // starting BFS\n→ Step 2: Initialize visited set to {beginWord} // track visited words\n→ Step 3: Initialize results list // store sequences\n→ Decision: While queue not empty? // BFS loop\n    → Step 4: For each word in current level: pop word, path\n    → Step 5: If word == endWord? // reached end\n        Yes → Step 6: Add path to results // store sequence\n        No  → Decision: For each possible single-letter change generate nextWord\n            → Step 7: If nextWord in wordList and not visited\n                → Step 8: Append nextWord to path, enqueue new path\n                → Step 9: Mark nextWord as visited in this level\n    → Step 10: After processing level, if results not empty, break // only shortest\n→ Decision: If results empty? // no sequence\n    Yes → Step 11: Return empty list\n    No  → Step 12: Return results\n\nBut we need also to handle visited per level and build adjacency for backtracking? Actually typical approach: BFS to build predecessors mapping, then DFS backtrack. Could also do BFS then backtrack. But to produce all shortest sequences we need to record paths. For virtual code we can keep simple BFS with path per queue. That's okay though less efficient but conceptual.\n\nLet's produce step lines with arrow indentation.\n\nWe should incorporate arrow decisions indent.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Set wordSet = set(wordList) // 將字典轉為集合便於查找\n→ Step 2: If endWord not in wordSet → End // 若終點不在字典則無解\n→ Step 3: Initialize queue with tuple(beginWord, [beginWord]) // BFS起始節點與路徑\n→ Step 4: Initialize visited = {beginWord} // 已訪問過的單詞\n→ Step 5: Initialize results = [] // 存放所有最短路徑\n→ Decision: While queue not empty? // 開始 BFS\n    → Step 6: levelSize = len(queue) // 本層節點數\n    → Decision: levelSize > 0? // 仍有節點\n        → Step 7: Initialize localVisited = set() // 本層新增訪問的單詞\n        → For i in range(levelSize): // 逐個處理本層節點\n            → Step 8: word, path = queue.popleft() // 取出節點與其路徑\n            → Decision: word == endWord? // 到達終點\n                → Yes → Step 9: results.append(path) // 保存一條完整路徑\n                → No → Step 10: For each position j in word: // 嘗試改變一個字\n                    → Step 11: For each char c in 'a'..'z': // 生成候選\n                        → Step 12: If c == word[j] continue // 跳過相同字\n                        → Step 13: nextWord = word[:j] + c + word[j+1:] // 新單詞\n                        → Decision: nextWord in wordSet and nextWord not in visited? // 合格且未訪問\n                            → Yes → Step 14: queue.append((nextWord, path + [nextWord])) // 入隊\n                            → Step 15: localVisited.add(nextWord) // 標記本層已訪問\n        → Step 16: visited.update(localVisited) // 更新全局已訪問\n    → Decision: results not empty? // 已找到最短路徑\n        → Yes → Break // 結束 BFS\n→ Decision: results empty? // 沒有路徑\n    → Yes → Step 17: Return [] // 空列表\n    → No  → Step 18: Return results // 回傳所有最短路徑\nEnd // 程式執行結束\n\nWe need ensure syntax correct: arrow lines with indentation and spaces.\n\nWe'll produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set wordSet = set(wordList) // 把字典轉成集合方便查找  \n→ Step 2: If endWord not in wordSet → End // 終點不在字典則直接結束  \n→ Step 3: Initialize queue with tuple(beginWord, [beginWord]) // BFS起始節點與路徑  \n→ Step 4: Initialize visited = {beginWord} // 已訪問過的單詞  \n→ Step 5: Initialize results = [] // 存放所有最短路徑  \n→ Decision: While queue not empty? // 開始 BFS  \n    → Step 6: levelSize = len(queue) // 本層節點數  \n    → Decision: levelSize > 0? // 仍有節點  \n        → Step 7: Initialize localVisited = set() // 本層新增訪問的單詞  \n        → For i in range(levelSize): // 逐個處理本層節點  \n            → Step 8: word, path = queue.popleft() // 取出節點與其路徑  \n            → Decision: word == endWord? // 到達終點  \n                → Yes → Step 9: results.append(path) // 保存一條完整路徑  \n                → No → Step 10: For each position j in word: // 嘗試改變一個字  \n                    → Step 11: For each char c in 'a'..'z': // 生成候選  \n                        → Step 12: If c == word[j] continue // 跳過相同字  \n                        → Step 13: nextWord = word[:j] + c + word[j+1:] // 新單詞  \n                        → Decision: nextWord in wordSet and nextWord not in visited? // 合格且未訪問  \n                            → Yes → Step 14: queue.append((nextWord, path + [nextWord])) // 入隊  \n                            → Step 15: localVisited.add(nextWord) // 標記本層已訪問  \n        → Step 16: visited.update(localVisited) // 更新全局已訪問  \n    → Decision: results not empty? // 已找到最短路徑  \n        → Yes → Break // 結束 BFS  \n→ Decision: results empty? // 沒有路徑  \n    → Yes → Step 17: Return [] // 空列表  \n    → No  → Step 18: Return results // 回傳所有最短路徑  \nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar I",
      "source_file": "Leetcode/leetcode729.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp87b21u5a.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmp87b21u5a.py\", line 23, in main\n    commands = ast.literal_eval(left.strip())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MyCalendar\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyCalendar:\n    def __init__(self):\n        self.bookings = []\n\n    def book(self, start, end):\n        for s, e in self.bookings:\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Separate the two lists that are comma‑separated\n    left, right = data.split(',', 1)\n    commands = ast.literal_eval(left.strip())\n    args = ast.literal_eval(right.strip())\n\n    instance = None\n    results = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MyCalendar\":\n            instance = MyCalendar()\n            results.append(None)\n        elif cmd == \"book\":\n            start, end = arg\n            res = instance.book(start, end)\n            results.append(res)\n        else:\n            # Unsupported command, append None\n            results.append(None)\n\n    # Convert the result list to JSON format (null, true, false)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode with each line and explanation. The task: implement MyCalendar with add event without double booking. Use typical approach: maintain a sorted list or tree of intervals. Each book checks if any overlap. Since need virtual code. Provide steps: Start, store intervals list, book function.\n\nLet's produce a linear algorithm: On book, iterate over stored intervals, check if overlap: if start < existing.end && end > existing.start then overlap. If no overlap, insert into list preserving order. Return true/false.\n\nAlso constructor: initialize list.\n\nWe'll produce pseudocode:\n\nStart\n→ Step 1: Define MyCalendar class // 定義 MyCalendar 類別\n→ Step 2: In constructor, create empty list intervals // 建立空的事件清單\n→ Step 3: Define book(startTime, endTime) // 定義預訂方法\n→ Decision: For each interval in intervals? // 檢查是否有衝突\n    Yes → Condition: startTime < interval.end && endTime > interval.start? // 檢查重疊\n        Yes → Step 4: Return false // 衝突，預訂失敗\n        No  → Continue // 無衝突，檢查下一個\n→ Step 5: Insert [startTime, endTime] into intervals maintaining sorted order // 加入新事件\n→ Step 6: Return true // 成功預訂\n\nEnd\n\nBut need each line \"虛擬碼步驟\" plus comment. Provide arrow for flow.\n\nLet's produce more detailed steps. Possibly include Decision: check overlap.\n\nOk produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Define MyCalendar class // 定義 MyCalendar 類別\n→ Step 1: Constructor MyCalendar() // 初始化構造函數\n    → intervals ← empty list // 建立一個空的事件清單\n→ Step 2: Method book(startTime, endTime) // 定義預訂方法\n    → Decision: 事件是否與已存在的事件重疊? // 檢查是否有衝突\n        → For each [s, e] in intervals // 遍歷所有已預訂的事件\n            → Condition: startTime < e AND endTime > s? // 判斷兩個半開區間是否有交集\n                Yes → Step 3: Return false // 發現衝突，拒絕預訂\n                No  → Continue // 無衝突，檢查下一個事件\n        → Step 4: Insert [startTime, endTime] into intervals sorted by startTime // 將新事件加入清單，保持升序\n        → Step 5: Return true // 預訂成功\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,1,0,0,6,0,1,1]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 1, 0, 0, 6, 0, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # 建立映射表，把黑名單中小於白名單範圍的數字映射到大於等於 n - len(blacklist) 的白名單數字\n        self.mapping = {}\n        self.size = n - len(blacklist)          # 可被選擇的白名單數量\n        black = set(blacklist)\n        last = n - 1                            # 從最高的數字開始向下找可用白名單\n        for b in blacklist:\n            if b < self.size:                  # 只需處理小於白名單範圍的黑名單元素\n                while last in black:           # 找到不在黑名單中的最大數字\n                    last -= 1\n                self.mapping[b] = last          # 建立映射\n                last -= 1\n\n    def pick(self):\n        # 隨機選取一個白名單索引，必要時使用映射轉為合法數字\n        index = random.randint(0, self.size - 1)\n        return self.mapping.get(index, index)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])          # 例如 [\"Solution\", \"pick\", \"pick\"]\n    args = json.loads(data[1])          # 例如 [[7, [2,3,5]], [], []]\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            result.append(None)          # 造物時返回 null\n        else:\n            # 其他方法直接呼叫\n            method = getattr(obj, op)\n            result.append(method(*arg))\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce pseudo-code steps. It's design algorithm: use mapping of blacklisted numbers >= white range to whitelisted numbers < n-m. Implementation: In constructor, store mapping and whitelist set. pick: choose random k from 0 to whitelistSize-1; if k in mapping, return mapping[k]; else return k.\n\nAlso handle random calls minimal: only one random per pick.\n\nNeed pseudo-code with Start, Decision, etc. Provide each step line with explanation. Use \"→\" arrow. Provide structure.\n\nLet's write:\n\nStart\n→ Step 1: Compute m = blacklist.size\n→ Step 2: Compute w = n - m // number of allowed numbers\n→ Step 3: Initialize set allowedSet with numbers 0..n-1 excluding blacklist\n→ Step 4: Create mapping dict\n→ Decision: If blacklist contains number < w?\nYes → For each b in blacklist where b < w:\n→ Step 5: Find smallest number a in allowedSet > w-1\n→ Step 6: mapping[b] = a\n→ Step 7: Remove a from allowedSet\nNo → End mapping\n\nBut maybe simpler: Build set of blacklisted numbers; iterate over range w-1 downto 0? Actually algorithm: Let set black = set(blacklist). Let next = n-1; for each b in blacklist where b < w: while next in black: next--; mapping[b] = next; next--; That ensures mapping.\n\nSo pseudo-code lines accordingly.\n\nThen pick() method:\n\nStart\n→ Step 1: r = randomInt(0, w-1) // one random call\n→ Decision: If r in mapping?\nYes → Step 2: return mapping[r]\nNo  → Step 3: return r\nEnd\n\nProvide explanation each line. Also include End.\n\nWe need to output lines step-by-step for constructor and pick separately? Provide all steps sequentially? Could treat each method separately with separate Start/End. Provide explanation. Should produce pseudo-code for whole class.\n\nThus:\n\nStart // 初始化\n→ Step 1: m ← blacklist.size\n→ Step 2: w ← n - m // 可選範圍長度\n→ Step 3: blackSet ← Set(blacklist)\n→ Step 4: mapping ← EmptyMap\n→ Decision: 是否存在 b < w?\n    Yes → For each b in blacklist where b < w:\n            → Step 5: next ← n - 1\n            → Decision: while next ∈ blackSet?\n                Yes → next ← next - 1\n                No  → Exit loop\n            → Step 6: mapping[b] ← next\n            → Step 7: next ← next - 1\n    No → End\nEnd // 構造完成\n\nStart // pick\n→ Step 1: r ← randomInt(0, w-1)\n→ Decision: r ∈ mapping?\n    Yes → Step 2: return mapping[r]\n    No  → Step 3: return r\nEnd // pick 結束\n\nAdd comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 初始化 Solution 物件  \n→ Step 1: m ← blacklist.size // 黑名單長度  \n→ Step 2: w ← n - m // 可被選的整數總數  \n→ Step 3: blackSet ← Set(blacklist) // 黑名單集合，方便 O(1) 查詢  \n→ Step 4: mapping ← EmptyMap // 用於把小於 w 的黑名單映射到大於等於 w 的白名單  \n→ Decision: 是否存在黑名單元素小於 w？  \n    Yes → For each b in blacklist where b < w:  \n        → Step 5: next ← n - 1 // 從 n-1 開始往回找可用數字  \n        → Decision: next ∈ blackSet?  \n            Yes → next ← next - 1 // 若 next 仍在黑名單，繼續遞減  \n            No  → Exit loop // 找到可用的白名單數字  \n        → Step 6: mapping[b] ← next // 將黑名單數字映射到可用白名單  \n        → Step 7: next ← next - 1 // 供下一個映射使用  \n    No  → End // 無需映射  \nEnd // 結束建構  \n\nStart // pick() 方法  \n→ Step 1: r ← randomInt(0, w-1) // 只呼叫一次隨機數生成器  \n→ Decision: r ∈ mapping?  \n    Yes → Step 2: return mapping[r] // 取映射後的白名單數字  \n    No  → Step 3: return r // 直接返回原本的白名單數字  \nEnd // pick() 結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,3,null,5]'\nGot (Norm):      '[None,3,None,5]'\n--- (Raw) ---\nRaw Expected: '[null, null, 3, null, 5]'\nRaw Got:      '[None, 3, None, 5]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Node:\n    \"\"\"Trie node storing cumulative sum of all keys that pass through it.\"\"\"\n    __slots__ = (\"children\", \"sum\")\n    def __init__(self):\n        self.children = {}  # mapping from char to Node\n        self.sum = 0        # cumulative sum of values for keys with this prefix\n\nclass MapSum:\n    \"\"\"Data structure that maps string keys to integers and can return\n    the sum of all values whose keys share a common prefix.\"\"\"\n    def __init__(self):\n        self.root = Node()   # root of the Trie\n        self.val_map = {}    # maps key -> current value\n\n    def insert(self, key: str, val: int) -> None:\n        \"\"\"Insert or update the key with the given value.\"\"\"\n        delta = val - self.val_map.get(key, 0)  # change to propagate\n        self.val_map[key] = val\n        node = self.root\n        node.sum += delta\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = Node()\n            node = node.children[ch]\n            node.sum += delta\n\n    def sum(self, prefix: str) -> int:\n        \"\"\"Return the sum of all values of keys that start with the prefix.\"\"\"\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef main() -> None:\n    # Read entire input, strip newlines, and parse as a tuple of (ops, args)\n    raw = sys.stdin.read().replace(\"\\n\", \"\")\n    if not raw:\n        return\n    ops, args = ast.literal_eval(raw)\n\n    ms = MapSum()\n    outputs = []\n    for op, arg in zip(ops, args):\n        if op == \"insert\":\n            ms.insert(arg[0], arg[1])\n            outputs.append(None)\n        elif op == \"sum\":\n            outputs.append(ms.sum(arg[0]))\n        else:\n            # unknown operation, skip or raise error\n            pass\n\n    # Print the result list in Python syntax (None represents null)\n    print(outputs)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for MapSum class with methods. Use trie concept. Provide line-by-line pseudocode with explanations. Use arrows and decision. Include Start and End. Let's produce structure.\n\nStart\n→ Step: Define Node struct with children map and int sum\n→ Step: Define MapSum class with root node and key-value map\n→ Step: MapSum() constructor // initialize root\n→ Step: insert(key, val)\n    → Compute delta = val - existingVal(key)\n    → Update key-value map\n    → For each char in key: traverse or create child, add delta to node.sum\n→ Step: sum(prefix)\n    → Traverse prefix; if missing return 0\n    → Return node.sum\n\nNeed to include decisions and arrows. Provide each step as separate line.\n\nLet's produce.\n\nUse \"→ Step X:\" format.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Node 結構，內含子節點字典 children 與累計值 sum // 建立 Trie 節點  \n→ Step 2: 定義 MapSum 類別，內含 root 節點與 key-value 映射 map // MapSum 主體  \n→ Step 3: MapSum() // 建構子  \n    → Step 3.1: 初始化 root 為新 Node // 起始 Trie 節點  \n→ Step 4: insert(String key, int val) // 插入或覆蓋鍵值  \n    → Step 4.1: 計算 delta = val - map.getOrDefault(key, 0) // 差值，考慮覆蓋  \n    → Step 4.2: map.put(key, val) // 更新映射表  \n    → Step 4.3: node = root // 從根節點開始  \n    → Step 4.4: Decision: 迴圈遍歷 key 中每個字元 ch? // 逐字串走 Trie  \n        Yes → Step 4.4.1: 如果 node.children 沒有 ch 則創建新 Node // 建立節點  \n        Yes → Step 4.4.2: node = node.children.get(ch) // 移動到子節點  \n        Yes → Step 4.4.3: node.sum += delta // 更新累計值  \n        No  → // 迴圈結束  \n→ Step 5: sum(String prefix) // 取得前綴總和  \n    → Step 5.1: node = root // 從根節點開始  \n    → Step 5.2: Decision: 迴圈遍歷 prefix 中每個字元 ch? // 逐字搜尋  \n        Yes → Step 5.2.1: 如果 node.children 不含 ch 則 Return 0 // 前綴不存在  \n        Yes → Step 5.2.2: node = node.children.get(ch) // 移動到子節點  \n        No  → // 迴圈結束  \n    → Step 5.3: Return node.sum // 前綴對應節點的累計值  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.8766485676986168,-0.10955056877561899],[0.9016160348946639,-0.3592259370662682],[-0.5814400244895415,-0.2704560007137729]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.8766485676986168, -0.10955056877561899], [0.9016160348946639, -0.3592259370662682], [-0.5814400244895415, -0.2704560007137729]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    lines = data.splitlines()\n    # 確保至少有兩行輸入\n    if len(lines) < 2:\n        sys.exit(0)\n\n    commands = json.loads(lines[0].strip())\n    args = json.loads(lines[1].strip())\n\n    result = []\n    obj = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            obj = Solution(*arg)\n            result.append(None)\n        elif cmd == \"randPoint\":\n            if obj is not None:\n                result.append(obj.randPoint())\n            else:\n                result.append(None)\n        else:\n            result.append(None)\n\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with comments. The requirement: we should not output actual code, just structure. Need to produce virtual code using arrows. For example, Start, etc. Provide the steps to implement class Solution with constructor and randPoint. Steps: store radius, center coordinates. In randPoint, generate random angle between 0 and 2π, random radius sqrt(rand)*R. Then compute x,y. Return array.\n\nWe need to show \"虛擬碼步驟\" then space then comment. So each line: e.g., \"Start // 程式開始執行\". Then lines with arrows: \"→ Step 1: 儲存 radius, x_center, y_center // ...\"\n\nWe need to use Decision: if needed. Not necessary. But we can show algorithm.\n\nWe'll produce maybe 10 lines. Use arrow for nested steps.\n\nLet's produce:\n\nStart\n→ Step 1: 宣告屬性 radius, x_center, y_center // 儲存圓的半徑與中心座標\n→ Step 2: Solution Constructor(radius, x_center, y_center) 初始化屬性 // 將參數存入物件\n→ Step 3: randPoint() 方法 // 用於產生隨機點\n    → Step 4: 生成隨機角度 θ ∈ [0, 2π) // 用隨機數產生角度\n    → Step 5: 生成隨機半徑 r = sqrt(random()) * radius // 使用 sqrt 以保證均勻分佈\n    → Step 6: 計算點坐標 x = x_center + r * cos(θ) // 角度轉 x\n    → Step 7: 計算點坐標 y = y_center + r * sin(θ) // 角度轉 y\n    → Step 8: 回傳 [x, y] // 以陣列形式返回點\nEnd // 程式結束\n\nBut need to ensure each line is a \"虛擬碼步驟\". The Step numbering is part of virtual code. Use arrow \"→\" preceding. For nested steps, indent maybe.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: 宣告屬性 radius, x_center, y_center // 儲存圓的半徑與中心座標\n→ Step 2: Solution Constructor(radius, x_center, y_center) // 初始化物件屬性\n    → Step 2.1: this.radius = radius // 設定半徑\n    → Step 2.2: this.x_center = x_center // 設定 x 中心\n    → Step 2.3: this.y_center = y_center // 設定 y 中心\n→ Step 3: randPoint() 方法 // 產生隨機點\n    → Step 3.1: θ ← random() * 2π // 產生 0-2π 隨機角度\n    → Step 3.2: r ← sqrt(random()) * this.radius // 產生均勻半徑\n    → Step 3.3: x ← this.x_center + r * cos(θ) // 計算 x\n    → Step 3.4: y ← this.y_center + r * sin(θ) // 計算 y\n    → Step 3.5: 回傳 [x, y] // 回傳點\nEnd // 程式結束\n\nLet's ensure format: \"虛擬碼步驟 [space] // 解釋\". We'll use arrow \"→\" before each step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告屬性 radius, x_center, y_center // 儲存圓的半徑與中心座標  \n→ Step 2: Solution Constructor(radius, x_center, y_center) // 初始化物件屬性  \n  → Step 2.1: this.radius = radius // 設定半徑  \n  → Step 2.2: this.x_center = x_center // 設定 x 中心  \n  → Step 2.3: this.y_center = y_center // 設定 y 中心  \n→ Step 3: randPoint() 方法 // 產生隨機點  \n  → Step 3.1: θ ← random() * 2π // 產生 0-2π 隨機角度  \n  → Step 3.2: r ← sqrt(random()) * this.radius // 產生均勻半徑  \n  → Step 3.3: x ← this.x_center + r * cos(θ) // 計算 x 坐標  \n  → Step 3.4: y ← this.y_center + r * sin(θ) // 計算 y 坐標  \n  → Step 3.5: 回傳 [x, y] // 回傳隨機點  \nEnd // 程式結束"
    },
    {
      "title": "Count Different Palindromic Subsequences",
      "source_file": "Leetcode/leetcode730.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '3'"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '104860361'\nGot (Norm):      '59371064'\n--- (Raw) ---\nRaw Expected: '104860361'\nRaw Got:      '59371064'"
        }
      ],
      "generated_code": "import sys\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # next_pos[i][c] = next index >= i where char c appears, or n if none\n    next_pos = [[n] * 26 for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for c in range(26):\n            next_pos[i][c] = next_pos[i + 1][c]\n        next_pos[i][ord(s[i]) - 97] = i\n\n    # prev_pos[i][c] = previous index < i where char c appears, or -1 if none\n    prev_pos = [[-1] * 26 for _ in range(n + 1)]\n    for i in range(n):\n        for c in range(26):\n            prev_pos[i + 1][c] = prev_pos[i][c]\n        prev_pos[i + 1][ord(s[i]) - 97] = i\n\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n + 1):\n        for l in range(0, n - length + 1):\n            r = l + length - 1\n            if s[l] != s[r]:\n                dp[l][r] = (dp[l + 1][r] + dp[l][r - 1] - dp[l + 1][r - 1]) % MOD\n            else:\n                left = next_pos[l][ord(s[l]) - 97]\n                right = prev_pos[r][ord(s[r]) - 97]\n                if left > right:\n                    dp[l][r] = (dp[l + 1][r - 1] * 2 + 2) % MOD\n                elif left == right:\n                    dp[l][r] = (dp[l + 1][r - 1] * 2 + 1) % MOD\n                else:\n                    dp[l][r] = (dp[l + 1][r - 1] * 2 - dp[left + 1][right - 1]) % MOD\n    return dp[0][n - 1]\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the string, handling possible \"s = \\\"...\\\"\" format\n    if '=' in data:\n        _, part = data.split('=', 1)\n        part = part.strip()\n        if (part.startswith('\"') and part.endswith('\"')) or (part.startswith(\"'\") and part.endswith(\"'\")):\n            s = part[1:-1]\n        else:\n            s = part\n    else:\n        if (data.startswith('\"') and data.endswith('\"')) or (data.startswith(\"'\") and data.endswith(\"'\")):\n            s = data[1:-1]\n        else:\n            s = data\n\n    result = count_palindromic_subsequences(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for DP solution. We'll produce step-by-step algorithm: using dp[l][r] count of distinct palindromic subseqs in s[l..r]. Use recurrence with next/prev arrays. Provide mod. Implementation steps: compute next occurrence and prev occurrence for each index. Use 2D dp and 3 nested loops. Provide start, decisions.\n\nWe produce pseudo steps lines. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to produce algorithmic pseudo code, not actual code. So we must use steps like \"Start\", \"→ Initialize variables\", etc.\n\nLet's craft.\n\nWe'll produce:\n\nStart // 開始\n→ Input string s and N=length // 取得輸入字串與長度\n→ Compute next[i][c] for each position i and char c // 下一個相同字元的位置\n→ Compute prev[i][c] for each position i and char c // 上一個相同字元的位置\n→ Initialize dp[N][N] to 0 // 2D DP 表\n→ For i from N-1 downto 0: // 單字元子序列\n    → dp[i][i] = 1 // 每個單字元本身為一個回文子序列\n→ For length L from 2 to N: // 子串長度\n    → For l from 0 to N-L:\n        → r = l+L-1\n        → If s[l] != s[r]:\n            → dp[l][r] = dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1] // 依賴\n            → If dp[l][r] < 0: dp[l][r] += MOD\n        → Else: // s[l] == s[r]\n            → left = next[l][s[l]] // 下一個相同字元位置\n            → right = prev[r][s[r]] // 上一個相同字元位置\n            → If left > right: // 無中間相同字元\n                → dp[l][r] = 2 + dp[l+1][r-1] // 新增兩個以兩端字元為首尾的子序列\n            → Else if left == right: // 僅一個中間相同字元\n                → dp[l][r] = 1 + dp[l+1][r-1] // 新增一個以兩端字元為首尾的子序列\n            → Else: // 至少兩個相同字元在中間\n                → dp[l][r] = 2 * dp[l+1][r-1] - dp[left+1][right-1] // 去除重複\n            → dp[l][r] = (dp[l][r] % MOD + MOD) % MOD // 正模\n→ Result = dp[0][N-1] // 完整字串答案\n→ Output Result // 印出結果\n\nBut need to express in each line with virtual code and comment.\n\nAlso need to mention using modulo. Use MOD=1000000007.\n\nWe may include decision blocks for s[l] != s[r], etc.\n\nLet's craft.\n\nWe need to produce lines: \"Start // 程式開始執行\" etc.\n\nWe need to use arrows and decision: \"Decision: 如果 s[l] != s[r]?\".\n\nBut we can also express with nested lines.\n\nLet's produce.\n\nWe must produce step lines:\n\nStart // 程式開始\n\n→ Input s // 取得輸入字串\n\n→ N ← length(s) // 計算字串長度\n\n→ MOD ← 1000000007 // 定義模數\n\n→ Initialize next[N][26] to N // 下一個同字元位置表，預設為 N (不存在)\n\n→ For i from N-1 downto 0: // 從右到左計算\n    → For c from 0 to 25:\n        → If s[i] == char('a'+c): next[i][c] = i\n        → Else: next[i][c] = next[i+1][c] // 继承右侧下一次位置\n...\n\nBut we might skip details to keep concise.\n\nHowever the requirement: produce step-by-step, each line with code step and comment. Should include loops and decisions.\n\nLet's produce a final answer.\n\nWe'll include variable names: `nextPos`, `prevPos`, `dp`.\n\nWe'll produce nested loops for lengths.\n\nWe need to show decisions for s[l] == s[r].\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s // 取得輸入字串  \n→ N ← length(s) // 字串長度  \n→ MOD ← 1000000007 // 模數  \n\n// 先建 nextPos 與 prevPos 表，方便快速找相同字元  \n→ Create nextPos[N][26] // 下一個同字元位置表，缺失時設為 N  \n→ Create prevPos[N][26] // 上一個同字元位置表，缺失時設為 -1  \n\n→ For i from N-1 downto 0: // 從右往左填寫 nextPos  \n    → For c from 0 to 25:  \n        → If s[i] == char('a'+c): nextPos[i][c] = i  \n        → Else: nextPos[i][c] = nextPos[i+1][c]  \n\n→ For i from 0 to N-1: // 從左往右填寫 prevPos  \n    → For c from 0 to 25:  \n        → If s[i] == char('a'+c): prevPos[i][c] = i  \n        → Else: prevPos[i][c] = prevPos[i-1][c]  \n\n// 建立 dp 二維表，dp[l][r] 為 s[l..r] 中不同非空回文子序列的數量  \n→ Create dp[N][N] // 初始化為 0  \n\n→ For i from 0 to N-1: // 單字元子序列都是回文  \n    → dp[i][i] ← 1  \n\n// 從長度 2 開始遞增計算  \n→ For L from 2 to N:  \n    → For l from 0 to N-L:  \n        → r ← l + L - 1  \n\n        // 判斷兩端字元是否相同  \n        → Decision: 如果 s[l] != s[r]?  \n            Yes → // 不同字元時使用合併公式  \n                → dp[l][r] ← dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]  \n                → If dp[l][r] < 0: dp[l][r] += MOD // 取正模  \n\n            No  → // 同字元時需考慮內部重複  \n                → left ← nextPos[l][s[l]-'a'] // 下一個相同字元位置  \n                → right ← prevPos[r][s[r]-'a'] // 上一個相同字元位置  \n\n                // 判斷內部是否存在相同字元  \n                → Decision: 如果 left > right? // 無中間相同字元  \n                    Yes → // 兩端字元可單獨形成兩個新回文  \n                        → dp[l][r] ← 2 + dp[l+1][r-1]  \n\n                    No → Decision: 如果 left == right? // 僅一個中間相同字元  \n                        Yes → // 兩端字元形成一個新回文  \n                            → dp[l][r] ← 1 + dp[l+1][r-1]  \n\n                        No  → // 至少兩個中間相同字元  \n                            → dp[l][r] ← 2 * dp[l+1][r-1] - dp[left+1][right-1]  \n\n                → dp[l][r] ← (dp[l][r] % MOD + MOD) % MOD // 確保非負模  \n\n→ Result ← dp[0][N-1] // 完整字串的答案  \n→ Output Result // 印出最終結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,3,1],[1,2,3],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 3, 1], [1, 2, 3], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport random\n\nclass Solution:\n    \"\"\"隨機打亂陣列的實作。\"\"\"\n\n    def __init__(self, nums):\n        # 保存原始陣列（作為不可變的參考）\n        self.original = list(nums)\n        # 目前的陣列，初始時為原始陣列的拷貝\n        self.current = list(nums)\n\n    def reset(self):\n        \"\"\"重設為原始陣列並回傳。\"\"\"\n        self.current = list(self.original)\n        return self.current\n\n    def shuffle(self):\n        \"\"\"使用 Fisher‑Yates 算法隨機打亂陣列並回傳。\"\"\"\n        arr = list(self.current)  # 先複製一份，保持原陣列不變\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\n\ndef main():\n    \"\"\"主程式：從 stdin 讀取操作序列，執行並輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 把輸入包成 tuple 方便 literal_eval 解析\n    wrapped = f'({data})'\n    ops, args = ast.literal_eval(wrapped)\n\n    obj = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0])\n            outputs.append(None)  # 建構子沒有回傳值\n        elif op == \"reset\":\n            outputs.append(obj.reset())\n        elif op == \"shuffle\":\n            outputs.append(obj.shuffle())\n        else:\n            outputs.append(None)  # 其他不預期的指令\n\n    # 將結果轉成 JSON 字串輸出，符合範例格式\n    print(json.dumps(outputs))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the described class. We need to give steps. We need to output line by line, each line with \"虛擬碼步驟 // 解釋\". Use arrows and Start, End, Decision.\n\nWe need to describe the class initialization, storing original array, implementing reset and shuffle with Fisher-Yates algorithm.\n\nWe need to produce a structured virtual code. Since it's a class, we may treat it as functions inside class. Use Start, End. Use Decision for random selection.\n\nWe'll produce pseudo lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 定義主類別\n    → Step 2: 變數 original: array // 儲存原始陣列\n    → Step 3: 變數 current: array // 目前陣列\n    → Step 4: 建構子 Solution(nums)\n        → Step 5: original ← copy(nums) // 產生原始陣列副本\n        → Step 6: current ← copy(nums) // 產生可變陣列副本\n    → Step 7: 方法 reset()\n        → Step 8: current ← copy(original) // 重設為原始\n        → Step 9: return current // 回傳\n    → Step 10: 方法 shuffle()\n        → Step 11: for i from 0 to length-1\n            → Decision: 隨機選取 j 在 i 到 length-1 之間? // 隨機化索引\n                Yes → Step 12: swap current[i] 與 current[j] // 交換\n                No  → Step 12: 仍選擇另一個 j (實際上只需要一次)\n        → Step 13: return current // 回傳隨機排列\nEnd // 程式執行結束\n\nBut we need to use arrow arrow. The format: \"虛擬碼步驟 // 解釋\". Use \"→\" to show flow.\n\nNeed to maintain indentation for decisions.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 定義主類別  \n    → Step 2: 變數 original: array // 儲存原始陣列的副本  \n    → Step 3: 變數 current: array // 儲存目前的陣列  \n    → Step 4: 建構子 Solution(nums) // 初始化物件  \n        → Step 5: original ← copy(nums) // 產生原始陣列的完整副本  \n        → Step 6: current ← copy(nums) // 產生可變的陣列副本  \n    → Step 7: 方法 reset() // 重設陣列到原始狀態  \n        → Step 8: current ← copy(original) // 將 current 設回原始副本  \n        → Step 9: return current // 回傳重設後的陣列  \n    → Step 10: 方法 shuffle() // 產生隨機排列  \n        → Step 11: for i from 0 to length-1 // 遍歷每個索引  \n            → Decision: 隨機產生 j 在 [i, length-1] 之間? // 決定交換位置  \n                Yes → Step 12: swap current[i] 與 current[j] // 交換元素  \n                No  → Step 12: 重新產生 j (實際上只需一次) // 確保選擇有效  \n        → Step 13: return current // 回傳隨機排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])          # 1. 把目前子集加入結果\n            for i in range(start, len(nums)):\n                path.append(nums[i])     # 2. 加入元素\n                backtrack(i + 1, path)   # 3. 進行遞迴\n                path.pop()               # 4. 回溯\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 解析輸入，支援 \"nums = [1,2,3]\" 或直接 \"[1,2,3]\"\n    if \"=\" in data:\n        _, expr = data.split(\"=\", 1)\n        nums = eval(expr.strip())\n    else:\n        nums = eval(data)\n    solution = Solution()\n    result = solution.subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets of a set of unique elements. We need to produce each line with \"虛擬碼步驟\" and explanation. Use Start, End, Decision: and arrows. No actual code. Each line must have a virtual code step and explanation.\n\nWe need to cover algorithm: perhaps backtracking / recursion. We can choose a typical algorithm: iterate over elements, for each element add to current subset and recursively explore.\n\nWe need to show steps: start, input, initialize result, define backtrack function, etc. Use \"→\" to show actions.\n\nWe need to produce a structured pseudo-code.\n\nWe need to be careful to keep formatting: each line: \"虛擬碼步驟 // 解釋\".\n\nUse Start, End. Indent for decisions.\n\nWe can produce steps like:\n\nStart // 程式開始\n\n→ Input: array nums // 取得輸入數列\n\n→ Initialize: result = [] // 存放所有子集\n\n→ Define function backtrack(start, current): // 定義遞迴函式\n\n   Decision: start == length of nums? // 檢查是否已經處理完所有元素\n\n      Yes → Append copy of current to result // 把目前子集加入結果\n\n      No  → Step: Append copy of current to result // 也加入一次（空集等）\n\n          Decision: 是否要回溯？ // Actually we should always add current to result before exploring further\n\n          // Wait: we need to add current to result for each call.\n\nBut typical algorithm: at each recursive call, add current to result, then iterate from start to n-1: include element and recurse.\n\nThus pseudo:\n\n→ Function backtrack(index, current):\n\n   → Append current to result\n\n   → For i from index to n-1:\n\n        → current.push(nums[i])\n\n        → backtrack(i+1, current)\n\n        → current.pop()\n\nWe need to write in virtual code.\n\nWe need to produce lines for start, input, init, define backtrack, etc. Use arrow.\n\nWe should show decision and loops. For loops maybe use \"Loop:\" and \"Step\".\n\nWe can use \"Loop: for i from index to n-1\" etc.\n\nWe need to ensure each line has arrow and comment.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Input: nums // 取得輸入陣列\n\n→ Initialize: result ← [] // 用於儲存所有子集\n\n→ Define Function: backtrack(index, current) // 以遞迴方式產生子集\n\n    → Append copy of current to result // 每個階段都加入目前子集\n\n    → Loop i from index to length(nums)-1 // 循環選取剩餘元素\n\n        → current.push(nums[i]) // 將第 i 個元素加入子集\n\n        → backtrack(i+1, current) // 以下一個索引遞迴\n\n        → current.pop() // 回溯，移除最後加入的元素\n\n→ Call backtrack(0, []) // 從索引 0 開始，子集初始為空\n\n→ Output: result // 返回所有子集\n\nEnd // 程式結束\n\nBut we need to use \"Decision:\" for branching. Here there's no decision except loops. But we can still show \"Decision:\" for if i < length.\n\nBetter to show \"Decision: i < length?\" but typical loop structure can be shown as \"Loop:\".\n\nBut the requirement: \"使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:)\" So we can use Decision but not mandatory. But we can show loop as \"Loop:\".\n\nBut let's keep simple.\n\nLet's produce each line with arrow and comment.\n\nWe need to ensure each line is a separate line.\n\nAlso note that each line should contain the virtual code step, a space, and then comment starting with //.\n\nLet's produce.\n\nCheck formatting: no extra leading/trailing spaces.\n\nWe need to output only the virtual code lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: nums // 取得輸入陣列  \n→ Initialize: result ← [] // 用於儲存所有子集  \n→ Define Function: backtrack(index, current) // 以遞迴方式產生子集  \n → Append copy of current to result // 每個階段都加入目前子集  \n → Loop i from index to length(nums)-1 // 循環選取剩餘元素  \n  → current.push(nums[i]) // 將第 i 個元素加入子集  \n  → backtrack(i+1, current) // 以下一個索引遞迴  \n  → current.pop() // 回溯，移除最後加入的元素  \n→ Call backtrack(0, []) // 從索引 0 開始，子集初始為空  \n→ Output: result // 返回所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Task Scheduler",
      "source_file": "Leetcode/leetcode621.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "actual_output_or_error": "Error parsing input: 輸入格式錯誤"
        },
        {
          "example_index": 1,
          "input": "tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1",
          "expected_output": "6",
          "actual_output_or_error": "Error parsing input: 輸入格式錯誤"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "actual_output_or_error": "Error parsing input: 輸入格式錯誤"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\ndef least_interval(tasks, n):\n    \"\"\"計算完成所有任務所需的最小 CPU 時間間隔。\"\"\"\n    task_counts = Counter(tasks)\n    max_freq = max(task_counts.values())\n    # 同時擁有最高頻率的任務種類數\n    max_count = sum(1 for cnt in task_counts.values() if cnt == max_freq)\n    # 先假設所有高頻任務之間都有 n 個空閒間隔\n    intervals = (max_freq - 1) * (n + 1) + max_count\n    return max(intervals, len(tasks))\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析 tasks 列表和 n 整數。\n    預期輸入形如：tasks = [\"A\",\"A\",\"B\"], n = 2\n    \"\"\"\n    pattern = r'tasks\\s*=\\s*(\\[\\s*(?:[A-Za-z]\\s*,\\s*)*[A-Za-z]\\s*\\])\\s*,\\s*n\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"輸入格式錯誤\")\n    tasks_str, n_str = match.groups()\n    tasks = ast.literal_eval(tasks_str)\n    n = int(n_str)\n    return tasks, n\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_data = sys.stdin.read().strip()\n    if not raw_data:\n        sys.exit(0)\n    # 解析輸入\n    try:\n        tasks_list, cooldown = parse_input(raw_data)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n    # 計算並輸出結果\n    result = least_interval(tasks_list, cooldown)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for scheduling CPU tasks with cooldown. Classic problem: \"Task Scheduler\" from Leetcode.\n\nWe need to output virtual code lines with explanation.\n\nApproach: Count frequencies, find max freq, count how many tasks have max freq. Compute idle slots: (max-1)*(n+1) - sum(min(freq, max-1))? Actually formula: (maxCount-1)*(n+1)+numMaxTasks; answer = max(totalTasks, idle). So we can produce algorithm.\n\nWe will produce steps: Start, input tasks array, n. Compute frequency map. Find maxCount, countMax. Compute intervalsNeeded = (maxCount-1)*(n+1)+countMax. Return max(totalTasks, intervalsNeeded). End.\n\nWe need to output each line with arrow, etc. Use structure: Start, Decision, etc. Let's produce algorithm steps:\n\nStart\n→ Step: Build frequency map from tasks\n→ Step: Find maxCount (max frequency) and countMax (# of tasks with maxCount)\n→ Step: Compute idleSlots = (maxCount-1)*(n+1) - (sum of min(freq, maxCount-1) for all tasks?) Actually easier: intervals = (maxCount-1)*(n+1)+countMax\n→ Decision: if intervals < totalTasks? Then answer = totalTasks\n→ Decision: else answer = intervals\n→ End\n\nWe can include decisions.\n\nBut the instructions: Use 虛擬碼步驟 + explanation. Use arrows: →, Yes→, No→.\n\nWe can embed decision blocks.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化頻率映射 freqMap = {} // 建立字典以儲存每個任務的出現次數\n→ Step 2: 對 tasks 中每個任務字母計數，更新 freqMap // 統計每個任務的執行頻率\n→ Step 3: 找到最高頻率 maxCount 以及同時擁有最高頻率的任務數 countMax // 這兩個值決定冷卻期安排\n→ Step 4: 計算基於最高頻率的最小時間 intervals = (maxCount - 1) * (n + 1) + countMax // 先假設所有高頻任務之間都隔 n 個間隔\n→ Decision: intervals < totalTasks? // 比較計算得到的最小時間與實際任務總數\n    Yes → Step 5: 結果 answer = totalTasks // 若任務數多於計算時間，直接使用任務數\n    No  → Step 5: 結果 answer = intervals // 否則使用計算得到的最小時間\nEnd // 程式執行結束\n\nBut we need to add explanation after each line.\n\nWe might need to show totalTasks variable earlier.\n\nWe can add Step: totalTasks = len(tasks).\n\nLet's produce final list.\n\nAlso we can show decision block indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: totalTasks ← len(tasks) // 計算任務總數  \n→ Step 2: freqMap ← {} // 初始化頻率映射，用於統計每個任務字母的出現次數  \n→ Step 3: for task in tasks: freqMap[task] ← freqMap.get(task, 0) + 1 // 逐一遍歷任務並更新頻率  \n→ Step 4: maxCount ← 0; countMax ← 0 // 兩個變數用於保存最高頻率及其出現的任務種類數  \n→ Step 5: for freq in freqMap.values():  \n    if freq > maxCount:  \n     maxCount ← freq  \n     countMax ← 1  \n    elif freq == maxCount:  \n     countMax ← countMax + 1 // 找到最高頻率及其任務數  \n→ Step 6: intervals ← (maxCount - 1) * (n + 1) + countMax // 先假設所有高頻任務之間都有 n 個空閒間隔  \n→ Decision: intervals < totalTasks? // 檢查計算得到的最小時間是否小於實際任務數  \n  Yes → Step 7: answer ← totalTasks // 若任務數多於計算時間，直接使用任務數  \n  No  → Step 7: answer ← intervals // 否則使用計算得到的最小時間  \nEnd // 程式執行結束"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmh_dxqat.py\", line 55, in <module>\n    nums, k, t = parse_input(raw_input)\n                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmh_dxqat.py\", line 44, in parse_input\n    exec(input_str, {}, local_vars)\n  File \"<string>\", line 1\n    nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\n    ^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvn5e6wlj.py\", line 55, in <module>\n    nums, k, t = parse_input(raw_input)\n                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvn5e6wlj.py\", line 44, in parse_input\n    exec(input_str, {}, local_vars)\n  File \"<string>\", line 1\n    nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\n    ^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom bisect import bisect_left, insort\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        \"\"\"\n        利用滑動窗口與有序列表判斷是否存在符合條件的索引對。\n        :param nums: List[int] - 數組\n        :param k: int - 最大索引距離\n        :param t: int - 最大數值差\n        :return: bool - 是否存在符合條件的對\n        \"\"\"\n        if k <= 0 or t < 0:\n            return False\n\n        window = []  # 有序列表，存儲當前窗口內的元素\n        for i, num in enumerate(nums):\n            # 1. 在窗口中查找是否存在值在 [num-t, num+t] 範圍內的元素\n            left = num - t\n            right = num + t\n            pos = bisect_left(window, left)\n            if pos < len(window) and window[pos] <= right:\n                return True\n\n            # 2. 把當前元素加入窗口\n            insort(window, num)\n\n            # 3. 保持窗口大小不超過 k\n            if len(window) > k:\n                out_val = nums[i - k]          # 要移除的舊元素\n                idx = bisect_left(window, out_val)\n                # 刪除第一個匹配的值\n                if idx < len(window) and window[idx] == out_val:\n                    window.pop(idx)\n\n        return False\n\ndef parse_input(input_str: str):\n    \"\"\"\n    將形如 'nums = [1,2,3,1], indexDiff = 3, valueDiff = 0' 的字串解析成變量。\n    \"\"\"\n    local_vars = {}\n    # 執行字串以得到變量\n    exec(input_str, {}, local_vars)\n    nums = local_vars.get('nums', [])\n    k = local_vars.get('indexDiff', 0)\n    t = local_vars.get('valueDiff', 0)\n    return nums, k, t\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    nums, k, t = parse_input(raw_input)\n    solution = Solution()\n    result = solution.containsNearbyAlmostDuplicate(nums, k, t)\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nWe need to produce virtual code with arrows. The problem: find pair of indices with constraints. We need to give virtual steps: loop over i, j maybe sliding window. Provide algorithm. Provide pseudocode steps.\n\nWe need to produce step by step lines with explanations. Each line must have \"虛擬碼步驟\" then a space then \"// 解釋/說明\".\n\nUse Start, End, Decision.\n\nLet's craft:\n\nStart // start\n→ Step 1: 建立一個空的平衡樹/有序集合 // 用於儲存可比較的元素\n→ Step 2: 初始化指標 left = 0 // 左邊界指標\n→ Decision: 遍歷 i 從 0 到 nums.length-1? // 遍歷所有元素\n    Yes → Step 3: 移除左邊超出 indexDiff 的元素 // 確保距離條件\n        → Step 3a: While i - left > indexDiff:\n            → Step 3a1: 從集合刪除 nums[left]\n            → Step 3a2: left += 1\n    Yes → Step 4: 在集合中尋找是否存在 x 滿足 |x - nums[i]| <= valueDiff\n        → Step 4a: 使用查找範圍 [nums[i]-valueDiff, nums[i]+valueDiff]\n        → Step 4b: 如果找到，返回 true\n    Yes → Step 5: 將 nums[i] 插入集合\n→ Decision: 是否已遍歷完所有 i?\n    Yes → End // 無符合條件，返回 false\n    No  → 回到 Decision 進行下一個 i\n\nBut we need each line individually. Use arrow format with indentation for nested decisions.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 建立一個空的有序集合 tree // 用於快速查找值範圍\n→ Step 2: 設定 left = 0 // 左邊界指標\n→ Decision: i 在 0 到 nums.length-1? // 循環遍歷所有索引\n    Yes → Step 3: 當 i - left > indexDiff 時\n        → Decision: i - left > indexDiff? // 確保距離不超過 indexDiff\n            Yes → Step 3a: 從 tree 刪除 nums[left] // 移除超出窗口的元素\n                → Step 3b: left += 1\n                → Step 3c: 回到 Decision: i - left > indexDiff? // 可能還有多個超出\n            No  → Step 4: 在 tree 中尋找是否存在 x 滿足 |x - nums[i]| <= valueDiff\n                → Step 4a: 計算 low = nums[i] - valueDiff, high = nums[i] + valueDiff\n                → Step 4b: 如果 tree 中有任一元素在 [low, high] 範圍內\n                    → Step 4b1: 返回 true // 找到符合條件的對\n                → Step 5: 將 nums[i] 插入 tree // 將當前元素加入窗口\n    No  → End // 所有索引已處理，未找到符合條件，返回 false\n\nBut need each line individually, no sub-steps? We can split.\n\nLet's produce each step as one line: Step numbers incremental.\n\nWe need to ensure arrow syntax and decisions.\n\nWe can indent using spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空的有序集合 tree // 用於快速查找值範圍  \n→ Step 2: 設定 left = 0 // 左邊界指標  \n→ Decision: i 在 0 到 nums.length-1? // 循環遍歷所有索引  \n&nbsp;&nbsp;Yes → Step 3: 當 i - left > indexDiff 時  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: i - left > indexDiff? // 確保距離不超過 indexDiff  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3a: 從 tree 刪除 nums[left] // 移除超出窗口的元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 3b: left += 1 // 移動左邊界  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 3c: 回到 Decision: i - left > indexDiff? // 可能還有多個超出  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Step 4: 在 tree 中尋找是否存在 x 滿足 |x - nums[i]| <= valueDiff // 檢查值差條件  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 4a: 計算 low = nums[i] - valueDiff, high = nums[i] + valueDiff  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 4b: 如果 tree 中有任一元素在 [low, high] 範圍內  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4b1: 返回 true // 找到符合條件的對  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 5: 將 nums[i] 插入 tree // 將當前元素加入窗口  \n&nbsp;&nbsp;No → End // 所有索引已處理，未找到符合條件，返回 false"
    },
    {
      "title": "Shortest Completing Word",
      "source_file": "Leetcode/leetcode748.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]",
          "expected_output": "\"steps\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpt3mq3nq2.py\", line 34, in <module>\n    main()\n  File \"/tmp/tmpt3mq3nq2.py\", line 25, in main\n    data = eval('{' + raw + '}')\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]}\n     ^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"]",
          "expected_output": "\"pest\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9dmwgsyh.py\", line 34, in <module>\n    main()\n  File \"/tmp/tmp9dmwgsyh.py\", line 25, in main\n    data = eval('{' + raw + '}')\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"]}\n     ^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport collections\n\nclass Solution:\n    def shortestCompletingWord(self, licensePlate, words):\n        # Count letters in licensePlate (ignore case and non-letters)\n        plate_count = collections.Counter(\n            c.lower() for c in licensePlate if c.isalpha()\n        )\n        result = None\n        for word in words:\n            word_count = collections.Counter(word)\n            # Check if word satisfies all required counts\n            if all(word_count[c] >= plate_count[c] for c in plate_count):\n                if result is None or len(word) < len(result):\n                    result = word\n        return result\n\ndef main():\n    # Read entire input; input format: licensePlate = \"...\", words = [...]\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # Wrap with braces to make it a valid dict string\n    data = eval('{' + raw + '}')\n    licensePlate = data['licensePlate']\n    words = data['words']\n\n    sol = Solution()\n    answer = sol.shortestCompletingWord(licensePlate, words)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanations. Use arrow and structure. We need to outline algorithm: parse licensePlate to counts ignoring non-letters. For each word, count letters, check if contains required counts. Keep shortest length and first order. Use Start, Decision, End.\n\nLet's write:\n\nStart\n→ Step 1: 初始化 licenseCount[26] 為 0 // 统计 licensePlate 字母出现次数\n→ Step 2: 对 licensePlate 中每个字符进行遍历\n    → Decision: 字符是否为字母?\n        Yes → Step 3: 将字符转换为小写，licenseCount[索引]++\n        No  → Step 4: 跳过 // 忽略非字母\n→ Step 5: 初始化 bestWord = \"\"，bestLen = Infinity // 存储当前最短满足条件的单词\n→ Step 6: 对 words 数组中的每个单词 word 进行遍历\n    → Step 7: 初始化 wordCount[26] 为 0 // 统计当前单词字母出现次数\n    → Step 8: 对 word 中每个字符进行遍历\n        → Step 9: 将字符转换为小写，wordCount[索引]++\n    → Step 10: Decision: word 是否满足 licenseCount?\n        → Decision: 对所有 i 从 0 到 25 判断 wordCount[i] >= licenseCount[i]？\n            Yes → Step 11: Decision: word 长度 < bestLen?\n                Yes → Step 12: bestWord = word // 更新最短单词\n                       → Step 13: bestLen = word 长度\n                No  → Step 14: 跳过 // 长度不比当前更短\n            No  → Step 15: 跳过 // 不满足条件\n→ Step 16: Output bestWord // 返回结果\nEnd\n\nMake sure each line has // explanation. Use arrow. Use Yes → No. Use indentation maybe but format similar to example. Use \"Decision:\" before decision lines.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 licenseCount[26] 為 0 // 建立 26 個位置統計 licensePlate 中字母出現頻率  \n→ Step 2: 對 licensePlate 中每個字符進行遍歷  \n    → Decision: 字符是否為字母? // 判斷是否要計數  \n        Yes → Step 3: 將字符轉為小寫，licenseCount[字母索引]++ // 更新統計  \n        No  → Step 4: 跳過 // 忽略非字母字符  \n→ Step 5: 初始化 bestWord = \"\"，bestLen = Infinity // 用來記錄目前最短符合條件的單詞  \n→ Step 6: 對 words 陣列中的每個單詞 word 進行遍歷  \n    → Step 7: 初始化 wordCount[26] 為 0 // 建立單詞字母統計表  \n    → Step 8: 對 word 中每個字符進行遍歷  \n        → Step 9: 將字符轉為小寫，wordCount[字母索引]++ // 统计当前单词的字母出现次数  \n    → Decision: word 是否滿足 licenseCount? // 判断是否是 completing word  \n        → Decision: 對所有 i 從 0 到 25 判斷 wordCount[i] >= licenseCount[i]？ // 逐個字母比較需求  \n            Yes → Step 10: Decision: word 長度 < bestLen? // 若符合，判斷是否比目前更短  \n                Yes → Step 11: bestWord = word // 更新最短符合條件的單詞  \n                       → Step 12: bestLen = word 長度 // 更新最短長度  \n                No  → Step 13: 跳過 // 长度不比当前更短  \n            No  → Step 14: 跳過 // 不满足条件  \n→ Step 15: Output bestWord // 返回結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,0,1,1,0,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 0, 1, 1, 0, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport bisect\nimport json\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 將輸入包裝成合法的 Python 字面量\n    data = '[' + data + ']'\n    ops, args = ast.literal_eval(data)\n\n    solution = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # arg 形如 [[1]] 或 [[1,3]]，取第一個元素作為權重列表\n            solution = Solution(arg[0])\n            results.append(None)  # 代表 null\n        elif op == \"pickIndex\":\n            results.append(solution.pickIndex())\n\n    # 以 JSON 格式輸出，這樣 None 會轉成 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing pickIndex with weighted random selection. Use prefix sums, random number, binary search. Provide steps with explanations. Must use arrow syntax. Each line: step, // explanation.\n\nLet's design:\n\nStart\n→ Step 1: Compute prefix sums array cumulativeW from w // cumulative weights\n→ Step 2: total = cumulativeW[last] // total weight\n→ Step 3: Define function pickIndex() // function definition\n→   Step 3.1: Generate random integer r in [1, total] // random number\n→   Step 3.2: Binary search in cumulativeW to find smallest index such that cumulativeW[idx] >= r // find selected index\n→   Step 3.3: Return idx // return result\nEnd\n\nBut need to show Start/End, maybe for function also? We'll use Start, Step. Use arrow indentation for nested.\n\nLet's produce lines.\n\nUse \"Step 1:\", \"Step 2:\", etc. Provide explanations.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Compute prefix sums array cumulativeW from w // 將原始權重轉成前綴和，方便後續查找  \n→ Step 2: total = cumulativeW[last] // 獲取總權重，用於隨機數生成的上限  \n→ Step 3: Define function pickIndex() // 定義隨機挑選索引的函式  \n    → Step 3.1: Generate random integer r in [1, total] // 產生一個落在總權重範圍內的隨機整數  \n    → Step 3.2: Binary search cumulativeW to find smallest idx where cumulativeW[idx] >= r // 用二分搜尋找出對應的索引  \n    → Step 3.3: Return idx // 回傳選中的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpj08f2wk6.py\", line 29, in <module>\n    data = eval(raw_input, {}, {})\n           ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'mat' is not defined. Did you mean: 'max'?"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7e2jwc_m.py\", line 29, in <module>\n    data = eval(raw_input, {}, {})\n           ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'mat' is not defined. Did you mean: 'max'?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        \"\"\"\n        Count soldiers in each row using binary search (rows are sorted: all 1's come before 0's).\n        Return indices of the k weakest rows.\n        \"\"\"\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()\n        return [i for _, i in soldiers[:k]]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 轉換成字典形式以便 eval\n    raw_input = raw_input.replace(\"mat =\", \"mat:\").replace(\"k =\", \"k:\")\n    raw_input = \"{\" + raw_input + \"}\"\n    data = eval(raw_input, {}, {})\n    mat = data[\"mat\"]\n    k = data[\"k\"]\n    # 執行核心演算法\n    solution = Solution()\n    result = solution.kWeakestRows(mat, k)\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps for algorithm to find k weakest rows. The user wants virtual code: line-by-line with explanation, using Start, Decision, arrows etc. Should not output actual code. Must use Traditional Chinese.\n\nLet's produce pseudocode: read matrix, compute soldier count per row (binary sorted so use binary search or linear scan), store pairs (count,index). Sort by count then index. Select first k indices. Output.\n\nUse decision flows. Provide each step with arrow and explanation. We need to adhere to format: \"Start // 程式開始執行\" etc.\n\nLet's produce. Ensure each line includes \"虛擬碼步驟\" plus explanation.\n\nWe should use arrows: → Step X: ... // explanation\n\nUse Decision steps: Decision: ... // explanation\n\nWe need to be careful to maintain structure.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Initialize m = number of rows, n = number of columns // 取得矩陣尺寸\n→ Create empty list rowInfo // 用來儲存每行的(士兵數, 行索引)\n→ For i from 0 to m-1 // 遍歷每一行\n    → Decision: 這行是否有士兵? // 檢查是否存在 1\n        Yes → Set low=0, high=n-1, count=0 // 二分搜尋準備\n        No  → Set count=0 // 直接為 0\n    → While low <= high // 進行二分搜尋找最後一個 1 的位置\n        → mid = (low+high)/2\n        → Decision: mat[i][mid] == 1? // 是否是士兵\n            Yes → count = mid+1; low = mid+1 // 更新士兵數並搜尋右半\n            No  → high = mid-1 // 搜尋左半\n    → Append (count, i) to rowInfo // 記錄該行資訊\n→ Sort rowInfo by count ascending, then by index ascending // 依照士兵數及行索引排序\n→ Create result list // 用於存放前 k 行索引\n→ For j from 0 to k-1\n    → Append rowInfo[j].index to result // 取前 k 個最弱行\n→ Output result // 回傳結果\nEnd // 程式執行結束\n\nBut we need to match the format: each line \"虛擬碼步驟 // 解釋\". Also include arrows. Use \"Decision:\" lines for condition.\n\nNeed to keep indentation but maybe show lines within loops. Format:\n\nStart // 程式開始執行\n→ Initialize m = number of rows, n = number of columns // 取得矩陣尺寸\n→ Create empty list rowInfo // 用來儲存每行的(士兵數, 行索引)\n→ For i from 0 to m-1 // 遍歷每一行\n    → Decision: 這行是否有士兵? // 檢查是否存在 1\n        Yes → Set low=0, high=n-1, count=0 // 二分搜尋準備\n        No  → Set count=0 // 直接為 0\n    → While low <= high // 進行二分搜尋找最後一個 1 的位置\n        → mid = (low+high)/2\n        → Decision: mat[i][mid] == 1? // 是否是士兵\n            Yes → count = mid+1; low = mid+1 // 更新士兵數並搜尋右半\n            No  → high = mid-1 // 搜尋左半\n    → Append (count, i) to rowInfo // 記錄該行資訊\n→ Sort rowInfo by count ascending, then by index ascending // 依照士兵數及行索引排序\n→ Create result list // 用於存放前 k 行索引\n→ For j from 0 to k-1\n    → Append rowInfo[j].index to result // 取前 k 個最弱行\n→ Output result // 回傳結果\nEnd // 程式執行結束\n\nBut we need to ensure each line has \"虛擬碼步驟\" then a space then comment. Also arrows used for lines that proceed. For loops we can show indentation by spaces? In example, they used indentation spaces but not strict. Should be fine.\n\nWe should be careful that each line of pseudocode ends with comment. Provide explanation in Chinese.\n\nMake sure not to output actual code but just pseudocode with arrows.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize m = number of rows, n = number of columns // 取得矩陣尺寸  \n→ Create empty list rowInfo // 用來儲存每行的 (士兵數, 行索引)  \n→ For i from 0 to m-1 // 遍歷每一行  \n    → Decision: 這行是否有士兵? // 檢查是否存在 1  \n        Yes → Set low=0, high=n-1, count=0 // 二分搜尋準備  \n        No  → Set count=0 // 直接為 0  \n    → While low <= high // 進行二分搜尋找最後一個 1 的位置  \n        → mid = (low+high)/2  \n        → Decision: mat[i][mid] == 1? // 是否是士兵  \n            Yes → count = mid+1; low = mid+1 // 更新士兵數並搜尋右半  \n            No  → high = mid-1 // 搜尋左半  \n    → Append (count, i) to rowInfo // 記錄該行資訊  \n→ Sort rowInfo by count ascending, then by index ascending // 依照士兵數及行索引排序  \n→ Create result list // 用於存放前 k 行索引  \n→ For j from 0 to k-1 // 取前 k 個最弱行  \n    → Append rowInfo[j].index to result // 加入結果列表  \n→ Output result // 回傳最弱行的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Word in Dictionary",
      "source_file": "Leetcode/leetcode720.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"w\",\"wo\",\"wor\",\"worl\",\"world\"]",
          "expected_output": "world",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'world'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'world'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]",
          "expected_output": "apple",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'apple'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'apple'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef longest_word(words):\n    # 將單字按長度升序、字典序升序排序\n    words.sort(key=lambda w: (len(w), w))\n    built = set()\n    ans = \"\"\n\n    for w in words:\n        # 空字串視為已建構\n        if not w:\n            built.add(w)\n            continue\n\n        # 檢查前綴是否已存在\n        if w[: -1] in built:\n            built.add(w)\n            # 更新答案：較長者優先；長度相同則字典序較小者優先\n            if len(w) > len(ans) or (len(w) == len(ans) and w < ans):\n                ans = w\n\n    return ans\n\ndef main():\n    # 讀取所有輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        words = []\n    else:\n        # 移除可能的 \"words = \" 前綴\n        if '=' in data:\n            data = data.split('=', 1)[1].strip()\n        # 解析為 Python 列表\n        words = ast.literal_eval(data)\n\n    result = longest_word(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: longest word that can be built one character at a time by other words. This is typical LeetCode problem. Steps: sort words by length then lexicographically. Use set for built words. Iterate each word, check if all prefixes exist; if yes, add to set and update answer. Complexity O(n log n * L). Provide virtual code lines. Use structure Start, End, Decision, etc. Need to output each line with // explanation. Provide only virtual code, no actual code. Must use arrow characters. Provide lines like \"Start // 程式開始\". Use \"→\" to go to next step. Use Decision: etc. Ensure line numbers not needed. Just sequential. Let's craft.\n\nWe need to include sorting step, set init, iterate words, check prefixes, update answer, end.\n\nWe'll need to handle lexicographical tie: sorting ensures that shorter first? Actually we need longest with smallest lexicographic among same length. Sorting by length ascending ensures we process short first, but we need longest. Maybe we sort by length ascending, then lexicographic ascending, but we can update answer only if new word longer or equal length but lexicographically smaller. Or we could sort by length descending, lexicographic ascending. But typical solution: sort words by length ascending, then by lexicographic. When iterating, we keep a set of built words. For each word, if its prefix exists (first len-1 chars) in set, we add word to set and update answer if longer or same length but smaller lexicographically. But if we process ascending, later longer words may have lexicographically larger earlier? Actually if we process ascending, we will process all possible smaller words before bigger ones. Then when we encounter a word, if its prefix is built, we add. At the end, we can just keep track of best answer as longest; if tie, choose lexicographically smaller. So we need to compare when updating.\n\nWe should produce pseudocode with Decision steps: check if prefix in set, etc.\n\nLet's produce.\n\nAlso need to note sorting step: sort by length ascending, then lexicographic ascending.\n\nLet's craft lines.\n\nUse \"→\" to indicate flow to next step. Use \"Decision:\".\n\nLet's produce.\n\nWe also need to handle empty string return.\n\nOk.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: Sort words by length ascending, then lexicographically ascending // 方便先檢查較短單字，確保所有前綴已處理\n→ Step 2: 初始化建構集合 built = empty set // 用來記錄已能完整建構的單字\n→ Step 3: 初始化答案 ans = \"\" // 儲存目前符合條件的最佳單字\n→ Step 4: 對每個單字 w 在 words 中進行迴圈 // 逐一評估是否可由前綴建構\n    → Decision: 如果 w 為空字串? // 空字串可視為已建構\n        Yes → Step 4.1: 將 w 加入 built // 建構集合中加入空字串\n        No  → Decision: 是否存在 w 的前綴？即是否 w[0:len(w)-1] 在 built? // 檢查是否可一步完成\n            Yes → Step 4.2: 將 w 加入 built // w 可以由前綴建構，加入集合\n                    → Decision: 是否比 ans 長？或長度相同且字典序更小? // 更新最佳答案\n                        Yes → Step 4.3: ans = w // 以此單字作為新的答案\n                        No  → Step 4.4: // 仍保留舊答案\n            No  → Step 4.5: // w 不能建構，略過\n→ End // 程式結束，ans 為最終結果（若無可建構單字則為空字串）"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      \"'2'\""
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      \"'123'\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # Handle zero quickly\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n        # Result can be at most m+n digits\n        pos = [0] * (m + n)\n\n        # Multiply each digit (from right to left)\n        for i in range(m - 1, -1, -1):\n            d1 = ord(num1[i]) - 48  # faster than int()\n            for j in range(n - 1, -1, -1):\n                d2 = ord(num2[j]) - 48\n                mul = d1 * d2\n                p1, p2 = i + j, i + j + 1\n                total = mul + pos[p2]\n                pos[p2] = total % 10\n                pos[p1] += total // 10\n\n        # Skip leading zeros\n        start = 0\n        while start < len(pos) - 1 and pos[start] == 0:\n            start += 1\n\n        # Build result string\n        result = ''.join(str(d) for d in pos[start:])\n        return result\n\ndef _parse_input(data: str):\n    \"\"\"Extract two numeric strings from the input.\"\"\"\n    # Find all sequences of digits (handles quoted numbers as well)\n    digits = re.findall(r'\\d+', data)\n    if len(digits) >= 2:\n        return digits[0], digits[1]\n\n    # Fallback: split on whitespace or commas\n    parts = re.split(r'[\\s,]+', data.strip())\n    parts = [p for p in parts if p]\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    raise ValueError(\"Input does not contain two numbers.\")\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n    num1, num2 = _parse_input(raw_input)\n    solver = Solution()\n    product = solver.multiply(num1, num2)\n    # Print with surrounding single quotes as shown in the examples\n    print(f\"'{product}'\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for multiplication of large numbers represented as strings without built-in BigInteger or converting to integer. We need step-by-step virtual code. Provide explanation after each line. We need to output as specified: each line \"虛擬碼步驟 // 解釋/說明\". Use arrow, Decision, Start, End.\n\nLet's design algorithm:\n\n- Input: num1, num2 strings.\n- Edge cases: if either is \"0\" return \"0\".\n- Determine lengths: len1, len2.\n- Create result array of size len1+len2, initialized with 0.\n- Iterate i from len1-1 downto 0:\n  - digit1 = num1[i] - '0'.\n  - carry = 0.\n  - For j from len2-1 downto 0:\n     - digit2 = num2[j] - '0'.\n     - sum = result[i+j+1] + digit1*digit2 + carry.\n     - result[i+j+1] = sum % 10.\n     - carry = sum / 10.\n  - After inner loop: result[i] += carry.\n- Convert result array to string:\n  - skip leading zeros.\n  - build string by iterating result.\n- Return string.\n\nWe need to produce virtual code. Let's craft step by step.\n\nUse decisions: Check zero. Maybe also convert char to digit.\n\nLet's produce.\n\nMake sure to include lines like:\n\nStart // 開始\n\n→ Step 1: 輸入 num1, num2 // 取得輸入字串\n\n→ Decision: 如果 num1 為 \"0\" 或 num2 為 \"0\"? // 檢查是否有 0\n\n   Yes → Step 2: 回傳 \"0\" // 直接返回\n\n   No  → Step 3: 取得長度 len1, len2 // 計算長度\n\n   → Step 4: 建立結果陣列 result[ len1 + len2 ] 全 0 // 初始化\n\n   → Step 5: 對 i 從 len1-1 到 0 做循環 // 外層迴圈\n\n       → Step 6: digit1 = num1[i] - '0' // 轉成整數\n\n       → Step 7: carry = 0 // 初始化進位\n\n       → Step 8: 對 j 從 len2-1 到 0 做循環 // 內層迴圈\n\n           → Step 9: digit2 = num2[j] - '0' // 轉成整數\n\n           → Step 10: sum = result[i+j+1] + digit1*digit2 + carry // 計算和\n\n           → Step 11: result[i+j+1] = sum % 10 // 儲存單位\n\n           → Step 12: carry = sum / 10 // 取得進位\n\n       → Step 13: result[i] += carry // 把剩餘進位放到前一位\n\n   → Step 14: 轉換 result 陣列為字串 resStr // 建立結果字串\n\n       → Step 15: index = 0 // 初始索引\n\n       → Decision: 如果 result[index] 為 0? // 跳過前導零\n\n           Yes → Step 16: index += 1 // 移動到非零\n\n           No  → // 保持\n\n       → Step 17: 建立字串 builder = \"\" // 建立字符串\n\n       → Step 18: 從 index 到 len1+len2-1 做循環\n\n           → Step 19: builder += result[k] + '0' // 將數字轉字元\n\n       → Step 20: resStr = builder // 完成\n\n   → Step 21: 回傳 resStr // 返回結果\n\nEnd // 程式結束\n\nMake sure each line has \"虛擬碼步驟 // 解釋/說明\". Use arrows. Use \"→\" to show flow. Use \"Decision:\" lines.\n\nAlso need to use indentation? Not necessary but we can show. Use \"→\" at beginning of each step. Use \"Start\" and \"End\".\n\nWe should not output actual code. So each line: \"Start // 程式開始執行\". Then \"→ Step 1: ... // 解釋\". For decisions: \"→ Decision: ...\".\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 num1, num2 // 從使用者取得兩個字串  \n→ Decision: 如果 num1 為 \"0\" 或 num2 為 \"0\"? // 檢查是否有 0  \n  Yes → Step 2: 回傳 \"0\" // 若有任一為 0，直接返回  \n  No  → Step 3: 計算 len1 = 長度(num1), len2 = 長度(num2) // 取得兩字串長度  \n   → Step 4: 建立 result[ len1 + len2 ] 初始化為 0 // 結果陣列長度足以容納所有位數  \n   → Step 5: 對 i 從 len1-1 降至 0 迴圈 // 外層迴圈處理 num1 的每一位  \n    → Step 6: digit1 = num1[i] - '0' // 把字元轉成數字  \n    → Step 7: carry = 0 // 初始化進位  \n    → Step 8: 對 j 從 len2-1 降至 0 迴圈 // 內層迴圈處理 num2 的每一位  \n     → Step 9: digit2 = num2[j] - '0' // 把字元轉成數字  \n     → Step 10: sum = result[i + j + 1] + digit1 * digit2 + carry // 計算乘積加進位  \n     → Step 11: result[i + j + 1] = sum % 10 // 存入單位位數  \n     → Step 12: carry = sum / 10 // 取得進位  \n    → Step 13: result[i] += carry // 把最後進位放到前一位  \n   → Step 14: 初始化 index = 0 // 用於跳過前導 0  \n   → Decision: 如果 result[index] 為 0? // 判斷是否有前導 0  \n     Yes → Step 15: index += 1 // 移至第一個非 0 位  \n     No  → // 仍在同一位置  \n   → Step 16: 建立空字串 builder = \"\" // 用於拼接結果  \n   → Step 17: 從 k = index 到 k < len1 + len2 迴圈  \n    → Step 18: builder += result[k] + '0' // 把數字轉成字元加入 builder  \n   → Step 19: resStr = builder // 完成結果字串  \n   → Step 20: 回傳 resStr // 將字串輸出作為乘積  \nEnd // 程式執行結束"
    }
  ]
}