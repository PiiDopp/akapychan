{
  "run_index": 40,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 391,
  "generation_or_validation_failure_count": 48,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,5,2,6,1]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 5, 2, 6, 1]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰子，回傳結果列表。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\ndef main():\n    \"\"\"\n    讀取標準輸入的程式碼，並在本地命名空間執行。\n    \"\"\"\n    # 讀取全部輸入\n    code = sys.stdin.read()\n    if not code.strip():\n        return\n\n    # 在 globals 中提供 roll_dice 供 eval/exec 使用\n    local_namespace = {'roll_dice': roll_dice}\n    # 執行輸入的程式碼\n    exec(code, local_namespace)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for a function roll_dice(n) using random module, simulating n dice rolls, returning a list of results. The output must be in the specified format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrow → and Decision, Start, End. The function code in pseudocode. The code is for roll_dice(n). We need to include import random. Steps: Start function, Input n, Initialize empty list, Loop i from 1 to n, generate random integer 1-6, append to list, After loop, return list, End. Also maybe handle invalid n? Could add decision if n <= 0? Might keep simple. Provide virtual code lines.\n\nLet's produce. Use Start at top. Then → Step: Import random module. Then → Step: Define function roll_dice(n). Then → Step: Initialize results list. Then → Step: For i in range(1, n+1). Inside loop: → Step: roll = random.randint(1,6). → Step: Append roll. After loop: → Step: Return results. End.\n\nMake sure each line has comment after //. Use arrow and indentation for decisions? We can add Decision if n < 1? But not required. Might include to show handling of invalid input: Decision: n > 0? Yes→ proceed, No→ return empty list. Provide that. Let's output accordingly.\n\nEnsure \"Start\" and \"End\" included. Use \"→\" arrows.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: Import random module // 引入 random 模組  \n→ Step: Define function roll_dice(n) // 建立函式 roll_dice，接收參數 n  \n→ Decision: n > 0? // 檢查擲骰次數是否為正整數  \n Yes → Step: Initialize results list // 建立空列表以存放擲骰結果  \n  → Step: For i from 1 to n // 進行 n 次循環  \n    → Step: roll = random.randint(1, 6) // 產生 1~6 的隨機整數  \n    → Step: Append roll to results list // 將結果加入列表  \n    → End // 循環結束  \n  → Step: Return results list // 回傳所有擲骰結果  \n No → Step: Return empty list // 若 n 非正整數，回傳空列表  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量 func 執行所需的秒數，並回傳經過時間 (四捨五入到小數點 3 位)。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入內容，預期為一段 Python 程式碼\n    code = sys.stdin.read()\n\n    # 建立執行環境，將 measure_time 與 time 模組放入字典\n    env = {\n        \"measure_time\": measure_time,\n        \"time\": time\n    }\n\n    # 執行讀取到的程式碼，結果將直接輸出到標準輸出\n    exec(code, env)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described function: measure_time(func, *args) using time module. Steps: import time; define function; record start; call func(*args); record end; compute elapsed; round to 3 decimal places; return result. But careful: Should return result of func or elapsed? The description: \"測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)\" It likely returns elapsed time rounded to 3 decimals. Not the func result. So measure_time returns the elapsed seconds.\n\nSo we need to produce virtual code lines with arrow notation. Provide each line step with comment. Include Start, End. Possibly define measure_time function block. Provide inner steps.\n\nLet's produce:\n\nStart\n→ Step 1: Import time module // 引入 time 模組\n→ Step 2: 定義函數 measure_time(func, *args) // 建立測量時間的函式\n    → Step 3: 記錄開始時間 start = time.time() // 取得起始時間\n    → Step 4: 執行目標函式 result = func(*args) // 呼叫傳入的函式並取得結果\n    → Step 5: 記錄結束時間 end = time.time() // 取得結束時間\n    → Step 6: 計算耗時 elapsed = end - start // 計算差值為執行時間\n    → Step 7: 四捨五入到小數點 3 位 rounded = round(elapsed, 3) // 四捨五入\n    → Step 8: 回傳 rounded // 傳回耗時\n→ End // 程式結束\n\nBut we need to include the function body block properly. We might use indentation or arrow to show nested steps.\n\nWe should output lines with `→` for each step. Use \"Decision:\" for condition? Not needed.\n\nThus produce lines accordingly. Use virtual code arrow. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Import time module // 引入 time 模組\n→ Step 2: 定義函數 measure_time(func, *args) // 建立測量時間的函式\n    → Step 3: 記錄開始時間 start = time.time() // 取得起始時間\n    → Step 4: 執行目標函式 result = func(*args) // 呼叫傳入的函式並取得結果\n    → Step 5: 記錄結束時間 end = time.time() // 取得結束時間\n    → Step 6: 計算耗時 elapsed = end - start // 取得執行所需秒數\n    → Step 7: 四捨五入到小數點 3 位 rounded = round(elapsed, 3) // 進行四捨五入\n    → Step 8: 回傳 rounded // 傳回經過的秒數\nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"melon\",\"apple\",\"orange\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'melon', 'apple', 'orange', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入（若有輸入），此程式不需要實際資料，僅為符合輸入規範\n    sys.stdin.read()\n\n    # 建立並操作集合\n    fruits = {'apple', 'banana'}\n    fruits.add('orange')                     # 新增 orange\n    fruits.update(['grape', 'melon'])        # 同時新增 grape 與 melon\n    fruits.remove('banana')                  # 移除 banana\n    fruits.discard('pineapple')              # 嘗試移除不存在的元素，安全不拋錯\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with comments. Use structure with Start, End, Decision not needed but we can include. We just produce steps. Use \"→ Step X:\" etc. Provide explanation. Let's produce lines:\n\nStart\n→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增橘子\n→ Step 3: fruits.update({'grape', 'melon'}) // 同時新增葡萄與西瓜\n→ Step 4: fruits.remove('banana') // 移除香蕉\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的鳳梨，不會拋錯\n→ Step 6: output fruits // 顯示最終集合\nEnd\n\nWe must ensure format with \"虛擬碼步驟\" and comment. Use \"→\" arrow. We'll keep \"Step 1:\" etc. Use \"[空格]\" between code and comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合 fruits，包含 apple 與 banana  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 orange 到集合  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 一次新增 grape 與 melon  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 banana，若不存在將拋例外  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除 pineapple，元素不存在時不會拋錯  \n→ Step 6: output fruits // 輸出最終集合 fruits  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.76TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.76 TWD'"
        }
      ],
      "generated_code": "import requests\nimport sys\n\ndef fetch_rate():\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()\n        data = r.json()\n        return data['rates']['TWD']\n    except Exception:\n        return None\n\ndef main():\n    input_text = sys.stdin.read().strip()\n    if '更新匯率' in input_text:\n        rate = fetch_rate()\n        if rate is not None:\n            print(f'目前美元匯率：約 {rate} TWD')\n        else:\n            print('更新失敗，請檢查網路連線')\n    # 可選: 若輸入不包含「更新匯率」則不輸出任何東西\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, with arrow and explanation. Should not output actual code. Use virtual steps: Start, import modules, define function to fetch, define Tkinter UI, etc. Use Decision for errors? Probably simple.\n\nNeed to include the API call. Steps: Start, import modules, define function get_rate, use requests.get, parse JSON, get rate. Define UI: Start Tkinter, create window, label, button. Button callback calls get_rate and updates label. Mainloop. End.\n\nWe need to follow arrow syntax: \"→ Step: ...\" etc. Also \"Decision:\" maybe not needed if no decision. But we can include Decision: if requests fails? Possibly.\n\nWe should output in Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋\".\n\nLet's craft.\n\nStart // 程式開始執行\n\n→ Step 1: import requests, tkinter // 匯入 HTTP 與 GUI 模組\n\n→ Step 2: 定義函式 fetch_rate() // 用於取得匯率\n\n→ Step 3: 在 fetch_rate() 裡送出 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 呼叫 API\n\n→ Decision: 如果請求成功? // 判斷是否成功取得資料\n\n    Yes → Step 4: 解析 JSON，取出 'rates' 中的 'TWD' // 取得台幣匯率\n\n    No  → Step 5: 回傳 None，顯示錯誤訊息 // 失敗處理\n\n→ Step 6: 定義函式 update_rate() // 按鈕點擊時執行\n\n→ Step 7: 在 update_rate() 裡呼叫 fetch_rate()，若非 None，更新 label 顯示 '1 USD = X TWD' // 更新 UI\n\n→ Step 8: 初始化 tkinter 根窗口，設定標題 '美元兌台幣匯率' // 建立視窗\n\n→ Step 9: 建立 label 用於顯示匯率，初始文字為 '請按下更新' // 初始訊息\n\n→ Step 10: 建立按鈕，文字為 '更新匯率'，命令為 update_rate() // 按鈕\n\n→ Step 11: 使用 pack 或 grid 放置 label 與按鈕 // 布局\n\n→ Step 12: 呼叫 update_rate() 以顯示首次匯率 // 初始顯示\n\n→ Step 13: 執行主迴圈 root.mainloop() // 開始 GUI 事件循環\n\nEnd // 程式執行結束\n\nNeed to ensure each line starts with \"→\" except Start and End. Provide explanation after \"//\".\n\nAlso include arrow lines for decision: we can show indentation? In example, they used \"Yes →\" on same line. We can do similarly.\n\nThus produce output.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: import requests, tkinter // 匯入 HTTP 與 GUI 模組  \n→ Step 2: 定義函式 fetch_rate() // 用於取得匯率  \n→ Step 3: 在 fetch_rate() 裡送出 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 呼叫 API  \n→ Decision: 如果請求成功? // 判斷是否成功取得資料  \n  Yes → Step 4: 解析 JSON，取出 'rates' 中的 'TWD' // 取得台幣匯率  \n  No  → Step 5: 回傳 None，顯示錯誤訊息 // 失敗處理  \n→ Step 6: 定義函式 update_rate() // 按鈕點擊時執行  \n→ Step 7: 在 update_rate() 裡呼叫 fetch_rate()，若非 None，更新 label 顯示 '1 USD = X TWD' // 更新 UI  \n→ Step 8: 初始化 tkinter 根窗口，設定標題 '美元兌台幣匯率' // 建立視窗  \n→ Step 9: 建立 label 用於顯示匯率，初始文字為 '請按下更新' // 初始訊息  \n→ Step 10: 建立按鈕，文字為 '更新匯率'，命令為 update_rate() // 按鈕  \n→ Step 11: 使用 pack 或 grid 放置 label 與按鈕 // 布局  \n→ Step 12: 呼叫 update_rate() 以顯示首次匯率 // 初始顯示  \n→ Step 13: 執行主迴圈 root.mainloop() // 開始 GUI 事件循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgab96b0p.py\", line 77, in <module>\n    main()\n  File \"/tmp/tmpgab96b0p.py\", line 62, in main\n    res = obj.insert(arg[0])\n          ^^^^^^^^^^\nAttributeError: 'NoneType' object has no attribute 'insert'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        # value -> index mapping\n        self.val_to_index = {}\n        # list of current values\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        \"\"\"Insert val into set if not present.\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"Remove val from set if present.\"\"\"\n        if val not in self.val_to_index:\n            return False\n        index = self.val_to_index[val]\n        last_val = self.values[-1]\n        # Move the last element to the spot of the element to remove\n        self.values[index] = last_val\n        self.val_to_index[last_val] = index\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"Return a random element from the set.\"\"\"\n        return random.choice(self.values)\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Parse the custom input format:\n    [\"cmd1\",\"cmd2\",...], [[arg1], [arg2], ...]\n    \"\"\"\n    input_str = input_str.strip()\n    # Find the first closing bracket of the first list\n    first_close = input_str.index(']')\n    first_part = input_str[:first_close + 1]\n    second_part = input_str[first_close + 2:].strip()  # skip the comma and space\n    cmds = ast.literal_eval(first_part)\n    args = ast.literal_eval(second_part)\n    return cmds, args\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    commands, arguments = parse_input(data)\n    # Result list, with None for constructor\n    results = [None]\n    obj = None\n    for cmd, arg in zip(commands[1:], arguments[1:]):\n        if cmd == \"insert\":\n            res = obj.insert(arg[0])\n        elif cmd == \"remove\":\n            res = obj.remove(arg[0])\n        elif cmd == \"getRandom\":\n            res = obj.getRandom()\n        elif cmd == \"RandomizedSet\":\n            obj = RandomizedSet()\n            res = None\n        else:\n            res = None\n        results.append(res)\n    # Output as a JSON array\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with explanation, each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Start, End, Decision: etc. Should cover the RandomizedSet class implementation. Let's write initialization: store values in array/list and map from value to index. Insert: check map, if exists false else add to list, update map, return true. Remove: if not exists false; else get index of element to remove, swap with last element, update map for swapped element, pop last, delete from map, return true. getRandom: choose random index from list length, return element at that index. All operations O(1). Use pseudo steps.\n\nWe'll produce step-by-step pseudo-code. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 RandomizedSet 類別 // 建立類別框架  \n→ Step 2: 初始化內部資料結構  \n  → Variable: values ← 空清單 [] // 存放所有元素  \n  → Variable: indices ← 空映射 {} // 取得元素在 values 中的索引  \n→ Step 3: 定義 insert(val)  \n  → Decision: 如果 val 已存在於 indices? // 檢查元素是否已存在  \n    Yes → Return false // 已存在，無法插入  \n    No → Append val 到 values // 插入新元素  \n     → Update indices[val] ← len(values) - 1 // 記錄索引  \n     Return true // 成功插入  \n→ Step 4: 定義 remove(val)  \n  → Decision: 如果 val 不存在於 indices? // 檢查元素是否存在  \n    Yes → Return false // 無法移除  \n    No → idx ← indices[val] // 取得要移除元素的索引  \n     lastVal ← values[-1] // 取得清單最後一個元素  \n     Swap values[idx] 與 values[-1] // 交換位置，保持 O(1)  \n     Update indices[lastVal] ← idx // 更新被交換元素的索引  \n     Remove values[-1] // 刪除最後一個元素  \n     Delete indices[val] // 刪除索引映射  \n     Return true // 成功移除  \n→ Step 5: 定義 getRandom()  \n  → idx ← 隨機整數 0 到 len(values)-1 // 隨機選取索引  \n  → Return values[idx] // 回傳隨機元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_h9xno3a.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmp_h9xno3a.py\", line 27, in main\n    commands = json.loads(data[0].strip())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 54 (char 53)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.n, x % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.flipped.clear()\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = json.loads(data[0].strip())\n    args_list = json.loads(data[1].strip())\n    results = []\n    sol = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            sol = Solution(*args)\n            results.append(None)\n        elif cmd == \"flip\":\n            results.append(sol.flip())\n        elif cmd == \"reset\":\n            sol.reset()\n            results.append(None)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step-by-step explanation. We must not output real code. We need to design algorithm: basically reservoir / mapping. Use array of all indices [0..m*n-1] treat linear. Keep a map from idx to current value. When flipping, pick random r from 0 to remaining-1, get actual index from map or r itself. Then swap mapping: map[r] = map[remaining-1] else map[remaining-1] remains. Decrement remaining. Return row,col from index. Reset: clear map and set remaining to m*n.\n\nSo virtual code lines: Start, init with m,n; remaining = m*n; map empty. flip: if remaining==0 then ...; generate random r in [0,remaining-1]; get val = map.getOrDefault(r,r); then set map.put(r, map.getOrDefault(remaining-1,remaining-1)); remaining--; compute i=val/m; j=val%m; return [i,j]. reset: map.clear(); remaining=m*n.\n\nLet's output each step line: Start, Step 1: initialize variables, etc. Use Decision for reset etc. Use arrows. Provide explanations after each line.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use arrows \"→\".\n\nAlso need to include class definition? Use Step 0: Define class Solution. Might not need actual syntax.\n\nLet's produce a structured pseudo. Use indentation? Not necessary.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義 class Solution(m, n) // 初始化矩陣尺寸\n→ Step 2: 設定 remaining = m * n // 剩餘可翻轉的格子數\n→ Step 3: 建立空白映射 map = {} // 將線性索引映射到實際索引\n→ Step 4: 定義 flip() 方法 // 開始翻轉操作\n→ Decision: 如果 remaining == 0? // 檢查是否已全部翻轉\n    Yes → Step 5: return null 或拋錯 // 代表無可用格子\n    No  → Step 6: 產生隨機整數 r = random(0, remaining-1) // 選取剩餘範圍內的索引\n→ Step 7: 取得 val = map.get(r, r) // 若映射存在則取映射值，否則取 r 本身\n→ Step 8: 取得 swap_val = map.get(remaining-1, remaining-1) // 準備交換的最後一個索引\n→ Step 9: map.put(r, swap_val) // 將 r 的位置映射為 swap_val\n→ Step 10: remaining = remaining - 1 // 已翻轉一格，更新剩餘數\n→ Step 11: 計算 row = val / n // 從線性索引轉回行號\n→ Step 12: 計算 col = val % n // 從線性索引轉回列號\n→ Step 13: return [row, col] // 返回並已將此格子視為 1\n→ Step 14: 定義 reset() 方法 // 重置操作\n→ Step 15: map.clear() // 清空所有映射\n→ Step 16: remaining = m * n // 恢復剩餘格子數\n→ Step 17: End // 程式結束\n\nBut we need arrow for each line? The start line is \"Start\". Then each line maybe preceded by arrow or not? Format examples show:\n\nStart // 程式開始執行\n→ Step 1: ...\n→ Decision: ...\nYes → ...\nNo  → ...\n\nSo we can use \"→\" for each step line.\n\nFor reset we may need to start a new block? But we can include within same class.\n\nAlso we need to show \"Step 4: 定義 flip() 方法\" then \"Decision\" inside.\n\nLet's produce final output accordingly. Ensure each line ends with explanation comment. Use Chinese.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 class Solution(m, n) // 建立 Solution 類並接收矩陣尺寸  \n→ Step 2: 設定 remaining = m * n // 追蹤還能被翻轉的格子數量  \n→ Step 3: 建立空白映射 map = {} // 用來映射線性索引到實際索引，避免重複  \n→ Step 4: 定義 flip() 方法 // 開始翻轉邏輯  \n→ Decision: remaining == 0? // 檢查是否已無可翻轉的格子  \n  Yes → Step 5: return null // 所有格子已為 1，無法再翻轉  \n  No  → Step 6: 產生隨機整數 r = random(0, remaining-1) // 從剩餘範圍內隨機選取  \n→ Step 7: 取得 val = map.get(r, r) // 若 r 有映射則取映射值，否則直接用 r  \n→ Step 8: 取得 swap_val = map.get(remaining-1, remaining-1) // 準備交換最後一個可用索引  \n→ Step 9: map.put(r, swap_val) // 把 r 對應的索引設為 swap_val，確保 r 不再可用  \n→ Step 10: remaining = remaining - 1 // 已翻轉一格，更新剩餘數量  \n→ Step 11: 計算 row = val / n // 由線性索引轉回行號  \n→ Step 12: 計算 col = val % n // 由線性索引轉回列號  \n→ Step 13: return [row, col] // 返回已被翻轉的格子座標，並視為 1  \n→ Step 14: 定義 reset() 方法 // 重置邏輯  \n→ Step 15: map.clear() // 清除所有映射，恢復初始狀態  \n→ Step 16: remaining = m * n // 恢復剩餘格子數為全矩陣大小  \n→ End // 程式執行結束"
    },
    {
      "title": "Teemo Attacking",
      "source_file": "Leetcode/leetcode495.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      'Invalidinputformat'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      'Invalid input format'"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      'Invalidinputformat'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      'Invalid input format'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries, duration):\n        if not timeSeries:\n            return 0\n        total = 0\n        # 對於每一對相鄰攻擊，加入兩者間的最小值與持續時間中的較小值\n        for i in range(len(timeSeries) - 1):\n            total += min(timeSeries[i + 1] - timeSeries[i], duration)\n        # 最後一次攻擊的完整持續時間\n        total += duration\n        return total\n\ndef main():\n    # 從標準輸入讀取整個內容，預期格式類似：\n    # timeSeries = [1,4], duration = 2\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 解析輸入\n    parts = [p.strip() for p in raw_input.split(',')]\n    if len(parts) != 2:\n        print(\"Invalid input format\")\n        return\n    time_series_part = parts[0]\n    duration_part = parts[1]\n\n    # 取得 timeSeries 列表\n    try:\n        time_series_str = time_series_part.split('=')[1].strip()\n        timeSeries = ast.literal_eval(time_series_str)\n        if not isinstance(timeSeries, list):\n            raise ValueError\n    except Exception:\n        print(\"Invalid timeSeries input\")\n        return\n\n    # 取得 duration 整數\n    try:\n        duration_str = duration_part.split('=')[1].strip()\n        duration = int(duration_str)\n    except Exception:\n        print(\"Invalid duration input\")\n        return\n\n    # 計算並輸出結果\n    sol = Solution()\n    result = sol.findPoisonedDuration(timeSeries, duration)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line for solution: compute total poisoned seconds given attack times and duration. Explanation each line. We'll output as per format. Use Start, End, Decision, etc. Provide steps: initialize total=0, prev_attack=-inf. For each t in timeSeries: if t > prev_attack+duration-1 then no overlap: add duration; else add t - prev_attack (overlap). Update prev_attack. Finally return total. Let's craft lines accordingly. Each line includes comment. Use arrow. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 total_poisoned = 0 // 初始化總毒秒數  \n→ Step 2: 設定 prev_attack = -∞ // 前一次攻擊時間，初始為負無限  \n→ Step 3: 迭代 timeSeries 中的每個攻擊時刻 t // 遍歷所有攻擊  \n  → Decision: t > prev_attack + duration - 1? // 判斷此次攻擊是否與前一次毒效重疊  \n   Yes → Step 4: total_poisoned += duration // 沒重疊，加入完整持續時間  \n   No  → Step 5: total_poisoned += t - prev_attack // 有重疊，只加入差值  \n  → Step 6: prev_attack = t // 更新前一次攻擊時間  \n→ Step 7: 返回 total_poisoned // 結束並輸出總毒秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp26jk2877.py\", line 73, in <module>\n    main()\n  File \"/tmp/tmp26jk2877.py\", line 59, in main\n    instance.buildDict(args)\n    ^^^^^^^^^^^^^^^^^^\nAttributeError: 'NoneType' object has no attribute 'buildDict'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport re\nfrom collections import defaultdict\n\nclass MagicDictionary:\n    def __init__(self):\n        # patternDict maps a pattern with a wildcard '*' to the set of words that match it\n        self.patternDict = defaultdict(set)\n\n    def buildDict(self, dictionary):\n        \"\"\"Builds the internal data structure from a list of distinct words.\"\"\"\n        self.patternDict.clear()\n        for word in dictionary:\n            for i in range(len(word)):\n                pattern = word[:i] + '*' + word[i+1:]\n                self.patternDict[pattern].add(word)\n\n    def search(self, searchWord):\n        \"\"\"Returns True if exactly one character can be changed to match a word in the dictionary.\"\"\"\n        for i in range(len(searchWord)):\n            pattern = searchWord[:i] + '*' + searchWord[i+1:]\n            if pattern in self.patternDict:\n                words = self.patternDict[pattern]\n                # If there is more than one word for this pattern or the only word is not the original\n                if len(words) > 1 or (len(words) == 1 and next(iter(words)) != searchWord):\n                    return True\n        return False\n\ndef parse_input(s):\n    \"\"\"\n    Parse the input string into two lists: commands and args.\n    The input format is: [cmd1, cmd2, ...], [arg1, arg2, ...]\n    \"\"\"\n    s = s.strip()\n    # Split at the top-level comma that separates the two lists\n    split_regex = re.compile(r'\\]\\s*,\\s*\\[')\n    parts = split_regex.split(s, maxsplit=1)\n    if len(parts) != 2:\n        raise ValueError(\"Input format is incorrect.\")\n    list1_str = parts[0] + ']'\n    list2_str = '[' + parts[1]\n    commands = ast.literal_eval(list1_str)\n    args = ast.literal_eval(list2_str)\n    return commands, args\n\ndef main():\n    input_data = sys.stdin.read()\n    if not input_data.strip():\n        return\n    commands, args_list = parse_input(input_data)\n\n    results = [None]  # constructor produces null\n    instance = None\n\n    for cmd, args in zip(commands[1:], args_list[1:]):\n        if cmd == \"buildDict\":\n            instance.buildDict(args)\n            results.append(None)\n        elif cmd == \"search\":\n            res = instance.search(args)\n            results.append(res)\n        else:\n            # For safety, handle unexpected commands\n            results.append(None)\n\n    # Convert Python None/True/False to JSON null/true/false\n    json_output = json.dumps(results)\n    print(json_output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanations. Not actual code, but pseudo. Use arrows and structure. We need to design data structure, methods, algorithm: build dict and search.\n\nProbably using a Trie or hash map grouping by length. For each word in dict, we can precompute patterns by replacing each char with wildcard, store in map pattern->list of words. Then search: for each position, create pattern with wildcard and check if any word differs by exactly one char. Must avoid matching same word? But requirement: can change exactly one char to match any word. So if searchWord exactly matches a word, we must ensure there is at least one other word with one char diff. In typical LeetCode solution, we can check patterns. When building, store map from pattern to set of words. Then search: for each pattern, if map contains pattern and either size>1 or the word in set not equal to searchWord. So produce pseudocode accordingly.\n\nWe produce steps:\n\nStart\n→ Step 1: 定義 MagicDictionary 類別\n→ Step 2: 建立空的字典 mapPattern\n→ Step 3: 定義建構子\n→ Step 4: buildDict\n→ etc.\n\nWe'll produce virtual steps with explanation.\n\nLet's craft.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義 MagicDictionary 類別 // 建立整體結構\n    → Step 1.1: 宣告 Map<string, Set<string>> patternDict // 用來存放「萬用字元」對應的所有單字\n→ Step 2: 定義建構子 MagicDictionary() // 初始化空字典\n    → Step 2.1: patternDict ← 空集合 // 無任何已建字元\n→ Step 3: 定義方法 buildDict(String[] dictionary) // 建立資料結構\n    → Step 3.1: 清空 patternDict // 重新設定\n    → Decision: 若 dictionary 為空? // 若沒有單字則直接返回\n        Yes → Return\n        No  →\n    → Step 3.2: For each word in dictionary\n        → Step 3.2.1: For i from 0 to word.length-1\n            → Step 3.2.1.1: pattern ← word[0..i-1] + '*' + word[i+1..] // 以 '*' 替換第 i 個字元\n            → Step 3.2.1.2: 若 patternDict 沒有 pattern → patternDict[pattern] ← 新 Set\n            → Step 3.2.1.3: patternDict[pattern].add(word) // 加入對應單字\n    → Step 3.3: Return // 建構完成\n→ Step 4: 定義方法 search(String searchWord) // 判斷是否能改變正好一個字元匹配字典\n    → Decision: 若 searchWord 為空? // 空字串無法改變字元\n        Yes → Return false\n        No  →\n    → Step 4.1: For i from 0 to searchWord.length-1\n        → Step 4.1.1: pattern ← searchWord[0..i-1] + '*' + searchWord[i+1..] // 產生萬用字元模式\n        → Decision: patternDict 是否包含 pattern? // 有沒有對應的字元組合\n            Yes →\n                → Step 4.1.1.1: words ← patternDict[pattern] // 取得所有符合模式的單字\n                → Decision: words.size > 1 或 words 中沒有 searchWord? // 確保改一個字元後不等於原字串\n                    Yes → Return true // 有符合條件的單字\n                    No  → // 仍需檢查下一個位置\n            No  → // 這個位置不符合任何字典字元，檢查下一個位置\n    → Step 4.2: Return false // 所有位置皆不符合，返回假\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe7cd__8o.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmpe7cd__8o.py\", line 38, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpe7cd__8o.py\", line 12, in __init__\n    self.lookup[(word[:i], word[j:])] = weight\n    ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    def __init__(self, words):\n        # 建立字典，key 為 (prefix, suffix)，value 為最大的索引\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):          # 所有前綴長度\n                for j in range(L + 1):      # 所有後綴長度\n                    self.lookup[(word[:i], word[j:])] = weight\n\n    def f(self, prefix, suffix):\n        # 直接查詢字典，若不存在回傳 -1\n        return self.lookup.get((prefix, suffix), -1)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入分成兩部分：words 列表和 (prefix, suffix) 列表\n    split_idx = data.find('],')\n    if split_idx == -1:\n        # 若輸入格式不符合預期直接返回\n        return\n    first_part = data[:split_idx + 1]          # words 列表\n    second_part = data[split_idx + 2:].strip() # [prefix, suffix]\n\n    words = ast.literal_eval(first_part)\n    pref_suff = ast.literal_eval(second_part)\n    if not isinstance(pref_suff, (list, tuple)) or len(pref_suff) != 2:\n        print(-1)\n        return\n    pref, suff = pref_suff\n\n    wf = WordFilter(words)\n    result = wf.f(pref, suff)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode that implements WordFilter with prefix/suffix search. We will produce line by line with explanation. Should be conceptual. We'll need data structures: Trie for prefixes and suffixes, maybe store indices. Approach: Build a combined trie mapping prefix+suffix via hashing: For each word, for each possible prefix and suffix combine to key and store max index. But typical solution uses Trie of suffix + '#' + prefix. Use dictionary mapping of combined string to index.\n\nBut pseudocode: We'll implement WordFilter with constructor and function f.\n\nLet's design:\n\n- Use a hashmap: key string -> int (max index)\n- For each word index i:\n  - For each prefix length p from 0 to len(word):\n    - prefix = word[0:p]\n    - For each suffix length s from 0 to len(word):\n      - suffix = word[len(word)-s:]\n      - key = prefix + '#' + suffix\n      - dict[key] = i (since we go in order, i increases, so later index override)\n- f(pref, suff): return dict.get(pref+'#'+suff, -1)\n\nBut this O(n^3) for words length up to 10? Might be okay but okay.\n\nAlternatively use trie.\n\nWe'll present pseudocode:\n\nStart\n→ Step: Define class WordFilter\n    → Step: WordFilter(words)\n        → For i from 0 to words.length-1\n            → word = words[i]\n            → For pLen from 0 to word.length\n                → prefix = substring(word, 0, pLen)\n                → For sLen from 0 to word.length\n                    → suffix = substring(word, word.length - sLen, sLen)\n                    → key = prefix + '#' + suffix\n                    → dict[key] = i\n    → Step: f(pref, suff)\n        → key = pref + '#' + suff\n        → If key in dict\n            → Return dict[key]\n        → Else\n            → Return -1\n\nAdd explanations.\n\nEnsure each line uses arrow etc.\n\nLet's produce.\n\nAlso need to include Start and End.\n\nAlso include Decision? Not needed but can.\n\nWill produce like:\n\nStart\n→ Step: Define class WordFilter // 定義 WordFilter 類別\n    → Step: WordFilter(words) // 建構子，輸入單詞陣列\n        → For i from 0 to words.length-1 // 遍歷每個單詞\n            → word = words[i] // 取得當前單詞\n            → For pLen from 0 to word.length // 產生所有前綴\n                → prefix = substring(word, 0, pLen) // 取前綴\n                → For sLen from 0 to word.length // 產生所有後綴\n                    → suffix = substring(word, word.length - sLen, sLen) // 取後綴\n                    → key = prefix + '#' + suffix // 組合鍵\n                    → dict[key] = i // 存入或覆蓋，保留最大索引\n        → End // 建構子結束\n    → Step: f(pref, suff) // 查詢方法\n        → key = pref + '#' + suff // 組合查詢鍵\n        → Decision: key 是否存在於 dict? // 判斷是否有符合條件\n            → Yes → Return dict[key] // 有，回傳最大索引\n            → No  → Return -1 // 無，回傳 -1\nEnd\n\nNeed to format as specified.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義 WordFilter 類別 // 建立類別框架  \n  → Step: WordFilter(words) // 建構子，接收單詞陣列  \n    → For i from 0 to words.length-1 // 遍歷每個單詞  \n      → word = words[i] // 取得第 i 個單詞  \n      → For pLen from 0 to word.length // 產生所有前綴  \n        → prefix = substring(word, 0, pLen) // 取前綴  \n        → For sLen from 0 to word.length // 產生所有後綴  \n          → suffix = substring(word, word.length - sLen, sLen) // 取後綴  \n          → key = prefix + '#' + suffix // 組合鍵以避免衝突  \n          → dict[key] = i // 存入或覆寫，保留最大的索引值  \n      → End // 內層 for 結束  \n    → End // 內層 for 結束  \n  → End // 建構子結束  \n  → Step: f(pref, suff) // 查詢方法  \n    → key = pref + '#' + suff // 組合查詢鍵  \n    → Decision: key 是否存在於 dict? // 判斷是否有符合條件  \n      Yes → Return dict[key] // 有，回傳最大索引  \n      No  → Return -1 // 無，回傳 -1  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\",\"(())()\"]'"
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()()\",\"(a())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"\n        Remove the minimum number of invalid parentheses to make the string valid.\n        Return all unique valid strings.\n        \"\"\"\n        # Count the number of left and right parentheses that must be removed\n        left_rem, right_rem = 0, 0\n        for ch in s:\n            if ch == '(':\n                left_rem += 1\n            elif ch == ')':\n                if left_rem == 0:\n                    right_rem += 1\n                else:\n                    left_rem -= 1\n\n        res = set()\n\n        def dfs(index, left_count, right_count, left_rem, right_rem, path):\n            \"\"\"\n            Backtracking helper:\n            - index: current position in s\n            - left_count/right_count: counts of '(' and ')' kept so far\n            - left_rem/right_rem: remaining parentheses we can still delete\n            - path: list of characters forming the current candidate string\n            \"\"\"\n            if index == len(s):\n                # All characters processed; string is valid if no deletions left\n                if left_rem == 0 and right_rem == 0:\n                    res.add(''.join(path))\n                return\n\n            ch = s[index]\n\n            if ch == '(':\n                # Option 1: delete this '(' if we still have deletions left\n                if left_rem > 0:\n                    dfs(index + 1, left_count, right_count, left_rem - 1, right_rem, path)\n                # Option 2: keep this '('\n                dfs(index + 1, left_count + 1, right_count, left_rem, right_rem, path + [ch])\n\n            elif ch == ')':\n                # Option 1: delete this ')' if we still have deletions left\n                if right_rem > 0:\n                    dfs(index + 1, left_count, right_count, left_rem, right_rem - 1, path)\n                # Option 2: keep this ')' only if there is a matching '('\n                if left_count > right_count:\n                    dfs(index + 1, left_count, right_count + 1, left_rem, right_rem, path + [ch])\n\n            else:\n                # Regular character, always keep it\n                dfs(index + 1, left_count, right_count, left_rem, right_rem, path + [ch])\n\n        dfs(0, 0, 0, left_rem, right_rem, [])\n        return list(res)\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    Parse the raw input string to extract the parentheses string.\n    Handles formats like:\n        s = \"()())()\"\n    or simply:\n        \"()())()\"\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return ''\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    # Remove surrounding quotes if present\n    if (expr.startswith('\"') and expr.endswith('\"')) or (expr.startswith(\"'\") and expr.endswith(\"'\")):\n        expr = expr[1:-1]\n    return expr\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    results = solution.removeInvalidParentheses(s)\n    # Output in JSON-like format without spaces to match examples\n    print(json.dumps(results, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for removing minimum parentheses. Use BFS or DFS with pruning. We'll produce generic steps: Count mismatched left/right, then use DFS/backtracking to remove. The virtual code must be step-by-step, each line with explanation. Use arrows, Start, Decision, End. We must include only steps, no real code. We need to describe the algorithm. Should mention we use recursion to generate all results. Use set to avoid duplicates.\n\nLet's produce:\n\nStart\n→ Step 1: Count left_removals and right_removals by traversing s // find minimal removals\n→ Decision: If left_removals == 0 and right_removals == 0? // string already valid\n    Yes → Step 2: Return list containing s // return as only result\n    No  → Step 3: Initialize result set // to store unique valid strings\n→ Step 4: Define recursive function DFS(index, left_count, right_count, left_rem, right_rem, path) // process characters\n→   Decision: If index == len(s)? // finished traversal\n        Yes → Decision: If left_rem == 0 and right_rem == 0? // valid after removals\n                Yes → Step 5: Add joined path to result set // store valid string\n                No  → No action // invalid\n        No  → Decision: If s[index] is '('? // handle left parenthesis\n                // Try to remove it if left_rem > 0\n                Decision: If left_rem > 0? // removal path\n                    Yes → Step 6: DFS(index+1, left_count, right_count, left_rem-1, right_rem, path) // skip '('\n                No  → No action\n                // Keep '('\n                Step 7: DFS(index+1, left_count+1, right_count, left_rem, right_rem, path + '(') // add '('\n            No → Decision: If s[index] is ')'?\n                // Try to remove it if right_rem > 0\n                Decision: If right_rem > 0? \n                    Yes → Step 8: DFS(index+1, left_count, right_count, left_rem, right_rem-1, path) // skip ')'\n                No  → No action\n                // Keep ')' only if left_count > right_count\n                Decision: If left_count > right_count?\n                    Yes → Step 9: DFS(index+1, left_count, right_count+1, left_rem, right_rem, path + ')') // add ')'\n                No  → No action\n            No → // character is letter\n                Step 10: DFS(index+1, left_count, right_count, left_rem, right_rem, path + s[index]) // keep letter\n→ Step 11: Call DFS(0,0,0,left_removals,right_removals, '') // start recursion\n→ Step 12: Return list from result set // convert set to list\nEnd\n\nMake sure to add comments. Use virtual arrows. Provide each line. Ensure formatting exactly. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Count left_removals and right_removals by traversing s // 找出需要刪除的最少左括號和右括號數量  \n→ Decision: If left_removals == 0 and right_removals == 0? // 字串已經有效  \n  Yes → Step 2: Return list containing s // 直接回傳原字串作為唯一結果  \n  No  → Step 3: Initialize result set // 用集合存放唯一有效字串  \n→ Step 4: Define recursive function DFS(index, left_count, right_count, left_rem, right_rem, path) // 以遞迴方式探索所有可能的刪除方式  \n→   Decision: If index == len(s)? // 已處理完所有字符  \n   Yes → Decision: If left_rem == 0 and right_rem == 0? // 刪除數量符合最少要求  \n     Yes → Step 5: Add joined path to result set // 儲存有效結果  \n     No  → No action // 結果不符合條件，忽略  \n   No  → Decision: If s[index] is '('? // 處理左括號  \n     Decision: If left_rem > 0? // 可以刪除左括號  \n       Yes → Step 6: DFS(index+1, left_count, right_count, left_rem-1, right_rem, path) // 跳過此左括號  \n       No  → No action  \n     Step 7: DFS(index+1, left_count+1, right_count, left_rem, right_rem, path + '(') // 保留左括號  \n   No → Decision: If s[index] is ')'? // 處理右括號  \n     Decision: If right_rem > 0? // 可以刪除右括號  \n       Yes → Step 8: DFS(index+1, left_count, right_count, left_rem, right_rem-1, path) // 跳過此右括號  \n       No  → No action  \n     Decision: If left_count > right_count? // 保留右括號前需有左括號配對  \n       Yes → Step 9: DFS(index+1, left_count, right_count+1, left_rem, right_rem, path + ')') // 保留右括號  \n       No  → No action  \n   No → // 字符是字母  \n    Step 10: DFS(index+1, left_count, right_count, left_rem, right_rem, path + s[index]) // 直接保留字母  \n→ Step 11: Call DFS(0,0,0,left_removals,right_removals, '') // 從頭開始遞迴探索  \n→ Step 12: Return list from result set // 將集合轉成列表作為輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Find K Pairs with Smallest Sums",
      "source_file": "Leetcode/leetcode373.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjhutr9jh.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpjhutr9jh.py\", line 37, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n    ^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp27rx7mhd.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmp27rx7mhd.py\", line 37, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    nums1 = [1,1,2], nums2 = [1,2,3], k = 2\n    ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport heapq\n\nclass Solution:\n    def kSmallestPairs(self, nums1, nums2, k):\n        \"\"\"Return k pairs with the smallest sums from two sorted arrays.\"\"\"\n        if not nums1 or not nums2 or k <= 0:\n            return []\n\n        # Min-heap to store tuples of (sum, index in nums1, index in nums2)\n        heap = []\n        res = []\n\n        # Initialize heap with pairs (nums1[i], nums2[0]) for the first min(k, len(nums1)) elements\n        for i in range(min(k, len(nums1))):\n            heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n\n        # Extract the smallest pairs up to k times\n        while heap and len(res) < k:\n            current_sum, i, j = heapq.heappop(heap)\n            res.append([nums1[i], nums2[j]])\n\n            # If there's a next element in nums2 for the same i, push the new pair\n            if j + 1 < len(nums2):\n                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n        return res\n\n\ndef main():\n    # Read the entire input (expected in the format: nums1 = [...], nums2 = [...], k = ...)\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # Execute the input to define nums1, nums2, and k\n    exec(data, globals())\n\n    # Compute and output the result\n    solution = Solution()\n    result = solution.kSmallestPairs(nums1, nums2, k)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: given two sorted arrays and k, return k pairs with smallest sums. The typical solution uses min-heap (priority queue). We'll produce steps:\n\n- Start\n- Input arrays and k\n- Initialize min-heap with first pair of each element from nums1 with first element of nums2? Actually typical algorithm: push (nums1[i], nums2[0], i, 0) for i up to min(k, len(nums1)) because each pair's sum. Then pop k times. Each time we output pair and push next pair from same i with j+1 if j+1 < len(nums2). We need to avoid duplicates: use heap of tuples (sum, i, j). So steps:\n\n- Determine m,n\n- For i in 0..min(k, m)-1: push (nums1[i]+nums2[0], i, 0)\n- Result list []\n- While len(result) < k and heap not empty:\n    - pop (sum, i, j)\n    - append (nums1[i], nums2[j]) to result\n    - if j+1 < n: push (nums1[i]+nums2[j+1], i, j+1)\n- Output result\n- End\n\nWe need to write virtual code line by line with arrow syntax. Provide explanation comments.\n\nLet's produce lines like:\n\nStart // 程式開始\n\n→ Step 1: 讀取 nums1, nums2, k // 從輸入取得兩個有序陣列和 k\n\n→ Step 2: 計算 m = len(nums1), n = len(nums2) // 取得陣列長度\n\n→ Step 3: 初始化 MinHeap // 建立最小堆\n\n→ Step 4: for i in 0 .. min(k, m)-1: push (nums1[i]+nums2[0], i, 0) // 將每個 nums1[i] 與 nums2[0] 的和入堆\n\n→ Step 5: 建立空列表 result // 儲存答案\n\n→ Decision: 目前 result 長度 < k 且堆不空? // 檢查是否還需取對\n\n    Yes → Step 6: pop (sum, i, j) from MinHeap // 取最小和\n\n    Yes → Step 7: append (nums1[i], nums2[j]) to result // 加入答案\n\n    Yes → Decision: j+1 < n? // 是否還有下一個 nums2\n\n        Yes → Step 8: push (nums1[i]+nums2[j+1], i, j+1) // 將下一個與同一 i 的組合入堆\n\n        No → // 無下一個，跳過\n\n    No → // 堆已空，結束\n\nEnd // 程式結束\n\nWe need to follow format: \"Step X:\" but not required maybe; we can include step number optional. Each line must include virtual code + // comment.\n\nMake sure to use arrow \"→\" before each step, and indentation for nested decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 讀取 nums1, nums2, k // 取得兩個有序陣列及目標數量\n\n→ Step 2: 計算 m = len(nums1), n = len(nums2) // 獲得陣列長度\n\n→ Step 3: 初始化 MinHeap // 建立最小堆以儲存 (sum, i, j)\n\n→ Step 4: for i in 0 .. min(k, m)-1: push (nums1[i]+nums2[0], i, 0) // 將每個 nums1[i] 與 nums2[0] 的和入堆\n\n→ Step 5: 建立空列表 result // 用於儲存最小和的對\n\n→ Decision: result 長度 < k 且 MinHeap 不空? // 檢查是否還需要取得對\n\n    Yes → Step 6: pop (sum, i, j) from MinHeap // 取出堆中最小和\n\n    Yes → Step 7: append (nums1[i], nums2[j]) to result // 加入答案\n\n    Yes → Decision: j+1 < n? // 同一 i 下是否還有下一個 j\n\n        Yes → Step 8: push (nums1[i]+nums2[j+1], i, j+1) // 將下一個組合入堆\n\n        No  → // 沒有下一個 j，略過\n\n    No  → // 堆已空，跳出循環\n\nEnd // 程式結束"
    },
    {
      "title": "Jewels and Stones",
      "source_file": "Leetcode/leetcode771.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "jewels = \"aA\", stones = \"aAAbbbb\"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def numJewelsInStones(self, J: str, S: str) -> int:\n        \"\"\"\n        計算石頭中珠寶的數量。\n        1. 把 J 轉成集合，利用 O(1) 的查詢時間。\n        2. 遍歷 S，若字符屬於集合則累加。\n        \"\"\"\n        jewels = set(J)\n        return sum(1 for stone in S if stone in jewels)\n\ndef strip_quotes(s: str) -> str:\n    \"\"\"若字符串被單引號或雙引號包圍，則移除它們。\"\"\"\n    if len(s) >= 2 and s[0] == s[-1] and s[0] in {\"'\", '\"'}:\n        return s[1:-1]\n    return s\n\ndef main() -> None:\n    \"\"\"\n    讀取輸入：\n        - 若有兩行，第一行是 jewels，第二行是 stones。\n        - 若只有一行，且包含空格，則第一個單詞為 jewels，第二個單詞為 stones。\n    輸出：珠寶數量的整數。\n    \"\"\"\n    data = [line.strip() for line in sys.stdin.read().splitlines() if line.strip()]\n    if not data:\n        return\n\n    if len(data) >= 2:\n        jewels_raw, stones_raw = data[0], data[1]\n    else:\n        parts = data[0].split()\n        if len(parts) >= 2:\n            jewels_raw, stones_raw = parts[0], parts[1]\n        else:\n            # 只有一個輸入，無法判斷，直接結束\n            return\n\n    jewels = strip_quotes(jewels_raw)\n    stones = strip_quotes(stones_raw)\n\n    sol = Solution()\n    result = sol.numJewelsInStones(jewels, stones)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, following format. Each line: virtual step then space then comment //. Use arrow symbols. Should not output real code. Provide algorithm: Start, maybe initialize count = 0, iterate over stones, check if char in jewels set, increment. Finally output count. Use Decision: if char in jewels? etc. Also need to create jewels set from string. Maybe use hash table. We'll include steps: Start, Step 1: create set of jewels. Step 2: initialize count. Step 3: for each stone in stones: Decision: stone in jewels? Yes -> increment. End. Output count.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 jewels 轉換成集合 JewelSet // 用集合快速判斷是否為珠寶  \n→ Step 2: 設定計數器 count = 0 // 用於累計珠寶數量  \n→ Step 3: 對 stones 中的每個字元 stone 進行迭代 // 遍歷所有石頭  \n    → Decision: stone 是否存在於 JewelSet? // 檢查此石頭是否為珠寶  \n        Yes → Step 4: count = count + 1 // 若是珠寶，計數器加一  \n        No  → // 不是珠寶，忽略  \n→ Step 5: 輸出 count // 顯示珠寶總數  \nEnd // 程式執行結束"
    },
    {
      "title": "leetcode846_problem_1",
      "source_file": "Leetcode/leetcode846.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
          "expected_output": "True",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_nd04xkf.py\", line 23, in <module>\n    eval(input_str, {}, local_vars)\n  File \"<string>\", line 1\n    hand = [1,2,3,6,2,3,4,7,8], groupSize = 3\n         ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "hand = [1,2,3,4,5], groupSize = 4",
          "expected_output": "False",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7pi_k9fi.py\", line 23, in <module>\n    eval(input_str, {}, local_vars)\n  File \"<string>\", line 1\n    hand = [1,2,3,4,5], groupSize = 4\n         ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def isNStraightHand(self, hand, groupSize):\n        if len(hand) % groupSize != 0:\n            return False\n        count = Counter(hand)\n        for card in sorted(count):\n            freq = count[card]\n            if freq > 0:\n                for i in range(card, card + groupSize):\n                    if count.get(i, 0) < freq:\n                        return False\n                    count[i] -= freq\n        return True\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，預期格式類似: \"hand = [1,2,3,6,2,3,4,7,8], groupSize = 3\"\n    input_str = sys.stdin.read().strip()\n    local_vars = {}\n    # 以安全方式評估輸入，避免使用全域變量\n    eval(input_str, {}, local_vars)\n    hand = local_vars.get(\"hand\", [])\n    groupSize = local_vars.get(\"groupSize\", 0)\n\n    solution = Solution()\n    result = solution.isNStraightHand(hand, groupSize)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Problem: determine if array can be partitioned into groups of size groupSize with consecutive values. Standard problem: \"Hand of Straights\" Leetcode 846. Approach: Count frequencies with map; then iterate sorted keys; for each value, if count > 0, try to subtract count from next groupSize consecutive values. If any missing or count mismatch, return false. Complexity O(n log n). Provide virtual steps.\n\nWe should output line by line virtual code with explanations. Use arrows etc. Provide Start, End, Decision, etc.\n\nLet's produce steps:\n\nStart\n→ Step 1: 建立空字典 freq // 统计每张牌的出现次数\n→ For each card in hand: freq[card]++ // 填充频率表\n\n→ Step 2: 对 freq 键进行升序排序 // 需要按牌值升序处理\n→ 变量 sortedKeys = 排序后的 freq.keys()\n\n→ Step 3: 迭代 sortedKeys:\n    → Decision: freq[key] == 0? // 已经被分配完的牌\n        Yes → 跳过 // 不再处理\n        No  → 取 count = freq[key] // 当前牌的剩余数量\n            → Decision: count > 0? (必然 true)\n                // 用 count 作为组内每张牌的数量\n                → 迭代 i from 0 to groupSize-1:\n                    → currentVal = key + i\n                    → Decision: freq[currentVal] >= count? // 检查后续牌足够\n                        Yes → freq[currentVal] -= count // 减去使用的牌\n                        No  → Return false // 不能组装成功\n→ Step 4: 所有牌已处理完毕 → Return true\n\nAdd End.\n\nWe need arrow representation: \"→\". For decisions: \"Decision:\" with indentation.\n\nLet's format each line with `虛擬碼步驟 // 解釋`. Use the arrow notation.\n\nMake sure each line ends with comment.\n\nLet's produce final output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: freq ← 空字典 // 建立字典用於統計每張牌出現的次數\n→ For card in hand: freq[card] ← freq.get(card, 0) + 1 // 填入頻率表\n→ Step 2: sortedKeys ← 排序(freq.keys()) // 按牌值升序排序\n→ Step 3: 對於 key 在 sortedKeys 中:\n    → Decision: freq[key] == 0? // 這張牌已經被分配完\n        Yes → 跳過 // 不再處理此鍵\n        No  → count ← freq[key] // 取出該牌剩餘的數量\n            → Decision: count > 0? // 確保 count 有值（必然成立）\n                Yes → 迭代 i 從 0 到 groupSize - 1:\n                    → currentVal ← key + i // 下一張需要連續的牌\n                    → Decision: freq.get(currentVal, 0) >= count? // 檢查是否足夠\n                        Yes → freq[currentVal] ← freq[currentVal] - count // 減去已使用的牌\n                        No  → Return false // 無法組成連續組，直接返回\n→ Step 4: 所有牌已成功分配完畢\n→ Return true // 可以按需求重新排列\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Top K Frequent Words",
      "source_file": "Leetcode/leetcode692.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2",
          "expected_output": "[\"i\",\"love\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpd8v4pvib.py\", line 31, in <module>\n    main()\n  File \"/tmp/tmpd8v4pvib.py\", line 21, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4",
          "expected_output": "[\"the\",\"is\",\"sunny\",\"day\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvyums1cb.py\", line 31, in <module>\n    main()\n  File \"/tmp/tmpvyums1cb.py\", line 21, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def topKFrequent(self, words, k):\n        # Count frequency of each word\n        count = Counter(words)\n        # Sort by decreasing frequency, then lexicographically\n        sorted_words = sorted(count.items(), key=lambda x: (-x[1], x[0]))\n        # Return only the first k words\n        return [word for word, freq in sorted_words[:k]]\n\ndef main():\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Execute the input string to get 'words' and 'k' variables\n    local_vars = {}\n    exec(data, {}, local_vars)\n    words = local_vars.get('words', [])\n    k = local_vars.get('k', 0)\n    # Compute the result\n    solution = Solution()\n    result = solution.topKFrequent(words, k)\n    # Print the result as a JSON array to match the expected format\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations, following format.\n\nThe user wants virtual code for given problem: array of strings words and integer k, return k most frequent strings, sorted by frequency descending, tie by lex order ascending.\n\nWe need step by step pseudo code. Use Start, End, Decision, etc.\n\nNeed to output only virtual code lines, each line \"虛擬碼步驟 // 解釋/說明\". Use arrows → etc.\n\nWe must produce for each step. Let's craft algorithm:\n\n1. Start.\n2. Count frequencies: map string->int.\n3. Convert map entries to list of pairs (word, count).\n4. Sort list by comparator: first by count descending, then word ascending lex.\n5. Take first k words from sorted list.\n6. Return list of words.\n\nWe can also mention decision for each step? We can incorporate sorting algorithm.\n\nUse virtual code.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 建立空哈希表 freq // 用來統計每個字的出現次數\n\n→ Step 2: 對 words 陣列中的每個字 word:\n        freq[word] += 1 // 對應字頻數加一\n\n→ Step 3: 建立列表 freqList，將每個 (word, count) 依序加入 // 準備排序\n\n→ Decision: 如果 freqList 為空? // 防止空陣列\n    Yes → Return 空列表 // 無字可處理\n    No  → Continue\n\n→ Step 4: 以自訂比較器對 freqList 進行排序\n        // 主要依 count 降序；相同 count 時 word 升序\n\n→ Step 5: 建立結果列表 result\n→ Step 6: 取前 k 個元素自 freqList，加入 result\n\n→ Decision: 如果 k 大於 freqList 長度?\n    Yes → k = freqList長度 // 調整 k 為可用數量\n\n→ Step 7: 從 result 取出 word 欄位並回傳\n\nEnd // 程式結束\n\nBut need to maintain virtual code structure: each line starting with → or Start, End.\n\nAlso we can embed decision indent. For clarity, we can use nested indentation with spaces? They didn't specify but we can include indentation for decision branches.\n\nLet's format accordingly:\n\nStart // 程式開始執行\n→ Step 1: 建立空哈希表 freq // 用來統計每個字的出現次數\n→ Step 2: 對 words 陣列中的每個字 word:\n    freq[word] += 1 // 對應字頻數加一\n→ Step 3: 建立列表 freqList，將每個 (word, count) 依序加入 // 準備排序\n→ Decision: 如果 freqList 為空?\n    Yes → Return 空列表 // 無字可處理\n    No  → 進行下一步\n→ Step 4: 以自訂比較器對 freqList 進行排序\n        // 主要依 count 降序；相同 count 時 word 升序\n→ Step 5: 建立結果列表 result\n→ Step 6: 取前 k 個元素自 freqList，加入 result\n→ Decision: 如果 k 大於 freqList 長度?\n    Yes → k = freqList長度 // 調整 k 為可用數量\n    No  → 直接使用 k\n→ Step 7: 從 result 取出 word 欄位並回傳\nEnd // 程式執行結束\n\nNeed to ensure each line has virtual code step + space + // explanation.\n\nAlso need to avoid actual code.\n\nMake sure to use arrow for steps: \"→ Step X: ...\"\n\nDecision lines: \"→ Decision: ...\"\n\nYes and No branches: \"Yes → ...\" \"No → ...\"\n\nWe need to include step numbers? Not required but fine.\n\nWe should ensure each line has one line. For branches we can indent but still part of same line? The sample shows indentation but each line still separate. For branches, they used:\n\nYes → Step 2: ... // explanation\nNo  → Decision: ...\n\nWe should follow that style.\n\nAlso in the loops, we used \"→ Step 2: 對 words 陣列中的每個字 word:\" then next line \"freq[word] += 1\". That second line should be indented under Step 2? They didn't mention but it's okay.\n\nWe need to maintain \"逐行\" meaning each line is separate.\n\nWe also need to provide explanation after each line.\n\nThus produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空哈希表 freq // 用來統計每個字的出現次數\n→ Step 2: 對 words 陣列中的每個字 word:\n    freq[word] += 1 // 對應字頻數加一\n→ Step 3: 建立列表 freqList，將每個 (word, count) 依序加入 // 準備排序\n→ Decision: 如果 freqList 為空?\n    Yes → Return 空列表 // 無字可處理\n    No  → 進行下一步\n→ Step 4: 以自訂比較器對 freqList 進行排序\n        // 主要依 count 降序；相同 count 時 word 升序\n→ Step 5: 建立結果列表 result\n→ Step 6: 取前 k 個元素自 freqList，加入 result\n→ Decision: 如果 k 大於 freqList 長度?\n    Yes → k = freqList長度 // 調整 k 為可用數量\n    No  → 直接使用 k\n→ Step 7: 從 result 取出 word 欄位並回傳\nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Reverse Polish Notation",
      "source_file": "Leetcode/leetcode150.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
          "expected_output": "9",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuobycq51.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpuobycq51.py\", line 48, in main\n    tokens = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n           ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvi_hq8ef.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpvi_hq8ef.py\", line 48, in main\n    tokens = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\n           ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
          "expected_output": "22",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5bwa3ajt.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmp5bwa3ajt.py\", line 48, in main\n    tokens = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\n           ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def evalRPN(self, tokens):\n        \"\"\"\n        Evaluate a Reverse Polish Notation expression.\n\n        Parameters:\n        tokens (list of str): RPN tokens, each token is either an operator\n                              '+', '-', '*', '/' or an integer in string form.\n\n        Returns:\n        int: The integer result of the expression.\n        \"\"\"\n        stack = []\n\n        for token in tokens:\n            if token in '+-*/':          # operator\n                b = stack.pop()          # right operand\n                a = stack.pop()          # left operand\n\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                else:  # token == '/'\n                    # Division that truncates toward zero\n                    stack.append(int(a / b))\n            else:                        # operand\n                stack.append(int(token))\n\n        return stack[0]\n\n\ndef main():\n    \"\"\"\n    Read RPN tokens from standard input, evaluate the expression,\n    and print the result. The input is expected to be a Python\n    list literal, e.g. '[\"2\",\"1\",\"+\",\"3\",\"*\"]'.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse the input string into a Python list\n    tokens = ast.literal_eval(data)\n\n    solution = Solution()\n    result = solution.evalRPN(tokens)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode for evaluating RPN. Provide each line with \"虛擬碼步驟\" and comment. Use arrow and decision structure. Need to be in Traditional Chinese. Use Start, End, Decision. No actual code. Provide step-by-step.\n\nLet's craft algorithm:\n\nStart\n→ Step 1: Initialize stack as empty // 用於存放中間數值\n→ Step 2: For each token in tokens: // 遍歷所有令牌\n   → Decision: token is operator? // 檢查是否為運算符\n       Yes → Step 3: Pop right operand from stack // 右操作數\n           → Step 4: Pop left operand from stack // 左操作數\n           → Step 5: Compute result based on operator\n           → Step 6: Push result onto stack // 把計算結果放回堆疊\n       No  → Step 7: Convert token to integer // 轉成整數\n           → Step 8: Push integer onto stack // 放入堆疊\n→ Step 9: After loop, stack top is final result // 最終結果在堆疊頂\n→ Step 10: Return stack.pop() // 返回結果\nEnd\n\nWe need to include decision branches inside loops? Use indentation.\n\nUse 虛擬碼箭頭 as per example. Provide Chinese explanation after //.\n\nLet's craft with proper indentation: Use spaces. The example shows indentation under decision with spaces and tabs.\n\nWe'll produce each line. Use arrow \"→\". For decision lines use \"Decision:\" and \"Yes →\", \"No →\".\n\nWe'll need to ensure each line includes \"虛擬碼步驟\" text? The example uses plain text like \"Step 1: ...\". It's okay.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空堆疊 stack // 用於存放中間計算結果  \n→ Step 2: 遍歷 tokens 中的每一個 token // 逐個處理 RPN 表達式  \n  Decision: token 是否為運算符? // 判斷 token 是否為 '+', '-', '*', '/'  \n   Yes → Step 3: 從 stack 彈出右操作數 right // 右邊操作數  \n    Step 4: 從 stack 彈出左操作數 left // 左邊操作數  \n    Step 5: 根據 token 執行對應運算：  \n     如果 token 為 '+'，result = left + right  \n     如果 token 為 '-'，result = left - right  \n     如果 token 為 '*'，result = left * right  \n     如果 token 為 '/'，result = int(left / right) // 以零為截斷方向  \n    Step 6: 把 result 推回 stack // 將計算結果放回堆疊  \n   No → Step 7: 把 token 轉成整數 value // token 為數字時轉換  \n    Step 8: 把 value 推進 stack // 存入堆疊  \n→ Step 9: 循環結束後，stack 的唯一元素即為最終結果 // RPN 計算完成  \n→ Step 10: 返回 stack.pop() // 將結果返回給呼叫者  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[0,1],[1,0],[2,3],[4,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[0, 1], [1, 0], [2, 3], [4, 2]]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\ndef palindrome_pairs(words):\n    rev_index = {word[::-1]: i for i, word in enumerate(words)}\n    result = []\n\n    for i, word in enumerate(words):\n        l = len(word)\n        for j in range(l + 1):\n            prefix, suffix = word[:j], word[j:]\n\n            # Case 1: prefix is a palindrome and suffix reversed exists\n            if is_palindrome(prefix) and suffix in rev_index:\n                j_idx = rev_index[suffix]\n                if j_idx != i:\n                    result.append([i, j_idx])\n\n            # Case 2: suffix is a palindrome and prefix reversed exists\n            # Avoid duplicate check when j == l (suffix is empty)\n            if j != l and is_palindrome(suffix) and prefix in rev_index:\n                j_idx = rev_index[prefix]\n                if j_idx != i:\n                    result.append([j_idx, i])\n\n    return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list after 'words ='\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n    list_part = list_part.strip()\n    try:\n        words = ast.literal_eval(list_part)\n    except Exception:\n        # If parsing fails, assume the entire input is the list\n        words = ast.literal_eval(data)\n    pairs = palindrome_pairs(words)\n    print(pairs)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for algorithm: find all palindrome pairs with linear complexity sum of lengths. Use hash map of reversed words. Typical solution: for each word, for each split, check if prefix is palindrome and suffix reversed exists. Complexity O(n * L^2) worst but with constraints? Usually acceptable. But they want O(sum of lengths). There's known algorithm using Trie. But produce virtual code steps.\n\nWe will produce steps: Build Trie of reversed words. For each word, traverse Trie while checking palindrome suffix. Also handle word equal to reversed.\n\nWe need step-by-step. Use virtual code arrows. Let's craft.\n\nWe must explain each line concisely.\n\nLet's create steps:\n\nStart\n→ Build Trie of reversed words with storing indices and list of palindrome suffix indices\n→ For each word index i:\n    → Set node=root\n    → For each char in word from end to start? We traverse reversed? Let's detail:\n    -> While traversing, if node has palindromeIndices list, for each j in that list, if j != i then add pair (i,j)\n    -> Move to child of current char\n    -> If child null break\n    -> After loop, check if node.wordIndex != -1 and node.wordIndex != i => pair (i, node.wordIndex)\n    -> Also for palindrome suffix of current word (if entire word is palindrome) -> handle with empty string.\nEnd\n\nWe need step for building Trie: for each word, reverse it, insert into Trie, at each node if remaining prefix is palindrome, add index to node.palindromeSuffixIndices.\n\nOk.\n\nWe will output line by line.\n\nLet's produce.\n\nWe must include explanations.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行\n→ BuildTrie() // 建立一個 Trie，用於儲存所有單字的反向字串\n→ Decision: 若 words 為空? // 檢查輸入是否為空陣列\n    Yes → End // 若為空，直接結束，因為不存在任何組合\n    No  → Continue // 進一步執行後續步驟\n→ For each word in words with index i: // 逐一處理每個單字\n    → InsertIntoTrie(words[i], i) // 把單字反轉後插入 Trie，並在各節點記錄能形成回文的子字串索引\n→ For each word in words with index i: // 再次遍歷，搜尋符合條件的對\n    → Set node ← root // 重新從 Trie 根節點開始\n    → For each character c in words[i] 從首字元到尾字元: // 依照單字順序向 Trie 前進\n        → Decision: node has palindromeSuffixIndices? // 檢查目前節點是否記錄了可形成回文的後續單字索引\n            Yes → For each j in node.palindromeSuffixIndices: // 逐一處理這些索引\n                → Decision: j ≠ i? // 確保不是同一個單字\n                    Yes → AddPair(i, j) // 加入 (i, j) 到結果\n                    No  → Continue // 跳過自身\n            No  → Continue // 沒有可用索引，繼續\n        → Decision: node has child for c? // 該字元在 Trie 中是否有子節點\n            Yes → node ← node.child[c] // 前進到下一節點\n            No  → Break // 無法繼續，結束此單字的搜尋\n    → Decision: node.wordIndex ≠ -1 且 node.wordIndex ≠ i? // 檢查是否在 Trie 中遇到完整反向字串\n        Yes → AddPair(i, node.wordIndex) // 加入 (i, node.wordIndex) 到結果\n        No  → Continue // 不符合條件，繼續下一個單字\n→ End // 程式執行結束\n\n// ---------- 子程序說明 ----------\n→ BuildTrie() // 初始化 Trie\n    → Create root node\n    → For each word with index idx in words:\n        → reverseWord ← Reverse(words[idx]) // 取得單字的反向字串\n        → Set node ← root\n        → For each character c in reverseWord:\n            → If node.child[c]不存在則建立\n            → node ← node.child[c]\n            → Decision: Remaining prefix of reverseWord after c is palindrome?\n                Yes → node.palindromeSuffixIndices.add(idx) // 若此時後綴能成回文，記錄索引\n                No  → Continue\n        → node.wordIndex ← idx // 標記此節點代表完整單字\n        → node.palindromeSuffixIndices.add(idx) // 整個單字也可以成回文，記錄自身\n→ InsertIntoTrie(word, idx) // 本程序即為 BuildTrie 的插入步驟，已在 BuildTrie 中完成\n→ AddPair(a, b) // 把 (a, b) 存入結果列表\n    → results.add([a, b]) // 直觀加入結果\n\n// 本虛擬碼以線性時間完成，因為每個字串只被遍歷一次進入 Trie，並在搜尋階段也只按字長走一次路徑。"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Generate all permutations of the list `nums` using backtracking.\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # If we've fixed all positions, record the current permutation\n            if start == len(nums):\n                res.append(nums[:])  # make a copy\n                return\n            # Try each element as the next position\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # swap to fix nums[start]\n                backtrack(start + 1)                         # recurse\n                nums[start], nums[i] = nums[i], nums[start]  # backtrack (swap back)\n\n        backtrack(0)\n        return res\n\ndef main():\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list part after '=' if present\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = data\n\n    # Safely evaluate the list of integers\n    try:\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        print(\"[]\")\n        return\n\n    # Ensure the input is a list of integers\n    if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums):\n        print(\"[]\")\n        return\n\n    # Compute permutations\n    sol = Solution()\n    perms = sol.permute(nums)\n\n    # Format output without spaces as shown in examples\n    output = '[' + ','.join('[' + ','.join(str(x) for x in perm) + ']' for perm in perms) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all permutations of an array of distinct integers. Provide step-by-step with arrows, start, decisions, etc. No actual code. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Include recursion/backtracking steps. Also maybe a stack or path. Provide lines:\n\nStart // start\n→ Initialize result list // ...\n→ Define backtrack(currentPermutation, remaining) // recursion function\n→ Decision: if remaining empty? // base case\nYes → Add currentPermutation to result // store\nNo → For each num in remaining:\n    → Decision: choose num? // pick\n    → Action: add num to currentPermutation; remove from remaining\n    → Recursively call backtrack\n    → Undo: remove num from currentPermutation; add back to remaining\nEnd\n\nWe should reflect structure. Use indent or arrow? The format example uses indentation with spaces. We can mimic:\n\nStart // ...\n→ Step 1: 初始化 result 列表 // ...\n→ Step 2: 定義遞迴函數 backtrack(perm, remaining) // ...\n→ Decision: 若 remaining 為空? // ...\n    Yes → Step 3: 把 perm 加入 result // ...\n    No  → For each num in remaining:\n        → Decision: 選取 num? // ...\n        → Step 4: 把 num 加到 perm 並從 remaining 刪除 // ...\n        → Step 5: 呼叫 backtrack(perm, remaining) // ...\n        → Step 6: 回溯：把 num 從 perm 移除並還原到 remaining // ...\nEnd\n\nMake sure each line has one step. The backtracking steps within loop maybe need separate lines. Use arrow with spaces. Use indentation for decision branches. Provide concise explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空列表 // 用於存放所有排列結果\n→ Step 2: 定義遞迴函數 backtrack(perm, remaining) // perm 為目前已選取的元素，remaining 為剩餘可選元素\n→ Decision: 如果 remaining 為空? // 判斷是否已完成排列\n    Yes → Step 3: 把 perm 加入 result // 完整排列已生成，加入結果集\n    No  → For each num 在 remaining: // 逐一嘗試剩餘元素作為下一個位置\n        → Decision: 選取 num? // 確定要把 num 加到目前排列中\n        → Step 4: 把 num 加入 perm 並從 remaining 移除 // 建立新的子狀態\n        → Step 5: 呼叫 backtrack(perm, remaining) // 進一步遞迴處理\n        → Step 6: 回溯：把 num 從 perm 移除並還原到 remaining // 取消選擇，恢復原狀以嘗試其他選項\nEnd // 程式執行結束，result 為所有可能的排列集合"
    },
    {
      "title": "Coin Change",
      "source_file": "Leetcode/leetcode322.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpngasnzkj.py\", line 43, in <module>\n    coins, amount = parse_input(input_data)\n                    ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpngasnzkj.py\", line 27, in parse_input\n    amount_part = parts[1].split('=', 1)[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def coinChange(self, coins, amount):\n        # 初始化 dp 陣列，dp[i] 表示湊成金額 i 所需最少硬幣數\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n\n        return dp[amount] if dp[amount] != float('inf') else -1\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入，支援兩種格式：\n    1. 單行：'coins = [1,2,5], amount = 11'\n    2. 兩行：第一行為 'coins = [1,2,5]'，第二行為 'amount = 11'\n    \"\"\"\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) == 1 and 'coins' in lines[0] and 'amount' in lines[0]:\n        # 單行格式\n        parts = lines[0].split(',')\n        coins_part = parts[0].split('=', 1)[1].strip()\n        amount_part = parts[1].split('=', 1)[1].strip()\n        coins = ast.literal_eval(coins_part)\n        amount = int(amount_part)\n    elif len(lines) >= 2:\n        # 兩行格式\n        coins_part = lines[0].split('=', 1)[1].strip()\n        amount_part = lines[1].split('=', 1)[1].strip()\n        coins = ast.literal_eval(coins_part)\n        amount = int(amount_part)\n    else:\n        # 無效輸入\n        raise ValueError(\"無法解析輸入\")\n    return coins, amount\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    coins, amount = parse_input(input_data)\n    solution = Solution()\n    result = solution.coinChange(coins, amount)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code (like pseudocode steps) to solve coin change minimal number of coins. The requirement: \"逐行產生虛擬碼\" and after each line add explanation. Use arrow notation. Use Start, End, Decision. Provide each line with code step and comment. Should not output actual code, but pseudo steps. Use dynamic programming approach: array dp[amount+1] initialized to large value except dp[0]=0. Loop amount from 1 to target; for each coin, if coin <= i, dp[i] = min(dp[i], dp[i-coin]+1). After fill, return dp[amount] if < INF else -1. Need to output steps line by line.\n\nShould we include loops and decisions? Yes.\n\nWe need to present as \"虛擬碼步驟\" + \" // 解釋\". For loops, use \"Loop: i from 0 to amount\" etc. For decision, \"Decision: If dp[i] < INF?\" etc.\n\nLet's craft.\n\nStart\n→ Step 1: Initialize dp array of size amount+1 with Infinity // 代表最小硬幣數\n→ Step 2: Set dp[0] = 0 // 零金額需要零硬幣\n→ Loop: i from 1 to amount // 計算每個金額的最小硬幣數\n    → Loop: each coin in coins // 檢查每種硬幣\n        → Decision: If coin ≤ i? // 僅考慮可用硬幣\n            → Step: newCount = dp[i-coin] + 1 // 加一枚硬幣\n            → Decision: If newCount < dp[i]? // 更新更少的硬幣數\n                → Step: dp[i] = newCount // 存入更小值\n→ Decision: If dp[amount] == Infinity? // 不能組成金額\n    → Step: return -1 // 無法達成\n    → Step: return dp[amount] // 返回最小硬幣數\nEnd\n\nWe need to output each line as separate line.\n\nLet's format with arrow \"→\" and indentation. Use \"Decision:\" lines with Yes/No? But we can keep simple \"Decision:\".\n\nBetter to include arrow indent.\n\nWe need to maintain the formatting: \"虛擬碼步驟\" + \" // 解釋\". For loops, maybe \"Loop: ...\" not \"→\".\n\nUse arrow for each step.\n\nWe can indent lines with tab or spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 dp 陣列長度為 amount+1，所有元素設為 Infinity // 代表目前尚未找到最小硬幣數  \n→ Step 2: 設定 dp[0] = 0 // 金額為零不需要任何硬幣  \n→ Loop: i 從 1 到 amount // 逐一計算每個金額的最小硬幣數  \n    → Loop: 取 coins 中每一枚硬幣 coin // 檢查所有可能的硬幣  \n        → Decision: 如果 coin ≤ i? // 只考慮可用的硬幣  \n            → Step: newCount = dp[i-coin] + 1 // 用一枚硬幣再加上一個已計算好的子金額  \n            → Decision: 如果 newCount < dp[i]? // 是否比目前已知的更少  \n                → Step: dp[i] = newCount // 更新 dp[i] 為更小的硬幣數  \n→ Decision: 如果 dp[amount] == Infinity? // 無法組成目標金額  \n    → Step: 回傳 -1 // 代表無解  \n    → Step: 回傳 dp[amount] // 返回最小硬幣數  \nEnd // 程式執行結束"
    },
    {
      "title": "Best Time to Buy and Sell Stock III",
      "source_file": "Leetcode/leetcode123.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "prices = [3,3,5,0,0,3,1,4]",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '9'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '9'"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '5'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '5'"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '7'\n--- (Raw) ---\nRaw Expected: '0'\nRaw Got:      '7'"
        }
      ],
      "generated_code": "import sys\n\ndef max_profit_two_transactions(prices):\n    \"\"\"\n    计算最多两笔交易能获得的最大利润。\n    采用四个变量维护状态：\n    - buy1: 第一次买入的最小花费（负值）\n    - sell1: 第一次卖出的最大利润\n    - buy2: 第二次买入的最小花费（已扣除第一次卖出的利润）\n    - sell2: 第二次卖出的最大利润\n    \"\"\"\n    if not prices:\n        return 0\n\n    buy1 = sell1 = buy2 = sell2 = 0\n\n    for price in prices:\n        # 计算第一次买入（最大负数）\n        buy1 = max(buy1, -price)\n        # 计算第一次卖出（最大利润）\n        sell1 = max(sell1, buy1 + price)\n        # 计算第二次买入（考虑第一次卖出的利润）\n        buy2 = max(buy2, sell1 - price)\n        # 计算第二次卖出（最大利润）\n        sell2 = max(sell2, buy2 + price)\n\n    return sell2\n\nif __name__ == \"__main__\":\n    # 从标准输入读取完整内容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析输入格式，例如： \"prices = [3,3,5,0,0,3,1,4]\"\n    local_vars = {}\n    try:\n        exec(raw_input, {}, local_vars)\n    except Exception:\n        # 若解析失败，尝试直接解析列表\n        try:\n            import ast\n            prices = ast.literal_eval(raw_input)\n        except Exception:\n            print(0)\n            sys.exit()\n    else:\n        prices = local_vars.get('prices', [])\n\n    # 计算并输出结果\n    result = max_profit_two_transactions(prices)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: maximum profit with at most two transactions, cannot hold multiple stocks. Classic DP: dp[i][k][0/1] or using four variables: first_buy, first_sell, second_buy, second_sell. We will produce simple algorithm: iterate days, update four variables: first_buy = min(price, first_buy), first_sell = max(first_sell, price - first_buy), second_buy = min(second_buy, price - first_sell), second_sell = max(second_sell, price - second_buy). At end return second_sell.\n\nWe need to write virtual code step by step.\n\nLet's produce:\n\nStart // program start\n→ Step 1: Initialize first_buy, second_buy to +∞, first_sell, second_sell to 0 // set initial states\n→ Step 2: For each price in prices array // iterate over days\n    → Step 3: first_buy = min(first_buy, price) // best cost for first buy\n    → Step 4: first_sell = max(first_sell, price - first_buy) // best profit after first sell\n    → Step 5: second_buy = min(second_buy, price - first_sell) // best cost for second buy considering profit from first sell\n    → Step 6: second_sell = max(second_sell, price - second_buy) // best profit after second sell\n→ Step 7: Return second_sell // maximum profit after at most two transactions\nEnd // program ends\n\nBut need each line with arrow and comment.\n\nAlso include Decision? Might not need decision.\n\nWe'll just use arrow.\n\nLet's craft final output with correct formatting.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 first_buy, second_buy 為正無窮大，first_sell, second_sell 為 0 // 設定初始狀態，準備追蹤買賣  \n→ Step 2: 遍歷每個價格 price in prices // 逐日處理  \n  → Step 3: first_buy = min(first_buy, price) // 更新第一筆買入的最低成本  \n  → Step 4: first_sell = max(first_sell, price - first_buy) // 更新第一筆賣出的最高利潤  \n  → Step 5: second_buy = min(second_buy, price - first_sell) // 更新第二筆買入時的有效成本（扣除已得利潤）  \n  → Step 6: second_sell = max(second_sell, price - second_buy) // 更新第二筆賣出的最高利潤  \n→ Step 7: 回傳 second_sell // 結果：最多兩筆交易能得到的最大利潤  \nEnd // 程式執行結束"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcc8jp6bq.py\", line 118, in <module>\n    main()\n  File \"/tmp/tmpcc8jp6bq.py\", line 97, in main\n    ops, args = parse_input(raw)\n                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpcc8jp6bq.py\", line 91, in parse_input\n    ops = ast.literal_eval(ops_str)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"LRUCache\",\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass LRUCache:\n    \"\"\"\n    O(1) LRU cache using OrderedDict.\n    \"\"\"\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}          # key -> node\n        self.head = None         # Most recently used\n        self.tail = None         # Least recently used\n        self.size = 0\n\n    def _remove(self, node):\n        \"\"\"Remove node from the doubly linked list.\"\"\"\n        prev, nxt = node.prev, node.next\n        prev.next = nxt\n        nxt.prev = prev\n\n    def _add_to_front(self, node):\n        \"\"\"Add node right after head sentinel.\"\"\"\n        node.next = self.head\n        node.prev = None\n        if self.head:\n            self.head.prev = node\n        self.head = node\n        if self.tail is None:\n            self.tail = node\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        # Move to front\n        if node is not self.head:\n            self._remove(node)\n            self._add_to_front(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            if node is not self.head:\n                self._remove(node)\n                self._add_to_front(node)\n        else:\n            node = _Node(key, value)\n            self.cache[key] = node\n            self._add_to_front(node)\n            self.size += 1\n            if self.size > self.capacity:\n                # Evict tail\n                lru = self.tail\n                self._remove(lru)\n                del self.cache[lru.key]\n                self.size -= 1\n\nclass _Node:\n    \"\"\"Internal node for the doubly linked list.\"\"\"\n    __slots__ = ('key', 'val', 'prev', 'next')\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input that can be either two separate lines or a single line\n    containing two lists separated by '],['.\n    Returns a tuple of two lists: operations and arguments.\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], []\n\n    if '\\n' in data:\n        ops_str, args_str = data.splitlines()\n    else:\n        idx = data.find('],[')\n        if idx != -1:\n            ops_str = data[:idx+1]\n            args_str = data[idx+2:]\n        else:\n            # fallback: split on space\n            parts = data.split()\n            ops_str, args_str = parts[0], parts[1]\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\ndef main():\n    raw = sys.stdin.read()\n    ops, args = parse_input(raw)\n\n    cache = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"LRUCache\":\n            cache = LRUCache(arg[0])\n            results.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            val = cache.get(arg[0])\n            results.append(val)\n\n    # Convert None to 'null' for output formatting\n    out = '[' + ', '.join(['null' if v is None else str(v) for v in results]) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, not actual code, explaining each line. The user wants design of LRUCache with O(1) operations. Virtual code should describe data structures: hashmap for key->node, doubly linked list for order, capacity, head tail dummy nodes. Steps for get: if not exist return -1, else move node to head, return value. Put: if exist update value, move to head. else create node, add to head, add to map, increment size, if size > capacity remove tail->prev node, delete from map, decrement size. Also functions for remove node, add to head, move to head. And initialization. Should be stepwise, with decisions.\n\nWe output line by line: Start, then steps. Use \"→\" to indent.\n\nLet's craft. We need to describe each virtual step, with short explanation. Must follow format. Use virtual arrows.\n\nOk.\n\nWe'll produce:\n\nStart\n→ Step: 初始化空的哈希表 map // 用於快速查找 key 的節點\n→ Step: 初始化空的雙向鏈表，創建頭尾哨兵 dummyHead, dummyTail // 用於 O(1) 插入、刪除\n→ Step: 將 dummyHead 的 next 指向 dummyTail, dummyTail 的 prev 指向 dummyHead // 完成鏈表連接\n→ Step: 儲存容量 capacity, 以及當前大小 size=0 // 控制容量\n\nThen get:\n→ Step: get(key) // 呼叫獲取\n→ Decision: key 是否存在於 map?\n    Yes → Step: node = map[key] // 取得節點\n    Yes → Step: moveToHead(node) // 將節點移到最近使用位置\n    Yes → Step: return node.value // 返回值\n    No  → Step: return -1 // 未找到\n\nmoveToHead:\n→ Step: remove(node) // 刪除節點\n→ Step: addToHead(node) // 插入\n\nremove:\n→ Step: prev = node.prev, next = node.next // 取得相鄰節點\n→ Step: prev.next = next\n→ Step: next.prev = prev // 斷開節點\n\naddToHead:\n→ Step: node.next = dummyHead.next\n→ Step: node.prev = dummyHead\n→ Step: dummyHead.next.prev = node\n→ Step: dummyHead.next = node // 將節點插到頭部\n\nevict:\n→ Decision: size > capacity?\n    Yes → Step: lru = dummyTail.prev // 最舊節點\n    Yes → Step: remove(lru)\n    Yes → Step: delete map[lru.key] // 從哈希表移除\n    Yes → Step: size = size - 1\n\nput:\n→ Step: put(key, value)\n→ Decision: key 是否存在於 map?\n    Yes → Step: node = map[key]\n    Yes → Step: node.value = value\n    Yes → Step: moveToHead(node)\n    No  → Step: node = new Node(key, value) // 創建節點\n    No  → Step: map[key] = node\n    No  → Step: addToHead(node)\n    No  → Step: size = size + 1\n    No  → Decision: size > capacity? // 超過容量則 evict\n        Yes → Step: lru = dummyTail.prev\n        Yes → Step: remove(lru)\n        Yes → Step: delete map[lru.key]\n        Yes → Step: size = size - 1\n\nEnd\n\nNeed to ensure each line has arrow or indentation.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step: 初始化哈希表 map // 快速根據 key 取得節點\n→ Step: 創建雙向鏈表的兩個哨兵節點 dummyHead, dummyTail // 用於 O(1) 插入和刪除\n→ Step: dummyHead.next ← dummyTail ; dummyTail.prev ← dummyHead // 完成鏈表初始連接\n→ Step: 設定 capacity ← given_capacity ; size ← 0 // 儲存容量與當前元素數量\n\n// --------- get(key) ----------\n→ Step: get(key) // 呼叫獲取操作\n→ Decision: key 是否存在於 map?\n    Yes → Step: node ← map[key] // 取得對應節點\n    Yes → Step: moveToHead(node) // 把節點移到最近使用位置\n    Yes → Step: return node.value // 回傳對應值\n    No  → Step: return -1 // key 不存在，返回 -1\n\n// --------- moveToHead(node) ----------\n→ Step: remove(node) // 先把節點從鏈表中刪除\n→ Step: addToHead(node) // 再插入到頭部\n\n// --------- remove(node) ----------\n→ Step: prev ← node.prev ; next ← node.next // 取得相鄰節點\n→ Step: prev.next ← next ; next.prev ← prev // 斷開節點，更新相鄰節點指向\n\n// --------- addToHead(node) ----------\n→ Step: node.next ← dummyHead.next\n→ Step: node.prev ← dummyHead\n→ Step: dummyHead.next.prev ← node\n→ Step: dummyHead.next ← node // 完成節點插入\n\n// --------- put(key, value) ----------\n→ Step: put(key, value) // 呼叫新增/更新操作\n→ Decision: key 是否存在於 map?\n    Yes → Step: node ← map[key]\n    Yes → Step: node.value ← value // 更新值\n    Yes → Step: moveToHead(node) // 更新使用順序\n    No  → Step: node ← new Node(key, value) // 創建新節點\n    No  → Step: map[key] ← node\n    No  → Step: addToHead(node)\n    No  → Step: size ← size + 1\n    No  → Decision: size > capacity? // 檢查是否超出容量\n        Yes → Step: lru ← dummyTail.prev // 找到最舊節點\n        Yes → Step: remove(lru) // 刪除鏈表中的節點\n        Yes → Step: delete map[lru.key] // 從哈希表中移除對應鍵\n        Yes → Step: size ← size - 1 // 更新大小\n\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Minimum Index Sum of Two Lists",
      "source_file": "Leetcode/leetcode599.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]",
          "expected_output": "[\"Shogun\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpq8ftvh2z.py\", line 44, in <module>\n    main()\n  File \"/tmp/tmpq8ftvh2z.py\", line 34, in main\n    data = ast.literal_eval(dict_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {\"list1\" = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], \"list2\" = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]}\n     ^^^^^^^\nSyntaxError: cannot assign to literal here. Maybe you meant '==' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]",
          "expected_output": "[\"Shogun\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjl6b4l52.py\", line 44, in <module>\n    main()\n  File \"/tmp/tmpjl6b4l52.py\", line 34, in main\n    data = ast.literal_eval(dict_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {\"list1\" = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], \"list2\" = [\"KFC\",\"Shogun\",\"Burger King\"]}\n     ^^^^^^^\nSyntaxError: cannot assign to literal here. Maybe you meant '==' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]",
          "expected_output": "[\"sad\",\"happy\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy1u85d36.py\", line 44, in <module>\n    main()\n  File \"/tmp/tmpy1u85d36.py\", line 34, in main\n    data = ast.literal_eval(dict_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {\"list1\" = [\"happy\",\"sad\",\"good\"], \"list2\" = [\"sad\",\"happy\",\"good\"]}\n     ^^^^^^^\nSyntaxError: cannot assign to literal here. Maybe you meant '==' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findRestaurant(self, list1, list2):\n        # 建立 list1 的索引映射\n        index_map = {name: i for i, name in enumerate(list1)}\n        min_sum = float('inf')\n        res = []\n\n        # 遍歷 list2，尋找共同字串並計算索引和\n        for j, name in enumerate(list2):\n            if name in index_map:\n                total = j + index_map[name]\n                if total < min_sum:\n                    min_sum = total\n                    res = [name]\n                elif total == min_sum:\n                    res.append(name)\n        return res\n\ndef main():\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 轉換成字典格式再使用 literal_eval\n    # 把 \"list1 =\" 變成 \"\\\"list1\\\":\"\n    # 把 \"list2 =\" 變成 \"\\\"list2\\\":\"\n    transformed = raw.replace('list1', '\"list1\"').replace('list2', '\"list2\"')\n    # 這樣可以直接把兩個鍵值對包在大括號內\n    dict_str = '{' + transformed + '}'\n    data = ast.literal_eval(dict_str)\n\n    list1 = data['list1']\n    list2 = data['list2']\n\n    sol = Solution()\n    result = sol.findRestaurant(list1, list2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code. Use Start, End, Decision etc. We have to list steps: create hash map from list1 to index, iterate list2, compute index sum, track min, collect results. Provide line-by-line with explanation. Use arrows →. Ensure each line ends with // explanation. Let's craft. Use typical pseudo code structure: Start, Step 1: Build map, Step 2: Initialize min sum, list result, Step 3: Iterate over list2, Step 4: Check if in map, compute sum, compare, etc. Use Decision blocks. Provide any order. Let's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 map1 為空映射 // 用於儲存 list1 中每個字串及其索引\n→ Step 2: 從 i = 0 到 list1.length - 1 做\n    → map1[list1[i]] = i // 將字串映射到其索引\n→ Step 3: 初始化 minSum 為無限大 // 追蹤目前找到的最小索引和\n→ Step 4: 初始化 answer 為空列表 // 存放所有最小索引和的共同字串\n→ Step 5: 從 j = 0 到 list2.length - 1 做\n    → Decision: 如果 list2[j] 存在於 map1? // 檢查是否為共同字串\n        Yes → Step 6: 計算 sum = j + map1[list2[j]] // 取得兩個列表的索引和\n        → Decision: sum < minSum? // 判斷是否為新的最小值\n            Yes → Step 7: minSum = sum // 更新最小索引和\n            → Step 8: answer = [list2[j]] // 重新建立答案列表，只保留當前字串\n            No  → Decision: sum == minSum? // 判斷是否等於目前最小值\n                Yes → Step 9: answer.append(list2[j]) // 加入當前字串到答案\n                No  → // 什麼也不做，因為 sum 大於最小值\n→ End // 程式執行結束，答案在 answer 中，可直接返回或輸出"
    },
    {
      "title": "Stickers to Spell Word",
      "source_file": "Leetcode/leetcode691.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2kui4cxx.py\", line 78, in <module>\n    main()\n  File \"/tmp/tmp2kui4cxx.py\", line 74, in main\n    result = solution.minStickers(stickers, target)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2kui4cxx.py\", line 40, in minStickers\n    return dp(target)\n           ^^^^^^^^^^\n  File \"/tmp/tmp2kui4cxx.py\", line 15, in dp\n    key = tuple(sorted(remain.items()))\n                       ^^^^^^^^^^^^\nAttributeError: 'str' object has no attribute 'items'"
        },
        {
          "example_index": 1,
          "input": "stickers = [\"notice\",\"possible\"], target = \"basicbasic\"",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7oa0yq3y.py\", line 78, in <module>\n    main()\n  File \"/tmp/tmp7oa0yq3y.py\", line 74, in main\n    result = solution.minStickers(stickers, target)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7oa0yq3y.py\", line 40, in minStickers\n    return dp(target)\n           ^^^^^^^^^^\n  File \"/tmp/tmp7oa0yq3y.py\", line 15, in dp\n    key = tuple(sorted(remain.items()))\n                       ^^^^^^^^^^^^\nAttributeError: 'str' object has no attribute 'items'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def minStickers(self, stickers, target):\n        # Convert each sticker to a Counter for quick letter count access\n        sticker_counters = [Counter(s) for s in stickers]\n        memo = {}\n\n        def dp(remain):\n            if not remain:\n                return 0\n            key = tuple(sorted(remain.items()))\n            if key in memo:\n                return memo[key]\n\n            # Count letters remaining\n            remain_counter = Counter(remain)\n            best = float('inf')\n            for sticker in sticker_counters:\n                # Skip stickers that don't contain the first needed letter\n                if not (remain_counter & sticker):\n                    continue\n                # Build new remaining string after using this sticker\n                new_remaining = []\n                for ch, cnt in remain_counter.items():\n                    remaining = cnt - sticker.get(ch, 0)\n                    if remaining > 0:\n                        new_remaining.append(ch * remaining)\n                new_remain_str = ''.join(new_remaining)\n                sub = dp(new_remain_str)\n                if sub != -1:\n                    best = min(best, sub + 1)\n\n            memo[key] = -1 if best == float('inf') else best\n            return memo[key]\n\n        return dp(target)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Try to parse the input format: stickers = [...], target = \"...\"\n    match = re.search(\n        r'stickers\\s*=\\s*(\\[[^\\]]*?\\])\\s*,\\s*target\\s*=\\s*([\"\\'])(.*?)\\2',\n        data, re.DOTALL\n    )\n    if match:\n        stickers_str = match.group(1)\n        target_str = match.group(3)\n        stickers = ast.literal_eval(stickers_str)\n        target = target_str\n    else:\n        # Fallback: assume first line is the stickers list, second line is the target\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            stickers = ast.literal_eval(lines[0].strip())\n            target = lines[1].strip()\n        else:\n            # If format is not recognized, try eval of the whole string\n            try:\n                parsed = eval(data, {})\n                stickers = parsed.get('stickers', [])\n                target = parsed.get('target', '')\n            except Exception:\n                stickers = []\n                target = ''\n\n    solution = Solution()\n    result = solution.minStickers(stickers, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for solving this problem: given array stickers (list of strings), target string. Need min number of stickers to form target by cutting letters and rearranging. Unlimited copies of each sticker. Classic problem \"Stickers to Spell Word\" using DP over subsets or BFS over states. We should produce a virtual code with decision arrows. Use approach: count frequency of target, then use DP with memoization (bitmask or dictionary) for remaining string. Use greedy? Actually typical solution uses DP with recursion over bitmask of target indices or using string remaining.\n\nSimplify: we can convert target to frequency array of 26 letters. Then each sticker has frequency. The problem reduces to covering target freq using stickers with unlimited use; objective minimize number. Use BFS over remaining freq states, using mask representation for positions in target string? Since target length maybe small because only two words concatenated, but could be up to ~20? Not given. We'll propose DP with memoization using bitmask of target indices (since target length <= 15? Not sure). But to keep pseudocode simpler, we can use DFS with memoization on remaining string.\n\nWe'll produce pseudocode:\n\nStart\n→ Define function minStickers(stickers, target) // main\n→ Build stickerCounts array of 26 counts for each sticker\n→ Build targetCounts array of 26 counts\n→ Memo = empty map\n→ Define recursive function dfs(remainingCounts) // array of 26 ints\n    → If all counts zero → return 0\n    → key = string of remainingCounts (joined)\n    → If key in Memo → return Memo[key]\n    → res = Infinity\n    → For each sticker in stickerCounts\n        → If sticker can reduce remainingCounts (any count >0)\n            → newRemaining = remainingCounts minus sticker (clamped to 0)\n            → sub = dfs(newRemaining)\n            → If sub != -1 → res = min(res, sub + 1)\n    → Memo[key] = (res==Infinity? -1: res)\n    → Return Memo[key]\n→ Return dfs(targetCounts)\n\nWe'll include decisions and loops. Provide line-by-line pseudocode.\n\nWe must output virtual code lines each with explanation. Use arrows: Start, End, Decision, etc.\n\nWe'll produce each line. Let's craft lines:\n\nStart // 程式開始\n→ Step 1: 將 stickers 轉換為 26 個字母的計數矩陣 stickerCounts // 每個貼紙的字母頻率\n→ Step 2: 將 target 轉換為 26 個字母的計數矩陣 targetCounts // 目標字母頻率\n→ Step 3: 建立 Memo = 空映射 // 用於記錄已計算的子問題結果\n→ Decision: 是否已將所有目標字母消除? // 檢查 targetCounts 是否全為 0\n    Yes → Step 4: 回傳 0 // 無需貼紙\n    No  → Continue\n→ Step 5: 定義遞迴函數 dfs(remaining) // remaining 為 26 字母頻率陣列\n    → Decision: 是否存在 key 為 remaining 的紀錄於 Memo? // 檢查是否已計算\n        Yes → Step 6: 回傳 Memo[key] // 直接回傳已存的最小貼紙數\n        No  → Step 7: 將 res 設為 Infinity // 初始最小貼紙數\n        → For each stickerCount in stickerCounts\n            → Decision: 這張貼紙能否減少至少一個目標字母? // stickerCount[i] > remaining[i]\n                Yes → Step 8: 計算 newRemaining = remaining - stickerCount (下限為 0) // 形成新的子問題\n                → Step 9: sub = dfs(newRemaining) // 取得使用此貼紙後的最小貼紙數\n                → Decision: sub 是否可行 (sub != -1)? \n                    Yes → Step 10: res = min(res, sub + 1) // 更新最小貼紙數\n                    No  → Step 11: 跳過\n        → Decision: res 是否仍為 Infinity? // 無法完成\n            Yes → Step 12: Memo[key] = -1\n            No  → Step 13: Memo[key] = res\n        → Step 14: 回傳 Memo[key] // 回傳結果\n→ Step 15: 回傳 dfs(targetCounts) // 主函數輸出最小貼紙數\nEnd // 程式結束\n\nBut we need to produce virtual code with arrow syntax. We'll output each line with // explanation.\n\nWe must use arrow: Start, End, Decision:, and maybe Use \"→\". Use each line like \"Start // ...\" etc.\n\nLet's format each line with indentation maybe for Decision blocks, but the spec doesn't mention indentation, but we can show lines after \"Decision:\" with indentation and \"Yes →\" etc. Use like example.\n\nWe must avoid actual code, just pseudocode. We'll produce lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: stickersCount ← Build 26‑letter frequency for each sticker in stickers // 把每張貼紙的字母頻率存成 26 個數值  \n→ Step 2: targetCount ← Build 26‑letter frequency of target // 目標字串的字母頻率  \n→ Step 3: Memo ← empty map // 用於記錄已算出的子問題答案  \n→ Decision: targetCount 全為 0? // 判斷是否已無需貼紙  \n Yes → Step 4: 回傳 0 // 無需貼紙即可完成  \n No  →  \n→ Step 5: 定義遞迴函數 dfs(remaining) // 參數 remaining 為 26 個字母的剩餘頻率  \n → Decision: Memo 中是否已有 key 為 remaining? // 檢查是否已算過此子問題  \n  Yes → Step 6: 回傳 Memo[key] // 直接回傳已存的結果  \n  No → Step 7: res ← Infinity // 初始化目前子問題的最小貼紙數  \n  → For each stickerCount in stickersCount // 遍歷每種貼紙  \n   → Decision: stickerCount 可否減少 remaining 中至少一個字母? // stickerCount[i] > remaining[i]  \n    Yes → Step 8: newRemaining ← remaining - stickerCount (下限 0) // 計算使用此貼紙後的剩餘字母  \n    → Step 9: sub ← dfs(newRemaining) // 取得使用此貼紙後所需的最小貼紙數  \n    → Decision: sub ≠ -1? // 判斷子問題是否可行  \n     Yes → Step 10: res ← min(res, sub + 1) // 更新最小貼紙數  \n     No  → Step 11: 跳過 // 子問題不可行，忽略此貼紙  \n  → Decision: res 為 Infinity? // 是否仍無法完成此子問題  \n   Yes → Step 12: Memo[key] ← -1 // 標記不可完成  \n   No  → Step 13: Memo[key] ← res // 存入最小貼紙數  \n  → Step 14: 回傳 Memo[key] // 回傳本子問題結果  \n→ Step 15: 回傳 dfs(targetCount) // 主函數輸出最小貼紙數  \nEnd // 程式結束執行"
    },
    {
      "title": "Implement strStr()",
      "source_file": "Leetcode/leetcode28.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "haystack = \"sadbutsad\", needle = \"sad\"",
          "expected_output": "0",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '0'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"Return the index of the first occurrence of needle in haystack,\n        or -1 if needle is not part of haystack.\"\"\"\n        if not needle:          # 空字串總是出現在起始位置\n            return 0\n\n        n, m = len(haystack), len(needle)\n        # 只需要檢查到足夠長度的位置\n        for i in range(n - m + 1):\n            if haystack[i:i+m] == needle:  # 完全相等才算找到\n                return i\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中擷取 haystack 與 needle。\"\"\"\n    # 先嘗試匹配 'haystack = \"...\" , needle = \"...\"' 這類格式\n    m = re.search(r'haystack\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]\\s*,\\s*needle\\s*=[\\'\"]([^\\'\"]*)[\\'\"]', data)\n    if m:\n        return m.group(1), m.group(2)\n\n    # 若格式不同，嘗試以換行或空白分隔\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n\n    parts = data.strip().split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # 最後回退：把整個輸入當作 haystack，needle 為空\n    return data, ''\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    haystack, needle = parse_input(data)\n    result = Solution().strStr(haystack, needle)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for string search algorithm. Provide each line with \"虛擬碼步驟 // 解釋\". Use Start, Decision, etc. We must not output actual code. So we will describe algorithm steps: start, input needle, haystack, check empty needle, loop through haystack, compare substring, return index or -1. Use decision arrows.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 needle 和 haystack // 從使用者或函式參數取得兩個字串  \n→ Decision: 如果 needle 為空字串? // 先處理特殊情況  \n    Yes → Step 2: 回傳 0 // 空字串總是出現在任何字串的起始位置  \n    No → Step 3: 計算 haystack 長度 N 與 needle 長度 M // 為後續迴圈做準備  \n→ Decision: 如果 M > N? // 字串太長無法出現在 haystack  \n    Yes → Step 4: 回傳 -1 // 沒有符合的子字串  \n    No → Step 5: 設定 index = 0 // 從起始位置開始搜尋  \n→ Decision: 迴圈條件 index <= N - M? // 只需到剩下足夠長度的位置  \n    Yes → Step 6: 取 haystack 子字串 haystack[index … index+M-1] // 取目前候選位置的子字串  \n    → Decision: 子字串 == needle? // 比對兩個字串是否完全相同  \n        Yes → Step 7: 回傳 index // 找到第一個匹配，直接返回  \n        No → Step 8: index = index + 1 // 位置向後移動一個字元，繼續搜尋  \n    → 回到 Decision: 迴圈條件 index <= N - M?  \n    No → Step 9: 回傳 -1 // 所有位置都檢查完畢仍無匹配  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i - 1][0] <= left and right <= self.ranges[i - 1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\n\ndef main():\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    outputs = []\n    instances = {}\n\n    for line in lines:\n        if line.endswith(';'):\n            line = line[:-1].strip()\n        if line.startswith('RangeModule'):\n            # Example: RangeModule rangeModule = new RangeModule()\n            left_part, _ = line.split('=', 1)\n            _, var_name = left_part.strip().split()\n            instances[var_name] = RangeModule()\n            outputs.append(None)\n        else:\n            var_name, method_call = line.split('.', 1)\n            method_name, rest = method_call.split('(', 1)\n            args_str = rest.rstrip(')')\n            args = [int(a.strip()) for a in args_str.split(',') if a.strip()]\n            instance = instances[var_name]\n            if method_name == 'addRange':\n                instance.addRange(*args)\n                outputs.append(None)\n            elif method_name == 'removeRange':\n                instance.removeRange(*args)\n                outputs.append(None)\n            elif method_name == 'queryRange':\n                result = instance.queryRange(*args)\n                outputs.append(result)\n            else:\n                outputs.append(None)\n\n    out_str = '[' + ', '.join(\n        ['null' if v is None else ('true' if v else 'false') for v in outputs]\n    ) + ']'\n    print(out_str)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. Not actual code but pseudo steps. Need to design data structure for RangeModule. Likely use sorted list of non-overlapping intervals, operations: addRange merges, queryRange checks containment, removeRange splits.\n\nWe need step-by-step pseudocode for initialization and each method.\n\nSo output:\n\nStart // program start\n→ Step 1: Define RangeModule class // define class\n... but need per method.\n\nBetter: produce pseudo code for whole design.\n\nLine 1: Start // program starts\n→ Step 1: Define RangeModule // class definition\n→ Step 2: Initialize list of intervals // e.g., empty list\n...\n\nBut they want virtual code for operations. Provide pseudocode for initialization, addRange, queryRange, removeRange.\n\nWe can create pseudo steps for each method.\n\nSo format:\n\nStart // 程式開始執行\n→ Step 1: Define RangeModule class // 定義類別\n    → Step 2: Constructor: Create empty sorted list // 建立空列表\n    → Step 3: Method addRange(left, right) // 加入區間\n        ... etc.\n\nBut maybe easier: Provide a generic pseudo code with decisions.\n\nLet's produce.\n\nWe'll produce line-by-line.\n\nWe'll include decisions, loops.\n\nLet's craft.\n\nUse arrow lines.\n\nUse indentation with spaces maybe.\n\nImportant: Each line must contain virtual code step and // explanation.\n\nLet's write.\n\nWe need to be careful to keep each line separate, no extra formatting.\n\nLet's do.\n\nWe need to cover steps: find first interval with end > left etc.\n\nBut pseudo code can be high-level.\n\nOk produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Define RangeModule class // 建立 RangeModule 類別\n    → Step 2: Constructor: intervals ← empty list // 初始化為空的區間列表\n    → Step 3: Method addRange(left, right) // 新增區間\n        → Step 4: idx ← index of first interval whose end > left // 找出可能重疊的起點\n        → Step 5: newLeft ← left // 設定合併後區間的左邊界\n        → Step 6: newRight ← right // 設定合併後區間的右邊界\n        → Step 7: While idx < length(intervals) AND intervals[idx].start <= right\n            → Step 8: newLeft ← min(newLeft, intervals[idx].start) // 取左邊界最小\n            → Step 9: newRight ← max(newRight, intervals[idx].end) // 取右邊界最大\n            → Step 10: Remove intervals[idx] // 刪除重疊的區間\n        → Step 11: Insert (newLeft, newRight) at position idx // 插入合併後的區間\n    → Step 12: Method queryRange(left, right) // 查詢區間是否全被追蹤\n        → Step 13: idx ← index of interval whose end > left // 找到可能覆蓋左邊界的區間\n        → Step 14: If idx == length(intervals) OR intervals[idx].start > left\n            → Step 15: Return False // 沒有區間覆蓋左邊界\n        → Step 16: Return intervals[idx].end >= right // 若右邊界被覆蓋則返回真\n    → Step 17: Method removeRange(left, right) // 移除區間\n        → Step 18: idx ← index of first interval whose end > left // 找出可能重疊的起點\n        → Step 19: While idx < length(intervals) AND intervals[idx].start < right\n            → Step 20: curStart ← intervals[idx].start\n            → Step 21: curEnd ← intervals[idx].end\n            → Step 22: If curStart < left\n                → Step 23: intervals[idx].end ← left // 只保留左半段\n                → Step 24: idx ← idx + 1\n            → Step 25: Else\n                → Step 26: Remove intervals[idx] // 完全被移除\n            → Step 27: If curEnd > right\n                → Step 28: Insert (right, curEnd) at position idx // 保留右半段\n                → Step 29: Break // 右半段已處理完畢\n    → Step 30: End // RangeModule 類別定義結束\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,true,true,false,2,true,true,true,4]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, true, true, true, false, 2, true, true, true, 4]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k                     # maximum capacity\n        self.buf = [0] * k             # circular buffer\n        self.head = 0                  # index of the first element\n        self.count = 0                 # current number of elements\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    # filter out any empty lines\n    lines = [line for line in data if line.strip()]\n    if len(lines) < 2:\n        return\n    ops = json.loads(lines[0])\n    params = json.loads(lines[1])\n\n    results = []\n    obj = None\n\n    for op, param in zip(ops, params):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(param[0])\n            results.append(None)               # constructor returns null\n        elif op == \"insertFront\":\n            results.append(obj.insertFront(param[0]))\n        elif op == \"insertLast\":\n            results.append(obj.insertLast(param[0]))\n        elif op == \"deleteFront\":\n            results.append(obj.deleteFront())\n        elif op == \"deleteLast\":\n            results.append(obj.deleteLast())\n        elif op == \"getFront\":\n            results.append(obj.getFront())\n        elif op == \"getRear\":\n            results.append(obj.getRear())\n        elif op == \"isEmpty\":\n            results.append(obj.isEmpty())\n        elif op == \"isFull\":\n            results.append(obj.isFull())\n        else:\n            # unknown operation, ignore or handle as needed\n            results.append(None)\n\n    # output as JSON array, converting Python None to null\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the implementation of MyCircularDeque class with its methods. Use Start, End, Decision: lines. Provide each line as \"虛擬碼步驟 // 解釋\". We need to explain line by line. We should not output actual code, only virtual code. Steps include initialization, array storage, front and rear pointers, size count, wrap around logic.\n\nWe must cover class definition, constructor, methods. Use pseudo-code steps. Provide flow for each method: insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Use Decision lines for checking full/empty etc.\n\nWe should not output actual code, just virtual steps.\n\nEnsure each line has arrow \"→\" at start if needed, but top-level Start line. Use \"→\" to denote continuation. Use \"Decision:\" lines. Provide explanation after //.\n\nWe need to maintain structure; not actual programming syntax. Use \"虛擬碼步驟\" could be something like \"Set capacity = k\" etc.\n\nLet's produce.\n\nStart\n→ Initialize array of size k // 建立固定大小的陣列來儲存元素\n→ Set front = 0 // 指向隊首指標\n→ Set rear = 0 // 指向隊尾指標\n→ Set count = 0 // 當前元素數量\n\nThen for insertFront:\n→ Decision: 如果 count == capacity? // 檢查是否已滿\n    Yes → return false // 不能插入\n    No  → 前移 front: front = (front - 1 + capacity) % capacity // 先計算新位置\n          array[front] = value // 放入值\n          count++ // 更新計數\n          return true\n\nSimilarly insertLast:\n→ Decision: 如果 count == capacity? // 檢查是否已滿\n    Yes → return false\n    No  → array[rear] = value // 放入值\n          rear = (rear + 1) % capacity // 移動尾指標\n          count++ \n          return true\n\ndeleteFront:\n→ Decision: 如果 count == 0? // 檢查是否空\n    Yes → return false\n    No  → front = (front + 1) % capacity // 移動首指標\n          count--\n          return true\n\ndeleteLast:\n→ Decision: 如果 count == 0? // 檢查是否空\n    Yes → return false\n    No  → rear = (rear - 1 + capacity) % capacity // 移動尾指標\n          count--\n          return true\n\ngetFront:\n→ Decision: 如果 count == 0? // 檢查是否空\n    Yes → return -1\n    No  → return array[front] // 返回首元素\n\ngetRear:\n→ Decision: 如果 count == 0? // 檢查是否空\n    Yes → return -1\n    No  → index = (rear - 1 + capacity) % capacity // 最後一個元素位置\n          return array[index] // 返回尾元素\n\nisEmpty:\n→ Decision: 如果 count == 0? // 判斷是否空\n    Yes → return true\n    No  → return false\n\nisFull:\n→ Decision: 如果 count == capacity? // 判斷是否滿\n    Yes → return true\n    No  → return false\n\nEnd\n\nBut we need to produce in proper format lines. Each line starts with \"虛擬碼步驟\" but we can just write pseudo code. Provide arrows.\n\nUse \"Start\" at top. Use \"End\" at bottom.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize array[capacity] // 建立固定大小的陣列來儲存元素  \n→ Set front = 0 // 指向隊首指標  \n→ Set rear = 0 // 指向隊尾指標  \n→ Set count = 0 // 當前元素數量  \n\n→ Decision: 如果 count == capacity? // 檢查是否已滿  \n  Yes → return false // 不能插入  \n  No  → 前移 front: front = (front - 1 + capacity) % capacity // 先計算新位置  \n    array[front] = value // 放入值  \n    count++ // 更新計數  \n    return true  \n\n→ Decision: 如果 count == capacity? // 檢查是否已滿  \n  Yes → return false  \n  No  → array[rear] = value // 放入值  \n    rear = (rear + 1) % capacity // 移動尾指標  \n    count++  \n    return true  \n\n→ Decision: 如果 count == 0? // 檢查是否空  \n  Yes → return false // 不能刪除  \n  No  → front = (front + 1) % capacity // 移動首指標  \n    count-- // 更新計數  \n    return true  \n\n→ Decision: 如果 count == 0? // 檢查是否空  \n  Yes → return false  \n  No  → rear = (rear - 1 + capacity) % capacity // 移動尾指標  \n    count--  \n    return true  \n\n→ Decision: 如果 count == 0? // 檢查是否空  \n  Yes → return -1 // 队列为空  \n  No  → return array[front] // 返回首元素  \n\n→ Decision: 如果 count == 0? // 檢查是否空  \n  Yes → return -1  \n  No  → index = (rear - 1 + capacity) % capacity // 找到最後一個元素位置  \n    return array[index] // 返回尾元素  \n\n→ Decision: 如果 count == 0? // 判斷是否空  \n  Yes → return true  \n  No  → return false  \n\n→ Decision: 如果 count == capacity? // 判斷是否滿  \n  Yes → return true  \n  No  → return false  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,null,false,true,true,true]'\nGot (Norm):      '[None,None,None,None,False,True,True,True]'\n--- (Raw) ---\nRaw Expected: '[null,null,null,null,false,true,true,true]'\nRaw Got:      '[None, None, None, None, False, True, True, True]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, i: int) -> bool:\n            if i == len(word):\n                return node.is_end\n            ch = word[i]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            if ch not in node.children:\n                return False\n            return dfs(node.children[ch], i + 1)\n        return dfs(self.root, 0)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Wrap the input with brackets to parse as a list of two lists\n    data = '[' + data + ']'\n    ops, args = ast.literal_eval(data)\n    result = []\n    word_dict = None\n    for i, op in enumerate(ops):\n        if op == \"WordDictionary\":\n            word_dict = WordDictionary()\n            result.append(None)\n        elif op == \"addWord\":\n            word_dict.addWord(args[i][0])\n            result.append(None)\n        elif op == \"search\":\n            result.append(word_dict.search(args[i][0]))\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo code with explanation per line, for a WordDictionary class that supports addWord and search with dot support. It's basically a trie with DFS for search. We'll produce a step-by-step pseudo code structure. Provide Start, End. For each line: \"虛擬碼步驟 // 解釋\". Use arrow. For decisions use \"Decision:\".\n\nNeed to produce a logical flow: Initialize root node; addWord: insert letters; search: recursively check each character, with dot case. Provide DFS function. Should be line-by-line with explanation.\n\nWe must not output actual code, just pseudo code steps. Provide steps for class, methods, and internal functions. Let's produce something like:\n\nStart // Initialize WordDictionary\n→ Step 1: Define Node structure with children[26] and isEnd // Trie node\n→ Step 2: Root ← new Node // Root of trie\n→ Step 3: End // Constructor done\nThen addWord: \n→ Step 4: addWord(word) // method\n→ Step 5: curr ← root\n→ Step 6: For each char c in word\n→ Step 7: idx ← c - 'a'\n→ Step 8: If curr.children[idx] == null → curr.children[idx] ← new Node\n→ Step 9: curr ← curr.children[idx]\n→ Step 10: End For\n→ Step 11: curr.isEnd ← true\n→ End // addWord finished\nSearch:\n→ Step 12: search(word) // method\n→ Step 13: Return DFS(0, root, word) // start DFS from index 0\n→ Step 14: End // search finished\nDFS:\n→ Step 15: DFS(index, node, word) // recursive helper\n→ Step 16: If index == word.length → Return node.isEnd\n→ Step 17: char c = word[index]\n→ Step 18: If c != '.' // not wildcard\n→ Step 19: idx ← c - 'a'\n→ Step 20: child ← node.children[idx]\n→ Step 21: If child == null → Return false\n→ Step 22: Return DFS(index+1, child, word)\n→ Step 23: Else // c == '.'\n→ Step 24: For each child in node.children\n→ Step 25: If child != null and DFS(index+1, child, word) → Return true\n→ Step 26: Return false\n→ End // DFS finished\nEnd // program\n\nAdd line breaks with explanations. Ensure each line has arrow etc. Use \"→\" for step, \"Decision:\" for decisions.\n\nNeed to output only pseudo code lines. Let's format exactly as specified. Use Chinese explanations. Also maintain consistency: start of method lines maybe with indentation but not required. Use \"Step X:\" etc. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 定義 Node 結構，包含 children[26] 與 isEnd // Trie 節點的定義  \n→ Step 2: root ← new Node // 建立 Trie 的根節點  \n→ End // 建構子完成\n\n→ Step 3: WordDictionary() // WordDictionary 的初始化方法  \n→ End // 初始化方法結束\n\n→ Step 4: addWord(word) // 新增單詞的方法  \n→ Step 5: curr ← root // 從根節點開始  \n→ Step 6: For each char c in word // 遍歷單詞中的每個字元  \n→ Step 7: idx ← c - 'a' // 轉換字元為索引  \n→ Step 8: If curr.children[idx] == null → curr.children[idx] ← new Node // 若節點不存在則建立  \n→ Step 9: curr ← curr.children[idx] // 移動至下一節點  \n→ Step 10: End For  \n→ Step 11: curr.isEnd ← true // 標記單詞結尾  \n→ End // addWord 方法結束\n\n→ Step 12: search(word) // 搜尋單詞的主方法  \n→ Step 13: Return DFS(0, root, word) // 從根節點開始遞迴搜尋  \n→ End // search 方法結束\n\n→ Step 14: DFS(index, node, word) // 內部遞迴搜尋輔助函式  \n→ Step 15: If index == word.length → Return node.isEnd // 到達字串末端，判斷是否為完整單詞  \n→ Step 16: char c ← word[index] // 取目前字元  \n→ Step 17: Decision: 如果 c != '.'? // 判斷是否為普通字元  \n    Yes → Step 18: idx ← c - 'a' // 轉換索引  \n        → Step 19: child ← node.children[idx] // 取得對應子節點  \n        → Step 20: If child == null → Return false // 沒有對應字元，搜尋失敗  \n        → Step 21: Return DFS(index + 1, child, word) // 進一步搜尋下一個字元  \n    No  → Step 22: Decision: 如果 c == '.'? // 處理萬用字元  \n        Yes → Step 23: For each child in node.children // 遍歷所有子節點  \n            → Step 24: If child != null and DFS(index + 1, child, word) → Return true // 有任一子節點匹配成功  \n        → Step 25: Return false // 所有分支都失敗  \n→ End // DFS 函式結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"Return list of groups of duplicate file paths based on file content.\"\"\"\n        content_map = defaultdict(list)\n\n        for path in paths:\n            parts = path.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content[:-1]  # remove trailing ')'\n                content_map[content].append(f\"{root}/{name}\")\n\n        # Only keep groups with at least two files\n        return [files for files in content_map.values() if len(files) > 1]\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Remove possible leading variable assignment like \"paths = \"\n    if data.startswith(\"paths\"):\n        idx = data.find(\"=\")\n        if idx != -1:\n            data = data[idx + 1:].strip()\n\n    # Parse the list of strings safely\n    try:\n        paths = ast.literal_eval(data)\n    except Exception as e:\n        print(\"Error parsing input:\", e)\n        sys.exit(1)\n\n    # Compute and output duplicate file groups\n    solution = Solution()\n    result = solution.findDuplicate(paths)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce pseudocode steps line by line with arrow and explanation, no real code. The task: Given list of directory info strings, return duplicate files by content. Should parse each entry, extract directory path and files with content, build map from content to list of file paths. Finally, collect lists where size>=2. So virtual code steps: Start, Step 1: Initialize map content->list, Step 2: For each entry in paths: split by space to get dir path and file parts, Step 3: For each file part: parse file name and content, build full path, add to map. Step 4: After processing, iterate map to collect duplicates. End.\n\nWe need arrows. Use \"→\". Each line: \"虛擬碼步驟 // 解釋\". We'll produce each line. Use Decision: maybe for filtering duplicates. Use No/Yes arrows. Let's produce stepwise. Probably include Step lines and decisions.\n\nLet's format accordingly.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空的映射 contentMap (key 為檔案內容，value 為該內容的檔案完整路徑列表) // 初始化用於存放內容對應路徑的字典\n→ Step 2: 遍歷輸入列表 paths，對每個元素 directoryInfo 進行處理 // 逐一解析每個目錄資訊字串\n    → Step 2.1: 以空格為分隔符將 directoryInfo 拆成兩部分：directoryPath 與 fileInfoList // 取得目錄路徑及其檔案資訊\n    → Step 2.2: 對 fileInfoList 中的每個 fileInfo（形如 \"fileName(content)\"）進行處理\n        → Step 2.2.1: 找到左括號位置，提取 fileName 為子字串前半段，content 為括號內部的字串 // 解析檔案名與內容\n        → Step 2.2.2: 組合 fullPath = directoryPath + \"/\" + fileName // 形成完整檔案路徑\n        → Step 2.2.3: 如果 contentMap 已有 key content，則將 fullPath 加入其列表；否則，建立新列表並加入 fullPath // 將路徑按內容分組\n→ Step 3: 建立空的答案列表 duplicateGroups // 用於儲存重複檔案的群組\n→ Step 3.1: 遍歷 contentMap 的每個 entry (content, pathsList)\n    → Decision: pathsList 是否至少包含兩個元素？\n        Yes → Step 3.2: 將 pathsList 加入 duplicateGroups // 只保留重複檔案群組\n        No  → Step 3.3: 跳過此內容，因為沒有重複檔案\n→ Step 4: 返回 duplicateGroups // 輸出所有重複檔案的路徑群組\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[3]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[3]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[8,8]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[8,8]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[2,2,4]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[2,2,4]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport random\n\ndef rand7() -> int:\n    \"\"\"Simulate the provided rand7() API using Python's random module.\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"Generate a uniform random integer in the range [1, 10] using only rand7().\"\"\"\n        while True:\n            # Combine two rand7() calls to get a uniform distribution over [1, 49]\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:                     # Accept only the first 40 outcomes\n                return 1 + (num - 1) % 10     # Map 1~40 to 1~10\n\nif __name__ == \"__main__\":\n    # Read input such as \"n = 3\"\n    raw_input = sys.stdin.read().strip()\n    match = re.search(r'(\\d+)', raw_input)\n    n = int(match.group(1)) if match else 0\n\n    solver = Solution()\n    results = [solver.rand10() for _ in range(n)]\n\n    # Output in the format \"[a,b,c]\" without spaces after commas\n    output = '[' + ','.join(str(x) for x in results) + ']'\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Problem: generate rand10 using rand7. Classic solution: use rejection sampling. Idea: generate two 7's to get 49 outcomes. Use first 40 (0-39) mapping to 1-10 (mod 10). Or using 1-49 mapping to 1-10 via modulo 10. Or use 1-49 -> 1-10 by rejecting if >40.\n\nAlternatively use mapping 1-49 to 1-10 by (x-1)%10+1, accept if x <= 40. Else re-roll.\n\nSo steps: start, generate rand7() twice: r1,r2 -> combined = (r1-1)*7 + r2 -> range 1-49. If combined <=40 then output ((combined-1)%10)+1. Else loop again.\n\nImplement while loop.\n\nWe need virtual code with arrows. Use Start, Decision, etc.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Decision: 是否已生成有效亂數? // 判斷是否已得到合法的 1~10\n    No  → Step 1: r1 ← rand7() // 產生第一個 1~7\n    No  → Step 2: r2 ← rand7() // 產生第二個 1~7\n    No  → Step 3: combined ← (r1-1)*7 + r2 // 轉換為 1~49\n    No  → Decision: 是否有效? (combined ≤ 40?) // 檢查是否在可接受區間\n        Yes → Step 4: result ← ((combined-1) mod 10) + 1 // 將 1~40 映射到 1~10\n        Yes → Step 5: return result // 回傳結果\n        No  → Step 6: 跳回 Decision: 是否已生成有效亂數? // 若失敗則重新開始\nEnd // 程式結束\n\nBut need to include loop arrow properly. Use while loop concept: Use Decision: loop until return.\n\nWe could structure as:\n\nStart\n→ Decision: 是否已返回? // Start loop\n    No → Step 1: r1 ← rand7()\n    No → Step 2: r2 ← rand7()\n    No → Step 3: combined ← (r1-1)*7 + r2\n    No → Decision: (combined ≤ 40)?\n        Yes → Step 4: result ← ((combined-1) mod 10) + 1\n        Yes → Step 5: return result\n        No  → Step 6: 回到上一 Decision: 是否已返回? // loop\n\nBut need to represent arrow after No -> Decision. Use indentation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 是否已返回結果? // 啟動循環，直到產生有效亂數  \n No → Step 1: r1 ← rand7() // 取得第一個 1~7 的隨機數  \n No → Step 2: r2 ← rand7() // 取得第二個 1~7 的隨機數  \n No → Step 3: combined ← (r1-1)*7 + r2 // 轉換為 1~49 的整數  \n No → Decision: combined ≤ 40? // 判斷是否在可接受區間  \n  Yes → Step 4: result ← ((combined-1) mod 10) + 1 // 將 1~40 映射到 1~10  \n  Yes → Step 5: return result // 回傳 1~10 的亂數  \n  No → Step 6: 回到 Decision: 是否已返回結果? // 若失敗則重新進行  \nEnd // 程式結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n\n        # 取得六條邊距離平方\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n        # dists[0] ~ dists[3] 為四條邊，dists[4] ~ dists[5] 為兩條對角線\n        return (\n            dists[0] > 0 and\n            dists[0] == dists[1] == dists[2] == dists[3] and\n            dists[4] == dists[5] and\n            dists[4] == 2 * dists[0]\n        )\n\ndef main():\n    data = sys.stdin.read()\n    # 取得所有整數（包含負號）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) != 8:\n        # 如果輸入格式不符合預期，可自行處理或直接輸出 false\n        print('false')\n        return\n\n    # 以 4 個點的座標對組成 tuple\n    points = [(nums[i], nums[i + 1]) for i in range(0, 8, 2)]\n    sol = Solution()\n    result = sol.validSquare(*points)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps explaining algorithm for determining if four points form a square. Use steps: compute all pairwise distances, sort them, check smallest four equal and >0, largest two equal, etc. Provide explanation. Use virtual code syntax. Provide each line. Need Start, End. Provide decision. Provide arrow lines. Use indentation. Provide short explanation. Provide only virtual code steps.\n\nWe produce something like:\n\nStart\n→ Step 1: Read four points p1,p2,p3,p4\n→ Step 2: Create list distances = []\n→ Step 3: For each pair (i<j) compute squared distance and add to list\n→ Step 4: Sort distances\n→ Decision: If any distance == 0? // duplicates\n    No → Step 5: Check first 4 distances equal?\n    Yes → Step 6: Return false\n... etc.\n\nWe need to handle that there are 6 distances. For square: first 4 equal (sides), last 2 equal (diagonals). Diagonals must be larger than sides. Provide decisions.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取四個點 p1, p2, p3, p4 // 從輸入取得四組座標  \n→ Step 2: 建立空陣列 distances // 用於儲存所有點對之間的距離平方  \n→ Step 3: For i from 0 to 3  \n  For j from i+1 to 3  \n   計算 d = (p_i.x - p_j.x)^2 + (p_i.y - p_j.y)^2  \n   將 d 加入 distances // 計算六個距離平方  \n→ Step 4: 將 distances 由小到大排序 // 方便比對相同長度  \n→ Decision: 是否有距離為 0? // 同一點會產生距離為 0  \n  Yes → Step 5: Return false // 無法形成正方形  \n  No → Step 6: 檢查前四個距離是否相等 // 代表四條邊長相同  \n→ Decision: 前四個距離相等?  \n  Yes → Step 7: 檢查最後兩個距離是否相等 // 代表兩條對角線長相同  \n   Decision: 最後兩個距離相等?  \n    Yes → Step 8: 檢查對角線長度是否大於邊長 // 必須為正方形  \n     Decision: 對角線 > 邊?  \n      Yes → Step 9: Return true // 符合正方形條件  \n      No → Step 10: Return false // 對角線不大於邊，非正方形  \n    No → Step 11: Return false // 對角線長度不相等，非正方形  \n  No → Step 12: Return false // 四條邊長不相同，非正方形  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuas1q18z.py\", line 34, in <module>\n    special = eval(re.search(r'special\\s*=\\s*(\\[[^\\]]*\\])', data).group(1))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[3,0,5]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9uvjv675.py\", line 34, in <module>\n    special = eval(re.search(r'special\\s*=\\s*(\\[[^\\]]*\\])', data).group(1))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,1,0,4]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # base cost without any special offers\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            for offer in special:\n                # check if offer can be applied\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:  # all items in offer fit\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    price = eval(re.search(r'price\\s*=\\s*(\\[[^\\]]*\\])', data).group(1))\n    special = eval(re.search(r'special\\s*=\\s*(\\[[^\\]]*\\])', data).group(1))\n    needs = eval(re.search(r'needs\\s*=\\s*(\\[[^\\]]*\\])', data).group(1))\n    result = Solution().shoppingOffers(price, special, needs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving LeetCode problem \"638. Shopping Offers\". Need to output line by line, each line \"虛擬碼步驟 // 解釋\". Use Start, Decision, End etc. Should describe algorithm: use DFS with memoization/backtracking, try each offer if can use, compute min cost. Also consider no offer path: sum of needs*price. Use recursion. Use hash map for memo key from needs vector to cost.\n\nWe need to output virtual code lines describing the algorithm.\n\nMake sure we include Start, then steps. For each step: define function solve(need vector). Step: compute key string. Decision: if key in memo? Yes→ return memo[key]. No→ compute.\n\nThen compute base cost = sum(need[i]*price[i]). Then iterate each offer. Decision: canApply? Yes→ newNeed = need - offer counts; Recursively compute costOffer = specialPrice + solve(newNeed). Update min.\n\nAfter loop, store memo[key] = minCost; return.\n\nFinally call solve(initialNeeds). Output result.\n\nWe'll produce virtual code lines.\n\nMake sure to use arrow \"→\" and \"Yes →\", \"No →\".\n\nWe should include array indexing.\n\nOk.\n\nLet's craft:\n\nStart // Program starts\n→ Step 1: 定義 function Solve(need) // 以需求為參數遞迴\n→ Step 2: 產生 key = string representation of need // 用於 memo\n→ Decision: 如果 key 已存在於 memo?\n    Yes → Step 3: 返回 memo[key] // 直接回傳已計算結果\n    No → Step 4: 計算基礎價格 base = sum(need[i]*price[i]) // 沒用優惠的成本\n→ Step 5: 設定 minCost = base\n→ Step 6: 對於每個特別優惠 offer in specials\n→ Decision: 如果 offer 可以被使用 (即每個項目數量 ≤ 需要)?\n    Yes → Step 7: newNeed = need - offerCounts // 減去優惠中的項目數\n    → Step 8: costWithOffer = offerPrice + Solve(newNeed) // 递归计算\n    → Step 9: minCost = min(minCost, costWithOffer) // 更新最小成本\n    No → Skip\n→ Step 10: 存入 memo[key] = minCost\n→ Step 11: 返回 minCost\n→ Step 12: 在主程式呼叫 Solve(initialNeeds) 並輸出結果\nEnd // 程式結束\n\nMake sure each line has a single step and comment.\n\nLet's format exactly: \"虛擬碼步驟 // 解釋\".\n\nAlso need arrow lines maybe \"→\" but ensure they are part of code text. Eg \"→ Step 1: ...\" We'll put \"→\" at start.\n\nAlso use \"Decision:\" lines with indentation.\n\nWe should keep each decision branch in separate lines.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 Solve(need) // 以需求向量為參數遞迴求解  \n→ Step 2: 產生 key = 字串化 need // 用於 memoization 的鍵  \n→ Decision: 若 key 已存在於 memo?  \n Yes → Step 3: 回傳 memo[key] // 直接返回已計算結果  \n No → Step 4: 計算基礎價格 base = Σ need[i] * price[i] // 未使用優惠時的成本  \n→ Step 5: 設定 minCost = base // 初始最小成本為基礎價格  \n→ Step 6: 對 specials 中的每個 offer 迭代  \n → Decision: 若 offer 可用 (即每項目數量 ≤ need[i])?  \n  Yes → Step 7: newNeed = need - offerCounts // 依優惠扣減需求  \n   → Step 8: costWithOffer = offerPrice + Solve(newNeed) // 递归计算  \n   → Step 9: minCost = min(minCost, costWithOffer) // 更新最小成本  \n  No → Skip // 該優惠不可使用  \n→ Step 10: 存入 memo[key] = minCost // 缓存结果  \n→ Step 11: 回傳 minCost // 返回本需求的最小價格  \n→ Step 12: 在主程式中呼叫 Solve(initialNeeds) 並輸出結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Rotate Function",
      "source_file": "Leetcode/leetcode396.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '26'\nGot (Norm):      '34'\n--- (Raw) ---\nRaw Expected: '26'\nRaw Got:      '34'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxRotateFunction(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = sum(nums)\n        # 初始旋轉函數 F(0)\n        current = sum(i * num for i, num in enumerate(nums))\n        max_val = current\n        # 依照公式更新每個旋轉\n        for i in range(n - 1):\n            current = current + total - n * nums[i]\n            if current > max_val:\n                max_val = current\n        return max_val\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 找到第一個 '[' 與最後一個 ']'，將其中的字串轉成列表\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        print(0)\n        return\n    list_str = data[start:end+1]\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        print(0)\n        return\n    sol = Solution()\n    result = sol.maxRotateFunction(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm to compute max rotation function. Standard solution uses formula: sum = sum(nums), current=0, max=0. For i from 0 to n-1: current += sum - n*nums[i]; max = max(max, current). return max. Also initial F(0)=0*nums[0]+... So compute initial F0 via sum(i*nums[i]). Then iterate. Provide virtual code with steps.\n\nWe need to output step by step with comments. Use Start, End, Decision etc. Use arrow for steps.\n\nWe'll write:\n\nStart\n→ Step 1: 輸入陣列 nums，長度 n // 取得輸入\n→ Step 2: 計算總和 sum = Σ nums[i] // 計算總和\n→ Step 3: 計算 F0 = Σ i*nums[i] // 初始旋轉函數\n→ Step 4: 設定 maxVal = F0，current = F0 // 初始最大值與當前值\n→ Decision: 迭代 i from 0 to n-2? Actually we need n-1 rotations. Use loop counter i from 0 to n-2? For each next rotation: current = current + sum - n*nums[i]. So loop i 0 to n-2? Actually we need to compute for k=1..n-1. So loop i from 0 to n-2 inclusive. But we can also loop i 0 to n-1 but skip last because after n-1 rotations we get original? We'll produce loop for i from 0 to n-2.\nUse loop: for i in 0 to n-2\n→ Step 5: 更新 current = current + sum - n*nums[i] // 根據公式更新\n→ Step 6: 更新 maxVal = max(maxVal, current) // 更新最大值\nEnd loop\n→ Step 7: 回傳 maxVal // 結果\n\nWe need to use Decision arrow? Might not need decision. But we can include Decision for loop condition? But specification requires Decision lines. We can include:\n\n→ Decision: 是否還有未處理的 i? // 判斷迴圈是否結束\n    Yes → Step 5...\n    No → End loop\n\nBut easier: Use for loop concept as steps. Let's incorporate.\n\nWe'll produce:\n\nStart\n→ Step 1: 計算 n = nums 的長度\n→ Step 2: 計算 sum = Σ nums[i] // 總和\n→ Step 3: 計算 F0 = Σ i*nums[i] // 初始旋轉函數\n→ Step 4: 設定 current = F0，maxVal = F0 // 初始化\n→ Step 5: 設定 i = 0 // 迴圈變數\n→ Decision: i < n-1? // 檢查是否還有旋轉\n    Yes → Step 6: current = current + sum - n*nums[i] // 更新 current\n    → Step 7: maxVal = max(maxVal, current) // 更新最大值\n    → Step 8: i = i + 1 // 進行下一次\n    → 回到 Decision\n    No  → Step 9: 返回 maxVal // 結束\nEnd\n\nMake sure arrow formatting. Use `→` for steps, `Decision:` for decision lines. Provide comments after `//`.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 n = nums 的長度 // 取得陣列長度  \n→ Step 2: 計算 sum = Σ nums[i] // 計算所有元素之和  \n→ Step 3: 計算 F0 = Σ i * nums[i] // 取得 F(0) 的值  \n→ Step 4: 設定 current = F0，maxVal = F0 // 初始化目前值與最大值  \n→ Step 5: 設定 i = 0 // 迴圈起始索引  \n→ Decision: i < n-1? // 判斷是否還有剩餘的旋轉  \n    Yes → Step 6: current = current + sum - n * nums[i] // 用公式更新 current  \n    → Step 7: maxVal = max(maxVal, current) // 若 current 大於 maxVal，更新  \n    → Step 8: i = i + 1 // 移動到下一個索引  \n    → 回到 Decision  \n    No  → Step 9: 返回 maxVal // 所有旋轉已計算完畢，輸出結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpug9k7_va.py\", line 57, in <module>\n    main()\n  File \"/tmp/tmpug9k7_va.py\", line 51, in main\n    ans = sol.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpug9k7_va.py\", line 9, in calcEquation\n    graph[a][b] = val\n    ~~~~~^^^\nTypeError: unhashable type: 'list'"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprmu6ywu8.py\", line 57, in <module>\n    main()\n  File \"/tmp/tmprmu6ywu8.py\", line 51, in main\n    ans = sol.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmprmu6ywu8.py\", line 8, in calcEquation\n    for (a, b), val in zip(equations, values):\n        ^^^^^^\nValueError: too many values to unpack (expected 2)"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpu96pxnjc.py\", line 57, in <module>\n    main()\n  File \"/tmp/tmpu96pxnjc.py\", line 51, in main\n    ans = sol.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpu96pxnjc.py\", line 8, in calcEquation\n    for (a, b), val in zip(equations, values):\n        ^^^^^^\nValueError: not enough values to unpack (expected 2, got 1)"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1.0 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        result = []\n        for u, v in queries:\n            result.append(dfs(u, v, set()))\n        return result\n\ndef parse_input(data: str):\n    # Split by variable names\n    parts = data.split('values =')\n    equations_part = parts[0]\n    equations_str = equations_part.split('equations =')[1].strip()\n    rest = parts[1]\n    values_part, queries_part = rest.split('queries =')\n    values_str = values_part.strip()\n    queries_str = queries_part.strip()\n\n    equations = ast.literal_eval(equations_str)\n    values = ast.literal_eval(values_str)\n    queries = ast.literal_eval(queries_str)\n    return equations, values, queries\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    equations, values, queries = parse_input(raw_input)\n    sol = Solution()\n    ans = sol.calcEquation(equations, values, queries)\n    # Format output with 5 decimal places\n    out_str = '[' + ','.join(f'{x:.5f}' for x in ans) + ']'\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for solving the problem: given equations Ai/Bi = values[i], queries Cj/Dj. We need to answer each query with value or -1.0. Classic problem: evaluate division using graph or union find with weight. We can produce virtual code using graph BFS/DFS. Let's produce virtual code with steps: Build graph, for each query run DFS, if not connected return -1.0.\n\nWe need to produce each line with \"虛擬碼步驟\" + space + comment. Use arrow →, Start, End, Decision:.\n\nWe must not output actual code. Use simplified pseudo steps.\n\nLet's draft:\n\nStart // 程式開始\n→ Step 1: 初始化空圖 G // 建立變量到相鄰節點的加權圖\n→ Step 2: 對每個方程 (Ai, Bi, val) 做\n    → Step 2a: 若 Ai 不在 G，則新增 Ai 為空鍵\n    → Step 2b: 若 Bi 不在 G，則新增 Bi 為空鍵\n    → Step 2c: G[Ai] 加入 (Bi, val) // Ai -> Bi，權重 val\n    → Step 2d: G[Bi] 加入 (Ai, 1/val) // Bi -> Ai，權重 1/val\n→ Step 3: 初始化結果陣列 ans\n→ Step 4: 對每個查詢 (C, D) 做\n    → Decision: C 與 D 都在 G 中且 C 能通過圖到達 D? // 判斷兩變量是否相連\n        Yes →\n            → Step 4a: 呼叫 DFS(C, D, 初始乘積 1, 已訪問集合) // 取得從 C 到 D 的乘積\n            → Step 4b: 將 DFS 結果加入 ans\n        No →\n            → Step 4c: 將 -1.0 加入 ans\n→ Step 5: 回傳 ans\nEnd // 程式結束\n\nBut need to detail DFS: Use recursion stack. Provide steps for DFS: function DFS(curr, target, product, visited) -> if curr==target return product; mark visited; for each neighbor (next, weight) if not visited: res=DFS(next,target,product*weight,visited); if res != -1.0 return res; end loop; return -1.0.\n\nWe can add virtual code for DFS subroutine.\n\nAdd:\n\n→ Function DFS(curr, target, product, visited) // 計算從 curr 到 target 的乘積\n    → Decision: curr == target? // 是否到達目標\n        Yes → Return product // 成功找到路徑\n        No →\n            → Mark curr 為已訪問\n            → For 每個 (next, weight) 在 G[curr] 做\n                → Decision: next 未訪問? // 確保不循環\n                    Yes →\n                        → Step: sub_res = DFS(next, target, product * weight, visited)\n                        → Decision: sub_res != -1.0? // 找到有效路徑\n                            Yes → Return sub_res\n                            No →\n                    No → // skip\n            → End for\n            → Return -1.0 // 沒有可行路徑\n\nBut we must ensure arrow lines etc.\n\nLet's produce each line exactly as requested.\n\nAlso use \"虛擬碼步驟\" but they didn't specify a placeholder. They used \"虛擬碼步驟\". We'll write e.g. \"Start\", \"→ Step 1: ...\". Each line include comment after //.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: 建立空圖 G // 用於存儲變量之間的加權邊\n→ Step 2: 對每個方程 (Ai, Bi, val) 做\n    → Step 2a: 如果 Ai 未在 G 中，新增 Ai 為空鍵\n    → Step 2b: 如果 Bi 未在 G 中，新增 Bi 為空鍵\n    → Step 2c: G[Ai] 加入 (Bi, val) // Ai → Bi，權重 val\n    → Step 2d: G[Bi] 加入 (Ai, 1/val) // Bi → Ai，權重 1/val\n→ Step 3: 建立結果陣列 ans\n→ Step 4: 對每個查詢 (C, D) 做\n    → Decision: C 與 D 都在 G 且可通過圖相連? // 判斷兩變量是否可計算\n        Yes →\n            → Step 4a: 呼叫 DFS(C, D, 1, 空集合) // 從 C 開始搜尋\n            → Step 4b: 將 DFS 返回值加入 ans\n        No →\n            → Step 4c: 將 -1.0 加入 ans\n→ Step 5: 回傳 ans // 完成所有查詢\nEnd // 程式結束執行\n\nNow need DFS subroutine lines.\n\nWe'll include them separately, maybe before Step 4.\n\nAdd:\n\n→ Function DFS(curr, target, product, visited) // 計算從 curr 到 target 的乘積\n    → Decision: curr == target? // 是否已到達目標節點\n        Yes → Return product // 找到路徑，返回乘積\n        No →\n            → visited.add(curr) // 標記為已訪問\n            → For 每個 (next, weight) 在 G[curr] 做\n                → Decision: next 未被訪問? // 防止循環\n                    Yes →\n                        → sub_res = DFS(next, target, product * weight, visited) // 深度優先遞歸\n                        → Decision: sub_res != -1.0? // 是否找到有效路徑\n                            Yes → Return sub_res // 直接回傳結果\n                            No → // 繼續嘗試其他相鄰節點\n                    No → // 跳過已訪問節點\n            → End for\n            → Return -1.0 // 所有路徑嘗試完畢仍未找到\n\nMake sure each line ends with comment.\n\nAlso, we need to maintain structure arrow \"→\" before lines inside function. We may need to indent but not necessary. Use arrow for sub-lines.\n\nWe should also include Start, End for DFS function? Not necessary, but can include.\n\nLet's produce final output with all lines sequentially.\n\nBe careful to include each line exactly once, with arrow or indent.\n\nLet's draft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空圖 G // 用於存儲變量之間的加權邊  \n→ Step 2: 對每個方程 (Ai, Bi, val) 做  \n    → Step 2a: 如果 Ai 未在 G 中，新增 Ai 為空鍵  \n    → Step 2b: 如果 Bi 未在 G 中，新增 Bi 為空鍵  \n    → Step 2c: G[Ai] 加入 (Bi, val) // Ai → Bi，權重 val  \n    → Step 2d: G[Bi] 加入 (Ai, 1/val) // Bi → Ai，權重 1/val  \n→ Step 3: 建立結果陣列 ans  \n→ Function DFS(curr, target, product, visited) // 計算從 curr 到 target 的乘積  \n    → Decision: curr == target? // 是否已到達目標節點  \n        Yes → Return product // 找到路徑，返回乘積  \n        No →  \n            → visited.add(curr) // 標記為已訪問  \n            → For 每個 (next, weight) 在 G[curr] 做  \n                → Decision: next 未被訪問? // 防止循環  \n                    Yes →  \n                        → sub_res = DFS(next, target, product * weight, visited) // 深度優先遞歸  \n                        → Decision: sub_res != -1.0? // 是否找到有效路徑  \n                            Yes → Return sub_res // 直接回傳結果  \n                            No → // 繼續嘗試其他相鄰節點  \n                    No → // 跳過已訪問節點  \n            → End for  \n            → Return -1.0 // 所有路徑嘗試完畢仍未找到  \n→ Step 4: 對每個查詢 (C, D) 做  \n    → Decision: C 與 D 都在 G 且可通過圖相連? // 判斷兩變量是否可計算  \n        Yes →  \n            → Step 4a: 呼叫 DFS(C, D, 1, 空集合) // 從 C 開始搜尋  \n            → Step 4b: 將 DFS 返回值加入 ans  \n        No →  \n            → Step 4c: 將 -1.0 加入 ans  \n→ Step 5: 回傳 ans // 完成所有查詢  \nEnd // 程式結束執行"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                parent_email = find(first_email)\n                parent_email2 = find(email)\n                parent[parent_email2] = parent_email\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        return [[email_to_name[root]] + sorted(emails) for root, emails in merged.items()]\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    # Remove any leading variable assignment (e.g., \"accounts =\")\n    if '=' in raw_input:\n        raw_input = raw_input.split('=', 1)[1].strip()\n    # Safely evaluate the list of accounts\n    try:\n        accounts = ast.literal_eval(raw_input)\n    except Exception as e:\n        # If evaluation fails, exit silently\n        sys.exit(1)\n    # Merge accounts\n    result = Solution().accountsMerge(accounts)\n    # Print the merged accounts\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps, line by line with comments. The requirement: virtual code, not actual code. Use Start, End, Decision, arrows. The algorithm: accounts merging by emails union find or graph. We'll produce steps. Provide high-level logic. Use steps: Start, Build email to name map, Build graph edges between emails in same account, DFS/Union find, gather groups, sort emails, output. Provide explanation. Ensure each line has virtual code step and comment.\n\nWe need to produce a sequence like:\n\nStart // 開始\n→ Step 1: Initialize mapping structures // ...\n\nUse \"Decision:\" when condition.\n\nOk produce. Use arrows: → Step 1: ...\nYes → ...\nNo → ...\n\nWe'll produce lines until End.\n\nMake sure each line ends with // comment. Provide only virtual code lines, no actual code. Ensure no real code snippet.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 email → 名稱對應表 // 為每個 email 儲存對應的名字  \n→ Step 2: 建立 graph (email → 相鄰 email 集合) // 同一帳號內的所有 email 互相連接  \n→ Decision: accounts 是否空？ // 檢查輸入是否為空列表  \n    Yes → End // 若無帳號，直接結束  \n    No  →  \n→ Step 3: 遍歷每個帳號 accounts[i]  \n    → Step 3.1: 取得 name = accounts[i][0] // 第一個元素為名字  \n    → Step 3.2: 取得 emailList = accounts[i][1:] // 其餘元素為 email  \n    → Step 3.3: 將 emailList 中的每個 email 加入 email → 名稱對應表 // 確保名稱一致  \n    → Step 3.4: 對於 emailList 中的每一對 (emailA, emailB)  \n        → Step 3.4.1: 在 graph 中將 emailA 與 emailB 互相連接 // 建立邊  \n→ Step 4: 使用 DFS 或 Union‑Find 取得 email 群組 // 將相連的 email 聚合成一組  \n→ Step 5: 為每個群組建立結果帳號  \n    → Step 5.1: 取群組內任一 email 以取得 name 從 email → 名稱對應表  \n    → Step 5.2: 將群組內所有 email 取出並排序 // 依字典序排列  \n    → Step 5.3: 產生新帳號 = [name] + sortedEmails // 組裝最終帳號  \n    → Step 5.4: 將新帳號加入 outputList  \n→ End // 程式執行結束, outputList 為最終結果"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\ndef parse_input(raw):\n    # Convert the input string into a dictionary\n    raw = raw.strip()\n    raw = raw.replace('beginWord =', 'beginWord:')\n    raw = raw.replace('endWord =', 'endWord:')\n    raw = raw.replace('wordList =', 'wordList:')\n    raw = '{' + raw + '}'\n    try:\n        data = ast.literal_eval(raw)\n    except Exception:\n        data = {}\n    return data.get('beginWord'), data.get('endWord'), data.get('wordList', [])\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit(0)\n    beginWord, endWord, wordList = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: find all shortest transformation sequences from beginWord to endWord using word list, each adjacent word differs by one letter. Classic Word Ladder II problem. Need BFS to find shortest paths and backtrack. Provide pseudo-code steps line by line with explanations, using Start, Decision, etc. No actual code. Just structure. Provide line numbers? Not required. Use arrow. Each line: \"虛擬碼步驟 // 解釋\". Use \"Start\", \"End\". Provide BFS building adjacency map level by level, store parents. Then DFS to build paths.\n\nLet's craft steps.\n\nStart\n→ Initialize wordSet from wordList // convert to set for O(1) lookups\n→ Check if endWord not in wordSet // if not present, no path\n    Yes → Return empty list // no sequence exists\n    No  → Continue\n→ Initialize queue with beginWord // BFS frontier\n→ Initialize visited set with beginWord // words visited in previous levels\n→ Initialize levelVisited empty // words visited in current level\n→ Initialize parents map: word -> list of previous words // to reconstruct paths\n→ Initialize found flag false // indicates reached endWord\n→ While queue not empty and not found\n    → Pop current word\n    → For each character position i in current word\n        → For each letter 'a' to 'z'\n            → Generate newWord by replacing i-th char\n            → If newWord in wordSet and newWord not in visited\n                → If newWord not in levelVisited\n                    → Add to levelVisited\n                    → Add newWord to queue\n                → Append current word to parents[newWord] // record path\n                → If newWord == endWord\n                    → Set found true // reached target\n    → After processing all words in current level\n        → Add all words in levelVisited to visited // mark them visited for next levels\n        → Clear levelVisited\n→ If not found\n    → Return empty list // no shortest path\n→ Initialize result list // store all sequences\n→ Define recursive DFS function buildPath(word, path)\n    → If word == beginWord\n        → Append reversed path to result // full sequence\n        → Return\n    → For each prev in parents[word]\n        → Append prev to path\n        → Recursively call buildPath(prev, path)\n        → Remove prev from path\n→ Call buildPath(endWord, [endWord]) // start DFS\n→ Return result // all shortest sequences\nEnd\n\nNeed to ensure arrows properly. Provide in required format: each line with virtual code then // explanation. Use arrows. Use indentation for decisions? Provide \"Decision:\" line. Provide \"Yes →\" \"No →\" lines. Let's produce.\n\nUse \"Start\" line, then \"→\" lines. For loops, we just show as \"→ For each ...\" etc. Not actual syntax.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ 虛擬碼: 建立 wordSet ← Set(wordList) // 將字典轉成集合以便快速查詢  \n→ 虛擬碼: 判斷 endWord 是否存在於 wordSet  \n    Decision: endWord ∉ wordSet? // 若目標字不在字典中  \n        Yes → 虛擬碼: 回傳空清單 // 沒有可行路徑  \n        No  → 虛擬碼: 繼續執行  \n→ 虛擬碼: 初始化 queue ← [beginWord] // BFS 的佇列  \n→ 虛擬碼: visited ← {beginWord} // 已訪問過的字  \n→ 虛擬碼: levelVisited ← ∅ // 本層已發現的字  \n→ 虛擬碼: parents ← {} // 每個字的前驅字集合，用於回溯  \n→ 虛擬碼: found ← False // 是否已找到 endWord  \n→ 虛擬碼: 開始 while queue 非空 且 未 found  \n    → 虛擬碼: current ← pop(queue) // 取出當前字  \n    → 虛擬碼: For i 取 0 到 len(current)-1  \n        → 虛擬碼: For ch 取 'a' 到 'z'  \n            → 虛擬碼: newWord ← 替換 current 的第 i 位為 ch  \n            → 虛擬碼: 若 newWord 在 wordSet 且 newWord 未在 visited  \n                → Decision: newWord ∉ levelVisited? // 是否首次在本層出現  \n                    Yes → 虛擬碼: 加入 levelVisited ← newWord  \n                    Yes → 虛擬碼: 加入 queue ← newWord  \n                → 虛擬碼: parents[newWord] ← parents.get(newWord, []) ∪ {current} // 記錄前驅  \n                → Decision: newWord == endWord? // 是否達到目標  \n                    Yes → 虛擬碼: found ← True // 結束搜索  \n    → 虛擬碼: visited ← visited ∪ levelVisited // 本層已完成，將其標記為已訪問  \n    → 虛擬碼: levelVisited ← ∅ // 清空本層集合  \n→ 虛擬碼: 若 found 為 False  \n    → 虛擬碼: 回傳空清單 // 無最短路徑  \n→ 虛擬碼: 結果 ← [] // 儲存所有最短序列  \n→ 虛擬碼: 定義遞迴函式 buildPath(word, path)  \n    → 虛擬碼: 若 word == beginWord  \n        → 虛擬碼: results.append(path[::-1]) // 反轉為完整路徑  \n        → 虛擬碼: 回傳  \n    → 虛擬碼: For prev 在 parents.get(word, [])  \n        → 虛擬碼: path.append(prev) // 將前驅加入當前路徑  \n        → 虛擬碼: buildPath(prev, path) // 進一步回溯  \n        → 虛擬碼: path.pop() // 回溯  \n→ 虛擬碼: 調用 buildPath(endWord, [endWord]) // 從終點開始回溯  \n→ 虛擬碼: 回傳 results // 所有最短轉換序列  \nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar I",
      "source_file": "Leetcode/leetcode729.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpaom3cmro.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpaom3cmro.py\", line 45, in main\n    result = instance.book(*param)\n             ^^^^^^^^^^^^^\nAttributeError: 'NoneType' object has no attribute 'book'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MyCalendar:\n    \"\"\"簡易日曆，避免重疊事件。\"\"\"\n    def __init__(self):\n        self.bookings = []  # 以 (start, end) 形式儲存已預約的區間\n\n    def book(self, start: int, end: int) -> bool:\n        \"\"\"若可新增事件則回傳 True，否則回傳 False。\"\"\"\n        for s, e in self.bookings:\n            # 兩個區間若有非空交集，則不能新增\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\ndef main() -> None:\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 解析輸入，支援兩行或單行兩段的情況\n    if '\\n' in raw:\n        ops_str, args_str = raw.splitlines()[:2]\n    else:\n        # 找第一個閉括號，將其後作為第二個列表\n        idx = raw.find(']')\n        ops_str = raw[:idx+1]\n        args_str = raw[idx+2:]  # 跳過 '], '\n\n    ops = ast.literal_eval(ops_str)   # e.g. [\"MyCalendar\",\"book\",\"book\",\"book\"]\n    args = ast.literal_eval(args_str) # e.g. [[],[10,20],[15,25],[20,30]]\n\n    instance = None\n    output = [None]  # 建構子呼叫回傳 null\n\n    for method, param in zip(ops[1:], args[1:]):\n        if method == 'MyCalendar':\n            instance = MyCalendar()\n            output.append(None)\n        elif method == 'book':\n            # param 是 [start, end]\n            result = instance.book(*param)\n            output.append(result)\n        else:\n            # 如有其他方法，直接跳過或可自行擴充\n            output.append(None)\n\n    # 輸出符合 LeetCode 風格的 JSON\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code description for implementing MyCalendar class with book method. We need to do step-by-step pseudocode, with explanations. The virtual code lines should include arrows, decisions, etc. The language is Chinese (Traditional). We'll write line-by-line:\n\nStart\n→ Step 1: Define MyCalendar class with empty event list // store events\n→ Step 2: Constructor: initialize events list // no events initially\n→ Step 3: Method book(start, end): // attempt to book\n    → Decision: iterate over each event in events list // check for overlap\n        → Decision: if start < event.end AND end > event.start? // overlapping condition\n            Yes → Return false // cannot book due to double booking\n            No  → Continue loop // check next\n    → After loop: add new event (start, end) to events list // store booking\n    → Return true // booking successful\nEnd\n\nBut we need to include virtual code arrow style: \"→\" before steps, \"Decision:\" for conditions, \"Yes →\" etc. Also include comments after \"//\".\n\nAlso we should include Start and End markers.\n\nLet's produce the output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCalendar 類別，內部保留 events 列表 // 用來儲存已預約的區間  \n→ Step 2: MyCalendar() 初始化函式  \n  → events ← [] // 初始時沒有任何預約  \n→ Step 3: book(start, end) 方法  \n  → Decision: 迭代 events 中的每一個 (s, e) // 檢查與已存在預約是否衝突  \n    Yes → Decision: start < e AND end > s? // 判斷兩區間是否有交集  \n      Yes → Return false // 發現衝突，不能預約  \n      No  → Continue // 無衝突，繼續檢查下一個預約  \n  → 迭代結束後  \n   → events.add((start, end)) // 將新預約加入列表  \n   → Return true // 預約成功  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,6,6,0,1,1,0,1]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 6, 6, 0, 1, 1, 0, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        index = random.randint(0, self.size - 1)\n        return self.mapping.get(index, index)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            res.append(None)\n        elif op == \"pick\":\n            res.append(obj.pick())\n        else:\n            # For safety, ignore unknown operations\n            res.append(None)\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps. Provide explanation each line. Use virtual code with arrows. Need to implement algorithm that picks random from [0, n-1] excluding blacklist, uniformly, with minimal random calls.\n\nStandard solution: Map blacklisted numbers in [0, n-1] to whitelist numbers in [0, n-1] that are not blacklisted but in range M = n - blacklist.length. Use a dictionary mapping from blacklisted number < M to some white number >= M not blacklisted. Then pick a random integer k in [0, M-1] uniformly. If k in mapping, return mapping[k], else return k.\n\nSo steps: preprocess: set of blacklist. Compute M = n - len(blacklist). For each b in blacklist: if b < M, store it for mapping. Compute set of \"available\" white numbers >= M (non-blacklisted). Use pointer. Build mapping dict. Then pick: generate random integer r in [0, M-1], if r in map, return map[r] else r.\n\nLet's produce virtual code with explanations. Ensure each line starts with \"虛擬碼步驟\" but actually we output lines like:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化參數 n, blacklist // 取得輸入\n\n→ Step 2: 計算 M = n - blacklist.size // 可用白色數量\n\n… and so on. Use decision structure for mapping building? We can just iterate.\n\nAlso need to mention min random calls: each pick uses 1 random call. Preprocessing uses O(b) time and memory.\n\nLet's output. Use 虛擬碼箭頭 \"→\" before each step. Provide comment.\n\nWe need to ensure we don't output actual code; just virtual code. Provide explanation for each line. Use \"Step\" naming. Use \"Decision:\" when needed. But mapping building may not need decision. Use \"For each b in blacklist:\" as pseudo.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收參數 n 與 blacklist // 初始化類別屬性  \n→ Step 2: 計算 M = n - blacklist.size // 可被隨機選取的白色數量  \n→ Step 3: 建立集合 blacklistSet，將所有黑名單數字加入 // 方便 O(1) 判斷  \n→ Step 4: 建立空字典 mapping // 用於將小於 M 的黑名單映射到白色數字  \n→ Step 5: 建立指標 last = n - 1 // 指向可用白色數字的最高端  \n→ Decision: 需要對所有黑名單數字做處理? // 循環遍歷黑名單  \n    Yes → For each b in blacklist:  \n        → Decision: b < M? // 只處理落在 [0, M-1] 範圍內的黑名單  \n            Yes → Decision: last 位置是否為黑名單? // 需要跳過已被映射的白色數字  \n                Yes → While blacklistSet.contains(last):  \n                    → last ← last - 1 // 找到下一個不在黑名單的白色數字  \n                No  → // last 已是合法白色數字  \n            No  → // b >= M，無需映射  \n        → mapping[b] ← last // 將 b 映射到合法白色數字  \n        → last ← last - 1 // 移動指標，準備下一個映射  \n→ Step 6: 完成 mapping 構建 // 只需一次遍歷，即可得到所有必要映射  \n→ Step 7: 定義 pick() 方法  \n    → Step 7.1: 生成隨機整數 r ∈ [0, M-1] // 只呼叫一次隨機函式  \n    → Decision: r 是否存在於 mapping? // 判斷 r 是否為映射的黑名單索引  \n        Yes → Return mapping[r] // 回傳對應的白色數字  \n        No  → Return r // 直接回傳 r  \nEnd // 程式結束，pick() 可隨機返回非黑名單數字，且每個白色數字等機會被選中。"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3ehm3rfn.py\", line 66, in <module>\n    main()\n  File \"/tmp/tmp3ehm3rfn.py\", line 45, in main\n    ops, args = parse_input(raw_data)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp3ehm3rfn.py\", line 40, in parse_input\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [ [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MapSum:\n    def __init__(self):\n        self._dict = {}\n\n    def insert(self, key: str, val: int) -> None:\n        \"\"\"插入或覆蓋 key 對應的值\"\"\"\n        self._dict[key] = val\n\n    def sum(self, prefix: str) -> int:\n        \"\"\"回傳所有以 prefix 為前綴的 key 的值之和\"\"\"\n        return sum(v for k, v in self._dict.items() if k.startswith(prefix))\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串轉成兩個列表：\n    ops  : 方法名清單\n    args : 參數清單\n    支援兩種格式：\n        1. 兩個 JSON 清單以 ', ' 分隔（如範例）\n        2. 兩行分別為 ops 與 args\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], []\n\n    # 判斷是否為「list1, list2」格式\n    if ',' in data and data.count(']') >= 2:\n        parts = data.split('],', 1)\n        ops_str = parts[0] + ']'\n        args_str = '[' + parts[1]\n    else:\n        lines = data.splitlines()\n        ops_str = lines[0].strip()\n        args_str = lines[1].strip() if len(lines) > 1 else '[]'\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\ndef main():\n    raw_data = sys.stdin.read()\n    ops, args = parse_input(raw_data)\n\n    res = None\n    output = []\n\n    for i, op in enumerate(ops):\n        if op == 'MapSum':\n            res = MapSum()\n            output.append(None)\n        elif op == 'insert':\n            res.insert(*args[i])\n            output.append(None)\n        elif op == 'sum':\n            val = res.sum(*args[i])\n            output.append(val)\n\n    # 將 None 轉為 JSON 中的 null 以符合預期輸出格式\n    out_str = '[' + ', '.join('null' if v is None else str(v) for v in output) + ']'\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with comments. Not actual code. Must follow format: each line has virtual code step, space, // explanation. Use Start, End, Decision. We need to design a MapSum class with methods insert and sum. Also we need data structures: maybe Trie with cumulative sums. Provide pseudocode steps: Initialize root node, with map children and sum. Insert: traverse nodes, accumulate old value difference. Keep dictionary to track current values. Sum: traverse prefix nodes, return sum. Provide steps. We need to produce step-by-step algorithm, not actual implementation. Let's outline steps.\n\nWe'll show Start, then steps to create MapSum. Then Insert and Sum methods. Use Decision blocks? For override logic. We need to track if key exists, oldVal else 0. So Decision: if key in map? Yes => oldVal = map[key], else 0. diff = val - oldVal. Update map[key] = val. Then traverse trie, update node sum += diff.\n\nSum: traverse prefix nodes; if node missing return 0. Else return node.sum.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 建立 MapSum 類別，含 root TrieNode、字典 keyToVal，並初始化 root.sum = 0 // 初始化資料結構\n→ Step 2: 定義 TrieNode，含 children map 及 sum // 每個節點保存前綴總和\n→ Step 3: MapSum() 建構子 // 建構 MapSum 物件\n    → Step 4: root ← 新 TrieNode() // 創建根節點\n    → Step 5: keyToVal ← 空字典 // 用於儲存 key 與其值\n→ Step 6: void insert(key, val) // 插入或覆蓋 key\n    → Step 7: 如果 key 在 keyToVal? // 檢查 key 是否已存在\n        Yes → Step 8: oldVal ← keyToVal[key] // 取得舊值\n        No  → Step 9: oldVal ← 0 // 沒有則舊值為 0\n    → Step 10: diff ← val - oldVal // 計算值差\n    → Step 11: keyToVal[key] ← val // 更新 key 對應值\n    → Step 12: node ← root // 從根節點開始\n    → Step 13: node.sum ← node.sum + diff // 更新根節點總和\n    → Step 14: 逐字元 ch 在 key 中\n        → Step 15: 如果 ch 不在 node.children? // 子節點不存在\n            Yes → Step 16: node.children[ch] ← 新 TrieNode() // 建立新節點\n        → Step 17: node ← node.children[ch] // 進入子節點\n        → Step 18: node.sum ← node.sum + diff // 更新此節點總和\n→ Step 19: int sum(prefix) // 計算前綴總和\n    → Step 20: node ← root // 從根節點開始\n    → Step 21: 逐字元 ch 在 prefix 中\n        → Step 22: 如果 ch 不在 node.children? // 前綴不存在\n            Yes → Step 23: return 0 // 前綴無匹配，返回 0\n        → Step 24: node ← node.children[ch] // 進入子節點\n    → Step 25: return node.sum // 返回前綴節點總和\nEnd // 程式執行結束\n\nMake sure each line ends with // explanation. Also use proper indentation? Not required but lines show steps. Use arrows. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 MapSum 類別，含 root TrieNode、字典 keyToVal，並初始化 root.sum = 0 // 初始化資料結構  \n→ Step 2: 定義 TrieNode，含 children map 及 sum // 每個節點保存前綴總和  \n→ Step 3: MapSum() 建構子 // 建構 MapSum 物件  \n → Step 4: root ← 新 TrieNode() // 創建根節點  \n → Step 5: keyToVal ← 空字典 // 用於儲存 key 與其值  \n→ Step 6: void insert(key, val) // 插入或覆蓋 key  \n → Step 7: 如果 key 在 keyToVal? // 檢查 key 是否已存在  \n  Yes → Step 8: oldVal ← keyToVal[key] // 取得舊值  \n  No  → Step 9: oldVal ← 0 // 沒有則舊值為 0  \n → Step 10: diff ← val - oldVal // 計算值差  \n → Step 11: keyToVal[key] ← val // 更新 key 對應值  \n → Step 12: node ← root // 從根節點開始  \n → Step 13: node.sum ← node.sum + diff // 更新根節點總和  \n → Step 14: 逐字元 ch 在 key 中  \n  → Step 15: 如果 ch 不在 node.children? // 子節點不存在  \n   Yes → Step 16: node.children[ch] ← 新 TrieNode() // 建立新節點  \n  → Step 17: node ← node.children[ch] // 進入子節點  \n  → Step 18: node.sum ← node.sum + diff // 更新此節點總和  \n→ Step 19: int sum(prefix) // 計算前綴總和  \n → Step 20: node ← root // 從根節點開始  \n → Step 21: 逐字元 ch 在 prefix 中  \n  → Step 22: 如果 ch 不在 node.children? // 前綴不存在  \n   Yes → Step 23: return 0 // 前綴無匹配，返回 0  \n  → Step 24: node ← node.children[ch] // 進入子節點  \n → Step 25: return node.sum // 返回前綴節點總和  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.14757149626810775,0.08372307953884844],[0.62825850695437,0.21418239848463055],[0.27701484659912334,-0.33105003794084925]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.14757149626810775, 0.08372307953884844], [0.62825850695437, 0.21418239848463055], [0.27701484659912334, -0.33105003794084925]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())  # 保證均勻分布\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n\n    # 第一行是方法名列表，第二行是對應的參數列表\n    methods = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    obj = None\n    outputs = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            outputs.append(None)  # LeetCode 用 null 表示 None\n        elif method == \"randPoint\":\n            result = obj.randPoint()\n            outputs.append(result)\n        else:\n            # 若有其他方法，直接忽略或可擴充\n            outputs.append(None)\n\n    # 用 JSON 轉成字串並輸出\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step. Use Start, End, Decision, etc. Must not output actual code. Just steps.\n\nWe need to implement a class with constructor and method randPoint. The algorithm: generate random point uniformly inside circle. Approach: generate random angle uniform [0,2π), random radius sqrt(random) * radius to ensure uniform distribution. Then x = x_center + r*cosθ, y = y_center + r*sinθ. So virtual steps: initialization, storing values, method randPoint: generate random u in [0,1], set r = sqrt(u)*radius; generate angle = 2π*random; compute x, y; return array [x,y].\n\nWe produce each step. Use arrows.\n\nWe must ensure each line is a step. Possibly group into steps: e.g., Step 1: Set class attributes. Step 2: Define randPoint method. Within, Step 3: Generate random number u. etc.\n\nNeed to keep arrow usage.\n\nWe should include comments after //.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Solution 類別並接收 radius、x_center、y_center // 建立物件並存入圓半徑及中心座標  \n→ Step 2: 在建構子中將 radius、x_center、y_center 存成類別屬性 // 方便 randPoint 內部使用  \n→ Step 3: 定義 randPoint 方法 // 回傳隨機點的主入口  \n→ Decision: randPoint 方法內部進行以下操作？ // 準備隨機生成流程  \n  Yes → Step 4: 產生一個 0 到 1 之間的隨機數 u // 作為半徑的比例因子  \n  Yes → Step 5: 計算 r = sqrt(u) * radius // 取得符合均勻分佈的半徑  \n  Yes → Step 6: 產生一個 0 到 2π 之間的隨機角度 θ // 確保方向均勻  \n  Yes → Step 7: 計算 x = x_center + r * cos(θ) // 求出橫向座標  \n  Yes → Step 8: 計算 y = y_center + r * sin(θ) // 求出縱向座標  \n  Yes → Step 9: 回傳陣列 [x, y] // 產生的隨機點  \nEnd // 程式執行結束"
    },
    {
      "title": "Target Sum",
      "source_file": "Leetcode/leetcode494.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,1,1], target = 3",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpefdqost7.py\", line 29, in <module>\n    nums = eval(nums_str)        # 轉成 list\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def findTargetSumWays(self, nums, target):\n        # 動態規劃：dp[sum] 表示目前能得到的 sum 的組合數\n        dp = defaultdict(int)\n        dp[0] = 1  # 初始時只有 0 的組合數為 1\n\n        for num in nums:\n            next_dp = defaultdict(int)\n            for s, count in dp.items():\n                next_dp[s + num] += count\n                next_dp[s - num] += count\n            dp = next_dp\n\n        return dp[target]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 範例輸入形式：'nums = [1,1,1,1,1], target = 3'\n    # 先移除變量名稱，得到 '[1,1,1,1,1] 3'\n    if raw_input:\n        parts = raw_input.replace(\"nums =\", \"\").replace(\"target =\", \"\").split(\",\")\n        nums_str = parts[0].strip()\n        target_str = parts[1].strip() if len(parts) > 1 else \"\"\n        nums = eval(nums_str)        # 轉成 list\n        target = int(target_str)     # 轉成 int\n    else:\n        nums = []\n        target = 0\n\n    solution = Solution()\n    result = solution.findTargetSumWays(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code. The problem: Count number of ways to assign + or - to each integer such that sum equals target. It's like subset sum count. We need dynamic programming or recursion. Provide virtual code steps line by line.\n\nNeed to include arrow structure: Start, → Step, Decision, End.\n\nProvide each line with comment after space. Provide explanation. Ensure no actual code. Just virtual steps. We'll do algorithm: use recursion with memoization, or DP.\n\nWe'll produce steps: Start, Input array, Input target, Set memo, define recursive function dfs(index, currentSum). Base case: index==len(nums): if currentSum==target return 1 else 0. Else return dfs(index+1, currentSum+nums[index]) + dfs(index+1, currentSum-nums[index]). Return result. End.\n\nLet's craft step-by-step.\n\nWe'll use steps: Step 1: Input nums, target. Step 2: Initialize memo. Step 3: Define recursive function. Step 4: Call dfs. Step 5: Return result. End.\n\nLet's produce each line with arrow. Use \"→\" arrow. Provide explanation. Use indentation for decisions inside function? Could do Decision for base case.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取整數陣列 nums 與目標值 target // 從使用者取得輸入\n→ Step 2: 初始化記憶化表 memo // 用於儲存已計算子問題的結果\n→ Step 3: 定義遞迴函式 dfs(index, current) // index 是目前處理的位置，current 為已累加的總和\n    → Decision: 若 index 等於 nums 長度? // 到達陣列末尾\n        Yes → Step 4: 若 current 等於 target? // 檢查是否達成目標\n            Yes → Step 5: 回傳 1 // 找到一個有效表達式\n            No  → Step 6: 回傳 0 // 不是有效表達式\n        No  → Step 7: 先檢查 memo 是否已有結果 // 避免重複計算\n            Yes → Step 8: 回傳 memo[index][current] // 直接回傳已計算值\n            No  → Step 9: 先計算加法結果 sumAdd = dfs(index+1, current + nums[index]) // 加號\n            → Step 10: 再計算減法結果 sumSub = dfs(index+1, current - nums[index]) // 減號\n            → Step 11: total = sumAdd + sumSub // 總和\n            → Step 12: 存入 memo[index][current] = total // 記錄結果\n            → Step 13: 回傳 total // 回傳此子問題結果\n→ Step 14: 呼叫 dfs(0, 0) 並將回傳值存入 result // 從頭開始計算\n→ Step 15: 回傳 result // 結果即為符合 target 的表達式數量\nEnd // 程式執行結束\n\nBut ensure each line separate. Use \"→\" and \"Decision:\" lines. Let's format correctly: Each line start with arrow or Step.\n\nWill output as block with each line. Use \"→\" before step lines. Use indentation for Decision block. Use \"Yes →\" and \"No →\" lines.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數陣列 nums 與目標值 target // 從使用者取得輸入  \n→ Step 2: 初始化記憶化表 memo // 用於儲存已計算子問題的結果  \n→ Step 3: 定義遞迴函式 dfs(index, current) // index 是目前處理的位置，current 為已累加的總和  \n  → Decision: 若 index 等於 nums 長度? // 到達陣列末尾  \n   Yes → Step 4: 若 current 等於 target? // 檢查是否達成目標  \n    Yes → Step 5: 回傳 1 // 找到一個有效表達式  \n    No  → Step 6: 回傳 0 // 不是有效表達式  \n   No  → Step 7: 先檢查 memo 是否已有結果 // 避免重複計算  \n    Yes → Step 8: 回傳 memo[index][current] // 直接回傳已計算值  \n    No  → Step 9: sumAdd = dfs(index+1, current + nums[index]) // 加號  \n    → Step 10: sumSub = dfs(index+1, current - nums[index]) // 減號  \n    → Step 11: total = sumAdd + sumSub // 總和  \n    → Step 12: 存入 memo[index][current] = total // 記錄結果  \n    → Step 13: 回傳 total // 回傳此子問題結果  \n→ Step 14: result = dfs(0, 0) // 從頭開始計算  \n→ Step 15: 回傳 result // 結果即為符合 target 的表達式數量  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,2,1],[1,2,3],[2,1,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [3, 2, 1], [1, 2, 3], [2, 1, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"初始化時保留原始陣列的複本。\"\"\"\n        self.original = list(nums)\n        self.n = len(nums)\n\n    def reset(self):\n        \"\"\"回傳原始陣列的複本。\"\"\"\n        return list(self.original)\n\n    def shuffle(self):\n        \"\"\"使用 Fisher‑Yates 洗牌演算法隨機打亂陣列。\"\"\"\n        arr = list(self.original)\n        n = self.n\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：第一部分為指令清單，第二部分為每個指令的參數清單\n    split_index = data.find('],')\n    if split_index == -1:\n        # 如果找不到 '],'，就以逗號切分（備用方案）\n        parts = data.split(',')\n        commands_str, args_str = parts[0], parts[1]\n    else:\n        commands_str = data[:split_index + 1]      # 包含結尾的 ']'\n        args_str = data[split_index + 2 :]         # 跳過 '],'\n\n    try:\n        commands = ast.literal_eval(commands_str)\n        args = ast.literal_eval(args_str)\n    except Exception:\n        # 如上面失敗，嘗試使用 json 解析\n        commands = json.loads(commands_str)\n        args = json.loads(args_str)\n\n    results = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            # 建構子只需要第一個參數（原始陣列）\n            obj = Solution(arg[0])\n            results.append(None)          # 代表 null\n        elif cmd == \"reset\":\n            results.append(obj.reset())\n        elif cmd == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            results.append(None)\n\n    # 輸出結果，使用 json.dumps 以得到 null 的格式\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this algorithm. We need to think about typical solution: store original array copy, shuffle via Fisher-Yates. Steps: constructor copies array, reset returns copy, shuffle clones array and perform random shuffle.\n\nWe need to provide step-by-step virtual code with explanations, line by line, using arrow notation.\n\nWe must not output actual code, just pseudo steps.\n\nWe need to handle the methods: constructor, reset, shuffle.\n\nWe'll produce steps like:\n\nStart\n→ Step 1: Define class Solution\n→ Step 2: Constructor receives nums\n→ Step 3: Store original array copy\n→ Step 4: Store length\n→ End Constructor\n→ Step 5: reset method returns a clone of original array\n→ Step 6: shuffle method creates a clone of original array\n→ Step 7: For i from 0 to n-1\n→ Step 8: Generate random index j between i and n-1\n→ Step 9: Swap elements at i and j\n→ Step 10: Return shuffled array\nEnd\n\nBut we need each line to have the arrow and explanation. Use \"→\" arrow each line after Start/End. Also we need Decision lines? Not necessary for algorithm but we might include a Decision if needed. But we don't need Decision.\n\nThe formatting must be:\n\nStart // 程式開始執行\n→ Step 1: 定義 Solution 類別 // ...\nEnd // 程式執行結束\n\nBut we need to separate methods maybe as sub-blocks. Use indentation? Not necessary but can show nested lines with indent maybe.\n\nBetter to produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 Solution 類別 // 建立類別\n→ Step 2: Constructor: 參數 nums // 接收初始陣列\n→ Step 3: 原始陣列 copy = 複製 nums // 保存原始配置\n→ Step 4: length = nums.length // 儲存長度\n→ End Constructor // 結束建構\n→ Step 5: reset() 方法 // 重設陣列\n→ Step 6: return 複製 copy // 回傳原始配置\n→ Step 7: shuffle() 方法 // 隨機洗牌\n→ Step 8: result = 複製 copy // 先複製一份\n→ Step 9: for i from 0 to length-1 // 逐個位置\n→ Step 10: j = 隨機整數 i 之間 到 length-1 // 隨機選取\n→ Step 11: swap result[i] 與 result[j] // 交換\n→ Step 12: end for\n→ Step 13: return result // 回傳洗牌結果\nEnd // 程式結束\n\nAdd arrow for each step. Provide explanation after //.\n\nWe must ensure we use only virtual code syntax: maybe \"Step 1:\" etc. We can use arrow \"→\". Must not output real code. Should be straightforward.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Solution 類別 // 建立用於處理洗牌的類  \n→ Step 2: Constructor(nums) // 接收原始整數陣列  \n→ Step 3: original ← 複製 nums // 儲存原始配置，避免被改動  \n→ Step 4: n ← nums.length // 記錄陣列長度，便於後續運算  \n→ End Constructor // 結束建構  \n\n→ Step 5: reset() 方法 // 重設陣列至原始狀態  \n→ Step 6: return 複製 original // 回傳一份原始陣列的複本  \n\n→ Step 7: shuffle() 方法 // 產生等機率的隨機排列  \n→ Step 8: shuffled ← 複製 original // 先做一份可變的複本  \n→ Step 9: for i ← 0 to n-1 // 逐個位置進行交換  \n→ Step 10: j ← 隨機整數 [i, n-1] // 隨機選取 i 之後的任意位置  \n→ Step 11: swap shuffled[i] 與 shuffled[j] // 交換兩個元素  \n→ Step 12: end for  \n→ Step 13: return shuffled // 回傳洗牌後的陣列  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Comments",
      "source_file": "Leetcode/leetcode722.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "source = [\"a/*comment\", \"line\", \"more_comment*/b\"]",
          "expected_output": "[\"ab\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"ab\"]'\nGot (Norm):      '[\"b\"]'\n--- (Raw) ---\nRaw Expected: '[\"ab\"]'\nRaw Got:      '[\"b\"]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def removeComments(self, source):\n        res = []\n        in_block = False\n        for line in source:\n            i = 0\n            new_line = []\n            while i < len(line):\n                # Start of a block comment\n                if (not in_block and i + 1 < len(line) and\n                    line[i] == '/' and line[i + 1] == '*'):\n                    in_block = True\n                    i += 2\n                    continue\n                # End of a block comment\n                if (in_block and i + 1 < len(line) and\n                    line[i] == '*' and line[i + 1] == '/'):\n                    in_block = False\n                    i += 2\n                    continue\n                # Start of a line comment\n                if (not in_block and i + 1 < len(line) and\n                    line[i] == '/' and line[i + 1] == '/'):\n                    break\n                # Normal code character\n                if not in_block:\n                    new_line.append(line[i])\n                i += 1\n            if new_line and not in_block:\n                res.append(''.join(new_line))\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    # Extract the list representation from the input string\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        source = []\n    else:\n        list_str = data[start:end+1]\n        try:\n            source = ast.literal_eval(list_str)\n        except Exception:\n            source = []\n    solution = Solution()\n    result = solution.removeComments(source)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to remove comments from C++ source array of strings. Output each step line with explanation comment. We need to follow format. Provide algorithm: iterate lines, maintain state inside block comment. Build result lines list. Use string builder per line. Handle cases: while scanning each line, if currently inside block comment, search for \"*/\" else search for \"//\" and \"/*\" etc. Should be careful with precedence: first effective comment in line determines ignoring rest. Implementation details: Use index scanning. Steps: Start, initialize variables, iterate lines, for each line, set i=0, if not in block, start new builder, while i < len, check if not in block: if line[i:i+2] == \"/*\": set block=true, i+=2, continue; if line[i:i+2] == \"//\": break; else append char, i++; else (in block): find \"*/\" index; if found: block=false; i=pos+2; else break loop. After loop, if not in block and builder not empty: add to result. End. Provide virtual code steps.\n\nNeed to follow arrow syntax: Use \"→\" for normal steps. Use Decision lines. Provide explanation comments after //.\n\nLet's produce lines accordingly. Need to start with Start, then steps.\n\nWill include loop over lines: \"→ For each line in source:\". Inside need index loop. Use decision to check inBlock. Let's create variables: result list, inBlock bool, current string builder.\n\nOk.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行\n→ 初始化 result 為空列表 // 用於儲存處理後的每一行\n→ 初始化 inBlock 為 False // 判斷是否處於區塊註解內\n→ 初始化 current 為空字符串 // 用於暫存當前行中未被註解的內容\n→ For each line in source: // 逐行處理原始程式碼\n    → 設定 i 為 0 // 索引指向行首\n    → Decision: 是否在區塊註解中? // 判斷是否仍處於前一行啟動的 block comment\n        Yes → Decision: 當前行是否還包含「*/」? // 找到區塊註解結束位置\n            Yes → 設定 endIdx 為「*/」的起始索引 // 找到結束位置\n            → 將 inBlock 設為 False // 區塊註解結束\n            → 將 i 更新為 endIdx + 2 // 跳過「*/」\n            No  → // 未找到結束，整行都屬於註解\n                → 跳至下一行 // 跳過此行剩餘處理\n    No  → // 當前不在區塊註解內，開始逐字符掃描\n        → Decision: i 已到行尾? // 是否已經處理完整行\n            Yes → // 完成掃描，結束內層循環\n            No  → // 仍有字符可處理\n                → Decision: 從 i 開始的兩個字符為「/*」? // 檢測區塊註解起始\n                    Yes → \n                        → 設定 inBlock 為 True // 開始區塊註解\n                        → 將 i 增加 2 // 跳過「/*」\n                    No  →\n                        → Decision: 從 i 開始的兩個字符為「//」? // 檢測行註解起始\n                            Yes → // 行註解開始，忽略此行剩餘\n                                → 跳至下一行\n                            No  →\n                                → 將 line[i] 加到 current // 這個字符是有效程式碼\n                                → 將 i 增加 1 // 移到下一個字符\n    → Decision: 是否已處理完此行且不在區塊註解中? // 檢查是否可以將 current 加入結果\n        Yes → Decision: current 是否非空? // 只輸出非空行\n            Yes → \n                → 將 current 加到 result // 添加清理後的行\n                → 將 current 設為空字符串 // 重置\n            No → // current 為空，跳過輸出\n        No → // 仍在區塊註解中，忽略此行不輸出\nEnd // 程式執行結束，返回 result。"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])          # 先將目前子集加入結果\n            for i in range(start, len(nums)):\n                path.append(nums[i])     # 加入新元素\n                backtrack(i + 1, path)   # 深入遞迴\n                path.pop()               # 回溯\n        backtrack(0, [])\n        return res\n\ndef format_output(subsets):\n    \"\"\"將子集列表轉成不含空格的字串形式。\"\"\"\n    parts = []\n    for subset in subsets:\n        if not subset:\n            parts.append('[]')\n        else:\n            parts.append('[' + ','.join(str(x) for x in subset) + ']')\n    return '[' + ','.join(parts) + ']'\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從字串中擷取列表部分\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums_str = match.group()\n        nums = ast.literal_eval(nums_str)   # 安全地解析成列表\n    else:\n        nums = []\n\n    # 計算所有子集\n    solution = Solution()\n    subsets = solution.subsets(nums)\n\n    # 以符合範例的格式輸出\n    output = format_output(subsets)\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating power set of a list of unique integers, no duplicates. Likely use backtracking or iterative bitmask. Use recursion. Output steps. Use Start, End, Decision etc. Provide each line as \"Step: ...\" with comment.\n\nWe need to adhere to format: each line \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow. Use Start, End, Decision. Provide in Chinese (繁體). Use no real code, just virtual.\n\nWe'll produce something like:\n\nStart // 程式開始\n→ Step 1: 初始化空集合 subsets = [] // 用於存放所有子集\n→ Step 2: 定義遞歸函數 backtrack(start, current) // 產生子集\n→ Decision: 是否已經遍歷完所有元素? // 判斷是否到尾\n    Yes → Step 3: 將 current 加入 subsets // 保存當前子集\n    No  → Step 4: 循環遍歷索引 i 從 start 到 nums.length-1 // 選取元素\n        → Step 5: 將 nums[i] 加入 current // 暫時加入\n        → Step 6: 呼叫 backtrack(i+1, current) // 深入遞歸\n        → Step 7: 移除 nums[i] 從 current // 回溯\nEnd // 程式結束\n\nBut need \"Start\" and \"End\" maybe separate lines. Also include Step numbering. Provide arrow lines. Use \"Decision:\" for decisions.\n\nLet's produce final answer accordingly. Ensure each line ends with comment.\n\nUse \"→\" to indicate arrow lines. For decisions indent with arrow to next lines? The example shows indentation for nested.\n\nWe'll follow that style.\n\nAlso \"Step 1: ...\" etc.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 初始化空集合 subsets = [] // 用於存放所有子集\n\n→ Step 2: 定義遞歸函數 backtrack(start, current) // 產生子集的核心函數\n\n    → Decision: 是否已經遍歷完所有元素? // 判斷是否到達陣列尾端\n        Yes → Step 3: 將 current 加入 subsets // 把目前的子集保存到結果中\n        No  → Step 4: 循環遍歷索引 i 從 start 到 nums.length-1 // 為每個可選元素進行嘗試\n\n            → Step 5: 將 nums[i] 加入 current // 暫時把元素加入子集\n            → Step 6: 呼叫 backtrack(i+1, current) // 進行遞歸深度優先探索\n            → Step 7: 從 current 移除 nums[i] // 回溯，恢復到上一狀態\n\nEnd // 程式結束"
    },
    {
      "title": "Reconstruct Original Digits from English",
      "source_file": "Leetcode/leetcode423.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '012'\nGot (Norm):      '0127'\n--- (Raw) ---\nRaw Expected: '\"012\"'\nRaw Got:      '0127'"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '45'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"45\"'\nRaw Got:      '457'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def originalDigits(self, s: str) -> str:\n        count = Counter(s)\n        out = {}\n        # Unique letters for specific digits\n        out['0'] = count['z']\n        out['2'] = count['w']\n        out['4'] = count['u']\n        out['6'] = count['x']\n        out['8'] = count['g']\n        # Remaining digits after removing unique ones\n        out['3'] = count['h'] - out['8']\n        out['5'] = count['f'] - out['4']\n        out['7'] = count['s'] - out['6']\n        out['1'] = count['o'] - out['0'] - out['2'] - out['4']\n        out['9'] = count['i'] - out['5'] - out['6'] - out['8']\n        # Build result string in ascending order\n        result = []\n        for digit in sorted(out.keys()):\n            result.append(digit * out[digit])\n        return ''.join(result)\n\ndef main():\n    # Read entire stdin input\n    data = sys.stdin.read()\n    # Extract all alphabetic characters to form the scrambled string\n    s = ''.join(re.findall(r'[a-zA-Z]', data))\n    sol = Solution()\n    print(sol.originalDigits(s))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. Task: given string s with scrambled English representation of digits 0-9, return digits sorted ascending. This is similar to LeetCode 423 Reconstruct Original Digits from English. The algorithm: count letters, identify unique letters for digits: 'z'->0, 'w'->2, 'u'->4, 'x'->6, 'g'->8. Then after removing those digits, identify 'o'->1, 'h'->3, 'f'->5, 's'->7, 'i'->9. Count accordingly. So virtual code lines: start, input s, count freq, step to identify each digit, build output string.\n\nWe need to output line by line with arrow. Let's produce as requested.\n\nProbably include decision steps for each letter.\n\nOk produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者處取得混亂的英文數字字串  \n→ Step 2: 初始化字母頻率表 freq[26] = 0 // 用 26 個元素計算每個字母出現次數  \n→ Step 3: 為每個字母 c in s: freq[c - 'a']++ // 累積字母出現頻率  \n\n→ Decision: 檢查字母 'z' 是否存在? // 'z' 只屬於 \"zero\"  \n    Yes → Step 4: 讀取 count = freq['z' - 'a']  \n        → Step 5: 將 0 重複 count 次加入結果列表 digitCounts[0]  \n        → Step 6: 對於每個字母 'z','e','r','o': freq[letter - 'a'] -= count // 移除已計算字母  \n\n→ Decision: 檢查字母 'w' 是否存在? // 'w' 只屬於 \"two\"  \n    Yes → Step 7: count = freq['w' - 'a']  \n        → Step 8: digitCounts[2] += count  \n        → Step 9: 對於 't','w','o': freq[...] -= count  \n\n→ Decision: 檢查字母 'u' 是否存在? // 'u' 只屬於 \"four\"  \n    Yes → Step 10: count = freq['u' - 'a']  \n        → Step 11: digitCounts[4] += count  \n        → Step 12: 對於 'f','o','u','r': freq[...] -= count  \n\n→ Decision: 檢查字母 'x' 是否存在? // 'x' 只屬於 \"six\"  \n    Yes → Step 13: count = freq['x' - 'a']  \n        → Step 14: digitCounts[6] += count  \n        → Step 15: 對於 's','i','x': freq[...] -= count  \n\n→ Decision: 檢查字母 'g' 是否存在? // 'g' 只屬於 \"eight\"  \n    Yes → Step 16: count = freq['g' - 'a']  \n        → Step 17: digitCounts[8] += count  \n        → Step 18: 對於 'e','i','g','h','t': freq[...] -= count  \n\n→ Decision: 檢查字母 'o' 是否存在? // 'o' 現在只屬於 \"one\"  \n    Yes → Step 19: count = freq['o' - 'a']  \n        → Step 20: digitCounts[1] += count  \n        → Step 21: 對於 'o','n','e': freq[...] -= count  \n\n→ Decision: 檢查字母 'h' 是否存在? // 'h' 現在只屬於 \"three\"  \n    Yes → Step 22: count = freq['h' - 'a']  \n        → Step 23: digitCounts[3] += count  \n        → Step 24: 對於 't','h','r','e','e': freq[...] -= count  \n\n→ Decision: 檢查字母 'f' 是否存在? // 'f' 現在只屬於 \"five\"  \n    Yes → Step 25: count = freq['f' - 'a']  \n        → Step 26: digitCounts[5] += count  \n        → Step 27: 對於 'f','i','v','e': freq[...] -= count  \n\n→ Decision: 檢查字母 's' 是否存在? // 's' 現在只屬於 \"seven\"  \n    Yes → Step 28: count = freq['s' - 'a']  \n        → Step 29: digitCounts[7] += count  \n        → Step 30: 對於 's','e','v','e','n': freq[...] -= count  \n\n→ Decision: 檢查字母 'i' 是否存在? // 'i' 現在只屬於 \"nine\"  \n    Yes → Step 31: count = freq['i' - 'a']  \n        → Step 32: digitCounts[9] += count  \n        → Step 33: 對於 'n','i','n','e': freq[...] -= count  \n\n→ Step 34: 建立結果字串 result = \"\"  \n→ Step 35: 從 0 到 9 逐位 for d in 0..9:  \n    → Step 36: 重複 digitCounts[d] 次將字符 ('0'+d) 加入 result // 依序組合升序數字  \n\nEnd // 程式執行結束，輸出升序排列的數字字串 result"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpm9_k7auy.py\", line 22, in <module>\n    methods, args = json.loads(raw_input)\n                    ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 49 (char 48)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入字串\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析成兩個列表：方法名與對應參數\n    methods, args = json.loads(raw_input)\n\n    result = []\n    obj = None  # 會存放 NumArray 物件\n\n    for i, method in enumerate(methods):\n        if method == \"NumArray\":\n            # 建構子只有一次，參數是一個 list\n            obj = NumArray(args[i][0])\n            result.append(None)  # 代表 null\n        elif method == \"sumRange\":\n            left, right = args[i]\n            res = obj.sumRange(left, right)\n            result.append(res)\n        else:\n            # 若遇到未知方法，可忽略或拋出錯誤\n            raise ValueError(f\"Unknown method {method}\")\n\n    # 輸出結果，以 JSON 格式\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to output virtual code for class implementation. Steps: constructor building prefix sum array. sumRange uses prefix sums. So we produce virtual code lines. Use Start, End, Decision? Not many decisions. Just steps. Provide line-by-line with explanation. Ensure each line format. Use \"NumArray\" constructor, initialize prefix array length+1. SumRange returns prefix[right+1]-prefix[left]. Provide comments. No actual code, just virtual. Use arrow syntax. Let's produce.\n\nWe'll output:\n\nStart\n→ Step 1: Declare class NumArray // define class\n→ Step 2: Declare array prefix // store prefix sums\n→ Step 3: Constructor NumArray(nums) // initialize\n    → Step 4: prefix[0] = 0 // base case\n    → Step 5: For i from 0 to nums.length-1\n        → Step 6: prefix[i+1] = prefix[i] + nums[i] // build prefix\n→ Step 7: Method sumRange(left, right) // compute sum\n    → Step 8: return prefix[right+1] - prefix[left] // result\nEnd\n\nAdd explanations. Use \"Step\" lines. Provide arrow. Ok.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Declare class NumArray // 定義 NumArray 類別\n→ Step 2: Declare array prefix // 用於存放前綴和\n→ Step 3: Constructor NumArray(nums) // 接收輸入陣列並初始化\n    → Step 4: prefix[0] = 0 // 前綴和的基準值為 0\n    → Step 5: For i from 0 to nums.length-1 // 逐個遍歷輸入陣列\n        → Step 6: prefix[i+1] = prefix[i] + nums[i] // 建立前綴和，prefix[k] = nums[0] + … + nums[k-1]\n→ Step 7: Method sumRange(left, right) // 計算左到右範圍內的和\n    → Step 8: return prefix[right+1] - prefix[left] // 利用前綴和快速求和\nEnd // 程式執行結束"
    },
    {
      "title": "Word Pattern",
      "source_file": "Leetcode/leetcode290.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n\n        char_to_word = {}\n        word_to_char = {}\n\n        for c, w in zip(pattern, words):\n            if c in char_to_word:\n                if char_to_word[c] != w:\n                    return False\n            else:\n                char_to_word[c] = w\n\n            if w in word_to_char:\n                if word_to_char[w] != c:\n                    return False\n            else:\n                word_to_char[w] = c\n\n        return True\n\ndef parse_input(raw: str):\n    # Remove any surrounding whitespace\n    raw = raw.strip()\n    if not raw:\n        return \"\", \"\"\n\n    # Try to extract assignments like pattern = \"abba\", s = \"dog cat cat dog\"\n    assignments = {}\n    # Split by commas first, then by newlines\n    parts = [p.strip() for p in re.split(r',|\\n', raw) if p.strip()]\n    for part in parts:\n        m = re.match(r'pattern\\s*=\\s*[\"\\']?([^\"\\']+)[\"\\']?', part)\n        if m:\n            assignments['pattern'] = m.group(1).strip()\n            continue\n        m = re.match(r's\\s*=\\s*[\"\\']?(.*)[\"\\']?', part)\n        if m:\n            assignments['s'] = m.group(1).strip()\n            continue\n\n    # If still missing, fallback: assume first line is pattern, second line is s\n    if 'pattern' not in assignments or 's' not in assignments:\n        lines = [l.strip() for l in raw.splitlines() if l.strip()]\n        if len(lines) >= 2:\n            if 'pattern' not in assignments:\n                assignments['pattern'] = lines[0]\n            if 's' not in assignments:\n                assignments['s'] = lines[1]\n        else:\n            # Only one line left: try to split by spaces, first token is pattern\n            tokens = lines[0].split()\n            if tokens:\n                assignments.setdefault('pattern', tokens[0])\n                assignments.setdefault('s', ' '.join(tokens[1:]))\n    return assignments.get('pattern', ''), assignments.get('s', '')\n\ndef main():\n    raw_input = sys.stdin.read()\n    pattern, s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.wordPattern(pattern, s)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: given pattern string of letters, and s string of words separated by spaces. Determine if bijection exists. This is typical \"Word Pattern\" problem. Steps: split s into words array. If length mismatch, return false. Create map from char to string, map from string to char. Iterate pairs. If mapping exists and mismatched return false. Else if string already mapped to another char return false. Else add mapping. After loop return true. We'll output virtual code step by step, each line with explanation.\n\nWe must follow output format: each line: \"虛擬碼步驟 // 解釋\". Use arrows and Decision blocks. So we produce start, then step: assign. We'll use pseudo code. Use \"Start\" \"End\". Use \"Decision:\" and Yes →, No →.\n\nLet's produce:\n\nStart\n→ Step 1: 把 s 按空格拆分成 words 數組 // 將輸入字串拆成單詞\n→ Decision: words 數量是否等於 pattern 長度? // 確保字數匹配\n    Yes → Step 2: 初始化字母到單詞映射 dict1 // 以字母為鍵的字典\n    Yes → Step 3: 初始化單詞到字母映射 dict2 // 以單詞為鍵的字典\n    Yes → Step 4: 從 i = 0 到 pattern 長度-1 迭代 // 逐個字母匹配\n        → Step 4.1: currChar ← pattern[i] // 取得當前字母\n        → Step 4.2: currWord ← words[i] // 取得對應單詞\n        → Decision: currChar 已在 dict1? // 檢查字母是否已映射\n            Yes → Decision: dict1[currChar] ≠ currWord? // 若映射單詞不同\n                Yes → Step 4.3: 返回 False // 不是同一對應，失敗\n                No  → No → // 繼續\n            No  → Decision: currWord 已在 dict2? // 檢查單詞是否已被映射\n                Yes → Step 4.4: 返回 False // 同一單詞映射到不同字母，失敗\n                No  → Step 4.5: dict1[currChar] ← currWord // 建立字母→單詞映射\n                No  → Step 4.6: dict2[currWord] ← currChar // 建立單詞→字母映射\n    → Step 5: 返回 True // 所有對應都成功\n→ Decision: words 數量不等於 pattern 長度? // 如果不相等\n    Yes → Step 6: 返回 False // 無法對應\nEnd\n\nNeed to ensure format: Each line must have \"虛擬碼步驟 // 解釋\". Use arrow lines. For decision blocks, we use indentation. In example they used \"Decision:\" with Yes → and No → sublines. So we will mimic.\n\nLet's craft final output accordingly. Use Chinese explanation. Ensure each line ends with comment. Use \"Step\" numbering. Use indentation for sub-steps. Use \"Decision:\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: words ← s.Split(' ') // 把 s 以空格拆成單詞陣列  \n→ Decision: words.Length = pattern.Length? // 檢查單詞數與 pattern 長度是否相等  \n    Yes → Step 2: dict1 ← new Map<char, string>() // 建立字母 → 單詞 的映射表  \n    Yes → Step 3: dict2 ← new Map<string, char>() // 建立單詞 → 字母 的映射表  \n    Yes → Step 4: i ← 0 // 初始化迭代索引  \n    Yes → Decision: i < pattern.Length? // 仍有未處理的字母  \n        Yes → Step 4.1: currChar ← pattern[i] // 取出目前字母  \n        Yes → Step 4.2: currWord ← words[i] // 取出對應單詞  \n        Yes → Decision: dict1.ContainsKey(currChar)? // 該字母是否已經有映射  \n            Yes → Decision: dict1[currChar] ≠ currWord? // 映射單詞是否不符  \n                Yes → Step 4.3: Return False // 同一字母對應不同單詞，失敗  \n                No  → No → // 繼續檢查下一對  \n            No  → Decision: dict2.ContainsKey(currWord)? // 該單詞是否已被映射  \n                Yes → Step 4.4: Return False // 同一單詞對應不同字母，失敗  \n                No  → Step 4.5: dict1[currChar] ← currWord // 建立字母→單詞映射  \n                No  → Step 4.6: dict2[currWord] ← currChar // 建立單詞→字母映射  \n        Yes → Step 4.7: i ← i + 1 // 移到下一個索引  \n        Yes → No → // 重複 Decision：i < pattern.Length?  \n    Yes → Step 5: Return True // 所有字母與單詞都成功對應  \n    No  → No → // 迭代完成  \n→ Decision: words.Length ≠ pattern.Length? // 如果單詞數與 pattern 長度不符  \n    Yes → Step 6: Return False // 直接失敗  \n    No  → No → // 這裡不會發生，已在上一 Decision 處理  \nEnd // 程式執行結束"
    },
    {
      "title": "Shortest Unsorted Continuous Subarray",
      "source_file": "Leetcode/leetcode581.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "0",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '-2'\n--- (Raw) ---\nRaw Expected: '0'\nRaw Got:      '-2'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\ndef parse_nums(text: str):\n    \"\"\"從輸入文字中提取並解析整數列表。\"\"\"\n    match = re.search(r'\\[([^\\]]*)\\]', text)\n    if match:\n        inner = match.group(1).strip()\n        if inner == '':\n            return []\n        return ast.literal_eval('[' + inner + ']')\n    # 若找不到括號，嘗試直接解析整個文字\n    try:\n        return ast.literal_eval(text)\n    except Exception:\n        return []\n\ndef findUnsortedSubarray(nums):\n    \"\"\"找出最短需要排序的子陣列長度。\"\"\"\n    n = len(nums)\n    if n <= 1:\n        return 0\n\n    left, right = 0, -1\n    min_val, max_val = nums[-1], nums[0]\n\n    # 從左往右找右邊界\n    for i in range(n):\n        if nums[i] > max_val:\n            max_val = nums[i]\n        else:\n            right = i\n\n    # 從右往左找左邊界\n    for i in range(n - 1, -1, -1):\n        if nums[i] < min_val:\n            min_val = nums[i]\n        else:\n            left = i\n\n    if right == -1:  # 已經排好序\n        return 0\n    return right - left + 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = parse_nums(data)\n    result = findUnsortedSubarray(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode (virtual code) for algorithm: find shortest subarray that if sorted will make whole array sorted. Classic problem: find left boundary and right boundary of unsorted subarray. Approach: traverse from left to find max so far, identify where element < max => right boundary. From right, track min so far, where element > min => left boundary. Length = right-left+1 else 0.\n\nWe need to produce virtual code line-by-line, each with explanation. Use Start, End, Decision, arrows. We need to include lines like \"Start\" then \"→ Step 1: input array\" etc. Provide steps:\n\n- Start\n- Step 1: input array\n- Step 2: initialize variables n, max_so_far, right_boundary\n- Step 3: loop i from 0 to n-1: update max, if arr[i] < max => set right_boundary = i\n- Step 4: if right_boundary == -1: output 0; return\n- Step 5: initialize min_so_far, left_boundary\n- Step 6: loop i from n-1 down to 0: update min, if arr[i] > min => set left_boundary = i\n- Step 7: length = right_boundary - left_boundary + 1\n- End\n\nNeed to include Decision statements: e.g., Decision: right_boundary == -1? Yes → output 0; No → continue. Similarly for left_boundary maybe.\n\nWe also need to include explanation per line.\n\nWe need to ensure each line has \"虛擬碼步驟\" and \" // 解釋/說明\" separated by a space.\n\nWe must use arrows → and Yes → No →, etc.\n\nLet's craft lines.\n\nWe can use: \"→ Step 1: 輸入整數陣列 nums\" // get input\n\n\"→ Step 2: 初始化 n = nums 的長度, max_so_far = -∞, right_boundary = -1\" // set variables\n\n\"→ Step 3: 從左到右遍歷陣列，更新 max_so_far, 如 nums[i] < max_so_far, 設置 right_boundary = i\" // left to right pass\n\nBut we need to separate loops maybe with decisions inside loop? We can have a Decision inside loop: Decision: nums[i] < max_so_far? Yes → set right_boundary = i. But maybe simpler.\n\nBut instructions: Use arrow and Decision structure. So inside loop we need Decision: if nums[i] > max_so_far? then update max. If nums[i] < max_so_far then right_boundary = i. We can write steps: Step 3.1: if nums[i] > max_so_far → update. Step 3.2: if nums[i] < max_so_far → set right_boundary.\n\nBut we need to keep it simple.\n\nLet's produce:\n\nStart\n→ Step 1: 輸入整數陣列 nums // 取得輸入\n→ Step 2: n ← nums 的長度, max_so_far ← -∞, right_boundary ← -1 // 初始化參數\n→ Step 3: 從 i = 0 到 n-1 逐一遍歷陣列 // 左到右掃描\n    → Decision: nums[i] > max_so_far? // 判斷是否更新最大值\n        Yes → max_so_far ← nums[i] // 更新最大值\n        No  → No action\n    → Decision: nums[i] < max_so_far? // 判斷是否為未排序元素\n        Yes → right_boundary ← i // 記錄右邊界\n        No  → No action\n→ Decision: right_boundary == -1? // 是否已經整個已排序\n    Yes → Step 4: 輸出 0 // 整個陣列已經排好\n    No  → No action\n→ Step 5: min_so_far ← ∞, left_boundary ← -1 // 初始化左邊界\n→ Step 6: 從 i = n-1 到 0 逐一遍歷陣列 // 右到左掃描\n    → Decision: nums[i] < min_so_far? // 判斷是否更新最小值\n        Yes → min_so_far ← nums[i]\n        No  → No action\n    → Decision: nums[i] > min_so_far? // 判斷是否為未排序元素\n        Yes → left_boundary ← i\n        No  → No action\n→ Step 7: subarray_length ← right_boundary - left_boundary + 1 // 計算長度\n→ Step 8: 輸出 subarray_length // 回傳結果\nEnd\n\nMake sure each line includes \" // 解釋/說明\". For steps inside loop we might treat them as separate lines with indent? The format shows indent lines as part of Decision.\n\nWe need each line as: \"→ Step X: ...\" // explanation. The lines within Decision blocks also follow same format. For indent we need indentation with spaces? The example shows indent with four spaces maybe? They used spaces. We'll replicate with spaces.\n\nWe need to ensure \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nMake sure not to output actual code, just pseudocode lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 取得輸入的整數陣列  \n→ Step 2: n ← nums 的長度, max_so_far ← -∞, right_boundary ← -1 // 初始化長度、最大值與右邊界  \n→ Step 3: 從 i = 0 到 n-1 逐一遍歷陣列 // 左到右掃描以找右邊界  \n  → Decision: nums[i] > max_so_far? // 判斷是否更新目前最大值  \n   Yes → max_so_far ← nums[i] // 更新最大值  \n   No → No action // 保持原值  \n  → Decision: nums[i] < max_so_far? // 判斷是否為未排序元素  \n   Yes → right_boundary ← i // 記錄右邊界  \n   No → No action // 保持原值  \n→ Decision: right_boundary == -1? // 判斷整個陣列是否已排序  \n  Yes → Step 4: 輸出 0 // 若無需任何子陣列，長度為 0  \n  No → No action // 需要繼續尋找左邊界  \n→ Step 5: min_so_far ← ∞, left_boundary ← -1 // 初始化最小值與左邊界  \n→ Step 6: 從 i = n-1 到 0 逐一遍歷陣列 // 右到左掃描以找左邊界  \n  → Decision: nums[i] < min_so_far? // 判斷是否更新目前最小值  \n   Yes → min_so_far ← nums[i] // 更新最小值  \n   No → No action // 保持原值  \n  → Decision: nums[i] > min_so_far? // 判斷是否為未排序元素  \n   Yes → left_boundary ← i // 記錄左邊界  \n   No → No action // 保持原值  \n→ Step 7: subarray_length ← right_boundary - left_boundary + 1 // 計算子陣列長度  \n→ Step 8: 輸出 subarray_length // 回傳最短需要排序的子陣列長度  \nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum",
      "source_file": "Leetcode/leetcode39.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpx5_lps6x.py\", line 29, in <module>\n    main()\n  File \"/tmp/tmpx5_lps6x.py\", line 21, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    candidates = [2,3,6,7], target = 7\n    ^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6v4pzhto.py\", line 29, in <module>\n    main()\n  File \"/tmp/tmp6v4pzhto.py\", line 21, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    candidates = [2,3,5], target = 8\n    ^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "candidates = [2], target = 1",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxqs_ip9v.py\", line 29, in <module>\n    main()\n  File \"/tmp/tmpxqs_ip9v.py\", line 21, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    candidates = [2], target = 1\n    ^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nclass Solution:\n    def combinationSum(self, candidates, target):\n        res = []\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(path[:])\n                return\n            if total > target:\n                return\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, total + candidates[i])\n                path.pop()\n        backtrack(0, [], 0)\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    local_vars = {}\n    exec(data, {}, local_vars)\n    candidates = local_vars['candidates']\n    target = local_vars['target']\n    sol = Solution()\n    result = sol.combinationSum(candidates, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving combination sum problem. Provide step-by-step pseudocode, with each line: \"虛擬碼步驟 // 解釋\". Use arrows, decisions, etc. No real code.\n\nWe need to include recursion/backtracking, loops, etc.\n\nLet's craft:\n\nStart\n→ Sort candidates // optional for pruning\n→ Define function Backtrack(start, remaining, path) // recursive\n    → If remaining == 0:\n        → Add copy of path to result // found valid combination\n        → Return\n    → If remaining < 0:\n        → Return // overshoot\n    → For i from start to len(candidates)-1:\n        → Add candidates[i] to path // choose number\n        → Backtrack(i, remaining - candidates[i], path) // stay at i for unlimited use\n        → Remove last from path // backtrack\n\nAfter function defined\n→ Call Backtrack(0, target, empty list)\n→ Return result\nEnd\n\nMake sure each line is separate with comments.\n\nWe need to use arrow \"→\" before each step; also decisions like \"Decision:\" when we have if statements.\n\nWe need to ensure each line has \"虛擬碼步驟 // 解釋\". We'll use Chinese explanation.\n\nLet's craft.\n\nAlso note: \"Start\" and \"End\" lines.\n\nWe'll produce lines:\n\nStart // 程式開始執行\n→ Sort candidates ascending // 方便剪枝和維持順序\n→ 定義函式 Backtrack(start, remaining, path) // 從 start 開始嘗試\n    → Decision: 如果 remaining == 0? // 檢查是否已達目標\n        Yes → Add path copy to result // 收集有效組合\n        No  → Decision: 如果 remaining < 0? // 檢查是否超過目標\n            Yes → Return // 回溯，因為負數不可能回到 0\n            No  → For i from start to candidates.length-1: // 遍歷可選數字\n                → Add candidates[i] 到 path // 選擇此數字\n                → Backtrack(i, remaining - candidates[i], path) // 允許重複選取\n                → Remove last from path // 回溯到前一狀態\n→ 初始化 result 為空列表 // 用於存放所有組合\n→ Call Backtrack(0, target, empty list) // 開始遞歸\n→ Return result // 返回所有組合\nEnd // 程式執行結束\n\nBut we must adhere to format: Each line \"虛擬碼步驟\" + space + \"// 解釋\". The \"Decision:\" lines should have indentation? The format example shows indenting decisions.\n\nWe can use nested indenting for Decision lines and steps under them. Each line will start with \"→\" or \"→ Decision:\" or \"Yes →\" etc. But we must keep each line separate. Use indentation maybe 4 spaces? But they didn't specify indentation; just arrow. We'll keep each line as separate. For nested we can just indent spaces.\n\nLet's craft each line exactly.\n\nStart // 程式開始執行\n→ Sort candidates ascending // 方便剪枝並保持遞增順序\n→ Define Backtrack(start, remaining, path) // 從索引 start 開始遞歸搜尋\n    → Decision: 如果 remaining == 0? // 檢查是否已達到目標和\n        Yes → Add copy of path to result // 將有效組合加入結果\n        No  → Decision: 如果 remaining < 0? // 檢查是否超過目標和\n            Yes → Return // 過大，直接回溯\n            No  → For i = start to candidates.length-1: // 遍歷候選數\n                → Add candidates[i] to path // 選擇該數字\n                → Backtrack(i, remaining - candidates[i], path) // 允許重複使用同一數字\n                → Remove last from path // 回溯到上一步\n→ 初始化 result 為空列表 // 用於存放所有有效組合\n→ Call Backtrack(0, target, empty list) // 開始遞歸搜索\n→ Return result // 輸出所有組合\nEnd // 程式結束\n\nEnsure each line ends with \"// 解釋\".\n\nWe should also include \"Start\" and \"End\". Provide lines exactly as above.\n\nCheck formatting: Each line begins with either \"Start\", \"→\", \"Decision:\" etc. Ensure the colon after Decision. And \"Yes →\" or \"No →\" lines start with Yes → or No →. Good.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Sort candidates ascending // 方便剪枝並保持遞增順序\n→ Define Backtrack(start, remaining, path) // 從索引 start 開始遞歸搜尋\n    → Decision: 如果 remaining == 0? // 檢查是否已達到目標和\n        Yes → Add copy of path to result // 將有效組合加入結果\n        No  → Decision: 如果 remaining < 0? // 檢查是否超過目標和\n            Yes → Return // 過大，直接回溯\n            No  → For i = start to candidates.length-1: // 遍歷候選數\n                → Add candidates[i] to path // 選擇該數字\n                → Backtrack(i, remaining - candidates[i], path) // 允許重複使用同一數字\n                → Remove last from path // 回溯到上一步\n→ 初始化 result 為空列表 // 用於存放所有有效組合\n→ Call Backtrack(0, target, empty list) // 開始遞歸搜索\n→ Return result // 輸出所有組合\nEnd // 程式結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,0,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 0, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 隨機選取 1 ~ total 之間的整數（包含兩端）\n        target = random.randint(1, self.total)\n        # bisect_left 找到第一個 >= target 的位置，即選中的索引\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    # 讀取整行輸入，例子形如: '[\"Solution\",\"pickIndex\"], [[[1]],[]]'\n    content = sys.stdin.read().strip()\n    if not content:\n        return\n\n    # 以 '],' 為分隔符拆分第一個列表和第二個列表\n    split_idx = content.find('],')\n    first_list_str = content[:split_idx + 1]          # 包含閉括號\n    second_list_str = content[split_idx + 2:].strip()  # 跳過逗號\n\n    # 解析成 Python 物件\n    ops = ast.literal_eval(first_list_str)\n    args_list = ast.literal_eval(second_list_str)\n\n    # 為了可重現性，設定隨機種子\n    random.seed(0)\n\n    results = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            # args 是一個列表，可能是 [[1,3]] 等，使用 * 展開\n            obj = Solution(*args)\n            results.append(None)\n        elif op == \"pickIndex\":\n            if obj is None:\n                raise ValueError(\"Solution instance not initialized\")\n            res = obj.pickIndex()\n            results.append(res)\n        else:\n            raise ValueError(f\"Unsupported operation: {op}\")\n\n    # 輸出結果，使用 json.dumps 以得到 null、true 等格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing pickIndex function using prefix sums. Use random number. Step: compute cumulative sums, sum, pick random between 0 and sum exclusive. Binary search. Outline steps. Provide explanation after each line. Use \"Start\", \"End\", \"Decision:\" etc. Provide virtual code lines.\n\nMake sure each line includes \"虛擬碼步驟\" and explanation comment. Provide lines: Start, Step 1 compute prefix sums array cum, Step 2 compute total, Step 3 generate random number r in [0,total), Step 4 binary search on cum to find first >= r, Step 5 return index. Include decisions? Might include Decision: if r < cum[0]? Actually use binary search algorithm. Could just illustrate with a Decision loop: while low < high, mid = (low+high)/2, if cum[mid] <= r, low=mid+1 else high=mid. At end low is answer. Provide that.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 建立空陣列 cum 以儲存前綴和 // 初始化前綴和陣列\n→ Decision: 是否已完成前綴和計算? // 判斷是否需要累積計算\n    Yes → Step 2: 對於 i 由 0 到 n-1\n        → Step 2.1: cum[i] = (i == 0 ? w[0] : cum[i-1] + w[i]) // 計算前綴和\n    No → ...\nBut maybe simpler: Step 2: compute cum and total in loop. Provide explanation.\n\nThen Step 3: total = cum[n-1] // total weight\nStep 4: r = random() * total // 隨機數\nStep 5: low=0; high=n-1\nStep 6: Decision: low < high? // binary search loop\n    Yes → Step 7: mid = (low+high)/2\n    Step 8: Decision: cum[mid] <= r? // 判斷 r 是否在左半邊\n        Yes → Step 9: low = mid + 1 // r 在右半邊\n        No  → Step 10: high = mid // r 在左半邊\n    No → ...\nStep 11: Return low // 找到的索引\n\nEnd.\n\nMake sure each line has the pattern.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空陣列 cum 用於存放前綴和 // 建立前綴和陣列  \n→ Step 2: 計算前綴和並同時計算總重 sum  \n→ Decision: 是否已遍歷完 w? // 判斷是否需要繼續累積  \n  Yes → Step 3: For i in 0..w.length-1  \n    → Step 3.1: cum[i] = (i == 0 ? w[0] : cum[i-1] + w[i]) // 更新前綴和  \n    → Step 3.2: sum = cum[i] // 取得目前總重  \n    → Decision: i < w.length-1? // 仍有元素未處理  \n      Yes → 回到 Step 3  \n      No → 跳出迴圈  \n  No → （此分支不會發生）  \n→ Step 4: 隨機產生 r，範圍為 [0, sum)  \n  → Step 4.1: r = random() * sum // 隨機數  \n→ Step 5: 初始化二分搜尋變數 low = 0, high = w.length - 1  \n→ Decision: low < high? // 是否仍可繼續搜尋  \n  Yes → Step 6: mid = (low + high) / 2 // 取中間索引  \n    → Decision: cum[mid] <= r? // 判斷 r 在前綴和的哪一段  \n      Yes → Step 7: low = mid + 1 // r 在右半邊，縮小搜尋區間  \n      No  → Step 8: high = mid // r 在左半邊，縮小搜尋區間  \n    → 回到 Decision: low < high?  \n  No → // 搜尋完成，low 為符合條件的索引  \n→ Step 9: Return low // 回傳隨機選取的索引  \nEnd // 程式執行結束"
    }
  ]
}