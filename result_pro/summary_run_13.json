{
  "run_index": 13,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 390,
  "generation_or_validation_failure_count": 49,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef count_lines_in_file() -> None:\n    \"\"\"\n    開啟名為 data.txt 的檔案，讀取內容並輸出總共有幾行文字。\n    若檔案不存在，顯示『找不到檔案！』。\n    \"\"\"\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print(f\"檔案共有 {len(lines)} 行\")\n    except FileNotFoundError:\n        print(\"找不到檔案！\")\n\ndef main() -> None:\n    \"\"\"\n    main 區塊從標準輸入讀取所有資料（此題不需要實際資料），\n    然後執行檔案行數計算功能。\n    \"\"\"\n    # 讀取 stdin 以符合「從標準輸入讀取」的規範，雖然此處不使用資料\n    sys.stdin.read()\n    count_lines_in_file()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations, each line: \"虛擬碼步驟 // 解釋\". Use arrows →, Start, End, Decision. Use try/except with with syntax. Steps: Start, Try block: Open file with with, read lines, count lines, print. Decision: file open success? Actually try will catch FileNotFoundError. So we need Decision: try succeeded? But simpler: we can structure Decision inside except: if exception. So structure:\n\nStart\n→ Decision: 試圖開啟檔案? // Attempt to open file\n    Yes → Step: with open(...) as f: // open file\n        → Step: lines = f.readlines() // read lines\n        → Step: count = len(lines) // count lines\n        → Step: print(f\"共 {count} 行\") // output\n        → End\n    No  → Decision: 例外 FileNotFoundError? // catch\n        Yes → Step: print('找不到檔案！')\n        No → Step: 重新拋出例外? // optional\nEnd\n\nBut need with try/except. So we need a Decision: 例外? Actually flow: Start -> Try block: open file with with; if success proceed; if exception, except block.\n\nSo we can structure:\n\nStart\n→ Decision: 進入 try? // start try block\n    Yes → Step: with open('data.txt', 'r') as f: // open file\n        → Step: lines = f.readlines() // read lines\n        → Step: count = len(lines) // count\n        → Step: print(f\"共 {count} 行\") // output\n    No  → Decision: 捕捉 FileNotFoundError? // exception handling\n        Yes → Step: print('找不到檔案！') // show message\n        No  → Step: 重新拋出? // for other exceptions\nEnd\n\nBut need to reflect try/except properly. Might include Step: try: and except: but we can express as Decision: Try block success? Actually we can represent as:\n\nStart\n→ Step: try: // 進入 try 區塊\n    → Step: with open('data.txt', 'r') as f: // 打開檔案\n        → Step: lines = f.readlines() // 讀取所有行\n        → Step: count = len(lines) // 計算行數\n        → Step: print(f\"共 {count} 行\") // 輸出結果\n→ Decision: 是否發生 FileNotFoundError? // 判斷是否拋出例外\n    Yes → Step: print('找不到檔案！') // 顯示錯誤訊息\n    No  → Step: 重新拋出例外 // 其他例外重新拋出\nEnd\n\nBut we need each line with virtual code arrow etc.\n\nLet's produce final answer with these steps. Ensure each line has 虛擬碼步驟 [space] // 解釋. Use arrow symbol →. Use Start, End, Decision.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 進入 try 區塊? // 嘗試執行程式碼  \n  Yes → Step: with open('data.txt', 'r') as f: // 使用 with 語法開啟檔案  \n    → Step: lines = f.readlines() // 讀取檔案中的所有行  \n    → Step: count = len(lines) // 計算行數  \n    → Step: print(f\"共 {count} 行\") // 輸出總行數  \n  No → Decision: 是否拋出 FileNotFoundError? // 檢查是否因找不到檔案而失敗  \n    Yes → Step: print('找不到檔案！') // 顯示錯誤訊息  \n    No → Step: raise // 重新拋出其他未知例外  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[6,2,3,4,6]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[6, 2, 3, 4, 6]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if data.strip():\n        exec(data)",
      "virtual_code": "Thinking...\nWe need to output the virtual code step-by-step with explanation. Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows and structure: Start, End, Decision:. Provide steps to import random, define function roll_dice(n), create empty list, loop n times, generate random int 1-6, append, return list. Ensure no actual code. Just pseudocode. Format: each line: \"虛擬碼步驟 // 解釋/說明\".\n\nLet's produce.\n\nNote: We must use \"→\" arrow for next steps. Use \"Start\" and \"End\". Use Decision if any. But here no decision except loop, but we can use Decision: if i < n? maybe.\n\nBut the instruction: Use Decision, Yes →, No →. For loop we could use Decision: 迴圈結束? But simpler to just use loop. But to follow requirement, maybe include a Decision for loop condition.\n\nLet's produce steps:\n\nStart\n→ Import random module // 引入 random 模組\n→ Function roll_dice(n): // 定義 roll_dice 函數，接受擲骰次數\n    → List results = empty list // 建立空串列存放結果\n    → Integer counter = 0 // 初始化計數器\n    → Decision: counter < n? // 檢查是否已擲完\n        Yes → Integer roll = random.randint(1,6) // 產生 1-6 的隨機數\n        → Append roll to results // 將結果加入串列\n        → Increment counter by 1 // 計數器加 1\n        → Decision: counter < n? // 再次檢查是否還需擲\n            Yes → (repeat)\n            No  → Return results // 回傳所有結果\n        No  → Return results // n 為 0 時直接回傳空串列\nEnd\n\nBut we need each line as a line. Let's format accordingly. Use \"→\" each step indent maybe. Use indentation via spaces.\n\nNeed to output as:\n\nStart // 程式開始執行\n→ Import random module // 引入 random 模組\n→ Function roll_dice(n): // 定義 roll_dice 函數，接受擲骰次數\n    → List results = empty list // 建立空串列存放結果\n    → Integer counter = 0 // 初始化計數器\n    → Decision: counter < n? // 檢查是否已擲完\n        Yes → Integer roll = random.randint(1,6) // 產生 1-6 的隨機數\n        → Append roll to results // 將結果加入串列\n        → Increment counter by 1 // 計數器加 1\n        → Decision: counter < n? // 再次檢查是否還需擲\n            Yes → (repeat)\n            No  → Return results // 回傳所有結果\n        No  → Return results // n 為 0 時直接回傳空串列\nEnd // 程式執行結束\n\nBut we must ensure \"每行\" includes \"虛擬碼步驟\" + space + \"// 解釋/說明\". So we cannot have \"→ (repeat)\" as separate line? We can just show loops using Decision.\n\nBut maybe simpler: Use a loop construct like \"While counter < n:\" but we cannot use actual code. We can express as \"→ While counter < n:\". But requirement says use Decision arrow style. So better to use Decision and Yes/No.\n\nWe need to keep each line separate.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Import random module // 引入 random 模組\n→ Function roll_dice(n): // 定義 roll_dice 函數，接受擲骰次數\n    → List results = empty list // 建立空串列存放結果\n    → Integer counter = 0 // 初始化計數器\n    → Decision: counter < n? // 檢查是否還有擲骰\n        Yes → Integer roll = random.randint(1,6) // 產生 1-6 的隨機數\n        → Append roll to results // 將結果加入串列\n        → Increment counter by 1 // 計數器加 1\n        → Decision: counter < n? // 再次檢查\n            Yes → (repeat)\n            No  → Return results // 回傳所有結果\n        No  → Return results // n 為 0 時直接回傳空串列\nEnd // 程式執行結束\n\nBut each line must contain \"虛擬碼步驟 // 解釋\". The indentation lines count as separate lines. So \"→ (repeat)\" might not be needed. We can collapse the repeated part into just loop. But to satisfy, we could use \"Yes → (loop body)\" but not actual code. We could just show that Yes branch leads to loop body again. But \"Yes → (loop body)\" not a code step. But we can just skip that.\n\nBetter structure: Use Decision with Yes to go back to top of loop, but we don't need separate line.\n\nMaybe we can present as:\n\nStart // 程式開始執行\n→ Import random module // 引入 random 模組\n→ Function roll_dice(n): // 定義 roll_dice 函數，接受擲骰次數\n    → List results = empty list // 建立空串列存放結果\n    → Integer counter = 0 // 初始化計數器\n    → Decision: counter < n? // 檢查是否還有擲骰\n        Yes → Integer roll = random.randint(1,6) // 產生 1-6 的隨機數\n        → Append roll to results // 將結果加入串列\n        → Increment counter by 1 // 計數器加 1\n        → Decision: counter < n? // 再次檢查是否仍需擲\n            Yes → (回到 Decision) // 重新檢查\n            No  → Return results // 回傳所有結果\n        No  → Return results // n 為 0 時直接回傳空串列\nEnd // 程式執行結束\n\nBut \"回到 Decision\" is not a step. Instead we can say \"Yes → (loop body)\" referencing earlier steps.\n\nAlternatively, we could avoid the second Decision inside the loop, just loop until counter < n? but can't use loops.\n\nSimplify: Use \"→ While counter < n:\" as step. But not allowed? The requirement doesn't forbid \"While\". It just says use Decision arrows and structure. But we can incorporate While.\n\nBetter: Use Decision to check condition at each iteration.\n\nOk final version:\n\nStart // 程式開始執行\n→ Import random module // 引入 random 模組\n→ Function roll_dice(n): // 定義 roll_dice 函數，接受擲骰次數\n    → List results = empty list // 建立空串列存放結果\n    → Integer counter = 0 // 初始化計數器\n    → Decision: counter < n? // 檢查是否還需要擲骰\n        Yes → Integer roll = random.randint(1,6) // 產生 1-6 的隨機數\n        → Append roll to results // 將結果加入串列\n        → Increment counter by 1 // 計數器加 1\n        → Decision: counter < n? // 再次檢查是否還需擲\n            Yes → (回到上一步的 Decision) // 重新開始循環\n            No  → Return results // 回傳所有結果\n        No  → Return results // n 為 0 時直接回傳空串列\nEnd // 程式執行結束\n\nHowever, \"回到上一步的 Decision\" is not a code step, but it's explanation. We can skip that line; just use Yes → (loop back). But each line must have code + explanation.\n\nWe can write:\n\nYes → Integer roll = random.randint(1,6) // 產生 1-6 的隨機數\n→ Append roll to results // 將結果加入串列\n→ Increment counter by 1 // 計數器加 1\n→ Decision: counter < n? // 再次檢查是否還需擲\n    Yes → (loop again) // 重新進行擲骰\n    No  → Return results // 回傳所有結果\n\nBut that includes \"Yes → (loop again)\" which is not actual code. Maybe we can write: \"Yes → Go back to Decision: counter < n?\" but that's explanation. The \"虛擬碼步驟\" part could be \"Yes →\" with nothing else? But maybe it's fine.\n\nSimplify: Provide a simpler pseudocode with a while loop. The requirement didn't forbid using loops. But they ask to use Decision and arrows. But we can use \"→ While counter < n:\" and treat that as a decision? Eh.\n\nMaybe better to produce:\n\nStart // 程式開始執行\n→ Import random module // 引入 random 模組\n→ Function roll_dice(n): // 定義 roll_dice 函數，接受擲骰次數\n    → List results = empty list // 建立空串列存放結果\n    → Integer counter = 0 // 初始化計數器\n    → While counter < n: // 只要計數器小於 n，繼續擲骰\n        → Integer roll = random.randint(1,6) // 產生 1-6 的隨機數\n        → Append roll to results // 將結果加入串列\n        → Increment counter by 1 // 計數器加 1\n    → Return results // 回傳所有結果\nEnd // 程式執行結束\n\nBut that uses While. But the spec says \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\". It doesn't forbid using While. But they want arrow usage. We can still use While. It's fine.\n\nBut maybe better to adhere strictly: use Decision and arrows. So final answer: provide pseudocode with Decision loops.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import random module // 引入 random 模組  \n→ Function roll_dice(n): // 定義 roll_dice 函數，接受擲骰次數  \n → List results = empty list // 建立空串列存放結果  \n → Integer counter = 0 // 初始化計數器  \n → Decision: counter < n? // 檢查是否還需要擲骰  \n  Yes → Integer roll = random.randint(1,6) // 產生 1-6 的隨機數  \n  → Append roll to results // 將結果加入串列  \n  → Increment counter by 1 // 計數器加 1  \n  → Decision: counter < n? // 再次檢查是否仍需擲  \n   Yes → (重複上述 Decision) // 重新進行擲骰  \n   No → Return results // 回傳所有結果  \n  No → Return results // n 為 0 時直接回傳空串列  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"測量傳入函式 func 執行所需秒數，並回傳四捨五入到小數點 3 位的耗時。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入的全部程式碼，並在此模組的全域命名空間執行。\n    # 這樣即可使用已定義的 measure_time 函式。\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with arrow, explanation. The function measure_time(func, *args). Use time module. Steps: import time; define function measure_time. Inside, record start = time.time(); result = func(*args); end = time.time(); elapsed = round(end - start, 3); return result, elapsed? It says 回傳結果 (四捨五入到小數點 3 位)。Probably return elapsed? Actually function measurement returns time seconds. But maybe also return result? Might be ambiguous. Usually measure_time returns the time taken. But maybe they want to return elapsed. We'll return elapsed.\n\nLet's produce:\n\nStart\n→ Step 1: Import time module // 導入 time\n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函式\n→ Step 3: Record start_time = time.time() // 紀錄開始時間\n→ Step 4: Call result = func(*args) // 執行目標函式\n→ Step 5: Record end_time = time.time() // 紀錄結束時間\n→ Step 6: Compute elapsed = round(end_time - start_time, 3) // 計算耗時並四捨五入\n→ Step 7: Return elapsed // 回傳耗時\n\nBut if we need to return both result and time? We can specify returning tuple. Let's include that.\n\nLet's write virtual code accordingly.\n\nUse Decision? Not needed.\n\nJust simple sequence.\n\nWe need arrow notation: → Step X: ... // 解釋\n\nAlso Start and End.\n\nThus produce:\n\nStart // 程式開始\n→ Step 1: Import time module // 導入 time 模組\n→ Step 2: Define function measure_time(func, *args) // 定義函式\n→ Step 3: start_time = time.time() // 紀錄開始時間\n→ Step 4: result = func(*args) // 執行傳入的函式\n→ Step 5: end_time = time.time() // 紀錄結束時間\n→ Step 6: elapsed = round(end_time - start_time, 3) // 計算並四捨五入\n→ Step 7: return result, elapsed // 回傳結果與耗時\nEnd // 程式結束\n\nBut need virtual code arrow style? The example used \"Start\" then \"→ Step 1: ...\" each arrow. Good.\n\nWe might include comment after each line. Let's produce final.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: Import time module // 導入 time 模組\n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函式\n→ Step 3: start_time = time.time() // 紀錄開始時間\n→ Step 4: result = func(*args) // 執行傳入的函式並取得結果\n→ Step 5: end_time = time.time() // 紀錄結束時間\n→ Step 6: elapsed = round(end_time - start_time, 3) // 計算耗時並四捨五入到小數點 3 位\n→ Step 7: return result, elapsed // 回傳函式結果及耗時\nEnd // 程式結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "class Student:\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        print(f'{self.name} 的分數是 {self.score}')\n\n\ndef main():\n    import sys\n    data = sys.stdin.read().strip()\n\n    # 若輸入為空，使用預設兩個學生\n    if not data:\n        s1 = Student('Alice', 90)\n        s2 = Student('Bob', 80)\n        s1.show_info()\n        s2.show_info()\n        return\n\n    # 解析輸入，每行格式: <姓名> <分數>\n    for line in data.splitlines():\n        parts = line.split()\n        if len(parts) < 2:\n            continue\n        name = parts[0]\n        try:\n            score = int(parts[1])\n        except ValueError:\n            continue\n        student = Student(name, score)\n        student.show_info()\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line. Each line: \"虛擬碼步驟 // 解釋\". Use arrows → etc. Provide structure. Start, End. We'll include class definition steps. For methods etc. We'll also instantiate objects. Provide sequential steps. Let's produce:\n\nStart\n→ Step: Define class Student // 定義 Student 類別\n    → Step: __init__(): 初始化 name, score // 建構子設定兩個屬性\n        → Step: self.name = name // 設定姓名\n        → Step: self.score = score // 設定分數\n    → Step: show_info(): 輸出 'name 的分數是 score' // 方法顯示資訊\n        → Step: output string // 產生輸出\n→ Step: 建立 Student 物件 a = Student(\"Alice\", 85) // 建立第一個物件\n→ Step: 呼叫 a.show_info() // 顯示第一個物件資訊\n→ Step: 建立 Student 物件 b = Student(\"Bob\", 92) // 建立第二個物件\n→ Step: 呼叫 b.show_info() // 顯示第二個物件資訊\nEnd\n\nBut need to adhere to arrow syntax: \"→\" before each step. Use indentation for Decision? None needed. But we can still use indent.\n\nEnsure each line ends with // 解釋. Provide arrow. Provide indentation with spaces? Eg:\n\nStart // 程式開始執行\n→ Step: 定義 Student 類別 // ...\n\nUse indent. Provide each step on its own line. We'll provide the entire flow. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義 Student 類別 // 宣告一個名為 Student 的類別  \n&nbsp;&nbsp;→ Step: __init__(): 初始化 name 與 score // 建構子接收姓名與分數並存入物件屬性  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step: self.name = name // 設定物件的姓名屬性  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step: self.score = score // 設定物件的分數屬性  \n&nbsp;&nbsp;→ Step: show_info(): 輸出「姓名 的分數是 分數」 // 方法用來顯示學生資訊  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step: 輸出 self.name + \" 的分數是 \" + self.score // 產生並顯示訊息  \n→ Step: 建立第一個 Student 物件 a = Student(\"Alice\", 85) // 建立名為 Alice 的學生並分數 85  \n→ Step: 呼叫 a.show_info() // 顯示 Alice 的分數資訊  \n→ Step: 建立第二個 Student 物件 b = Student(\"Bob\", 92) // 建立名為 Bob 的學生並分數 92  \n→ Step: 呼叫 b.show_info() // 顯示 Bob 的分數資訊  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"melon\",\"orange\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'melon', 'orange', 'apple'}\""
        }
      ],
      "generated_code": "def main():\n    import sys\n    # 讀取輸入（即使本問題不需要任何輸入，也保持通用性）\n    sys.stdin.read()\n\n    # 1. 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 2. 使用 add() 新增 'orange'\n    fruits.add('orange')\n\n    # 3. 使用 update() 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 4. 使用 remove() 移除 'banana'\n    fruits.remove('banana')\n\n    # 5. 使用 discard() 嘗試移除 'pineapple'（不存在的元素不會拋出錯誤）\n    fruits.discard('pineapple')\n\n    # 6. 輸出最終集合\n    print(fruits)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. We have to follow format. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision optional? Not needed. Just steps.\n\nUse arrows: \"→ Step X: ...\". Use spaces and comment.\n\nSo:\n\nStart // start program\n\n→ Step 1: Initialize fruits set with 'apple', 'banana' // create set\n\n→ Step 2: fruits.add('orange') // add orange\n\n→ Step 3: fruits.update({'grape', 'melon'}) // add grape and melon\n\n→ Step 4: fruits.remove('banana') // remove banana\n\n→ Step 5: fruits.discard('pineapple') // discard pineapple (no error)\n\n→ Step 6: Output fruits // print set\n\nEnd // end\n\nAdd explanations.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize fruits = {'apple', 'banana'} // 建立初始集合  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'（不會錯誤）  \n→ Step 6: Output fruits // 輸出最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.71TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.71 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate():\n    \"\"\"取得 USD 對 TWD 的匯率。若失敗回傳 None。\"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()\n        data = r.json()\n        return data[\"rates\"].get(\"TWD\")\n    except Exception:\n        return None\n\ndef create_gui():\n    \"\"\"建立 tkinter GUI，並在按鈕點擊時更新匯率。\"\"\"\n    root = tk.Tk()\n    root.title(\"匯率查詢\")\n\n    label = tk.Label(root, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update():\n        rate = fetch_rate()\n        if rate is not None:\n            label.config(text=f\"目前美元匯率：約 {rate:.2f} TWD\")\n        else:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n\n    button = tk.Button(root, text=\"更新匯率\", command=update)\n    button.pack(pady=5)\n\n    root.mainloop()\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入。若有輸入則執行文字輸出；若無則啟動 GUI。\n    input_data = sys.stdin.read()\n    if input_data.strip():\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate:.2f} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n    else:\n        create_gui()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following format, no actual code, just steps with arrows. We'll produce steps like:\n\nStart // 程式開始執行\n→ Import 模組: requests, tkinter // 導入需要的模組\n→ Create 主視窗 root // 建立 tkinter 主視窗\n→ 設定標題 'USD/TWD 匯率' // 設定視窗標題\n→ 創建 Label label_rate // 用於顯示匯率\n→ 放置 Label 在視窗 // 布局\n→ 定義函式 update_rate() // 定義更新匯率的函式\n    → 送出 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 呼叫 API\n    → 解析 JSON 取得 rates.TWD // 取得台幣匯率\n    → 更新 label_rate 的文字 // 顯示匯率\n→ 創建 Button btn_update // 按鈕\n→ 設定按鈕文字 '更新匯率' // 按鈕文字\n→ 設定按鈕 command update_rate // 按下時呼叫函式\n→ 放置 Button 在視窗 // 布局\n→ 呼叫 update_rate() 初始載入 // 開始時顯示一次\n→ 執行 root.mainloop() // 開始 tkinter 事件循環\nEnd // 程式結束\n\nNeed to use the arrow format: \"→\" before each step. Use \"Decision:\" for any conditional? No. But maybe if requests fails, we could include decision: if success. But requirement: use arrows and decisions as needed. So we can include Decision: if request successful. But not necessary. The problem statement didn't ask for error handling, but we can add optional. But it's okay to keep simple.\n\nThe format: each line \"虛擬碼步驟\" space \" // 解釋\". So we must add explanation after slash.\n\nNeed to not output actual code; just virtual steps. Eg: \"→ Import 模組: requests, tkinter\". Explanation: \"// 導入需要的模組\".\n\nAlso \"Start // 程式開始執行\".\n\nOk. Let's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import 模組: requests, tkinter // 導入 HTTP 請求和 GUI 相關模組  \n→ Create 主視窗 root // 建立 tkinter 主視窗實例  \n→ Set 標題 'USD/TWD 匯率' // 為視窗設定顯示標題  \n→ Create Label label_rate // 建立用於顯示匯率的文字標籤  \n→ Place Label 在視窗中 // 使用 pack/grid 進行簡易佈局  \n→ Define 函式 update_rate() // 定義按鈕點擊時執行的匯率更新邏輯  \n  → Decision: 如果 request 成功? // 檢查 HTTP 請求是否成功  \n   Yes → 送出 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 呼叫匯率 API  \n    → 解析 JSON 取得 rates.TWD // 從回傳資料中擷取台幣匯率  \n    → 更新 label_rate 文字為 '1 USD = {TWD} TWD' // 將取得的匯率顯示在標籤  \n   No  → Update label_rate 文字為 '匯率取得失敗' // 顯示錯誤訊息  \n→ Create Button btn_update // 建立更新匯率的按鈕  \n→ Set 按鈕文字為 '更新匯率' // 設定按鈕顯示文字  \n→ Set 按鈕 command 為 update_rate // 設定點擊事件為匯率更新函式  \n→ Place Button 在視窗中 // 進行佈局  \n→ 呼叫 update_rate() // 初始載入時立即顯示最新匯率  \n→ 執行 root.mainloop() // 啟動 tkinter 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo4fjgsdp.py\", line 55, in <module>\n    magic_dict.buildDict(arg)\n  File \"/tmp/tmpo4fjgsdp.py\", line 17, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MagicDictionary:\n    \"\"\"\n    MagicDictionary 的實作，使用 set 儲存字典，\n    透過逐位替換檢查是否能正好改一個字元符合任何單字。\n    \"\"\"\n    def __init__(self):\n        # 用 set 存放所有單字，方便 O(1) 查找\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        \"\"\"\n        建立字典。dictionary 為包含不同單字的 list。\n        \"\"\"\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        \"\"\"\n        判斷是否可以將 searchWord 的恰好一個字元改變，\n        使其變成字典中的某個單字。\n        \"\"\"\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    # 把兩個 list 包裝成一個外層 list，方便 json 解析\n    # 例如：[\"MagicDictionary\", \"buildDict\", ...], [[], ...]\n    # 轉成: [[\"MagicDictionary\", \"buildDict\", ...], [[], ...]]\n    data = json.loads(f'[{input_data}]')\n\n    ops = data[0]     # 操作列表\n    args = data[1]    # 參數列表\n\n    result = []\n    magic_dict = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MagicDictionary\":\n            # 建構子呼叫\n            magic_dict = MagicDictionary()\n            result.append(None)          # 代表 null\n        elif op == \"buildDict\":\n            magic_dict.buildDict(arg)\n            result.append(None)          # 代表 null\n        elif op == \"search\":\n            res = magic_dict.search(arg)\n            result.append(res)           # 真/假\n        else:\n            # 若有其他操作，可自行處理\n            result.append(None)\n\n    # 將結果輸出成符合題目格式的 JSON 字串\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line. Should describe logic. Probably use trie or hash. Simpler: buildDict store set of words. search: for each position, try all 26 letters except original, construct new string, check if in set. Complexity fine. Provide virtual code steps. Each line: \"Step X:\" etc. Use arrow. We'll show Start, Decision, etc.\n\nLet's produce lines:\n\nStart\n→ Step 1: Define class MagicDictionary // class definition\n→ Step 2: Initialize empty set wordSet // store dictionary words\n→ Step 3: buildDict(dictionary) // populate set\n   → For each word in dictionary: add to wordSet // store distinct words\n→ End\n\nThen search logic:\n\n→ Step 4: search(searchWord) // function to check\n   → Decision: If searchWord length 0? // edge case\n      Yes → Return false // cannot change one char\n      No → Proceed\n   → For i from 0 to len-1:\n      → For each ch from 'a' to 'z':\n          → Decision: if ch == searchWord[i]? // skip same char\n              Yes → Continue\n              No → \n                 → newWord = replace character at i with ch // construct\n                 → Decision: if newWord in wordSet? // found\n                     Yes → Return true // one modification matches\n   → Return false // no match found\n\nEnd\n\nWe need to use arrow syntax \"→\". Use Decision indentation.\n\nProvide each line as required.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 MagicDictionary // 建立 MagicDictionary 類  \n→ Step 2: 初始化空集合 wordSet // 用來存放字典中的單字  \n→ Step 3: buildDict(dictionary) // 取得並儲存字典  \n  → For 每個 word 在 dictionary:  \n    → 加入 word 至 wordSet // 確保字典單字唯一  \n→ End // 建構完成  \n\n→ Step 4: search(searchWord) // 判斷是否可正好改一個字元匹配字典  \n  → Decision: 搜尋字串長度是否為 0?  \n    Yes → Return false // 不能改一個字元  \n    No → 進行檢查  \n  → For i 從 0 到 length(searchWord)-1:  \n    → For 每個字母 ch 從 'a' 到 'z':  \n      → Decision: ch 是否等於 searchWord[i]?  \n       Yes → Continue // 跳過相同字元，避免無變化  \n       No →  \n        → newWord ← 將 searchWord[i] 換成 ch // 建立新字串  \n        → Decision: newWord 是否在 wordSet?  \n         Yes → Return true // 找到符合條件的單字  \n         No → 继续循环  \n  → Return false // 沒有任何一個改動能匹配字典  \n→ End // 程式執行結束"
    },
    {
      "title": "Bulb Switcher II",
      "source_file": "Leetcode/leetcode672.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1, presses = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnrcb5p_0.py\", line 39, in <module>\n    main()\n  File \"/tmp/tmpnrcb5p_0.py\", line 31, in main\n    nums = [int(s) for s in data.replace(',', ' ').replace('=', ' ').split()]\n            ^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        },
        {
          "example_index": 1,
          "input": "n = 2, presses = 1",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp6jfijl5.py\", line 39, in <module>\n    main()\n  File \"/tmp/tmpp6jfijl5.py\", line 31, in main\n    nums = [int(s) for s in data.replace(',', ' ').replace('=', ' ').split()]\n            ^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        },
        {
          "example_index": 2,
          "input": "n = 3, presses = 1",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfm2pvk40.py\", line 39, in <module>\n    main()\n  File \"/tmp/tmpfm2pvk40.py\", line 31, in main\n    nums = [int(s) for s in data.replace(',', ' ').replace('=', ' ').split()]\n            ^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        }
      ],
      "generated_code": "import sys\n\ndef flip_lights(n: int, presses: int) -> int:\n    # Precompute the four button patterns\n    pattern1 = [1] * n                                   # Button 1: all bulbs\n    pattern2 = [1 if i % 2 == 0 else 0 for i in range(1, n + 1)]  # Button 2: even\n    pattern3 = [1 if i % 2 == 1 else 0 for i in range(1, n + 1)]  # Button 3: odd\n    pattern4 = [1 if (i - 1) % 3 == 0 else 0 for i in range(1, n + 1)]  # Button 4: 1 mod 3\n\n    patterns = [pattern1, pattern2, pattern3, pattern4]\n    unique_states = set()\n\n    for mask in range(16):  # 4 buttons → 16 possible parity combinations\n        k = bin(mask).count('1')  # number of buttons pressed an odd number of times\n        if k > presses or (presses - k) % 2 == 1:\n            continue  # this combination cannot be achieved with exactly 'presses' presses\n\n        # Compute the resulting state for this parity combination\n        state = [0] * n\n        for b in range(4):\n            if mask >> b & 1:\n                pat = patterns[b]\n                for i in range(n):\n                    state[i] ^= pat[i]\n        unique_states.add(tuple(state))\n\n    return len(unique_states)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    nums = [int(s) for s in data.replace(',', ' ').replace('=', ' ').split()]\n    if len(nums) < 2:\n        return\n    n, presses = nums[0], nums[1]\n    result = flip_lights(n, presses)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step pseudocode that given n and presses returns number of possible statuses. Need to think algorithm: 4 buttons operations. Each button toggles subset of bulbs. We can represent each operation as vector of length n bits. The set of possible resulting statuses after exactly presses moves: we apply sequence of operations. Since toggling is XOR. The total effect is XOR of chosen button vectors. But order irrelevant; only count of times each button pressed modulo 2 matters because pressing same button twice cancels. However we must have exactly presses total. So we need to count number of sequences of length presses where resulting vector is distinct? Wait problem: \"return the number of different possible statuses after performing all presses button presses.\" So we consider all possible sequences of length presses (order matters) and count distinct final statuses. Equivalent to number of distinct XOR combinations achievable with exactly presses selections.\n\nWe can precompute basis of button vectors: B1= all 1s. B2= even indices 1. B3= odd indices 1. B4= indices 1 mod3.\n\nWe can compute span of these 4 vectors; but with restrictions on parity of counts per button. Since pressing button twice cancels, only parity matters. So for each vector we have choice 0 or1 times. So maximum 2^4=16 possible final statuses. However presses must be exactly given number; so parity constraint: sum of chosen counts mod2 equals something? Wait number of presses pressed for each button i: pi. total presses sum pi = presses. parity of pi matters for effect. So we need to count distinct XOR results among all pi vectors where sum pi = presses, pi >=0 integer. For each vector we only care pi mod 2. But presses parity constraints may limit reachable combinations.\n\nLet ai = pi mod2. Then effect is XOR of ai*Bi. We need to find number of distinct XOR results among all ai satisfying sum(pi)=presses.\n\nBut pi can be any nonnegative integers with given parity. For each ai, there exist pi with that parity if presses >= sum(ai) and parity of presses equals parity of sum(ai). Because we can adjust remaining presses by adding pairs of same button (adds 2 to pi). So condition: sum(ai) <= presses and (presses - sum(ai)) even. So set of achievable ai is those with sum(ai) <= presses and same parity. So number of distinct statuses equals number of distinct XOR results for all subsets of buttons with size <= presses and parity same as presses.\n\nThus we can enumerate subsets (16). For each subset S, let k=|S|. If k <= presses and (presses - k) %2 ==0 then status possible. Count distinct XOR vectors among such S.\n\nThus algorithm: compute XOR vector for each subset. Use set to count unique vectors. Complexity O(16* n). n can be large maybe up to 10^5, but fine.\n\nWe need pseudocode steps. Provide virtual code lines. Use Start, End. Use Decision, etc.\n\nLet's produce steps:\n\nStart\n→ Step 1: Read n, presses\n→ Step 2: Define array buttonVectors[4] length n\n    For i=1 to n:\n        buttonVectors[0][i] = 1  // button1 all on\n        buttonVectors[1][i] = (i%2==0)?1:0  // even\n        buttonVectors[2][i] = (i%2==1)?1:0  // odd\n        buttonVectors[3][i] = ((i-1)%3==0)?1:0  // 1 mod 3\n→ Step 3: Initialize set statusSet\n→ Step 4: For mask from 0 to 15:\n    → Decision: Let k = popcount(mask) // number of buttons pressed odd times\n        Yes → Decision: if k <= presses AND (presses - k) %2 == 0 // achievable\n            Yes → Step: Compute xorVector = zeros\n                For b from 0 to 3:\n                    if mask bit b is 1:\n                        xorVector ^= buttonVectors[b]\n                Add xorVector to statusSet\n        No → continue\n→ Step 5: Return size of statusSet\nEnd\n\nNeed explain each line. Use arrow syntax.\n\nWe must output each line with explanation. We'll list each line accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n 與 presses // 取得燈號數量與按鈕總按下次數  \n→ Step 2: 建立四個長度為 n 的布林向量 buttonVectors[4] // 每個向量代表一個按鈕的翻轉規則  \n  → For i 從 1 到 n  \n    buttonVectors[0][i] = true // 按鈕1：所有燈號翻轉  \n    buttonVectors[1][i] = (i % 2 == 0) // 按鈕2：偶數標號燈號翻轉  \n    buttonVectors[2][i] = (i % 2 == 1) // 按鈕3：奇數標號燈號翻轉  \n    buttonVectors[3][i] = ((i - 1) % 3 == 0) // 按鈕4：1,4,7,…標號燈號翻轉  \n→ Step 3: 建立集合 statusSet 以存放不同的燈號狀態 // 方便去重  \n→ Step 4: 循環所有 2^4 = 16 種按鈕奇偶組合  \n  → For mask 從 0 到 15  \n    → Decision: 令 k = popcount(mask) // 這個組合中被按奇數次的按鈕數量  \n     Yes → Decision: 若 k <= presses 且 (presses - k) % 2 == 0  \n      Yes → Step: 建立空的 xorVector  \n       → For b 從 0 到 3  \n        Decision: 若 mask 的第 b 位為 1  \n         Yes → xorVector ^= buttonVectors[b] // 對應按鈕的翻轉結果進行 XOR  \n        No → 何也不做  \n       → Add xorVector 到 statusSet // 若組合可達，加入結果  \n     No → 何也不做  \n→ Step 5: 回傳 statusSet 的大小 // 不同可能的燈號狀態數量  \nEnd // 程式執行結束"
    },
    {
      "title": "24 Game",
      "source_file": "Leetcode/leetcode679.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "cards = [1,2,1,2]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmps12hp_hz.py\", line 57, in <module>\n    result = sol.judgePoint24(cards)\n             ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmps12hp_hz.py\", line 33, in judgePoint24\n    if dfs(list(perm)):\n       ^^^^^^^^^^^^^^^\n  File \"/tmp/tmps12hp_hz.py\", line 28, in dfs\n    if dfs(rest + [res]):\n       ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmps12hp_hz.py\", line 28, in dfs\n    if dfs(rest + [res]):\n       ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmps12hp_hz.py\", line 28, in dfs\n    if dfs(rest + [res]):\n       ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmps12hp_hz.py\", line 11, in dfs\n    return abs(nums[0] - 24) < eps\n               ~~~~~~~~^~~~\nTypeError: unsupported operand type(s) for -: 'NoneType' and 'int'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport itertools\n\nclass Solution:\n    def judgePoint24(self, nums):\n        eps = 1e-6\n\n        def dfs(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < eps\n            for i in range(len(nums)):\n                for j in range(len(nums)):\n                    if i == j:\n                        continue\n                    a, b = nums[i], nums[j]\n                    rest = [nums[k] for k in range(len(nums)) if k != i and k != j]\n                    for op in (lambda x, y: x + y,\n                               lambda x, y: x - y,\n                               lambda x, y: x * y,\n                               lambda x, y: x / y if abs(y) > eps else None):\n                        if op is None:\n                            continue\n                        try:\n                            res = op(a, b)\n                        except ZeroDivisionError:\n                            continue\n                        if dfs(rest + [res]):\n                            return True\n            return False\n\n        for perm in itertools.permutations(nums):\n            if dfs(list(perm)):\n                return True\n        return False\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input like 'cards = [4,1,8,7]' or just a list string.\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    try:\n        start = data.index('[')\n        end = data.index(']', start)\n        list_str = data[start:end+1]\n        return ast.literal_eval(list_str)\n    except ValueError:\n        # Fallback: assume whole string is a list\n        return ast.literal_eval(data)\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    cards = parse_input(raw)\n    sol = Solution()\n    result = sol.judgePoint24(cards)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need produce virtual code steps to solve problem: given array of 4 numbers, find if any arrangement using + - * / and parentheses yields 24. Need algorithm: brute force permutations and operations combinations and binary tree structures. Use DFS.\n\nWe output line by line pseudocode with explanations. Ensure to cover generating permutations of numbers, operations combinations, and recursively combine pairs. Use decision structure. End result: true/false.\n\nLet's craft.\n\nStart\n→ Generate all permutations of cards // 4! permutations\nFor each perm\n    → Recursively combine numbers to produce 24? // call function\n        Recursively: if only one number left\n            Yes → Check if abs(num-24) < epsilon // true\n            No  → Return false\n        Else\n            For each pair i<j\n                For each operation op in + - * /\n                    Compute result\n                    If op is division and second operand close to 0 skip\n                    Form new list: result + remaining numbers\n                    → Recursively call on new list\n                    Decision: If recursive true\n                        Yes → Return true\n            End loops\n→ Decision: If any permutation yields true\n    Yes → Return true\n    No  → Return false\nEnd\n\nWe need line-by-line with comments.\n\nAlso include epsilon.\n\nLet's produce.\n\nUse arrow indentation for decisions.\n\nWe'll produce pseudo-code with simple syntax.\n\nRemember to include virtual code step then comment after //.\n\nLet's generate final.\n...done thinking.\n\nStart // 程式開始執行  \n→ GeneratePermutations(cards) → permList // 產生所有 4! 種數字排列  \n→ Decision: 是否有排列能產生 24? // 檢查每個排列  \n    Yes → For each perm in permList  \n        → Call CanReach24(perm) // 以此排列遞迴判斷是否能得到 24  \n        Decision: CanReach24(perm) 為 true? // 判斷遞迴結果  \n            Yes → Return true // 找到有效表達式，結束  \n            No  → Continue // 試下一個排列  \n    No  → Return false // 所有排列都失敗，無法得到 24  \nEnd // 程式執行結束  \n\n---  \n//------------------------------  \n// 函式: CanReach24(nums)  \nCanReach24(nums) // 判斷給定數字列表是否能組成 24  \n→ Decision: nums 只剩 1 個? // 只有一個數字時可直接比較  \n    Yes → Decision: abs(nums[0] - 24) < epsilon? // 允許微小浮點誤差  \n        Yes → Return true // 正好等於 24  \n        No  → Return false // 不等於 24  \n    No  → Decision: 選取兩個數字 i < j? // 迭代所有數字對  \n        Yes → For each op in ['+','-','*','/']  \n            → Decision: op 是 '/' 且 nums[j] ≈ 0? // 避免除以 0  \n                Yes → Continue // 跳過此組合  \n                No  → Compute result // 執行運算  \n                    If op == '+' → result = nums[i] + nums[j]  \n                    If op == '-' → result = nums[i] - nums[j]  \n                    If op == '*' → result = nums[i] * nums[j]  \n                    If op == '/' → result = nums[i] / nums[j]  \n                → Build newList = [result] + nums[k] for all k ≠ i, j // 創造新列表  \n                → Call CanReach24(newList) // 以新列表遞迴  \n                Decision: CanReach24(newList) 為 true?  \n                    Yes → Return true // 成功找到表達式  \n                    No  → Continue // 試下一個操作  \n        End For  \n        End Decision  \n        Return false // 所有數字對與操作都嘗試完畢但無法得到 24  \nEnd // 函式結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_c7f7wqf.py\", line 69, in <module>\n    main()\n  File \"/tmp/tmp_c7f7wqf.py\", line 63, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_c7f7wqf.py\", line 20, in __init__\n    self.lookup[(prefix, suffix)] = weight  # 覆蓋即為最大索引\n    ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom typing import List, Dict, Tuple\n\n\nclass WordFilter:\n    \"\"\"\n    將每個單字的所有前綴和後綴組合成鍵，對應到最大的索引\n    \"\"\"\n    def __init__(self, words: List[str]) -> None:\n        self.lookup: Dict[Tuple[str, str], int] = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            # 產生所有前綴\n            for i in range(L + 1):\n                prefix = word[:i]\n                # 產生所有後綴\n                for j in range(L + 1):\n                    suffix = word[j:]\n                    self.lookup[(prefix, suffix)] = weight  # 覆蓋即為最大索引\n\n    def f(self, prefix: str, suffix: str) -> int:\n        \"\"\"\n        回傳符合前綴和後綴的最大索引，若不存在則回傳 -1\n        \"\"\"\n        return self.lookup.get((prefix, suffix), -1)\n\n\ndef _split_input(data: str) -> Tuple[str, str]:\n    \"\"\"\n    將輸入字串拆成兩個 JSON 片段：第一個是 words list，第二個是 query\n    \"\"\"\n    bracket_level = 0\n    for idx, ch in enumerate(data):\n        if ch == '[':\n            bracket_level += 1\n        elif ch == ']':\n            bracket_level -= 1\n            if bracket_level == 0:\n                first = data[:idx + 1]\n                rest = data[idx + 1 :].strip()\n                if rest.startswith(','):\n                    rest = rest[1:].strip()\n                return first, rest\n    return data, ''\n\n\ndef main() -> None:\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    words_json, query_json = _split_input(raw)\n    words: List[str] = json.loads(words_json)\n    # query 可能是一對字串，或多個查詢的列表\n    query_data = json.loads(query_json)\n    if isinstance(query_data, list) and len(query_data) == 2:\n        queries = [query_data]\n    else:\n        # 假設 query_data 本身就是多個查詢，每個是 [prefix, suffix]\n        queries = query_data\n\n    wf = WordFilter(words)\n    for pref, suff in queries:\n        print(wf.f(pref, suff))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for WordFilter class: constructor takes array of words, builds data structure for prefix-suffix search. f(pref, suff) returns max index of word with that prefix and suffix. Usually solution: use hash map from combined prefix#suffix to max index. Or use trie. We'll produce algorithm using map of combined prefix-suffix keys. Provide step-by-step pseudocode.\n\nThe user wants each line: virtual code + comment. Use arrow notation. Should show Start, End, Decision, etc. Provide for constructor and method f. Also may include building data structure. Let's produce a high-level pseudo code:\n\nStart\n→ WordFilter(words)\n    → For each index i, word\n        → For each prefix length 0..len(word)\n            → prefix = word[0:len]\n            → For each suffix length 0..len(word)\n                → suffix = word[len(word)-len:]\n                → key = prefix + \"#\" + suffix\n                → map[key] = i  // store max index\n→ f(pref, suff)\n    → key = pref + \"#\" + suff\n    → If key in map\n        → Return map[key]\n        → Else return -1\n\nBut to be more efficient, we can use only prefixes and suffixes. But it's okay.\n\nWe must output each line with comment. Use arrow indentation maybe.\n\nLet's craft:\n\nStart // 程式開始執行\n\n→ WordFilter(words) // 建構子：接收字串陣列\n\n    → For i from 0 to words.length-1 // 逐字索引\n        → word = words[i]\n        → For preLen from 0 to word.length // 產生所有前綴\n            → pref = word.substring(0, preLen)\n            → For sufLen from 0 to word.length // 產生所有後綴\n                → suff = word.substring(word.length - sufLen)\n                → key = pref + \"#\" + suff\n                → map[key] = i // 以最大索引覆蓋\n\n→ f(pref, suff) // 搜尋方法\n    → key = pref + \"#\" + suff\n    → If key in map\n        → Return map[key] // 找到對應最大索引\n        → Else\n            → Return -1\n\nEnd // 程式結束\n\nBut need to use Decision arrow. Provide decision: If key in map? Yes/No.\n\nAlso we can include Start of class, End of class, but just show pseudo code. Use `Decision:` lines.\n\nLet's produce.\n\nEnsure each line ends with comment after //.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ WordFilter(words) // 建構子：接收字串陣列並初始化資料結構\n    → For i from 0 to words.length-1 // 逐字索引\n        → word = words[i] // 取得目前字串\n        → For preLen from 0 to word.length // 產生所有前綴\n            → pref = word.substring(0, preLen) // 前綴字串\n            → For sufLen from 0 to word.length // 產生所有後綴\n                → suff = word.substring(word.length - sufLen) // 後綴字串\n                → key = pref + \"#\" + suff // 組合鍵\n                → map[key] = i // 存入映射，覆蓋為最大索引\n→ f(pref, suff) // 搜尋方法：回傳符合前綴與後綴的最大索引\n    → key = pref + \"#\" + suff // 組合鍵\n    → Decision: key 是否存在於 map? // 判斷是否有匹配\n        Yes → Return map[key] // 取得最大索引\n        No  → Return -1 // 無匹配項，返回 -1\nEnd // 程式執行結束"
    },
    {
      "title": "Two Sum",
      "source_file": "Leetcode/leetcode1.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,7,11,15], target = 9",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp20f8uj3d.py\", line 37, in <module>\n    nums, target = parse_input(raw_data)\n                   ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp20f8uj3d.py\", line 26, in parse_input\n    target_part = parts[1].split('=')[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,4], target = 6",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp77tzn7sk.py\", line 37, in <module>\n    nums, target = parse_input(raw_data)\n                   ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp77tzn7sk.py\", line 26, in parse_input\n    target_part = parts[1].split('=')[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3], target = 6",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkeh8zw__.py\", line 37, in <module>\n    nums, target = parse_input(raw_data)\n                   ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkeh8zw__.py\", line 26, in parse_input\n    target_part = parts[1].split('=')[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Find two indices i, j such that nums[i] + nums[j] == target.\n        Uses a hash map to store numbers seen so far and their indices.\n        \"\"\"\n        seen = {}\n        for i, val in enumerate(nums):\n            complement = target - val\n            if complement in seen:\n                return [seen[complement], i]\n            seen[val] = i\n        # According to the problem statement, a solution always exists.\n        return []\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form 'nums = [2,7,11,15], target = 9'.\n    Returns a tuple (nums, target).\n    \"\"\"\n    parts = data.split(',')\n    nums_part = parts[0].split('=')[1].strip()\n    target_part = parts[1].split('=')[1].strip()\n    nums = eval(nums_part)          # safe because input is controlled by the judge\n    target = int(target_part)\n    return nums, target\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_data = sys.stdin.read().strip()\n    if not raw_data:\n        sys.exit(0)\n\n    nums, target = parse_input(raw_data)\n\n    solution = Solution()\n    result = solution.twoSum(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line, with explanation comments. Virtual code format using arrows, Start, End, Decision. Must avoid actual code. Provide steps: iterate through array with hash map to store number to index. For each number, compute complement target - num, check if complement in map, if yes return indices. else store current index. At the end End. Provide steps line by line. Ensure each line contains \"虛擬碼步驟 [space] // 解釋\". Use arrow \"→\". Also use Decision: structure. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空哈希表 hashMap，鍵為數字，值為其索引 // 用於快速查找已遍歷的數字  \n→ Step 2: 針對 nums 中每個索引 i 進行迴圈 // 循環遍歷整個陣列  \n  → Step 3: 計算 complement = target - nums[i] // 需要的配對數字  \n  → Decision: hashMap 是否包含 complement? // 檢查是否已找到符合條件的數字  \n   Yes → Step 4: 回傳 [hashMap[complement], i] // 找到答案，返回兩個索引  \n   No  → Step 5: 將 nums[i] 加入 hashMap 且值為 i // 儲存當前數字與索引以供後續查詢  \nEnd // 程式執行結束，若沒有提前返回則表示沒有符合條件的兩數（理論上不會發生）"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,null,-3,null,0,-2]'\nGot (Norm):      '[null,null,null,null,null,-3,null,0,-2]'\n--- (Raw) ---\nRaw Expected: '[null,null,null,null,-3,null,0,-2]'\nRaw Got:      '[null,null,null,null,null,-3,null,0,-2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MinStack:\n    \"\"\"\n    儲存堆疊元素與最小值堆疊\n    \"\"\"\n    def __init__(self):\n        self.stack = []      # 主堆疊\n        self.min_stack = []  # 最小堆疊\n\n    def push(self, val: int) -> None:\n        \"\"\"把 val 推進主堆疊，同時更新最小堆疊\"\"\"\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        \"\"\"移除主堆疊頂部元素，若為最小值也從最小堆疊移除\"\"\"\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        if val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self) -> int | None:\n        \"\"\"取得主堆疊頂部元素\"\"\"\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -> int | None:\n        \"\"\"取得目前堆疊中的最小值\"\"\"\n        return self.min_stack[-1] if self.min_stack else None\n\n\ndef main() -> None:\n    \"\"\"\n    主程式：讀取輸入，執行 MinStack 的各項操作，並輸出結果\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入為兩個列表：operations 與 arguments\n    try:\n        ops, args = ast.literal_eval(data)\n    except Exception:\n        # 若輸入是兩行，先分行再解析\n        parts = data.splitlines()\n        ops = ast.literal_eval(parts[0])\n        args = ast.literal_eval(parts[1])\n\n    # 儲存每一次操作的輸出結果\n    output = []\n\n    # 建構子對應 null\n    min_stack = MinStack()\n    output.append('null')\n\n    # 執行所有操作\n    for op, arg in zip(ops, args):\n        if op == 'push':\n            min_stack.push(arg[0])\n            output.append('null')\n        elif op == 'pop':\n            min_stack.pop()\n            output.append('null')\n        elif op == 'top':\n            val = min_stack.top()\n            output.append(str(val) if val is not None else 'null')\n        elif op == 'getMin':\n            val = min_stack.getMin()\n            output.append(str(val) if val is not None else 'null')\n        else:\n            # 未定義的操作，直接忽略\n            output.append('null')\n\n    # 印出結果，符合 LeetCode 的輸出格式\n    print('[' + ','.join(output) + ']')\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo-code lines, each with comment. Provide for MinStack implementation. Must maintain O(1). Standard approach: maintain two stacks: data stack and min stack. push: push to data; if min empty or val <= min.top, push to min. pop: pop from data; if popped equals min.top, pop min. top: return data.top. getMin: return min.top.\n\nSo we produce pseudo-code lines accordingly. Format: Start // 程式開始執行 etc. Provide class definition? We can treat as pseudo-code steps for operations.\n\nLet's produce structure:\n\nStart // Start\n→ Step: 初始化兩個空堆疊 dataStack, minStack // Create empty stacks\n\n→ Decision: 操作類型? // Determine operation\n\nBut maybe just show methods. But user expects virtual code for entire solution? Usually they'd want the code skeleton. We can present pseudo-code for class and methods.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step: 定義 MinStack 類別 // Declare class\n    → Step: 定義 private 成員: dataStack, minStack // Define stacks\n\nThen methods:\n\n→ Step: Constructor: 初始化 dataStack, minStack // Initialize stacks\n\n→ Step: push(val):\n    → Step: dataStack.push(val) // Push onto main stack\n    → Decision: minStack.isEmpty() 或 val <= minStack.top()?\n        Yes → minStack.push(val) // 更新最小堆疊\n        No  → // 不更新\n\n→ Step: pop():\n    → Step: val = dataStack.pop() // 移除頂部元素\n    → Decision: val == minStack.top()?\n        Yes → minStack.pop() // 同時移除最小堆疊頂部\n        No  → // 不移除\n\n→ Step: top():\n    → Return dataStack.top() // 取得主堆疊頂部\n\n→ Step: getMin():\n    → Return minStack.top() // 取得最小堆疊頂部\n\nEnd\n\nMake sure each line is a separate pseudo-code step, comments after space.\n\nWe need each line has arrow if necessary. For nested decisions, indent with tabs? In example they used indentation with spaces. We'll replicate.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義 MinStack 類別 // 宣告 MinStack 類型  \n  → Step: 定義私有成員 dataStack, minStack // 兩個堆疊用於存儲數值與最小值  \n→ Step: MinStack() // 建構子  \n  → Step: dataStack 初始化為空堆疊 // 主堆疊  \n  → Step: minStack 初始化為空堆疊 // 最小堆疊  \n\n→ Step: push(val) // 將值 val 推進堆疊  \n  → Step: dataStack.push(val) // 把 val 放到主堆疊頂部  \n  → Decision: minStack.isEmpty() 或 val <= minStack.top()? // 判斷是否需要更新最小值  \n    Yes → minStack.push(val) // 新的最小值也推進最小堆疊  \n    No  → // 無需更新最小堆疊  \n\n→ Step: pop() // 移除堆疊頂部元素  \n  → Step: val = dataStack.pop() // 從主堆疊取出頂部值  \n  → Decision: val == minStack.top()? // 檢查是否同時是最小值  \n    Yes → minStack.pop() // 同時從最小堆疊移除  \n    No  → // 不需要移除最小堆疊  \n\n→ Step: top() // 取得堆疊頂部元素  \n  → Return dataStack.top() // 回傳主堆疊的頂部值  \n\n→ Step: getMin() // 取得目前最小值  \n  → Return minStack.top() // 回傳最小堆疊的頂部值  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder",
      "source_file": "Leetcode/leetcode127.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList) -> int:\n        # 若目標字不在字典中，直接返回 0\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return 0\n        # 若起點即終點，最短序列長度為 1\n        if beginWord == endWord:\n            return 1\n\n        # BFS：佇列中儲存 (單詞, 目前層數)\n        queue = deque([(beginWord, 1)])\n        # 已訪問的單詞，起點視為已訪問\n        visited = {beginWord}\n\n        while queue:\n            word, level = queue.popleft()\n            # 逐位替換字母，產生相鄰節點\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word == endWord:\n                        return level + 1\n                    if new_word in word_set and new_word not in visited:\n                        visited.add(new_word)\n                        queue.append((new_word, level + 1))\n        # 無法到達終點\n        return 0\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 將輸入字串轉為字典字面值\n    # 將 \"beginWord = \"hit\"\" 這種格式改為 \"beginWord: \"hit\"\"，再加上大括號\n    raw_dict = '{' + raw.replace('=', ':') + '}'\n    try:\n        data = ast.literal_eval(raw_dict)\n    except Exception as e:\n        # 如果解析失敗，輸出 0\n        print(0)\n        return\n\n    beginWord = data.get('beginWord', '')\n    endWord = data.get('endWord', '')\n    wordList = data.get('wordList', [])\n\n    solution = Solution()\n    result = solution.ladderLength(beginWord, endWord, wordList)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code with steps, comments. Problem: Word Ladder shortest path length. Use BFS from beginWord to endWord over graph where edges between words differ by one letter. Use word list set. If endWord not in set, return 0. BFS with queue, track depth. We'll produce steps with Start, Step, Decision, End. Must be per line. Let's design.\n\nSteps:\nStart\n→ Check if endWord in wordList set else return 0\n→ Initialize queue with (beginWord, 1)\n→ Initialize visited set with beginWord\n→ While queue not empty:\n    ← Dequeue word, level\n    ← For each position i in word:\n        ← For each letter 'a'..'z':\n            ← Form newWord\n            ← If newWord == endWord: return level+1\n            ← If newWord in wordList and not visited:\n                → Enqueue (newWord, level+1)\n                → Mark visited\nEnd // if loop ends without finding endWord return 0\n\nAlso need to handle case beginWord==endWord: return 1? Actually shortest sequence includes beginWord and endWord, so length 1? Usually return 1. We'll include decision.\n\nLet's produce virtual code lines:\n\nStart // 程式開始執行\n→ Decision: 若 endWord 不在 wordList? // 檢查目標字是否存在字典\n    No  → Step: 設 wordSet ← wordList 轉集合 // 方便查詢\n    Yes → Step: 返回 0 // 沒有目標字，無法完成轉換\n→ Decision: 若 beginWord == endWord? // 起點即終點\n    Yes → Step: 返回 1 // 轉換序列長度為 1\n    No  → Step: 初始化 queue ← (beginWord, 1) // BFS: (單詞, 層數)\n    No  → Step: 初始化 visited ← {beginWord} // 已訪問集合\n→ Decision: 循環 while queue 非空? // BFS 主循環\n    Yes → Step: Dequeue currentWord, level from queue // 取出前置單詞及其深度\n    Yes → Step: 迭代 i 從 0 到 len(currentWord)-1 // 遍歷每個位置\n        → Step: 迭代 c 從 'a' 到 'z' // 替換字母\n            → Step: newWord ← currentWord 的第 i 位換成 c // 生成新單詞\n            → Decision: 若 newWord == endWord? // 找到終點\n                Yes → Step: 返回 level + 1 // 成功完成，返回序列長度\n                No  → Decision: 若 newWord 在 wordSet 且未訪問? // 合法且未處理\n                    Yes → Step: Enqueue (newWord, level + 1) // 將新單詞加入佇列\n                    Yes → Step: Mark visited 新Word // 標記為已訪問\n                    No  → Step: 跳過 // 不合法或已訪問\n            No  → Step: 繼續迭代下一個字母\n        No  → Step: 繼續迭代下一個位置\n    No  → Step: 繼續循環 while queue 非空\n→ Step: 返回 0 // 無法到達 endWord\nEnd // 程式執行結束\n\nNeed to ensure each line ends with comment. Provide exactly as format. Let's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 若 endWord 不在 wordList? // 檢查目標字是否存在字典  \n  Yes → Step: 返回 0 // 沒有目標字，無法完成轉換  \n  No  → Step: wordSet ← wordList 轉集合 // 方便查詢  \n→ Decision: 若 beginWord == endWord? // 起點即終點  \n  Yes → Step: 返回 1 // 轉換序列長度為 1  \n  No  → Step: queue ← (beginWord, 1) // BFS: (單詞, 層數)  \n  No  → Step: visited ← {beginWord} // 已訪問集合  \n→ Decision: 循環 while queue 非空? // BFS 主循環  \n  Yes → Step: currentWord, level ← queue.dequeue() // 取出前置單詞及其深度  \n  Yes → Step: 迭代 i 從 0 到 len(currentWord)-1 // 遍歷每個位置  \n    → Step: 迭代 c 從 'a' 到 'z' // 替換字母  \n     → Step: newWord ← currentWord 的第 i 位換成 c // 生成新單詞  \n     → Decision: 若 newWord == endWord? // 找到終點  \n      Yes → Step: 返回 level + 1 // 成功完成，返回序列長度  \n      No  → Decision: 若 newWord 在 wordSet 且未訪問? // 合法且未處理  \n       Yes → Step: queue.enqueue(newWord, level + 1) // 將新單詞加入佇列  \n       Yes → Step: visited.add(newWord) // 標記為已訪問  \n       No  → Step: 跳過 // 不合法或已訪問  \n     No  → Step: 繼續迭代下一個字母"
    },
    {
      "title": "Count Binary Substrings",
      "source_file": "Leetcode/leetcode696.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"00110011\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "s = \"10101\"",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '10'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '10'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        # 建立連續相同字元的群組長度列表\n        groups = []\n        count = 1\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                count += 1\n            else:\n                groups.append(count)\n                count = 1\n        groups.append(count)\n\n        # 計算符合條件的子字串數量\n        result = 0\n        for i in range(1, len(groups)):\n            result += min(groups[i], groups[i - 1])\n        return result\n\nif __name__ == \"__main__\":\n    s = sys.stdin.readline().strip()\n    solution = Solution()\n    print(solution.countBinarySubstrings(s))",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. It's a classic problem: Count Binary Substrings. Approach: iterate string, count lengths of consecutive groups, store in list. Then iterate adjacent pairs of group lengths, add min(len[i], len[i+1]) to result.\n\nWe need to output virtual code lines with arrows and explanation. Must be in Traditional Chinese. No actual code. Provide lines with virtual code step and explanation after //.\n\nUse arrows: Start, → Step, Decision etc.\n\nWe'll need steps:\n\nStart\n→ Step 1: Initialize variables: result=0, prev=0, current=1 // store counts\n→ Step 2: Loop through string from index 1 to end: // iterate each char\n   Decision: If s[i] == s[i-1]?\n     Yes → current++ // same group continue\n     No → result += min(prev, current) // add min of prev group and current group\n           prev = current // move current to prev\n           current = 1 // reset current to 1 for new group\n→ Step 3: After loop, add min(prev, current) // last group\n→ Step 4: Return result\nEnd\n\nBut ensure we capture requirement that substrings counted per occurrence. Explanation lines.\n\nWe also need to use 虛擬碼 arrow and decision labels.\n\nWe'll produce lines as required. Use traditional Chinese.\n\nMake sure each line contains \"虛擬碼步驟\" followed by // explanation.\n\nWe should include indentation for Decision lines? Format example shows indentation for nested steps. Use spaces.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化變數 result = 0, prev = 0, current = 1 // 設定結果、前一組長度、目前組長度\n→ Step 2: 從索引 1 開始迴圈遍歷字串 s // 逐個檢查字元\n    Decision: 若 s[i] 等於 s[i-1]? // 判斷是否屬於同一組\n        Yes → current = current + 1 // 同組字元，累加組長\n        No  → result = result + min(prev, current) // 結束一組，累加可組合子字串數\n             → prev = current // 將目前組長設為前一組長\n             → current = 1 // 重置目前組長為 1，開始新組\n→ Step 3: 迴圈結束後，result = result + min(prev, current) // 處理最後一組\n→ Step 4: 回傳 result // 結束並返回答案\nEnd // 程式執行結束\n\nCheck format: each line must have `虛擬碼步驟` + space + `// 解釋`. We used `Step 1:`. Good.\n\nWe need to ensure lines are exactly \"虛擬碼步驟\" not \"虛擬碼步驟\"? The prompt says each line must contain: `虛擬碼步驟` + `[空格]` + `// 解釋/說明`. They used \"虛擬碼步驟\" as placeholder; we should output actual code like `Start` etc. So line format: e.g., `Start // 程式開始執行`. Good.\n\nMake sure to use arrow \"→\" for steps. For decision lines, use \"Decision:\".\n\nThus final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 result = 0, prev = 0, current = 1 // 設定結果、前一組長度與目前組長度  \n→ Step 2: 從索引 1 開始迴圈遍歷字串 s // 逐個檢查字元  \n Decision: 若 s[i] 等於 s[i-1]? // 判斷是否屬於同一組  \n  Yes → current = current + 1 // 同組字元，累加組長  \n  No → result = result + min(prev, current) // 結束一組，累加可組合子字串數  \n   → prev = current // 將目前組長設為前一組長  \n   → current = 1 // 重置目前組長為 1，開始新組  \n→ Step 3: 迴圈結束後，result = result + min(prev, current) // 處理最後一組  \n→ Step 4: 回傳 result // 結束並返回答案  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,4,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 4, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立一個字典，鍵為數值，值為該數值所有索引的清單\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機挑選 target 在 num_indices[target] 中的任一索引\n        return random.choice(self.num_indices[target])\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入拆成方法名稱列表和對應參數列表\n    # 例如: '[\"Solution\", \"pick\"], [[[1, 2, 3]], [2]]'\n    split_index = data.find('],')\n    if split_index == -1:\n        return\n    commands_str = data[:split_index+1]          # 包含第一個閉括號\n    args_str = data[split_index+2:].strip()     # 從第二個開括號開始\n    commands = ast.literal_eval(commands_str)\n    args_list = ast.literal_eval(args_str)\n\n    outputs = []\n    obj = None\n    for cmd, arg in zip(commands, args_list):\n        if cmd == 'Solution':\n            # arg 是類似 [[1, 2, 3]] 的結構，取第一個元素作為 nums\n            obj = Solution(arg[0])\n            outputs.append(None)\n        elif cmd == 'pick':\n            res = obj.pick(arg[0])\n            outputs.append(res)\n        else:\n            outputs.append(None)\n\n    # 將輸出格式化為 LeetCode 樣式的 JSON (null 代表 None)\n    formatted = '[' + ', '.join('null' if v is None else str(v) for v in outputs) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code in lines, each line with \"虛擬碼步驟\" and explanation, following the formatting guidelines. They want to not output actual code, just steps.\n\nWe need to design a virtual algorithm for the class Solution: constructor takes array nums; pick(target) randomly picks index.\n\nTypical solution: preprocess: build hash map target -> vector of indices; then pick returns random index from vector.\n\nAlternatively reservoir sampling: iterate through array and randomly pick index among matches. But they may want that method because not need extra memory. But either approach is fine.\n\nLet's produce virtual code that shows building a map in constructor, then pick.\n\nLet's write steps:\n\nStart\n→ Step 1: 初始化 Solution: 接收 nums\n→ Step 2: 建立空字典 indicesMap\n→ Decision: 遍歷 nums 從 i=0 到 len-1\n    → Step 3: let val = nums[i]\n    → Decision: val 是否已存在於 indicesMap?\n        Yes → Step 4: 將 i 加入 indicesMap[val] 的索引清單\n        No  → Step 5: 在 indicesMap 建立新條目，值為 [i]\n→ Step 6: 存儲 indicesMap 為物件屬性\n→ End\n\nThen pick method:\nStart\n→ Step 7: 接收 target\n→ Step 8: 從 indicesMap 取出索引清單 targetIndices\n→ Step 9: 產生隨機整數 r 在 [0, len(targetIndices)-1] 之間\n→ Step 10: 回傳 targetIndices[r]\n→ End\n\nBut need to follow the arrow syntax: \"→\" for steps, \"Decision:\" etc.\n\nWe need to use arrow arrow. For decisions: \"Decision:\".\n\nAlso need to include comments in Chinese after //.\n\nAlso each line must have \"虛擬碼步驟\" then a space then comment.\n\nLet's produce virtual code lines for the whole class: include constructor and pick.\n\nWe need to show each line separately.\n\nOk, let's craft.\n\nWe need to start with Start, End.\n\nWe should separate constructor block and pick block maybe with comment lines like \"Start Constructor\".\n\nWe can produce:\n\nStart // 程式開始執行\n\n→ Step 1: 接收參數 nums // 初始化建構子\n\n→ Step 2: 建立空字典 indicesMap // 用於存儲每個值對應的索引清單\n\n→ Decision: 遍歷 nums 的每個索引 i\n    Yes → Step 3: 取得 nums[i] 為 val\n    Yes → Decision: indicesMap 是否包含 val?\n        Yes → Step 4: 將 i 加入 indicesMap[val]\n        No  → Step 5: 建立 indicesMap[val] 為新列表 [i]\n→ Step 6: 將 indicesMap 存入物件屬性 this.indicesMap // 完成建構\n\nEnd // 建構子結束\n\nStart // pick 方法開始執行\n→ Step 7: 接收目標值 target\n→ Step 8: 取得 indices = this.indicesMap[target] // 所有符合 target 的索引\n→ Decision: indices 是否存在\n    Yes → Step 9: 計算 len = indices.length\n    Yes → Step 10: 產生隨機整數 r 在 0 到 len-1\n    Yes → Step 11: 回傳 indices[r] // 隨機選取\n→ End // pick 方法結束\n\nBut we need to keep each line separately, no nested lines? The example shows nested lines with indentation. We can use indentation with spaces before \"Yes →\" etc. But each line still a separate line.\n\nLet's produce lines accordingly:\n\nStart // 程式開始執行\n→ Step 1: 接收參數 nums // 初始化建構子\n→ Step 2: 建立空字典 indicesMap // 用於存儲每個值對應的索引清單\n→ Decision: 遍歷 nums 的每個索引 i\n    Yes → Step 3: 取得 nums[i] 為 val // 取得目前元素值\n    Yes → Decision: indicesMap 是否包含 val?\n        Yes → Step 4: 將 i 加入 indicesMap[val] // 已有索引列表，追加新索引\n        No  → Step 5: 建立 indicesMap[val] 為新列表 [i] // 新值，建立列表\n→ Step 6: 將 indicesMap 存入物件屬性 this.indicesMap // 完成建構\nEnd // 建構子結束\n\nStart // pick 方法開始執行\n→ Step 7: 接收目標值 target // pick 的參數\n→ Step 8: 取得 indices = this.indicesMap[target] // 所有符合 target 的索引\n→ Decision: indices 是否存在\n    Yes → Step 9: 計算 len = indices.length // 索引列表長度\n    Yes → Step 10: 產生隨機整數 r 在 0 到 len-1 // 隨機選取位置\n    Yes → Step 11: 回傳 indices[r] // 回傳隨機索引\n→ End // pick 方法結束\n\nBut we need to ensure each line is separate. For indentation, we can indent the nested lines with 4 spaces maybe. But each line should be one line. Ok.\n\nWe might also need to include \"Decision:\" for pick to check indices exist, but assumption target exists, so we can skip. But keep for safety.\n\nLet's format.\n\nWe should start each line with \"虛擬碼步驟\" part. But we don't need to literally write \"虛擬碼步驟\". They mean each line has the step and comment.\n\nThus, just write the step text, like \"Start\". Then a space then comment.\n\nWe need to ensure we follow the formatting: \"虛擬碼步驟 [空格] // 解釋\". So we must have step text, space, then comment.\n\nOk.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收參數 nums // 初始化建構子  \n→ Step 2: 建立空字典 indicesMap // 用於存儲每個值對應的索引清單  \n→ Decision: 遍歷 nums 的每個索引 i  \n    Yes → Step 3: 取得 nums[i] 為 val // 取得目前元素值  \n    Yes → Decision: indicesMap 是否包含 val?  \n        Yes → Step 4: 將 i 加入 indicesMap[val] // 已有索引列表，追加新索引  \n        No  → Step 5: 建立 indicesMap[val] 為新列表 [i] // 新值，建立列表  \n→ Step 6: 將 indicesMap 存入物件屬性 this.indicesMap // 完成建構  \nEnd // 建構子結束  \n\nStart // pick 方法開始執行  \n→ Step 7: 接收目標值 target // pick 的參數  \n→ Step 8: 取得 indices = this.indicesMap[target] // 所有符合 target 的索引  \n→ Decision: indices 是否存在  \n    Yes → Step 9: 計算 len = indices.length // 索引列表長度  \n    Yes → Step 10: 產生隨機整數 r 在 0 到 len-1 // 隨機選取位置  \n    Yes → Step 11: 回傳 indices[r] // 回傳隨機索引  \n→ End // pick 方法結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3, 2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 將每個單字映射到其索引\n        word_to_index = {word: i for i, word in enumerate(words)}\n        res = []\n\n        for i, word in enumerate(words):\n            # 依次嘗試所有切分點 j\n            for j in range(len(word) + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                # 如果前綴已經是字典中的單詞，且後綴是回文\n                if prefix in word_to_index and word_to_index[prefix] != i and suffix == suffix[::-1]:\n                    res.append([i, word_to_index[prefix]])\n\n                # 如果後綴已經是字典中的單詞，且前綴是回文\n                # j != 0 防止重複\n                if j != 0 and suffix in word_to_index and word_to_index[suffix] != i and prefix == prefix[::-1]:\n                    res.append([word_to_index[suffix], i])\n\n        return res\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 只取出第一個 '[' 後面的字串作為 list 表示\n    start = data.find('[')\n    if start == -1:\n        words = []\n    else:\n        list_str = data[start:]\n        try:\n            words = ast.literal_eval(list_str)\n        except Exception:\n            words = []\n\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for algorithm to find all palindrome pairs in O(total length). Classic solution: use Trie of reversed words, check splits. Provide virtual code line by line. Provide explanations.\n\nWe need to follow format. Provide steps like Start, etc.\n\nLet's produce algorithm:\n\n1. Build a map from word to its index.\n2. For each word, iterate all splits including empty prefix/suffix.\n3. For each split, if prefix is palindrome, find reversed suffix in map and pair accordingly.\n4. Similarly if suffix palindrome and not same word, pair reversed prefix.\n5. Add result pairs.\n\nAlso need to account for empty string case.\n\nAll within total length.\n\nWe produce virtual code with arrows and decision.\n\nLet's craft lines:\n\nStart // ...\n→ Step 1: 建立 wordIndexMap // 將每個單詞對應到其索引\n→ For each word (idx, w) in words: // 迭代每個單詞\n    → Step 2: 針對 w 的所有切分進行檢查 // 將單詞切成前綴與後綴\n        → For len from 0 to w.length: // 切分點\n            → Substring prefix = w[0:len], suffix = w[len:]\n            → Decision: prefix 是否為回文? // 檢查前綴\n                Yes → Step 3: 若 reverse(suffix) 在 map 且 map[reverse(suffix)] != idx, 則加入 [map[reverse(suffix)], idx] // 將回文前綴配對\n                No  → No action\n            → Decision: suffix 是否為回文? // 檢查後綴\n                Yes → Step 4: 若 reverse(prefix) 在 map 且 map[reverse(prefix)] != idx，且 len != w.length，則加入 [idx, map[reverse(prefix)]] // 將回文後綴配對\n                No  → No action\n    → Step 5: 特殊處理空字串 // 若 words 包含空字串\n        → Decision: 是否存在空字串? // ...\n        → Yes → For each word non-empty且是回文，加入 [index_of_empty, idx] 和 [idx, index_of_empty]\n→ End // 結束\n\nBut we must also ensure O(total length). Use prefix/suffix loops but overall complexity linear. Provide explanation.\n\nLet's produce final answer with virtual code lines and comments.\n\nEnsure each line ends with `// 解釋/說明`.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 wordIndexMap ← 於 map[word] 記錄 words 之索引 // 為快速查找單詞索引  \n→ Step 2: 將 words 迭代為 (idx, w) // 逐個處理每個單詞  \n    → Step 3: 針對單詞 w 進行所有切分點 i（0 到 w.length） // 切分成前綴與後綴  \n        → Step 4: 前綴 prefix ← w[0:i]，後綴 suffix ← w[i:] // 取得切分後的兩段  \n        → Decision: prefix 是否為回文? // 檢查前綴是否可形成完整回文  \n            Yes → Step 5: reverseSuffix ← reverse(suffix)  \n                → Decision: reverseSuffix 在 wordIndexMap 且 wordIndexMap[reverseSuffix] ≠ idx? // 找到匹配的另一個單詞  \n                    Yes → Step 6: 加入 pair [wordIndexMap[reverseSuffix], idx] // 將前綴回文配對  \n                    No  → No action  \n            No  → No action  \n        → Decision: suffix 是否為回文? // 檢查後綴是否可形成完整回文  \n            Yes → Step 7: reversePrefix ← reverse(prefix)  \n                → Decision: reversePrefix 在 wordIndexMap 且 wordIndexMap[reversePrefix] ≠ idx 且 i ≠ w.length? // 確保不是空切分重複  \n                    Yes → Step 8: 加入 pair [idx, wordIndexMap[reversePrefix]] // 將後綴回文配對  \n                    No  → No action  \n            No  → No action  \n    → Step 9: 特殊處理空字串 case  \n        → Decision: words 包含空字串? // 判斷是否存在空字串  \n            Yes → emptyIdx ← wordIndexMap[\"\"]  \n                → For each (j, w2) in words, j ≠ emptyIdx:  \n                    → Decision: w2 是否為回文? // 只有回文才能與空字串配對  \n                        Yes → Step 10: 加入 pair [emptyIdx, j]  \n                        Yes → Step 11: 加入 pair [j, emptyIdx]  \n                        No  → No action  \n            No → No action  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"Return the length of the longest uncommon subsequence.\"\"\"\n        freq = Counter(strs)\n        for s in strs:\n            if freq[s] == 1:\n                return len(s)\n        return -1\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        print(-1)\n    else:\n        # Parse the input string as a list of strings\n        try:\n            strs = json.loads(data)\n        except json.JSONDecodeError:\n            # If JSON parsing fails, try using literal_eval as a fallback\n            from ast import literal_eval\n            strs = literal_eval(data)\n        # Ensure we have a list of strings\n        if not isinstance(strs, list):\n            print(-1)\n        else:\n            sol = Solution()\n            result = sol.findLUSlength(strs)\n            print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm. We should explain each line. We need to handle problem: longest uncommon subsequence between strings in array. Known solution: If any string appears only once, return its length; else return -1. Because if there are duplicates, cannot use that as uncommon; but if a string is unique, it's longest possible subsequence: itself. If no unique string, answer -1.\n\nThus virtual code: Start → Step 1: build frequency map of each string → Step 2: iterate through array → Decision: if freq[str] == 1 → return len(str). After loop, return -1. That covers algorithm.\n\nBut we must produce line-by-line virtual code with arrows etc. Use \"Decision:\" \"Yes →\" \"No →\" lines. Provide explanation after \"//\".\n\nAlso include array iteration and map building.\n\nWe need to output with \"虛擬碼步驟\" before each line, but example uses \"Step 1:\" etc. So we will produce similar format.\n\nWe should follow guidelines: \"每行必須包含：`虛擬碼步驟` + [空格] + `// 解釋/說明`\". And arrow usage.\n\nWe'll produce:\n\nStart // 程式開始\n→ Step 1: 建立空字典 freq // 用於計算每個字串出現次數\n→ Step 2: 對每個字串 s in strs 進行\n    → Step 2.1: freq[s] = freq.get(s,0)+1 // 更新頻率\n→ Step 3: 對每個字串 s in strs 進行\n    → Decision: 如果 freq[s] == 1?\n        Yes → Step 3.1: 回傳 len(s) // 唯一出現的字串即為最長不常見子序列\n        No  → Decision: 繼續迴圈 // 不是唯一，檢查下一個\n→ Step 4: 回傳 -1 // 沒有唯一字串，無不常見子序列\nEnd // 程式結束\n\nWe need to ensure arrow structure: use \"→\" before lines inside steps. For decisions, \"Decision:\" and indent for Yes/No.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 建立空字典 freq // 用於計算每個字串出現次數  \n→ Step 2: 對每個字串 s in strs 進行  \n → Step 2.1: freq[s] = freq.get(s,0)+1 // 更新頻率  \n→ Step 3: 對每個字串 s in strs 進行  \n → Decision: 如果 freq[s] == 1? // 判斷是否為唯一出現  \n  Yes → Step 3.1: 回傳 len(s) // 唯一字串即為最長不常見子序列  \n  No  → Decision: 繼續檢查下一個字串 // 不是唯一，轉至下一個  \n→ Step 4: 回傳 -1 // 未發現唯一字串，無不常見子序列  \nEnd // 程式結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 解析輸入，例如 \"nums = [1,2,3]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        nums = ast.literal_eval(expr.strip())\n    else:\n        nums = ast.literal_eval(data)\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code with arrows, step-by-step. The problem: generate all permutations of an array of distinct integers. We need to output the virtual code and brief explanation after each line. Use \"Start\", \"End\", \"Decision:\" etc. Use arrows \"→\". Provide line by line. Ensure each line includes \"虛擬碼步驟\" + space + \"// 解釋/說明\". So we produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化結果列表 result ← [] // 用於存放所有排列\n→ Step 2: 定義遞歸函數 permute(idx, current) // idx 為目前處理到的位置\n→ Step 3: Decision: 如果 idx 等於 nums.length? // 判斷是否已經處理完所有元素\n    Yes → Step 4: 把 current 追加到 result // 完整排列加入結果\n    No  → Decision: 迭代 i 從 0 到 nums.length-1? // 選取尚未使用的元素\n        ← (此處需要維護已使用集合) ...\nBut we need to produce a full flowchart-like description. The problem: permutations. Standard backtracking: we maintain used boolean array or swap in place. For simplicity, we can use recursion with backtracking: maintain current path and visited. So steps: start, call helper(0). In helper, if path length = nums.length, add to result. Else for each i not visited: mark visited, append nums[i], recurse, pop, unvisit.\n\nWe need to produce virtual code lines accordingly. We'll use decision arrows. Provide line for loop and decisions. Let's design:\n\nStart // 程式開始\n→ Step 1: 取得輸入陣列 nums // 從使用者取得\n→ Step 2: 初始化 result ← [] // 用來儲存所有排列\n→ Step 3: 初始化 visited ← [false]*nums.length // 標記是否已被使用\n→ Step 4: 呼叫遞迴函式 backtrack(path, index) // 開始回溯\n    // backtrack defined below\n→ Step 5: 在 backtrack 中 Decision: 如果 path.length 等於 nums.length? // 判斷是否已完成一個排列\n        Yes → Step 6: result.append(copy of path) // 將完整排列加入結果\n        No  → Step 7: Decision: 迭代 i 從 0 到 nums.length-1? // 逐一嘗試未使用的元素\n                Yes? Actually loop with decision for visited\n                ← If not visited[i]:\n                    → Step 8: visited[i] ← true // 標記使用\n                    → Step 9: path.append(nums[i]) // 加入元素\n                    → Step 10: backtrack(path, index+1) // 進一步遞迴\n                    → Step 11: path.pop() // 移除最後元素，回溯\n                    → Step 12: visited[i] ← false // 取消標記\n→ Step 13: 回到主程式\n→ End // 完成\n\nBut need to express in virtual code style. Use \"Decision:\" lines. Use \"Yes →\" and \"No →\" accordingly. For loops, we can indicate as \"Loop: for i in 0..nums.length-1\" but maybe use Decision inside. Use arrows accordingly.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 從使用者處取得\n→ Step 2: 初始化 result ← [] // 用於存放所有排列\n→ Step 3: 初始化 visited ← [false, false, …] // 與 nums 長度相同，用來標記已使用的元素\n→ Step 4: 呼叫 backtrack(0, []) // 開始回溯，起始位置為 0，路徑為空\n→ Step 5: 定義函式 backtrack(index, path) // index 表示目前已放置的元素個數\n    // 內部邏輯以下\n→ Step 6: Decision: 若 path.length 等於 nums.length? // 判斷是否已完成一個完整排列\n        Yes → Step 7: result.append(copy of path) // 完整排列加入結果\n        No  → Step 8: Loop: for i in 0 .. nums.length-1 // 逐一嘗試每個元素\n                → Decision: 是否已使用 visited[i]? // 判斷該元素是否已被放入\n                    Yes → No → // 跳過已使用的元素\n                    No  → Step 9: visited[i] ← true // 標記元素為已使用\n                            → Step 10: path.append(nums[i]) // 加入元素到路徑\n                            → Step 11: backtrack(index+1, path) // 進一步遞迴\n                            → Step 12: path.pop() // 從路徑移除最後加入的元素，回溯\n                            → Step 13: visited[i] ← false // 取消標記\n→ End // 程式執行結束，result 中含有所有排列\n\nBut we must ensure each line is separate, with arrow lines, and each line ends with \"// 解釋\". Also need to include arrow for the \"Loop: for\" but the format didn't mention \"Loop:\", but we can treat loop as Decision or just as step with arrow to \"Loop\".\n\nThe output must be purely virtual code lines. Avoid actual code. Use \"Step\" numbers etc. Let's produce.\n\nWe need to use arrow after each step. For decisions, we need to include \"Decision: ...\". Provide Yes and No sub-lines with arrows. Let's produce final output accordingly.\n\nAlso ensure we do not output actual code. Provide only virtual code lines.\n\nLet's craft final output:\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 從使用者處取得待排列的整數陣列  \n→ Step 2: 初始化 result ← [] // 用來存放所有生成的排列  \n→ Step 3: 初始化 visited ← [false, false, …] // 與 nums 長度相同，標記每個元素是否已被使用  \n→ Step 4: 呼叫 backtrack(0, []) // 開始回溯，起始位置為 0，路徑為空陣列  \n→ Step 5: 定義函式 backtrack(index, path) // index 表示已放置元素的數量，path 是目前的排列  \n    // 內部邏輯以下  \n→ Step 6: Decision: 若 path.length 等於 nums.length? // 判斷是否已組成完整排列  \n        Yes → Step 7: result.append(copy of path) // 完整排列加入結果列表  \n        No  → Step 8: Loop: for i in 0 .. nums.length-1 // 嘗試每個尚未使用的元素  \n                → Decision: visited[i] 是否為 true? // 檢查元素是否已被放入路徑  \n                    Yes → No → // 跳過已使用的元素，繼續下一個 i  \n                    No  → Step 9: visited[i] ← true // 標記元素為已使用  \n                            → Step 10: path.append(nums[i]) // 將元素加入當前路徑  \n                            → Step 11: backtrack(index+1, path) // 進一步遞迴探索剩餘位置  \n                            → Step 12: path.pop() // 回溯：移除最後加入的元素  \n                            → Step 13: visited[i] ← false // 取消標記，讓元素可再次使用  \n→ End // 程式執行結束，result 中已包含所有可能的排列順序"
    },
    {
      "title": "Sliding Window Maximum",
      "source_file": "Leetcode/leetcode239.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "expected_output": "[3,3,5,5,6,7]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfdf1luur.py\", line 28, in parse_input\n    data = eval('{' + inp.replace('=', ':') + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'nums' is not defined\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpfdf1luur.py\", line 40, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfdf1luur.py\", line 34, in parse_input\n    nums = eval(nums_part)\n           ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\ndef max_sliding_window(nums, k):\n    if not nums or k == 0:\n        return []\n    deq = deque()\n    res = []\n    for i, num in enumerate(nums):\n        # 移除已離開窗口的索引\n        while deq and deq[0] < i - k + 1:\n            deq.popleft()\n        # 移除後端比當前數字小的索引\n        while deq and nums[deq[-1]] < num:\n            deq.pop()\n        deq.append(i)\n        # 窗口已滿時，將最大值加入結果\n        if i >= k - 1:\n            res.append(nums[deq[0]])\n    return res\n\ndef parse_input(inp):\n    inp = inp.strip()\n    if not inp:\n        return [], 0\n    # 將輸入轉換成字典格式，例如: {nums: [...], k: 3}\n    try:\n        data = eval('{' + inp.replace('=', ':') + '}')\n        return data.get('nums', []), data.get('k', 0)\n    except Exception:\n        # 若解析失敗，嘗試另一種簡易解析方式\n        parts = [p.strip() for p in inp.split(',')]\n        nums_part = parts[0].split('=', 1)[1].strip()\n        nums = eval(nums_part)\n        k = int(parts[1].split('=')[1].strip())\n        return nums, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    result = max_sliding_window(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Problem: sliding window maximum. Approach: use deque to store indices of useful elements. For each i, remove indices out of window; remove smaller values from back; add current index; when i >= k-1, output max at front. Provide start, decisions. Provide virtual steps.\n\nMake sure each line is `虛擬碼步驟 // 解釋`. Use arrows. Need Start, End. Use Decision: conditions. Provide loops.\n\nLet's craft:\n\nStart // start\n\n→ Step 1: 初始化空 deque Q // 用於存儲索引\n\n→ Step 2: 初始化空列表 output // 儲存結果\n\n→ For i from 0 to len(nums)-1 // 遍歷整個陣列\n\n    → Decision: 是否需要移除離開窗口的索引？ // 檢查最前面的索引是否在窗口外\n\n        Yes → Step: 移除 Q 的前端 // 移除已離開窗口的索引\n\n    → Decision: 是否需要移除小於 nums[i] 的後端索引？ // 從後端移除較小的元素，保持降序\n\n        Yes → Step: 移除 Q 的後端 // 移除不再是最大值候選的索引\n\n    → Step: 將 i 加入 Q 的後端 // 加入當前索引\n\n    → Decision: i >= k-1 ? // 窗口已滿\n\n        Yes → Step: 將 nums[Q.front] 加入 output // 目前窗口最大值\n\nEnd // 結束\n\nNeed to ensure formatting: each line as \"虛擬碼步驟 // 解釋\". Use arrows `→` only at the start of each line? For nested lines, we can indent with spaces or use lines with arrow and decision inside. The example shows indentation with spaces. We'll replicate.\n\nSo output:\n\nStart // 程式開始執行\n→ Step 1: 初始化空 deque Q // 用於存儲索引\n→ Step 2: 初始化空列表 output // 儲存結果\n→ For i from 0 to len(nums)-1 // 遍歷整個陣列\n    → Decision: Q.front <= i - k ? // 檢查最前面的索引是否已離開窗口\n        Yes → Step: 移除 Q.front // 移除已離開窗口的索引\n    → Decision: nums[Q.back] < nums[i] ? // 從後端移除較小的元素，保持降序\n        Yes → Step: 移除 Q.back // 移除不再是最大值候選的索引\n    → Step: 將 i 加入 Q.back // 加入當前索引\n    → Decision: i >= k - 1 ? // 窗口已滿\n        Yes → Step: 將 nums[Q.front] 加入 output // 目前窗口最大值\nEnd // 程式執行結束\n\nMake sure each line is one line; indentation for nested. Use spaces. Use arrow and decision as shown. Provide final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空 deque Q // 用於存儲索引  \n→ Step 2: 初始化空列表 output // 儲存結果  \n→ For i from 0 to len(nums)-1 // 遍歷整個陣列  \n    → Decision: Q.front <= i - k ? // 檢查最前面的索引是否已離開窗口  \n        Yes → Step: 移除 Q.front // 移除已離開窗口的索引  \n    → Decision: nums[Q.back] < nums[i] ? // 從後端移除較小的元素，保持降序  \n        Yes → Step: 移除 Q.back // 移除不再是最大值候選的索引  \n    → Step: 將 i 加入 Q.back // 加入當前索引  \n    → Decision: i >= k - 1 ? // 窗口已滿  \n        Yes → Step: 將 nums[Q.front] 加入 output // 目前窗口最大值  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null,true,false,true,1,true,2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass RandomizedCollection:\n    \"\"\"\n    A data structure that supports inserting, removing and getting a random element\n    in average O(1) time even when duplicate values are allowed.\n    \"\"\"\n    def __init__(self):\n        # 存放所有元素，方便用索引取隨機值\n        self.data = []\n        # 每個值對應的索引集合，使用 set 方便 O(1) 的增刪\n        self.idx_map = defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"\n        插入一個值，返回是否為第一次插入。\n        \"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        # 如果 idx_map[val] 的長度為 1，表示此值第一次出現\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"\n        移除一個值，返回是否成功。\n        \"\"\"\n        if not self.idx_map[val]:\n            return False\n\n        # 取出 idx_map[val] 中的一個索引，並將其對應位置的元素移除\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n\n        # 如果要移除的不是最後一個元素，則需要把最後一個元素移到該位置\n        if remove_idx != len(self.data) - 1:\n            self.data[remove_idx] = last_val\n            # 更新 last_val 的索引集合\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(len(self.data) - 1)\n\n        # 刪除最後一個元素\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"\n        隨機返回一個元素，概率與元素個數成正比。\n        \"\"\"\n        return random.choice(self.data)\n\ndef main():\n    # 讀取輸入，格式為兩個 JSON 陣列，中間用逗號分隔\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 將兩個陣列包裝成一個外層陣列，並修正逗號分隔\n    wrapped = '[' + raw.replace('], [', '],[') + ']'\n    ops, args = json.loads(wrapped)\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            results.append(None)  # Constructor的返回值為 null\n        elif op == \"insert\":\n            results.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            results.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            results.append(obj.getRandom())\n        else:\n            # 未定義的操作，忽略\n            results.append(None)\n\n    # 輸出結果，使用 json 讓 None 轉成 null\n    print(json.dumps(results, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementation of RandomizedCollection with insert, remove, getRandom, O(1). Use dictionary mapping value to set of indices, and vector array for values. Steps include initialization, insert, remove, getRandom. Provide line by line with explanations. Use arrows and decisions. Let's craft.\n\nMake Start, then steps. Let's include variables: arr, map. Insert: add val to arr, record index in map[val] set. Return not existed? Determine if val existed before. Remove: if val not in map: return false. Else, pick an index from map[val] set. Swap with last element if not same. Update map sets. Pop last. Return true. getRandom: random choice from arr. Provide pseudo.\n\nNeed to use arrow structure. Let's format each line: \"Step: ... // explanation\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 建立空陣列 values ← [] // 用於儲存所有元素，允許隨機存取\n→ Step 2: 建立映射 indexMap ← {} // key: 數值，value: set 其在 values 的索引集合\n→ Step 3: 定義 RandomizedCollection() // 初始化建構子，已完成上述兩步\n\n→ Step 4: 定義 insert(val) // 插入元素\n    → Step 4.1: 取得目前 values 長度 len ← values.size() // 新元素將放在尾部\n    → Step 4.2: 將 val 加入 values → values.append(val) // O(1) 時間\n    → Step 4.3: 若 val 不在 indexMap 中，建立空集合 → if val not in indexMap: indexMap[val] = set()\n    → Step 4.4: 將索引 len 加入 indexMap[val] → indexMap[val].add(len) // O(1) 更新集合\n    → Step 4.5: 判斷 val 是否第一次出現 → Decision: 若 val 之前不存在?\n        Yes → Return True // 第一次插入，返回 true\n        No  → Return False // 已存在，返回 false\n\n→ Step 5: 定義 remove(val) // 刪除元素\n    → Step 5.1: Decision: 若 val 不在 indexMap? // 判斷是否存在\n        Yes → Return False // 沒有該元素，返回 false\n        No  → \n            → Step 5.2: 取得並移除一個索引 remIdx ← indexMap[val].pop() // 任取一索引\n            → Step 5.3: 取得陣列最後一個元素 lastVal ← values[-1] // 為了交換\n            → Step 5.4: 若 remIdx ≠ len(values)-1? // 需要交換\n                Yes → \n                    → Step 5.4.1: 替換索引 → values[remIdx] = lastVal\n                    → Step 5.4.2: 更新 indexMap[lastVal]： \n                        → Step 5.4.2.1: 從 indexMap[lastVal] 移除舊索引 len(values)-1\n                        → Step 5.4.2.2: 加入新索引 remIdx\n                No  → // 若刪除的是最後一個元素，無需交換\n            → Step 5.5: 從 values 刪除最後元素 → values.pop()\n            → Step 5.6: 若 indexMap[val] 為空集合? // 可能已經沒有該值\n                Yes → del indexMap[val] // 清除空集合\n            → Step 5.7: Return True // 成功刪除一個實例\n\n→ Step 6: 定義 getRandom() // 隨機取元素\n    → Step 6.1: 產生隨機索引 idx ← random.randint(0, len(values)-1) // O(1)\n    → Step 6.2: Return values[idx] // 依概率返回\n\nEnd // 程式執行結束"
    },
    {
      "title": "Coin Change",
      "source_file": "Leetcode/leetcode322.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9jdrtj9a.py\", line 29, in <module>\n    coins = eval(coins_part.split('=', 1)[1].strip())\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def coinChange(self, coins, amount):\n        # dp[i] 表示湊成金額 i 所需最少硬幣數，初始為無限大\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0  # 金額為 0 時不需要硬幣\n\n        # 逐一遍歷每個硬幣，更新 dp 陣列\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                if dp[x - coin] + 1 < dp[x]:\n                    dp[x] = dp[x - coin] + 1\n\n        # 若 dp[amount] 仍為無限大，表示無法湊成該金額\n        return dp[amount] if dp[amount] != float('inf') else -1\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入格式: 例如 \"coins = [1,2,5], amount = 11\"\n    parts = [p.strip() for p in data.split(',')]\n    coins_part = parts[0]\n    amount_part = parts[1]\n\n    coins = eval(coins_part.split('=', 1)[1].strip())\n    amount = int(amount_part.split('=', 1)[1].strip())\n\n    # 計算並輸出結果\n    sol = Solution()\n    result = sol.coinChange(coins, amount)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for coin change problem using DP. Use standard DP array. Outline steps.\n\nWe produce each line with arrow.\n\nWe'll start: Start. Then initialize dp array size amount+1 with large number (infinite). dp[0]=0.\n\nLoop i from 1 to amount: for each coin: if coin <= i: dp[i] = min(dp[i], dp[i-coin]+1).\n\nAfter loop, if dp[amount] > amount: return -1 else return dp[amount].\n\nWe'll produce virtual code lines with explanations. Use arrow, Decision for checking if dp[amount] > amount.\n\nEnsure each line: \"虛擬碼步驟 // 解釋\" with arrow or structure.\n\nLet's craft.\n\nLines:\n\nStart // 程式開始\n\n→ Step 1: 設定 MAX = amount + 1 // 最大值作為無限\n\n→ Step 2: 初始化 dp[0..amount] 為 MAX // dp 用於存儲最小硬幣數\n\n→ Step 3: dp[0] = 0 // 零金額不需要硬幣\n\n→ Step 4: For i from 1 to amount: // 遍歷每個金額\n\n    → Step 5: For each coin in coins: // 逐個硬幣\n\n        → Decision: if coin <= i? // 能否使用此硬幣\n\n            Yes → Step 6: dp[i] = min(dp[i], dp[i - coin] + 1) // 更新最小硬幣數\n\n            No → // 直接跳過\n\n← End For loops\n\n→ Decision: if dp[amount] == MAX? // 仍無法組合\n\n    Yes → Step 7: return -1 // 不能組合\n\n    No → Step 8: return dp[amount] // 返回結果\n\nEnd // 程式結束\n\nNeed to ensure each line has arrow or structure. Use \"→\" for steps. For nested loops, indent.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 設定 MAX = amount + 1 // 用於表示無限大\n\n→ Step 2: 初始化 dp[0..amount] 為 MAX // dp 用來存最小硬幣數\n\n→ Step 3: dp[0] = 0 // 金額為 0 時不需要硬幣\n\n→ Step 4: For i from 1 to amount: // 逐金額遍歷\n\n    → Step 5: For each coin in coins: // 逐硬幣考慮\n\n        → Decision: 如果 coin <= i? // 能否用此硬幣\n\n            Yes → Step 6: dp[i] = min(dp[i], dp[i - coin] + 1) // 更新 dp[i]\n\n            No  → // 跳過此硬幣\n\n← End For loops\n\n→ Decision: 如果 dp[amount] == MAX? // 仍無法組成\n\n    Yes → Step 7: return -1 // 不能用任何組合組成\n\n    No  → Step 8: return dp[amount] // 返回最小硬幣數\n\nEnd // 程式結束"
    },
    {
      "title": "Minimum Number of Arrows to Burst Balloons",
      "source_file": "Leetcode/leetcode452.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "points = [[1,2],[3,4],[5,6],[7,8]]",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '0'"
        },
        {
          "example_index": 2,
          "input": "points = [[1,2],[2,3],[3,4],[4,5]]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findMinArrowShots(self, points):\n        \"\"\"\n        Returns the minimum number of arrows required to burst all balloons.\n        points: List[List[int]] where each sublist is [x_start, x_end].\n        \"\"\"\n        if not points:\n            return 0\n\n        # Sort intervals by their ending coordinate\n        points.sort(key=lambda x: x[1])\n        arrows = 1                     # At least one arrow is needed\n        current_end = points[0][1]      # End of the first interval\n\n        # Greedy traversal: each time a new interval starts after current_end,\n        # a new arrow is required\n        for start, end in points[1:]:\n            if start > current_end:\n                arrows += 1\n                current_end = end\n\n        return arrows\n\n\nif __name__ == \"__main__\":\n    # Read entire stdin content, e.g., 'points = [[10,16],[2,8],[1,6],[7,12]]'\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(0)\n        sys.exit(0)\n\n    # Evaluate the input string to extract the points list\n    # The input format is a valid Python expression\n    try:\n        points = eval(raw_input)\n    except Exception as e:\n        # If evaluation fails, output 0 as a safe fallback\n        print(0)\n        sys.exit(0)\n\n    # Compute and output the result\n    result = Solution().findMinArrowShots(points)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solution: classic intervals covering with min arrows. Approach: sort intervals by end, then greedily count arrows when next interval not covered by current arrow. Pseudocode lines. Provide comments. Let's produce step-by-step. Ensure each line ends with // explanation.\n\nWe must not output actual code, just pseudocode with arrows. Use Start, End, Decision, etc. Let's craft.\n\nStructure: Start → Step 1: Sort points by x_end ascending. → Step 2: Initialize arrowCount=0, currentArrowEnd = None. → Decision: if points empty? → Yes → End else continue. Then iterate intervals. For each interval: Decision: if currentArrowEnd is None or interval.x_start > currentArrowEnd? → Yes → Step: arrowCount++ ; currentArrowEnd = interval.x_end // fire new arrow at interval end. No → continue // interval already covered.\n\nAfter loop, End. Provide explanation each line.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort `points` by `x_end` ascending // 將所有氣球依右端點排序，方便貪婪選擇  \n→ Step 2: Initialize `arrowCount = 0` and `currentArrowEnd = None` // 記錄已射出的箭數與目前箭最後可命中的右端點  \n→ Decision: 如果 `points` 為空? // 檢查是否有氣球需要處理  \n Yes → End // 無氣球，直接結束  \n No  → // 進入主迴圈  \n→ Step 3: 對每個 `interval` in `points` 執行循環  \n → Decision: `currentArrowEnd` 為 None 或 `interval.x_start > currentArrowEnd`? // 判斷該氣球是否已被現有箭擊中  \n  Yes → Step 4: `arrowCount++` // 需要新箭  \n   → Step 5: `currentArrowEnd = interval.x_end` // 射箭點選在此氣球的右端，以覆蓋最大區間  \n  No  → // 氣球已被覆蓋，無需新增箭  \nEnd // 程式執行結束，`arrowCount` 為最小箭數"
    },
    {
      "title": "Maximum Distance in Arrays",
      "source_file": "Leetcode/leetcode624.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "arrays = [[1,2,3],[4,5],[1,2,3]]",
          "expected_output": " 4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpc1tf1tj7.py\", line 27, in <module>\n    arrays = eval(data)\n             ^^^^^^^^^^\n  File \"<string>\", line 1\n    arrays = [[1,2,3],[4,5],[1,2,3]]\n           ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": " arrays = [[1],[1]]",
          "expected_output": " 0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkif4aixa.py\", line 27, in <module>\n    arrays = eval(data)\n             ^^^^^^^^^^\n  File \"<string>\", line 1\n    arrays = [[1],[1]]\n           ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\n\ndef max_distance(arrays):\n    \"\"\"\n    计算从不同数组中选取的两个整数的最大绝对差值。\n    \"\"\"\n    # 初始全局最小值与最大值来自第一组\n    min_val = arrays[0][0]\n    max_val = arrays[0][-1]\n    res = 0\n\n    # 遍历其余数组\n    for arr in arrays[1:]:\n        # 计算当前数组最大值与全局最小值的差，或当前数组最小值与全局最大值的差\n        res = max(res, abs(arr[-1] - min_val), abs(max_val - arr[0]))\n        # 更新全局最小值和最大值\n        min_val = min(min_val, arr[0])\n        max_val = max(max_val, arr[-1])\n\n    return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 通过 eval 解析输入字符串为数组结构\n    arrays = eval(data)\n    result = max_distance(arrays)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code in Traditional Chinese, following the format. The problem: given m arrays sorted ascending, pick one integer from each of two distinct arrays, compute absolute difference, return maximum difference. So essentially we want to pick a and b from different arrays to maximize |a - b|. Since arrays sorted ascending, overall min among all numbers across all arrays and max among all numbers across all arrays? But must pick from different arrays, so cannot pick two numbers from same array. So we need to consider across arrays. The maximum absolute difference would be between global maximum value from one array and global minimum value from another array. But careful: if the global min and global max belong to the same array, we cannot pick them both. Then we need to find next best. But we can choose any pair across arrays, so maximum difference is max(max_i - min_j) where i != j. So algorithm: find overall min value and its array index; find overall max value and its array index. If they belong to different arrays, answer = max_val - min_val. If same array, we need next extremes: either second smallest from that array or second largest? We need to find candidate differences: max between global max and min from other arrays (excluding the array containing max), and min between global min and max from other arrays. So compute per array min and max. Then we can compute for each array, consider max_val of that array and min_val of other arrays: difference = max_val(array) - min_of_other. Similarly min_val(array) and max_of_other. Then take maximum. So algorithm: collect arrays' min and max. Compute global min and max with indices. If indices differ, answer = global_max - global_min. Else, compute best_other_min = min(min of arrays except that array), best_other_max = max(max of arrays except that array). answer = max(global_max - best_other_min, best_other_max - global_min). Implementation: loops. Complexity O(total elements) to find per array min and max.\n\nWe need to produce virtual code step-by-step. Each line includes \"虛擬碼步驟\" plus explanation. Use arrows. Let's produce.\n\nWe need to start with Start. Then maybe Step 1: Initialize arrays min and max lists. Step 2: Loop through each array: record min and max. Step 3: Find global min, global max and their indices. Step 4: Decision: are indices different? Yes→ answer=global_max - global_min; No→ compute best_other_min and best_other_max. Step 5: Compute best_other_min by scanning min array excluding index. Step 6: Compute best_other_max similarly. Step 7: answer=max(global_max - best_other_min, best_other_max - global_min). End.\n\nAdd comments. Ensure each line has arrow or indentation. Use Decision block with Yes → etc. Format lines with spaces. Provide brief explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空列表 min_vals 與 max_vals // 用於儲存每個陣列的最小值與最大值  \n→ Step 2: for 每個陣列 arr 在 0~m-1  \n&nbsp;&nbsp;→ Step 2.1: 設 min_vals[i] = arr[0] // 第一個元素即為該陣列最小值（因已升序）  \n&nbsp;&nbsp;→ Step 2.2: 設 max_vals[i] = arr[last] // 最後一個元素即為該陣列最大值  \n→ Step 3: 找出全域最小值 min_val 及其索引 min_idx  \n&nbsp;&nbsp;→ Step 3.1: min_val = min(min_vals)  \n&nbsp;&nbsp;→ Step 3.2: min_idx = min_vals.index(min_val)  \n→ Step 4: 找出全域最大值 max_val 及其索引 max_idx  \n&nbsp;&nbsp;→ Step 4.1: max_val = max(max_vals)  \n&nbsp;&nbsp;→ Step 4.2: max_idx = max_vals.index(max_val)  \n→ Decision: min_idx != max_idx? // 判斷全域最小值與最大值是否來自不同陣列  \n&nbsp;&nbsp; Yes → Step 5: answer = max_val - min_val // 直接取差值為最大距離  \n&nbsp;&nbsp; No  → Step 6: 計算其他陣列的最小值 best_other_min  \n&nbsp;&nbsp;&nbsp;&nbsp; → Step 6.1: best_other_min = min(min_vals[j] for j ≠ max_idx)  \n&nbsp;&nbsp; &nbsp;&nbsp; Step 6.2: best_other_max = max(max_vals[j] for j ≠ min_idx) // 取其他陣列的最大值  \n&nbsp;&nbsp; &nbsp;&nbsp; Step 6.3: answer = max(max_val - best_other_min, best_other_max - min_val) // 取兩種可能的最大距離  \nEnd // 程式執行結束"
    },
    {
      "title": "All O`one Data Structure",
      "source_file": "Leetcode/leetcode432.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo6m4kuv_.py\", line 109, in <module>\n    main()\n  File \"/tmp/tmpo6m4kuv_.py\", line 87, in main\n    ops = ast.literal_eval(data[0])\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7c58f7307890>"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass Node:\n    def __init__(self, count=0):\n        self.count = count\n        self.keys = set()\n        self.prev = None\n        self.next = None\n\nclass AllOne:\n    def __init__(self):\n        self.head = Node()          # dummy head\n        self.tail = Node()          # dummy tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}\n\n    def _insert_after(self, prev_node, count):\n        new_node = Node(count)\n        new_node.prev = prev_node\n        new_node.next = prev_node.next\n        prev_node.next.prev = new_node\n        prev_node.next = new_node\n        return new_node\n\n    def _remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key):\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            next_node = node.next\n            target_count = node.count + 1\n            if next_node == self.tail or next_node.count > target_count:\n                new_node = self._insert_after(node, target_count)\n            else:\n                new_node = next_node\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            # key is new\n            next_node = self.head.next\n            if next_node == self.tail or next_node.count > 1:\n                new_node = self._insert_after(self.head, 1)\n            else:\n                new_node = next_node\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n\n    def dec(self, key):\n        node = self.key_to_node[key]\n        node.keys.remove(key)\n        new_count = node.count - 1\n        if new_count == 0:\n            del self.key_to_node[key]\n        else:\n            prev_node = node.prev\n            if prev_node == self.head or prev_node.count < new_count:\n                new_node = self._insert_after(prev_node, new_count)\n            else:\n                new_node = prev_node\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self):\n        if self.tail.prev == self.head:\n            return \"\"\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self):\n        if self.head.next == self.tail:\n            return \"\"\n        return next(iter(self.head.next.keys))\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1]) if len(data) > 1 else []\n    allone = None\n    outputs = []\n    for op, args in zip(ops, args_list):\n        if op == \"AllOne\":\n            allone = AllOne()\n            outputs.append(None)\n        elif op == \"inc\":\n            allone.inc(args[0])\n            outputs.append(None)\n        elif op == \"dec\":\n            allone.dec(args[0])\n            outputs.append(None)\n        elif op == \"getMaxKey\":\n            outputs.append(allone.getMaxKey())\n        elif op == \"getMinKey\":\n            outputs.append(allone.getMinKey())\n    print(\"Output\")\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for designing a data structure AllOne. Must be O(1). Standard solution: Doubly linked list of counts, with bucket nodes containing set of keys. Map key to node. inc, dec, getMinKey, getMaxKey.\n\nWe produce stepwise pseudocode lines with explanations. Use arrow syntax.\n\nWe need to output step-by-step: Start, initializations, inc, dec, getMaxKey, getMinKey, End.\n\nBut each function can be multiple steps; we need to produce pseudo-code lines. Use Decision etc.\n\nWe'll output something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化頭尾 dummy 節點 // 建立雙向連結的 count 節點\n→ Step 2: keyNodeMap ← empty // 儲存 key 到節點的映射\n\nDefine inc(key) as function: etc.\n\nBut we need to output each line sequentially, not separate functions. But can produce separate blocks.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: Create dummyHead, dummyTail // 兩個虛擬節點，代表最小與最大 count\n\n→ Step 2: Connect dummyHead.next = dummyTail, dummyTail.prev = dummyHead\n\n→ Step 3: keyNodeMap = {} // key -> node mapping\n\nThen function inc(key):\n\n→ Step 4: If key not in keyNodeMap: // 新 key\n\n   → Step 5: If dummyHead.next.count == 1: // 1 已存在\n\n        → Step 6: Add key to dummyHead.next.keySet\n\n        → Step 7: keyNodeMap[key] = dummyHead.next\n\n     No → Step 8: Create newNode(count=1, keySet={key})\n\n        → Step 9: Insert newNode after dummyHead\n\n        → Step 10: keyNodeMap[key] = newNode\n\nElse key exists:\n\n   → Step 11: node = keyNodeMap[key]\n\n   → Step 12: nextNode = node.next\n\n   → Step 13: If nextNode.count == node.count + 1: // next node has desired count\n\n        → Step 14: Add key to nextNode.keySet\n\n        → Step 15: keyNodeMap[key] = nextNode\n\n     No → Step 16: Create newNode(count=node.count+1, keySet={key})\n\n        → Step 17: Insert newNode after node\n\n        → Step 18: keyNodeMap[key] = newNode\n\n   → Step 19: Remove key from node.keySet\n\n   → Step 20: If node.keySet is empty: // remove node\n\n        → Step 21: Delete node from list\n\nSimilarly for dec(key):\n\n   → Step 22: node = keyNodeMap[key]\n\n   → Step 23: If node.count == 1: // will be removed\n\n        → Step 24: Remove key from node.keySet\n\n        → Step 25: Remove node if empty\n\n        → Step 26: Delete keyNodeMap[key]\n\n     No → Step 27: prevNode = node.prev\n\n        → Step 28: If prevNode.count == node.count -1:\n\n            → Step 29: Add key to prevNode.keySet\n\n            → Step 30: keyNodeMap[key] = prevNode\n\n          No → Step 31: Create newNode(count=node.count-1, keySet={key})\n\n            → Step 32: Insert newNode before node\n\n            → Step 33: keyNodeMap[key] = newNode\n\n        → Step 34: Remove key from node.keySet\n\n        → Step 35: If node.keySet is empty: delete node\n\ngetMaxKey:\n\n   → Step 36: If dummyTail.prev == dummyHead: return \"\"\n\n   → Step 37: Return any key from dummyTail.prev.keySet\n\ngetMinKey:\n\n   → Step 38: If dummyHead.next == dummyTail: return \"\"\n\n   → Step 39: Return any key from dummyHead.next.keySet\n\nEnd\n\nWe must use decision syntax for conditionals.\n\nLet's produce each line accordingly.\n\nWe should include Decision: lines.\n\nOk let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 dummyHead 與 dummyTail 節點，分別代表最小與最大 count // 初始化雙向連結的頭尾節點  \n→ Step 2: dummyHead.next ← dummyTail；dummyTail.prev ← dummyHead // 將頭尾連接起來  \n→ Step 3: keyNodeMap ← 空字典 // key 到節點的映射表  \n\n→ Function inc(key) // 增加 key 的計數  \n    → Decision: 如果 key 不在 keyNodeMap? // 判斷是否為新 key  \n        Yes → Step 4a: 若 dummyHead.next.count == 1? // 已有 count=1 的節點嗎？  \n                Yes → Step 5a: 加入 key 到 dummyHead.next.keySet // 將 key 放入現有節點  \n                No  → Step 6a: 建立 newNode(count=1, keySet={key}) // 新增節點  \n                → Step 7a: 插入 newNode 在 dummyHead 後面  \n            No → Step 8a: keyNodeMap[key] ← dummyHead.next // 更新映射  \n        No → Step 9a: node ← keyNodeMap[key] // 取得目前 key 所在節點  \n            → Step 10a: nextNode ← node.next  \n            → Decision: 如果 nextNode.count == node.count + 1? // 下個節點是否為目標計數  \n                Yes → Step 11a: 加入 key 到 nextNode.keySet  \n                No  → Step 12a: 建立 newNode(count=node.count + 1, keySet={key})  \n                → Step 13a: 插入 newNode 在 node 後面  \n            → Step 14a: keyNodeMap[key] ← 目標節點（nextNode 或 newNode）  \n            → Step 15a: 從 node.keySet 刪除 key  \n            → Decision: 如果 node.keySet 為空? // 檢查是否需要刪除節點  \n                Yes → Step 16a: 移除 node 從雙向鏈表  \n                No  → 何無事  \n\n→ Function dec(key) // 減少 key 的計數  \n    → Step 17a: node ← keyNodeMap[key] // 取得目前節點  \n    → Decision: 如果 node.count == 1? // 將被刪除  \n        Yes → Step 18a: 從 node.keySet 刪除 key  \n            → Step 19a: 移除 node 若 keySet 為空  \n            → Step 20a: 刪除 keyNodeMap[key]  \n        No → Step 21a: prevNode ← node.prev  \n            → Decision: 如果 prevNode.count == node.count - 1? // 前一節點是否為目標計數  \n                Yes → Step 22a: 加入 key 到 prevNode.keySet  \n                No  → Step 23a: 建立 newNode(count=node.count - 1, keySet={key})  \n                → Step 24a: 插入 newNode 在 node 前面  \n            → Step 25a: keyNodeMap[key] ← 目標節點（prevNode 或 newNode）  \n            → Step 26a: 從 node.keySet 刪除 key  \n            → Decision: 如果 node.keySet 為空?  \n                Yes → Step 27a: 移除 node  \n                No  → 何無事  \n\n→ Function getMaxKey() // 取得最大計數的 key  \n    → Decision: 如果 dummyTail.prev == dummyHead? // 沒有任何 key  \n        Yes → Step 28a: 返回 \"\"  \n        No  → Step 29a: 返回 dummyTail.prev.keySet 中任一 key  \n\n→ Function getMinKey() // 取得最小計數的 key  \n    → Decision: 如果 dummyHead.next == dummyTail? // 沒有任何 key  \n        Yes → Step 30a: 返回 \"\"  \n        No  → Step 31a: 返回 dummyHead.next.keySet 中任一 key  \n\nEnd // 程式執行結束"
    },
    {
      "title": "K Inverse Pairs Array",
      "source_file": "Leetcode/leetcode629.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 3, k = 0",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7wenh8sa.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmp7wenh8sa.py\", line 26, in main\n    data = list(map(int, sys.stdin.read().split()))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphnh2sjz8.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmphnh2sjz8.py\", line 26, in main\n    data = list(map(int, sys.stdin.read().split()))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        }
      ],
      "generated_code": "import sys\n\nMOD = 10 ** 9 + 7\n\ndef k_inverse_pairs(n: int, k: int) -> int:\n    # 若 k 超過可能的最大逆序對數，直接返回 0\n    if k > n * (n - 1) // 2:\n        return 0\n\n    # dp[i][j] 表示長度為 i 的排列中有 j 個逆序對的數量\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        dp[i][0] = 1  # 逆序對為 0 時只有遞增排列\n        for j in range(1, k + 1):\n            # 使用前一行的值來避免重複計算\n            val = (dp[i][j - 1] + dp[i - 1][j]) % MOD\n            if j >= i:\n                val = (val - dp[i - 1][j - i]) % MOD\n            dp[i][j] = val\n\n    return dp[n][k]\n\ndef main() -> None:\n    data = list(map(int, sys.stdin.read().split()))\n    if not data:\n        return\n    n, k = data[0], data[1]\n    print(k_inverse_pairs(n, k))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for counting number of permutations of 1..n with exactly k inversions. Standard DP: dp[n][k] = sum_{i=0}^{min(k, n-1)} dp[n-1][k-i]. Mod M.\n\nWe need to provide steps line by line with explanations. The code is virtual. Use Start, End, Decision. Let's produce high-level algorithm steps: input n,k, define dp table size (n+1)*(k+1) initialize dp[0][0]=1. For i from 1 to n: compute dp[i][0]=1. For j from 1 to k: compute cumulative sum to optimize? We'll implement straightforward sum with nested loops. Or use prefix sums to avoid O(nk^2). But we can present simple approach. Provide decision if j-i>=0 etc.\n\nWe need to produce virtual code with arrows.\n\nLet's produce lines:\n\nStart\n→ Read n, k // 讀取輸入\n→ Initialize 2D array dp[n+1][k+1] with zeros // 產生 dp 表\n→ Set dp[0][0] = 1 // 基本情況\n→ Decision: 是否需要處理 k<0? No // skip\n→ For i from 1 to n: // 外層循環\n    → Decision: i == 0? // skip\n    → dp[i][0] = 1 // 0 inversions\n    → For j from 1 to k: // 內層循環\n        → dp[i][j] = 0 // 初始化\n        → For t from 0 to min(j, i-1): // 累加前一個階段的不同 i-1\n            → dp[i][j] += dp[i-1][j-t] // 加總\n            → dp[i][j] %= MOD // 取模\n→ Result = dp[n][k] % MOD // 最終結果\n→ Output Result\nEnd\n\nBut the requirement: Each line must include virtual code step plus explanation. Use arrow.\n\nWe need to incorporate Decision lines.\n\nLet's produce detailed steps. Use 'Decision:' lines to handle loops? It's okay. Provide step lines accordingly.\n\nWe need to use virtual code arrow \"→\" and Decision: lines with Yes / No.\n\nWe'll create code:\n\nStart // 開始\n→ Read n, k // 讀取 n 與 k\n→ Define constant MOD = 1000000007 // 模數\n→ Initialize dp[0..n][0..k] = 0 // dp 表\n→ dp[0][0] = 1 // 基本情況\n→ For i = 1 to n:\n    → dp[i][0] = 1 // 只有 0 個逆序對\n    → For j = 1 to k:\n        → dp[i][j] = 0 // 初始化\n        → For t = 0 to min(j, i-1):\n            → dp[i][j] = (dp[i][j] + dp[i-1][j-t]) % MOD // 累加\n→ Output dp[n][k] // 結果\n\nBut we need to include decision lines: maybe Decision: If j > i-1? etc. But the above uses min; we can implement decision inside loop.\n\nBetter to include Decision: If j-t >= 0? No.\n\nBut maybe we can use prefix sums to make O(nk). But not necessary.\n\nWe need each line with explanation. Provide 20-30 lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Read n, k // 讀取整數 n 與 k  \n→ Define constant MOD = 1000000007 // 取模數值  \n→ Initialize 2D array dp[0..n][0..k] with 0 // 建立 DP 表  \n→ dp[0][0] = 1 // 空排列只有一種且逆序對數為 0  \n→ Decision: 是否需要考慮 k < 0? No // k 為非負，直接進行計算  \n→ For i = 1 to n: // 依照排列長度遞增  \n    → dp[i][0] = 1 // 任何排列長度 i，若逆序對為 0 時只有遞增序列  \n    → For j = 1 to k: // 逐個計算逆序對數  \n        → dp[i][j] = 0 // 初始化本層結果  \n        → For t = 0 to min(j, i-1): // 新加入元素位置的可能移動  \n            → dp[i][j] = (dp[i][j] + dp[i-1][j-t]) % MOD // 累加前一層結果並取模  \n→ Result = dp[n][k] % MOD // 最終答案  \n→ Output Result // 顯示結果  \nEnd // 程式執行結束"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpj4ulja2z.py\", line 47, in <module>\n    result = Solution().kthSmallest(matrix, k)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpj4ulja2z.py\", line 9, in kthSmallest\n    mid = (low + high) // 2\n          ~~~~~~~~~~~~~^^~~\nTypeError: unsupported operand type(s) for //: 'list' and 'int'"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-5'\nGot (Norm):      '[-5]'\n--- (Raw) ---\nRaw Expected: '-5'\nRaw Got:      '[-5]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def kthSmallest(self, matrix, k):\n        n = len(matrix)\n        low, high = matrix[0][0], matrix[-1][-1]\n        while low < high:\n            mid = (low + high) // 2\n            count = 0\n            for i in range(n):\n                j = n - 1\n                while j >= 0 and matrix[i][j] > mid:\n                    j -= 1\n                count += j + 1\n            if count >= k:\n                high = mid\n            else:\n                low = mid + 1\n        return low\n\ndef parse_input(data: str):\n    \"\"\"Parse input that may be in the form\n       'matrix = [[...]], k = ...' or\n       two separate lines: first the matrix, second the integer k.\"\"\"\n    data = data.strip()\n    if 'k =' in data:\n        parts = data.split('k =')\n        matrix_part = parts[0].strip()\n        if matrix_part.startswith('matrix ='):\n            matrix_part = matrix_part[len('matrix ='):].strip()\n        k_part = parts[1].strip()\n        matrix = ast.literal_eval(matrix_part)\n        k = int(k_part)\n    else:\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            matrix = ast.literal_eval(lines[0].strip())\n            k = int(lines[1].strip())\n        else:\n            raise ValueError(\"Invalid input format\")\n    return matrix, k\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    matrix, k = parse_input(input_data)\n    result = Solution().kthSmallest(matrix, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line, with explanation comments. Problem: given sorted matrix n x n, each row and column ascending, find kth smallest element. We need memory complexity better than O(n^2). Typical solution: binary search on value range + count elements <= mid. O(n log(max-min)). Or min-heap approach O(k log n). We'll produce pseudocode for binary search approach.\n\nWe must output lines with arrow etc. Use Start, End, Decision. We will produce pseudocode lines: Start, read matrix and k, determine min and max, binary search loop with Decision: while low < high. Counting step. At end output low.\n\nEnsure each line includes virtual code step + // explanation. Use arrow \"→\" for steps. Use Decision lines with Yes/No branches. Use proper indentation. For counting, we can have loop over rows.\n\nLet's produce.\n\nAlso we need memory better than O(n^2). The algorithm uses O(1) memory.\n\nWe'll produce steps:\n\nStart\n→ Step 1: Input matrix M, size n, integer k // read inputs\n→ Step 2: low ← M[0][0] // smallest element\n→ Step 3: high ← M[n-1][n-1] // largest element\n→ Decision: while low < high? // loop until range narrowed\n    Yes →\n        → mid ← (low + high) // 2 // mid value\n        → Step 4: count ← 0 // counter for <= mid\n        → For i from 0 to n-1:\n            → j ← n-1\n            → Decision: while j >= 0 and M[i][j] > mid? // if element greater, move left\n                Yes → j ← j - 1\n                No  → Step 5: count ← count + (j + 1) // all elements <= mid in this row\n                      → Break // exit inner while\n        → Decision: if count >= k? // enough elements <= mid\n            Yes → high ← mid // k-th is <= mid, reduce high\n            No  → low ← mid + 1 // k-th is larger, increase low\n    No  → End of loop\n→ End // Output low as k-th smallest\n\nNeed to use arrow for inner loops etc. Use proper indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Input matrix M, size n, integer k // 取得 n×n 排序矩陣與 k\n→ Step 2: low ← M[0][0] // 設定最小值為矩陣左上角\n→ Step 3: high ← M[n-1][n-1] // 設定最大值為矩陣右下角\n→ Decision: while low < high? // 當搜尋範圍還沒縮小到單一值時\n    Yes →\n        → mid ← (low + high) // 取區間中點\n        → Step 4: count ← 0 // 初始化小於等於 mid 的元素數量\n        → For i from 0 to n-1: // 遍歷每一行\n            → j ← n-1 // 從行尾開始\n            → Decision: while j >= 0 and M[i][j] > mid? // 若右側元素大於 mid，往左移動\n                Yes → j ← j - 1\n                No  → // 此行所有列 0..j 的元素都 <= mid\n                    → count ← count + (j + 1) // 加上該行符合條件的數量\n                    → Break // 進入下一行\n        → Decision: if count >= k? // 判斷是否至少有 k 個元素 <= mid\n            Yes → high ← mid // k-th 小於等於 mid，縮小高值\n            No  → low ← mid + 1 // k-th 大於 mid，增大低值\n    No → // 低值已等於高值，搜尋結束\n→ End // 輸出 low 為第 k 個最小元素\n\n(Note：此虛擬碼使用 O(1) 除了輸入矩陣本身之外的額外空間，並透過二分搜尋與行列計數取得答案。)"
    },
    {
      "title": "Combination Sum IV",
      "source_file": "Leetcode/leetcode377.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmdza6_du.py\", line 34, in <module>\n    main()\n  File \"/tmp/tmpmdza6_du.py\", line 25, in main\n    info = ast.literal_eval(\"{\" + data + \"}\")\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {nums = [1,2,3], target = 4}\n     ^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums = [9], target = 3",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpd5ova_10.py\", line 34, in <module>\n    main()\n  File \"/tmp/tmpd5ova_10.py\", line 25, in main\n    info = ast.literal_eval(\"{\" + data + \"}\")\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {nums = [9], target = 3}\n     ^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def combinationSum4(self, nums, target):\n        # 動態規劃：dp[i] 表示總和為 i 的組合數量\n        dp = [0] * (target + 1)\n        dp[0] = 1  # 基本情況：只有一種方式得到總和 0，即不選任何數字\n\n        for i in range(1, target + 1):\n            for num in nums:\n                if i - num >= 0:\n                    dp[i] += dp[i - num]\n\n        return dp[target]\n\ndef main():\n    # 從標準輸入讀取整行資料\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析「nums = [...], target = ...」格式\n    # 先將其包裝成字典字串，再使用 ast.literal_eval 進行安全解析\n    info = ast.literal_eval(\"{\" + data + \"}\")\n    nums = info['nums']\n    target = info['target']\n\n    solution = Solution()\n    result = solution.combinationSum4(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: Given distinct integers array nums, target integer target, return number of possible combinations that add up to target. This is classic \"Combination Sum IV\" from LeetCode: count number of combinations (order matters) where sum equals target. Use DP or recursion with memo.\n\nWe need to produce line by line virtual code with explanation, using arrows and structure. Use Start, Decision, etc.\n\nWe'll produce steps:\n\n- Start\n- Input nums, target\n- Initialize dp array of size target+1\n- dp[0] = 1\n- For i from 1 to target:\n  - For each num in nums:\n    - If num <= i: dp[i] += dp[i-num]\n- Return dp[target]\n- End\n\nAlso include comments.\n\nMake sure each line includes `虛擬碼步驟` + space + `// 解釋/說明`. Use arrow `→`. Format accordingly.\n\nNeed to adhere to no actual code.\n\nLet's craft lines:\n\nStart // 程式開始執行\n\n→ Step 1: 取得 nums 與 target // 從使用者或測試案例取得輸入\n\n→ Step 2: 建立 dp 陣列，長度為 target+1，並將所有值設為 0 // 用於存儲子問題答案\n\n→ Step 3: dp[0] ← 1 // 基本情況：只有一種方式達到 0，即不選任何數\n\n→ Decision: 是否已經完成所有 i 從 1 到 target? // 檢查循環是否結束\n\n    No → Step 4: 設定 i ← 1 // 開始第一個子目標\n\n        → Step 5: Decision: i ≤ target? // 確認 i 在有效範圍\n\n            Yes → Step 6: Decision: nums 之中是否存在數可用? // 內部迴圈\n\n                → Loop over each num in nums\n\n                    → Decision: num ≤ i? // 檢查能否用此數\n\n                        Yes → Step 7: dp[i] ← dp[i] + dp[i-num] // 累加組合數\n\n                        No  → // 跳過\n\n                → Step 8: i ← i + 1 // 進行下一個子目標\n\n            No → End // 超過 target，結束循環\n\n→ Step 9: Return dp[target] // 返回最終答案\n\nEnd // 程式執行結束\n\nBut we need each line separate. Use arrow for nested steps maybe? The format example shows indentation. We'll replicate similar.\n\nLet's produce:\n\n```\nStart // 程式開始執行\n→ Step 1: 取得 nums 與 target // 讀取輸入資料\n→ Step 2: 建立 dp 陣列長度 target+1 並初始化為 0 // 用於存儲子問題答案\n→ Step 3: dp[0] ← 1 // 基本情況，只有一種方式得到總和 0\n→ Decision: i ≤ target? // 判斷是否還有尚未計算的子目標\n    Yes → Step 4: i ← 1 // 設定初始子目標\n        → Decision: i ≤ target? // 迴圈控制\n            Yes → Step 5: Loop over each num in nums // 嘗試每個可用數字\n                → Decision: num ≤ i? // 檢查此數字是否可用於組合\n                    Yes → Step 6: dp[i] ← dp[i] + dp[i-num] // 加總組合數\n                    No  → // 不可用，直接跳過\n            No  → // i 超過 target，結束迴圈\n→ Step 7: Return dp[target] // 輸出最終答案\nEnd // 程式執行結束\n```\n\nBut we must not output actual code. The arrows represent control flow. The indentation can show nested decision. The line numbering not necessary. The example had \"Step 1:\" etc.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 nums 與 target // 讀取輸入資料  \n→ Step 2: 建立 dp 陣列長度 target+1 並初始化為 0 // 用於存儲子問題答案  \n→ Step 3: dp[0] ← 1 // 基本情況，只有一種方式得到總和 0  \n→ Decision: i ≤ target? // 判斷是否還有尚未計算的子目標  \n Yes → Step 4: i ← 1 // 設定初始子目標  \n  → Decision: i ≤ target? // 迴圈控制  \n   Yes → Step 5: Loop over each num in nums // 嘗試每個可用數字  \n    → Decision: num ≤ i? // 檢查此數字是否可用於組合  \n     Yes → Step 6: dp[i] ← dp[i] + dp[i-num] // 加總組合數  \n     No → // 不可用，直接跳過  \n   No → // i 超過 target，結束迴圈  \n→ Step 7: Return dp[target] // 輸出最終答案  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        i = 0\n        n = len(self.ranges)\n        # add all non-overlapping intervals before the new range\n        while i < n and self.ranges[i][1] < left:\n            new_ranges.append(self.ranges[i])\n            i += 1\n        # merge all overlapping intervals\n        new_left, new_right = left, right\n        while i < n and self.ranges[i][0] <= right:\n            new_left = min(new_left, self.ranges[i][0])\n            new_right = max(new_right, self.ranges[i][1])\n            i += 1\n        new_ranges.append([new_left, new_right])\n        # add the remaining intervals\n        while i < n:\n            new_ranges.append(self.ranges[i])\n            i += 1\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        for l, r in self.ranges:\n            if l <= left < r:\n                return r >= right\n            if l > left:\n                break\n        return False\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef parse_command(line: str):\n    line = line.strip()\n    if not line:\n        return None\n    if 'new RangeModule' in line:\n        return ('init',)\n    if '.' not in line:\n        return None\n    obj, rest = line.split('.', 1)\n    rest = rest.strip()\n    if '(' not in rest:\n        return None\n    method_name, args_part = rest.split('(', 1)\n    args_part = args_part.rstrip(');')\n    args = []\n    if args_part:\n        for part in args_part.split(','):\n            part = part.strip()\n            if part:\n                args.append(int(part))\n    return (method_name, args)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    instance = None\n    outputs = []\n    for line in data:\n        cmd = parse_command(line)\n        if not cmd:\n            continue\n        if cmd[0] == 'init':\n            instance = RangeModule()\n            outputs.append('null')\n        elif cmd[0] == 'addRange':\n            instance.addRange(*cmd[1])\n            outputs.append('null')\n        elif cmd[0] == 'removeRange':\n            instance.removeRange(*cmd[1])\n            outputs.append('null')\n        elif cmd[0] == 'queryRange':\n            res = instance.queryRange(*cmd[1])\n            outputs.append('true' if res else 'false')\n    print('[' + ', '.join(outputs) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code (step-by-step) for implementing a RangeModule data structure, likely using interval management. Provide steps: start, init, addRange, queryRange, removeRange, end. Each step line includes code step and explanation. Use arrow \"→\". Use Decision. Provide lines for each operation. Should not output actual code, only pseudocode steps. We'll write a generic design: use list of intervals sorted and non-overlapping. For addRange: merge. For query: check coverage. For remove: split. Provide step-by-step logic.\n\nWe'll output virtual code lines like:\n\nStart\n→ Step 1: 初始化空區間集合 intervals = [] // 存儲已追蹤區間\n→ Step 2: addRange(left, right) // 插入區間\n\nInside addRange:\n→ Decision: 找到插入位置\n\nBut we need step by step. We'll produce a high-level algorithm, not function skeleton. Each line is step. We'll include decisions.\n\nLet's produce:\n\nStart\n→ Step 1: 建立空列表 intervals // 儲存已追蹤區間\n→ Step 2: addRange(left, right) // 添加新區間\n    → Decision: 找到左邊界插入點\n    → Decision: 找到右邊界插入點\n    → 合併重疊區間並插入\n→ Step 3: queryRange(left, right) // 查詢區間是否完全被追蹤\n    → Decision: 逐區間檢查是否有缺口\n    → Return true/false\n→ Step 4: removeRange(left, right) // 刪除區間\n    → Decision: 找到與刪除區間重疊的區間\n    → 分割或移除\nEnd\n\nBut we need more detailed steps. Provide each step line with arrow. Let's produce detailed pseudocode:\n\nStart // 程式開始執行\n→ Step 1: 初始化 intervals = [] // 空列表，存儲已追蹤區間，保持排序且不重疊\n→ Step 2: addRange(left, right) // 開始處理加入區間\n    → Decision: 找到第一個區間 idx 使 intervals[idx].right >= left // 找左邊界位置\n    → Decision: 找到最後一個區間 idx_end 使 intervals[idx_end].left <= right // 找右邊界位置\n    → Decision: 如果 idx > idx_end 則無重疊區間\n        → Step 3a: 插入新區間 [left, right] 並保持排序\n    → Decision: 否則有重疊區間\n        → Step 3b: new_left = min(left, intervals[idx].left)\n        → Step 3c: new_right = max(right, intervals[idx_end].right)\n        → Step 3d: 刪除 intervals[idx:idx_end+1]\n        → Step 3e: 插入 intervals[new_left, new_right]\n→ Step 4: queryRange(left, right) // 查詢區間是否完整覆蓋\n    → Decision: 遍歷 intervals\n        → Step 5a: 如果 intervals[i].left > left 且 intervals[i-1].right < left 則不覆蓋\n        → Step 5b: 若 intervals[i].right < right 且 intervals[i+1].left > right 則不覆蓋\n    → Return true/false\n→ Step 6: removeRange(left, right) // 移除區間\n    → Decision: 找到第一個重疊區間 start_idx\n    → Decision: 找到最後一個重疊區間 end_idx\n    → Step 7a: 若 start_idx > end_idx 則無重疊，返回\n    → Step 7b: 若 intervals[start_idx].left < left 且 intervals[start_idx].right > right\n        → Step 7c: 將 intervals[start_idx] 分割為兩個區間 [intervals[start_idx].left, left) 與 (right, intervals[start_idx].right]\n    → Step 7d: 若 intervals[start_idx].left < left < intervals[start_idx].right\n        → Step 7e: 將 intervals[start_idx].right = left\n    → Step 7f: 若 intervals[end_idx].left < right < intervals[end_idx].right\n        → Step 7g: 將 intervals[end_idx].left = right\n    → Step 7h: 刪除 intervals[start_idx+1:end_idx] // 移除中間重疊區間\nEnd // 程式結束\n\nBut we need to present as \"每行虛擬碼\" like \"→ Step 1: ... // 說明\". We need to indent Decision block lines as separate lines.\n\nWe'll produce final output accordingly. Ensure each line ends with comment. Use arrows.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: intervals ← [] // 初始化空列表，存放已追蹤區間，保持排序且不重疊  \n\n// ---------- addRange(left, right) ----------\n→ Step 2: addRange(left, right) // 開始處理加入區間  \n    → Decision: leftIdx ← 找到第一個 intervals[i] 使 intervals[i].right ≥ left // 找左邊界位置  \n    → Decision: rightIdx ← 找到最後一個 intervals[i] 使 intervals[i].left ≤ right // 找右邊界位置  \n    → Decision: leftIdx > rightIdx? // 是否沒有重疊區間  \n        Yes → Step 3a: 插入 intervals ← intervals[:leftIdx] + [[left, right]] + intervals[leftIdx:] // 插入新區間  \n        No  → Step 3b: newLeft ← min(left, intervals[leftIdx].left) // 取最左側界  \n        → Step 3c: newRight ← max(right, intervals[rightIdx].right) // 取最右側界  \n        → Step 3d: 刪除 intervals[leftIdx:rightIdx+1] // 移除重疊區間  \n        → Step 3e: 插入 intervals ← intervals[:leftIdx] + [[newLeft, newRight]] + intervals[leftIdx:] // 插入合併後區間  \n\n// ---------- queryRange(left, right) ----------\n→ Step 4: queryRange(left, right) // 查詢區間是否完整覆蓋  \n    → Decision: current ← left // 從左端開始檢查  \n    → Decision: 逐一遍歷 intervals  \n        → Decision: intervals[i].left ≤ current < intervals[i].right? // 是否在當前區間內  \n            Yes → current ← max(current, intervals[i].right) // 更新已覆蓋範圍  \n            No  → Step 5a: Return False // 發現缺口，直接返回  \n    → Decision: current ≥ right? // 是否已覆蓋到右端  \n        Yes → Step 5b: Return True // 完全覆蓋  \n        No  → Step 5c: Return False // 尚未覆蓋完  \n\n// ---------- removeRange(left, right) ----------\n→ Step 6: removeRange(left, right) // 移除區間  \n    → Decision: leftIdx ← 找到第一個 intervals[i] 使 intervals[i].right > left // 找左邊界重疊起點  \n    → Decision: rightIdx ← 找到最後一個 intervals[i] 使 intervals[i].left < right // 找右邊界重疊終點  \n    → Decision: leftIdx > rightIdx? // 是否沒有重疊區間  \n        Yes → Step 6a: Return // 無需處理  \n        No  → Step 6b:  \n            → Decision: intervals[leftIdx].left < left < intervals[leftIdx].right? // 左側區間需截斷  \n                Yes → Step 6c: intervals[leftIdx].right ← left // 截斷左側至 left  \n            → Decision: intervals[rightIdx].left < right < intervals[rightIdx].right? // 右側區間需截斷  \n                Yes → Step 6d: intervals[rightIdx].left ← right // 截斷右側至 right  \n            → Decision: rightIdx - leftIdx > 1? // 是否有中間完整重疊區間  \n                Yes → Step 6e: 刪除 intervals[leftIdx+1:rightIdx] // 刪除中間所有區間  \n            → Decision: intervals[leftIdx].left == intervals[leftIdx].right? // 檢查左側是否成為空區間  \n                Yes → Step 6f: 刪除 intervals[leftIdx] // 刪除空區間  \n            → Decision: intervals[rightIdx].left == intervals[rightIdx].right? // 檢查右側是否成為空區間  \n                Yes → Step 6g: 刪除 intervals[rightIdx] // 刪除空區間  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,true,true,false,2,true,true,true,4]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, true, true, true, false, 2, true, true, true, 4]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MyCircularDeque:\n    \"\"\" 循環雙端佇列實作 \"\"\"\n    def __init__(self, k: int):\n        self.capacity = k\n        self.buf = [0] * k          # 固定長度陣列\n        self.front = 0              # 前端指標\n        self.size = 0               # 現有元素個數\n\n    def insertFront(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.front = (self.front - 1 + self.capacity) % self.capacity\n        self.buf[self.front] = value\n        self.size += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        idx = (self.front + self.size) % self.capacity\n        self.buf[idx] = value\n        self.size += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.front = (self.front + 1) % self.capacity\n        self.size -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.size -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.buf[self.front]\n\n    def getRear(self) -> int:\n        if self.isEmpty():\n            return -1\n        idx = (self.front + self.size - 1) % self.capacity\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.size == 0\n\n    def isFull(self) -> bool:\n        return self.size == self.capacity\n\n\ndef format_value(val):\n    if val is None:\n        return 'null'\n    if isinstance(val, bool):\n        return 'true' if val else 'false'\n    return str(val)\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    ops = ast.literal_eval(data[0])\n    params = ast.literal_eval(data[1])\n\n    result = []\n    obj = None\n    for op, p in zip(ops, params):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(p[0])\n            result.append(None)  # constructor returns null\n        else:\n            method = getattr(obj, op)\n            if p:\n                ret = method(*p)\n            else:\n                ret = method()\n            result.append(ret)\n\n    # 將結果轉成 LeetCode 風格輸出\n    output = '[' + ', '.join(format_value(v) for v in result) + ']'\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for implementing circular deque. Should produce step-by-step pseudo code lines, with explanation comment. Use Start, End, Decision:, arrow etc. We need to cover initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Probably also internal fields: array, front, rear, size, capacity. Show logic. Use virtual code with steps. Let's produce.\n\nWe need to use \"→\" arrow for steps. Use indentation. Provide explanation after //.\n\nLet's produce.\n\nWe'll start with Start. Then Step: define class. Then Step: Initialize variables. Then each method. Use Decision. For methods, we can show steps. Provide logic.\n\nMake sure each line ends with // comment.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 MyCircularDeque // 宣告資料結構\n→ Step 2: 建立私有變數 capacity, size, front, rear, data[capacity] // 佈局固定長度陣列與指標\n→ Step 3: MyCircularDeque(int k) // 建構子\n    → Step 3.1: capacity ← k // 設定最大容量\n    → Step 3.2: size ← 0 // 初始元素數量為 0\n    → Step 3.3: front ← 0 // 前端指標指向陣列起點\n    → Step 3.4: rear ← k - 1 // 後端指標指向陣列末尾（此處方便使用模運算）\n    → Step 3.5: data ← 新陣列[capacity] // 建立實體陣列\n→ Step 4: boolean insertFront(int value) // 將元素插入前端\n    → Decision: 如果 isFull()? // 檢查是否已滿\n        Yes → Step 4.1: return false // 無法插入，回傳失敗\n        No  → Step 4.2: front ← (front - 1 + capacity) % capacity // 往前移動前端指標\n              Step 4.3: data[front] ← value // 放入元素\n              Step 4.4: size ← size + 1 // 更新元素數量\n              Step 4.5: return true // 成功\n→ Step 5: boolean insertLast(int value) // 將元素插入後端\n    → Decision: 如果 isFull()? // 檢查是否已滿\n        Yes → Step 5.1: return false // 無法插入，回傳失敗\n        No  → Step 5.2: rear ← (rear + 1) % capacity // 往後移動後端指標\n              Step 5.3: data[rear] ← value // 放入元素\n              Step 5.4: size ← size + 1 // 更新元素數量\n              Step 5.5: return true // 成功\n→ Step 6: boolean deleteFront() // 刪除前端元素\n    → Decision: 如果 isEmpty()? // 檢查是否為空\n        Yes → Step 6.1: return false // 無法刪除，回傳失敗\n        No  → Step 6.2: front ← (front + 1) % capacity // 往後移動前端指標，實際移除\n              Step 6.3: size ← size - 1 // 更新元素數量\n              Step 6.4: return true // 成功\n→ Step 7: boolean deleteLast() // 刪除後端元素\n    → Decision: 如果 isEmpty()? // 檢查是否為空\n        Yes → Step 7.1: return false // 無法刪除，回傳失敗\n        No  → Step 7.2: rear ← (rear - 1 + capacity) % capacity // 往前移動後端指標\n              Step 7.3: size ← size - 1 // 更新元素數量\n              Step 7.4: return true // 成功\n→ Step 8: int getFront() // 取得前端值\n    → Decision: 如果 isEmpty()? // 檢查是否為空\n        Yes → Step 8.1: return -1 // 空時回傳 -1\n        No  → Step 8.2: return data[front] // 回傳前端元素\n→ Step 9: int getRear() // 取得後端值\n    → Decision: 如果 isEmpty()? // 檢查是否為空\n        Yes → Step 9.1: return -1 // 空時回傳 -1\n        No  → Step 9.2: return data[rear] // 回傳後端元素\n→ Step 10: boolean isEmpty() // 判斷是否為空\n    → Step 10.1: return size == 0 // 若元素數量為 0 則為空\n→ Step 11: boolean isFull() // 判斷是否已滿\n    → Step 11.1: return size == capacity // 若元素數量等於容量則已滿\nEnd // 程式執行結束"
    },
    {
      "title": "Beautiful Arrangement II",
      "source_file": "Leetcode/leetcode667.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 3, k = 1",
          "expected_output": "[1,2,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,2,3]'\nGot (Norm):      '[1,3,2]'\n--- (Raw) ---\nRaw Expected: '[1,2,3]'\nRaw Got:      '[1, 3, 2]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef construct_array(n: int, k: int):\n    \"\"\"\n    建立一個長度為 n 的排列，使相鄰元素的絕對差值有恰好 k 個不同的值。\n    方法：先用左指標和右指標交替取值產生 k+1 個元素，形成 k 個不同的差值。\n          再把剩餘的數字按遞增順序填入，保持差值為 1，故不會增加新的差值。\n    \"\"\"\n    ans = []\n    left, right = 1, n\n    i = 0\n    # 產生前 k+1 個元素\n    while i <= k:\n        if i % 2 == 0:\n            ans.append(left)\n            left += 1\n        else:\n            ans.append(right)\n            right -= 1\n        i += 1\n    # 將剩餘數字遞增填入\n    for num in range(left, right + 1):\n        ans.append(num)\n    return ans\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    result = construct_array(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps explaining algorithm: given n,k produce permutation of 1..n such that absolute differences between consecutive elements has exactly k distinct values. Classic problem: we can create sequence that yields differences 1,2,...,k distinct, others repeated. Approach: use pattern: start from 1, then n, then 2, then n-1,... produce k differences first, then remaining positions fill with remaining numbers to keep differences repeated. Known solution: For k distinct differences, use pattern of size k+1: 1, n, 2, n-1, 3, n-2,... until we used k+1 elements. This gives differences alternating large and small generating k distinct differences:  n-1, n-2, n-3,...? Actually differences are n-1, n-2, n-3,... etc produce distinct. Then remaining numbers from k+2 to n in ascending order. That yields total differences: the first k differences distinct; remaining differences are 1 repeated. So total distinct = k. Implementation: use two pointers left=1, right=n. For i from 0 to k: if i%2==0: take left++ else take right--. Append to ans. Then for remaining numbers from left to right (since left <= right), append in ascending order. That ensures distinct count k.\n\nWe need virtual code with each line explanation.\n\nLet's produce steps: Start, Input n,k, Initialize ans list, left=1, right=n, i=0. Decision: While i <= k? But we need k+1 elements. So while i <= k: etc.\n\nAfter building prefix, fill rest: for num from left to right: ans.append(num). Then output ans.\n\nReturn ans.\n\nWe should also consider when k==n-1 then prefix will consume all numbers, no remaining. Implementation: after prefix loop, if left <= right, add rest.\n\nLet's produce virtual code lines.\n\nMake sure each line with arrow as shown: \"→ Step X: ... // ...\"\n\nInclude decisions.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n, k // 取得題目給定的兩個整數  \n→ Step 2: 初始化 ans = [] // 用於儲存最終排列  \n→ Step 3: 設定 left = 1, right = n // 左右指標，分別指向最小與最大可用數  \n→ Step 4: 設定 i = 0 // 迭代計數，決定前 k+1 個位置的值  \n→ Decision: i ≤ k? // 是否還需填充前 k+1 個元素  \n    Yes → Step 5: Decision: i 是偶數? // 根據奇偶決定取左邊還是右邊  \n        Yes → Step 6: ans.append(left) // 取左指標值  \n        → Step 7: left = left + 1 // 左指標往右移動  \n        No  → Step 8: ans.append(right) // 取右指標值  \n        → Step 9: right = right - 1 // 右指標往左移動  \n    → Step 10: i = i + 1 // 完成一次迭代  \n    No  → // 已完成前 k+1 個元素的填充  \n→ Step 11: Decision: left ≤ right? // 是否還剩未使用的數字  \n    Yes → Step 12: for num in range(left, right + 1): // 依序將剩餘數字加入  \n        → Step 13: ans.append(num) // 將 num 加入答案  \n    No  → // 沒有剩餘數字，直接跳過  \n→ Step 14: 返回 ans // 結束並回傳最終排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef find_duplicate(paths):\n    \"\"\"返回所有重複檔案的路徑組，組內至少兩個檔案。\"\"\"\n    content_map = defaultdict(list)\n\n    for entry in paths:\n        # 以空白分隔，第一項是目錄路徑，後面是檔案資訊\n        parts = entry.split()\n        root = parts[0]\n        for file_info in parts[1:]:\n            # 檔案名稱與內容由 '(' 分隔，內容後有 ')'\n            name, content = file_info.split('(')\n            content = content.rstrip(')')  # 去掉結尾的 ')'\n            full_path = f\"{root}/{name}\"\n            content_map[content].append(full_path)\n\n    # 只留下重複的組\n    return [paths for paths in content_map.values() if len(paths) > 1]\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入，並移除可能的前置文字 'paths ='\n    raw_input = sys.stdin.read().strip()\n    if raw_input.startswith(\"paths =\"):\n        raw_input = raw_input[len(\"paths =\"):].strip()\n\n    # 解析為 Python 清單\n    try:\n        paths_list = ast.literal_eval(raw_input)\n    except Exception as e:\n        # 若解析失敗，直接退出\n        sys.exit(f\"輸入格式錯誤: {e}\")\n\n    # 計算重複檔案\n    duplicates = find_duplicate(paths_list)\n\n    # 輸出結果\n    print(duplicates)",
      "virtual_code": "Thinking...\nWe need to output pseudo-code steps line by line. The user wants algorithm for duplicate file detection from input list of directory strings. Steps: parse each string, split by space, first token directory, rest are files with content in parentheses. Build mapping content->list of paths. After processing all, filter groups with len>1. Output list of groups.\n\nWe need to produce virtual code with arrows and decisions.\n\nWe need to ensure \"逐行\" with each line as virtual code step + comment.\n\nLet's produce. Use Start, End.\n\nWe need to show steps: Initialize dictionary, iterate over list, parse each entry, split by space, for each file parse name and content, construct full path, add to dict. After loop, iterate dict, collect groups with >1, return list.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 空字典 contentMap ← {} // 建立內容到路徑清單的映射  \n→ Step 2: 對於每個 dirInfo 在 paths 迴圈 // 逐一處理輸入的目錄資訊  \n  → Step 3: 以空格分割 dirInfo 為 tokens // tokens[0] 為目錄路徑  \n  → Step 4: 設定 dirPath ← tokens[0] // 取得目錄完整路徑  \n  → Step 5: 對於每個 fileToken 在 tokens[1:] 迴圈 // 逐個檔案字串  \n    → Decision: 是否包含 '('? // 檢查檔名與內容是否正確分隔  \n      Yes → Step 6: 取得 fileName ← substring before '('  \n                     // 取得檔名"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[6]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[6]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[9,5]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[9, 5]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[5,8,4]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[5, 8, 4]'"
        }
      ],
      "generated_code": "import os\nimport sys\nimport re\n\ndef rand7():\n    \"\"\"\n    產生 1~7 的均勻隨機整數。利用 os.urandom 取得隨機位元\n    \"\"\"\n    return int.from_bytes(os.urandom(1), 'big') % 7 + 1\n\nclass Solution:\n    def rand10(self):\n        \"\"\"\n        產生 1~10 的均勻隨機整數。使用兩次 rand7 生成 1~49 的值，\n        再做 rejection sampling 只保留前 40 個可映射到 1~10。\n        \"\"\"\n        while True:\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\nif __name__ == \"__main__\":\n    # 讀取輸入，例如 \"n = 3\"\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining algorithm: generate uniform 1-10 using rand7. Classic method: generate 2 digits base-7: e.g., (rand7()-1)*7 + (rand7()-1)+1 => gives 1-49. Rejection sample: if <=40 use (x-1)%10 +1. Else reject and repeat.\n\nAlternative: use two calls: produce number 1-49.\n\nSo pseudocode: Start → Step: generate a=rand7() → Step: generate b=rand7() → Compute num = (a-1)*7 + (b-1)+1 // 1-49 → Decision: if num <= 40? Yes → Step: return (num-1)%10 + 1 else → loop.\n\nWe need loop; maybe while true. Use Decision: if num <= 40? Yes → Step: return … No → Step: continue loop. Or we can embed in while. Use Start -> Decision: loop condition. Use indentation. Provide each line with comment.\n\nWe must output line by line.\n\nOk. Use pseudocode with arrow for steps, decision etc. Also include loop label. Let's produce:\n\nStart // 程式開始\n\n→ Decision: 是否已獲得合法結果? // 用於重複生成直到符合條件\n\n   No → Step: a ← rand7() // 第一個亂數\n\n   No → Step: b ← rand7() // 第二個亂數\n\n   No → Step: num ← (a-1)*7 + (b-1) + 1 // 將兩個 1~7 轉為 1~49\n\n   No → Decision: num ≤ 40? // 只保留前 40 個可映射到 1~10\n\n       Yes → Step: return (num-1) mod 10 + 1 // 產生 1~10\n\n       No  → Step: // 失敗，重複循環\n\nEnd // 程式結束\n\nBut need loop structure: we can use While true. Let's rewrite:\n\nStart\n\n→ Step: while True // 無限迴圈\n\n   → Step: a ← rand7()\n\n   → Step: b ← rand7()\n\n   → Step: num ← (a-1)*7 + (b-1) + 1\n\n   → Decision: num ≤ 40?\n\n      Yes → Step: return (num-1) mod 10 + 1\n\n      No  → Step: continue // 重新進入 while\n\nEnd\n\nBut we need to show virtual code arrow and comments. Let's produce lines:\n\nStart // 程式開始\n\n→ Step: while True // 進入無限迴圈，直到成功產生 1~10\n\n   → Step: a ← rand7() // 產生第一個 1~7\n\n   → Step: b ← rand7() // 產生第二個 1~7\n\n   → Step: num ← (a-1)*7 + (b-1) + 1 // 組合成 1~49\n\n   → Decision: num ≤ 40? // 只使用前 40 個\n\n       Yes → Step: return (num-1) mod 10 + 1 // 產生 1~10\n\n       No  → Step: // 失敗，繼續迴圈\n\nEnd // 程式結束\n\nNeed to maintain indentation: each subsequent line inside loop maybe indicated by arrow again.\n\nWe can use '→' for each step, with indentation.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始\n\n→ Step: while True // 進入無限迴圈，直到成功產生 1~10\n\n    → Step: a ← rand7() // 產生第一個 1~7\n\n    → Step: b ← rand7() // 產生第二個 1~7\n\n    → Step: num ← (a-1)*7 + (b-1) + 1 // 組合成 1~49\n\n    → Decision: num ≤ 40? // 只使用前 40 個可映射到 1~10\n\n        Yes → Step: return (num-1) mod 10 + 1 // 產生 1~10\n\n        No  → Step: // 失敗，回到迴圈開始\n\nEnd // 程式結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n        return (\n            dists[0] > 0 and\n            dists[0] == dists[1] == dists[2] == dists[3] and\n            dists[4] == dists[5] and\n            dists[4] == 2 * dists[0]\n        )\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 8:\n        # Insufficient data, default to false\n        print(\"false\")\n        return\n    p1 = [nums[0], nums[1]]\n    p2 = [nums[2], nums[3]]\n    p3 = [nums[4], nums[5]]\n    p4 = [nums[6], nums[7]]\n    sol = Solution()\n    result = sol.validSquare(p1, p2, p3, p4)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for the algorithm: given 4 points, determine if they form a square. Classic approach: compute all pairwise distances (squared). There should be exactly 2 distinct distances: side and diagonal. The side appears 4 times, diagonal 2 times. Also side > 0. Also check that diagonal == 2 * side (by geometry) but not necessary if counts correct. But we can include.\n\nWe'll produce virtual code step-by-step with Start, Steps, Decision, etc.\n\nMake sure each line is in the specified format: \"虛擬碼步驟 // 解釋\".\n\nWe must output in Traditional Chinese.\n\nWe should not output actual code. So pseudocode lines with arrow → and decision etc.\n\nWe should structure like:\n\nStart // 程式開始\n→ Step 1: 定義一個空陣列 distList // 用來存所有 6 個距離\n→ Step 2: 計算所有 6 個兩兩距離的平方值，加入 distList // 避免開平方\n→ Decision: distList 是否包含 0? // 檢查有重點點\n    Yes → Step 3: 回傳 false // 零距離不合法\n    No  → Continue\n→ Step 4: 取 distList 之獨特值並排序 // 以便判斷 side 與 diagonal\n→ Decision: 唯一距離數量是否為 2? // 需要兩種距離\n    Yes → Step 5: 取得最小距離 side 和最大距離 diag\n    No  → Step 6: 回傳 false // 不是兩種距離\n→ Decision: side 出現的次數是否為 4? // 四邊相等\n    Yes → Continue\n    No  → Step 7: 回傳 false\n→ Decision: diag 出現的次數是否為 2? // 兩條對角線相等\n    Yes → Continue\n    No  → Step 8: 回傳 false\n→ Decision: diag 是否等於 2 * side? // 斜邊長平方等於兩倍邊長平方\n    Yes → Step 9: 回傳 true\n    No  → Step 10: 回傳 false\nEnd\n\nBut we need to be mindful of the structure: decisions use Yes → and No → lines with indentation.\n\nAlso step numbers may not be required, but we can add. Use \"Step X:\" format.\n\nMake sure each line ends with // Explanation in Traditional Chinese.\n\nWe must keep the arrow arrows as specified: \"→\" before each step, \"Yes →\" etc. The example uses \"Yes →\" and \"No →\" after Decision.\n\nLet's create final pseudocode.\n\nAlso, we need to note that we are not to output actual code, only steps. Ensure each line is one step. Use \"Step\" with numbering optional.\n\nMake sure to use \"Start\" and \"End\".\n\nAlso the decision lines need nested indentation. Use tab or spaces? Example uses tab indentation for Yes and No branches. We'll replicate with indentation by spaces.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 建立空陣列 distances // 用於存放 6 個距離平方\n→ Step 2: 對每一對點 (i, j) 計算 (x_i-x_j)^2 + (y_i-y_j)^2，並加入 distances // 以避免浮點誤差\n→ Decision: 是否有距離為 0? // 檢查重複點\n    Yes → Step 3: 回傳 false // 零距離表示點重合，非正方形\n    No  → \n→ Step 4: 取得 distances 的唯一值並排序為 sortedVals // 辨識 side 與 diagonal\n→ Decision: sortedVals 的長度是否為 2? // 正方形需恰好兩種距離\n    Yes → \n        Step 5: side = sortedVals[0]\n        Step 6: diagonal = sortedVals[1]\n    No  → Step 7: 回傳 false // 超過兩種距離，非正方形\n→ Decision: side 在 distances 中出現的次數是否為 4? // 四邊相等\n    Yes → \n    No  → Step 8: 回傳 false\n→ Decision: diagonal 在 distances 中出現的次數是否為 2? // 兩條對角線相等\n    Yes → \n    No  → Step 9: 回傳 false\n→ Decision: diagonal 是否等於 2 * side? // 斜邊長平方應為兩倍\n    Yes → Step 10: 回傳 true\n    No  → Step 11: 回傳 false\nEnd // 程式結束\n\nWe need to keep each line as single step. But the \"Decision:\" lines with multiple lines inside (Yes →) should be separate lines.\n\nBut the example shows \"Decision: 如果數字大於 0?\" then indentation with Yes → Step 2 and No → etc. So we must structure similarly.\n\nThus our lines after Decision: should indent. The \"Yes →\" and \"No →\" lines are separate steps. And within Yes branch, we might have multiple steps; the example shows a single step per branch, but we may need multiple. So we need to indent accordingly.\n\nBetter to separate each step as distinct lines.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 建立空陣列 distances // 用於存放 6 個距離平方\n→ Step 2: 針對所有 6 對點計算距離平方 (x_i-x_j)^2 + (y_i-y_j)^2，並加入 distances // 避免浮點誤差\n→ Decision: 是否存在距離平方為 0? // 檢查是否有重複點\n    Yes → Step 3: 回傳 false // 零距離表示點重合，不能成正方形\n    No  → \n→ Step 4: 取得 distances 的唯一值並排序成 sortedVals // 辨識邊長與對角線長\n→ Decision: sortedVals 的長度是否為 2? // 正方形必須僅有兩種不同距離\n    Yes → \n        Step 5: side = sortedVals[0] // 较小的距離即為邊長\n        Step 6: diagonal = sortedVals[1] // 较大的距離即為對角線\n    No  → Step 7: 回傳 false // 超過兩種距離，非正方形\n→ Decision: side 在 distances 中出現的次數是否為 4? // 四條邊相等\n    Yes → \n    No  → Step 8: 回傳 false // 边长不一致\n→ Decision: diagonal 在 distances 中出現的次數是否為 2? // 两条对角线相等\n    Yes → \n    No  → Step 9: 回傳 false // 对角线不一致\n→ Decision: diagonal 是否等於 2 * side? // 对角线长度平方应为两倍边长平方\n    Yes → Step 10: 回傳 true // 成为正方形\n    No  → Step 11: 回傳 false // 对角线长度不符正方形性质\nEnd // 程式結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpucav8yc7.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpucav8yc7.py\", line 44, in main\n    special = ast.literal_eval(lists[1])\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[3,0,5]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmwshlwc9.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpmwshlwc9.py\", line 44, in main\n    special = ast.literal_eval(lists[1])\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,4]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom typing import List, Tuple, Dict\n\n\nclass Solution:\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\n        n = len(price)\n        memo: Dict[Tuple[int, ...], int] = {}\n\n        def dfs(curr_needs: List[int]) -> int:\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n\n            # 直接按單價購買\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n\n            # 嘗試每個優惠\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    # 優惠可使用，遞迴計算剩餘需求\n                    res = min(res, offer[-1] + dfs(temp))\n\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    # 抓取所有以方括號包圍的列表\n    lists = re.findall(r'\\[[^\\]]+\\]', data)\n    if len(lists) < 3:\n        return\n    price = ast.literal_eval(lists[0])\n    special = ast.literal_eval(lists[1])\n    needs = ast.literal_eval(lists[2])\n\n    solution = Solution()\n    result = solution.shoppingOffers(price, special, needs)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code that solves the problem: given price array, needs array, special offers array (each offer includes counts and price). Need minimal cost to exactly meet needs. Classic DP with recursion + memoization or bitmask or state compression. Since n ≤ 6 in LeetCode, we can use DFS with memo. Let's write pseudocode accordingly.\n\nWe output line-by-line with comments.\n\nUse Start, Decision, End.\n\nWe need to produce \"虛擬碼步驟\" and comment. So each line: e.g., \"Start // 程式開始執行\". Use arrows for steps.\n\nLet's design:\n\n- Start\n- Read price, needs, special\n- Initialize memo dictionary\n- Define recursive function dfs(state)\n  - state is tuple of remaining needs\n  - if state in memo: return memo[state]\n  - base cost = sum(state[i]*price[i]) // no special\n  - For each offer in special:\n    - Check if offer can be applied: for all i, state[i] >= offer[i]\n    - If yes:\n      - new_state = tuple(state[i] - offer[i] for i)\n      - cost_offer = offer_price + dfs(new_state)\n      - base = min(base, cost_offer)\n  - memo[state] = base\n  - return base\n- result = dfs(tuple(needs))\n- Output result\n\nLet's produce pseudo code lines. Use \"→\" arrow for steps within function. Use \"Decision:\" lines.\n\nWe need to adhere to format: each line \"虛擬碼步驟 // 解釋\".\n\nLet's produce.\n\nNote: We'll use \"Start\", \"→\", \"Decision:\", \"End\". For function definition we can write \"→ Function: dfs(state)\". Inside, use arrow for substeps.\n\nWe need to include \"Yes →\", \"No →\" for decisions. For loops, we can represent with \"→ For each offer in special\". For condition, \"Decision: 需要是否足夠?\" etc.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Read price, needs, special // 讀入物品價格、需求與優惠資訊  \n→ Initialize memo = {} // 建立記錄已計算狀態的快取  \n\n→ Function: dfs(state) // 定義遞迴求解最小價格的函式  \n → Decision: state 是否在 memo? // 判斷是否已計算此需求組合  \n  Yes → Return memo[state] // 若已計算，直接回傳記錄值  \n  No  →  \n\n   → 計算 base_cost = sum(state[i] * price[i]) // 只買單價物品的費用  \n   → For each offer in special // 遍歷所有優惠方案  \n     → Decision: 是否能套用優惠? // 判斷目前需求是否滿足優惠的數量  \n      Yes →  \n        → new_state = tuple(state[i] - offer[i] for i in 0..n-1) // 更新需求  \n        → cost_with_offer = offer[n] + dfs(new_state) // 優惠價格加上剩餘需求的最小費用  \n        → base_cost = min(base_cost, cost_with_offer) // 選擇較低費用  \n       No  → continue // 無法使用此優惠，跳過  \n   → memo[state] = base_cost // 記錄此需求組合的最小費用  \n  → Return base_cost // 回傳最小費用  \n\n→ result = dfs(tuple(needs)) // 從完整需求開始遞迴求解  \n→ Output result // 回傳最小價格  \nEnd // 程式執行結束"
    },
    {
      "title": "132 Pattern",
      "source_file": "Leetcode/leetcode456.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'false'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'false'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,4,2]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      ''"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,3,2,0]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def find132pattern(self, nums):\n        stack = []\n        s3 = float('-inf')\n        for num in reversed(nums):\n            if num < s3:\n                return True\n            while stack and stack[-1] < num:\n                s3 = stack.pop()\n            stack.append(num)\n        return False\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 移除可能的前綴「nums =」\n    if data.lower().startswith(\"nums =\"):\n        data = data[5:].strip()\n\n    # 使用 eval 解析陣列字串\n    try:\n        nums = eval(data, {}, {})\n    except Exception:\n        # 若解析失敗，直接終止\n        sys.exit()\n\n    solution = Solution()\n    result = solution.find132pattern(nums)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The problem: detect 132 pattern. Use stack approach: traverse from end, maintain max_k. Pseudocode: Start, input array. Initialize stack empty, max_k = -inf. For i from n-1 down to 0: if nums[i] < max_k then return true. While stack not empty and stack.top <= nums[i]: max_k = stack.pop. Push nums[i] onto stack. After loop, return false. Then End.\n\nWe need to format each line: \"虛擬碼步驟 // 解釋\". Use arrows. Also decisions. For loop: Decision: if i >=0? but typical pseudocode: Start, input array. Initialize stack, max_k. → Decision: if i >=0? But we can show loop. Maybe \"→ For i from n-1 downto 0: // 迭代陣列\". Inside: Decision: if nums[i] < max_k? Yes return true. No: while stack not empty and stack.top <= nums[i] → ... etc.\n\nMake sure each line includes arrow or indentation. Use \"→\" for each step, indent for nested. Use Decision lines with Yes→ and No→.\n\nAlso after loop End. Provide explanation after each line. Ensure no actual code. Use simplified terms. Provide explanation in Chinese.\n\nLet's craft lines:\n\nStart // 程式開始\n→ Input nums // 取得輸入陣列\n→ Initialise stack as empty, max_k = -∞ // 設定空棧與初始最大值\n→ For i from n-1 downto 0: // 從尾端開始遍歷\n    → Decision: if nums[i] < max_k? // 判斷是否已符合 132 模式\n        Yes → Return true // 符合，立即返回真\n        No  → Decision: while stack not empty and stack.top ≤ nums[i]? // 若不符合，嘗試更新 max_k\n            Yes → Set max_k = stack.pop() // 用棧頂取代 max_k\n            No  → End While // 退出 while\n    → Push nums[i] onto stack // 將當前元素加入棧\n→ Return false // 完整遍歷後未找到模式\nEnd // 程式結束\n\nWe need to ensure each line includes \"虛擬碼步驟 // 解釋\". For nested lines, we need indent with arrows and maybe spaces. Provide clear.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums // 取得輸入陣列  \n→ Initialise stack as empty, max_k = -∞ // 設定空棧與初始最大值  \n→ For i from n-1 downto 0: // 從尾端開始遍歷陣列  \n  → Decision: if nums[i] < max_k? // 判斷是否已符合 132 模式  \n    Yes → Return true // 符合，立即返回真  \n    No → Decision: while stack not empty and stack.top ≤ nums[i]? // 若不符合，嘗試更新 max_k  \n      Yes → Set max_k = stack.pop() // 用棧頂取代 max_k  \n      No → End While // 退出 while  \n  → Push nums[i] onto stack // 將當前元素加入棧  \n→ Return false // 完整遍歷後未找到 132 模式  \nEnd // 程式執行結束"
    },
    {
      "title": "Rotate Function",
      "source_file": "Leetcode/leetcode396.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '26'\nGot (Norm):      '34'\n--- (Raw) ---\nRaw Expected: '26'\nRaw Got:      '34'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef max_rotate_function(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    total = sum(nums)\n    F = sum(i * num for i, num in enumerate(nums))\n    max_val = F\n    for i in range(1, n):\n        F = F + total - n * nums[i - 1]\n        if F > max_val:\n            max_val = F\n    return max_val\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 找出 [] 內的內容\n    match = re.search(r'\\[([^\\]]*)\\]', data)\n    if match:\n        nums_str = match.group(1)\n        if nums_str.strip() == \"\":\n            nums = []\n        else:\n            nums = [int(x.strip()) for x in nums_str.split(',')]\n    else:\n        nums = []\n    result = max_rotate_function(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps explaining algorithm to compute maximum rotation function F. Classic Leetcode problem: rotate array, compute rotation function. Efficient O(n) solution: compute initial F(0) and total sum of array. Then iteratively compute next F using formula F(k) = F(k-1) + sum - n * arr[k-1]. We'll produce pseudocode step by step. Use Start, End, Decision. Provide explanation each line. Must output in traditional Chinese. Ensure each line has `虛擬碼步驟` + space + `// 解釋/說明`. Use arrows and structure. We should include input reading, compute sum, initial F0, max, loop, update, compare. Provide final result output. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取整數陣列 nums，長度為 n // 從輸入取得陣列\n→ Step 2: 計算 sum = Σ nums[i]，i = 0..n-1 // 求所有元素總和\n→ Step 3: 計算 F = Σ i * nums[i]，i = 0..n-1 // 初始旋轉函數 F(0)\n→ Step 4: 設 maxF = F // 初始化最大值為 F(0)\n→ Step 5: 設 i = 0 // 用於迭代每一次旋轉\n→ Decision: i < n-1? // 是否還有未計算的旋轉\n    Yes →\n        → Step 6: 更新 F = F + sum - n * nums[i] // 依公式計算 F(i+1)\n        → Step 7: maxF = max(maxF, F) // 若新 F 大於已知最大值，更新\n        → Step 8: i = i + 1 // 移至下一個旋轉\n        → Step 9: 回到 Decision: i < n-1? // 重複迴圈\n    No →\n→ Step 10: 輸出 maxF // 顯示最大的旋轉函數值\nEnd // 程式執行結束"
    },
    {
      "title": "Design Linked List",
      "source_file": "Leetcode/leetcode707.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n[[], [1], [3], [1, 2], [1], [1], [1]]",
          "expected_output": "[null, null, null, null, 2, null, 3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,null,2,null,3]'\nGot (Norm):      '[null,null,null,null,-1,null,-1]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, null, 2, null, 3]'\nRaw Got:      '[null, null, null, null, -1, null, -1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MyLinkedList:\n    class Node:\n        def __init__(self, val=0):\n            self.val = val\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.size = 0\n\n    def get(self, index):\n        if index < 0 or index >= self.size:\n            return -1\n        curr = self.head\n        for _ in range(index):\n            curr = curr.next\n        return curr.val\n\n    def addAtHead(self, val):\n        node = self.Node(val)\n        node.next = self.head\n        self.head = node\n        self.size += 1\n\n    def addAtTail(self, val):\n        node = self.Node(val)\n        if not self.head:\n            self.head = node\n        else:\n            curr = self.head\n            while curr.next:\n                curr = curr.next\n            curr.next = node\n        self.size += 1\n\n    def addAtIndex(self, index, val):\n        if index < 0 or index > self.size:\n            return\n        if index == 0:\n            self.addAtHead(val)\n            return\n        node = self.Node(val)\n        curr = self.head\n        for _ in range(index - 1):\n            curr = curr.next\n        node.next = curr.next\n        curr.next = node\n        self.size += 1\n\n    def deleteAtIndex(self, index):\n        if index < 0 or index >= self.size:\n            return\n        if index == 0:\n            self.head = self.head.next\n        else:\n            curr = self.head\n            for _ in range(index - 1):\n                curr = curr.next\n            curr.next = curr.next.next\n        self.size -= 1\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    methods = ast.literal_eval(data[0].strip())\n    args_list = ast.literal_eval(data[1].strip()) if len(data) > 1 else []\n\n    obj = None\n    result = []\n\n    for i, method in enumerate(methods):\n        args = args_list[i] if i < len(args_list) else []\n        if method == \"MyLinkedList\":\n            obj = MyLinkedList()\n            result.append(None)\n        else:\n            func = getattr(obj, method)\n            ret = func(*args) if method == \"get\" else None\n            if method == \"get\":\n                result.append(ret)\n            else:\n                result.append(None)\n\n    # Format output: replace None with 'null'\n    formatted = '[' + ', '.join('null' if v is None else str(v) for v in result) + ']'\n    print(formatted)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing a linked list class. Use either singly or doubly. We choose singly as simpler. Virtual code structure: Start, then steps for each method? Should produce pseudo algorithm for the class implementation: define Node, MyLinkedList constructor, methods get, addAtHead, addAtTail, addAtIndex, deleteAtIndex. For each step, we need a line with the virtual code followed by // explanation.\n\nWe need to follow format: Each line like \"Start // 程式開始執行\" then \"→ Step 1: ...\" etc. For class definitions, maybe \"Start\" then \"→ Define Node // 定義節點結構\". Then \"→ Define MyLinkedList // 定義鏈表類別\". Then \"→ MyLinkedList() // 初始化\" etc. But we need to break down the operations.\n\nSince each method is separate, maybe each method has its own steps. We need to produce the virtual code line by line. Should we separate sections? Possibly use comments for method names.\n\nWe need to use the arrow structure. For conditionals, use Decision: lines. For loops, maybe \"Loop\" but we can just use \"→ Step ...\" For clarity, each line should have the virtual code and explanation. Provide line for class definition and methods.\n\nLet's produce pseudocode:\n\nStart // 程式開始執行\n→ Define Node // 節點結構，含值和下一個指標\n→ Define MyLinkedList // 鏈表類別，包含頭指標和大小\n\nNow method MyLinkedList constructor:\n→ MyLinkedList() // 建構子\n    → Set head to null // 初始化頭為空\n    → Set size to 0 // 初始化大小\n\nMethod get(index):\n→ get(index) // 取得索引位置的值\n    → Decision: index < 0 或 index >= size? // 檢查索引有效性\n        No  → Step 1: curr = head // 從頭節點開始\n        → Loop i=0 to index-1\n            → curr = curr.next // 移動到下一節點\n        → Step 2: return curr.val // 返回節點值\n    → Yes  → return -1 // 無效索引\n\nMethod addAtHead(val):\n→ addAtHead(val) // 在頭部新增節點\n    → Step 1: node = new Node(val) // 建立新節點\n    → Step 2: node.next = head // 指向舊頭\n    → Step 3: head = node // 更新頭指標\n    → Step 4: size++ // 大小加一\n\nMethod addAtTail(val):\n→ addAtTail(val) // 在尾部新增節點\n    → Decision: head == null? // 若鏈表空\n        Yes → addAtHead(val) // 直接在頭部加\n        No → Step 1: curr = head // 找尾部\n            → Loop while curr.next != null\n                → curr = curr.next\n            → Step 2: newNode = new Node(val)\n            → Step 3: curr.next = newNode\n            → Step 4: size++\n\nMethod addAtIndex(index, val):\n→ addAtIndex(index, val) // 在指定索引前插入\n    → Decision: index < 0? // 若負數視為0\n        Yes → index = 0\n    → Decision: index > size? // 超過尾部\n        Yes → return // 不插入\n    → Decision: index == 0? // 插入頭部\n        Yes → addAtHead(val)\n        No → Step 1: curr = head\n            → Loop i=0 to index-2\n                → curr = curr.next\n            → Step 2: newNode = new Node(val)\n            → Step 3: newNode.next = curr.next\n            → Step 4: curr.next = newNode\n            → Step 5: size++\n\nMethod deleteAtIndex(index):\n→ deleteAtIndex(index) // 刪除索引位置節點\n    → Decision: index < 0 or index >= size? // 無效\n        Yes → return\n    → Decision: index == 0? // 刪除頭部\n        Yes → head = head.next\n        → size--\n    → No → Step 1: curr = head\n            → Loop i=0 to index-2\n                → curr = curr.next\n            → Step 2: curr.next = curr.next.next // 跳過要刪除節點\n            → Step 3: size--\n\nEnd // 程式結束\n\nWe need to use \"→\" at each step line, but the sample shows indentation for nested Decision branches. We'll format accordingly.\n\nWe must not output actual code but virtual code. So we can use pseudocode-like lines.\n\nLet's produce. Ensure each line has code then // explanation. Use Chinese.\n\nWe need to include \"Start\" and \"End\". We can include comment for each method.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Node // 節點結構，含值 (val) 與指向下一個節點的指標 (next)  \n→ Define MyLinkedList // 鏈表類別，內含頭指標 head 與大小 size  \n\n// ---------- MyLinkedList 建構子 ----------\n→ MyLinkedList() // 初始化鏈表  \n    → head = null // 置空頭指標  \n    → size = 0 // 初始大小為 0  \n\n// ---------- get(index) ----------\n→ get(index) // 取得索引位置的節點值  \n    → Decision: index < 0 或 index >= size? // 檢查索引是否有效  \n        Yes → return -1 // 無效索引，返回 -1  \n        No → curr = head // 從頭節點開始  \n            → Loop i = 0 to index - 1  \n                → curr = curr.next // 移動到下一節點  \n            → return curr.val // 返回目標節點的值  \n\n// ---------- addAtHead(val) ----------\n→ addAtHead(val) // 在頭部新增節點  \n    → node = new Node(val) // 建立新節點  \n    → node.next = head // 新節點指向舊頭  \n    → head = node // 更新頭指標為新節點  \n    → size++ // 大小加一  \n\n// ---------- addAtTail(val) ----------\n→ addAtTail(val) // 在尾部新增節點  \n    → Decision: head == null? // 若鏈表為空  \n        Yes → addAtHead(val) // 直接在頭部加入  \n        No → curr = head // 找尾部節點  \n            → Loop while curr.next != null  \n                → curr = curr.next // 移動到最後一個節點  \n            → newNode = new Node(val) // 建立新節點  \n            → curr.next = newNode // 尾部指向新節點  \n            → size++ // 大小加一  \n\n// ---------- addAtIndex(index, val) ----------\n→ addAtIndex(index, val) // 在指定索引前插入節點  \n    → Decision: index < 0? // 負索引視為 0  \n        Yes → index = 0  \n    → Decision: index > size? // 超過尾部不插入  \n        Yes → return  \n    → Decision: index == 0? // 插入頭部  \n        Yes → addAtHead(val) // 直接新增頭部節點  \n        No → curr = head // 遍歷到索引前一個節點  \n            → Loop i = 0 to index - 2  \n                → curr = curr.next  \n            → newNode = new Node(val) // 建立新節點  \n            → newNode.next = curr.next // 連接後續節點  \n            → curr.next = newNode // 插入新節點  \n            → size++ // 大小加一  \n\n// ---------- deleteAtIndex(index) ----------\n→ deleteAtIndex(index) // 刪除指定索引的節點  \n    → Decision: index < 0 或 index >= size? // 索引無效  \n        Yes → return // 不做任何操作  \n        No → Decision: index == 0? // 刪除頭部  \n            Yes → head = head.next // 移除頭節點  \n            → size-- // 大小減一  \n            No → curr = head // 遍歷到索引前一個節點  \n                → Loop i = 0 to index - 2  \n                    → curr = curr.next  \n                → curr.next = curr.next.next // 跳過被刪除節點  \n                → size-- // 大小減一  \n\nEnd // 程式結束執行"
    },
    {
      "title": "Kth Largest Element in an Array",
      "source_file": "Leetcode/leetcode215.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1,5,6,4], k = 2",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3oxzbf5c.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmp3oxzbf5c.py\", line 27, in main\n    nums = eval(val.strip())\n           ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpeuuxdz_x.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmpeuuxdz_x.py\", line 27, in main\n    nums = eval(val.strip())\n           ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport heapq\n\ndef find_kth_largest(nums, k):\n    \"\"\"Return the k-th largest element using a min-heap of size k.\"\"\"\n    heap = nums[:k]\n    heapq.heapify(heap)\n    for num in nums[k:]:\n        if num > heap[0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, num)\n    return heap[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    nums = None\n    k = None\n\n    # Attempt to parse a single line like \"nums = [...], k = ...\"\n    parts = [p.strip() for p in data.split(',')]\n    for part in parts:\n        if part.startswith('nums'):\n            _, val = part.split('=', 1)\n            nums = eval(val.strip())\n        elif part.startswith('k'):\n            _, val = part.split('=', 1)\n            k = int(val.strip())\n\n    # If parsing failed, try line‑by‑line\n    if nums is None or k is None:\n        for line in data.splitlines():\n            line = line.strip()\n            if line.startswith('nums'):\n                _, val = line.split('=', 1)\n                nums = eval(val.strip())\n            elif line.startswith('k'):\n                _, val = line.split('=', 1)\n                k = int(val.strip())\n\n    if nums is None or k is None:\n        raise ValueError(\"Input format incorrect. Expected 'nums = [...] , k = ...'\")\n\n    result = find_kth_largest(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. Problem: find k-th largest element in array, not necessarily distinct, without sorting. Classic solution: use min-heap of size k. Virtual pseudocode lines: Start, Step 1: initialize min-heap, etc. Use Decision and loops. Must not produce actual code, just virtual code. Provide step-by-step with comments. Use arrow. Use \"Decision:\" and \"Yes →\" \"No →\". Provide line for End.\n\nWe'll produce something like:\n\nStart // program begins\n→ Step 1: Create empty min-heap // heap holds up to k elements\n→ Step 2: For each num in nums // iterate through array\n    → Decision: heap size < k? // if heap not full\n        Yes → Step 3: Insert num into heap // add element\n        No  → Decision: num > heap.top()? // if new num larger than smallest in heap\n            Yes → Step 4: Remove smallest from heap → Insert num into heap // replace smallest\n            No  → Step 5: Continue // ignore num\n→ Step 6: Return heap.top() // k-th largest element\nEnd // program ends\n\nNeed to produce each line with \"虛擬碼步驟 [space] // 解釋\". Use arrow for steps inside loops. Use indent? Example uses indentation for nested lines. Use arrow only for steps. For decision lines use \"Decision:\" with Yes → and No →.\n\nLet's produce lines accordingly. Ensure each line has arrow for steps and decision lines are separate. Use indentation for nested lines, with arrows for steps inside loops. Use \"→\" arrow before each line. Actually the sample uses \"→ Step 1: ...\". So we should do same. For nested steps, indent with some spaces and arrow.\n\nWe also need to handle for loop. Maybe use \"For each num in nums:\" as Step. Then inside we use Decision. So produce like:\n\nStart // 程式開始執行\n→ Step 1: 建立空的最小堆 Heap // 用於儲存 k 個最大元素\n→ Step 2: For each num in nums // 遍歷陣列\n    → Decision: Heap.size() < k? // 堆還未滿 k 個元素\n        Yes → Step 3: Heap.insert(num) // 將元素加入堆\n        No  → Decision: num > Heap.peek()? // 新元素是否比最小堆頂大\n            Yes → Step 4: Heap.removeMin() → Heap.insert(num) // 取代最小元素\n            No  → Step 5:  /* 仍保持堆不變 */ // 忽略此元素\n→ Step 6: Return Heap.peek() // 堆頂即為第 k 大元素\nEnd // 程式結束\n\nBut we need to keep format: Each line: virtual code step [space] // explanation. Use arrow only at beginning of lines. For nested lines, indent with spaces then arrow. For decision lines: \"Decision:\" then indentation. For Yes → and No → lines: indent further.\n\nAlso we must not output any actual code, just virtual steps. Ensure no syntax like `for each`? But we can use pseudocode. Use `For each` etc. But not actual code.\n\nWe should produce all lines. Let's format:\n\nStart // 程式開始執行\n→ Step 1: 建立空的最小堆 Heap // 用於儲存 k 個最大元素\n→ Step 2: For each num in nums // 遍歷陣列\n    → Decision: Heap.size() < k? // 堆還未滿 k 個元素\n        Yes → Step 3: Heap.insert(num) // 將 num 加入堆\n        No  → Decision: num > Heap.peek()? // 新元素是否大於堆頂\n            Yes → Step 4: Heap.removeMin() → Heap.insert(num) // 替換最小元素\n            No  → Step 5: /* 保持堆不變 */ // 忽略 num\n→ Step 6: Return Heap.peek() // 堆頂即為第 k 大元素\nEnd // 程式結束\n\nBut we need to maintain format: Each line: \"虛擬碼步驟\" followed by space then comment. Use arrow in front of step lines.\n\nEnsure to include arrows for nested steps: yes.\n\nNow produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的最小堆 Heap // 用於儲存 k 個最大元素  \n→ Step 2: For each num in nums // 遍歷陣列  \n  → Decision: Heap.size() < k? // 堆還未滿 k 個元素  \n   Yes → Step 3: Heap.insert(num) // 將 num 加入堆  \n   No → Decision: num > Heap.peek()? // 新元素是否大於堆頂（最小）  \n    Yes → Step 4: Heap.removeMin() → Heap.insert(num) // 替換最小元素  \n    No → Step 5: /* 保持堆不變 */ // 忽略此元素  \n→ Step 6: Return Heap.peek() // 堆頂即為第 k 大元素  \nEnd // 程式結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        # DSU parent mapping\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        # email -> name mapping\n        email_to_name = {}\n\n        for acc in accounts:\n            name = acc[0]\n            if len(acc) < 2:\n                continue\n            first_email = acc[1]\n            # Union all emails of this account with the first email\n            for email in acc[1:]:\n                root_first = find(first_email)\n                root_email = find(email)\n                parent[root_email] = root_first\n                email_to_name[email] = name\n\n        # Group emails by root\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        # Build result\n        result = []\n        for root, emails in merged.items():\n            name = email_to_name[root]\n            result.append([name] + sorted(emails))\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse input like: accounts = [[\"John\", ...]]\n    if '=' in data:\n        _, accounts_str = data.split('=', 1)\n        accounts_str = accounts_str.strip()\n    else:\n        accounts_str = data\n    try:\n        accounts = ast.literal_eval(accounts_str)\n    except Exception as e:\n        print(\"[]\")\n        return\n\n    solution = Solution()\n    merged = solution.accountsMerge(accounts)\n    print(merged)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for merging accounts. Must follow format. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and Decision. So we need to produce algorithm: Build mapping email->name, DSU for emails. Process each account: for each email, union with first email. Then gather components: email to root. Build map root->name, list emails. Sort emails. Output. Provide in virtual code style.\n\nWe produce Start, then iterate accounts, then inside each account iterate emails. Use DSU functions: find, union. After processing, gather results: map root->list emails. Then produce output list: for each root, sort emails, add name. End.\n\nWe must adhere to structure: \"→\" arrow lines for steps, and Decision lines with Yes/No arrows.\n\nWe need to show algorithmic steps, not actual code.\n\nLet's craft lines:\n\nStart\n→ Step 1: 初始化 DSU 結構，準備 union 與 find 功能 // 建立聯合查找資料結構\n→ Step 2: 建立映射 emailToName，emailToIndex，並設定唯一索引 // 為每個 email 分配唯一 ID\n\n→ Step 3: 遍歷 accounts 列表 // 處理每一個帳號資料\n    → Step 3.1: 取得帳號名稱 name = accounts[i][0] // 取得此帳號的擁有者名稱\n    → Step 3.2: 針對此帳號的每一封 email\n        → Step 3.2.1: 若 email 未出現在映射中\n            → Step 3.2.1.1: 為此 email 創建唯一索引 idx\n            → Step 3.2.1.2: emailToName[idx] ← name\n        → Step 3.2.2: 若這是該帳號的第一封 email，記錄 firstIdx ← idx\n        → Step 3.2.3: 否則 union(firstIdx, idx) // 把同一帳號中的 email 合併\n        → Step 3.2.4: emailToIndex[email] ← idx\n\n→ Step 4: 建立 rootToEmails 映射 // 根據 DSU 重新分組\n    → Step 4.1: 對於每個 email 在 emailToIndex 中\n        → Step 4.1.1: 找到其根節點 root = find(idx)\n        → Step 4.1.2: 若 root 不在 rootToEmails，初始化空列表\n        → Step 4.1.3: 加入 email 至 rootToEmails[root]\n        → Step 4.1.4: 若 root 不在 rootToName，設定 rootToName[root] ← emailToName[idx]\n\n→ Step 5: 構造結果列表 accountsResult\n    → Step 5.1: 對於每個 root 在 rootToEmails\n        → Step 5.1.1: 取得 name = rootToName[root]\n        → Step 5.1.2: 取得 emailsList = rootToEmails[root]\n        → Step 5.1.3: 將 emailsList 排序\n        → Step 5.1.4: 新增一個 list = [name] + emailsList\n        → Step 5.1.5: 加入 accountsResult\n\n→ End // 輸出 accountsResult\n\nNeed decisions? Maybe when checking if email present? Use Decision lines.\n\nLet's modify Step 3.2: Decision if email exists.\n\nAlso maybe decision for rootToName? But not needed.\n\nAdd Decision lines:\n\n→ Decision: email 是否已存在? // 檢查此 email 是否已被處理\n    Yes → Step 3.2.2: (skip creation)\n    No → Step 3.2.1: create\n\nAlso maybe decision for first email.\n\nWe'll incorporate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 DSU 結構，準備 union 與 find 功能 // 建立聯合查找資料結構  \n→ Step 2: 建立映射 emailToIndex、emailToName，並為每個 email 分配唯一索引 // 為每封郵件建立 ID  \n\n→ Step 3: 遍歷 accounts 列表 // 處理每一筆帳號  \n    → Step 3.1: 取得帳號名稱 name = accounts[i][0] // 取得此帳號的擁有者名稱  \n    → Step 3.2: 對於此帳號的每一封 email  \n        → Decision: email 是否已存在於映射中? // 檢查此郵件是否已被處理  \n            Yes → Step 3.2.1: idx ← emailToIndex[email] // 取得已存在的 ID  \n            No  → Step 3.2.2: 為此 email 創建唯一索引 idx = 新 ID  \n                → Step 3.2.2.1: emailToIndex[email] ← idx  \n                → Step 3.2.2.2: emailToName[idx] ← name // 將 ID 與名稱關聯  \n        → Decision: 是否為此帳號的第一封 email? // 判斷是否要作為 union 的參考  \n            Yes → Step 3.2.3: firstIdx ← idx // 記錄此帳號的第一封郵件 ID  \n            No  → Step 3.2.4: union(firstIdx, idx) // 把同一帳號中的郵件合併  \n\n→ Step 4: 建立 rootToEmails 映射 // 根據 DSU 重新分組  \n    → Step 4.1: 對於每個 email 在 emailToIndex 中  \n        → Step 4.1.1: root ← find(idx) // 找到該郵件的根節點  \n        → Decision: root 是否已在 rootToEmails?  \n            Yes → Step 4.1.2: 加入 email 至 rootToEmails[root] // 把郵件加入對應分組  \n            No  → Step 4.1.3: 初始化 rootToEmails[root] ← 空列表，然後加入 email  \n        → Decision: root 是否已在 rootToName?  \n            No  → Step 4.1.4: rootToName[root] ← emailToName[idx] // 設定此分組的名稱  \n\n→ Step 5: 構造結果列表 accountsResult  \n    → Step 5.1: 對於每個 root 在 rootToEmails  \n        → Step 5.1.1: name ← rootToName[root] // 取出此分組的名稱  \n        → Step 5.1.2: emailsList ← rootToEmails[root] // 取出所有郵件  \n        → Step 5.1.3: 將 emailsList 排序 // 讓郵件有序  \n        → Step 5.1.4: newAccount ← [name] + emailsList // 製作最終帳號格式  \n        → Step 5.1.5: 加入 newAccount 至 accountsResult  \n\nEnd // 程式執行結束，輸出 accountsResult 其中每筆帳號已合併且郵件已排序。"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsknj80e1.py\", line 48, in <module>\n    exec(data_str, {}, local_vars)\n  File \"<string>\", line 1\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0xjq9_r9.py\", line 48, in <module>\n    exec(data_str, {}, local_vars)\n  File \"<string>\", line 1\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS: find shortest distance and parents for each word\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path: list[str], word: str) -> None:\n            if word == beginWord:\n                res.append(path[::-1])  # reverse to start->end order\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data_str = sys.stdin.read().strip()\n    # Execute the input string to get variables\n    local_vars = {}\n    exec(data_str, {}, local_vars)\n    beginWord = local_vars.get(\"beginWord\")\n    endWord = local_vars.get(\"endWord\")\n    wordList = local_vars.get(\"wordList\", [])\n    # Solve\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    # Print the result\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step for algorithm. Problem: Word Ladder II, find all shortest transformation sequences. We need BFS to find shortest paths and then DFS/backtracking to reconstruct all sequences. We need to output as steps with arrows and explanations. Use Start, Decision, End. Provide each step line with comment. We should incorporate BFS building adjacency map and levels, then DFS generating paths. Provide logic in plain pseudo steps. Use appropriate arrows for branching.\n\nWe need to list steps. Probably like:\n\nStart\n→ Initialize data structures: set for wordList, adjacency dict, level map\n→ If endWord not in wordList: return empty list\n→ BFS queue with beginWord, level 1\n→ while queue not empty:\n    → Dequeue word, currentLevel\n    → For each neighbor (one-letter diff) in wordList:\n        → If neighbor not visited:\n            → Mark visited, set level[neighbor] = currentLevel+1, enqueue neighbor\n        → Else if level[neighbor] == currentLevel+1:\n            → Add to adjacency\n→ After BFS, if endWord not visited: return empty list\n→ DFS helper(word, path):\n    → If word == endWord: append copy of path to result\n    → Else:\n        → For each next in adjacency[word]:\n            → DFS(next, path + [next])\n→ Call DFS(beginWord, [beginWord])\n→ Return result\nEnd\n\nBut must use \"Decision:\" and \"Yes →\" etc. We need step-by-step. For loops, use \"Loop:\" maybe not required but can use decisions. Use arrow notation. Provide explanation after each line.\n\nLet's produce. Use indentation to show nested decision. Provide \"Decision:\" lines for if statements.\n\nAlso we need to show building adjacency only when level[neighbor]==currentLevel+1. Use decisions.\n\nLet's craft lines:\n\nStart\n→ Initialize wordSet = set(wordList) // 轉換字典為集合方便 O(1) 查詢\n→ If endWord not in wordSet: → End // 若目標字不在字典則無路徑直接結束\n→ Initialize adjacency = defaultdict(list) // 儲存從每個字到下一層合法字的連結\n→ Initialize level = {} // 每個字到起點的最短距離\n→ Initialize queue = [beginWord]\n→ level[beginWord] = 0\n→ While queue not empty:\n    → current = queue.pop(0)\n    → For each position i in range(len(current)):\n        → For each c in 'abcdefghijklmnopqrstuvwxyz':\n            → If c == current[i]: continue\n            → nextWord = current[:i] + c + current[i+1:]\n            → If nextWord in wordSet:\n                → Decision: 是否已在 level? // 檢查是否已被訪問過\n                    Yes → Decision: nextWord 的距離是否等於 level[current]+1? // 若已在同層\n                        Yes → adjacency[current].append(nextWord) // 連結同層字\n                        No  → No → // 跳過\n                    No  → level[nextWord] = level[current]+1 // 設定距離\n                           adjacency[current].append(nextWord) // 連結新字\n                           queue.append(nextWord) // 加入隊列\n→ Decision: endWord 是否在 level? // 判斷是否找到目標\n    Yes → // 進行 DFS 產生所有路徑\n    No  → → End // 沒有路徑直接結束\n→ Initialize result = []\n→ Define DFS(word, path):\n    → Decision: word == endWord?\n        Yes → result.append(path.copy()) // 完整路徑加入結果\n        No  → For next in adjacency[word]:\n            → DFS(next, path + [next]) // 深度優先遍歷\n→ Call DFS(beginWord, [beginWord])\n→ End // 回傳結果\n\nNeed to format each line. Use \"→\" arrow before each step. Indentation maybe not necessary but we can just list. But we should maintain proper structure. Each line contains code step then comment. For nested decisions, we might indent.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ wordSet ← Set(wordList) // 將字典轉成集合，便於 O(1) 查詢\n→ Decision: endWord 是否在 wordSet? // 判斷目標字是否在字典內\n    Yes → // 若不在，直接結束\n    No  → End // 沒有可行路徑，返回空列表\n→ adjacency ← DefaultDict(List) // 用來儲存從每個字到下一層合法字的連結\n→ level ← {} // 每個字到起點的最短距離\n→ queue ← [beginWord] // BFS 的隊列\n→ level[beginWord] ← 0 // 起點距離為 0\n→ Decision: queue 是否非空? // BFS 主循環\n    Yes → // 取出當前字\n        → current ← queue.pop(0) // 取得並移除隊列首字\n        → Loop: i in 0 .. len(current)-1 // 遍歷每個字母位置\n            → Loop: c in 'abcdefghijklmnopqrstuvwxyz' // 嘗試所有字母\n                → Decision: c == current[i]? // 是否為同一個字母\n                    Yes → No → // 跳過\n                    No  → nextWord ← current[:i] + c + current[i+1:] // 替換字母得到新字\n                        → Decision: nextWord 在 wordSet? // 是否是合法字\n                            Yes →\n                                → Decision: nextWord 已在 level? // 是否已被訪問\n                                    Yes →\n                                        → Decision: level[nextWord] == level[current] + 1? // 是否在同一層\n                                            Yes → adjacency[current].append(nextWord) // 同層連結\n                                            No  → No // 跳過\n                                    No  →\n                                        → level[nextWord] ← level[current] + 1 // 設定距離\n                                        → adjacency[current].append(nextWord) // 連結新字\n                                        → queue.append(nextWord) // 加入隊列\n                            No  → No // 非字典字忽略\n→ Decision: endWord 是否在 level? // 判斷是否找到目標\n    Yes → // 進行 DFS 產生所有最短路徑\n    No  → → End // 沒有路徑直接結束\n→ result ← [] // 存放所有最短轉換序列\n→ Define DFS(word, path): // 從 word 開始的遞迴搜尋\n    → Decision: word == endWord? // 是否到達終點\n        Yes → result.append(path.copy()) // 將完整路徑加入結果\n        No  → // 遍歷下一層合法字\n            → Loop: next in adjacency[word]\n                → DFS(next, path + [next]) // 深度優先遞迴\n→ DFS(beginWord, [beginWord]) // 啟動 DFS 搜尋\n→ End // 程式執行結束，返回 result\n```"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,6,4,4,4,1,0,6]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 6, 4, 4, 4, 1, 0, 6]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # size of the available numbers\n        self.size = n - len(blacklist)\n        # map from blacklisted numbers in [0, size-1] to valid numbers\n        self.mapping = {}\n        black = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                # find the next valid number from the upper end\n                while last in black:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        # random integer in [0, size-1]\n        idx = random.randint(0, self.size - 1)\n        # return mapped value if it exists\n        return self.mapping.get(idx, idx)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    ops = ast.literal_eval(data[0].strip())\n    args_list = ast.literal_eval(data[1].strip())\n\n    results = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            func = getattr(obj, op)\n            results.append(func())\n    # output with JSON formatting (None -> null)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code lines with comments. Let's think algorithm: typical solution: map blacklisted numbers in [0, n-m-1] to allowed numbers in [n-m, n-1] that are not blacklisted. Preprocess. Then pick random in [0, n-m-1] and map.\n\nWe output step-by-step. Use Start, End, Decision. For clarity: lines like \"Solution Constructor: ...\" etc.\n\nLet's produce.\n\nSteps:\n\nStart\n→ Initialize n, blacklist\n→ Compute m = len(blacklist)\n→ Compute w = n - m (number of allowed numbers)\n→ Create set B = set(blacklist)\n→ Create mapping dict = empty\n→ For each b in blacklist:\n    If b < w:\n        Find smallest x >= w not in B\n        map[b] = x\n        add x to B\n→ End constructor\n\npick():\nStart\n→ Generate random integer r in [0, w-1]\n→ If r in mapping:\n        Return mapping[r]\n    Else:\n        Return r\nEnd\n\nBut need virtual code line by line. Use arrows. For decisions, we use Decision: If condition.\n\nLet's produce. Use arrow arrows like \"→\".\n\nWe need \"虛擬碼步驟\" plus comment.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n\n→ 初始化變數 n, blacklist // 將輸入的整數與黑名單存入物件\n\n→ 計算 m = len(blacklist) // 黑名單長度\n\n→ 計算 w = n - m // 可用數字的個數\n\n→ 建立集合 B = set(blacklist) // 方便 O(1) 查詢\n\n→ 建立空字典 map = {} // 用於映射黑名單中的前段數字\n\n→ Decision: 如果 B 內有任何數字小於 w? // 需要對前段黑名單做映射\n    Yes →\n        → 初始化 x = w // 從可用範圍的最小值開始尋找\n        → Decision: x 在 B? // 檢查 x 是否為黑名單\n            Yes →\n                → x = x + 1 // 找到下一個非黑名單數字\n                → Decision: x 在 B? // 重複直到找到非黑名單\n                    Yes → 從此點回到前面再次判斷\n                    No  → \n                        → map[b] = x // 將黑名單中的前段數字映射到合法數字\n                        → B.add(x) // 把映射後的數字加入黑名單集合，避免重複\n                        → 回到外層 Decision 以處理下一個 b\n            No  →\n                → map[b] = x // 黑名單數字本身小於 w，直接映射\n                → B.add(x) // 同樣加入集合\n                → 回到外層 Decision\n    No → // 沒有前段黑名單，無需映射\n\nEnd // 構造完成，準備呼叫 pick\n\n// ----------------- pick 方法 -----------------\n\nStart // pick 方法開始\n\n→ 產生隨機整數 r 在 [0, w-1] // 等概率選擇前段範圍內的數字\n\n→ Decision: r 在 map 中? // 檢查是否需要映射\n    Yes → \n        → 返回 map[r] // 回傳映射後的合法數字\n    No  → \n        → 返回 r // 直接回傳，因為 r 本身合法\n\nEnd // pick 方法結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.15256465532817617,-0.37359975844714965],[0.5686484039556907,0.39566798942777676],[-0.7256147949891556,-0.08268154178031283]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.15256465532817617, -0.37359975844714965], [0.5686484039556907, 0.39566798942777676], [-0.7256147949891556, -0.08268154178031283]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\nimport ast\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機生成半徑（使用 sqrt 保證均勻分布）\n        r = self.radius * math.sqrt(random.random())\n        # 隨機角度\n        theta = random.uniform(0, 2 * math.pi)\n        # 轉換為直角座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入\n    ops = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n\n    obj = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            # 建構子回傳 None (LeetCode 風格)\n            obj = Solution(*args)\n            results.append(None)\n        elif op == \"randPoint\":\n            results.append(obj.randPoint())\n        else:\n            # 若有其他方法，預設回傳 None\n            results.append(None)\n\n    # 輸出結果，None 轉成 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, following the format. Provide steps: Start, initialization, generating random radius via sqrt, random angle, etc. Provide Decision? But no decisions needed except maybe loop to handle negative? We'll produce steps. Use arrows. Ensure each line ends with // 解釋. Provide Start and End. Use 'Step' names. Provide the logic. We'll produce:\n\nStart\n→ Step 1: Store radius, center coordinates // initialize variables\n→ Step 2: Generate random number u in [0,1) // for radial distribution\n→ Step 3: Compute radial distance r = radius * sqrt(u) // ensures uniform distribution\n→ Step 4: Generate random angle theta in [0, 2π) // full circle\n→ Step 5: Compute x = x_center + r * cos(theta) // convert polar to cartesian\n→ Step 6: Compute y = y_center + r * sin(theta) // same\n→ Step 7: Return [x, y] // output point\nEnd\n\nAlso need class structure: \n→ Step 0: Define class Solution // main class\n→ Step 1: Constructor Solution(radius, x_center, y_center) // store values\n→ Step 2: Method randPoint() // generates point\n\nBut we must show steps sequentially. Possibly show class definition and method body. Use arrows accordingly. Use 'Start' at top. End at bottom. Provide explanation. Use 'Decision:' only if necessary. Not needed.\n\nMake sure each line has a single arrow.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 定義類別 Solution // 主類別  \n→ Step 1: Constructor: Solution(radius, x_center, y_center) // 初始化半徑與中心座標  \n    → Store radius, x_center, y_center as instance variables // 方便後續使用  \n→ Step 2: 定義方法 randPoint() // 產生隨機點  \n    → Step 2.1: 產生隨機數 u ∈ [0, 1) // 用於半徑分佈  \n    → Step 2.2: 計算 r = radius * sqrt(u) // 轉換成均勻分佈的半徑  \n    → Step 2.3: 產生隨機角度 θ ∈ [0, 2π) // 360° 全圓  \n    → Step 2.4: 計算 x = x_center + r * cos(θ) // 極座標轉直角座標  \n    → Step 2.5: 計算 y = y_center + r * sin(θ) // 同上  \n    → Step 2.6: 回傳 [x, y] // 隨機點結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Count Different Palindromic Subsequences",
      "source_file": "Leetcode/leetcode730.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '7'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '7'"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '104860361'\nGot (Norm):      '104860362'\n--- (Raw) ---\nRaw Expected: '104860361'\nRaw Got:      '104860362'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # next_idx[i] = index of next occurrence of s[i] after i, or n if none\n    next_idx = [n] * n\n    last = {}\n    for i in range(n - 1, -1, -1):\n        next_idx[i] = last.get(s[i], n)\n        last[s[i]] = i\n\n    # prev_idx[i] = index of previous occurrence of s[i] before i, or -1 if none\n    prev_idx = [-1] * n\n    last.clear()\n    for i in range(n):\n        prev_idx[i] = last.get(s[i], -1)\n        last[s[i]] = i\n\n    # DP table\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1  # single character is a palindrome\n\n    # Build DP for substrings of length >= 2\n    for length in range(2, n + 1):\n        for l in range(0, n - length + 1):\n            r = l + length - 1\n            if s[l] == s[r]:\n                nl = next_idx[l]\n                pr = prev_idx[r]\n                if nl > pr:          # no same character inside\n                    val = dp[l + 1][r - 1] * 2 + 2\n                elif nl == pr:       # exactly one same character inside\n                    val = dp[l + 1][r - 1] * 2 + 1\n                else:                # more than one same character inside\n                    val = dp[l + 1][r - 1] * 2 - dp[nl + 1][pr - 1]\n            else:\n                val = dp[l + 1][r] + dp[l][r - 1] - dp[l + 1][r - 1]\n            dp[l][r] = val % MOD\n\n    return dp[0][n - 1] % MOD\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract only alphabetic characters to get the string\n    s = re.sub(r'[^A-Za-z]', '', data)\n    result = count_palindromic_subsequences(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines for algorithm solving number of distinct non-empty palindromic subsequences. Typical DP solution: dp[l][r] counts distinct palindromic subsequences in s[l..r]. Use recurrence: if s[l]==s[r], then dp[l][r] = dp[l+1][r] + dp[l][r-1] +1; else dp[l][r] = dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]. But need to handle duplicates: if same char occurs inside. The standard algorithm: For each pair l,r, if s[l]==s[r], find next occurrence next[l] > l and prev occurrence prev[r] < r. If next[l] > prev[r], meaning no same char between, then dp[l][r] = dp[l+1][r-1]*2 + 2. If next[l] == prev[r] (only one same char inside), dp[l][r] = dp[l+1][r-1]*2 +1. Else (more than one), dp[l][r] = dp[l+1][r-1]*2 - dp[next[l]+1][prev[r]-1]. Standard.\n\nWe produce virtual code: steps: compute next occurrence array, prev array, dp 2D. Use mod. We'll produce loops for lengths from 1 to n. Use base dp[i][i]=1. Then for len 2 to n: for l in 0..n-len: r = l+len-1; if s[l]==s[r] then handle. else dp = dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]. Then mod adjust. Finally result = dp[0][n-1] mod.\n\nWe need to produce pseudo code with arrows and decision branches for the cases. Use Start, End. Provide each line with explanation comment. Use virtual code lines. Must not output actual code. Use step names.\n\nLet's draft:\n\nStart // 程式開始\n→ Step 1: 取得字串長度 n // 讀取輸入字串長度\n→ Step 2: 初始化 2D 陣列 dp[n][n] 為 0 // 佈局 DP 表\n→ Step 3: 計算 next[l] 與 prev[l] // 計算每個位置右側下一個相同字元與左側上一個相同字元\n    → Decision: 逐個字元處理 // 逐位建立 next 與 prev\n        Yes → Step 3.1: 若未找到相同字元，next[l] = n; prev[l] = -1\n        No  → Step 3.2: 設定對應索引\n→ Step 4: 設定所有 dp[i][i] = 1 // 單個字元本身即為回文子序列\n→ Step 5: 依長度 len 從 2 到 n 進行 DP\n    → Decision: len 循環\n        Yes → Step 5.1: 針對每個起始索引 l 計算 r = l+len-1\n            → Decision: s[l] == s[r]?\n                Yes → Step 5.1.a: 找到 nextIndex = next[l], prevIndex = prev[r]\n                    → Decision: nextIndex > prevIndex?\n                        Yes → Step 5.1.a.i: dp[l][r] = dp[l+1][r-1] * 2 + 2\n                        No → Decision: nextIndex == prevIndex?\n                            Yes → Step 5.1.a.ii: dp[l][r] = dp[l+1][r-1] * 2 + 1\n                            No  → Step 5.1.a.iii: dp[l][r] = dp[l+1][r-1] * 2 - dp[nextIndex+1][prevIndex-1]\n                    → Step 5.1.a.iv: dp[l][r] = (dp[l][r] mod M + M) mod M // 保證非負\n                No  → Step 5.1.b: dp[l][r] = dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]\n                    → Step 5.1.b.i: dp[l][r] = (dp[l][r] mod M + M) mod M\n→ Step 6: 回傳 dp[0][n-1] mod M // 結果輸出\nEnd // 程式結束\n\nNeed to include arrow after each line. Provide comments. Use arrow \"→\". For decisions we need indentation. Let's follow style in example: use \"→ Decision: ...\" then indent subsequent lines with 4 spaces? In example they used indentation: \n    Yes → Step 2: ...\nWe should replicate.\n\nLet's produce final output with lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 s，計算長度 n // 取得輸入字串及其長度  \n→ Step 2: 初始化 dp[n][n] 為 0 // 佈局 2D DP 表  \n→ Step 3: 建立 next[n] 與 prev[n] 陣列  \n    → Decision: 從左到右掃描字元  \n        Yes → Step 3.1: 若當前字元未在右側再次出現，設定 next[i] = n  \n        No  → Step 3.2: 記錄下一個相同字元的位置  \n    → Decision: 從右到左掃描字元  \n        Yes → Step 3.3: 若當前字元未在左側再次出現，設定 prev[i] = -1  \n        No  → Step 3.4: 記錄上一個相同字元的位置  \n→ Step 4: 對所有 i，設定 dp[i][i] = 1 // 單個字元本身即為回文子序列  \n→ Step 5: 依長度 len 從 2 到 n 逐步計算 dp  \n    → Decision: 迴圈 len = 2 .. n  \n        Yes → Step 5.1: 針對每個起始索引 l（0 ≤ l ≤ n-len）  \n            → Step 5.1.1: 設定 r = l + len - 1 // 結束索引  \n            → Decision: s[l] == s[r]？  \n                Yes → Step 5.1.2: 取得 nextIndex = next[l]，prevIndex = prev[r]  \n                    → Decision: nextIndex > prevIndex？  \n                        Yes → Step 5.1.2.a: dp[l][r] = dp[l+1][r-1] * 2 + 2  \n                        No  → Decision: nextIndex == prevIndex？  \n                            Yes → Step 5.1.2.b: dp[l][r] = dp[l+1][r-1] * 2 + 1  \n                            No  → Step 5.1.2.c: dp[l][r] = dp[l+1][r-1] * 2 - dp[nextIndex+1][prevIndex-1]  \n                    → Step 5.1.2.d: dp[l][r] = (dp[l][r] mod M + M) mod M // 取模並確保非負  \n                No  → Step 5.1.3: dp[l][r] = dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]  \n                    → Step 5.1.3.a: dp[l][r] = (dp[l][r] mod M + M) mod M // 取模並確保非負  \n→ Step 6: 輸出結果 dp[0][n-1] mod M // 最終答案  \nEnd // 程式結束執行"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,1,3],[1,2,3],[2,1,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 1, 3], [1, 2, 3], [2, 1, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    \"\"\"保持原始陣列並實作重置與洗牌功能。\"\"\"\n\n    def __init__(self, nums):\n        # 以 list 副本儲存原始陣列，避免後續操作改變原始資料\n        self.original = list(nums)\n\n    def reset(self):\n        \"\"\"回傳原始陣列的副本。\"\"\"\n        return list(self.original)\n\n    def shuffle(self):\n        \"\"\"使用 Fisher‑Yates 洗牌演算法隨機打亂陣列。\"\"\"\n        arr = list(self.original)          # 先取原始陣列的副本\n        n = len(arr)\n        for i in range(n - 1, 0, -1):       # 從最後一個元素往前迴圈\n            j = random.randint(0, i)       # 隨機取 0~i 的索引\n            arr[i], arr[j] = arr[j], arr[i]  # 交換位置\n        return arr\n\ndef main():\n    # 讀取全部輸入並轉為 Python 物件\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將兩個列表包在外層列表後使用 literal_eval 解析\n    expr = '[' + data + ']'\n    commands, args = ast.literal_eval(expr)\n\n    output = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            # 建構子不回傳值，加入 None\n            obj = Solution(arg[0])\n            output.append(None)\n        elif cmd == \"reset\":\n            output.append(obj.reset())\n        elif cmd == \"shuffle\":\n            output.append(obj.shuffle())\n        else:\n            # 任何未定義的方法直接跳過或拋錯\n            raise ValueError(f\"Unknown command: {cmd}\")\n\n    # 輸出結果，將 None 轉為 JSON null\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing algorithm. Not actual code. Steps: class definition, constructor storing original, reset returns original, shuffle uses Fisher-Yates. Provide explanation each line. Use arrow formatting. Ensure start, decision, etc. Provide steps. Use \"Start\", \"End\". Also show arrays, loops. Use arrows \"→\". Use indentation. Provide each line: \"虛擬碼步驟 // 解釋\". Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 物件  \n→ Step 2: 宣告變數 original, current as 整數陣列 // 用來儲存原始與目前狀態  \n→ Decision: 若傳入的 nums 為空？ // 檢查輸入陣列是否存在  \n  Yes → Step 3: 把 original 設為空陣列 // 空陣列處理  \n  No → Step 4: 把 original 設為 nums 的複本 // 儲存原始順序  \n  No → Step 5: 把 current 設為 nums 的複本 // 初始化為原始順序  \n\n→ Step 6: 定義函式 reset()  \n  → Step 7: 把 current 設為 original 的複本 // 重新回到原始排列  \n  → Step 8: 回傳 current // 回傳重置後的陣列  \n\n→ Step 9: 定義函式 shuffle()  \n  → Step 10: 將 current 轉成可改變的陣列變量 arr // 用於洗牌  \n  → Step 11: 取得陣列長度 n  \n  → For i 從 n-1 迴圈到 1  \n    → Step 12: 隨機產生索引 j，範圍 0~i // Fisher‑Yates 隨機索引  \n    → Decision: 如果 j ≠ i? // 若索引不同才需要交換  \n      Yes → Step 13: 交換 arr[i] 與 arr[j] // 進行位置交換  \n      No  → Step 14: 不做任何事 // 若相同則保持原樣  \n  → Step 15: 把 arr 複製回 current // 更新 current 為洗牌結果  \n  → Step 16: 回傳 current // 回傳隨機排列  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\ndef subsets(nums):\n    res = []\n\n    def backtrack(start, path):\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n\n    backtrack(0, [])\n    return res\n\ndef parse_input(data):\n    \"\"\"\n    將類似 'nums = [1,2,3]' 的字串轉成 list。\n    \"\"\"\n    # 先去除空白與換行\n    data = data.strip()\n    # 找出第一個出現的列表字串\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if not match:\n        return []\n    list_str = match.group(0)\n    # 使用 ast.literal_eval 解析成 Python list\n    try:\n        return ast.literal_eval(list_str)\n    except Exception:\n        return []\n\ndef main():\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    result = subsets(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step for generating all subsets (power set) of a set of unique elements. We should use the format with arrows and Decision, etc. Each line: \"虛擬碼步驟 [space] // 解釋\".\n\nNeed to include Start, End, Decision. Steps: Input array, maybe length n, then recursion or iterative generation. We can use backtracking.\n\nLet's produce:\n\nStart\n→ Input nums // 取得輸入陣列\n→ Variable subsets = [] // 用於存儲所有子集\n→ Function backtrack(start, current) // 递归函数\n    → Decision: start == len(nums)? // 是否已遍历完所有元素\n        Yes → Append copy of current to subsets // 完成一個子集，加入結果\n        No  → Decision: Include current element? // 递归选择包含或不包含\n            Yes → Append nums[start] to current // 包含 nums[start]\n            → backtrack(start+1, current) // 继续递归\n            → Remove last from current // 撤销选择\n            No  → backtrack(start+1, current) // 直接跳过当前元素\n→ Call backtrack(0, []) // 开始递归\n→ Return subsets // 返回所有子集\nEnd\n\nBut we must be careful to produce each line with \"虛擬碼步驟 // 解釋\". Use arrows. For nested decisions, indent? Use indent for nested lines maybe but maintain format. Use \"→\" for lines, \"Decision:\" for decisions, \"Yes →\", \"No →\". Each line must have a space between the code and the comment.\n\nLet's produce accordingly. Use indentation? Not necessary but can show.\n\nWe must ensure each line ends with // 解釋.\n\nMake sure no actual code, only pseudocode steps. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums // 取得使用者輸入的唯一元素陣列  \n→ Variable subsets = [] // 用於存放所有子集  \n→ Function backtrack(start, current) // 定義遞迴生成子集的函式  \n    → Decision: start == len(nums)? // 檢查是否已處理完所有元素  \n        Yes → Append copy of current to subsets // 完成一個子集，加入結果  \n        No → Decision: Include nums[start]? // 選擇是否包含當前元素  \n            Yes → Append nums[start] to current // 將 nums[start] 加入當前子集  \n            → backtrack(start+1, current) // 進一步遞迴處理下一個元素  \n            → Remove last from current // 撤銷選擇，恢復狀態  \n            No → backtrack(start+1, current) // 直接跳過當前元素，繼續遞迴  \n→ Call backtrack(0, []) // 從第一個元素開始遞迴  \n→ Return subsets // 回傳所有生成的子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Task Scheduler",
      "source_file": "Leetcode/leetcode621.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '8'\nGot (Norm):      '10'\n--- (Raw) ---\nRaw Expected: '8'\nRaw Got:      '10'"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '10'\nRaw Got:      '12'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\n# ------------------------------------------------------------\n# 功能：計算完成所有任務所需的最小 CPU 時間段數\n# ------------------------------------------------------------\ndef least_interval(tasks: list[str], n: int) -> int:\n    \"\"\"\n    1. 統計每個任務字母的出現頻率\n    2. 找到出現次數最大的任務類別 max_freq\n    3. 計算有 max_freq 次數的任務種類數 count_max\n    4. 依公式計算理論上必須的閒置時間 idle_slots\n    5. 若閒置時間為負數則設為 0\n    6. 最終時間段 = idle_slots + 任務總數\n    7. 若理論時間段 < 任務總數，則直接返回任務總數\n    \"\"\"\n    if not tasks:\n        return 0\n\n    freq = Counter(tasks)                 # 1\n    max_freq = max(freq.values())         # 2\n    count_max = sum(1 for v in freq.values() if v == max_freq)  # 3\n\n    # 4\n    idle_slots = (max_freq - 1) * (n + 1) - count_max\n    # 5\n    if idle_slots < 0:\n        idle_slots = 0\n\n    # 6\n    intervals = idle_slots + len(tasks)\n\n    # 7\n    return max(intervals, len(tasks))\n\n# ------------------------------------------------------------\n# 主程式：從 stdin 讀取資料，輸出結果\n# ------------------------------------------------------------\ndef parse_input(content: str) -> tuple[list[str], int]:\n    \"\"\"\n    解析輸入字串，提取 tasks 列表與整數 n。\n    輸入範例： 'tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2'\n    \"\"\"\n    # 取得 tasks 列表字串\n    tasks_match = re.search(r'tasks\\s*=\\s*(\\[[^\\]]*\\])', content, re.S)\n    # 取得 n 整數字串\n    n_match = re.search(r'n\\s*=\\s*(-?\\d+)', content)\n\n    tasks = ast.literal_eval(tasks_match.group(1)) if tasks_match else []\n    n = int(n_match.group(1)) if n_match else 0\n    return tasks, n\n\ndef main() -> None:\n    # 讀取全部輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    tasks, n = parse_input(raw_input)\n    result = least_interval(tasks, n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining algorithm. Use Start, Decision, etc. Must be in Traditional Chinese. No actual code. Just virtual code steps.\n\nWe need to outline algorithm: Count frequencies, find max freq, count tasks with that freq, compute idle slots etc. Then compute max between tasks count and idle+tasks count.\n\nWe need step-by-step.\n\nOk produce lines.\n\nWe'll start with Start.\n\nWe'll parse tasks array, compute frequency map.\n\nFind max freq.\n\nCount number of tasks with max freq.\n\nCompute idle slots: (maxFreq-1)*(n+1) - countMax.\n\nIf idleSlots <0, idle=0.\n\nTotal intervals = idleSlots + len(tasks).\n\nReturn total.\n\nMake decisions accordingly.\n\nWe should produce virtual code lines accordingly.\n\nLet's produce about 20 lines.\n\nWe need to show decisions for if idleSlots >0 etc.\n\nLet's craft.\n\nAlso explanation each line.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立頻率表 freq ← 空字典 // 讀取每個任務字母並統計其出現次數  \n→ Step 2: maxFreq ← 0 // 變數用來儲存任務出現次數中的最大值  \n→ Step 3: countMax ← 0 // 變數用來計算具有 maxFreq 次數的任務種類數  \n→ Decision: 迭代 freq 中每一個 (label, count) // 對每個任務類別做分析  \n  Yes → Step 4: 若 count > maxFreq? // 判斷是否為新的最大值  \n   Yes → Step 5: maxFreq ← count // 更新最大頻率  \n     countMax ← 1 // 重新開始計算擁有此最大頻率的任務數量  \n   No  → Decision: 若 count = maxFreq? // 是否與目前最大頻率相同  \n    Yes → Step 6: countMax ← countMax + 1 // 增加相同最大頻率的任務種類數  \n    No → Step 7: // 無須做任何事  \n→ Step 8: idleSlots ← (maxFreq - 1) * (n + 1) - countMax // 計算理論上必須的閒置時間  \n→ Decision: idleSlots < 0? // 若計算出的閒置時間為負數，表示不需要閒置  \n  Yes → Step 9: idleSlots ← 0 // 將閒置時間設為零  \n  No  → Step 10: // 留下計算出的正閒置時間  \n→ Step 11: totalIntervals ← idleSlots + len(tasks) // 最終所需的 CPU 時間段數  \n→ Step 12: Return totalIntervals // 傳回答案  \nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,3,null,-1,3,4]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, 3, null, -1, 3, 4]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}          # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key: int):\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from its current frequency bucket\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to the next frequency bucket\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used key (and least recently used within that freq)\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data or len(data) < 2:\n        sys.exit(0)\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    cache = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            outputs.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            outputs.append(None)\n        elif op == \"get\":\n            res = cache.get(arg[0])\n            outputs.append(res)\n        else:\n            outputs.append(None)\n\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to design and implement an LFUCache with O(1). Must output lines with \"虛擬碼步驟 // 解釋\". Use arrow, Start, End, Decision etc. The steps include initialization, get, put, helper to update freq, eviction, etc. Provide each line. Let's outline high-level algorithm: maintain maps: key->(value,freq). freq->LinkedHashSet of keys for LRU within same freq. minFreq track lowest freq. On get: if key not exist return -1; else increment freq: remove from old freq set, add to new freq set, if old set empty and freq==minFreq, increment minFreq. return value. On put: if capacity 0 return; if key exists: update value, then call get to increment freq. else if cache size==capacity: evict key from minFreq freq set's first element (LRU) remove from maps. Insert new key with freq 1, add to freq map, minFreq=1. Complexity O(1). We'll produce virtual code step by step.\n\nWe need to include steps for initialization, get, put, update frequency, eviction. We'll create pseudo code lines with arrows. Each line has comment.\n\nLet's produce as per format. Use \"Start // 程式開始執行\". Then \"→ Step: ...\". We might need to separate functions: \"Start\", \"→ Initialize LFUCache\", etc.\n\nLet's craft:  \n\n1. Start  \n2. → Step: 定義 LFUCache 類別，包含容量 cap、字典 keyMap、字典 freqMap、最小頻率 minFreq  \n3. → Step: Constructor(capacity) 初始化各變數並設 minFreq=0  \n4. → Step: 定義內部方法 updateFreq(key)  \n5. → Decision: key 是否存在於 keyMap?  \n    - Yes → Step: 取得舊頻率 oldFreq，計算新頻率 newFreq = oldFreq+1  \n    - Step: 移除 key 從 freqMap[oldFreq] 集合  \n    - Step: 若 freqMap[oldFreq] 為空且 oldFreq==minFreq，則 minFreq++  \n    - Step: 若 freqMap[newFreq] 不存在，初始化為空 LinkedHashSet  \n    - Step: 把 key 加入 freqMap[newFreq]  \n    - Step: 更新 keyMap[key] 的頻率為 newFreq  \n    - No → Step: （此情況不會在 updateFreq 呼叫時發生）  \n6. → Step: get(key)  \n7. → Decision: key 是否存在於 keyMap?  \n    - Yes → Step: 調用 updateFreq(key)  \n    - Step: 返回 keyMap[key].value  \n    - No → Step: 返回 -1  \n8. → Step: put(key,value)  \n9. → Decision: capacity 為 0?  \n    - Yes → Step: 直接返回（不做任何處理）  \n10. → Decision: key 是否已存在於 keyMap?  \n    - Yes → Step: 更新 keyMap[key].value 為 value  \n    - Step: 調用 updateFreq(key)  \n    - No → Decision: cache 大小 == capacity?  \n        - Yes → Step: 從 freqMap[minFreq] 取出最舊的 key (iterator.next)  \n        - Step: 從 keyMap 刪除該 key  \n        - Step: 從 freqMap[minFreq] 刪除該 key  \n        - Step: 若 freqMap[minFreq] 為空，保持 minFreq=1（後面會設定）  \n        - No → Step: （不做 eviction）  \n    - Step: 在 keyMap 插入 key 的 (value, freq=1)  \n    - Step: 若 freqMap[1] 不存在，初始化為空 LinkedHashSet  \n    - Step: 把 key 加入 freqMap[1]  \n    - Step: 設置 minFreq=1  \n10. End // 程式結束\n\nBut we need each line as \"虛擬碼步驟 // 解釋\". Use arrow for steps: \"→\". Use \"Decision:\" for branching.\n\nLet's produce each line as separate line. For decision we include indent lines. Eg:\n\n→ Decision: key 是否存在於 keyMap?  \n    Yes → Step: ...  \n    No → Step: ...\n\nNeed each line with explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義 LFUCache 類別，包含容量 capacity、鍵值映射 keyMap、頻率映射 freqMap、最小頻率 minFreq  \n→ Step: Constructor(capacity) 初始化 capacity、keyMap 為空字典、freqMap 為空字典、minFreq = 0  \n→ Step: 定義內部方法 updateFreq(key) 用以將 key 的頻率提升 1  \n    → Decision: key 是否存在於 keyMap?  \n        Yes → Step: 取得舊頻率 oldFreq ← keyMap[key].freq  \n        Yes → Step: 計算新頻率 newFreq ← oldFreq + 1  \n        Yes → Step: 從 freqMap[oldFreq] 移除 key  \n        Yes → Step: 若 freqMap[oldFreq] 為空且 oldFreq == minFreq，則 minFreq ← minFreq + 1  \n        Yes → Step: 若 freqMap[newFreq] 不存在，初始化為空 LinkedHashSet  \n        Yes → Step: 將 key 加入 freqMap[newFreq]  \n        Yes → Step: 更新 keyMap[key].freq ← newFreq  \n        No → Step: （updateFreq 呼叫時 key 肯定存在，故不處理）  \n→ Step: get(key)  \n    → Decision: key 是否存在於 keyMap?  \n        Yes → Step: 調用 updateFreq(key)  \n        Yes → Step: 回傳 keyMap[key].value  \n        No → Step: 回傳 -1  \n→ Step: put(key, value)  \n    → Decision: capacity == 0?  \n        Yes → Step: 直接返回（無法存儲任何元素）  \n    → Decision: key 是否存在於 keyMap?  \n        Yes → Step: 更新 keyMap[key].value ← value  \n        Yes → Step: 調用 updateFreq(key)  \n        No → Decision: keyMap 大小 == capacity?  \n            Yes → Step: 從 freqMap[minFreq] 取得最舊的 key（iterator.next）  \n            Yes → Step: 從 keyMap 刪除該 key  \n            Yes → Step: 從 freqMap[minFreq] 刪除該 key  \n            Yes → Step: （若 freqMap[minFreq] 仍不為空，minFreq 保持不變；若為空，等下會重設為 1）  \n            No → Step: （不需要 evict）  \n        No → Step: 在 keyMap 插入 key 的 (value, freq = 1)  \n        No → Step: 若 freqMap[1] 不存在，初始化為空 LinkedHashSet  \n        No → Step: 將 key 加入 freqMap[1]  \n        No → Step: 設定 minFreq ← 1  \nEnd // 程式執行結束"
    },
    {
      "title": "Shortest Completing Word",
      "source_file": "Leetcode/leetcode748.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]",
          "expected_output": "\"steps\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'steps'\nGot (Norm):      'step\",\"steps\",\"stripe\",\"stepple'\n--- (Raw) ---\nRaw Expected: '\"steps\"'\nRaw Got:      '\"step\",\"steps\",\"stripe\",\"stepple\"'"
        },
        {
          "example_index": 1,
          "input": "licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"]",
          "expected_output": "\"pest\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'pest'\nGot (Norm):      'looks\",\"pest\",\"stew\",\"show'\n--- (Raw) ---\nRaw Expected: '\"pest\"'\nRaw Got:      '\"looks\",\"pest\",\"stew\",\"show\"'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def shortestCompletingWord(self, licensePlate: str, words: list[str]) -> str:\n        # Count letters in licensePlate (case‑insensitive, ignore non‑letters)\n        plate_count = Counter(c.lower() for c in licensePlate if c.isalpha())\n        result = None\n        for word in words:\n            word_count = Counter(word.lower())\n            # Check if word contains all required letters in required frequency\n            if all(word_count[char] >= plate_count[char] for char in plate_count):\n                if result is None or len(word) < len(result):\n                    result = word\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input in the format:\n        licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]\n    Returns (licensePlate, words_list)\n    \"\"\"\n    pattern = r'licensePlate\\s*=\\s*\"([^\"]*)\",\\s*words\\s*=\\s*\\[([^\\]]*)\\]'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"Input format not recognized.\")\n    license_plate = match.group(1)\n    words_part = match.group(2)\n\n    # Split words, removing surrounding quotes and whitespace\n    words = []\n    for w in re.split(r',(?![^\"]*\")', words_part):\n        w = w.strip().strip('\"').strip(\"'\")\n        if w:\n            words.append(w)\n    return license_plate, words\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    license_plate, words_list = parse_input(raw_input)\n    sol = Solution()\n    answer = sol.shortestCompletingWord(license_plate, words_list)\n    # Print the result surrounded by double quotes as in the examples\n    print(f'\"{answer}\"')",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code algorithm. Input: licensePlate string, words array. We ignore non-letters, case-insensitive, count frequency of letters in licensePlate. Then find shortest word that covers these counts. If multiple same length, choose first. We'll output steps accordingly. Use Start, End, Decision, etc. Provide explanation. Use arrow formatting as requested. No actual code, just pseudocode steps. Each line: \"虛擬碼步驟 // 解釋\". Include indentation maybe? Format example: Start // 程式開始執行. Use → Step 1: ... etc. Ensure each line includes step and explanation. Let's craft. We'll need steps: parse licensePlate -> build frequency map. Then iterate words, filter by length then check if word satisfies frequency, keep shortest. Implementation wise: We'll maintain minLen = inf, result = \"\". For each word in words: if len(word) >= minLen skip? Actually need to find shortest. We'll check word length less than current minLen, else skip. Then check if word covers freq. If yes and len(word) < minLen -> update. If len equal to minLen, keep first found earlier due to iteration order, so no need to update. Finally return result. Provide decisions for each word: If word length < minLen? Actually start with minLen = large. For each word: Decision: Is length >= minLen? If yes -> skip? But we want shortest, so we only consider if length < minLen. But if equal, we keep earlier. So decision: If length < minLen → check frequencies. Else skip. So algorithm steps: parse licensePlate into freq map. Then init minLen = Infinity, result = \"\". Then for each word in words: Decision: if len(word) < minLen? Yes -> Step: Build word frequency map. Decision: word covers licensePlate freq? Yes -> Update minLen and result. No -> continue. If len(word) >= minLen: skip. End loop. End // 返回結果.\n\nAlso need to handle case-insensitive: convert licensePlate to lower-case, same for words.\n\nLet's produce pseudocode. Use arrow lines. Provide explanation after //.\n\nBe careful: In pseudocode, we can use \"→ Step 1: ...\" etc. Use indentation for nested decisions? Example in spec: they used indentation for decisions: Decision: If...; Yes → ... No → ... etc. We will follow similar.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 licensePlate 轉成小寫，並只保留字母 // 對輸入進行字元過濾與大小寫統一  \n→ Step 2: 建立 licenseFreq 字典，計算 licensePlate 中每個字母的出現頻率 // 用於後續比對  \n\n→ Step 3: 初始化 minLen = ∞，result = \"\" // 用於追蹤目前最短的符合條件的字  \n→ Step 4: 遍歷 words 陣列  \n    → Decision: 如果 len(word) < minLen? // 僅考慮更短或同長度（首次出現）的字  \n        Yes → Step 5: 將 word 轉成小寫，並建立 wordFreq 字典計算字母頻率 // 準備頻率比對  \n        → Decision: wordFreq 是否覆蓋 licenseFreq? // 檢查每個字母至少出現所需次數  \n            Yes → Step 6: minLen = len(word)，result = word // 更新最短符合條件的字  \n            No  → Step 7: 不做任何事，繼續下一個 word // 字不符合要求  \n        No  → Step 8: 跳過此 word，繼續下一個 word // 字太長，無法成為最短答案  \n\n→ Step 9: 返回 result // 完成最短符合條件的字的選取  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,0,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null,1,0,1,1,1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Wrap the input to make it a valid JSON array of two elements\n    ops_and_args = json.loads('[' + data + ']')\n    ops, args = ops_and_args\n\n    res = []\n    sol = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            sol = Solution(arg[0])   # constructor receives a list like [1] or [1,3]\n            res.append(None)\n        elif op == \"pickIndex\":\n            res.append(sol.pickIndex())\n    # Convert None to null and remove spaces for exact formatting\n    output = json.dumps(res).replace(' ', '')\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode with explanation after each line. The user described a typical weighted random selection problem: build prefix sum array, use random number in [1, total], binary search. Provide functions: constructor to build prefix sum; pickIndex function. Use structure. Provide \"Start\" and \"End\". Provide steps. We must use arrow \"→\" for steps, \"Decision:\" for conditions. Provide explanation after each line.\n\nWe need to output in Chinese Traditional. Use // 解釋/說明. Each line: virtual code + space + // explanation. No actual code.\n\nWe'll structure:\n\nStart\n→ Step 1: 建立前綴和陣列 prefix // 轉換權重為累積和\n→ Step 2: 計算總重量 total = prefix[last] // 取得總權重\n→ Decision: 如果 total == 0? // 檢查是否為空\n   Yes → End // 若無權重，直接結束\n   No  → continue\n→ Step 3: 產生隨機整數 r 於 1 到 total 之間 // 以總重量為範圍\n→ Decision: 二分搜尋 r 在 prefix 中的位置 // 找到符合條件的索引\n   Yes → Step 4: 回傳該索引 // 返回選擇的索引\n   No  → Step 5: （若沒有則迴圈尋找） // 處理邏輯\n\nBut we need more structured: use Decision and Yes/No.\n\nBetter approach: implement binary search as sub-step.\n\nLet's produce a more detailed algorithm:\n\nStart\n→ Step 1: 將輸入陣列 w 存入 class 變數 // 保存原始權重\n→ Step 2: 初始化前綴和陣列 prefix 長度 = w.length // 用於快速查找\n→ Step 3: 前綴和累加: for i 0 to w.length-1: prefix[i] = (i==0? w[0] : prefix[i-1] + w[i]) // 計算累積\n→ Step 4: 計算 total = prefix[w.length-1] // 總重量\n→ Step 5: pickIndex() 函數\n   → Step 5.1: 產生隨機 r 於 1 到 total\n   → Step 5.2: 二分搜尋 r 在 prefix 中最小 index // 取得索引\n   → Step 5.3: 回傳 index\n\nWe need to include decision steps for binary search. Provide decision for each iteration.\n\nLet's create pseudo code with loops and decisions. Use \"Decision:\" lines.\n\nWe need to output in the format with each line as \"虛擬碼步驟 // 解釋\".\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 儲存輸入陣列 w // 這是權重來源  \n→ Step 2: 建立前綴和陣列 prefix，長度 = w.length // 用來快速定位權重區間  \n→ Step 3: 前綴和累積  \n    → Decision: 迴圈 i 從 0 到 w.length-1? // 逐一處理每個權重  \n        Yes → Step 3.1: prefix[i] ← (i == 0 ? w[0] : prefix[i-1] + w[i]) // 計算累積和  \n        No  → End of Loop // 完成前綴和建構  \n→ Step 4: total ← prefix[w.length-1] // 取得總重量  \n→ Decision: total == 0? // 檢查是否有可選項  \n    Yes → End // 若無權重，直接結束  \n    No  → Continue  \n\n// --------------- pickIndex() 函式 ---------------\n→ Step 5: pickIndex()  \n    → Step 5.1: 產生隨機整數 r 於 [1, total] 之間 // 確保每個區間對應權重比例  \n    → Step 5.2: BinarySearch(r, prefix)  \n        → Decision: 低 = 0, 高 = prefix.length - 1? // 初始化二分搜尋  \n            Yes → Step 5.2.1: 迴圈 while 低 < 高? // 計算中點  \n                Yes → Step 5.2.1.1: 中 = (低 + 高) // 2  \n                Yes → Decision: prefix[中] < r?  \n                    Yes → Step 5.2.1.2: 低 ← 中 + 1 // r 在右半區  \n                    No  → Step 5.2.1.3: 高 ← 中 // r 在左半區（含中）  \n                No  → End of Loop // 二分搜尋完成  \n            No  → End of Loop  \n        → Step 5.2.2: 回傳 低 // low 即為符合 r 的索引  \n    → Step 5.3: 回傳該索引 // pickIndex 的結果  \n\nEnd // 程式執行結束"
    }
  ]
}