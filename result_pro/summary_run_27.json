{
  "run_index": 27,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 396,
  "generation_or_validation_failure_count": 43,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[1,2,4,1,4]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[1, 2, 4, 1, 4]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰子，回傳所有結果的列表。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\ndef main():\n    \"\"\"\n    從標準輸入讀取程式碼，並在全域命名空間中執行。\n    這樣可以處理像 'print(roll_dice(5))' 之類的輸入。\n    \"\"\"\n    code = sys.stdin.read()\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe user wants virtual code for a function roll_dice(n) using random module, simulate rolling n six-sided dice, return list of results. Need to output step-by-step virtual code with explanations. Use structure with Start, End, Decision, etc. No actual code, just pseudo steps.\n\nLet's produce steps:\n\nStart // program start\n→ Step 1: 定義函式 roll_dice(n) // 定義函式\n→ Step 2: 初始化結果列表 results = [] // 空列表\n→ Step 3: 初始化計數 i = 0 // 計數器\n→ Decision: 如果 i < n? // 循環判斷\n    Yes → Step 4: 生成隨機數 random_value = random.randint(1,6) // 擲骰\n    → Step 5: 將 random_value 加入 results // 收集結果\n    → Step 6: i = i + 1 // 進位\n    → Return to Decision\n    No → Step 7: 返回 results // 函式返回\nEnd // 程式結束\n\nAlso maybe include import random at start.\n\nLet's output accordingly. Use virtual arrows. Ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". The arrow lines start with \"→\". The Decision lines with \"Decision:\" and indent sub-steps. Use \"Yes →\" and \"No →\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: import random // 匯入 random 模組以便產生隨機數  \n→ Step 2: Define Function roll_dice(n) // 定義 roll_dice 函式，參數為擲骰次數  \n→ Step 3: results ← [] // 建立空列表以儲存所有擲骰結果  \n→ Step 4: i ← 0 // 初始化計數器 i 為 0  \n→ Decision: i < n? // 判斷是否已擲完 n 次骰子  \n  Yes → Step 5: value ← random.randint(1, 6) // 產生 1~6 的隨機整數  \n  → Step 6: results.append(value) // 把骰子結果加入結果列表  \n  → Step 7: i ← i + 1 // 計數器加一，繼續下一次擲骰  \n  → Decision: i < n? // 再次檢查是否需要繼續擲骰  \n    Yes → 回到 Step 5  \n    No → Step 8: return results // 所有擲骰結束，返回結果列表  \n  No → Step 8: return results // 直接返回空列表（n 為 0 時）  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量 func 執行所需的秒數，並回傳四捨五入到小數點 3 位的結果。\n    \"\"\"\n    start = time.time()          # 執行前時間戳\n    func(*args)                  # 呼叫目標函式\n    end = time.time()            # 執行後時間戳\n    return round(end - start, 3) # 回傳經過四捨五入的秒數\n\nif __name__ == \"__main__\":\n    import sys\n    # 讀取標準輸入的所有內容，通常是一段 Python 程式碼\n    code = sys.stdin.read()\n    # 在全域命名空間中執行讀取到的程式碼\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to generate virtual code line by line, with explanations. The user wants a function measure_time(func, *args) that uses time module to measure the execution time of func and returns the result rounded to 3 decimal places. So steps: import time, define function, record start time, call func(*args), record end time, compute elapsed, round, return. Also might consider return both result and time? But specification: return result? Wait: \"回傳結果\" likely means return the measured time? Actually \"測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。\" Might mean return elapsed time. Let's produce steps accordingly. Provide virtual code. Use Start End, Decision, etc. Provide explanation after each line.\n\nWe need to be careful: not actual code, just virtual pseudocode. Use arrow notation. Let's produce:\n\nStart\n→ Step 1: Import time module // bring time functions\n→ Step 2: Define function measure_time(func, *args) // start function definition\n    → Step 3: Set start_time ← current time // record start\n    → Step 4: Set result ← func(*args) // call target function\n    → Step 5: Set end_time ← current time // record end\n    → Step 6: Set elapsed ← end_time - start_time // compute duration\n    → Step 7: Set rounded_elapsed ← round(elapsed, 3) // round to 3 decimals\n    → Step 8: Return rounded_elapsed // return measured time\nEnd\n\nBut also we might want to return both result and time? The spec says return the result which is the time. We'll keep that. Provide explanation for each.\n\nLet's output each line with comment. Ensure to use virtual arrows.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Import time module // 引入 time 模組以使用時間函式\n→ Step 2: Define function measure_time(func, *args) // 建立 measure_time 函式，接受目標函式與任意參數\n    → Step 3: Set start_time ← current time // 記錄執行前的時間戳\n    → Step 4: Set result ← func(*args) // 呼叫目標函式並取得其回傳值\n    → Step 5: Set end_time ← current time // 記錄執行後的時間戳\n    → Step 6: Set elapsed ← end_time - start_time // 計算兩個時間戳的差，即執行時間\n    → Step 7: Set rounded_elapsed ← round(elapsed, 3) // 將執行時間四捨五入到小數點三位\n    → Step 8: Return rounded_elapsed // 回傳經過四捨五入後的秒數\nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"melon\",\"grape\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'melon', 'grape', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入（即使目前程式不使用輸入資料，也必須讀取以符合題目要求）\n    _ = sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 使用 add() 新增 'orange'\n    fruits.add('orange')\n\n    # 使用 update() 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 使用 remove() 移除 'banana'\n    fruits.remove('banana')\n\n    # 使用 discard() 嘗試移除 'pineapple'（不存在不會拋錯）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code line by line, each line: \"虛擬碼步驟 // 解釋\" with arrow notation. Use Start, End, Decision: though maybe not necessary for simple steps. Provide each line.\n\nSteps: start, create set, add, update, remove, discard, print set, end.\n\nWe can use arrow notation: → Step: ... but must follow format.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: fruits ← {'apple', 'banana'} // 建立集合 fruits，初始元素為 apple 與 banana\n→ Step 2: fruits.add('orange') // 使用 add() 新增元素 orange 到 fruits\n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 同時新增 grape 與 melon\n→ Step 4: fruits.remove('banana') // 使用 remove() 刪除 banana，若不存在會拋錯\n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試刪除 pineapple，元素不存在時不會拋錯\n→ Step 6: print(fruits) // 輸出最終集合\nEnd // 程式執行結束\n\nMake sure each line has 虛擬碼 step plus // 解釋. We need to use arrow (→). Use Step 1 etc.\n\nWe must not include actual code, only virtual.\n\nOk produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits ← {'apple', 'banana'} // 建立集合 fruits，初始元素為 apple 與 banana  \n→ Step 2: fruits.add('orange') // 使用 add() 新增元素 orange 到 fruits  \n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 同時新增 grape 與 melon  \n→ Step 4: fruits.remove('banana') // 使用 remove() 刪除 banana，若不存在會拋錯  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試刪除 pineapple，元素不存在時不會拋錯  \n→ Step 6: print(fruits) // 輸出最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate():\n    \"\"\"\n    從匯率 API 取得美元對台幣的匯率。\n    成功時回傳浮點數，失敗時回傳 None。\n    \"\"\"\n    url = 'https://api.exchangerate-api.com/v4/latest/USD'\n    try:\n        response = requests.get(url, timeout=5)\n        response.raise_for_status()\n        data = response.json()\n        return data['rates']['TWD']\n    except Exception:\n        return None\n\ndef update_label(label):\n    \"\"\"\n    重新取得匯率並更新 label 的文字。\n    \"\"\"\n    rate = fetch_rate()\n    if rate is not None:\n        label.config(text=f'目前美元匯率：約 {rate} TWD')\n    else:\n        label.config(text='更新失敗，請檢查網路連線')\n\ndef main():\n    \"\"\"\n    主程序：\n    1. 從 stdin 讀取輸入（任何文字皆視為觸發更新）。\n    2. 取得匯率並印出至 stdout。\n    3. 建立 tkinter GUI，並在按鈕點擊時更新匯率。\n    \"\"\"\n    # 讀取 stdin（內容不影響流程，只是觸發更新）\n    _ = sys.stdin.read()\n\n    # 取得匯率並印出結果\n    rate = fetch_rate()\n    if rate is not None:\n        print(f'目前美元匯率：約 {rate} TWD')\n    else:\n        print('更新失敗，請檢查網路連線')\n\n    # 建立 GUI\n    root = tk.Tk()\n    root.title('匯率查詢')\n\n    # 初始 label 文字根據取得的匯率設定\n    initial_text = f'目前美元匯率：約 {rate} TWD' if rate is not None else '更新失敗，請檢查網路連線'\n    label = tk.Label(root, text=initial_text, font=('Arial', 12))\n    label.pack(pady=10)\n\n    # 更新按鈕\n    update_btn = tk.Button(root, text='更新匯率', command=lambda: update_label(label))\n    update_btn.pack(pady=5)\n\n    root.mainloop()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode lines for the described program: use requests to fetch exchange rate API, parse JSON to get TWD rate, display in Tkinter window, have button to update.\n\nWe must output lines with virtual code plus explanation.\n\nNo actual code, only virtual steps.\n\nWe need to use arrows, Decision, Start, End. Let's craft steps:\n\nStart\n→ Import requests and tkinter modules // load required modules\n→ Define function fetch_rate() // function to get exchange rate\n    → Send GET request to API URL // fetch data\n    → If response status 200? // check success\n        Yes → Parse JSON // get data\n        → Extract rate for TWD // store rate\n        → Return rate\n        No → Return 'Error' // error handling\n→ Define function update_display() // called by button\n    → Call fetch_rate() // get latest rate\n    → Update label text with rate // show to user\n→ Create Tk root window // main window\n→ Create label widget // to display rate\n→ Create button widget with command update_display // triggers update\n→ Place widgets in window // layout\n→ Call update_display() // initial load\n→ Start mainloop // run GUI\n\nEnd\n\nBut need to follow format exactly: each line has virtual code step then // explanation. Use arrows.\n\nUse \"→\" for steps. \"Decision:\" lines. Use \"Start\", \"End\".\n\nWe need to be careful with indentation and arrow formatting.\n\nWe need to include Decision lines.\n\nLet's produce.\n\nWe will do:\n\nStart // 程式開始執行\n→ Import modules: requests, tkinter // 取得所需模組\n→ Define fetch_rate() // 定義取得匯率的函式\n    → Decision: 是否成功發送 GET 請求? // 檢查網路請求是否成功\n        Yes → Parse JSON response // 解析回傳的 JSON\n            → Extract TWD rate from JSON // 取得台幣匯率\n            → Return rate // 回傳匯率值\n        No → Return error message // 回傳錯誤訊息\n→ Define update_display() // 定義按鈕觸發更新的函式\n    → Call fetch_rate() // 取得最新匯率\n    → Update label text with rate // 將匯率顯示在標籤上\n→ Create Tk root window // 建立 Tkinter 視窗\n→ Create Label widget to show rate // 標籤用於顯示匯率\n→ Create Button widget with command update_display // 按鈕用於更新匯率\n→ Pack/Place widgets in window // 佈局 widgets\n→ Call update_display() // 初始載入匯率\n→ Start mainloop // 啟動 GUI 事件迴圈\nEnd // 程式結束\n\nBut we must ensure arrow usage properly. Each step must be on its own line with virtual code plus explanation.\n\nAlso we must indicate arrows properly. Indent for nested lines: maybe we use tabs or spaces but not necessary.\n\nWe need to use \"→\" for each step line. For decision we use \"Decision:\". Use \"Yes →\", \"No →\".\n\nThe decision part must be nested. Eg:\n\n→ Decision: 是否成功發送 GET 請求? // 檢查網路請求是否成功\n    Yes → Parse JSON response // 解析回傳的 JSON\n        → Extract TWD rate from JSON // 取得台幣匯率\n        → Return rate // 回傳匯率值\n    No → Return error message // 回傳錯誤訊息\n\nWe might need to include arrow for each line after the decision: \"Yes →\" and \"No →\".\n\nBut \"Parse JSON response\" is a step; we need to add arrow before \"Parse JSON response\". We can do:\n\n    Yes → Parse JSON response // 解析回傳的 JSON\n        → Extract TWD rate from JSON // 取得台幣匯率\n        → Return rate // 回傳匯率值\n\nAlternatively, maybe indent each line after Yes or No.\n\nLet's produce final output accordingly.\n\nLet's produce each line with arrow, but for decisions, the line after decision maybe need to be indented and also start with arrow. Use consistent indentation maybe 4 spaces.\n\nAlso we need to keep the explanation after // in Chinese.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Import modules: requests, tkinter // 取得所需模組\n→ Define fetch_rate() // 定義取得匯率的函式\n    → Decision: 是否成功發送 GET 請求? // 檢查網路請求是否成功\n        Yes → Parse JSON response // 解析回傳的 JSON\n            → Extract TWD rate from JSON // 取得台幣匯率\n            → Return rate // 回傳匯率值\n        No → Return error message // 回傳錯誤訊息\n→ Define update_display() // 定義按鈕觸發更新的函式\n    → Call fetch_rate() // 取得最新匯率\n    → Update label text with rate // 將匯率顯示在標籤上\n→ Create Tk root window // 建立 Tkinter 視窗\n→ Create Label widget to show rate // 標籤用於顯示匯率\n→ Create Button widget with command update_display // 按鈕用於更新匯率\n→ Pack/Place widgets in window // 佈局 widgets\n→ Call update_display() // 初始載入匯率\n→ Start mainloop // 啟動 GUI 事件迴圈\nEnd // 程式結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        # 列表存儲元素，字典映射元素到其在列表中的索引\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        # 若元素已存在，插入失敗\n        if val in self.val_to_index:\n            return False\n        # 將新元素加入末尾\n        self.values.append(val)\n        # 記錄其索引\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        # 若元素不存在，刪除失敗\n        if val not in self.val_to_index:\n            return False\n        # 取得要刪除元素的索引\n        idx = self.val_to_index[val]\n        # 取出列表最後一個元素\n        last_val = self.values[-1]\n        # 用最後一個元素覆蓋要刪除的位置\n        self.values[idx] = last_val\n        # 更新最後一個元素的新索引\n        self.val_to_index[last_val] = idx\n        # 移除最後一個元素\n        self.values.pop()\n        # 刪除字典條目\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        # 隨機返回列表中的一個元素\n        return random.choice(self.values)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入，得到操作列表和參數列表\n    ops, args = ast.literal_eval(data)\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            results.append(None)\n        elif op == \"insert\":\n            results.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            results.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            results.append(obj.getRandom())\n        else:\n            # 未知操作，輸出 None\n            results.append(None)\n\n    # 輸出結果，使用 JSON 格式以匹配題目要求\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to generate pseudo-code lines with explanations for a RandomizedSet class implementing insert, remove, getRandom in average O(1). Use data structures: array/list for values, hash map from value to index in array. Each operation: insert: if val in map return false; else append to array, set map[val]=len(array)-1; return true. remove: if val not in map return false; else get index; last element = array[-1]; swap array[idx] with last; update map[last]=idx; pop last; delete map[val]; return true. getRandom: random index from 0 to len(array)-1; return array[idx].\n\nNow produce pseudocode lines with explanation. Each line must include \"→\" for steps, \"Decision:\" lines, etc. Need to separate operations maybe as separate procedures: insert, remove, getRandom. Should also show initialization.\n\nWe produce lines starting with Start etc.\n\nLet's produce structure:\n\nStart // initialize data structures\n→ Step 1: values = [] // list to store elements\n→ Step 2: indices = {} // map from value to its index in values\n\nThen for insert(val):\n→ Step 1: Decision: 如果 val 已存在 indices? // check presence\n    Yes → Step 2: return False // already present\n    No  → Step 3: Append val to values // add\n    → Step 4: indices[val] = len(values)-1 // record index\n    → Step 5: return True // success\n\nSimilarly remove(val):\n→ Step 1: Decision: 如果 val 不在 indices? // not present\n    Yes → Step 2: return False\n    No  → Step 3: idx = indices[val] // current index\n    → Step 4: last = values[-1] // last element\n    → Step 5: Swap values[idx] and last // put last into idx\n    → Step 6: indices[last] = idx // update last's index\n    → Step 7: values.pop() // remove last\n    → Step 8: delete indices[val] // remove mapping\n    → Step 9: return True\n\ngetRandom:\n→ Step 1: n = len(values) // number of elements\n→ Step 2: idx = RandomInt(0, n-1) // random index\n→ Step 3: return values[idx] // return random element\n\nWrap with End.\n\nBut requirement: each line must contain \"虛擬碼步驟\" plus explanation. Provide arrow \"→\" or \"Start\" etc. Should be sequential. Should include nested decision lines with indentation maybe with indentation spaces. Use \"Yes →\" and \"No →\" on same line after decision? In example they indent and use \"Yes →\" and \"No →\" lines. We'll follow.\n\nAlso each step needs \"Step X:\" maybe but not necessary. Provide clear.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: values = [] // 建立空列表以儲存集合中的元素  \n→ Step 2: indices = {} // 建立空哈希表以映射值到其在列表中的索引\n\n// -------------------- insert 方法 --------------------\n→ Step 3: Decision: 如果 indices 已包含 key val? // 檢查值是否已存在  \n  Yes → Step 4: return False // 已存在，插入失敗  \n  No  → Step 5: values.append(val) // 將新值加入列表  \n    → Step 6: indices[val] = len(values) - 1 // 記錄其索引  \n    → Step 7: return True // 插入成功  \n\n// -------------------- remove 方法 --------------------\n→ Step 8: Decision: 如果 indices 不包含 key val? // 檢查值是否存在  \n  Yes → Step 9: return False // 不存在，刪除失敗  \n  No  → Step 10: idx = indices[val] // 取得要移除值的索引  \n    → Step 11: last = values[-1] // 取得列表最後一個元素  \n    → Step 12: values[idx] = last // 用最後一個元素覆蓋要刪除的位置  \n    → Step 13: indices[last] = idx // 更新最後一個元素的新索引  \n    → Step 14: values.pop() // 移除列表最後一個元素  \n    → Step 15: del indices[val] // 刪除對應的哈希表條目  \n    → Step 16: return True // 刪除成功  \n\n// -------------------- getRandom 方法 --------------------\n→ Step 17: n = len(values) // 獲取目前元素個數  \n→ Step 18: idx = RandomInt(0, n - 1) // 隨機產生合法索引  \n→ Step 19: return values[idx] // 以相同機率返回隨機元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfsv03uaw.py\", line 64, in <module>\n    main()\n  File \"/tmp/tmpfsv03uaw.py\", line 52, in main\n    obj.buildDict(arg)\n  File \"/tmp/tmpfsv03uaw.py\", line 19, in buildDict\n    pattern = word[:i] + '*' + word[i+1:]\n              ~~~~~~~~~^~~~~\nTypeError: can only concatenate list (not \"str\") to list"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict\n\nclass MagicDictionary:\n    \"\"\"\n    MagicDictionary 使用萬用字串 (wildcard) 建構映射表，能在 O(L) 時間內判斷是否存在只改一個字母能匹配的單字。\n    \"\"\"\n    def __init__(self):\n        # mapping: pattern -> set of words that match this pattern\n        self.pattern_dict = defaultdict(set)\n\n    def buildDict(self, dictionary):\n        \"\"\"\n        為每個單字建立所有位置上帶 '*' 的萬用字串，並將單字加入對應集合。\n        \"\"\"\n        for word in dictionary:\n            for i in range(len(word)):\n                pattern = word[:i] + '*' + word[i+1:]\n                self.pattern_dict[pattern].add(word)\n\n    def search(self, searchWord):\n        \"\"\"\n        對 searchWord 的每個位置建立萬用字串，檢查對應集合中是否存在除了自身以外的單字。\n        \"\"\"\n        for i in range(len(searchWord)):\n            pattern = searchWord[:i] + '*' + searchWord[i+1:]\n            if pattern in self.pattern_dict:\n                for candidate in self.pattern_dict[pattern]:\n                    if candidate != searchWord:\n                        return True\n        return False\n\ndef main():\n    # 讀取整個 stdin，並解析為兩個列表：commands 與 args\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把 \"], [\" 替換成 \"],[\"，使之能被 json 解析為兩個列表\n    data = data.replace('], [', '],[')\n    # 把整體包裝成一個外層列表，方便 json.loads\n    data = '[' + data + ']'\n    commands, args = json.loads(data)\n\n    res = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MagicDictionary\":\n            obj = MagicDictionary()\n            res.append(None)            # constructor returns null\n        elif cmd == \"buildDict\":\n            obj.buildDict(arg)\n            res.append(None)            # buildDict returns null\n        elif cmd == \"search\":\n            res.append(obj.search(arg))\n        else:\n            # 其他命令可忽略或拋錯\n            res.append(None)\n\n    # 輸出結果，使用 json.dumps 以得到 null/true/false 格式\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step. It's a data structure problem. The algorithm: we can build a trie or store words. For search: for each word in dictionary, check if exactly one char differs. But efficient: precompute all patterns with one wildcard. Approach: Build map from pattern to set of words. For each word, for each position i, create pattern with wildcard (like replace i with '*') and store mapping. Then search: for each position i, pattern = searchWord with '*' at i, check if mapping contains any word that differs from searchWord exactly one char. Need to ensure not counting same word with same pattern? If searchWord itself present, we need to check that other word exists. We'll store map pattern → set of words. In search, iterate positions, pattern. For each word in set, if word != searchWord, return true. Complexity fine.\n\nLet's produce virtual code. Steps:\n\nStart\n→ Step 1: 定義 MagicDictionary 類別\n→ Step 2: 建構子: 初始化 mapping 為空字典\n→ Step 3: buildDict: 對於每個單字\n    → Step 4: 對於每個位置 i\n        → Step 5: 產生 pattern: 替換第 i 個字元為 '*'\n        → Step 6: 若 pattern 不在 mapping，則新增空集合\n        → Step 7: 將單字加入 mapping[pattern] 的集合\n→ Step 8: search: 定義函式 searchWord\n    → Step 9: 對於每個位置 i\n        → Step 10: 產生 pattern: 替換第 i 個字元為 '*'\n        → Step 11: 若 pattern 在 mapping\n            → Step 12: 對於每個 word 在 mapping[pattern]\n                → Step 13: 若 word != searchWord，回傳 true\n    → Step 14: 回傳 false\nEnd\n\nAdd comments. Use arrows.\n\nLet's output lines accordingly. Use 虛擬碼步驟 + // explanation. Use arrow with indentation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MagicDictionary 類別 // 宣告一個類別以存放字典與查詢功能  \n→ Step 2: 建構子: 初始化 mapping 為空字典 // mapping 用來存儲「萬用字串 → 能匹配之單字集合」  \n→ Step 3: buildDict(String[] dictionary)  \n    → Step 4: 對於每個單字 word 在 dictionary  \n        → Step 5: 對於每個位置 i 從 0 到 word.length-1  \n            → Step 6: 產生 pattern = word 的第 i 個字元替換為 '*' // 形成一個「一字母可變」的萬用字串  \n            → Step 7: 若 mapping 中不存在 pattern，則 mapping[pattern] ← 空集合 // 初始此萬用字串的集合  \n            → Step 8: mapping[pattern] 加入 word // 將原單字加入對應萬用字串的集合  \n→ Step 9: search(String searchWord)  \n    → Step 10: 對於每個位置 i 從 0 到 searchWord.length-1  \n        → Step 11: 產生 pattern = searchWord 的第 i 個字元替換為 '*' // 生成可能符合的萬用字串  \n        → Step 12: 若 pattern 存在於 mapping  \n            → Step 13: 對於每個候選單字 candidate 在 mapping[pattern]  \n                → Step 14: 若 candidate ≠ searchWord，則返回 true // 找到至少一個不同單字，滿足「只改一字母」  \n    → Step 15: 返回 false // 所有位置都未找到符合條件的單字  \nEnd // 程式執行結束"
    },
    {
      "title": "Heaters",
      "source_file": "Leetcode/leetcode475.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "houses = [1,2,3], heaters = [2]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2_zymjwz.py\", line 34, in <module>\n    result = find_radius(houses, heaters)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2_zymjwz.py\", line 5, in find_radius\n    houses.sort()\n    ^^^^^^^^^^^\nAttributeError: 'tuple' object has no attribute 'sort'"
        },
        {
          "example_index": 1,
          "input": "houses = [1,2,3,4], heaters = [1,4]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwzedur4o.py\", line 34, in <module>\n    result = find_radius(houses, heaters)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwzedur4o.py\", line 5, in find_radius\n    houses.sort()\n    ^^^^^^^^^^^\nAttributeError: 'tuple' object has no attribute 'sort'"
        },
        {
          "example_index": 2,
          "input": "houses = [1,5], heaters = [2]",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdsh5l_vw.py\", line 34, in <module>\n    result = find_radius(houses, heaters)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdsh5l_vw.py\", line 5, in find_radius\n    houses.sort()\n    ^^^^^^^^^^^\nAttributeError: 'tuple' object has no attribute 'sort'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef find_radius(houses, heaters):\n    houses.sort()\n    heaters.sort()\n    max_radius = 0\n    i = 0  # index of the heater currently considered\n    for house in houses:\n        # Move to the heater that is closer to this house\n        while i < len(heaters) - 1 and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):\n            i += 1\n        max_radius = max(max_radius, abs(heaters[i] - house))\n    return max_radius\n\ndef parse_input(data: str):\n    # Split the input into the part before and after 'heaters ='\n    parts = data.split('heaters =', 1)\n    houses_part = parts[0].strip()\n    heaters_part = parts[1].strip() if len(parts) > 1 else '[]'\n    # Extract the list expressions after '='\n    houses_expr = houses_part.split('=', 1)[1].strip()\n    heaters_expr = heaters_part\n    # Safely evaluate the list expressions\n    houses = ast.literal_eval(houses_expr)\n    heaters = ast.literal_eval(heaters_expr)\n    return houses, heaters\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    houses, heaters = parse_input(raw_input)\n    result = find_radius(houses, heaters)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step-by-step for solving the problem. The problem: given arrays houses positions and heaters positions on line, find minimal radius such that all houses covered by at least one heater. Classic problem: For each house, find distance to nearest heater. The maximum of these distances is minimal radius.\n\nWe need to write virtual code in the specified format: Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow symbols and decision structure.\n\nWe need to produce algorithm steps.\n\nLet's design algorithm:\n\n1. Sort houses and heaters.\n2. For each house, find nearest heater via binary search: find index of first heater >= house, then compute min of distances to that heater and previous heater.\n3. Keep track of maximum distance.\n4. Return max distance.\n\nWe need to produce virtual code steps in lines.\n\nWe'll include start, end, decision.\n\nLet's produce code lines like:\n\nStart\n→ Step 1: Sort houses ascending\n→ Step 2: Sort heaters ascending\n→ Step 3: Initialize maxRadius = 0\n→ For each house in houses:\n    → Step 4: Use binary search to find index idx of first heater >= house\n    → Decision: If idx < length of heaters? // If there is heater to right\n        Yes → Step 5: Compute distRight = heaters[idx] - house\n        No  → Step 5: Set distRight = Infinity\n    → Decision: If idx > 0? // If there is heater to left\n        Yes → Step 6: Compute distLeft = house - heaters[idx-1]\n        No  → Step 6: Set distLeft = Infinity\n    → Step 7: nearestDist = min(distLeft, distRight)\n    → Step 8: Update maxRadius = max(maxRadius, nearestDist)\n→ End: Return maxRadius\n\nNeed to use arrows for each line: \"→\". For nested decisions: indent and use Yes → and No →.\n\nLet's produce accordingly. Ensure each line includes \"虛擬碼步驟 // 解釋\". Use comments.\n\nWe must not output actual code but virtual steps. Use Chinese.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort houses ascending // 把所有屋子位置從小到大排序  \n→ Step 2: Sort heaters ascending // 把所有暖氣位置從小到大排序  \n→ Step 3: Initialize maxRadius = 0 // 用來存最大最小距離，最終即為最小半徑  \n→ For each house in houses: // 逐一處理每座屋子  \n  → Step 4: Find idx = first heater index where heater[idx] >= house (binary search) // 找出最接近右側的暖氣  \n  → Decision: 如果 idx < heaters.length? // 是否存在右側暖氣  \n    Yes → Step 5: distRight = heaters[idx] - house // 右側暖氣距離  \n    No  → Step 5: distRight = Infinity // 右側無暖氣，距離無限大  \n  → Decision: 如果 idx > 0? // 是否存在左側暖氣  \n    Yes → Step 6: distLeft = house - heaters[idx - 1] // 左側暖氣距離  \n    No  → Step 6: distLeft = Infinity // 左側無暖氣，距離無限大  \n  → Step 7: nearestDist = min(distLeft, distRight) // 找出此屋子最近的暖氣距離  \n  → Step 8: maxRadius = max(maxRadius, nearestDist) // 更新需要的最大半徑  \n→ End // 程式執行結束，返回 maxRadius 為所有屋子至少被一個暖氣覆蓋的最小半徑"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpoi4vaf5y.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpoi4vaf5y.py\", line 48, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpoi4vaf5y.py\", line 15, in __init__\n    self.lookup[(pre, suf)] = weight  # 只保留最後一次（最大索引）\n    ~~~~~~~~~~~^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    def __init__(self, words):\n        # 建立前綴 + 後綴 → 最大索引 的映射\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            # 產生所有前綴 (含空字串) 與所有後綴 (含空字串)\n            for i in range(L + 1):\n                pre = word[:i]\n                for j in range(L + 1):\n                    suf = word[j:]\n                    self.lookup[(pre, suf)] = weight  # 只保留最後一次（最大索引）\n\n    def f(self, prefix, suffix):\n        # 直接查詢映射，若不存在則回傳 -1\n        return self.lookup.get((prefix, suffix), -1)\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 判斷輸入格式：一行或兩行\n    lines = data.splitlines()\n    if len(lines) == 1:\n        # 一行：把整個字串包裝成 tuple 再 literal_eval\n        try:\n            words, query = ast.literal_eval('(' + data + ')')\n        except Exception as e:\n            # 若解析失敗，直接終止\n            print(-1)\n            return\n    else:\n        # 多行：每行分別為 words 與 query\n        words = ast.literal_eval(lines[0])\n        query = ast.literal_eval(lines[1])\n\n    # query 可能是 ['pref', 'suff'] 或 ('pref', 'suff')\n    if isinstance(query, (list, tuple)) and len(query) >= 2:\n        pref, suff = query[0], query[1]\n    else:\n        pref, suff = '', ''\n\n    wf = WordFilter(words)\n    result = wf.f(pref, suff)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output a step-by-step pseudocode for the design of a special dictionary that supports prefix and suffix search. The WordFilter class has constructor and function f. We need to produce virtual code line by line with explanation, using arrows and structure. We need to propose an algorithm: using a trie for prefixes and suffixes or combined key mapping. Common solution: use a trie of words reversed plus prefix appended. But we can produce a simpler conceptual solution: Preprocess words, for each word, for each prefix length, for each suffix length, store combined key pref + '#' + suff -> index. But we want to be efficient: Use dictionary mapping from combined key to index, updating to max index. Then f just looks up key. Virtual code: Start, initialize map, etc.\n\nWe produce line by line.\n\nLet's design steps:\n\nStart // begin program\n\n→ Step 1: WordFilter(words) // constructor called\n\n→ Decision: 是否有 words? // if words list not empty\n\n   Yes → Step 2: 初始化空字典 keyToIndex // map from key to index\n\n   → For 每個 word, index in words\n\n       → For prefLen from 1 to len(word)\n\n          → prefix = word[0:prefLen]\n\n          → For suffLen from 1 to len(word)\n\n              → suffix = word[-suffLen:]\n\n              → key = prefix + '#' + suffix\n\n              → keyToIndex[key] = max(index, keyToIndex.get(key, -1))\n\n   No → Step 3: keyToIndex remains empty\n\n→ Step 4: 完成初始化\n\n→ End // constructor finished\n\n→ Step 5: f(pref, suff) // method called\n\n→ Decision: key = pref + '#' + suff in keyToIndex? // check existence\n\n   Yes → Step 6: return keyToIndex[key] // return stored index\n\n   No  → Step 7: return -1\n\nEnd // method finished\n\nWe can make this more concise. Provide each line with arrow and comment. Use proper structure.\n\nWe need to output in specified format: Each line \"虛擬碼步驟 // 解釋\". Use arrows and structure. Ensure we include Start and End.\n\nLet's produce.\n\nWe need to include the Decision and Yes/No branches.\n\nMake sure to use '→' arrow at each step.\n\nAlso include nested loops using indentation perhaps, but still each line separate. We can represent loops with \"→ Loop: For ...\".\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: WordFilter(words) // 呼叫建構子，傳入字典詞組  \n→ Decision: words 是否非空？ // 檢查是否有詞可處理  \n  Yes → Step 2: keyToIndex ← 空字典 // 建立鍵值對字典，儲存 (前綴#後綴) → 索引  \n   → Loop: 每個 word, index in words // 逐一處理字典中的每個單字  \n     → Loop: prefLen 從 1 到 len(word) // 生成所有可能的前綴  \n       → prefix ← word[0 : prefLen] // 取得前綴字串  \n       → Loop: suffLen 從 1 到 len(word) // 生成所有可能的後綴  \n         → suffix ← word[-suffLen : ] // 取得後綴字串  \n         → key ← prefix + '#' + suffix // 組合鍵值，使用分隔符避免衝突  \n         → keyToIndex[key] ← max(index, keyToIndex.get(key, -1)) // 只保留最大索引  \n       → End // 循環後綴完成  \n      → End // 循環前綴完成  \n   → End // 循環單字完成  \n  No  → Step 3: keyToIndex ← 空字典 // 若無詞，直接建立空字典  \n→ Step 4: 初始化完成 // 建構子工作結束  \nEnd // 建構子結束執行  \n\n→ Step 5: f(pref, suff) // 呼叫查詢方法，傳入前綴與後綴  \n→ Decision: key = pref + '#' + suff 是否存在於 keyToIndex？ // 判斷鍵是否已被建立  \n  Yes → Step 6: return keyToIndex[key] // 回傳對應最大索引  \n  No  → Step 7: return -1 // 若不存在，回傳 -1  \nEnd // 查詢方法結束執行"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()\"]'"
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        res = set()\n\n        # 先統計需要移除的左括號和右括號數量\n        leftRem = rightRem = 0\n        for ch in s:\n            if ch == '(':\n                leftRem += 1\n            elif ch == ')':\n                if leftRem > 0:\n                    leftRem -= 1\n                else:\n                    rightRem += 1\n\n        # DFS 進行遞迴搜索\n        def dfs(index, leftCount, rightCount, leftRem, rightRem, path):\n            # 若已不需要再移除\n            if leftRem == 0 and rightRem == 0:\n                if leftCount == rightCount:\n                    res.add(path)\n                return\n            if index == len(s):\n                return\n\n            ch = s[index]\n\n            if ch not in ('(', ')'):\n                # 非括號字元直接保留\n                dfs(index + 1, leftCount, rightCount, leftRem, rightRem, path + ch)\n                return\n\n            # 1. 試著移除目前的括號\n            if ch == '(' and leftRem > 0:\n                dfs(index + 1, leftCount, rightCount, leftRem - 1, rightRem, path)\n            elif ch == ')' and rightRem > 0:\n                dfs(index + 1, leftCount, rightCount, leftRem, rightRem - 1, path)\n\n            # 2. 試著保留目前的括號\n            if ch == '(':\n                dfs(index + 1, leftCount + 1, rightCount, leftRem, rightRem, path + ch)\n            else:  # ch == ')'\n                if leftCount > rightCount:\n                    dfs(index + 1, leftCount, rightCount + 1, leftRem, rightRem, path + ch)\n\n        dfs(0, 0, 0, leftRem, rightRem, \"\")\n        return list(res)\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n\n    # 嘗試從輸入中抓取第一個被單引號或雙引號包起來的字串\n    start = end = None\n    for i, ch in enumerate(data):\n        if ch in (\"'\", '\"'):\n            start = i\n            break\n    if start is not None:\n        for j in range(start + 1, len(data)):\n            if data[j] == data[start]:\n                end = j\n                break\n\n    if start is not None and end is not None:\n        s = data[start + 1:end]\n    else:\n        # 若沒有引號，嘗試去除 's = ' 之類的字串\n        if '=' in data:\n            s = data.split('=')[-1].strip()\n        else:\n            s = data\n\n    sol = Solution()\n    result = sol.removeInvalidParentheses(s)\n    # 排序以便輸出順序可預測\n    result.sort()\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for the problem: Remove minimum number of invalid parentheses to make the input string valid, return all unique results.\n\nWe need to output line by line, with virtual code steps and explanation. Use arrow syntax: Start, → Step, Decision: etc.\n\nWe need to design an algorithm. Standard solution: BFS over strings, removing parentheses, until find level with valid strings. Or DFS with backtracking count left removals and right removals.\n\nWe need to output virtual steps.\n\nWe should produce something like:\n\nStart\n→ Step 1: Compute counts of left and right parentheses to remove.\n→ Step 2: DFS function removeRec with parameters string, index, leftCount, rightCount, leftRemove, rightRemove, resultSet.\n→ Decision: if leftRemove==0 and rightRemove==0 -> check validity -> add to resultSet\n→ Decision: if index==len(s) -> return\n→ Decision: if current char not '(' or ')' -> recursive call\n→ Decision: if char '(' and leftRemove>0 -> skip removal\n→ Decision: if char ')' and rightRemove>0 -> skip removal\n→ etc\n\nBut we need to produce virtual code steps for algorithm, not actual code.\n\nLet's structure:\n\nStart\n→ Step 1: Calculate leftRem and rightRem counts of invalid parentheses by scanning string.\n→ Decision: if string already valid? maybe skip? But we can just continue.\n\n→ Step 2: Define recursive helper function dfs(index, leftCount, rightCount, leftRem, rightRem, currentString)\n→ Decision: if leftRem==0 and rightRem==0:\n    → Step: if currentString is valid (leftCount==rightCount) add to results\n→ Decision: if index == len(s): return\n→ Step: let char = s[index]\n→ Decision: if char not '(' or ')':\n    → Step: dfs(index+1, leftCount, rightCount, leftRem, rightRem, currentString+char)\n→ Decision: if char=='(':\n    → Step: // option 1: remove it if leftRem>0\n    → Decision: if leftRem>0:\n        → Step: dfs(index+1, leftCount, rightCount, leftRem-1, rightRem, currentString)\n    → Step: // option 2: keep it\n    → Step: dfs(index+1, leftCount+1, rightCount, leftRem, rightRem, currentString+char)\n→ Decision: if char==')':\n    → Step: // option 1: remove if rightRem>0\n    → Decision: if rightRem>0:\n        → Step: dfs(index+1, leftCount, rightCount, leftRem, rightRem-1, currentString)\n    → Decision: if leftCount>rightCount:\n        → Step: // option 2: keep it\n        → Step: dfs(index+1, leftCount, rightCount+1, leftRem, rightRem, currentString+char)\n→ End\n\nBut we also need to ensure uniqueness: use set.\n\nWe need to output all unique strings.\n\nLet's produce virtual code step by step:\n\nStart // start\n\n→ Step 1: compute leftRem, rightRem // count how many left and right parentheses to remove\n\n→ Step 2: initialize result set // empty set for unique results\n\n→ Step 3: call dfs(0,0,0,leftRem,rightRem,\"\") // start recursion\n\n→ Decision: if leftRem==0 and rightRem==0: // no more removals left\n    → Step 4: if leftCount==rightCount: // balanced\n        → Step 5: add currentString to result set\n    → End\n→ Decision: if index==len(s): // reached end\n    → End\n→ Step 6: ch = s[index]\n→ Decision: if ch not '(' or ')':\n    → Step 7: dfs(index+1,leftCount,rightCount,leftRem,rightRem,currentString+ch)\n    → End\n→ Decision: if ch=='(':\n    → Step 8: if leftRem>0: // remove this '('\n        → Step 9: dfs(index+1,leftCount,rightCount,leftRem-1,rightRem,currentString)\n    → Step 10: dfs(index+1,leftCount+1,rightCount,leftRem,rightRem,currentString+ch)\n→ Decision: if ch==')':\n    → Step 11: if rightRem>0: // remove this ')'\n        → Step 12: dfs(index+1,leftCount,rightCount,leftRem,rightRem-1,currentString)\n    → Decision: if leftCount>rightCount: // keep if balanced so far\n        → Step 13: dfs(index+1,leftCount,rightCount+1,leftRem,rightRem,currentString+ch)\n→ End // after recursion done\n\nFinally, convert set to list and return.\n\nWe also need to show final step: return list(results).\n\nWe should present as virtual steps, not code. So we must keep \"Step X:\" style.\n\nLet's produce lines accordingly.\n\nAlso use arrow '→' for each step line. Use 'Decision:' lines for conditions. Use 'Yes →', 'No →' to indicate branches.\n\nOk.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 s 中多餘的左括號數量 leftRem 以及右括號數量 rightRem // 先統計需移除的括號數  \n→ Step 2: 初始化一個空集合 resultSet 用來儲存唯一的有效字串 // 防止重複結果  \n→ Step 3: 呼叫遞迴函式 dfs(0, 0, 0, leftRem, rightRem, \"\") // 從索引 0 開始遞迴  \n\nDecision: 如果 leftRem == 0 且 rightRem == 0? // 沒有剩餘的移除操作  \n Yes → Step 4: 若 leftCount == rightCount? // 目前字串已平衡  \n   Yes → Step 5: 將 currentString 加入 resultSet // 加入唯一結果  \n   No → End // 字串不平衡，直接結束此路徑  \n No → End // 尚有移除可做，繼續往下處理  \n\nDecision: 如果 index == len(s)? // 已處理完所有字元  \n Yes → End // 直接回傳  \n\nStep 6: 設定 ch = s[index] // 取得目前處理的字元  \n\nDecision: 如果 ch 不是 '(' 或 ')'?  \n Yes → Step 7: dfs(index+1, leftCount, rightCount, leftRem, rightRem, currentString + ch) // 直接保留非括號字元  \n No → End  \n\nDecision: 如果 ch == '('?  \n Yes → Step 8: 若 leftRem > 0? // 可選擇移除此 '('  \n   Yes → Step 9: dfs(index+1, leftCount, rightCount, leftRem-1, rightRem, currentString) // 移除後繼續  \n   No → End  \n   Step 10: dfs(index+1, leftCount+1, rightCount, leftRem, rightRem, currentString + ch) // 保留此 '('  \n No → End  \n\nDecision: 如果 ch == ')'？  \n Yes → Step 11: 若 rightRem > 0? // 可選擇移除此 ')'  \n   Yes → Step 12: dfs(index+1, leftCount, rightCount, leftRem, rightRem-1, currentString) // 移除後繼續  \n   No → End  \n   Decision: 若 leftCount > rightCount? // 只保留能保持平衡的 ')'  \n    Yes → Step 13: dfs(index+1, leftCount, rightCount+1, leftRem, rightRem, currentString + ch) // 保留此 ')'  \n    No → End  \n No → End  \n\nEnd // 所有遞迴路徑結束  \n\nStep 14: 將 resultSet 轉成列表並回傳 // 結果以列表形式回給使用者  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,2]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\nimport ast\n\nclass Solution:\n    def __init__(self, nums):\n        # 直接把每個數字對應的索引存起來，方便隨機挑選\n        self.index_map = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.index_map[num].append(i)\n\n    def pick(self, target):\n        # 隨機挑選 target 的一個索引\n        return random.choice(self.index_map[target])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入包成元組，方便使用 literal_eval 解析\n    data = f\"({data})\"\n    commands, args = ast.literal_eval(data)\n\n    results = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            # 參數是一個列表，裡面只有一個元素為實際的 nums 列表\n            obj = Solution(arg[0])\n            results.append(None)  # 建構子返回 None\n        elif cmd == \"pick\":\n            # pick 的參數也在一個列表中\n            results.append(obj.pick(arg[0]))\n        else:\n            # 若有其他方法，這裡可以按需擴充\n            results.append(None)\n\n    # 把 None 轉成 null 以符合輸出格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanation. The requirement: use virtual code arrow, decision, etc. We must describe the algorithm for this problem: reservoir sampling in pick. The constructor stores nums. In pick: iterate through array, for each index where nums[i]==target, increment count, and with probability 1/count pick the index. Return chosen index. Use random. Provide step by step.\n\nWe must output only the virtual code lines and explanations.\n\nLet's craft:\n\nStart\n→ Step 1: 定義 Solution 類 // 建立類別\n→ Step 2: 定義成員變數 nums // 存儲傳入陣列\n→ Decision: 构造函数? // 接收輸入\n    Yes → Step 3: 接收參數 nums → Step 4: 儲存到成員變數 // 初始化\nEnd // 建構完成\n\nThen pick method:\n\n→ Step 5: 定義 pick(target) 方法 // 入口\n→ Step 6: 初始化 count = 0, result = -1 // 計數與暫存\n→ Step 7: 循環遍歷陣列索引 i 從 0 到 length-1 // 檢查\n    → Decision: nums[i] == target? // 是否符合目標\n        Yes → Step 8: count += 1 // 有效位置計數\n            → Step 9: 產生隨機數 r 在 [1, count] // 產生\n            → Decision: r == 1? // 是否選中\n                Yes → Step 10: result = i // 記錄索引\n                No → No action // 跳過\n        No → No action // 非目標忽略\n→ Step 11: 返回 result // 回傳\n\nEnd\n\nBut we must use arrow notation exactly: `→` preceding each step. Indent decisions maybe. Format: Each line `虛擬碼步驟 // 解釋`.\n\nMake sure each line ends with `// 解釋`. Provide the decision branch lines with indentation but still using `→`? In example, decision lines are indented with 4 spaces? Actually example shows indentation of 4 spaces before Yes/No lines. We'll mimic that: For Decision lines, we need indentation for Yes and No lines.\n\nSo code:\n\nStart // 程式開始執行\n→ Step 1: 定義 Solution 類 // 建立類別\n→ Step 2: 定義成員變數 nums // 存儲傳入陣列\n→ Decision: 构造函数? // 接收初始化參數\n    Yes → Step 3: 接收參數 nums // 取得輸入陣列\n    Yes → Step 4: 儲存到成員變數 nums // 初始化存儲\nEnd // 建構完成\n\nBut we need to separate method definitions. Could use steps for constructor and method.\n\nMaybe better:\n\nStart // 程式開始執行\n→ Step 1: 定義 class Solution // 建立類別\n→ Step 2: 定義成員變數 nums // 用於存儲數組\n→ Step 3: 定義構造函數 Solution(nums) // 初始化\n    → Step 3.1: 設置 this.nums = nums // 保存參數\n→ Step 4: 定義方法 pick(target) // 選擇隨機索引\n    → Step 4.1: 設置 count = 0, result = -1 // 初始化計數器與暫存\n    → Step 4.2: 循環遍歷索引 i 從 0 到 this.nums.length - 1 // 遍歷數組\n        → Decision: this.nums[i] == target? // 判斷是否為目標\n            Yes → Step 4.2.1: count += 1 // 有效位置計數\n            Yes → Step 4.2.2: 生成隨機整數 r 在 [1, count] // 隨機選取\n            Yes → Decision: r == 1? // 判斷是否選中\n                Yes → Step 4.2.3: result = i // 記錄索引\n                No → Step 4.2.4: // 不變，保持前一次選中\n            No → // 跳過非目標元素\n    → Step 4.3: 返回 result // 回傳隨機索引\nEnd // 程式結束\n\nNeed to use arrow formatting like example: decision lines show `Yes →` and `No →`. Use indentation.\n\nThus output should be each line separate. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 class Solution // 建立 Solution 類  \n→ Step 2: 定義成員變數 nums // 用於存儲傳入的整數陣列  \n→ Step 3: 定義構造函數 Solution(nums) // 初始化物件  \n → Step 3.1: 設置 this.nums = nums // 保存傳入的陣列  \n→ Step 4: 定義方法 pick(target) // 隨機選取目標值的索引  \n → Step 4.1: 設置 count = 0, result = -1 // 初始化計數器與暫存索引  \n → Step 4.2: 循環遍歷索引 i 從 0 到 this.nums.length - 1 // 遍歷整個陣列  \n  → Decision: this.nums[i] == target? // 判斷是否為目標值  \n   Yes → Step 4.2.1: count += 1 // 有效位置計數加一  \n   Yes → Step 4.2.2: 生成隨機整數 r 在 [1, count] // 隨機選取  \n   Yes → Decision: r == 1? // 判斷是否選中此索引  \n    Yes → Step 4.2.3: result = i // 記錄被選中的索引  \n    No  → Step 4.2.4: // 不變，保持前一次選中  \n   No  → Step 4.2.5: // 跳過非目標元素  \n → Step 4.3: 返回 result // 回傳最終被選中的隨機索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    \"\"\"\n    生成 nums 的所有排列。使用回溯+交換法。\n    \"\"\"\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []  # 用於存放最終結果\n\n        def backtrack(start):\n            # 如果 start 已經到達 nums 的長度，表示已經選完所有數字\n            if start == len(nums):\n                res.append(nums[:])  # 把目前的排列加入結果\n                return\n            # 遍歷從 start 開始的每個位置，嘗試把它放到目前的 start\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # 交換\n                backtrack(start + 1)  # 進行下一層遞迴\n                nums[start], nums[i] = nums[i], nums[start]  # 回溯，還原交換\n\n        backtrack(0)  # 從第一個位置開始\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個輸入\n    data = sys.stdin.read()\n    # 尋找輸入中的列表字面量\n    l = data.find('[')\n    r = data.rfind(']')\n    if l == -1 or r == -1:\n        nums = []\n    else:\n        # eval 解析 Python 列表字面量，例如 \"[1,2,3]\"\n        nums = eval(data[l:r + 1])\n\n    # 計算所有排列\n    solution = Solution()\n    result = solution.permute(nums)\n\n    # 將結果輸出到標準輸出\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for generating all permutations of array of distinct integers. Use typical backtracking algorithm. Output each step with explanation. Use Start, End, Decision, Step lines. Use arrow syntax. Must be line by line. Provide explanation after //.\n\nLet's produce steps:\n\nStart\n→ Step 1: Define function permute(nums) // Entry function\n→ Step 2: Initialize results list // Store permutations\n→ Step 3: Define backtrack(path, used) // Helper\n→ Decision: If path length == len(nums)? // All numbers used\n    Yes → Step 4: Append copy of path to results // Add permutation\n    No → Step 5: For each index i in range(len(nums)) // iterate candidates\n        Decision: If used[i] == False? // number not used yet\n            Yes → Step 6: Append nums[i] to path // Choose number\n            → Step 7: Mark used[i] = True // Mark as used\n            → Step 8: Call backtrack(path, used) // Recurse\n            → Step 9: Unmark used[i] = False // Backtrack\n            → Step 10: Remove last from path // Remove choice\n→ Step 11: Call backtrack([], [False]*len(nums)) // Start recursion\n→ Step 12: Return results // Output permutations\nEnd\n\nMake sure each line ends with // explanation. Use arrow formatting: \"→\" before each step line. Indentation for nested steps. Use \"Decision:\" lines with Yes→ etc. Provide explanation after //.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 permute(nums) // 入口函式，接收整數陣列  \n→ Step 2: 初始化 results 為空列表 // 用於儲存所有排列  \n→ Step 3: 定義遞迴協助函式 backtrack(path, used) // 回溯核心  \n→ Decision: 如果 len(path) == len(nums)? // 是否已選完所有數字  \n  Yes → Step 4: 將 path 的複本加入 results // 完整排列加入結果  \n  No  → Step 5: 對於 i 從 0 到 len(nums)-1 // 遍歷每個候選數  \n    Decision: 如果 used[i] 為 False? // 該數字尚未被選用  \n     Yes → Step 6: 將 nums[i] 加入 path // 選擇此數字  \n      → Step 7: 設置 used[i] = True // 標記已使用  \n      → Step 8: 呼叫 backtrack(path, used) // 進一步遞迴  \n      → Step 9: 將 used[i] 設回 False // 回溯，解除使用標記  \n      → Step 10: 從 path 中移除最後一個元素 // 解除選擇  \n→ Step 11: 呼叫 backtrack([], [False]*len(nums)) // 從空路徑開始  \n→ Step 12: 回傳 results // 將所有排列輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe4ow8v5k.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmpe4ow8v5k.py\", line 43, in main\n    args = json.loads('[' + args_str + ']')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 4 (char 3)"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\nimport heapq\n\nclass MedianFinder:\n    \"\"\"兩個堆來維持中位數：small 為最大堆、large 為最小堆\"\"\"\n    def __init__(self):\n        self.small = []  # 以負數儲存，模擬最大堆\n        self.large = []  # 正常最小堆\n\n    def addNum(self, num: int) -> None:\n        # 把數字放進對應的堆\n        if not self.small or num <= -self.small[0]:\n            heapq.heappush(self.small, -num)\n        else:\n            heapq.heappush(self.large, num)\n\n        # 平衡堆的大小\n        if len(self.small) > len(self.large) + 1:\n            heapq.heappush(self.large, -heapq.heappop(self.small))\n        elif len(self.large) > len(self.small):\n            heapq.heappush(self.small, -heapq.heappop(self.large))\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入為兩個列表：操作名稱和對應參數\n    m = re.match(r'\\s*\\[(.*?)\\]\\s*,\\s*\\[(.*?)\\]\\s*', data, re.S)\n    if not m:\n        return\n    ops_str, args_str = m.group(1), m.group(2)\n    ops = json.loads('[' + ops_str + ']')\n    args = json.loads('[' + args_str + ']')\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == 'MedianFinder':\n            obj = MedianFinder()\n            res.append(None)\n        elif op == 'addNum':\n            obj.addNum(arg[0])\n            res.append(None)\n        elif op == 'findMedian':\n            res.append(obj.findMedian())\n\n    # 以 JSON 方式輸出，將 None 轉成 null\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for implementing MedianFinder class with addNum and findMedian using two heaps (max heap for lower half, min heap for upper half). Use virtual steps. Ensure each line has virtual code step + space + // explanation.\n\nFollow format: Start, arrow lines with indent maybe. Use arrow →.\n\nStructure: Start // program start\n→ Step: Initialize two heaps: lower (max), upper (min) // initialize heaps\n→ Decision: If size of lower > size of upper + 1? // balance condition\n    Yes → Step: move top from lower to upper // rebalance\n    No: ...\nBut need addNum method.\n\nLet's produce algorithm for addNum:\n- if lower empty or num <= lower.top then push to lower else push to upper\n- then balance sizes: if lower.size > upper.size + 1 then move top from lower to upper; else if upper.size > lower.size then move top from upper to lower.\n\nFor findMedian:\n- if lower.size == upper.size then median = (lower.top + upper.top)/2.0\n- else median = lower.top\n\nReturn.\n\nAlso initialization.\n\nWill produce virtual code with steps.\n\nWe should present as if pseudo-code but no actual language. Use arrows.\n\nLet's produce:\n\nStart\n→ Step: 初始化兩個堆：lower為最大堆，upper為最小堆 // 初始資料結構\n→ Step: 定義 addNum(num) 方法 // 新增數字\n    → Decision: lower 為空 或 num <= lower.top? // 判斷應放入哪個堆\n        Yes → Step: push num 到 lower // 放入下半堆\n        No  → Step: push num 到 upper // 放入上半堆\n    → Decision: lower.size > upper.size + 1? // 平衡檢查\n        Yes → Step: pop top from lower → push to upper // 調整大小\n        No → Decision: upper.size > lower.size? // 另一種不平衡\n            Yes → Step: pop top from upper → push to lower // 調整大小\n            No → // 已平衡\n→ Step: 定義 findMedian() 方法 // 計算中位數\n    → Decision: lower.size == upper.size? // 數量相等時\n        Yes → Step: median = (lower.top + upper.top)/2.0 // 平均兩個中值\n        No  → Step: median = lower.top // 下半堆較大，取其最大值\n    → Step: return median // 回傳中位數\nEnd\n\nBut we must include each line with virtual code step and explanation. Also use arrow for steps. Use \"Step:\" maybe. Use \"Decision:\" for decisions.\n\nAlso ensure we indicate Start and End.\n\nWe need to use virtual code arrow \"→\" preceding each step. For Decision lines, indent them? The example uses indentation with spaces. We can follow similar. Use spaces before Yes/No lines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 初始化兩個堆：lower 為最大堆，upper 為最小堆 // 建立兩個優先佇列來分別存放較小和較大的半段\n→ Step: 定義 addNum(num) 方法 // 允許從資料流中加入新數字\n    → Decision: lower 為空 或 num <= lower.top? // 判斷數字屬於較小半段還是較大半段\n        Yes → Step: push num 到 lower // 放入較小半段堆\n        No  → Step: push num 到 upper // 放入較大半段堆\n    → Decision: lower.size > upper.size + 1? // 檢查是否需要調整平衡\n        Yes → Step: pop top from lower → push 到 upper // 把較小堆的最大值移到較大堆\n        No → Decision: upper.size > lower.size? // 另一種不平衡情況\n            Yes → Step: pop top from upper → push 到 lower // 把較大堆的最小值移到較小堆\n            No  → // 兩堆已平衡\n→ Step: 定義 findMedian() 方法 // 計算目前所有數字的中位數\n    → Decision: lower.size == upper.size? // 兩堆大小相等時\n        Yes → Step: median = (lower.top + upper.top) / 2.0 // 取兩個中值的平均\n        No  → Step: median = lower.top // 只有較小堆多一個元素，取其最大值\n    → Step: return median // 回傳中位數\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuqwp3b0b.py\", line 56, in <module>\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpuqwp3b0b.py\", line 46, in parse_input\n    raise ValueError(\"Input format is incorrect.\")\nValueError: Input format is incorrect."
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprphyf3iv.py\", line 56, in <module>\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmprphyf3iv.py\", line 46, in parse_input\n    raise ValueError(\"Input format is incorrect.\")\nValueError: Input format is incorrect."
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Insert the merged interval\n        result.append(newInterval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(raw):\n    \"\"\"\n    Parse input of the form:\n        intervals = [[1,3],[6,9]], newInterval = [2,5]\n    and return the corresponding Python objects.\n    \"\"\"\n    pattern = r'intervals\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*newInterval\\s*=\\s*(\\[.*\\])'\n    match = re.search(pattern, raw, re.S)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    intervals = ast.literal_eval(match.group(1))\n    new_interval = ast.literal_eval(match.group(2))\n    return intervals, new_interval\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    intervals, new_interval = parse_input(raw_input)\n    sol = Solution()\n    result = sol.insert(intervals, new_interval)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for inserting interval into sorted non-overlapping intervals with merging. Provide step-by-step pseudocode with explanation. Use \"Start\", \"Decision\", \"Yes →\", \"No →\", \"→\", \"End\".\n\nWe need to output line by line. Each line: virtual code step + space + // explanation.\n\nWe should include steps like initialize result array, iterate through intervals, add intervals before newInterval, merge, then add intervals after, etc.\n\nLet's produce steps.\n\nLine 1: Start // Start of algorithm.\n\nLine 2: → Initialize result = [] // create output list.\n\nLine 3: → Initialize i = 0 // index for iterating intervals.\n\nLine 4: → Determine n = length(intervals) // number of intervals.\n\nLine 5: → While i < n and intervals[i].end < newInterval.start: // add intervals ending before new interval starts.\n\n   Yes → Append intervals[i] to result // add non-overlapping left intervals.\n\n   No → break? Actually when condition false we exit loop. But we can just continue loop until false. So we can include No → move to next step.\n\nBut better structure: Use while loop. So maybe we put:\n\n→ While i < n and intervals[i].end < newInterval.start: // iterate left non-overlapping\n\n   → Append intervals[i] to result\n\n   → i = i + 1\n\nEnd of while.\n\nThen next step: Merge newInterval with overlapping intervals.\n\n→ If i < n and intervals[i].start <= newInterval.end: // overlapping\n\n   Yes → newInterval.start = min(newInterval.start, intervals[i].start)\n\n   → newInterval.end = max(newInterval.end, intervals[i].end)\n\n   → i = i + 1\n\n   → While i < n and intervals[i].start <= newInterval.end: // further overlaps\n\n       → newInterval.start = min(newInterval.start, intervals[i].start)\n\n       → newInterval.end = max(newInterval.end, intervals[i].end)\n\n       → i = i + 1\n\nEnd of while.\n\n→ Append newInterval to result // add merged interval\n\n→ While i < n: // add remaining intervals after newInterval\n\n   → Append intervals[i] to result\n\n   → i = i + 1\n\n→ End // return result\n\nBut need to output each step line-by-line with arrows. Use indentation? The format sample shows nested lines with indentation. We'll mimic that.\n\nWe need to use \"Decision:\" for if conditions. Use Yes → etc.\n\nLet's craft.\n\n```\nStart // 程式開始執行\n→ Result = [] // 建立結果陣列\n→ i = 0 // 初始化索引\n→ n = len(intervals) // 取得 intervals 長度\n→ While i < n and intervals[i].end < newInterval.start: // 先加入不重疊且在新區間左側的 intervals\n    → Result.append(intervals[i]) // 加入左側區間\n    → i = i + 1\n→ Decision: 是否還有區間且與 newInterval 重疊? // 檢查是否需要合併\n    Yes → newInterval.start = min(newInterval.start, intervals[i].start) // 更新合併後的起點\n    → newInterval.end = max(newInterval.end, intervals[i].end) // 更新合併後的終點\n    → i = i + 1\n    → While i < n and intervals[i].start <= newInterval.end: // 仍有重疊區間\n        → newInterval.start = min(newInterval.start, intervals[i].start) // 合併起點\n        → newInterval.end = max(newInterval.end, intervals[i].end) // 合併終點\n        → i = i + 1\n    → Result.append(newInterval) // 加入合併後的新區間\n    No → Result.append(newInterval) // 若沒有重疊直接加入\n→ While i < n: // 加入右側所有剩餘區間\n    → Result.append(intervals[i]) // 加入右側區間\n    → i = i + 1\nEnd // 回傳結果陣列\n```\n\nNeed to ensure each line has a virtual code step + space + // explanation. The nested lines should still follow format. Each line begins with arrow or Start. For nested lines, we can indent with spaces. In example, they indent two spaces before nested lines. So we should match that.\n\nAlso the Decision line: Should be \"Decision: If ... ?\" The example uses \"Decision: 如果數字大於 0?\" etc. We'll use Chinese. \"Decision: 是否還有區間且與 newInterval 重疊?\" Good.\n\nWe also need \"Yes →\" and \"No →\" lines.\n\nFor While loops, we may not need explicit decision. But to fit format, we just write \"→ While i < n and intervals[i].end < newInterval.start:\".\n\nBut in the sample, they didn't have While, but it's okay.\n\nWe need to maintain that each line ends with \" // explanation\". Ensure after each line we add comment.\n\nAlso for nested lines, each line after indent starts with arrow \"→\". For Decision block, indent one level and add \"Yes →\" or \"No →\". Good.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Result = [] // 建立結果陣列  \n→ i = 0 // 初始化索引  \n→ n = len(intervals) // 取得 intervals 長度  \n→ While i < n and intervals[i].end < newInterval.start: // 先加入不重疊且在新區間左側的 intervals  \n  → Result.append(intervals[i]) // 加入左側區間  \n  → i = i + 1  \n→ Decision: 是否還有區間且與 newInterval 重疊? // 檢查是否需要合併  \n  Yes → newInterval.start = min(newInterval.start, intervals[i].start) // 更新合併後的起點  \n   → newInterval.end = max(newInterval.end, intervals[i].end) // 更新合併後的終點  \n   → i = i + 1  \n   → While i < n and intervals[i].start <= newInterval.end: // 仍有重疊區間  \n     → newInterval.start = min(newInterval.start, intervals[i].start) // 合併起點  \n     → newInterval.end = max(newInterval.end, intervals[i].end) // 合併終點  \n     → i = i + 1  \n   → Result.append(newInterval) // 加入合併後的新區間  \n  No → Result.append(newInterval) // 若沒有重疊直接加入  \n→ While i < n: // 加入右側所有剩餘區間  \n  → Result.append(intervals[i]) // 加入右側區間  \n  → i = i + 1  \nEnd // 回傳結果陣列"
    },
    {
      "title": "Maximum Distance in Arrays",
      "source_file": "Leetcode/leetcode624.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "arrays = [[1,2,3],[4,5],[1,2,3]]",
          "expected_output": " 4",
          "actual_output_or_error": "Input format error: invalid syntax (<string>, line 1)"
        },
        {
          "example_index": 1,
          "input": " arrays = [[1],[1]]",
          "expected_output": " 0",
          "actual_output_or_error": "Input format error: invalid syntax (<string>, line 1)"
        }
      ],
      "generated_code": "import sys\nimport math\n\nclass Solution:\n    def maxDistance(self, arrays):\n        \"\"\"\n        給定多個已排序的升序陣列，找出兩個來自不同陣列的整數，使得它們的絕對差最大。\n        \"\"\"\n        if len(arrays) < 2:\n            # 只有一個陣列時無法取兩個不同陣列的數字，回傳 0\n            return 0\n\n        # 全域最小值與次小值\n        min1 = math.inf\n        min2 = math.inf\n        minIdx = -1\n\n        # 全域最大值與次大值\n        max1 = -math.inf\n        max2 = -math.inf\n        maxIdx = -1\n\n        for i, arr in enumerate(arrays):\n            if not arr:          # 空陣列直接略過\n                continue\n            a = arr[0]          # 陣列的最小值\n            b = arr[-1]         # 陣列的最大值\n\n            # 更新最小值與次小值\n            if a < min1:\n                min2, min1 = min1, a\n                minIdx = i\n            elif a < min2:\n                min2 = a\n\n            # 更新最大值與次大值\n            if b > max1:\n                max2, max1 = max1, b\n                maxIdx = i\n            elif b > max2:\n                max2 = b\n\n        # 若全域最小與最大來自不同陣列，直接取差值\n        if minIdx != maxIdx:\n            return max1 - min1\n        else:\n            # 否則考慮替代組合，取兩個可能的最大差值\n            return max(max1 - min2, max2 - min1)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 期望輸入為 Python 語法的列表，例如: arrays = [[1,2,3],[4,5],[1,2,3]]\n    try:\n        # 直接 eval 解析為 Python 物件\n        arrays = eval(data)\n    except Exception as e:\n        print(f\"Input format error: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    solution = Solution()\n    result = solution.maxDistance(arrays)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce pseudocode lines. We need to explain each step. Problem: given m sorted arrays, pick one integer from each of two different arrays and maximize |a - b|. Equivalent: maximize difference between any two elements from different arrays. Since arrays sorted ascending, we can find min among all arrays and max among all arrays. But careful: must pick from different arrays. The global min and max could be from same array; if that happens, we must choose next min or max from another array. Approach: find global min value and its array index, and global max value and its array index. If they are different arrays, answer = global max - global min. If same, we need consider second smallest among all arrays or second largest. We can compute min1, min2 (smallest two values across arrays with indices), and max1, max2. Then if min1 index != max1 index -> max1 - min1 else max(max1 - min2, max2 - min1). Complexity O(total elements). Pseudocode.\n\nLet's produce step lines: Start, compute min1/min2 etc.\n\nWe need arrow format: → Step x: description // explanation.\n\nUse Decision lines. Use End. Use arrow for decision yes/no.\n\nLet's produce.\n\nWe need each line virtual code + // explanation. Let's keep code simple.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 min1, min2, max1, max2 為 +∞, -∞，並記錄對應陣列索引 minIdx, maxIdx 為 -1 // 準備儲存全域最小、次小、最大、次大值  \n→ Step 2: 對每一個陣列 i  \n    → Decision: 該陣列是否為空? // 檢查是否有元素可供選取  \n        Yes → 跳過此陣列 // 空陣列不影響結果  \n        No  →  \n            → Step 3: 取陣列 i 的第一個元素 a = arr[i][0] // 最小值  \n            → Step 4: 取陣列 i 的最後一個元素 b = arr[i][-1] // 最大值  \n            → Step 5: 更新 min1, min2  \n                → Decision: a < min1?  \n                    Yes → min2 = min1, min1 = a, minIdx = i  \n                    No  → Decision: a < min2?  \n                        Yes → min2 = a  \n                        No  → 不更新  \n            → Step 6: 更新 max1, max2  \n                → Decision: b > max1?  \n                    Yes → max2 = max1, max1 = b, maxIdx = i  \n                    No  → Decision: b > max2?  \n                        Yes → max2 = b  \n                        No  → 不更新  \n→ Step 7: Decision: minIdx ≠ maxIdx? // 全域最小與最大來自不同陣列  \n    Yes → Step 8: 結果 = max1 - min1 // 直接相減即可得到最大距離  \n    No → Step 9: 結果 = max( max1 - min2, max2 - min1 ) // 取替代組合中的最大差距  \n→ Step 10: 輸出結果 // 回傳最大距離  \nEnd // 程式執行結束"
    },
    {
      "title": "Substring with Concatenation of All Words",
      "source_file": "Leetcode/leetcode30.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[6,9,12]'\nGot (Norm):      '[6]'\n--- (Raw) ---\nRaw Expected: '[6,9,12]'\nRaw Got:      '[6]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter, defaultdict\n\ndef findSubstring(s: str, words) -> list:\n    \"\"\"找出所有符合條件的子字串起始索引。\"\"\"\n    if not s or not words:\n        return []\n\n    word_len = len(words[0])\n    word_cnt = len(words)\n    concat_len = word_len * word_cnt\n    n = len(s)\n\n    if n < concat_len:\n        return []\n\n    # 單字頻率表\n    freq = Counter(words)\n    result = []\n\n    # 在每個 word_len 的 offset 上滑動窗口\n    for offset in range(word_len):\n        left = offset\n        right = offset\n        cur = defaultdict(int)\n        count = 0\n\n        while right + word_len <= n:\n            word = s[right:right + word_len]\n            right += word_len\n\n            if word in freq:\n                cur[word] += 1\n                if cur[word] <= freq[word]:\n                    count += 1\n                else:\n                    # 超過允許的頻率，收縮左端直到合法\n                    while cur[word] > freq[word]:\n                        left_word = s[left:left + word_len]\n                        cur[left_word] -= 1\n                        left += word_len\n                        if left_word == word:\n                            count -= 1\n\n                if count == word_cnt:\n                    result.append(left)\n            else:\n                # 非法單字，重置窗口\n                cur.clear()\n                count = 0\n                left = right\n\n    return result\n\ndef parse_input(data: str):\n    \"\"\"將 stdin 的資料解析成 s 與 words。\"\"\"\n    # 先用正則找出 s 與 words 的字串\n    pattern = r's\\s*=\\s*(?P<s>.+?)\\s*,\\s*words\\s*=\\s*(?P<words>.+)'\n    m = re.search(pattern, data, re.S)\n    if not m:\n        raise ValueError(\"Invalid input format\")\n\n    s_part = m.group('s').strip()\n    words_part = m.group('words').strip()\n\n    # 使用 ast.literal_eval 以安全方式評估字串\n    s = ast.literal_eval(s_part)\n    words = ast.literal_eval(words_part)\n\n    return s, words\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if raw:\n        try:\n            s_val, words_val = parse_input(raw)\n            res = findSubstring(s_val, words_val)\n            print(res)\n        except Exception as e:\n            # 若解析失敗，直接輸出空清單\n            print([])\n    else:\n        print([])",
      "virtual_code": "Thinking...\nWe need produce virtual code for solving the problem: find starting indices of substrings that are concatenation of all words exactly once in any order. Classic LeetCode 30. We'll produce pseudo steps. Use sliding window approach. Need to output virtual code lines with explanation comments. Let's produce structure:\n\nStart\n→ Step: Get word length wlen, total words m, total length concatLen = wlen * m\n→ Decision: if s length < concatLen → End (no possible)\n→ Step: Build frequency map of words\n→ Step: For each offset 0 to wlen-1:\n    → Step: Initialize left=offset, right=offset, count=0, curMap empty\n    → While right + wlen <= s length:\n        → Step: Extract word = s substring right->right+wlen\n        → Decision: If word in freqMap? \n            Yes → Add to curMap, right += wlen\n                → Decision: if curMap[word] <= freqMap[word]?\n                    Yes → count++\n                    No → While curMap[word] > freqMap[word]:\n                        → Step: Remove leftWord = s substring left->left+wlen\n                        → Decrement curMap[leftWord], left += wlen\n                        → Decision: if leftWord == word? count-- \n                → Decision: if count == m?\n                    Yes → Record left\n            No → Step: Clear curMap, count=0, right += wlen, left = right\n        ...\n→ End\n\nBut need line by line virtual code with arrow.\n\nWe must follow format: \"虛擬碼步驟 // 解釋\".\n\nLet's craft.\n\nAlso need to include Start and End. Use arrow \"→\" before each step? In example they used:\n\nStart // 程式開始執行\n→ Step 1: ... // explanation\n\nYes.\n\nAlso for Decision lines we need indent: Decision: ... // etc. Use \"Decision:\" line with Yes → and No →.\n\nLet's produce.\n\nWe'll keep indentation by spaces. For each inner step inside Decision, we indent.\n\nWe'll produce final code.\n\nLet's craft.\n\nNeed to ensure we include loops properly.\n\nI'll produce as:\n\nStart // 程式開始執行\n→ Step 1: wordLen ← length of words[0] // 取得每個單字長度\n→ Step 2: totalWords ← length of words // 總單字數\n→ Step 3: concatLen ← wordLen * totalWords // 總拼接長度\n→ Decision: 如果 len(s) < concatLen? // s 長度不足以包含任何拼接字串\n    Yes → End // 結束\n    No  → Step 4: freqMap ← empty map // 建立單字頻率表\n→ Step 5: For each w in words: freqMap[w]++ // 計算每個單字出現次數\n→ Step 6: result ← empty list // 儲存答案\n→ For offset from 0 to wordLen-1:\n    → Step 7: left ← offset // 滑動窗口左端\n    → Step 8: right ← offset // 滑動窗口右端\n    → Step 9: curMap ← empty map // 當前窗口內單字頻率\n    → Step 10: count ← 0 // 當前窗口已符合的單字數\n    → While right + wordLen ≤ len(s): // 循環處理窗口\n        → Step 11: word ← s.substring(right, right+wordLen) // 取下一個單字\n        → Decision: 如果 word 在 freqMap? // 檢查是否是合法單字\n            Yes → \n                → Step 12: curMap[word]++ // 更新窗口頻率\n                → Decision: 如果 curMap[word] ≤ freqMap[word]? // 超過代表重複\n                    Yes → Step 13: count++ // 成功加入一個合法單字\n                    No → \n                        → Step 14: While curMap[word] > freqMap[word]: // 調整窗口\n                            → Step 15: leftWord ← s.substring(left, left+wordLen) // 移除左端單字\n                            → Step 16: curMap[leftWord]-- // 更新頻率\n                            → Step 17: left ← left + wordLen // 移動左端\n                            → Decision: 如果 leftWord == word? \n                                Yes → Step 18: count-- // 重新計算\n                                No → // 無需變更\n                → Decision: 如果 count == totalWords? // 完整拼接匹配\n                    Yes → Step 19: result.append(left) // 記錄起始位置\n                    No → // 繼續\n                → Step 20: right ← right + wordLen // 右端往右移\n            No → \n                → Step 21: curMap.clear() // 清空窗口頻率\n                → Step 22: count ← 0 // 重置計數\n                → Step 23: right ← right + wordLen // 右端往右移\n                → Step 24: left ← right // 重新對齊左端\n→ Step 25: Return result // 回傳所有起始索引\nEnd // 程式執行結束\n\nNeed to ensure indentation lines for inner Decision: In format they used:\n\nDecision: ... // ...\n    Yes → ...\n    No  → ...\n\nWe need to align. We'll produce consistent indent.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: wordLen ← length of words[0] // 取得每個單字長度\n→ Step 2: totalWords ← length of words // 總單字數\n→ Step 3: concatLen ← wordLen * totalWords // 總拼接長度\n→ Decision: 如果 len(s) < concatLen? // s 長度不足以包含任何拼接字串\n    Yes → End // 結束\n    No  → Step 4: freqMap ← empty map // 建立單字頻率表\n→ Step 5: For each w in words: freqMap[w]++ // 計算每個單字出現次數\n→ Step 6: result ← empty list // 儲存答案\n→ For offset from 0 to wordLen-1:\n    → Step 7: left ← offset // 滑動窗口左端\n    → Step 8: right ← offset // 滑動窗口右端\n    → Step 9: curMap ← empty map // 當前窗口內單字頻率\n    → Step 10: count ← 0 // 當前窗口已符合的單字數\n    → While right + wordLen ≤ len(s): // 循環處理窗口\n        → Step 11: word ← s.substring(right, right+wordLen) // 取下一個單字\n        → Decision: 如果 word 在 freqMap? // 檢查是否是合法單字\n            Yes →\n                → Step 12: curMap[word]++ // 更新窗口頻率\n                → Decision: 如果 curMap[word] ≤ freqMap[word]? // 超過代表重複\n                    Yes → Step 13: count++ // 成功加入一個合法單字\n                    No →\n                        → Step 14: While curMap[word] > freqMap[word]: // 調整窗口\n                            → Step 15: leftWord ← s.substring(left, left+wordLen) // 移除左端單字\n                            → Step 16: curMap[leftWord]-- // 更新頻率\n                            → Step 17: left ← left + wordLen // 移動左端\n                            → Decision: 如果 leftWord == word? \n                                Yes → Step 18: count-- // 重新計算\n                                No → // 無需變更\n                → Decision: 如果 count == totalWords? // 完整拼接匹配\n                    Yes → Step 19: result.append(left) // 記錄起始位置\n                    No → // 繼續\n                → Step 20: right ← right + wordLen // 右端往右移\n            No →\n                → Step 21: curMap.clear() // 清空窗口頻率\n                → Step 22: count ← 0 // 重置計數\n                → Step 23: right ← right + wordLen // 右端往右移\n                → Step 24: left ← right // 重新對齊左端\n→ Step 25: Return result // 回傳所有起始索引\nEnd // 程式執行結束"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "board = \"WRRBBW\", hand = \"RB\"",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4r17x3d5.py\", line 91, in <module>\n    result = solve(board, hand)\n             ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4r17x3d5.py\", line 61, in solve\n    hand_counts[COLOR_IDX[ch]] += 1\n                ~~~~~~~~~^^^^\nKeyError: '\"'"
        },
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwimya4x5.py\", line 91, in <module>\n    result = solve(board, hand)\n             ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwimya4x5.py\", line 61, in solve\n    hand_counts[COLOR_IDX[ch]] += 1\n                ~~~~~~~~~^^^^\nKeyError: '\"'"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbeeiizat.py\", line 91, in <module>\n    result = solve(board, hand)\n             ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbeeiizat.py\", line 61, in solve\n    hand_counts[COLOR_IDX[ch]] += 1\n                ~~~~~~~~~^^^^\nKeyError: '\"'"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\n\nINF = 10 ** 9\nCOLOR_IDX = {'R': 0, 'Y': 1, 'B': 2, 'G': 3, 'W': 4}\nIDX_COLOR = ['R', 'Y', 'B', 'G', 'W']\n\ndef collapse(s: str) -> str:\n    \"\"\"Remove all contiguous groups of 3 or more identical characters repeatedly.\"\"\"\n    changed = True\n    while changed:\n        changed = False\n        i = 0\n        new_s = []\n        while i < len(s):\n            j = i + 1\n            while j < len(s) and s[j] == s[i]:\n                j += 1\n            if j - i >= 3:\n                changed = True\n                i = j  # skip this group\n            else:\n                new_s.append(s[i:j])\n                i = j\n        s = \"\".join(new_s)\n    return s\n\ndef dfs(board: str, hand_counts: tuple, memo: dict) -> int:\n    \"\"\"Return minimum insertions needed to clear board, or INF if impossible.\"\"\"\n    key = (board, hand_counts)\n    if key in memo:\n        return memo[key]\n    if not board:\n        return 0\n    if sum(hand_counts) == 0:\n        return INF\n\n    best = INF\n    board_len = len(board)\n    for i in range(board_len + 1):\n        left_color = board[i - 1] if i > 0 else None\n        right_color = board[i] if i < board_len else None\n        for idx in range(5):\n            if hand_counts[idx] == 0:\n                continue\n            color = IDX_COLOR[idx]\n            # Only consider insertion that can potentially form a group of 3\n            if left_color == color or right_color == color:\n                new_board = collapse(board[:i] + color + board[i:])\n                new_counts = list(hand_counts)\n                new_counts[idx] -= 1\n                res = dfs(new_board, tuple(new_counts), memo)\n                if res != INF:\n                    best = min(best, 1 + res)\n    memo[key] = best\n    return best\n\ndef solve(board: str, hand: str) -> int:\n    hand_counts = [0] * 5\n    for ch in hand:\n        hand_counts[COLOR_IDX[ch]] += 1\n    memo = {}\n    ans = dfs(board, tuple(hand_counts), memo)\n    return -1 if ans == INF else ans\n\ndef parse_input(text: str):\n    \"\"\"Extract board and hand from raw input.\"\"\"\n    lines = [line.strip() for line in text.splitlines() if line.strip()]\n    if not lines:\n        return \"\", \"\"\n    # Check for \"board = \\\"...\\\", hand = \\\"...\\\"\" style\n    if any(\"board\" in line for line in lines) and any(\"hand\" in line for line in lines):\n        board = \"\"\n        hand = \"\"\n        for line in lines:\n            if \"board\" in line:\n                parts = line.split(\"=\")\n                board = parts[1].strip().strip('\",\\'')\n            if \"hand\" in line:\n                parts = line.split(\"=\")\n                hand = parts[1].strip().strip('\",\\'')\n        return board, hand\n    # Otherwise assume first line is board, second is hand\n    board = lines[0]\n    hand = lines[1] if len(lines) > 1 else \"\"\n    return board, hand\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    board, hand = parse_input(raw)\n    result = solve(board, hand)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output pseudo-code steps to solve the Zuma variant problem: find minimum number of insertions to clear board. This is known as \"Zuma Game\" from Leetcode. Approach: DFS with memoization, recursion exploring insertions. Use backtracking with pruning: for each position between balls, try inserting a ball from hand to create at least 3 group. We need to simulate removal: after insertion, collapse groups of >=3. Recursively solve. Return min or -1.\n\nWe should produce pseudo-code line by line, with comments. Use Start, Decision, etc. We'll outline algorithm high-level: define function solve(board, hand) returns min insertions. Use DFS. Use helper collapse. Use memo key of board+hand counts.\n\nWe'll produce steps: Start, if board empty return 0, else if hand empty return INF, else iterate positions i 0..len(board). For each color in hand with count>0, check if insertion at i leads to group >=3 after collapse, if so, simulate and recursively call. Keep best.\n\nAlso we need to skip insertion where no effect (i.e., insertion not adjacent to same color groups). Use logic: find leftmost and rightmost same color. Use loops.\n\nWe'll output pseudo-code with arrow.\n\nLet's produce step-by-step pseudo-code. Ensure no actual code syntax. Use arrow, Start, End, Decision.\n\nWe'll also need collapse function: while True, find any group of >=3 contiguous same, remove, repeat.\n\nAlso memoization: map key to min.\n\nOk produce.\n\nLet's format: Each line: \"虛擬碼步驟 // 解釋\". Use arrows for branching.\n\nWe'll include indentation with arrow? Use indentation by spaces.\n\nLet's proceed.\n...done thinking.\n\nStart // 程式開始執行\n→ Function Solve(board, hand) // 主函式，回傳清空最小插入數\n→ Decision: 若 board 為空? // 檢查是否已清空\n    Yes → Return 0 // 直接成功，無需插入\n    No  → // 仍有球需處理\n→ Decision: 若 hand 為空? // 沒有可用球\n    Yes → Return INF // 表示無法完成，將在最終判斷回傳 -1\n    No  → // 可以嘗試插入\n→ Step 1: 建立 memo = {} // 用於記錄已計算狀態\n→ Step 2: 回傳 DFS(board, hand, memo) // 開始深度優先搜尋\n\n→ Function DFS(board, hand, memo)\n→ Decision: 若 memo 包含 key(board, hand)? // 檢查是否已計算\n    Yes → Return memo[key] // 直接回傳已知最小值\n    No  →\n→ Decision: 若 board 為空? // 目標達成\n    Yes → Return 0\n    No  →\n→ Decision: 若 hand 為空? // 仍有球但手中無可插\n    Yes → Return INF\n    No  →\n→ Step 3: minInsert = INF // 初始最小插入數\n→ Step 4: for i from 0 to len(board) // 迭代所有插入位置\n→ Decision: 取子串 left = board[0:i], right = board[i:] // 位置左右兩段\n    No  →\n→ Step 5: for each color c in {'R','Y','B','G','W'} // 嘗試所有顏色\n→ Decision: 若 hand.count(c) == 0? // 沒有此顏色的球\n    Yes → Continue // 跳過\n    No  →\n→ Step 6: // 檢查插入此顏色是否能形成至少三個連續球\n→ Decision: 若 left 末端與右 起始均為相同顏色且可形成三個? // 用於剪枝\n    Yes →\n→ Step 7: newBoard = Collapse(left + c + right) // 插入後立即消除\n→ Step 8: newHand = hand with one c removed\n→ Step 9: insertCount = DFS(newBoard, newHand, memo) // 递归求解\n→ Decision: 若 insertCount != INF? // 递归成功\n    Yes → minInsert = min(minInsert, 1 + insertCount) // 加上本次插入\n    No  →\n→ Step 10: // 结束此顏色循环\n→ Step 11: // 结束此位置循环\n→ Step 12: memo[key] = minInsert // 记录当前状态结果\n→ Return minInsert // 返回最小插入数\n\n→ Function Collapse(s) // 連續消除功能\n→ Decision: 若 s 為空? // 沒有球\n    Yes → Return s // 直接返回\n    No  →\n→ Step 13: find first segment [l,r) where s[l]==s[r-1] and r-l >=3 // 找到長度>=3的連續區段\n→ Decision: 若 未找到? // 沒有可消除的區段\n    Yes → Return s\n    No  →\n→ Step 14: newS = s[0:l] + s[r:] // 刪除該區段\n→ Step 15: Return Collapse(newS) // 递归继续消除\n\n→ Function key(board, hand) // 生成 memo 的鍵\n→ Return board + \"#\" + sorted hand counts // 例如 \"RBY#2R1Y\" // 用於唯一標識\n\n→ End // 程式結束\n\n// 最終使用者調用\n→ Step 16: result = Solve(boardString, handString) // 取得最小插入數\n→ Decision: 若 result == INF? // 無法清空\n    Yes → Return -1\n    No  → Return result // 返回最小插入數\n\nEnd // 程式執行結束"
    },
    {
      "title": "K Inverse Pairs Array",
      "source_file": "Leetcode/leetcode629.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "n = 3, k = 1",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1000000006'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1000000006'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nMOD = 10 ** 9 + 7\n\ndef count_permutations_with_k_inversions(n: int, k: int) -> int:\n    \"\"\"\n    Count the number of permutations of 1..n that have exactly k inversion pairs.\n    Uses a 1‑dimensional DP with sliding window optimization.\n    \"\"\"\n    # If k is larger than the maximum possible inversions, return 0\n    max_inv = n * (n - 1) // 2\n    if k > max_inv:\n        return 0\n\n    # dp[j] = number of permutations of the current size with j inversions\n    dp = [0] * (k + 1)\n    dp[0] = 1  # Base case: empty permutation has 0 inversions\n\n    for size in range(1, n + 1):\n        new_dp = [0] * (k + 1)\n        new_dp[0] = 1  # There is always exactly one way to have 0 inversions\n\n        # Sliding window sum to compute new_dp efficiently\n        window_sum = 0\n        for inv in range(1, k + 1):\n            # Add the previous dp value for the current inversion count\n            window_sum = (window_sum + dp[inv]) % MOD\n            # If the window size exceeds the current element count, remove the oldest contribution\n            if inv >= size:\n                window_sum = (window_sum - dp[inv - size] + MOD) % MOD\n            new_dp[inv] = window_sum\n\n        dp = new_dp\n\n    return dp[k] % MOD\n\n\ndef main() -> None:\n    \"\"\"\n    Reads input from stdin, processes it, and prints the result.\n    The input may contain arbitrary text; only the first two integers are used\n    as n and k respectively.\n    \"\"\"\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    result = count_permutations_with_k_inversions(n, k)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting number of arrays of length n with numbers 1..n that have exactly k inverse pairs. This is known as number of permutations of size n with k inversions. Count known as \"inversion number\" DP: dp[n][k] = sum_{i=0}^{min(k,n-1)} dp[n-1][k-i]. Use modulo. Complexity O(n*k). Provide virtual code steps.\n\nWe need to produce step-by-step pseudo code with arrows. Let's think: Start, Step: read n, k, Step: if k > n*(n-1)/2: output 0 // impossible. Step: initialize dp array of size (n+1) x (k+1) zeros. dp[0][0] = 1. For i from 1 to n: for j from 0 to k: dp[i][j] = sum_{t=0}^{min(j,i-1)} dp[i-1][j-t] mod M. Use sliding window to optimize but we can mention. After loops, output dp[n][k] mod M. End.\n\nAdd Decision step for invalid k. And loops etc.\n\nLet's produce each line with comments. Use arrow notation: Start, → Step 1: read n, k. Use decision if k>maxInv → output 0 → End.\n\nNeed to output step per line. Use \"Decision:\" lines.\n\nAlso include modulus M = 1_000_000_007. Use \"dp\" 2D array. Use nested loops. Provide sliding window optimization: maintain sum.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\nLine 2: → Step 1: 讀取整數 n 與 k // 取得輸入的陣列長度與目標逆序對數\nLine 3: → Step 2: 設定 M = 1_000_000_007 // 取模數\nLine 4: → Decision: 若 k > n*(n-1)/2? // 若目標逆序對超過最大可達值，結果為 0\nLine 5:    Yes → Step 3: 輸出 0 // 無法達成\nLine 6:    Yes → End // 程式結束\nLine 7:    No  → // 繼續計算\nLine 8: → Step 4: 建立 dp[0..n][0..k] 皆 0 // 初始化動態規劃表\nLine 9: → Step 5: dp[0][0] = 1 // 空序列只有 1 種方式\nLine 10: → Step 6: 對 i 取值 1..n // 逐層添加新元素\nLine 11: →     // 初始化滑動窗口和\nLine 12: →     Step 6.1: sum = 0\nLine 13: →     // j 從 0 到 k\nLine 14: →     Step 6.2: 對 j 取值 0..k\nLine 15: →         // 將 dp[i-1][j] 加入窗口\nLine 16: →         sum = (sum + dp[i-1][j]) mod M\nLine 17: →         // 若窗口長度 > i-1，移除最舊元素\nLine 18: →         If j >= i: sum = (sum - dp[i-1][j-i] + M) mod M\nLine 19: →         dp[i][j] = sum // dp[i][j] 為前 i-1 個元素的所有可能加上新元素位置\nLine 20: → Step 7: 輸出 dp[n][k] mod M // 最終答案\nLine 21: End // 程式結束\n\nMake sure arrows and indentation. Use \"Yes →\" \"No →\". In Decision: we had a Yes branch that ends program, else continue.\n\nBut we need to maintain proper format: each line starts with arrow or Start or End. Use \"Decision:\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n 與 k // 取得輸入的陣列長度與目標逆序對數  \n→ Step 2: 設定 M = 1_000_000_007 // 取模數  \n→ Decision: 若 k > n*(n-1)/2? // 若目標逆序對超過最大可達值，結果為 0  \n Yes → Step 3: 輸出 0 // 無法達成  \n Yes → End // 程式結束  \n No  → // 繼續計算  \n→ Step 4: 建立 dp[0..n][0..k] 皆 0 // 初始化動態規劃表  \n→ Step 5: dp[0][0] = 1 // 空序列只有 1 種方式  \n→ Step 6: 對 i 取值 1..n // 逐層添加新元素  \n → Step 6.1: sum = 0 // 初始化滑動窗口和  \n → // j 從 0 到 k  \n → Step 6.2: 對 j 取值 0..k  \n  → Step 6.2.1: sum = (sum + dp[i-1][j]) mod M // 將 dp[i-1][j] 加入窗口  \n  → Step 6.2.2: 若 j >= i: sum = (sum - dp[i-1][j-i] + M) mod M // 移除最舊元素  \n  → Step 6.2.3: dp[i][j] = sum // dp[i][j] 為前 i-1 個元素的所有可能加上新元素位置  \n→ Step 7: 輸出 dp[n][k] mod M // 最終答案  \nEnd // 程式結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        # 使用 disjoint 半開區間列表，已經排好順序\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i - 1][0] <= left and right <= self.ranges[i - 1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        print(\"[]\")\n        return\n\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    rng_module = None\n    output = []\n\n    for line in lines:\n        if line.startswith(\"RangeModule\"):\n            # 初始化\n            rng_module = RangeModule()\n            output.append(\"null\")\n        elif \"addRange\" in line:\n            nums = [int(x) for x in line[line.find(\"(\")+1:line.find(\")\")].split(\",\")]\n            rng_module.addRange(nums[0], nums[1])\n            output.append(\"null\")\n        elif \"removeRange\" in line:\n            nums = [int(x) for x in line[line.find(\"(\")+1:line.find(\")\")].split(\",\")]\n            rng_module.removeRange(nums[0], nums[1])\n            output.append(\"null\")\n        elif \"queryRange\" in line:\n            nums = [int(x) for x in line[line.find(\"(\")+1:line.find(\")\")].split(\",\")]\n            result = rng_module.queryRange(nums[0], nums[1])\n            output.append(\"true\" if result else \"false\")\n        else:\n            # 未知行，忽略\n            continue\n\n    print(f\"[{', '.join(output)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for designing data structure: RangeModule. Should outline operations using data structures like interval list or tree. Provide steps. Let's design using sorted list of disjoint intervals. Provide operations: addRange, queryRange, removeRange. We'll give pseudocode for each. Use virtual steps line by line. Also include Start, End. Provide decisions. Probably break into methods. Provide algorithm: maintain list of intervals sorted. For add: merge overlaps. For query: check intervals cover. For remove: split intervals. We'll produce stepwise virtual code.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 RangeModule 類別 // 建立資料結構的框架\n    → Step 2: 建立空的 intervalList // 存放已追蹤的 disjoint 半開區間，使用排序陣列或鏈表\n\n→ Step 3: 實作 addRange(left, right) // 新增區間\n    → Step 4: 找到 intervalList 中第一個與 [left, right) 交叉或相鄰的區間索引 i\n    → Step 5: 如果 i 不存在，直接將 [left, right) 加入並保持排序\n    → Decision: 是否存在與 [left, right) 交叉或相鄰的區間？\n        Yes → Step 6: 合併所有與 [left, right) 交叉或相鄰的區間，更新 left = min(left, i.left)，right = max(right, i.right)\n        No  → Step 7: 將 [left, right) 插入 intervalList 在索引 i 的位置\n    → Step 8: 刪除所有已被合併的舊區間\n    → Step 9: 插入新的合併後區間並保持排序\n\n→ Step 10: 實作 queryRange(left, right) // 查詢區間是否完全被追蹤\n    → Step 11: 找到 intervalList 中第一個左邊界不小於 left 的區間索引 i\n    → Decision: i 是否存在且 i.left <= left 且 i.right >= right ?\n        Yes → Return true // 完全覆蓋\n        No  → Return false // 未覆蓋\n\n→ Step 12: 實作 removeRange(left, right) // 移除區間\n    → Step 13: 找到 intervalList 中第一個與 [left, right) 交叉的區間索引 i\n    → Decision: 是否存在與 [left, right) 交叉的區間？\n        Yes → Step 14: 對每個交叉區間 j 進行處理\n            → Decision: j.left < left ？\n                Yes → Step 15: 在 j 左側保留 [j.left, left) 作為新區間\n            → Decision: j.right > right ？\n                Yes → Step 16: 在 j 右側保留 [right, j.right) 作為新區間\n        No  → No action\n    → Step 17: 刪除所有完全被 [left, right) 包含的舊區間\n    → Step 18: 插入保留的左側和右側新區間，保持排序\n\n→ End // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpyvumd8xj.py\", line 62, in <module>\n    ops = json.loads(data[0])      # 例如 [\"MyCircularDeque\", \"insertLast\", ...]\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    \"\"\"環狀雙端佇列實作。\"\"\"\n    def __init__(self, k: int):\n        self.k = k                    # 最大容量\n        self.buf = [0] * k            # 固定大小的儲存區\n        self.head = 0                 # 前端指標\n        self.count = 0                # 當前元素數量\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:      # 檢查是否已滿\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:      # 檢查是否已滿\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:           # 檢查是否為空\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:           # 檢查是否為空\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:           # 檢查是否為空\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:           # 檢查是否為空\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    ops = json.loads(data[0])      # 例如 [\"MyCircularDeque\", \"insertLast\", ...]\n    args = json.loads(data[1])     # 例如 [[3], [1], [2], ...]\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(arg[0])\n            result.append(None)          # constructor returns null\n        else:\n            method = getattr(obj, op)\n            # call method with arguments (could be empty list)\n            res = method(*arg)\n            result.append(res)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step, no actual code, just steps. Each line: step description + \"// explanation\". Use arrows and structure. Provide full logic for MyCircularDeque with capacity k, array, head, tail pointers, count. Steps: Start, init, etc. Also methods.\n\nWe need to output line by line. For each method maybe separate block. Use Start/End per method? Probably yes. The sample shows Start/End overall program. Here we can show initialization and each method. Use decision points.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCircularDeque 類別 // 宣告類別並準備建構子與成員變數  \n→ Decision: 判斷是否已宣告類別？ // 確保類別已存在  \n    Yes → End // 結束確認  \n\n// 建構子  \n→ Step 2: 建構子 MyCircularDeque(k)  \n    → Initialise array of size k // 建立容量為 k 的固定長度陣列  \n    → Set head = 0 // 前端指標初始化為 0  \n    → Set tail = 0 // 後端指標初始化為 0  \n    → Set count = 0 // 目前元素數量為 0  \n    → Return // 建構子完成  \n→ End // 建構子結束  \n\n// insertFront 方法  \n→ Step 3: insertFront(value)  \n    → Decision: 如果 count == k? // 檢查是否已滿  \n        Yes → Return false // 無法插入，已滿  \n        No →  \n            → head = (head - 1 + k) mod k // 前端指標往前移（循環）  \n            → array[head] = value // 存入值  \n            → count++ // 數量加一  \n            → Return true // 插入成功  \n→ End // insertFront 結束  \n\n// insertLast 方法  \n→ Step 4: insertLast(value)  \n    → Decision: 如果 count == k? // 檢查是否已滿  \n        Yes → Return false // 無法插入，已滿  \n        No →  \n            → array[tail] = value // 存入值  \n            → tail = (tail + 1) mod k // 後端指標往後移（循環）  \n            → count++ // 數量加一  \n            → Return true // 插入成功  \n→ End // insertLast 結束  \n\n// deleteFront 方法  \n→ Step 5: deleteFront()  \n    → Decision: 如果 count == 0? // 檢查是否為空  \n        Yes → Return false // 無法刪除，已空  \n        No →  \n            → head = (head + 1) mod k // 前端指標往後移（循環）  \n            → count-- // 數量減一  \n            → Return true // 刪除成功  \n→ End // deleteFront 結束  \n\n// deleteLast 方法  \n→ Step 6: deleteLast()  \n    → Decision: 如果 count == 0? // 檢查是否為空  \n        Yes → Return false // 無法刪除，已空  \n        No →  \n            → tail = (tail - 1 + k) mod k // 後端指標往前移（循環）  \n            → count-- // 數量減一  \n            → Return true // 刪除成功  \n→ End // deleteLast 結束  \n\n// getFront 方法  \n→ Step 7: getFront()  \n    → Decision: 如果 count == 0? // 檢查是否為空  \n        Yes → Return -1 // 空時回傳 -1  \n        No → Return array[head] // 回傳前端值  \n→ End // getFront 結束  \n\n// getRear 方法  \n→ Step 8: getRear()  \n    → Decision: 如果 count == 0? // 檢查是否為空  \n        Yes → Return -1 // 空時回傳 -1  \n        No →  \n            → rearIndex = (tail - 1 + k) mod k // 後端指標實際位置  \n            → Return array[rearIndex] // 回傳後端值  \n→ End // getRear 結束  \n\n// isEmpty 方法  \n→ Step 9: isEmpty()  \n    → Return (count == 0) // 判斷數量是否為 0  \n→ End // isEmpty 結束  \n\n// isFull 方法  \n→ Step 10: isFull()  \n    → Return (count == k) // 判斷數量是否達到容量  \n→ End // isFull 結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Size Subarray Sum",
      "source_file": "Leetcode/leetcode209.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "target = 7, nums = [2,3,1,2,4,3]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp92eiphig.py\", line 24, in <module>\n    nums = ast.literal_eval(parts[1].split('=')[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "target = 4, nums = [1,4,4]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1c_m3gfb.py\", line 24, in <module>\n    nums = ast.literal_eval(parts[1].split('=')[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgokdbsqt.py\", line 24, in <module>\n    nums = ast.literal_eval(parts[1].split('=')[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def minSubArrayLen(self, target, nums):\n        left = 0\n        total = 0\n        min_len = float('inf')\n        for right in range(len(nums)):\n            total += nums[right]\n            while total >= target:\n                min_len = min(min_len, right - left + 1)\n                total -= nums[left]\n                left += 1\n        return 0 if min_len == float('inf') else min_len\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Expected format: 'target = 7, nums = [2,3,1,2,4,3]'\n    parts = [part.strip() for part in data.split(',')]\n    target = int(parts[0].split('=')[1].strip())\n    nums = ast.literal_eval(parts[1].split('=')[1].strip())\n    result = Solution().minSubArrayLen(target, nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for algorithm: minimal subarray length >= target sum, using sliding window. Provide lines with virtual code and comments.\n\nWe must follow format: each line: `虛擬碼步驟` + space + `// 解釋`. Use arrow symbols etc. Use Start, End. Use Decision etc. Provide step-by-step.\n\nWe need to produce lines such as:\n\nStart // 程式開始執行\n→ Step 1: 設定 left = 0, right = 0, currentSum = 0, minLen = Infinity // 初始化變數\n→ Decision: 右指標是否 < len(nums)? // 主循環\n  Yes → Step 2: 加入 nums[right] 到 currentSum // 拓展窗口\n  ...\nBut we need to express sliding window: while left < len(nums) etc.\n\nLet's outline:\n\nStart\n→ Step 1: Initialize variables: left = 0, minLen = Infinity, currentSum = 0\n→ Decision: While left < len(nums)? // Outer loop? Actually typical algorithm: for right in range(len(nums)):\n   but can also use while right < len(nums):\nWe'll produce pseudo:\n\n→ Step 2: Set right = 0\n→ Decision: While right < len(nums)? // iterate right pointer\n    Yes → Step 3: currentSum += nums[right] // add to window\n    → Decision: currentSum >= target? // shrink window if meets\n        Yes → Step 4: minLen = min(minLen, right-left+1) // update min\n        → Step 5: currentSum -= nums[left] // remove leftmost\n        → Step 6: left += 1 // move left\n        → Decision: currentSum >= target? // repeat shrinking\n            Yes → (loop back to step 4?) Might use inner loop; but we can express recursively.\n\nBut we need to produce linear lines.\n\nSimpler: Use for loop and while loop inside.\n\nWe can express pseudo as:\n\nStart // 程式開始執行\n→ Step 1: left = 0, minLen = Infinity, currentSum = 0\n→ Decision: For right in range(len(nums))? // iterate right pointer\n   Yes → Step 2: currentSum += nums[right] // add current element to sum\n   → Decision: currentSum >= target? // check if window meets requirement\n        Yes → Step 3: minLen = min(minLen, right-left+1) // record minimal length\n        → Step 4: currentSum -= nums[left] // shrink from left\n        → Step 5: left += 1 // move left pointer\n        → Decision: currentSum >= target? // repeat shrinking until not met\n            Yes → (repeat steps 3-5)\n            No → (continue outer loop)\n   No → (continue outer loop)\n→ Decision: minLen == Infinity? // no subarray found\n    Yes → Step 6: return 0 // return 0 if none\n    No  → Step 7: return minLen // return minimal length\n\nWe need to write each step line with arrow. Use `→` for flow.\n\nWe need to show loops and decisions. Use \"Decision:\" lines with indentation.\n\nAlso include Start, End.\n\nWe need to produce lines as described. Provide explanation after //.\n\nLet's produce.\n\nNeed to avoid actual code. Use words.\n\nAlso \"Return\" lines.\n\nBe careful to match output format: each line \"虛擬碼步驟\" space \" // 解釋\". Use arrow.\n\nWe need to handle indentation for nested decisions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 設定 left = 0, currentSum = 0, minLen = Infinity // 初始化滑動窗口參數\n→ Decision: 遍歷右指標 right 從 0 到 nums.length-1? // 外層循環\n    Yes → Step 2: currentSum += nums[right] // 將右邊元素加入窗口總和\n    → Decision: currentSum >= target? // 窗口總和是否已達目標\n        Yes → Step 3: minLen = min(minLen, right-left+1) // 更新最小子陣列長度\n        → Step 4: currentSum -= nums[left] // 從左邊收縮窗口\n        → Step 5: left += 1 // 左指標右移\n        → Decision: currentSum >= target? // 繼續收縮直到不滿足\n            Yes → (回到 Step 3-5 循環) // 這裡用循環標示\n            No → (跳回外層循環) // 收縮結束\n        No → (跳回外層循環) // 右指標右移\n→ Decision: minLen == Infinity? // 是否找到符合條件的子陣列\n    Yes → Step 6: return 0 // 沒有找到，返回 0\n    No  → Step 7: return minLen // 返回最小長度\nEnd // 程式執行結束\n\nBut we need to include line for Step 6 and Step 7.\n\nAlso we need to express loops explicitly. Use `→ Step` etc.\n\nMaybe use `→ Decision: For each right?` but we can just use Decision: for right in range? Provide comment.\n\nBut to maintain structure: Use Decision for loops, but we can treat as \"Decision: for right in range(...)?\"\n\nLet's produce final output accordingly.\n\nMake sure each line ends with // explanation. Use indent for nested decisions. The indentation should be spaces.\n\nAlso after \"→ Decision: For right in range...\" the Yes branch leads to Step 2. But we also need to indicate No branch goes to next? Actually For loop ends when done. We'll indicate \"No → End of loop\" maybe.\n\nBut the example shows nested decisions with Yes and No. For loop can be represented as Decision: right < len(nums)? Yes → Step, No → End loop.\n\nLet's produce using while loop representation:\n\nStart // 程式開始執行\n→ Step 1: left = 0, currentSum = 0, minLen = Infinity // 初始化變數\n→ Decision: right < len(nums)? // 主迴圈條件\n    Yes → Step 2: currentSum += nums[right] // 將右邊元素加入總和\n    → Decision: currentSum >= target? // 判斷是否達標\n        Yes → Step 3: minLen = min(minLen, right-left+1) // 更新最小長度\n        → Step 4: currentSum -= nums[left] // 從左邊收縮窗口\n        → Step 5: left += 1 // 移動左指標\n        → Decision: currentSum >= target? // 仍然滿足條件？重複收縮\n            Yes → (重複 Step 3-5) // 這裡用循環標示\n            No → (跳回到右指標右移)\n        No → (跳回到右指標右移)\n    → Step 6: right += 1 // 右指標右移\n    → Decision: right < len(nums)? // 繼續主迴圈\n        Yes → (回到 Step 2)\n        No  → (結束主迴圈)\n→ Decision: minLen == Infinity? // 是否找到了符合條件的子陣列\n    Yes → Step 7: return 0 // 未找到，返回 0\n    No  → Step 8: return minLen // 返回最小長度\nEnd // 程式執行結束\n\nBut need to make sure each line has explanation after //. Use the arrow symbol.\n\nThe lines inside nested decisions may have indentation. The example shows indent of 4 spaces maybe. We'll use 4 spaces.\n\nWe also need to ensure \"→ (重複 Step 3-5)\" is a line; but maybe we can treat as \"→ Step 3: ...\" again? It's ambiguous.\n\nSimpler: Use while loop to handle shrink inside while currentSum >= target. That can be represented as:\n\n→ Decision: currentSum >= target? // 只要滿足條件就收縮\n    Yes → Step 3: minLen = min(minLen, right-left+1) // 更新最小長度\n    → Step 4: currentSum -= nums[left] // 從左邊移除元素\n    → Step 5: left += 1 // 左指標右移\n    → Decision: currentSum >= target? // 再次判斷\n        Yes → (repeat step 3-5)\n        No  → (exit shrink loop)\nBut to keep simple, we can not explicitly loop but say \"→ Step 3\" inside while.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: left = 0, currentSum = 0, minLen = Infinity // 初始化變數\n→ Decision: right < len(nums)? // 主迴圈條件\n    Yes → Step 2: currentSum += nums[right] // 加入右邊元素\n    → Decision: currentSum >= target? // 是否達標\n        Yes → Step 3: minLen = min(minLen, right-left+1) // 更新最小長度\n        → Step 4: currentSum -= nums[left] // 收縮左側\n        → Step 5: left += 1 // 左指標右移\n        → Decision: currentSum >= target? // 仍然達標？繼續收縮\n            Yes → (重複 Step 3-5)\n            No → (跳出收縮)\n        No → (跳出收縮)\n    → Step 6: right += 1 // 右指標右移\n    → Decision: right < len(nums)? // 繼續主迴圈\n        Yes → (回到 Step 2)\n        No  → (結束主迴圈)\n→ Decision: minLen == Infinity? // 是否存在子陣列\n    Yes → Step 7: return 0 // 沒有找到\n    No  → Step 8: return minLen // 返回最小長度\nEnd // 程式執行結束\n\nWe need to produce this as output. Let's ensure each line is separate.\n\nAlso we need to ensure we include \"→\" arrow before each step. The first line \"Start\" no arrow. Then \"→ Step 1:\" etc.\n\nAlso indent lines inside decisions. Use 4 spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: left = 0, currentSum = 0, minLen = Infinity // 初始化滑動窗口參數\n→ Decision: right < len(nums)? // 主迴圈條件\n    Yes → Step 2: currentSum += nums[right] // 將右邊元素加入窗口總和\n    → Decision: currentSum >= target? // 窗口總和是否已達目標\n        Yes → Step 3: minLen = min(minLen, right-left+1) // 更新最小子陣列長度\n        → Step 4: currentSum -= nums[left] // 從左邊收縮窗口\n        → Step 5: left += 1 // 左指標右移\n        → Decision: currentSum >= target? // 繼續收縮直到不滿足\n            Yes → (重複 Step 3-5) // 仍然達標，重複更新與收縮\n            No  → (跳出收縮) // 收縮結束\n        No  → (跳出收縮) // 初始總和未達標，直接跳過收縮\n    → Step 6: right += 1 // 右指標右移\n    → Decision: right < len(nums)? // 檢查是否還有元素可處理\n        Yes → (回到 Step 2) // 進入下一輪右指標\n        No  → (結束主迴圈) // 已處理完所有元素\n→ Decision: minLen == Infinity? // 是否找到符合條件的子陣列\n    Yes → Step 7: return 0 // 沒有找到，回傳 0\n    No  → Step 8: return minLen // 返回最小長度\nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuh5f_tc6.py\", line 64, in <module>\n    main()\n  File \"/tmp/tmpuh5f_tc6.py\", line 43, in main\n    ops = json.loads(parts[0])\n          ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 18 (char 17)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, idx: int) -> bool:\n            if idx == len(word):\n                return node.is_end\n            ch = word[idx]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, idx + 1):\n                        return True\n                return False\n            else:\n                if ch not in node.children:\n                    return False\n                return dfs(node.children[ch], idx + 1)\n        return dfs(self.root, 0)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse the input which is two JSON arrays separated by a comma\n    parts = data.split(',', 1)\n    ops = json.loads(parts[0])\n    args = json.loads(parts[1])\n\n    wd = None\n    results = []\n    for op, arg in zip(ops, args):\n        if op == \"WordDictionary\":\n            wd = WordDictionary()\n            results.append(None)\n        elif op == \"addWord\" and wd is not None:\n            wd.addWord(arg[0])\n            results.append(None)\n        elif op == \"search\" and wd is not None:\n            results.append(wd.search(arg[0]))\n        else:\n            results.append(None)\n\n    # Output results in JSON format (null, true, false)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for the WordDictionary class: addWord and search with dot support. Likely use Trie with recursion for search. Provide step-by-step virtual code lines with explanations.\n\nWe need to produce a virtual code snippet line by line. Should include Start, End, Decision, etc. For class definition and methods. Need to incorporate data structures.\n\nWe can break into steps:\n\nStart\n→ Define Node structure with children map and isEnd flag\n→ Define WordDictionary with root node\n→ AddWord method: iterate through characters, create nodes, set isEnd true at last\n→ Search method: call recursive helper function searchInNode(word, node)\n→ Recursive search: if char is '.', iterate over all children and recurse; else follow specific child; if char not found return false; base case at end of word: return node.isEnd\nReturn boolean.\n\nWe'll present virtual code lines accordingly. Ensure each line includes comment explanation. Use arrows for decision branches. Provide recursion logic as separate steps.\n\nLet's produce the virtual code.\n\nNeed to avoid actual code, but show pseudo-steps.\n\nWill show class initialization etc.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Node: 子節點字典，與結尾標記 // 建立 Trie 節點結構  \n    → 子節點字典 // 存放對應字母的子節點  \n    → isEnd flag // 標示該節點是否為單字結尾  \n→ WordDictionary 初始化：根節點 = Node() // 建立空字典的根節點  \n→ addWord(word) // 新增單字  \n    → current ← root // 從根節點開始遍歷  \n    → For each char in word  \n        → If char not in current.children  \n            → current.children[char] ← Node() // 新建子節點  \n        → current ← current.children[char] // 移動到下一個節點  \n    → current.isEnd ← true // 標記單字結束  \n→ search(word) // 搜尋單字或帶 '.' 的模式  \n    → Return searchRecursive(word, root, 0) // 呼叫遞迴搜尋  \n→ searchRecursive(pattern, node, index) // 遞迴協助搜尋  \n    → Decision: 如果 index 等於 pattern.length? // 已到字尾  \n        Yes → Return node.isEnd // 若節點是結尾則命中  \n        No  → // 仍有字元要處理  \n            → char ← pattern[index] // 取得目前字元  \n            → Decision: 如果 char 為 '.'? // 任意字母匹配  \n                Yes → For each childNode in node.children.values()  \n                    → If searchRecursive(pattern, childNode, index + 1) return true // 有一條路徑成功則返回 true  \n                → Return false // 所有子節點均失敗  \n                No  → Decision: 如果 char 在 node.children? // 具體字母匹配  \n                    Yes → Return searchRecursive(pattern, node.children[char], index + 1) // 繼續遞迴  \n                    No  → Return false // 無對應子節點，直接失敗  \nEnd // 程式執行結束"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5iwzpgnm.py\", line 23, in <module>\n    args = ast.literal_eval(data[1])\n                            ~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmjsx2shk.py\", line 23, in <module>\n    args = ast.literal_eval(data[1])\n                            ~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n    ops = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1])\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"KthLargest\":\n            obj = KthLargest(*arg)\n            results.append(None)\n        elif op == \"add\":\n            res = obj.add(arg[0])\n            results.append(res)\n        else:\n            # Unsupported operation; ignore or raise error\n            results.append(None)\n\n    # Convert None to 'null' for output formatting\n    output = \"[\" + \", \".join(\"null\" if r is None else str(r) for r in results) + \"]\"\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for class KthLargest, with constructor and add method. We need to explain each line. Use arrow style. We need to design algorithm: maintain min-heap of size k; constructor adds initial nums; add pushes val, then if size > k pop smallest; return heap[0] as kth largest.\n\nWe need to produce virtual code lines: Start, Step: Initialize k, heap, etc. Show decision if heap size > k. Then add method.\n\nWe need to use virtual code with arrows. Let's produce something like:\n\nStart\n→ Step 1: 定義 KthLargest 類別 // 定義類別\n→ Step 2: 定義變數 k, minHeap // k 為目標順位，minHeap 儲存前 k 大元素\n...\n\nBut need to follow output format: each line \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow arrow. For decision we use \"Decision:\".\n\nWe also need separate blocks for constructor and add method. Could use \"Method: Constructor\" and \"Method: add\". But following format, maybe use steps.\n\nWe can use indentation for decision lines. Use \"Yes →\", \"No →\".\n\nLet's craft.\n\nFirst block: Start.\n\nThen Step: Initialize k and minHeap.\n\nThen Step: For each num in nums: push to heap.\n\nThen Decision: if heap size > k? If yes, pop smallest.\n\nThen End.\n\nBut we also need to return value after constructor? Not necessary. Constructor returns nothing.\n\nAdd method: similar.\n\nLet's produce virtual code:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 KthLargest // 建立 KthLargest 類別\n→ Step 2: 定義成員變數 k, minHeap // k 為目標順位，minHeap 為大小為 k 的最小堆\n→ Step 3: Constructor KthLargest(k, nums) // 初始化方法\n    → Step 3.1: 設定 this.k = k // 設定目標順位\n    → Step 3.2: 初始化 this.minHeap 為空堆 // 建立最小堆\n    → Step 3.3: 對 nums 中每個值 v 執行 add(v) // 將初始分數加入堆中\n→ Step 4: 方法 add(val) // 新增分數並返回第 k 大分數\n    → Step 4.1: 將 val 推入 this.minHeap // 將新分數加入堆\n    → Decision: 若堆長度 > this.k? // 超過 k 個元素\n        Yes → Step 4.2: 從 this.minHeap 中移除最小值 // 只保留前 k 大\n        No  → Step 4.3: 無需移除 // 堆已不超過 k\n    → Step 4.4: 返回 this.minHeap[0] // 堆頂即為第 k 大分數\nEnd // 程式執行結束\n\nBut need to use arrow syntax exactly: \"→\" etc. Also we need each line to be separate, no nested indentation? They allow indentation for decision. Use indent spaces.\n\nBetter: Represent decision block with indent.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 KthLargest // 建立 KthLargest 類別  \n→ Step 2: 定義成員變數 k, minHeap // k 為目標順位，minHeap 為大小為 k 的最小堆  \n→ Step 3: Constructor KthLargest(k, nums) // 初始化方法  \n    → Step 3.1: 設定 this.k = k // 設定目標順位  \n    → Step 3.2: 初始化 this.minHeap 為空堆 // 建立最小堆  \n    → Step 3.3: 對 nums 中每個值 v 執行 add(v) // 將初始分數加入堆中  \n→ Step 4: 方法 add(val) // 新增分數並返回第 k 大分數  \n    → Step 4.1: 將 val 推入 this.minHeap // 將新分數加入堆  \n    → Decision: 若堆長度 > this.k? // 超過 k 個元素  \n        Yes → Step 4.2: 從 this.minHeap 中移除最小值 // 只保留前 k 大  \n        No  → Step 4.3: 無需移除 // 堆已不超過 k  \n    → Step 4.4: 返回 this.minHeap[0] // 堆頂即為第 k 大分數  \nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkw5hef6y.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpkw5hef6y.py\", line 41, in main\n    result = solver.complexNumberMultiply(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkw5hef6y.py\", line 18, in complexNumberMultiply\n    a_real, a_imag = parse(a)\n                     ^^^^^^^^\n  File \"/tmp/tmpkw5hef6y.py\", line 14, in parse\n    return int(real_part), int(imag_part)\n           ^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '1+'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        def parse(s: str):\n            \"\"\"解析 'real+imaginaryi' 字串，回傳 (real, imag) 整數對。\"\"\"\n            # 移除最後的 'i'\n            s = s.rstrip('i')\n            # 從最後一個位置往前搜尋 '+' 或 '-'，避免把 real 的符號誤當成分隔符號\n            for i in range(len(s) - 1, 0, -1):\n                if s[i] in '+-':\n                    real_part = s[:i]\n                    imag_part = s[i:]\n                    return int(real_part), int(imag_part)\n            # 若找不到分隔符號，代表沒有虛部，直接回傳 (real, 0)\n            return int(s), 0\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        # (a + bi) * (c + di) = (ac - bd) + (ad + bc)i\n        real_res = a_real * b_real - a_imag * b_imag\n        imag_res = a_real * b_imag + a_imag * b_real\n\n        return f\"{real_res}+{imag_res}i\"\n\ndef main():\n    # 讀取整個輸入，預期格式類似: \"1+1i\", \"1+1i\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 依照逗號分隔兩個複數字串，並去除可能存在的引號與空白\n    parts = data.split(',')\n    if len(parts) < 2:\n        # 如果只有一行但沒有逗號，嘗試以空白分隔\n        parts = data.split()\n    num1 = parts[0].strip().strip('\"').strip(\"'\")\n    num2 = parts[1].strip().strip('\"').strip(\"'\")\n\n    solver = Solution()\n    result = solver.complexNumberMultiply(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for multiplying two complex numbers represented as strings. Provide each line with explanation. Use Start, Decision, etc. Not actual code. Ensure each line: \"虛擬碼步驟 // 解釋\". Use arrow →. Also need to parse strings to extract real and imaginary integers, multiply according to (a+bi)*(c+di) = (ac - bd) + (ad + bc)i. Then format back to string.\n\nWe'll generate steps: start, input strings, parse, decision? maybe validate ranges. compute product. format string. output. end.\n\nInclude Decision: maybe check sign of imaginary part? But simpler. Use Steps for parsing: split by '+' or '-'? But string format \"real+imaginaryi\". Real part can be negative, imaginary can be negative. Format e.g. \"-3-4i\"? But spec says \"real+imaginaryi\" but imaginary could be negative so might be \"-3-4i\"? We'll just assume string always has sign before imaginary part, like \"a+bi\" or \"a-bi\". We'll parse accordingly. Steps: find index of last '+' or '-'. Could handle negative real part.\n\nWe'll provide pseudo-code with explanation. Use Decision: if string contains '-', etc.\n\nLet's produce virtual code.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 num1, num2 // 取得兩個複數字串\n→ Decision: 檢查 num1 是否符合 \"real+imaginaryi\" 格式？ // 驗證字串結構\n    Yes → Step 2: 解析 num1 為 real1, imag1 // 取得實部與虛部\n    No  → Step 3: 顯示錯誤訊息並終止 // 格式錯誤時結束\n→ Decision: 檢查 num2 是否符合 \"real+imaginaryi\" 格式？ // 同樣驗證\n    Yes → Step 4: 解析 num2 為 real2, imag2 // 取得實部與虛部\n    No  → Step 5: 顯示錯誤訊息並終止\n→ Step 6: 計算實部結果 realRes = real1 * real2 - imag1 * imag2 // (ac - bd)\n→ Step 7: 計算虛部結果 imagRes = real1 * imag2 + imag1 * real2 // (ad + bc)\n→ Decision: 虛部正負？ // 方便格式化\n    Yes → Step 8: resultStr = realRes + \"+\" + imagRes + \"i\" // 虛部為正\n    No  → Step 9: resultStr = realRes + imagRes + \"i\" // 虛部為負，符號已包含\n→ Step 10: 輸出 resultStr // 回傳結果字串\nEnd // 程式執行結束\n\n// 解析步驟詳細說明（在 Step 2 與 Step 4 中）\n// Step 2/4: 找到字串最後一次出現 '+' 或 '-'（用於分隔實部與虛部）\n//          取得 substring 0 到此位置為 realPart，轉換為整數\n//          取得 substring 位置+1 到字串長度-1（去掉最後的 'i'）為 imagPart，轉換為整數\n//          若 realPart 以 '-' 開頭，包含負號；若 imagPart 以 '-' 開頭，包含負號\n//          若字串不符合此結構，判斷為錯誤。"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"Return lists of duplicate file paths.\"\"\"\n        content_map = defaultdict(list)\n\n        for path in paths:\n            parts = path.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content.rstrip(')')\n                content_map[content].append(f\"{root}/{name}\")\n\n        return [files for files in content_map.values() if len(files) > 1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Remove possible leading variable assignment\n    if data.startswith(\"paths\"):\n        _, data = data.split(\"=\", 1)\n        data = data.strip()\n    # Safely evaluate the list expression\n    try:\n        paths = ast.literal_eval(data)\n    except Exception:\n        # Fallback: if the data is already a list-like string without quotes\n        paths = data.splitlines()\n    sol = Solution()\n    result = sol.findDuplicate(paths)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line, each line ends with // explanation. Use virtual code arrows. Provide steps for algorithm: parse input, map content to list of paths, then collect those with length>=2. Provide start and end. Use Decision structure. Provide mapping. Let's craft.\n\nSteps:\n\nStart\n→ Step 1: 初始化空字典 contentMap // 用於存放內容到文件路徑列表\n→ Decision: 如果 paths 為空? // 檢查輸入是否有資料\n    Yes → End // 沒資料直接結束\n    No  → Step 2: 遍歷每個 dirInfo in paths // 逐一處理每個目錄資訊\n\nInside loop:\n\n→ Step 2.1: 解析 dirInfo 成 directoryPath 與 filesList // 把字符串拆成路徑與文件列表\n→ Step 2.2: 遍歷每個 fileEntry in filesList // 處理每個文件\n→ Step 2.3: 解析 fileEntry 成 fileName 與 fileContent // 拆分文件名與內容\n→ Step 2.4: 完整路徑 = directoryPath + \"/\" + fileName // 組成完整路徑\n→ Step 2.5: 如果 contentMap 沒有 key fileContent 則 contentMap[fileContent] = [] // 建立新列表\n→ Step 2.6: contentMap[fileContent].append(完整路徑) // 加入路徑到對應內容\n\nAfter loops:\n\n→ Step 3: 初始化結果列表 result = [] // 用於存儲重複文件組\n→ Step 4: 遍歷 contentMap.items() // 逐個內容檢查\n→ Decision: 如果 listSize < 2? // 需要至少兩個文件才算重複\n    Yes → Continue // 跳過\n    No  → result.append(list) // 加入結果\n\n→ End // 返回結果\n\nWe need to output as lines with //.\n\nAlso include \"Start\" and \"End\". Use Decision lines with indent. Use arrow. Provide explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 contentMap 為空字典 // 用於存放檔案內容到其完整路徑的映射  \n→ Decision: 如果 paths 為空? // 檢查輸入列表是否為空  \n Yes → End // 沒有資料，直接結束程式  \n No  → Step 2: 遍歷每個 dirInfo 於 paths 中 // 逐一處理每個目錄資訊  \n\n→ Step 2.1: 解析 dirInfo 成 directoryPath 與 filesList // 以空格分割，首個為目錄路徑，其餘為檔案描述  \n→ Step 2.2: 遍歷每個 fileEntry 於 filesList 中 // 逐個處理檔案名稱與內容  \n → Step 2.3: 解析 fileEntry 成 fileName 與 fileContent // 用括號分割，前半為檔名，後半為內容  \n → Step 2.4: 完整路徑 ← directoryPath + \"/\" + fileName // 組成完整的檔案路徑  \n → Decision: contentMap 是否已有 key fileContent? // 判斷此內容是否已經存在於映射中  \n  Yes → Step 2.5: contentMap[fileContent].append(完整路徑) // 加入此路徑到對應內容的列表  \n  No  → Step 2.5: contentMap[fileContent] ← [完整路徑] // 建立新列表並加入第一個路徑  \n\n→ Step 3: 初始化 result 為空列表 // 用於儲存所有重複檔案的路徑組  \n→ Step 4: 遍歷 contentMap.items() // 逐個檢查內容與對應路徑列表  \n → Decision: listSize < 2? // 需要至少兩個檔案才能算重複  \n  Yes → Continue // 跳過此內容  \n  No  → result.append(list) // 將此重複組加入結果  \n\nEnd // 程式執行結束，返回 result"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[7]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[7]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[6,5,8]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[6, 5, 8]'"
        }
      ],
      "generated_code": "import random\n\n# 假設有一個 rand7() API，這裡用 random 來模擬\ndef rand7() -> int:\n    \"\"\"產生 1~7 的均勻隨機數（僅供本地測試使用）\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"使用兩次 rand7() 產生 1~10 的均勻隨機數\"\"\"\n        while True:\n            # 兩次 rand7() 組合成 1~49\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            # 只接受 1~40，保證 40 是 10 的倍數\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\ndef main():\n    import sys, re\n    # 讀取一行輸入，範例：'n = 1'\n    line = sys.stdin.readline().strip()\n    # 取得第一個整數作為 n\n    m = re.search(r'\\d+', line)\n    n = int(m.group()) if m else 0\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    # 輸出結果為 Python list 的字串表示\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for rand10 using rand7. Classic approach: use two calls to rand7 to generate range 1-49, reject >40 to get uniform 1-40, then map to 1-10 by modulo. Or alternative: using rejection sampling of 1-49 to 1-10, 5*10=50, but we need 1-40.\n\nBetter: use two rand7: x = (rand7()-1)*7 + rand7(); gives 1-49. If x <= 40, return ((x-1)%10)+1. Else reject and repeat.\n\nWe need to output step by step with explanation after each line, using virtual code arrow format.\n\nNeed to follow output format: each line: \"虛擬碼步驟 // 解釋\". Include Start, End, Decision lines. Use arrow.\n\nLet's produce:\n\nStart // 開始\n→ Step 1: 數字 = rand7() // 取得第一個 1-7\n→ Step 2: 數字2 = rand7() // 取得第二個 1-7\n→ Step 3: 合成值 = (數字-1)*7 + 數字2 // 轉換成 1-49\n→ Decision: 如果 合成值 <= 40? // 檢查是否在可接受區間\n    Yes → Step 4: 回傳 ((合成值-1)%10)+1 // 映射到 1-10\n    No  → Step 5: Go back to Step 1 // 重試\nEnd // 結束\n\nBut we need to show the loop. Maybe we use While loop. But using decisions and arrows.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: repeat // 進入重試迴圈\n    → Step 2: a = rand7() // 取得第一個隨機數 1~7\n    → Step 3: b = rand7() // 取得第二個隨機數 1~7\n    → Step 4: x = (a-1)*7 + b // 將兩個數轉換為 1~49\n    → Decision: 如果 x <= 40? // 檢查是否落在可接受範圍\n        Yes → Step 5: 返回 ((x-1)%10)+1 // 產生 1~10\n        No  → Step 6: continue // 重複 Step 2\n→ End // 程式結束\n\nNeed to use arrow? The structure: Start, Step, Decision, Yes, No, End.\n\nLet's produce final answer with each line. Use Chinese explanation.\n\nWe'll include the loop explicitly: We can show as:\n\nStart // 開始\n→ Step 1: 進入 while loop // 迴圈開始\n    → Step 2: a = rand7() // ...\n    ...\nBut we need arrow for each step. Use indentation to show block. Use '→' for each inside block. We also need to include arrow 'Yes →', 'No →' inside decision.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 是否已得到 1~10? // 判斷是否需要繼續迴圈（初始為否）  \n    No → Step 1: a = rand7() // 產生第一個 1~7 的隨機數  \n    → Step 2: b = rand7() // 產生第二個 1~7 的隨機數  \n    → Step 3: x = (a-1)*7 + b // 將兩個隨機數組合為 1~49  \n    → Decision: 如果 x <= 40? // 只接受前 40 個值以保持均勻  \n        Yes → Step 4: result = ((x-1) % 10) + 1 // 把 1~40 映射到 1~10  \n            → Step 5: return result // 回傳 1~10 的隨機數  \n        No  → Step 6: 轉回 Decision：是否已得到 1~10? // 重試，回到判斷開始  \nEnd // 程式執行結束"
    },
    {
      "title": "Search Insert Position",
      "source_file": "Leetcode/leetcode35.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfnw8wb4i.py\", line 52, in <module>\n    main()\n  File \"/tmp/tmpfnw8wb4i.py\", line 44, in main\n    parsed = parse_line(line)\n             ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfnw8wb4i.py\", line 34, in parse_line\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuaswjzfr.py\", line 52, in <module>\n    main()\n  File \"/tmp/tmpuaswjzfr.py\", line 44, in main\n    parsed = parse_line(line)\n             ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpuaswjzfr.py\", line 34, in parse_line\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg4p1baup.py\", line 52, in <module>\n    main()\n  File \"/tmp/tmpg4p1baup.py\", line 44, in main\n    parsed = parse_line(line)\n             ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpg4p1baup.py\", line 34, in parse_line\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef search_insert(nums, target):\n    \"\"\"二分搜尋插入位置，時間複雜度 O(log n)\"\"\"\n    left, right = 0, len(nums)\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef parse_line(line: str):\n    \"\"\"\n    解析輸入行，例如：\n    nums = [1,3,5,6], target = 5\n    或者帶引號的字串：\n    'nums = [1,3,5,6], target = 5'\n    \"\"\"\n    line = line.strip()\n    if not line:\n        return None\n    # 移除可能的外層引號\n    if (len(line) >= 2 and line[0] == line[-1] and line[0] in ('\"', \"'\")):\n        line = line[1:-1].strip()\n    # 以逗號分隔兩個表達式\n    parts = line.split(',', 1)\n    if len(parts) != 2:\n        raise ValueError(f\"輸入格式錯誤: {line}\")\n    nums_part = parts[0].split('=', 1)[1].strip()\n    target_part = parts[1].split('=', 1)[1].strip()\n    nums = ast.literal_eval(nums_part)\n    target = int(target_part)\n    return nums, target\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    results = []\n    for line in data:\n        if not line.strip():\n            continue\n        parsed = parse_line(line)\n        if parsed is None:\n            continue\n        nums, target = parsed\n        results.append(str(search_insert(nums, target)))\n    sys.stdout.write(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for binary search that returns index or insertion point. We need to use virtual code format with arrows. Provide line by line with explanation. The user wants in Traditional Chinese. Provide in the required format: each line: \"虛擬碼步驟 // 解釋/說明\". Use \"Start\", \"End\", \"Decision:\" and arrows. Let's produce step-by-step pseudo-code:\n\nStart\n→ Step 1: 設定 left = 0, right = n-1 // 左右指標初始化\n→ Decision: 如果 left > right? // 檢查是否搜尋完畢\n    Yes → Step 2: 回傳 left // left 為插入位置\n    No  → Step 3: 計算 mid = left + (right - left)/2 // 中點\n→ Decision: 如果 arr[mid] == target? // 找到目標\n    Yes → Step 4: 回傳 mid // 返回索引\n    No  → Decision: 如果 arr[mid] < target? // 目標在右半\n        Yes → Step 5: left = mid + 1 // 調整左指標\n        No  → Step 6: right = mid - 1 // 調整右指標\n→ Goto Step 1 // 重新循環\n\nEnd\n\nBut we need \"→ Goto Step 1\"? We can just use loop. Use \"→ Step 1\" again? But the pseudo-code typical loop: while left <= right. But we can structure as Decision at the top. It's okay.\n\nLet's produce with arrows like:\n\nStart // 程式開始執行\n→ Step 1: left = 0, right = n-1 // 初始化左右指標\n→ Decision: left > right? // 搜尋是否結束\n    Yes → Step 2: return left // 找不到，左指標即為插入位置\n    No  → Step 3: mid = left + (right - left) / 2 // 計算中點\n→ Decision: arr[mid] == target? // 是否找到目標\n    Yes → Step 4: return mid // 返回索引\n    No  → Decision: arr[mid] < target? // 目標在右半\n        Yes → Step 5: left = mid + 1 // 左指標往右移\n        No  → Step 6: right = mid - 1 // 右指標往左移\n→ Goto Step 1 // 重新檢查條件\n\nEnd // 程式執行結束\n\nLet's ensure each line ends with // explanation. Use \"→\" arrow for steps and decisions. Use \"Yes →\" and \"No →\". Need to mention the loop. Use \"Goto Step 1\". That is okay.\n\nCheck requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So we must have the arrow and step.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0, right = n-1 // 初始化左右指標，左指標指向陣列起始，右指標指向結尾  \n→ Decision: left > right? // 判斷是否已搜尋完畢  \n  Yes → Step 2: return left // 若左指標超過右指標，說明目標不存在，左指標即為插入位置  \n  No  → Step 3: mid = left + (right - left) / 2 // 計算中點位置，避免溢位  \n→ Decision: arr[mid] == target? // 判斷中點元素是否為目標值  \n  Yes → Step 4: return mid // 找到目標，直接回傳其索引  \n  No  → Decision: arr[mid] < target? // 若目標大於中點，目標必在右半區  \n    Yes → Step 5: left = mid + 1 // 將左指標移至中點右側，縮小搜尋範圍  \n    No  → Step 6: right = mid - 1 // 否則將右指標移至中點左側，縮小搜尋範圍  \n→ Goto Step 1 // 重複檢查條件，執行下一輪搜尋  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpijrkojli.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmpijrkojli.py\", line 44, in main\n    price, special, needs = parse_input(raw_input)\n                            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpijrkojli.py\", line 34, in parse_input\n    raise ValueError(\"Input format incorrect. Expected three lists.\")\nValueError: Input format incorrect. Expected three lists."
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbh24nq4j.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmpbh24nq4j.py\", line 44, in main\n    price, special, needs = parse_input(raw_input)\n                            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbh24nq4j.py\", line 34, in parse_input\n    raise ValueError(\"Input format incorrect. Expected three lists.\")\nValueError: Input format incorrect. Expected three lists."
        }
      ],
      "generated_code": "import sys\nimport re\nfrom typing import List, Tuple\n\nclass Solution:\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs: Tuple[int]) -> int:\n            if curr_needs in memo:\n                return memo[curr_needs]\n            # Direct purchase without any offer\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            # Try every special offer\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    # offer is applicable\n                    res = min(res, offer[-1] + dfs(tuple(temp)))\n            memo[curr_needs] = res\n            return res\n\n        return dfs(tuple(needs))\n\ndef parse_input(data: str) -> Tuple[List[int], List[List[int]], List[int]]:\n    # Find all list literals in the input string\n    lists = re.findall(r'\\[.*?\\]', data, flags=re.DOTALL)\n    if len(lists) != 3:\n        raise ValueError(\"Input format incorrect. Expected three lists.\")\n    price = eval(lists[0], {})\n    special = eval(lists[1], {})\n    needs = eval(lists[2], {})\n    return price, special, needs\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    price, special, needs = parse_input(raw_input)\n    solution = Solution()\n    result = solution.shoppingOffers(price, special, needs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line for solving the problem: find minimum cost to buy exact needed items using special offers, can use offers multiple times, no overbuying. This is classic \"shopping offers\" DP with recursion/backtracking or DFS with memoization. Provide steps: Start, compute DFS with memo on needs vector, for each state consider using each offer if applicable, compute cost recursively, also direct purchase cost, return min. Use representation of needs as key string or tuple.\n\nLet's produce virtual code lines: Start, define function dfs(needs) -> min cost, check memo, compute direct cost, iterate offers, if can apply, subtract, compute cost, update min, memoize, return min. End. Provide explanation after each line. Use arrow for step. Provide Decision nodes for offer applicability and base case.\n\nLet's output with virtual code lines. Ensure each line ends with // explanation.\n\nLet's craft.\n\nWe'll need to represent price, needs, special as global variables.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ // 定義全域變數: price, needs, special  \n→ Declare price, needs, special // 傳入的商品價格、需求與特價優惠  \n\n→ // 建立快取以避免重複計算  \n→ Declare memo as Map<String, Integer> // 鍵為需求向量字串，值為最小成本  \n\n→ // 主要遞迴函式，輸入當前需求向量，回傳最低成本  \n→ Function dfs(currentNeeds) → Integer // 從目前需求計算最低購買成本  \n\n→ Decision: 是否已經計算過 currentNeeds? // 檢查快取  \n    Yes → Return memo[currentNeeds] // 已計算，直接回傳  \n\n→ // 直接購買方式：不使用任何優惠，按單價購買所有剩餘商品  \n→ Set directCost = 0  \n→ For i from 0 to n-1  \n    directCost += currentNeeds[i] * price[i] // 每件乘以單價累加  \n\n→ Set minCost = directCost // 初始化最小成本為直接購買成本  \n\n→ // 嘗試使用每個特價優惠  \n→ For each offer in special  \n    Set canUse = True  \n    For j from 0 to n-1  \n        If offer[j] > currentNeeds[j]  \n            canUse = False  \n            Break // 不能使用此優惠，因為會超過需求  \n\n    Decision: canUse? // 檢查優惠是否可用  \n        Yes → // 生成新的需求向量  \n            Set newNeeds = []  \n            For j from 0 to n-1  \n                newNeeds[j] = currentNeeds[j] - offer[j] // 消耗此優惠的商品量  \n\n            // 遞迴計算使用此優惠後的成本  \n            Set costWithOffer = offer[n] + dfs(newNeeds) // 優惠價格加上後續最小成本  \n\n            // 更新最小成本  \n            minCost = min(minCost, costWithOffer) // 若更便宜則更新  \n\n→ // 記錄並回傳最小成本  \n→ memo[currentNeeds] = minCost // 快取結果  \n→ Return minCost // 回傳本需求向量的最小成本  \n\n→ End Function dfs // dfs 函式結束  \n\n→ // 主流程：將原始需求轉成向量，呼叫 dfs 計算答案  \n→ Set result = dfs(needs) // 從原始需求開始計算  \n\n→ End // 程式執行結束，result 為最小購買成本"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"\n        In-place reordering of nums so that nums[0] < nums[1] > nums[2] < nums[3] ...\n        \"\"\"\n        for i in range(len(nums) - 1):\n            # even index: nums[i] should be less than nums[i+1]\n            if i % 2 == 0:\n                if nums[i] > nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n            # odd index: nums[i] should be greater than nums[i+1]\n            else:\n                if nums[i] < nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Extract list of numbers. Accept formats like \"nums = [1,2,3]\" or just \"[1,2,3]\"\n    if raw_input.startswith(\"nums\"):\n        _, _, expr = raw_input.partition(\"=\")\n        nums_str = expr.strip()\n    else:\n        nums_str = raw_input\n\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        # If parsing fails, treat as empty list\n        nums = []\n\n    # Ensure we have a list\n    if not isinstance(nums, list):\n        nums = []\n\n    # Apply wiggle sort\n    Solution().wiggleSort(nums)\n\n    # Output the resulting list\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for wiggle sort. Standard algorithm: iterate and ensure pattern. Use one-pass. Steps: for i from 0 to len-2, if i%2==0 then need nums[i] < nums[i+1] else need nums[i] > nums[i+1]; if not satisfied, swap. End. Also can mention we can just reorder in place.\n\nLet's produce each line.\n\nStart\n\n→ Step 1: 設定 i = 0 // 初始化索引\n\n→ Decision: 是否 i < len(nums)-1? // 迴圈條件\n\n    Yes → Decision: 如果 i % 2 == 0? // 判斷位置是偶數還是奇數\n\n        Yes → Decision: 是否 nums[i] >= nums[i+1]? // 對於偶數位置需要 nums[i] < nums[i+1]\n\n            Yes → Step 2: 交換 nums[i] 與 nums[i+1] // 交換以滿足關係\n\n            No → // 不需要交換\n\n        No  → Decision: 是否 nums[i] <= nums[i+1]? // 對於奇數位置需要 nums[i] > nums[i+1]\n\n            Yes → Step 2: 交換 nums[i] 與 nums[i+1] // 交換以滿足關係\n\n            No → // 不需要交換\n\n    No → // i 已到尾\n\n→ Step 3: i = i + 1 // 移動到下一個索引\n\n→ Go back to Decision: 是否 i < len(nums)-1? // 重複\n\nEnd // 完成\n\nBut we need to use virtual code arrow format exactly. Provide each line. Use indentation? Format example uses indentation.\n\nLet's produce.\n\nWe might also add step to get length. But it's fine.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i = 0 // 初始化索引  \n→ Decision: i < len(nums)-1? // 迴圈判斷是否還有相鄰元素  \n    Yes → Decision: i % 2 == 0? // 判斷位置是偶數還是奇數  \n        Yes → Decision: nums[i] >= nums[i+1]? // 偶數位置需滿足 nums[i] < nums[i+1]  \n            Yes → Step 2: swap(nums[i], nums[i+1]) // 交換以修正順序  \n            No  → // 已符合要求，無需處理  \n        No  → Decision: nums[i] <= nums[i+1]? // 奇數位置需滿足 nums[i] > nums[i+1]  \n            Yes → Step 2: swap(nums[i], nums[i+1]) // 交換以修正順序  \n            No  → // 已符合要求，無需處理  \n    No  → // i 已達尾端，結束迴圈  \n→ Step 3: i = i + 1 // 移動到下一個索引  \n→ Go back to Decision: i < len(nums)-1? // 重複迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmponhofvgg.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmponhofvgg.py\", line 51, in main\n    equations, values, queries = parse_input(input_data)\n                                 ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmponhofvgg.py\", line 39, in parse_input\n    module = ast.parse(input_str)\n             ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3tm2g61w.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmp3tm2g61w.py\", line 51, in main\n    equations, values, queries = parse_input(input_data)\n                                 ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp3tm2g61w.py\", line 39, in parse_input\n    module = ast.parse(input_str)\n             ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpubyqxxm9.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmpubyqxxm9.py\", line 51, in main\n    equations, values, queries = parse_input(input_data)\n                                 ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpubyqxxm9.py\", line 39, in parse_input\n    module = ast.parse(input_str)\n             ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        # 建立圖：每個節點到鄰居的權重\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1.0 / val\n\n        # 深度優先搜尋求兩個節點之間的乘積\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor in visited:\n                    continue\n                res = dfs(neighbor, dst, visited)\n                if res != -1.0:\n                    return weight * res\n            return -1.0\n\n        results = []\n        for u, v in queries:\n            results.append(dfs(u, v, set()))\n        return results\n\ndef parse_input(input_str):\n    \"\"\"\n    解析形如\n        equations = [...], values = [...], queries = [...]\n    的字串，回傳 equations, values, queries 的三個值。\n    \"\"\"\n    module = ast.parse(input_str)\n    data = {}\n    for node in module.body:\n        if isinstance(node, ast.Assign) and len(node.targets) == 1:\n            var_name = node.targets[0].id\n            data[var_name] = ast.literal_eval(node.value)\n    return data[\"equations\"], data[\"values\"], data[\"queries\"]\n\ndef main():\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return\n    equations, values, queries = parse_input(input_data)\n    sol = Solution()\n    res = sol.calcEquation(equations, values, queries)\n    # 格式化輸出，保留五位小數\n    formatted = \"[\" + \",\".join(f\"{x:.5f}\" for x in res) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanation comments. Need to solve the problem: given equations and values, and queries, find division results. It's classic graph / union find. Provide virtual steps. Ensure each line has arrow and explanation. Use Start, End, Decision etc. Use variables like BuildGraph, DFS, etc. Provide line-by-line algorithm. Let's produce.\n\nLet's write Start, Step 1: Build adjacency graph from equations and values. Then for each query: if both variables present, run DFS or BFS to compute product along path. Use Decision: if path found. If not found or variable absent, output -1.0. Use arrays for results. Use loops. Use virtual steps. No actual code, but structure.\n\nMake sure each line: Virtual code step + // explanation.\n\nUse arrow like →. Use Decision: Yes →, No →.\n\nLet's produce.\n\nWe'll need some loop lines. Provide high-level steps: BuildGraph, For each query: Check existence, if missing return -1.0, else DFS. In DFS: if start==target return 1, else for each neighbor visited accumulate product. Use Decision: if path found return product, else return -1.0.\n\nWill keep each step as separate line. Possibly use pseudo variables: graph, visited, result array.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 graph 為空的鄰接表 // 建立變數之間的圖結構  \n→ Step 2: 初始化 results 為空陣列 // 用來儲存每個查詢的答案  \n\n→ Step 3: 針對每個 (Ai, Bi, values[i]) 在 equations 中進行  \n  → Step 3.1: 在 graph[Ai] 中加入 (Bi, values[i]) // Ai / Bi = value  \n  → Step 3.2: 在 graph[Bi] 中加入 (Ai, 1/values[i]) // Bi / Ai = 1/value  \n\n→ Step 4: 針對每個 query (Cj, Dj) 進行  \n  → Decision: 若 Cj 或 Dj 未出現在 graph? // 判斷變數是否已知  \n    Yes → Step 4.1: results.append(-1.0) // 未定義，答案為 -1  \n    No → Step 4.2: 初始化 visited 為空集合 // 為 DFS 做標記  \n     → Step 4.3: 執行 DFS(Cj, Dj, 1.0)  \n      → Decision: 若 DFS 找到路徑?  \n        Yes → Step 4.4: results.append(找到的乘積) // 輸出計算結果  \n        No  → Step 4.5: results.append(-1.0) // 沒有路徑可行  \n\n→ Step 5: 回傳 results // 結果回傳給使用者  \nEnd // 程式執行結束  \n\n// DFS 函式說明  \n→ Function DFS(current, target, prod)  \n  → Decision: 若 current == target? // 到達目標  \n    Yes → Return prod // 乘積即為答案  \n    No → Step 5.1: visited.add(current)  \n     → 針對每個 (neighbor, value) 在 graph[current] 中進行  \n      → Decision: 若 neighbor 已在 visited?  \n        Yes → Step 5.2: 繼續下一個鄰居 // 跳過已訪問  \n        No → Step 5.3: res = DFS(neighbor, target, prod * value)  \n         → Decision: 若 res != None? // 找到路徑  \n           Yes → Return res // 傳回結果  \n           No → Step 5.4: 繼續檢查其他鄰居  \n      → Return None // 所有鄰居嘗試完畢仍未找到  \n// 以上虛擬碼提供了完整的圖構建、DFS 搜尋與查詢處理流程。"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      \"['dogcatsdog', 'catsdogcats', 'ratcatdogcat']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef find_all_concatenated_words(words):\n    # 先按長度遞增排序，確保較短字已先加入集合\n    words.sort(key=len)\n    seen = set()\n    result = []\n\n    for word in words:\n        if not word:\n            continue\n        if can_form(word, seen):\n            result.append(word)\n        seen.add(word)\n    return result\n\ndef can_form(word, seen):\n    \"\"\"\n    判斷 word 是否能被 seen 中的單字拼湊成。\n    使用 DP，dp[i] 表示 word[:i] 能否拼湊。\n    \"\"\"\n    dp = [False] * (len(word) + 1)\n    dp[0] = True\n    for i in range(1, len(word) + 1):\n        for j in range(i):\n            if dp[j] and word[j:i] in seen:\n                dp[i] = True\n                break\n    return dp[len(word)]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 支援輸入類型：words = [\"cat\",\"cats\",...]\n    if data.startswith(\"words\"):\n        data = data.split(\"=\", 1)[1].strip()\n    try:\n        words = ast.literal_eval(data)\n    except Exception:\n        # 若輸入格式不符，直接終止\n        words = []\n    result = find_all_concatenated_words(words)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving problem: given array of strings words (no duplicates), return all concatenated words in the list. A concatenated word comprises entirely of at least two shorter words from the list. Need to produce steps with explanation, not actual code. Use Start, End, Decision, arrows. Each line: 虛擬碼步驟 + space + // 解釋. Provide step-by-step algorithm.\n\nAlgorithm typical: sort words by length ascending; use set of words seen; for each word, use DP to check if it can be segmented into at least two words in set; if yes, add to result; then add word to set. Use a helper function canForm(word, set) returns bool using DP with DP array length+1; dp[0]=true; for i from 1..len: for j from 0..i-1: if dp[j] and word[j:i] in set: dp[i]=true; break. Also need count of words used? The requirement: at least two shorter words. DP ensures segmentation into at least one word; but we need at least two. Approach: in DP, we can check if there exists segmentation that uses at least one word before and at end uses a word: ensure at least two parts. Simplest: we can treat that word itself not counted as a shorter word, so if segmentation found that uses any partition, it's at least two if we ensure we don't consider whole word as one part. In DP, we can iterate j from 1 to i-1 only to avoid full word match. Or we can after segmentation check that we used at least one cut. Implementation: during DP, if j>0 or i<len? Let's propose: in canForm, when i==len(word) and dp[i] is true, we must ensure that the segmentation uses at least two words. That means we can check if there exists j such that dp[j]==true and j>0 and substring[j:len] in set. But dp[0] is true. If the whole word exists in set (it does because we inserted after processing?), but we process before adding current word to set, so not in set. So dp will only be true if segmentation uses at least one shorter word. However it could be just one word equal to word? Not in set. So segmentation will be at least two words. Good. So no need special handling. But we sort by length ascending, so set contains only shorter words. So DP segmentation uses at least one part. But can it be exactly one part? Only if the word itself is in set, which is false. So at least two. So fine.\n\nThus algorithm:\n\nStart\n→ Sort words by length ascending\n→ Initialize empty set seenWords\n→ Initialize empty list result\n→ For each word in sorted words:\n    → Decision: Can the word be segmented using words in seenWords? // call helper\n        Yes → Step: Append word to result // it's concatenated\n    → Step: Add word to seenWords // now available for later words\nEnd\n\nHelper function: canForm(word, seenWords):\n    → Initialize dp array of length+1 with false; dp[0]=true\n    → For i from 1 to len(word):\n        → For j from 0 to i-1:\n            → Decision: dp[j]==true and substring(word, j, i) in seenWords?\n                Yes → dp[i]=true; break // break inner loop\n    → Return dp[len(word)] // segmentation possible\n\nAlso maybe we need to ensure that at least two words: Since seenWords contains only shorter words, segmentation uses at least two. So we can explain that.\n\nLet's produce lines accordingly. Use arrows, decisions, etc. We must keep each line as \"虛擬碼步驟 // 解釋\". Provide Start, End. Use arrow for steps. Let's produce.\n\nNeed to be careful: each line includes \"虛擬碼步驟\" then a space then comment. Use `→` for steps, `Decision:` for if. Use `Yes →` and `No →` under decision. For helper function we need to indent lines? Use indentation or just separate. We'll just use new lines with arrow. Also within helper we might use nested steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort words by length ascending // 先把單字依長度遞增排列，確保較短的字已先處理  \n→ Initialize seenWords as empty set // 用來存放已經確認過的較短字  \n→ Initialize result as empty list // 存放所有符合條件的連接字  \n\n→ For each word in words: // 逐個檢查每個字  \n    → Decision: Can word be segmented using seenWords? // 判斷目前字是否能由已知較短字拼湊而成  \n        Yes → Append word to result // 如果能，加入結果清單  \n    → Add word to seenWords // 無論能否拼湊，將該字加入集合供後續字使用  \n\nEnd // 程式執行結束  \n\n---  \n\n// Helper 函式：檢查字能否由 seenWords 內的字拼湊而成  \nStart // Helper 開始  \n→ Function canForm(word, seenWords)  \n    → Initialize dp array of length(word)+1 with false; dp[0] = true // dp[i] 表示前 i 個字可拼湊  \n    → For i from 1 to length(word): // 逐字位移  \n        → For j from 0 to i-1: // 嘗試所有切分點  \n            → Decision: dp[j] == true AND word[j:i] in seenWords? // 前面可拼湊且切分片段為已知字  \n                Yes → Set dp[i] = true; Break inner loop // 找到有效切分，即可確定 dp[i]  \n    → Return dp[length(word)] // 若最後 dp 為 true，表示整個字能被拼湊  \nEnd // Helper 結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        return [[email_to_name[root]] + sorted(emails) for root, emails in merged.items()]\n\nif __name__ == \"__main__\":\n    import sys\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 支援 'accounts = [...]' 或直接 '[...]' 的輸入格式\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    try:\n        accounts = ast.literal_eval(expr)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    sol = Solution()\n    merged_accounts = sol.accountsMerge(accounts)\n    print(merged_accounts)",
      "virtual_code": "Thinking...\nWe need produce virtual code steps for merging accounts problem (Leetcode 721). Provide pseudocode line by line with explanations. Use Start, End, Decision, arrow, etc.\n\nWe should cover:\n\n- Input list accounts\n- Build mapping email -> name, email -> component (union-find). Use DSU or graph.\n\nSimplify: use DSU.\n\nSteps: initialize DSU, map email to name, union emails within same account.\n\nAfter unions, group by root, collect emails, sort, add name.\n\nReturn list.\n\nWe produce line-by-line virtual code with explanation.\n\nLet's produce maybe around 25-30 lines.\n\nEnsure each line ends with // explanation.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定空的字典 emailToName // 以 email 為鍵記錄對應的姓名\n→ Step 2: 設定空的字典 parent  // 用於 DSU 的父節點映射\n→ Step 3: 定義函式 find(x) // DSU 查找，並做路徑壓縮\n→     Step 3.1: If parent[x] ≠ x then parent[x] ← find(parent[x]) // 路徑壓縮\n→     Step 3.2: Return parent[x] // 回傳根節點\n→ Step 4: 定義函式 union(a, b) // DSU 合併\n→     Step 4.1: rootA ← find(a)\n→     Step 4.2: rootB ← find(b)\n→     Step 4.3: If rootA ≠ rootB then parent[rootB] ← rootA // 合併兩個集合\n→ Decision: 檢查 accounts 是否為空？ // 防止空輸入\n    Yes → Step 5: Return 空列表 // 若無帳戶，直接回傳空\n    No  →  // 繼續\n→ Step 6: For each account in accounts\n→     Step 6.1: name ← account[0] // 取得姓名\n→     Step 6.2: For each email in account[1:]\n→         Step 6.2.1: If email 不在 parent 中\n→             Yes → Step 6.2.1.1: parent[email] ← email // 初始化父節點\n→         Step 6.2.2: emailToName[email] ← name // 記錄姓名\n→         Step 6.2.3: If first email in account\n→             Yes → Step 6.2.3.1: prevEmail ← email // 先前的 email\n→         No  → Step 6.2.4: union(prevEmail, email) // 合併相鄰 email\n→             Step 6.2.4.1: prevEmail ← email // 更新先前的 email\n→ Step 7: 建立字典 rootToEmails // 根節點到其所有 email 的映射\n→ Step 8: For each email in parent.keys()\n→     Step 8.1: root ← find(email) // 找到此 email 的根\n→     Step 8.2: If root 不在 rootToEmails 中\n→         Yes → Step 8.2.1: rootToEmails[root] ← 空列表 // 初始化\n→     Step 8.3: rootToEmails[root].append(email) // 將 email 加入對應集合\n→ Step 9: 建立結果列表 mergedAccounts\n→ Step 10: For each root, emailsList in rootToEmails.items()\n→     Step 10.1: Sort emailsList  // 依字母順序排序\n→     Step 10.2: name ← emailToName[emailsList[0]] // 取第一個 email 對應的姓名\n→     Step 10.3: mergedAccounts.append([name] + emailsList) // 加入完整帳戶\n→ End // 程式執行結束，返回 mergedAccounts"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,1,4,1,1,0,1,6]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 1, 4, 1, 1, 0, 1, 6]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # 建立 blacklist 的集合，方便 O(1) 查詢\n        black_set = set(blacklist)\n        # 可用數字的個數\n        self.size = n - len(blacklist)\n        # 建立映射表：將低區域 (< size) 的黑名單數字映射到高區域合法數字\n        self.mapping = {}\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                # 找到不在 blacklist 的最高數字作為映射目標\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        # 只呼叫一次隨機數產生器\n        idx = random.randint(0, self.size - 1)\n        # 若 idx 在映射表中則返回映射值，否則直接返回 idx\n        return self.mapping.get(idx, idx)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n\n    # 讀取兩行輸入：命令列表和對應的參數列表\n    cmds = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(cmds, args_list):\n        if cmd == \"Solution\":\n            # 建構物件，參數為 n 與 blacklist\n            obj = Solution(*args)\n            results.append(None)\n        elif cmd == \"pick\":\n            # 呼叫 pick，將結果加入結果清單\n            results.append(obj.pick())\n        else:\n            # 若有其他命令，視需求自行處理\n            results.append(None)\n\n    # 以 JSON 格式輸出結果，讓 None 變成 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line with comments, following the format: \"Start\", \"→ Step 1: ...\" etc. No actual code, just steps.\n\nAlgorithm: classic solution: map blacklisted numbers in [0, n-1] to allowed numbers in [0, n-1] excluding blacklist. Count whitelist size M = n - len(blacklist). Preprocess: build a set of blacklist numbers. For each blacklisted number b < M, map it to a number from tail (i from n-1 down) not in blacklist. Use dictionary mapping.\n\nDuring pick: random integer k in [0, M-1]. If k in mapping, return mapping[k], else return k.\n\nSo virtual code: initialization: Start, Step: store n, store blacklist set, compute M, build map, etc.\n\nPick: generate random, check mapping.\n\nNeed to use arrows and decisions.\n\nLet's write.\n\nAlso mention minimizing calls to random: only one call per pick.\n\nProceed.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收 n 與 blacklist // 初始化參數  \n→ Step 2: 建立 setB ← set(blacklist) // 方便 O(1) 查詢  \n→ Step 3: 計算 M ← n - |blacklist| // 可用數字總數  \n→ Step 4: 建立空字典 map // 用於映射黑名單中 < M 的數字到合法尾數  \n→ Step 5: 初始化 ptr ← n-1 // 指向尾部數字  \n→ Decision: 有黑名單中小於 M 的數字? // 檢查是否需要建立映射  \n    Yes → → Step 6: 遍歷每個 b in blacklist  \n        → Decision: b < M? // 僅對低區域的黑名單進行映射  \n            Yes → → Step 7: while ptr in setB: ptr ← ptr - 1 // 找到非黑名單尾數  \n            → Step 8: map[b] ← ptr // 建立映射  \n            → Step 9: ptr ← ptr - 1 // 移動至下一個尾數  \n        No  → → Step 10: 繼續下一個 b  \n    No  → → Step 11: 跳過映射步驟  \n→ End // 初始化完成  \n\nStart // pick 函式開始  \n→ Step 12: r ← random_int(0, M-1) // 只呼叫一次隨機數產生器  \n→ Decision: r in map? // 判斷 r 是否為映射鍵  \n    Yes → → Step 13: return map[r] // 返回映射後的合法數字  \n    No  → → Step 14: return r // r 本身已合法，直接返回  \nEnd // pick 函式結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.05372,0.39025],[0.15538,-0.00839],[0.55962,0.6726]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.05372, 0.39025], [0.15538, -0.00839], [0.55962, 0.6726]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 均勻地在圓內取一點\n        r = self.radius * math.sqrt(random.random())  # sqrt 保證均勻分布\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [round(x, 5), round(y, 5)]  # 取五位小數，方便比對\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data or len(data) < 2:\n        sys.exit(0)\n\n    commands = ast.literal_eval(data[0])  # e.g. [\"Solution\", \"randPoint\", ...]\n    args_list = ast.literal_eval(data[1])  # e.g. [[1.0,0.0,0.0], [], ...]\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # 建構子，返回 null\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            # 呼叫方法\n            method = getattr(obj, cmd)\n            res = method(*args) if args else method()\n            results.append(res)\n\n    # 使用 json.dumps 讓 None 變成 null，且保留數字格式\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. No actual code, just pseudo steps. We need to show steps of initialization and randPoint. Use random uniform distribution. Approach: choose random angle uniform [0,2π) and random radius sqrt(r)*sqrt(u) to maintain uniform density. Then offset by center. Provide steps. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立主類別  \n→ Decision: 是否進入建構子? // 檢查是否呼叫建構子  \n    Yes → Step 2: 接收 radius, x_center, y_center // 取得圓半徑與中心座標  \n    → Step 3: 存儲 radius → Step 4: 存儲 x_center → Step 5: 存儲 y_center // 保存參數到物件屬性  \n    → Step 6: 建構子結束 // 完成初始化  \n→ Step 7: 定義方法 randPoint() // 用於產生隨機點  \n→ Decision: 是否呼叫 randPoint()？ // 檢查是否需要生成點  \n    Yes → Step 8: 生成隨機角度 θ ∈ [0, 2π) // 隨機選取角度  \n        → Step 9: 生成隨機半徑 r' = radius * sqrt(U)，其中 U ∈ [0,1) // 透過 sqrt 使分布均勻  \n            → Step 10: 計算偏移 x_offset = r' * cos(θ) // 將極座標轉回直角座標  \n            → Step 11: 計算偏移 y_offset = r' * sin(θ) // 同上  \n            → Step 12: 計算最終 x = x_center + x_offset // 加上中心座標  \n            → Step 13: 計算最終 y = y_center + y_offset // 同上  \n            → Step 14: 回傳 [x, y] // 回傳隨機點  \n    No → Step 15: 不進行任何操作 // 若未呼叫方法，則不生成點  \nEnd // 程式執行結束"
    },
    {
      "title": "Ones and Zeroes",
      "source_file": "Leetcode/leetcode474.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2881skyl.py\", line 23, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7x6uwden.py\", line 23, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\n    ^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 逆序遍歷，避免重複使用同一個字串\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，預期為類似 'strs = [...], m = ..., n = ...' 的格式\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 用 exec 解析變數，允許直接使用 eval 風格輸入\n    local_vars = {}\n    exec(data, {}, local_vars)\n    strs = local_vars.get('strs', [])\n    m = local_vars.get('m', 0)\n    n = local_vars.get('n', 0)\n\n    sol = Solution()\n    result = sol.findMaxForm(strs, m, n)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code for the problem: find largest subset of binary strings given constraints on number of 0's and 1's.\n\nWe need to produce a dynamic programming solution. Steps: Start, compute counts of zeros and ones for each string, initialize DP array size (m+1)*(n+1) with zeros. For each string, iterate i from m down to zeros, j from n down to ones, dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1). After processing all strings, answer dp[m][n]. Then End.\n\nWe need to output line-by-line with arrow and comments. Provide arrow lines: Start, then Step 1, Step 2 etc. Use \"→\" arrows. Decision not needed except maybe final output. But we can show decision for max? not necessary. But we can use Step 1: 解析輸入. Step 2: 建立 dp.\n\nWe must ensure each line has \"虛擬碼步驟\" then a space then comment.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 讀取輸入 strs, m, n // 取得輸入資料\n\nLine 3: → Step 2: 建立 dp 陣列大小 (m+1) × (n+1)，全部初始為 0 // DP 用於記錄最大子集大小\n\nLine 4: → Decision: 是否已有處理完所有字符串? // 迭代每個字符串\n\nWe need a loop. Represent with arrows: Step 3: 針對每個字符串 s in strs // 逐一處理\n\nThen inside loop we need to compute zeroCount, oneCount.\n\nLine 5: → Step 4: 計算 s 的 0 與 1 的數量 zeroCount, oneCount // 這兩個值用於 DP 的限制\n\nThen inner loops: iterate i from m down to zeroCount, j from n down to oneCount.\n\nLine 6: → Step 5: for i = m downto zeroCount\n\nLine 7: → Step 6: for j = n downto oneCount\n\nLine 8: → Step 7: dp[i][j] = max(dp[i][j], dp[i-zeroCount][j-oneCount] + 1) // 更新 DP\n\nClose loops and continue to next string.\n\nAfter loop end, answer is dp[m][n].\n\nLine 9: → Step 8: 輸出 dp[m][n] // 最終結果\n\nEnd.\n\nWe need to ensure each line uses arrow. For loops we can use \"→\" preceding each step.\n\nBut the example shows indentation for decisions and sub-steps. We can just indent with tabs or spaces? Example uses tabs? \"    Yes → Step 2:\" etc. We'll replicate indenting.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入 strs, m, n // 取得輸入資料\n→ Step 2: 建立 dp 陣列大小 (m+1) × (n+1)，全部初始為 0 // DP 用於記錄最大子集大小\n→ Decision: 是否已處理完所有字符串? // 檢查是否結束迴圈\n    Yes → End // 結束程式\n    No  → Step 3: 針對每個字符串 s in strs // 逐一處理\n        → Step 4: 計算 s 的 0 與 1 的數量 zeroCount, oneCount // 這兩個值用於 DP 的限制\n        → Decision: zeroCount > m 或 oneCount > n? // 檢查此字串是否能被加入\n            Yes → Continue // 跳過此字串\n            No  → Step 5: for i = m downto zeroCount\n                → Step 6: for j = n downto oneCount\n                    → Step 7: dp[i][j] = max(dp[i][j], dp[i-zeroCount][j-oneCount] + 1) // 更新 DP\nAfter loop, → Step 8: 輸出 dp[m][n] // 最終結果\nEnd // 程式執行結束\n\nBut the example didn't include continue; but it's fine.\n\nHowever we need to keep arrow usage correct. Example uses \"→ Decision:\" for decision. For loop steps they use \"→ Step:\".\n\nWe may need to show loops as Steps.\n\nLet's rewrite more clearly.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入 strs, m, n // 取得輸入資料\n→ Step 2: 初始化 dp 陣列 (m+1)×(n+1)，全部為 0 // 用於動態規劃\n→ Decision: 是否已經處理完所有字串？ // 檢查迴圈結束條件\n    Yes → End // 程式結束\n    No  → Step 3: 逐一遍歷 strs 中的每個字串 s // 開始處理每個字串\n        → Step 4: 計算 s 的 0 與 1 的數量 zeroCount, oneCount // 為 DP 做準備\n        → Decision: zeroCount > m 或 oneCount > n? // 若超過限制直接跳過\n            Yes → Continue // 跳過此字串\n            No  → Step 5: 從 i = m 下降到 zeroCount\n                → Step 6: 從 j = n 下降到 oneCount\n                    → Step 7: dp[i][j] = max(dp[i][j], dp[i-zeroCount][j-oneCount] + 1) // 更新 DP\nAfter 完成所有字串 → Step 8: 回傳 dp[m][n] // 取得最大子集大小\nEnd // 程式結束\n\nWe need to ensure each line has \"虛擬碼步驟\" then space then comment. Let's provide exactly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入 strs, m, n // 取得輸入資料\n→ Step 2: 初始化 dp 陣列 (m+1)×(n+1)，全部為 0 // 用於動態規劃\n→ Decision: 是否已經處理完所有字串？ // 檢查迴圈結束條件\n    Yes → End // 程式結束\n    No  → Step 3: 逐一遍歷 strs 中的每個字串 s // 開始處理每個字串\n        → Step 4: 計算 s 的 0 與 1 的數量 zeroCount, oneCount // 為 DP 做準備\n        → Decision: zeroCount > m 或 oneCount > n? // 若超過限制直接跳過\n            Yes → Continue // 跳過此字串\n            No  → Step 5: 從 i = m 下降到 zeroCount\n                → Step 6: 從 j = n 下降到 oneCount\n                    → Step 7: dp[i][j] = max(dp[i][j], dp[i-zeroCount][j-oneCount] + 1) // 更新 DP\n→ Step 8: 回傳 dp[m][n] // 取得最大子集大小\nEnd // 程式結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,2,3],[1,2,3],[2,3,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 2, 3], [1, 2, 3], [2, 3, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = list(nums)          # 原始陣列備份\n        self.current = list(nums)           # 可被打亂的陣列\n\n    def reset(self):\n        self.current = list(self.original)\n        return self.current\n\n    def shuffle(self):\n        shuffled = list(self.current)\n        n = len(shuffled)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 將輸入包裝成元組以方便 eval\n    ops, args = eval('(' + raw + ')')\n    outputs = []\n    obj = None\n    for i, op in enumerate(ops):\n        if op == \"Solution\":\n            obj = Solution(args[i][0])   # args[i] 為 [[1,2,3]]\n            outputs.append(None)\n        elif op == \"reset\":\n            outputs.append(obj.reset())\n        elif op == \"shuffle\":\n            outputs.append(obj.shuffle())\n    # 將結果輸出為 JSON，Python 的 None 會轉為 null\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe user wants virtual code steps. Need to produce step-by-step pseudocode for a solution that randomly shuffles an integer array. Provide explanation after each line. Use the arrow format and decision structure. Provide the code in that format. We need to include initialization, reset, and shuffle methods. For shuffle, we can use Fisher-Yates shuffle algorithm. Provide steps accordingly.\n\nWe need to output the virtual code lines, each line with \"虛擬碼步驟\" and \"// 解釋/說明\". We should maintain the indentation with arrows. Use Start, End, Decision. So we need to produce a sequence of lines that represents the algorithm. The pseudocode likely includes class structure: Start, initialize with original array, store copy, shuffle method.\n\nWe should avoid actual code, just steps. We can use pseudo like: Start // 程式開始執行. Then class Solution { … } but using steps.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類別\n→ Step 2: 在 Constructor 接收 nums // 將原始陣列存入\n    → Step 2.1: 把 nums 複製成 original // 原始順序備份\n    → Step 2.2: 把 nums 複製成 current // 目前陣列\n→ Step 3: 定義 reset 方法 // 重置陣列\n    → Step 3.1: 把 current 設為 original 的複製 // 恢復原始順序\n    → Step 3.2: 回傳 current // 回傳重置後陣列\n→ Step 4: 定義 shuffle 方法 // 隨機打亂陣列\n    → Step 4.1: 設定 n 為 current 長度 // 取得陣列長度\n    → Step 4.2: 從 i = n-1 到 1 迴圈 // Fisher–Yates 迴圈\n        → Step 4.2.1: 隨機產生 j 在 [0, i] 之間 // 隨機選取索引\n        → Step 4.2.2: 交換 current[i] 與 current[j] // 交換元素\n    → Step 4.3: 回傳 current // 回傳隨機排列陣列\nEnd // 程式執行結束\n\nWe can also include decisions like random range. But the algorithm is straightforward.\n\nWe should ensure each line has the pattern \"虛擬碼步驟 // 解釋\".\n\nWe can use indentation with arrow for nested steps. For Decision, we can use if but not necessary.\n\nWe can produce final output accordingly. Ensure we keep the format.\n\nLet's write the final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: Constructor 接收 nums // 初始化時接收原始陣列  \n    → Step 2.1: 把 nums 複製成 original // 保存原始順序作備份  \n    → Step 2.2: 把 nums 複製成 current // 用於後續操作的現行陣列  \n→ Step 3: 定義 reset() 方法 // 重新回到原始順序  \n    → Step 3.1: 把 current 設為 original 的複製 // 復原為原始陣列  \n    → Step 3.2: 回傳 current // 回傳重置後的陣列  \n→ Step 4: 定義 shuffle() 方法 // 隨機打亂陣列  \n    → Step 4.1: 設定 n 為 current 的長度 // 取得陣列長度  \n    → Step 4.2: 從 i = n-1 迴圈至 1 // Fisher–Yates 交換迴圈  \n        → Step 4.2.1: 隨機產生 j 在 [0, i] 之間 // 隨機選取索引  \n        → Step 4.2.2: 交換 current[i] 與 current[j] // 交換元素  \n    → Step 4.3: 回傳 current // 回傳隨機排列後的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            res.append(path[:])          # 加入目前為止的子集\n            for i in range(start, len(nums)):\n                path.append(nums[i])     # 選擇元素\n                backtrack(i + 1, path)   # 進行遞迴\n                path.pop()               # 回溯\n\n        backtrack(0, [])\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得 list 的部分\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n    list_part = list_part.strip()\n\n    # 使用安全的 eval 解析 list\n    try:\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        nums = ast.literal_eval(data)\n\n    # 確保為 list\n    if not isinstance(nums, list):\n        nums = [nums]\n\n    solution = Solution()\n    subsets = solution.subsets(nums)\n\n    # 以不帶空格的 JSON 方式輸出\n    print(json.dumps(subsets, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all subsets of a unique-element integer array. Use virtual code with Start, Decision, arrows. Should include recursion or iterative approach. Provide step-by-step, each line with explanation. Should not output real code. Just virtual steps.\n\nWe need to produce a linear set of steps. Each step might be labelled Step 1, Step 2 etc. Use \"→\" arrow. Use Decision: If ...? etc. We must ensure unique subsets, but array unique so no duplicates. Return solution in any order. Virtual algorithm: Backtracking.\n\nSo steps:\n\nStart\n→ Step 1: Initialize result list with empty set // start with empty subset\n→ Step 2: Define recursive function backtrack(start, currentSubset) // to build subsets\n→ Decision: If start == length(nums)? // all elements considered\n    Yes → Step 3: Add copy of currentSubset to result // add subset\n    No → Step 4: For each i from start to end\n        → Step 5: Append nums[i] to currentSubset // include element\n        → Step 6: backtrack(i+1, currentSubset) // recurse\n        → Step 7: Remove last element from currentSubset // backtrack\n→ Step 8: Call backtrack(0, emptyList) // start recursion\n→ Step 9: Return result // output all subsets\nEnd\n\nAdd explanation comments for each. Use arrow properly.\n\nWe need to output each line with \"虛擬碼步驟 // 解釋\".\n\nLet's format accordingly. Use Start, End. Use arrow \"→\" before step label.\n\nAlso include decisions lines: Decision: If ...? // explanation.\n\nInside loop, need nested arrow lines. Should indent? In example, indentation with spaces after Decision: lines. But we can just show arrow for each step. For nested steps we can indent by spaces.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為包含空集合的列表 // 開始時結果只含空子集  \n→ Step 2: 定義遞迴函式 backtrack(start, current) // 用來建立子集  \n→ Decision: 若 start == nums.length? // 是否已遍歷完所有元素  \n Yes → Step 3: 把 current 的複製加入 result // 完整子集加入結果  \n No → Step 4: 循環 i 從 start 到 nums.length-1  \n  → Step 5: 把 nums[i] 加入 current // 選擇該元素  \n  → Step 6: 呼叫 backtrack(i+1, current) // 進一步遞迴  \n  → Step 7: 從 current 中移除最後一個元素 // 回溯至上一層  \n→ Step 8: 呼叫 backtrack(0, 空列表) // 從索引 0 開始遞迴  \n→ Step 9: 回傳 result // 輸出所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppq2yrnl8.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmppq2yrnl8.py\", line 25, in main\n    obj = NumArray(arg)\n          ^^^^^^^^^^^^^\n  File \"/tmp/tmppq2yrnl8.py\", line 9, in __init__\n    self.prefix_sums.append(self.prefix_sums[-1] + num)\n                            ~~~~~~~~~~~~~~~~~~~~~^~~~~\nTypeError: unsupported operand type(s) for +: 'int' and 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入視為兩個列表的元組\n    ops, args = ast.literal_eval('(' + data + ')')\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            obj = NumArray(arg)\n            result.append(None)\n        else:\n            # 動態呼叫對應的方法\n            result.append(getattr(obj, op)(*arg))\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: implementing NumArray class with constructor and sumRange method. We'll produce steps: Start, Step 1: initialize prefix sum array, Step 2: handle queries, etc. Also decision? Not necessary but we can show logic. Let's create simple pseudo-code: Build prefix sum, sumRange uses prefix difference.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 NumArray // 宣告 NumArray 類別\n→ Step 2: 在建構子中接收 int[] nums // 傳入原始數組\n→ Step 3: 建立 int[] prefix 其長度為 nums.length + 1 // 前綴和陣列\n→ Step 4: prefix[0] ← 0 // 前綴和初始值\n→ Step 5: 從 i = 1 到 nums.length 進行迴圈 // 建構前綴和\n    → Step 5a: prefix[i] ← prefix[i-1] + nums[i-1] // 累加\n→ Step 6: sumRange 方法接收 left, right // 查詢區間\n→ Step 7: return prefix[right+1] - prefix[left] // 計算區間和\nEnd // 程式執行結束\n\nWe also can add decision? Not necessary.\n\nWe must keep each line with the format. Provide arrow lines with \"→\". Let's include decisions maybe not needed. The requirement: Use virtual code's arrow and Decision if needed. It's okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 NumArray // 宣告 NumArray 類別  \n→ Step 2: 在建構子中接收 int[] nums // 傳入原始數組  \n→ Step 3: 建立 int[] prefix 其長度為 nums.length + 1 // 前綴和陣列  \n→ Step 4: prefix[0] ← 0 // 前綴和初始值  \n→ Step 5: 從 i = 1 到 nums.length 進行迴圈 // 建構前綴和  \n  → Step 5a: prefix[i] ← prefix[i-1] + nums[i-1] // 累加到前綴和  \n→ Step 6: sumRange 方法接收 left, right // 查詢區間  \n→ Step 7: return prefix[right+1] - prefix[left] // 計算區間和  \nEnd // 程式執行結束"
    },
    {
      "title": "Divide Two Integers",
      "source_file": "Leetcode/leetcode29.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "dividend = 10, divisor = 3",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "dividend = 7, divisor = -3",
          "expected_output": "-2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-2'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        \"\"\"\n        Divide two integers without using multiplication, division, and mod operator.\n        Truncate toward zero and clamp to 32-bit signed integer range.\n        \"\"\"\n        INT_MAX = 2 ** 31 - 1\n        INT_MIN = -2 ** 31\n\n        # Handle overflow case\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n\n        # Determine the sign of the result\n        negative = (dividend < 0) != (divisor < 0)\n\n        # Work with positive numbers to simplify the loop\n        dividend_abs = -dividend if dividend < 0 else dividend\n        divisor_abs = -divisor if divisor < 0 else divisor\n\n        quotient = 0\n\n        # Main loop: subtract divisor multiples from dividend\n        while dividend_abs <= -divisor_abs:\n            temp = divisor_abs\n            multiple = 1\n            # Double temp until it is the largest power of two multiple <= dividend_abs\n            while dividend_abs <= -(temp << 1):\n                temp <<= 1\n                multiple <<= 1\n            # Subtract and accumulate quotient\n            dividend_abs -= temp\n            quotient -= multiple  # accumulate as negative to avoid overflow\n\n        # Apply sign\n        if negative:\n            quotient = -quotient\n\n        # Clamp to 32-bit signed integer range\n        if quotient > INT_MAX:\n            return INT_MAX\n        if quotient < INT_MIN:\n            return INT_MIN\n        return quotient\n\nif __name__ == \"__main__\":\n    # Read entire input\n    data = sys.stdin.read()\n    # Extract integers (handles inputs like \"dividend = 10, divisor = 3\")\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) >= 2:\n        dividend, divisor = nums[0], nums[1]\n        result = Solution().divide(dividend, divisor)\n        print(result)\n    else:\n        # Not enough numbers; exit silently\n        pass",
      "virtual_code": "Thinking...\nWe need produce virtual code lines for dividing two integers without using * / %. Use shift subtraction approach. Outline steps: convert to negative to avoid overflow. Use bit shifting to find quotient. Then adjust sign, clamp to range. Provide line by line with arrow etc.\n\nMake sure to start with Start. Use Decision, etc.\n\nLet's craft.\n\nLines:\n\nStart // 程式開始執行\n→ Step 1: 設定 max = 2^31 -1, min = -2^31 // 定義 32-bit 範圍\n→ Step 2: 如果 dividend == min AND divisor == -1 返回 max // 避免 overflow\n→ Decision: 如果 divisor == 0? // 防止除零\n    Yes → Step 3: 返回 error // 或者拋錯，這裡假設返回 0\n    No  → Proceed\n→ Step 4: 確定 sign = (dividend < 0) XOR (divisor < 0) ? -1 : 1 // 判斷結果正負\n→ Step 5: 把 dividend 與 divisor 轉成負數（更大範圍） // 以避免正整數溢出\n    dividend = dividend < 0 ? dividend : -dividend\n    divisor  = divisor  < 0 ? divisor  : -divisor\n→ Step 6: 計算 quotient = 0\n→ Decision: 當 dividend <= divisor? // 只要 dividend 整數小於等於 divisor\n    Yes → Step 7: 退出循環\n    No  → 進入循環\nLoop:\n    → Step 8: 計算 temp = divisor, multiple = 1\n    → Step 9: Decision: 當 temp >= min >> 1 AND dividend <= temp << 1? // 左移直到超過\n        Yes → temp = temp << 1; multiple = multiple << 1 // 乘以2\n        No  → Step 10: dividend = dividend - temp; quotient = quotient - multiple\n              再返回到 Step 9 以尋找下一組\nEnd Loop\n→ Step 11: 如果 sign == -1 把 quotient 轉為正值 // 由於都是負數，直接取負\n    quotient = -quotient\n→ Decision: 如果 quotient > max? // 需要 clamping\n    Yes → Step 12: 返回 max\n    No  → Decision: 如果 quotient < min?\n        Yes → Step 13: 返回 min\n        No  → Step 14: 返回 quotient\nEnd\n\nBut need arrow style: Start → Step etc.\n\nLet's format as required: each line: \"虛擬碼步驟 [space] // 解釋\". Use arrows.\n\nAlso need Decision blocks with Yes → and No →. For loops, we can just use \"Loop:\" but maybe better: \"→ Step 6: 迴圈：當 dividend > divisor?\".\n\nHowever spec wants Use Decision: ... Yes → ... No → ... For loops maybe use Step 6: 進入迴圈: While dividend <= divisor? Then inside loop.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 max = 2^31 -1, min = -2^31 // 定義 32 位元整數範圍  \n→ Step 2: 如果 dividend == min AND divisor == -1 返回 max // 避免 overflow  \n→ Decision: divisor == 0? // 防止除零  \n    Yes → Step 3: 返回 0 // 除零情況，簡單處理  \n    No  → 進行下一步  \n→ Step 4: 計算 sign = (dividend < 0) XOR (divisor < 0) ? -1 : 1 // 判斷結果正負  \n→ Step 5: 將 dividend 與 divisor 轉成負數  \n    dividend = dividend < 0 ? dividend : -dividend  \n    divisor  = divisor  < 0 ? divisor  : -divisor // 使數值範圍最大化  \n→ Step 6: 設定 quotient = 0 // 初始商  \n→ Decision: dividend <= divisor? // 只要 dividend 小於等於 divisor，就停止  \n    Yes → Step 7: 跳出循環  \n    No  → 進入循環  \nLoop Start  \n→ Step 8: 設定 temp = divisor, multiple = 1 // 以 divisor 為起點  \n→ Decision: temp >= min >> 1 AND dividend <= temp << 1? // 能否左移二倍？  \n    Yes → temp = temp << 1; multiple = multiple << 1 // 乘以 2  \n    No  → Step 9: dividend = dividend - temp; quotient = quotient - multiple // 更新  \n        → 回到 Decision  \nLoop End  \n→ Step 10: 如果 sign == -1，則 quotient = -quotient // 轉為正值  \n→ Decision: quotient > max? // 超過上限？  \n    Yes → Step 11: 返回 max  \n    No  → Decision: quotient < min? // 低於下限？  \n        Yes → Step 12: 返回 min  \n        No  → Step 13: 返回 quotient // 正常返回  \nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,3,null,-1,3,4]'\nGot (Norm):      '[None,None,None,1,None,-1,3,None,-1,3,4]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, 3, null, -1, 3, 4]'\nRaw Got:      '[None, None, None, 1, None, -1, 3, None, -1, 3, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}                # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key: int) -> None:\n        \"\"\"Increment the frequency of the given key.\"\"\"\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from old frequency list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to new frequency list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        \"\"\"Return value of key if present, else -1.\"\"\"\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        \"\"\"Insert or update the key with given value.\"\"\"\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict the least frequently used key\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Convert input like '[\"LFUCache\",\"put\",...], [[2],[1,1],...]' to two Python lists\n    ops, args = ast.literal_eval('[' + data + ']')\n    results = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            results.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            val = cache.get(arg[0])\n            results.append(val)\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for implementing LFUCache with capacity, get, put, all O(1). Provide explanation each line. Use Start, End, Decision, arrow. Must be structured pseudocode, not actual code. Use bullet lines? Just one line each with virtual code step and explanation. Use arrows. We need to show overall algorithm: use hashmap key->node, frequency map freq->LinkedHashSet of keys for ordering. Track min frequency. Steps for get: if not exist return -1; else update freq, move key from freq list to freq+1, update min freq if needed. For put: if capacity 0 return; if key exists: update value, call get? or increment freq. If new key: if capacity reached, evict key with min freq and earliest (first) from its list. Then insert new key with freq=1, add to freq map, update min freq=1.\n\nLet's craft virtual code lines sequentially. Use lines like \"Start\" etc. We'll produce code for the class and methods. We'll include \"LFUCache: ...\". Provide steps for init, get, put.\n\nWe'll keep each line as a step: \"Step X: ...\". Provide explanation after //.\n\nNeed to maintain data structures: mapKeyToNode, freqMap, minFreq. Node holds key, value, freq.\n\nWe can produce pseudocode like:\n\nStart // 開始\n\n→ Step 1: 定義類 LFUCache // 這是主類別\n\nWithin class: constructor etc.\n\nWe might need to structure like nested. Use indentation via spaces to show nested blocks. The format doesn't specify indent but we can use spaces.\n\nWe need to output each line with code and explanation. Use '→' for steps.\n\nLet's craft.\n\nWe'll produce like:\n\nStart // 程式開始執行\n→ Step 1: 定義 LFUCache 類，包含成員: capacity, minFreq, keyNodeMap, freqMap // 設定主要資料結構\n→ Step 2: 定義 Node 結構，包含 key, value, freq // 方便管理頻率\n→ Step 3: LFUCache(capacity) → 初始化 capacity, minFreq=0, keyNodeMap={}, freqMap={} // 建構子\n→ Step 4: get(key) // 取得鍵值\n→ Decision: 如果 key 不在 keyNodeMap? // 判斷是否存在\n    Yes → Step 5: 返回 -1 // 不存在回傳 -1\n    No  → Step 6: node ← keyNodeMap[key] // 取得節點\n    → Step 7: UpdateFrequency(node) // 更新頻率\n    → Step 8: 返回 node.value // 回傳值\n→ Step 9: put(key, value) // 插入或更新\n→ Decision: 如果 capacity <= 0? // 檢查容量\n    Yes → Step 10: 返回 // 無效容量不做任何事\n    No  →\n→ Decision: 如果 key 在 keyNodeMap? // 是否已存在\n    Yes → Step 11: node.value ← value // 更新值\n    → Step 12: UpdateFrequency(node) // 更新頻率\n    No  →\n→ Decision: 如果 keyNodeMap.size == capacity? // 是否已滿\n    Yes →\n→ Decision: 找到 freqMap[minFreq] 的最舊鍵 keyToEvict // 取得最舊的鍵\n→ Step 13: 移除 keyToEvict 從 keyNodeMap // 刪除鍵\n→ Step 14: 移除 keyToEvict 從 freqMap[minFreq] // 刪除頻率表\n→ Decision: 如果 freqMap[minFreq] 為空? // 檢查是否還有此頻率\n    Yes → Step 15: 刪除 freqMap[minFreq] // 清空空的頻率表\n→ End of eviction block\n→ Step 16: 新建 node(key, value, freq=1) // 創建新節點\n→ Step 17: keyNodeMap[key] ← node // 加入鍵表\n→ Step 18: 若 freqMap[1] 不存在 則 freqMap[1] ← LinkedHashSet() // 建立頻率1表\n→ Step 19: freqMap[1].add(key) // 加入鍵\n→ Step 20: minFreq ← 1 // 重置最小頻率\n→ End // 程式結束\n\nNeed to include UpdateFrequency function lines:\n\n→ Step 21: 定義 UpdateFrequency(node) // 更新頻率的子程序\n→ Step 22: oldFreq ← node.freq // 取得舊頻率\n→ Step 23: node.freq ← oldFreq + 1 // 增加頻率\n→ Step 24: 移除 node.key 從 freqMap[oldFreq] // 從舊頻率表移除\n→ Decision: 如果 freqMap[oldFreq] 為空? // 檢查空表\n    Yes → Step 25: 刪除 freqMap[oldFreq] // 刪除空表\n→ Decision: 如果 oldFreq == minFreq 且 freqMap[oldFreq] 為空? // 需要更新最小頻率\n    Yes → Step 26: minFreq ← node.freq // 更新 minFreq\n→ Step 27: 若 freqMap[node.freq] 不存在 則 freqMap[node.freq] ← LinkedHashSet() // 建立新頻率表\n→ Step 28: freqMap[node.freq].add(node.key) // 加入新頻率表\n\nBut we need to place UpdateFrequency inside class but before usage.\n\nWe should ensure order: define UpdateFrequency before get/put or can be defined after.\n\nWe must keep each line as \"虛擬碼步驟 // 解釋\". Use \"→\" arrow. For nested decisions use indentation.\n\nLet's produce final answer with each line.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 LFUCache 類，包含成員: capacity, minFreq, keyNodeMap, freqMap // 主資料結構  \n→ Step 2: 定義 Node 結構，包含 key, value, freq // 節點儲存鍵值與頻率  \n→ Step 3: LFUCache(capacity) → 初始化 capacity, minFreq = 0, keyNodeMap = {}, freqMap = {} // 建構子  \n→ Step 4: 定義 UpdateFrequency(node) // 更新節點頻率的子程序  \n→ Step 5: oldFreq ← node.freq // 取得舊頻率  \n→ Step 6: node.freq ← oldFreq + 1 // 將頻率加 1  \n→ Step 7: 移除 node.key 從 freqMap[oldFreq] // 從舊頻率表移除鍵  \n→ Decision: 如果 freqMap[oldFreq] 為空? // 判斷舊頻率表是否空  \n    Yes → Step 8: 刪除 freqMap[oldFreq] // 刪除空表  \n→ Decision: 如果 oldFreq == minFreq 且 freqMap[oldFreq] 為空? // 是否需要更新 minFreq  \n    Yes → Step 9: minFreq ← node.freq // 將 minFreq 更新為新頻率  \n→ Decision: 如果 freqMap[node.freq] 不存在? // 檢查新頻率表是否已建立  \n    Yes → Step 10: freqMap[node.freq] ← LinkedHashSet() // 建立新頻率表  \n→ Step 11: freqMap[node.freq].add(node.key) // 將鍵加入新頻率表  \n→ Step 12: get(key) // 取得鍵值  \n→ Decision: 如果 key 不在 keyNodeMap? // 判斷是否存在  \n    Yes → Step 13: 返回 -1 // 不存在回傳 -1  \n    No → Step 14: node ← keyNodeMap[key] // 取得節點  \n    → Step 15: UpdateFrequency(node) // 更新頻率  \n    → Step 16: 返回 node.value // 回傳值  \n→ Step 17: put(key, value) // 插入或更新鍵值  \n→ Decision: 如果 capacity <= 0? // 檢查容量是否有效  \n    Yes → Step 18: 返回 // 無效容量不執行任何操作  \n    No →  \n→ Decision: 如果 key 在 keyNodeMap? // 是否已存在該鍵  \n    Yes → Step 19: node.value ← value // 更新值  \n    → Step 20: UpdateFrequency(node) // 更新頻率  \n    No →  \n→ Decision: 如果 keyNodeMap.size == capacity? // 檢查是否已滿  \n    Yes →  \n→ Step 21: keyToEvict ← freqMap[minFreq].removeFirst() // 取得最舊的最小頻率鍵  \n→ Step 22: 移除 keyToEvict 從 keyNodeMap // 刪除鍵表中的鍵  \n→ Step 23: 若 freqMap[minFreq] 為空? // 檢查是否還有此頻率  \n    Yes → Step 24: 刪除 freqMap[minFreq] // 刪除空表  \n→ End of eviction block  \n→ Step 25: node ← Node(key, value, freq = 1) // 新建節點  \n→ Step 26: keyNodeMap[key] ← node // 加入鍵表  \n→ Decision: 如果 freqMap[1] 不存在? // 檢查頻率 1 表  \n    Yes → Step 27: freqMap[1] ← LinkedHashSet() // 建立頻率 1 表  \n→ Step 28: freqMap[1].add(key) // 加入鍵至頻率 1 表  \n→ Step 29: minFreq ← 1 // 重置最小頻率  \n→ End // 程式執行結束"
    },
    {
      "title": "Basic Calculator",
      "source_file": "Leetcode/leetcode224.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \" 2-1 + 2 \"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        \"\"\"\n        Evaluate a mathematical expression containing +, -, *, /, parentheses and spaces.\n        Integer division truncates toward zero.\n        \"\"\"\n        def helper(s: str, idx: int) -> tuple[int, int]:\n            stack = []          # 存放已處理完的數字\n            num = 0             # 當前正在讀取的數字\n            last_op = '+'       # 前一個運算子，預設為加法\n            i = idx\n\n            while i < len(s):\n                ch = s[i]\n\n                if ch == ' ':\n                    i += 1\n                    continue\n\n                if ch.isdigit():\n                    num = num * 10 + int(ch)\n                elif ch == '(':\n                    # 進入子表達式，遞歸計算\n                    num, i = helper(s, i + 1)\n                # 如果遇到運算子或右括號，或已到字串結尾，則把前一個數字根據 last_op 處理\n                if ch in '+-*/)' or i == len(s) - 1:\n                    if last_op == '+':\n                        stack.append(num)\n                    elif last_op == '-':\n                        stack.append(-num)\n                    elif last_op == '*':\n                        stack.append(stack.pop() * num)\n                    elif last_op == '/':\n                        # Python 的整除向下取整，這裡要向零截斷\n                        stack.append(int(stack.pop() / num))\n                    # 更新 last_op 為現在的運算子，並重置 num\n                    last_op = ch\n                    num = 0\n\n                if ch == ')':\n                    # 結束子表達式，返回目前為止的結果\n                    return sum(stack), i\n\n                i += 1\n\n            return sum(stack), i\n\n        # 直接調用 helper，從 0 開始\n        result, _ = helper(s, 0)\n        return result\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並從第一個雙引號到最後一個雙引號之間取出表達式\n    raw_input = sys.stdin.read().strip()\n    first_quote = raw_input.find('\"')\n    last_quote = raw_input.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        expr = raw_input[first_quote + 1:last_quote]\n    else:\n        # 如果沒有引號，直接使用整行作為表達式\n        expr = raw_input\n\n    solution = Solution()\n    result = solution.calculate(expr)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step. Problem: Basic calculator evaluate expression string with + - * /. Possibly parentheses? Problem statement didn't specify parentheses but typical Basic Calculator II includes +,-,*,/ without parentheses. Could assume no parentheses. We'll handle +,-,*,/ precedence. Approach: stack, iterate string, build number, when encountering operator or end, push last number with sign. For *,/ combine with previous top. Use long for intermediate.\n\nWe'll produce pseudocode steps.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize stack, num = 0, lastOp = '+'\n→ Step 2: Iterate each character i in string s plus an extra '+' sentinel at end\n→ Decision: If char is digit → accumulate num = num*10 + digit\n→ Decision: If char is operator or i == last index -> handle lastOp\n→ Decision: lastOp is '+': push num\n→ Decision: lastOp is '-': push -num\n→ Decision: lastOp is '*': pop prev, push prev * num\n→ Decision: lastOp is '/': pop prev, push prev / num (integer division truncate towards zero)\n→ Update lastOp = char, reset num=0\nEnd\n→ Step 3: Sum all numbers in stack to get result\n→ Return result\n\nAdd comments.\n\nMake sure each line has virtual code plus comment.\n\nLet's craft lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 stack, num = 0, lastOp = '+' // 建立資料結構與初始變數  \n→ Step 2: 迴圈 i 從 0 到 s.length（包含最後一個虛擬運算子 '+') // 逐字元處理輸入字串  \n    Decision: 若 s[i] 為數字字符  \n        Yes → num = num * 10 + int(s[i]) // 取得完整數字  \n    Decision: 若 s[i] 為運算子或 i 為最後一個位置  \n        Yes → Decision: lastOp 為 '+'  \n            Yes → stack.push(num) // 正數直接加入 stack  \n        Decision: lastOp 為 '-'  \n            Yes → stack.push(-num) // 負數進入 stack  \n        Decision: lastOp 為 '*'  \n            Yes → prev = stack.pop(); stack.push(prev * num) // 先前結果乘上目前數字  \n        Decision: lastOp 為 '/'  \n            Yes → prev = stack.pop(); stack.push(int(prev / num)) // 先前結果除以目前數字，向零截斷  \n        // 更新操作符並重設 num  \n        Yes → lastOp = s[i]; num = 0  \nEnd // 程式執行結束  \n→ Step 3: result = 0  \n→ Step 4: 對 stack 中每個值累加到 result // 求最終總和  \n→ Return result // 回傳計算結果"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjwtqxe93.py\", line 64, in <module>\n    nums = eval(val)            # safe assumption: val is a list literal\n           ^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg2k6w00r.py\", line 64, in <module>\n    nums = eval(val)            # safe assumption: val is a list literal\n           ^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom math import floor\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        Determine whether there exist two indices i and j such that\n        i != j,\n        |i - j| <= indexDiff,\n        |nums[i] - nums[j]| <= valueDiff\n        \"\"\"\n        if indexDiff <= 0 or valueDiff < 0 or not nums:\n            return False\n\n        bucket_size = valueDiff + 1          # bucket width\n        buckets = {}                        # bucket_id -> index\n\n        for j, cur in enumerate(nums):\n            # Remove element that is out of the sliding window\n            if j > indexDiff:\n                old_index = j - indexDiff - 1\n                old_val = nums[old_index]\n                old_bucket = floor(old_val / bucket_size)\n                buckets.pop(old_bucket, None)\n\n            # Current bucket id\n            cur_bucket = floor(cur / bucket_size)\n\n            # Exact match in the same bucket\n            if cur_bucket in buckets:\n                return True\n\n            # Check neighboring buckets for potential match\n            left_bucket = cur_bucket - 1\n            right_bucket = cur_bucket + 1\n\n            if left_bucket in buckets and abs(cur - nums[buckets[left_bucket]]) <= valueDiff:\n                return True\n            if right_bucket in buckets and abs(cur - nums[buckets[right_bucket]]) <= valueDiff:\n                return True\n\n            # Insert current element into its bucket\n            buckets[cur_bucket] = j\n\n        return False\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    parts = [p.strip() for p in data.split(',')]\n    nums = []\n    k = 0\n    t = 0\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        if key == 'nums':\n            nums = eval(val)            # safe assumption: val is a list literal\n        elif key == 'indexDiff':\n            k = int(val)\n        elif key == 'valueDiff':\n            t = int(val)\n\n    sol = Solution()\n    result = sol.containsNearbyAlmostDuplicate(nums, k, t)\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nWe need to produce pseudocode step-by-step for algorithm to find pair indices with constraints. Likely O(n log n) using balanced BST or bucket sort.\n\nSimpler: iterate j, maintain a sliding window of indices [j-indexDiff, j-1], store numbers in balanced BST (or sorted list). For each j, query if there is value in BST within valueDiff. Use something like binary search in sorted list: find floor/ceil.\n\nAlternatively use bucket method: bucket size = valueDiff+1. Use hashmap from bucket id to index. Maintain sliding window by removing older index.\n\nWe need to produce step-by-step pseudocode with explanation each line. Use virtual code arrow. We'll provide generic algorithm.\n\nWe'll produce:\n\nStart\n→ Step 1: Initialize empty map bucketMap // store bucket id -> index\n→ Step 2: For each index j from 0 to len(nums)-1\n    → Decision: If j > indexDiff // window larger than allowed\n        → Step 3: Remove element nums[j-indexDiff-1] from bucketMap // maintain window\n    → Step 4: Compute bucket id for nums[j] // bucket = floor(nums[j]/(valueDiff+1))\n    → Decision: If bucketMap contains bucket // exact match\n        → Step 5: Return true // difference zero <= valueDiff\n    → Decision: If bucketMap contains bucket-1 and abs(nums[j]-bucketMap[bucket-1]) <= valueDiff\n        → Step 6: Return true\n    → Decision: If bucketMap contains bucket+1 and abs(nums[j]-bucketMap[bucket+1]) <= valueDiff\n        → Step 7: Return true\n    → Step 8: bucketMap[bucket] = j // insert current\n→ Step 9: Return false // no pair found\nEnd\n\nBut we also need to consider valueDiff could be zero; bucket size should be valueDiff+1 to avoid zero division.\n\nEdgecases: valueDiff negative? likely non-negative.\n\nWe can also propose sorted list algorithm; but bucket is simpler.\n\nBut we need to include sliding window removal: when j-indexDiff-1 >= 0.\n\nLet's produce step-by-step with explanations.\n\nUse arrow →.\n\nUse Decision: \"如果...?\" for conditions.\n\nWill produce pseudocode lines with comments.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: bucketSize ← valueDiff + 1 // 以 valueDiff+1 為桶寬度，避免除零\n→ Step 2: bucketMap ← 空字典 // bucket id → 索引，維持滑動窗口\n→ Step 3: For j from 0 到 len(nums)-1 // 遍歷所有索引\n    → Decision: 如果 j > indexDiff? // 確保窗口大小不超過 indexDiff\n        Yes → Step 4: oldIdx ← j - indexDiff - 1 // 最舊索引\n              → Step 5: oldVal ← nums[oldIdx]\n              → Step 6: oldBucket ← floor(oldVal / bucketSize) // 計算舊值所在桶\n              → Step 7: 移除 bucketMap[oldBucket] // 從窗口中刪除超時元素\n    → Step 8: curVal ← nums[j] // 當前數值\n    → Step 9: curBucket ← floor(curVal / bucketSize) // 當前數值桶 id\n    → Decision: 如果 bucketMap 含有 curBucket? // 同桶即差值 ≤ valueDiff\n        Yes → Step 10: Return true // 找到符合條件的 (i, j)\n    → Decision: 如果 bucketMap 含有 curBucket-1? 且 abs(curVal - nums[bucketMap[curBucket-1]]) ≤ valueDiff? // 相鄰桶\n        Yes → Step 11: Return true\n    → Decision: 如果 bucketMap 含有 curBucket+1? 且 abs(curVal - nums[bucketMap[curBucket+1]]) ≤ valueDiff? // 相鄰桶\n        Yes → Step 12: Return true\n    → Step 13: bucketMap[curBucket] ← j // 將當前索引加入窗口\n→ Step 14: Return false // 遍歷完畢仍無符合條件\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,0,1,0,0]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null,1,0,1,0,0]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport bisect\n\nclass Solution:\n    \"\"\"\n    Weighted random picker.\n\n    The constructor builds a prefix sum array of the given weights.\n    pickIndex() generates a random integer in [1, total] and uses binary\n    search to find the first prefix that is >= the random number,\n    which corresponds to the selected index.\n    \"\"\"\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    # Read the entire stdin as a single string\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        return\n\n    # Wrap the input in brackets to make it a single Python literal list\n    # e.g. '[\"Solution\",\"pickIndex\"], [[[1]],[]]' -> \n    #      '[' + '[\"Solution\",\"pickIndex\"], [[[1]],[]]' + ']'\n    wrapped = '[' + data_str + ']'\n    try:\n        commands_and_args = ast.literal_eval(wrapped)\n    except Exception as e:\n        # If parsing fails, exit silently\n        return\n\n    commands, args_list = commands_and_args\n    outputs = []\n    obj = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # args[0] contains the weight list, e.g. [1, 3]\n            obj = Solution(args[0])\n            outputs.append(None)\n        elif cmd == \"pickIndex\":\n            res = obj.pickIndex()\n            outputs.append(res)\n        else:\n            # Unsupported command; ignore\n            outputs.append(None)\n\n    # Convert outputs to the desired string format\n    out_str = '[' + ','.join('null' if o is None else str(o) for o in outputs) + ']'\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for implementation of pickIndex based on weighted random selection. We should outline building prefix sum array, generating random number, binary search. Use Start, End, Decision. Provide step-by-step. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 prefixSum 陣列 // 用來儲存累積權重\n    → Step 1.1: 初始化 totalWeight = 0 // 計算總權重\n    → Step 1.2: 對 w 中每個元素 i 執行\n        → Step 1.2.1: totalWeight += w[i] // 累加權重\n        → Step 1.2.2: prefixSum[i] = totalWeight // 儲存到前綴和\n→ Step 2: 在 pickIndex() 中\n    → Step 2.1: 產生隨機數 r = Random(0, totalWeight) // 取介於 0 與總權重之間的數\n    → Step 3: 在 prefixSum 中尋找 r 所在的區間 // 使用二分搜尋以取得對應索引\n        → Decision: r <= prefixSum[mid]? // 判斷 r 是否落在左半段\n            Yes → Step 3.1: 將 right = mid - 1 // 繼續搜尋左側\n            No  → Step 3.2: 將 left = mid + 1 // 繼續搜尋右側\n        → Step 3.3: 當搜尋完成後，left 為第一個大於 r 的索引，返回 left - 1 // 取得符合權重的索引\n→ End // 程式執行結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        用兩個字串表示的非負整數做乘法，結果以字串回傳。\n        \"\"\"\n        # 若任一數字為 0，直接回傳 \"0\"\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        m, n = len(num1), len(num2)\n        # 結果最大長度為 m + n，先初始化全 0\n        pos = [0] * (m + n)\n\n        # 逐位相乘，從右往左\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                # 每次只把單一位數字轉成整數做乘法\n                mul = int(num1[i]) * int(num2[j])\n                # pos 的位置：i+j 位置儲存進位，i+j+1 位置儲存本位\n                p1, p2 = i + j, i + j + 1\n                sum_ = mul + pos[p2]\n                # 將進位累加到更高一位\n                pos[p1] += sum_ // 10\n                # 本位取模 10\n                pos[p2] = sum_ % 10\n\n        # 把整數陣列轉成字串，去除前導 0\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    data = sys.stdin.read()\n    # 取得所有數字字串（允許前導 0）\n    numbers = re.findall(r'\\d+', data)\n    if len(numbers) < 2:\n        # 若輸入不足兩個數字，視為 0\n        num1 = numbers[0] if numbers else '0'\n        num2 = numbers[1] if len(numbers) > 1 else '0'\n    else:\n        num1, num2 = numbers[0], numbers[1]\n\n    sol = Solution()\n    result = sol.multiply(num1, num2)\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for string multiplication algorithm similar to manual multiplication. Use arrays for digits. Steps: initialize result array of length len1+len2. For each digit i from end of num1, for each digit j from end of num2, multiply digits, add to result[i+j+1], handle carry. Then convert result array to string ignoring leading zeros. Ensure not using BigInt or int conversion directly. Use char to int via subtract '0'.\n\nWe produce step lines accordingly. Use Start, End, Decision, etc. Each line with virtual code and explanation. We'll produce steps in order.\n\nLet's craft. Use '→' arrow from Start. Use Decision for skipping leading zeros. Provide comment. Ensure each line has virtual code and comment. Let's produce.\n\nWe need no actual code. Use pseudo: \"Step 1: Initialize result array of size len1+len2 with zeros\" etc.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 num1 與 num2 的長度，分別為 len1、len2 // 取得字串長度  \n→ Step 2: 建立長度為 len1 + len2 的整數陣列 result，全部初始化為 0 // 用於儲存乘積各位  \n→ Step 3: 從 num1 最右位開始迴圈 i = len1 - 1 到 0 // 逐位取出 num1 的每個數字  \n  → Step 3a: 把 num1[i] 轉為整數 digit1 = num1[i] - '0' // 字元轉整數  \n  → Step 4: 在 num2 內部迴圈 j = len2 - 1 到 0 // 逐位取出 num2 的每個數字  \n    → Step 4a: 把 num2[j] 轉為整數 digit2 = num2[j] - '0' // 字元轉整數  \n    → Step 5: 計算乘積 product = digit1 * digit2 // 單位乘法  \n    → Step 6: 將 product 加到 result[i + j + 1] 中，並取得進位 carry = (result[i + j + 1] + product) / 10  \n    → Step 7: 更新 result[i + j + 1] = (result[i + j + 1] + product) % 10 // 存入本位  \n    → Step 8: 把 carry 加到 result[i + j] // 將進位累加到左側位元  \n→ Step 9: 建立 StringBuilder sb 用於拼接最終字串 // 方便轉成文字  \n→ Decision: 若 result[0] 為 0? // 判斷最高位是否為 0  \n  Yes → Step 10: 從 index = 1 開始遍歷 result 並將每個數字轉為字元追加到 sb  \n  No → Step 11: 從 index = 0 開始遍歷 result 並將每個數字轉為字元追加到 sb  \n→ Step 12: 回傳 sb 的字串表示，代表 num1 * num2 的乘積 // 輸出結果  \nEnd // 程式執行結束"
    }
  ]
}