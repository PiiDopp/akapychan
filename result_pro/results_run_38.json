[
  {
    "source_file": "900.json",
    "problem_index_in_file": 0,
    "title": "安全除法",
    "description_snippet": "請寫一個程式，讓使用者輸入兩個整數 a 與 b，輸出 a / b 的結果。若輸入的資料非整數或除數為 0，請顯示錯誤提示『輸入錯誤或除數為 0』。程式必須使用 try / except 結構。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation, following the format. Use Start, End, Decision, arrow. Must incorporate try/except structure. Use 虛擬碼步驟, space, // 解釋.\n\nWe need to produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入 a // ...\n→ Step 2: 取得輸入 b // ...\n→ Decision: 嘗試進行除法計算? // ...\n    Yes → Step 3: 輸出 a / b // ...\n    No  → Step 4: 輸出錯誤訊息 // ...\n\nBut try/except structure should be expressed. We can use Decision: \"執行除法? 可能會發生錯誤\" with Yes/No? Or maybe we use Decision: \"嘗試除法\" and inside Yes branch we output result, No branch output error. But we need to reflect try/except. We could include \"Try:\" step and \"Except:\" step.\n\nLet's structure:\n\nStart\n→ Step 1: 讀取輸入 a // ...\n→ Step 2: 讀取輸入 b // ...\n→ Decision: 進行 try / except? // 這裡使用 try\n    Yes → Step 3: Try 內部: 將 a 和 b 轉成整數 // ...\n    Yes → Step 4: Try 內部: 計算 result = a / b // ...\n    Yes → Step 5: 輸出 result // ...\n    No  → Step 6: Except 內部: 輸出錯誤訊息 // ...\nEnd\n\nBut we need more clarity. Use \"Decision: 進入 try 區塊?\" maybe. Actually, we could do:\n\n→ Decision: 是否進入 try? // 進入 try 以捕捉錯誤\n    Yes → Step 3: Try: 將輸入轉為整數並計算除法 // ...\n    No  → Step 4: Except: 捕捉錯誤並輸出錯誤訊息 // ...\n\nBut the decision may not be necessary; we can just show try block steps and except block steps.\n\nBetter: Use Decision: 是否成功執行 try? If Yes, output result, else output error. But that decision occurs after try.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入 a // 從使用者取得第一個數字\n→ Step 2: 讀取輸入 b // 從使用者取得第二個數字\n→ Decision: 進入 try / except 區塊? // 準備嘗試除法並捕捉錯誤\n    Yes → Step 3: Try: 將 a 與 b 轉為整數並計算 result = a / b // 可能會拋出錯誤\n    Yes → Decision: try 成功? // 判斷是否執行成功\n        Yes → Step 4: 輸出 result // 顯示除法結果\n        No  → Step 5: Except: 捕捉錯誤 // 當轉換或除法失敗時\n            → Step 6: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息\nEnd // 程式執行結束\n\nBut we need to reflect that the except step is executed only on error. So maybe the decision \"try 成功?\" is Yes when no exception, No when exception occurs. Then No branch goes to except.\n\nLet's produce final. Use indentation properly.\n\nBe careful with formatting: each line with \"虛擬碼步驟\" + space + \"// 解釋\".\n\nUse \"→\" before steps.\n\nWe'll output:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入 a // 從使用者取得第一個整數\n→ Step 2: 讀取輸入 b // 從使用者取得第二個整數\n→ Decision: 進入 try / except 區塊? // 準備嘗試除法並捕捉錯誤\n    Yes → Step 3: Try: 將 a 與 b 轉為整數並計算 result = a / b // 可能會拋出錯誤\n    Yes → Decision: try 成功? // 判斷是否執行成功\n        Yes → Step 4: 輸出 result // 顯示除法結果\n        No  → Step 5: Except: 捕捉錯誤 // 當轉換或除法失敗時\n            → Step 6: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息\nEnd // 程式執行結束\n\nBut the \"No\" branch of Decision: try 成功? goes to Step 5. After Step 5, we still need to output error. We already have Step 6 inside Step 5? Actually Step 5 is \"Except: 捕捉錯誤\". Step 6 is inside it? Might be fine. But we might need to indent.\n\nLet's write:\n\n→ Decision: try 成功? // 判斷是否執行成功\n    Yes → Step 4: 輸出 result // 顯示除法結果\n    No  → Step 5: Except: 捕捉錯誤 // 當轉換或除法失敗時\n        → Step 6: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息\n\nYes that matches.\n\nMake sure to use \"→\" before each step and decision. Use \"Decision:\" keyword. Use indentation with spaces.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入 a // 從使用者取得第一個整數\n→ Step 2: 讀取輸入 b // 從使用者取得第二個整數\n→ Decision: 進入 try / except 區塊? // 準備嘗試除法並捕捉錯誤\n    Yes → Step 3: Try: 將 a 與 b 轉為整數並計算 result = a / b // 可能會拋出錯誤\n    Yes → Decision: try 成功? // 判斷是否執行成功\n        Yes → Step 4: 輸出 result // 顯示除法結果\n        No  → Step 5: Except: 捕捉錯誤 // 當轉換或除法失敗時\n            → Step 6: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    try:\n        # 讀取輸入，假設兩個整數以空格或換行分隔\n        data = sys.stdin.read().strip().split()\n        a, b = map(int, data[:2])  # 取前兩個值\n        print(a / b)\n    except (ValueError, ZeroDivisionError):\n        print('輸入錯誤或除數為 0')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "10 0",
          "expected_output": "輸入錯誤或除數為 0",
          "success": true,
          "output": "輸入錯誤或除數為 0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "900.json",
    "problem_index_in_file": 1,
    "title": "統計文字行數",
    "description_snippet": "請寫一個程式，開啟名為 data.txt 的檔案，讀取內容並輸出總共有幾行文字。若檔案不存在，請顯示『找不到檔案！』。請使用 with 語法搭配 try / except。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with line-by-line steps and explanations. Format: \"虛擬碼步驟 // 解釋\". Include arrow symbols. Use Start, End, Decision etc. For file operations: try/except, with open, readlines, len, output. So produce lines like:\n\nStart // 程式開始\n→ Decision: 檔案是否存在? // Check existence\n\nBut we need to use try/except. So maybe:\n\n→ Step 1: 嘗試以讀取模式打開 'data.txt' // open file\n→ Decision: 是否成功? // try success\n\nBut try/except is a structure.\n\nWe need to show with syntax. Use 'with' as a step. So:\n\n→ Step 1: 嘗試以讀取模式開啟檔案 data.txt 並使用 with 語法 // 對檔案進行上下文管理\n\n→ Decision: 是否捕捉到 FileNotFoundError? // 檢查是否出錯\n\nIf error:\n\n    Yes → Step 2: 輸出 '找不到檔案！' // 顯示錯誤訊息\n\nIf no error:\n\n    No → Step 3: 讀取所有行到 list lines // 取得行列表\n    No → Step 4: 計算 len(lines) 為 line_count // 行數\n    No → Step 5: 輸出 '共 X 行' // 顯示行數\n\nEnd\n\nBut need to incorporate the Decision about exception.\n\nUse typical pseudocode with Decision: Try...except.\n\nBetter to show:\n\n→ Step 1: 嘗試執行 with open('data.txt','r') as f: // 開啟檔案\n→ Decision: 是否發生 FileNotFoundError? // 監測例外\n    Yes → Step 2: 輸出 '找不到檔案！'\n    No → Step 3: lines = f.readlines() // 讀取行\n        No → Step 4: line_count = len(lines) // 計算行數\n        No → Step 5: 輸出 '共 {line_count} 行'\n\nBut the indentation maybe. But just provide simple steps.\n\nMake sure each line includes arrow and explanation. Use //.\n\nLet's produce.\n\nNote: We need to include the Decision: Try...except? We can show:\n\nDecision: 是否發生 FileNotFoundError? // 監測檔案是否存在\n\nBut also indicate that we are inside try block. Maybe we can write:\n\n→ Step 1: 嘗試執行 with open('data.txt','r') as f: // 打開檔案\n→ Decision: 是否捕捉到 FileNotFoundError? // 檢查是否發生例外\n    Yes → Step 2: 輸出 '找不到檔案！'\n    No  → Step 3: lines = f.readlines() // 讀取所有行\n        No  → Step 4: line_count = len(lines) // 計算行數\n            No  → Step 5: 輸出 '共 {line_count} 行' // 顯示行數\n\nBut the indentation may be confusing. We just show lines sequentially.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 試圖以讀取模式開啟 'data.txt' 並使用 with 語法? // 檢查檔案是否可開啟  \n    Yes → Step 1: with open('data.txt', 'r') as f: // 進入檔案上下文  \n    No  → Step 2: 輸出 '找不到檔案！' // 檔案不存在，提示錯誤訊息  \n→ Decision: 是否成功進入檔案上下文? // 確認是否進入 try 區塊  \n    Yes → Step 3: lines = f.readlines() // 讀取檔案所有行  \n    No  → End // 若未進入上下文，直接結束  \n→ Step 4: line_count = len(lines) // 計算行數  \n→ Step 5: 輸出 '共 {line_count} 行' // 顯示總行數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef count_lines_in_file():\n    \"\"\"\n    嘗試以讀取模式打開名為 'data.txt' 的檔案，計算並輸出行數。\n    若檔案不存在，則印出錯誤訊息。\n    \"\"\"\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print('檔案共有', len(lines), '行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    # 為符合「從標準輸入讀取資料」的要求，先讀取 stdin（內容不會被使用）。\n    _ = sys.stdin.read()\n    count_lines_in_file()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 1 行",
          "success": true,
          "output": "檔案共有 1 行"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 0,
    "title": "表達式計算",
    "description_snippet": "請寫一個程式，輸入三個整數 a、b、c，計算並輸出結果：a + b * c 和 (a + b) * c。請觀察兩者的不同。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate step-by-step pseudocode with arrows. Provide each line with \"//\" explanation. Use Start, End, Decision maybe not needed. The user wants to input three integers a, b, c, compute a + b * c and (a + b) * c, output results, observe difference.\n\nWe must produce virtual code lines. Each line: \"虛擬碼步驟 // 解釋\". Use arrow → or Decision. Let's produce a simple flow.\n\nStructure:\nStart\n→ Input a\n→ Input b\n→ Input c\n→ Compute result1 = a + b * c\n→ Compute result2 = (a + b) * c\n→ Output result1\n→ Output result2\nEnd\n\nAdd comments. Could also include explanation of operator precedence.\n\nLet's generate accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input a // 從使用者取得第一個整數  \n→ Input b // 從使用者取得第二個整數  \n→ Input c // 從使用者取得第三個整數  \n→ result1 = a + b * c // 先計算 b * c，再加上 a（符合運算子優先順序）  \n→ result2 = (a + b) * c // 先把 a + b 計算後，再乘以 c  \n→ Output result1 // 顯示第一個表達式的計算結果  \n→ Output result2 // 顯示第二個表達式的計算結果  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b, c = map(int, data[:3])\n    expr1 = a + b * c\n    expr2 = (a + b) * c\n    print(f\"a + b * c = {expr1}\")\n    print(f\"(a + b) * c = {expr2}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2 3 4",
          "expected_output": "a + b * c = 14\n(a + b) * c = 20",
          "success": true,
          "output": "a + b * c = 14\n(a + b) * c = 20"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 1,
    "title": "平均分配",
    "description_snippet": "小明有 n 顆糖果，要平均分給 m 個小朋友。請輸入 n 和 m，輸出每個小朋友分到幾顆糖果，剩下幾顆糖果沒有分完。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code outline step-by-step following format. Input n and m, compute division. Output quotient and remainder. Provide explanation after each line. Use arrows. Use Start, End, Decision. Probably need to compute quotient = n / m (integer division), remainder = n mod m. Then output. Should include input steps, decision maybe check m > 0? Could do. For simplicity, include a decision to check if m == 0, handle divide by zero. Provide code lines accordingly.\n\nMake sure each line has: virtual code step + space + // explanation. Use arrows as per spec. Use Start, End, Decision:. Use \"Yes →\", \"No →\". For the decision \"if m == 0?\" Then Yes path: output error, No path: compute.\n\nThus produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 輸入 n // 取得糖果總數\n→ Step 2: 輸入 m // 取得小朋友人數\n→ Decision: 如果 m == 0? // 檢查是否除數為零\n    Yes → Step 3: 輸出 '無法分配，因為小朋友人數為 0' // 顯示錯誤訊息\n    No  → Step 4: 計算 每人糖果 = n ÷ m // 進行整數除法\n→ Step 5: 計算 剩餘糖果 = n mod m // 計算餘數\n→ Step 6: 輸出 '每人分到' 每人糖果 '顆糖果，剩餘' 剩餘糖果 '顆' // 顯示結果\nEnd // 程式執行結束\n\nNeed to ensure each line with virtual code and comment. Use proper arrows: \"→\" preceding each step. Decision lines indent? In example, Decision line uses indent? In example, Decision line preceded by indentation. We'll replicate.\n\nMake sure after each line include // explanation. Use Chinese. Provide no actual code.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n // 取得糖果總數  \n→ Step 2: 輸入 m // 取得小朋友人數  \n→ Decision: 如果 m == 0? // 檢查小朋友人數是否為零  \n  Yes → Step 3: 輸出 '無法分配，因為小朋友人數為 0' // 顯示錯誤訊息  \n  No  → Step 4: 計算 每人糖果 = n ÷ m // 進行整數除法，得到每個小朋友分到的糖果數  \n→ Step 5: 計算 剩餘糖果 = n mod m // 計算無法平均分配的剩餘糖果數  \n→ Step 6: 輸出 '每人分到' 每人糖果 '顆糖果，剩餘' 剩餘糖果 '顆' // 顯示分配結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    per = n // m\n    left = n % m\n    print(f\"每人={per} 剩下={left}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "20 6",
          "expected_output": "每人=3 剩下=2",
          "success": true,
          "output": "每人=3 剩下=2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 0,
    "title": "模擬擲骰子遊戲",
    "description_snippet": "請使用 random 模組，寫一個函數 roll_dice(n)，模擬擲 n 次六面骰，並回傳所有結果的串列。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. Use Start, End, Decision etc. Include random module import. Use function definition roll_dice(n). Inside, create list results, loop i in 1..n, generate random int 1-6, append to list. Return list. No actual code. Use arrows. Provide in Chinese. Each line: virtual code step + space + // explanation. Use arrow \"→\" for normal steps, \"Decision:\" for condition. For loops we can use \"→ Loop: i from 1 to n\". Or \"→ Step: 為每次擲骰\" etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Import random module // 引入 random 模組\n→ Function: roll_dice(n) // 定義函式，接收擲骰次數\n    → Step: 初始化 results 為空串列 // 用於儲存每次擲骰結果\n    → Loop: i 從 1 到 n // 重複擲 n 次\n        → Step: value = random.randint(1,6) // 產生 1~6 的隨機整數\n        → Step: results.append(value) // 將結果加入串列\n    → Step: return results // 回傳所有結果\nEnd // 程式執行結束\n\nBut ensure each line has arrow. For loop maybe use \"→ Loop: i in range(1, n+1)\" etc. For function body we indent lines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import random // 引入 random 模組  \n→ Function: roll_dice(n) // 定義 roll_dice 函式，參數為擲骰次數  \n    → Step: results = [] // 初始化空串列，用於存放每次擲骰結果  \n    → Loop: i in 1..n // 重複擲 n 次  \n        → Step: value = random.randint(1, 6) // 產生 1 至 6 的隨機整數  \n        → Step: results.append(value) // 將此擲骰結果加入 results 串列  \n    → Step: return results // 回傳整個結果串列  \nEnd // 程式執行結束",
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳所有結果的串列。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有程式碼並執行\n    code = sys.stdin.read()\n    exec(code, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,1,3,1,6]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 1, 3, 1, 6]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 1,
    "title": "計算程式執行時間",
    "description_snippet": "請使用 time 模組，寫一個函數 measure_time(func, *args)，用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. The function measure_time(func,*args). Steps: import time, define function measure_time, record start time, call func with *args, record end time, compute elapsed, round to 3 decimal, return result. Also return result of func? The requirement: measure time of func execution and return result? It says \"並回傳結果\" which likely means return the result of func, but also maybe return time? It's ambiguous. Usually measure_time returns the result of func? Or return elapsed time? Might be both. Let's assume returns elapsed time. But maybe they want return elapsed time. We will produce measure_time that returns elapsed time. Also maybe they want round to 3 decimal. We will include rounding. Provide virtual code lines.\n\nWe need to use arrows and Start, End, Decision, etc. For function definition we can use Step 1: define function. Then Step 2: start time. Step 3: call function and store result. Step 4: end time. Step 5: compute elapsed. Step 6: round. Step 7: return rounded elapsed. Also maybe return result? But we will mention that.\n\nWe need to produce code as virtual lines, not real code. Use arrows.\n\nOk produce:\n\nStart\n→ Step 1: Import time module // 引入 time 以取得時間戳\n→ Step 2: Define function measure_time(func, *args) // 宣告測時函式\n    → Step 3: Record start_time ← time.time() // 紀錄起始時間\n    → Step 4: Call result ← func(*args) // 執行目標函式並取得回傳值\n    → Step 5: Record end_time ← time.time() // 紀錄結束時間\n    → Step 6: Compute elapsed ← end_time - start_time // 計算耗時\n    → Step 7: Round elapsed_rounded ← round(elapsed, 3) // 四捨五入到三位小數\n    → Step 8: Return elapsed_rounded // 回傳耗時\nEnd\n\nAlso include maybe return result? But we skip.\n\nWe'll output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Import time module // 引入 time 以取得時間戳\n→ Step 2: Define function measure_time(func, *args) // 宣告測時函式\n    → Step 3: Record start_time ← time.time() // 紀錄起始時間\n    → Step 4: Call result ← func(*args) // 執行目標函式並取得回傳值\n    → Step 5: Record end_time ← time.time() // 紀錄結束時間\n    → Step 6: Compute elapsed ← end_time - start_time // 計算耗時\n    → Step 7: Round elapsed_rounded ← round(elapsed, 3) // 四捨五入到三位小數\n    → Step 8: Return elapsed_rounded // 回傳耗時\nEnd // 程式執行結束",
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"測量函式 func 執行所需的秒數，並回傳四捨五入到小數點 3 位的耗時。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入內容\n    code = sys.stdin.read()\n    # 在包含 measure_time 的全域字典中執行讀入的程式碼\n    exec(code, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 0,
    "title": "BMI 計算器\n",
    "description_snippet": "請撰寫一個程式，依序讀入使用者的姓名、身高（公分，float）、體重（公斤，float），計算 BMI = 體重(kg) / (身高(m))^2，並印出「<姓名> 的 BMI 為 <數值>」。數值四捨...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanations. Use Start, End, Decision. Need to read name, height, weight, compute BMI, round to 1 decimal, print. No actual code. Provide steps. Use arrow →. Ensure each line ends with // explanation. Provide no code. Use proper formatting. Let's craft.\n\nLines:\nStart\n→ Step 1: Read input \"name\" // get user name\n→ Step 2: Read input \"height_cm\" // get height in centimeters\n→ Step 3: Read input \"weight_kg\" // get weight in kilograms\n→ Step 4: Convert height to meters: height_m = height_cm / 100 // convert cm to m\n→ Step 5: Compute bmi = weight_kg / (height_m ^ 2) // calculate BMI\n→ Step 6: Round bmi to 1 decimal place: bmi_rounded = round(bmi, 1) // round\n→ Step 7: Output formatted string \"<name> 的 BMI 為 <bmi_rounded>\" // display result\nEnd\n\nWe could also add decision for input validation but not necessary.\n\nAdd comments.\n\nEnsure each line follows format: \"虛擬碼步驟 // 解釋\".\n\nUse arrow and indentation? Provide arrows at each step. Probably no indentation needed. Use Start, End. Provide arrow for each step. Use maybe \"→\" before step. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取使用者姓名 // 取得使用者的姓名輸入  \n→ Step 2: 讀取身高（公分） // 取得使用者的身高數值（cm）  \n→ Step 3: 讀取體重（公斤） // 取得使用者的體重數值（kg）  \n→ Step 4: 將身高轉換為公尺：height_m = height_cm / 100 // 將 cm 轉成 m  \n→ Step 5: 計算 BMI：bmi = weight_kg / (height_m ^ 2) // 使用公式計算 BMI  \n→ Step 6: 四捨五入 BMI 到小數點後 1 位：bmi_rounded = round(bmi, 1) // 取得保留 1 位小數的結果  \n→ Step 7: 輸出結果：<name> 的 BMI 為 <bmi_rounded> // 顯示姓名及其 BMI  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    # 讀取使用者姓名\n    name = input()\n    # 讀取身高（公分），並轉為 float\n    height_cm = float(input())\n    # 讀取體重（公斤），並轉為 float\n    weight = float(input())\n\n    # 將身高從公分轉成公尺\n    height_m = height_cm / 100\n    # 計算 BMI\n    bmi = weight / (height_m ** 2)\n\n    # 輸出結果，保留 1 位小數\n    print(f\"{name} 的 BMI 為 {bmi:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Alice\n160\n50\n",
          "expected_output": "Alice 的 BMI 為 19.5\n",
          "success": true,
          "output": "Alice 的 BMI 為 19.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 1,
    "title": "兩數計算小工具\n",
    "description_snippet": "請撰寫一個程式，讀入一行包含兩個以空白分隔的整數，將其轉為 int 後，計算並輸出四個結果：和、差（第一個減第二個）、積、平均（保留到小數點後 1 位）。輸出格式固定為：\n和:<和> 差:<差> 積:...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code, each line with \"虛擬碼步驟 // 解釋\" format. Use Start, End, Decision etc. Steps: read line, split, convert to int, compute sum, diff, product, average, format output. Average to 1 decimal place. Use fixed output string.\n\nSo each line like: Start // 程式開始\n\n→ Step 1: 讀入輸入行 // 取得使用者輸入\n\n→ Step 2: 將行拆分為兩個子串 // 以空白分隔\n\n→ Step 3: 轉為整數 a // 把第一個子串轉為 int\n\n→ Step 4: 轉為整數 b // 把第二個子串轉為 int\n\n→ Step 5: 計算 sum = a + b // 和\n\n→ Step 6: 計算 diff = a - b // 差\n\n→ Step 7: 計算 prod = a * b // 積\n\n→ Step 8: 計算 avg = (a + b) / 2.0 // 平均\n\n→ Step 9: 格式化 avg 至 1 位小數 // 保留一位小數\n\n→ Step 10: 產生輸出字串 // 合併四個結果\n\n→ Step 11: 輸出結果 // 顯示\n\nEnd // 程式結束\n\nBut also could use Decision? No need.\n\nMake sure arrow formatting: \"→\" before each step. Use \"Start\" and \"End\" without arrow.\n\nUse Chinese description.\n\nReturn the lines. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀入輸入行 // 取得使用者輸入的一行文字\n→ Step 2: 將行拆分為兩個子串 // 以空白字元分割成兩個字串\n→ Step 3: 轉為整數 a // 把第一個子串轉成整數變數 a\n→ Step 4: 轉為整數 b // 把第二個子串轉成整數變數 b\n→ Step 5: 計算 sum = a + b // 計算兩數之和\n→ Step 6: 計算 diff = a - b // 計算第一個數減第二個數的差\n→ Step 7: 計算 prod = a * b // 計算兩數之積\n→ Step 8: 計算 avg = (a + b) / 2.0 // 計算平均值，使用浮點除法\n→ Step 9: 格式化 avg 至 1 位小數 // 轉成字串並保留小數點後 1 位\n→ Step 10: 產生輸出字串 // 依格式「和:<sum> 差:<diff> 積:<prod> 平均:<avg>」組合結果\n→ Step 11: 輸出結果 // 顯示組合好的字串\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取輸入行並移除首尾空白\n    line = sys.stdin.readline().strip()\n    if not line:\n        return\n\n    # 以空白分割取得兩個整數字串\n    a_str, b_str = line.split()\n\n    # 轉為整數\n    a = int(a_str)\n    b = int(b_str)\n\n    # 計算和、差、積\n    sum_val = a + b\n    diff_val = a - b\n    prod_val = a * b\n\n    # 計算平均值，保留一位小數\n    avg_val = (a + b) / 2\n\n    # 輸出結果，格式為「和:<sum> 差:<diff> 積:<prod> 平均:<avg>」\n    print(f\"和:{sum_val} 差:{diff_val} 積:{prod_val} 平均:{avg_val:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 3\n",
          "expected_output": "和:15 差:9 積:36 平均:7.5\n",
          "success": true,
          "output": "和:15 差:9 積:36 平均:7.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 0,
    "title": "學生資料類別設計",
    "description_snippet": "請定義一個 Student 類別，具有屬性 name（姓名）與 score（分數）。\n1. 於 __init__() 建構子中初始化這兩個屬性。\n2. 定義方法 show_info()，輸出『XXX ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. The user wants a class Student with init, show_info, create two objects, call method. Provide each line with arrow and comment. Use Start, End, Decision maybe not needed, but we can use Decision for branch? Not necessary. We'll just outline sequential steps. Ensure each line has \"虛擬碼步驟\" and comment. Format as:\n\nStart // 程式開始執行\n→ Step 1: 定義 Student 類別 // ...\n\nWe need to be careful with arrow formatting: \"→\" then space, then \"Step 1: ...\". Provide explanation after //. Should we number steps? They used Step 1, Step 2, etc. Use Step 1, Step 2, etc. Also include method definitions inside class.\n\nWe should show that class has __init__, show_info, etc. Then outside create objects. Provide the final End.\n\nWe must not output actual code, only virtual code. Provide each line as described.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Student 類別 // 開始宣告一個名為 Student 的類別  \n→ Step 2: 於 Student 類別內宣告 __init__() 建構子 // 準備初始化屬性  \n→ Step 3: 在 __init__() 內設定 self.name = name // 存儲姓名屬性  \n→ Step 4: 在 __init__() 內設定 self.score = score // 存儲分數屬性  \n→ Step 5: 於 Student 類別內宣告 show_info() 方法 // 定義顯示資訊的方法  \n→ Step 6: 在 show_info() 內輸出「{self.name} 的分數是 {self.score}」 // 顯示姓名與分數  \n→ Step 7: 於程式主體創建第一個 Student 物件：student1 = Student('張三', 88) // 建立學生物件  \n→ Step 8: 呼叫 student1.show_info() // 顯示第一個學生的資訊  \n→ Step 9: 於程式主體創建第二個 Student 物件：student2 = Student('李四', 92) // 建立第二個學生物件  \n→ Step 10: 呼叫 student2.show_info() // 顯示第二個學生的資訊  \nEnd // 程式執行結束",
      "generated_code": "class Student:\n    \"\"\"學生類別，擁有姓名與分數屬性，並能顯示資訊。\"\"\"\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        print(f\"{self.name} 的分數是 {self.score}\")\n\n\ndef main():\n    # 讀取標準輸入，確保程式會把輸入資料消耗完\n    import sys\n    sys.stdin.read()\n\n    # 以程式內建的資料為例，產生兩位學生並顯示資訊\n    student1 = Student(\"Alice\", 90)\n    student2 = Student(\"Bob\", 80)\n\n    student1.show_info()\n    student2.show_info()\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "success": true,
          "output": "Alice 的分數是 90\nBob 的分數是 80"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 1,
    "title": "動物類別繼承",
    "description_snippet": "請設計一個父類別 Animal，包含方法 make_sound()，印出『動物發出聲音』。\n建立子類別 Dog 與 Cat：\n1. Dog 覆寫 make_sound()，輸出『汪汪！』。\n2. Ca...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code in Traditional Chinese, following format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow → etc. Should represent object-oriented structure. Not actual code, just virtual steps. Provide lines for class definitions, method overrides, object creation, method calls. Should follow pattern like:\n\nStart // 程式開始\n→ Step 1: 定義父類別 Animal // ...\n→ Step 2: 定義 Animal 的方法 make_sound() // ...\n→ Step 3: 定義子類別 Dog 繼承 Animal // ...\n→ Step 4: 覆寫 Dog 的 make_sound() // ...\n...\n\nNeed to include decision? No decisions needed. Just sequence.\n\nWe can use \"Step:\" lines. Example format earlier: \"Step 1: ...\" They used \"Step 1:\" but we can use \"Step X:\".\n\nMake sure each line ends with // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義父類別 Animal // 建立 Animal 類別  \n→ Step 2: 在 Animal 中定義方法 make_sound() // 方法會印出「動物發出聲音」  \n→ Step 3: 定義子類別 Dog 繼承 Animal // Dog 以 Animal 為父類別  \n→ Step 4: 覆寫 Dog 的 make_sound() 方法 // 替換父類別的方法  \n→ Step 5: 在 Dog 的 make_sound() 裡印出「汪汪！」 // 狗的聲音輸出  \n→ Step 6: 定義子類別 Cat 繼承 Animal // Cat 以 Animal 為父類別  \n→ Step 7: 覆寫 Cat 的 make_sound() 方法 // 替換父類別的方法  \n→ Step 8: 在 Cat 的 make_sound() 裡印出「喵～」 // 貓的聲音輸出  \n→ Step 9: 建立 Dog 物件 dogInstance // 創建 Dog 物件  \n→ Step 10: 呼叫 dogInstance.make_sound() // 執行 Dog 的聲音方法  \n→ Step 11: 建立 Cat 物件 catInstance // 創建 Cat 物件  \n→ Step 12: 呼叫 catInstance.make_sound() // 執行 Cat 的聲音方法  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Animal:\n    def make_sound(self):\n        print('動物發出聲音')\n\nclass Dog(Animal):\n    def make_sound(self):\n        print('汪汪！')\n\nclass Cat(Animal):\n    def make_sound(self):\n        print('喵～')\n\ndef main():\n    # 讀取 stdin 以符合要求，但對此題無需使用輸入\n    sys.stdin.read()\n    d = Dog()\n    c = Cat()\n    d.make_sound()\n    c.make_sound()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "汪汪！\n喵～",
          "success": true,
          "output": "汪汪！\n喵～"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 0,
    "title": "溫度判斷",
    "description_snippet": "請寫一個程式，輸入一個整數代表氣溫，並依下列規則輸出：\n- 小於 0：『冰點以下』\n- 0~29：『正常範圍』\n- 30~39：『炎熱』\n- 大於等於 40：『極端高溫』...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step with explanation. Use Start, Decision, Yes→, No→ etc. Each line: \"虛擬碼步驟 // 解釋\". We need to output the steps. Steps: Start, input temperature, decision if <0, yes output, no decision if <=29, etc. Use nested decisions. We must ensure each line follows \"虛擬碼步驟 // 解釋\". Use arrow syntax. Let's craft.\n\nStart // 程式開始\n→ Step 1: 輸入氣溫整數 // 取得使用者輸入的氣溫\n→ Decision: 氣溫 < 0? // 判斷是否低於冰點\n    Yes → Step 2: 輸出『冰點以下』 // 低於冰點時輸出訊息\n    No  → Decision: 氣溫 ≤ 29? // 未低於冰點，判斷是否在正常範圍\n        Yes → Step 3: 輸出『正常範圍』 // 正常範圍內輸出訊息\n        No  → Decision: 氣溫 ≤ 39? // 超過29，判斷是否在炎熱區間\n            Yes → Step 4: 輸出『炎熱』 // 炎熱區間輸出訊息\n            No  → Step 5: 輸出『極端高溫』 // 大於等於40時輸出訊息\nEnd // 程式結束\n\nMake sure each line includes the arrow symbol and comment after //. Provide in Traditional Chinese. Provide one line per step. Ensure each line has the same format. Also need to put arrow for nested decisions: maybe use indentation but keep arrow. The arrow is part of code. The format is like:\n\nStart // 程式開始執行\n→ Step 1: 輸入氣溫整數 // ...\n→ Decision: 氣溫 < 0? // ...\n    Yes → Step 2: 輸出『冰點以下』 // ...\n    No  → Decision: 氣溫 ≤ 29? // ...\n        Yes → Step 3: 輸出『正常範圍』 // ...\n        No  → Decision: 氣溫 ≤ 39? // ...\n            Yes → Step 4: 輸出『炎熱』 // ...\n            No  → Step 5: 輸出『極端高溫』 // ...\nEnd // 程式執行結束\n\nYes. Ensure line breaks.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入氣溫整數 // 從使用者取得氣溫數值  \n→ Decision: 氣溫 < 0? // 判斷氣溫是否低於冰點  \n    Yes → Step 2: 輸出『冰點以下』 // 低於冰點時輸出訊息  \n    No  → Decision: 氣溫 ≤ 29? // 未低於冰點，判斷是否在正常範圍  \n        Yes → Step 3: 輸出『正常範圍』 // 正常範圍內輸出訊息  \n        No  → Decision: 氣溫 ≤ 39? // 超過29，判斷是否在炎熱區間  \n            Yes → Step 4: 輸出『炎熱』 // 炎熱區間輸出訊息  \n            No  → Step 5: 輸出『極端高溫』 // 大於等於40時輸出訊息  \nEnd // 程式執行結束",
      "generated_code": "def classify_temperature(temp: int) -> str:\n    if temp < 0:\n        return \"冰點以下\"\n    elif temp < 30:\n        return \"正常範圍\"\n    elif temp < 40:\n        return \"炎熱\"\n    else:\n        return \"極端高溫\"\n\ndef main() -> None:\n    import sys\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    try:\n        temp = int(data)\n    except ValueError:\n        # 如果輸入不是合法整數，直接結束\n        return\n    result = classify_temperature(temp)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "35",
          "expected_output": "炎熱",
          "success": true,
          "output": "炎熱"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 1,
    "title": "三數最大值",
    "description_snippet": "請寫一個程式，輸入三個整數，輸出其中最大的數字。不得使用 Python 內建 max()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, with explanations, in traditional Chinese. Output must be per line, each line: 虛擬碼步驟 + space + // explanation. Use arrows →, Yes→, No→, Decision: etc. We need to handle input of three integers, find maximum without max().\n\nLet's design flow:\n\nStart\n→ Step 1: Read integer a // get first input\n→ Step 2: Read integer b // second input\n→ Step 3: Read integer c // third input\n→ Decision: If a >= b? // compare a and b\n    Yes → Step 4: Assign max_ab = a // a is larger or equal\n    No  → Step 4: Assign max_ab = b // b larger\n→ Decision: If max_ab >= c? // compare current max with c\n    Yes → Step 5: Assign max_val = max_ab // current max remains\n    No  → Step 5: Assign max_val = c // c is new max\n→ Step 6: Output max_val // display maximum\nEnd\n\nMake sure to avoid max() usage. Use conditional assignments.\n\nProvide each line with arrow or indent for decision branches.\n\nLet's produce output accordingly. Use the arrow syntax: Start // ...\n→ Step 1: Read integer a // ...\n→ Step 2: Read integer b // ...\n→ Step 3: Read integer c // ...\n→ Decision: If a >= b? // compare a and b\n    Yes → Step 4: Assign max_ab = a // a is larger or equal\n    No  → Step 4: Assign max_ab = b // b is larger\n→ Decision: If max_ab >= c? // compare current max with c\n    Yes → Step 5: Assign max_val = max_ab // current max remains\n    No  → Step 5: Assign max_val = c // c becomes new max\n→ Step 6: Output max_val // display maximum\nEnd // program ends\n\nCheck formatting: each line must be separate, each line includes the virtual code step + space + // explanation. For lines inside decision, need indent or maybe separate lines starting with Yes → or No →. In example, they show indent: Yes → Step ... inside Decision. We'll follow same format.\n\nMake sure to use arrow arrows: → for steps, Decision: for decision, Yes → etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read integer a // 從使用者取得第一個整數  \n→ Step 2: Read integer b // 從使用者取得第二個整數  \n→ Step 3: Read integer c // 從使用者取得第三個整數  \n→ Decision: If a >= b? // 比較 a 與 b 的大小  \n    Yes → Step 4: Assign max_ab = a // a 大於等於 b，將 a 存入 max_ab  \n    No  → Step 4: Assign max_ab = b // b 大於 a，將 b 存入 max_ab  \n→ Decision: If max_ab >= c? // 比較目前最大值與 c  \n    Yes → Step 5: Assign max_val = max_ab // c 小於等於目前最大，保持 max_ab  \n    No  → Step 5: Assign max_val = c // c 大於目前最大，更新 max_val  \n→ Step 6: Output max_val // 將最大值輸出到螢幕  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b, c = map(int, data[:3])\n\n    if a >= b and a >= c:\n        print(a)\n    elif b >= a and b >= c:\n        print(b)\n    else:\n        print(c)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 25 7",
          "expected_output": "25",
          "success": true,
          "output": "25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 0,
    "title": "倍數輸出",
    "description_snippet": "請寫一個程式，輸入一個正整數 n，使用 for 迴圈搭配 range()，輸出 1~50 之間所有能被 n 整除的數字。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. Virtual code uses arrows and steps. We need to use \"→\" and \"Decision:\" etc. We'll output as per format. We'll include Start, Step 1 input, Step 2 for loop, Decision inside loop to check if divisible. If divisible, output. End. Use for range 1 to 50 inclusive. Provide simple code. Use \"range(1, 51)\" maybe. Use \"if i % n == 0\". We'll produce steps accordingly. Let's craft.\n\nNeed to be careful: each line must have \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow symbol. Start. Then arrow to Step 1: 輸入正整數 n. Then arrow to Step 2: 初始化迴圈 i 從 1 到 50. For loop. Then Decision inside loop: if i mod n == 0. Yes branch outputs. No branch maybe nothing. Then after loop End. Ensure formatting with arrows and indentation for nested decisions. Use spaces indent? The example shows indentation for nested decisions but no extra colon? Use \"Decision:\" then indent inside.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入正整數 n // 從使用者取得 n\n→ Step 2: For i in range 1 to 50 // 建立 1~50 的迴圈\n    → Decision: i 能被 n 整除? // 檢查 i % n 是否為 0\n        Yes → Step 3: 輸出 i // 輸出能被 n 整除的數字\n        No  → // 不是則不輸出\nEnd // 程式結束\n\nNeed to adhere to format: \"虛擬碼步驟 [space] // 解釋/說明\". So for decision we need the \"Decision:\" part. For the no branch maybe just \"No → // 什麼也不做\". Might be okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入正整數 n // 從使用者取得一個正整數  \n→ Step 2: For i in range 1 to 50 // 建立 1~50 的迴圈  \n    → Decision: i 能被 n 整除? // 檢查 i % n 是否等於 0  \n        Yes → Step 3: 輸出 i // 輸出能被 n 整除的數字  \n        No → // 不是則不輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取輸入（只需要第一個數字）\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n\n    # 收集能被 n 整除的 1~50 之間的數字\n    result = []\n    for i in range(1, 51):\n        if i % n == 0:\n            result.append(str(i))\n\n    # 輸出結果，數字之間以空格分隔\n    print(' '.join(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "7",
          "expected_output": "7 14 21 28 35 42 49",
          "success": true,
          "output": "7 14 21 28 35 42 49"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 1,
    "title": "密碼檢查",
    "description_snippet": "請寫一個程式，讓使用者重複輸入密碼，直到輸入正確的密碼 'python123' 為止。每次輸入錯誤都提示『密碼錯誤，請再試一次』，輸入正確時輸出『登入成功』。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line. Provide steps. Use Start, End, Decision. Show arrow. For repeated input, use loop. We can use while True or Decision loop.\n\nWe need to output in the format:\n\nStart // 程式開始執行\n→ Step 1: 讀取使用者輸入密碼 // etc\n\nBut ensure each line has 虛擬碼步驟 + space + // explanation.\n\nWe need to include decision for checking password. Loop until correct. So:\n\nStart\n→ Decision: 是否已輸入正確密碼? // start with false\n    No → Step: 讀取密碼\n    No → Decision: 密碼是否等於 'python123'?\n        Yes → Step: 輸出 '登入成功'\n        No → Step: 輸出 '密碼錯誤，請再試一次'\n    No → (loop back)\nEnd\n\nBut we might need explicit loop arrow. Use `Yes → End` or `No →` etc.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Decision: 是否已成功登入? // 初始為否\n    No  → Step 1: 讀取使用者輸入密碼 // 取得密碼\n    No  → Decision: 輸入的密碼等於 'python123'? // 檢查是否正確\n        Yes → Step 2: 輸出 '登入成功' // 正確則成功\n        No  → Step 3: 輸出 '密碼錯誤，請再試一次' // 錯誤提示\n    No  → Step 4: 重新執行程式開始 // 迴圈回到 Start\nEnd // 程式結束\n\nBut we need arrow for loop. Could use `→` for flow. Maybe:\n\nStart // 程式開始執行\n→ Decision: 是否已成功登入? // 初始為否\n    No → Step 1: 讀取密碼 // 取得密碼\n    No → Decision: 密碼是否正確? // 檢查\n        Yes → Step 2: 輸出 '登入成功' // 成功訊息\n        No  → Step 3: 輸出 '密碼錯誤，請再試一次' // 錯誤提示\n    No → Decision: 是否已成功登入? // 回到判斷，形成迴圈\nEnd // 結束\n\nBut we need to show that we loop until correct. The Decision at end may be same. Use `Yes` to end, `No` to loop.\n\nBetter:\n\nStart // 程式開始執行\n→ Decision: 是否已成功登入? // 初始為否\n    No → Step 1: 讀取密碼 // 取得輸入\n    No → Decision: 輸入的密碼等於 'python123'? // 檢查正確性\n        Yes → Step 2: 輸出 '登入成功' // 正確\n        No  → Step 3: 輸出 '密碼錯誤，請再試一次' // 錯誤\n    No → Decision: 是否已成功登入? // 迴圈判斷，若還未成功則重試\nEnd // 程式結束\n\nBut this is not typical; we might want to show explicit loop arrow: after Step3, go back to Decision. Let's incorporate: Step 3 → Decision: 是否已成功登入? or Step 3 → Step 1 again.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Decision: 是否已成功登入? // 初始為否\n    No → Step 1: 讀取密碼 // 取得使用者輸入\n    No → Decision: 密碼是否等於 'python123'? // 檢查是否正確\n        Yes → Step 2: 輸出 '登入成功' // 正確訊息\n        No  → Step 3: 輸出 '密碼錯誤，請再試一次' // 錯誤提示\n    No → Step 1 // 重新輸入密碼，形成迴圈\nEnd // 程式結束\n\nBut we need to note that Step 1 again. So we loop until success. Good.\n\nLet's produce final answer in required format. Ensure each line ends with `// 解釋/說明`. Use arrows `→`. Use `Decision:` etc.\n\nAlso use `Start` and `End`.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 是否已成功登入? // 初始時尚未登入  \n No → Step 1: 讀取使用者輸入密碼 // 取得使用者輸入  \n No → Decision: 輸入的密碼等於 'python123'? // 檢查密碼是否正確  \n  Yes → Step 2: 輸出 '登入成功' // 正確密碼，輸出成功訊息  \n  No  → Step 3: 輸出 '密碼錯誤，請再試一次' // 錯誤密碼，提示重試  \n No  → Step 1 // 錯誤後重新讀取密碼，形成迴圈  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    correct_password = 'python123'\n    while True:\n        try:\n            pwd = input()\n        except EOFError:\n            break  # 如果沒有更多輸入就結束\n        if pwd == correct_password:\n            print('登入成功')\n            break\n        else:\n            print('密碼錯誤，請再試一次')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "abc\n1234\npython123",
          "expected_output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功",
          "success": true,
          "output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 0,
    "title": "串列操作練習",
    "description_snippet": "請建立一個串列，內容包含整數 1 到 5，接著完成以下操作：\n1. 新增一個元素 6 到串列尾端。\n2. 刪除串列中的第 2 個元素（索引 1 的位置）。\n3. 輸出最後的串列結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line with arrow. Use \"Start\", \"End\", etc. Need to explain each line. For the user: \"建立一個串列，內容包含整數 1 到 5，接著完成以下操作：1. 新增一個元素 6 到串列尾端。2. 刪除串列中的第 2 個元素（索引 1 的位置）。3. 輸出最後的串列結果。\" So we need to produce virtual code lines with explanation. Use structure: Start, → Step ... etc. Use Decision? Not necessary. So just step by step.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow \"→\". Example: \"→ Step 1: 創建串列 [1,2,3,4,5] // 初始化串列\". Yes.\n\nLet's produce.\n\nWe'll use \"Start // 程式開始執行\".\n\nThen \"→ Step 1: 建立串列 list = [1, 2, 3, 4, 5] // 初始值為 1 到 5\".\n\nThen \"→ Step 2: list.append(6) // 在尾端新增元素 6\".\n\nThen \"→ Step 3: list.pop(1) // 刪除索引 1 的元素（第二個元素）\".\n\nThen \"→ Step 4: 輸出 list // 顯示最終串列\".\n\nThen \"End // 程式結束\".\n\nAlso we can add more descriptive steps like \"輸出\" etc.\n\nLet's follow the exact output format. No actual code, just virtual steps.\n\nAlso use arrow \"→\".\n\nMake sure each line: \"虛擬碼步驟 // 解釋\". For the \"→ Step\" lines, include the arrow. The \"Start\" line should be \"Start // 程式開始執行\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立串列 list = [1, 2, 3, 4, 5] // 初始化串列，內容為 1 到 5  \n→ Step 2: list.append(6) // 在串列尾端新增元素 6  \n→ Step 3: list.pop(1) // 刪除索引 1 的元素（即第二個元素）  \n→ Step 4: 輸出 list // 顯示最後的串列結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # Read entire stdin to consume any input (not used)\n    sys.stdin.read()\n    nums = [1, 2, 3, 4, 5]\n    nums.append(6)\n    del nums[1]\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[1, 3, 4, 5, 6]",
          "success": true,
          "output": "[1, 3, 4, 5, 6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 1,
    "title": "集合函數練習",
    "description_snippet": "請建立一個集合 fruits = {'apple', 'banana'}，並完成以下操作：\n1. 使用 add() 新增 'orange'。\n2. 使用 update() 一次新增 'grape' 與...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output line by line virtual code. Steps: Start, define fruits set, then add, update, remove, discard, print. Use arrow notation.\n\nEnsure each line has \"虛擬碼步驟 [space] // 解釋\".\n\nWe must not output actual code, only virtual steps. Use arrows, Decision not needed. So simple sequential steps.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: fruits ← {'apple', 'banana'} // 建立集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 一次新增兩個元素\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'\n→ Step 6: output fruits // 輸出最終集合\nEnd // 程式結束\n\nNeed to format exactly: \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow \"→\". Provide comment after space.\n\nThus each line: \"→ Step X: ...\" followed by space then comment. For Start and End: \"Start\" and \"End\". Example: \"Start // 程式開始執行\". Provide consistent.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits ← {'apple', 'banana'} // 建立集合 fruits，初始包含 'apple' 與 'banana'  \n→ Step 2: fruits.add('orange') // 使用 add() 將 'orange' 新增至集合  \n→ Step 3: fruits.update({'grape', 'melon'}) // 一次新增 'grape' 與 'melon' 至集合  \n→ Step 4: fruits.remove('banana') // 移除集合中的 'banana'，若不存在會拋錯  \n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'，不會拋錯  \n→ Step 6: output fruits // 輸出最終集合內容  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取輸入（若有的話），這裡實際上不需要使用\n    _ = sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'\n    fruits.discard('pineapple')\n\n    # 輸出結果\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"orange\",\"melon\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'orange', 'melon', 'apple'}\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 0,
    "title": "質數判斷函數",
    "description_snippet": "請寫一個函數 is_prime(n)，判斷一個整數是否為質數。如果是質數回傳 True，否則回傳 False。\n\n質數定義：大於 1，且除了 1 和自己本身外，沒有其他因數。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for function is_prime(n). Should include Start, function definition, input n, check n<=1, etc. Use Decision arrows. Provide explanation. Use 虛擬碼步驟 and comment. No actual code. Use structure. Provide steps line by line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函數 is_prime(n) // 宣告一個接受整數 n 的函式  \n→ Step 2: 判斷 n 是否小於等於 1 // 質數必須大於 1  \n→ Decision: n ≤ 1?  \n    Yes → Step 3: 回傳 False // 小於等於 1 的數不是質數  \n    No  → Step 4: 設定 i 為 2 // 從 2 開始檢查可能的因數  \n→ Decision: i * i ≤ n? // 只需要檢查到 sqrt(n)  \n    Yes → Step 5: 判斷 n 除以 i 是否整除 // 檢查 i 是否為 n 的因數  \n        Yes → Step 6: 回傳 False // 有因數，非質數  \n        No  → Step 7: i ← i + 1 // 檢查下一個可能的因數  \n        No → Step 4 迴圈回到 Decision: i * i ≤ n? // 進行下一次迴圈  \n    No  → Step 8: 回傳 True // 迴圈結束，未發現因數，為質數  \nEnd // 程式執行結束",
      "generated_code": "def is_prime(n: int) -> bool:\n    \"\"\"\n    判斷整數 n 是否為質數。\n    質數定義：大於 1，且除了 1 和自己本身外，沒有其他因數。\n    \"\"\"\n    # 1 或更小的數不為質數\n    if n <= 1:\n        return False\n\n    # 只需檢查到平方根即可\n    limit = int(n ** 0.5) + 1\n    for i in range(2, limit):\n        if n % i == 0:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    # 讀取所有標準輸入（可為多行 Python 程式碼）\n    input_code = sys.stdin.read()\n\n    # 執行讀取到的程式碼，讓使用者自行撰寫測試或其他操作\n    # 這裡使用 globals() 讓執行環境可以存取 is_prime 函式\n    exec(input_code, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(is_prime(7))\nprint(is_prime(12))",
          "expected_output": "True\nFalse",
          "success": true,
          "output": "True\nFalse"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 1,
    "title": "計算平均分數",
    "description_snippet": "請寫一個函數 calc_avg(*scores)，接收多個分數作為參數，並回傳平均值 (四捨五入到小數點後 2 位)。\n\n限制：不可使用內建函數 sum()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with explanations. The function calc_avg(*scores) takes variable arguments. Must compute average without sum().\n\nPseudo steps: Start function. Initialize total = 0, count = 0. Iterate over scores: add each to total, increment count. After loop, average = total / count. Round to 2 decimals (using round?). Use round(avg, 2). Return.\n\nEnsure no built-in sum used. Use simple loops.\n\nOutput format: lines: Start // 程式開始執行. Then arrow etc.\n\nWe must include arrows (→). For function definition, we can have Start function calc_avg. Then steps.\n\nWe'll write:\n\nStart // 程式開始執行\n→ Step 1: 定義函數 calc_avg(*scores) // 接收可變參數\n→ Step 2: total ← 0 // 初始化總分\n→ Step 3: count ← 0 // 初始化分數數量\n→ Decision: 是否存在 scores? // 檢查是否有傳入分數\n    Yes → Loop each score in scores: // 逐一處理分數\n        → Step 4: total ← total + score // 累加分數\n        → Step 5: count ← count + 1 // 計數增加\n    No  → Step 6: return 0.0 // 若無分數回傳 0.0\n→ Step 7: avg ← total / count // 計算平均\n→ Step 8: avg_rounded ← round(avg, 2) // 四捨五入到兩位小數\n→ Step 9: return avg_rounded // 回傳平均值\nEnd // 程式結束\n\nNeed to use arrows for Decision branches and loops. Use \"Loop each score in scores:\"? We can express with arrow.\n\nMaybe use \"Loop each score in scores:\" with a nested block.\n\nLet's produce accordingly. Ensure each line ends with // explanation.\n\nCheck format: Each line: virtual code step + space + // explanation.\n\nUse arrow for start and each step. Use \"→\" before each step except Start? In example, Start line had no arrow. Actually example had Start no arrow, but then arrow for each step. We'll follow that.\n\nThus first line: Start // 程式開始執行\nNext lines: → Step 1: 定義函數 calc_avg(*scores) // 接收可變參數\nAnd so on.\n\nLet's ensure Decision: lines: \"→ Decision: 是否存在 scores?\" with indent. Then Yes → etc.\n\nIndent lines: in example, they used indentation for Yes branch. We'll replicate.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函數 calc_avg(*scores) // 接收可變參數  \n→ Step 2: total ← 0 // 初始化總分  \n→ Step 3: count ← 0 // 初始化分數數量  \n→ Decision: 是否存在 scores? // 檢查是否有傳入分數  \n Yes → Loop each score in scores: // 逐一處理分數  \n  → Step 4: total ← total + score // 累加分數  \n  → Step 5: count ← count + 1 // 計數增加  \n No  → Step 6: return 0.0 // 若無分數回傳 0.0  \n→ Step 7: avg ← total / count // 計算平均  \n→ Step 8: avg_rounded ← round(avg, 2) // 四捨五入到兩位小數  \n→ Step 9: return avg_rounded // 回傳平均值  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef calc_avg(*scores):\n    \"\"\"\n    接收任意多個分數，計算其平均值並四捨五入到小數點後 2 位。\n    \"\"\"\n    total = 0\n    count = 0\n    for s in scores:\n        total += s\n        count += 1\n    # 防止除以 0 的情況（雖然題目中預期至少有一個分數）\n    if count == 0:\n        return 0.0\n    return round(total / count, 2)\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整段程式碼並執行\n    code = sys.stdin.read()\n    exec(code, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(calc_avg(80, 90, 100))\nprint(calc_avg(70, 75, 85, 95))",
          "expected_output": "90.0\n81.25",
          "success": true,
          "output": "90.0\n81.25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 0,
    "title": "列表與條件生成式練習",
    "description_snippet": "請寫一個程式，建立一個包含 1 到 20 的整數列表，接著使用列表生成式（List Comprehension）產生一個新列表，只保留偶數並將它們平方後輸出結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. Each line: virtual code step + space + // explanation. Use Start, End, Decision:, → arrows, Yes →, No →. Use \"虛擬碼步驟\" in Chinese. Provide step by step.\n\nUser request: create a program that builds a list of integers from 1 to 20, then uses list comprehension to produce new list containing only even numbers squared, and output the result. So steps: Start, create list, maybe assign to list variable, then create new list with list comprehension, then output. We don't need decision statements unless optional. But we can show simple steps. Use \"虛擬碼步驟\" as e.g., \"Step 1: 建立 1~20 整數列表\". Then \"Step 2: 使用列表生成式產生偶數平方列表\". Then \"Step 3: 輸出結果\". End. Should we use arrow after each step? Format: \"Start // 程式開始執行\" then \"→ Step 1: ... // ...\". Should we indent? Possibly yes. Use \"→\" arrow. Might include \"Decision\" but not needed.\n\nLet's produce: \nStart\n→ Step 1: 建立列表 nums = 1~20 // 用範圍產生 1 至 20 整數\n→ Step 2: 產生 new_list = [x*x for x in nums if x % 2 == 0] // 列表生成式：篩選偶數並平方\n→ Step 3: 輸出 new_list // 顯示結果\nEnd\n\nBut we need to ensure \"虛擬碼步驟\" phrase? The prompt says \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". The example shows \"→ Step 1: ...\" That's fine. They didn't require the phrase \"虛擬碼步驟\". It may be \"Step 1:\" is considered. So we will use \"Step\". Use Chinese for description.\n\nAlso we may include arrow: \"→\" before each step. Provide \"Start\" before. Provide \"End\" after.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 1~20 的整數列表 nums // 用範圍產生 1 至 20 的整數  \n→ Step 2: 產生 new_list = [x*x for x in nums if x % 2 == 0] // 列表生成式：篩選偶數並平方  \n→ Step 3: 輸出 new_list // 顯示偶數平方後的新列表  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入（如果有輸入則會被忽略）\n    sys.stdin.read()\n    # 建立 1~20 的整數列表\n    nums = list(range(1, 21))\n    # 列表生成式：保留偶數並平方\n    result = [n * n for n in nums if n % 2 == 0]\n    # 將結果輸出到標準輸出\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]",
          "success": true,
          "output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 1,
    "title": "map() / filter() / lambda 綜合練習",
    "description_snippet": "請寫一個程式，建立一個列表 numbers = [3, 7, 10, 15, 20]。\n1. 使用 filter() 搭配 lambda 篩選出可被 5 整除的數。\n2. 使用 map() 將這些數字...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines following format. Steps: Start, create list, filter with lambda, map with lambda, output result, End. Provide explanation after // each line. Use arrow → and Decision maybe not needed. Just sequential. Use virtual steps names.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 numbers = [3, 7, 10, 15, 20] // 建立原始列表  \n→ Step 2: filtered = filter(lambda x: x % 5 == 0, numbers) // 篩選出能被 5 整除的元素  \n→ Step 3: mapped = map(lambda x: x * 10, filtered) // 將篩選結果乘以 10  \n→ Step 4: result = list(mapped) // 將 map 物件轉為列表以便顯示  \n→ Step 5: 輸出 result // 顯示最終結果列表  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取所有標準輸入並忽略，確保程式能處理任何輸入\n    sys.stdin.read()\n\n    # 建立原始列表\n    numbers = [3, 7, 10, 15, 20]\n\n    # 1. 篩選能被 5 整除的數字\n    filtered = filter(lambda x: x % 5 == 0, numbers)\n\n    # 2. 將篩選結果乘以 10\n    result = list(map(lambda x: x * 10, filtered))\n\n    # 輸出最終結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[100, 150, 200]",
          "success": true,
          "output": "[100, 150, 200]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 0,
    "title": "JSON 檔案儲存與讀取練習",
    "description_snippet": "請寫一個程式，建立一個字典 data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}。\n1. 使用 json.dump() 將其寫入 data.jso...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user requests to produce virtual code steps for a program that creates a dictionary data, writes to JSON file, reads back, prints name and city. The output must be line by line, each line with virtual code step, a space, and // explanation. Must use arrows and structure: Start, End, Decision, etc. It's straightforward no conditions needed.\n\nWe need to produce virtual code with arrows. Format: Start // 程式開始執行\n→ Step 1: 定義字典 data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'} // 建立資料\n→ Step 2: 開啟檔案 data.json 為寫入模式 // 準備寫入\n→ Step 3: json.dump(data, file) // 將資料寫入檔案\n→ Step 4: 關閉檔案 // 完成寫入\n→ Step 5: 開啟檔案 data.json 為讀取模式 // 準備讀取\n→ Step 6: loaded_data = json.load(file) // 讀取資料\n→ Step 7: 印出 loaded_data['name'] // 顯示 name\n→ Step 8: 印出 loaded_data['city'] // 顯示 city\n→ End // 程式執行結束\n\nBut need to include virtual code steps. They likely want something like:\n\nStart // 程式開始執行\n→ Step 1: data ← {'name': 'Alice', 'age': 25, 'city': 'Taipei'} // 建立資料\n→ Step 2: file ← open('data.json', 'w') // 打開檔案寫入\n→ Step 3: json.dump(data, file) // 寫入 JSON\n→ Step 4: close(file) // 關閉檔案\n→ Step 5: file ← open('data.json', 'r') // 打開檔案讀取\n→ Step 6: loaded_data ← json.load(file) // 讀取 JSON\n→ Step 7: print(loaded_data['name']) // 印出 name\n→ Step 8: print(loaded_data['city']) // 印出 city\n→ End // 程式結束\n\nWe need to ensure each line ends with // explanation. Use virtual code arrow. Use Start, End. No decisions needed. Good. Provide in Chinese. We'll produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: data ← {'name': 'Alice', 'age': 25, 'city': 'Taipei'} // 建立字典資料  \n→ Step 2: file ← open('data.json', 'w') // 開啟檔案進行寫入  \n→ Step 3: json.dump(data, file) // 將字典寫入 JSON 檔案  \n→ Step 4: close(file) // 關閉檔案，確保寫入完成  \n→ Step 5: file ← open('data.json', 'r') // 重新開啟檔案進行讀取  \n→ Step 6: loaded_data ← json.load(file) // 從 JSON 檔案載入資料  \n→ Step 7: print(loaded_data['name']) // 輸出 name 欄位  \n→ Step 8: print(loaded_data['city']) // 輸出 city 欄位  \n→ End // 程式執行結束",
      "generated_code": "import json\nimport sys\n\ndef main() -> None:\n    # 讀取所有標準輸入 (即使內容不被使用，也要讀完避免殘留資料)\n    _ = sys.stdin.read()\n\n    # 建立資料字典\n    data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}\n\n    # 將資料寫入 JSON 檔案\n    with open('data.json', 'w', encoding='utf-8') as f:\n        json.dump(data, f, ensure_ascii=False, indent=2)\n\n    # 從 JSON 檔案讀取資料\n    with open('data.json', 'r', encoding='utf-8') as f:\n        result = json.load(f)\n\n    # 印出姓名與城市\n    print(f'姓名： {result[\"name\"]}')\n    print(f'城市： {result[\"city\"]}')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "姓名： Alice\n城市： Taipei",
          "success": true,
          "output": "姓名： Alice\n城市： Taipei"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 1,
    "title": "即時匯率查詢小工具",
    "description_snippet": "請使用 requests 模組串接匯率 API（https://api.exchangerate-api.com/v4/latest/USD），取得當前美元兌換台幣（TWD）的匯率。\n將結果顯示在 t...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrows and comments in Traditional Chinese. Should use structure: Start, End, Decision. Use → arrow. Must not output actual code. Just virtual steps. The user: \"請使用 requests 模組串接匯率 API（https://api.exchangerate-api.com/v4/latest/USD），取得當前美元兌換台幣（TWD）的匯率。將結果顯示在 tkinter 視窗中，按下按鈕即可更新最新匯率。請根據輸出格式要求產生虛擬碼和逐行解釋。\"\n\nWe need to produce steps for building such an application: import modules, create Tk window, label, button, function to fetch rate, update label, event binding, main loop. Use Start, End, Decision: maybe decision for success/failure of API. So include steps to handle error.\n\nLet's craft lines:\n\nStart\n→ Step 1: Import requests and tkinter modules // 引入網路請求和圖形介面模組\n→ Step 2: 建立 Tk 主視窗 // 初始化 tkinter 視窗\n→ Step 3: 設定視窗標題 'USD to TWD 匯率' // 顯示標題\n→ Step 4: 建立 Label 用於顯示匯率資訊 // 文字顯示元件\n→ Step 5: 建立 Button 標籤 '更新匯率' // 觸發更新按鈕\n→ Step 6: 定義函式 fetch_rate() 以請求 API // 取得匯率資料\n    → Decision: 如果 HTTP 請求成功? // 檢查回傳碼\n        Yes → Step 7: 解析 JSON 並取出 TWD 匯率 // 取得數值\n        Yes → Step 8: 更新 Label 文字為 'USD/TWD: {rate}' // 顯示最新匯率\n        No  → Step 9: 更新 Label 文字為 '取得匯率失敗' // 顯示錯誤訊息\n→ Step 10: 將 fetch_rate() 綁定至 Button 的 command // 按鈕點擊呼叫\n→ Step 11: 初始化時即呼叫 fetch_rate() 以顯示初始匯率 // 首次顯示\n→ Step 12: 執行 Tk 主迴圈 mainloop() // 開始 GUI 事件循環\nEnd\n\nMake sure each line ends with // explanation. Use correct indentation with spaces maybe.\n\nMake sure to include the arrow symbol '→' at start of each step except Start and End. Provide the explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests and tkinter modules // 引入網路請求與圖形介面模組  \n→ Step 2: 建立 Tk 主視窗 // 初始化 tkinter 視窗  \n→ Step 3: 設定視窗標題 'USD to TWD 匯率' // 顯示視窗標題  \n→ Step 4: 建立 Label 用於顯示匯率資訊 // 文字顯示元件  \n→ Step 5: 建立 Button 標籤 '更新匯率' // 觸發更新按鈕  \n→ Step 6: 定義函式 fetch_rate() 以請求 API // 取得匯率資料  \n  → Decision: 如果 HTTP 請求成功? // 檢查回傳碼  \n    Yes → Step 7: 解析 JSON 並取出 TWD 匯率 // 取得數值  \n    Yes → Step 8: 更新 Label 文字為 'USD/TWD: {rate}' // 顯示最新匯率  \n    No  → Step 9: 更新 Label 文字為 '取得匯率失敗' // 顯示錯誤訊息  \n→ Step 10: 將 fetch_rate() 綁定至 Button 的 command // 按鈕點擊呼叫  \n→ Step 11: 初始化時即呼叫 fetch_rate() 以顯示初始匯率 // 首次顯示  \n→ Step 12: 執行 Tk 主迴圈 mainloop() // 開始 GUI 事件循環  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef get_rate():\n    \"\"\"\n    取得美元對台幣匯率。若成功回傳浮點數，失敗回傳 None。\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    try:\n        r = requests.get(url, timeout=5)\n        r.raise_for_status()\n        data = r.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\ndef create_gui():\n    \"\"\"\n    建立 tkinter GUI，包含顯示匯率的 Label 與更新按鈕。\n    \"\"\"\n    win = tk.Tk()\n    win.title(\"美元對台幣匯率查詢\")\n\n    # 初始顯示文字\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update():\n        \"\"\"按鈕點擊時呼叫，更新 label 文字。\"\"\"\n        rate = get_rate()\n        if rate is not None:\n            label.config(text=f\"目前美元匯率：約 {rate:.2f} TWD\")\n        else:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n\n    tk.Button(win, text=\"更新匯率\", command=update).pack(pady=5)\n\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    \"\"\"\n    讀取標準輸入，若包含「按下「更新匯率」按鈕」字串即更新匯率並輸出結果。\n    完成後啟動 GUI。\n    \"\"\"\n    # 讀取整個標準輸入\n    input_text = sys.stdin.read()\n    if \"按下「更新匯率」按鈕\" in input_text:\n        rate = get_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate:.2f} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n\n    # 啟動 GUI 介面\n    create_gui()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "success": false,
          "output": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode306.json",
    "problem_index_in_file": 0,
    "title": "Additive Number",
    "description_snippet": "An additive number is a string whose digits can form an additive sequence.\n\nA valid additive sequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for checking additive number. Provide step by step logic, use Start, Decision, etc. Not actual code. Provide explanation comments. Use arrow. Should cover input, iterate over possible splits for first two numbers, backtracking to check sums. No actual code. Just steps.\n\nLet's craft:\n\nStart // program starts\n→ Step 1: 取得輸入字串 S // get input string\n→ Decision: S長度 < 3? // need at least 3 digits\n    Yes → Return False // too short\n    No → Continue\n→ Step 2: 設定範圍 i 從 1 到 len(S)-2 // first number end\n→ Step 3: 設定範圍 j 從 i+1 到 len(S)-1 // second number end\n→ Decision: 第一個數字或第二個數字以 '0' 開頭且長度>1? // leading zero check\n    Yes → Skip 此 i, j\n    No → 進入 Step 4\n→ Step 4: 取得 num1 = S[0:i] // first number string\n→ Step 5: 取得 num2 = S[i:j] // second number string\n→ Step 6: 呼叫 函式 isValid(num1, num2, j) // check rest of string\n→ Decision: isValid 回傳 True? // rest forms sequence\n    Yes → Return True\n    No → 續迴圈\n→ End // 所有組合檢查完畢\n→ Return False // 沒有合法序列\n\nNeed definition of isValid pseudo:\n\n→ 虛擬碼: isValid(num1, num2, startIndex)\nStart // 檢查剩餘子字串\n→ Decision: startIndex == len(S)? // 已走完字串\n    Yes → Return True // 成功\n    No → Continue\n→ Step 1: sumStr = 加法(num1, num2) // 加法結果字串\n→ Decision: S從 startIndex 開始的長度 < len(sumStr)? // 不足長度\n    Yes → Return False\n    No → Check 前綴\n→ Decision: S[startIndex:startIndex+len(sumStr)] == sumStr? // 匹配\n    Yes → Recursively call isValid(sumStr, S[startIndex+len(sumStr):], startIndex+len(sumStr)) // 進行下一步\n    No → Return False\n\nWe need use arrow notation. Provide step by step with comments. Provide pseudo functions maybe. Use \"→ Decision:\" etc.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 S // 從使用者或測試資料取得待驗證的數字字串  \n→ Decision: S長度 < 3? // 加法序列至少需三個數  \n    Yes → Return False // 字串太短，直接失敗  \n    No  → 進行下一步  \n\n→ Step 2: 設定 i 為第一個數字結束位置 (1 到 len(S)-2) // 第一個數字至少一位，留足兩個以上位  \n→ Step 3: 設定 j 為第二個數字結束位置 (i+1 到 len(S)-1) // 第二個數字至少一位，確保後續還有字元  \n\n→ Decision: 第一個數字或第二個數字以 '0' 開頭且長度>1? // 加法序列禁止前導零  \n    Yes → Skip 此 (i,j) 組合 // 無效，繼續嘗試其他分割  \n    No  → 進入 Step 4  \n\n→ Step 4: num1 = S[0:i] // 取得第一個數字字串  \n→ Step 5: num2 = S[i:j] // 取得第二個數字字串  \n\n→ Step 6: 呼叫 isValid(num1, num2, j) // 檢查剩餘字串是否能成為合法加法序列  \n→ Decision: isValid 回傳 True?  \n    Yes → Return True // 找到合法加法序列，整體驗證成功  \n    No  → 繼續嘗試其他 (i,j)  \n\nEnd // 所有分割組合已檢查完畢  \n→ Return False // 未找到合法加法序列，驗證失敗  \n\n---  \n\n虛擬碼: isValid(num1, num2, startIndex)  \nStart // 逐步驗證剩餘字串  \n→ Decision: startIndex == len(S)? // 已遍歷完所有字元  \n    Yes → Return True // 成功完成加法序列  \n    No  → 進行下一步  \n\n→ Step 1: sumStr = 加法(num1, num2) // 兩個前一數字相加得到下一個數字字串  \n→ Decision: S 的剩餘長度 < len(sumStr)? // 不足以匹配下一個數字  \n    Yes → Return False // 失敗，序列不完整  \n    No  → 進行下一步  \n\n→ Decision: S[startIndex : startIndex+len(sumStr)] == sumStr? // 目前剩餘子字串是否以 sumStr 為前綴  \n    Yes → Recursively call isValid(sumStr, S[startIndex+len(sumStr):], startIndex+len(sumStr)) // 以 sumStr 作為新 num1，原 num2 作為新 num2，移至下一段  \n    No  → Return False // 不匹配，序列失效  \n\nEnd // isValid 函式結束  \n\n此虛擬碼描述了利用兩層迴圈與遞迴回溯，檢驗字串是否能拆成合法的加法序列，並以簡短直觀的說明解釋每一步。",
      "generated_code": "import sys\n\nclass Solution:\n    def isAdditiveNumber(self, num: str) -> bool:\n        n = len(num)\n        if n < 3:\n            return False\n\n        # Try all splits for the first two numbers\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                num1, num2 = num[:i], num[i:j]\n\n                # Skip numbers with leading zeros\n                if (len(num1) > 1 and num1[0] == '0') or (len(num2) > 1 and num2[0] == '0'):\n                    continue\n\n                k = j\n                # Continue building the sequence\n                while k < n:\n                    sum_str = str(int(num1) + int(num2))\n                    if not num.startswith(sum_str, k):\n                        break\n                    k += len(sum_str)\n                    num1, num2 = num2, sum_str\n\n                if k == n:\n                    return True\n        return False\n\n\nif __name__ == \"__main__\":\n    # Read entire input, strip surrounding whitespace\n    raw_input = sys.stdin.read().strip()\n\n    # Remove optional surrounding quotes (e.g., '\"112358\"')\n    if len(raw_input) >= 2 and raw_input[0] == raw_input[-1] and raw_input[0] in ('\"', \"'\"):\n        s = raw_input[1:-1]\n    else:\n        s = raw_input\n\n    solution = Solution()\n    result = solution.isAdditiveNumber(s)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"112358\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"199100199\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode739.json",
    "problem_index_in_file": 0,
    "title": "Daily Temperatures",
    "description_snippet": "Given an array of integers temperatures represents the daily temperatures, return an array answer su...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: daily temperatures, return days until warmer. Use stack algorithm. Steps: start, initialize array answer same size zeros, stack for indices. Loop i from 0 to n-1: while stack not empty and temp[i] > temp[stack.top]: pop idx; answer[idx] = i - idx. push i. end loop. end. Provide virtual code lines. Must use arrows. Each line: virtual code step + space + // explanation. Use Start, End, Decision.\n\nLet's craft.\n\nLine1: Start // 程式開始執行\n\nLine2: → Step 1: n ← length(temperatures) // 取得陣列長度\n\nLine3: → Step 2: answer ← array of n zeros // 初始化答案\n\nLine4: → Step 3: stack ← empty stack of indices // 用於追蹤未處理的天\n\nLine5: → Decision: i = 0 到 n-1 迴圈開始? // 進入主迴圈\n\nLine6:     Yes → Step 4: While stack not empty and temperatures[i] > temperatures[stack.top] // 找到更暖的天\n\nLine7:         Yes → Step 5: idx ← stack.pop() // 取出較舊天的索引\n\nLine8:         Yes → Step 6: answer[idx] ← i - idx // 計算天數差\n\nLine9:     No  → Step 7: stack.push(i) // 將當前天加入堆疊\n\nLine10: → Decision: i < n-1? // 判斷是否還有天要處理\n\nLine11:    Yes → 回到 Line5\n\nLine12:    No  → End // 結束程式\n\nNeed to incorporate loop control. Might include i increment. Use line \"i ← i + 1\". Let's add.\n\nLine5: → Decision: i < n? // 是否已走完陣列\n\nLine6:     Yes → Step 4: While ... (inside)\n\nBut need to increment i. We can include Step 8: i ← i + 1 // 移動到下一天\n\nSimplify: Use for loop pseudo:\n\nStep 4: For i from 0 to n-1: // 逐天處理\n\nInside while. At end of loop body, increment automatically.\n\nBut we need explicit arrow steps. Let's design:\n\nLine4: → Step 4: For i ← 0; i < n; i++ // 逐天迴圈\n\nInside loop, but we must keep indent structure. Use indentation for nested.\n\nOk produce:\n\nStart\n\n→ Step 1: n ← length(temperatures) // 取得陣列長度\n\n→ Step 2: answer ← array of n zeros // 初始化答案陣列\n\n→ Step 3: stack ← empty stack // 用來儲存未找到更暖天的索引\n\n→ Step 4: For i ← 0; i < n; i++ // 循環處理每一天\n\n    → Decision: stack not empty AND temperatures[i] > temperatures[stack.top] // 檢查是否有更暖天\n\n        Yes → Step 5: idx ← stack.pop() // 取出較舊天的索引\n\n        Yes → Step 6: answer[idx] ← i - idx // 計算距離\n\n        Yes → Decision: stack not empty AND temperatures[i] > temperatures[stack.top] // 再次檢查，直到不滿足\n\n        No  → Step 7: stack.push(i) // 把當前天索引放入堆疊\n\nEnd\n\nBut we need to show that while loop. Use nested decisions.\n\nBetter:\n\nLine4: → Step 4: For i ← 0; i < n; i++ // 循環處理每天\n\n    → Decision: stack not empty AND temperatures[i] > temperatures[stack.top] // 是否需要彈出\n\n        Yes → Step 5: idx ← stack.pop() // 取出索引\n\n        Yes → Step 6: answer[idx] ← i - idx // 計算天數\n\n        Yes → Decision: stack not empty AND temperatures[i] > temperatures[stack.top] // 重複\n\n        No  → Step 7: stack.push(i) // 把當前索引加入堆疊\n\nBut we need the loop for the while. Use nested decision inside the for loop.\n\nAlso must include the end of for loop. The indentation indicates nested.\n\nLet's produce final virtual code lines with indentation and arrow.\n\nWe need to use \"→\" for each step. For decisions we use \"Decision:\" with Yes → and No →.\n\nMake sure each line includes explanation.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(temperatures) // 取得陣列長度  \n→ Step 2: answer ← array of n zeros // 初始化答案陣列  \n→ Step 3: stack ← empty stack // 用來儲存尚未找到更暖天的索引  \n→ Step 4: For i ← 0; i < n; i++ // 逐日循環處理  \n  → Decision: stack not empty AND temperatures[i] > temperatures[stack.top] // 判斷是否存在更暖的天  \n   Yes → Step 5: idx ← stack.pop() // 取出較舊天的索引  \n   Yes → Step 6: answer[idx] ← i - idx // 計算距離  \n   Yes → Decision: stack not empty AND temperatures[i] > temperatures[stack.top] // 重複檢查，直到不滿足  \n   No  → Step 7: stack.push(i) // 將當前天的索引加入堆疊  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def dailyTemperatures(self, temperatures):\n        n = len(temperatures)\n        res = [0] * n\n        stack = []\n        for i in range(n):\n            while stack and temperatures[i] > temperatures[stack[-1]]:\n                idx = stack.pop()\n                res[idx] = i - idx\n            stack.append(i)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        temperatures = []\n    else:\n        # 解析輸入的陣列字串，允許使用 Python 字面值\n        temperatures = ast.literal_eval(data)\n    solution = Solution()\n    result = solution.dailyTemperatures(temperatures)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[73,74,75,71,69,72,76,73]",
          "expected_output": "[1,1,4,2,1,1,0,0]",
          "success": true,
          "output": "[1, 1, 4, 2, 1, 1, 0, 0]"
        },
        {
          "example_index": 1,
          "input": "[30,40,50,60]",
          "expected_output": "[1,1,1,0]",
          "success": true,
          "output": "[1, 1, 1, 0]"
        },
        {
          "example_index": 2,
          "input": "[30,60,90]",
          "expected_output": "[1,1,0]",
          "success": true,
          "output": "[1, 1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode71.json",
    "problem_index_in_file": 0,
    "title": "Simplify Path",
    "description_snippet": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Y...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with arrow etc. For the algorithm: input path string. Split by '/', iterate tokens, maintain stack. For token: if token empty or '.' skip; if '..' pop if stack not empty; else push token. After loop join with '/' and prepend '/'. If stack empty return '/'. Provide each line step. Use \"Start\", \"Decision\", \"Step\". Need to output each line with \"→\" maybe. Use format: \"→ Step ... // ...\". We'll produce like:\n\nStart // 程式開始\n→ Step 1: Input absolute path // 取得使用者輸入的完整路徑\n→ Step 2: Split path by '/' into components // 將路徑拆成每段\n→ Step 3: 初始化空堆疊 // 用於儲存有效目錄\n→ Decision: For each component in components? Use loop; but we can express: \"→ Loop: component in components // 逐段處理每個目錄/符號\"\n\nWithin loop: Decision: If component is empty or '.'? etc.\n\nWe need to use arrow lines; maybe nest with indentation. Format similar to example: after Decision: if condition, use Yes → and No → with indentation. Let's produce.\n\nWe'll provide each line with explanation. We'll not produce actual code.\n\nLet's craft pseudocode.\n\nLines:\n\nStart // 程式開始\n\n→ Step 1: Read input path // 取得絕對路徑\n\n→ Step 2: components ← split path by '/' // 分割路徑成各部分\n\n→ Step 3: stack ← empty list // 儲存合法目錄名稱\n\n→ Loop: component in components // 逐一處理每個分段\n\n    → Decision: component is empty or component == '.'? // 空字串或單點\n\n        Yes → // 忽略此分段\n\n        No  → Decision: component == '..'? // 前進至上一層\n\n            Yes → If stack not empty then pop stack // 移除上一目錄\n\n            No  → // 其餘為合法目錄名稱\n\n                → Step 4: push component onto stack // 加入合法目錄\n\n→ End Loop // 迴圈結束\n\n→ Step 5: If stack is empty then simplified ← '/' else simplified ← '/' + join stack with '/' // 重新組合路徑\n\n→ End // 結束程式\n\nBut must use arrow and indentation as in example. Let's format accordingly. Ensure each line ends with \"// 說明\". Use arrow \"→\" for steps and decisions. For nested we indent with spaces and use \"Yes →\" \"No →\". Provide \"Decision:\" lines. After loop we may show \"End Loop\".\n\nLet's produce.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Read input path // 取得使用者輸入的絕對路徑\n→ Step 2: components ← split input path by '/' // 將路徑拆分為各個片段\n→ Step 3: stack ← empty list // 用來儲存合法的目錄名稱\n→ Loop: component in components // 逐個處理每個片段\n    → Decision: component is empty or component == '.'? // 檢查是否為空或單點\n        Yes → // 忽略此片段\n        No  → Decision: component == '..'? // 檢查是否為上層指令\n            Yes → If stack not empty then pop stack // 移除上一個目錄\n            No  → // 其餘情況視為合法目錄名稱\n                → Step 4: push component onto stack // 將合法目錄加入堆疊\n→ End Loop // 所有片段處理完畢\n→ Decision: stack is empty? // 判斷是否仍在根目錄\n    Yes → simplified ← '/' // 若堆疊為空，簡化路徑為根目錄\n    No  → simplified ← '/' + join stack with '/' // 否則重組成以 '/' 分隔的路徑\n→ End // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        \"\"\"\n        Simplify the given Unix-style absolute path.\n        \"\"\"\n        stack = []\n        # 分割路徑成各個片段\n        parts = path.split('/')\n        for part in parts:\n            if part == '' or part == '.':\n                # 空字串或單點符號，直接忽略\n                continue\n            elif part == '..':\n                # 上層目錄，若堆疊不空則 pop\n                if stack:\n                    stack.pop()\n            else:\n                # 其餘皆為合法目錄名稱，加入堆疊\n                stack.append(part)\n        # 重組為簡化路徑\n        return '/' + '/'.join(stack) if stack else '/'\n\n\ndef main() -> None:\n    \"\"\"\n    主程式：從標準輸入讀取資料，處理後輸出簡化後的路徑。\n    \"\"\"\n    # 讀取所有輸入\n    data = sys.stdin.read().strip()\n\n    # 先嘗試從字串中擷取位於雙引號之間的路徑\n    match = re.search(r'\\\"(.*?)\\\"', data)\n    if match:\n        path = match.group(1)\n    else:\n        # 若無雙引號，直接使用整行作為路徑\n        path = data\n\n    # 產生簡化後的路徑\n    result = Solution().simplifyPath(path)\n\n    # 將結果輸出到標準輸出\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "path = \"/home/\"",
          "expected_output": "\"/home\"",
          "success": true,
          "output": "/home"
        },
        {
          "example_index": 1,
          "input": "path = \"/home//foo/\"",
          "expected_output": "\"/home/foo\"",
          "success": true,
          "output": "/home/foo"
        },
        {
          "example_index": 2,
          "input": "path = \"/home/user/Documents/../Pictures\"",
          "expected_output": "\"/home/user/Pictures\"",
          "success": true,
          "output": "/home/user/Pictures"
        },
        {
          "example_index": 3,
          "input": "path = \"/../\"",
          "expected_output": "\"/\"",
          "success": true,
          "output": "/"
        },
        {
          "example_index": 4,
          "input": "path = \"/.../a/../b/c/../d/./\"",
          "expected_output": "\"/.../b/d\"",
          "success": true,
          "output": "/.../b/d"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode347.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Elements",
    "description_snippet": "Given an integer array nums and an integer k, return the k most frequent elements. You may return th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, not actual code, but stepwise logic for solving the problem: find k most frequent elements. Provide explanation after each line. Use arrow notation. Steps: start, count frequencies (maybe hashmap), build array of pairs (num, count), sort by frequency descending, take first k elements, output. Or use min-heap approach. Provide explanation each line. Let's craft steps accordingly. Use Start, End, Decision. Should show algorithm steps clearly.\n\nWe must output in Chinese Traditional. Use line per step.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 建立空的頻率字典 freqMap // 用於存儲每個數字的出現次數\n→ For each num in nums:\n    → freqMap[num] += 1 // 更新頻率\n→ Step 2: 將 freqMap 轉成頻率列表 freqList // 每項為 (num, count)\n→ Step 3: 依照 count 以降序排序 freqList // 使最頻繁的在前面\n→ Step 4: 取出 freqList 前 k 個數字，存入 resultList // 取得 k 個最頻繁元素\n→ End // 輸出 resultList\n\nBut also might include decision to handle tie? Not needed. Provide step by step.\n\nAdd details: Use Sort, or heap.\n\nLet's output with \"Decision:\" maybe not needed.\n\nWe'll include explanation for each line. Ensure each line ends with // explanation. Provide arrow \"→\" before each step. Provide nested arrow inside for loop? We can show For each as Step.\n\nBut maybe include: → Step 1: 初始化 freqMap // 建立空字典\n→ Step 2: 迭代 nums 循環\n→    freqMap[num] += 1 // 更新頻率\n\nLet's do that.\n\nWe need to obey format: each line \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow. Start, End.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的頻率字典 freqMap // 用於存儲每個數字的出現次數  \n→ Step 2: 迭代輸入陣列 nums  \n  → Step 2.1: 對每個 num 更新頻率 freqMap[num] += 1 // 逐個計算頻率  \n→ Step 3: 將 freqMap 轉成頻率列表 freqList，每項為 (num, count) // 方便排序  \n→ Step 4: 依照 count 降序排序 freqList // 使最頻繁的元素排在前面  \n→ Step 5: 建立結果清單 resultList  \n  → Decision: 是否已取 k 個元素? // 判斷是否已達到要求的個數  \n   Yes → End // 若已取完 k 個，結束  \n   No  → Step 5.1: 取 freqList 前一個元素的 num 加入 resultList // 收集結果  \n    → 回到 Decision // 重複直到取到 k 個  \nEnd // 輸出 resultList（k 個最頻繁元素）",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef top_k_frequent(nums, k):\n    \"\"\"Return the k most frequent elements in nums.\"\"\"\n    freq = Counter(nums)                     # Count frequencies\n    # most_common returns items sorted by frequency descending\n    return [num for num, _ in freq.most_common(k)]\n\ndef parse_input(data):\n    \"\"\"Parse input string of the form 'nums = [...], k = ...'.\"\"\"\n    # Extract list part\n    list_str = ''\n    start = data.find('[')\n    end = data.find(']', start)\n    if start != -1 and end != -1:\n        list_str = data[start:end+1]\n    nums = ast.literal_eval(list_str)  # Safely evaluate the list\n\n    # Extract k part\n    k = 0\n    k_part = data.split('k')\n    if len(k_part) > 1:\n        # Find the first number after 'k'\n        import re\n        match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n        if match:\n            k = int(match.group(1))\n    return nums, k\n\ndef main():\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    result = top_k_frequent(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,1,2,1,2,3,1,3,2], k = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode752.json",
    "problem_index_in_file": 0,
    "title": "Open the Lock",
    "description_snippet": "You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3',...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps solving the lock problem: given start 0000, deadends list, target string. Return min turns BFS. Steps: start BFS, visited set includes deadends. Use queue, track moves. While queue not empty: pop state and steps. If state == target return steps. Generate neighbors: for each of 4 wheels, turn +1 and -1 with wrap. If neighbor not visited and not deadend, add. After BFS done return -1.\n\nWe must produce virtual code line by line with explanation. Use Start, End, Decision. Provide steps. Ensure each line has \"虛擬碼步驟 // 解釋\". Use arrows for flow. Let's craft.\n\nWe will include: Start, Initialize variables, check deadends include start, etc. Use Decision for early return -1 if start deadend. BFS loop: Decision if queue empty? Actually while queue not empty: Decision inside loop? Could use Decision: queue not empty? Yes -> process. Provide neighbor generation loop. Use Decision inside neighbor loop? Use nested Decision.\n\nLet's write.\n\nWe'll produce each line. Let's include pseudocode like:\n\nStart // 程式開始執行\n→ Step 1: 定義 start = '0000' // 初始鎖位\n→ Step 2: 將 deadends 集合化為 set dead // 方便查詢\n→ Decision: start 是否在 dead? // 檢查起始點是否為死結\n    Yes → End // 若起始點為死結，直接結束並回傳 -1\n    No  → \n→ Step 3: 初始化 queue = [start] // BFS 待處理節點\n→ Step 4: 初始化 visited = {start} // 已訪問集合\n→ Step 5: 初始化 steps = 0 // 已轉動步數\n→ Decision: queue 是否為空? // 判斷是否還有節點\n    No → \n        → Step 6: 從 queue 取出前一個 state // 取前進節點\n        → Step 7: 若 state == target? // 判斷是否到目標\n            Yes → Return steps // 找到最短步數\n            No  →\n        → Step 8: 對每個 wheel i in 0..3 產生兩個鄰居\n            → Step 9: 產生 next_up = state[0:i] + digit((int(state[i])+1)%10) + state[i+1:] // 上一個\n            → Step 10: 產生 next_down = state[0:i] + digit((int(state[i])-1+10)%10) + state[i+1:] // 下一個\n            → Step 11: 若 next_up 不在 visited 且不在 dead\n                → Step 12: 加入 next_up 到 queue\n                → Step 13: 加入 next_up 到 visited\n            → Step 14: 若 next_down 不在 visited 且不在 dead\n                → Step 15: 加入 next_down 到 queue\n                → Step 16: 加入 next_down 到 visited\n        → Step 17: steps += 1 // 進入下一層\n        → Decision: queue 是否為空?\n            Yes → End // 無路可走，返回 -1\n            No  → Loop back to Decision\n    Yes → End // queue 先空，返回 -1\n\nBut we need to incorporate BFS outer loop and nested loops. Use arrow for loop.\n\nSimplify: Use while queue not empty: we can represent with Decision and loop.\n\nLet's craft final lines.\n\nAlso include helper function to rotate digit.\n\nBut we can embed logic.\n\nWe need to ensure each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 start = '0000' // 初始鎖位  \n→ Step 2: 將 deadends 轉換成集合 dead // 方便 O(1) 查詢  \n→ Decision: start 是否在 dead? // 檢查起始點是否為死結  \n    Yes → End // 若起始點為死結，直接返回 -1  \n    No  → // 繼續  \n→ Step 3: 初始化 queue = [start] // BFS 的待處理節點  \n→ Step 4: 初始化 visited = {start} // 已訪問集合  \n→ Step 5: 初始化 steps = 0 // 目前已轉動的總步數  \n\n→ Decision: queue 是否為空? // 判斷是否還有節點可處理  \n    No  → // 進入 BFS 主循環  \n        → Step 6: 取出 queue 前一個 state // 從隊列中取出當前節點  \n        → Decision: state 是否等於 target? // 判斷是否已到達目標  \n            Yes → Return steps // 找到最短步數，結束程式  \n            No  → // 生成相鄰節點  \n                → Step 7: 對每個 wheel i (0~3) 進行兩次轉動  \n                    → Step 8: 產生 next_up = state[0:i] + (int(state[i])+1)%10 + state[i+1:] // 向上轉一格  \n                    → Step 9: 產生 next_down = state[0:i] + (int(state[i])-1+10)%10 + state[i+1:] // 向下轉一格  \n                    → Decision: next_up 是否不在 visited 且不在 dead?  \n                        Yes → // 將有效鄰居加入隊列  \n                            → Step 10: queue.append(next_up)  \n                            → Step 11: visited.add(next_up)  \n                    → Decision: next_down 是否不在 visited 且不在 dead?  \n                        Yes → // 將有效鄰居加入隊列  \n                            → Step 12: queue.append(next_down)  \n                            → Step 13: visited.add(next_down)  \n        → Step 14: steps += 1 // 完成一層 BFS，步數增加  \n        → Decision: queue 是否為空? // 判斷是否還有下一層  \n            Yes → End // 沒有可行路徑，返回 -1  \n            No  → 回到 Decision: queue 是否為空?  \n    Yes → End // 初始 queue 已空，無法到達目標，返回 -1",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def openLock(self, deadends, target):\n        dead = set(deadends)\n        if '0000' in dead:\n            return -1\n        queue = deque([('0000', 0)])\n        visited = {'0000'}\n        while queue:\n            state, steps = queue.popleft()\n            if state == target:\n                return steps\n            for i in range(4):\n                digit = int(state[i])\n                for move in (-1, 1):\n                    new_digit = (digit + move) % 10\n                    new_state = state[:i] + str(new_digit) + state[i+1:]\n                    if new_state not in dead and new_state not in visited:\n                        visited.add(new_state)\n                        queue.append((new_state, steps + 1))\n        return -1\n\ndef parse_input(data: str):\n    # Extract deadends list\n    dead_match = re.search(r'deadends\\s*=\\s*(\\[[^\\]]*\\])', data)\n    dead_list = ast.literal_eval(dead_match.group(1)) if dead_match else []\n\n    # Extract target string\n    target_match = re.search(r'target\\s*=\\s*\"([^\"]*)\"', data)\n    target = target_match.group(1) if target_match else ''\n\n    return dead_list, target\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    deadends, target = parse_input(data)\n    solution = Solution()\n    result = solution.openLock(deadends, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "deadends = [\"8888\"], target = \"0009\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode380.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1)",
    "description_snippet": "Implement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\nbool inser...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for RandomizedSet operations. The user wants Virtual Code lines, each line: \"虛擬碼步驟 // 解釋\". Use arrow, Decision etc.\n\nWe need to include initialization, insert, remove, getRandom. Use data structures: array/list for values, hash map value to index. Each operation average O(1). Provide pseudocode for each method.\n\nWe need to output step by step. Possibly break into main start? Provide overall structure.\n\nThe Virtual Code must be line by line. Provide Start, End. Probably for each method separate? The user didn't specify grouping but we can provide separate sections for each method, each with Start/End. Use arrow for steps.\n\nWe need to use the format: \"虛擬碼步驟 // 解釋\".\n\nExamples show \"Start // 程式開始執行\". We'll produce e.g.:\n\nStart // RandomizedSet initialization\n→ Step 1: 建立空陣列 values // 用於儲存元素\n→ Step 2: 建立空哈希表 idxMap // 值到索引的映射\nEnd // 初始化完成\n\nThen similar for insert, remove, getRandom.\n\nFor insert:\nStart // Insert(val)\n→ Decision: 如果 val 已在 idxMap? // 檢查是否已存在\n    Yes → Return false // 失敗，已存在\n    No  → Step 1: 把 val 加入 values 陣列末尾 // 插入\n         → Step 2: 設定 idxMap[val] = values.size-1 // 记录索引\n         → Return true // 成功\n\nRemove:\nStart // Remove(val)\n→ Decision: 如果 val 不在 idxMap? // 检查存在性\n    Yes → Return false // 失敗，元素不存在\n    No  → Step 1: 取得要移除的索引 removeIdx = idxMap[val]\n         → Step 2: 取得最後一個元素 lastVal = values.last\n         → Step 3: values[removeIdx] = lastVal // 覆盖\n         → Step 4: 更新 idxMap[lastVal] = removeIdx // 更新索引\n         → Step 5: values.pop_back() // 移除最后元素\n         → Step 6: 刪除 idxMap[val] // 删除映射\n         → Return true\n\ngetRandom:\nStart // getRandom()\n→ Step 1: 生成隨機索引 randIdx = random(0, values.size-1)\n→ Step 2: 返回 values[randIdx] // 随机元素\n\nNeed to output each line with arrow. Use \"→\" for steps. For decisions, indent? Example uses \"    Yes →\" etc.\n\nLet's craft.\n\nEnsure each line ends with \"// 解釋\". Also \"Start // ...\".\n\nWe should produce maybe separate sections, but keep separate lines.\n\nLet's produce:\n\nStart // RandomizedSet 初始化\n→ Step 1: 初始化 values 為空列表 // 用於儲存所有元素\n→ Step 2: 初始化 idxMap 為空哈希表 // 存儲元素到索引的映射\nEnd // 初始化完成\n\nStart // insert(val) 方法\n→ Decision: 如果 val 在 idxMap? // 判斷元素是否已存在\n    Yes → Return false // 插入失敗，已存在\n    No  → Step 1: 將 val 加入 values 的末尾 // 添加新元素\n         → Step 2: 設定 idxMap[val] = values.size - 1 // 記錄新元素的位置\n         → Return true // 插入成功\n\nStart // remove(val) 方法\n→ Decision: 如果 val 不在 idxMap? // 判斷元素是否存在\n    Yes → Return false // 刪除失敗，元素不存在\n    No  → Step 1: 取得 val 的索引 removeIdx = idxMap[val] // 找到要刪除的位置\n         → Step 2: 取得 values 的最後一個元素 lastVal = values.back() // 取得最後元素\n         → Step 3: values[removeIdx] = lastVal // 用最後元素覆蓋要刪除的位置\n         → Step 4: 更新 idxMap[lastVal] = removeIdx // 更新最後元素的新索引\n         → Step 5: values.pop_back() // 刪除最後一個元素\n         → Step 6: 刪除 idxMap[val] // 移除 val 的映射\n         → Return true // 刪除成功\n\nStart // getRandom() 方法\n→ Step 1: 生成隨機整數 r 在 [0, values.size-1] // 隨機索引\n→ Step 2: 返回 values[r] // 返回隨機元素\n\nBut need \"虛擬碼步驟\" each line. In the example they used \"→ Step 1: ...\" The format: \"→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\". So we should include \"→ Step X: ...\" for steps. For decisions, use \"→ Decision:\" etc. Use indentation.\n\nWe need to output each line exactly like that.\n\nAlso need \"End // 程式執行結束\" maybe after each method. Example had End after entire flow. For each method we can have End. Provide \"End // 完成 insert\".\n\nBut we can choose to put End after each method. Not necessary but okay.\n\nLet's produce final answer with lines.\n\nWe must not output actual code, just virtual steps. Use Chinese. Ensure each line has \"虛擬碼步驟\" then space then comment. We will not include variable names? We can use pseudocode variable names.\n\nLet's craft final answer.\n...done thinking.\n\nStart // RandomizedSet 初始化\n→ Step 1: 初始化 values 為空列表 // 用於儲存所有元素\n→ Step 2: 初始化 idxMap 為空哈希表 // 存儲元素到索引的映射\nEnd // 初始化完成\n\nStart // insert(val) 方法\n→ Decision: 如果 val 在 idxMap? // 判斷元素是否已存在\n    Yes → Return false // 插入失敗，已存在\n    No  → Step 1: 將 val 加入 values 的末尾 // 添加新元素\n         → Step 2: 設定 idxMap[val] = values.size - 1 // 記錄新元素的位置\n         → Return true // 插入成功\nEnd // insert 完成\n\nStart // remove(val) 方法\n→ Decision: 如果 val 不在 idxMap? // 判斷元素是否存在\n    Yes → Return false // 刪除失敗，元素不存在\n    No  → Step 1: 取得 val 的索引 removeIdx = idxMap[val] // 找到要刪除的位置\n         → Step 2: 取得 values 的最後一個元素 lastVal = values.back() // 取得最後元素\n         → Step 3: values[removeIdx] = lastVal // 用最後元素覆蓋要刪除的位置\n         → Step 4: 更新 idxMap[lastVal] = removeIdx // 更新最後元素的新索引\n         → Step 5: values.pop_back() // 刪除最後一個元素\n         → Step 6: 刪除 idxMap[val] // 移除 val 的映射\n         → Return true // 刪除成功\nEnd // remove 完成\n\nStart // getRandom() 方法\n→ Step 1: 生成隨機整數 r 在 [0, values.size-1] // 隨機索引\n→ Step 2: 返回 values[r] // 返回隨機元素\nEnd // getRandom 完成",
      "generated_code": "import sys\nimport json\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        # value -> index mapping\n        self.val_to_index = {}\n        # list of values\n        self.values = []\n\n    def insert(self, val):\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.values)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Ensure two separate lists: operations and arguments\n    data = data.replace('], [', '],\\n[')\n    parts = data.split('\\n', 1)\n    ops = json.loads(parts[0])\n    args = json.loads(parts[1])\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            res.append(None)\n        elif op == \"insert\":\n            res.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            res.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            res.append(obj.getRandom())\n    print(json.dumps(res))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp58ulyz_l.py\", line 40, in <module>\n    ops = json.loads(parts[0])\n          ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 94 (char 93)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode519.json",
    "problem_index_in_file": 0,
    "title": "Random Flip Matrix",
    "description_snippet": "There is an m x n binary grid matrix with all the values set 0 initially. Design an algorithm to ran...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for algorithm: We can treat the matrix flattened as array of size m*n, use mapping to shuffle. Known solution: maintain list of available indices (0 to m*n-1). Use random index r from 0 to len-1, get idx=arr[r]; set arr[r] = arr[len-1]; reduce len. Then convert idx to (i,j). For reset, reset mapping: repopulate array or use next index approach. Use hash map for mapping. But we need minimal random calls: only one random per flip. We'll implement with vector 'available' and swap trick. Provide virtual code lines.\n\nWe need to output step lines: Start, Step 1: init variables, etc. Use Decision: and arrow. Provide explanation comments. Avoid actual code syntax, just structure. So produce like:\n\nStart // 程式開始\n→ Step 1: 初始化 m, n, total = m*n, idxList = [0..total-1], remaining = total // 設定變數\n→ Decision: 是否已經完成? (remaining == 0) // 檢查是否所有位置已被翻轉\n    Yes → Return None? maybe not needed\n    No  → Step 2: 隨機選取 r in [0, remaining-1] // 只呼叫一次 random\n→ Step 3: 取 idx = idxList[r] // 取得對應的平面索引\n→ Step 4: 交換 idxList[r] 和 idxList[remaining-1] // 移除已選\n→ Step 5: remaining-- // 減少可用數量\n→ Step 6: 將 idx 轉換為 (i, j) = (idx / n, idx % n) // 轉回座標\n→ Step 7: 返回 [i, j]\n→ Step 8: reset: 重新填充 idxList 為 0..total-1, remaining = total // 重置\n\nAlso maybe include Decision for reset? Not necessary.\n\nWe should format each line as \"虛擬碼步驟 // 解釋\".\n\nLet's produce lines accordingly. Provide multiple lines.\n\nEdge cases: no need to handle duplicates. Provide comments. Use arrow symbol only once per line? Format says \"虛擬碼步驟 [space] // 解釋\". So each line: \"Start // ...\". Use arrow \"→\" only at beginning of step lines. For decisions, we indent.\n\nLet's produce full flow:\n\nStart // 程式開始執行\n→ Step 1: Set m, n, total ← m * n // 計算矩陣大小\n→ Step 2: Create list indices ← [0, 1, …, total-1] // 代表所有可翻轉的位置\n→ Step 3: Set remaining ← total // 可用位置的個數\n→ Decision: 若 remaining == 0? // 檢查是否所有位置已翻轉\n    Yes → End // 若已無可翻轉位置，終止\n    No  → Step 4: 隨機產生 r ← RandomInt(0, remaining-1) // 只呼叫一次 random\n→ Step 5: idx ← indices[r] // 取得對應的線性索引\n→ Step 6: Swap indices[r] with indices[remaining-1] // 把已選位置移到末尾\n→ Step 7: remaining ← remaining - 1 // 更新剩餘可用數量\n→ Step 8: i ← idx / n // 計算行號\n→ Step 9: j ← idx % n // 計算列號\n→ Step 10: Return [i, j] // 回傳座標並完成 flip\n→ Step 11: reset() // 將所有位置重設為 0\n    → Step 12: Recreate indices ← [0, 1, …, total-1] // 重新填充索引\n    → Step 13: remaining ← total // 重設剩餘數量\n\nBut we might include reset as separate Start for function. Maybe separate function lines: \"→ Function reset:\" etc. Format may not require separate functions but we can represent as steps.\n\nHowever we must keep within format: each line with 虛擬碼步驟 // 解釋. Use arrow for steps, decision lines with indent. We'll produce code for flip and reset.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: m ← input_m, n ← input_n, total ← m * n // 初始化尺寸與總量\n→ Step 2: indices ← [0 … total-1] // 佈署可用索引池\n→ Step 3: remaining ← total // 可翻轉位置數\nEnd // 結束建構\n\nStart // flip 函式開始\n→ Decision: 若 remaining == 0? // 檢查是否已無可翻轉位置\n    Yes → Return null // 或適當處理\n    No  → Step 4: r ← RandomInt(0, remaining-1) // 隨機索引\n→ Step 5: idx ← indices[r] // 取得線性索引\n→ Step 6: indices[r] ↔ indices[remaining-1] // 將已選位置移至末尾\n→ Step 7: remaining ← remaining - 1 // 減少可用數量\n→ Step 8: i ← idx / n // 轉換為行號\n→ Step 9: j ← idx % n // 轉換為列號\n→ Step 10: Return [i, j] // 回傳並完成翻轉\nEnd // flip 函式結束\n\nStart // reset 函式開始\n→ Step 11: indices ← [0 … total-1] // 重新填充索引\n→ Step 12: remaining ← total // 重設剩餘數\nEnd // reset 函式結束\n\nBut the format might require no function naming; but okay.\n\nEnsure arrow usage: \"→\" at start of each step. For decision lines, we use \"Decision:\" and indent.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: m ← input_m, n ← input_n, total ← m * n // 初始化矩陣尺寸與總個數\n→ Step 2: indices ← [0 … total-1] // 建立所有可翻轉的位置池\n→ Step 3: remaining ← total // 記錄目前還有多少位置未被翻轉\nEnd // 建構完成\n\nStart // flip() 開始\n→ Decision: 若 remaining == 0? // 檢查是否所有位置已翻轉\n    Yes → Return null // 或擲例外，無法再翻轉\n    No  → Step 4: r ← RandomInt(0, remaining-1) // 只呼叫一次 random\n→ Step 5: idx ← indices[r] // 取得線性索引對應的矩陣位置\n→ Step 6: indices[r] ↔ indices[remaining-1] // 交換已選位置與池尾，移除已翻轉\n→ Step 7: remaining ← remaining - 1 // 更新可用位置數量\n→ Step 8: i ← idx / n // 計算行號\n→ Step 9: j ← idx % n // 計算列號\n→ Step 10: Return [i, j] // 回傳座標並完成翻轉\nEnd // flip() 結束\n\nStart // reset() 開始\n→ Step 11: indices ← [0 … total-1] // 重新填充所有索引池\n→ Step 12: remaining ← total // 重設剩餘可翻轉位置數\nEnd // reset() 結束",
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    \"\"\"Binary matrix flip and reset with O(1) random access.\"\"\"\n\n    def __init__(self, n_rows: int, n_cols: int):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols          # remaining zero cells\n        self.flipped = {}                     # mapping from virtual index to real index\n\n    def flip(self):\n        \"\"\"Return a random zero cell and flip it to one.\"\"\"\n        r = random.randint(0, self.total - 1)\n        # Get the real index that currently occupies position r\n        real_index = self.flipped.get(r, r)\n\n        # Decrease the count of remaining zeros\n        self.total -= 1\n\n        # Move the last unused index into position r\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n\n        # Convert 1‑D index back to 2‑D coordinates\n        return [real_index // self.cols, real_index % self.cols]\n\n    def reset(self):\n        \"\"\"Reset all cells to zero.\"\"\"\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\n\ndef main():\n    # Read the whole input; it consists of two Python lists separated by a comma\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split into the two lists\n    first_end = data.find(']')\n    if first_end == -1:\n        raise ValueError(\"Invalid input format\")\n\n    commands_str = data[:first_end + 1]\n    args_str = data[first_end + 2:].strip()  # skip comma and possible space\n\n    commands = ast.literal_eval(commands_str)\n    args = ast.literal_eval(args_str)\n\n    # Execute commands\n    result = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            obj = Solution(*arg)\n            result.append(None)\n        elif cmd == \"flip\":\n            result.append(obj.flip())\n        elif cmd == \"reset\":\n            obj.reset()\n            result.append(None)\n        else:\n            # Unknown command; append None\n            result.append(None)\n\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[None,[0,0],[1,0],[2,0],None,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[None, [0, 0], [1, 0], [2, 0], None, [1, 0]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode735.json",
    "problem_index_in_file": 0,
    "title": "Asteroid Collision",
    "description_snippet": "We are given an array asteroids of integers representing asteroids in a row. The indices of the aste...",
    "examples_loaded": 4,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for asteroid collision simulation using stack approach. Provide each line with explanation. Use \"Start\", \"→\", \"Decision:\" etc. Must be line-by-line. Use \"End\". No actual code. Provide explanation. Provide step-by-step. Probably something like:\n\nStart\n→ Step 1: Initialize stack empty\n→ For each asteroid a in array\n   → Decision: If a>0? // moving right\n      Yes → Push a onto stack\n      No → // moving left\n         While stack not empty and top>0 and abs(top) < abs(a)\n              Pop stack // top asteroid destroyed\n         If stack empty or top < 0\n              Push a onto stack\n         Else if abs(top) == abs(a)\n              Pop stack // both destroy\n         // else top larger, a destroyed\nAfter loop, stack contains survivors\n→ Step 2: Convert stack to list\nEnd\n\nNeed to include explanations each line. Use \"→ Decision:\" etc. Provide each line of virtual code. Must keep consistent formatting. Use indentation? The sample shows indentation by spaces. We'll produce similar.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化空堆疊 stack // 用於保存存活的小行星\n→ Step 2: 遍歷陣列 asteroids 中每個小行星 a // 逐一處理\n    → Decision: a 大於 0? // 小行星向右移動\n        Yes → Push a onto stack // 右移小行星直接加入堆疊\n        No  → Decision: stack 為空 或 stack.top 小於 0? // 左移小行星遇不到右移小行星\n            Yes → Push a onto stack // 沒有衝突，直接加入堆疊\n            No  → Decision: abs(stack.top) < abs(a)? // 與堆疊頂部右移小行星相撞，右方更小\n                Yes → Pop stack // 左移小行星擊碎右移小行星\n                     → Go to 前面 \"No\" 分支? // 需要再次檢查堆疊\n                No  → Decision: abs(stack.top) == abs(a)? // 同等大小\n                    Yes → Pop stack // 兩者同時消滅\n                    No  → // 左移小行星被右移小行星擊碎，停止進入堆疊\n→ Step 3: 將堆疊中的元素轉為結果陣列 // 最終存活的小行星\nEnd // 程式執行結束\n\nBut we need to be consistent with arrow usage and indent. Let's produce with arrow at start of each line.\n\nAlso, we need to note \"Go to\" maybe not needed. Instead use while loop representation: While stack not empty and top>0 and abs(top)<abs(a). Let's reflect that.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化空堆疊 stack // 用於保存存活的小行星\n→ Step 2: 遍歷陣列 asteroids 中每個小行星 a // 逐一處理\n    → Decision: a 大於 0? // 小行星向右移動\n        Yes → Push a onto stack // 右移小行星直接加入堆疊\n        No  → Decision: stack 為空 或 stack.top 小於 0? // 左移小行星無右移小行星可碰撞\n            Yes → Push a onto stack // 直接加入堆疊\n            No  → While stack 不為空 且 stack.top 大於 0 且 abs(stack.top) < abs(a)? // 與右移小行星相撞，右方更小\n                Yes → Pop stack // 右移小行星被擊碎\n                // 仍在左移小行星與堆疊頂部相撞，繼續迴圈\n                No → Decision: abs(stack.top) == abs(a)? // 同等大小\n                    Yes → Pop stack // 兩者同時消滅\n                    No  → // 左移小行星被右移小行星擊碎，停止進入堆疊\n    → // 迴圈結束後繼續下一個小行星\n→ Step 3: 將堆疊中的元素轉為結果陣列 // 最終存活的小行星\nEnd // 程式執行結束\n\nBut we need to use \"Decision:\" and \"While\" maybe not. But sample uses \"Decision:\" for if. Could use \"While\" as a step but we might keep simpler.\n\nLet's produce with proper indentation and arrow for nested decisions.\n\nWe must ensure each line has \"虛擬碼步驟\" then space then comment.\n\nLet's finalize.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空堆疊 stack // 用於保存存活的小行星  \n→ Step 2: 遍歷陣列 asteroids 中每個小行星 a // 逐一處理  \n  → Decision: a 大於 0? // 小行星向右移動  \n   Yes → Push a onto stack // 右移小行星直接加入堆疊  \n   No  → Decision: stack 為空 或 stack.top 小於 0? // 左移小行星無右移小行星可碰撞  \n    Yes → Push a onto stack // 直接加入堆疊  \n    No  → While stack 不為空 且 stack.top > 0 且 abs(stack.top) < abs(a)? // 與右移小行星相撞，右方更小  \n     Yes → Pop stack // 右移小行星被擊碎  \n     No  → Decision: abs(stack.top) == abs(a)? // 同等大小  \n      Yes → Pop stack // 兩者同時消滅  \n      No  → // 左移小行星被右移小行星擊碎，停止進入堆疊  \n  → // 迴圈結束後繼續下一個小行星  \n→ Step 3: 將堆疊中的元素轉為結果陣列 // 最終存活的小行星  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def asteroidCollision(self, asteroids):\n        stack = []\n        for a in asteroids:\n            # 只要右邊的堆疊元素正向移動且左邊小行星向左移動，就可能發生碰撞\n            while stack and a < 0 < stack[-1]:\n                top = stack[-1]\n                if top < -a:  # 右移小行星更小，右移小行星消失\n                    stack.pop()\n                    continue\n                elif top == -a:  # 相同大小，兩者同時消失\n                    stack.pop()\n                # 右移小行星更大，左移小行星消失，終止內層循環\n                break\n            else:\n                # 右移小行星或左移小行星沒有衝突，直接加入堆疊\n                stack.append(a)\n        return stack\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 允許輸入類似 \"asteroids = [5,10,-5]\" 或僅 \"[5,10,-5]\"\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n        list_str = list_str.strip()\n    else:\n        list_str = data\n    # 安全解析為 Python 物件\n    try:\n        asteroids = ast.literal_eval(list_str)\n    except Exception as e:\n        # 若解析失敗，直接輸出空列表\n        print([])\n        return\n    sol = Solution()\n    result = sol.asteroidCollision(asteroids)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "asteroids = [5,10,-5]",
          "expected_output": "[5,10]",
          "success": true,
          "output": "[5, 10]"
        },
        {
          "example_index": 1,
          "input": "asteroids = [8,-8]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "asteroids = [10,2,-5]",
          "expected_output": "[10]",
          "success": true,
          "output": "[10]"
        },
        {
          "example_index": 3,
          "input": "asteroids = [3,5,-6,2,-1,4]",
          "expected_output": "[-6,2,4]",
          "success": true,
          "output": "[-6, 2, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode45.json",
    "problem_index_in_file": 0,
    "title": "Jump Game II",
    "description_snippet": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at index ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for Jump Game II: minimum number of jumps to reach last index. Use greedy approach: maintain current end and farthest. Iterate, count jumps. Provide steps in virtual code with explanation each line. Use \"Start\", \"End\", \"Decision\". Must not output actual code. Provide each line like \"→ Step X: ...\" and explanation after //.\n\nWe must produce step-by-step pseudocode.\n\nLet's craft:\n\nStart\n→ Step 1: Set jumps = 0 // 初始化跳躍次數\n→ Step 2: Set currentEnd = 0 // 目前能到達的最遠位置\n→ Step 3: Set farthest = 0 // 迴圈中能到達的最遠位置\n→ Decision: If n <= 1? // 如果陣列只有一個元素，已經到達終點\n    Yes → Step 4: Return jumps // 返回 0\n    No  →\n→ Step 5: For i from 0 to n-2 // 遍歷除最後一個元素以外的索引\n→ Step 6: Update farthest = max(farthest, i + nums[i]) // 更新可達最遠位置\n→ Decision: If i == currentEnd? // 走到目前能到達的最遠點，需要進行一次跳躍\n    Yes → Step 7: Increment jumps // 增加跳躍次數\n    → Step 8: Set currentEnd = farthest // 設置新的最遠可達位置\n→ Step 9: End For\n→ Step 10: Return jumps // 返回最小跳躍次數\nEnd\n\nWe need to adhere to format: each line with \"→\" after start maybe. Provide explanation after //.\n\nMake sure \"Decision:\" lines have indentation and Yes/No arrow lines.\n\nAlso we should maintain clarity: Use \"→ Step\" for each step. \"Decision:\" lines need \"Yes →\" and \"No →\" on separate lines with indentation.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 jumps = 0 // 初始化跳躍次數  \n→ Step 2: 設定 currentEnd = 0 // 目前能到達的最遠位置  \n→ Step 3: 設定 farthest = 0 // 迴圈中能到達的最遠位置  \n→ Decision: 如果 n <= 1? // 檢查陣列長度是否為 1（已經到達終點）  \n  Yes → Step 4: 回傳 jumps // 回傳 0，無需跳躍  \n  No  →  \n→ Step 5: 對 i 從 0 到 n-2 迭代 // 遍歷除最後一個元素外的所有索引  \n  → Step 6: 更新 farthest = max(farthest, i + nums[i]) // 取得此範圍內能到達的最遠位置  \n  → Decision: 如果 i == currentEnd? // 到達目前可到達的最遠點，需進行跳躍  \n    Yes → Step 7: 增加 jumps // 跳躍次數加 1  \n      → Step 8: 設定 currentEnd = farthest // 更新新的最遠可達位置  \n    No  →  \n→ Step 9: 結束迴圈 // 所有索引已處理完畢  \n→ Step 10: 回傳 jumps // 回傳最小跳躍次數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_jumps(nums):\n    \"\"\"\n    計算從索引 0 到最後一個索引所需的最小跳躍次數。\n    \"\"\"\n    n = len(nums)\n    if n <= 1:\n        return 0\n\n    jumps = 0          # 已經執行的跳躍次數\n    current_end = 0    # 目前可達的最遠位置\n    farthest = 0       # 在迴圈中能到達的最遠位置\n\n    for i in range(n - 1):\n        # 更新在此範圍內能到達的最遠位置\n        farthest = max(farthest, i + nums[i])\n\n        # 當到達目前可達的最遠位置時，需要進行一次跳躍\n        if i == current_end:\n            jumps += 1\n            current_end = farthest\n\n    return jumps\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料，可能的格式為: \"nums = [2,3,1,1,4]\"\n    data = sys.stdin.read()\n    # 提取所有整數，無論前面是否有 \"nums = \"\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n\n    # 計算最小跳躍次數並輸出\n    result = min_jumps(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,3,0,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode495.json",
    "problem_index_in_file": 0,
    "title": "Teemo Attacking",
    "description_snippet": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets po...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, to solve problem. We'll describe algorithm: iterate over timeSeries, accumulate poison time. Keep prev_end variable. For each attack time t: if t > prev_end, add duration; else add max(0, t+duration-1 - prev_end). After loop, sum. Complexity O(n). We'll produce lines of virtual code with arrows and comments. We'll include Start, End, Decision, etc.\n\nLet's produce. Ensure each line: \"虛擬碼步驟 // 解釋\". Use arrow → and indent decisions. Ensure to produce exactly as required. We'll produce algorithm not actual code. Use pseudo-code. Use \"Start // 程式開始執行\" etc.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 total ← 0 // 紀錄總毒傷時間\n→ Step 2: 初始化 prev_end ← -∞ // 先前毒結束時間\n→ Step 3: 遍歷 timeSeries 的每個攻擊時刻 t // 逐個處理攻擊\n    → Decision: t > prev_end? // 檢查新攻擊是否在前一次毒結束後\n        Yes → Step 4: total ← total + duration // 完全新毒段，累加完整時長\n        No  → Step 5: total ← total + max(0, (t + duration - 1) - prev_end) // 只累加未覆蓋部分\n    → Step 6: prev_end ← t + duration - 1 // 更新前一次毒結束時間\n→ Step 7: 回傳 total // 回傳總毒傷時間\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries, duration):\n        \"\"\"計算 Ashe 被毒的總秒數。\"\"\"\n        if not timeSeries:\n            return 0\n        total = 0\n        for i in range(len(timeSeries) - 1):\n            # 兩次攻擊間的間隔，若小於 duration 則只能累加間隔時間\n            total += min(timeSeries[i + 1] - timeSeries[i], duration)\n        # 最後一次攻擊的毒持續時間必須全加\n        total += duration\n        return total\n\ndef parse_input(input_str: str):\n    \"\"\"\n    解析類似 'timeSeries = [1,4], duration = 2' 的輸入字串。\n    返回 (timeSeries, duration) 兩個參數。\n    \"\"\"\n    pattern = r\"timeSeries\\s*=\\s*\\[(.*?)\\],\\s*duration\\s*=\\s*(-?\\d+)\"\n    match = re.search(pattern, input_str.strip())\n    if not match:\n        raise ValueError(\"輸入格式不正確\")\n    # 解析時間序列\n    ts_str = match.group(1).strip()\n    if ts_str == \"\":\n        time_series = []\n    else:\n        time_series = [int(x.strip()) for x in ts_str.split(\",\")]\n    duration = int(match.group(2))\n    return time_series, duration\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read()\n    time_series, duration = parse_input(raw_input)\n    sol = Solution()\n    result = sol.findPoisonedDuration(time_series, duration)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode424.json",
    "problem_index_in_file": 0,
    "title": "Longest Repeating Character Replacement",
    "description_snippet": "You are given a string s and an integer k. You can choose any character of the string and change it ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for solution: longest repeating character after at most k changes. This is classic sliding window with max frequency. We'll produce steps.\n\nWe need to output line by line: \"虛擬碼步驟 // 解釋\". Use Start, Decision etc.\n\nWe'll describe algorithm: iterate window, maintain count of each char, track maxCount. While window length - maxCount > k, shrink left. At each step, record answer. End.\n\nNeed to output in Chinese explanation. Each line: 虛擬碼步驟 + space + // + explanation.\n\nWe need to use arrow notation. Let's craft.\n\nStart // 程式開始執行\n→ Step 1: 初始化左指標 left = 0, ans = 0, maxCount = 0, count[26] = 0 // 建立滑動窗口參數\n→ Step 2: 循環右指標 right 從 0 到 s.length-1 // 遍歷字串\n    → Step 2.1: 更新 count[s[right]]++ // 增加當前字元計數\n    → Step 2.2: maxCount = max(maxCount, count[s[right]]) // 追蹤窗口中最高頻字元\n    → Decision: 若 (right - left + 1 - maxCount) > k? // 判斷是否需要縮小窗口\n        Yes → Step 2.3: count[s[left]]-- // 減少左側字元計數\n        Yes → Step 2.4: left++ // 左指標右移\n        No  → Step 2.5: ans = max(ans, right - left + 1) // 更新答案\nEnd // 返回 ans 或輸出結果\n\nBut need to use \"Decision:\" lines etc.\n\nAlso we need to include comments.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left ← 0, ans ← 0, maxCount ← 0, count[26] ← 0 // 初始化滑動窗口參數  \n→ Step 2: 循環右指標 right 由 0 到 s.length-1 // 遍歷字串  \n  → Step 2.1: count[s[right]] ← count[s[right]] + 1 // 更新當前字元的頻次  \n  → Step 2.2: maxCount ← max(maxCount, count[s[right]]) // 追蹤窗口內最高頻字元  \n  → Decision: 若 (right - left + 1 - maxCount) > k? // 判斷是否需要縮小窗口  \n   Yes → Step 2.3: count[s[left]] ← count[s[left]] - 1 // 減少左側字元的頻次  \n   Yes → Step 2.4: left ← left + 1 // 左指標右移，縮小窗口  \n   No → Step 2.5: ans ← max(ans, right - left + 1) // 更新最長相同字元子字串長度  \nEnd // 程式執行結束，ans 為答案，返回或輸出 ans",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        count = [0] * 26\n        max_count = 0\n        left = 0\n        res = 0\n\n        for right, ch in enumerate(s):\n            idx = ord(ch) - ord('A')\n            count[idx] += 1\n            max_count = max(max_count, count[idx])\n\n            while (right - left + 1) - max_count > k:\n                count[ord(s[left]) - ord('A')] -= 1\n                left += 1\n\n            res = max(res, right - left + 1)\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract string inside double quotes if present\n    str_match = re.search(r'\"([^\"]*)\"', data)\n    # Extract the first integer found\n    int_match = re.search(r'(-?\\d+)', data)\n\n    if str_match:\n        s = str_match.group(1)\n    else:\n        # fallback: first token as string\n        parts = data.split()\n        s = parts[0] if parts else \"\"\n\n    if int_match:\n        k = int(int_match.group(1))\n    else:\n        # fallback: second token as integer\n        parts = data.split()\n        k = int(parts[1]) if len(parts) > 1 else 0\n\n    result = Solution().characterReplacement(s, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ABAB\", k = 2",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "s = \"AABABBA\", k = 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode58.json",
    "problem_index_in_file": 0,
    "title": "Length of Last Word",
    "description_snippet": "Given a string s consisting of words and spaces, return the length of the last word in the string.\n\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem: given string s, find length of last word. We need to produce step by step virtual code, line by line, each with arrow, and comment.\n\nWe should use Start, End, Decision, Step, etc. We need to be concise, but explain each line.\n\nLet's produce steps: Start; Step: Trim trailing spaces; Step: Find index of last space; If no space found, whole string is last word; else last word length = len(s) - lastSpaceIndex -1; Output that.\n\nWe could also loop from end to find first non-space char, then count until space. But simpler approach: reverse iterate to count length.\n\nWe need to produce virtual code steps: Start // 程式開始執行. Then Step 1: 初始化變數 lastWordLength = 0 // 用於儲存最後單詞長度. Step 2: 反向遍歷字符串，從末尾開始。 But better to produce step by step: Step 1: 將變數 i 指向字符串末尾索引 // i = len(s)-1. Step 2: Decision: i >= 0? // 確保還有字符。 Yes → Step 3: Decision: s[i] is space? // 判斷是否為空格。 Yes → Step 4: i = i - 1 // 跳過空格。 No → Step 5: lastWordLength = lastWordLength + 1 // 計算單詞長度。 Step 6: i = i - 1 // 移動到前一個字符。 Back to Decision i>=0. After loop, maybe need to stop when we hit space after counting? Actually we want to count until we hit space or i<0. But if we hit space after counting last word, we can stop because we already counted. But we should stop loop when we hit space after counting some characters? Actually typical algorithm: skip trailing spaces first; then count until space or start. So we could first skip trailing spaces, then count. So steps: Step 1: i = len(s)-1 // start at last index. Step 2: Decision: i >= 0? No -> Output 0. Yes -> Decision: s[i] is space? Yes -> i=i-1; repeat Step 2. If No -> start counting. Step 3: lastWordLength = 0. Step 4: Decision: i >=0 and s[i] not space? Yes -> lastWordLength++ ; i-- ; repeat Step 4. If No -> break loop. Step 5: Output lastWordLength. End.\n\nWe need to produce virtual code lines accordingly. Ensure each line has arrow and comment.\n\nLet's produce with structure: Start; → Step 1: i ← len(s) - 1 // 設定索引指向字符串末尾; → Decision: i < 0? // 判斷是否為空字符串; Yes → Step 2: Output 0 // 沒有字元，最後單詞長度為 0; No → Decision: s[i] == ' ' ? // 跳過尾部空格; Yes → Step 3: i ← i - 1 // 移動至前一個字元; No → Step 4: lastWordLength ← 0 // 開始計算最後單詞長度; -> Step 5: Decision: i >= 0 AND s[i] != ' ' ? // 繼續計算字元\n    Yes → Step 6: lastWordLength ← lastWordLength + 1 // 計算長度\n        → Step 7: i ← i - 1 // 移動\n        → Back to Decision Step 5\n    No → Step 8: Output lastWordLength // 計算完成\nEnd\n\nWe need to ensure each step line has arrow. Use → to indicate next step, and Yes →, No → in decisions.\n\nWe need to maintain indentation for nested decisions maybe not necessary but can add indent.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: i ← len(s) - 1 // 設定索引指向字符串末尾\n→ Decision: i < 0? // 判斷字串是否為空\n    Yes → Step 2: Output 0 // 沒有字元，最後單詞長度為 0\n    No  → Decision: s[i] == ' ' ? // 跳過尾部空格\n        Yes → Step 3: i ← i - 1 // 移動至前一個字元\n        No  → Step 4: lastWordLength ← 0 // 開始計算最後單詞長度\n→ Decision: i >= 0 AND s[i] != ' ' ? // 是否還有字元且不是空格\n    Yes → Step 5: lastWordLength ← lastWordLength + 1 // 計算長度\n        → Step 6: i ← i - 1 // 移動至前一個字元\n        → Back to Decision: i >= 0 AND s[i] != ' ' ?\n    No  → Step 7: Output lastWordLength // 計算完成\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\n\ndef length_of_last_word(s: str) -> int:\n    \"\"\"\n    返回字符串 s 中最后一个单词的长度。\n    若字符串为空或不含单词，则返回 0。\n    \"\"\"\n    # 去除首尾空格\n    s = s.strip()\n    if not s:\n        return 0\n    # split() 默认按任意空白字符分隔，且会忽略连续空格\n    words = s.split()\n    if not words:\n        return 0\n    return len(words[-1])\n\nif __name__ == \"__main__\":\n    # 读取全部输入\n    data = sys.stdin.read().strip()\n\n    # 处理可能的「s = \"...\"」格式\n    if '=' in data:\n        _, value = data.split('=', 1)\n        value = value.strip()\n        # 去掉外层引号（如果存在）\n        if (value.startswith('\"') and value.endswith('\"')) or (value.startswith(\"'\") and value.endswith(\"'\")):\n            value = value[1:-1]\n        s = value\n    else:\n        # 直接使用输入内容\n        s = data\n\n    result = length_of_last_word(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello World\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"   fly me   to   the moon  \"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"luffy is still joyboy\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode33.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array",
    "description_snippet": "There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being pas...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for searching target in rotated sorted array O(log n). Provide explanation each line.\n\nNeed to follow format: each line: `虛擬碼步驟 // 解釋/說明`. Use arrows and decisions.\n\nLet's produce start, initialize left, right, loop while left <= right, mid, compare, decide which side sorted, etc.\n\nMake sure to mention binary search.\n\nLet's output lines.\n\nAlso note requirement: do not output actual code, just virtual steps. Use arrows for flow.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left ← 0, right ← nums.length - 1 // 初始化左右指標  \n→ Decision: 當 left ≤ right 時進入搜尋迴圈? // 確保仍有區間可搜尋  \n    Yes → Step 2: mid ← (left + right) // 2 // 計算中間索引  \n    → Decision: nums[mid] 等於 target? // 檢查是否已找到  \n        Yes → Step 3: 回傳 mid // 找到目標，返回其索引  \n        No → Decision: nums[left] ≤ nums[mid]? // 判斷左半段是否為有序  \n            Yes → Step 4: nums[left] ≤ target < nums[mid]? // 目標是否在左有序區間  \n                Yes → Step 5: right ← mid - 1 // 將搜尋範圍縮小到左側  \n                No  → Step 6: left ← mid + 1 // 目標在右側，移動左指標  \n            No  → Step 7: nums[mid] < target ≤ nums[right]? // 目標是否在右有序區間  \n                Yes → Step 8: left ← mid + 1 // 目標在右側，移動左指標  \n                No  → Step 9: right ← mid - 1 // 目標在左側，縮小右指標  \n→ Decision: 仍然 left ≤ right? // 回到迴圈判斷  \n    Yes → 重複 Step 2-9  \n    No  → Step 10: 回傳 -1 // 搜尋完畢仍未找到，返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:  # 左半段有序\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:  # 右半段有序\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1\n\ndef parse_input(data):\n    \"\"\"\n    解析類似 'nums = [4,5,6,7,0,1,2], target = 0' 的字串\n    \"\"\"\n    pattern = re.compile(r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)', re.S)\n    match = pattern.search(data)\n    if not match:\n        return [], None\n    nums_str = match.group(1)\n    target_str = match.group(2)\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    nums, target = parse_input(raw_data)\n    if target is None:\n        print(-1)\n    else:\n        solution = Solution()\n        print(solution.search(nums, target))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,5,6,7,0,1,2], target = 0",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2], target = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "nums = [1], target = 0",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode676.json",
    "problem_index_in_file": 0,
    "title": "Implement Magic Dictionary",
    "description_snippet": "Design a data structure that is initialized with a list of different words. Provided a string, you s...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode. Should design MagicDictionary class with methods: constructor, buildDict, search. Use typical approach: store words in map by length or trie? Simpler: iterate over dictionary words, for each word, generate all variants with one wildcard? Approach: create a hash set of all words and a hash map of generic patterns: replace each character with '*' and map to count. For search, check if there exists pattern with count>1 or pattern exists but word not same. But requirement: exactly one character change. So typical solution: for each position in searchWord, replace with '*', check map.\n\nWe need virtual code steps with explanation per line. Use structure with Start, End, Decision. Provide each line with // explanation.\n\nLet's produce steps:\n\nStart\n→ Step 1: 初始化字典資料結構 // 建立存放單詞及通配符映射\n→ Step 2: 建構函式 MagicDictionary() // 只初始化空資料結構\n→ Step 3: 建構函式 buildDict(dictionary) // 將每個單詞加入字典並生成通配符模式\n    → For each word in dictionary\n        → For i from 0 to len(word)-1\n            → pattern = word[0:i] + '*' + word[i+1:]\n            → Increment map[pattern] count\n        → Add word to set\n→ Step 4: 建構函式 search(searchWord) // 檢查是否能改一個字母匹配\n    → For i from 0 to len(searchWord)-1\n        → pattern = searchWord[0:i] + '*' + searchWord[i+1:]\n        → If map contains pattern\n            → If map[pattern] > 1 OR word not equal to any word with this pattern // Actually need to check if there exists word different from searchWord\n                → Return true\n    → Return false\nEnd\n\nBut we must follow the specified format: Each line \"虛擬碼步驟 [space] // 解釋\". Use arrows for decision? We might need Decision: If map contains pattern? etc.\n\nLet's produce in order.\n\nNeed to include Step 1: Start // 程式開始執行\nBut that's the entire program? We produce pseudocode for class.\n\nBetter structure: Start\n→ Define class MagicDictionary\n    → Step 1: 初始化空集合 wordsSet and patternMap\n→ End\n\nBut we need to show methods.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 MagicDictionary 類別 // 建立類別框架\n    → Substep: wordsSet ← 空集合 // 用來存放所有單詞\n    → Substep: patternMap ← 空映射 // key: 通配符模式, value: 出現次數\n→ End // 類別定義結束\n→ Step 2: 建構子 MagicDictionary() // 初始化空資料結構\n    → wordsSet ← 空集合\n    → patternMap ← 空映射\n→ End // 建構子結束\n→ Step 3: 方法 buildDict(dictionary) // 建立字典\n    → For 每個 word 在 dictionary\n        → For i 從 0 到 len(word)-1\n            → pattern ← word[0:i] + '*' + word[i+1:]\n            → patternMap[pattern] ← patternMap.get(pattern,0) + 1\n        → wordsSet.add(word)\n→ End // buildDict 結束\n→ Step 4: 方法 search(searchWord) // 判斷是否能改一字匹配\n    → For i 從 0 到 len(searchWord)-1\n        → pattern ← searchWord[0:i] + '*' + searchWord[i+1:]\n        → Decision: patternMap.contains(pattern)?\n            Yes → If patternMap[pattern] > 1 OR searchWord not in wordsSet\n                → Return true\n            No → Continue\n    → Return false\n→ End // search 方法結束\nEnd // 程式執行結束\n\nBut must use \"Decision:\" lines. So maybe restructure:\n\nStep 4: 方法 search(searchWord)\n→ For i ...\n    → pattern = ...\n    → Decision: patternMap contains pattern?\n        Yes →\n            → Decision: patternMap[pattern] > 1 OR searchWord not in wordsSet?\n                Yes → Step: Return true\n                No → Continue\n        No → Continue\n→ Step: Return false\n\nNeed to include arrow \"→\" before each step.\n\nAlso need to include \"Start\" and \"End\".\n\nLet's write final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MagicDictionary 類別 // 建立類別框架  \n    → Substep 1.1: wordsSet ← 空集合 // 用於存放所有單字  \n    → Substep 1.2: patternMap ← 空映射 // key: 通配符模式, value: 出現次數  \n→ End // 類別定義結束  \n\n→ Step 2: MagicDictionary() // 建構子  \n    → wordsSet ← 空集合 // 初始化空集合  \n    → patternMap ← 空映射 // 初始化空映射  \n→ End // 建構子結束  \n\n→ Step 3: buildDict(dictionary) // 建立字典  \n    → For 每個 word 在 dictionary  \n        → For i 從 0 到 len(word)-1  \n            → pattern ← word[0:i] + '*' + word[i+1:] // 產生通配符模式  \n            → patternMap[pattern] ← patternMap.get(pattern,0) + 1 // 計數累加  \n        → wordsSet.add(word) // 加入單字集合  \n→ End // buildDict 結束  \n\n→ Step 4: search(searchWord) // 判斷是否能改一字匹配  \n    → For i 從 0 到 len(searchWord)-1  \n        → pattern ← searchWord[0:i] + '*' + searchWord[i+1:] // 產生通配符模式  \n        → Decision: patternMap.contains(pattern)? // 檢查是否存在此模式  \n            Yes → Decision: patternMap[pattern] > 1 OR searchWord ∉ wordsSet?  \n                Yes → Step 4.1: Return true // 有合法匹配，回傳真  \n                No → Continue // 不滿足條件，繼續檢查其他位置  \n            No → Continue // 沒有此模式，檢查下一個位置  \n    → Step 4.2: Return false // 所有位置都不符合，回傳假  \n→ End // search 方法結束  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    commands, args = ast.literal_eval(data)\n\n    results = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MagicDictionary\":\n            obj = MagicDictionary()\n            results.append(None)\n        elif cmd == \"buildDict\":\n            obj.buildDict(arg)\n            results.append(None)\n        elif cmd == \"search\":\n            res = obj.search(arg)\n            results.append(res)\n        else:\n            results.append(None)\n\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp65_ke7ub.py\", line 34, in <module>\n    obj.buildDict(arg)\n  File \"/tmp/tmp65_ke7ub.py\", line 10, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode672.json",
    "problem_index_in_file": 0,
    "title": "Bulb Switcher II",
    "description_snippet": "There is a room with n bulbs labeled from 1 to n that all are turned on initially, and four buttons ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line with comments, no real code. So we need algorithm outline to compute number of distinct bulb statuses after presses. It's classic problem: 4 buttons, each toggles subset. The group of operations forms a group. We can represent each button as vector of bits length n. After presses, reachable states are linear combinations over GF(2) of button vectors, with exactly presses operations, but order irrelevant since addition is XOR. However exactly presses: number of sequences length presses, but resulting state depends only on parity of each button count. But since pressing same button twice cancels, we only care about whether each button pressed odd or even times. But exactly presses means we need to consider which combinations of button counts that sum to presses. The number of reachable states equals number of distinct XOR sums achievable with any selection of buttons with counts parity vector, where total number of presses parity constraints? Wait: Suppose we press buttons a,b,c,d each count ai. The resulting state = XOR over ai mod 2 times vector i. So only parity matters. But counts must sum to presses, so sum(ai) = presses. Parity vector parity ai mod 2 must satisfy sum(ai) ≡ presses (mod 2). So if presses parity is p, we need vector parity with sum parity = p. But also, we need that there exist nonnegative integers ai achieving those parities while sum ai = presses. For given parity vector, can we always find such counts? Yes, if sum parity = p, we can adjust by adding 2 to some ai's to increase sum by multiples of 2. Since we can add 2 to any button count, we can always achieve any total presses with same parity as sum parity. Therefore all parity vectors whose sum parity matches presses parity are reachable. There are 2^4=16 parity vectors, half have parity sum even, half odd. So reachable states count is number of distinct XOR results for those parity vectors. Need to compute rank of set of 4 vectors to find number of distinct XORs among allowed parity vectors subset. For each parity vector subset, the resulting state is XOR of subset of button vectors. So we just need number of distinct XORs achievable by any subset of buttons with parity sum constraint.\n\nThus algorithm: compute the set of all XOR combinations of buttons. That's 2^4=16 states. Then filter those whose button count parity matches presses parity. Count unique states. Complexity trivial. But we produce pseudocode.\n\nLet's produce steps: Start, Input n, presses, generate button vectors as conceptual, but we can compute transitions pattern? But we can derive final state from combination using parity of each button. We'll represent state as tuple of bits length n but we can summarise as formula? For simplicity, we can compute states symbolically: but we can just compute resulting pattern for each subset by simulation using bitset of size n. We need pseudocode, not code. So we can describe loops.\n\nLet's produce steps:\n\n1. Start\n2. Read n, presses\n3. Create list of 4 vectors, each vector length n boolean initially false (off). But all start on, so we may track toggle effects. For each button, mark which indices toggled.\n4. For each subset of {0,1,2,3} (0-15) compute XOR result: start with all on (True). For each button in subset, toggle indices.\n5. Keep map of resulting state (string or set). But we need to check parity: number of buttons in subset parity should equal presses%2? Actually we need sum(ai) parity equals presses parity. For subset S, parity of count of buttons pressed odd = |S| mod 2. Since each button appears at most once. So condition: |S| mod 2 == presses mod 2. Keep state if condition true.\n6. Count distinct states.\n7. Output count.\n\nBut we also need to note that some states may be same due to dependencies among button vectors. But our set unique ensures that.\n\nEdge cases: n large, but we only need to compute up to 16 states. So we can represent each state as bitset string. Or we can compute a fingerprint: but pseudocode wise.\n\nWe also may discuss optimization: compute linear independence. But keep simple.\n\nLet's produce pseudocode lines accordingly, each with comment.\n\nLet's start.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取整數 n 與 presses // 取得燈泡數量與總按鈕按壓次數\n→ Step 2: 初始化 4 個布林陣列 button[4][n] 為 False // 代表各按鈕會翻轉哪些燈泡\n    → For i from 1 to n\n        → If i ≤ n → button[0][i] = True // 按鈕1 翻轉所有燈\n        → If i % 2 == 0 → button[1][i] = True // 按鈕2 翻轉偶數編號\n        → If i % 2 == 1 → button[2][i] = True // 按鈕3 翻轉奇數編號\n        → If (i-1) % 3 == 0 → button[3][i] = True // 按鈕4 翻轉 j = 3k+1 的燈\n→ Decision: 建立集合 states 以儲存已出現的燈泡狀態 // 以字串或位元集合表示\n→ Decision: 取得 presses 的奇偶性 parityPress = presses % 2 // 只與奇偶性相關\n→ For subsetMask from 0 to 15 // 逐一檢查所有按鈕組合\n    → Step 3: count = 位元個數(subsetMask) // 按鈕被按一次的數量\n    → Decision: 如果 count % 2 == parityPress // 只考慮符合總按壓奇偶性的組合\n        → Step 4: state = 全部燈亮的布林陣列 // 初始全開\n        → For buttonIdx from 0 to 3\n            → If subsetMask 的第 buttonIdx 位為 1\n                → Step 5: 針對每個 i 從 1 到 n\n                    → state[i] = state[i] XOR button[buttonIdx][i] // 翻轉對應燈\n        → Step 6: 把 state 轉成唯一鍵 key（如二進位字串）並加入 states // 去重\n→ Step 7: answer = states 的大小 // 不同可能狀態的個數\n→ End // 程式執行結束，輸出 answer",
      "generated_code": "import sys\n\n# ----------------------------------------------\n# 1. 主要解法：根據題目已知的結論\n# ----------------------------------------------\ndef count_possible_statuses(n: int, presses: int) -> int:\n    \"\"\"\n    根據「Bulb Switcher II」的結論計算不同燈泡狀態的個數。\n    只需要考慮 presses 的奇偶性、n 的大小，答案不會超過 8。\n    \"\"\"\n    # 按鈕按壓 0 次，只剩初始全亮的 1 種狀態\n    if presses == 0:\n        return 1\n\n    # n = 1 時，只有「所有燈開」和「所有燈關」兩種狀態\n    if n == 1:\n        return 2\n\n    # n = 2 時，最多 4 種狀態；若只按一次則 3 種\n    if n == 2:\n        return 4 if presses > 1 else 3\n\n    # n >= 3 時，狀態數量取決於 presses 的大小\n    if presses == 1:\n        return 4          # 只按一次，最多 4 種\n    if presses == 2:\n        return 7          # 按兩次，最多 7 種\n    # presses >= 3 時，所有 8 種都可達\n    return 8\n\n# ----------------------------------------------\n# 2. 讀取輸入、執行解法並輸出結果\n# ----------------------------------------------\ndef main() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n\n    # 允許輸入「n = 1, presses = 1」或「1 1」等多種格式\n    numbers = []\n    for token in data:\n        # 嘗試從 token 中提取整數\n        try:\n            numbers.append(int(token))\n        except ValueError:\n            # token 可能包含符號，如 'n', '=', 'presses', ','\n            # 只保留其中的數字部分\n            num_str = ''\n            for ch in token:\n                if ch.isdigit() or (ch == '-' and not num_str):\n                    num_str += ch\n            if num_str:\n                numbers.append(int(num_str))\n\n    if len(numbers) < 2:\n        return  # 需要至少兩個數字\n\n    n, presses = numbers[0], numbers[1]\n    result = count_possible_statuses(n, presses)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1, presses = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 2, presses = 1",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "n = 3, presses = 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode60.json",
    "problem_index_in_file": 0,
    "title": "Permutation Sequence",
    "description_snippet": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations.\n\nBy listing and labeling all o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code that returns k-th permutation for numbers 1..n. Typical algorithm: use factorial representation. We produce list of numbers available. For i from 1..n: factor = (n-i)!; index = (k-1)/factor; pick numbers[index], append to result, remove; k = (k-1)%factor +1. We'll generate pseudo-code step by step with explanation. Use arrows. Provide Start, End. Use Decision: etc. We'll keep it simple but thorough.\n\nWe need to output each line of virtual code with explanation comment after //.\n\nLet's craft. Use indentation maybe with tab spaces? The example uses arrows with spaces and indentation. We'll produce:\n\nStart // start\n→ Step 1: input n, k // get parameters\n→ Step 2: 初始化 numbers 列表 1..n // prepare list\n→ Step 3: 初始化 result 字符串 \"\" // result\n→ Step 4: 迴圈 i from 1 to n // iterate positions\n    → Step 5: factor = factorial(n - i) // compute remaining factorial\n    → Decision: 如果 k == 0? // handle zero index\n        Yes → k = n! // if k zero, wrap around\n        No  →\n    → Step 6: index = (k-1) / factor // determine index\n    → Step 7: result += numbers[index] // append\n    → Step 8: 移除 numbers[index] // remove used\n    → Step 9: k = (k-1) % factor + 1 // update k\n→ End // return result\n\nBut we should use virtual code steps with arrow and explanation. Let's produce lines with \"→\". Indent for nested. Use Decision with Yes → and No →. Let's craft exactly.\n\nMake sure each line is a single line. Use spaces after arrows. Provide explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n, k // 取得 n 與 k 的值  \n→ Step 2: 初始化 numbers 為 [1, 2, …, n] // 創建可用數字列表  \n→ Step 3: 初始化 result 為空字串 // 用於累積第 k 個排列  \n→ Step 4: 迴圈 i 從 1 到 n // 為每個位置選取數字  \n  → Step 5: 計算 factor = factorial(n - i) // 仍可填充的位數的排列數  \n  → Decision: 如果 k == 0? // 防止 k 為 0 時除錯  \n    Yes → k = factorial(n) // 若 k 為 0，將其置回總排列數  \n    No →  \n  → Step 6: 計算 index = (k - 1) / factor // 目前位子應選的索引  \n  → Step 7: 將 numbers[index] 加到 result // 取得此位數字  \n  → Step 8: 移除 numbers[index] // 把已使用的數字剔除  \n  → Step 9: 更新 k = (k - 1) % factor + 1 // 為下一位重設 k  \n→ End // 回傳 result 作為第 k 個排列序列",
      "generated_code": "import sys\nimport math\nimport re\n\ndef get_permutation(n: int, k: int) -> str:\n    \"\"\"\n    Return the k-th permutation of the sequence [1, 2, …, n].\n    \"\"\"\n    numbers = list(range(1, n + 1))\n    k -= 1  # Convert to 0‑indexed\n    result = []\n\n    for i in range(n, 0, -1):\n        fact = math.factorial(i - 1)\n        index = k // fact\n        result.append(str(numbers.pop(index)))\n        k %= fact\n\n    return ''.join(result)\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, compute the k‑th permutation, and print it.\n    The input format can be flexible; we extract integers from the text.\n    \"\"\"\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n\n    if len(nums) < 2:\n        return  # Not enough data\n\n    n, k = int(nums[0]), int(nums[1])\n    ans = get_permutation(n, k)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 3",
          "expected_output": "\"213\"",
          "success": true,
          "output": "213"
        },
        {
          "example_index": 1,
          "input": "n = 4, k = 9",
          "expected_output": "\"2314\"",
          "success": true,
          "output": "2314"
        },
        {
          "example_index": 2,
          "input": "n = 3, k = 1",
          "expected_output": "\"123\"",
          "success": true,
          "output": "123"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode744.json",
    "problem_index_in_file": 0,
    "title": "Find Smallest Letter Greater Than Target",
    "description_snippet": "You are given an array of characters letters that is sorted in non-decreasing order, and a character...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode in Chinese. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. We need Start, Decision, Yes→, No→, etc. So we need to produce a virtual code for the problem: given sorted array letters and a target char, return the smallest char greater than target; if none, return first char.\n\nWe need to produce algorithm, likely binary search, but we can also linear scan. But since array sorted, binary search is efficient.\n\nWe'll produce pseudocode with Start, maybe Step 1: initialize low, high, result. Step 2: binary search loop. Decision: while low <= high? etc. At the end, check if result found; else return letters[0]. Provide explanation per line.\n\nWe need to not output actual code. Use arrow arrows.\n\nLet's craft lines:\n\nStart // 開始\n→ Step 1: 設定 low = 0, high = len(letters)-1, result = null // 初始化索引\n→ Decision: while low <= high? // 判斷是否仍有搜尋區間\n    Yes → Step 2: mid = (low + high) // 2 // 計算中點索引\n    → Decision: letters[mid] <= target? // 判斷中點字元是否小於等於目標\n        Yes → Step 3: low = mid + 1 // 將低指標移至中點右側\n        No  → Step 4: result = letters[mid] // 找到比目標大的字元\n              → Step 5: high = mid - 1 // 繼續搜尋左側以找更小的符合條件字元\n→ Decision: result != null? // 搜尋是否找到符合字元\n    Yes → Step 6: return result // 回傳找到的字元\n    No  → Step 7: return letters[0] // 沒找到，回傳第一個字元\nEnd // 結束\n\nWe need to ensure each line has the virtual code followed by // explanation. Also need to keep arrow formatting: \"→\" and \"Yes →\", \"No →\".\n\nLet's produce final answer with each line as requested.\n\nLet's also include indentation for decisions maybe but keep simple.\n\nEnsure each line separate. Use \"Start\" and \"End\" lines. Let's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 0, high = len(letters) - 1, result = null // 初始化搜尋區間與答案  \n→ Decision: low <= high? // 判斷是否還有未搜尋區間  \n    Yes → Step 2: mid = (low + high) // 2 // 計算中點索引  \n    → Decision: letters[mid] <= target? // 判斷中點字元是否小於等於目標字元  \n        Yes → Step 3: low = mid + 1 // 移動低指標至中點右側繼續搜尋  \n        No  → Step 4: result = letters[mid] // 找到比目標大的字元，暫存作答案  \n              → Step 5: high = mid - 1 // 搜尋左側以找更小但仍大於目標的字元  \n→ Decision: result != null? // 搜尋是否已找到符合條件的字元  \n    Yes → Step 6: return result // 回傳最小比目標大的字元  \n    No  → Step 7: return letters[0] // 若無此字元，回傳第一個字元  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def nextGreatestLetter(self, letters, target):\n        left, right = 0, len(letters) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if letters[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return letters[left % len(letters)]\n\ndef parse_input(text: str):\n    # Extract the letters list\n    letters_match = re.search(r'letters\\s*=\\s*(\\[[^\\]]*\\])', text)\n    if letters_match:\n        letters = ast.literal_eval(letters_match.group(1))\n    else:\n        letters = []\n\n    # Extract the target character (quoted or unquoted)\n    target_match = re.search(r'target\\s*=\\s*(\".*?\"|\\'.*?\\'|[^\\s,]+)', text)\n    if target_match:\n        target_str = target_match.group(1)\n        try:\n            target = ast.literal_eval(target_str)\n        except Exception:\n            target = target_str.strip('\"\\'')\n    else:\n        target = ''\n\n    return letters, target\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read()\n    letters, target = parse_input(input_text)\n    solution = Solution()\n    result = solution.nextGreatestLetter(letters, target)\n    # Output in the same format as examples: quoted character\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"a\"",
          "expected_output": "\"c\"",
          "success": true,
          "output": "\"c\""
        },
        {
          "example_index": 1,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"c\"",
          "expected_output": "\"f\"",
          "success": true,
          "output": "\"f\""
        },
        {
          "example_index": 2,
          "input": "letters = [\"x\",\"x\",\"y\",\"y\"], target = \"z\"",
          "expected_output": "\"x\"",
          "success": true,
          "output": "\"x\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode496.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element I",
    "description_snippet": "The next greater element of some element x in an array is the first greater element that is to the r...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: given two arrays, find next greater element for each element in nums1 based on its position in nums2. Standard solution: Use stack to compute next greater element for all elements in nums2, store mapping value->next greater, then for each in nums1 produce mapping or -1.\n\nWe produce steps: Start, compute mapping via stack: iterate nums2 from end to start, maintain stack of greater elements, compute next greater for each element. Store mapping. Then iterate nums1, lookup mapping to fill ans. Output ans. End.\n\nWe need to use virtual code with arrow, decision, etc.\n\nWe need to produce each line with explanation comment. Use virtual code syntax: \"Start //\", \"→ Step X: ... //\", \"Decision:\" etc.\n\nWe should produce step by step.\n\nLet's craft lines:\n\nStart // 程式開始\n→ Step 1: 初始化空字典 nextGreaterMap // 用來儲存每個 nums2 元素對應的下一個更大元素\n→ Step 2: 初始化空棧 stack // 用於找下一個更大元素的輔助資料結構\n→ Decision: 如果 nums2 為空? // 檢查輸入是否為空\n    Yes → Step 3: 回傳空陣列 ans // 若 nums2 為空，直接回傳空結果\n    No → 進行後續計算\n\n→ Step 4: 從 nums2 的最後一個索引到第一個索引遍歷 // 逆序遍歷以便使用棧求下一個更大元素\n    → Step 4.1: 取得元素 val = nums2[i] // 取出目前元素\n    → Decision: 當前棧是否非空且棧頂 <= val? // 判斷是否需要清除小於等於 val 的元素\n        Yes → Loop: While stack 非空且 stack.top <= val, pop stack // 移除所有不大於 val 的元素\n        No  → 不進行操作\n    → Decision: 棧是否非空? // 判斷是否存在更大的元素\n        Yes → Step 4.2: 設定 nextGreaterMap[val] = stack.top // 最小更大元素為棧頂\n        No  → Step 4.3: 設定 nextGreaterMap[val] = -1 // 沒有更大元素\n    → Step 4.4: push val 到 stack // 把當前元素放入棧中，供左邊元素使用\n\n→ Step 5: 初始化 ans 陣列長度為 nums1.length // 準備結果陣列\n→ Decision: nums1 是否為空? // 若 nums1 空直接返回\n    Yes → Step 6: 回傳 ans // 空結果\n    No → 進行後續\n\n→ Step 7: 從 i = 0 到 nums1.length-1 遍歷 // 對每個 nums1 元素查找結果\n    → Step 7.1: 取得元素 x = nums1[i]\n    → Step 7.2: 設定 ans[i] = nextGreaterMap[x] // 取對應的下一個更大元素\n\n→ Step 8: 回傳 ans // 結果輸出\nEnd // 程式執行結束\n\nWe should ensure using arrow properly: Use \"→\" before steps. For decisions, use \"Decision:\" then indent. Provide explanation comments after \"//\".\n\nAlso we might need to show loops and while loops inside decisions. The requirement: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\". We should follow formatting.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 建立空字典 nextGreaterMap // 用來儲存每個 nums2 元素對應的下一個更大元素\n→ Step 2: 建立空棧 stack // 用於計算下一個更大元素\n→ Decision: 若 nums2 為空? // 檢查輸入是否為空\n    Yes → Step 3: 回傳空陣列 ans // 若 nums2 為空，直接回傳空結果\n    No  → 進行後續計算\n\n→ Step 4: 從 nums2 最後一個索引往前遍歷 // 逆序遍歷以便使用棧求下一個更大元素\n    → Step 4.1: 取得元素 val = nums2[i] // 取出目前元素\n    → Decision: 棧非空且 stack.top <= val? // 判斷是否需要移除小於等於 val 的元素\n        Yes → While stack 非空且 stack.top <= val:\n                pop stack // 移除所有不大於 val 的元素\n        No  → 不進行操作\n    → Decision: 棧非空? // 判斷是否存在更大的元素\n        Yes → Step 4.2: 設定 nextGreaterMap[val] = stack.top // 最小更大元素為棧頂\n        No  → Step 4.3: 設定 nextGreaterMap[val] = -1 // 沒有更大元素\n    → Step 4.4: push val 到 stack // 把當前元素放入棧中，供左邊元素使用\n\n→ Step 5: 建立 ans 陣列，長度為 nums1.length // 準備結果陣列\n→ Decision: 若 nums1 為空? // 若無需處理，直接返回\n    Yes → Step 6: 回傳 ans // 空結果\n    No  → 進行後續\n\n→ Step 7: 從 i = 0 到 nums1.length-1 遍歷 // 對每個 nums1 元素查找結果\n    → Step 7.1: 取得元素 x = nums1[i]\n    → Step 7.2: 設定 ans[i] = nextGreaterMap[x] // 取對應的下一個更大元素\n\n→ Step 8: 回傳 ans // 將結果輸出\nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def nextGreaterElement(self, nums1, nums2):\n        \"\"\"\n        找到 nums2 中每個元素的下一個更大元素，並回傳對應於 nums1 的結果。\n        \"\"\"\n        stack = []           # 用於保存尚未找到更大元素的數字\n        next_greater = {}    # value -> next greater value\n\n        for num in nums2:\n            # 把比當前 num 小的元素從堆疊中彈出，並設定它們的下一個更大元素\n            while stack and num > stack[-1]:\n                next_greater[stack.pop()] = num\n            stack.append(num)\n\n        # nums1 中的每個值，如果存在映射就取值，否則回傳 -1\n        return [next_greater.get(x, -1) for x in nums1]\n\n\ndef main():\n    import sys\n    import re\n\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 從輸入中抓取兩個 list，格式為 \"nums1 = [...], nums2 = [...]\"\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[[^\\]]*\\])', data)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[[^\\]]*\\])', data)\n\n    if not nums1_match or not nums2_match:\n        # 若輸入格式不符，則直接結束\n        return\n\n    # 使用 eval 解析 list 字串，安全前提下可接受\n    nums1 = eval(nums1_match.group(1))\n    nums2 = eval(nums2_match.group(1))\n\n    # 呼叫解法\n    solution = Solution()\n    result = solution.nextGreaterElement(nums1, nums2)\n\n    # 輸出結果\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [4,1,2], nums2 = [1,3,4,2]",
          "expected_output": "[-1,3,-1]",
          "success": true,
          "output": "[-1, 3, -1]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [2,4], nums2 = [1,2,3,4]",
          "expected_output": "[3,-1]",
          "success": true,
          "output": "[3, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode658.json",
    "problem_index_in_file": 0,
    "title": "Find K Closest Elements",
    "description_snippet": "Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the ar...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step. We must follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. For algorithm: Given sorted arr, find k closest to x. Approach: binary search to find closest index; then expand window of size k by two pointers. Let's produce steps.\n\nLine1: Start // 程式開始執行\nLine2: → Step 1: 二分搜尋找到 x 或最接近的索引 // 找出 x 或最近的元素索引\nLine3: → Decision: index 是否存在於 arr？ // 判斷是否直接找到 x\n    Yes → Step 2: left = index, right = index // 若找到 x，左右指針同為 index\n    No → Step 2: left = index - 1, right = index // 若未找到，左右分別指向兩邊最近\nLine4: → Step 3: 初始化結果集合 emptyList // 用於存儲 k 個最近元素\nLine5: → While: 結果數量 < k // 循環直到收集 k 個元素\n    → Decision: left 是否超出邊界? 或 right 是否超出邊界? // 檢查邊界\n        Yes → Decision: 左邊界超出? // 如果只有一側還有元素\n            Yes → Step 4: 加入 arr[right] 至結果， right++ // 取右側\n            No  → Step 4: 加入 arr[left] 至結果， left-- // 取左側\n        No  → Step 4: Decision: |arr[left]-x| ≤ |arr[right]-x| // 比較距離\n                Yes → Step 4: 加入 arr[left] 至結果， left-- // 取左側\n                No  → Step 4: 加入 arr[right] 至結果， right++ // 取右側\nLine6: → Step 5: 將結果集合排序 ascending // 排序以符合輸出要求\nLine7: End // 程式執行結束\n\nWe need to output each line with // explanation. Use arrow, indentation for nested decisions. Each line must be one of the steps. Use \"Decision:\" lines. Use arrow for Yes / No. Let's produce.\n\nMake sure each line is separate and no extra content. Use proper indentation spaces to show hierarchy maybe 4 spaces. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 二分搜尋找到 x 或最接近的索引 // 找出 x 或最近的元素索引\n→ Decision: 是否直接找到 x? // 判斷搜尋結果是否正好為 x\n    Yes → Step 2: left = index, right = index // 若找到 x，左右指針同為 index\n    No  → Step 2: left = index - 1, right = index // 若未找到，左右分別指向兩邊最近\n→ Step 3: 初始化結果集合 emptyList // 用於存儲 k 個最近元素\n→ While: 結果數量 < k // 循環直到收集 k 個元素\n    → Decision: 左右指針是否超出邊界? // 檢查是否只有一側還有元素\n        Yes → Decision: 左指針已越界? // 判斷是哪側已結束\n            Yes → Step 4: 加入 arr[right] 至結果， right++ // 取右側元素\n            No  → Step 4: 加入 arr[left] 至結果， left-- // 取左側元素\n        No  → Step 4: Decision: |arr[left]-x| ≤ |arr[right]-x| // 比較左右距離\n                Yes → Step 4: 加入 arr[left] 至結果， left-- // 取距離較近的左側\n                No  → Step 4: 加入 arr[right] 至結果， right++ // 取距離較近的右側\n→ Step 5: 將結果集合排序 ascending // 排序以符合輸出要求\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def findClosestElements(self, arr, k, x):\n        \"\"\"\n        找出陣列 arr 中最接近 x 的 k 個元素，並以升序輸出。\n        使用二分搜尋確定左端點 left，使得 arr[left:left+k] 為答案。\n        \"\"\"\n        left, right = 0, len(arr) - k\n        while left < right:\n            mid = (left + right) // 2\n            # 判斷哪一側更接近 x\n            if x - arr[mid] > arr[mid + k] - x:\n                left = mid + 1\n            else:\n                right = mid\n        return arr[left:left + k]\n\ndef parse_input(raw: str):\n    \"\"\"\n    將輸入字串轉換為字典 {'arr': [...], 'k': int, 'x': int}。\n    允許輸入格式為「arr = [1,2,3], k = 4, x = 5」等。\n    \"\"\"\n    # 把等號改成冒號，方便轉成字典字面量\n    raw = raw.replace('=', ':')\n    # 用花括號包起來，形成合法的 dict 表達式\n    expr = '{' + raw + '}'\n    return eval(expr)\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    data = parse_input(raw_input)\n    arr = data['arr']\n    k = data['k']\n    x = data['x']\n    solution = Solution()\n    result = solution.findClosestElements(arr, k, x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [1,2,3,4,5], k = 4, x = 3",
          "expected_output": "[1,2,3,4]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp6sebflhs.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmp6sebflhs.py\", line 34, in main\n    data = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6sebflhs.py\", line 28, in parse_input\n    return eval(expr)\n           ^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'arr' is not defined"
        },
        {
          "example_index": 1,
          "input": "arr = [1,1,2,3,4,5], k = 4, x = -1",
          "expected_output": "[1,1,2,3]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpuh44qd50.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmpuh44qd50.py\", line 34, in main\n    data = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpuh44qd50.py\", line 28, in parse_input\n    return eval(expr)\n           ^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'arr' is not defined"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode93.json",
    "problem_index_in_file": 0,
    "title": "Restore IP Addresses",
    "description_snippet": "A valid IP address consists of exactly four integers separated by single dots. Each integer is betwe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step. Must not output actual code. Use virtual code arrows, decisions, etc. Each line: \"虛擬碼步驟 // 解釋\". Provide the algorithm: backtracking to place 3 dots.\n\nInput: string s. Output list of strings.\n\nSteps: Start, Check length 4-12 else return empty. Define result list. Define backtrack(start, parts, path). If parts==4: if start==len(s) add path to result. return. For i from 1 to 3: if start+i<=len(s): segment=s[start:start+i]; if segment has leading zero and length>1 skip; if int(segment)>255 skip; else call backtrack(start+i, parts+1, path+segment+('.' if parts<3 else '')). After recursion. Then End.\n\nNeed to output each line with explanation. Use decision blocks for checks. Provide clear.\n\nEnsure each line includes the arrow? For start lines, \"Start //\".\n\nWe need arrow for decisions: \"Decision: ...\".\n\nUse indentation? Provide nested arrow lines. Format example earlier shows indentation with spaces. We'll do similar.\n\nLet's produce.\n\nNote: Each line must contain \"虛擬碼步驟\" + space + \"// 解釋\". For lines with arrow like \"→ Step 1: ...\". So include arrow in virtual code. Provide explanation after //.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得待拆解的數字字串  \n→ Decision: 如果 s 長度 < 4 或 > 12? // IP 必須 4 到 12 個數字  \n  Yes → Step 2: 回傳空列表 // 無法形成合法 IP  \n  No  → Step 3: 初始化結果 list, 呼叫 Backtrack(0, 0, \"\") // 開始遞迴搜尋  \n→ End // 程式執行結束  \n\nBacktrack( start, parts, path ) // start: 當前索引, parts: 已完成區段數, path: 已組成的字串  \n  Decision: 如果 parts == 4? // 已完成四段 IP  \n   Yes → Decision: 如果 start == len(s)? // 是否消費完所有字元  \n     Yes → Step 4: 將 path 加入結果 list // 成功組合\n     No  → Step 5: 返回 // 未消費完字元，回溯  \n   No  → Step 6: 對 i in 1..3 // 嘗試三種長度  \n     Decision: 如果 start + i <= len(s)? // 防止越界  \n      Yes → Step 7: segment = s[start : start+i] // 取候選區段  \n       Decision: 如果 segment 以 '0' 為首且 len>1? // 防止領先零  \n        Yes → Step 8: 跳過此 i // 非法領先零，繼續下一長度  \n        No  → Step 9: 轉 int seg_val = int(segment) // 轉為整數  \n        Decision: 如果 seg_val > 255? // 檢查數值範圍  \n         Yes → Step 10: 跳過此 i // 數值超過 255，繼續下一長度  \n         No  → Step 11: new_path = path + segment + ( \".\" if parts < 3 else \"\" ) // 加入區段及點  \n          → Backtrack( start + i, parts + 1, new_path ) // 深入遞迴  \n       Decision: 否則 // start + i 超過長度，跳出迴圈  \n        → 返回 // 回到上一層  \n     Decision: 否則 // parts < 4, 但無更多合法 i，直接返回  \n      → 返回 // 回到上一層  \n\n結果 list 已包含所有合法 IP，呼叫者可直接回傳或輸出。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def restoreIpAddresses(self, s: str):\n        res = []\n\n        def backtrack(start: int, parts: int, path: str):\n            if parts == 4:\n                if start == len(s):\n                    res.append(path)\n                return\n            for length in range(1, 4):\n                if start + length > len(s):\n                    break\n                segment = s[start:start + length]\n                if (segment.startswith('0') and len(segment) > 1) or int(segment) > 255:\n                    continue\n                new_path = segment if parts == 0 else path + '.' + segment\n                backtrack(start + length, parts + 1, new_path)\n\n        if 4 <= len(s) <= 12:\n            backtrack(0, 0, '')\n        return res\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    # 提取第一組數字字串，忽略可能的「s =」前綴與引號\n    nums = re.findall(r'\\d+', raw_input)\n    s = nums[0] if nums else ''\n    solution = Solution()\n    result = solution.restoreIpAddresses(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"25525511135\"",
          "expected_output": "[\"255.255.11.135\",\"255.255.111.35\"]",
          "success": true,
          "output": "['255.255.11.135', '255.255.111.35']"
        },
        {
          "example_index": 1,
          "input": "s = \"0000\"",
          "expected_output": "[\"0.0.0.0\"]",
          "success": true,
          "output": "['0.0.0.0']"
        },
        {
          "example_index": 2,
          "input": "s = \"101023\"",
          "expected_output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]",
          "success": true,
          "output": "['1.0.10.23', '1.0.102.3', '10.1.0.23', '10.10.2.3', '101.0.2.3']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode393.json",
    "problem_index_in_file": 0,
    "title": "UTF-8 Validation",
    "description_snippet": "Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps explaining algorithm for validating UTF-8 encoding given an integer array of bytes. We need to output step by step in specified format: each line: virtual code step + space + // explanation. Use arrows, decisions etc. Provide logic.\n\nWe must not produce actual code, just steps. Steps: Start, iterate through array, for each byte, determine leading bits count: count leading ones until 0 or 8. If leading ones count 1 or >4 invalid. Then if count >1, check following count bytes start with 10. Use loop. End. Should handle all bytes.\n\nWe should produce like:\n\nStart // 程式開始\n→ Step 1: 初始化索引 i = 0 // 設定迴圈指標\n→ Decision: i < data.Length? // 檢查是否還有未處理的位元組\n    Yes → Step 2: current = data[i] & 0xFF // 取得當前位元組\n    Yes → Step 3: leadingOnes = CountLeadingOnes(current) // 計算前導1的個數\n    Yes → Decision: leadingOnes == 0? // 是否為單字節\n        Yes → Step 4: i = i + 1 // 單字節，移動到下一個\n        No  → Decision: leadingOnes == 1 or leadingOnes > 4? // 無效長度\n            Yes → Step 5: return false // 無效編碼\n            No  → Step 6: expected = leadingOnes - 1 // 需要的連續後續位元組數\n    Yes → Decision: i + expected < data.Length? // 檢查剩餘足夠位元組\n        Yes → Step 7: For j=1 to expected: check if (data[i+j] & 0xC0) == 0x80 // 前兩位為10\n            Yes → Step 8: i = i + leadingOnes // 跳過整個字元\n            No  → Step 9: return false // 連續位元組格式錯誤\n        No  → Step 10: return false // 位元組不足\n→ Decision: i == data.Length? // 完成所有位元組\n    Yes → Step 11: return true // 所有字元皆合法\nEnd // 程式結束\n\nBut need to use arrows for decisions and steps; each line with virtual code step and comment.\n\nWe should include a function CountLeadingOnes maybe.\n\nMaybe produce steps:\n\nStart\n→ Step 1: Set i = 0\n→ Decision: i < data.Length?\n   Yes → Step 2: byte = data[i] & 0xFF\n   Yes → Step 3: ones = 0\n   Yes → Loop: while ((byte << ones) & 0x80) != 0: ones += 1 // count leading ones\n   Yes → Decision: ones == 0? // single byte\n        Yes → Step 4: i += 1\n        No  → Decision: ones == 1 or ones > 4? // invalid\n              Yes → Step 5: return false\n              No  → Step 6: expected = ones - 1\n   Yes → Decision: i + expected < data.Length?\n        Yes → For k from 1 to expected:\n               // check next bytes start with 10\n               If (data[i+k] & 0xC0) != 0x80: return false\n        Yes → Step 7: i += ones\n        No  → Step 8: return false\n→ Decision: i == data.Length?\n   Yes → Step 9: return true\nEnd\n\nBut we must write each line. Let's write clearly.\n\nWe must include arrow arrows like \"→\". For decisions we use \"Decision:\" and indent inside. Use \"Yes →\" and \"No →\".\n\nWe must produce step by step with explanation.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 設定迴圈指標，從第一個位元組開始\n→ Decision: i < data.Length? // 判斷是否還有未處理的位元組\n    Yes → Step 2: currentByte ← data[i] & 0xFF // 取得目前位元組的低 8 位\n    Yes → Step 3: leadingOnes ← 0 // 用來計算前導 1 的數量\n    Yes → Loop: while (currentByte & (0x80 >> leadingOnes)) ≠ 0? // 檢查第 (leadingOnes+1) 個最高位是否為 1\n        Yes → leadingOnes ← leadingOnes + 1 // 若為 1，計數加 1\n        No  → Exit Loop // 最高位為 0，停止計算\n    Yes → Decision: leadingOnes == 0? // 是否為 1 位元組的情況\n        Yes → Step 4: i ← i + 1 // 單字節，直接移至下一個位元組\n        No  → Decision: leadingOnes == 1 or leadingOnes > 4? // 1 以外或超過 4 位元組皆為非法長度\n            Yes → Step 5: return false // 語法錯誤，結束驗證\n            No  → Step 6: expectedBytes ← leadingOnes - 1 // 需要的連續位元組數量\n    Yes → Decision: i + expectedBytes < data.Length? // 判斷剩餘位元組數是否足夠\n        Yes → For j from 1 to expectedBytes:\n               // 檢查每個連續位元組的最高兩位是否為 10\n               If (data[i + j] & 0xC0) ≠ 0x80? // 最高兩位不是 10\n                   Yes → Step 7: return false // 連續位元組格式錯誤，結束驗證\n        Yes → Step 8: i ← i + leadingOnes // 跳過整個合法字元\n        No  → Step 9: return false // 位元組不足，無法完成字元\n→ Decision: i == data.Length? // 所有位元組是否已被處理完畢\n    Yes → Step 10: return true // 所有字元皆符合 UTF‑8 規則\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validUtf8(self, data):\n        \"\"\"\n        Validate whether the given byte array represents a valid UTF‑8 encoding.\n        Each element of `data` is an integer but only its lowest 8 bits are used.\n        \"\"\"\n        n_bytes = 0  # Number of continuation bytes expected for the current character\n\n        for num in data:\n            byte = num & 0xFF  # Use only the least significant 8 bits\n\n            if n_bytes == 0:\n                # Determine the number of leading 1 bits\n                leading = 0\n                mask = 0x80  # 1000 0000\n                while mask & byte:\n                    leading += 1\n                    mask >>= 1\n\n                if leading == 0:\n                    # 1‑byte character\n                    continue\n                if leading == 1 or leading > 4:\n                    # Invalid starting byte\n                    return False\n                n_bytes = leading - 1  # Remaining continuation bytes\n            else:\n                # Continuation byte must start with bits 10xxxxxx\n                if (byte & 0xC0) != 0x80:\n                    return False\n                n_bytes -= 1\n\n        # All bytes must be consumed exactly\n        return n_bytes == 0\n\ndef main():\n    # Read entire input; it may contain text such as \"data = [197,130,1]\"\n    raw = sys.stdin.read()\n    # Extract all integers (handles negative numbers if ever present)\n    nums = list(map(int, re.findall(r'-?\\d+', raw)))\n    result = Solution().validUtf8(nums)\n    # Print 'true' or 'false' in lowercase as required\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "data = [197,130,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "data = [235,140,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode475.json",
    "problem_index_in_file": 0,
    "title": "Heaters",
    "description_snippet": "Winter is coming! During the contest, your first job is to design a standard heater with a fixed war...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for problem: minimal radius such that heaters cover all houses. Classic: For each house, find distance to nearest heater; answer = max of those distances. Approach: sort houses and heaters; two pointers to find nearest heater. Provide pseudocode step by step.\n\nWe must not output actual code; use virtual code with arrows.\n\nLet's outline:\n\nStart\n→ Step 1: Sort houses ascending\n→ Step 2: Sort heaters ascending\n→ Step 3: Initialize heater index i = 0\n→ Step 4: Initialize maxRadius = 0\n→ Step 5: For each house h in houses:\n    → Step 5.1: While i < len(heaters) and heaters[i] < h: i++ // move to heater right of or at house\n    → Step 5.2: Compute distance to left heater: if i==0 then leftDist = Infinity else abs(h - heaters[i-1])\n    → Step 5.3: Compute distance to right heater: if i==len(heaters) then rightDist = Infinity else abs(heaters[i] - h)\n    → Step 5.4: nearestDist = min(leftDist, rightDist)\n    → Step 5.5: maxRadius = max(maxRadius, nearestDist)\n→ Step 6: Return maxRadius\n\nEdge cases: when heater exactly at house, distance zero.\n\nAlso note: need to use Infinity concept.\n\nAlternatively use binary search each house for nearest heater, but we choose linear sweep.\n\nAdd decision to handle index boundaries.\n\nNow produce virtual code lines with explanations.\n\nWe need each line: \"虛擬碼步驟 // 解釋/說明\"\n\nUse arrow \"→\" preceding each step.\n\nAlso for loops use Step: etc.\n\nLet's produce.\n\nAlso may include Decision: if i==0? etc.\n\nWe need to maintain the \"Decision:\" format.\n\nLet's design:\n\nStart // 程式開始執行\n→ Step 1: Sort houses ascending // 以便順序遍歷\n→ Step 2: Sort heaters ascending // 方便左右比較\n→ Step 3: Set i ← 0 // heater index pointer\n→ Step 4: Set maxRadius ← 0 // 儲存所需最小半徑\n→ Step 5: For each house h in houses:\n    → Decision: if i < len(heaters) AND heaters[i] < h? // 找到最接近右側的 heater\n        Yes → i ← i + 1 // 前進至下一個 heater\n        No  → // 留在原位置\n    → Step 5.1: Decision: i == 0? // 沒有左側 heater\n        Yes → leftDist ← Infinity // 無左側\n        No  → leftDist ← h - heaters[i-1] // 左側距離\n    → Step 5.2: Decision: i == len(heaters)? // 沒有右側 heater\n        Yes → rightDist ← Infinity // 無右側\n        No  → rightDist ← heaters[i] - h // 右側距離\n    → Step 5.3: nearestDist ← min(leftDist, rightDist) // 最近的 heater 距離\n    → Step 5.4: maxRadius ← max(maxRadius, nearestDist) // 更新最大距離\n→ Step 6: Return maxRadius // 最小半徑\nEnd // 程式結束\n\nWe should ensure \"Step 5:\" is not a separate line but inside loop; but we produce lines with \"→ Step\" maybe not \"Step 5.1\" but maintain hierarchical.\n\nWe need to preserve the indentation? The example uses indentation. We can replicate with spaces before lines inside loop? Not necessary, but may help.\n\nBetter produce:\n\nStart // 程式開始執行\n→ Step 1: Sort houses ascending // 以便順序遍歷\n→ Step 2: Sort heaters ascending // 方便左右比較\n→ Step 3: Set i ← 0 // heater index pointer\n→ Step 4: Set maxRadius ← 0 // 儲存所需最小半徑\n→ Step 5: For each house h in houses:\n    → Decision: if i < len(heaters) AND heaters[i] < h? // 找右側最接近的 heater\n        Yes → i ← i + 1\n        No  →\n    → Step 5.1: Decision: i == 0? // 沒有左側 heater\n        Yes → leftDist ← Infinity\n        No  → leftDist ← h - heaters[i-1]\n    → Step 5.2: Decision: i == len(heaters)? // 沒有右側 heater\n        Yes → rightDist ← Infinity\n        No  → rightDist ← heaters[i] - h\n    → Step 5.3: nearestDist ← min(leftDist, rightDist) // 最近的 heater 距離\n    → Step 5.4: maxRadius ← max(maxRadius, nearestDist) // 更新最大距離\n→ Step 6: Return maxRadius // 最小半徑\nEnd // 程式結束\n\nMake sure to use \"→\" arrow at each line.\n\nAlso maintain \"Decision:\" lines.\n\nOk produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort houses ascending // 以便順序遍歷  \n→ Step 2: Sort heaters ascending // 方便左右比較  \n→ Step 3: Set i ← 0 // heater 索引指針  \n→ Step 4: Set maxRadius ← 0 // 儲存所需的最小半徑  \n→ Step 5: For each house h in houses:  \n  → Decision: if i < len(heaters) AND heaters[i] < h? // 尋找右側最近的 heater  \n    Yes → i ← i + 1 // 前進至下一個 heater  \n    No  → // 留在原位置  \n  → Step 5.1: Decision: i == 0? // 沒有左側 heater  \n    Yes → leftDist ← Infinity // 無左側距離  \n    No  → leftDist ← h - heaters[i-1] // 左側距離  \n  → Step 5.2: Decision: i == len(heaters)? // 沒有右側 heater  \n    Yes → rightDist ← Infinity // 無右側距離  \n    No  → rightDist ← heaters[i] - h // 右側距離  \n  → Step 5.3: nearestDist ← min(leftDist, rightDist) // 最近的 heater 距離  \n  → Step 5.4: maxRadius ← max(maxRadius, nearestDist) // 更新最大距離  \n→ Step 6: Return maxRadius // 所求的最小半徑  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\nimport re\n\ndef find_radius(houses, heaters):\n    houses.sort()\n    heaters.sort()\n    res = 0\n    i = 0  # index of the nearest heater on the right side\n    for house in houses:\n        while i < len(heaters) - 1 and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):\n            i += 1\n        res = max(res, abs(heaters[i] - house))\n    return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析「houses = [...]」和「heaters = [...]」兩段文字\n    houses_match = re.search(r'houses\\s*=\\s*(\\[[^\\]]*\\])', data)\n    heaters_match = re.search(r'heaters\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not houses_match or not heaters_match:\n        raise ValueError(\"Input format error\")\n\n    houses = ast.literal_eval(houses_match.group(1))\n    heaters = ast.literal_eval(heaters_match.group(1))\n\n    result = find_radius(houses, heaters)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "houses = [1,2,3], heaters = [2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "houses = [1,2,3,4], heaters = [1,4]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "houses = [1,5], heaters = [2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode591.json",
    "problem_index_in_file": 0,
    "title": "Tag Validator",
    "description_snippet": "Given a string representing a code snippet, implement a tag validator to parse the code and return w...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for tag validator. It's a parsing algorithm. We must generate step-by-step virtual code with explanations. Not actual code. Use Start, Decision, etc. We need to produce steps for validating string. Probably need stack, scanning index. We'll produce high-level algorithm.\n\nLet's outline:\n\nStart\n→ Set i=0 // index\n→ If string not starting with '<' or not closed tag: invalid\n→ Define function parseContent until matching end tag or EOF\nBut we need to produce virtual code lines stepwise.\n\nWe'll produce steps: parse the outermost closed tag.\n\nPseudo:\n\nStart\n→ Check string length >0 else invalid\n→ If first character not '<' -> invalid\n→ Parse first tag name: read until '>' ignoring errors\n→ Validate tag name: only uppercase A-Z length 1-9 else invalid\n→ Move i to after '>'\n→ Parse content until matching closing tag with same name\n→ Use stack to handle nested tags\n→ While i < len\n   → If substring starts with '<![CDATA['\n        → skip until first ']]>'\n   → Else if substring starts with '<' and next char not '/'\n        → Parse nested tag name\n        → Validate tag name\n        → Recursively parse content\n   → Else if substring starts with '</'\n        → Parse end tag name\n        → If matches current open tag -> return\n        → else invalid\n   → Else\n        → Move i by 1 (any char allowed)\n→ After loop, if not closed -> invalid\n→ End\n\nBut need step-by-step. We'll break into functions: parseTagName, isValidTagName, parseCDATA, parseClosedTag.\n\nWe'll produce lines with decisions and arrow. Use Indentation for nested decisions.\n\nLet's produce a linear flow but with nested decisions.\n\nWe'll use '→' arrow each line.\n\nLet's write:\n\nStart // 程式開始執行\n→ Check if string is empty or first char不是 '<' // 若不是以 '<' 開頭即無效\n    No → Return false // 若不是，直接無效\n→ 讀取第一個 '<' 並判斷是否為 CDATA // 但因為必須是閉合標籤，若是 CDATA 立即無效\n    Yes → Return false // CDATA 作為開頭不允許\n→ 解析第一個開始標籤名稱 // 讀取直到第一個 '>'\n    → 如果未找到 '>' 或遇到 EOF → Return false // 標籤未閉合\n→ 將讀取到的名稱存為 outerTagName\n→ 判斷 outerTagName 是否有效 // 大寫且長度 1-9\n    Yes → Continue\n    No → Return false // 開始標籤名稱無效\n→ 將指標移到 '>' 後面 // 進入標籤內容\n→ 建立 stack 並 push outerTagName // 追蹤待關閉標籤\n→ While 指標未超過字串長度\n    → 如果以 '<![CDATA[' 開頭\n        → 進入 CDATA 模式\n            → 讀取至第一個 ']]>' // 直接跳過所有字符\n            → 若未找到 ']]>' → Return false // CDATA 未正確結束\n            → 將指標移到 ']]>' 後面\n            → Continue // 重新檢查\n    → 否則如果以 '</' 開頭\n        → 解析結束標籤名稱 // 讀取直到 '>'\n            → 若未找到 '>' → Return false // 結束標籤未閉合\n        → 判斷解析出的名稱是否與 stack top 相符\n            → Yes → pop stack // 成功關閉\n                → 若 stack 變空且指標未到字串尾 → Return false // 仍有多餘字符\n                → 若 stack 變空且指標已到尾 → Return true // 成功\n            → No → Return false // 結束標籤名稱不匹配\n    → 否則如果以 '<' 開頭（但不是 '</' 也不是 CDATA）\n        → 解析子標籤名稱 // 讀取直到 '>'\n            → 若未找到 '>' → Return false // 子標籤未閉合\n        → 判斷子標籤名稱是否有效\n            → Yes → push 名稱至 stack\n                → 若名稱長度 > 9 或包含非大寫字母 → Return false\n            → No → Return false // 子標籤名稱無效\n        → 移動指標至 '>' 後面 // 進入子標籤內容，loop 會處理\n    → 否則 // 任何其他字符\n        → 移動指標 +1 // 允許任意字符\n→ 循環結束後\n    → 若 stack 非空 → Return false // 有未關閉標籤\n    → Return true // 成功\n\nBut need to present step-by-step with decisions and arrows. Each line with explanation. Use `Decision:` for branches. Use indentation for nested decisions.\n\nAlso we may need to define helper functions but keep them as steps.\n\nLet's produce final answer.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Check if input string is empty or first char ≠ '<' // 必須以 < 開頭\n    No → Return false // 不是開頭標籤，無效\n→ 讀取第一個 '<' 並確認不是 CDATA 開頭\n    Yes → Return false // CDATA 作為最外層不允許\n→ 解析第一個開始標籤名稱（讀到第一個 '>'）\n    → 若未找到 '>' → Return false // 標籤未閉合\n→ 將解析得到的名稱存為 outerTagName\n→ Decision: outerTagName 是否為有效 TAG_NAME (A‑Z,長度 1‑9)?\n    Yes → Continue\n    No  → Return false // 開始標籤名稱無效\n→ 移動指標到 '>' 之後 // 進入標籤內容\n→ 建立 stack 並 push outerTagName // 追蹤待關閉標籤\n→ While 指標未超過字串長度\n    → Decision: 從指標開始的子字串是否以 \"<![CDATA[\" 開頭?\n        Yes →\n            → 讀取至第一個 \"]]>\" // 跳過 CDATA 內容\n            → 若未找到 \"]]>\" → Return false // CDATA 未正確結束\n            → 移動指標到 \"]]>\" 之後\n            → Continue // 重新評估新的子字串\n        No  →\n            → Decision: 子字串是否以 \"</\" 開頭?\n                Yes →\n                    → 解析結束標籤名稱（讀到 '>'）\n                    → 若未找到 '>' → Return false // 結束標籤未閉合\n                    → Decision: 解析出的名稱與 stack.top 是否相同?\n                        Yes →\n                            → pop stack // 成功關閉\n                            → Decision: stack 是否為空且指標已到字串尾?\n                                Yes → Return true // 成功完成\n                                No  → Return false // 多餘字符或未完全閉合\n                        No  → Return false // 結束標籤名稱不匹配\n                No  →\n                    → Decision: 子字串是否以 '<' 開頭（但不是 \"</\" 或 CDATA）?\n                        Yes →\n                            → 解析子標籤名稱（讀到 '>'）\n                            → 若未找到 '>' → Return false // 子標籤未閉合\n                            → Decision: 子標籤名稱是否為有效 TAG_NAME?\n                                Yes →\n                                    → push 名稱到 stack\n                                    → 移動指標到 '>' 之後 // 進入子標籤內容\n                                No  → Return false // 子標籤名稱無效\n                        No  →\n                            → 任何其他字符（文字或符號）\n                            → 移動指標 +1 // 允許任意字符\n→ 循環結束後\n    → Decision: stack 是否非空?\n        Yes → Return false // 有未關閉標籤\n        No  → Return true  // 所有規則皆符合，字串有效\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\n\nclass Solution:\n    def isValid(self, code: str) -> bool:\n        stack = []\n        i = 0\n        n = len(code)\n\n        while i < n:\n            # If code starts after outer tag but stack empty -> invalid\n            if i > 0 and not stack:\n                return False\n\n            # CDATA section\n            if code.startswith(\"<![CDATA[\", i):\n                j = i + 9\n                k = code.find(\"]]>\", j)\n                if k == -1:\n                    return False\n                i = k + 3\n                continue\n\n            # End tag\n            if code.startswith(\"</\", i):\n                j = i + 2\n                k = code.find(\">\", j)\n                if k == -1:\n                    return False\n                tag_name = code[j:k]\n                if not stack or stack[-1] != tag_name:\n                    return False\n                stack.pop()\n                i = k + 1\n                continue\n\n            # Start tag\n            if code[i] == \"<\":\n                j = i + 1\n                k = code.find(\">\", j)\n                if k == -1 or k == j or k - j > 9:\n                    return False\n                tag_name = code[j:k]\n                if not tag_name.isupper() or not tag_name.isalpha():\n                    return False\n                stack.append(tag_name)\n                i = k + 1\n                continue\n\n            # Regular character\n            i += 1\n\n        return not stack and n > 0 and code[0] == \"<\" and code[-1] == \">\"\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # Extract code string if input contains 'code ='\n    if '=' in raw_input:\n        _, part = raw_input.split('=', 1)\n        code_str = part.strip()\n    else:\n        code_str = raw_input.strip()\n    # Remove surrounding quotes if present\n    if (code_str.startswith('\"') and code_str.endswith('\"')) or \\\n       (code_str.startswith(\"'\") and code_str.endswith(\"'\")):\n        code_str = code_str[1:-1]\n\n    solution = Solution()\n    result = solution.isValid(code_str)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "code = \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "code = \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "code = \"<A>  <B> </A>   </B>\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode679.json",
    "problem_index_in_file": 0,
    "title": "24 Game",
    "description_snippet": "You are given an integer array cards of length 4. You have four cards, each containing a number in t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to check if 24 game possible. Use backtracking. Steps: generate permutations of numbers, generate operations combinations, evaluate expressions via recursion with parentheses. Use floating comparison tolerance. Steps: start, input array, create list of numbers, call DFS helper(numbers). DFS: if length 1: check if value ~24, return true else false. Else, for each pair i<j, for each op, compute result, create new list with result and remaining numbers, recurse. Use operations: +, -, *, /. For subtraction and division, order matters: a-b, a/b; also b-a, b/a. But we can handle by iterating over all pairs and applying both orders. Use epsilon 1e-6. Use helper to compute.\n\nLet's write virtual code lines accordingly.\n\nNeed to output each line as \"虛擬碼步驟 // 解釋\".\n\nStart block.\n\nImplement functions.\n\nLet's produce a clear algorithm.\n\nLet's write:\n\nStart\n→ Step 1: Define epsilon = 1e-6 // 允許的誤差範圍\n→ Step 2: Define Function canReach24(numbers) // 判斷是否能得到 24\n    → Decision: 如果 numbers 长度 == 1?\n        Yes → Step 3: Return |numbers[0] - 24| < epsilon // 单数直接比较\n        No  → Step 4: For 每对 i < j in numbers\n            → Step 5: 取值 a = numbers[i], b = numbers[j]\n            → Step 6: 生成剩余数 list rest = numbers excluding indices i,j\n            → Step 7: 对 每个运算符 op in ['+','-','*','/'] 循环\n                → Decision: 如果 op 是 '+'\n                    Yes → Step 8: result = a + b\n                    No\n                → Decision: 如果 op 是 '-'\n                    Yes → Step 9: result1 = a - b\n                    → Step 10: 递归: rest + result1\n                    → Decision: If 递归返回 true -> return true\n                    → Step 11: result2 = b - a\n                    → Step 12: 递归: rest + result2\n                → Decision: 如果 op 是 '*'\n                    Yes → Step 13: result = a * b\n                → Decision: 如果 op 是 '/'\n                    Yes → Step 14: 如果 b != 0 -> result1 = a / b\n                    → Step 15: 递归: rest + result1\n                    → Decision: If 递归返回 true -> return true\n                    → Step 16: 如果 a != 0 -> result2 = b / a\n                    → Step 17: 递归: rest + result2\n                → Step 18: 递归: rest + result\n                → Decision: 如果 递归返回 true -> return true\n            → Step 19: 循环结束\n        → Step 20: 返回 false // 所有组合均失败\n→ Step 21: 调用 canReach24(cards) // 主入口\n→ End\n\nBut need to use arrows and structure like Decision: etc. Provide each line.\n\nNeed to be careful formatting. Use indentation. Provide lines like:\n\nStart // 程式開始\n\n→ Step 1: Define epsilon = 1e-6 // 允許的誤差範圍\n\n→ Step 2: Function canReach24(numbers) // 判斷是否能得到 24\n\n    → Decision: 如果 numbers長度 == 1?\n        Yes → Step 3: Return |numbers[0] - 24| < epsilon // 單數直接比較\n        No  → Step 4: For 每對 i<j in numbers\n            ...\n\nBut we need each line with \"虛擬碼步驟\" and comment. We can break the nested lines into separate lines with indent arrows.\n\nMake sure to include arrows for decisions and loops. Use \"Yes →\" and \"No →\".\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: Define epsilon = 1e-6 // 允許的實數誤差範圍  \n\n→ Step 2: Function canReach24(numbers) // 判斷給定數字陣列能否組合成 24  \n  → Decision: 如果 numbers 長度 == 1? // 只剩一個數時直接檢查  \n   Yes → Step 3: Return |numbers[0] - 24| < epsilon // 單數與 24 的差距在誤差內即成功  \n   No  → Step 4: For 每對 (i, j) 在 numbers 中 (i < j) // 取兩個數字進行運算  \n    → Step 5: a = numbers[i]  \n    → Step 6: b = numbers[j]  \n    → Step 7: rest = numbers 之餘數 (排除索引 i 與 j) // 剩餘的數字  \n    → Decision: 對 每個運算符 op in ['+', '-', '*', '/'] 循環  \n      Yes → Decision: 如果 op 是 '+'  \n       Yes → Step 8: result = a + b  \n        → Step 9: If canReach24(rest + [result]) Then Return true // 递归檢查  \n       No  \n       Yes → Decision: 如果 op 是 '-'  \n        Yes → Step 10: result1 = a - b  \n        → If canReach24(rest + [result1]) Then Return true  \n        Yes → Step 11: result2 = b - a  \n        → If canReach24(rest + [result2]) Then Return true  \n       No  \n       Yes → Decision: 如果 op 是 '*'  \n        Yes → Step 12: result = a * b  \n        → If canReach24(rest + [result]) Then Return true  \n       No  \n       Yes → Decision: 如果 op 是 '/'  \n        Yes → Decision: 如果 b != 0  \n         Yes → Step 13: result1 = a / b  \n         → If canReach24(rest + [result1]) Then Return true  \n        No  \n        Yes → Decision: 如果 a != 0  \n         Yes → Step 14: result2 = b / a  \n         → If canReach24(rest + [result2]) Then Return true  \n       No  \n       No  \n       No // 所有運算都嘗試過  \n       No // 進入下一個 (i, j) 組合  \n      No // 所有 (i, j) 與 op 都已嘗試  \n    → Step 15: Return false // 無任何組合能達到 24  \n\n→ Step 16: Return canReach24(cards) // 主入口，傳入給定的四個卡片數字  \n\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\ndef judge_24(nums):\n    \"\"\"Return True if a sequence of operations can make 24 from the numbers.\"\"\"\n    eps = 1e-6\n\n    def dfs(numbers):\n        if len(numbers) == 1:\n            return abs(numbers[0] - 24) < eps\n        # Try every ordered pair of indices\n        for i in range(len(numbers)):\n            for j in range(len(numbers)):\n                if i == j:\n                    continue\n                a, b = numbers[i], numbers[j]\n                # Remaining numbers after removing indices i and j\n                remaining = [numbers[k] for k in range(len(numbers)) if k != i and k != j]\n\n                # Addition\n                if dfs(remaining + [a + b]):\n                    return True\n                # Subtraction a - b\n                if dfs(remaining + [a - b]):\n                    return True\n                # Multiplication\n                if dfs(remaining + [a * b]):\n                    return True\n                # Division a / b if b != 0\n                if b != 0 and dfs(remaining + [a / b]):\n                    return True\n        return False\n\n    # Try all permutations of the numbers\n    from itertools import permutations\n    for perm in permutations(nums):\n        if dfs(list(perm)):\n            return True\n    return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expect input like \"cards = [4,1,8,7]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    try:\n        cards = ast.literal_eval(expr.strip())\n    except Exception:\n        print(\"false\")\n        return\n    result = judge_24(cards)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "cards = [4,1,8,7]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "cards = [1,2,1,2]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode557.json",
    "problem_index_in_file": 0,
    "title": "Reverse Words in a String III",
    "description_snippet": "Given a string s, reverse the order of characters in each word within a sentence while still preserv...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to reverse characters of each word while preserving whitespace and order. Use structure Start, End, Decision, etc. Need to produce step-by-step virtual code, each line with explanation. Should be clear.\n\nWe need to consider string s. Steps: split by whitespace but keep separators? Better iterate over characters, building output: if letter, accumulate word; if space, flush reversed word and add space. Or use regex? For virtual code, we can use while loop over index i. Let's produce steps:\n\nStart\n→ Initialize index i = 0\n→ Initialize result = empty string\n→ Initialize wordBuffer = empty string\n→ Decision: i < length of s?\n   Yes → Step: currentChar = s[i]\n   Decision: currentChar is whitespace?\n      Yes → Step: result += reverse(wordBuffer); result += currentChar; wordBuffer = empty string\n      No  → Step: wordBuffer += currentChar\n   → Increment i; go back to Decision\n   No  → Step: result += reverse(wordBuffer); // flush remaining word\nEnd\n\nWe need to include reverse function. Virtual code maybe define a subroutine. Add step: Define function reverse(str) → returns reversed string. Or we can inline: step to reverse by iterating. For simplicity, we can assume built-in reverse.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ i = 0 // 初始化索引，指向字串 s 的第一個字符  \n→ result = \"\" // 用於累積最終輸出的字串  \n→ wordBuffer = \"\" // 用於暫存當前單詞的字符  \n→ Decision: i < length(s) ? // 檢查是否還有未處理的字符  \n    Yes → currentChar = s[i] // 取得當前字符  \n    Decision: currentChar 是空白字元? // 判斷是否為空白（空格、制表符等）  \n        Yes → result += reverse(wordBuffer) // 把已累積的單詞反轉後加入結果  \n        → result += currentChar // 把空白字元直接加入結果  \n        → wordBuffer = \"\" // 清空暫存器，準備下一個單詞  \n        No  → wordBuffer += currentChar // 若不是空白，將字符加入單詞暫存  \n    → i += 1 // 移動到下一個字符  \n    → 回到 Decision // 重複處理所有字符  \n    No  → result += reverse(wordBuffer) // 迴圈結束後，將最後一個單詞反轉加入結果  \nEnd // 程式執行結束\n\n// 辅助函数（在虛擬碼中可視作內部定義）  \n→ Function reverse(str) → // 將字串 str 的字符順序反轉  \n    → rev = \"\"  \n    → for idx from length(str)-1 downto 0  \n        rev += str[idx]  \n    → return rev   // 回傳反轉後的字串",
      "generated_code": "import sys\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        # 用空格分割，保留空字串以維持空格數量\n        words = s.split(' ')\n        # 反轉每個單詞\n        reversed_words = [word[::-1] for word in words]\n        # 重新以空格連接\n        return ' '.join(reversed_words)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 取得被雙引號包住的文字，如果沒有則直接使用整行\n    first_quote = data.find('\"')\n    if first_quote != -1:\n        last_quote = data.rfind('\"')\n        s = data[first_quote + 1:last_quote]\n    else:\n        s = data\n\n    sol = Solution()\n    result = sol.reverseWords(s)\n    # 以雙引號包住輸出\n    print(f\"\\\"{result}\\\"\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Let's take LeetCode contest\"",
          "expected_output": "\"s'teL ekat edoCteeL tsetnoc\"",
          "success": true,
          "output": "\"s'teL ekat edoCteeL tsetnoc\""
        },
        {
          "example_index": 1,
          "input": "s = \"Mr Ding\"",
          "expected_output": "\"rM gniD\"",
          "success": true,
          "output": "\"rM gniD\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode491.json",
    "problem_index_in_file": 0,
    "title": "Non-decreasing Subsequences",
    "description_snippet": "Given an integer array nums, return all the different possible non-decreasing subsequences of the gi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: generate all distinct non-decreasing subsequences of length >=2 from array nums. So it's typical backtracking/DFS with pruning to avoid duplicates. Provide steps line by line with virtual code and explanation. Use arrows, decisions. Start, End. Must not output actual code. Just structured steps. Let's think: algorithm:\n\nStart\n→ Initialize result list\n→ Define backtrack(startIndex, path)\n    → If path length >= 2, add copy to result\n    → Create set visited to avoid duplicates at this recursion depth\n    → For i from startIndex to n-1:\n        → If nums[i] >= last element of path (or path empty)\n        → If nums[i] already in visited: continue\n        → visited add nums[i]\n        → Append nums[i] to path\n        → backtrack(i+1, path)\n        → Remove last element from path\n→ Call backtrack(0, empty)\n→ Return result\n\nAlso we might need to mention sorting? No.\n\nAlso need to mention that result set to avoid duplicates: could use set of tuples.\n\nBut we can maintain visited set to skip duplicates for same recursion depth.\n\nLet's produce lines accordingly.\n\nEach line: \"虛擬碼步驟 // 解釋\".\n\nWe need to use arrow: →, Decision:, Yes →, No →.\n\nUse indentation for decision branches. Let's produce.\n\nRemember not to output actual code. Just steps.\n\nWe should show each step in the algorithm. Could be many lines. We'll list in order.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化結果集合 res 為空集合 // 用於儲存所有符合條件的子序列  \n→ 定義遞迴函式 backtrack(startIdx, path) // startIdx 表示下一個可選擇的索引，path 為目前已選擇的子序列  \n    → Decision: 若 path 長度 >= 2? // 檢查是否已滿足至少兩個元素  \n        Yes → 將 path 的拷貝加入 res // 把符合條件的子序列存入結果  \n        No  → // 仍須繼續遞迴搜尋  \n    → 建立空集合 visited // 用於同一層遞迴中避免重複使用相同的數字  \n    → For i 從 startIdx 到 nums.length-1: // 遍歷後續所有元素  \n        → Decision: 若 path 为空或 nums[i] >= path[-1]? // 檢查是否可維持非遞減  \n            Yes → Decision: nums[i] 是否已在 visited? // 防止同一層重複  \n                Yes → // 跳過此元素，避免重複子序列  \n                No  → visited 加入 nums[i] // 記錄此數字已被使用  \n                    → path 加入 nums[i] // 將數字加入目前子序列  \n                    → backtrack(i+1, path) // 進入下一層遞迴  \n                    → path 移除最後一個元素 // 回溯，恢復上一狀態  \n            No  → // nums[i] 不能維持非遞減，跳過此元素  \n→ 呼叫 backtrack(0, 空列表) // 從第一個元素開始遞迴  \n→ End // 程式執行結束，res 即為所有不同的非遞減子序列集合",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findSubsequences(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            if len(path) > 1:\n                res.append(path[:])\n            used = set()\n            for i in range(start, len(nums)):\n                if (not path or nums[i] >= path[-1]) and nums[i] not in used:\n                    used.add(nums[i])\n                    path.append(nums[i])\n                    backtrack(i + 1, path)\n                    path.pop()\n\n        backtrack(0, [])\n        return res\n\ndef parse_input(data: str):\n    data = data.strip()\n    if not data:\n        return []\n\n    # If input is like \"nums = [4,6,7,7]\"\n    if data.lower().startswith(\"nums\"):\n        try:\n            _, list_part = data.split(\"=\", 1)\n            list_part = list_part.strip()\n        except ValueError:\n            list_part = data\n    else:\n        list_part = data\n\n    # Try to parse as Python literal\n    try:\n        nums = ast.literal_eval(list_part)\n        if isinstance(nums, list):\n            return nums\n    except Exception:\n        pass\n\n    # Fallback: treat as space-separated numbers\n    try:\n        nums = list(map(int, list_part.split()))\n        return nums\n    except Exception:\n        pass\n\n    return []\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findSubsequences(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,6,7,7]",
          "expected_output": "[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]",
          "success": true,
          "output": "[[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]"
        },
        {
          "example_index": 1,
          "input": "nums = [4,4,3,2,1]",
          "expected_output": "[[4,4]]",
          "success": true,
          "output": "[[4, 4]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode535.json",
    "problem_index_in_file": 0,
    "title": "Encode and Decode TinyURL",
    "description_snippet": "Note: This is a companion problem to the System Design problem: Design TinyURL.\nTinyURL is a URL sho...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for class design. The user wants virtual code for designing TinyURL encode/decode. We output lines with virtual code and comment.\n\nWe need to show class, constructor, encode, decode methods, mapping.\n\nProbably use a dictionary to map short id to longUrl, and reverse mapping. Use base62.\n\nLet's produce pseudocode.\n\nUse Start at top? We can show steps inside class.\n\nWe'll produce virtual code:\n\nStart // program start? but not necessary maybe.\n\nWe produce: Start // 系統啟動\n\n→ Step 1: Define class Solution // 建立 Solution 類別\n\n→ Step 2: Inside Solution: Initialize counter = 0 // 用於生成唯一 ID\n\n→ Step 3: Initialize map idToUrl = {} // ID -> long URL\n\n→ Step 4: Initialize map urlToId = {} // long URL -> ID\n\n→ Step 5: Define encode(longUrl) // 方法\n\n→ Step 6:   If longUrl in urlToId: id = urlToId[longUrl] // 重複則取已存 ID\n\n→ Step 7:   Else: id = counter; counter += 1; urlToId[longUrl] = id; idToUrl[id] = longUrl\n\n→ Step 8: Convert id to base62 string code // 生成短碼\n\n→ Step 9: Return baseURL + code // 返回完整短連結\n\n→ Step 10: Define decode(shortUrl)\n\n→ Step 11:   Extract code from shortUrl // 去除前綴\n\n→ Step 12:   Convert code to id via base62 decode\n\n→ Step 13:   Return idToUrl[id]\n\nWe also need explanation after each line.\n\nLet's ensure to use arrow \"→\" and \"Decision:\" if any.\n\nThere is no branching except if-check.\n\nUse \"Decision: 如果 longUrl 已存在?\".\n\nOk.\n\nWe output in lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class Solution // 建立 TinyURL 系統的類別  \n→ Step 2: Inside Solution: Initialize counter = 0 // 用於產生唯一 ID  \n→ Step 3: Inside Solution: Initialize map idToUrl = {} // ID → 原長網址  \n→ Step 4: Inside Solution: Initialize map urlToId = {} // 原長網址 → ID  \n→ Step 5: Inside Solution: Define method encode(longUrl) // 編碼方法  \n→ Decision: 如果 longUrl 已存在於 urlToId? // 檢查是否已編碼  \n  Yes → Step 6: id = urlToId[longUrl] // 取已存在的 ID  \n  No → Step 7: id = counter; counter += 1; urlToId[longUrl] = id; idToUrl[id] = longUrl // 新增 ID 與映射  \n→ Step 8: Convert id to base62 string code // 把數字 ID 轉成 62 進制短碼  \n→ Step 9: Return baseURL + code // 回傳完整的短網址  \n→ Step 10: Inside Solution: Define method decode(shortUrl) // 解碼方法  \n→ Step 11: Extract code from shortUrl // 去掉前綴部分，獲取短碼  \n→ Step 12: Convert code from base62 to id // 將短碼轉回數字 ID  \n→ Step 13: Return idToUrl[id] // 回傳對應的原長網址  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def __init__(self):\n        # 用於生成唯一 ID 的計數器\n        self.counter = 0\n        # ID ↔ 長網址的映射\n        self.id_to_url = {}\n        self.url_to_id = {}\n        # 基礎網址前綴\n        self.base_url = \"http://tinyurl.com/\"\n        # Base62 字符表\n        self.chars = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        # 字符對應的數值字典，用於反向轉換\n        self.char_to_val = {c: i for i, c in enumerate(self.chars)}\n\n    def _to_base62(self, num: int) -> str:\n        \"\"\"將整數轉換為 Base62 字串\"\"\"\n        if num == 0:\n            return self.chars[0]\n        res = []\n        while num:\n            num, rem = divmod(num, 62)\n            res.append(self.chars[rem])\n        return ''.join(reversed(res))\n\n    def _from_base62(self, s: str) -> int:\n        \"\"\"將 Base62 字串轉回整數\"\"\"\n        num = 0\n        for ch in s:\n            num = num * 62 + self.char_to_val[ch]\n        return num\n\n    def encode(self, longUrl: str) -> str:\n        \"\"\"將長網址編碼成短網址\"\"\"\n        if longUrl in self.url_to_id:\n            id_ = self.url_to_id[longUrl]\n        else:\n            id_ = self.counter\n            self.counter += 1\n            self.url_to_id[longUrl] = id_\n            self.id_to_url[id_] = longUrl\n        code = self._to_base62(id_)\n        return self.base_url + code\n\n    def decode(self, shortUrl: str) -> str:\n        \"\"\"將短網址解碼回原始長網址\"\"\"\n        code = shortUrl.replace(self.base_url, '')\n        id_ = self._from_base62(code)\n        return self.id_to_url.get(id_, \"\")\n\nif __name__ == \"__main__\":\n    # 讀取輸入，去除可能的引號與首尾空白\n    raw_input = sys.stdin.read().strip()\n    long_url = raw_input.strip('\"')\n\n    codec = Solution()\n    short = codec.encode(long_url)\n    original = codec.decode(short)\n\n    print(original)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"https://leetcode.com/problems/design-tinyurl\"",
          "expected_output": "\"https://leetcode.com/problems/design-tinyurl\"",
          "success": true,
          "output": "https://leetcode.com/problems/design-tinyurl"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode745.json",
    "problem_index_in_file": 0,
    "title": "Prefix and Suffix Search",
    "description_snippet": "Design a special dictionary that searches the words in it by a prefix and a suffix.\n\nImplement the W...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the design. Provide a step-by-step algorithm. No actual code, just pseudocode lines with arrows and explanations. The algorithm: For each word, we might precompute prefix-suffix pairs? Typical solution uses Trie for prefixes and suffixes. But we can also use hash map mapping (prefix, suffix) -> max index. But there could be many combinations.\n\nSimpler: Build a trie of words reversed for suffix and forward for prefix, with indices. For each query, traverse both tries to find intersection. However we can store at each node the max index of words that pass through that node. Then we can combine by scanning prefix nodes and suffix nodes and find common index? Another approach: Use a hash map storing key = prefix + \"#\" + suffix -> max index. For all words, for all prefixes and suffixes. That is O(N*L^2). Not efficient.\n\nBut since it's virtual code, we don't need actual complexity analysis, just steps.\n\nWe'll describe: Build prefix trie: each node has children map and list of indices or max index. Similarly suffix trie (reversed words). For query, find all indices that match prefix by traversing prefix trie, collect indices (or node's index list). Find all indices that match suffix via suffix trie. Then intersect to find max index.\n\nAlternatively, we can store at each node a list of word indices sorted descending, then when querying, we traverse prefix node, suffix node, then two-pointer to find largest common.\n\nWe will produce steps:\n\n1. WordFilter constructor: Build prefix trie and suffix trie with nodes containing maxIndex and child map.\n2. For each word with index i:\n   - Insert into prefix trie: for each char c, create node if missing, set node.maxIndex = i (since processing in order, later index is larger, so set).\n   - Insert into suffix trie: reverse word, same insertion.\n3. Query f(pref, suff):\n   - Traverse prefix trie to node for pref; if not found, return -1.\n   - Traverse suffix trie for reversed suff; if not found, return -1.\n   - Use two-pointer technique on the lists of indices stored at these nodes? But we only stored maxIndex. Actually we need all indices to find intersection. Could store list of indices for each node sorted ascending or descending. Then use two-pointer to find max common.\n\nSimplify: store at each node a set of indices sorted ascending. Then intersection by merging.\n\nWe will produce pseudocode accordingly.\n\nAlso include Start, End.\n\nLet's produce virtual code:\n\nStart\n→ BuildTrie(prefixTrie)\n→ BuildTrie(suffixTrie)\n→ For each word, index in words:\n    → Insert into prefixTrie with index\n    → Insert into suffixTrie with reversed word and index\nEnd\n\nFunction f(pref, suff):\n    → nodePref = traverse prefixTrie with pref\n    → Decision: nodePref exists? If No → return -1\n    → nodeSuff = traverse suffixTrie with reversed suff\n    → Decision: nodeSuff exists? If No → return -1\n    → listPref = nodePref.indices // sorted ascending\n    → listSuff = nodeSuff.indices // sorted ascending\n    → i = 0; j = 0; maxIdx = -1\n    → Decision: i < len(listPref) and j < len(listSuff)? while loop\n        → Decision: listPref[i] == listSuff[j]? Yes → set maxIdx = listPref[i]; i++; j++\n        → Decision: listPref[i] < listSuff[j]? Yes → i++ else j++\n    → return maxIdx\n\nOk.\n\nWe'll produce each step with explanation.\n\nMake sure each line ends with // explanation.\n\nUse arrows appropriately.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ BuildTrie(prefixTrie) // 初始化前綴字典樹\n→ BuildTrie(suffixTrie) // 初始化後綴（逆序）字典樹\n\n→ ForEach word, index in words // 逐個處理單詞\n    → InsertWord(prefixTrie, word, index) // 將單詞插入前綴字典樹，並把索引記錄於節點\n    → InsertWord(suffixTrie, Reverse(word), index) // 將逆序單詞插入後綴字典樹，索引同樣記錄於節點\n\nEnd // 建構完成\n\n//----------------------------------------------\n// 函式：f(前綴, 後綴) 取得滿足條件的最大索引\n//----------------------------------------------\nStart // f 函式開始\n→ nodePref = Traverse(prefixTrie, pref) // 從前綴字典樹找到對應節點\n    Decision: nodePref 不是 null? // 檢查前綴是否存在\n        Yes → \n        No  → Return -1 // 前綴不存在，直接返回 -1\n\n→ nodeSuff = Traverse(suffixTrie, Reverse(suff)) // 從後綴字典樹找到對應節點\n    Decision: nodeSuff 不是 null? // 檢查後綴是否存在\n        Yes → \n        No  → Return -1 // 後綴不存在，直接返回 -1\n\n→ listPref = nodePref.indices // 取得前綴節點下所有索引（已升序排列）\n→ listSuff = nodeSuff.indices // 取得後綴節點下所有索引（已升序排列）\n\n→ i = 0 // 初始化前綴索引指標\n→ j = 0 // 初始化後綴索引指標\n→ maxIdx = -1 // 最高符合條件的索引\n\n→ Decision: i < len(listPref) AND j < len(listSuff)? // 若兩個索引列表均未遍歷完畢\n    Yes →\n        Decision: listPref[i] == listSuff[j]? // 兩索引相同\n            Yes → maxIdx = listPref[i]; i++; j++ // 記錄此索引，並同時向前移動兩指標\n            No  → Decision: listPref[i] < listSuff[j]? // 前綴索引較小\n                Yes → i++ // 前綴索引往後移動\n                No  → j++ // 後綴索引往後移動\n        Repeat Decision loop // 繼續尋找較大相同索引\n    No  → // 循環結束\n\n→ Return maxIdx // 回傳最大符合條件的索引，若不存在則為 -1\n\nEnd // f 函式結束\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    \"\"\"\n    建構 WordFilter 時，預先把所有可能的前綴 + 後綴組合\n    以字典存下來，key 為 (prefix, suffix)，value 為最大索引。\n    \"\"\"\n    def __init__(self, words):\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            # 逐字建立所有前綴、後綴組合\n            for i in range(L + 1):\n                pref = word[:i]\n                for j in range(L + 1):\n                    suff = word[j:]\n                    self.lookup[(pref, suff)] = weight  # 之後的索引更大，會覆寫\n\n    def f(self, prefix, suffix):\n        \"\"\"回傳符合前綴、後綴的最大索引，若不存在則回傳 -1\"\"\"\n        return self.lookup.get((prefix, suffix), -1)\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，格式為：\n        <words array>, <[prefix, suffix] array>\n    例如： '[\"apple\",\"banana\"], [\"a\", \"n\"]'\n    \"\"\"\n    data = data.strip()\n    # 找第一個完整的 words list 結束的位置\n    depth = 0\n    pos = -1\n    for i, ch in enumerate(data):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n            if depth == 0:\n                pos = i\n                break\n    if pos == -1:\n        raise ValueError(\"Invalid input format\")\n\n    words_str = data[:pos+1]\n    rest = data[pos+2:].strip()  # 跳過 ','\n    pref_suff_str = rest\n\n    words = ast.literal_eval(words_str)\n    pref_suff = ast.literal_eval(pref_suff_str)\n    return words, pref_suff[0], pref_suff[1]\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    words, pref, suff = parse_input(raw_input)\n\n    # 建構字典並查詢\n    wf = WordFilter(words)\n    result = wf.f(pref, suff)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpbldv2s4r.py\", line 59, in <module>\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbldv2s4r.py\", line 18, in __init__\n    self.lookup[(pref, suff)] = weight  # 之後的索引更大，會覆寫\n    ~~~~~~~~~~~^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode409.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindrome",
    "description_snippet": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the algorithm: Count frequencies, compute total length of palindrome: sum of even counts + (sum of odd counts -1?) Actually longest palindrome length = sum of all counts that are even + for each odd count add (count-1) then if any odd exists add 1. So algorithm: frequency map, sumEvenOdd, oddFlag.\n\nWe output Start, step: Input s, create map, iterate, compute, output length. Use virtual code with arrows. Must provide line per step. Also include decisions. We should show decision if oddFlag true. Provide explanation. Ensure each line ends with // explanation. Use Start, End. Use Decision for oddFlag.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 從使用者或函式參數取得字串  \n→ Step 2: 建立空字元計數表 charCount // 用於記錄每個字元出現的次數  \n→ Step 3: For each char c in s: // 遍歷字串中的每個字元  \n    If c in charCount: charCount[c] = charCount[c] + 1  \n    Else: charCount[c] = 1 // 更新字元計數  \n→ Step 4: Set length = 0, oddExists = False // 初始化最長回文長度及奇數計數標誌  \n→ Step 5: For each count v in charCount values: // 遍歷所有字元的出現次數  \n    If v mod 2 == 0: length = length + v // 完全偶數次數可直接加入  \n    Else: length = length + (v - 1); oddExists = True // 奇數次數減一後加入，記錄存在奇數  \n→ Decision: oddExists? // 判斷是否有奇數次數的字元  \n    Yes → Step 6: length = length + 1 // 若有奇數次數，可在回文中心放一個字元  \n    No →  // 沒有奇數次數，不需額外處理  \n→ Step 7: 輸出 length // 回傳或印出最長回文可能長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> int:\n        \"\"\"Return the length of the longest palindrome that can be built from s.\"\"\"\n        count = Counter(s)\n        length = 0\n        odd_found = False\n        for val in count.values():\n            if val % 2 == 0:\n                length += val\n            else:\n                length += val - 1\n                odd_found = True\n        if odd_found:\n            length += 1\n        return length\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 處理可能的 \"s = \" 前綴\n    if '=' in data:\n        _, s = data.split('=', 1)\n        s = s.strip()\n    else:\n        s = data\n\n    # 移除可能的雙引號\n    if s.startswith('\"') and s.endswith('\"'):\n        s = s[1:-1]\n    elif s.startswith(\"'\") and s.endswith(\"'\"):\n        s = s[1:-1]\n\n    solution = Solution()\n    result = solution.longestPalindrome(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abccccdd\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode502.json",
    "problem_index_in_file": 0,
    "title": "IPO",
    "description_snippet": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Cap...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode steps for solving the LeetCode problem \"Maximum Capital\" (like IPO). We need to use Start, End, Decision, arrows. Provide brief explanation each line. Use virtual code steps. Use arrows for branching. We need to produce step-by-step algorithm: we can sort projects by capital, use min-heap or max-heap. Use approach: sort by capital ascending, maintain max-heap for profits of projects we can afford. Iterate up to k times: while current capital >= projects[i].capital, push profits to max-heap, increment i. Then pop max profit from heap, add to capital. End loop. Output capital.\n\nWe need to produce each line with explanation.\n\nLet's produce:\n\nStart\n→ Step 1: 建立 pairs = (capital[i], profits[i]) for all projects // 准备项目列表\n→ Step 2: 按 capital 升序排序 pairs // 方便按资本可行性筛选\n→ Step 3: 初始化 maxProfitHeap // 记录当前可行项目的利润\n→ Step 4: i ← 0 // 项目索引\n→ Step 5: cap ← w // 当前可用资本\n→ Step 6: cnt ← 0 // 已完成项目计数\n→ Decision: cnt < k? // 是否还可以挑选项目\n    Yes →\n        → Decision: i < n AND pairs[i].capital ≤ cap? // 是否还有可负担的项目\n            Yes →\n                → Step 7: Push pairs[i].profit 到 maxProfitHeap // 加入可选项目\n                → Step 8: i ← i + 1 // 移到下一个项目\n                → Go back to Decision: i < n AND pairs[i].capital ≤ cap? // 继续加入\n            No →\n                → Decision: maxProfitHeap 非空? // 是否有可执行项目\n                    Yes →\n                        → Step 9: pop max profit from maxProfitHeap // 选最优项目\n                        → Step 10: cap ← cap + popped profit // 更新资本\n                        → Step 11: cnt ← cnt + 1 // 记录完成\n                        → Go back to Decision: cnt < k? // 再次尝试\n                    No →\n                        → End // 无可行项目且已无法继续\n    No →\n        → End // 已选 k 项或无更多项目\n→ End // 输出 cap\n\nBut we need each line with virtual code step and explanation. Use arrow \"→\" at start of each step except Start/End. Need to include \"Decision:\" lines with Yes→, No→ etc. Let's format properly. Use consistent indent maybe.\n\nLet's produce as final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 pairs = (capital[i], profits[i]) for i in [0, n-1] // 建立包含資本與利潤的對應列表  \n→ Step 2: 按 pairs.capital 升序排序 pairs // 方便按可負擔資本篩選  \n→ Step 3: 初始化 maxProfitHeap // 儲存目前可執行項目的最大利潤  \n→ Step 4: i ← 0 // 設定已掃描項目指標  \n→ Step 5: cap ← w // 設定目前可用資本  \n→ Step 6: cnt ← 0 // 已完成項目計數  \n\n→ Decision: cnt < k? // 仍有剩餘可選項目  \n    Yes →  \n        → Decision: i < n AND pairs[i].capital ≤ cap? // 仍有項目且可負擔  \n            Yes →  \n                → Step 7: Push pairs[i].profit 到 maxProfitHeap // 加入可選項目  \n                → Step 8: i ← i + 1 // 移至下一項目  \n                → Go back to Decision: i < n AND pairs[i].capital ≤ cap? // 繼續加入所有可負擔項目  \n            No →  \n                → Decision: maxProfitHeap 非空? // 是否有可執行項目  \n                    Yes →  \n                        → Step 9: pop maxProfit from maxProfitHeap // 取最大利潤項目  \n                        → Step 10: cap ← cap + maxProfit // 更新資本  \n                        → Step 11: cnt ← cnt + 1 // 記錄完成項目  \n                        → Go back to Decision: cnt < k? // 再次嘗試挑選項目  \n                    No →  \n                        → End // 無可行項目且已無法繼續  \n    No →  \n        → End // 已挑選 k 個項目或無剩餘可選  \n\nEnd // 輸出最終資本 cap",
      "generated_code": "import sys\nimport re\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: list[int], capital: list[int]) -> int:\n        # 將項目依照所需資本升序排序\n        projects = sorted(zip(capital, profits))\n        max_heap = []          # 儲存可執行項目的利潤（使用負值做最大堆）\n        i = 0                  # 已加入堆的項目索引\n        n = len(projects)\n\n        for _ in range(k):\n            # 把所有目前可負擔的項目放入最大堆\n            while i < n and projects[i][0] <= w:\n                heapq.heappush(max_heap, -projects[i][1])\n                i += 1\n            # 若無可執行項目則結束\n            if not max_heap:\n                break\n            # 取利潤最高的項目，完成後資本增加\n            w += -heapq.heappop(max_heap)\n        return w\n\ndef parse_input(text: str):\n    \"\"\"從輸入文字中擷取 k、w、profits、capital。\"\"\"\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', text)\n    w_match = re.search(r'w\\s*=\\s*(-?\\d+)', text)\n    profits_match = re.search(r'profits\\s*=\\s*\\[([^\\]]*)\\]', text)\n    capital_match = re.search(r'capital\\s*=\\s*\\[([^\\]]*)\\]', text)\n\n    k = int(k_match.group(1)) if k_match else 0\n    w = int(w_match.group(1)) if w_match else 0\n\n    def parse_list(lst: str):\n        if not lst:\n            return []\n        return [int(x.strip()) for x in lst.split(',') if x.strip()]\n\n    profits = parse_list(profits_match.group(1)) if profits_match else []\n    capital = parse_list(capital_match.group(1)) if capital_match else []\n\n    return k, w, profits, capital\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    k, w, profits, capital = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.findMaximizedCapital(k, w, profits, capital)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode242.json",
    "problem_index_in_file": 0,
    "title": "Valid Anagram",
    "description_snippet": "Given two strings s and t, return true if t is an anagram of s, and false otherwise....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. It's a simple algorithm: check if t is an anagram of s. Steps: start, check length, maybe create frequency map or sort, compare. Use decision nodes. Provide explanation after each line. Format exactly: each line \"虛擬碼步驟 // 解釋/說明\". Use arrow →, Yes → No → etc.\n\nWe must output only virtual code, no actual code. Use Start, End, Decision, Step, etc. Provide step numbering optional but not necessary; just sequential lines. Must be in Traditional Chinese.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 取得兩個字串 s, t // 從輸入中取得 s 與 t\n→ Decision: s 與 t 長度是否相同? // 若長度不同則不可能為字母異位詞\n    Yes → Step 2: 初始化 26 個計數器 count[26] = 0 // 建立英文字母頻率表\n    No  → Step 3: 回傳 false // 長度不同直接回傳 false\n→ Step 4: 對 s 的每個字元，對應 count[字元索引] 加 1 // 統計 s 的字母頻率\n→ Step 5: 對 t 的每個字元，對應 count[字元索引] 減 1 // 統計 t 的字母頻率\n→ Decision: 所有 count 值是否全為 0? // 若全為 0，則兩字串頻率一致\n    Yes → Step 6: 回傳 true // t 是 s 的字母異位詞\n    No  → Step 7: 回傳 false // t 不是字母異位詞\nEnd // 程式執行結束\n\nBut we must ensure each line has arrow and explanation.\n\nWe can also use simpler approach: sort strings and compare. But frequency map is more efficient.\n\nMake sure each line ends with // explanation. Use \"→\" arrow before each step. For decisions, show \"Decision:\" lines and \"Yes →\" \"No →\".\n\nWe need to produce all lines; each line includes code and comment. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s, t // 取得待檢測字串\n→ Decision: s 與 t 長度是否相同? // 字母異位詞必須長度相等\n    Yes → Step 2: 建立長度 26 的整數陣列 count = 0 // 初始化頻率表\n    No  → Step 3: 回傳 false // 長度不等即非字母異位詞\n→ Step 4: 對 s 的每個字元 c, 增加 count[c - 'a'] // 統計 s 的字母出現次數\n→ Step 5: 對 t 的每個字元 c, 減少 count[c - 'a'] // 統計 t 的字母出現次數\n→ Decision: count 中是否全部為 0? // 檢查兩個字串頻率是否一致\n    Yes → Step 6: 回傳 true // t 為 s 的字母異位詞\n    No  → Step 7: 回傳 false // t 不是字母異位詞\nEnd // 程式結束\n\nWe need to maintain correct format: each line begins with arrow? Start line no arrow. The next lines start with \"→\". For decision lines, we use \"Decision:\" and indent. The \"Yes →\" \"No →\" lines are separate lines.\n\nAlso include End line. Ensure no actual code (like \"count\" variable usage is okay; it's virtual code). It's fine. Provide step numbers? Not necessary but okay.\n\nWe should keep each line as separate line. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s, t // 取得待檢測字串  \n→ Decision: s 與 t 長度是否相同? // 字母異位詞必須長度相等  \n    Yes → Step 2: 建立長度 26 的整數陣列 count = 0 // 初始化頻率表  \n    No  → Step 3: 回傳 false // 長度不等即非字母異位詞  \n→ Step 4: 對 s 的每個字元 c, 增加 count[c - 'a'] // 統計 s 的字母出現次數  \n→ Step 5: 對 t 的每個字元 c, 減少 count[c - 'a'] // 統計 t 的字母出現次數  \n→ Decision: count 中是否全部為 0? // 檢查兩個字串頻率是否一致  \n    Yes → Step 6: 回傳 true // t 為 s 的字母異位詞  \n    No  → Step 7: 回傳 false // t 不是字母異位詞  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n        return Counter(s) == Counter(t)\n\ndef parse_input(text: str) -> tuple[str, str]:\n    \"\"\"從輸入文字中提取兩個字串 s 與 t。\"\"\"\n    # 找出所有雙引號或單引號包裹的字串\n    matches = re.findall(r'[\"\\']([^\"\\']*)[\"\\']', text)\n    if len(matches) >= 2:\n        return matches[0], matches[1]\n    # 若找不到符合的格式，回傳空字串\n    return \"\", \"\"\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    s, t = parse_input(data)\n    sol = Solution()\n    result = sol.isAnagram(s, t)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"anagram\", t = \"nagaram\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"rat\", t = \"car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode301.json",
    "problem_index_in_file": 0,
    "title": "Remove Invalid Parentheses",
    "description_snippet": "Given a string s that contains parentheses and letters, remove the minimum number of invalid parenth...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for the problem: remove invalid parentheses from a string to get all unique valid strings with minimal removals. The typical solution uses BFS or DFS with pruning. We'll produce a step-by-step virtual code. Should be in Chinese. Each line with arrow and explanation.\n\nLet's design:\n\nStart\n→ Step 1: 初始化queue, visited set, result list // BFS queue\n→ Step 2: enqueue original string // start\n→ Decision: 是否已處理完? // BFS loop\n  Yes? // but we need while queue not empty\n  We'll have a while loop, but we can show with Decision: queue 非空?\n    Yes → Step 3: 取出queue頭 // current string\n    → Decision: 是否valid? // check validity\n       Yes → Step 4: 添加到結果 // add to result set\n              → Decision: result 已滿? // if we found valid string at current level, we don't need further deeper removal at same level? Typically BFS stops after first found valid level\n                 Yes → Step 5: End // exit\n                 No → Continue // keep processing same level\n       No  → Decision: 是否已達到最低層? // if we haven't found any valid yet, generate children\n          Yes? // maybe we only generate next level\n          No → Step 6: 產生所有子串，去掉一個括號\n              → For i in 0..len-1\n                 → Decision: str[i] is '(' or ')'?\n                    Yes → 子串 = current substring remove char i\n                          → Decision: 子串未訪問? \n                             Yes → Add to queue, visited\n            → End for\n    → End Decision\n→ End while\n→ Step 7: Return result\n\nBut we need to keep minimal removal: BFS ensures minimal. We stop generating children once we found any valid string, and after finishing that level we don't generate deeper levels.\n\nLet's produce lines:\n\nStart // 程式開始\n\n→ Step 1: Initialize queue Q with s, visited set V = {s}, result list res = [], found = False // 初始化資料結構\n\n→ Decision: Q 非空? // BFS 主迴圈\n    Yes → Step 2: cur ← dequeue Q // 取出目前字串\n    → Decision: cur 是否有效? // 檢查括號是否匹配\n        Yes → Step 3: res ← res ∪ {cur} // 加入結果\n            → Decision: found 已為 True? // 已經找到合法字串\n                Yes → End // 直接結束，已找到最小移除\n                No → Step 4: found ← True // 記錄已找到\n        No  → Decision: found 為 False? // 尚未找到合法字串\n            Yes → Step 5: For each index i in cur\n                → Decision: cur[i] 為 '(' 或 ')'?\n                    Yes → newStr ← cur 去掉索引 i 的字元\n                        → Decision: newStr 未在 V 中?\n                            Yes → V ← V ∪ {newStr}; Q ← Q ∪ {newStr} // 新子串加入\n            No → // 如果已找到合法字串，跳過產生下一層\n    → End Decision\n→ End Decision\n\nEnd // 程式結束\n\nBut need to incorporate \"return result list\" maybe at end.\n\nLet's produce step lines exactly following format: each line like \"→ Step X: ...\" with comment. Use arrow '→'. Use 'Decision:' for if.\n\nMake sure to include indentation? Example given uses indentation inside Decision. We can do like:\n\nDecision: Q 非空? \n    Yes → Step ... \n    No  → End\n\nLet's produce final.\n\nAlso we need to mention unique strings; we use set res.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化隊列 Q ← [s]，已訪問集合 V ← {s}，結果列表 res ← []，找到合法字串標誌 found ← False // 為 BFS 做初始化  \n→ Decision: Q 非空?  \n    Yes → Step 2: cur ← Q.dequeue() // 取出隊首字串進行處理  \n    → Decision: cur 是否為合法字串? // 檢查括號是否配對  \n        Yes → Step 3: res ← res ∪ {cur} // 將合法字串加入結果集合  \n            → Decision: found 為 True?  \n                Yes → End // 已找到最小移除級別的合法字串，直接結束  \n                No  → Step 4: found ← True // 記錄已找到合法字串，以避免生成更深層的子串  \n        No  → Decision: found 為 False? // 尚未找到任何合法字串，仍需進一步移除  \n            Yes → Step 5: For i 在 0 到 cur.length - 1  \n                → Decision: cur[i] 為 '(' 或 ')'？  \n                    Yes → newStr ← cur 去除索引 i 的字元  \n                        → Decision: newStr 未在 V 中？  \n                            Yes → V ← V ∪ {newStr}；Q.enqueue(newStr) // 新子串加入隊列與訪問集合  \n            No  → // 若已找到合法字串，則不再產生下一層子串  \n    → End Decision  \n→ End Decision  \n→ Step 6: Return res // 回傳所有唯一的合法字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        # 判斷一個字串是否為合法括號組合\n        def isValid(string: str) -> bool:\n            balance = 0\n            for ch in string:\n                if ch == '(':\n                    balance += 1\n                elif ch == ')':\n                    balance -= 1\n                    if balance < 0:  # 右括號多於左括號\n                        return False\n            return balance == 0\n\n        level = {s}          # 目前層級的所有字串\n        while level:\n            # 過濾出所有合法字串\n            valid = [st for st in level if isValid(st)]\n            if valid:       # 找到最小移除級別的合法字串\n                return valid\n            next_level = set()\n            for item in level:\n                for i, ch in enumerate(item):\n                    if ch in ('(', ')'):               # 只刪除括號\n                        new_item = item[:i] + item[i+1:]\n                        if new_item not in next_level:\n                            next_level.add(new_item)\n            level = next_level\n        return []\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並解析出真正的字串\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(\"[]\")\n        sys.exit()\n\n    # 可能存在前綴如 \"s = \"，也可能直接給字串\n    if '=' in raw_input:\n        _, raw_input = raw_input.split('=', 1)\n        raw_input = raw_input.strip()\n\n    # 去除可能存在的雙引號或單引號\n    if (raw_input.startswith('\"') and raw_input.endswith('\"')) or \\\n       (raw_input.startswith(\"'\") and raw_input.endswith(\"'\")):\n        raw_input = raw_input[1:-1]\n\n    s = raw_input\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n    # 輸出 JSON 風格的列表，符合題目示例格式\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "success": true,
          "output": "[\"(())()\", \"()()()\"]"
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "success": true,
          "output": "[\"(a())()\", \"(a)()()\"]"
        },
        {
          "example_index": 2,
          "input": "s = \")(\"",
          "expected_output": "[\"\"]",
          "success": true,
          "output": "[\"\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode482.json",
    "problem_index_in_file": 0,
    "title": "License Key Formatting",
    "description_snippet": "You are given a license key represented as a string s that consists of only alphanumeric characters ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for reformatting license key. Provide steps: Start, Remove dashes, uppercase, split into groups of size k from end, etc. Use decision nodes? We can show algorithm:\n\n- Remove dashes, uppercase letters.\n- Reverse string to process from end, group k characters.\n- Build new string with dashes inserted between groups.\n- If reversed grouping, reverse result to correct order.\n- Edge cases: first group can be shorter.\n- Output result.\n\nWe can produce line by line with explanation. Use Decision for if string empty etc. Keep structure.\n\nOk produce steps.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Remove all '-' characters from s and convert to uppercase // 清除舊的分隔符並統一大寫\n→ Step 2: Let clean be the resulting string // 取得乾淨的字串\n→ Decision: 如果 clean 為空? // 檢查是否還有可處理的字元\n    Yes → Step 3: Return \"\" // 空輸入直接回傳空字串\n    No  → Continue\n→ Step 4: Reverse clean // 反轉字串，方便從尾部開始分組\n→ Step 5: 初始化 groups 為空列表 // 用來存放每一組\n→ Step 6: For i from 0 to length(clean)-1，步長 k:\n    → Step 7: groups.append( substring of clean from i to i+k ) // 取 k 個字元為一組\n→ Step 8: Reverse each group string in groups // 把每組字串恢復原順序\n→ Step 9: Reverse the order of groups // 由尾部組成到首部組成，得到正確順序\n→ Step 10: Join groups with '-' separator // 用 '-' 連接各組\n→ Step 11: Return the joined string // 回傳重新格式化的 license key\nEnd // 程式執行結束",
      "generated_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport sys\nimport re\n\nclass Solution:\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\n        \"\"\"\n        將 license key 重新格式化為每組 K 個字元，首組可以較短。\n        所有小寫字元轉為大寫，並且用 '-' 連接各組。\n        \"\"\"\n        # 1. 移除舊有的分隔符並轉成大寫\n        S = S.replace('-', '').upper()\n        n = len(S)\n        if n == 0:\n            return \"\"\n\n        # 2. 計算首組長度\n        first_len = n % K or K\n\n        # 3. 建立結果清單\n        parts = [S[:first_len]]\n        for i in range(first_len, n, K):\n            parts.append(S[i:i+K])\n\n        # 4. 以 '-' 連接並回傳\n        return '-'.join(parts)\n\ndef parse_input(data: str):\n    \"\"\"\n    從 stdin 取得輸入，支援以下兩種常見格式：\n    1. s = \"...\" , k = ...\n    2. 直接給兩個值，例如 5F3Z-2e-9-w 4\n    \"\"\"\n    # 先嘗試尋找「s = \"...\"」的格式\n    m_s = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    if m_s:\n        s = m_s.group(1)\n    else:\n        # 若找不到，嘗試直接分割字串\n        parts = data.strip().split()\n        s = parts[0] if parts else \"\"\n\n    # 尋找 k 的值\n    m_k = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if m_k:\n        k = int(m_k.group(1))\n    else:\n        # 若沒有 k 的標示，則取第二個值\n        parts = data.strip().split()\n        k = int(parts[1]) if len(parts) > 1 else 0\n\n    return s, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, k = parse_input(raw_input)\n    result = Solution().licenseKeyFormatting(s, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"5F3Z-2e-9-w\", k = 4",
          "expected_output": " \"5F3Z-2E9W\"",
          "success": true,
          "output": "5F3Z-2E9W"
        },
        {
          "example_index": 1,
          "input": "s = \"2-5g-3-J\", k = 2",
          "expected_output": "\"2-5G-3J\"",
          "success": true,
          "output": "2-5G-3J"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode373.json",
    "problem_index_in_file": 0,
    "title": "Find K Pairs with Smallest Sums",
    "description_snippet": "You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\n\nD...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The problem: find k smallest sum pairs from two sorted arrays. Standard solution uses min-heap. Steps: start, push first pair, then iterate until k pairs found. Use a heap of tuples (sum, i, j). Also track visited set. So produce pseudo lines.\n\nWe need to produce line-by-line with arrow, decisions, etc.\n\nLet's craft.\n\nStart // begin\n\n→ Step 1: 初始化最小堆 heap 與 visited 集合 // set up data structures\n\n→ Decision: 如果 k 為 0 或 nums1 为空 或 nums2 为空? // check for edge cases\n\n    Yes → Step 2: 返回空列表 // no pairs possible\n\n    No  → Step 3: 将 nums1[0] + nums2[0] 与索引 (0,0) 推入 heap // push initial pair\n\n→ Step 4: 初始化结果列表 res = [] // to store k pairs\n\n→ Decision: 当 res 长度小于 k 且 heap 非空? // main loop\n\n    Yes →\n\n        → Step 5: 弹出堆顶元素 (sum, i, j) // get smallest sum\n\n        → Step 6: 将 (nums1[i], nums2[j]) 添加到 res // record pair\n\n        → Decision: 是否能产生下一个 j? // j+1\n\n            Yes → Step 7: 计算 new_sum = nums1[i] + nums2[j+1] // new pair\n\n                → Decision: (i, j+1) 未访问? // visited set\n\n                    Yes → Step 8: 推入堆并标记 visited // push\n\n                    No  → No operation\n\n        → Decision: 是否能产生下一个 i? // i+1\n\n            Yes → Step 9: 计算 new_sum = nums1[i+1] + nums2[j] // new pair\n\n                → Decision: (i+1, j) 未访问? // visited\n\n                    Yes → Step 10: 推入堆并标记 visited\n\n                    No → No operation\n\n        → Decision: 重复循环? // loop again\n\n            Yes → 回到 Decision: 当 res 长度小于 k 且 heap 非空\n\n            No → Go to Step 11\n\n    No  → Step 11: 跳出循环 // exit loop\n\n→ Step 12: 返回 res // output k pairs\n\n→ End // program ends\n\nNeed to include arrow and comments. Ensure each line starts with \"→\" except start and end. Indent decision sub-lines. Use \"Yes →\" \"No →\" etc.\n\nLet's produce.\n\nAlso note we might include that visited is set of tuple (i,j). Use hash.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化最小堆 heap 與 visited 集合 // 建立最小堆與已訪問索引集合  \n→ Decision: 如果 k 為 0 或 nums1 為空 或 nums2 為空? // 檢查邊界情況  \n Yes → Step 2: 返回空列表 // 無法產生任何配對  \n No → Step 3: 將 nums1[0] + nums2[0] 與索引 (0,0) 推入 heap // 推入第一個可能的最小配對  \n→ Step 4: 初始化結果列表 res = [] // 用於儲存 k 個最小配對  \n→ Decision: 當 res 長度小於 k 且 heap 非空? // 主要循環條件  \n Yes →  \n  → Step 5: 弹出堆頂元素 (sum, i, j) // 取出當前最小總和  \n  → Step 6: 將 (nums1[i], nums2[j]) 加入 res // 記錄配對  \n  → Decision: 是否能產生下個 j? // 仍在同一行的下一列  \n   Yes →  \n    → Step 7: 計算 new_sum = nums1[i] + nums2[j+1] // 新配對的總和  \n    → Decision: (i, j+1) 未訪問? // 防止重複插入  \n     Yes →  \n      → Step 8: 推入堆並將 (i, j+1) 加入 visited // 新配對加入堆  \n      No →  // 已訪問，跳過  \n    No →  // j 已到尾，無新配對  \n  → Decision: 是否能產生下個 i? // 仍在同一列的下一行  \n   Yes →  \n    → Step 9: 計算 new_sum = nums1[i+1] + nums2[j] // 新配對的總和  \n    → Decision: (i+1, j) 未訪問? // 防止重複插入  \n     Yes →  \n      → Step 10: 推入堆並將 (i+1, j) 加入 visited // 新配對加入堆  \n      No →  // 已訪問，跳過  \n   No →  // i 已到尾，無新配對  \n  → Decision: 重複循環? // 回到主條件  \n   Yes → 回到 Decision: 當 res 長度小於 k 且 heap 非空  \n   No →  // 已滿足 k 個配對或堆已空  \n    → Step 11: 跳出循環 // 結束主循環  \n No →  // 堆已空但仍未達 k，結束循環  \n→ Step 12: 返回 res // 輸出 k 個最小配對  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nimport re\nimport ast\n\nclass Solution:\n    def kSmallestPairs(self, nums1, nums2, k):\n        if not nums1 or not nums2 or k <= 0:\n            return []\n        heap = []\n        res = []\n        # 初始化堆：把 nums1 的前 k 個元素與 nums2 的第一個元素組合\n        for i in range(min(k, len(nums1))):\n            heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n        # 依次取最小總和，並把下一個可能的配對推入堆\n        while heap and len(res) < k:\n            sum_val, i, j = heapq.heappop(heap)\n            res.append([nums1[i], nums2[j]])\n            if j + 1 < len(nums2):\n                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        return res\n\ndef parse_input(text):\n    \"\"\"\n    解析類似 'nums1 = [1,7,11], nums2 = [2,4,6], k = 3' 的輸入字串。\n    \"\"\"\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[[^\\]]*\\])', text)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[[^\\]]*\\])', text)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', text)\n    if not (nums1_match and nums2_match and k_match):\n        raise ValueError(\"輸入格式錯誤\")\n    nums1 = ast.literal_eval(nums1_match.group(1))\n    nums2 = ast.literal_eval(nums2_match.group(1))\n    k = int(k_match.group(1))\n    return nums1, nums2, k\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    nums1, nums2, k = parse_input(raw_input)\n    solution = Solution()\n    result = solution.kSmallestPairs(nums1, nums2, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "success": true,
          "output": "[[1, 2], [1, 4], [1, 6]]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "success": true,
          "output": "[[1, 1], [1, 1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode732.json",
    "problem_index_in_file": 0,
    "title": "My Calendar III",
    "description_snippet": "A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, for implementing MyCalendarThree with book method that returns max concurrent events (like max number of overlapping intervals). Use segment tree with lazy propagation or difference array with sweep line. For virtual code we can pick approach: maintain list of events, after each add, compute max overlap by sweep line. But efficient approach: difference map or segment tree. We should provide pseudo steps: initialize events list or segment tree; book function: add interval; update segment tree; get max; return. Use simple difference array: maintain map time->delta, update start +1, end -1, then sweep sorted keys, maintain current count, track max. That yields O(n log n). Good.\n\nLet's produce virtual code lines accordingly.\n\nStructure:\n\nStart // Program starts\n→ MyCalendarThree() // Constructor // initialize data structure\n    → TreeMap<Integer, Integer> timeline = new TreeMap<>(); // store time points and delta counts\n\n→ book(start, end) // Method to add event and return max overlap\n    → Timeline.put(start, Timeline.getOrDefault(start,0)+1); // add +1 at start\n    → Timeline.put(end, Timeline.getOrDefault(end,0)-1); // add -1 at end\n    → current = 0; max = 0; // initialize counters\n    → For each entry in timeline sorted by key // iterate time points in order\n        → current += entry.value; // update ongoing events\n        → if current > max then max = current; // track maximum overlap\n    → return max; // return max overlap after this event\n\nEnd // end\n\nBut we need virtual code line by line with arrows. Also decision steps? Not necessary. Just flow. Use indentation for loops. Provide explanation.\n\nLet's write each line as: Virtual code step [space] // explanation.\n\nUse arrows to show flow: Start → MyCalendarThree() → book(...) etc.\n\nAlso for loop: For each time point in timeline sorted by key → current += delta → update max.\n\nOk.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ MyCalendarThree() // 建構子：初始化資料結構  \n    → TreeMap<Integer, Integer> timeline = new TreeMap<>(); // 使用 TreeMap 儲存時間點與對應的變化量（+1 / -1）  \n→ book(int start, int end) // 新增事件並回傳目前最大的重疊數量  \n    → timeline.put(start, timeline.getOrDefault(start, 0) + 1); // 在開始時間加 +1  \n    → timeline.put(end, timeline.getOrDefault(end, 0) - 1); // 在結束時間加 -1（因為區間是半開）  \n    → int current = 0; // 當前同時進行的事件數  \n    → int max = 0; // 迄今為止最大的同時進行數  \n    → For each entry in timeline in ascending key order // 依時間點遞增順序遍歷  \n        → current += entry.getValue(); // 更新正在進行的事件數  \n        → if current > max then max = current; // 若更大則更新最大值  \n    → return max; // 回傳此時的最大重疊數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport bisect\n\nclass MyCalendarThree:\n    def __init__(self):\n        # timeline stores (time, delta) pairs sorted by time\n        self.timeline = []\n\n    def book(self, start: int, end: int) -> int:\n        # insert start and end events into the timeline\n        bisect.insort(self.timeline, (start, 1))\n        bisect.insort(self.timeline, (end, -1))\n        active = 0\n        max_active = 0\n        # sweep through timeline to find max overlap\n        for time, delta in self.timeline:\n            active += delta\n            if active > max_active:\n                max_active = active\n        return max_active\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # The input format is two lists separated by a comma, e.g.\n    # [\"MyCalendarThree\", \"book\", ...], [[], [10,20], ...]\n    # Wrap them into a tuple for safe evaluation\n    ops, args = ast.literal_eval(f\"({data})\")\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyCalendarThree\":\n            obj = MyCalendarThree()\n            results.append(None)\n        elif op == \"book\":\n            results.append(obj.book(*arg))\n        else:\n            # ignore unknown operations\n            results.append(None)\n\n    # Convert Python None to JSON null for output consistency\n    output = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "success": true,
          "output": "[null, 1, 1, 2, 3, 3, 3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode162.json",
    "problem_index_in_file": 0,
    "title": "Find Peak Element",
    "description_snippet": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a 0-indexed integer...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for peak element problem with binary search O(log n). Provide steps line by line with comments.\n\nNeed to use virtual code arrows and structure. Use Start, End, Decision.\n\nLet's produce steps:\n\nStart\n→ Step 1: 初始化 left = 0, right = n-1 // 設定搜尋範圍\n→ Decision: 如果 left == right? // 檢查只剩一個元素\n    Yes → Step 2: 回傳 left // 這個元素即為峰\n    No  → Step 3: 進行二分搜尋\n\nStep 3: 計算 mid = (left + right) // 2 // 取中點\n→ Decision: 如果 nums[mid] < nums[mid + 1]? // 比較右鄰\n    Yes → Step 4: left = mid + 1 // 峰一定在右半\n    No  → Step 5: right = mid // 峰在左半（含 mid）\n\n→ Decision: 回到 Step 3 循環 // 繼續縮小範圍\n\nEnd\n\nBut we need virtual code style with arrows and Decision blocks. Provide each line with comment.\n\nLet's produce.\n\nAlso incorporate that if mid > 0, but we can rely on assumption of boundaries. Use condition if nums[mid] < nums[mid+1] else.\n\nNeed to produce step lines.\n\nUse Start and End.\n\nAlso use indent for decisions.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left ← 0, right ← n-1 // 初始化搜尋區間為整個陣列  \n→ Decision: 如果 left == right? // 判斷是否只剩一個元素  \n  Yes → Step 2: 回傳 left // 這個索引即為峰元素  \n  No → Step 3: 進行二分搜尋  \n\nStep 3: mid ← (left + right) // 2 // 計算中點索引  \n→ Decision: 如果 nums[mid] < nums[mid + 1]? // 判斷右側鄰居較大  \n  Yes → Step 4: left ← mid + 1 // 峰必定在右半區域  \n  No → Step 5: right ← mid // 峰在左半區域（含 mid）  \n\n→ Decision: 重複 Step 3 // 迴圈繼續直到 left == right  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findPeakElement(self, nums):\n        \"\"\"\n        使用二分搜尋在 O(log n) 時間內找到峰值索引。\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < nums[mid + 1]:\n                # 峰一定在右半區域\n                left = mid + 1\n            else:\n                # 峰在左半區域（含 mid）\n                right = mid\n        return left\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個資料\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入格式，例如 'nums = [1,2,3,1]'\n    try:\n        if '=' in data:\n            _, expr = data.split('=', 1)\n            nums = ast.literal_eval(expr.strip())\n        else:\n            nums = ast.literal_eval(data)\n    except Exception:\n        # 無法解析時輸出 0 作為預設\n        print(0)\n        sys.exit(0)\n\n    sol = Solution()\n    peak_index = sol.findPeakElement(nums)\n    print(peak_index)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,1,3,5,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode736.json",
    "problem_index_in_file": 0,
    "title": "Parse Lisp Expression",
    "description_snippet": "You are given a string expression representing a Lisp-like expression to return the integer value of...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for evaluating such Lisp-like expressions. Provide line by line virtual code steps with comments.\n\nWe need to cover parsing expression, evaluating, handling let, add, mult, variable scopes, integers.\n\nWe should produce algorithm skeleton, not actual code.\n\nLet's craft lines:\n\nStart\n\n→ ParseExpression(expr) // recursively parse string into node\n\n→ Evaluate(node, env) // evaluate with environment stack\n\nImplement Evaluate:\n\nDecision: node type integer? -> return value\n\nYes → Return int // value\n\nNo → Decision: node type variable? -> lookup env\n\nYes → Return Lookup(env, var)\n\nNo → Decision: node type let? -> process\n\nYes → Start let evaluation: new local env, for each pair evaluate expr and bind variable\n\nNo → Decision: add? -> evaluate e1, e2, return sum\n\nNo → Decision: mult? -> evaluate e1, e2, return product\n\nInclude scope handling: env as stack of dicts.\n\nLet's write each line accordingly. Ensure each line ends with // comment.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: ParseExpression(input) // 將輸入字串轉成抽象語法樹（AST）結構\n→ Step 2: Evaluate(AST, []) // 用空環境開始評估整個表達式\n\n// Evaluate 函式的核心流程\n→ Decision: 若 node 為 整數字? // 判斷是否為直接的整數\n    Yes → Return node.value // 直接回傳整數值\n    No  → Decision: 若 node 為 變數名稱? // 需要查找變數值\n        Yes → Return Lookup(env, node.name) // 在環境中尋找最內層定義的變數\n        No  → Decision: 若 node 為 let 表達式? // 處理 let 的變數綁定\n            Yes →\n                → env.push({}) // 新增一層局部環境\n                → For each (var, expr) pair in let.body:\n                    → val = Evaluate(expr, env) // 評估右側表達式\n                    → env.top().bind(var, val) // 將變數綁定到目前環境\n                → result = Evaluate(let.finalExpr, env) // 評估 let 的最終表達式\n                → env.pop() // 移除局部環境\n                → Return result // 回傳 let 的計算結果\n            No  → Decision: 若 node 為 add 表達式? // 處理加法\n                Yes →\n                    → left = Evaluate(node.e1, env) // 評估左子表達式\n                    → right = Evaluate(node.e2, env) // 評估右子表達式\n                    → Return left + right // 回傳兩者之和\n                No  → Decision: 若 node 為 mult 表達式? // 處理乘法\n                    Yes →\n                        → left = Evaluate(node.e1, env) // 評估左子表達式\n                        → right = Evaluate(node.e2, env) // 評估右子表達式\n                        → Return left * right // 回傳兩者之積\n                    No → Return error // 若未匹配任何類型，報錯（但題目保證合法）\n\n// Lookup 函式負責在環境堆疊中尋找變數\n→ Function Lookup(envStack, varName):\n    → For each env in envStack (從最內層到最外層):\n        → If env contains varName:\n            → Return env[varName] // 找到即返回\n    → Raise undefined variable error // 但題目保證已定義\n\nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def evaluate(self, expression: str) -> int:\n        def eval_expr(expr: str, env: dict) -> int:\n            if not expr:\n                return 0\n            if expr[0] != '(':\n                if expr[0].isalpha():\n                    return env[expr]\n                return int(expr)\n            expr = expr[1:-1]  # remove outer parentheses\n            tokens = []\n            balance = 0\n            start = 0\n            for i, c in enumerate(expr):\n                if c == '(':\n                    balance += 1\n                elif c == ')':\n                    balance -= 1\n                elif c == ' ' and balance == 0:\n                    tokens.append(expr[start:i])\n                    start = i + 1\n            tokens.append(expr[start:])  # last token\n            op = tokens[0]\n            if op == 'add':\n                return eval_expr(tokens[1], env.copy()) + eval_expr(tokens[2], env.copy())\n            elif op == 'mult':\n                return eval_expr(tokens[1], env.copy()) * eval_expr(tokens[2], env.copy())\n            elif op == 'let':\n                new_env = env.copy()\n                i = 1\n                while i < len(tokens) - 1:\n                    var = tokens[i]\n                    val = eval_expr(tokens[i + 1], new_env)\n                    new_env[var] = val\n                    i += 2\n                return eval_expr(tokens[-1], new_env)\n            else:\n                return 0\n\n        return eval_expr(expression, {})\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the expression part if the input contains an '='\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data.strip()\n\n    # Remove surrounding quotes if present\n    if expr.startswith(\"'\") and expr.endswith(\"'\"):\n        expr = expr[1:-1]\n    elif expr.startswith('\"') and expr.endswith('\"'):\n        expr = expr[1:-1]\n\n    expr = expr.strip()\n\n    sol = Solution()\n    result = sol.evaluate(expr)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"",
          "expected_output": "14",
          "success": true,
          "output": "14"
        },
        {
          "example_index": 1,
          "input": "expression = \"(let x 3 x 2 x)\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "expression = \"(let x 1 y 2 x (add x y) (add x y))\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode87.json",
    "problem_index_in_file": 0,
    "title": "Scramble String",
    "description_snippet": "We can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the st...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode line by line, with explanation comment. The problem: determine if s2 is a scrambled string of s1 using scramble algorithm. Classic Leetcode 87 scramble string. Approach: recursive with memoization or DP. We'll produce pseudocode lines with arrows.\n\nWe need to output steps:\n\nStart\n→ Step 1: define function IsScramble(s1, s2)\n→ Decision: if lengths unequal? -> return false\n→ Decision: if s1 == s2? -> return true\n→ Decision: if sorted characters differ? -> return false\n→ Step: For i from 1 to len-1:\n  → Decision: Check no-swap: IsScramble(s1[0:i], s2[0:i]) && IsScramble(s1[i:], s2[i:])? If true return true\n  → Decision: Check swap: IsScramble(s1[0:i], s2[-i:]) && IsScramble(s1[i:], s2[0:-i])? If true return true\n→ Return false\nUse memoization dictionary key s1 + '|' + s2 to avoid recomputation.\n\nNeed to add memo at start: cache empty\n\nLet's format with arrow lines.\n\nNeed to ensure each line includes the step and comment. Use `→` for transitions. Indent decisions.\n\nLet's produce:\n\nStart\n→ Declare cache as empty map // 用於記錄已計算的子問題結果\n→ Function IsScramble(a, b) // 判斷兩字串是否為 Scramble\n    → Decision: if length(a) != length(b) then\n        → Return false // 長度不同不可為 Scramble\n    → Decision: if a == b then\n        → Return true // 完全相同即為 Scramble\n    → Decision: if sorted(a) != sorted(b) then\n        → Return false // 字元分布不同則不可能\n    → Decision: if cache contains key a|b then\n        → Return cache[a|b] // 直接回傳已算結果\n    → Decision: for i from 1 to length(a)-1 do\n        → Decision: if IsScramble(a[0:i], b[0:i]) and IsScramble(a[i:], b[i:]) then\n            → cache[a|b] = true\n            → Return true // 不交換時符合\n        → Decision: if IsScramble(a[0:i], b[-i:]) and IsScramble(a[i:], b[0:-i]) then\n            → cache[a|b] = true\n            → Return true // 交換時符合\n    → cache[a|b] = false\n    → Return false // 無任何分割方式符合\n→ End // 程式結束\n\nBut need to ensure we output each line with arrow and explanation. For loops and decisions we might indent with spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Declare cache as empty map // 用於記錄已計算的子問題結果\n→ Function IsScramble(a, b) // 判斷兩字串是否為 Scramble\n    → Decision: if length(a) != length(b) then\n        → Return false // 長度不同則不可能是 Scramble\n    → Decision: if a == b then\n        → Return true // 完全相同即為 Scramble\n    → Decision: if sorted(a) != sorted(b) then\n        → Return false // 字元分布不同則不可能\n    → Decision: if cache contains key a|b then\n        → Return cache[a|b] // 直接回傳已算結果\n    → Decision: for i from 1 to length(a)-1 do\n        → Decision: if IsScramble(a[0:i], b[0:i]) and IsScramble(a[i:], b[i:]) then\n            → cache[a|b] = true\n            → Return true // 不交換時符合條件\n        → Decision: if IsScramble(a[0:i], b[-i:]) and IsScramble(a[i:], b[0:-i]) then\n            → cache[a|b] = true\n            → Return true // 交換時符合條件\n    → cache[a|b] = false\n    → Return false // 沒有任何分割方式符合\n→ End // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\ndef is_scramble(s1: str, s2: str) -> bool:\n    memo = {}\n\n    def dfs(a: str, b: str) -> bool:\n        key = (a, b)\n        if key in memo:\n            return memo[key]\n        if a == b:\n            memo[key] = True\n            return True\n        if sorted(a) != sorted(b):\n            memo[key] = False\n            return False\n\n        n = len(a)\n        for i in range(1, n):\n            # no swap\n            if dfs(a[:i], b[:i]) and dfs(a[i:], b[i:]):\n                memo[key] = True\n                return True\n            # swap\n            if dfs(a[:i], b[-i:]) and dfs(a[i:], b[:-i]):\n                memo[key] = True\n                return True\n\n        memo[key] = False\n        return False\n\n    return dfs(s1, s2)\n\ndef parse_input(data: str):\n    # Try to extract quoted strings first\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n    # Fallback: split lines or words\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0].strip('\"'), lines[1].strip('\"')\n    tokens = data.strip().split()\n    if len(tokens) >= 2:\n        return tokens[0].strip('\"'), tokens[1].strip('\"')\n    # As a last resort, treat the whole input as s1\n    return data.strip().strip('\"'), \"\"\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s1, s2 = parse_input(raw_input)\n    result = is_scramble(s1, s2)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"great\", s2 = \"rgeat\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s1 = \"abcde\", s2 = \"caebd\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s1 = \"a\", s2 = \"a\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode34.json",
    "problem_index_in_file": 0,
    "title": "Find First and Last Position of Element in Sorted Array",
    "description_snippet": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending positio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: binary search for first and last positions. Steps: Start, input array, target. Use helper function findLeft/Right. Provide decision steps. Need to output virtual code lines with // explanation. Each line separate. Use arrows.\n\nWe need to avoid actual code. Use pseudocode. Provide O(log n) binary search.\n\nWe must include steps for start, find left, find right, output.\n\nLet's produce:\n\nStart\n→ Step: Initialize low = 0, high = length(nums)-1 // 定義搜尋區間\n→ Decision: If low > high? // 空陣列檢查\n    Yes → Step: Return [-1,-1] // 沒有元素\n    No → Step: Call FindFirst()\n    No → Step: Call FindLast()\n→ Step: Return [first, last] // 結果\n\nBut we need to define FindFirst and FindLast using binary search.\n\nDefine FindFirst:\nStart FindFirst // 子程序\n→ Step: low=0, high=len-1, first=-1 // 初始值\n→ Loop while low <= high // 迭代\n    → Step: mid = (low+high)/2 // 取中點\n    → Decision: nums[mid] == target? // 找到目標\n        Yes → Step: first=mid // 記錄位置\n             → Step: high=mid-1 // 繼續尋找左側\n        No  → Decision: nums[mid] < target? // 小於\n            Yes → Step: low=mid+1\n            No  → Step: high=mid-1\n→ End FindFirst // 回傳 first\n\nSimilarly FindLast:\nStart FindLast\n→ Step: low=0, high=len-1, last=-1\n→ Loop while low <= high\n    → Step: mid=(low+high)/2\n    → Decision: nums[mid] == target?\n        Yes → Step: last=mid\n             → Step: low=mid+1 // 右側\n        No  → Decision: nums[mid] < target?\n            Yes → Step: low=mid+1\n            No  → Step: high=mid-1\n→ End FindLast\n\nThen main uses first=FindFirst, last=FindLast.\n\nWe need to output with lines each with arrow and comment.\n\nWe need to use virtual arrow \"→\" or \"Yes →\" \"No →\" with indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← 0, high ← len(nums) - 1 // 初始化搜尋範圍  \n→ Decision: low > high? // 檢查陣列是否為空  \n Yes → Step 2: Return [-1, -1] // 空陣列直接回傳結果  \n No → Step 3: first ← FindFirst(nums, target) // 找到左端點  \n No → Step 4: last ← FindLast(nums, target) // 找到右端點  \n→ Step 5: Return [first, last] // 回傳搜尋結果  \nEnd // 程式結束  \n\nStart FindFirst(nums, target) // 子程序：尋找第一個目標位置  \n→ Step 1: low ← 0, high ← len(nums) - 1, first ← -1 // 初始化  \n→ Loop while low ≤ high // 迭代搜尋  \n → Step 2: mid ← (low + high) // 取中點  \n → Decision: nums[mid] == target? // 找到目標  \n  Yes → Step 3: first ← mid // 記錄位置  \n   → Step 4: high ← mid - 1 // 繼續搜尋左邊  \n  No → Decision: nums[mid] < target? // 目標在右邊  \n   Yes → Step 5: low ← mid + 1 // 移到右半區  \n   No → Step 6: high ← mid - 1 // 移到左半區  \n→ End FindFirst // 回傳 first  \n\nStart FindLast(nums, target) // 子程序：尋找最後一個目標位置  \n→ Step 1: low ← 0, high ← len(nums) - 1, last ← -1 // 初始化  \n→ Loop while low ≤ high // 迭代搜尋  \n → Step 2: mid ← (low + high) // 取中點  \n → Decision: nums[mid] == target? // 找到目標  \n  Yes → Step 3: last ← mid // 記錄位置  \n   → Step 4: low ← mid + 1 // 繼續搜尋右邊  \n  No → Decision: nums[mid] < target? // 目標在右邊  \n   Yes → Step 5: low ← mid + 1 // 移到右半區  \n   No → Step 6: high ← mid - 1 // 移到左半區  \n→ End FindLast // 回傳 last",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def searchRange(self, nums, target):\n        def findLeft(nums, target):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n                if nums[mid] == target:\n                    index = mid\n            return index\n\n        def findRight(nums, target):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] <= target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n                if nums[mid] == target:\n                    index = mid\n            return index\n\n        return [findLeft(nums, target), findRight(nums, target)]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not target_match:\n        return\n\n    nums = ast.literal_eval(nums_match.group(1))\n    target = int(target_match.group(1))\n\n    solution = Solution()\n    result = solution.searchRange(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,7,7,8,8,10], target = 8",
          "expected_output": "[3,4]",
          "success": true,
          "output": "[3, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [5,7,7,8,8,10], target = 6",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1, -1]"
        },
        {
          "example_index": 2,
          "input": "nums = [], target = 0",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode771.json",
    "problem_index_in_file": 0,
    "title": "Jewels and Stones",
    "description_snippet": "You're given strings jewels representing the types of stones that are jewels, and stones representin...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations, following format. For each line: \"虛擬碼步驟\" + \" // 解釋/說明\". Use Start, End, Decision: etc. Need to be step-by-step algorithm for counting jewels in stones.\n\nSo:\n\nStart\n→ Step 1: 建立空集合 jewelSet // 用於快速查找\n→ Step 2: 對於 jewel 中每個字符 ch → 將 ch 加入 jewelSet // 记录所有宝石类型\n→ Step 3: 初始化計數 count = 0 // 记录匹配个数\n→ Step 4: 對於 stones 中每個字符 s →\n    Decision: 如果 s 在 jewelSet 中? // 检查是否是宝石\n        Yes → Step 5: count += 1 // 匹配计数+1\n        No → // 不做任何操作\n→ Step 6: 輸出 count // 返回结果\nEnd\n\nNeed to ensure each line includes explanation. Use arrows. Indent for decisions. The \"Yes →\" lines.\n\nAlso ensure formatting: e.g., \"→ Decision: 如果 s 在 jewelSet 中? // 檢查是否是寶石\" and then indent lines.\n\nMake sure each line separate.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空集合 jewelSet // 用於快速查找所有寶石類型  \n→ Step 2: 對於 jewel 中每個字符 ch → 將 ch 加入 jewelSet // 將寶石字元存入集合  \n→ Step 3: 初始化計數 count = 0 // 用於統計同時為寶石的石頭數量  \n→ Step 4: 對於 stones 中每個字符 s →  \n    Decision: s 在 jewelSet 中? // 判斷此石頭是否為寶石  \n        Yes → Step 5: count += 1 // 若是寶石，計數+1  \n        No  → // 若不是寶石，保持計數不變  \n→ Step 6: 輸出 count // 回傳寶石的總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\n        \"\"\"\n        計算 stones 中與 jewels 相同字符的個數。\n        使用集合做 O(1) 查詢，遍歷 stones 時累加計數。\n        \"\"\"\n        jewel_set = set(jewels)          # 建立寶石類型集合\n        count = 0                        # 初始化計數器\n        for ch in stones:                # 遍歷每個石頭\n            if ch in jewel_set:          # 若是寶石則計數 +1\n                count += 1\n        return count\n\ndef parse_input(data: str):\n    \"\"\"\n    從 stdin 讀取的資料可能有兩種格式：\n    1. 兩行分別為 jewels 與 stones\n    2. 單行類似 'jewels = \"aA\", stones = \"aAAbbbb\"'\n    本函式嘗試從兩種格式中抽取兩個字串。\n    \"\"\"\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        # 直接取前兩行\n        jewels, stones = lines[0], lines[1]\n    else:\n        # 單行情況，使用正則找出兩個雙引號內的字串\n        matches = re.findall(r'\"(.*?)\"', data)\n        if len(matches) >= 2:\n            jewels, stones = matches[0], matches[1]\n        else:\n            # 若無法解析，回傳空字串\n            jewels, stones = \"\", \"\"\n    return jewels, stones\n\ndef main():\n    data = sys.stdin.read()\n    jewels, stones = parse_input(data)\n    result = Solution().numJewelsInStones(jewels, stones)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "jewels = \"aA\", stones = \"aAAbbbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "jewels = \"z\", stones = \"ZZ\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode594.json",
    "problem_index_in_file": 0,
    "title": "Longest Harmonious Subsequence",
    "description_snippet": "We define a harmonious array as an array where the difference between its maximum value and its mini...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution in pseudocode. Steps: count frequencies, iterate through keys, find where key+1 exists, compute length sum. Return max. Provide explanation. Use the format. Ensure no actual code but pseudocode steps. Each line: virtual code + comment. Use Start, End, Decision. Ensure arrow indentation. Let's craft.\n\nWe need to adhere to format: Start, each step arrow, Decision: If etc.\n\nWe should produce line by line: maybe:\n\nStart // 程式開始\n\n→ Step 1: Initialize frequency_map = empty map // Count occurrences\n\n→ Step 2: For each num in nums // Build frequency\n\n→ Step 3: If num not in frequency_map then frequency_map[num] = 0\n\n→ Step 4: frequency_map[num] += 1\n\n→ Step 5: Initialize max_len = 0 // store best length\n\n→ Step 6: For each key in frequency_map // Check neighbor\n\n→ Decision: If key+1 exists in frequency_map? // Check pair\n\n    Yes → temp_len = frequency_map[key] + frequency_map[key+1] // sum counts\n\n    → Decision: If temp_len > max_len? // Update max\n\n        Yes → max_len = temp_len\n\n        No → // do nothing\n\n    No → // no neighbor, skip\n\n→ Step 7: Return max_len // 最終結果\n\nEnd // 程式結束\n\nWe need to make sure each line ends with comment. Also indent? Not necessary. Use arrow and indent for nested decision. Provide explanation in Chinese.\n\nMake sure to use \"→\" and \"Decision:\" etc. Provide each line. Ensure \"Yes →\" etc. Provide comment after a space. Good.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: frequency_map ← 空字典 // 用於記錄每個數字出現的次數\n→ Step 2: 對於 nums 中的每個 num\n→     If num 不在 frequency_map 中\n→         frequency_map[num] ← 0 // 初始化該數字的計數\n→     frequency_map[num] ← frequency_map[num] + 1 // 累計計數\n→ Step 3: max_len ← 0 // 目前找到的最大和諧子序列長度\n→ Step 4: 對於 frequency_map 中的每個 key\n→     Decision: 如果 key+1 存在於 frequency_map 中? // 檢查是否有相鄰數字\n→         Yes → temp_len ← frequency_map[key] + frequency_map[key+1] // 兩個數字的總數量\n→             Decision: 如果 temp_len > max_len? // 是否更新最大長度\n→                 Yes → max_len ← temp_len // 更新為更長的子序列\n→                 No → // 保持現有 max_len\n→             End // 完成更新判斷\n→         No → // 沒有相鄰數字，跳過\n→     End // 完成 key 的判斷\n→ Step 5: Return max_len // 返回最長和諧子序列長度\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef find_lhs(nums):\n    \"\"\"找出最長和諧子序列的長度\"\"\"\n    freq = Counter(nums)\n    max_len = 0\n    for num in freq:\n        if num + 1 in freq:\n            cur_len = freq[num] + freq[num + 1]\n            if cur_len > max_len:\n                max_len = cur_len\n    return max_len\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 只保留方括號中的部分作為 list 表達式\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1 and end > start:\n        list_str = data[start:end+1]\n        try:\n            nums = ast.literal_eval(list_str)\n        except Exception:\n            # 如果解析失敗則直接嘗試解析整個輸入\n            nums = ast.literal_eval(data)\n    else:\n        # 沒有方括號，直接解析整個輸入\n        nums = ast.literal_eval(data)\n\n    result = find_lhs(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,2,2,5,2,3,7]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1.json",
    "problem_index_in_file": 0,
    "title": "Two Sum",
    "description_snippet": "Given an array of integers nums and an integer target, return indices of the two numbers such that t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, each line with \"虛擬碼步驟 // 解釋\" format. Use arrows, Start, End, Decision. It's basically the two-sum problem.\n\nWe produce steps: start, loop over array, for each number compute complement, check if complement seen in hash map. If found, output indices. Use dictionary mapping number to index. Provide explanation each line.\n\nWe must not output real code, only pseudo-code. Also must be line by line, each line with \"虛擬碼步驟 // 解釋\". Use arrow -> or decision arrows.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: 建立空字典 complementMap // 用於儲存已經看到的數字與其索引\n\n→ Step 2: 迭代索引 i 從 0 到 nums.Length - 1 // 遍歷陣列\n\n→ Decision: 判斷 nums[i] 是否為 target - nums[i] 的補數已存在於 complementMap? // 檢查是否已有符合條件的數字\n\nYes → Step 3: 取得 complementMap[target - nums[i]] 並輸出該索引與 i // 回傳兩個符合條件的索引\n\n→ End // 完成\n\nNo  → Step 4: 將 nums[i] 加入 complementMap，值為 i // 記錄此數字以供後續比較\n\n→ Continue // 回到下一個索引\n\nWe must keep \"Decision\" and then nested lines with Yes → and No →. Also ensure each line is separate. End must be after the whole process. We need to consider that after Yes we should exit? The pseudocode would End after Step 3 maybe. But we can simply have Step 3 outputs then End.\n\nBetter: after Step 3 we can go to End. We'll keep separate lines.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 complementMap // 用於儲存已看到的數字與其索引  \n→ Step 2: 迭代索引 i 從 0 到 nums.Length - 1 // 遍歷陣列  \n→ Decision: 判斷 target - nums[i] 是否已存在於 complementMap? // 檢查是否已有符合條件的補數  \n    Yes → Step 3: 取得 complementMap[target - nums[i]] 並輸出該索引與 i // 回傳兩個符合條件的索引  \n    No  → Step 4: 將 nums[i] 加入 complementMap，值為 i // 記錄此數字以供後續比較  \n→ Continue // 回到下一個索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        找出兩個數字的索引，使得它們的和等於 target。\n        使用字典來存儲已經遍歷過的數字及其索引，時間複雜度 O(n)。\n        \"\"\"\n        seen = {}\n        for i, value in enumerate(nums):\n            complement = target - value\n            if complement in seen:\n                return [seen[complement], i]\n            seen[value] = i\n        # 根據題目假設一定有解，這裡不需要額外處理\n        return []\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，例如:\n        'nums = [2,7,11,15], target = 9'\n    回傳 (nums_list, target_value)\n    \"\"\"\n    # 擷取列表內容\n    nums_match = re.search(r'\\[([^\\]]*)\\]', data)\n    nums = []\n    if nums_match:\n        nums = [int(x.strip()) for x in nums_match.group(1).split(',') if x.strip()]\n\n    # 擷取 target 數值\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    target = int(target_match.group(1)) if target_match else 0\n    return nums, target\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入（stdin）\n    raw_input = sys.stdin.read().strip()\n    nums, target = parse_input(raw_input)\n\n    # 呼叫解法\n    result = Solution().twoSum(nums, target)\n\n    # 將結果輸出到 stdout，格式為 [index1, index2]\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,7,11,15], target = 9",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,4], target = 6",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3], target = 6",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode354.json",
    "problem_index_in_file": 0,
    "title": "Russian Doll Envelopes",
    "description_snippet": "You are given a 2D array of integers envelopes where envelopes[i] = [w_i, h_i] represents the width ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Problem is classic Russian Doll Envelopes. Steps: sort by width ascending, then height descending for equal width, then find LIS on heights. We'll output virtual steps. Ensure each line: \"虛擬碼步驟 // 解釋\". Use arrows. We need Start, End, Decision. Outline:\n\nStart\n→ Step: 接收 2D 數組 envelopes // input\n→ Step: 先排序 envelopes，根據寬度升序、同寬度時高度降序 // sort\n→ Step: 建立空列表 dp 用於 LIS // dp init\n→ Decision: 是否還有 envelope 從排序列表中處理? // loop\n   Yes → Step: 取下一個 envelope 的高度 h\n   Yes → Step: 用二分搜尋在 dp 中找到第一個 >= h 的位置 idx\n   Yes → Step: 若 idx 等於 dp 長度，追加 h；否則 dp[idx] = h\n   Yes → Go back to Decision\n   No  → End of loop\n→ Step: 回傳 dp 長度 // result\nEnd\n\nWe need to format each line with `虛擬碼步驟 // 解釋`. Use arrows. Let's produce.\n\nAlso use indentation with arrow and decisions.\n\nLet's produce as per example: use `Start //` etc. Use `→` arrow before each step.\n\nEnsure no real code. Provide concise explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 接收 2D 數組 envelopes // 取得輸入的信封尺寸\n→ Step: 對 envelopes 按寬度升序、同寬度時高度降序排序 // 方便後續 LIS 處理\n→ Step: 初始化空列表 dp 用於儲存高度的 LIS 追蹤序列 // dp 將保持遞增高度序列\n→ Decision: 是否還有信封待處理? // 判斷是否結束迴圈\n    Yes → Step: 取下一個信封的高度 h // 取得當前高度\n    Yes → Step: 在 dp 中進行二分搜尋，找到第一個 >= h 的位置 idx // 找出插入位置\n    Yes → Step: 若 idx 等於 dp 長度，將 h 追加到 dp；否則將 dp[idx] 更新為 h // 更新 LIS 序列\n    Yes → Decision: 是否還有信封待處理? // 回到迴圈判斷\n    No  → Step: 回傳 dp 的長度 // dp 長度即為最大信封數量\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport bisect\nimport ast\n\ndef max_envelopes(envelopes):\n    \"\"\"Return the maximum number of envelopes that can be Russian‑dollled.\"\"\"\n    if not envelopes:\n        return 0\n    # 先按寬度升序，如果寬度相同，按高度降序\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []  # 存儲高度的 LIS 序列\n    for _, h in envelopes:\n        idx = bisect.bisect_left(dp, h)  # 找到第一個 >= h 的位置\n        if idx == len(dp):\n            dp.append(h)  # 直接追加\n        else:\n            dp[idx] = h   # 用更小的高度覆蓋\n    return len(dp)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，處理可能的「envelopes = …」格式\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(0)\n        sys.exit(0)\n\n    # 取得表達式部分\n    if '=' in raw_input:\n        _, expr = raw_input.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = raw_input\n\n    # 使用安全的 literal_eval 解析列表\n    try:\n        envelopes = ast.literal_eval(expr)\n    except Exception:\n        # 若解析失敗，直接輸出 0\n        print(0)\n        sys.exit(0)\n\n    # 確保輸入是一個列表\n    if not isinstance(envelopes, list):\n        print(0)\n        sys.exit(0)\n\n    result = max_envelopes(envelopes)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "envelopes = [[5,4],[6,4],[6,7],[2,3]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "envelopes = [[1,1],[1,1],[1,1]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode746.json",
    "problem_index_in_file": 0,
    "title": "Min Cost Climbing Stairs",
    "description_snippet": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you p...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described problem. It's essentially the Leetcode \"Min Cost Climbing Stairs\". We'll produce pseudo steps: start, compute dp array or use recursion, consider base cases. Use DP: minCost[i] = cost[i] + min(minCost[i-1], minCost[i-2]) for i from 2 to n-1. Answer is min(minCost[n-1], minCost[n-2]). Also can start at 0 or 1.\n\nWe need to output line by line with virtual code arrow, each line followed by comment. Use arrows \"→\". Also use Decision: ... Yes → ... No → ... For loops and conditions.\n\nWe should avoid actual code. Use pseudo.\n\nLet's craft.\n\nLine1: Start // start\n\nLine2: → Step 1: n ← length(cost) // get number of steps\n\nLine3: → Decision: if n == 0? // edge case no steps\n\nLine4:    Yes → Return 0 // nothing to climb\n\nLine5:    No → Continue\n\nLine6: → Step 2: Initialize array dp[0...n-1] // store min cost to reach each step\n\nLine7: → Step 3: dp[0] ← cost[0] // cost to reach first step\n\nLine8: → Step 4: dp[1] ← cost[1] // cost to reach second step\n\nLine9: → Decision: if n > 2? // need to compute further steps\n\nLine10:    Yes → For i from 2 to n-1:\n\nLine11:           → Step 5: dp[i] ← cost[i] + min(dp[i-1], dp[i-2]) // minimal cost to reach step i\n\nLine12:    No → Skip\n\nLine13: → Step 6: result ← min(dp[n-1], dp[n-2]) // min cost to reach top from either last or second last\n\nLine14: → End // return result\n\nWe should use arrow formatting.\n\nWe should include indentation maybe. But each line is separate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(cost) // 取得樓梯總階數  \n→ Decision: n == 0? // 判斷是否無任何階梯  \n  Yes → Return 0 // 無階梯時直接回傳 0  \n  No  → Continue // 有階梯時進行計算  \n→ Step 2: 初始化 dp[0...n-1] // dp 用於儲存到達每個階梯的最小成本  \n→ Step 3: dp[0] ← cost[0] // 到達第一階梯的成本  \n→ Step 4: dp[1] ← cost[1] // 到達第二階梯的成本  \n→ Decision: n > 2? // 是否還有更多階梯需要計算  \n  Yes → For i from 2 to n-1:  \n    → Step 5: dp[i] ← cost[i] + min(dp[i-1], dp[i-2]) // 從前一階或前二階跳到當前階梯的最小成本  \n  No  → Skip // 若只有兩階梯則不進行迴圈  \n→ Step 6: result ← min(dp[n-1], dp[n-2]) // 以最後一階或倒數第二階跳至頂層的最小成本  \n→ End // 程式執行結束，回傳 result",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def minCostClimbingStairs(self, cost):\n        n = len(cost)\n        if n == 0:\n            return 0\n        if n == 1:\n            return cost[0]\n        dp = [0] * n\n        dp[0], dp[1] = cost[0], cost[1]\n        for i in range(2, n):\n            dp[i] = cost[i] + min(dp[i-1], dp[i-2])\n        return min(dp[-1], dp[-2])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse the input like '[10,15,20]'\n    cost = ast.literal_eval(data)\n    solver = Solution()\n    result = solver.minCostClimbingStairs(cost)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[10,15,20]",
          "expected_output": "15",
          "success": true,
          "output": "15"
        },
        {
          "example_index": 1,
          "input": "[1,100,1,1,1,100,1,1,100,1]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode630.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule III",
    "description_snippet": "There are n different online courses numbered from 1 to n. You are given an array courses where cour...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve this problem: maximum number of courses that can be taken given durations and deadlines. Classic algorithm: sort by lastDay, iterate, maintain max-heap of durations, accumulate time, if time exceeds lastDay, remove longest duration. That's solution. We need to output in specified format: each line: \"虛擬碼步驟 // 解釋\". Use arrows and decision structure. Must not output actual code.\n\nWe need to create a step-by-step virtual algorithm in Chinese, explaining each step. Let's produce steps:\n\nStart\n→ Step 1: Sort courses by lastDay ascending // 為了依期限優先處理\n→ Step 2: Initialize max-heap durations empty // 用於存放已選課程長度\n→ Step 3: Initialize totalTime = 0 // 已經投入的總學習天數\n→ Step 4: For each course in sorted list // 逐個考慮課程\n    → Decision: 是否可加入? // 判斷是否能在期限前完成\n        Yes → Step 5: totalTime += duration // 加入課程時間\n              → Step 6: Add duration to max-heap // 記錄長度\n              → Decision: totalTime > lastDay? // 若已超過期限\n                Yes → Step 7: Remove longest duration from max-heap // 放棄最長課程\n                      → Step 8: totalTime -= removedDuration // 更新總時間\n                No → // 不超過，保持\n        No → // 不需處理, 直接跳過\n→ Step 9: Return size of max-heap // 最大可選課程數量\n\nBut we need to reflect decisions properly with arrows. Also include End.\n\nAlso include decision structure: Decision: if condition? and arrows Yes/No. Provide explanation after //.\n\nMake sure each line ends with // explanation. Use 虛擬碼步驟 and arrows.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort courses by lastDay ascending // 依照最後期限由小到大排列，以便先考慮緊迫課程  \n→ Step 2: Initialize max-heap durations empty // 建立最大堆疊，存放已選課程的持續時間  \n→ Step 3: Initialize totalTime = 0 // 目前已投入的總學習天數  \n→ Step 4: For each course in sorted list // 逐一檢視每個課程  \n    → Decision: 是否可將此課程加入計畫? // 判斷是否能在其 lastDay 前完成  \n        Yes → Step 5: totalTime += duration // 加入課程後更新總時間  \n             → Step 6: Insert duration into max-heap // 將此課程時間記錄於堆疊  \n             → Decision: totalTime > lastDay? // 檢查是否已超過該課程的最後期限  \n                 Yes → Step 7: Remove longest duration from max-heap // 移除已選課程中最長的一項，以縮短總時間  \n                     → Step 8: totalTime -= removedDuration // 調整總時間，剔除被移除課程的時間  \n                 No → // 總時間仍在期限內，保留當前選擇  \n        No → // 此課程無法在期限內完成，直接跳過  \n→ Step 9: Return size of max-heap // 最大可選課程數量即堆疊中項目數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\n\ndef max_courses(courses):\n    # 先依照最後期限升序排序\n    courses.sort(key=lambda x: x[1])\n    total_time = 0\n    max_heap = []  # 儲存已選課程的持續時間，使用負值做最大堆疊\n\n    for duration, last_day in courses:\n        if total_time + duration <= last_day:\n            # 若能在期限內完成，直接加入\n            heapq.heappush(max_heap, -duration)\n            total_time += duration\n        elif max_heap and -max_heap[0] > duration:\n            # 若已超過期限，且堆疊中最長課程比此課程長，則替換\n            removed = -heapq.heappop(max_heap)\n            total_time -= removed\n            heapq.heappush(max_heap, -duration)\n            total_time += duration\n\n    return len(max_heap)\n\ndef parse_input(data):\n    \"\"\"\n    解析類似 'courses = [[1,2],[3,4]]' 的輸入字串。\n    只保留方括號內的列表，並使用 eval 轉成 Python 物件。\n    \"\"\"\n    data = data.strip()\n    if data.startswith('courses'):\n        eq_index = data.find('=')\n        if eq_index != -1:\n            data = data[eq_index + 1:].strip()\n    try:\n        courses = eval(data, {\"__builtins__\": None}, {})\n        if not isinstance(courses, list):\n            courses = []\n    except Exception:\n        courses = []\n    return courses\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    courses = parse_input(raw_input)\n    result = max_courses(courses)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "courses = [[1,2]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "courses = [[3,2],[4,3]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode233.json",
    "problem_index_in_file": 0,
    "title": "Number of Digit One",
    "description_snippet": "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that counts number of digit '1' in all numbers from 0 to n inclusive. This is a typical problem: count ones in range [0,n]. Standard approach: iterate over digit positions, compute number of full cycles and remainder.\n\nWe need to output step-by-step virtual code with explanations. Each line: virtual code + space + comment. Use arrow \"→\" for steps. Use Start, End, Decision, etc.\n\nWe need to produce a line-by-line pseudo algorithm.\n\nWe need to ensure we use \"虛擬碼步驟\" e.g., \"→ Step 1: ...\".\n\nLet's design:\n\nStart\n\n→ Input: n // get integer n\n\n→ Initialize: count = 0 // counter for ones\n\n→ Initialize: factor = 1 // current digit position (units, tens, etc.)\n\n→ Decision: while factor <= n? // check if current position within n\n\n    Yes →\n\n        → lower = n % factor // digits right of current position\n\n        → cur = (n / factor) % 10 // current digit\n\n        → higher = n / (factor * 10) // digits left of current position\n\n        → Decision: if cur == 0? // current digit zero\n\n            Yes → count += higher * factor // add higher * factor\n\n            No → Decision: if cur == 1?\n\n                Yes → count += higher * factor + (lower + 1) // add higher*factor + remainder+1\n\n                No → count += (higher + 1) * factor // else current digit >1\n\n        → factor *= 10 // move to next position\n\n    No →\n\nEnd // return count\n\nBut we need to produce lines. Let's format each as:\n\nStart // 程式開始執行\n\n→ Step 1: 讀入整數 n // 獲取上限\n\n→ Step 2: count ← 0 // 初始化計數\n\n→ Step 3: factor ← 1 // 位權（個位、十位等）\n\n→ Decision: factor ≤ n? // 判斷是否還有位需要處理\n\n    Yes →\n\n        → Step 4: lower ← n mod factor // 低位數字\n\n        → Step 5: cur ← (n / factor) mod 10 // 當前位數字\n\n        → Step 6: higher ← n / (factor * 10) // 高位數字\n\n        → Decision: cur == 0? // 當前位為0\n\n            Yes →\n\n                → Step 7: count ← count + higher * factor // 加上高位×位權\n\n            No →\n\n                → Decision: cur == 1? // 當前位為1\n\n                    Yes →\n\n                        → Step 8: count ← count + higher * factor + (lower + 1) // 加上高位×位權 + 低位+1\n\n                    No →\n\n                        → Step 9: count ← count + (higher + 1) * factor // 加上(高位+1)×位權\n\n        → Step 10: factor ← factor * 10 // 進位到下一位\n\n    No →\n\nEnd // 程式結束\n\nWe need to ensure each line has comment. Also need to include arrow for decision lines. Provide indentation maybe with spaces. Use \"Yes →\" \"No →\".\n\nWe need to output each line separately. We must not output any actual code.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入整數 n // 獲取上限  \n→ Step 2: count ← 0 // 初始化計數  \n→ Step 3: factor ← 1 // 位權（個位、十位等）  \n→ Decision: factor ≤ n? // 判斷是否還有位需要處理  \n    Yes →  \n        → Step 4: lower ← n mod factor // 低位數字  \n        → Step 5: cur ← (n / factor) mod 10 // 當前位數字  \n        → Step 6: higher ← n / (factor * 10) // 高位數字  \n        → Decision: cur == 0? // 當前位為0  \n            Yes →  \n                → Step 7: count ← count + higher * factor // 加上高位×位權  \n            No →  \n                → Decision: cur == 1? // 當前位為1  \n                    Yes →  \n                        → Step 8: count ← count + higher * factor + (lower + 1) // 加上高位×位權 + 低位+1  \n                    No →  \n                        → Step 9: count ← count + (higher + 1) * factor // 加上(高位+1)×位權  \n        → Step 10: factor ← factor * 10 // 進位到下一位  \n    No →  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef count_digit_one(n: int) -> int:\n    if n <= 0:\n        return 0\n    count = 0\n    i = 1\n    while i <= n:\n        divider = i * 10\n        count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)\n        i *= 10\n    return count\n\ndef main():\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    result = count_digit_one(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode299.json",
    "problem_index_in_file": 0,
    "title": "Bulls and Cows",
    "description_snippet": "You are playing the Bulls and Cows game with your friend.\n\nYou write down a secret number and ask yo...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. The user asks: \"You are playing Bulls and Cows... Given secret and guess, return hint.\" So produce algorithm. Let's outline steps: count bulls, then count cows. Approach: iterate over indices, compare. For mismatched digits, count frequency in secret and guess using map. Then cows = sum of min counts for each digit.\n\nLet's produce virtual code:\n\nStart\n→ Step: 初始化 bulls = 0, cows = 0 // 计数变量\n→ Step: 建立字典 secretCount, guessCount // 记录未匹配数字出现次数\n→ For i in 0..len(secret)-1:\n    → Decision: secret[i] == guess[i]?\n        Yes → bulls +=1 // 正确位置\n        No  → secretCount[secret[i]] +=1 ; guessCount[guess[i]] +=1 // 记录未匹配\n→ Step: 对每个数字 d 在 secretCount 中:\n    → cows += min(secretCount[d], guessCount.get(d,0)) // 计算可以匹配的\n→ Step: 返回 f\"{bulls}A{cows}B\" // 生成提示\n\nEnd\n\nNeed to use the arrow syntax: \"→ Step ...\". Use Decision block with Yes →, No →.\n\nMake sure each line has explanation. Use correct punctuation. Use 虛擬碼步驟 + [space] + // 解釋/說明.\n\nLet's craft.\n\nAlso need to show For loop maybe as \"→ Decision: 是否到達結尾?\" Not necessary; we can just show steps.\n\nWe should incorporate \"Decision:\" for For loop? We can treat it as just Step. But maybe simpler: \"→ Step: 遍歷所有位數 i\" and within it Decision.\n\nLet's produce. Use \"Start\" and \"End\". Ensure each line separate.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化 bulls = 0, cows = 0 // 設定正確位置與錯誤位置的計數器  \n→ Step: 建立空字典 secretCount, guessCount // 用於記錄未匹配的數字出現頻率  \n→ Step: 遍歷索引 i 從 0 到 len(secret)-1  \n    → Decision: secret[i] == guess[i]? // 檢查第 i 位是否為 \"牛\"  \n        Yes → bulls += 1 // 如果相同則增加牛的計數  \n        No  → secretCount[secret[i]] += 1 ; guessCount[guess[i]] += 1 // 否則記錄為可能的 \"奶牛\"  \n→ Step: 對於 secretCount 中的每個數字 d  \n    → cows += min(secretCount[d], guessCount.get(d, 0)) // 以頻率最小值計算可成為 \"奶牛\" 的數量  \n→ Step: 返回 f\"{bulls}A{cows}B\" // 生成並輸出提示字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        bulls = 0\n        cows = 0\n\n        # Count all digits in secret and guess\n        secret_count = Counter(secret)\n        guess_count = Counter(guess)\n\n        # First pass: count bulls and reduce the corresponding counts\n        for s, g in zip(secret, guess):\n            if s == g:\n                bulls += 1\n                secret_count[s] -= 1\n                guess_count[g] -= 1\n\n        # Second pass: count cows\n        for digit in guess_count:\n            if digit in secret_count:\n                cows += min(secret_count[digit], guess_count[digit])\n\n        return f\"{bulls}A{cows}B\"\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read()\n\n    # Try to extract two numbers (secret and guess) from the input\n    nums = re.findall(r'\\d+', data)\n    if len(nums) >= 2:\n        secret, guess = nums[0], nums[1]\n    else:\n        # Fallback: split by lines or spaces\n        lines = data.strip().splitlines()\n        if len(lines) >= 2:\n            secret, guess = lines[0].strip(), lines[1].strip()\n        else:\n            parts = re.split(r'[=,\\s]+', data.strip())\n            secret, guess = parts[0], parts[1]\n\n    solver = Solution()\n    print(solver.getHint(secret, guess))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "secret = \"1807\", guess = \"7810\"",
          "expected_output": "\"1A3B\"",
          "success": true,
          "output": "1A3B"
        },
        {
          "example_index": 1,
          "input": "secret = \"1123\", guess = \"0111\"",
          "expected_output": "\"1A1B\"",
          "success": true,
          "output": "1A1B"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode486.json",
    "problem_index_in_file": 0,
    "title": "Predict the Winner",
    "description_snippet": "You are given an integer array nums. Two players are playing a game with this array: player 1 and pl...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for algorithm: Determine if player1 can win with optimal play. Classic problem: Predict the Winner. Approach: DP using difference of scores or recursion with memoization. We'll produce stepwise pseudo-code with decisions.\n\nWe need to output line by line: \"虛擬碼步驟 // 解釋\".\n\nWe need to use arrows →, Decision: if etc. We'll structure algorithm:\n\nStart\n\n→ Step 1: Define function canWin(nums) // main entry\n\n→ Step 2: n = length(nums)\n\n→ Step 3: Create 2D array memo[n][n] // store difference scores\n\n→ Decision: if memo already computed? etc.\n\nBut we can produce pseudo-code for recursion:\n\nDefine helper(i,j) returns max score difference player can achieve from subarray i..j.\n\nIf i>j return 0\n\nIf memo[i][j] exists return it\n\nOption1 = nums[i] - helper(i+1,j)\n\nOption2 = nums[j] - helper(i,j-1)\n\nmemo[i][j] = max(Option1, Option2)\n\nReturn memo[i][j]\n\nIn main, compute diff = helper(0, n-1)\n\nIf diff >=0 return true else false\n\nWe'll need to include decision steps. Provide pseudo-code lines with arrows.\n\nMake sure each line has \" // \" explanation.\n\nLet's format:\n\nStart // 程式開始執行\n\n→ Step 1: 定義函式 canWin(nums) // 主入口\n\n→ Step 2: n = nums.length // 獲取陣列長度\n\n→ Step 3: 創建二維表 memo[n][n] 初始化為 null // 用於記錄子問題結果\n\n→ Step 4: 定義遞歸函式 helper(i,j) // 計算子陣列 i..j 的最大分數差\n\n    → Decision: 如果 i > j? // 子陣列空\n\n        Yes → Return 0 // 空陣列時差為0\n\n    → Decision: 如果 memo[i][j] 已計算? // 查詢快取\n\n        Yes → Return memo[i][j] // 直接返回\n\n    → Step 5: 選擇左端 nums[i] 的方案 = nums[i] - helper(i+1, j) // 左選時對手獲得的差值\n\n    → Step 6: 選擇右端 nums[j] 的方案 = nums[j] - helper(i, j-1) // 右選時對手獲得的差值\n\n    → Step 7: memo[i][j] = max(方案左, 方案右) // 儲存最大差值\n\n    → Step 8: Return memo[i][j] // 回傳\n\n→ Step 9: diff = helper(0, n-1) // 計算整個陣列的分數差\n\n→ Decision: 如果 diff >= 0? // player1 得分不低於 player2\n\n    Yes → Return true // player1 可以贏\n\n    No  → Return false // 失敗\n\nEnd // 程式結束\n\nWe might need to use arrow to show calls. Use \"→\" for step lines. Use indentation for sub-steps. Ensure each line has // explanation. Use Decision blocks as required.\n\nWe need to produce a sequence of lines as per format. Each line must be \"虛擬碼步驟 // 解釋\".\n\nLet's produce.\n\nNeed to start with \"Start // 程式開始執行\" maybe just \"Start\" line.\n\nBut in example they had \"Start // 程式開始執行\" etc. We'll follow that.\n\nLet's produce lines. For decisions we show \"Decision:\" and indent Yes/No. Indentation is by spaces? They used tab indentation.\n\nWe'll replicate like:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 canWin(nums) // 主入口\n→ Step 2: n = nums.length // 取得陣列長度\n→ Step 3: 創建 2D 陣列 memo[n][n] 初始化為 null // 用於快取\n→ Step 4: 定義遞迴函式 helper(i,j) // 計算子陣列 i..j 的分數差\n    → Decision: i > j? // 子陣列為空\n        Yes → Return 0 // 空陣列差值為 0\n    → Decision: memo[i][j] 已存在? // 快取檢查\n        Yes → Return memo[i][j] // 直接回傳\n    → Step 5: 左選方案 = nums[i] - helper(i+1, j) // 選左端的分數差\n    → Step 6: 右選方案 = nums[j] - helper(i, j-1) // 選右端的分數差\n    → Step 7: memo[i][j] = max(左選方案, 右選方案) // 儲存最大差值\n    → Step 8: Return memo[i][j] // 回傳差值\n→ Step 9: diff = helper(0, n-1) // 計算整體分數差\n→ Decision: diff >= 0? // player1 得分不低於 player2\n    Yes → Return true // player1 能贏或平手\n    No  → Return false // player1 失敗\nEnd // 程式結束\n\nMake sure each line ends with // 解釋. Ensure no actual code. Use \"Return\" maybe but not actual language. That's fine.\n\nWe need to include arrow at each step. In example they used \"→\" before Step lines. We should use same.\n\nAlso decisions: \"Decision: ...\" lines also start with \"→ Decision:\".\n\nBut for clarity we include \"→ Decision:\" each.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義函式 canWin(nums) // 主入口，接受整數陣列\n→ Step 2: n = nums.length // 取得陣列長度\n→ Step 3: 創建 2D 陣列 memo[n][n] 初始化為 null // 用於快取子問題結果\n→ Step 4: 定義遞迴函式 helper(i, j) // 計算子陣列 i..j 的分數差\n    → Decision: i > j? // 子陣列已空\n        Yes → Return 0 // 空陣列時分數差為 0\n    → Decision: memo[i][j] 已存在? // 快取已計算\n        Yes → Return memo[i][j] // 直接回傳快取值\n    → Step 5: 左選方案 = nums[i] - helper(i + 1, j) // 選左端後的分數差\n    → Step 6: 右選方案 = nums[j] - helper(i, j - 1) // 選右端後的分數差\n    → Step 7: memo[i][j] = max(左選方案, 右選方案) // 儲存最大分數差\n    → Step 8: Return memo[i][j] // 回傳子問題結果\n→ Step 9: diff = helper(0, n - 1) // 計算整個陣列的分數差\n→ Decision: diff >= 0? // 玩家1得分是否不低於玩家2\n    Yes → Return true // 玩家1能贏或平手\n    No  → Return false // 玩家1輸\nEnd // 程式結束",
      "generated_code": "class Solution:\n    def predictTheWinner(self, nums):\n        n = len(nums)\n        # dp[i][j] 表示從 i 到 j 的區間內先手能比後手多贏多少分\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][i] = nums[i]\n\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n\n        return dp[0][n - 1] >= 0\n\n\ndef main():\n    import sys\n    import ast\n\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入中可能出現的 \"nums =\" 或 \"nums=\" 去除，只保留列表部分\n    if 'nums' in data:\n        idx = data.find('[')\n        if idx != -1:\n            data = data[idx:]\n\n    nums = ast.literal_eval(data)\n\n    solution = Solution()\n    result = solution.predictTheWinner(nums)\n    print(str(result).lower())\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,2]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,233,7]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode338.json",
    "problem_index_in_file": 0,
    "title": "Counting Bits",
    "description_snippet": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. Need to follow format: each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc. Provide algorithm: iterate i from 0 to n, compute popcount via bit operations, store in ans. Or use DP: ans[i] = ans[i >> 1] + (i & 1). We'll produce steps. Should be clear. Let's produce maybe 10-12 lines.\n\nLet's plan:\n\nStart\n→ Step 1: Initialize ans array of size n+1 // allocate array\n→ Step 2: Set ans[0] = 0 // 0 has zero 1s\n→ Decision: 如果 n >= 1? // need to loop from 1 to n\n    Yes → Step 3: For i from 1 to n:\n                → Step 3a: ans[i] = ans[i >> 1] + (i & 1) // DP compute popcount\n    No → skip loop\n→ Step 4: Return ans // output result\nEnd\n\nNeed to include each line as separate line with arrow maybe. Use arrow arrow. Use indent for nested. We'll use \"Decision:\" lines with Yes→ and No→. Provide explanation after //.\n\nWe must not produce actual code. Use plain steps. So maybe:\n\nStart // 程式開始執行\n→ Step 1: 建立 ans 陣列大小為 n+1 // 初始化答案陣列\n→ Step 2: ans[0] ← 0 // 0 的二進位 1 的數量為 0\n→ Decision: n 是否大於 0? // 判斷是否需要執行迴圈\n    Yes → Step 3: 對 i 從 1 到 n 執行\n        → Step 3a: ans[i] ← ans[i >> 1] + (i & 1) // 先取得 i 的右移一位的 popcount，再加上最低位\n    No  → // 不執行任何迴圈\n→ Step 4: 回傳 ans // 回傳結果陣列\nEnd // 程式結束\n\nBut need each line separate. For nested steps we can indent or just separate lines. The format requires each line is separate with \"虛擬碼步驟\" and explanation. Indentation optional. Use arrow. For decisions, we need Yes → and No →. So for the decision we need two lines: Decision: n 大於 0? // 判斷是否需要執行迴圈, then Yes → Step 3: ... and No  → // nothing.\n\nBut we can't have \"Step 3a\" as nested inside \"Yes →\". We can produce separate line \"Yes → Step 3: ...\", then next line maybe indent for inner loop. But the format may require each line with arrow. Use \"→\" inside the step. Example:\n\nYes → Step 3: for i from 1 to n\n    → Step 3a: ans[i] ← ans[i >> 1] + (i & 1)\n\nAlternatively, we can just have:\n\nYes → Step 3: for i from 1 to n\n→ Step 3a: ans[i] ← ans[i >> 1] + (i & 1)\n\nBut need to maintain hierarchy.\n\nSimplify: Use Decision: if n > 0? Then inside Yes, we include the loop as separate steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 ans 陣列，大小為 n+1 // 初始化答案陣列\n→ Step 2: ans[0] ← 0 // 0 的二進位 1 的數量為 0\n→ Decision: n 大於 0? // 判斷是否需要執行迴圈\n    Yes → Step 3: 對 i 從 1 到 n 執行\n        → Step 3a: ans[i] ← ans[i >> 1] + (i & 1) // 先取得 i 右移一位的 popcount，再加上最低位的 1\n    No  → // 若 n 為 0，則跳過迴圈\n→ Step 4: 回傳 ans // 回傳整個答案陣列\nEnd // 程式結束執行",
      "generated_code": "import sys\n\ndef count_bits(n: int):\n    \"\"\"Return a list where result[i] is the number of 1's in the binary representation of i.\"\"\"\n    res = [0] * (n + 1)\n    for i in range(1, n + 1):\n        res[i] = res[i >> 1] + (i & 1)\n    return res\n\ndef parse_input(data: str) -> int:\n    \"\"\"Parse the input string and extract the integer n.\"\"\"\n    data = data.strip()\n    if not data:\n        return 0\n    # If the input contains 'n =', extract the part after '='\n    if '=' in data:\n        parts = data.split('=')\n        n_part = parts[-1].strip()\n        return int(n_part)\n    # Otherwise, assume the whole string is the integer\n    return int(data)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    n = parse_input(raw_input)\n    result = count_bits(n)\n    # Output without spaces as shown in the examples\n    output = '[' + ','.join(str(x) for x in result) + ']'\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,1]",
          "success": true,
          "output": "[0,1,1]"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[0,1,1,2,1,2]",
          "success": true,
          "output": "[0,1,1,2,1,2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode757.json",
    "problem_index_in_file": 0,
    "title": "Set Intersection Size At Least Two",
    "description_snippet": "You are given a 2D integer array intervals where intervals[i] = [starti, endi] represents all the in...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output a virtual code algorithm for solving the problem: minimum size of a containing set for intervals. The classic greedy: sort intervals by end ascending; maintain last two selected numbers; for each interval, check how many selected numbers within [start,end], if >=2 do nothing; else need to add one or two numbers starting from end downward, ensuring no overlap with previous selected.\n\nLet's produce step-by-step pseudocode with decision nodes and arrows. Must include Start, End. Use \"Step X\" etc. Provide explanation after //.\n\nWe need to output line by line. Each line: virtual code step + space + // explanation. Use arrows and decisions.\n\nLet's design algorithm:\n\n1. Sort intervals by end ascending.\n2. Initialize empty set selectedNumbers.\n3. For each interval [start, end] in sorted intervals:\n    a. Count how many numbers from selectedNumbers are within [start, end].\n    b. If count >= 2: continue.\n    c. If count == 1:\n        i. Add end to selectedNumbers.\n    d. If count == 0:\n        i. Add end-1 and end to selectedNumbers.\n4. Return size of selectedNumbers.\n\nBut need to ensure we don't duplicate numbers: if end-1 already in set, but count 0 ensures none in interval. So end-1 not in interval. So okay.\n\nWe can also maintain last two numbers for efficiency: last1, last2. But we can keep set.\n\nLet's produce pseudocode with decisions.\n\nWe'll produce lines:\n\nStart\n→ Step 1: Sort intervals by ascending end // 將區間依結束點排序\n→ Step 2: Initialize empty list selected // 建立空集合儲存選取的數字\n→ For each interval [s, e] in intervals: // 逐個處理區間\n    → Step 3: Count selected numbers within [s, e] // 取出已選數字中在此區間的個數\n    → Decision: If count >= 2? // 已滿足至少兩個需求\n        Yes → Step 4: Continue // 跳過此區間\n        No  → Decision: If count == 1? // 只剩一個\n            Yes → Step 5: Add e to selected // 加入結束點\n            No  → Step 6: Add e-1 and e to selected // 加入兩個數字\n→ Step 7: Return size of selected // 返回集合大小\nEnd\n\nBut need arrow formatting: maybe \"→ Decision:\" and nested arrows.\n\nUse indentation? Provided example uses indentation inside decision. We'll follow same.\n\nAlso, we need to add explanation comments for each line.\n\nLet's produce each line.\n\nAlso, we may need to ensure we use the arrow after decision: \"Yes →\" etc.\n\nWe'll produce:\n\nStart // 程式開始執行\n\n→ Step 1: Sort intervals by end ascending // 將區間按照結束點遞增排序\n\n→ Step 2: Initialize empty set selectedNumbers // 建立空集合用於儲存選取的整數\n\n→ For each interval [start, end] in intervals: // 逐個處理每個區間\n\n    → Step 3: Count cnt = number of elements in selectedNumbers that lie between start and end // 計算已選數字中落在此區間的個數\n\n    → Decision: cnt >= 2? // 是否已至少兩個數字\n\n        Yes → Step 4: Continue to next interval // 已滿足，跳過\n\n        No  → Decision: cnt == 1? // 只剩一個\n\n            Yes → Step 5: Add end to selectedNumbers // 加入結束點確保兩個\n\n            No  → Step 6: Add end-1 and end to selectedNumbers // 兩個都不在區間，加入兩個以保證至少兩個\n\n→ Step 7: Return size of selectedNumbers // 輸出最小集合大小\n\nEnd // 程式執行結束\n\nCheck formatting: Each line must be \"虛擬碼步驟\" space \"// 解釋\". Yes.\n\nThe lines with indentation may be included but should be separate lines. We need to include the indentation spaces. In example, they used spaces before lines inside decision. So we will follow.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort intervals by end ascending // 將區間依結束點遞增排序  \n→ Step 2: Initialize empty set selectedNumbers // 建立空集合用於儲存選取的整數  \n→ For each interval [start, end] in intervals: // 逐個處理每個區間  \n    → Step 3: Count cnt = number of elements in selectedNumbers that lie between start and end // 計算已選數字中落在此區間的個數  \n    → Decision: cnt >= 2? // 是否已至少兩個數字  \n        Yes → Step 4: Continue to next interval // 已滿足，跳過  \n        No  → Decision: cnt == 1? // 只剩一個  \n            Yes → Step 5: Add end to selectedNumbers // 加入結束點確保兩個  \n            No  → Step 6: Add end-1 and end to selectedNumbers // 兩個都不在區間，加入兩個以保證至少兩個  \n→ Step 7: Return size of selectedNumbers // 輸出最小集合大小  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def intersectionSizeTwo(self, intervals):\n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        res = []\n        last, second_last = -1, -1\n        for start, end in intervals:\n            count = 0\n            if start <= second_last <= end:\n                count += 1\n            if start <= last <= end:\n                count += 1\n            if count >= 2:\n                continue\n            elif count == 1:\n                res.append(end)\n                second_last, last = last, end\n            else:\n                res.extend([end - 1, end])\n                second_last, last = end - 1, end\n        return len(res)\n\ndef parse_intervals(input_str: str):\n    input_str = input_str.strip()\n    if not input_str:\n        return []\n    start = input_str.find('[')\n    if start == -1:\n        return []\n    try:\n        intervals = ast.literal_eval(input_str[start:])\n    except Exception:\n        intervals = []\n    return intervals\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    intervals = parse_intervals(data)\n    solution = Solution()\n    result = solution.intersectionSizeTwo(intervals)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[3,7],[8,9]]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,3],[1,4],[2,5],[3,5]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,2],[2,3],[2,4],[4,5]]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode647.json",
    "problem_index_in_file": 0,
    "title": "Palindromic Substrings",
    "description_snippet": "Given a string s, return the number of palindromic substrings in it.\n\nA string is a palindrome when ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. The problem: count palindromic substrings. Use center expansion algorithm. We'll produce steps.\n\nWe need to follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrow arrow, Decision: etc.\n\nWe must avoid actual code. Just virtual steps.\n\nLet's produce:\n\nStart // start\n→ Step 1: Define function countPalindromes(s) // main function\n→ Step 2: Initialize count = 0 // counter for palindromic substrings\n→ Step 3: n = length of s // length of input\n→ Decision: If n == 0? // empty string case\n    Yes → Step 4: Return 0 // no substrings\n    No  → Step 5: For each center index i from 0 to n-1 // iterate over centers\n→ Step 6: ExpandAroundCenter(i, i) // odd-length palindromes\n→ Step 7: ExpandAroundCenter(i, i+1) // even-length palindromes\n→ Decision: Continue next i? // loop control\n    Yes → Go back to Step 5\n    No  → Step 8: Return count // final result\n→ End\n\nWe also need to explain ExpandAroundCenter. We could add separate steps:\n\n→ Step 6: // ExpandAroundCenter function\n    → Step 6.1: left = leftIndex, right = rightIndex\n    → Decision: While left >= 0 and right < n and s[left] == s[right]?\n        Yes → Increment count\n            left--\n            right++\n        No  → Stop expansion\n\nBut we want sequential steps maybe with nested decisions. Let's produce separate steps for expand.\n\nWe need to include steps that are not inside loops? We can produce pseudocode steps. Let's produce as lines with indentation to indicate nested actions.\n\nWe should use \"Decision:\" for ifs and loops. For loops, we can use \"Decision: If i < n?\" etc.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define function CountPalindromicSubstrings(s) // 建立主函式  \n→ Step 2: Initialize count = 0 // 迴圈計數器，用來統計所有回文子字串  \n→ Step 3: n = length of s // 取得字串長度  \n→ Decision: 若 n == 0? // 空字串特例  \n    Yes → Step 4: Return 0 // 沒有子字串可計算  \n    No → Step 5: For i = 0 to n-1 // 遍歷每個字符作為中心  \n→ Decision: i < n? // 控制迴圈進行  \n    Yes → Step 6: ExpandAroundCenter(i, i) // 處理奇數長度回文  \n      → Step 6.1: left = i, right = i  \n      → Decision: left ≥ 0 AND right < n AND s[left] == s[right]?  \n          Yes → Increment count // 找到一個回文子字串  \n                left = left - 1  \n                right = right + 1  \n          No → Skip // 結束此中心擴展  \n    Yes → Step 7: ExpandAroundCenter(i, i+1) // 處理偶數長度回文  \n      → Step 7.1: left = i, right = i+1  \n      → Decision: left ≥ 0 AND right < n AND s[left] == s[right]?  \n          Yes → Increment count // 找到一個回文子字串  \n                left = left - 1  \n                right = right + 1  \n          No → Skip // 結束此中心擴展  \n    Yes → Step 8: i = i + 1 // 前往下一個中心  \n    No → Step 9: Return count // 所有中心處理完畢，回傳總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef count_palindromic_substrings(s: str) -> int:\n    \"\"\"Return the number of palindromic substrings in s.\"\"\"\n    n = len(s)\n    count = 0\n\n    def expand(left: int, right: int) -> None:\n        nonlocal count\n        while left >= 0 and right < n and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n\n    for i in range(n):\n        expand(i, i)       # odd‑length palindromes\n        expand(i, i + 1)   # even‑length palindromes\n\n    return count\n\nif __name__ == \"__main__\":\n    # Read all input and extract the string value.\n    raw_input = sys.stdin.read().strip()\n\n    # Handle two possible input formats:\n    # 1. raw string: abc\n    # 2. assignment style: s = \"abc\"\n    if \"=\" in raw_input:\n        # Take the part after '=' and strip surrounding spaces and quotes.\n        _, value = raw_input.split(\"=\", 1)\n        value = value.strip()\n        if value.startswith('\"') and value.endswith('\"'):\n            s = value[1:-1]\n        elif value.startswith(\"'\") and value.endswith(\"'\"):\n            s = value[1:-1]\n        else:\n            s = value\n    else:\n        s = raw_input\n\n    result = count_palindromic_substrings(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abc\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"aaa\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode846.json",
    "problem_index_in_file": 0,
    "title": "leetcode846_problem_1",
    "description_snippet": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code for the problem: Given hand array and groupSize, can we rearrange into groups of size groupSize with consecutive values. This is Leetcode 846. Algorithm: if hand length % groupSize != 0 return false. Count frequency map of card values. Sort keys. For each key in sorted order, while freq[key] > 0, try to form group starting from key to key+groupSize-1, subtract freq for each; if any missing -> false. Return true.\n\nWe need to produce line-by-line pseudo code with explanations. Use arrow syntax: Start, End, Decision, etc.\n\nWe need to include step lines: Start, Step 1: check length divisible by groupSize, Decision: divisible? Yes -> Step 2: Build frequency map, Step 3: Sort unique values, Step 4: For each val in sorted unique values, Step 5: while freq[val] > 0, Step 6: For i from 0 to groupSize-1, if freq[val+i] exists and >0 subtract, else return false. After loop return true. End.\n\nWe need to produce each line as \"虛擬碼步驟 // 解釋\". We should adhere to arrow usage: \"→ Step 1: ...\" and decisions: \"Decision: ...\" with Yes → and No → branches.\n\nWe should keep it structured and concise. Let's produce.\n\nWe'll output:\n\nStart // 程式開始執行\n→ Step 1: 取得 hand 與 groupSize // 讀取輸入\n→ Decision: (hand.length % groupSize == 0)? // 檢查是否能整除\n    Yes → Step 2: 建立 cardCount 以儲存每張卡的出現次數 // 建構頻率表\n        → For each card in hand: cardCount[card]++ // 計數\n    No  → End // 直接失敗，無法整除\n→ Step 3: 取得並排序 cardCount 的所有鍵值 keyList // 取得所有不同卡值並排序\n→ Step 4: 逐個 key 進行檢查\n    → For each key in keyList:\n        → Decision: (cardCount[key] > 0)? // 若此卡還有剩餘\n            Yes → Step 5: 建立 groupCount = cardCount[key] // 需要處理的組數\n                → While groupCount > 0:\n                    → Decision: (key + groupSize - 1 <= maxKey?) // 確認是否超出最大卡值\n                        Yes → Step 6: 針對 i in 0..groupSize-1:\n                            → Decision: (cardCount[key + i] >= groupCount)? // 是否足夠\n                                Yes → cardCount[key + i] -= groupCount // 減少\n                                No  → End // 缺少卡，無法完成\n                        → groupCount = 0 // 形成完畢\n                    No  → End // 無法形成組\n            No  → Continue // 此卡已經全部被消耗，跳過\n→ End // 所有卡都能被分組，返回 true\n\nBut we need to use \"→ Decision:\" syntax with Yes→ and No→ lines. We need to output each line.\n\nWe should use minimal lines.\n\nLet's structure:\n\nStart\n→ Step 1: 如果 hand.length % groupSize != 0 → End // 無法整除\n→ Step 2: 建立頻率表 cardCount\n→ Step 3: 取得所有鍵並排序為 sortedKeys\n→ Decision: sortedKeys 為空？ No → End // no cards\n→ Step 4: 逐鍵檢查\n    → For each key in sortedKeys:\n        → Decision: cardCount[key] > 0?\n            Yes → Step 5: 取 groupCnt = cardCount[key]\n                → While groupCnt > 0:\n                    → Decision: 是否存在 key + i for i in 0..groupSize-1?\n                        Yes → Step 6: for i in 0..groupSize-1:\n                            → Decision: cardCount[key + i] >= groupCnt?\n                                Yes → cardCount[key + i] -= groupCnt\n                                No  → End\n                        → groupCnt = 0\n                    No  → End\n            No → Continue\n→ End\n\nBut we must use arrow after each line. Let's produce step by step.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 若 hand.length % groupSize ≠ 0 → End // 無法整除，直接失敗  \n→ Step 2: 建立頻率表 cardCount 以儲存每張卡的出現次數  \n    → For each card in hand: cardCount[card]++ // 計算每張卡的數量  \n→ Step 3: 取得所有不同卡值並排序為 sortedKeys // 方便依升序檢查  \n→ Decision: sortedKeys 是否為空?  \n    No → Step 4: 逐個 key 進行檢查  \n        → For each key in sortedKeys:  \n            → Decision: cardCount[key] > 0?  \n                Yes → Step 5: 取 groupCnt = cardCount[key] // 需要形成的組數  \n                    → While groupCnt > 0:  \n                        → Decision: 連續的 groupSize 張卡是否都存在?  \n                            Yes → Step 6: 對 i 由 0 到 groupSize-1:  \n                                → Decision: cardCount[key + i] ≥ groupCnt?  \n                                    Yes → cardCount[key + i] -= groupCnt // 減少剩餘數量  \n                                    No  → End // 缺少卡，無法完成  \n                            No  → End // 連續卡不完整，無法完成  \n                        → groupCnt = 0 // 形成完畢  \n                No → Continue // 此卡已經被消耗完，跳過  \n    Yes → End // 無卡可處理，直接結束  \n→ End // 所有卡都能被分組，回傳 true",
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isNStraightHand(self, hand, groupSize):\n        \"\"\"Return True if hand can be rearranged into groups of consecutive cards of size groupSize.\"\"\"\n        if len(hand) % groupSize != 0:\n            return False\n\n        count = Counter(hand)\n        for card in sorted(count):\n            freq = count[card]\n            if freq > 0:\n                for i in range(card, card + groupSize):\n                    if count[i] < freq:\n                        return False\n                    count[i] -= freq\n        return True\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form:\n        hand = [1,2,3], groupSize = 3\n    \"\"\"\n    hand_match = re.search(r'hand\\s*=\\s*(\\[[^\\]]*\\])', data)\n    group_match = re.search(r'groupSize\\s*=\\s*(-?\\d+)', data)\n    hand = ast.literal_eval(hand_match.group(1)) if hand_match else []\n    group_size = int(group_match.group(1)) if group_match else 0\n    return hand, group_size\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read()\n    hand, group_size = parse_input(raw_input)\n    result = Solution().isNStraightHand(hand, group_size)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
          "expected_output": "True",
          "success": true,
          "output": "True"
        },
        {
          "example_index": 1,
          "input": "hand = [1,2,3,4,5], groupSize = 4",
          "expected_output": "False",
          "success": true,
          "output": "False"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode88.json",
    "problem_index_in_file": 0,
    "title": "Merge Sorted Array",
    "description_snippet": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, each line with // explanation. Use arrow structure. Problem: merge two sorted arrays into first one. Classic approach: use three pointers from back. We'll produce steps: Start, pointer i=m-1, j=n-1, k=m+n-1. While i>=0 and j>=0, compare nums1[i] and nums2[j], place bigger into nums1[k] decrement accordingly. Then after loop, if j>=0, copy remaining nums2 into nums1. End.\n\nLet's output virtual code. Each step line. We'll include decisions. Use indentation. Use Yes→ and No→. Also we need to handle while loop: Decision: i>=0 and j>=0? Yes→ ... No→ after loop. Then Decision: j>=0? Yes→ copy remaining. No→ nothing.\n\nReturn nothing.\n\nWe'll produce step lines. Let's write.\n\nNote: Use \"Start\" line. Then pointer initialization lines. Then Decision loop.\n\nOk. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 i = m - 1 // 指向 nums1 原始元素最後一個位置  \n→ Step 2: 設定 j = n - 1 // 指向 nums2 最後一個位置  \n→ Step 3: 設定 k = m + n - 1 // 指向 nums1 最後一個可寫位置  \n\n→ Decision: i >= 0 且 j >= 0? // 是否還有元素要比較  \n    Yes → Step 4: 如果 nums1[i] > nums2[j]? // 比較兩個元素大小  \n        Yes → Step 5: nums1[k] = nums1[i] // 把較大的放到最後  \n            → Step 6: i = i - 1 // 移動 i  \n            → Step 7: k = k - 1 // 移動 k  \n        No  → Step 8: nums1[k] = nums2[j] // 把 nums2 的元素放到最後  \n            → Step 9: j = j - 1 // 移動 j  \n            → Step 10: k = k - 1 // 移動 k  \n    No  → Decision: j >= 0? // 是否還有 nums2 的元素未複製  \n        Yes → Step 11: nums1[k] = nums2[j] // 複製剩餘的 nums2 元素  \n            → Step 12: j = j - 1 // 移動 j  \n            → Step 13: k = k - 1 // 移動 k  \n            → Decision: j >= 0? // 檢查是否還有剩餘  \n                Yes → Step 11 (loop) // 重新執行第 11 步  \n                No  → End // 結束合併  \n        No  → End // 合併完成，所有元素已在 nums1  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        將兩個已排序的陣列 nums1、nums2 合併進入 nums1。\n        nums1 的長度為 m + n，前 m 個位置已填充有效元素，後 n 個位置為 0。\n        \"\"\"\n        i = m - 1          # nums1 原始元素的最後一個指標\n        j = n - 1          # nums2 最後一個指標\n        k = m + n - 1      # nums1 可寫的最後一個指標\n\n        # 從後往前比較，將較大的元素放到 nums1 的最後\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n\n        # 如果 nums2 還有剩餘元素，直接拷貝過來\n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n\n    # 取得兩個陣列字串\n    array_strs = re.findall(r'\\[.*?\\]', data)\n    if len(array_strs) < 2:\n        raise ValueError(\"輸入中缺少陣列定義\")\n\n    nums1 = eval(array_strs[0])   # 轉成 Python list\n    nums2 = eval(array_strs[1])\n\n    # 取得 m 和 n 的值\n    m_match = re.search(r'm\\s*=\\s*(\\d+)', data)\n    n_match = re.search(r'n\\s*=\\s*(\\d+)', data)\n    if not m_match or not n_match:\n        raise ValueError(\"輸入中缺少 m 或 n 的定義\")\n\n    m = int(m_match.group(1))\n    n = int(n_match.group(1))\n\n    # 執行合併\n    sol = Solution()\n    sol.merge(nums1, m, nums2, n)\n\n    # 輸出結果\n    print(nums1)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "expected_output": "[1,2,2,3,5,6]",
          "success": true,
          "output": "[1, 2, 2, 3, 5, 6]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1009.json",
    "problem_index_in_file": 0,
    "title": "Complement of Base 10 Integer",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps to compute complement of integer n. We must do line by line with arrow. We need to explain each line briefly. So produce steps: Start, Step 1: Input n, Step 2: Determine number of bits needed (i.e., find highest bit position). Step 3: Create mask with all 1's for that bit length. Step 4: Complement = n XOR mask. Step 5: Return complement. End. Use Decision? Might not need decision. But we can illustrate maybe decision to check n > 0? Actually we could just handle zero separately: complement of 0? Usually for 0 complement is 1? Wait if binary representation of 0 is \"0\", complement \"1\" which is 1. So we can handle separately. We'll include Decision: if n==0? then complement = 1. Else compute. Provide virtual code. Use arrow indentation. Provide explanation comments. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入整數 n // 從使用者取得需要取反的數字  \n→ Decision: 如果 n 等於 0? // 處理特殊情況，因為 0 的二進位表示為 \"0\"  \n  Yes → Step 2: 設定 complement = 1 // 0 的補碼為 1  \n  No  → Step 3: 取得 n 的最高位數字位數位 (bitLength)  \n    // 以位元左移的方式找出最高有效位  \n    bitLength = 1  \n    while (n >> bitLength) > 0  \n     bitLength ← bitLength + 1  \n    // bitLength 現在是 n 的二進位位數  \n→ Step 4: 建立遮罩 mask = (1 << bitLength) - 1  \n  // mask 會是 1 在所有 n 位元位置上（例如 5 位時 mask = 0b11111）  \n→ Step 5: 計算 complement = n XOR mask  \n  // XOR 會將每一位 0 變成 1，1 變成 0，得到補碼  \n→ Step 6: 回傳 complement // 將結果送回呼叫者  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        # Special case for 0\n        if n == 0:\n            return 1\n        # Determine the number of bits needed to represent n\n        bit_length = n.bit_length()\n        # Create a mask with all bits set to 1 for that length\n        mask = (1 << bit_length) - 1\n        # XOR with the mask flips all bits\n        return n ^ mask\n\ndef main() -> None:\n    # Read the entire input (e.g., \"n = 5\")\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the first integer found in the input\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n\n    solution = Solution()\n    result = solution.bitwiseComplement(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 10",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode712.json",
    "problem_index_in_file": 0,
    "title": "Minimum ASCII Delete Sum for Two Strings",
    "description_snippet": "Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for the problem: given two strings s1 and s2, find the minimum ASCII sum of deleted characters to make them equal. Classic DP problem: minimal cost to delete characters to equalize two strings: similar to shortest common supersequence? Actually we can think of editing: we can delete characters only. So we want to find longest common subsequence (LCS) with minimal deletion cost. For each character not in LCS, we delete it. So cost = sum of ASCII of all chars in s1 + sum of all chars in s2 - 2 * sum of ASCII of LCS. But easier to compute DP: dp[i][j] minimal cost for s1[0..i-1], s2[0..j-1]. Recurrence: if s1[i-1]==s2[j-1], dp[i][j] = dp[i-1][j-1] (no deletion). Else dp[i][j] = min(dp[i-1][j] + ASCII(s1[i-1]), dp[i][j-1] + ASCII(s2[j-1])).\n\nWe need virtual code line by line with explanation. Provide Start, then steps. Provide arrows. Use proper indentation? The format sample uses indentation for decisions. Provide lines.\n\nLet's produce virtual code: Start, Input strings, Compute lengths, Initialize DP table, Fill first row/col, iterate, compute recurrence, End, output dp[n][m].\n\nUse arrow lines: → Step: description. Use Decision: for conditional. Provide Yes → etc. But we can use simple loops. Provide Decision: if char equal? etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s1, s2 // 取得兩個要比較的字串  \n→ n ← length of s1 // 取得 s1 的長度  \n→ m ← length of s2 // 取得 s2 的長度  \n→ Create 2D array dp[0…n][0…m] // 建立 DP 表格  \n→ For i from 0 to n: dp[i][0] ← sum of ASCII values of s1[0…i-1] // 只刪除 s1 的前 i 個字元  \n→ For j from 0 to m: dp[0][j] ← sum of ASCII values of s2[0…j-1] // 只刪除 s2 的前 j 個字元  \n→ For i from 1 to n: // 逐行遍歷 s1  \n  For j from 1 to m: // 逐列遍歷 s2  \n   Decision: s1[i-1] == s2[j-1] // 兩個字元相同嗎？  \n    Yes → dp[i][j] ← dp[i-1][j-1] // 不需要刪除，保持目前的最小成本  \n    No → Decision: dp[i-1][j] + ASCII(s1[i-1]) < dp[i][j-1] + ASCII(s2[j-1]) // 哪個刪除更便宜？  \n     Yes → dp[i][j] ← dp[i-1][j] + ASCII(s1[i-1]) // 刪除 s1 的第 i 個字元  \n     No  → dp[i][j] ← dp[i][j-1] + ASCII(s2[j-1]) // 刪除 s2 的第 j 個字元  \n→ result ← dp[n][m] // 最終答案存於 dp[n][m]  \n→ Output result // 顯示最低 ASCII 刪除總和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        # 初始化第一列：只從 s1 刪除字符\n        for i in range(1, m + 1):\n            dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\n\n        # 初始化第一行：只從 s2 刪除字符\n        for j in range(1, n + 1):\n            dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\n\n        # DP 迭代\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(\n                        dp[i - 1][j] + ord(s1[i - 1]),\n                        dp[i][j - 1] + ord(s2[j - 1])\n                    )\n        return dp[m][n]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 嘗試從輸入中提取兩個字符串，支持單引號或雙引號\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) < 2:\n        matches = re.findall(r\"'([^']*)'\", data)\n    if len(matches) < 2:\n        # 如果還沒提取到，嘗試分行處理\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        strings = []\n        for line in lines:\n            if '=' in line:\n                _, val = line.split('=', 1)\n                val = val.strip()\n                if val.startswith('\"') and val.endswith('\"'):\n                    strings.append(val[1:-1])\n                elif val.startswith(\"'\") and val.endswith(\"'\"):\n                    strings.append(val[1:-1])\n        matches = strings\n\n    if len(matches) >= 2:\n        s1, s2 = matches[0], matches[1]\n    else:\n        # 如果還沒有成功，直接將整個輸入當作第一個字符串，第二個為空\n        s1 = data.strip()\n        s2 = \"\"\n\n    result = Solution().minimumDeleteSum(s1, s2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"sea\", s2 = \"eat\"",
          "expected_output": "231",
          "success": true,
          "output": "231"
        },
        {
          "example_index": 1,
          "input": "s1 = \"delete\", s2 = \"leet\"",
          "expected_output": "403",
          "success": true,
          "output": "403"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode640.json",
    "problem_index_in_file": 0,
    "title": "Solve the Equation",
    "description_snippet": "Solve a given equation and return the value of 'x' in the form of a string \"x=#value\". The equation ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving linear equation with + - operations and variable x and its coefficient. Format: each line: 虛擬碼步驟 [space] // 解釋. Use Start, End, Decision etc. We must not output actual code.\n\nWe need to produce algorithm steps: parse equation string, compute total coefficient of x and constant term. Then check: if coefficient ==0 and constant==0 => infinite solutions; if coefficient==0 and constant!=0 => no solution; else x = -constant / coefficient, integer. Output string.\n\nNeed to include handling of signs, spaces, negative numbers.\n\nBut we need to generate virtual code. So lines like:\n\nStart // start\n\n→ Step 1: Initialize coeff = 0, constant = 0 // set accumulators\n\n→ Step 2: Split equation by '=' into left and right sides // isolate sides\n\n→ Decision: if left side contains 'x' ... etc\n\nBut we can do simpler: For each side, parse terms separated by + or -. Use a sign variable.\n\nPseudo:\n\n- Function parseSide(side): iterate chars, build term.\n\n- Determine if term contains 'x': then coefficient = numeric part or 1 if only 'x'; else constant = numeric value.\n\n- For right side, we subtract terms from left by moving to left side: e.g., add coefficient and constant with opposite sign.\n\nSimplify: After parsing both sides, we compute net coefficient and constant: netCoeff = coeffLeft - coeffRight; netConst = constRight - constLeft? Wait better: equation: left = right. Move all terms to left: leftCoeff - rightCoeff etc.\n\nActually: Let's compute leftCoeffs, leftConsts, rightCoeffs, rightConsts. Then netCoeff = leftCoeff - rightCoeff, netConst = rightConst - leftConst? Wait bring constants to RHS: left = right => leftCoeff*x + leftConst = rightCoeff*x + rightConst => (leftCoeff - rightCoeff)*x = rightConst - leftConst. So netCoeff = leftCoeff - rightCoeff; netConst = rightConst - leftConst. Then solve.\n\nOk.\n\nNow produce virtual steps: Start, Step 1 parse left side, Step 2 parse right side, Step 3 compute netCoeff, netConst, Step 4 decision coefficient zero etc.\n\nNeed to explain each line.\n\nLet's generate lines:\n\nStart // 開始執行\n\n→ Step 1: Split equation string at '=' into LHS and RHS // 取得左右兩邊\n\n→ Step 2: Parse side function to accumulate coeff and const // 處理單一側\n\n→ Step 3: Call parseSide(LHS) → (coeffL, constL) // 解析左側\n\n→ Step 4: Call parseSide(RHS) → (coeffR, constR) // 解析右側\n\n→ Step 5: Compute netCoeff = coeffL - coeffR // 移項得到x係數\n\n→ Step 6: Compute netConst = constR - constL // 移項得到常數\n\n→ Decision: 如果 netCoeff == 0? // 判斷係數為零\n\n    Yes → Decision: 如果 netConst == 0? // 同時常數為零\n\n        Yes → Step 7: Output \"Infinite solutions\" // 無限多解\n\n        No  → Step 8: Output \"No solution\" // 無解\n\n    No  → Step 9: 計算 x = -netConst / netCoeff // 求解x值\n\n→ Step 10: Output \"x=\" + x // 以字串形式返回\n\nEnd // 執行結束\n\nBut we need to also mention that parseSide handles terms: maybe separate steps inside parseSide. But we can mention as step: parseSide details: iterate characters, track sign, term value, detect 'x', etc. Might be too long, but we can keep high-level.\n\nWe need to adhere to format: Each line has arrow if step. Should we use \"→\" for steps. For decisions, use \"Decision:\" lines with Yes → and No → lines. Also End line.\n\nEnsure each line ends with // explanation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Split equation string at '=' into LHS and RHS // 取得等號左右兩邊  \n→ Step 2: 定義 parseSide(side) → (coeff, const) // 解析單一側並回傳係數與常數  \n→ Step 3: 呼叫 parseSide(LHS) → (coeffL, constL) // 解析左側  \n→ Step 4: 呼叫 parseSide(RHS) → (coeffR, constR) // 解析右側  \n→ Step 5: 計算 netCoeff = coeffL - coeffR // 移項得到 x 的係數  \n→ Step 6: 計算 netConst = constR - constL // 移項得到等號右邊的常數  \n→ Decision: 如果 netCoeff == 0? // 判斷是否存在 x 的係數  \n    Yes → Decision: 如果 netConst == 0? // 同時檢查常數是否為零  \n        Yes → Step 7: Output \"Infinite solutions\" // 無限多解  \n        No  → Step 8: Output \"No solution\" // 無解  \n    No  → Step 9: 計算 x = -netConst / netCoeff // 求解唯一解（整數）  \n→ Step 10: Output \"x=\" + x // 以字串形式返回解  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def solveEquation(self, equation: str) -> str:\n        # 解析單一側的係數與常數\n        def parse_side(s: str):\n            x_coeff, const = 0, 0\n            i, n, sign = 0, len(s), 1\n            while i < n:\n                if s[i] == '+':\n                    sign = 1\n                    i += 1\n                elif s[i] == '-':\n                    sign = -1\n                    i += 1\n                else:\n                    j = i\n                    while j < n and s[j] not in '+-':\n                        j += 1\n                    token = s[i:j]\n                    if 'x' in token:\n                        coeff_part = token[:-1]\n                        if coeff_part == '' or coeff_part == '+':\n                            coeff = 1\n                        elif coeff_part == '-':\n                            coeff = -1\n                        else:\n                            coeff = int(coeff_part)\n                        x_coeff += sign * coeff\n                    else:\n                        const += sign * int(token)\n                    i = j\n            return x_coeff, const\n\n        left, right = equation.split('=')\n        left_x, left_const = parse_side(left)\n        right_x, right_const = parse_side(right)\n\n        # 把右側項移到左側\n        total_x = left_x - right_x\n        total_const = right_const - left_const\n\n        if total_x == 0:\n            if total_const == 0:\n                return \"Infinite solutions\"\n            else:\n                return \"No solution\"\n        else:\n            return f\"x={total_const // total_x}\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 允許輸入形式為 'equation = \"x+5-3+x=6+x-2\"' 或直接給出等式\n    if data.startswith('equation'):\n        first_quote = data.find('\"')\n        last_quote = data.rfind('\"')\n        if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n            equation = data[first_quote + 1:last_quote]\n        else:\n            # 若找不到引號，嘗試去掉前綴\n            parts = data.split('=', 1)\n            equation = parts[1].strip() if len(parts) > 1 else data\n    else:\n        equation = data\n\n    solution = Solution()\n    result = solution.solveEquation(equation)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "equation = \"x+5-3+x=6+x-2\"",
          "expected_output": "x=2",
          "success": true,
          "output": "x=2"
        },
        {
          "example_index": 1,
          "input": "equation = \"x=x\"",
          "expected_output": "Infinite solutions",
          "success": true,
          "output": "Infinite solutions"
        },
        {
          "example_index": 2,
          "input": "equation = \"2x=x\"",
          "expected_output": "x=0",
          "success": true,
          "output": "x=0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode128.json",
    "problem_index_in_file": 0,
    "title": "Longest Consecutive Sequence",
    "description_snippet": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Traditional Chinese, each line with virtual code step and explanation after //.\n\nWe need to produce an O(n) algorithm: typical solution uses hash set to store elements, iterate, for each number check if it's start of sequence (num-1 not in set), then expand to count consecutive. Complexity O(n).\n\nWe need to produce step-by-step pseudo-code.\n\nWe should use Start, End, Decision, etc. Provide each line step. Also arrow. Use indentation maybe not required, but we can show with spaces.\n\nWe need to ensure each line has \"虛擬碼步驟 [space] // 解釋\". Use arrow \"→\".\n\nOk. We'll produce:\n\nStart // 程式開始執行\n→ Step 1: 建立一個 HashSet<int> set // 將所有數字加入集合，方便 O(1) 查找\n→ Step 2: 取集合的所有元素作為迴圈遍歷 // 遍歷每個數字以檢查是否為序列起點\n→ Decision: 如果 set 內不包含 num-1? // 判斷 num 是否為連續序列的開始\n    Yes → Step 3: 設定 currentNum = num, currentStreak = 1 // 初始化目前序列長度\n    → Decision: 如果 set 內包含 currentNum + 1? // 檢查序列是否繼續\n        Yes → Step 4: currentNum = currentNum + 1, currentStreak = currentStreak + 1, // 延伸序列\n        No → Step 5: 记录 longestStreak = max(longestStreak, currentStreak) // 更新最大長度\n        // Loop back to Decision: if set 內包含 currentNum + 1?\n    No → Step 6: // 不是序列起點，直接忽略\nEnd // 程式執行結束\n\nBut we need to make loops: for each num, we might have nested while loop until no next. So use Step 4 inside a while.\n\nBetter:\n\n→ Step 3: if set does not contain num-1 → then\n    → Step 4: current = num\n    → Step 5: streak = 0\n    → Decision: while set contains current? // keep extending\n        Yes → Step 6: streak += 1\n        → Step 7: current += 1\n        No → Step 8: longest = max(longest, streak)\n    No → Step 9: // skip\n\nBut need to use Decision for while? Could use while decision: while set contains current? Yes: Step; else break.\n\nBut we can keep a while loop as Decision: while set contains current? yes.\n\nOk produce pseudo-code accordingly.\n\nWe need to include variable declarations: longest = 0.\n\nBetter produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 HashSet<int> set ← nums // 將陣列元素放入集合\n→ Step 2: longest ← 0 // 用來記錄最大連續序列長度\n→ Step 3: 針對每個 num in set 進行迴圈 // 遍歷集合\n    → Decision: 如果 set 不包含 num-1? // 判斷是否為序列起點\n        Yes → Step 4: current ← num // 初始化目前數字\n        → Step 5: streak ← 0 // 初始化序列長度\n        → Decision: while set 包含 current? // 只要能往前延伸就繼續\n            Yes → Step 6: streak ← streak + 1 // 累計長度\n            → Step 7: current ← current + 1 // 移動到下一個數字\n            No  → Step 8: longest ← max(longest, streak) // 更新最大長度\n        No  → Step 9: // 不是起點，跳過\nEnd // 程式執行結束\n\nBut need arrow formatting: Use \"→\" preceding each step. For nested decisions, indent maybe.\n\nLet's craft final answer accordingly.\n\nAlso note: The pseudo-code arrow may be \"→\" preceding step, not \"→ Decision: ...\".\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 HashSet<int> set ← nums // 將陣列元素放入集合\n→ Step 2: longest ← 0 // 初始化最大連續序列長度\n→ Step 3: 針對每個 num in set 進行迴圈 // 遍歷集合中的每個數字\n    → Decision: 如果 set 不包含 num-1? // 判斷 num 是否為序列的起始點\n        Yes → Step 4: current ← num // 設定目前數字為起點\n        → Step 5: streak ← 0 // 初始化該序列長度\n        → Decision: while set 包含 current? // 只要能繼續往後，延伸序列\n            Yes → Step 6: streak ← streak + 1 // 序列長度加一\n            → Step 7: current ← current + 1 // 移至下一個數字\n            No  → Step 8: longest ← max(longest, streak) // 更新最大長度\n        No  → Step 9: // 若不是起點，直接忽略\nEnd // 程式執行結束\n\nNeed to ensure each line has \"虛擬碼步驟\" and comment after //. But lines for nested decisions: We should still put \"Decision:\" with indentation and comment. Each line includes step or decision with comment. Good.\n\nBut we need to ensure each line ends with // 解釋. So for nested decision lines, we add comment after //.\n\nAlso each line should have a single step. Indentation can be done via spaces before the line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 HashSet<int> set ← nums // 將陣列元素放入集合，方便 O(1) 查找  \n→ Step 2: longest ← 0 // 初始化最大連續序列長度  \n→ Step 3: 針對每個 num in set 進行迴圈 // 遍歷集合中的每個數字  \n  → Decision: 如果 set 不包含 num-1? // 判斷 num 是否為序列的起始點  \n   Yes → Step 4: current ← num // 設定目前數字為起點  \n    → Step 5: streak ← 0 // 初始化該序列長度  \n    → Decision: while set 包含 current? // 只要能繼續往後，延伸序列  \n     Yes → Step 6: streak ← streak + 1 // 序列長度加一  \n      → Step 7: current ← current + 1 // 移至下一個數字  \n     No  → Step 8: longest ← max(longest, streak) // 更新最大長度",
      "generated_code": "import sys\nimport ast\n\ndef longest_consecutive(nums):\n    \"\"\"返回陣列中連續整數序列的最大長度，時間複雜度 O(n)\"\"\"\n    if not nums:\n        return 0\n    num_set = set(nums)\n    longest = 0\n    for num in num_set:\n        # 只從序列起點開始計算\n        if num - 1 not in num_set:\n            current = num\n            length = 1\n            while current + 1 in num_set:\n                current += 1\n                length += 1\n            if length > longest:\n                longest = length\n    return longest\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        return\n\n    # 若輸入中包含等號，提取等號右側的部分\n    if '=' in data:\n        _, part = data.split('=', 1)\n        part = part.strip()\n    else:\n        part = data\n\n    try:\n        # 嘗試使用 literal_eval 解析列表字面量\n        nums = ast.literal_eval(part)\n        if not isinstance(nums, list):\n            raise ValueError\n    except Exception:\n        # 若解析失敗，嘗試按空白或逗號分割並轉成整數\n        nums = [int(x) for x in part.replace(',', ' ').split()]\n\n    result = longest_consecutive(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [100,4,200,1,3,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 2,
          "input": "nums = [1,0,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode56.json",
    "problem_index_in_file": 0,
    "title": "Merge Intervals",
    "description_snippet": "Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals, ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code step-by-step. Provide each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" for steps, Decision etc. Use Start and End. Need to produce algorithm for merging intervals. Steps: sort by start, iterate, merge.\n\nWe need to provide each step line. Let's write like:\n\nStart // 程式開始執行\n→ Step 1: 將 intervals 按 start 升序排序 // 排序以便比較相鄰區間\n→ Step 2: 初始化 merged 為空列表 // 用於儲存合併後區間\n→ Step 3: 循環遍歷排序後的 intervals // 對每個區間進行處理\n    → Decision: merged 是否為空 或 intervals[i].start > merged[-1].end? // 判斷是否需要新建區間\n        Yes → Step 4: 將 intervals[i] 添加到 merged // 無重疊，直接加入\n        No  → Step 5: 更新 merged[-1].end 為 max(merged[-1].end, intervals[i].end) // 有重疊，合併區間\n→ Step 6: 回傳 merged // 返回合併後結果\nEnd // 程式執行結束\n\nBut need to ensure each line has arrow for steps. For decision lines use Decision: 以 Yes → Step etc. Provide each line. Use \"→\" for each step line. For decisions, use indentation with \"Decision:\" and sub-steps.\n\nAlso we need to be careful to include \"Start\" and \"End\".\n\nMake sure each line has a single virtual code step, not multiple. For example, \"Step 1: ...\" is one line. Then next line \"→ Step 2: ...\" etc.\n\nBut the decision line might need to be separate line? The example shows:\n\nDecision: 如果數字大於 0? \n    Yes → Step 2...\n    No  → Decision: ...\n\nSo we can mimic that.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: 將 intervals 按 start 升序排序 // 排序以便後續比較\n→ Step 2: 初始化 merged 為空列表 // 用來儲存合併後的區間\n→ Step 3: 從左到右遍歷排序後的 intervals // 處理每個區間\n    → Decision: merged 是否為空 或 intervals[i].start > merged[-1].end? // 判斷是否需要新區間\n        Yes → Step 4: 將 intervals[i] 追加到 merged // 無重疊，直接加入\n        No  → Step 5: 更新 merged[-1].end 為 max(merged[-1].end, intervals[i].end) // 有重疊，合併區間\n→ Step 6: 回傳 merged // 回傳合併後結果\nEnd // 程式執行結束\n\nWe must ensure indentation for decision lines. Provide each line as separate line. In the answer, keep the lines exactly as needed. Use the same arrow formatting. Provide all. Done.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 intervals 按 start 升序排序 // 排序以便後續比較  \n→ Step 2: 初始化 merged 為空列表 // 用來儲存合併後的區間  \n→ Step 3: 從左到右遍歷排序後的 intervals // 處理每個區間  \n  → Decision: merged 是否為空 或 intervals[i].start > merged[-1].end? // 判斷是否需要新區間  \n   Yes → Step 4: 將 intervals[i] 追加到 merged // 無重疊，直接加入  \n   No  → Step 5: 更新 merged[-1].end 為 max(merged[-1].end, intervals[i].end) // 有重疊，合併區間  \n→ Step 6: 回傳 merged // 回傳合併後結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef merge(intervals):\n    \"\"\"\n    合併重疊的區間，返回不重疊且覆蓋所有輸入區間的新列表。\n    \"\"\"\n    if not intervals:\n        return []\n\n    # 先按起始位置排序，方便相鄰比較\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]  # 用於儲存已合併好的區間\n\n    for current in intervals[1:]:\n        prev = merged[-1]\n        # 若當前區間的起點 <= 已合併區間的結點，則兩者重疊\n        if current[0] <= prev[1]:\n            # 將結點更新為兩者最大的結點\n            prev[1] = max(prev[1], current[1])\n        else:\n            # 無重疊，直接加入列表\n            merged.append(current)\n\n    return merged\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 預期輸入形如 \"intervals = [[1,3],[2,6],[8,10],[15,18]]\"\n    try:\n        # 先把等號前後切開，取等號右側作為表達式\n        parts = data.split('=', 1)\n        if len(parts) == 2:\n            expr = parts[1].strip()\n        else:\n            expr = data\n        intervals = eval(expr, {}, {})\n    except Exception:\n        # 若解析失敗，直接嘗試將整個輸入視為列表表達式\n        intervals = eval(data, {}, {})\n\n    result = merge(intervals)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
          "expected_output": "[[1,6],[8,10],[15,18]]",
          "success": true,
          "output": "[[1, 6], [8, 10], [15, 18]]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,4],[4,5]]",
          "expected_output": "[[1,5]]",
          "success": true,
          "output": "[[1, 5]]"
        },
        {
          "example_index": 2,
          "input": "intervals = [[4,7],[1,4]]",
          "expected_output": "[[1,7]]",
          "success": true,
          "output": "[[1, 7]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode395.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring with At Least K Repeating Characters",
    "description_snippet": "Given a string s and an integer k, return the length of the longest substring of s such that the fre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps with explanation. This is the sliding window approach or divide and conquer. We can use divide and conquer: recursively split on characters with frequency < k. Provide steps.\n\nLet's produce virtual code: Start, read s, k. Then recursive function findLongest(s,l,r). Count frequencies of substring s[l:r], if all freq >= k return r-l. Else find split positions where freq < k, recursively process each segment, return max. Also handle base case.\n\nWe need line-by-line steps, with explanation.\n\nLet's produce:\n\nStart\n→ Step 1: 讀取輸入字串 s 和整數 k // 初始化\n→ Function FindLongest(l, r) // 開始遞迴\n\nWe need to show recursion steps: inside function, count freq, check, find split indices.\n\nWe'll produce virtual code lines. Let's craft.\n\nRemember to use arrows. Each line: \"虛擬碼步驟 // 解釋\"\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 s 和整數 k // 取得要處理的字串與門檻值\n→ Function FindLongest(l, r) // 定義遞迴函式，搜尋 s[l:r]（左閉右開）中的答案\n    → Step 2: 建立長度 26 的頻數陣列 freq // 用於統計字母出現次數\n    → Step 3: 從索引 l 到 r-1 遍歷，更新 freq // 計算子字串中各字母的頻率\n    → Decision: 是否所有 freq[i] 為 0 或 >= k? // 判斷子字串是否已符合條件\n        Yes → Step 4: 回傳 r - l // 子字串長度即為答案\n        No  → Decision: 是否存在任何 freq[i] < k 且 > 0? // 檢查是否有「不合法」字母\n            Yes → Step 5: 找出所有頻率 < k 的字母並標記其位置 splitPositions // 這些字母將作為分割點\n            No  → Step 6: 回傳 0 // 子字串中無合法子字串\n    → Step 7: 初始化 maxLen = 0 // 用於記錄最大子字串長度\n    → Step 8: 以 splitPositions 為界，將 s[l:r] 分割成多段\n        → For 每個段的起點 segStart 與結束 segEnd\n            → Recursively 呼叫 FindLongest(segStart, segEnd) 並取得 len\n            → Decision: len > maxLen?\n                Yes → Step 9: maxLen = len // 更新目前最長長度\n    → Step 10: 回傳 maxLen // 此段子字串的最長合法長度\n→ Step 11: 呼叫 FindLongest(0, s.length) 並存入 result // 對整個字串求解\n→ Step 12: 輸出 result // 顯示最長子字串長度\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def longestSubstring(self, s: str, k: int) -> int:\n        \"\"\"\n        回傳 s 的最大長度子字串，該子字串中每個字母出現次數至少為 k。\n        若不存在符合條件的子字串，回傳 0。\n        \"\"\"\n        # 若整個字串長度不足 k，則不可能有合法子字串\n        if len(s) < k:\n            return 0\n\n        # 統計字串中各字母的頻率\n        freq = Counter(s)\n\n        # 若所有字母的頻率都 >= k，則整個字串即為答案\n        if all(cnt >= k for cnt in freq.values()):\n            return len(s)\n\n        # 找出所有頻率 < k 的字母，作為分割點\n        split_chars = {char for char, cnt in freq.items() if cnt < k}\n\n        # 將字串依照分割點切割，遞迴求每一段的答案\n        max_len = 0\n        start = 0\n        for i, ch in enumerate(s):\n            if ch in split_chars:\n                if i > start:\n                    max_len = max(max_len, self.longestSubstring(s[start:i], k))\n                start = i + 1\n        # 處理最後一段\n        if start < len(s):\n            max_len = max(max_len, self.longestSubstring(s[start:], k))\n\n        return max_len\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料，支援以下兩種格式：\n    1. s = \"aaabb\", k = 3\n    2. <string> <integer>（以空格或換行分隔）\n    \"\"\"\n    # 先嘗試正則式解析 \"s = \"...\", k = ...\"\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\"\\s*,\\s*k\\s*=\\s*(\\d+)', data)\n    if match:\n        return match.group(1), int(match.group(2))\n\n    # 如果沒有匹配，則以空格或換行分割\n    parts = data.replace('\\r', '').splitlines()\n    if len(parts) == 2:\n        s = parts[0].strip()\n        k = int(parts[1].strip())\n    else:\n        tokens = data.split()\n        if len(tokens) >= 2:\n            s = tokens[0]\n            k = int(tokens[1])\n        else:\n            # 無法解析，回傳空字串與 0\n            s, k = '', 0\n    return s, k\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read()\n    s, k = parse_input(raw_input)\n    result = Solution().longestSubstring(s, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aaabb\", k = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"ababbc\", k = 2",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode231.json",
    "problem_index_in_file": 0,
    "title": "Power of Two",
    "description_snippet": "Given an integer n, return true if it is a power of two. Otherwise, return false.\n\nAn integer n is a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with \"虛擬碼步驟 // 解釋\". Steps for algorithm: check if n>0, then n & (n-1)==0. Use decision steps.\n\nWe should output start, then Step 1: Check n > 0, if no, return false. If yes, then Step 2: compute n & (n-1). If result == 0 then true else false. End.\n\nLet's produce line by line with arrows. Use decision nodes.\n\nLet's write:\n\nStart // 程式開始\n→ Decision: n > 0? // 檢查 n 是否大於 0\n    Yes → Step 1: temp ← n & (n - 1) // 取得 n 與 n-1 的按位與\n    Yes → Decision: temp == 0? // 判斷 temp 是否為 0\n        Yes → Step 2: 回傳 true // n 為 2 的次方\n        No  → Step 3: 回傳 false // n 不是 2 的次方\n    No  → Step 4: 回傳 false // n 小於等於 0 時直接回傳 false\nEnd // 程式結束\n\nMake sure each line: \"虛擬碼步驟 // 解釋\".\n\nInclude arrow before each line? The example shows \"→ Step 1\". For decisions we can use \"Decision:\" lines.\n\nWe need to follow exactly: each line with \"虛擬碼步驟 // 解釋\".\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: n > 0? // 檢查 n 是否大於 0  \n  Yes → Step 1: temp ← n & (n - 1) // 計算 n 與 n-1 的按位與  \n  Yes → Decision: temp == 0? // 判斷 temp 是否為 0  \n    Yes → Step 2: 回傳 true // n 是 2 的次方，返回 true  \n    No  → Step 3: 回傳 false // n 不是 2 的次方，返回 false  \n  No  → Step 4: 回傳 false // n 小於等於 0 時直接返回 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        \"\"\"Return True if n is a power of two, else False.\"\"\"\n        if n <= 0:\n            return False\n        return (n & (n - 1)) == 0\n\ndef main() -> None:\n    # 讀取標準輸入並尋找第一個整數\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if match:\n        n = int(match.group())\n    else:\n        # 若找不到整數，視為 0\n        n = 0\n\n    solution = Solution()\n    result = solution.isPowerOfTwo(n)\n    # 按題目要求輸出小寫字串\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode455.json",
    "problem_index_in_file": 0,
    "title": "Assign Cookies",
    "description_snippet": "Assume you are an awesome parent and want to give your children some cookies. But, you should give e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code line by line with explanations. It's essentially the greedy algorithm: sort children greed factors, sort cookie sizes, iterate. For each child, find smallest cookie that satisfies. Count content. Provide virtual code lines with arrow symbols.\n\nWe need \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use Start, End, Decision. Provide line by line. So output must not be actual code but pseudo steps.\n\nLet's write:\n\nStart\n→ Input number of children n and array g[0..n-1]\n→ Input number of cookies m and array s[0..m-1]\n→ Sort g ascending // sort children by greed\n→ Sort s ascending // sort cookies by size\n→ Set i = 0, j = 0, count = 0 // indices for children and cookies\n→ Decision: while i < n and j < m? // still have children and cookies\n    Yes →\n        Decision: if s[j] >= g[i]? // cookie big enough for current child\n            Yes →\n                count = count + 1 // one child content\n                i = i + 1 // move to next child\n                j = j + 1 // cookie used\n            No →\n                j = j + 1 // cookie too small, try next cookie\n    No →\n        End loop\n→ Output count // maximum number of content children\nEnd\n\nWe need each line with arrow and comment. Use 虛擬碼步驟. Should include arrows. Format: \"→ Step 1: ...\" and comments after //.\n\nWe can break loops with Decision. Use proper indentation.\n\nWe must maintain arrow for each step. Provide step numbers? Not necessary, but could. The example used \"Step 1:\" etc. We can keep step names. Provide \"Step 1:\".\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入孩子數量 n 與孩子貪婪值陣列 g[0..n-1] // 從使用者取得孩子的貪婪度  \n→ Step 2: 輸入餅乾數量 m 與餅乾尺寸陣列 s[0..m-1] // 從使用者取得餅乾尺寸  \n→ Step 3: 將 g 陣列升序排序 // 以貪婪度由小到大排列孩子  \n→ Step 4: 將 s 陣列升序排序 // 以尺寸由小到大排列餅乾  \n→ Step 5: 設定 i ← 0, j ← 0, count ← 0 // i: 目前處理的孩子索引，j: 目前考慮的餅乾索引，count: 內容孩子數  \n→ Decision: while i < n AND j < m? // 還有孩子與餅乾可處理  \n    Yes →  \n        Decision: if s[j] >= g[i]? // 目前餅乾尺寸是否足夠滿足目前孩子  \n            Yes →  \n                count ← count + 1 // 此孩子滿足，計數加一  \n                i ← i + 1 // 進入下一個孩子  \n                j ← j + 1 // 這塊餅乾已使用，進入下一塊餅乾  \n            No →  \n                j ← j + 1 // 餅乾太小，嘗試下一塊餅乾  \n    No → End // 當孩子或餅乾已無可處理時結束迴圈  \n→ Step 6: 輸出 count // 顯示最大可滿足的孩子數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findContentChildren(self, g, s):\n        \"\"\"贪婪算法：先排序，再用双指针一次扫描\"\"\"\n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1          # 该孩子被满足\n            j += 1              # 尝试下一块饼干\n        return i                 # 满足的孩子数\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'g = [1,2,3], s = [1,1]' 的输入。\n    使用正则提取两个列表字符串，再用 ast.literal_eval 转成列表。\n    \"\"\"\n    pattern = r'g\\s*=\\s*(\\[.*?\\])\\s*,\\s*s\\s*=\\s*(\\[.*?\\])'\n    match = re.search(pattern, data, re.S)\n    if not match:\n        # 如果输入格式不符合预期，返回空列表\n        return [], []\n    g_str, s_str = match.group(1), match.group(2)\n    g = ast.literal_eval(g_str)\n    s = ast.literal_eval(s_str)\n    return g, s\n\nif __name__ == \"__main__\":\n    # 读取全部标准输入\n    raw_input = sys.stdin.read()\n    g, s = parse_input(raw_input)\n    sol = Solution()\n    result = sol.findContentChildren(g, s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "g = [1,2,3], s = [1,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "g = [1,2], s = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode155.json",
    "problem_index_in_file": 0,
    "title": "Min Stack",
    "description_snippet": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nI...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations, following format. Use Start, End, Decision, etc. We need to design MinStack supporting O(1). We'll present algorithm: use two stacks: main stack and min stack storing min at each push.\n\nWe'll produce steps: initialize stacks, push, pop, top, getMin. But need to show flow of each method, but also overall structure.\n\nWe'll output each step line by line.\n\nProbably include the main class and methods, but only virtual code steps. We'll include decisions: e.g., in pop, check if stack empty. But not necessary.\n\nLet's produce something like:\n\nStart\n→ Step 1: Declare class MinStack // 定義 MinStack 類別\n→ Step 2: Declare stack mainStack // 儲存所有元素\n→ Step 3: Declare stack minStack // 儲存最小值對應\n→ Decision: 初始化時 mainStack 及 minStack 是否空? // 確保兩個堆疊初始化為空\n    Yes → End // 初始化完成\n\nThen push method:\n\n→ Step 4: Function push(val) // 將值加入堆疊\n→ Decision: minStack 為空 OR val ≤ minStack.top()? // 判斷是否需更新 minStack\n    Yes → Step 5: minStack.push(val) // 新最小值\n    No  → Step 5: minStack.push(minStack.top()) // 保持最小值不變\n→ Step 6: mainStack.push(val) // 主堆疊實際推入值\n→ End // push 完成\n\nPop:\n\n→ Step 7: Function pop() // 移除頂部元素\n→ Decision: mainStack 是否空? // 確保堆疊非空\n    Yes → Step 8: mainStack.pop() // 移除主堆疊頂部\n    No  → Step 8: minStack.pop() // 同時移除 minStack 對應\n→ End // pop 完成\n\nBut actually need to pop from both stacks.\n\nTop:\n\n→ Step 9: Function top() // 取得主堆疊頂部\n→ Decision: mainStack 是否空? // 檢查堆疊是否為空\n    Yes → Step 10: Return null 或 error // 空堆疊\n    No  → Step 10: Return mainStack.top() // 返回頂部元素\n→ End // top 完成\n\ngetMin:\n\n→ Step 11: Function getMin() // 取得 minStack 頂部\n→ Decision: minStack 是否空? // 檢查堆疊是否為空\n    Yes → Step 12: Return null 或 error // 空堆疊\n    No  → Step 12: Return minStack.top() // 返回最小值\n→ End // getMin 完成\n\nBut need to maintain consistency: minStack always parallel to mainStack. So pop should pop from both.\n\nOk produce final virtual code.\n\nWe need to output each line with explanation.\n\nLet's format as per example: \"Start // 程式開始執行\". But we might not need a Start and End for whole program? Probably include Start at top, End at bottom.\n\nLet's produce as:\n\nStart // 程式開始執行\n→ Step 1: Define class MinStack // 建立 MinStack 類別\n→ Step 2: Declare stack mainStack // 儲存所有推入的元素\n→ Step 3: Declare stack minStack // 儲存對應的最小值\n→ Decision: 初始化時 mainStack 及 minStack 是否為空? // 確保兩個堆疊初始為空\n    Yes → End // 初始化完成\n\nBut that seems odd: we need to show initialization function.\n\nMaybe better:\n\nStart // 程式開始執行\n→ Step 1: Class MinStack // 宣告 MinStack 類別\n    → Function MinStack() // 建構子\n        → mainStack ← new Stack() // 初始化主堆疊\n        → minStack ← new Stack() // 初始化最小堆疊\n        → End // 建構子結束\n→ End // Class 定義完成\n\nBut this gets more complex. However we can produce simplified pseudo-code: just list methods with steps.\n\nLet's output a clear flow for each method. Use Decision for if.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MinStack 類別 // 宣告一個 MinStack 的類別  \n→ Step 2: 內部宣告 mainStack // 用於儲存所有被推入的值  \n→ Step 3: 內部宣告 minStack // 用於同步儲存每個層級的最小值  \n→ Decision: 建構子是否已呼叫？ // 確保兩個堆疊已經初始化  \n    Yes → End // 建構子結束  \n\nStart // push 方法開始  \n→ Step 4: push(val) // 接收一個整數值  \n→ Decision: minStack 為空 或 val ≤ minStack.top()? // 判斷是否需要更新最小值  \n    Yes → Step 5: minStack.push(val) // 新值是目前最小值，推入 minStack  \n    No  → Step 5: minStack.push(minStack.top()) // 保持前一個最小值，推入 minStack  \n→ Step 6: mainStack.push(val) // 實際將值推入主堆疊  \n→ End // push 完成  \n\nStart // pop 方法開始  \n→ Step 7: pop() // 移除堆疊頂部元素  \n→ Decision: mainStack 是否為空？ // 檢查是否可執行 pop  \n    Yes → Step 8: Return error // 堆疊為空，返回錯誤  \n    No  → Step 8: mainStack.pop() // 移除主堆疊頂部  \n        → Step 9: minStack.pop() // 同步移除 minStack 對應的最小值  \n→ End // pop 完成  \n\nStart // top 方法開始  \n→ Step 10: top() // 取得主堆疊頂部值  \n→ Decision: mainStack 是否為空？  \n    Yes → Step 11: Return error // 堆疊為空，返回錯誤  \n    No  → Step 11: Return mainStack.top() // 返回主堆疊頂部的值  \n→ End // top 完成  \n\nStart // getMin 方法開始  \n→ Step 12: getMin() // 取得目前堆疊中的最小值  \n→ Decision: minStack 是否為空？  \n    Yes → Step 13: Return error // 堆疊為空，返回錯誤  \n    No  → Step 13: Return minStack.top() // 返回 minStack 的頂部，即最小值  \n→ End // getMin 完成  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []          # 主堆疊\n        self.min_stack = []      # 同步儲存最小值的堆疊\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        if self.min_stack and val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self) -> int:\n        if not self.stack:\n            return None\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        if not self.min_stack:\n            return None\n        return self.min_stack[-1]\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 把兩個列表包裝成一個列表方便解析\n    try:\n        commands, args = ast.literal_eval(\"[\" + data + \"]\")\n    except Exception:\n        # 若解析失敗則直接結束\n        return\n\n    stack = None\n    output = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MinStack\":\n            stack = MinStack()\n            output.append(None)\n        elif cmd == \"push\":\n            # arg 是單個元素的列表，例如 [-2]\n            val = arg[0]\n            stack.push(val)\n            output.append(None)\n        elif cmd == \"pop\":\n            stack.pop()\n            output.append(None)\n        elif cmd == \"top\":\n            output.append(stack.top())\n        elif cmd == \"getMin\":\n            output.append(stack.getMin())\n\n    # 轉換成符合題目要求的字串輸出\n    result_str = '[' + ','.join('null' if v is None else str(v) for v in output) + ']'\n    print(result_str)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "success": true,
          "output": "[null,null,null,null,-3,null,0,-2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode12.json",
    "problem_index_in_file": 0,
    "title": "Integer to Roman",
    "description_snippet": "Seven different symbols represent Roman numerals with the following values:\n\nSymbol\tValue\nI\t1\nV\t5\nX\t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code, step by step, for converting integer to Roman numeral. Provide explanation after each line. Use Start, End, Decision, etc. Provide line per step. Use arrows. Not actual code. Provide for each line: \"虛擬碼步驟 // 解釋\". We need to produce algorithm. Let's think steps:\n\nStart\n-> Input integer N\n-> Initialize result string\n-> Define arrays of values and symbols for roman conversion, sorted descending.\n-> For each pair in arrays:\n  -> While N >= value:\n     -> Append symbol\n     -> N -= value\n-> End\n\nBut must incorporate subtractive forms rules. Use a combined array of (value, symbol) including subtractive: 1000 M, 900 CM, 500 D, 400 CD, 100 C, 90 XC, 50 L, 40 XL, 10 X, 9 IX, 5 V, 4 IV, 1 I.\n\nThus algorithm is simpler. We produce steps accordingly. Must show decision: If N >= value then subtract etc. Use loop.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Input N // 取得要轉換的整數\n→ Initialize result = \"\" // 用於儲存羅馬數字\n→ 定義數值與符號對陣列: values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]; symbols = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"] // 先按從大到小的順序列出所有可能的組合\n→ 設定 index = 0 // 用於遍歷陣列\n→ Decision: index < length of values? // 判斷是否還有數值可處理\n    Yes → Decision: N >= values[index]? // 檢查是否可以使用目前數值\n        Yes → Step: result += symbols[index] // 把對應符號加入結果\n              → Step: N -= values[index] // 從 N 中減去該數值\n              → Jump back to Decision: N >= values[index]? // 重新檢查是否還能使用同一個數值\n        No  → Step: index += 1 // 移到下一個較小的數值\n    No  → End // 所有數值處理完畢，輸出結果\n\nBut we must output result. So before End, add output result.\n\n→ Output result // 輸出最終的羅馬數字\n\nNeed to ensure arrow formatting consistent. Use \"→\" for step lines. For Decision block, indent lines with spaces and \"Yes →\", \"No →\".\n\nLet's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Input N // 取得要轉換的整數\n→ Initialize result = \"\" // 用於儲存羅馬數字\n→ 定義數值與符號對陣列: values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]; symbols = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"] // 先按從大到小的順序列出所有可能的組合\n→ 設定 index = 0 // 用於遍歷陣列\n→ Decision: index < length(values)? // 判斷是否還有數值可處理\n    Yes → Decision: N >= values[index]? // 檢查是否可以使用目前數值\n        Yes → result += symbols[index] // 把對應符號加入結果\n              → N -= values[index] // 從 N 中減去該數值\n              → Decision: N >= values[index]? // 重新檢查是否還能使用同一個數值\n        No  → index += 1 // 移到下一個較小的數值\n    No  → Output result // 輸出最終的羅馬數字\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        \"\"\"\n        Convert an integer to a Roman numeral.\n        \"\"\"\n        values = [1000, 900, 500, 400, 100, 90,\n                  50, 40, 10, 9, 5, 4, 1]\n        symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\",\n                   \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n        roman = []\n        for value, symbol in zip(values, symbols):\n            count = num // value\n            if count:\n                roman.append(symbol * count)\n                num -= value * count\n        return \"\".join(roman)\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, convert the first integer found to a Roman numeral,\n    and print the result to stdout.\n    \"\"\"\n    data = sys.stdin.read()\n    # Extract the first integer (handles formats like \"num = 3749\" or just \"3749\")\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    num = int(match.group())\n    solution = Solution()\n    print(solution.intToRoman(num))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 3749",
          "expected_output": "\"MMMDCCXLIX\"",
          "success": true,
          "output": "MMMDCCXLIX"
        },
        {
          "example_index": 1,
          "input": "num = 58",
          "expected_output": "\"LVIII\"",
          "success": true,
          "output": "LVIII"
        },
        {
          "example_index": 2,
          "input": "num = 1994",
          "expected_output": "\"MCMXCIV\"",
          "success": true,
          "output": "MCMXCIV"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode165.json",
    "problem_index_in_file": 0,
    "title": "Compare Version Numbers",
    "description_snippet": "Given two version strings, version1 and version2, compare them. A version string consists of revisio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for comparing two version strings. Provide line-by-line steps with explanation. Use Start, End, Decision. No real code. Just virtual.\n\nWe must handle splitting by dot, converting to integer ignoring leading zeros (standard int conversion). Compare revision by revision. If one string shorter, treat missing as 0. After loop, decide return.\n\nWe need to produce steps. Use arrow and indent for decisions. Provide simple steps. Let's craft.\n\nStart // 程式開始執行\n→ Step 1: 切割 version1 為 revList1 用 '.' 作分隔 // 取得版本1的所有修訂項\n→ Step 2: 切割 version2 為 revList2 用 '.' 作分隔 // 取得版本2的所有修訂項\n→ Step 3: 設定 maxLen 為 max(len(revList1), len(revList2)) // 取較長列表長度\n→ Step 4: 從 i = 0 到 maxLen-1 迭代 // 比較每個修訂項\n   → Decision: i < len(revList1)? // 確認版本1是否還有修訂項\n       Yes → val1 = int(revList1[i]) // 轉成整數，去掉前導零\n       No  → val1 = 0 // 缺失修訂項視為0\n   → Decision: i < len(revList2)? // 確認版本2是否還有修訂項\n       Yes → val2 = int(revList2[i]) // 轉成整數\n       No  → val2 = 0\n   → Decision: val1 < val2? // 比較兩個修訂項\n       Yes → Return -1 // 版本1小於版本2\n       No  → Decision: val1 > val2?\n           Yes → Return 1 // 版本1大於版本2\n           No  → // 兩個修訂項相等，繼續迭代\nEnd // 迴圈結束，所有修訂項相等\n→ Return 0 // 兩個版本相等\n\nCheck formatting: each line \"虛擬碼步驟 // 解釋\". Indent for nested. Use arrow with \"→\". Use Decision: lines. Ensure consistent. Provide each line. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 切割 version1 為 revList1 用 '.' 作分隔 // 取得版本1的所有修訂項  \n→ Step 2: 切割 version2 為 revList2 用 '.' 作分隔 // 取得版本2的所有修訂項  \n→ Step 3: 設定 maxLen 為 max(len(revList1), len(revList2)) // 取較長列表長度  \n→ Step 4: 從 i = 0 到 maxLen-1 迭代 // 比較每個修訂項  \n → Decision: i < len(revList1)? // 確認版本1是否還有修訂項  \n  Yes → val1 = int(revList1[i]) // 轉成整數，去掉前導零  \n  No  → val1 = 0 // 缺失修訂項視為0  \n → Decision: i < len(revList2)? // 確認版本2是否還有修訂項  \n  Yes → val2 = int(revList2[i]) // 轉成整數  \n  No  → val2 = 0  \n → Decision: val1 < val2? // 比較兩個修訂項  \n  Yes → Return -1 // 版本1小於版本2  \n  No  → Decision: val1 > val2?  \n   Yes → Return 1 // 版本1大於版本2  \n   No  → // 兩個修訂項相等，繼續迭代  \nEnd // 迴圈結束，所有修訂項相等  \n→ Return 0 // 兩個版本相等",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        # 將每個版本字串拆成數字列表\n        v1 = [int(x) for x in version1.split('.')]\n        v2 = [int(x) for x in version2.split('.')]\n        # 以較長列表為基準進行逐段比較\n        for i in range(max(len(v1), len(v2))):\n            num1 = v1[i] if i < len(v1) else 0\n            num2 = v2[i] if i < len(v2) else 0\n            if num1 < num2:\n                return -1\n            if num1 > num2:\n                return 1\n        return 0\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整內容\n    data = sys.stdin.read().strip()\n    # 找出兩個版本號（假設格式為 ... \"xxx\" ... \"yyy\" ...）\n    versions = re.findall(r'\"([^\"]*)\"', data)\n    if len(versions) >= 2:\n        version1, version2 = versions[0], versions[1]\n        result = Solution().compareVersion(version1, version2)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "version1 = \"1.2\", version2 = \"1.10\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "version1 = \"1.01\", version2 = \"1.001\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "version1 = \"1.0\", version2 = \"1.0.0.0\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode692.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Words",
    "description_snippet": "Given an array of strings words and an integer k, return the k most frequent strings.\n\nReturn the an...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Steps: Start, input words array and k, count frequencies, sort by frequency desc, lex ascending, take first k. Use structures: Start, End, Decision, maybe loops. Provide line by line.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 freq // 用來計算每個字串出現次數\n→ Step 2: 對 words 中每個 word 進行累加 // 計算頻率\n→ Step 3: 將 freq 轉成列表 of (word, count) // 方便排序\n→ Step 4: 排序列表，先按 count 降序，再按 word 升序 // 確保排序規則\n→ Step 5: 取前 k 個 word // 取得最頻繁的 k 個字串\n→ Step 6: 回傳結果列表 // 完成輸出\nEnd // 程式執行結束\n\nBut we need arrow structure and maybe Decision for ties. Provide explanation.\n\nWe should maintain step format: \"Step X:\" maybe.\n\nLet's produce each line. Ensure each line has virtual code step and explanation.\n\nAlso include Decision? Might not be necessary but maybe for tie break decision.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: freq ← EmptyMap // 建立空的頻率字典\n→ Step 2: For each word in words: freq[word] ← freq.get(word, 0) + 1 // 計算每個字串出現次數\n→ Step 3: freqList ← List of (word, freq[word]) from freq // 轉成可排序的列表\n→ Step 4: Sort freqList by (−count, word) // 先按頻率降序，再按字典序升序\n→ Step 5: result ← EmptyList // 用來存放最頻繁的 k 個字串\n→ Step 6: For i from 0 to k-1: result.add(freqList[i].word) // 取前 k 個字串\n→ Step 7: Return result // 回傳結果\nEnd // 程式結束\n\nBut we need arrow lines. Let's add:\n\n→ Decision: k ≤ length(freqList)? // 檢查 k 是否合法\n    Yes → Step 6\n    No  → Step 6: result ← freqList.all().word // 取全部\n\nBut not necessary.\n\nLet's keep simple.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: freq ← EmptyMap // 建立一個空的頻率字典  \n→ Step 2: For each word in words: freq[word] ← freq.get(word, 0) + 1 // 計算每個字串的出現次數  \n→ Step 3: freqList ← List of (word, freq[word]) from freq // 把字典轉成可排序的 (word, count) 列表  \n→ Step 4: Sort freqList by (−count, word) // 先按頻率降序，再按字典序升序排序  \n→ Step 5: result ← EmptyList // 用來儲存最頻繁的 k 個字串  \n→ Step 6: For i from 0 to k-1: result.add(freqList[i].word) // 取前 k 個字串加入結果  \n→ Step 7: Return result // 回傳排序後的結果列表  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def topKFrequent(self, words, k):\n        # Count frequencies\n        count = Counter(words)\n        # Sort by decreasing frequency, then lexicographically\n        sorted_words = sorted(count.items(), key=lambda x: (-x[1], x[0]))\n        # Return only the words of the top k entries\n        return [word for word, freq in sorted_words[:k]]\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read()\n    # Extract words list and k using regular expressions\n    match = re.search(r'words\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*k\\s*=\\s*(\\d+)', data)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    words_str, k_str = match.groups()\n    words = ast.literal_eval(words_str)  # safely evaluate list\n    k = int(k_str)\n\n    # Compute the result\n    result = Solution().topKFrequent(words, k)\n    # Print the result in Python list format\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2",
          "expected_output": "[\"i\",\"love\"]",
          "success": true,
          "output": "['i', 'love']"
        },
        {
          "example_index": 1,
          "input": "words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4",
          "expected_output": "[\"the\",\"is\",\"sunny\",\"day\"]",
          "success": true,
          "output": "['the', 'is', 'sunny', 'day']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode728.json",
    "problem_index_in_file": 0,
    "title": "Self Dividing Numbers",
    "description_snippet": "A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. The algorithm: iterate numbers from left to right, check if self-dividing: for each digit, if digit==0 or num%digit!=0 then false. If true, add to list. At end return list.\n\nWe need to produce virtual code with arrows. Format: each line: \"虛擬碼步驟 // 解釋\". Should start with Start and End. Use Decision: for loop and digit check. Use Yes/No arrows. Provide structure. Use proper indentation? Not necessary but structure lines.\n\nWe produce lines: Start, → Step 1: initialize result list, → Step 2: for num from left to right, -> Decision: if num has zero or not self-dividing? Actually need check: inside loop, need to check digits. So maybe use inner loop.\n\nSimplify: for num in [left,right]: checkSelfDividing(num). If true, add. Then after loop return result.\n\nWe can write Decision: If digit==0? → No? Actually we want to check each digit. So inside loop: temp = num; flag=true; while temp>0: digit = temp%10; Decision: if digit==0? → Yes: flag=false; break; No: Decision: if num%digit !=0? → Yes: flag=false; break; No: continue; after loop: if flag: add to result.\n\nLet's produce accordingly. Use arrows like → Step, Decision: etc. Provide explanation.\n\nLet's output lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空列表 results ← [] // 用來儲存所有自除數  \n→ Step 2: 將 num 設為 left // 從最小值開始  \n→ Decision: 是否 num ≤ right? // 檢查是否已遍歷完範圍  \n    Yes → Step 3: 設 temp ← num // 用於分解數字  \n        → Step 4: 設 flag ← True // 假設 num 是自除數  \n        → Decision: 是否 temp > 0? // 仍有數位未檢查  \n            Yes → Step 5: 設 digit ← temp % 10 // 取得最低位數字  \n                → Decision: 是否 digit == 0? // 不能包含 0  \n                    Yes → Step 6: 設 flag ← False // 不是自除數  \n                          → Step 7: 退出內部循環 (break) // 跳到 Step 10  \n                    No  → Decision: 是否 num % digit ≠ 0? // 不能整除  \n                        Yes → Step 8: 設 flag ← False // 不是自除數  \n                              → Step 9: 退出內部循環 (break) // 跳到 Step 10  \n                        No  → Step 10: 設 temp ← temp // 移除已檢查位元  \n                              → Step 10: 設 temp ← temp / 10 // 整數除法  \n                              → 再回到 Step 3 的 Decision  \n        No  → Step 11: Decision: 是否 flag? // 所有位數都符合條件  \n            Yes → Step 12: results ← results ∪ [num] // 加入結果列表  \n            No  → Step 13: /* 不做任何事 */  \n        → Step 14: 設 num ← num + 1 // 進到下一個數字  \n        → 再回到 Step 2 的 Decision  \n→ Step 15: 回傳 results // 所有自除數已列出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef self_dividing_numbers(left: int, right: int):\n    \"\"\"Return list of self‑dividing numbers between left and right inclusive.\"\"\"\n    result = []\n    for num in range(left, right + 1):\n        temp = num\n        divisible = True\n        while temp > 0:\n            digit = temp % 10\n            if digit == 0 or num % digit != 0:\n                divisible = False\n                break\n            temp //= 10\n        if divisible:\n            result.append(num)\n    return result\n\nif __name__ == \"__main__\":\n    # 讀取輸入，示例格式: \"left = 1, right = 22\"\n    data = sys.stdin.read().strip()\n    # 從輸入中擷取所有整數\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if len(numbers) >= 2:\n        left, right = numbers[0], numbers[1]\n    else:\n        # 若輸入格式不符合，則使用預設值或直接退出\n        sys.exit(\"Invalid input format.\")\n    # 計算並輸出結果\n    print(self_dividing_numbers(left, right))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 1, right = 22",
          "expected_output": "[1,2,3,4,5,6,7,8,9,11,12,15,22]",
          "success": true,
          "output": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"
        },
        {
          "example_index": 1,
          "input": "left = 47, right = 85",
          "expected_output": "[48,55,66,77]",
          "success": true,
          "output": "[48, 55, 66, 77]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1296.json",
    "problem_index_in_file": 0,
    "title": "Divide Array in Sets of K Consecutive Numbers",
    "description_snippet": "Given an array of integers nums and a positive integer k, check whether it is possible to divide thi...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: given array nums and k, check if can divide into sets of k consecutive numbers. This is LeetCode problem 659. Approach: frequency map, sorted keys, iterate from smallest to largest, for each number, if count>0, try to take a consecutive block of length k, decrement counts. If any count becomes negative or missing, return false. Complexity O(n log n).\n\nSo produce steps: Start, build frequency map, sort keys, iterate, check.\n\nLet's write lines with arrows and decisions. Provide explanation comments after each line.\n\nUse \"Start // 程式開始執行\". Use \"→ Step 1: ...\". Use \"Decision:\" etc.\n\nLet's craft.\n\nPotential steps:\n\n1. Start\n2. Build frequency map of nums: freq[nums[i]]++.\n3. Sort unique numbers ascending: sortedNums.\n4. For each num in sortedNums:\n   Decision: if freq[num] > 0? (Yes: need to process block)\n5. Set count = freq[num].\n   For i from 0 to k-1:\n       current = num + i\n       Decision: if freq[current] >= count? (Yes: decrement)\n           freq[current] -= count\n       Else: // not enough consecutive numbers\n           Return false\n6. After loop, continue to next num.\n7. End // return true\n\nNeed to use arrow and decisions with Yes→/No→.\n\nLet's craft lines accordingly.\n\nWe need each line \"虛擬碼步驟 [space] // 解釋\".\n\nLet's output step by step.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個頻率表 freq // 建立一個哈希表來記錄每個數字出現的次數  \n→ Step 2: 遍歷 nums，對每個值 x 執行 freq[x]++ // 统计每个整数的出现次数  \n→ Step 3: 取出 freq 的鍵，並按升序排序得到 sortedNums // 方便按从小到大的顺序处理  \n→ Step 4: 對 sortedNums 中的每個 num 進行以下操作 // 逐个检查每个数  \n    Decision: 如果 freq[num] > 0? // 只有出现次数大于 0 的数字才需要处理  \n        Yes → Step 5: 设 count = freq[num] // 记录当前数字的出现次数，后面会用来减去连续块  \n        → Step 6: 循环 i 从 0 到 k-1 // 为了形成长度为 k 的连续区间  \n            Decision: 如果 freq[num + i] >= count? // 检查连续位置是否有足够的数  \n                Yes → Step 7: freq[num + i] -= count // 减去对应的次数，完成一次完整的区间  \n                No → Step 8: Return false // 若缺少足够的数，无法完成划分，直接返回错误  \n        → Step 9: // 完成当前数字的连续块处理，继续循环到下一个 num  \n    No → Step 10: // freq[num] == 0，跳过该数字，继续循环到下一个 num  \n→ End // 所有数字都已处理完毕，返回 true，表示可以划分为 k 个连续数集  \n→ Step 11: Return true // 说明满足条件，可成功划分成 k 连续数集",
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def isPossibleDivide(self, nums, k):\n        if len(nums) % k != 0:\n            return False\n        count = Counter(nums)\n        for num in sorted(count):\n            freq = count[num]\n            if freq > 0:\n                for i in range(num, num + k):\n                    if count[i] < freq:\n                        return False\n                    count[i] -= freq\n        return True\n\ndef parse_input(input_str):\n    \"\"\"Parse input of the form 'nums = [...], k = X'.\"\"\"\n    if not input_str:\n        return [], 0\n    # Split by comma that separates nums and k\n    parts = input_str.split(',')\n    if len(parts) < 2:\n        raise ValueError(\"Input must contain nums and k\")\n    # Extract list\n    nums_part = parts[0].strip()\n    nums_str = nums_part.split('=', 1)[1].strip()\n    nums = eval(nums_str)\n    # Extract k\n    k_part = parts[1].strip()\n    k_str = k_part.split('=', 1)[1].strip()\n    k = int(k_str)\n    return nums, k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    nums, k = parse_input(data)\n    solution = Solution()\n    result = solution.isPossibleDivide(nums, k)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,3,4,4,5,6], k = 4",
          "expected_output": "true",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp9qv71rub.py\", line 38, in <module>\n    nums, k = parse_input(data)\n              ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9qv71rub.py\", line 29, in parse_input\n    nums = eval(nums_str)\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3",
          "expected_output": "true",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpilmgp5gz.py\", line 38, in <module>\n    nums, k = parse_input(data)\n              ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpilmgp5gz.py\", line 29, in parse_input\n    nums = eval(nums_str)\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpscf73jkv.py\", line 38, in <module>\n    nums, k = parse_input(data)\n              ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpscf73jkv.py\", line 29, in parse_input\n    nums = eval(nums_str)\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode238.json",
    "problem_index_in_file": 0,
    "title": "Product of Array Except Self",
    "description_snippet": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, for algorithm: product except self without division, O(n). Standard solution: left products, right products, etc. Provide start, step lines, decisions maybe. We need to output line by line with `虛擬碼步驟` and `// 解釋/說明`. Use arrow `→` etc. Each line ends with explanation.\n\nWe should produce code like:\n\nStart\n→ Step 1: let n = length(nums) // get array length\n→ Step 2: initialize answer array of size n with 1 // start with 1\n→ Step 3: initialize leftProduct = 1 // left cumulative product\n→ Decision: for i from 0 to n-1? Actually loop\n    Yes → Step 4: answer[i] = leftProduct // set answer to left product\n    Yes → Step 5: leftProduct *= nums[i] // update left product\n→ Step 6: initialize rightProduct = 1 // right cumulative product\n→ Decision: for i from n-1 down to 0\n    Yes → Step 7: answer[i] *= rightProduct // multiply by right product\n    Yes → Step 8: rightProduct *= nums[i] // update right product\nEnd\n\nWe also might need explanation of each line. Use `//` to add comment.\n\nMake sure each line is separate.\n\nAlso include decision for loops? But loops can be represented as Decision with Yes. Alternatively just Step: For loop.\n\nBetter to express loops with Decision: if i < n? Might not be needed.\n\nLet's produce a simple virtual code: Use Step: For i in 0..n-1.\n\nBut the instructions: Use arrows (→, Yes →, No →). We can use `Decision:` for loops, with Yes branch executed each iteration. But easier: use `→ Step: For i in 0..n-1` but not arrow? Use `→ Step 4: For i from 0 to n-1` might be okay. But arrow expects a step. We can write `→ Step 4: For i from 0 to n-1` as a step. But not necessary to have Decision. The sample uses Decision for if.\n\nBetter: Use Decision: for i from 0 to n-1? Not a decision. Let's keep simple.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: let n = length(nums) // 取得輸入陣列長度\n→ Step 2: create answer array of size n, initialise all elements to 1 // 先預設答案為1\n→ Step 3: set leftProduct = 1 // 左側累積乘積初值\n→ Step 4: for i from 0 to n-1 // 迭代左乘積\n    → Step 5: answer[i] = leftProduct // 將左乘積賦值給答案\n    → Step 6: leftProduct = leftProduct * nums[i] // 更新左乘積\n→ Step 7: set rightProduct = 1 // 右側累積乘積初值\n→ Step 8: for i from n-1 down to 0 // 迭代右乘積\n    → Step 9: answer[i] = answer[i] * rightProduct // 與右乘積相乘\n    → Step 10: rightProduct = rightProduct * nums[i] // 更新右乘積\nEnd // 程式結束\n\nNeed to ensure each line is separate, with arrow `→`. For loops, each inner step also needs arrow.\n\nBut we must have `虛擬碼步驟` + `[空格]` + `// 解釋/說明`.\n\nWe can prefix each line with `→` or not. Example: `Start // 程式開始執行` doesn't need arrow. But the example uses `Start`. So we can just write `Start`. For Step 1 we use `→ Step 1:` etc.\n\nBut we need to keep each line separate. Indent the inner steps? Not required but okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: let n = length(nums) // 取得輸入陣列長度  \n→ Step 2: create answer array of size n, initialise all elements to 1 // 先預設答案為 1  \n→ Step 3: set leftProduct = 1 // 左側累積乘積初值  \n→ Step 4: for i from 0 to n-1 // 迭代左乘積  \n    → Step 5: answer[i] = leftProduct // 把目前左乘積存入答案  \n    → Step 6: leftProduct = leftProduct * nums[i] // 更新左乘積  \n→ Step 7: set rightProduct = 1 // 右側累積乘積初值  \n→ Step 8: for i from n-1 down to 0 // 迭代右乘積  \n    → Step 9: answer[i] = answer[i] * rightProduct // 與右乘積相乘  \n    → Step 10: rightProduct = rightProduct * nums[i] // 更新右乘積  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\ndef product_except_self(nums):\n    n = len(nums)\n    res = [1] * n\n    left = 1\n    for i in range(n):\n        res[i] = left\n        left *= nums[i]\n    right = 1\n    for i in range(n - 1, -1, -1):\n        res[i] *= right\n        right *= nums[i]\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    if '=' in data:\n        _, nums_str = data.split('=', 1)\n    else:\n        nums_str = data\n    nums_str = nums_str.strip()\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        nums = []\n    result = product_except_self(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "[24,12,8,6]",
          "success": true,
          "output": "[24, 12, 8, 6]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,1,0,-3,3]",
          "expected_output": "[0,0,9,0,0]",
          "success": true,
          "output": "[0, 0, 9, 0, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode321.json",
    "problem_index_in_file": 0,
    "title": "Create Maximum Number",
    "description_snippet": "You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 re...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for problem: maximum number from two arrays digits, similar to Leetcode 321. Steps: choose subsequence of length i from nums1 and j from nums2 such that i+j=k, find max for each i, merge, track best.\n\nWe'll produce step-by-step pseudocode lines with comments. Use Start, End, Decision.\n\nWe need to produce steps line by line. Use \"→\" for flow, \"Decision:\" for branching. Provide explanation after //.\n\nWe'll structure:\n\nStart\n→ Step: Define helper function MaxSubsequence(array, length) // get max subsequence preserving order\n→ Step: Define helper function Merge(seq1, seq2) // merge two subsequences to form max\n→ Step: Initialize bestResult empty // store best k digits\n→ Step: For i from max(0,k-n) to min(k,m):\n    → Decision: check if i<=m and k-i <= n? // ensure feasible\n        Yes →\n            → Step: subseq1 = MaxSubsequence(nums1, i)\n            → Step: subseq2 = MaxSubsequence(nums2, k-i)\n            → Step: candidate = Merge(subseq1, subseq2)\n            → Decision: is candidate > bestResult? // lexicographic comparison\n                Yes → Step: bestResult = candidate\nEnd\n\nBut must express in lines with arrows and comments. Let's write each line. Use indentation with \"    \" for nested lines. Use \"→\" for flow steps, \"Decision:\" for branching, \"Yes →\" etc.\n\nWe'll need a function comparison for arrays, but just comment.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義輔助函式 MaxSubsequence(array, length) // 取得最大子序列，保持原序  \n→ Step 2: 定義輔助函式 Merge(seq1, seq2) // 合併兩個子序列，生成最大的數字  \n→ Step 3: 初始化 bestResult 為空列表 // 用於儲存目前最佳的 k 位數字  \n→ Step 4: 計算 i 的範圍: start = max(0, k - n)，end = min(k, m) // i 為從 nums1 選取的位數  \n→ Step 5: 從 start 到 end 逐步迭代 i  \n    → Decision: 檢查 i <= m 且 (k - i) <= n? // 確保兩個子序列都能取到對應長度  \n        Yes →  \n            → Step 6: subseq1 = MaxSubsequence(nums1, i) // 從 nums1 取最大子序列  \n            → Step 7: subseq2 = MaxSubsequence(nums2, k - i) // 從 nums2 取最大子序列  \n            → Step 8: candidate = Merge(subseq1, subseq2) // 合併得到當前候選解  \n            → Decision: candidate 是否比 bestResult 大? // 逐位比較兩個數列  \n                Yes →  \n                    → Step 9: bestResult = candidate // 更新最佳答案  \n                No →  \n                    → Step 10: 保持 bestResult 不變 // 當前候選不優於已知最佳  \n        No →  \n            → Step 11: 跳過此 i，因為無法滿足長度要求  \n→ Step 12: 返回 bestResult // 結束並輸出最大 k 位數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxNumber(self, nums1, nums2, k):\n        # Helper to pick the maximum subsequence of length t from nums\n        def pick_max(nums, t):\n            drop = len(nums) - t  # number of digits we can discard\n            stack = []\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:t]\n\n        # Helper to merge two subsequences into the maximum number\n        def merge(a, b):\n            res = []\n            i = j = 0\n            while i < len(a) and j < len(b):\n                # Compare the remaining parts lexicographically\n                if a[i:] > b[j:]:\n                    res.append(a[i])\n                    i += 1\n                else:\n                    res.append(b[j])\n                    j += 1\n            # Append any remaining digits\n            res.extend(a[i:])\n            res.extend(b[j:])\n            return res\n\n        max_res = []\n        # i digits from nums1, k-i digits from nums2\n        start = max(0, k - len(nums2))\n        end = min(k, len(nums1))\n        for i in range(start, end + 1):\n            a = pick_max(nums1, i)\n            b = pick_max(nums2, k - i)\n            candidate = merge(a, b)\n            if candidate > max_res:\n                max_res = candidate\n        return max_res\n\n\ndef parse_input(text):\n    \"\"\"Parse input of the form 'nums1 = [...], nums2 = [...], k = X'.\"\"\"\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[[^\\]]*\\])', text)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[[^\\]]*\\])', text)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', text)\n\n    if not nums1_match or not nums2_match or not k_match:\n        raise ValueError(\"Input format incorrect\")\n\n    nums1 = eval(nums1_match.group(1))\n    nums2 = eval(nums2_match.group(1))\n    k = int(k_match.group(1))\n    return nums1, nums2, k\n\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read()\n    nums1, nums2, k = parse_input(input_text)\n    solution = Solution()\n    result = solution.maxNumber(nums1, nums2, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5",
          "expected_output": "[9,8,6,5,3]",
          "success": true,
          "output": "[9, 8, 6, 5, 3]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [6,7], nums2 = [6,0,4], k = 5",
          "expected_output": "[6,7,6,0,4]",
          "success": true,
          "output": "[6, 7, 6, 0, 4]"
        },
        {
          "example_index": 2,
          "input": "nums1 = [3,9], nums2 = [8,9], k = 3",
          "expected_output": "[9,8,9]",
          "success": true,
          "output": "[9, 8, 9]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode343.json",
    "problem_index_in_file": 0,
    "title": "Integer Break",
    "description_snippet": "Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the pro...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for integer break maximizing product. Standard DP or greedy: For n≥2 break into at least 2 positive integers. Max product can be achieved by breaking into 3s, except remainder 1 adjust. Provide steps.\n\nWe produce steps:\n\nStart\n→ Input n\n→ If n <= 3 return n-1 // because best product for 2->1, 3->2\n→ Set product=1\n→ While n > 4\n    → product *= 3\n    → n -= 3\n→ product *= n\n→ Output product\nEnd\n\nAdd explanations. Use decision and loops. Use Start End. Provide each line.\n\nLet's produce lines. Use arrow indent.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 取得欲拆分的整數  \n→ Decision: 如果 n <= 3? // 小數值可直接算出最佳積  \n  Yes → Output n-1 // 2→1, 3→2，已是最大積  \n  No → Set product = 1 // 初始化積  \n   → Decision: n > 4? // 大於 4 時可重複取 3  \n    Yes → product = product * 3 // 將 3 乘入積  \n     n = n - 3 // 將 n 減去 3，重複  \n     → Decision: n > 4? // 迴圈條件  \n      Yes → repeat 上面兩步  \n      No → // n 變成 2、3 或 4  \n       product = product * n // 將剩餘數乘入積  \n       → Output product // 最終最大積  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef integer_break(n: int) -> int:\n    \"\"\"\n    將整數 n 拆成至少兩個正整數，使其乘積最大\n    \"\"\"\n    # n <= 3 時特殊處理\n    if n == 2:\n        return 1          # 2 = 1 + 1, 1*1 = 1\n    if n == 3:\n        return 2          # 3 = 2 + 1, 2*1 = 2\n\n    product = 1\n    # 盡量拆成 3，因為 3 的乘積效益最高\n    while n > 4:\n        product *= 3\n        n -= 3\n    # 將剩餘的 n (2、3 或 4) 乘入結果\n    return product * n\n\ndef main() -> None:\n    \"\"\"\n    主函式：讀取標準輸入，解析 n，計算並輸出結果\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # 從輸入中抓取第一個數字，支援類似 \"n = 10\" 的格式\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = integer_break(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 10",
          "expected_output": "36",
          "success": true,
          "output": "36"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode438.json",
    "problem_index_in_file": 0,
    "title": "Find All Anagrams in a String",
    "description_snippet": "Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to find all start indices of p's anagrams in s. Sliding window, frequency map. We need to output virtual code lines with arrow etc. No actual code.\n\nWe need to include Start, End, Decision, Step etc.\n\nWe need to output step-by-step pseudocode, each line: \"虛擬碼步驟 // 解釋\".\n\nSo start: Start // start execution.\n\nThen Step 1: Define variables: s, p, sLen, pLen, result list.\n\nThen Step 2: If pLen > sLen: return empty.\n\nStep 3: Build frequency map for p.\n\nStep 4: Build frequency map for first window in s of length pLen.\n\nStep 5: Compare maps. If equal, add 0 to result.\n\nStep 6: For i from pLen to sLen-1: Slide window: add s[i], remove s[i-pLen]; update maps.\n\nStep 7: Compare maps. If equal, add i-pLen+1 to result.\n\nStep 8: End // return result.\n\nWe should use Decision nodes to compare maps.\n\nWe'll produce lines accordingly.\n\nWe should use \"→\" arrows, indent for decisions.\n\nLet's craft lines:\n\nStart // 程式開始\n\n→ Step 1: 設定 sLen ← len(s), pLen ← len(p), result ← 空列表 // 初始化長度與結果\n\n→ Decision: 如果 pLen > sLen? // 若 p 長度大於 s，無法匹配\n\n    Yes → Step 2: 回傳 result // 直接回傳空列表\n\n    No  → Step 3: 建立 freqP ← {char:計數}，freqS ← {char:計數} // 兩個頻率表\n\n→ Step 4: 迭代 i 從 0 到 pLen-1: freqP[s[i]]++ // 统计 p 的字符频率\n\n→ Step 5: 迭代 i 從 0 到 pLen-1: freqS[s[i]]++ // 统计 s 前 pLen 个字符的频率\n\n→ Step 6: Decision: freqS == freqP? // 判断第一窗口是否为字谜\n\n    Yes → Step 7: result.append(0) // 若相等，加入起始索引 0\n\n    No  → Step 8: // 继续滑动窗口\n\n→ Step 9: 迭代 i 從 pLen 到 sLen-1: // 滑动窗口\n\n    → Step 10: freqS[s[i]]++ // 加入新字符\n\n    → Step 11: freqS[s[i - pLen]]-- // 移除旧字符\n\n    → Decision: freqS == freqP? // 判断当前窗口\n\n        Yes → Step 12: result.append(i - pLen + 1) // 若相等，加入起始索引\n\n        No  → Step 13: // 继续循环\n\n→ End // 返回 result\n\nWe need to ensure each line has \"虛擬碼步驟 // 解釋\". So each line is like:\n\nStart // 程式開始\n\n→ Step 1: ... // 解释\n\nBut we also need to indicate decisions properly. Provide indentation with tabs maybe. Use arrow and indent.\n\nLet's produce final answer with that format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: sLen ← len(s) , pLen ← len(p) , result ← 空列表 // 初始化字串長度與結果列表  \n→ Decision: pLen > sLen? // 檢查 p 是否比 s 長，無法匹配  \n Yes → Step 2: 回傳 result // 若 p 長度大於 s，直接回傳空列表  \n No  → Step 3: 建立 freqP ← 空字典，freqS ← 空字典 // 建立兩個頻率表  \n→ Step 4: 迭代 i 從 0 到 pLen-1: freqP[s[i]]++ // 統計 p 中每個字符的頻率  \n→ Step 5: 迭代 i 從 0 到 pLen-1: freqS[s[i]]++ // 統計 s 前 pLen 個字符的頻率  \n→ Decision: freqS == freqP? // 判斷第一個滑窗是否為 p 的字謎  \n Yes → Step 6: result.append(0) // 若相等，加入起始索引 0  \n No  → // 直接進行滑動窗口處理  \n→ Step 7: 迭代 i 從 pLen 到 sLen-1: // 開始滑動窗口  \n → Step 8: freqS[s[i]]++ // 加入新進入窗口的字符  \n → Step 9: freqS[s[i - pLen]]-- // 移除離開窗口的字符  \n → Decision: freqS == freqP? // 判斷當前窗口是否為字謎  \n  Yes → Step 10: result.append(i - pLen + 1) // 若相等，加入起始索引  \n  No  → // 繼續下一個滑動  \n→ End // 程式執行結束，回傳 result",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> list[int]:\n        ns, np = len(s), len(p)\n        if ns < np:\n            return []\n\n        p_count = Counter(p)\n        s_count = Counter(s[:np])\n        res = []\n\n        if s_count == p_count:\n            res.append(0)\n\n        for i in range(1, ns - np + 1):\n            left_char = s[i - 1]\n            right_char = s[i + np - 1]\n\n            s_count[left_char] -= 1\n            if s_count[left_char] == 0:\n                del s_count[left_char]\n\n            s_count[right_char] += 1\n\n            if s_count == p_count:\n                res.append(i)\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the two quoted strings: first is s, second is p\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        s_input, p_input = matches[0], matches[1]\n    else:\n        # Fallback: try to split by comma if quotes missing\n        parts = data.split(',')\n        s_input = parts[0].split('=')[1].strip().strip('\"')\n        p_input = parts[1].split('=')[1].strip().strip('\"')\n    solution = Solution()\n    result = solution.findAnagrams(s_input, p_input)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"cbaebabacd\", p = \"abc\"",
          "expected_output": "[0,6]",
          "success": true,
          "output": "[0, 6]"
        },
        {
          "example_index": 1,
          "input": "s = \"abab\", p = \"ab\"",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode467.json",
    "problem_index_in_file": 0,
    "title": "Unique Substrings in Wraparound String",
    "description_snippet": "We define the string base to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so b...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for algorithm: Count unique substrings of s that appear as substrings in infinite wraparound string of alphabet. Known problem: Leetcode 467. Approach: maintain array of max length ending at each letter. For each position i in s, if s[i] consecutive to previous char (s[i-1] +1 modulo 26) then current_len++ else current_len=1. Update maxLen[letter] = max(maxLen[letter], current_len). After traversal sum all maxLen values = answer. Provide pseudocode lines accordingly. Need each line with explanation. Use arrow formatting.\n\nLet's craft. We'll include Start, Step lines. Steps: Initialize array length 26 zeros. current_len=0. Iterate i from 0 to len(s)-1. Check condition. Update current_len. Update maxLen. After loop sum. Return answer. End.\n\nLet's produce line by line. Ensure to follow format: \"虛擬碼步驟 // 解釋\".\n\nUse arrows. Provide indentation? Not required but can use spaces. Use arrow \"→\" before steps. Use Decision lines for if. For sum maybe use Step.\n\nLet's create:\n\nStart // 程式開始\n\n→ Step 1: 建立陣列 maxLen[26] 初始化為 0 // 用來記錄以每個字母結尾的最大合法子字串長度\n\n→ Step 2: current_len ← 0 // 用於記錄當前連續字母序列長度\n\n→ Step 3: 對於每個索引 i 從 0 到 len(s)-1 進行迴圈 // 遍歷輸入字串\n\n    → Decision: i==0 或 s[i] 是否是 s[i-1] 的下一個字母? // 判斷是否連續\n\n        Yes → current_len ← current_len + 1 // 連續，長度加 1\n\n        No  → current_len ← 1 // 非連續，重置長度為 1\n\n    → Step 4: letterIndex ← s[i] 的字母索引（0-25） // 取得當前字母對應的索引\n\n    → Step 5: maxLen[letterIndex] ← max(maxLen[letterIndex], current_len) // 更新以此字母結尾的最大長度\n\n→ Step 6: answer ← sum(maxLen[0..25]) // 所有字母結尾最大長度之和即為符合條件的不同子字串數\n\n→ Step 7: 返回 answer // 結果\n\nEnd // 程式執行結束\n\nMake sure each line includes comment after //. Use arrow.\n\nAlso ensure indentation: we can use spaces after arrow to indicate sub-steps. Each sub-step line starts with arrow as well. In sample, they indent under decision with spaces and arrow. We'll mimic.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立陣列 maxLen[26] 初始化為 0 // 用來記錄以每個字母結尾的最大合法子字串長度  \n→ Step 2: current_len ← 0 // 用於記錄目前連續字母序列長度  \n→ Step 3: 對於每個索引 i 從 0 到 len(s)-1 進行迴圈 // 遍歷輸入字串  \n → Decision: i==0 或 s[i] 是否是 s[i-1] 的下一個字母? // 判斷是否連續  \n  Yes → current_len ← current_len + 1 // 連續，長度加 1  \n  No  → current_len ← 1 // 非連續，重置長度為 1  \n → Step 4: letterIndex ← s[i] 的字母索引（0-25） // 取得目前字母對應的索引  \n → Step 5: maxLen[letterIndex] ← max(maxLen[letterIndex], current_len) // 更新以此字母結尾的最大長度  \n→ Step 6: answer ← sum(maxLen[0..25]) // 所有字母結尾最大長度之和即為符合條件的不同子字串數  \n→ Step 7: 返回 answer // 結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def findSubstringInWraproundString(self, p: str) -> int:\n        \"\"\"\n        Count unique non‑empty substrings of `p` that appear in the infinite\n        wraparound string of the alphabet.\n        \"\"\"\n        # dp[i] stores the maximum length of a substring ending with the\n        # letter chr(i + ord('a')) that is present in the wraparound string.\n        dp = [0] * 26\n        cur_len = 0  # current length of consecutive sequence\n\n        for i, ch in enumerate(p):\n            if i > 0 and (ord(ch) - ord(p[i - 1])) % 26 == 1:\n                cur_len += 1\n            else:\n                cur_len = 1\n            idx = ord(ch) - ord('a')\n            dp[idx] = max(dp[idx], cur_len)\n\n        return sum(dp)\n\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    Extract the string value from raw input which may be of the form:\n    's = \"abc\"' or just 'abc'.\n    \"\"\"\n    raw = raw.strip()\n    # Remove a leading 's ='\n    if raw.lower().startswith('s ='):\n        raw = raw[3:].strip()\n    # Remove surrounding quotes if present\n    if raw.startswith('\"') and raw.endswith('\"'):\n        raw = raw[1:-1]\n    return raw\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findSubstringInWraproundString(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode219.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate II",
    "description_snippet": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line, with arrow and explanation. Should cover algorithm: using hash map to store last seen index, iterate over array, check distance.\n\nWe need Start, End, Decision. Provide steps. Ensure each line: \"虛擬碼步驟 // 解釋\". Use arrow. For decision, we use indentation.\n\nLet's write:\n\nStart // 程式開始\n→ Step 1: 初始化哈希表 seen = {} // 用於存儲元素最後出現的索引\n→ Step 2: 循環遍歷 nums，索引 i 從 0 到 len(nums)-1 // 遍歷整個陣列\n    → Decision: 是否存在 key nums[i] 在 seen? // 檢查是否已看到此值\n        Yes → Step 3: 計算距離 diff = i - seen[nums[i]] // 兩個相同值之間的距離\n            → Decision: diff <= k? // 檢查距離是否在 k 內\n                Yes → Step 4: 返回 true // 找到符合條件的索引對\n                No  → Step 5: 更新 seen[nums[i]] = i // 更新最後索引，繼續循環\n        No  → Step 6: 將 seen[nums[i]] = i // 第一次見到此值，記錄索引\n→ Step 7: 循環結束後返回 false // 未找到符合條件的索引對\nEnd // 程式結束\n\nWe need to maintain each line with arrow and explanation. Use arrow for each step. For decisions, we indent with spaces. Ensure each line ends with // explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化哈希表 seen = {} // 用於存儲每個數字最近一次出現的索引  \n→ Step 2: 循環遍歷 nums，索引 i 從 0 到 len(nums)-1 // 逐個檢查陣列元素  \n  → Decision: nums[i] 是否已存在於 seen? // 判斷此數字是否已被遇到過  \n   Yes → Step 3: 計算 diff = i - seen[nums[i]] // 兩個相同數字之間的距離  \n    → Decision: diff <= k? // 檢查距離是否不超過 k  \n     Yes → Step 4: 返回 true // 找到符合條件的索引對，結束程式  \n     No  → Step 5: 更新 seen[nums[i]] = i // 距離太大，更新最近索引並繼續  \n   No  → Step 6: 設置 seen[nums[i]] = i // 第一次遇到此數字，記錄索引  \n→ Step 7: 循環結束後返回 false // 未找到任何符合條件的索引對  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        判斷是否存在兩個相同元素，且其索引差距不超過 k。\n        使用哈希表記錄每個元素最近一次出現的索引。\n        \"\"\"\n        index_map = {}\n        for i, num in enumerate(nums):\n            if num in index_map and i - index_map[num] <= k:\n                return True\n            index_map[num] = i\n        return False\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中提取 nums 與 k。\n    支援格式：'nums = [1,2,3,1], k = 3'\n    \"\"\"\n    pattern = r'nums\\s*=\\s*\\[([^\\]]*)\\]\\s*,\\s*k\\s*=\\s*([^\\s]+)'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"Invalid input format\")\n    nums_str, k_str = match.group(1), match.group(2)\n    # 解析 nums\n    nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n    k = int(k_str)\n    return nums, k\n\ndef main():\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    nums, k = parse_input(raw_input)\n    sol = Solution()\n    result = sol.containsNearbyDuplicate(nums, k)\n    # 按題目要求輸出小寫字串\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], k = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1], k = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,1,2,3], k = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode135.json",
    "problem_index_in_file": 0,
    "title": "Candy",
    "description_snippet": "There are n children standing in a line. Each child is assigned a rating value given in the integer ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the candy distribution problem. Use typical two-pass algorithm. We need to produce step-by-step virtual code with arrows, decisions, etc. Ensure each line has \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Provide algorithm. Include initialization, first pass left-to-right, second pass right-to-left, sum candies.\n\nLet's craft steps:\n\nStart\n→ Step 1: Input n and ratings array // get data\n→ Step 2: Initialize candies array of size n with all 1 // at least one candy each\n→ Step 3: For i from 1 to n-1 // left-to-right pass\n    → Decision: If ratings[i] > ratings[i-1]?\n        Yes → candies[i] = candies[i-1] + 1 // higher rating gets more\n        No → continue // no change\n→ Step 4: For i from n-2 downto 0 // right-to-left pass\n    → Decision: If ratings[i] > ratings[i+1]?\n        Yes → candies[i] = max(candies[i], candies[i+1] + 1) // ensure higher rating gets more\n        No → continue\n→ Step 5: sum = 0 // total candies\n→ Step 6: For each c in candies\n    → sum += c // accumulate\n→ Step 7: Return sum // minimal candies needed\nEnd\n\nEnsure each line with arrow and comment. Also need decision indenting. Format: \"→ Decision: ...\". For loop lines, use indentation with arrow inside? Usually each step is a separate line. We need to include loops. Perhaps:\n\n→ Step 3: For i = 1 to n-1\n    → Decision: If ratings[i] > ratings[i-1]?\n        Yes → candies[i] = candies[i-1] + 1\n\nBut each line separate. Let's produce each line as separate virtual code line. Use indentation with spaces? In example, indentation uses 4 spaces? Example:\n\n→ Decision: If數字大於 0? // ...\n    Yes → Step 2: ...\n\nSo we can mimic. We'll include indentation by spaces before \"Yes →\". For loops we can show:\n\n→ Step 3: For i from 1 to n-1 // left-to-right pass\n    → Decision: If ratings[i] > ratings[i-1]?\n        Yes → candies[i] = candies[i-1] + 1 // higher rating gets more\n        No → // no change\n\nSimilarly second pass. For sum loop. Provide simple.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n 與 ratings 陣列 // 取得兒童數量與評分  \n→ Step 2: 建立 candies 陣列，長度為 n，並將每個元素設為 1 // 每位兒童至少拿一顆糖  \n→ Step 3: 從左到右遍歷 1 ~ n-1 // 左至右掃描  \n  → Decision: 若 ratings[i] > ratings[i-1]？ // 比鄰近評分高？  \n    Yes → candies[i] = candies[i-1] + 1 // 評分較高則拿多一顆  \n    No → // 無須調整，保持目前值  \n→ Step 4: 從右到左遍歷 n-2 ~ 0 // 右至左掃描  \n  → Decision: 若 ratings[i] > ratings[i+1]？ // 比鄰近評分高？  \n    Yes → candies[i] = max(candies[i], candies[i+1] + 1) // 確保右邊也符合規則  \n    No → // 無須調整，保持目前值  \n→ Step 5: sum ← 0 // 初始化總糖數  \n→ Step 6: 對 candies 中每個 c  \n  → sum ← sum + c // 累加總數  \n→ Step 7: 回傳 sum // 最小所需糖果數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        candies = [1] * n\n\n        # Left to right pass\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        # Right to left pass\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        return sum(candies)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Expect input like: ratings = [1,0,2]\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    try:\n        ratings = ast.literal_eval(expr)\n    except Exception:\n        ratings = []\n\n    sol = Solution()\n    result = sol.candy(ratings)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ratings = [1,0,2]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "ratings = [1,2,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode127.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for finding the length of shortest transformation sequence, basically classic Word Ladder problem. They want step-by-step pseudocode, not actual code. Must use Start, End, Decision, Yes→ No→. Include explanation on each line after //.\n\nWe need to output line by line, each with \"虛擬碼步驟 // 解釋\". Use arrow → and decisions. Provide algorithm steps: BFS with queue, visited set, early exit. Also handle edge cases.\n\nWe need to output in Traditional Chinese.\n\nLet's craft:\n\nStart\n→ If endWord not in wordList, return 0 // no possible path\n→ Initialize set wordSet = set(wordList) // for O(1) lookup\n→ Initialize queue with (beginWord, 1) // 1 counts beginWord\n→ Initialize visited set with beginWord // avoid revisits\n→ While queue not empty:\n    → Pop word, level\n    → If word == endWord: return level // found shortest\n    → For each position i in word:\n        → For each letter a-z:\n            → If newWord != word:\n                → If newWord in wordSet and newWord not visited:\n                    → Add newWord to visited\n                    → Enqueue (newWord, level+1)\n→ Return 0 // no path\n\nBut must maintain the format: Each line with step. Use arrow. We can incorporate Decision and Yes/No.\n\nAlso maybe use \"Decision:\" lines to check conditions. Use \"Yes →\" and \"No →\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Decision: 若 endWord 不在 wordList? // 檢查目標單字是否可達\n    Yes → Step: 回傳 0 // 無法完成轉換，直接結束\n    No  → Step: 建立 wordSet = Set(wordList) // 方便 O(1) 查詢\n→ Step: 初始化 Queue 為 [(beginWord, 1)] // 1 表示包含 beginWord 的步數\n→ Step: 建立 visited = {beginWord} // 標記已訪問的單字\n→ Decision: 若 Queue 為空? // 檢查是否還有待處理單字\n    Yes → Step: 回傳 0 // 未找到目標，結束\n    No  → Step: 進入循環 // 開始 BFS\n→ While Queue not 空: // BFS 迴圈\n    → Step: 取出 (currentWord, level) 之首元素\n    → Decision: 若 currentWord == endWord? // 找到目標\n        Yes → Step: 回傳 level // 回傳最短轉換步數\n        No  → Step: 生成相鄰單字\n    → Step: 為 each i 於 currentWord 長度\n        → Step: 為 each char 在 'a'..'z'\n            → Decision: 若 char == currentWord[i]? // 避免自我替換\n                Yes → Step: 跳過\n                No  → Step: 新單字 newWord = currentWord 前半 + char + 後半\n            → Decision: 若 newWord 在 wordSet 且 newWord 未 visited?\n                Yes → Step: 加入 visited\n                Yes → Step: 入隊 (newWord, level+1)\n            → No → Step: 跳過\n→ End // 程式執行結束\n\nBut we need to produce each line exactly following the format: \"虛擬碼步驟 // 解釋\".\n\nAlso must use arrow \"→\" and \"Yes →\", \"No →\" properly. Let's refine to match example.\n\nWe may combine decisions into one line: \"Decision: 若 endWord 不在 wordList?\" etc.\n\nAlso need to show indentation? Not necessary but can show nested decisions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Decision: endWord 是否在 wordList? // 判斷目標是否存在於字典中\n    Yes → Step: 回傳 0 // 若不存在則無法完成轉換\n    No  → Step: wordSet ← Set(wordList) // 建立 O(1) 查詢集合\n→ Step: queue ← [(beginWord, 1)] // 初始隊列，1 為步數\n→ Step: visited ← {beginWord} // 記錄已訪問單字\n→ Decision: queue 是否為空? // 檢查是否有待處理單字\n    Yes → Step: 回傳 0 // 沒有路徑\n    No  → Step: 開始 BFS 迴圈 // 進入搜索\n→ While queue 不為空: // BFS 主迴圈\n    → Step: (current, level) ← queue.pop() // 取出最前面元素\n    → Decision: current 是否等於 endWord? // 判斷是否達到目標\n        Yes → Step: 回傳 level // 找到最短轉換長度\n        No  → Step: 產生相鄰單字\n    → Step: 對於 i 從 0 到 len(current)-1: // 遍歷每個位置\n        → Step: 對於 char 從 'a' 到 'z': // 嘗試替換字母\n            → Decision: char 是否等於 current[i]? // 避免無意義替換\n                Yes → Step: 跳過\n                No  → Step: newWord ← current[:i] + char + current[i+1:] // 新單字\n            → Decision: newWord 是否在 wordSet 且 newWord 不在 visited? // 合法性檢查\n                Yes → Step: visited.add(newWord) // 標記已訪問\n                Yes → Step: queue.append((newWord, level+1)) // 入隊\n                No  → Step: 跳過\n→ End // 程式執行結束\n\nWe must ensure each line starts with virtual code step, then space then // explanation. And lines like \"Yes → Step:\" but maybe we just write \"Yes → Step: ...\" but we can just use \"Yes → Step: ...\".\n\nIn example, they wrote \"Yes → Step 2: 輸出 '正數'\". So \"Yes → Step:\" is fine. For Decision lines they wrote \"Decision: 如果數字大於 0?\" etc. So we should mimic that.\n\nLet's adjust lines with \"Decision:\" and \"Yes →\" etc.\n\nThus final output:\n\n```\nStart // 程式開始執行\n→ Decision: endWord 是否在 wordList? // 判斷目標是否存在於字典中\n    Yes → Step: 回傳 0 // 若不存在則無法完成轉換\n    No  → Step: wordSet ← Set(wordList) // 建立 O(1) 查詢集合\n→ Step: queue ← [(beginWord, 1)] // 初始隊列，1 為步數\n→ Step: visited ← {beginWord} // 記錄已訪問單字\n→ Decision: queue 是否為空? // 檢查是否有待處理單字\n    Yes → Step: 回傳 0 // 沒有路徑\n    No  → Step: 開始 BFS 迴圈 // 進入搜索\n→ While queue 不為空: // BFS 主迴圈\n    → Step: (current, level) ← queue.pop() // 取出最前面元素\n    → Decision: current 是否等於 endWord? // 判斷是否達到目標\n        Yes → Step: 回傳 level // 找到最短轉換長度\n        No  → Step: 產生相鄰單字\n    → Step: 對於 i 從 0 到 len(current)-1: // 遍歷每個位置\n        → Step: 對於 char 從 'a' 到 'z': // 嘗試替換字母\n            → Decision: char 是否等於 current[i]? // 避免無意義替換\n                Yes → Step: 跳過\n                No  → Step: newWord ← current[:i] + char + current[i+1:] // 新單字\n            → Decision: newWord 是否在 wordSet 且 newWord 不在 visited? // 合法性檢查\n                Yes → Step: visited.add(newWord) // 標記已訪問\n                Yes → Step: queue.append((newWord, level+1)) // 入隊\n                No  → Step: 跳過\n→ End // 程式執行結束\n```\n\nCheck each line has space after step before //? They want \"虛擬碼步驟[空格]// 解釋\". We have that.\n\nYes.\n\nReturn only this block.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: endWord 是否在 wordList? // 判斷目標是否存在於字典中  \n Yes → Step: 回傳 0 // 若不存在則無法完成轉換  \n No  → Step: wordSet ← Set(wordList) // 建立 O(1) 查詢集合  \n→ Step: queue ← [(beginWord, 1)] // 初始隊列，1 為步數  \n→ Step: visited ← {beginWord} // 記錄已訪問單字  \n→ Decision: queue 是否為空? // 檢查是否有待處理單字  \n Yes → Step: 回傳 0 // 沒有路徑  \n No  → Step: 開始 BFS 迴圈 // 進入搜索  \n→ While queue 不為空: // BFS 主迴圈  \n → Step: (current, level) ← queue.pop() // 取出最前面元素  \n → Decision: current 是否等於 endWord? // 判斷是否達到目標  \n  Yes → Step: 回傳 level // 找到最短轉換長度  \n  No  → Step: 產生相鄰單字  \n → Step: 對於 i 從 0 到 len(current)-1: // 遍歷每個位置  \n  → Step: 對於 char 從 'a' 到 'z': // 嘗試替換字母  \n   → Decision: char 是否等於 current[i]? // 避免無意義替換  \n    Yes → Step: 跳過  \n    No  → Step: newWord ← current[:i] + char + current[i+1:] // 新單字  \n   → Decision: newWord 是否在 wordSet 且 newWord 不在 visited? // 合法性檢查  \n    Yes → Step: visited.add(newWord) // 標記已訪問  \n    Yes → Step: queue.append((newWord, level+1)) // 入隊  \n    No  → Step: 跳過  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: list[str]) -> int:\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return 0\n\n        queue = deque([(beginWord, 1)])\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in word_set:\n                        word_set.remove(new_word)\n                        queue.append((new_word, length + 1))\n        return 0\n\ndef parse_input(raw: str) -> tuple[str, str, list[str]]:\n    \"\"\"Parse the input string into beginWord, endWord and wordList.\"\"\"\n    raw = raw.strip()\n    # Replace the assignment syntax with JSON-like syntax\n    raw = raw.replace('beginWord =', '\"beginWord\":')\n    raw = raw.replace('endWord =', '\"endWord\":')\n    raw = raw.replace('wordList =', '\"wordList\":')\n    # Wrap with braces to form a dict literal\n    raw = '{' + raw + '}'\n    data = ast.literal_eval(raw)\n    return data['beginWord'], data['endWord'], data['wordList']\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if raw_input:\n        begin, end, wlist = parse_input(raw_input)\n        sol = Solution()\n        result = sol.ladderLength(begin, end, wlist)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode76.json",
    "problem_index_in_file": 0,
    "title": "Minimum Window Substring",
    "description_snippet": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, using Start, End, Decision, arrow. The problem: minimum window substring.\n\nWe need to produce a pseudo algorithm, like sliding window with two pointers, freq map, needed count, formed count.\n\nWe must output in the required format: each line: virtual code step + space + // explanation.\n\nUse Start, End, Decision: If statements use Decision.\n\nUse arrow \"→\" for each step. Indentation can be spaces? Use indentation as example? We can indent with spaces for nested decisions. The example shows indentation using 4 spaces maybe? The example uses two spaces? It's a bit ambiguous. But we can indent for clarity.\n\nWe must not output actual code, only pseudo. We'll need to include arrow and step label like \"Step X: description\". And decisions.\n\nWe need to show steps: Initialize maps, two pointers left=0,right=0, required= number of unique chars in t, formed=0, window counts map. Then iterate over s with right pointer, update counts, when count of current char equals required, increment formed. When formed==required, try to contract window from left. Keep track of min length window. Finally return substring or \"\".\n\nWe need to present as pseudo code.\n\nWe'll label steps as Step 1, Step 2 etc.\n\nUse \"Decision:\" for if checks.\n\nFor loops we can write \"Loop: while right < n\" etc.\n\nLet's produce.\n\nWe need to produce each line with virtual code and explanation comment. Use arrow.\n\nWe'll start with Start.\n\nLet's write lines:\n\nStart // 程式開始執行\n\n→ Step 1: Initialize frequency map of t (needCount) // 建立 t 中每個字元所需的數量\n\n→ Step 2: required = number of keys in needCount // 需要匹配的獨立字元數量\n\n→ Step 3: left = 0; right = 0 // 左右滑動指標\n\n→ Step 4: formed = 0 // 目前滑窗中已滿足需求的字元數量\n\n→ Step 5: windowCounts = empty map // 滑窗內字元計數\n\n→ Step 6: minLen = infinity; minStart = 0 // 最小窗口長度與起點\n\n→ Step 7: Loop: while right < n // 循環遍歷 s\n\n    → Step 7.1: char = s[right] // 取右指標字元\n\n    → Step 7.2: Update windowCounts[char]++ // 增加滑窗計數\n\n    → Step 7.3: If windowCounts[char] == needCount[char] then formed++ // 如果滑窗已滿足此字元需求\n\n    → Step 7.4: right++ // 右指標右移\n\n    → Decision: 是否已形成滿足所有需求? // 判斷 formed 是否等於 required\n\n        Yes → Step 7.5: Contract loop: while left <= right-1 and formed == required // 收縮窗口\n\n            → Decision: 是否可以進一步收縮? // 檢查左側字元是否仍滿足需求\n\n                Yes → Step 7.5.1: charL = s[left] // 取左指標字元\n\n                → Step 7.5.2: If windowCounts[charL] == needCount[charL] then formed-- // 收縮後字元需求可能不足\n\n                → Step 7.5.3: Update windowCounts[charL]-- // 減少滑窗計數\n\n                → Step 7.5.4: left++ // 左指標右移\n\n                No → Step 7.5.5: currentLen = right - left // 目前窗口長度\n\n                → Step 7.5.6: If currentLen < minLen then minLen = currentLen; minStart = left // 更新最小窗口\n\n            // 退出 Contract loop\n\n        No → // 不進行收縮，繼續右指標滑動\n\n→ Decision: 是否已遍歷完 s? // 判斷 right 是否等於 n\n\n    Yes → // 已完成主循環\n\n→ Step 8: If minLen == infinity then return \"\" // 無符合窗口\n\n    No → Step 9: return s.substr(minStart, minLen) // 返回最小窗口子字串\n\nEnd // 程式執行結束\n\nBut we need each line with \"虛擬碼步驟\" and comment. Should we number steps? Yes.\n\nWe need to format each line as \"→ Step X: ...\" maybe with indent.\n\nMake sure each line has virtual code + space + \"// explanation\".\n\nEnsure we use Decision: properly.\n\nAlso we need to indent nested steps for clarity. In example, they indent 4 spaces after decision. We'll mimic.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Initialize frequency map of t (needCount) // 建立 t 中每個字元所需的數量\n→ Step 2: required = number of keys in needCount // 需要匹配的獨立字元數量\n→ Step 3: left = 0; right = 0 // 左右滑動指標\n→ Step 4: formed = 0 // 目前滑窗中已滿足需求的字元類別數\n→ Step 5: windowCounts = empty map // 滑窗內字元計數\n→ Step 6: minLen = infinity; minStart = 0 // 最小窗口長度與起點\n→ Step 7: Loop: while right < n // 循環遍歷 s\n    → Step 7.1: char = s[right] // 取右指標字元\n    → Step 7.2: Update windowCounts[char]++ // 增加滑窗計數\n    → Step 7.3: Decision: if windowCounts[char] == needCount[char] then formed++ // 如果滑窗已滿足此字元需求\n        Yes → // formed 增加\n    → Step 7.4: right++ // 右指標右移\n    → Decision: 是否已形成滿足所有需求? // 判斷 formed 是否等於 required\n        Yes → Step 7.5: Contract loop: while left <= right-1 and formed == required // 收縮窗口\n            → Decision: 是否可以進一步收縮? // 檢查左側字元是否仍滿足需求\n                Yes → Step 7.5.1: charL = s[left] // 取左指標字元\n                → Step 7.5.2: Decision: if windowCounts[charL] == needCount[charL] then formed-- // 收縮後字元需求可能不足\n                    Yes → // formed 減少\n                → Step 7.5.3: Update windowCounts[charL]-- // 減少滑窗計數\n                → Step 7.5.4: left++ // 左指標右移\n                No → Step 7.5.5: currentLen = right - left // 目前窗口長度\n                → Step 7.5.6: Decision: if currentLen < minLen then minLen = currentLen; minStart = left // 更新最小窗口\n                    Yes → // minLen 與 minStart 更新\n        No → // 不進行收縮，繼續右指標滑動\n→ Decision: 是否已遍歷完 s? // 判斷 right 是否等於 n\n    Yes → // 已完成主循環\n→ Step 8: Decision: if minLen == infinity then return \"\" // 無符合窗口\n    Yes → // 回傳空字串\n    No → Step 9: return s.substr(minStart, minLen) // 返回最小窗口子字串\nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n        dict_t = Counter(t)\n        required = len(dict_t)\n        l = r = 0\n        formed = 0\n        window_counts = {}\n        ans = (float(\"inf\"), 0, 0)  # (window length, left, right)\n\n        while r < len(s):\n            char = s[r]\n            window_counts[char] = window_counts.get(char, 0) + 1\n            if char in dict_t and window_counts[char] == dict_t[char]:\n                formed += 1\n\n            while l <= r and formed == required:\n                char_left = s[l]\n                if r - l + 1 < ans[0]:\n                    ans = (r - l + 1, l, r)\n\n                window_counts[char_left] -= 1\n                if char_left in dict_t and window_counts[char_left] < dict_t[char_left]:\n                    formed -= 1\n                l += 1\n            r += 1\n\n        return \"\" if ans[0] == float(\"inf\") else s[ans[1]:ans[2] + 1]\n\ndef parse_input(text: str):\n    \"\"\"Extract two quoted strings from input like:\n       s = \"ADOBECODEBANC\", t = \"ABC\"\n    \"\"\"\n    import re\n    parts = re.findall(r'\"(.*?)\"', text)\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    s, t = parse_input(data)\n    sol = Solution()\n    result = sol.minWindow(s, t)\n    # Output with double quotes as shown in examples\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
          "expected_output": "\"BANC\"",
          "success": true,
          "output": "\"BANC\""
        },
        {
          "example_index": 1,
          "input": "s = \"a\", t = \"a\"",
          "expected_output": "\"a\"",
          "success": true,
          "output": "\"a\""
        },
        {
          "example_index": 2,
          "input": "s = \"a\", t = \"aa\"",
          "expected_output": "\"\"",
          "success": true,
          "output": "\"\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode420.json",
    "problem_index_in_file": 0,
    "title": "Strong Password Checker",
    "description_snippet": "A password is considered strong if the below conditions are all met:\n\nIt has at least 6 characters a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for algorithm: minimum steps to make password strong. Conditions: length 6-20, at least one lowercase, uppercase, digit, no three repeating chars. Standard Leetcode 420. We produce line by line virtual code with explanations. Provide steps: check length, count missing types, find repeats, calculate replacements, deletions etc.\n\nWe need to produce in Chinese traditional. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Let's produce algorithm.\n\nLet's outline:\n\nStart\n→ Step 1: Initialize variables: n = len(password)\n→ Step 2: Count missing types: missing = 3 - (hasLower + hasUpper + hasDigit)\n→ Step 3: Find repeats: iterate through password, count sequences of same char length >=3, store length, also calculate replace_needed = sum(len//3)\n→ Step 4: If n < 6:\n    → Step 5: Need inserts = 6 - n\n    → Step 6: result = max(missing, replace_needed, inserts)\n    → Step 7: Return result\n→ Step 4: If n between 6 and 20:\n    → Step 5: result = max(missing, replace_needed)\n    → Step 6: Return result\n→ Step 4: If n > 20:\n    → Step 5: deletions_needed = n - 20\n    → Step 6: Reduce replace_needed by deleting strategically: for repeats where len%3==0 reduce by 1 deletion each until deletions_needed 0, then for len%3==1 reduce by 2 deletions, then len%3==2 reduce by 3 deletions.\n    → Step 7: After deletions, replace_needed = max(0, replace_needed)\n    → Step 8: result = deletions_needed + max(missing, replace_needed)\n    → Step 9: Return result\nEnd\n\nNeed to express loops and decisions.\n\nMake each line: e.g., \"→ Decision: password length < 6?\".\n\nWe'll produce lines.\n\nMake sure each line ends with \"// explanation\".\n\nLet's generate.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: n ← length(password) // 取得密碼長度\n→ Step 2: hasLower ← 0, hasUpper ← 0, hasDigit ← 0 // 初始化字符類型計數\n→ Decision: 遍歷每個字符? // 檢查是否含有小寫、大寫、數字\n    → Yes → Step 3: 若字符為小寫則 hasLower ← 1 // 記錄小寫字母\n    → Yes → Step 4: 若字符為大寫則 hasUpper ← 1 // 記錄大寫字母\n    → Yes → Step 5: 若字符為數字則 hasDigit ← 1 // 記錄數字\n→ Step 6: missing ← 3 - (hasLower + hasUpper + hasDigit) // 計算缺失類型數\n→ Step 7: repeats ← [] // 儲存連續相同字符序列長度\n→ Step 8: i ← 0 // 初始化索引\n→ Decision: i < n? // 遍歷整個密碼\n    → Yes → Step 9: j ← i // 開始新序列\n    → Decision: j < n AND password[j] = password[i]? // 判斷是否連續相同\n        → Yes → Step 10: j ← j + 1 // 擴展序列\n        → No  → Step 11: len ← j - i // 序列長度\n        → Decision: len ≥ 3? // 是否為重複序列\n            → Yes → Step 12: repeats.append(len) // 儲存長度\n        → Step 13: i ← j // 移動至下一個未處理字符\n    → No → Step 14: i ← i + 1 // 向前移動\n→ Step 15: replaceNeeded ← 0 // 計算需替換的次數\n→ Decision: repeats 为空? // 判斷是否有重複序列\n    → No  → Step 16: For each len in repeats:\n        → Step 17: replaceNeeded ← replaceNeeded + floor(len / 3) // 每3個重複需要一次替換\n→ Decision: n < 6? // 長度不足6\n    → Yes → Step 18: insertsNeeded ← 6 - n // 需要插入字符數\n    → Step 19: result ← max(missing, replaceNeeded, insertsNeeded) // 取最大步驟數\n    → Step 20: Return result // 結束\n→ Decision: n ≤ 20? // 長度在區間內\n    → Yes → Step 21: result ← max(missing, replaceNeeded) // 取最大步驟數\n    → Step 22: Return result // 結束\n→ Decision: n > 20? // 長度超過20\n    → Yes → Step 23: deletesNeeded ← n - 20 // 需要刪除字符數\n    → Step 24: // 先依次消除重複序列中的可削減替換\n    → Step 25: For each len in repeats:\n        → Step 26: If len % 3 == 0 AND deletesNeeded > 0:\n            → Step 27: delCount ← min(1, deletesNeeded) // 刪除1個\n            → Step 28: len ← len - delCount\n            → Step 29: deletesNeeded ← deletesNeeded - delCount\n            → Step 30: replaceNeeded ← replaceNeeded - delCount // 替換需求減1\n        → Step 31: If len % 3 == 1 AND deletesNeeded > 0:\n            → Step 32: delCount ← min(2, deletesNeeded)\n            → Step 33: len ← len - delCount\n            → Step 34: deletesNeeded ← deletesNeeded - delCount\n            → Step 35: replaceNeeded ← replaceNeeded - floor(delCount / 2)\n        → Step 36: If len % 3 == 2 AND deletesNeeded > 0:\n            → Step 37: delCount ← min(3, deletesNeeded)\n            → Step 38: len ← len - delCount\n            → Step 39: deletesNeeded ← deletesNeeded - delCount\n            → Step 40: replaceNeeded ← replaceNeeded - floor(delCount / 3)\n    → Step 41: // 若還有剩餘刪除，均可減少一個替換\n    → Step 42: replaceNeeded ← max(0, replaceNeeded - deletesNeeded)\n    → Step 43: result ← (n - 20) + max(missing, replaceNeeded) // 刪除 + 最大需求\n    → Step 44: Return result // 結束\nEnd // 程式執行結束",
      "generated_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport sys\nimport re\n\nclass Solution:\n    def strongPasswordChecker(self, s: str) -> int:\n        \"\"\"\n        計算將密碼強度化所需的最小步驟數。\n        \"\"\"\n        n = len(s)\n\n        # 1. 判斷是否缺少三種字符類型\n        has_lower = has_upper = has_digit = 0\n        for c in s:\n            if c.islower():\n                has_lower = 1\n            elif c.isupper():\n                has_upper = 1\n            elif c.isdigit():\n                has_digit = 1\n        missing_types = 3 - (has_lower + has_upper + has_digit)\n\n        # 2. 找出重複序列，計算需要替換的次數\n        replace = 0\n        one_mod = two_mod = 0  # 用於刪除時優先順序\n        i = 2\n        while i < n:\n            if s[i] == s[i-1] == s[i-2]:\n                length = 2\n                while i < n and s[i] == s[i-1]:\n                    length += 1\n                    i += 1\n                replace += length // 3\n                if length % 3 == 0:\n                    one_mod += 1\n                elif length % 3 == 1:\n                    two_mod += 1\n            else:\n                i += 1\n\n        # 3. 根據長度分三種情況處理\n        if n < 6:\n            # 長度不足，需要插入，同時還要滿足缺失類型和替換\n            return max(6 - n, missing_types, replace)\n        elif n <= 20:\n            # 長度在合法範圍，直接取缺失類型與替換的較大值\n            return max(missing_types, replace)\n        else:\n            # 長度過長，需要先刪除\n            delete = n - 20\n\n            # 優先刪除使得 replace 減少的序列\n            reduce = min(delete, one_mod)\n            replace -= reduce\n            delete -= reduce\n\n            # 再刪除能減少 2 次 replace 的序列\n            reduce = min(delete // 2, two_mod)\n            replace -= reduce\n            delete -= reduce * 2\n\n            # 最後剩餘刪除會減少 3 次 replace\n            replace -= delete // 3\n\n            # 結果 = 刪除步驟 + max(缺失類型, 替換次數)\n            return (n - 20) + max(missing_types, replace)\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從輸入字串中抽取密碼值。\n    支援兩種形式：\n    1. password = \"abc123\"\n    2. 直接輸入密碼\n    \"\"\"\n    match = re.search(r'password\\s*=\\s*\"(.*)\"', raw)\n    if match:\n        return match.group(1)\n    # 若沒有符合上述格式，直接移除空白與引號再回傳\n    return raw.strip().strip('\"')\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    pwd = parse_input(raw_input)\n\n    sol = Solution()\n    result = sol.strongPasswordChecker(pwd)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "password = \"a\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "password = \"aA1\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "password = \"1337C0d3\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode643.json",
    "problem_index_in_file": 0,
    "title": "Maximum Average Subarray I",
    "description_snippet": "You are given an integer array nums consisting of n elements, and an integer k.\n\nFind a contiguous s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode that finds subarray length k with max average. Approach: sliding window sum of length k, keep max sum, compute avg. Complexity O(n). We'll produce lines with \"Start\", \"→ Step 1: Input array and k\", etc. Ensure explanation per line. We'll use Decision nodes maybe to handle edge cases: if n < k etc. Provide virtual code. Let's produce lines:\n\nStart\n→ Step 1: Read input array nums and integer k // get data\n→ Decision: If length of nums < k? // check invalid\n    Yes → Step 2: Return error // or handle\n    No  → Step 3: Initialize windowSum = sum of first k elements // compute first window sum\n→ Step 4: maxSum = windowSum // set max\n→ Step 5: For i from k to length(nums)-1: // slide window\n        → SubStep: windowSum = windowSum - nums[i-k] + nums[i] // update sum\n        → Decision: If windowSum > maxSum? // check max\n            Yes → maxSum = windowSum // update\n→ Step 6: Compute maxAvg = maxSum / k // average\n→ End // return maxAvg\n\nAdd explanations. Use virtual arrow formatting: \"→\" before each step. For substeps maybe indent? but format only requires \"虛擬碼步驟\" + space + \" // 解釋\". Use indentation by spaces? The example uses indentation for decisions. We'll follow that.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read input array nums and integer k // 取得陣列與目標長度  \n→ Decision: 若 nums 的長度 < k? // 檢查是否能形成長度為 k 的子陣列  \n Yes → Step 2: 回傳錯誤或 0 // 無法形成子陣列時結束  \n No  → Step 3: 計算前 k 個元素之和 windowSum = sum(nums[0…k-1]) // 初始滑動窗口總和  \n→ Step 4: maxSum = windowSum // 設定目前最大子陣列總和  \n→ Step 5: 從 i = k 到 nums.length-1 迴圈滑動窗口  \n  → SubStep: windowSum = windowSum - nums[i-k] + nums[i] // 移除最左邊元素並加入右邊元素  \n  → Decision: 若 windowSum > maxSum? // 比較是否為新最大總和  \n   Yes → maxSum = windowSum // 更新最大總和  \n→ Step 6: maxAvg = maxSum / k // 計算最大平均值  \n→ End // 回傳 maxAvg 為結果（允許 10^-5 的誤差）",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findMaxAverage(self, nums, k):\n        if not nums or k <= 0 or k > len(nums):\n            return 0.0\n        window_sum = sum(nums[:k])\n        max_sum = window_sum\n        for i in range(k, len(nums)):\n            window_sum += nums[i] - nums[i - k]\n            if window_sum > max_sum:\n                max_sum = window_sum\n        return max_sum / k\n\ndef parse_input(data: str):\n    # Extract the list of numbers\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    nums = ast.literal_eval(nums_match.group(1)) if nums_match else []\n\n    # Extract k\n    k_match = re.search(r'k\\s*=\\s*([-\\d\\.]+)', data)\n    k = int(k_match.group(1)) if k_match else 0\n\n    return nums, k\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read().strip()\n    nums, k = parse_input(raw_data)\n\n    solution = Solution()\n    max_avg = solution.findMaxAverage(nums, k)\n\n    # Output with 5 decimal places as in the examples\n    print(f\"{max_avg:.5f}\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,12,-5,-6,50,3], k = 4",
          "expected_output": "12.75000",
          "success": true,
          "output": "12.75000"
        },
        {
          "example_index": 1,
          "input": "nums = [5], k = 1",
          "expected_output": "5.00000",
          "success": true,
          "output": "5.00000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode258.json",
    "problem_index_in_file": 0,
    "title": "Add Digits",
    "description_snippet": "Given an integer num, repeatedly add all its digits until the result has only one digit, and return ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for digital root problem. Need to produce line-by-line steps, with arrow, explanation. Use Start, End, Decision. Let's produce steps: Start, input num, define result = num, Decision: while result has more than one digit? Yes → compute sum of digits, set result = sum, loop back to Decision. No → output result, End. Use arrow notation. Provide comment after space. Use Chinese. Ensure each line has \"→\" or \"Start\" etc. Provide explanation. Use \"Decision:\" lines with Yes →, No →. Also use \"Step:\" lines. Should include loop. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 num // 取得使用者輸入的數字  \n→ Step 2: 設定 result = num // 用 result 來儲存目前的數字  \n→ Decision: result 是否為單一位數? // 判斷 result 是否已經只有一位  \n  Yes → Step 3: 輸出 result // 若是單一位數，直接回傳結果  \n  No  → Step 4: 計算 result 的各位數字總和 // 若有多位，求各位數字之和  \n    → Step 5: 設定 result = sum // 把求得的總和存回 result  \n    → Decision: 回到 Step 3 的判斷 // 重新檢查新的 result 是否已是單一位  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        \"\"\"\n        反覆將數字各位相加，直到結果為單一位數。\n        \"\"\"\n        while num >= 10:\n            # 先把數字轉成字串，再逐位相加\n            num = sum(int(digit) for digit in str(num))\n        return num\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，提取第一個整數並計算其數字根，最後輸出結果。\n    \"\"\"\n    data = sys.stdin.read()\n    # 使用正則表達式找出字串中的整數（允許負號）\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    num = int(nums[0])\n    result = Solution().addDigits(num)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 38",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode696.json",
    "problem_index_in_file": 0,
    "title": "Count Binary Substrings",
    "description_snippet": "Given a binary string s, return the number of non-empty substrings that have the same number of 0's ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code (like flowchart steps) to solve: Given binary string s, count number of non-empty substrings that have equal number of 0's and 1's and all 0s and 1s are grouped consecutively. Essentially count substrings that are like \"00...0111...1\" or \"11...1000...0\" where count of zeros equals count of ones. Equivalent to counting pairs of consecutive groups of same bits with equal lengths. Approach: iterate string, count lengths of consecutive groups: e.g., [3,2,1,4,...]. Then for each adjacent pair, add min(len[i], len[i+1]) to answer. Because a substring that starts at some position in group i and ends in group i+1 with same number of zeros and ones. That yields count of possible substrings.\n\nSo produce virtual code steps: Start, Step 1: Initialize variables: ans=0, prevLen=0, currLen=1, etc. But we can write more high-level: iterate through string building group lengths list. Then iterate list.\n\nBut must produce step by step with arrows and explanations. Use Start, End, Decision, etc.\n\nWe'll produce something like:\n\nStart\n→ Step 1: Initialize ans = 0, groups = empty list, i=0 // prepare variables\n→ Step 2: While i < length of s // loop through string to build groups\n   → Step 3: Set currentBit = s[i], count = 0 // get current bit\n   → Decision: While i < length and s[i] == currentBit // count same bit group\n       Yes → Step 4: count++ ; i++ // count consecutive same bit\n   → Step 5: Append count to groups // store group length\n→ Step 6: For each index j from 0 to groups.length-2 // iterate adjacent groups\n   → Step 7: ans += min(groups[j], groups[j+1]) // add number of substrings for this pair\n→ Step 8: Return ans // final answer\nEnd\n\nBut we need arrow and explanation after each line. Use arrow symbol.\n\nAlso incorporate decision nodes for loops.\n\nWe need \"逐行\" output.\n\nLet's format each line:\n\nStart // 程式開始執行\n→ Step 1: Initialize ans = 0, groups = [], i = 0 // 設置計數器、群組列表和索引\n→ Step 2: While i < len(s) // 遍歷整個字符串\n    → Decision: i < len(s) ?\n        Yes → Step 3: currentBit = s[i], count = 0 // 取當前位元並初始化計數\n        → Step 4: While i < len(s) and s[i] == currentBit // 內部循環計算相同位元連續長度\n            → Decision: i < len(s) and s[i] == currentBit ?\n                Yes → Step 5: count++ ; i++ // 增加計數並移動索引\n                No → Step 6: Append count to groups // 完成一個群組，加入列表\n        No → End // 完成外層循環\n→ Step 7: For j in 0 .. groups.length-2 // 遍歷相鄰群組\n    → Step 8: ans += min(groups[j], groups[j+1]) // 加上能形成子字符串的數量\n→ Step 9: Return ans // 回傳總數\nEnd // 程式執行結束\n\nBut we need each line to have virtual code and explanation separated by space. Must include arrow. For nested steps, we can indent or include arrow inside arrow. Use the format from example. Use \"→\" as arrow. For nested decisions, indent by spaces? In example they indent lines after Decision. We'll follow that style.\n\nWe must ensure each line has \"虛擬碼步驟\" then a space then \"// 解釋\". So the arrow is part of virtual code step.\n\nWe need to produce lines with indent. Let's produce lines like:\n\nStart // 程式開始執行\n→ Step 1: ans = 0, groups = [], i = 0 // 初始化變數\n→ Step 2: While i < len(s) // 遍歷整個字符串\n    → Decision: i < len(s) ?\n        Yes → Step 3: currentBit = s[i], count = 0 // 取目前位元並開始計數\n        → Step 4: While i < len(s) and s[i] == currentBit // 計算相同連續位元長度\n            → Decision: i < len(s) and s[i] == currentBit ?\n                Yes → Step 5: count += 1 ; i += 1 // 計數加1，索引加1\n                No → Step 6: groups.append(count) // 將群組長度加入列表\n        No → // 內層While結束\n    No → // 外層While結束\n→ Step 7: For j = 0 to len(groups)-2 // 針對相鄰群組\n    → Step 8: ans += min(groups[j], groups[j+1]) // 加上符合條件的子字串數\n→ Step 9: Return ans // 回傳結果\nEnd // 程式結束\n\nBut we need \"逐行\" output. Each line must be separate. Let's produce like:\n\nStart // 程式開始執行\n→ Step 1: ans = 0, groups = [], i = 0 // 初始化計數器、群組列表和索引\n→ Step 2: While i < len(s) // 遍歷整個字符串\n    → Decision: i < len(s) ?\n        Yes → Step 3: currentBit = s[i], count = 0 // 取目前位元並開始計數\n        → Step 4: While i < len(s) and s[i] == currentBit // 計算相同連續位元長度\n            → Decision: i < len(s) and s[i] == currentBit ?\n                Yes → Step 5: count += 1 ; i += 1 // 計數加1，索引加1\n                No → Step 6: groups.append(count) // 將群組長度加入列表\n        No → // 內層While結束\n    No → // 外層While結束\n→ Step 7: For j = 0 to len(groups)-2 // 針對相鄰群組\n    → Step 8: ans += min(groups[j], groups[j+1]) // 加上符合條件的子字串數\n→ Step 9: Return ans // 回傳結果\nEnd // 程式結束\n\nHowever we need \"逐行\" with each line containing a single virtual code step. The decision lines have nested arrow lines. In the example, they had \"Decision:\" line with indentation of nested arrows. We'll replicate.\n\nWe need to be careful that each line after the Decision: line is also a separate line. They have \"Decision: 如果數字大於 0?\" line then indented \"Yes → Step...\" etc. We'll follow that.\n\nThus final output: each line starts with \"Start\" or arrow etc.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: ans = 0, groups = [], i = 0 // 初始化計數器、群組列表和索引\n→ Step 2: While i < len(s) // 遍歷整個字符串\n    → Decision: i < len(s) ?\n        Yes → Step 3: currentBit = s[i], count = 0 // 取目前位元並開始計數\n        → Step 4: While i < len(s) and s[i] == currentBit // 計算相同連續位元長度\n            → Decision: i < len(s) and s[i] == currentBit ?\n                Yes → Step 5: count += 1 ; i += 1 // 計數加1，索引加1\n                No → Step 6: groups.append(count) // 將群組長度加入列表\n        No → // 內層While結束\n    No → // 外層While結束\n→ Step 7: For j = 0 to len(groups)-2 // 針對相鄰群組\n    → Step 8: ans += min(groups[j], groups[j+1]) // 加上符合條件的子字串數\n→ Step 9: Return ans // 回傳結果\nEnd // 程式結束",
      "generated_code": "import sys\n\ndef count_binary_substrings(s: str) -> int:\n    \"\"\"\n    計算符合條件的子字串個數：子字串的 0 與 1 數量相等，\n    並且同一個位元在子字串內必須連續排列。\n    \"\"\"\n    groups = []          # 存儲連續相同位元的長度\n    count = 1            # 第一次遇到字符時長度為 1\n\n    # 建立連續相同位元的長度清單\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            groups.append(count)\n            count = 1\n    groups.append(count)  # 最後一個群組\n\n    # 相鄰兩個群組形成的子字串數量\n    result = 0\n    for i in range(1, len(groups)):\n        result += min(groups[i], groups[i - 1])\n\n    return result\n\ndef main() -> None:\n    \"\"\"\n    讀取輸入、處理並輸出結果。\n    支援以下兩種輸入形式：\n    1. 直接輸入二進位字串，如 00110011\n    2. 帶有前綴的形式，如 s = \"00110011\"\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 若輸入包含 '='，則取等號後面的內容\n    if '=' in data:\n        _, value = data.split('=', 1)\n        s = value.strip()\n        # 去除兩側可能存在的單/雙引號\n        if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n            s = s[1:-1]\n    else:\n        # 直接使用整行內容\n        s = data.strip()\n\n    # 若字串仍為空，嘗試從多行輸入中找第一個非空行\n    if not s:\n        for line in data.splitlines():\n            line = line.strip()\n            if line:\n                s = line\n                break\n\n    result = count_binary_substrings(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"00110011\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "s = \"10101\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode205.json",
    "problem_index_in_file": 0,
    "title": "Isomorphic Strings",
    "description_snippet": "Given two strings s and t, determine if they are isomorphic.\n\nTwo strings s and t are isomorphic if ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the format. Should describe algorithm: mapping from s to t and t to s to ensure injective. Use hash maps. Steps: Start, Input s t, if lengths differ → false, else create dict mapS, mapT, loop over indices, check mapping, else map. At end true. Use Decision, etc. Provide each line with arrow and comment. Use Start, End. Use Yes/No arrows. Use Decision statements. Let's craft.\n\nWe can structure:\n\nStart\n→ Step 1: 讀入字串 s 和 t // 取得兩個字串\n→ Decision: s 長度是否等於 t？ // 確保長度相等\n    Yes → Step 2: 建立兩個映射 mapS, mapT // 用於映射字符\n    No  → Step 3: 回傳 False // 長度不等，非同構\n→ Step 4: For i from 0 to len(s)-1 // 逐字符檢查\n    → Decision: s[i] 在 mapS 中? // 檢查已有映射\n        Yes → Step 5: 若 mapS[s[i]] ≠ t[i] → Step 6: 回傳 False // 映射不一致\n        No  → Decision: t[i] 已被另一字符映射到? // 防止兩個字符映射到同一\n            Yes → Step 7: 回傳 False // 兩字符映射同一目標\n            No  → Step 8: mapS[s[i]] = t[i]; mapT[t[i]] = s[i] // 建立新映射\n→ Step 9: 回傳 True // 所有字符均符合映射規則\nEnd\n\nBut need to maintain the formatting: each line \"虛擬碼步驟 // 解釋\". Use arrows \"→\". For decisions, indent? Use the sample: Decision: ... with Yes → ... No → ... We should maintain indentation. Use tab or spaces. Probably indent with 4 spaces.\n\nAlso ensure each line includes arrow and comment.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入字串 s 和 t // 取得兩個待檢查的字串  \n→ Decision: s 長度是否等於 t？ // 若長度不同，無法同構  \n  Yes → Step 2: 建立兩個映射 mapS, mapT // mapS 用於 s → t 的映射，mapT 用於 t → s 的映射  \n  No  → Step 3: 回傳 False // 長度不同直接判定非同構  \n→ Step 4: For i from 0 to len(s)-1 // 逐個字符檢查對應關係  \n  → Decision: s[i] 已在 mapS 中映射？ // 檢查 s 中該字符是否已有映射  \n    Yes → Step 5: 若 mapS[s[i]] ≠ t[i] → Step 6: 回傳 False // 映射不一致，非同構  \n    No  → Decision: t[i] 已被另一 s 字符映射到？ // 防止兩個不同字符映射到同一目標  \n      Yes → Step 7: 回傳 False // 同一 t 字符映射自兩個不同 s 字符，非同構  \n      No  → Step 8: mapS[s[i]] = t[i]; mapT[t[i]] = s[i] // 建立新的映射對應  \n→ Step 9: 回傳 True // 所有字符均符合一一對應規則，為同構字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        mapping_s_t = {}\n        mapping_t_s = {}\n        for c1, c2 in zip(s, t):\n            if c1 in mapping_s_t and mapping_s_t[c1] != c2:\n                return False\n            if c2 in mapping_t_s and mapping_t_s[c2] != c1:\n                return False\n            mapping_s_t[c1] = c2\n            mapping_t_s[c2] = c1\n        return True\n\ndef main():\n    data = sys.stdin.read()\n    # 尝试从字符串中提取双引号内的内容\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        s, t = matches[0], matches[1]\n    else:\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            s, t = parts[0], parts[1]\n        elif len(parts) == 1:\n            s = parts[0]\n            t = ''\n        else:\n            s, t = '', ''\n    solution = Solution()\n    result = solution.isIsomorphic(s, t)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"egg\", t = \"add\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"foo\", t = \"bar\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"paper\", t = \"title\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode412.json",
    "problem_index_in_file": 0,
    "title": "Fizz Buzz",
    "description_snippet": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for FizzBuzz problem. Each line: \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nWe must not output actual code, only pseudocode steps. Use Start, End, Decision, arrow. Provide each step line. Example above shows style. We need to include for loop, decisions. Must be 1-indexed. So iterate from 1 to n. Build array answer. For each i, decide string. Use nested decisions: divisible by 3 and 5, else divisible by 3, else divisible by 5, else string of i.\n\nSo produce lines: Start, Initialize array, For i=1 to n, Decision: i%15==0? Yes→Set \"FizzBuzz\", No→Decision: i%3==0? Yes→Set \"Fizz\", No→Decision: i%5==0? Yes→Set \"Buzz\", No→Set string of i. End For. End. Provide each line with explanation.\n\nBe careful to include arrow for each step. Also indicate End of algorithm.\n\nLet's craft lines.\n\nLine1: Start // 程式開始執行\nLine2: → Step 1: 建立空陣列 answer // 用來儲存結果\nLine3: → Step 2: 設定變數 i = 1 // 初始化迴圈指標\nLine4: → Decision: i <= n? // 檢查是否還有未處理的數字\nLine5:    Yes → Step 3: 判斷 i 是否能被 15 整除 // 同時可被 3 與 5 整除\nLine6:    No  → Step 7: 迴圈結束 // 已完成所有數字\nLine7: → Decision: i % 15 == 0? // 檢查 3 與 5 同時整除\nLine8:    Yes → Step 4: answer[i] = \"FizzBuzz\" // 若同時整除，加入字串\nLine9:    No  → Decision: i % 3 == 0? // 檢查是否能被 3 整除\nLine10:   Yes → Step 5: answer[i] = \"Fizz\" // 只被 3 整除\nLine11:   No  → Decision: i % 5 == 0? // 檢查是否能被 5 整除\nLine12:   Yes → Step 6: answer[i] = \"Buzz\" // 只被 5 整除\nLine13:   No  → Step 7: answer[i] = i as string // 既不被 3 也不被 5 整除\nLine14: → Step 8: i = i + 1 // 進行下一個數字\nLine15: → Go back to Decision: i <= n? // 重新檢查迴圈條件\nLine16: End // 程式執行結束\n\nBut we need to maintain numbering consistent? It's fine.\n\nBut we have step numbering: Step 1, Step 2, etc. Actually earlier we used Step 1, Step 2. Then Step 3 inside? Might cause confusion. We can keep simple: Step 1, Step 2, etc. For nested decisions we can refer to them as Step 3, etc. Ensure each line is separate. Let's produce final.\n\nWe should maintain the format: Each line has a virtual code step, a space, then `// 解釋`. Use arrows etc.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空陣列 answer // 用來儲存 1~n 的結果  \n→ Step 2: 設定變數 i = 1 // 初始化迴圈指標  \n→ Decision: i <= n? // 判斷是否還有未處理的數字  \n Yes → Step 3: 判斷 i 是否能被 15 整除 // 同時可被 3 與 5 整除  \n No  → Step 8: 迴圈結束 // 已完成所有數字  \n→ Decision: i % 15 == 0? // 檢查 3 與 5 同時整除  \n Yes → Step 4: answer[i] = \"FizzBuzz\" // 若同時整除，加入字串  \n No  → Decision: i % 3 == 0? // 檢查是否能被 3 整除  \n  Yes → Step 5: answer[i] = \"Fizz\" // 只被 3 整除  \n  No  → Decision: i % 5 == 0? // 檢查是否能被 5 整除  \n   Yes → Step 6: answer[i] = \"Buzz\" // 只被 5 整除  \n   No  → Step 7: answer[i] = i as string // 既不被 3 也不被 5 整除  \n→ Step 8: i = i + 1 // 進行下一個數字  \n→ Go back to Decision: i <= n? // 重新檢查迴圈條件  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def fizzBuzz(self, n):\n        res = []\n        for i in range(1, n + 1):\n            if i % 15 == 0:\n                res.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                res.append(\"Fizz\")\n            elif i % 5 == 0:\n                res.append(\"Buzz\")\n            else:\n                res.append(str(i))\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        sys.exit()\n    n = int(nums[0])\n    solution = Solution()\n    result = solution.fizzBuzz(n)\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"1\",\"2\",\"Fizz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\"]"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode150.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Reverse Polish Notation",
    "description_snippet": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polis...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo-code for evaluating RPN. Use virtual code lines, each line with arrow and explanation comment. Should cover stack usage. Provide decisions for operators, pop operands, push result. Ensure truncation toward zero division.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize empty stack // stack for operands\n→ For each token in tokens: // iterate\n    Decision: If token is operator? // check\n        Yes → Step 2: Pop operand2 // second operand\n        Step 3: Pop operand1 // first operand\n        Step 4: Compute result = operand1 operator operand2 // apply op\n        Step 5: Push result // push back\n        No  → Step 6: Convert token to integer // operand\n        Step 7: Push integer // onto stack\n→ Step 8: Result = stack.pop() // final value\nEnd\n\nWe also need to handle division truncation: result = int(operand1 / operand2) with trunc toward zero. In pseudo-code, we can write: result = trunc(operand1 / operand2)\n\nAlso for integer parsing.\n\nWe should produce lines with \"Step X: ...\". Use arrow \"→\". For decisions, indent inside. Provide explanatory comments. Use Start End markers.\n\nMake sure each line ends with \"// 解釋/說明\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空的堆疊 stack // 用來存放運算子和中間結果  \n→ For 每個 token in tokens: // 逐一處理後綴式字串  \n&nbsp;&nbsp;Decision: token 是運算符號 (+, -, *, /) 嗎? // 判斷是算式還是數字  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2: 取出 stack.pop() → 變數 operand2 // 取出右邊的運算子  \n&nbsp;&nbsp;&nbsp;&nbsp;Step 3: 取出 stack.pop() → 變數 operand1 // 取出左邊的運算子  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: token 是 '+' 嗎?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: result = operand1 + operand2  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: token 是 '-' 嗎?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: result = operand1 - operand2  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: token 是 '*' 嗎?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: result = operand1 * operand2  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step 7: result = trunc(operand1 / operand2) // 除法向零截斷  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 8: push result onto stack // 將計算結果存回堆疊  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Step 9: 將 token 轉成整數 value = int(token) // 處理數字  \n&nbsp;&nbsp;&nbsp;&nbsp;Step 10: push value onto stack // 把數字放進堆疊  \n→ Step 11: 最終結果 = stack.pop() // 取出堆疊中的唯一元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                elif token == '/':\n                    # 向零取整\n                    stack.append(int(a / b))\n            else:\n                stack.append(int(token))\n        return stack[0]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 解析輸入，支援 'tokens = [...]' 或直接輸入 list\n    if data.startswith('tokens'):\n        _, tokens_str = data.split('=', 1)\n        tokens = ast.literal_eval(tokens_str.strip())\n    else:\n        tokens = ast.literal_eval(data)\n    result = Solution().evalRPN(tokens)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
          "expected_output": "22",
          "success": true,
          "output": "22"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode90.json",
    "problem_index_in_file": 0,
    "title": "Subsets II",
    "description_snippet": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all unique subsets of array with duplicates. We produce backtracking. Provide step-by-step lines with arrows and explanations. Let's craft. Use \"Start\", \"→\" arrow, \"Decision:\" etc.\n\nWe must be careful to include steps like sorting, backtracking, skip duplicates. Provide explanation for each line. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入陣列 nums 並排序 // 先排序以便後續判斷重複元素  \n→ Step 2: 建立空列表 result 來存儲所有子集 // 結果集合  \n→ Step 3: 定義遞迴函數 backtrack(index, current) // index: 當前處理的位置, current: 目前組成的子集  \n→     Inside backtrack:  \n→         Decision: 是否把 current 加入結果? // 任何時候都把當前子集加入結果集合  \n→             Yes → Step 4: 把 current 的複製加到 result // 儲存子集  \n→         Decision: index 是否已經超過陣列長度? // 遞迴終止條件  \n→             Yes → Return // 已處理完所有元素  \n→         Decision: 是否需要跳過重複元素? // 若當前元素等於前一個且前一個未被使用，則跳過  \n→             Yes → Step 5: index++  // 跳過相同元素，避免重複子集  \n→         Decision: 是否考慮包含 nums[index]? // 進行兩種分支  \n→             Yes → Step 6: 把 nums[index] 加入 current  \n→             → backtrack(index + 1, current) // 進行下一層遞迴  \n→             → Step 7: 從 current 移除最後一個元素 // 回溯，恢復狀態  \n→             No  → backtrack(index + 1, current) // 直接跳過此元素  \n→ End of backtrack definition  \n→ Step 8: 呼叫 backtrack(0, 空列表) // 開始遞迴  \n→ Step 9: 返回 result // 程式結束，輸出所有唯一子集  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"回溯法產生所有不重複的子集\"\"\"\n        nums.sort()                      # 先排序，方便跳過重複元素\n        res: List[List[int]] = []\n\n        def backtrack(start: int, path: List[int]) -> None:\n            # 任何時候都把目前的子集加入結果\n            res.append(path.copy())\n\n            # 從 start 開始嘗試加入每個元素\n            for i in range(start, len(nums)):\n                # 跳過重複元素，避免產生重複子集\n                if i > start and nums[i] == nums[i - 1]:\n                    continue\n                path.append(nums[i])          # 選擇 nums[i]\n                backtrack(i + 1, path)        # 進一步遞迴\n                path.pop()                    # 回溯，移除最後一個元素\n\n        backtrack(0, [])\n        return res\n\ndef parse_input(data: str) -> List[int]:\n    \"\"\"將輸入字串轉成 list[int]，支援 'nums = [...]' 或直接列表字串\"\"\"\n    data = data.strip()\n    if data.startswith(\"nums\"):\n        # 移除前面的 'nums' 以及等號\n        _, expr = data.split(\"=\", 1)\n        data = expr.strip()\n    return ast.literal_eval(data)\n\ndef main() -> None:\n    raw = sys.stdin.read()\n    if not raw:\n        return\n    nums = parse_input(raw)\n    sol = Solution()\n    subsets = sol.subsetsWithDup(nums)\n    print(subsets)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "success": true,
          "output": "[[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[], [0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode415.json",
    "problem_index_in_file": 0,
    "title": "Add Strings",
    "description_snippet": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode that adds two numbers represented as strings, no big integer conversion, no library, no convert to int directly. We need to output virtual code line by line with explanations. Should be in Traditional Chinese. Use arrows → and decision structure. Provide each line: \"虛擬碼步驟 // 解釋/說明\". The requirement: \"虛擬碼步驟\" meaning the step description. Use Start, End, Decision: etc. Provide step-by-step algorithm: reverse strings, iterate, compute sum digit by digit with carry, build result string, reverse at end.\n\nWe must ensure no actual code, just pseudocode. Each line with a comment after space. We'll output step by step.\n\nWe need to include arrow arrow for next step. Let's design:\n\nStart // Start\n→ Step 1: 初始化 carry 為 0，result 為空字符串 // 設定初始值\n→ Step 2: 設定 idx1 為 num1 的最後一個索引，idx2 為 num2 的最後一個索引 // 準備從末尾開始遍歷\n→ Decision: 是否 idx1 >= 0 或 idx2 >= 0 或 carry != 0? // 判斷是否還有數字或進位需要處理\n    Yes → Step 3: 取 digit1 為 (idx1 >= 0 ? num1[idx1] - '0' : 0) // 從 num1 取得當前位數字\n    → Step 4: 取 digit2 為 (idx2 >= 0 ? num2[idx2] - '0' : 0) // 從 num2 取得當前位數字\n    → Step 5: 計算 total = digit1 + digit2 + carry // 取得本位總和\n    → Step 6: 更新 carry 為 total / 10 // 計算進位\n    → Step 7: 將 (total % 10) 轉為字符並加到 result 前面 // 建立結果字符串\n    → Step 8: idx1--，idx2-- // 移動到上一位\n    → Decision: 是否需要重複上述步驟? // 這裡重複直到結束\n        Yes → 回到 Step 3\n        No  → Step 9: 將 result 轉為字符串輸出 // 完成\nEnd // 結束\n\nBut need to use decision lines properly. Let's create the structure: Start, Step, Decision: etc. Each step arrow points to next step. For decision, we need Yes → and No → arrows.\n\nWe need to ensure each line is separated. Each line: \"虛擬碼步驟 // 解釋\". Use Traditional Chinese. Use arrow \"→\" to indicate next step.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 初始化 carry = 0, result = \"\" // 設定初始值\n→ Step 2: idx1 = num1.length - 1, idx2 = num2.length - 1 // 從最後一位開始\n→ Decision: idx1 >= 0 或 idx2 >= 0 或 carry > 0? // 判斷是否還有位數或進位\n    Yes → Step 3: digit1 = (idx1 >= 0 ? num1[idx1] - '0' : 0) // 取得 num1 的位數\n    → Step 4: digit2 = (idx2 >= 0 ? num2[idx2] - '0' : 0) // 取得 num2 的位數\n    → Step 5: total = digit1 + digit2 + carry // 計算本位總和\n    → Step 6: carry = total / 10 // 更新進位\n    → Step 7: result = (total % 10) + result // 將餘數加到結果前面\n    → Step 8: idx1--; idx2--; // 移動索引\n    → Decision: 是否繼續? // 重新檢查條件\n        Yes → 回到 Step 3\n        No  → Step 9: 輸出 result // 結束\nEnd // 程式結束\n\nBut the requirement: \"虛擬碼步驟\" is each step. Use \"Step X:\" maybe.\n\nAlso need arrow for decision branches. We must include \"Decision:\" lines.\n\nLet's craft final output with proper indentation for readability.\n\nAlso ensure we mention that we are not converting to int; we only treat char as digit by subtracting '0'.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 初始化 carry = 0, result = \"\" // 設定初始進位與結果字串\n→ Step 2: idx1 = num1.length - 1, idx2 = num2.length - 1 // 由字串尾端開始逐位相加\n→ Decision: idx1 >= 0 或 idx2 >= 0 或 carry > 0? // 判斷是否還有位數或進位未處理\n    Yes → Step 3: digit1 = (idx1 >= 0 ? num1[idx1] - '0' : 0) // 取得 num1 的當前位數字，若已結束則為 0\n    → Step 4: digit2 = (idx2 >= 0 ? num2[idx2] - '0' : 0) // 取得 num2 的當前位數字，若已結束則為 0\n    → Step 5: total = digit1 + digit2 + carry // 本位總和\n    → Step 6: carry = total / 10 // 更新進位\n    → Step 7: result = (total % 10) + result // 將本位餘數轉為字元並加到結果前面\n    → Step 8: idx1--; idx2--; // 移動索引至上一位\n    → Decision: 是否繼續處理? // 重新檢查條件\n        Yes → 回到 Step 3\n        No  → Step 9: 輸出 result // 完成加法，返回字串結果\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n        while i >= 0 or j >= 0 or carry:\n            x = ord(num1[i]) - 48 if i >= 0 else 0\n            y = ord(num2[j]) - 48 if j >= 0 else 0\n            total = x + y + carry\n            res.append(chr(total % 10 + 48))\n            carry = total // 10\n            i -= 1\n            j -= 1\n        return ''.join(reversed(res))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = re.findall(r'\"([^\"]*)\"', data)\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n    else:\n        # If input format is like: 11 123\n        parts = data.split()\n        num1, num2 = parts[0], parts[1] if len(parts)>1 else ''\n    sol = Solution()\n    result = sol.addStrings(num1, num2)\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "success": true,
          "output": "\"134\""
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "success": true,
          "output": "\"533\""
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "success": true,
          "output": "\"0\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode440.json",
    "problem_index_in_file": 0,
    "title": "K-th Smallest in Lexicographical Order",
    "description_snippet": "Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n]....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: given n and k, return the kth lexicographically smallest integer in [1,n]. It's like finding k-th number in lexicographic order. Approach: iterate through numbers, counting steps between prefixes. Use DFS style counting number of nodes in subtree. Standard algorithm: while k>1, find next prefix by counting steps between cur and cur+1. Steps: count = 0; for (first=cur; first<=n; first*=10) { count += min(n+1, first*10) - first; } Then if count < k, cur++; k -= count; else cur*=10; k--; until k==1 return cur.\n\nBut we can produce pseudo-code step by step.\n\nWe must follow format: each line with virtual code step and explanation comment.\n\nWe need to use arrows and decisions. We'll produce start, input, variable init, loop, decisions, end.\n\nLet's design:\n\nStart\n→ Input n, k\n→ Step: cur = 1 // current prefix\n→ Step: while k > 1\n    → Step: count = 0 // number of nodes between cur and cur+1\n    → Step: first = cur\n    → Decision: while first <= n\n        → Step: count += min(n+1, first*10) - first // nodes in this subtree\n        → Step: first *= 10\n    → Decision: if count < k\n        → Step: cur += 1 // move to next sibling\n        → Step: k -= count\n    → Decision: else\n        → Step: cur *= 10 // go deeper into subtree\n        → Step: k -= 1\n→ Step: return cur\nEnd\n\nBut we need arrow syntax: \"→\" before each step, \"Decision:\" with Yes/No branches.\n\nBetter structure: Use while loop with decision inside. But we can express with arrow and decisions.\n\nLet's produce line by line.\n\n1. Start // 程式開始執行\n2. → Input n, k // 取得範圍上限與目標序號\n3. → cur = 1 // 設定目前前綴為 1\n4. → Decision: k > 1? // 是否還有步驟需要處理\n    Yes → Step: count = 0 // 初始化子樹節點數\n    Yes → Step: first = cur // 以目前前綴作為起點\n    Yes → Decision: first <= n? // 計算子樹大小\n        Yes → Step: count += min(n+1, first*10) - first // 加上此層節點數\n        Yes → Step: first *= 10 // 移至下一級子節點\n        No  → // 結束內層迴圈\n    Yes → Decision: count < k? // 能否跳過整個子樹\n        Yes → Step: cur += 1 // 移至下一個兄弟前綴\n        Yes → Step: k -= count // 更新剩餘步數\n        No  → Step: cur *= 10 // 進入子樹\n        No  → Step: k -= 1 // 在子樹內減少一步\n    No  → // k==1 時結束 while\n5. → Step: return cur // 回傳 kth 小序號\n6. End // 程式結束\n\nBut we need each line to have a virtual code step and comment. For decision branches we need \"Yes →\" and \"No →\" lines with indent. Ensure proper formatting.\n\nWe should not output actual code but structure. Let's produce as required. Ensure each line is separate, with virtual code step + comment. Use \"Decision:\" with branches. Also we may need to include \"→ Step:\" lines.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Input n, k // 取得範圍上限與目標序號\n→ cur = 1 // 設定目前前綴為 1\n→ Decision: k > 1? // 是否還有步驟需要處理\n    Yes → Step: count = 0 // 初始化子樹節點數\n    Yes → Step: first = cur // 以目前前綴作為起點\n    Yes → Decision: first <= n? // 計算子樹大小\n        Yes → Step: count += min(n+1, first*10) - first // 加上此層節點數\n        Yes → Step: first *= 10 // 移至下一級子節點\n        No  → // 結束內層迴圈\n    Yes → Decision: count < k? // 能否跳過整個子樹\n        Yes → Step: cur += 1 // 移至下一個兄弟前綴\n        Yes → Step: k -= count // 更新剩餘步數\n        No  → Step: cur *= 10 // 進入子樹\n        No  → Step: k -= 1 // 在子樹內減少一步\n    No  → // k==1 時結束 while\n→ Step: return cur // 回傳 kth 小序號\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        \"\"\"\n        找到範圍 [1, n] 中第 k 個字典序數字。\n        使用「前綴計數」方法，時間複雜度為 O(log10(n) * log10(n))。\n        \"\"\"\n        def count_prefix(prefix: int, n: int) -> int:\n            \"\"\"計算所有以 prefix 為前綴的數字個數（不超過 n）。\"\"\"\n            cur = prefix\n            nxt = prefix + 1\n            cnt = 0\n            while cur <= n:\n                # 本層中介於 cur 與 nxt-1 的所有數字\n                cnt += min(n + 1, nxt) - cur\n                cur *= 10\n                nxt *= 10\n            return cnt\n\n        curr = 1          # 目前前綴\n        k -= 1            # 先減去「自己」這一步\n        while k > 0:\n            cnt = count_prefix(curr, n)\n            if k >= cnt:\n                # 跳過整個以 curr 為前綴的子樹\n                k -= cnt\n                curr += 1\n            else:\n                # 進入子樹的下一層\n                k -= 1\n                curr *= 10\n        return curr\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，允許「n = 13, k = 2」或「13 2」等形式\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(numbers) >= 2:\n        n, k = numbers[0], numbers[1]\n        sol = Solution()\n        result = sol.findKthNumber(n, k)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13, k = 2",
          "expected_output": "10",
          "success": true,
          "output": "10"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode40.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum II",
    "description_snippet": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique c...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for solving the combination sum II problem. Unique combinations, each candidate used at most once. Avoid duplicates. Approach: sort candidates, use backtracking with index, skip duplicates when same value at same depth. Steps: Start, sort, call backtrack(0, target, empty). In backtrack: if target==0 output combination. Else if index==len return. For i from index to len-1: if i>index && candidates[i]==candidates[i-1] skip. If candidates[i] > target break. else include, recurs. After recursion, backtrack. End. Provide line by line with explanation. Use arrow syntax. Let's produce.\n\nWe must ensure each line is \"虛擬碼步驟 // 解釋\". Use Start, End, Decision etc. Provide appropriate structure.\n\nLet's craft lines:\n\nStart // 程式開始\n→ Step 1: 讀取 candidates 與 target // 取得輸入資料\n→ Step 2: 將 candidates 依數值遞增排序 // 方便後續去重與提前終止\n→ Step 3: 初始化空結果 list // 存放所有符合條件的組合\n→ Step 4: 呼叫 Backtrack(0, target, 空組合) // 從索引 0 開始遞迴搜尋\nBacktrack(index, remaining, current) // 入口函式\n    → Decision: 若 remaining == 0? // 檢查是否已達目標\n        Yes → Step 5: 複製 current 加入結果 list // 成功組合\n        No  → Decision: 若 index == len(candidates)? // 無更多候選數\n            Yes → End // 結束此分支\n            No  →\n                → Step 6: 從 i = index 到 len-1 迭代 // 選取每個候選數\n                    → Decision: 若 i > index 且 candidates[i] == candidates[i-1]? // 跳過重複值\n                        Yes → Skip // 跳過此項\n                        No  →\n                            → Decision: 若 candidates[i] > remaining? // 不能再進一步\n                                Yes → Break // 結束迴圈\n                                No  →\n                                    → Step 7: 將 candidates[i] 加入 current // 選擇此數\n                                    → Step 8: 呼叫 Backtrack(i+1, remaining - candidates[i], current) // 進一步搜尋\n                                    → Step 9: 移除 current 末尾元素 // 回溯到上層\nEnd // 程式結束\n\nWe need to format each line as \"虛擬碼步驟 // 解釋\". Each block like Indent maybe. Provide arrow lines with indentation.\n\nNeed to include the decision lines, etc. Let's format accordingly.\n\nBe careful: Each line has only one step, and we can't use multiple commands separated by semicolons? We can combine as Step 6: For i = index to len-1, but we need to separate loops and decisions maybe. But requirement: Each line must be \"虛擬碼步驟 // 解釋\". We can embed for loop inside a step: Step 6: For i = index to len-1 // iterate candidates\n\nBut we also need decision inside. We might use sub-steps with indentation. Provide as separate lines with arrow for decisions.\n\nBetter to format:\n\nStart // 程式開始\n→ Step 1: 輸入 candidates 與 target // 取得輸入資料\n→ Step 2: 將 candidates 依升序排序 // 方便去重\n→ Step 3: 建立空結果 list // 儲存所有組合\n→ Step 4: 呼叫 Backtrack(0, target, 空) // 從索引 0 開始搜尋\n\nBacktrack(index, remaining, current) // 入口函式\n    → Decision: remaining == 0? // 已達目標\n        Yes → Step 5: 把 current 複製加入結果 // 儲存組合\n        No  → Decision: index == len(candidates)? // 無候選可選\n            Yes → End // 結束此路徑\n            No  →\n                → Step 6: 迭代 i = index 到 len-1 // 嘗試每個候選數\n                    → Decision: i > index 且 candidates[i] == candidates[i-1]? // 跳重複\n                        Yes → Skip // 跳過重複項\n                        No  →\n                            → Decision: candidates[i] > remaining? // 超過目標\n                                Yes → Break // 結束迴圈\n                                No  →\n                                    → Step 7: 加入 candidates[i] 到 current // 選擇數字\n                                    → Step 8: 呼叫 Backtrack(i+1, remaining - candidates[i], current) // 繼續搜尋\n                                    → Step 9: 從 current 移除最後一個 // 回溯\n\nEnd // 程式結束\n\nNow we need to ensure each line includes \"// 解釋\" only once. Each line must be \"虛擬碼步驟 // 解釋\". For decisions we need arrow. The example used indentation for decisions. So each decision block line: \"Decision: ...\" with arrow maybe. Use \"Decision:  remaining == 0?\" etc. For Yes/No lines, use \"Yes → ...\". For Skip and Break lines, we can just write \"Skip // 跳過\" but maybe use \"Yes → Skip // 跳過\". They used \"Yes → Step ...\".\n\nSo we must align: For decisions, we have a line: \"Decision: remaining == 0? // 已達目標\" and then lines \"Yes → Step 5: ...\". We need to ensure each line is separate.\n\nLet's produce final answer accordingly. Use proper indentation: maybe spaces to represent nested blocks. Provide lines.\n\nAlso we cannot output any actual code. Just virtual code steps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 輸入 candidates 與 target // 取得輸入資料\n→ Step 2: 將 candidates 依升序排序 // 方便後續去重與提前終止\n→ Step 3: 建立空結果 list // 用來儲存所有符合條件的組合\n→ Step 4: 呼叫 Backtrack(0, target, 空) // 從索引 0 開始遞迴搜尋\n\nBacktrack(index, remaining, current) // 入口函式\n    → Decision: remaining == 0? // 檢查是否已達目標\n        Yes → Step 5: 複製 current 加入結果 list // 成功組合\n        No  → Decision: index == len(candidates)? // 無更多候選數可選\n            Yes → End // 結束此分支\n            No  →\n                → Step 6: 迭代 i = index 到 len-1 // 嘗試每個候選數\n                    → Decision: i > index 且 candidates[i] == candidates[i-1]? // 跳過重複值\n                        Yes → Skip // 跳過此項\n                        No  →\n                            → Decision: candidates[i] > remaining? // 超過目標\n                                Yes → Break // 結束迴圈\n                                No  →\n                                    → Step 7: 加入 candidates[i] 到 current // 選擇此數字\n                                    → Step 8: 呼叫 Backtrack(i+1, remaining - candidates[i], current) // 繼續搜尋\n                                    → Step 9: 從 current 移除最後一個 // 回溯到上層\n\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combinationSum2(self, candidates, target):\n        candidates.sort()\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            prev = -1\n            for i in range(start, len(candidates)):\n                if candidates[i] == prev:\n                    continue\n                path.append(candidates[i])\n                backtrack(i + 1, path, total + candidates[i])\n                path.pop()\n                prev = candidates[i]\n\n        backtrack(0, [], 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract candidates list\n    cand_match = re.search(r'candidates\\s*=\\s*\\[([^\\]]*)\\]', data)\n    if cand_match:\n        cand_str = cand_match.group(1).strip()\n        if cand_str:\n            candidates = [int(x.strip()) for x in cand_str.split(',')]\n        else:\n            candidates = []\n    else:\n        candidates = []\n\n    # Extract target value\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    target = int(target_match.group(1)) if target_match else 0\n\n    solution = Solution()\n    result = solution.combinationSum2(candidates, target)\n\n    # Format output without spaces between commas as in examples\n    output = '[' + ','.join('[' + ','.join(str(x) for x in combo) + ']' for combo in result) + ']'\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [10,1,2,7,6,1,5], target = 8",
          "expected_output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
          "success": true,
          "output": "[[1,1,6],[1,2,5],[1,7],[2,6]]"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,5,2,1,2], target = 5",
          "expected_output": "[[1,2,2],[5]]",
          "success": true,
          "output": "[[1,2,2],[5]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode449.json",
    "problem_index_in_file": 0,
    "title": "Serialize and Deserialize BST",
    "description_snippet": "Serialization is converting a data structure or object into a sequence of bits so that it can be sto...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Must design algorithm to serialize/deserialize BST, compact string. Usually we can use preorder traversal, separating with commas, maybe use null markers. But since BST can be reconstructed from preorder without nulls because BST property allows inferring missing children. For simplicity: use preorder list with delimiters. For deserialization, reconstruct BST by inserting values into BST or using bounds.\n\nWe'll produce steps: Start -> Step 1: Serialize: perform preorder, join values with commas // etc. Step 2: Deserialize: parse numbers; use helper to build BST using bounds.\n\nWe must produce line-by-line pseudo-code, with explanation after //.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: Define serialize(root) -> string // 函式入口\n\n→ Step 2: Initialize empty list output // 用於儲存序列\n\n→ Step 3: Define helper(node) // 內部遞迴\n\n→ Step 4: If node is null, return // BST 沒有空位需跳過\n\n→ Step 5: Append node.val to output // 記錄節點值\n\n→ Step 6: Call helper(node.left) // 先序左子\n\n→ Step 7: Call helper(node.right) // 先序右子\n\n→ Step 8: End helper // 完成遞迴\n\n→ Step 9: Return output.join(',') // 產生逗號分隔字串\n\n→ Step 10: End serialize // 返還序列字串\n\n→ Step 11: Define deserialize(data) -> TreeNode // 反序列函式\n\n→ Step 12: If data is empty, return null // 空串代表空樹\n\n→ Step 13: Split data by ',' into list nums // 取得值序列\n\n→ Step 14: Convert each to integer // 數字化\n\n→ Step 15: Define helper(min, max) // 內部建樹\n\n→ Step 16: If idx >= nums.length return null // 沒有更多節點\n\n→ Step 17: val = nums[idx] // 取下一個值\n\n→ Step 18: If val < min or val > max return null // 不符合 BST 範圍\n\n→ Step 19: Create node = new TreeNode(val) // 建節點\n\n→ Step 20: idx++ // 移動索引\n\n→ Step 21: node.left = helper(min, val) // 左子樹允許值 < val\n\n→ Step 22: node.right = helper(val, max) // 右子樹允許值 > val\n\n→ Step 23: Return node // 完成節點\n\n→ Step 24: End helper // 完成子樹\n\n→ Step 25: Initialize idx = 0 // 全域索引\n\n→ Step 26: Return helper(-Infinity, Infinity) // 從根建立整棵樹\n\n→ Step 27: End deserialize // 返還根節點\n\n→ End // 程式結束\n\nMake sure we use arrow notation. Also we need to reflect decision points if any. We have decision lines 16, 18 etc. Format: Use Decision: If... and Yes → etc. But we can also use simple if. The spec says use Decision: and Yes→ No→ but not mandatory? It says \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\". So we should incorporate Decision: for conditional lines. For example, Step 4: Decision: node is null? Yes→ return. Use arrow. Similarly for Step 16, 18.\n\nLet's adjust.\n\nWe need each line format: 虛擬碼步驟 [space] // 解釋\n\nSo produce each line accordingly.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Function serialize(root) -> string // 定義序列化入口\n→ Step 2: Initialize empty list output // 用於儲存節點值序列\n→ Step 3: Decision: root is null? // 檢查根節點是否存在\n    Yes → Return '' // 空樹序列化為空字串\n    No  → Proceed to helper\n→ Step 4: Function helper(node) // 內部遞迴函式\n→ Step 5: Decision: node is null? // 判斷節點是否為空\n    Yes → Return // 空節點不產生輸出\n    No  → Append node.val to output // 記錄節點值\n→ Step 6: Call helper(node.left) // 先序左子\n→ Step 7: Call helper(node.right) // 先序右子\n→ Step 8: End helper // 完成遞迴\n→ Step 9: Return output.join(',') // 生成逗號分隔的字串\n→ Step 10: End serialize // 序列化完成\n→ Step 11: Function deserialize(data) -> TreeNode // 定義反序列化入口\n→ Step 12: Decision: data is empty? // 檢查字串是否為空\n    Yes → Return null // 空字串代表空樹\n    No  → Proceed\n→ Step 13: Split data by ',' into list nums // 取得數值序列\n→ Step 14: Convert each element to integer // 轉成數字\n→ Step 15: Initialize idx = 0 // 指標指向當前元素\n→ Step 16: Function helper(min, max) // 建樹遞迴\n→ Step 17: Decision: idx >= nums.length? // 沒有剩餘節點\n    Yes → Return null // 子樹結束\n    No  → val = nums[idx] // 取得當前值\n→ Step 18: Decision: val < min or val > max? // 值不在合法範圍\n    Yes → Return null // 無效節點\n    No  → Create node = new TreeNode(val) // 建節點\n→ Step 19: idx++ // 進入下一個位置\n→ Step 20: node.left = helper(min, val) // 左子樹範圍\n→ Step 21: node.right = helper(val, max) // 右子樹範圍\n→ Step 22: Return node // 返回節點\n→ Step 23: End helper // 完成子樹\n→ Step 24: Return helper(-Infinity, Infinity) // 從根建立整棵樹\n→ Step 25: End deserialize // 反序列化完成\nEnd // 程式結束\n\nNeed to ensure each line has 虛擬碼步驟 and explanation after //.\n\nAlso include arrows for decisions. For lines 5, 17, 18 we need Yes → and No →. Already done.\n\nBut we need to include \"Decision:\" prefix.\n\nE.g.:\n\nDecision: node is null? // 斷點\n\nYes → Return\n\nNo  → Append node.val to output\n\nWe need to keep the arrow lines after the decision. Format: The decision line then indented Yes→ and No→ lines.\n\nWe must keep same formatting as sample: Decision: ... // ... and inside indent Yes → ... // ... etc.\n\nAlso need to use proper spacing.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Function serialize(root) -> string // 定義序列化入口  \n→ Step 2: Initialize empty list output // 用於儲存節點值序列  \n→ Decision: root is null? // 檢查根節點是否存在  \n Yes → Return '' // 空樹序列化為空字串  \n No  → Proceed to helper  \n→ Step 4: Function helper(node) // 內部遞迴函式  \n→ Decision: node is null? // 判斷節點是否為空  \n Yes → Return // 空節點不產生輸出  \n No  → Append node.val to output // 記錄節點值  \n→ Step 6: Call helper(node.left) // 先序左子  \n→ Step 7: Call helper(node.right) // 先序右子  \n→ Step 8: End helper // 完成遞迴  \n→ Step 9: Return output.join(',') // 生成逗號分隔的字串  \n→ Step 10: End serialize // 序列化完成  \n→ Step 11: Function deserialize(data) -> TreeNode // 定義反序列化入口  \n→ Decision: data is empty? // 檢查字串是否為空  \n Yes → Return null // 空字串代表空樹  \n No  → Proceed  \n→ Step 13: Split data by ',' into list nums // 取得數值序列  \n→ Step 14: Convert each element to integer // 轉成數字  \n→ Step 15: Initialize idx = 0 // 指標指向當前元素  \n→ Step 16: Function helper(min, max) // 建樹遞迴  \n→ Decision: idx >= nums.length? // 沒有剩餘節點  \n Yes → Return null // 子樹結束  \n No  → val = nums[idx] // 取得當前值  \n→ Decision: val < min or val > max? // 值不在合法範圍  \n Yes → Return null // 無效節點  \n No  → Create node = new TreeNode(val) // 建節點  \n→ Step 19: idx++ // 進入下一個位置  \n→ Step 20: node.left = helper(min, val) // 左子樹範圍  \n→ Step 21: node.right = helper(val, max) // 右子樹範圍  \n→ Step 22: Return node // 返回節點  \n→ Step 23: End helper // 完成子樹  \n→ Step 24: Return helper(-Infinity, Infinity) // 從根建立整棵樹  \n→ Step 25: End deserialize // 反序列化完成  \nEnd // 程式結束",
      "generated_code": "import sys\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\"\"\"\n        res = []\n\n        def preorder(node):\n            if not node:\n                return\n            res.append(str(node.val))\n            preorder(node.left)\n            preorder(node.right)\n\n        preorder(root)\n        return ','.join(res)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\"\"\"\n        if not data:\n            return None\n        preorder = list(map(int, data.split(',')))\n\n        def build(min_val, max_val):\n            if preorder and min_val < preorder[0] < max_val:\n                val = preorder.pop(0)\n                node = TreeNode(val)\n                node.left = build(min_val, val)\n                node.right = build(val, max_val)\n                return node\n            return None\n\n        return build(float('-inf'), float('inf'))\n\ndef insert_into_bst(root, val):\n    \"\"\"Helper to insert a value into a BST.\"\"\"\n    if root is None:\n        return TreeNode(val)\n    if val < root.val:\n        root.left = insert_into_bst(root.left, val)\n    else:\n        root.right = insert_into_bst(root.right, val)\n    return root\n\ndef parse_input(input_str):\n    \"\"\"Extract list of integers from input like 'root = [2,1,3]'.\"\"\"\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        return []\n    content = input_str[start+1:end].strip()\n    if not content:\n        return []\n    return [int(x.strip()) for x in content.split(',')]\n\ndef build_tree_from_list(values):\n    \"\"\"Build BST by inserting values in given order.\"\"\"\n    root = None\n    for v in values:\n        root = insert_into_bst(root, v)\n    return root\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    values = parse_input(raw_input)\n    root = build_tree_from_list(values)\n    codec = Codec()\n    serialized = codec.serialize(root)\n    # Wrap result in brackets as per examples\n    if serialized:\n        output = f'[{serialized}]'\n    else:\n        output = '[]'\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "root = [2,1,3]",
          "expected_output": "[2,1,3]",
          "success": true,
          "output": "[2,1,3]"
        },
        {
          "example_index": 1,
          "input": "root = []",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode349.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The problem: intersection of two integer arrays, unique elements. We can use hash sets.\n\nWe need to write virtual code lines with Start, Decision, Step, End. Use arrows. Provide explanation after each line. Format: \"虛擬碼步驟 // 解釋/說明\".\n\nWe need to produce step-by-step algorithm.\n\nSo: Start. Step 1: convert nums1 to set1. Step 2: convert nums2 to set2. Step 3: create empty result set. Step 4: iterate over set1, if element in set2 add to result. Or simpler: result = set1 intersection set2. Step 5: convert result set to array. Step 6: return result array. End.\n\nWe need arrows and Decision maybe for checking emptiness? Not necessary but we can include.\n\nLet's produce.\n\nWe need each line: \"虛擬碼步驟\" then space then \"// 解釋\".\n\nWe must keep virtual code in Chinese? Probably Chinese.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: set1 ← new Set(nums1) // 把 nums1 轉成集合，去重\n→ Step 2: set2 ← new Set(nums2) // 把 nums2 轉成集合，去重\n→ Step 3: resultSet ← new Set() // 建立空集合儲存交集\n→ Decision: 如果 set1 為空? // 檢查第一個集合是否為空\n    Yes → Step 4: resultArray ← [] // 若為空，交集為空\n    No  → Step 5: 迭代 set1 的每個元素 x\n        → Decision: x 在 set2? // 檢查 x 是否存在於第二個集合\n            Yes → resultSet.add(x) // 存在則加入結果集合\n            No  → // 不加入\n→ Step 6: resultArray ← Array.from(resultSet) // 把集合轉成陣列\n→ Step 7: return resultArray // 回傳交集陣列\nEnd // 程式執行結束\n\nBut we need to make sure format: each line \"虛擬碼步驟 // 解釋\". For steps inside loop we can indent but keep arrow? Use arrow for each step. The Decision block inside loop maybe nested.\n\nLet's write each line with arrow and indentation indicated by spaces.\n\nWe should not include code syntax, just description. Use arrow for steps and decisions.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: set1 ← new Set(nums1) // 把 nums1 轉成集合，去重  \n→ Step 2: set2 ← new Set(nums2) // 把 nums2 轉成集合，去重  \n→ Step 3: resultSet ← new Set() // 建立空集合儲存交集  \n→ Decision: 若 set1 為空? // 檢查第一個集合是否為空  \n    Yes → Step 4: resultArray ← [] // 若為空，交集為空  \n    No  → Step 5: 迭代 set1 的每個元素 x  \n        → Decision: x 在 set2? // 檢查 x 是否存在於第二個集合  \n            Yes → resultSet.add(x) // 存在則加入結果集合  \n            No  → // 不加入  \n→ Step 6: resultArray ← Array.from(resultSet) // 把集合轉成陣列  \n→ Step 7: return resultArray // 回傳交集陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def intersection(self, nums1, nums2):\n        \"\"\"Return the unique intersection of two integer lists.\"\"\"\n        return list(set(nums1) & set(nums2))\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    # Find all bracketed substrings (the two lists)\n    parts = re.findall(r'\\[([^\\]]*)\\]', data)\n\n    # Parse each list of numbers\n    nums1, nums2 = [], []\n    if len(parts) >= 2:\n        for i, part in enumerate(parts[:2]):\n            part = part.strip()\n            if part:  # non‑empty list\n                nums = list(map(int, part.split(',')))\n            else:      # empty list\n                nums = []\n            if i == 0:\n                nums1 = nums\n            else:\n                nums2 = nums\n\n    # Compute intersection and print result\n    sol = Solution()\n    result = sol.intersection(nums1, nums2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[9,4]",
          "success": true,
          "output": "[9, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode416.json",
    "problem_index_in_file": 0,
    "title": "Partition Equal Subset Sum",
    "description_snippet": "Given an integer array nums, return true if you can partition the array into two subsets such that t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. It's a typical subset sum / partition problem. The algorithm: check total sum even, target sum = total/2, DP to find subset sum reachable. Virtual code: Start, input array, compute total, decision if odd → false, else DP array reachable[0..target] initialize false, reachable[0]=true, loop over numbers, for each num iterate backwards from target down to num update reachable[i] = reachable[i] or reachable[i-num]. After loop, decision if reachable[target] true → true else false. End.\n\nWe need to produce lines with arrow. Provide explanations after //.\n\nLet's produce line by line. Ensure each line starts with virtual code step, a space, then // explanation. Use arrows \"→\", \"Yes →\", \"No →\", Decision: etc. Ensure final \"End // 程式執行結束\".\n\nLet's do it.\n\nWe must start with \"Start // 程式開始執行\". Then arrow.\n\nLine 1: Start.\n\nLine 2: → Input nums // 取得整數陣列\n\nLine 3: → Compute totalSum = sum(nums) // 計算所有元素之和\n\nLine 4: → Decision: 如果 totalSum 為奇數? // 檢查總和是否可被 2 整除\n\nLine 5: Yes → Output false // 若奇數，無法分割\n\nLine 6: No  → Compute target = totalSum / 2 // 設定子集目標和\n\nLine 7: → Initialize boolean array dp[0..target] // 用於記錄可達子集和\n\nLine 8: → Set dp[0] = true // 零和總是可達\n\nLine 9: → For each num in nums // 逐個處理陣列元素\n\nLine 10:     → For i from target down to num // 從大到小更新 dp\n\nLine 11:         → dp[i] = dp[i] OR dp[i-num] // 更新可達性\n\nLine 12: → Decision: 如果 dp[target] 為 true? // 判斷是否有子集和為目標\n\nLine 13: Yes → Output true // 可分割\n\nLine 14: No  → Output false // 不可分割\n\nLine 15: End // 程式執行結束\n\nWe need to maintain arrow syntax. For nested loops, indent with spaces.\n\nWe need to format exactly as example: Each line must have the virtual code step, a space, then // explanation.\n\nLet's craft accordingly. Use \"→\" arrow for each step. For decisions, use \"Decision:\" line with \"Yes →\" and \"No →\".\n\nWe'll ensure we use \"→\" for all steps.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums // 取得整數陣列  \n→ Compute totalSum = sum(nums) // 計算所有元素之和  \n→ Decision: 如果 totalSum 為奇數? // 檢查總和是否可被 2 整除  \n    Yes → Output false // 若奇數，無法分割  \n    No  → Compute target = totalSum / 2 // 設定子集目標和  \n→ Initialize boolean array dp[0..target] // 用於記錄可達子集和  \n→ Set dp[0] = true // 零和總是可達  \n→ For each num in nums // 逐個處理陣列元素  \n    → For i from target down to num // 從大到小更新 dp  \n        → dp[i] = dp[i] OR dp[i-num] // 更新可達性  \n→ Decision: 如果 dp[target] 為 true? // 判斷是否有子集和為目標  \n    Yes → Output true // 可分割  \n    No  → Output false // 不可分割  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef can_partition(nums):\n    total = sum(nums)\n    if total % 2 != 0:\n        return False\n    target = total // 2\n\n    dp = [False] * (target + 1)\n    dp[0] = True\n\n    for num in nums:\n        for j in range(target, num - 1, -1):\n            dp[j] = dp[j] or dp[j - num]\n\n    return dp[target]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 取出 nums 列表，支持 \"nums = [...]\" 或僅輸入列表\n    if '=' in data:\n        _, nums_part = data.split('=', 1)\n        nums_part = nums_part.strip()\n    else:\n        nums_part = data\n\n    # 使用安全的 literal_eval 解析列表\n    try:\n        nums = ast.literal_eval(nums_part)\n    except Exception:\n        # 如果解析失敗，直接結束\n        sys.exit()\n\n    result = can_partition(nums)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,11,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,5]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode398.json",
    "problem_index_in_file": 0,
    "title": "Random Pick Index",
    "description_snippet": "Given an integer array nums with possible duplicates, randomly output the index of a given target nu...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. Should include steps: constructor storing array, maybe storing mapping from target to list of indices for O(1) pick. Or use reservoir sampling during pick. Provide decision structure? But requirement: use virtual code with arrow and structure. Provide Start, End, Decision. Need to produce virtual code for whole algorithm.\n\nWe will show Start, Step: initialize map, etc. Then pick: use reservoir sampling: iterate over array, if nums[i]==target, increment count, with probability 1/count choose i. At the end return chosen index. Provide explanation each line.\n\nLet's produce lines:\n\nStart\n→ Step 1:  建立一個空字典 targetToIndices // 用於儲存每個目標值對應的索引列表\n→ Step 2:  從傳入的陣列 nums 遍歷並將索引加入對應目標值的列表 // 準備快速存取\n→ Step 3:  完成建構 // 初始化結束\nEnd // 建構完成\n\nThen pick function:\n\nStart\n→ Step 1:  初始化 count = 0, result = -1 // 進行 reservoir sampling\n→ Decision: 遍歷 nums 的每個索引 i // 為每個元素做判斷\n    → Step 2:  如果 nums[i] == target\n        → Step 3:  count += 1 // 有一個符合的索引\n        → Decision: 產生隨機整數 r 在 [1, count] 中\n            Yes → (r == 1) // 判斷是否選中\n                → Step 4:  result = i // 若被選中，記錄索引\nEnd // 迴圈結束\n→ Step 5:  回傳 result // 返回隨機選取的索引\n\nBut we need to use arrow for decisions: Decision: ...; Yes → ; No →. For random number, we can just show as Decision: 隨機 r 在 1 到 count 中; Yes → r==1? Actually we need condition: r == 1; Yes → set result. No → ignore.\n\nLet's craft proper pseudo.\n\nWe should show lines with arrows; Each line includes '虛擬碼步驟' + ' // 解釋'. So each line is e.g.:\n\nStart // 程式開始執行\n\n→ Step 1: ... // explanation\n\nWe should show nested decisions with indentation? In example they indent. We can indent accordingly.\n\nLet's produce.\n\nWe need to include \"Decision:\" lines for conditionals. For the pick function, inside loop, we need a decision to check if nums[i] == target. That is a Decision line with Yes and No branches. But we can keep it simple: use Decision: if nums[i]==target? Yes → increment count, etc.\n\nOk.\n\nAlso we need to maintain that we don't produce actual code; just pseudo.\n\nWe also should include mapping building logic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1:  建立空字典 `targetToIndices` // 用於存放每個數值對應的所有索引  \n→ Step 2:  對於 `index` 從 0 到 nums.length-1  \n  → Decision: nums[index] 是否已存在於 `targetToIndices`? // 檢查是否已為此目標建立索引清單  \n   Yes → Step 3a:  在 `targetToIndices[nums[index]]` 的清單中加入 `index` // 已有清單，直接加入  \n   No  → Step 3b:  新建清單 `[index]` 並加入 `targetToIndices[nums[index]]` // 第一次遇到此目標  \n→ Step 4:  完成建構 // 所有目標值的索引已存儲  \nEnd // 建構結束  \n\n---  \n\nStart // pick 方法開始執行  \n→ Step 1:  設定 `count = 0`, `chosenIndex = -1` // 準備 reservoir sampling  \n→ Step 2:  遍歷 `index` 從 0 到 nums.length-1  \n  → Decision: nums[index] == target? // 檢查是否符合目標  \n   Yes → Step 3a:  `count += 1` // 有一個符合的索引  \n    → Decision: 產生隨機整數 r 在 1 到 `count` 之間  \n     Yes → r == 1? // 判斷是否被選中  \n      Yes → Step 3b:  `chosenIndex = index` // 這個索引被選中  \n      No  → Step 3c:  留空 // 沒被選中，保持之前選中的索引  \n    No  → Step 3d:  留空 // 不是目標，跳過  \n→ Step 4:  回傳 `chosenIndex` // 返回隨機選取的索引  \nEnd // pick 方法結束\n\n---  \n\n// 以上虛擬碼展示了使用字典快速定位目標索引，以及利用 reservoir sampling 為多重索引提供等機率選取。",
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    \"\"\"\n    Solution class that stores indices of each number for O(1) random selection.\n    \"\"\"\n    def __init__(self, nums):\n        \"\"\"\n        Initialize the object with the list of numbers.\n        \"\"\"\n        self.indices = {}\n        for i, num in enumerate(nums):\n            self.indices.setdefault(num, []).append(i)\n\n    def pick(self, target):\n        \"\"\"\n        Return a random index where nums[i] == target.\n        Each valid index has equal probability.\n        \"\"\"\n        return random.choice(self.indices[target])\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Parse the input into operations and arguments\n    # Input format: ops, args_list separated by a comma\n    data = ast.literal_eval('[' + raw_input + ']')\n    ops, args_list = data\n\n    results = []\n    obj = None\n\n    for op, args in zip(ops, args_list):\n        if op == 'Solution':\n            # Instantiate Solution with provided nums\n            obj = Solution(*args)\n            results.append(None)  # Constructor returns None\n        else:\n            # Call the method and store its result\n            result = getattr(obj, op)(*args)\n            results.append(result)\n\n    # Print the results in JSON format to match expected output\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,4,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 4, 0, 3]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode139.json",
    "problem_index_in_file": 0,
    "title": "Word Break",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a spac...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for word break problem. Use DP. Use Start, End, Decision. Provide line by line. No actual code. Use arrow arrow. Example earlier shows arrow after Start line. Format: \"Start // 程式開始執行\". Then \"→ Step 1: ...\" etc. Use indentation? In example, decisions indented. Use spaces. Provide steps: input s, input wordDict, create dp array size len(s)+1, dp[0] = True, loop i from 1 to len(s): loop j from 0 to i: if dp[j] and s[j:i] in wordDict: dp[i]=True break. Finally return dp[len(s)]. Provide steps. Also decision to check dp[i] true? maybe. We'll produce. Use arrows. Use \"Decision:\" with Yes/No arrows. Provide short explanation. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s  // 取得需要斷詞的字串  \n→ Step 2: 讀取字典 wordDict  // 取得允許使用的單字集合  \n→ Step 3: 建立 dp 陣列大小為 len(s)+1  // dp[i] 表示 s[0:i] 是否能被斷詞  \n→ Step 4: 設定 dp[0] = True  // 空字串永遠可斷詞  \n→ Step 5: 從 i = 1 到 len(s) 迴圈  // 為每個位置計算 dp 值  \n  → Decision: dp[i] 已為 True? // 是否已經找到一種斷詞方式  \n    Yes → Continue to next i  // 已經可斷詞，直接跳到下一個 i  \n    No  → Step 6: 從 j = 0 到 i-1 迴圈  // 嘗試切分子字串 s[j:i]  \n      → Decision: dp[j] 為 True? // 先前子字串是否可斷詞  \n        Yes → Step 7: 檢查 s[j:i] 是否在 wordDict  // 子字串是否是字典詞  \n          Yes → Step 8: 設定 dp[i] = True  // 找到合法斷詞，標記為 True  \n            → Break 迴圈 j  // 斷詞成功，無需再嘗試其他 j  \n        No  → Continue 迴圈 j  // 試下個 j  \n→ Step 9: Decision: dp[len(s)] 為 True? // 最長子字串是否可斷詞  \n   Yes → Step 10: 回傳 True  // 能被完整斷詞  \n   No  → Step 11: 回傳 False // 無法完整斷詞  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        word_set = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(s)]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 解析 s\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', raw_input)\n    s = s_match.group(1) if s_match else \"\"\n    # 解析 wordDict\n    dict_match = re.search(r'wordDict\\s*=\\s*(\\[.*\\])', raw_input, re.S)\n    word_dict = ast.literal_eval(dict_match.group(1)) if dict_match else []\n\n    solution = Solution()\n    result = solution.wordBreak(s, word_dict)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode283.json",
    "problem_index_in_file": 0,
    "title": "Move Zeroes",
    "description_snippet": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for moving zeros to end while preserving order. In-place. Standard algorithm: two pointers: write index, read index. Iterate over array, when non-zero copy to write index and increment write. After loop, fill remaining from write index to end with zeros.\n\nNeed to follow format exactly: Each line: virtual code step + space + // explanation. Use arrows (→) and structure (Start, End, Decision:). Also should be line by line.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize writeIndex to 0 // pointer for next non-zero position\n→ Step 2: For each element at readIndex from 0 to length-1 // iterate through array\n   → Decision: If nums[readIndex] != 0? // check non-zero\n        Yes → Step 3: nums[writeIndex] = nums[readIndex] // copy non-zero to write position\n        Yes → Step 4: writeIndex = writeIndex + 1 // move write pointer\n        No  → // skip zeros\n→ Step 5: For fillIndex from writeIndex to length-1 // set remaining to 0\n   → Step 6: nums[fillIndex] = 0 // place zero\nEnd\n\nBut need to maintain structure: Use arrows to show decisions. Should show nested lines properly. Each line as separate line with indent? They didn't specify indentation but example shows indentation for nested branches. Use spaces.\n\nLet's produce each line. The pseudocode should reflect the algorithm.\n\nMake sure each line has one step. For loops and decisions maybe treat as steps. Provide explanation after //.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: writeIndex ← 0 // 設定寫入指標，指向下一個非零元素應寫入的位置  \n→ Step 2: For readIndex ← 0 To nums.length - 1 // 循環遍歷整個陣列  \n&nbsp;&nbsp;→ Decision: nums[readIndex] ≠ 0? // 判斷目前元素是否非零  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: nums[writeIndex] ← nums[readIndex] // 把非零元素複製到寫入指標位置  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: writeIndex ← writeIndex + 1 // 移動寫入指標至下一個空位  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → // 若為零，直接跳過  \n→ Step 5: For fillIndex ← writeIndex To nums.length - 1 // 將剩餘位置填充為 0  \n&nbsp;&nbsp;→ Step 6: nums[fillIndex] ← 0 // 將該位置設為零  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef move_zeroes(nums):\n    \"\"\"把所有 0 移到陣列末尾，保持非零元素的相對順序。\"\"\"\n    write = 0  # 下一個非零元素應寫入的位置\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[write] = nums[i]\n            write += 1\n    # 把剩下的位置全部設為 0\n    for i in range(write, len(nums)):\n        nums[i] = 0\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行資料\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 找出 '[' 與 ']' 之間的字串，並解析成 list\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        # 若輸入格式不符，直接結束\n        sys.exit()\n\n    list_str = data[start:end + 1]\n    nums = ast.literal_eval(list_str)\n\n    move_zeroes(nums)\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,0,3,12]",
          "expected_output": "[1,3,12,0,0]",
          "success": true,
          "output": "[1, 3, 12, 0, 0]"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode650.json",
    "problem_index_in_file": 0,
    "title": "2 Keys Keyboard",
    "description_snippet": "There is only one character 'A' on the screen of a notepad. You can perform one of two operations on...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for minimal steps to get n 'A's using copy all and paste. Classic problem \"2 keys keyboard\". The minimal steps equals sum of prime factors: for each factor p, add p. So algorithm: result=0; while n>1: find smallest divisor d of n; if none (prime) d=n; result+=d; n/=d; return result.\n\nWe need to produce virtual code step-by-step with explanation, each line with `虛擬碼步驟 // 解釋`. Use arrows, Start, End. Let's generate.\n\nWe'll produce Start // 程式開始執行\n→ Step 1: 輸入整數 n // 讀取目標字母數量\n→ Step 2: 設置 result = 0 // 儲存最小步驟數\n→ Decision: n <= 1? // 若目標小於等於 1，無需操作\n    Yes → Step 3: 輸出 result // 直接回傳 0\n    No  → Step 4: 設置 temp = n // 用於分解因數\n→ Step 5: 設置 d = 2 // 從 2 開始尋找最小因數\n→ Decision: d * d <= temp? // 只需檢查到 sqrt(temp)\n    Yes → Step 6: Decision: temp mod d == 0? // 檢查 d 是否為因數\n        Yes → Step 7: result += d // 取得因數，累加步驟\n            → Step 8: temp /= d // 把 temp 除以因數\n            → Step 9: d = 2 // 重新從 2 開始尋找下一因數\n        No  → Step 10: d += 1 // d 不是因數，嘗試下一個數\n    No  → Step 11: Decision: temp > 1? // 若 temp 還大於 1，代表剩餘的 prime factor\n        Yes → Step 12: result += temp // 加上剩餘的大素因數\n        No  → // 不需要任何操作\n→ Step 13: 輸出 result // 返回最小步驟數\nEnd // 程式結束\n\nBut we need iterative loop. Instead of nested decisions, we can write a while loop pseudocode: while n > 1: find smallest divisor d; result += d; n /= d. And to find d, for i from 2 to sqrt(n). If no divisor found, d = n.\n\nLet's produce virtual code accordingly, with arrows.\n\nBetter produce:\n\nStart // 程式開始\n→ Input n // 讀入目標字母數\n→ Set result = 0 // 初始化步驟計數\n→ While n > 1: // 只要還有待分解的因數\n    → Set d = 2 // 假設最小因數為 2\n    → While d * d <= n: // 只需要檢查到 sqrt(n)\n        → Decision: n mod d == 0? // 是否能整除\n            Yes → Break // 找到最小因數\n            No  → d += 1 // 試下一個\n    → Decision: d * d > n? // 若沒有找到因數，n 本身是素數\n        Yes → d = n // 素數因數為自身\n    → result += d // 累加步驟\n    → n /= d // 去除已處理的因數\n→ End While\n→ Output result // 回傳最小步驟數\nEnd // 程式結束\n\nBut we need each line with explanation.\n\nLet's produce step lines accordingly. Use 'Start', 'End'. Use arrows \"→\". Use 'Decision:' with Yes →, No →. Use loops: 'While'.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 讀取目標字母數  \n→ Set result = 0 // 初始化最小步驟計數  \n→ While n > 1: // 只要還有待分解的因數  \n    → Set d = 2 // 初始最小因數為 2  \n    → While d * d <= n: // 只需檢查到平方根  \n        → Decision: n mod d == 0? // 判斷 d 是否能整除 n  \n            Yes → Break // 找到最小因數，跳出內層循環  \n            No  → d += 1 // d 不是因數，嘗試下一個數  \n    → Decision: d * d > n? // 若內層循環未找到因數，n 為素數  \n        Yes → d = n // 素數因數為自身  \n    → result += d // 累加該因數對步驟的貢獻  \n    → n /= d // 去除已處理的因數，繼續分解剩餘部分  \n→ End While // 所有因數處理完畢  \n→ Output result // 回傳最小操作數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_steps(n: int) -> int:\n    \"\"\"Return the minimum number of operations to get exactly n 'A's.\"\"\"\n    res = 0\n    d = 2\n    while n > 1:\n        # 把 n 分解為最小因數 d 的乘積\n        while n % d == 0:\n            res += d\n            n //= d\n        d += 1\n    return res\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取整數 n，輸出最小操作數.\"\"\"\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    print(min_steps(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode397.json",
    "problem_index_in_file": 0,
    "title": "Integer Replacement",
    "description_snippet": "Given a positive integer n, you can apply one of the following operations:\n\n1. If n is even, replace...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: given n, find min operations to reduce to 1 using rules: if even, n=n/2; if odd, can do n+1 or n-1. Classic problem: integer replacement. We need to output virtual code with explanations per line. Use arrows and decision nodes. We need step-by-step algorithm, likely greedy or DP. Provide high-level algorithm. Since we must not output actual code but structured steps. Should be clear.\n\nWe need to cover:\n\n- Start\n- Input n\n- If n==1 return 0\n- Else recursively compute min operations using recursion/DP or BFS. Probably use recursion with memoization.\n\nLet's produce algorithm:\n\n- Define function minOps(n)\n- If n==1 return 0\n- If n even: return 1 + minOps(n/2)\n- If n odd: return 1 + min(minOps(n+1), minOps(n-1))\n\nNeed to avoid infinite recursion: memoization map.\n\nThus steps:\n\nStart\n→ Read n\n→ Decision: n == 1? // base\n   Yes → Return 0 // already 1\n   No → → Call minOps(n) // compute\nDefine function minOps(x)\n→ Decision: x==1? // base\n   Yes → Return 0\n   No → Decision: x even? // check\n        Yes → Return 1 + minOps(x/2)\n        No → Return 1 + min(minOps(x+1), minOps(x-1))\nUse memoization: before computing, check if result cached.\n\nAlso could use BFS iterative to avoid recursion depth.\n\nLet's output virtual steps. Each line as specified.\n\nWe must keep consistent arrow syntax: \"→ Step ...\" For decisions, \"Decision:\" lines.\n\nWe'll produce steps for main function and helper.\n\nWe may break into sub-steps.\n\nLet's produce a linear representation:\n\nStart\n→ Read integer n\n→ Decision: n == 1? // if already 1\n    Yes → Output 0 // no operations needed\n    No  → → Call Function minOps(n)\nDefine Function minOps(current)\n    Start\n    → Decision: current == 1? // base case\n        Yes → Return 0 // already at target\n        No  → Decision: current is even? // check parity\n            Yes → → Return 1 + minOps(current / 2) // one operation, halve\n            No  → → Return 1 + min( minOps(current + 1), minOps(current - 1) ) // choose best of +1 or -1\n    End\nEnd\n\nBut we need memoization: add caching.\n\nAdd step: If cache contains current return cached value.\n\nLet's produce:\n\nDefine Function minOps(current)\n    Start\n    → Decision: cache contains current? // already computed\n        Yes → Return cache[current] // reuse\n        No  → Decision: current == 1?\n            Yes → → cache[current] = 0; Return 0\n            No  → Decision: current even?\n                Yes → → temp = minOps(current / 2); cache[current] = 1 + temp; Return cache[current]\n                No  → → temp1 = minOps(current + 1); temp2 = minOps(current - 1); cache[current] = 1 + min(temp1, temp2); Return cache[current]\n    End\n\nAlso mention recursion depth maybe large; but okay.\n\nAlternatively use iterative BFS but complexity.\n\nLet's produce final answer in required format.\n\nMake sure each line includes // explanation.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Read integer n // 取得使用者輸入的正整數  \n→ Decision: n == 1? // 檢查是否已經是 1  \n    Yes → Output 0 // 不需要任何操作  \n    No  → → Call Function minOps(n) // 計算最小步數  \nEnd // 主程式結束  \n\nDefine Function minOps(current) // 計算 current 變成 1 的最小步數  \n    Start  \n    → Decision: cache contains current? // 已經計算過？  \n        Yes → Return cache[current] // 直接回傳已記錄的結果  \n        No  → → Decision: current == 1? // 基本情況  \n            Yes → → cache[current] = 0  \n            No  → → Decision: current is even? // 判斷奇偶  \n                Yes → → temp = minOps(current / 2) // 一步後變成一半  \n                No  → → temp1 = minOps(current + 1) // 一步後加 1  \n                      → temp2 = minOps(current - 1) // 一步後減 1  \n                      → temp = min(temp1, temp2) // 選擇較少步數的方案  \n            → cache[current] = 1 + temp // 加上本步操作  \n            → Return cache[current] // 回傳最小步數  \n    End  \nEnd // 函式結束",
      "generated_code": "import sys\nimport re\n\ndef integer_replacement(n: int) -> int:\n    \"\"\"Return the minimal number of operations to reduce n to 1.\"\"\"\n    count = 0\n    while n != 1:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            # For odd n choose the direction that gives a number\n            # with more trailing zeros in binary representation.\n            # Special case: n == 3 -> go to 2 to avoid extra step.\n            if n == 3 or ((n >> 1) & 1) == 0:\n                n -= 1\n            else:\n                n += 1\n        count += 1\n    return count\n\ndef solve() -> None:\n    data = sys.stdin.read()\n    # Extract the first integer found in the input\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group(0))\n    result = integer_replacement(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 8",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode387.json",
    "problem_index_in_file": 0,
    "title": "First Unique Character in a String",
    "description_snippet": "Given a string s, find the first non-repeating character in it and return its index. If it does not ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation. Use arrows, Start, End, Decision etc. For problem: find first non-repeating char index. Approach: use frequency map, then iterate to find first char with count 1. Steps: input string s, build freq map, iterate, find first with count 1, return index or -1.\n\nWe need to produce each line: \"虛擬碼步驟 // 解釋\".\n\nWe can structure: Start, Step 1: input s, Step 2: build frequency map, Step 3: initialize index variable, Step 4: iterate through s with index i, Decision: if freq[s[i]]==1? Yes -> return i, No -> continue. After loop, return -1. End.\n\nNeed to use arrow: →. For decisions: Yes → etc. Each line must have \"虛擬碼步驟 [space] // 解釋\". Use Chinese explanation. Let's produce.\n\nMake sure to include each line. Also maybe include Step 0: start. We need to follow format exactly: \"Start // 程式開始執行\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得待處理的字串  \n→ Step 2: 建立頻率字典 freq ← 空字典 // 用於統計每個字元出現次數  \n→ Step 3: 對於每個字元 c in s  \n    → Step 3.1: freq[c] ← freq.get(c, 0) + 1 // 更新字元出現次數  \n→ Step 4: 對於索引 i 從 0 到 len(s)-1  \n    → Decision: 如果 freq[s[i]] == 1? // 判斷此字元是否唯一  \n        Yes → Step 5: 回傳 i // 找到第一個非重複字元，返回其索引  \n        No  → Step 4.2: 繼續迴圈 // 不是唯一字元，檢查下一個位置  \n→ Step 6: 回傳 -1 // 若整個字串都無非重複字元，返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport collections\n\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        \"\"\"\n        找出字串中第一個非重複字元的索引。\n        若不存在則回傳 -1。\n        \"\"\"\n        if not s:\n            return -1\n\n        # 計算每個字元出現次數\n        count = collections.Counter(s)\n\n        # 依序檢查，尋找第一次出現次數為 1 的字元\n        for idx, ch in enumerate(s):\n            if count[ch] == 1:\n                return idx\n\n        # 全部都是重複字元\n        return -1\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    解析輸入，支援兩種常見格式：\n    1. 直接給字串，例如: hello\n    2. 形式為 s = \"hello\" 或 s = 'hello'\n    \"\"\"\n    raw = raw.strip()\n    if '=' in raw:\n        # 取等號右側的內容\n        _, val = raw.split('=', 1)\n        s = val.strip()\n    else:\n        s = raw\n\n    # 去除可能存在的單/雙引號\n    if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n        s = s[1:-1]\n\n    return s\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.firstUniqChar(s)\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "s = \"loveleetcode\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "s = \"aabb\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode697.json",
    "problem_index_in_file": 0,
    "title": "Degree of an Array",
    "description_snippet": "Given a non-empty array of non-negative integers nums, the degree of this array is defined as the ma...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for algorithm. Approach: count frequency, find degree, track first and last occurrence of each number, compute min length of subarray covering degree. Pseudocode lines with Start, Decision, etc. We need to produce each line with \"虛擬碼步驟 // 解釋\". Should be clear but not actual code. Let's produce steps: Start; Step 1: Initialize dictionaries: freq, left, right. Step 2: Iterate over array with index. Step 3: Update freq, left if not seen, right always. Step 4: After loop, find degree = max(freq). Step 5: Initialize minLen large. Step 6: Iterate over items in freq: if freq == degree, compute length = right - left + 1; if length < minLen, update. Step 7: Output minLen. End.\n\nUse decision arrows for conditionals. Need to use arrow symbol for each step: \"→ Step X\". Use decision: \"Decision: 如果 ...\". Provide explanation after //. Each line must contain code step and explanation. We can add \"Yes →\" and \"No →\" for decisions. Let's format accordingly. Provide each line. Use \"Start\" at top. Use \"End\" at bottom.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字典 freq、left、right // 用於統計頻率、第一次出現位置與最後一次出現位置  \n→ Step 2: 遍歷 nums 並取得索引 i 與元素 val // 逐一處理陣列中的每個值  \n    → Decision: 如果 val 尚未在 left 中? // 判斷是否為第一次遇到此值  \n        Yes → Step 3: 設定 left[val] = i // 記錄第一次出現的位置  \n        No  → Step 4: 留空 // 已經存在，無需更新 left  \n    → Step 5: 更新 freq[val]++ // 這個值的頻率加一  \n    → Step 6: 設定 right[val] = i // 每次都更新最後一次出現的位置  \n→ Step 7: 計算 degree = max(freq.values()) // 找出陣列的度數（最大頻率）  \n→ Step 8: 設定 minLen = 無窮大 // 初始化最小子陣列長度  \n→ Step 9: 遍歷 freq 中的每個 (val, count) // 檢查所有數值  \n    → Decision: 如果 count == degree? // 只考慮符合度數的數值  \n        Yes → Step 10: 計算 len = right[val] - left[val] + 1 // 子陣列長度  \n        → Decision: 如果 len < minLen? // 比較並更新最小值  \n            Yes → Step 11: minLen = len // 找到更短的子陣列  \n            No  → Step 12: 留空 // 保持現有 minLen  \n        No  → Step 13: 留空 // 不是度數值，忽略  \n→ Step 14: 輸出 minLen // 返回符合度數的最短子陣列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findShortestSubArray(self, nums):\n        \"\"\"回傳與 nums 同度數的最短子陣列長度\"\"\"\n        left, right, count = {}, {}, {}\n        for i, num in enumerate(nums):\n            if num not in left:           # 第一次見到此數字\n                left[num] = i\n            right[num] = i                # 每次更新最後出現位置\n            count[num] = count.get(num, 0) + 1\n\n        degree = max(count.values())       # 整個陣列的度數\n        min_length = float('inf')\n        for num, cnt in count.items():\n            if cnt == degree:              # 只考慮符合度數的數字\n                cur_len = right[num] - left[num] + 1\n                if cur_len < min_length:\n                    min_length = cur_len\n        return min_length\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 將輸入轉換成 list\n    try:\n        # 支援 'nums = [1,2,3]' 形式\n        if '=' in raw_input:\n            _, nums_part = raw_input.split('=', 1)\n            nums = ast.literal_eval(nums_part.strip())\n        else:\n            nums = ast.literal_eval(raw_input)\n    except Exception as e:\n        raise ValueError(f\"無法解析輸入: {raw_input}\") from e\n\n    sol = Solution()\n    result = sol.findShortestSubArray(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,2,3,1,4,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode503.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element II",
    "description_snippet": "Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with arrow and explanation. We must produce algorithm to compute next greater element for circular array. We can use stack method.\n\nWe need to output steps. We need to follow format exactly: line per step. Use \"Start\" and \"End\". Use arrows \"→\". Decision lines etc.\n\nWe must not produce actual code, only pseudocode steps with explanation.\n\nWe'll include steps: initialize result array with -1, stack empty, iterate twice through array indices to simulate circular, push indices, etc.\n\nWe should include decision lines for when stack not empty and current number > value at stack top.\n\nWe'll provide explanatory comments.\n\nLet's create steps.\n\nWe'll write:\n\nStart // begin\n→ Initialize n = length of nums // get size\n→ Initialize result array res of size n with all -1 // default\n→ Initialize empty stack S // will hold indices of elements awaiting next greater\n→ For i from 0 to 2*n-1: // iterate twice over array\n    → Set idx = i mod n // current index in circular sense\n    → While S not empty and nums[idx] > nums[S.top()]: // found next greater for indices on stack\n        → Decision: S.top() value less than nums[idx]?\n            Yes → Pop top = S.pop()\n            → Set res[top] = nums[idx] // assign next greater\n        No  → // loop ends\n    → Push idx onto S // current element may need a next greater later\n→ End // result ready\n\nBut we need \"Decision:\" lines inside while. In the while, we check condition; we don't need decision for each iteration; but we can keep while condition as a decision. The structure guidelines: use Decision: If condition? and then Yes → actions; No → continue.\n\nBut for loops we can just write \"→ For i from 0 to 2*n-1:\".\n\nInside For, we can include decision \"Decision: 如果 nums[idx] > nums[S.top()]?\" etc.\n\nLet's design:\n\nStart\n→ Initialize n = length of nums // 取得陣列長度\n→ Initialize res[0..n-1] = -1 // 預設所有答案為 -1\n→ Initialize empty stack S // 用於儲存待尋找更大值的索引\n→ For i = 0 to 2*n - 1: // 兩次遍歷模擬環形\n    → Set idx = i mod n // 取得目前的環形索引\n    → Decision: 如果 S 非空且 nums[idx] > nums[S.top()]? // 判斷是否有更大值可賦予堆疊頂部\n        Yes →\n            → Pop top = S.pop() // 取得堆疊頂部索引\n            → Set res[top] = nums[idx] // 將更大值寫入答案\n        No → // 若條件不滿足，跳過\n    → Push idx onto S // 將當前索引加入堆疊，等待更大值\n→ End // 完成所有計算\n\nBut we need to ensure that while loop continues until condition fails. But we can use decision inside for and a loop like:\n\n→ Decision: 如果 S 非空且 nums[idx] > nums[S.top()]? // ...\n    Yes → repeat ... (like go back to decision). But that's messy.\n\nBetter to use while loop style:\n\n→ While S 非空且 nums[idx] > nums[S.top()]:\n    → Pop top = S.pop()\n    → res[top] = nums[idx]\n\nBut our format expects arrow lines, but can include while with Decision.\n\nWe can write:\n\n→ Decision: 如果 S 非空且 nums[idx] > nums[S.top()]? // 檢查是否可以賦值\n    Yes →\n        → Pop top = S.pop()\n        → Set res[top] = nums[idx]\n        → Go back to Decision // 重複判斷\n    No  → // 結束 while\n\nBut we cannot use \"Go back to Decision\". Instead we can express as nested loops: For each idx, we repeatedly pop while condition holds. We can structure like:\n\n→ While S 非空且 nums[idx] > nums[S.top()]:\n    → Pop top = S.pop()\n    → Set res[top] = nums[idx]\n\nBut we need to use Decision lines? We can use Decision for the while condition.\n\nLet's propose:\n\n→ Decision: S 非空且 nums[idx] > nums[S.top()]? // 判斷是否有更大值可賦予堆疊頂部\n    Yes →\n        → Pop top = S.pop()\n        → Set res[top] = nums[idx]\n        → Go back to Decision // 重複檢查\n    No  → // 退出 while\n\nBut \"Go back to Decision\" might not be allowed; but we can just show nested decisions.\n\nAlternatively, we can use a for loop with internal while using decision lines.\n\nWe can write:\n\n→ For i from 0 to 2*n - 1:\n    → Set idx = i mod n\n    → Decision: S 非空且 nums[idx] > nums[S.top()]? // 檢查是否需要賦值\n        Yes →\n            → Pop top = S.pop()\n            → Set res[top] = nums[idx]\n            → Go back to Decision // 循環\n        No  → // 退出\n    → Push idx onto S\n\nBut we might simplify: just show decision repeated; but we might not need explicit loop because the pseudocode could just show the while. But format demands we use arrows and structure; we can have while as a block.\n\nWe can do:\n\n→ While S 非空且 nums[idx] > nums[S.top()]:\n    → Pop top = S.pop()\n    → Set res[top] = nums[idx]\n\nBut the format might not allow while; but it's okay. The example didn't show while, only Decision. But we can still use while maybe.\n\nBut guidelines: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\". So we must use those. So we can avoid while and use nested decisions.\n\nWe can create a sub-loop:\n\n→ Decision: S 非空且 nums[idx] > nums[S.top()]? // 判斷\n    Yes →\n        → Pop top = S.pop()\n        → Set res[top] = nums[idx]\n        → Go back to Decision // 重複\n    No  → // 不再賦值\n\nBut we need \"Go back to Decision\". Might be okay but might not match expectation. We could use recursion style but okay.\n\nAlternatively, we can structure:\n\n→ While S 非空且 nums[idx] > nums[S.top()]:\n    → Pop top = S.pop()\n    → Set res[top] = nums[idx]\n\nThe example didn't show while but maybe allowed. But we can just do:\n\n→ Decision: S 非空且 nums[idx] > nums[S.top()]? // 判斷是否有更大值\n    Yes →\n        → Pop top = S.pop()\n        → Set res[top] = nums[idx]\n        → Decision: S 非空且 nums[idx] > nums[S.top()]? // 重新檢查\n            Yes → ... // same as above\n            No  → // exit\n    No  → // exit\n\nBut that's repetitive.\n\nBetter to show a while block: We can show a step \"While S 非空且 nums[idx] > nums[S.top()]:\" with arrow then sub-steps. But example didn't use while but still fine.\n\nGiven the instructions, we should include the algorithm. I'll use a while loop with explanation.\n\nLet's produce final virtual code:\n\nStart\n→ Initialize n = length(nums) // 取得陣列長度\n→ Initialize res array of size n with -1 // 預設所有答案為 -1\n→ Initialize empty stack S // 用來儲存還未找到更大值的索引\n→ For i = 0 to 2*n - 1: // 兩次遍歷以模擬環形\n    → Set idx = i mod n // 當前環形索引\n    → While S 非空且 nums[idx] > nums[S.top()]: // 只要堆疊頂部元素小於當前元素，就賦予答案\n        → Pop top = S.pop()\n        → Set res[top] = nums[idx] // 設定下一個更大值\n    → Push idx onto S // 把當前索引推入堆疊，等待未來更大值\n→ End\n\nBut we need to include explanations after each line. We must add // explanation after each step.\n\nLet's craft final answer:\n\nStart // 程式開始\n→ Initialize n = length(nums) // 取得陣列長度\n→ Initialize res array of size n with -1 // 預設答案為 -1\n→ Initialize empty stack S // 存放尚未找到下一個更大數字的索引\n→ For i = 0 to 2*n - 1: // 兩次遍歷模擬環形陣列\n    → Set idx = i mod n // 取得目前環形索引\n    → While S 非空且 nums[idx] > nums[S.top()]: // 若堆疊頂元素小於當前元素，說明已找到更大值\n        → Pop top = S.pop() // 取出堆疊頂部索引\n        → Set res[top] = nums[idx] // 設定下一個更大值\n    → Push idx onto S // 把當前索引推進堆疊，等待未來更大值\n→ End // 完成所有計算\n\nWe need to add explanations after each line. Ensure formatting: each line `虛擬碼步驟 // 解釋/說明`.\n\nBut we must include indentation? The example didn't use indentation for nested lines; each line has `→` arrow. For nested inside while, we can also use `→` arrow. But we must keep each line separate. The while block should be indicated with arrow too. Example: \"→ While S 非空且 ...:\" then next line inside while also \"→\" maybe with extra indentation? But the instructions didn't say how to indent. But we can keep as separate lines with arrow.\n\nLet's produce each line:\n\nStart // 程式開始\n→ Initialize n = length(nums) // 取得陣列長度\n→ Initialize res array of size n with -1 // 預設答案為 -1\n→ Initialize empty stack S // 存放尚未找到下一個更大數字的索引\n→ For i = 0 to 2*n - 1: // 兩次遍歷模擬環形陣列\n    → Set idx = i mod n // 取得目前環形索引\n    → While S 非空且 nums[idx] > nums[S.top()]: // 若堆疊頂元素小於當前元素，說明已找到更大值\n        → Pop top = S.pop() // 取出堆疊頂部索引\n        → Set res[top] = nums[idx] // 設定下一個更大值\n    → Push idx onto S // 把當前索引推進堆疊，等待未來更大值\n→ End // 完成所有計算\n\nBut we need to ensure each line has a single `→` at beginning. The inner while lines also start with `→`. That's fine.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始  \n→ Initialize n = length(nums) // 取得陣列長度  \n→ Initialize res array of size n with -1 // 預設所有答案為 -1  \n→ Initialize empty stack S // 用來儲存尚未找到更大值的索引  \n→ For i = 0 to 2*n - 1: // 兩次遍歷以模擬環形陣列  \n    → Set idx = i mod n // 取得目前的環形索引  \n    → While S 非空且 nums[idx] > nums[S.top()]: // 若堆疊頂元素小於當前元素，說明已找到更大值  \n        → Pop top = S.pop() // 取出堆疊頂部索引  \n        → Set res[top] = nums[idx] // 設定下一個更大值  \n    → Push idx onto S // 把當前索引推進堆疊，等待未來更大值  \n→ End // 完成所有計算",
      "generated_code": "import sys\nimport ast\nimport re\n\ndef next_greater_elements(nums):\n    n = len(nums)\n    res = [-1] * n\n    stack = []\n    for i in range(2 * n):\n        while stack and nums[stack[-1]] < nums[i % n]:\n            res[stack.pop()] = nums[i % n]\n        if i < n:\n            stack.append(i)\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    m = re.search(r'\\[.*\\]', data)\n    if m:\n        nums_str = m.group(0)\n    else:\n        nums_str = data\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        nums = list(map(int, data.split()))\n    result = next_greater_elements(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1]",
          "expected_output": "[2,-1,2]",
          "success": true,
          "output": "[2, -1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,3]",
          "expected_output": "[2,3,4,-1,4]",
          "success": true,
          "output": "[2, 3, 4, -1, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode120.json",
    "problem_index_in_file": 0,
    "title": "Triangle",
    "description_snippet": "Given a triangle array, return the minimum path sum from top to bottom.\n\nFor each step, you may move...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line. For the algorithm: typical DP from bottom up or top down. Let's choose bottom-up: start from bottom row, accumulate min sums upwards. Steps: start, read triangle, initialize DP as last row copy, iterate rows upward, for each index compute min of two below, update DP. Finally result is DP[0]. Return that.\n\nNeed to use structure with Start, End, Decision. Provide comments. We'll include loops and conditions.\n\nLet's produce lines:\n\nStart // start\n→ Step 1: triangle = input triangle // receive data\n→ Decision: triangle is empty? // check\n    Yes → Step 2: return 0 // no triangle\n    No  →\n→ Step 3: dp = copy of last row // initialize dp\n→ Step 4: for row from second last to first // iterate rows upwards\n    → Step 4.1: for index i in current row\n        → Step 4.1.1: dp[i] = triangle[row][i] + min(dp[i], dp[i+1]) // update\n    → End for each row\n→ Step 5: return dp[0] // result\nEnd // end\n\nAdd arrows: Use → for step lines. Use Decision: with Yes →, No →. Need to ensure each line separate. Use comments //. Provide Chinese explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: triangle = input triangle // 取得三角形資料  \n→ Decision: triangle 為空? // 檢查是否有資料  \n  Yes → Step 2: return 0 // 若三角形為空，直接回傳 0  \n  No → // 進行後續計算  \n→ Step 3: dp = copy of triangle[last row] // 初始化 dp 為最底一列  \n→ Step 4: for row從 second last 到 first 步驟 // 逐行往上處理  \n  → Step 4.1: for index i in triangle[row] 步驟 // 逐個位置  \n    → Step 4.1.1: dp[i] = triangle[row][i] + min(dp[i], dp[i+1]) // 更新最小路徑和  \n  → End for index i  \n→ End for row  \n→ Step 5: return dp[0] // 最小路徑和位於 dp[0]  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef minimum_total(triangle):\n    \"\"\"\n    以自底向上動態規劃計算最小路徑和。\n    dp[i] 代表當前行第 i 個位置到最底部的最小總和。\n    \"\"\"\n    if not triangle:\n        return 0\n    dp = triangle[-1][:]  # 複製最後一行\n    # 逐行往上更新 dp\n    for row in range(len(triangle) - 2, -1, -1):\n        for i in range(len(triangle[row])):\n            dp[i] = triangle[row][i] + min(dp[i], dp[i + 1])\n    return dp[0]\n\ndef main():\n    \"\"\"\n    從標準輸入讀取三角形資料，格式示例：\n    triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 只取等號右邊的列表表達式\n    try:\n        _, expr = data.split('=', 1)\n        triangle = eval(expr.strip())\n    except Exception:\n        # 若輸入格式不符，直接輸出 0\n        triangle = []\n\n    result = minimum_total(triangle)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        },
        {
          "example_index": 1,
          "input": "triangle = [[-10]]",
          "expected_output": "-10",
          "success": true,
          "output": "-10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode506.json",
    "problem_index_in_file": 0,
    "title": "Relative Ranks",
    "description_snippet": "You are given an integer array score of size n, where score[i] is the score of the i_th athlete in a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. The user provided problem: mapping scores to ranks. Steps: pair score with index, sort descending, assign ranks. Output array.\n\nWe need to write virtual code lines: Start, Step lines, decisions maybe none. Provide explanations after //.\n\nUse arrow lines. Use indentation maybe not necessary but include. We can use Decision steps if needed.\n\nWe will produce something like:\n\nStart\n→ Step 1: 建立一個陣列 pair，存放(score, index) for each i // 取出原始分數與索引\n→ Step 2: 將 pair 陣列依 score 降序排序 // 由高分到低分排列\n→ Step 3: 建立答案陣列 answer，長度 n // 用來存放各位運動員的名次\n→ Step 4: 從排序後的 pair 逐個遍歷並為每個索引賦予名次\n    → Decision: 如果位置 < 3? // 前三名特殊\n        Yes → Step 5a: answer[原索引] = 名次對應的獎牌字串 // \"Gold Medal\",\"Silver Medal\",\"Bronze Medal\"\n        No  → Step 5b: answer[原索引] = 位置+1 的字串 // 其餘名次為數字字串\n→ End\n\nBut need to be precise: mapping positions: 0->Gold,1->Silver,2->Bronze. Use variable rank.\n\nWe should show loops: For i from 0 to n-1.\n\nLet's produce lines with arrow. Use indentation for nested.\n\nWe'll output:\n\nStart\n→ Step 1: pair = 空陣列\n→ Decision: 是否有 n 個元素? // ensures array size\n    Yes → 省略\nBut not necessary.\n\nBetter: Show loops: For i in 0..n-1: pair.append((score[i], i)).\n\nWe'll write as virtual code: \"For i = 0 to n-1: pair.append(score[i], i)\" etc.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: pair ← 空陣列 // 用於儲存 (score, 原始索引) 的對\n→ For i = 0 to n-1: pair.append((score[i], i)) // 把每位運動員的分數與索引存入 pair\n→ Step 2: pair.sort(by: score desc) // 依照分數從高到低排序\n→ Step 3: answer ← Array(size: n) // 準備儲存最終名次的陣列\n→ For i = 0 to n-1:\n    → rank ← i + 1 // 排名從 1 開始\n    → Decision: rank <= 3? // 前三名有特殊稱號\n        Yes → Step 4a: medal ← [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"][rank-1] // 取對應獎牌字串\n        No  → Step 4b: medal ← rank.toString() // 其餘名次直接使用數字字串\n    → Step 5: answer[pair[i].index] ← medal // 把名次寫回對應的原始位置\nEnd // 程式執行結束，answer 為最終結果陣列",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def findRelativeRanks(self, score):\n        # 若輸入為空，直接回傳空列表\n        if not score:\n            return []\n        # 依分數由高到低排序\n        sorted_scores = sorted(score, reverse=True)\n        # 建立分數對應名次的字典\n        rank_map = {}\n        for i, s in enumerate(sorted_scores):\n            if i == 0:\n                rank_map[s] = \"Gold Medal\"\n            elif i == 1:\n                rank_map[s] = \"Silver Medal\"\n            elif i == 2:\n                rank_map[s] = \"Bronze Medal\"\n            else:\n                rank_map[s] = str(i + 1)\n        # 根據原始順序產生結果\n        return [rank_map[s] for s in score]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入字串成 Python list\n    score = ast.literal_eval(data)\n    solution = Solution()\n    result = solution.findRelativeRanks(score)\n    # 輸出符合題目要求的 JSON 格式（無空格）\n    print(json.dumps(result, separators=(',', '')))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[5,4,3,2,1]",
          "expected_output": "[\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]",
          "success": true,
          "output": "[\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]"
        },
        {
          "example_index": 1,
          "input": "[10,3,8,9,4]",
          "expected_output": "[\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]",
          "success": true,
          "output": "[\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode451.json",
    "problem_index_in_file": 0,
    "title": "Sort Characters By Frequency",
    "description_snippet": "Given a string s, sort it in decreasing order based on the frequency of the characters. The frequenc...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanation. Should not output actual code, only steps like \"Start\", \"→ Step 1: Build frequency map of characters from s\", etc. Use arrows. Use decision steps. Provide line by line. Let's craft.\n\nWe need to handle input string s, count frequency, sort characters by frequency descending, build result string. If multiple answers, any. So steps: start, step1: create map, step2: iterate string to count, step3: create list of (char, freq), step4: sort by freq descending, step5: build result string by repeating char freq times, step6: return result, end.\n\nNeed to use virtual code with arrow and explanation. Use \"Decision:\" maybe not needed. Could show sorting decision but not a binary decision.\n\nLet's produce maybe some decision if freq equal then any order, we just keep original or arbitrary.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: Initialize empty map freqMap // 用來記錄每個字元出現次數\n→ Step 2: For each char in s: increment freqMap[char] // 統計頻率\n→ Step 3: Convert freqMap to list of (char, freq) pairs // 方便排序\n→ Step 4: Sort list by freq descending // 依頻率降序排列\n    (若頻率相同，任意順序) // 允許多種答案\n→ Step 5: Initialize empty result string // 用於組裝結果\n→ Step 6: For each (char, freq) in sorted list:\n→     Append char repeated freq times to result // 重複寫入\n→ Step 7: Return result // 最終輸出\nEnd // 程式執行結束\n\nNeed to include arrow and comments.\n\nMake sure each line follows format: \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nAlso use \"Start\" and \"End\".\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize empty map freqMap // 用來記錄每個字元出現的頻率  \n→ Step 2: For each char in s: increment freqMap[char] // 逐字累加統計  \n→ Step 3: Convert freqMap to list of (char, freq) pairs // 方便後續排序  \n→ Step 4: Sort list by freq descending // 按頻率由高到低排列  \n  (若頻率相同，可任意順序) // 允許多種合法答案  \n→ Step 5: Initialize empty string result // 用於組裝最終字串  \n→ Step 6: For each (char, freq) in sorted list:  \n  Append char repeated freq times to result // 重複寫入以形成頻率段  \n→ Step 7: Return result // 回傳排序後的字串  \nEnd // 程式執行結束",
      "generated_code": "from collections import Counter\n\ndef frequency_sort(s: str) -> str:\n    \"\"\"將字串 s 按字元頻率降序排序，若頻率相同則保持原始順序。\"\"\"\n    counts = Counter(s)\n    # Counter.most_common() 會按頻率降序，頻率相同時保持原始順序\n    return ''.join(char * freq for char, freq in counts.most_common())\n\ndef main() -> None:\n    import sys\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析可能的「s = \"xxxx\"」格式，或直接輸入字串\n    first_quote = data.find('\"')\n    last_quote = data.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        s = data[first_quote + 1 : last_quote]\n    else:\n        # 直接輸入字串，移除可能的外層引號\n        s = data.strip('\"')\n\n    result = frequency_sort(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eetr\"",
          "success": true,
          "output": "eetr"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"cccaaa\"",
          "success": true,
          "output": "cccaaa"
        },
        {
          "example_index": 2,
          "input": "s = \"Aabb\"",
          "expected_output": "\"bbAa\"",
          "success": true,
          "output": "bbAa"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode336.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Pairs",
    "description_snippet": "You are given a 0-indexed array of unique strings words.\n\nA palindrome pair is a pair of integers (i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output pseudocode steps. The requirement: virtual code, no actual code. Must explain each line. Must be O(total length). For palindrome pairs problem, typical solution uses hash map of reversed strings. We need to outline steps: build map of word -> index. For each word, iterate over splits, check palindrome prefixes/suffixes, and look up reversed complement. Must avoid duplicate pairs.\n\nWe need to output in specified format, each line: \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nWe need to produce steps: Start, Build map, For each word i, for each split position from 0 to len, check palindrome prefix and suffix, etc. Also handle empty string special case.\n\nAlso need to avoid duplicates: we can store pairs sorted or only add when i < j. But we can just produce all and deduplicate.\n\nLet's craft pseudocode lines. Need to be clear.\n\nWe'll produce steps: Start, Build map, For each word i: iterate over splits, etc.\n\nLet's output in Chinese comments.\n\nAlso need to include decisions with arrow Yes/No.\n\nWe'll produce:\n\nStart // 程式開始執行\n\n→ Step 1: 建立字典 reverse_map，將每個字串的反向映射到其索引 // 方便快速查找\n\n→ Step 2: 初始化空列表 pairs // 儲存所有符合條件的索引對\n\n→ Decision: 是否有空字串在 words? // 空字串與任何回文字串都可形成對\n\n    Yes → For each word j ≠ empty_index: If word[j] is palindrome → pairs add (empty_index, j) and (j, empty_index) // 兩種順序\n\n    No → // 無需處理\n\n→ For each index i, word in words: // 主迴圈\n\n    → For split pos from 0 to len(word): // 分割位置\n\n        → Decision: 前綴 word[0:pos] 是否為回文? // 若為回文\n\n            Yes → suffix = word[pos:] // 後綴\n\n                → Decision: suffix 在 reverse_map? // 以查找相對的反向字串\n\n                    Yes → j = reverse_map[suffix]\n\n                        → Decision: j != i? // 防止自對\n\n                            Yes → pairs add (j, i) // 因為 suffix + prefix = palindrome\n\n                            No → // skip\n\n                    No → // 無對應字串\n\n            No → // 前綴非回文，跳過\n\n        → Decision: 後綴 word[pos:] 是否為回文? // 另一種情況\n\n            Yes → prefix = word[0:pos]\n\n                → Decision: prefix 在 reverse_map? // 查找對應反向\n\n                    Yes → j = reverse_map[prefix]\n\n                        → Decision: j != i?\n\n                            Yes → pairs add (i, j) // 前綴 + suffix = palindrome\n\n                            No → // skip\n\n                    No → // 無對應\n\n            No → // 後綴非回文，跳過\n\n→ End // 程式結束，返回 pairs\n\nWe also need to ensure that for splits where pos==len(word) or pos==0 we treat appropriately: When pos==len(word), prefix is whole word, suffix empty string. If suffix is empty, we check reverse_map['']? That would be empty string index. That will handle empty string pair. But we already handle empty separately.\n\nBut we can keep logic.\n\nMake sure to use arrows \"→\".\n\nLet's format each line with \"虛擬碼步驟\" then space then comment.\n\nWe need to use \"→\" and \"Decision:\" etc.\n\nWe should keep each line separate. Let's craft lines.\n\nNeed to keep consistent indentation? Not required but may help readability.\n\nWe'll use arrow for each step line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 reverse_map，將每個字串的反向映射到其索引 // 方便快速查找  \n→ Step 2: 初始化空列表 pairs // 儲存所有符合條件的索引對  \n→ Decision: words 中是否有空字串？ // 空字串可與任何回文字串配對  \n Yes → Step 3: 找出空字串的索引 empty_idx  \n  → For each index j ≠ empty_idx: // 逐個字串  \n    → Decision: words[j] 是否為回文？  \n     Yes → pairs add (empty_idx, j) // 空+回文  \n     Yes → pairs add (j, empty_idx) // 回文+空  \n     No → // 不是回文，跳過  \n No → // 沒有空字串，無需特別處理  \n→ For each index i, word in words: // 主迴圈，檢查每個字串  \n → For split_pos from 0 to len(word): // 逐位分割  \n  → Decision: 前綴 word[0:split_pos] 是否為回文？  \n   Yes → suffix = word[split_pos:]  \n    → Decision: suffix 是否存在於 reverse_map？  \n     Yes → j = reverse_map[suffix]  \n      → Decision: j ≠ i？  \n       Yes → pairs add (j, i) // suffix+prefix 為回文  \n       No → // 自對，跳過  \n     No → // 無對應字串  \n   No → // 前綴非回文，跳過  \n  → Decision: 後綴 word[split_pos:] 是否為回文？  \n   Yes → prefix = word[0:split_pos]  \n    → Decision: prefix 是否存在於 reverse_map？  \n     Yes → j = reverse_map[prefix]  \n      → Decision: j ≠ i？  \n       Yes → pairs add (i, j) // 前綴+suffix 為回文  \n       No → // 自對，跳過  \n     No → // 無對應字串  \n   No → // 後綴非回文，跳過  \nEnd // 程式執行結束，返回 pairs",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立字典：每個字串的反向映射到其索引\n        reverse_map = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        # 檢查是否有空字串，若有則與所有回文字串配對\n        if \"\" in words:\n            empty_idx = words.index(\"\")\n            for j, w in enumerate(words):\n                if j != empty_idx and self.is_palindrome(w):\n                    res.append([empty_idx, j])\n                    res.append([j, empty_idx])\n\n        # 針對每個字串進行所有可能的切分\n        for i, word in enumerate(words):\n            word_len = len(word)\n            for j in range(word_len + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                # 情況一：前綴是回文，後綴存在於字典\n                if self.is_palindrome(prefix):\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in reverse_map:\n                        k = reverse_map[rev_suffix]\n                        if k != i:\n                            res.append([i, k])\n\n                # 情況二：後綴是回文，前綴存在於字典\n                # 避免重複：j != 0 保證前綴非空\n                if j != 0 and self.is_palindrome(suffix):\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in reverse_map:\n                        k = reverse_map[rev_prefix]\n                        if k != i:\n                            res.append([k, i])\n\n        return res\n\n    @staticmethod\n    def is_palindrome(s: str) -> bool:\n        \"\"\"判斷字串是否為回文\"\"\"\n        return s == s[::-1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，例如 \"words = [\\\"abcd\\\",\\\"dcba\\\",\\\"lls\\\",\\\"s\\\",\\\"sssll\\\"]\"\n    if \"=\" in data:\n        _, words_part = data.split(\"=\", 1)\n        words_part = words_part.strip()\n    else:\n        words_part = data\n\n    # 使用 ast.literal_eval 以安全方式解析字串\n    words = ast.literal_eval(words_part)\n\n    sol = Solution()\n    result = sol.palindromePairs(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[2,3]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[2, 3]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1], [0, 1]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode386.json",
    "problem_index_in_file": 0,
    "title": "Lexicographical Numbers",
    "description_snippet": "Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for algorithm that given integer n, return all numbers from 1 to n sorted lexicographically. Classic problem: generate lexicographic order via DFS/iterative. We must O(n) time and O(1) space. Use iterative with current prefix, loop over n. We'll produce pseudocode lines with comments.\n\nWe should output lines with Start, → Step, Decision, etc.\n\nWe need to include each line as \"虛擬碼步驟 // 解釋\".\n\nWe need to ensure we produce all lines.\n\nLet's craft algorithm:\n\nStart\n→ Step 1: 設定 current = 1, count = 0 // 初始化當前數字為 1，已輸出數量為 0\n→ Decision: while count < n? // 確認是否已輸出完所有數字\n    Yes → Step 2: 輸出 current // 輸出目前數字\n    → Step 3: count = count + 1 // 已輸出數量加一\n    → Decision: 如果 current * 10 <= n? // 是否可以往下擴充為下一層前綴\n        Yes → Step 4: current = current * 10 // 進入下一層\n        No → Decision: 如果 current % 10 != 9 且 current + 1 <= n? // 是否可以右移到下一個兄弟\n            Yes → Step 5: current = current + 1 // 移動到下一個兄弟\n            No → Step 6: current = current / 10 // 返回上一層\n                → Decision: 如果 current == 0? // 當回到根層時結束\n                    Yes → End // 程式結束\n                    No → Step 7: current = current + 1 // 從上一層的最後兄弟往右移\n\nBut need to be careful: In lexicographic order, we can use algorithm similar to Leetcode 386. Use while loop until count==n.\n\nWe need to maintain O(1) space. We only use few variables.\n\nWe should express pseudocode step by step. Let's produce lines.\n\nWe might use indentations for decisions.\n\nWe must include \"→ Decision:\" lines with branches.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 current ← 1, count ← 0 // 初始化當前數字為 1，已輸出數量為 0  \n→ Decision: 是否已輸出完所有數字 (count < n)?  \n    Yes → Step 2: 輸出 current // 將 current 加入結果序列  \n    → Step 3: count ← count + 1 // 已輸出數量加 1  \n    → Decision: 是否可以進入下一層 (current * 10 ≤ n)?  \n        Yes → Step 4: current ← current * 10 // 進入以 current 為前綴的子樹  \n        No → Decision: 是否可以右移到同層的下一個兄弟 (current % 10 ≠ 9 且 current + 1 ≤ n)?  \n            Yes → Step 5: current ← current + 1 // 右移到同層下一個數字  \n            No → Step 6: current ← current / 10 // 回到上一層  \n                → Decision: 是否已回到根層 (current = 0)?  \n                    Yes → End // 所有數字已輸出，結束程式  \n                    No → Step 7: current ← current + 1 // 從上一層的最後兄弟往右移  \n→ Decision: 返回主循環 (count < n)?  \n    Yes → 回到 Decision: 是否已輸出完所有數字  \n    No → End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef lexical_order(n: int):\n    \"\"\"\n    Return all numbers from 1 to n in lexicographical order.\n    Algorithm uses only a few integer variables (O(1) extra space)\n    and visits each number exactly once (O(n) time).\n    \"\"\"\n    result = []\n    current = 1          # current number in the lexicographical traversal\n    count = 0            # how many numbers have been output\n\n    while count < n:\n        result.append(current)\n        count += 1\n\n        # Try to go deeper to the next level (current*10)\n        if current * 10 <= n:\n            current *= 10\n        else:\n            # Can't go deeper, move to the next sibling in the same level\n            while current % 10 == 9 or current + 1 > n:\n                current //= 10\n            current += 1\n\n    return result\n\ndef main() -> None:\n    # Read the entire input, extract the first integer found\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n\n    # Compute and output the lexicographical order\n    print(lexical_order(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "success": true,
          "output": "[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode10.json",
    "problem_index_in_file": 0,
    "title": "Regular Expression Matching",
    "description_snippet": "Given an input string s and a pattern p, implement regular expression matching with support for '.' ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for regex matching with . and *. Standard dynamic programming approach. We'll produce steps: start, input s, p, initialize DP table, iterate, decisions. Provide explanation each line.\n\nWe must produce virtual code steps line by line. Use arrows. Let's produce as per example. Ensure each line has \"虛擬碼步驟\" then space then \"// explanation\". Use arrows as needed.\n\nLet's produce:\n\nStart\n→ Input: s, p\n→ Initialize DP array dp[ len(s)+1 ][ len(p)+1 ] to False\n→ dp[0][0] = True\n→ // dp[i][j] means s[0..i) matches p[0..j)\n→ For i from 0 to len(s):\n    → For j from 1 to len(p):\n        → Decision: 如果 p[j-1] == '*':\n            → Decision: 如果 j-2 >= 0 and (p[j-2] == s[i-1] or p[j-2] == '.'):\n                → Yes → dp[i][j] = dp[i][j-2] or dp[i-1][j] // zero or more\n                → No  → dp[i][j] = dp[i][j-2] // zero occurrence\n            → Else:\n                → No? Actually when p[j-1] != '*', skip.\n        → Decision: 如果 p[j-1] != '*':\n            → Decision: 如果 i>0 and (p[j-1] == s[i-1] or p[j-1] == '.'):\n                → Yes → dp[i][j] = dp[i-1][j-1]\n            → No  → dp[i][j] = False\n→ End // return dp[len(s)][len(p)]\n\nWe need to adapt formatting: Use \"→\" at start of each line, nested decisions indent? In example they used indent. We'll follow same style.\n\nLet's produce each step. Ensure each line ends with // explanation. Use Chinese explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: s, p // 取得待匹配字串與模式  \n→ Initialize DP array dp[ len(s)+1 ][ len(p)+1 ] to False // dp[i][j] 表示 s 的前 i 個字元能否與 p 的前 j 個字元完全匹配  \n→ dp[0][0] = True // 空字串與空模式匹配  \n→ // 迭代計算 dp 表  \n→ For i from 0 to len(s): // i 為 s 的長度指標  \n    → For j from 1 to len(p): // j 為 p 的長度指標  \n        → Decision: p[j-1] == '*'? // 判斷當前模式字符是否為星號  \n            → Yes → Decision: j-2 >= 0 AND (p[j-2] == s[i-1] OR p[j-2] == '.')? // 星號前一個字符與 s 的上一個字符是否匹配  \n                → Yes → dp[i][j] = dp[i][j-2] OR dp[i-1][j] // 0 次或多次匹配  \n                → No  → dp[i][j] = dp[i][j-2] // 只考慮 0 次  \n            → No  → // p[j-1] 不是 '*', 直接進行字符比對  \n                → Decision: i > 0 AND (p[j-1] == s[i-1] OR p[j-1] == '.')? // 前一字符是否匹配  \n                    → Yes → dp[i][j] = dp[i-1][j-1] // 逐字符匹配  \n                    → No  → dp[i][j] = False // 不匹配  \n→ End // 程式執行結束，返回 dp[len(s)][len(p)] 為最終匹配結果",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        # When pattern can match empty string (e.g., a* or .* etc.)\n        for j in range(2, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    # zero occurrence of the preceding element\n                    dp[i][j] = dp[i][j - 2]\n                    # one or more occurrences if preceding element matches current char\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n        return dp[m][n]\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form:\n        s = \"abc\", p = \"a.*c\"\n    Returns the two strings without quotes.\n    \"\"\"\n    pattern = r's\\s*=\\s*\"([^\"]*)\"\\s*,\\s*p\\s*=\\s*\"([^\"]*)\"'\n    match = re.search(pattern, data)\n    if match:\n        return match.group(1), match.group(2)\n    # Fallback: try reading two lines each containing a string\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, p = parse_input(raw_input)\n    sol = Solution()\n    result = sol.isMatch(s, p)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"a*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\", p = \".*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode518.json",
    "problem_index_in_file": 0,
    "title": "Coin Change II",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for coin change combinations problem. We output line by line virtual code with explanation. Use Start, End, Decision, etc. Provide a DP approach. Steps: initialize DP array length amount+1, DP[0] = 1. For each coin, iterate amount from coin to target, dp[amt] += dp[amt-coin]. At end return dp[amount].\n\nWe should represent loops and decisions. The loop over coins, inner loop over amounts. Provide explanation each line. Avoid actual code. Use arrow and description. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 dp 陣列長度為 amount+1 且全部初值為 0 // 建立用於存放各金額組合數的 DP 陣列  \n→ Step 2: 將 dp[0] 設為 1 // 金額為 0 時只有一種組合，即不拿任何硬幣  \n→ Step 3: 迭代每一個硬幣 denomination in coins // 外層循環，逐個處理不同面額  \n    → Step 4: 迭代 amt 從 denomination 到 amount // 內層循環，更新可達到的金額  \n        → Decision: 如果 amt >= denomination? // 判斷此金額是否可使用當前硬幣  \n            Yes → Step 5: dp[amt] 加上 dp[amt - denomination] // 將使用此硬幣前已知的組合數加入  \n            No  → // 不需要任何操作，因為 amt < denomination 時此硬幣不可能使用  \n→ Step 6: 返回 dp[amount] // 完成所有硬幣處理後，dp[amount] 即為所求組合數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef change(amount: int, coins: list[int]) -> int:\n    \"\"\"\n    计算使用无限个各面额硬币组成目标金额 amount 的组合数。\n    使用动态规划：\n    - dp[i] 表示金额 i 的组合数\n    - 初始化 dp[0] = 1（金额 0 只有一种组合：不拿硬币）\n    - 对每个硬币面额 coin，遍历金额 i 从 coin 到 amount\n      更新 dp[i] += dp[i - coin]\n    \"\"\"\n    dp = [0] * (amount + 1)\n    dp[0] = 1\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n    return dp[amount]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 期望輸入格式類似: '5, [1,2,5]'\n    parts = data.split(',', 1)\n    amount = int(parts[0].strip())\n    coins_str = parts[1].strip()\n    coins = ast.literal_eval(coins_str)\n    result = change(amount, coins)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "5, [1,2,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "3, [2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "10, [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode434.json",
    "problem_index_in_file": 0,
    "title": "Number of Segments in a String",
    "description_snippet": "Given a string s, return the number of segments in the string.\n\nA segment is defined to be a contigu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Provide line by line with explanation. The steps: Start, Step to initialize count and inSegment flag, iterate characters, update count when start of new segment, etc. Use Decision arrows. Let's craft.\n\nWe need to output in Traditional Chinese.\n\nSteps:\n\nStart // start\n→ Step 1: 初始化 count = 0，inSegment = false // 初始化計數器與段狀態\n→ Step 2: 遍歷字符串 s 的每個字符 ch // 遍歷每個字符\n    → Decision: 如果 ch 為空格? // 檢查字符是否為空格\n        Yes → Set inSegment = false // 空格，結束任何段\n        No → Decision: 如果 inSegment 為 false? // 若不是空格且未處於段中\n            Yes → Increment count; inSegment = true // 新段開始，計數 +1\n            No  → // 仍在段中，繼續\n→ Step 3: 返回 count // 回傳段數\nEnd // 程式結束\n\nMake sure format: each line with \"虛擬碼步驟\" and comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 count = 0，inSegment = false // 設定段數計數器為 0，並標示是否正在段中  \n→ Step 2: 遍歷字符串 s 的每個字符 ch // 逐一處理每個字符  \n    → Decision: 如果 ch 為空格? // 判斷是否為空白字符  \n        Yes → inSegment = false // 遇到空格則結束任何段  \n        No  → Decision: if inSegment 為 false? // 若不是空格且不在段中  \n            Yes → count = count + 1，inSegment = true // 新段開始，段數加一並標示已進入段  \n            No  → // 已在段中，繼續遍歷下個字符  \n→ Step 3: 返回 count // 結束並輸出段的總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef count_segments(s: str) -> int:\n    \"\"\"\n    計算 s 中連續非空白字符所形成的段數。\n    \"\"\"\n    count = 0          # 段數計數器\n    in_segment = False # 是否正在一個段中\n    for ch in s:\n        if ch.isspace():          # 遇到空白字符，結束任何段\n            in_segment = False\n        else:                     # 遇到非空白字符\n            if not in_segment:    # 不是段中的字符，表示新段開始\n                count += 1\n                in_segment = True\n    return count\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取資料，處理後輸出段數。\n    支援輸入形式：\n        s = \"Hello, my name is John\"\n        \"Hello, my name is John\"\n        Hello\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 嘗試從輸入中抽取字串\n    if '\"' in data:\n        start = data.find('\"')\n        end = data.rfind('\"')\n        s = data[start + 1:end]\n    else:\n        # 可能是 \"s = Hello\" 之類的格式\n        if '=' in data:\n            _, value = data.split('=', 1)\n            s = value.strip()\n        else:\n            s = data\n\n    result = count_segments(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello, my name is John\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"Hello\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode483.json",
    "problem_index_in_file": 0,
    "title": "Smallest Good Base",
    "description_snippet": "Given an integer n represented as a string, return the smallest good base of n.\n\nWe call k >= 2 a go...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: given n as string, find smallest base k>=2 such that representation of n in base k is all ones. That means n = 1 + k + k^2 + ... + k^{m-1} for some m >= 2. That sum = (k^m -1)/(k-1) = n. Need to find smallest k.\n\nWe can search m from max possible down to 2. Since k>=2, m <= log2(n)+1. So for each m, compute integer k as floor(n^(1/(m-1)))? Actually we need to find k such that k^{m-1} <= n. Use binary search. For each m, binary search k from 2 to n^{1/(m-1)}+1. Compute sum with overflow detection. If sum equals n, return k. After loop, return n-1 as base because when m=2, representation is '11' base (n = k+1 => k = n-1). So answer is n-1.\n\nWe produce virtual code with steps, decisions, loops.\n\nWe output line by line with arrows etc. Use Start, End. Use Decision: if found? etc.\n\nNeed to avoid actual code. Just pseudocode. Provide explanations after //.\n\nLet's craft:\n\nStart\n→ Step 1: Convert input string n to integer value N // Get numeric value of n\n→ Decision: If N <= 3? // handle small numbers\n    Yes → Step 2: Return N-1 // minimal base\n    No  → Step 3: Compute max_m = floor(log2(N)) + 1 // maximum possible number of digits\n→ Step 4: For m from max_m down to 2 // iterate possible lengths\n    → Step 5: Set low = 2, high = N^{1/(m-1)} + 1 // initial search bounds\n    → Decision: While low <= high? // binary search for base k\n        → Step 6: mid = (low + high) // 2 // candidate base\n        → Step 7: Compute sum = 1\n        → Step 8: For i from 1 to m-1\n            → Step 9: sum = sum * mid + 1 // accumulate ones\n            → Decision: If sum > N? // avoid overflow\n                → Step 10: Break // stop early\n        → Decision: If sum == N? // found base\n            → Yes → Step 11: Return mid // smallest good base found\n            → No → Decision: If sum < N? // adjust search\n                → Yes → Step 12: low = mid + 1 // try larger k\n                → No  → Step 13: high = mid - 1 // try smaller k\n→ Step 14: Return N-1 // fallback, m=2 case\n\nEnd\n\nWe need to format each line with arrow. Use \"→\" preceding each step. Indent decisions etc.\n\nNeed to show \"Decision:\" lines. Use indentation for nested. Use Yes → etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 把輸入字串 n 轉成整數 N // 取得 n 的數值  \n→ Decision: 如果 N <= 3? // 處理小數字特殊情況  \n  Yes → Step 2: 回傳 N-1 // 最小好基為 N-1（如 n=2,3）  \n  No  → Step 3: 計算 max_m = ⌊log₂(N)⌋ + 1 // 可能的最大位數  \n→ Step 4: 從 m = max_m 迴圈到 2 // 嘗試每種位數  \n  → Step 5: 設 low = 2, high = ⌊N^{1/(m-1)}⌋ + 1 // 二分搜尋範圍  \n  → Decision: while low <= high? // 搜尋 k  \n    Yes → Step 6: mid = (low + high) / 2 // 目前候選基底  \n    → Step 7: 計算 sum = 1 // 初始位數 1  \n    → Step 8: 對 i = 1 到 m-1 做  \n      → Step 9: sum = sum * mid + 1 // 逐位累加 1  \n      → Decision: 如果 sum > N? // 防止溢出或過大  \n        Yes → Step 10: 跳出迴圈 // 已超過 N  \n    → Decision: 如果 sum == N? // 找到答案  \n      Yes → Step 11: 回傳 mid // 找到最小好基底  \n      No → Decision: 如果 sum < N? // 需要更大 k  \n        Yes → Step 12: low = mid + 1 // 將範圍調大  \n        No  → Step 13: high = mid - 1 // 將範圍調小  \n→ Step 14: 回傳 N-1 // 若沒找到，退回到 m=2 的情況  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        N = int(n)\n\n        # For very small N the answer is trivial\n        if N <= 3:\n            return str(N - 1)\n\n        # The number of digits m in the base‑k representation satisfies\n        #   k^(m-1) <= N < k^m   and k >= 2\n        # Thus m cannot exceed the bit length of N.\n        max_m = N.bit_length()\n\n        # Try all possible lengths m from large to small\n        for m in range(max_m, 1, -1):\n            left, right = 2, N - 1\n\n            # Binary search for the base k\n            while left <= right:\n                mid = (left + right) // 2\n\n                # Compute 1 + mid + mid^2 + ... + mid^(m-1)\n                s = 1\n                for _ in range(1, m):\n                    s = s * mid + 1\n                    if s > N:          # no need to keep computing\n                        break\n\n                if s == N:\n                    return str(mid)\n                elif s < N:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n\n        # If no larger m works, the representation must be \"11\" in base N-1\n        return str(N - 1)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract the first integer found in the input\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        sys.exit(0)\n\n    n_str = nums[0]\n    solution = Solution()\n    print(solution.smallestGoodBase(n_str))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = \"13\"",
          "expected_output": "\"3\"",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = \"4681\"",
          "expected_output": "\"8\"",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 2,
          "input": "n = \"1000000000000000000\"",
          "expected_output": "\"999999999999999999\"",
          "success": true,
          "output": "999999999999999999"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode326.json",
    "problem_index_in_file": 0,
    "title": "Power of Three",
    "description_snippet": "Given an integer n, return true if it is a power of three. Otherwise, return false.\n\nAn integer n is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm: check if n is power of three. We will provide step-by-step pseudo code with arrow and explanation. Must use Start, Decision, End. Each line: virtual code step + space + // explanation.\n\nShould be structured. Probably steps: Start, Step 1: if n <=0 return false, Step 2: while n %3 ==0 divide n by3, Step 3: return n==1, End.\n\nUse decisions with Yes/No. Provide each line accordingly.\n\nLet's produce.\n\nMake sure each line has virtual code then // explanation.\n\nUse arrow →. Use Start and End lines.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: n 是否小於等於 0? // 檢查是否為非正整數  \n    Yes → Step 1: 回傳 false // 非正整數不能是 3 的冪  \n    No  → Step 2: 進入迴圈檢查除以 3 的可行性 // 確認能否不斷除以 3  \n→ Decision: n 能否被 3 完全整除? // 判斷目前 n 是否仍為 3 的倍數  \n    Yes → Step 3: n = n / 3 // 進一步簡化 n，繼續迴圈  \n    No  → Decision: n 是否等於 1? // 迴圈結束時檢查是否化為 1  \n        Yes → Step 4: 回傳 true // 成功化為 1，表示 n 是 3 的冪  \n        No  → Step 5: 回傳 false // 無法化為 1，表示 n 不是 3 的冪  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfThree(self, n: int) -> bool:\n        \"\"\"\n        檢查 n 是否為 3 的冪。\n        \"\"\"\n        if n <= 0:\n            return False\n        while n % 3 == 0:\n            n //= 3\n        return n == 1\n\ndef main() -> None:\n    \"\"\"\n    讀取輸入，解析整數 n，輸出是否為 3 的冪。\n    \"\"\"\n    data = sys.stdin.read()\n    # 找出第一個整數（可能包含負號）\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    solution = Solution()\n    result = solution.isPowerOfThree(n)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 27",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = -1",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode179.json",
    "problem_index_in_file": 0,
    "title": "Largest Number",
    "description_snippet": "Given a list of non-negative integers nums, arrange them such that they form the largest number and ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm to form largest number from list of non-negative integers by arranging them. Classic problem: sort by custom comparator of string concatenation.\n\nWe produce pseudo-code line by line: Start, Step 1: convert list to strings. Step 2: sort using comparator: compare a+b vs b+a. Step 3: if first string is \"0\", return \"0\". Step 4: concatenate sorted list into result string. Step 5: return result. End.\n\nWe need each line with arrow and comment. Use Start, End, Decision. Use Yes → No. For sorting, we could have Decision: if a+b > b+a? But better to sort directly. Provide pseudo-code with comparator.\n\nLet's draft lines.\n\nStart // 程式開始執行\n\n→ Step 1: Convert each integer in nums to a string array strs // 轉換為字串以便比較\n\n→ Step 2: Sort strs using comparator that orders strings by concatenation result // 排序，較大組合排前面\n\n→ Decision: strs[0] == \"0\"? // 檢查最高位是否為 0，若全為 0\n\n    Yes → Step 3: Return \"0\" // 若所有數字為 0，直接回傳單一 \"0\"\n\n    No  → Step 4: Concatenate all strings in strs into result // 將排序後的字串連接成最終結果\n\n→ Step 5: Return result // 回傳最大的數字字串\n\nEnd // 程式執行結束\n\nBut need to show comparator details maybe. Use decision inside sort: For each pair a,b: compare a+b and b+a. But we can simply state.\n\nWe can include an explicit comparator function as a step:\n\n→ Step 2a: Define comparator Compare(a,b) → return a+b > b+a // 判斷兩個字串組合的大小\n\n→ Step 2b: Sort strs with Compare // 用比較函數排序\n\nLet's produce final output.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow for each step. Use Decision: lines indent? In example, they used indentation with 4 spaces.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: Convert each integer in nums to string array strs // 將整數轉為字串以便後續排序\n→ Step 2a: Define comparator Compare(a,b) → return a+b > b+a // 判斷兩個字串組合的大小，較大排前\n→ Step 2b: Sort strs using Compare // 根據比較函數對字串進行排序\n→ Decision: strs[0] == \"0\"? // 檢查排序後最高位是否為 0，若全為 0\n    Yes → Step 3: Return \"0\" // 若所有數字為 0，直接回傳 \"0\"\n    No  → Step 4: Concatenate all strings in strs into result // 將排序後的字串連接成最終結果\n→ Step 5: Return result // 回傳最大的數字字串\nEnd // 程式執行結束\n\nMake sure format: each line starts with arrow or Start, End. For decision branches indent lines after Decision.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Convert each integer in nums to string array strs // 將整數轉為字串以便後續排序  \n→ Step 2a: Define comparator Compare(a,b) → return a+b > b+a // 判斷兩個字串組合的大小，較大排前  \n→ Step 2b: Sort strs using Compare // 根據比較函數對字串進行排序  \n→ Decision: strs[0] == \"0\"? // 檢查排序後最高位是否為 0，若全為 0  \n  Yes → Step 3: Return \"0\" // 若所有數字為 0，直接回傳 \"0\"  \n  No  → Step 4: Concatenate all strings in strs into result // 將排序後的字串連接成最終結果  \n→ Step 5: Return result // 回傳最大的數字字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom functools import cmp_to_key\n\nclass Solution:\n    def largestNumber(self, nums):\n        # 1. 把整數轉成字串\n        nums_str = list(map(str, nums))\n        # 2. 定義比較函式：若 x+y > y+x，則 x 應排在前面\n        def compare(x, y):\n            if x + y > y + x:\n                return -1\n            elif x + y < y + x:\n                return 1\n            else:\n                return 0\n        # 3. 用自訂比較函式排序\n        nums_str.sort(key=cmp_to_key(compare))\n        # 4. 連結排序後的字串\n        result = ''.join(nums_str)\n        # 5. 若結果全為 0，回傳單一 '0'\n        return '0' if result[0] == '0' else result\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    data = sys.stdin.read().strip()\n    # 取出中括號內的數列\n    match = re.search(r'\\[(.*?)\\]', data)\n    if match:\n        # 直接 eval 轉成 list，因為輸入格式是合法的 Python 列表字面量\n        nums = eval(match.group(0))\n    else:\n        nums = []\n\n    sol = Solution()\n    answer = sol.largestNumber(nums)\n    print(answer)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,2]",
          "expected_output": "\"210\"",
          "success": true,
          "output": "210"
        },
        {
          "example_index": 1,
          "input": "nums = [3,30,34,5,9]",
          "expected_output": "\"9534330\"",
          "success": true,
          "output": "9534330"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode232.json",
    "problem_index_in_file": 0,
    "title": "Implement Queue using Stacks",
    "description_snippet": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should supp...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing a queue using two stacks. Each line: virtual step + // explanation. Use Start, End, Decision, arrows. No actual code, only pseudo-steps. Should be line-by-line.\n\nWe need to cover push, pop, peek, empty methods. We need to maintain two stacks: stack_in and stack_out. On push: push to stack_in. On pop/peek: if stack_out empty, transfer all from stack_in to stack_out. Then pop/peek from stack_out.\n\nAlso empty: check both stacks empty.\n\nWe need to provide steps for class definition and methods.\n\nSo format:\n\nStart // 開始程式\n\n→ Step: Initialize stack_in, stack_out // 初始化兩個堆疊\n\nThen methods.\n\nMaybe we need separate methods pseudo. Provide as separate blocks.\n\nLet's craft.\n\nWe can include method definitions as separate steps.\n\nMake sure each line includes virtual code step and comment.\n\nUse arrow → for next steps.\n\nUse Decision: for condition checks.\n\nAlso mention loops.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個空堆疊 stack_in、stack_out // 用來儲存進入與移除元素的兩個堆疊  \n\n// -------- push 方法 --------  \n→ Step 2: 定義 push(x) // 進行進隊操作  \n→   → Step 3: 將 x 推入 stack_in // 直接把新元素放到進堆疊頂部  \n\n// -------- pop 方法 --------  \n→ Step 4: 定義 pop() // 進行出隊操作  \n→   → Decision: 若 stack_out 為空? // 需要先把前面的元素移到出堆疊  \n        Yes → Step 5: 重複直到 stack_in 為空: pop stack_in → push 到 stack_out // 將所有進堆疊的元素反轉順序放入出堆疊  \n        No  → No operation // 若 stack_out 已有元素，跳過轉移  \n→   → Step 6: 從 stack_out 彈出頂部元素並返回 // 這即為隊列前端元素  \n\n// -------- peek 方法 --------  \n→ Step 7: 定義 peek() // 取得前端元素但不移除  \n→   → Decision: 若 stack_out 為空? // 同樣需要將元素搬到出堆疊  \n        Yes → Step 8: 重複直到 stack_in 為空: pop stack_in → push 到 stack_out // 轉移  \n        No  → No operation // 已有元素，保持不變  \n→   → Step 9: 取 stack_out 頂部元素但不彈出並返回 // 取得前端值  \n\n// -------- empty 方法 --------  \n→ Step 10: 定義 empty() // 檢查隊列是否為空  \n→   → Decision: 若 stack_in 與 stack_out 均為空?  \n        Yes → Step 11: 回傳 true // 隊列空  \n        No  → Step 12: 回傳 false // 隊列非空  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyQueue:\n    def __init__(self):\n        # 兩個堆疊，stack_in 儲存進隊的元素，stack_out 儲存即將出隊的元素\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        # 直接將新元素推到進堆疊\n        self.stack_in.append(x)\n\n    def pop(self):\n        # 若 stack_out 為空，先把所有 stack_in 的元素轉移過來\n        self.peek()\n        # 從 stack_out 彈出最先進隊的元素\n        return self.stack_out.pop()\n\n    def peek(self):\n        # 若 stack_out 為空，將 stack_in 的元素全部轉移至 stack_out\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        # stack_out 的頂部即為隊列前端元素\n        return self.stack_out[-1]\n\n    def empty(self):\n        # 當兩個堆疊皆空時，隊列為空\n        return not self.stack_in and not self.stack_out\n\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入，除去可能存在的 'Input' 標頭\n    raw_input = sys.stdin.read().strip().splitlines()\n    if raw_input and raw_input[0].strip().startswith(\"Input\"):\n        raw_input = raw_input[1:]\n\n    # 解析操作名稱與參數\n    ops = ast.literal_eval(raw_input[0].strip())\n    args = ast.literal_eval(raw_input[1].strip())\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyQueue\":\n            obj = MyQueue()\n            results.append(None)\n        elif op == \"push\":\n            obj.push(arg)\n            results.append(None)\n        elif op == \"pop\":\n            results.append(obj.pop())\n        elif op == \"peek\":\n            results.append(obj.peek())\n        elif op == \"empty\":\n            results.append(obj.empty())\n\n    # 輸出結果，使用 json.dumps 可將 None 轉為 null，True/False 轉為 true/false\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,1,false]'\nGot (Norm):      '[null,null,null,[1],[1],false]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, 1, false]'\nRaw Got:      '[null, null, null, [1], [1], false]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode718.json",
    "problem_index_in_file": 0,
    "title": "Maximum Length of Repeated Subarray",
    "description_snippet": "Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in bo...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for longest common subarray between two integer arrays. This is classic problem: longest common subarray (or substring) between two arrays. Can use binary search + hashing (rolling hash) or DP. We need step-by-step virtual code with explanation.\n\nWe need to use arrows etc. Each line: \"虛擬碼步驟 // 解釋\". Should produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 variables // etc\n\nWe'll need to present algorithm: maybe binary search length L from 0 to min(len1, len2), for each L check if any subarray of length L exists in both using rolling hash. So we produce virtual code accordingly.\n\nThus produce lines for:\n\nStart\n→ Step 1: 定義 n1, n2\n→ Step 2: 定義低高\n→ Decision: 低 <= 高? etc.\n\nBut we need each line with explanation. We'll produce around 30 lines.\n\nImportant: no actual code, only virtual steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 取得 nums1 與 nums2 的長度 n1, n2 // 取得兩個陣列長度\n→ Step 2: 設定 low = 0, high = min(n1, n2) // 搜尋範圍\n→ Decision: low <= high? // 判斷是否還有可搜尋的長度\n    Yes → Step 3: mid = (low + high) // 2 // 取中間長度作為檢查目標\n    → Step 4: 建立 set hashSet // 用於儲存 nums1 的子陣列 hash\n    → Step 5: 以 Rolling Hash 方式計算 nums1 前 mid 個元素的 hash // 初始化 hash\n    → Step 6: 將 hash 加入 hashSet // 存進 set\n    → Step 7: 迭代 i from 1 to n1 - mid // 逐步滑動窗口\n        → Step 8: 更新 hash 為移除 nums1[i-1] 加上 nums1[i+mid-1] // 滑動更新\n        → Step 9: 加入 hashSet // 將新的 hash 存入\n    → Step 10: 以相同方式計算 nums2 的 hash 並檢查是否存在於 hashSet // 檢查匹配\n        → Step 11: 若找到匹配，則 exists = true // 找到相同長度子陣列\n        → Step 12: 否則 continue // 沒找到，繼續檢查\n    → Decision: exists? // 是否找到匹配\n        Yes → Step 13: low = mid + 1 // 仍可嘗試更長，向上調整搜尋範圍\n        No  → Step 14: high = mid - 1 // 找不到，縮小搜尋範圍\n    → Step 15: 重複 Decision: low <= high? // 迴圈繼續\n→ Step 16: 回傳 high // high 為最大可行長度\nEnd // 程式執行結束\n\nBut we need each line with explanation comment. Provide arrow. For decisions include indentation.\n\nWe also need to include binary search loop properly.\n\nLet's produce the final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得 nums1 與 nums2 的長度 n1, n2 // 取得兩個陣列長度\n→ Step 2: 設定 low = 0, high = min(n1, n2) // 搜尋可行子陣列長度範圍\n→ Decision: low <= high? // 是否還有長度可嘗試\n    Yes → Step 3: mid = (low + high) // 2 // 取中間長度作為檢查目標\n    → Step 4: 初始化 hashSet = empty set // 用於儲存 nums1 的子陣列 hash\n    → Step 5: 若 mid == 0, 設定 exists = true // 零長度始終存在\n    → Step 6: 否則\n        → Step 7: 計算 nums1 前 mid 個元素的 Rolling Hash // 初始 hash\n        → Step 8: 將 hash 加入 hashSet // 存進 set\n        → Step 9: 迭代 i 從 1 到 n1 - mid\n            → Step 10: 更新 hash 為移除 nums1[i-1] 加上 nums1[i+mid-1] // 滑動窗口更新\n            → Step 11: 將新的 hash 加入 hashSet // 存入 set\n        → Step 12: 計算 nums2 的子陣列 Rolling Hash 並檢查 hashSet\n            → Step 13: 若遇到 hash 存在於 hashSet，則 exists = true // 找到匹配\n            → Step 14: 否則 exists = false // 未找到匹配\n    → Decision: exists? // 是否在兩個陣列中找到長度為 mid 的子陣列\n        Yes → Step 15: low = mid + 1 // 可能還有更長的可行長度，往上調整\n        No  → Step 16: high = mid - 1 // 找不到，往下縮小搜尋範圍\n    → Step 17: 迴圈回到 Decision: low <= high? // 繼續二分搜尋\n→ Step 18: 回傳 high // high 為最大可行子陣列長度\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findLength(self, nums1, nums2):\n        m, n = len(nums1), len(nums2)\n        # 使用一維 dp 儲存上一行的資訊，減少空間\n        dp_prev = [0] * (n + 1)\n        max_len = 0\n        for i in range(1, m + 1):\n            dp_cur = [0] * (n + 1)\n            for j in range(1, n + 1):\n                if nums1[i - 1] == nums2[j - 1]:\n                    dp_cur[j] = dp_prev[j - 1] + 1\n                    if dp_cur[j] > max_len:\n                        max_len = dp_cur[j]\n            dp_prev = dp_cur\n        return max_len\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 從輸入中找出兩個列表字串\n    list_strings = re.findall(r'\\[.*?\\]', data)\n    if len(list_strings) < 2:\n        print(0)\n        sys.exit()\n    nums1 = ast.literal_eval(list_strings[0])\n    nums2 = ast.literal_eval(list_strings[1])\n\n    solution = Solution()\n    result = solution.findLength(nums1, nums2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode493.json",
    "problem_index_in_file": 0,
    "title": "Reverse Pairs",
    "description_snippet": "Given an integer array nums, return the number of reverse pairs in the array.\n\nA reverse pair is a p...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting reverse pairs in array. Classic solution uses merge sort or BIT. Provide steps: input array, handle empty, define recursive function merge_sort returns count. Steps: divide, count left, count right, count cross via two pointers, merge. Provide virtual code lines with explanations.\n\nWe need to output line by line, each line \"虛擬碼步驟 // 解釋\".\n\nLet's craft:\n\nStart\n→ Step 1: 接收輸入陣列 nums // 取得要處理的整數陣列\n→ Decision: 如果 nums 為空? // 檢查是否為空陣列\n    Yes → Step 2: 回傳 0 // 空陣列無反轉對\n    No → Step 3: 呼叫 MergeSort(nums, 0, nums.length-1) // 進行分治\n→ Step 4: 回傳結果 // 結果為總反轉對數\n\nDefine MergeSort(subarray, left, right):\n    Start\n    → Decision: 如果 left >= right? // 基礎情況\n        Yes → Step: 回傳 0 // 單元素無對\n        No → Step: mid = (left+right)/2 // 找中點\n        → Step: leftCount = MergeSort(nums, left, mid) // 左半部分\n        → Step: rightCount = MergeSort(nums, mid+1, right) // 右半部分\n        → Step: crossCount = CountCross(nums, left, mid, right) // 計算跨越對\n        → Step: Merge(nums, left, mid, right) // 合併兩個已排序的子陣列\n        → Step: 回傳 leftCount + rightCount + crossCount // 返回總數\n    End\n\nDefine CountCross(nums, left, mid, right):\n    Start\n    → Step: count = 0\n    → Step: j = mid + 1\n    → Step: for i from left to mid:\n        → Decision: 如果 nums[i] > 2 * nums[j]? // 判斷是否為反轉對\n            Yes → j++ // 移動 j，繼續尋找符合條件的\n            No  → count += j - (mid + 1) // 所有符合 j 的索引形成反轉對\n    → Step: 回傳 count\n    End\n\nDefine Merge(nums, left, mid, right):\n    Start\n    → Step: temp = 空列表 // 暫存合併結果\n    → Step: i = left, j = mid + 1\n    → Step: while i <= mid and j <= right:\n        → Decision: 如果 nums[i] <= nums[j]? // 小元素放進 temp\n            Yes → temp.append(nums[i]); i++\n            No  → temp.append(nums[j]); j++\n    → Step: while i <= mid: temp.append(nums[i]); i++\n    → Step: while j <= right: temp.append(nums[j]); j++\n    → Step: for k in range(left, right+1): nums[k] = temp[k-left] // 回寫到原陣列\n    End\n\nBut we need each line with // after a space. Let's produce final. Ensure arrows as specified: Use `→` at start of each step line except Start/End lines. Use `Yes →` and `No →`. Use `Decision:` lines.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入陣列 nums // 取得要處理的整數陣列  \n→ Decision: nums 是否為空? // 檢查陣列是否為空  \n  Yes → Step 2: 回傳 0 // 空陣列沒有反轉對  \n  No  → Step 3: 計算反轉對 = MergeSort(nums, 0, nums.length-1) // 進行分治排序與計算  \n→ Step 4: 回傳 計算反轉對 // 將總數輸出  \nEnd // 程式結束  \n\n// ------------------------------------  \n// MergeSort 函式：分治並計算反轉對  \n// ------------------------------------  \nStart // MergeSort 開始  \n→ Decision: left >= right? // 基礎情況：單個元素  \n  Yes → Step: 回傳 0 // 沒有反轉對  \n  No  → Step: mid = (left + right) / 2 // 找中點  \n    → Step: leftCount = MergeSort(nums, left, mid) // 左半部分  \n    → Step: rightCount = MergeSort(nums, mid+1, right) // 右半部分  \n    → Step: crossCount = CountCross(nums, left, mid, right) // 跨越對  \n    → Step: Merge(nums, left, mid, right) // 合併兩個已排序子陣列  \n    → Step: 回傳 leftCount + rightCount + crossCount // 返回總數  \nEnd // MergeSort 結束  \n\n// ------------------------------------  \n// CountCross 函式：計算跨越左右子陣列的反轉對  \n// ------------------------------------  \nStart // CountCross 開始  \n→ Step: count = 0 // 初始化計數  \n→ Step: j = mid + 1 // j 從右半陣列起始位置  \n→ Step: for i in range(left, mid+1): // 逐個左半元素  \n  → Decision: nums[i] > 2 * nums[j]? // 判斷是否為反轉對  \n    Yes → Step: j += 1 // 移動 j，尋找下一個可能的 j  \n    No  → Step: count += j - (mid + 1) // 所有符合 j 的索引都形成反轉對  \n→ Step: 回傳 count // 返回跨越對數量  \nEnd // CountCross 結束  \n\n// ------------------------------------  \n// Merge 函式：合併兩個已排序子陣列  \n// ------------------------------------  \nStart // Merge 開始  \n→ Step: temp = [] // 暫存合併結果  \n→ Step: i = left; j = mid + 1 // 初始化兩個指標  \n→ Step: while i <= mid and j <= right: // 兩個子陣列尚未完全遍歷  \n  → Decision: nums[i] <= nums[j]? // 選取較小元素  \n    Yes → Step: temp.append(nums[i]); i += 1 // 放入 temp  \n    No  → Step: temp.append(nums[j]); j += 1 // 放入 temp  \n→ Step: while i <= mid: temp.append(nums[i]); i += 1 // 左半剩餘元素  \n→ Step: while j <= right: temp.append(nums[j]); j += 1 // 右半剩餘元素  \n→ Step: for k in range(left, right + 1): nums[k] = temp[k - left] // 回寫到原陣列  \nEnd // Merge 結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reversePairs(self, nums):\n        \"\"\"\n        Count the number of reverse pairs in the array using a modified merge sort.\n        A reverse pair is a pair (i, j) such that 0 <= i < j < len(nums) and nums[i] > 2 * nums[j].\n        \"\"\"\n        def merge_sort(start, end):\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            count = merge_sort(start, mid) + merge_sort(mid + 1, end)\n\n            # Count cross pairs\n            j = mid + 1\n            for i in range(start, mid + 1):\n                while j <= end and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - (mid + 1)\n\n            # Merge the two sorted halves\n            temp = []\n            left, right = start, mid + 1\n            while left <= mid and right <= end:\n                if nums[left] <= nums[right]:\n                    temp.append(nums[left])\n                    left += 1\n                else:\n                    temp.append(nums[right])\n                    right += 1\n            while left <= mid:\n                temp.append(nums[left])\n                left += 1\n            while right <= end:\n                temp.append(nums[right])\n                right += 1\n            nums[start:end + 1] = temp\n            return count\n\n        return merge_sort(0, len(nums) - 1)\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read()\n    # Extract all integers from the input string\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    # Compute the number of reverse pairs\n    result = Solution().reversePairs(nums)\n    # Output the result\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,4,3,5,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode443.json",
    "problem_index_in_file": 0,
    "title": "String Compression",
    "description_snippet": "Given an array of characters chars, compress it using the following algorithm:\n\nBegin with an empty ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for array compression with constant space. Provide each line with explanation. Use Start, End, Decision, etc.\n\nWe'll produce algorithm in generic pseudocode. Steps: count groups, write compressed characters at writeIndex, readIndex traverse array. At end return writeIndex.\n\nWe need to output per line: \"Start // 程式開始執行\", etc.\n\nLet's craft.\n\nLines:\n\nStart // 程式開始執行\n→ Variable write = 0 // 指標寫入位置\n→ Variable read = 0 // 指標讀取位置\n→ Variable n = chars.length // 原陣列長度\n→ While read < n: // 逐個處理字符\n    → Variable current = chars[read] // 當前字符\n    → Variable count = 0 // 重複次數\n    → While read < n and chars[read] == current: // 計算連續重複數\n        → count = count + 1\n        → read = read + 1\n    → chars[write] = current // 寫入字符\n    → write = write + 1\n    → If count > 1: // 需要寫入長度\n        → Variable digits = digits_of(count) // 將數字轉為字元陣列\n        → For each d in digits:\n            → chars[write] = d\n            → write = write + 1\n→ End // 程式執行結束\n→ Return write // 新長度\n\nBut we need to use only constant space; digits_of(count) can be obtained by converting to string and iterating. But that uses extra space? Converting to string uses memory but it's O(1) per digit? In theory we can convert by using division. But fine.\n\nLet's produce pseudocode with Decision: If count > 1 etc.\n\nAlso we need to show Decision structure: Decision: if count > 1? Yes → etc.\n\nOk.\n\nWe also must keep lines separate with comments.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ write = 0 // 寫入指標\n→ read = 0 // 讀取指標\n→ n = chars.length // 原陣列長度\n→ While read < n: // 迭代整個陣列\n    → current = chars[read] // 取得當前字符\n    → count = 0 // 初始化重複計數\n    → While read < n and chars[read] == current: // 計算連續相同字符數\n        → count = count + 1\n        → read = read + 1\n    → chars[write] = current // 寫入字符\n    → write = write + 1\n    → Decision: count > 1? // 判斷是否需要寫入長度\n        Yes → Variable temp = count // 將計數儲存\n            → While temp > 0: // 把數字拆成單個字符寫入\n                → digit = temp % 10\n                → chars[write] = char(digit + '0') // 將數字轉為字符\n                → write = write + 1\n                → temp = temp / 10\n            → Reverse the digits written? Wait we wrote LSB first; need reverse. Actually easier: convert to string; but we can accumulate digits into array then reverse. Since constant space, we can use stack? We'll just convert to string and iterate. But we can do simpler: use temporary string digits = \"\" ; digits = digits + char(digit + '0'); but that uses string concat, but still constant? Ok.\n\nSimpler: use string conversion.\n\n    Yes → digits = toString(count) // 將計數轉為字串\n        → For i from 0 to digits.length-1:\n            → chars[write] = digits[i]\n            → write = write + 1\n        End For\n        No → // count == 1, do nothing\n→ End While\n→ End // 程式執行結束\n→ Return write // 新陣列長度\n\nBut we used toString. Provide explanation.\n\nLet's format properly.\n\nNeed to use proper indentation. Each line as separate.\n\nWe'll incorporate Decision lines as per format:\n\nDecision: count > 1? // 判斷是否需要寫入長度\n    Yes → ... \n    No  → ... \n\nWe need to be careful with indentation: each line with \"→\" arrow at start? Example from spec: \"→ Step 1: ...\" They used \"→\" before each step inside Start. Indentation indicates nested? They had \"→ Decision: ...\" then nested lines with indentation. We'll follow that.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ write = 0 // 寫入指標（新位置）  \n→ read = 0 // 讀取指標（遍歷原陣列）  \n→ n = chars.length // 原陣列長度  \n→ While read < n: // 逐個處理陣列中的字符  \n  → current = chars[read] // 取得當前字符  \n  → count = 0 // 初始化此字符的連續次數  \n  → While read < n and chars[read] == current: // 計算連續相同字符的個數  \n    → count = count + 1  \n    → read = read + 1  \n  → chars[write] = current // 把字符寫回陣列  \n  → write = write + 1  \n  → Decision: count > 1? // 是否需要把長度寫進去？  \n    Yes → digits = toString(count) // 把計數轉成字串  \n      → For i = 0 to digits.length - 1: // 將每個數字字元寫入  \n        → chars[write] = digits[i]  \n        → write = write + 1  \n       End For  \n    No → // count 為 1，直接跳過  \n→ End While  \nEnd // 程式執行結束  \n→ Return write // 返回壓縮後陣列的新長度",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def compress(self, chars):\n        write = 0\n        left = 0\n        n = len(chars)\n        \n        while left < n:\n            right = left\n            while right < n and chars[right] == chars[left]:\n                right += 1\n            chars[write] = chars[left]\n            write += 1\n            count = right - left\n            if count > 1:\n                for c in str(count):\n                    chars[write] = c\n                    write += 1\n            left = right\n        \n        return write\n\ndef main():\n    data = sys.stdin.read()\n    # Locate the first '[' and the last ']' to extract the list\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        return\n    array_str = data[start:end+1]\n    try:\n        chars = ast.literal_eval(array_str)\n    except Exception:\n        chars = []\n    sol = Solution()\n    new_len = sol.compress(chars)\n    print(new_len)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "chars = [\"a\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode674.json",
    "problem_index_in_file": 0,
    "title": "Longest Continuous Increasing Subsequence",
    "description_snippet": "Given an unsorted array of integers nums, return the length of the longest continuous increasing sub...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines, each with explanation, following format:\n\nStart // 程式開始執行\n→ Step 1: ... // Explanation\n→ Decision: ... // Explanation\n    Yes → Step ...\n    No  → ...\n\nWe need to solve: given unsorted array nums, find length of longest continuous increasing subarray. Approach: iterate, keep current length, update max. Complexity O(n). Pseudocode:\n\nStart\n→ Step 1: 初始化 maxLen = 1, currentLen = 1 // handle at least one element\n→ Decision: 是否陣列長度為 0? // empty array\n    Yes → Step 2: return 0 // nothing to process\n    No  → ...\n→ Step 3: 從 i = 1 到 nums.length - 1\n    → Decision: 如果 nums[i] > nums[i-1]?\n        Yes → Step 4: currentLen = currentLen + 1\n        No  → Step 5: currentLen = 1\n    → Decision: currentLen > maxLen?\n        Yes → Step 6: maxLen = currentLen\n→ Step 7: return maxLen\n\nNeed to format lines properly with arrows and indentation. Use Start, End. Use \"→\" for each step and \"Decision:\" with Yes/No branches. Provide each line with // explanation. For branches, each line should be separate.\n\nWe need to ensure \"逐行輸出\" each line.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 初始化 maxLen = 1, currentLen = 1 // 設定初始最大長度和目前連續長度\n→ Decision: 如果 nums 的長度為 0?\n    Yes → Step 2: return 0 // 空陣列直接回傳 0\n    No  → \n→ Step 3: 從 i = 1 迭代到 nums.length - 1\n    → Decision: 如果 nums[i] > nums[i-1]?\n        Yes → Step 4: currentLen = currentLen + 1 // 連續遞增，長度加一\n        No  → Step 5: currentLen = 1 // 不遞增，重新開始計算\n    → Decision: currentLen > maxLen?\n        Yes → Step 6: maxLen = currentLen // 更新最大長度\n→ Step 7: return maxLen // 回傳最長連續遞增子陣列長度\nEnd // 程式執行結束\n\nBut note we need each line separate; for branches we need separate lines.\n\nLet's separate branch lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 maxLen = 1, currentLen = 1 // 設定初始最大長度和目前連續長度\n→ Decision: 如果 nums 的長度為 0?\n    Yes → Step 2: return 0 // 空陣列直接回傳 0\n    No  →\n→ Step 3: 從 i = 1 迭代到 nums.length - 1\n    → Decision: 如果 nums[i] > nums[i-1]?\n        Yes → Step 4: currentLen = currentLen + 1 // 連續遞增，長度加一\n        No  → Step 5: currentLen = 1 // 不遞增，重新開始計算\n    → Decision: currentLen > maxLen?\n        Yes → Step 6: maxLen = currentLen // 更新最大長度\n→ Step 7: return maxLen // 回傳最長連續遞增子陣列長度\nEnd // 程式執行結束\n\nBut we have \"→ Step 3:\" and then nested decisions; we need to indent lines for clarity. Use spaces.\n\nAlso \"Decision:\" lines are separate. The \"No →\" with nothing should have next line? Might be \"No →\" followed by nothing? The sample shows No → Decision: ... So \"No → Decision:\" is okay. But in this case we don't have a step after No; we just skip.\n\nMaybe we can adjust: The No branch for empty array just proceed; we don't need a step. So we can have:\n\n→ Decision: 如果 nums 的長度為 0?\n    Yes → Step 2: return 0 // 空陣列直接回傳 0\n    No  → // 不是空陣列，繼續執行\n\nBut the format expects lines. We can include \"No  → // 不是空陣列，繼續執行\". That might satisfy.\n\nLet's produce final pseudocode with proper indentation and lines.\n\nAlso include End.\n\nMake sure each line has \"虛擬碼步驟\" and explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 maxLen = 1, currentLen = 1 // 設定初始最大長度和目前連續長度  \n→ Decision: 如果 nums 的長度為 0?  \n    Yes → Step 2: return 0 // 空陣列直接回傳 0  \n    No  → // 不是空陣列，繼續執行  \n→ Step 3: 從 i = 1 迭代到 nums.length - 1  \n    → Decision: 如果 nums[i] > nums[i-1]?  \n        Yes → Step 4: currentLen = currentLen + 1 // 連續遞增，長度加一  \n        No  → Step 5: currentLen = 1 // 不遞增，重新開始計算  \n    → Decision: currentLen > maxLen?  \n        Yes → Step 6: maxLen = currentLen // 更新最大長度  \n→ Step 7: return maxLen // 回傳最長連續遞增子陣列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLengthOfLCIS(self, nums):\n        if not nums:\n            return 0\n        max_len = 1\n        cur_len = 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                cur_len += 1\n                if cur_len > max_len:\n                    max_len = cur_len\n            else:\n                cur_len = 1\n        return max_len\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 找出 '[' 與 ']' 之間的字串並解析成列表\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        nums = []\n    else:\n        nums_str = data[start:end+1]\n        nums = ast.literal_eval(nums_str)\n    solution = Solution()\n    result = solution.findLengthOfLCIS(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,4,7]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode541.json",
    "problem_index_in_file": 0,
    "title": "Reverse String II",
    "description_snippet": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Use Start, End, Decision. Should handle loop over string in increments of 2k. For each segment, determine length. Then reverse first k if enough. If less than k, reverse all. If between k and 2k, reverse first k, leave rest. We'll produce line-by-line.\n\nProbably steps:\n\nStart\n→ Initialize result string builder\n→ Set i=0\n→ While i < length(s):\n    → Decision: remaining_len = len(s)-i // Check remaining length\n        Yes (remaining_len > 0)\n    → Determine segment_len = min(2k, remaining_len)\n    → Determine to_reverse_len = min(k, segment_len)\n    → Take segment = s[i:i+segment_len]\n    → Reverse first to_reverse_len chars of segment\n    → Append reversed part + remaining part (if any)\n    → Update i += segment_len\n→ End\n\nBut need more detailed decisions. Use Decision nodes.\n\nLet's craft virtual steps:\n\nStart // 程式開始\n→ Step 1: 設定 i = 0 // 初始化索引\n→ Step 2: 設定 result = 空字串 // 用於儲存結果\n→ Decision: i < len(s) ? // 是否還有未處理的字元\n    Yes → Step 3: 計算 remaining = len(s) - i // 剩餘字元數\n    → Step 4: segment_len = min(2k, remaining) // 本次段長\n    → Step 5: to_reverse = min(k, segment_len) // 需要反轉的長度\n    → Step 6: segment = s[i : i + segment_len] // 取出段\n    → Step 7: reversed_part = reverse(segment[0 : to_reverse]) // 反轉前段\n    → Step 8: unchanged_part = segment[to_reverse : ] // 未變更部分\n    → Step 9: result += reversed_part + unchanged_part // 合併到結果\n    → Step 10: i += segment_len // 移動索引\n    → No → Step 11: 輸出 result // 程式結束\nEnd // 程式結束\n\nBut need to ensure arrow syntax: Use \"→\" for steps, \"Decision:\" lines with Yes →, No →.\n\nAlso after \"Decision: i < len(s) ?\" we need two branches. But we want loop; we can represent with loop via repeated decision.\n\nBetter:\n\nStart\n→ Step 1: i = 0\n→ Step 2: result = \"\"\n→ Decision: i < len(s) ?\n    Yes → Step 3: remaining = len(s) - i\n    → Step 4: segment_len = min(2k, remaining)\n    → Step 5: to_reverse = min(k, segment_len)\n    → Step 6: segment = s[i : i + segment_len]\n    → Step 7: reversed_part = reverse(segment[0 : to_reverse])\n    → Step 8: unchanged_part = segment[to_reverse :]\n    → Step 9: result += reversed_part + unchanged_part\n    → Step 10: i += segment_len\n    → Decision: i < len(s) ? (loop back)\n        Yes → (go back to Step 3)  // Could indicate loop\n        No → Step 11: output result\n    No → Step 11: output result\nEnd\n\nBut we need to be concise. Use \"Decision: i < len(s) ?\" at top; inside branch Yes we go through steps then go back to Decision; after No we output.\n\nWe need to output virtual code line by line, each line with a comment.\n\nWe must not output real code. Use pseudocode.\n\nLet's produce final answer accordingly. Ensure each line ends with comment.\n\nLet's craft final output:\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i = 0 // 初始化索引  \n→ Step 2: result = \"\" // 用於累積結果字串  \n→ Decision: i < len(s) ? // 判斷是否還有未處理的字元  \n    Yes → Step 3: remaining = len(s) - i // 計算剩餘字元數  \n    → Step 4: segment_len = min(2k, remaining) // 本次 2k 段的實際長度  \n    → Step 5: to_reverse = min(k, segment_len) // 需要反轉的子長度  \n    → Step 6: segment = s[i : i + segment_len] // 取得本段子字串  \n    → Step 7: reversed_part = reverse(segment[0 : to_reverse]) // 反轉前 k 個（或全部）  \n    → Step 8: unchanged_part = segment[to_reverse : ] // 未變更的剩餘部分  \n    → Step 9: result += reversed_part + unchanged_part // 合併到結果  \n    → Step 10: i += segment_len // 移動到下一個 2k 段的起點  \n    → Decision: i < len(s) ? // 重新檢查是否還有字元  \n        Yes → (loop back to Step 3) // 進入下一輪循環  \n        No  → Step 11: output result // 沒有剩餘字元，輸出結果  \n    No → Step 11: output result // 初始就無字元，直接輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef reverse_str(s: str, k: int) -> str:\n    \"\"\"Reverse the first k characters for every 2k characters in the string.\"\"\"\n    chars = list(s)\n    for i in range(0, len(chars), 2 * k):\n        # Determine how many characters we can actually reverse\n        end = min(i + k, len(chars))\n        chars[i:end] = reversed(chars[i:end])\n    return \"\".join(chars)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Parse input like: '\"abcdefg\", 2'\n    try:\n        s, k = ast.literal_eval(data)\n    except Exception:\n        # Fallback: assume separate lines\n        parts = data.splitlines()\n        s = parts[0].strip().strip('\"')\n        k = int(parts[1].strip())\n    result = reverse_str(s, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abcdefg\", 2",
          "expected_output": "\"bacdfeg\"",
          "success": true,
          "output": "bacdfeg"
        },
        {
          "example_index": 1,
          "input": "\"abcd\", 2",
          "expected_output": "\"bacd\"",
          "success": true,
          "output": "bacd"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode188.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock IV",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm to find max profit with at most k transactions on stock prices array. Should be described step by step. We need to use virtual code with arrows, decision, etc. Provide each line as \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Steps: input, initialization of DP arrays, nested loops, update. Provide explanation.\n\nWe need to produce step-by-step pseudo-code, not actual code. Should be line by line.\n\nOk produce:\n\nStart\n→ Step 1: 取得 prices 陣列與 k 整數 // Input\n→ Decision: 若 k >= len(prices)/2? // If k large enough treat as unlimited\n   Yes → Step 2: 計算每日增值總和 // Unlimited transaction: sum positive diffs\n   No → Step 3: 初始化 DP arrays 交易次數 0..k, holding state 0/1 // DP\n   → Step 4: 設定 dp[0][0] = 0; dp[0][1] = -prices[0]\n   → Loop: for day from 1 to len(prices)-1\n        → Step 5: 更新不持股狀態：dp[t][0] = max(dp[t][0], dp[t][1] + prices[day]) // Sell\n        → Step 6: 更新持股狀態：dp[t][1] = max(dp[t][1], dp[t-1][0] - prices[day]) // Buy\n   → End Loop\n   → Step 7: 回傳 dp[k][0] // max profit\n\nEnd\n\nAdd explanations.\n\nWe need each line of virtual code with // explanation.\n\nMake sure to include indentation for nested decisions.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得 prices 陣列與 k 整數 // 讀取輸入\n→ Decision: 若 k ≥ len(prices)/2? // 判斷是否可以視為無限交易\n    Yes → Step 2: 計算每日價格差總和 >0 的部分 // 無限交易情況下直接相加正增幅\n        → Step 3: 回傳 Step 2 計算結果 // 結束\n    No → Step 4: 初始化 2D DP 陣列 dp[k+1][2] // k+1 行，兩列表示持有與不持有\n→ Step 5: 設定 dp[0][0] = 0 // 無交易且不持股的利潤為 0\n→ Step 6: 設定 dp[0][1] = -prices[0] // 只有一次買入，利潤為負價格\n→ Step 7: 迴圈 day 迴圈從 1 到 len(prices)-1 // 遍歷所有交易日\n    → Decision: 若 day > 0? // 進入日常更新\n        Yes →\n            → Step 8: 迭代交易次數 t 從 1 到 k\n                → Step 9: 更新不持股狀態：dp[t][0] = max(dp[t][0], dp[t][1] + prices[day]) // 卖出\n                → Step 10: 更新持股狀態：dp[t][1] = max(dp[t][1], dp[t-1][0] - prices[day]) // 买入\n→ End // 迴圈結束\n→ Step 11: 回傳 dp[k][0] // 最大利潤為第 k 次交易後不持股的利潤\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProfit(self, k, prices):\n        n = len(prices)\n        if n == 0:\n            return 0\n        # If k is large enough, it's equivalent to unlimited transactions\n        if k >= n // 2:\n            profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i - 1]:\n                    profit += prices[i] - prices[i - 1]\n            return profit\n\n        # DP: dp[t][d] = max profit using at most t transactions up to day d\n        dp = [[0] * n for _ in range(k + 1)]\n        for t in range(1, k + 1):\n            # max_diff holds the best value of dp[t-1][d] - prices[d]\n            max_diff = -prices[0]\n            for d in range(1, n):\n                # either do nothing (dp[t][d-1]) or sell today at price[d]\n                dp[t][d] = max(dp[t][d - 1], prices[d] + max_diff)\n                # update max_diff for the next day: consider buying today\n                max_diff = max(max_diff, dp[t - 1][d] - prices[d])\n        return dp[k][n - 1]\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input that may be in the form:\n        k = 2, prices = [2,4,1]\n    or just numbers:\n        2\n        2 4 1\n    Returns (k, prices list).\n    \"\"\"\n    data = data.strip()\n    # Try regex extraction\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    prices_match = re.search(r'prices\\s*=\\s*\\[([^\\]]*)\\]', data)\n    if k_match and prices_match:\n        k = int(k_match.group(1))\n        prices_str = prices_match.group(1)\n        prices = [int(x) for x in prices_str.split(',') if x.strip()]\n        return k, prices\n\n    # Fallback: extract all integers, first is k\n    nums = [int(x) for x in re.findall(r'-?\\d+', data)]\n    if not nums:\n        return 0, []\n    k = nums[0]\n    prices = nums[1:]\n    return k, prices\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    k, prices = parse_input(raw_input)\n    sol = Solution()\n    result = sol.maxProfit(k, prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, prices = [2,4,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "k = 2, prices = [3,2,6,5,0,3]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode522.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence II",
    "description_snippet": "Given an array of strings strs, return the length of the longest uncommon subsequence between them. ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem, in Traditional Chinese, following the format. No actual code. Need to reason about algorithm: longest uncommon subsequence in array of strings.\n\nObservation: If any string is unique among array, answer is length of that string. Else, if all strings equal, no uncommon subsequence exists -> -1. Because any subsequence of a string is also a subsequence of identical string. So algorithm: count frequency of each string. For each string in array, if its frequency is 1, return its length (max). If none unique, return -1.\n\nNeed to handle multiple unique lengths, choose max. Steps: Start; read input array; compute frequency map; initialize maxLen = -1; iterate through array: if freq[str]==1 and len>maxLen => update; end loop; output maxLen. End.\n\nWe need to use virtual code lines with arrows. We'll include Start, Step 1, Step 2, etc. Use Decision for checking uniqueness. Provide explanation comments.\n\nLet's produce step-by-step.\n\nWe need to adhere to format: each line \"虛擬碼步驟 // 解釋\". Use arrows like \"→ Step 1:\".\n\nWe need to show decisions: For each string: check if freq==1.\n\nLet's write:\n\nStart\n→ Step 1: 建立空字典 freq // 初始化字典用於統計每個字串出現次數\n→ Step 2: 對 strs 中每個字串 str 執行 freq[str]++ // 計算頻率\n→ Step 3: 初始化 maxLen ← -1 // 儲存最大長度，預設 -1 表示尚未找到\n→ Step 4: 對 strs 中每個字串 str 執行\n    → Decision: freq[str] == 1 ?\n        Yes → Step 5: 更新 maxLen ← max(maxLen, len(str)) // 若該字串唯一，更新最大長度\n        No  → Step 5a: 跳過 // 不是唯一，忽略\n→ End // 輸出 maxLen 作為結果\n\nBut we need arrow before each line and use arrow for inner decisions maybe indent. Format example shows indentation for decision branches. Use \"→ Decision:\" with indentation. Need to ensure each line has \"虛擬碼步驟\". Example shows \"→ Decision: 如果數字大於 0?\" then indent \"Yes → Step 2:\" etc.\n\nSo we should structure accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 freq // 初始化字典用於統計每個字串出現次數  \n→ Step 2: 對 strs 中每個字串 str 執行 freq[str]++ // 計算頻率  \n→ Step 3: 初始化 maxLen ← -1 // 儲存最大長度，預設 -1 表示尚未找到  \n→ Step 4: 對 strs 中每個字串 str 執行  \n    → Decision: freq[str] == 1? // 檢查該字串是否唯一  \n        Yes → Step 5: 更新 maxLen ← max(maxLen, len(str)) // 若唯一，更新最大長度  \n        No → Step 5a: 跳過 // 不是唯一，忽略該字串  \n→ End // 輸出 maxLen 作為結果，若仍為 -1 則表示不存在不常見子序列",
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\ndef find_lus_length(strs):\n    \"\"\"\n    依據題意求「最長不常見子序列」的長度。\n    1. 若某個字串在陣列中唯一，則它本身即為不常見子序列，長度即為答案。\n    2. 若所有字串均相同，則不存在不常見子序列，回傳 -1。\n    \"\"\"\n    freq = Counter(strs)          # 統計每個字串出現的次數\n    max_len = -1                  # 初始答案為 -1，表示尚未找到\n    for s in strs:\n        if freq[s] == 1:          # 只要遇到唯一字串，即可更新最大長度\n            max_len = max(max_len, len(s))\n    return max_len\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個資料，並去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(-1)\n    else:\n        # 解析 JSON 格式的字串陣列，例如 '[\"aba\",\"cdc\",\"eae\"]'\n        try:\n            strs = json.loads(raw_input)\n            if not isinstance(strs, list):\n                raise ValueError\n        except Exception:\n            # 若輸入不是合法的 JSON 陣列，則直接輸出 -1\n            print(-1)\n        else:\n            result = find_lus_length(strs)\n            print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"aba\",\"cdc\",\"eae\"]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode413.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices",
    "description_snippet": "An integer array is called arithmetic if it consists of at least three elements and if the differenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode. Problem: count number of arithmetic subarrays of at least length 3. We need to produce virtual code line by line with explanation. We should design algorithm: iterate through array, maintain current difference and length of consecutive arithmetic sequence. For each index, if diff same as previous, increase currentLen; else reset. For each index when currentLen>=3, increment count by currentLen-2. Classic solution.\n\nWe output steps: Start, input array, initialize count, initialize currentLen = 2 maybe? Actually we need to treat first two elements as start of sequence. We'll iterate from index 2 to n-1.\n\nLet's produce pseudocode lines.\n\nWe need to include arrow and decision structure. For each step we can write:\n\nStart // start\n→ Step 1: nums ← input array // get input\n→ Step 2: count ← 0 // initialize result\n→ Step 3: if length(nums) < 3 then return count // no subarray possible\n→ Step 4: currentDiff ← nums[1] - nums[0] // initial difference\n→ Step 5: currentLen ← 2 // current length of arithmetic run\n→ Step 6: for i from 2 to length(nums)-1 do // iterate over rest\n    → Decision: if nums[i] - nums[i-1] == currentDiff? // check if same diff\n        Yes →\n            → Step 7: currentLen ← currentLen + 1 // extend run\n            → Decision: if currentLen >= 3? // at least length 3\n                Yes →\n                    → Step 8: count ← count + (currentLen - 2) // add new subarrays ending at i\n                No → // nothing\n        No →\n            → Step 9: currentDiff ← nums[i] - nums[i-1] // new diff\n            → Step 10: currentLen ← 2 // reset run length to 2 (last two elements)\n→ End // output count\n\nBut need to handle when loop ends. Might need to return count after loop. Use step after loop: → Step 11: return count\n\nWe also need to handle empty array case.\n\nAlso we might need to consider that we need to maintain result after each iteration; the formula count += currentLen - 2 counts all new subarrays ending at i: each time you extend by one, new subarrays formed equals currentLen-2.\n\nLet's produce lines accordingly with explanations.\n\nAlso maybe include decision for array length <3 before loop.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums ← input array // 取得輸入的整數陣列  \n→ Step 2: count ← 0 // 用於累計所有符合條件的子陣列數量  \n→ Decision: 如果 length(nums) < 3? // 若陣列長度不足三個元素  \n  Yes → Step 3: return count // 直接回傳 0，因為不可能存在長度 ≥3 的子陣列  \n  No  → Step 4: currentDiff ← nums[1] - nums[0] // 計算第一個相鄰差值  \n     currentLen ← 2 // 目前已知的連續算術序列長度（前兩個元素）  \n→ Step 5: for i from 2 to length(nums)-1 do // 從第三個元素開始逐一檢查  \n  Decision: 如果 nums[i] - nums[i-1] == currentDiff? // 判斷是否繼續相同差值  \n    Yes →  \n     → Step 6: currentLen ← currentLen + 1 // 連續算術序列長度加一  \n     Decision: 如果 currentLen >= 3? // 是否已達到至少三個元素  \n       Yes →  \n        → Step 7: count ← count + (currentLen - 2) // 新增所有以 i 為結尾的算術子陣列  \n       No → // 連續序列尚未足夠長，無子陣列可計算  \n    No →  \n     → Step 8: currentDiff ← nums[i] - nums[i-1] // 重新設定差值  \n     → Step 9: currentLen ← 2 // 重置連續序列長度為兩個元素（i-1 與 i）  \n→ Step 10: return count // 輸出總計算得到的算術子陣列數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums):\n        n = len(nums)\n        if n < 3:\n            return 0\n\n        total = 0\n        curr = 0  # number of arithmetic slices ending at current position\n        for i in range(2, n):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                curr += 1\n                total += curr\n            else:\n                curr = 0\n        return total\n\ndef parse_input(input_str: str):\n    \"\"\"Parse the input string to extract the list of integers.\n    Supports formats like 'nums = [1, 2, 3]' or just '[1, 2, 3]'.\n    \"\"\"\n    input_str = input_str.strip()\n    if not input_str:\n        return []\n\n    # If the input contains an assignment, extract the RHS\n    if '=' in input_str:\n        _, rhs = input_str.split('=', 1)\n        input_str = rhs.strip()\n\n    # Use literal_eval to safely parse the list\n    try:\n        nums = ast.literal_eval(input_str)\n    except Exception:\n        # Fallback: try to evaluate the whole string\n        nums = eval(input_str)\n    # Ensure we have a list\n    if not isinstance(nums, list):\n        nums = [nums]\n    return nums\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.numberOfArithmeticSlices(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode345.json",
    "problem_index_in_file": 0,
    "title": "Reverse Vowels of a String",
    "description_snippet": "Given a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e',...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for reversing only vowels in string. Steps: two pointers i, j, while i<j. If s[i] not vowel, i++. If s[j] not vowel, j--. If both vowels, swap. Then return string. We'll produce step-by-step lines with explanation. Ensure format: Start, steps with arrows, Decision. Also use \"→\" arrow. Should use virtual code step labels like \"Step 1:\" etc. Each line: \"虛擬碼步驟 // 解釋\". Let's produce. Ensure no actual code. Use pseudocode. Use Start/End. Use Decision: If. Should maintain clarity. Use lowercase? It's virtual. Provide Chinese explanation. Use arrow. Use \"Yes →\" etc. We'll produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 i ← 0, j ← s.length - 1 // 初始化左右指標  \n→ Step 2: 定義 isVowel(ch)  // 判斷字符是否為元音  \n  Decision: ch 為 'a'、'e'、'i'、'o'、'u' 或其大寫?  \n   Yes → 返回 true  \n   No  → 返回 false  \n→ Decision: i < j? // 檢查左右指標是否已交叉  \n  Yes →  \n   Decision: isVowel(s[i])? // 左側是否為元音  \n    Yes →  \n     Decision: isVowel(s[j])? // 右側是否為元音  \n      Yes → Step 3: 交換 s[i] 與 s[j]；i++ ; j-- // 兩端都是元音，進行交換並移動指標  \n      No  → i++ // 右側不是元音，僅左指標前移  \n    No → j-- // 左側不是元音，僅右指標後移  \n  No  → Step 4: 返回 s // 左右指標已交叉，處理完畢  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def reverseVowels(self, s: str) -> str:\n        vowels = set('aeiouAEIOU')\n        chars = list(s)\n        left, right = 0, len(chars) - 1\n        while left < right:\n            while left < right and chars[left] not in vowels:\n                left += 1\n            while left < right and chars[right] not in vowels:\n                right -= 1\n            if left < right:\n                chars[left], chars[right] = chars[right], chars[left]\n                left += 1\n                right -= 1\n        return ''.join(chars)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n\n    # 尝试提取引号中的字符串\n    start = data.find('\"')\n    end = data.rfind('\"')\n    if start != -1 and end != -1 and end > start:\n        s = data[start + 1:end]\n    else:\n        # 如果没有引号，尝试解析类似 \"s = abc\" 的形式\n        if '=' in data:\n            s = data.split('=', 1)[1].strip()\n        else:\n            s = data\n\n    result = Solution().reverseVowels(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"IceCreAm\"",
          "expected_output": "\"AceCreIm\"",
          "success": true,
          "output": "AceCreIm"
        },
        {
          "example_index": 1,
          "input": "s = \"leetcode\"",
          "expected_output": "\"leotcede\"",
          "success": true,
          "output": "leotcede"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode464.json",
    "problem_index_in_file": 0,
    "title": "Can I Win",
    "description_snippet": "In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The p...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem \"100 game with no reuse\" essentially Leetcode 464. The algorithm: DFS with memo, bitmask to represent used numbers. Check if total >= desiredTotal then previous player wins; else iterate over unused numbers and try to pick one that leads to opponent losing. If none, return false. Complexity exponential but memo helps.\n\nWe need to output virtual code lines with explanations. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. Use indentation. Use bitmask represented as integer or string? We can just use integer bitmask. Provide pseudo steps: define function canWin(maxChoosableInteger, desiredTotal). Edge cases: sum of all numbers < desiredTotal -> return false. Also if desiredTotal <= maxChoosableInteger -> return true because first can choose that number. Then recursion.\n\nWe'll produce pseudo-code: Start // begin\n→ Step 1: 定義函式 canWin(max, target) // 主要函式\n→ Decision: 如果 (max*(max+1)/2 < target) // 可行性檢查\n    Yes → Return false // 目標無法達成\n    No → Continue\n→ Step 2: 初始化 memo map // 用於存放已計算狀態\n→ Step 3: 定義遞迴 DFS(usedMask, currentTotal) // 遞歸判斷\n→ Step 4: Decision: 如果 currentTotal >= target\n    Yes → Return false // 上一玩家已勝利，現在無法再行動\n    No → Continue\n→ Step 5: Decision: 如果 memo contains usedMask\n    Yes → Return memo[usedMask]\n    No → Continue\n→ Step 6: For i from 1 to max\n    → Decision: 如果 bit i 在 usedMask 為 0 (unused)\n        Yes → NewMask = usedMask | (1 << (i-1))\n        → NewTotal = currentTotal + i\n        → Decision: 如果 !DFS(NewMask, NewTotal)\n            Yes → memo[usedMask] = true; Return true // 找到贏的方法\n    End For\n→ Step 7: memo[usedMask] = false; Return false // 無法勝利\n→ End // 結束\n\nThen call DFS(0, 0) and return that.\n\nWe need to show step lines with arrow and explanation. Use Start, End, Decision.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義函式 canWin(maxChoosableInteger, desiredTotal) // 主入口函式\n→ Decision: 如果 maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal\n    Yes → Return false // 所有數字加總都不到目標，第一個玩家無法勝利\n    No → Continue // 目標可達，進行下一步\n→ Step 2: 初始化 memo map // 用來記錄已計算過的位掩碼結果，避免重複計算\n→ Step 3: 定義遞迴函式 DFS(usedMask, currentTotal) // usedMask 表示已被選取的數字，currentTotal 為目前總和\n→ Decision: 如果 currentTotal >= desiredTotal\n    Yes → Return false // 上一個動作已使總和達到或超過目標，現在無法再動，說明上一玩家已勝利\n    No → Continue\n→ Decision: 如果 memo 中存在 usedMask\n    Yes → Return memo[usedMask] // 直接回傳已知結果\n    No → Continue\n→ Step 4: For i from 1 to maxChoosableInteger\n    → Decision: 如果 (usedMask & (1 << (i-1))) == 0 // i 尚未被選取\n        Yes → NewMask = usedMask | (1 << (i-1)) // 標記 i 為已選取\n        → NewTotal = currentTotal + i // 更新總和\n        → Decision: 如果 !DFS(NewMask, NewTotal) // 若下一個玩家無法勝利\n            Yes → memo[usedMask] = true; Return true // 找到贏的方法，記錄並返回\n    End For\n→ Step 5: memo[usedMask] = false; Return false // 所有可選的 i 都無法贏，記錄並返回\n→ Step 6: Return DFS(0, 0) // 從空狀態開始遞迴，取得最終結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        # 若目標為 0 或負數，第一個玩家直接勝利\n        if desiredTotal <= 0:\n            return True\n\n        # 若所有數字加總也無法達到目標，則無法勝利\n        if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal:\n            return False\n\n        memo = {}\n\n        def can_win(used_mask: int, remaining: int) -> bool:\n            # 若此狀態已經計算過，直接回傳結果\n            if used_mask in memo:\n                return memo[used_mask]\n\n            # 嘗試每一個尚未使用的數字\n            for i in range(maxChoosableInteger):\n                bit = 1 << i\n                if not used_mask & bit:  # i+1 尚未被選取\n                    num = i + 1\n                    # 若選取此數字就能直接贏\n                    if remaining <= num:\n                        memo[used_mask] = True\n                        return True\n                    # 若對手在下一步無法勝利，則此步為贏\n                    if not can_win(used_mask | bit, remaining - num):\n                        memo[used_mask] = True\n                        return True\n\n            # 所有選項都無法勝利\n            memo[used_mask] = False\n            return False\n\n        return can_win(0, desiredTotal)\n\ndef main():\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if len(nums) >= 2:\n        maxChoosableInteger = int(nums[0])\n        desiredTotal = int(nums[1])\n    else:\n        # 如果輸入不足，預設為 0\n        maxChoosableInteger = 0\n        desiredTotal = 0\n\n    solution = Solution()\n    result = solution.canIWin(maxChoosableInteger, desiredTotal)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "maxChoosableInteger = 10, desiredTotal = 11",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "maxChoosableInteger = 10, desiredTotal = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "maxChoosableInteger = 10, desiredTotal = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode122.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock II",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the i^th day....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, for the problem: maximum profit with at most one share at any time, unlimited transactions, can buy/sell same day. Standard approach: iterate through array, add positive differences. Virtual code. Need Start, Step, Decision, etc.\n\nWe must not output actual code, just virtual steps. Let's produce: Start, Step: initialize profit, maybe hold? Standard algorithm: profit = 0; for i=1 to n-1 if prices[i] > prices[i-1] profit += prices[i] - prices[i-1]. That's it. Provide explanation. Use decision: if price rises? Yes then add profit. Also could do variable to hold previous price.\n\nLet's output step by step.\n\nWe need arrow for each step.\n\nWe could also use Decision block for each iteration? Might be repetitive. But we can illustrate loop.\n\nLet's structure:\n\nStart\n→ Step 1: Initialize profit = 0 // Starting profit zero\n→ Step 2: Set prevPrice = prices[0] // Store first day's price\n→ Step 3: For each day i from 1 to length-1 // Iterate through days\n    → Decision: If prices[i] > prevPrice? // Check price increase\n        Yes → Step 4: profit += prices[i] - prevPrice // Add gain\n        No → Step 5: profit unchanged // No gain\n    → Step 6: prevPrice = prices[i] // Update previous price\n→ End // Return profit\n\nBut we must keep each line as single virtual code line with comment. For loop might be a step \"Loop: for i from 1 to n-1\". Inside loop we might use decisions.\n\nLet's format:\n\nStart\n→ Step 1: Initialize profit = 0 // profit starts at 0\n→ Step 2: Set prevPrice = prices[0] // first day's price\n→ Step 3: Loop over i from 1 to n-1 // iterate days\n    → Decision: If prices[i] > prevPrice? // price rises\n        Yes → Step 4: profit += prices[i] - prevPrice // add difference\n        No  → Step 5: // no change to profit\n    → Step 6: prevPrice = prices[i] // update prev price\n→ End // profit now max achievable\n\nBut each line needs \"虛擬碼步驟\" plus comment. Indentation for nested lines maybe but keep format.\n\nWe can produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 profit = 0 // profit 初始為 0\n→ Step 2: 設置 prevPrice = prices[0] // 取第一天價格\n→ Step 3: Loop i = 1 to n-1 // 遍歷其餘天數\n    → Decision: 如果 prices[i] > prevPrice? // 檢查價格上漲\n        Yes → Step 4: profit += prices[i] - prevPrice // 加入利潤\n        No  → Step 5: // 無利潤增益\n    → Step 6: prevPrice = prices[i] // 更新上一天價格\n→ End // 回傳 profit\n\nBut must keep each line with comment. For nested lines, still a line each.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 profit = 0 // 利潤起始為 0  \n→ Step 2: 設置 prevPrice = prices[0] // 取得第一天價格  \n→ Step 3: Loop i = 1 to n-1 // 從第二天開始遍歷所有天數  \n  → Decision: 如果 prices[i] > prevPrice? // 檢查今天價格是否高於前一天  \n    Yes → Step 4: profit += prices[i] - prevPrice // 若上漲，加入差額為利潤  \n    No  → Step 5: // 若不上漲，利潤保持不變  \n  → Step 6: prevPrice = prices[i] // 更新 prevPrice 為今天價格  \n→ End // 程式執行結束，回傳 profit 最高可得利潤",
      "generated_code": "import sys\n\nclass Solution:\n    def maxProfit(self, prices):\n        \"\"\"\n        計算在能夠多次交易但同一時間最多持有一股的條件下，能取得的最大利潤。\n        只需累加相鄰天數價格上漲的差值即可。\n        \"\"\"\n        if not prices:\n            return 0\n        profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i - 1]:\n                profit += prices[i] - prices[i - 1]\n        return profit\n\ndef parse_input(raw):\n    \"\"\"\n    將 stdin 讀入的字串轉換為 price list。\n    支援兩種格式：\n    1. 'prices = [1,2,3]'\n    2. '[1,2,3]'\n    \"\"\"\n    raw = raw.strip()\n    if '=' in raw:\n        _, expr = raw.split('=', 1)\n        raw = expr.strip()\n    return eval(raw)  # 假設輸入合法且安全\n\ndef main():\n    raw_input = sys.stdin.read()\n    prices = parse_input(raw_input)\n    solution = Solution()\n    result = solution.maxProfit(prices)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode214.json",
    "problem_index_in_file": 0,
    "title": "Shortest Palindrome",
    "description_snippet": "You are given a string s. You can convert s to a palindrome by adding characters in front of it.\n\nRe...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line with explanations. The algorithm: find longest palindrome prefix; add reverse of remaining suffix to front. Steps: find longest palindrome prefix via KMP or two-pointer. Provide virtual code. We'll produce lines.\n\nUse structure Start, End, Decision.\n\nWe can incorporate KMP building failure function. Or simpler two-pointer. But let's choose two-pointer for clarity.\n\nPseudo:\n\nStart\n→ Step 1: 初始化 i = 0, j = len(s)-1 // 設定左右指標\n→ Decision: 如果 s[i] == s[j]? // 檢查字元是否對稱\n    Yes → i++ ; j-- ; // 左右指標向內移動\n    No  → Break // 當不對稱時停止\n→ Step 2: 找到分割點 idx = i // idx 為第一個不對稱位置\n→ Step 3: 從 idx 到 end 取子串 tail // 後半不匹配的部分\n→ Step 4: 反轉 tail 並設為 prefix // 需要加入的前綴\n→ Step 5: 組合 prefix + s // 最終最短回文\nEnd\n\nBut we need to ensure we handle when string already palindrome: idx becomes len(s). In that case tail empty.\n\nLet's produce each line. Add comments.\n\nUse arrow \"→\" at start each step. For decisions, indent lines.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 i = 0, j = length(s) - 1 // 左右指標指向字串兩端  \n→ Decision: 如果 s[i] == s[j]? // 檢查左右兩端是否相等  \n  Yes → i = i + 1 ; j = j - 1 ; // 若相等，指標向內移動  \n  No  → Break ; // 若不相等，結束對稱判斷  \n→ Step 2: 令 idx = i // idx 為第一次不對稱的位置（或字串長度）  \n→ Step 3: 取 tail = s[idx … end] // 後半不匹配的子串  \n→ Step 4: 令 prefix = reverse(tail) // 需要加在前面的反轉字串  \n→ Step 5: 產生 result = prefix + s // 最短回文字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        \"\"\"Return the shortest palindrome by adding characters in front.\"\"\"\n        if not s:\n            return \"\"\n\n        # Build the temporary string for KMP: original + '#' + reversed(original)\n        temp = s + \"#\" + s[::-1]\n        n = len(temp)\n        lps = [0] * n  # Longest prefix-suffix array\n\n        # Compute LPS array\n        for i in range(1, n):\n            length = lps[i - 1]\n            while length > 0 and temp[i] != temp[length]:\n                length = lps[length - 1]\n            if temp[i] == temp[length]:\n                length += 1\n            lps[i] = length\n\n        # Characters that need to be added in front\n        to_add = s[lps[-1]:][::-1]\n        return to_add + s\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    Parse the raw input to extract the string s.\n    Supports formats like:\n      s = 'abc'\n      \"abc\"\n      abc\n    \"\"\"\n    raw = raw.strip()\n    # If the input starts with \"s =\", strip it\n    if raw.lower().startswith(\"s =\"):\n        raw = raw.split(\"=\", 1)[1].strip()\n    # Remove surrounding quotes if present\n    if (raw.startswith(\"'\") and raw.endswith(\"'\")) or (raw.startswith('\"') and raw.endswith('\"')):\n        raw = raw[1:-1]\n    return raw\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n\n    sol = Solution()\n    result = sol.shortestPalindrome(s)\n\n    # Print the result surrounded by single quotes as shown in the examples\n    print(f\"'{result}'\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'aacecaaa'",
          "expected_output": "'aaacecaaa'",
          "success": true,
          "output": "'aaacecaaa'"
        },
        {
          "example_index": 1,
          "input": "s = 'abcd'",
          "expected_output": "'dcbabcd'",
          "success": true,
          "output": "'dcbabcd'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode713.json",
    "problem_index_in_file": 0,
    "title": "Subarray Product Less Than K",
    "description_snippet": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for sliding window approach: count subarrays with product < k. Use two pointers, product variable, loop over right. Complexity O(n). Also handle k <= 1 return 0. Provide steps line by line with explanations. Ensure format: Start, → Step, Decision etc. Provide comments after space. Use virtual code arrows. Provide each step. Ensure each line includes virtual code and comment separated by space. Let's produce.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\" e.g. \"Start // 程式開始執行\". Use arrows. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: if k <= 1 return 0 // 若 k 小於等於 1，任何子陣列積必不小於 k，直接回傳 0\n→ Step 2: 初始化 left = 0, prod = 1, result = 0 // 左指標、積、結果計數\n→ For each right from 0 to nums.length-1: // 右指標遍歷陣列\n    → Step 3: prod = prod * nums[right] // 把當前元素加入積\n    → Decision: while prod >= k and left <= right: // 當積已不小於 k 時收縮左指標\n        Yes → Step 4: prod = prod / nums[left] // 移除左側元素\n        Yes → Step 5: left = left + 1 // 左指標右移\n    → Step 6: result = result + (right - left + 1) // 以左指標為起點的所有子陣列皆符合條件\nEnd // 程式執行結束\n\nBut we must preserve arrow formatting. Use \"→\" before each step. Decision lines inside loop. Might need indentation? Provide as separate lines.\n\nWe need to be careful: The arrow format: \"→ Decision: ...\". Use indent like 4 spaces or tab? Not necessary. Provide lines with arrow at start.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: if k <= 1 return 0 // 若 k 小於等於 1，任何子陣列積必不小於 k，直接回傳 0  \n→ Step 2: initialize left = 0, prod = 1, result = 0 // 設定左指標、積、結果計數  \n→ Step 3: for each right from 0 to nums.length - 1 do // 右指標遍歷陣列  \n  → Step 4: prod = prod * nums[right] // 把當前元素加入積  \n  → Decision: while prod >= k and left <= right? // 當積已不小於 k 時收縮左指標  \n   Yes → Step 5: prod = prod / nums[left] // 移除左側元素  \n   Yes → Step 6: left = left + 1 // 左指標右移  \n  → Step 7: result = result + (right - left + 1) // 以左指標為起點的所有子陣列皆符合條件  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numSubarrayProductLessThanK(self, nums, k):\n        if k <= 1:\n            return 0\n        prod = 1\n        result = 0\n        left = 0\n        for right, val in enumerate(nums):\n            prod *= val\n            while prod >= k and left <= right:\n                prod //= nums[left]\n                left += 1\n            result += right - left + 1\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析出 nums 列表與 k 整數。\n    支援兩種常見格式：\n      1. 一行：'nums = [1,2,3], k = 10'\n      2. 多行：第一行是列表，第二行是 k\n    \"\"\"\n    # 先嘗試從字串中抓取列表\n    list_match = re.search(r'\\[([^\\]]*)\\]', data)\n    if list_match:\n        nums_str = '[' + list_match.group(1) + ']'\n        nums = eval(nums_str)  # 允許字面解析列表\n    else:\n        # 若沒有找到列表，則假設第一行就是列表字面量\n        lines = data.splitlines()\n        if not lines:\n            raise ValueError(\"No input data found.\")\n        nums = eval(lines[0].strip())\n\n    # 再抓取 k\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if k_match:\n        k = int(k_match.group(1))\n    else:\n        # 若沒抓到 k，假設第二行就是 k\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            k = int(lines[1].strip())\n        else:\n            # 最後的備援，若沒有 k，則預設為 0\n            k = 0\n    return nums, k\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums, k = parse_input(input_data)\n    solution = Solution()\n    result = solution.numSubarrayProductLessThanK(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,5,2,6], k = 100",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3], k = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode187.json",
    "problem_index_in_file": 0,
    "title": "Repeated DNA Sequences",
    "description_snippet": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'. For e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for given problem: find all 10-letter substrings that appear more than once in a DNA string. We need to provide step-by-step virtual code, each line with \"→\" and comment after //. We need to use Start, End, Decision, etc. We need to cover reading input string, sliding window of length 10, store counts in hash map, then collect those with count >1, output list. Provide maybe use set to avoid duplicates in output. Provide complexity analysis? Not necessary.\n\nWe should produce code steps.\n\nLet's produce something like:\n\nStart // 開始\n→ Step 1: 取得輸入字串 s // input\n→ Decision: s.length < 10? // 若長度不足，直接返回空\n    Yes → Step 2: 返回空清單 // 無足夠子字串\n    No  → Step 3: 初始化哈希表 counts // 用於記錄子字串出現次數\n    → Step 4: 初始化空集合 result // 儲存重複的 10 字串\n    → Step 5: 對 i 從 0 到 s.length-10 做:\n        → Substring t = s.substring(i, i+10) // 取 10 長度子字串\n        → if counts.containsKey(t):\n            → counts[t] = counts[t] + 1 // 次數加一\n            → if counts[t] == 2:\n                → result.add(t) // 第 2 次出現時加入結果\n          else:\n            → counts[t] = 1 // 第一次出現\n    → Step 6: 將 result 轉為清單回傳 // 產生輸出\nEnd // 結束\n\nNeed to include arrow for loops etc. Use \"→\" for each step. Provide explanation after //.\n\nLet's format each line as required. Use \"→\" and \"Decision:\" for if.\n\nAlso mention the loop: \"→ Loop: i = 0 to s.length-10\" and inside the loop steps.\n\nBetter to represent with indent maybe but not necessary.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者或呼叫介面取得 DNA 序列  \n→ Decision: s.length < 10? // 若字串長度不足 10，無法形成 10 字長子字串  \n Yes → Step 2: 返回空清單 // 直接回傳空結果  \n No  → Step 3: 初始化哈希表 counts // 用於紀錄每個 10 字長子字串的出現次數  \n  → Step 4: 初始化空集合 result // 儲存重複出現的 10 字長子字串  \n  → Step 5: Loop i = 0 to s.length - 10 // 依序檢查所有可能的 10 字長子字串  \n   → Substring t = s.substring(i, i+10) // 取得目前 10 字長子字串  \n   → Decision: counts 內有 t? // 檢查該子字串是否已被遇過  \n    Yes → Step 6: counts[t] = counts[t] + 1 // 次數加一  \n     → Decision: counts[t] == 2? // 只在第二次出現時加入結果，避免重複加入  \n      Yes → result.add(t) // 加入結果集合  \n      No → No operation // 之後再遇到的重複不再加入  \n    No  → Step 7: counts[t] = 1 // 第一次出現，初始化計數  \n  → End Loop // 完成所有子字串檢查  \n→ Step 8: 將 result 轉為清單並回傳 // 產生最終輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        \"\"\"找出重複出現的 10 字長 DNA 子字串\"\"\"\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)   # 第二次出現時加入結果\n            else:\n                seen.add(seq)        # 第一次出現\n        return list(repeated)\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：可能是 \"s = '...' \" 或直接字串\n    if '=' in data:\n        _, right = data.split('=', 1)\n        s = right.strip()\n    else:\n        s = data\n\n    # 去除外層單引號或雙引號（如果存在）\n    if (s.startswith(\"'\") and s.endswith(\"'\")) or (s.startswith('\"') and s.endswith('\"')):\n        s = s[1:-1]\n\n    solution = Solution()\n    result = solution.findRepeatedDnaSequences(s)\n    # 輸出符合題目範例格式的 JSON 字串\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        },
        {
          "example_index": 1,
          "input": "s = 'AAAAAAAAAAAAA'",
          "expected_output": "[\"AAAAAAAAAA\"]",
          "success": true,
          "output": "[\"AAAAAAAAAA\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode300.json",
    "problem_index_in_file": 0,
    "title": "Longest Increasing Subsequence",
    "description_snippet": "Given an integer array nums, return the length of the longest strictly increasing subsequence....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for computing longest increasing subsequence (LIS). Provide virtual code line by line with explanations, using Start, End, Decision, arrow. Should be simple algorithm: DP O(n^2) or patience sorting O(n log n). Likely use DP for clarity.\n\nSteps: Start, initialize n, dp array length n all 1. Loop i from 1 to n-1, inner j from 0 to i-1, if nums[j] < nums[i] then dp[i] = max(dp[i], dp[j]+1). Keep track of maxLen. At end return maxLen.\n\nAdd comments. Ensure each line with // explanation. Use arrow \"→\".\n\nMake sure each step uses virtual code arrow notation. Possibly using \"Step X\" or just \"→\" before each.\n\nLet's format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: dp ← array of size n, all 1 // 每個位置至少包含自身，長度為 1  \n→ Step 3: maxLen ← 1 // 目前已知的最大遞增子序列長度  \n→ Decision: 是否存在多於一個元素? // 檢查陣列是否只有一個元素  \n    Yes → Step 4: For i from 1 to n-1 // 從第二個元素開始遍歷  \n        → Decision: i < n? // 是否仍有元素待處理  \n            Yes → Step 5: For j from 0 to i-1 // 比較前面所有元素  \n                → Decision: nums[j] < nums[i]? // 前一個是否小於當前元素  \n                    Yes → Step 6: dp[i] ← max(dp[i], dp[j] + 1) // 更新 dp[i] 為更長的子序列長度  \n                    No  → // 不做任何改變  \n                → Decision: i < n-1? // 是否仍有下一個 i 循環  \n                    No  → Step 7: maxLen ← max(maxLen, dp[i]) // 更新最大長度  \n            No  → // i 迴圈結束  \n        → Decision: maxLen < n? // 是否仍有元素可處理  \n            No  → End // 所有元素已處理，結束程式  \nEnd // 程式執行結束，返回 maxLen",
      "generated_code": "import sys\nimport bisect\nimport ast\n\nclass Solution:\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        利用「patience sorting」的思想，時間複雜度為 O(n log n)。\n        tails[i] 代表長度為 i+1 的遞增子序列的最小尾端元素。\n        \"\"\"\n        tails = []\n        for num in nums:\n            # 找到第一個不小於 num 的位置\n            idx = bisect.bisect_left(tails, num)\n            if idx == len(tails):\n                tails.append(num)          # 新增更長的子序列\n            else:\n                tails[idx] = num           # 替換成更小的尾端，保持將來更大的子序列可能\n        return len(tails)\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 尋找第一個 '[' 與最後一個 ']'，提取列表字串\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        # 若找不到合法的列表格式，直接退出\n        print(0)\n        return\n\n    list_str = data[start:end+1]\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # 解析失敗時回傳 0\n        print(0)\n        return\n\n    if not isinstance(nums, list):\n        print(0)\n        return\n\n    sol = Solution()\n    result = sol.lengthOfLIS(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,9,2,5,3,7,101,18]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,3,2,3]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [7,7,7,7,7,7,7]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode46.json",
    "problem_index_in_file": 0,
    "title": "Permutations",
    "description_snippet": "Given an array nums of distinct integers, return all the possible permutations. You can return the a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for generating all permutations of an array of distinct integers, in any order. Provide step-by-step virtual code with explanation after each line. Use arrow syntax, decision, Start, End. Should be line by line. Use \"Step 1\" etc.\n\nWe need to show typical backtracking algorithm. We'll write:\n\nStart\n\n→ Step 1: 定義結果列表 result = []\n\n→ Step 2: 定義回溯函式 backtrack(current, remaining)\n\n→ Decision: 如果 remaining 為空? // 當沒有剩餘元素時\n\n    Yes → Step 3: result.append(current.copy()) // 將當前排列加入結果\n\n    No  → Step 4: For each idx, val in enumerate(remaining):\n\n        → Step 5: next_current = current + [val] // 加入選中的元素\n\n        → Step 6: next_remaining = remaining[:idx] + remaining[idx+1:] // 移除選中的元素\n\n        → Step 7: backtrack(next_current, next_remaining) // 進行下一層遞迴\n\n→ Step 8: backtrack([], nums) // 初始呼叫\n\n→ Step 9: return result // 返回所有排列\n\nEnd\n\nWe also need to add explanation after each line. We need to ensure each line has virtual code + space + // explanation.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result = [] // 初始化儲存所有排列的結果列表  \n→ Step 2: define backtrack(current, remaining) // 定義回溯函式，current 為已選元素，remaining 為剩餘未選元素  \n    → Decision: if remaining is empty? // 檢查是否已經選完所有元素  \n        Yes → Step 3: result.append(current.copy()) // 將完整排列加入結果列表  \n        No  → Step 4: for idx, val in enumerate(remaining): // 逐個嘗試剩餘元素作為下一個位置  \n            → Step 5: next_current = current + [val] // 將選中的元素加入目前排列  \n            → Step 6: next_remaining = remaining[:idx] + remaining[idx+1:] // 從剩餘列表中移除已選元素  \n            → Step 7: backtrack(next_current, next_remaining) // 進行下一層遞迴探索  \n→ Step 8: backtrack([], nums) // 從空排列和完整數字列表開始回溯  \n→ Step 9: return result // 回傳所有生成的排列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        返回 nums 的所有排列，使用回溯 + 交換法\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # 如果已經排好所有位置，將結果加入 res\n            if start == len(nums):\n                res.append(nums[:])   # 做切片拷貝，避免後續變更影響\n                return\n            # 嘗試將剩餘未決定的元素放到 current 位置\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # 交換\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # 回朔\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整行輸入，示例格式： nums = [1,2,3]\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析輸入中的列表\n    if '=' in raw_input:\n        _, list_str = raw_input.split('=', 1)\n        list_str = list_str.strip()\n    else:\n        list_str = raw_input\n\n    # 使用 literal_eval 以安全方式轉換為 list\n    nums = ast.literal_eval(list_str)\n\n    # 取得所有排列並輸出\n    solution = Solution()\n    permutations = solution.permute(nums)\n    print(permutations)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0, 1], [1, 0]]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode829.json",
    "problem_index_in_file": 0,
    "title": "Consecutive Numbers Sum",
    "description_snippet": "Given an integer n, return the number of ways you can write n as the sum of consecutive positive int...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps, line by line, with explanation. The requirement: no real code, just structured steps. Use arrows etc. The algorithm: number of ways to express n as sum of consecutive positive integers. Known result: count of odd divisors of n. Or iterate over length k and check if there exists starting integer. Use formula: n = k*(2a + k -1)/2 => a = (n/k - (k-1)/2). Must be integer >=1. So we can loop k from 1 to sqrt(2n). Count if a integer >=1. Output count.\n\nLet's produce steps:\n\nStart\n→ Step 1: input n // get integer\n→ Step 2: initialize count = 0 // ways counter\n→ Step 3: set maxLen = floor(sqrt(2*n)) // maximum possible length of sequence\n→ Step 4: for k from 1 to maxLen // iterate possible lengths\n    → Step 4.1: compute numerator = n - k*(k-1)/2 // derived from a formula\n    → Decision: 如果 numerator <= 0? // if negative or zero, break loop\n        Yes → Break // further lengths will also be too large\n        No → Decision: numerator mod k == 0? // check divisibility\n            Yes → Step 4.2: a = numerator / k // starting number\n                Decision: a >= 1? // ensure positive start\n                    Yes → Step 4.3: count = count + 1 // valid representation\n                    No → // ignore\n            No → // not divisible, ignore\n→ Step 5: output count // result\nEnd\n\nBut we must use arrow syntax: Start, → Step 1 etc. Each line with comment. Use indentation for decision branches.\n\nMake sure each line includes arrow and comment. Use \"Decision:\" for if. Also use \"Yes →\", \"No →\". For loops we use \"→ For ...\". But sample uses indentation. We'll follow similar style.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 從使用者取得目標數值  \n→ Step 2: 初始化計數器 count ← 0 // 用來統計符合條件的寫法數量  \n→ Step 3: 計算最大可能長度 maxLen ← floor(√(2·n)) // 長度越大，總和越快超過 n  \n→ Step 4: 循環 k 由 1 到 maxLen // k 為連續數字的個數  \n  → Decision: 如果 n - k·(k-1)/2 ≤ 0? // 總和已無法再正向延伸  \n   Yes → Break // 退出循環，因為更長的 k 也會不符合  \n   No → Decision: (n - k·(k-1)/2) mod k == 0? // 判斷是否能整除得到起始數  \n    Yes → Step 4.1: a ← (n - k·(k-1)/2) / k // 取得起始數 a  \n     Decision: a ≥ 1? // 起始數必須為正整數  \n      Yes → Step 4.2: count ← count + 1 // 有效表示法，計數加一  \n      No → // 起始數不合法，忽略此 k  \n    No → // k 無法整除，忽略此 k  \n→ Step 5: 輸出 count // 回傳符合條件的總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef consecutive_numbers_sum(n: int) -> int:\n    \"\"\"\n    計算 n 能以多少種方式寫成連續正整數之和。\n    \"\"\"\n    count = 0\n    k = 1\n    # 只要 k*(k-1)/2 < n，k 就仍有可能成立\n    while k * (k - 1) // 2 < n:\n        # 使得 a = (n - k*(k-1)/2) / k 為正整數\n        if (n - k * (k - 1) // 2) % k == 0:\n            count += 1\n        k += 1\n    return count\n\ndef main() -> None:\n    # 從標準輸入讀取整數 n，輸入格式可能為 \"n = 5\" 等\n    raw = sys.stdin.read()\n    match = re.search(r'\\d+', raw)\n    if not match:\n        return\n    n = int(match.group())\n    print(consecutive_numbers_sum(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 9",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode202.json",
    "problem_index_in_file": 0,
    "title": "Happy Number",
    "description_snippet": "Write an algorithm to determine if a number n is happy.\n\nA happy number is a number defined by the f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation after space. Should use virtual code syntax: Start, End, Decision: etc. We need algorithm for happy number. Steps: Input n, initialize seen set, loop: if n==1 return true, if n in seen return false, add n to seen, compute sum of squares of digits: temp=0, while n>0: digit=n%10; temp+=digit*digit; n//=10; set n=temp; loop. End. We need to produce lines with arrow arrows. Use Start. Then step: Input n. Then Decision: If n == 1? Yes -> return true. No -> Decision: If n in seen? Yes -> return false. No -> compute next n. Then loop back. Use a loop structure? We can use a Decision that loops. Maybe using Start → Step: 初始化 seen set → Decision: while true? But simpler: use a while loop with condition that breaks. We can do Decision: n==1? Yes return true. No Decision: n in seen? Yes return false. No → Step: compute next. Loop back to start of loop. So we need to indicate loop. Maybe use a label like LoopStart. Let's produce:\n\nStart\n→ Step 1: 初始化 seen 集合 // 建立空集合記錄已出現的數\n→ Step 2: 接收輸入 n // 取得要檢查的正整數\n→ LoopStart // 迴圈起點\n    → Decision: n == 1? // 判斷是否已到 1\n        Yes → Step 3: 返回 true // 成為快樂數\n        No  → Decision: n 在 seen? // 檢查是否進入循環\n            Yes → Step 4: 返回 false // 不是快樂數\n            No  → Step 5: 計算下個數 // 取各位數平方和\n                → Step 6: 初始化 temp = 0\n                → Step 7: 計算 temp = sum of squares of digits of n\n                    → WhileLoopStart\n                        → Decision: n > 0?\n                            Yes → Step 8: digit = n % 10 // 取最低位\n                            → Step 9: temp += digit * digit // 加平方\n                            → Step 10: n = n / 10 // 去除最低位\n                            → Decision: n > 0? Yes → 回到 WhileLoopStart No → 结束\n                    → Step 11: n = temp // 更新 n 為新值\n                → Step 12: 把原始 n 加入 seen // 記錄已出现的 n\n                → Decision: 回到 LoopStart // 继续循环\nEnd\n\nBut we need to keep arrow formatting consistent. Use arrow lines with arrow and colon. Use `→` before each step. For decision blocks indent. Use Yes → etc. Must maintain format. Also need to close with End.\n\nMake sure each line ends with `// 解釋/說明`. Provide explanation. Use Chinese simplified? Should be Traditional Chinese.\n\nLet's craft final answer. Ensure no code block fences; just plain lines. Use the arrow. Also use `Decision:` line. Use indentation. Provide each line separate.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 seen 集合 // 建立空集合以記錄已出現的數字  \n→ Step 2: 接收輸入 n // 取得待判斷的正整數  \n→ LoopStart // 迴圈起點  \n    → Decision: n == 1? // 判斷是否已到 1  \n        Yes → Step 3: 返回 true // 成為快樂數，結束程式  \n        No  → Decision: n 在 seen? // 檢查是否進入重複循環  \n            Yes → Step 4: 返回 false // 不是快樂數，結束程式  \n            No  → Step 5: 計算下個數 // 取各位數平方和  \n                → Step 6: 初始化 temp = 0 // 用於累加平方和  \n                → Step 7: WhileLoopStart // 進入內部循環計算平方和  \n                    → Decision: n > 0? // 處理每一位數  \n                        Yes → Step 8: digit = n % 10 // 取最低位數字  \n                        → Step 9: temp += digit * digit // 加上平方  \n                        → Step 10: n = n / 10 // 去除最低位  \n                        → Decision: n > 0? Yes → 回到 WhileLoopStart No → 结束  \n                → Step 11: n = temp // 更新 n 為新計算值  \n                → Step 12: 把前一次的 n 加入 seen // 記錄已出現的數  \n                → Decision: 回到 LoopStart // 继续外部循环  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isHappy(self, n: int) -> bool:\n        def get_next(number: int) -> int:\n            total = 0\n            while number > 0:\n                digit = number % 10\n                total += digit * digit\n                number //= 10\n            return total\n\n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        return n == 1\n\nif __name__ == \"__main__\":\n    line = sys.stdin.readline().strip()\n    if not line:\n        sys.exit(0)\n    if '=' in line:\n        n = int(line.split('=')[1].strip())\n    else:\n        n = int(line)\n    result = Solution().isHappy(n)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 19",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode189.json",
    "problem_index_in_file": 0,
    "title": "Rotate Array",
    "description_snippet": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for rotating array right by k. Each line with virtual code and comment. Use arrows. Need to handle steps: get length n, k = k % n, reverse whole array, reverse first k, reverse remaining n-k. Also handle n=0 or k=0. Use Decision steps. Let's produce.\n\nRemember not to output actual code. Provide virtual steps like \"Start\", \"→ Step 1: 取得陣列長度 n\", etc. Use Decision lines. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列長度 n = nums.length // 確定陣列長度  \n→ Decision: n == 0 或 n == 1? // 若陣列太短，無需旋轉  \n    Yes → End // 直接結束，無需變更  \n    No  → Step 2: 取得 k = k mod n // 將步數限制在陣列長度內  \n→ Decision: k == 0? // 若步數為零，陣列保持不變  \n    Yes → End // 結束  \n    No  → Step 3: 反轉整個陣列 nums[0…n-1] // 先反轉全陣列  \n→ Step 4: 反轉前 k 個元素 nums[0…k-1] // 反轉前 k 個，完成旋轉的一部分  \n→ Step 5: 反轉剩餘 n-k 個元素 nums[k…n-1] // 反轉後面的 n-k 個，完成旋轉  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def rotate(self, nums, k):\n        \"\"\"Rotate the array to the right by k steps in-place.\"\"\"\n        n = len(nums)\n        if n == 0:\n            return\n        k %= n\n        if k == 0:\n            return\n        self._reverse(nums, 0, n - 1)\n        self._reverse(nums, 0, k - 1)\n        self._reverse(nums, k, n - 1)\n\n    def _reverse(self, nums, start, end):\n        \"\"\"Helper to reverse a portion of the list.\"\"\"\n        while start < end:\n            nums[start], nums[end] = nums[end], nums[start]\n            start += 1\n            end -= 1\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n\n    # 從輸入中提取 nums 和 k\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not k_match:\n        raise ValueError(\"輸入格式錯誤，請確保包含 'nums = [...]' 與 'k = ...'\")\n\n    nums = eval(nums_match.group(1))\n    k = int(k_match.group(1))\n\n    # 執行旋轉\n    Solution().rotate(nums, k)\n\n    # 輸出結果\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "expected_output": "[5,6,7,1,2,3,4]",
          "success": true,
          "output": "[5, 6, 7, 1, 2, 3, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,-100,3,99], k = 2",
          "expected_output": "[3,99,-1,-100]",
          "success": true,
          "output": "[3, 99, -1, -100]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode492.json",
    "problem_index_in_file": 0,
    "title": "Construct the Rectangle",
    "description_snippet": "A web developer needs to know how to design a web page's size. So, given a specific rectangular web ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step, with comments, explaining algorithm to find L and W given area A. Constraints: L >= W, minimize L-W, integer dimensions? Usually problem expects integer lengths. We need to produce algorithm: Start, Step: Input area A. Compute sqrtA floor. For w from floor(sqrtA) downto 1: if A % w == 0: L = A / w; W = w; return [L, W]. This ensures L >= W and minimal difference because we start from largest width <= sqrt(A). That's typical. We'll output virtual code steps accordingly.\n\nAlso we might have additional decision to check if A is 0? Usually area>0. We'll keep simple.\n\nWe must adhere to format: \"虛擬碼步驟 // 解釋\". Use arrows for decision.\n\nWe'll output lines starting with \"Start\". Then arrow lines.\n\nNeed to use \"Decision:\" for if condition.\n\nWe also need to include \"End\".\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入目標面積 A // 取得使用者輸入的長方形面積  \n→ Step 2: 計算平方根 floorSqrtA = ⌊√A⌋ // 取得面積平方根的整數下限  \n→ Decision: 迴圈變數 w 從 floorSqrtA 減到 1 ？ // 準備從最大可能寬度開始遞減  \n    → Step 3: 若 A % w == 0？ // 判斷 w 是否為 A 的因數  \n        Yes → Step 4: 設定 L = A / w, W = w // 找到長度與寬度  \n        Yes → Step 5: 回傳 [L, W] // 由於從最大 w 開始，差值已最小  \n        No  → Continue // 無法整除，繼續遞減 w  \n→ End // 若所有 w 都測試完仍未回傳，表示輸入無效，程式結束（此情況在合理輸入下不會發生）",
      "generated_code": "import sys\nimport math\nimport re\n\ndef construct_rectangle(area: int):\n    # 找出最大寬度 w，且 w * (area // w) == area，且 w <= sqrt(area)\n    w = int(math.isqrt(area))\n    while area % w != 0:\n        w -= 1\n    return [area // w, w]\n\ndef main():\n    # 讀取整個輸入，並從中提取第一個整數作為 area\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    area = int(match.group())\n    result = construct_rectangle(area)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "area = 4",
          "expected_output": "[2,2]",
          "success": true,
          "output": "[2, 2]"
        },
        {
          "example_index": 1,
          "input": "area = 37",
          "expected_output": "[37,1]",
          "success": true,
          "output": "[37, 1]"
        },
        {
          "example_index": 2,
          "input": "area = 122122",
          "expected_output": "[427,286]",
          "success": true,
          "output": "[427, 286]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode383.json",
    "problem_index_in_file": 0,
    "title": "Ransom Note",
    "description_snippet": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for ransom note problem. Must be line-by-line with explanation. Use Start, End, Decision etc. Each line with virtual code step and comment. The solution: count letters in magazine, then for each letter in ransomNote, check if available. Use dictionary.\n\nWe should produce steps like:\n\nStart\n→ Step 1: 初始化字典 counts = {} // 统计杂志中每个字符\n→ Step 2: 对 magazine 每个字符 c 进行 counts[c] += 1 // 计数\n→ Step 3: 对 ransomNote 每个字符 c 进行...\n→ Decision: 如果 counts[c] > 0? ...\n   Yes → Step 4: counts[c] -= 1 // 用一次\n   No → Step 5: Return False // 无法构造\n→ Step 6: Return True // 成功\nEnd\n\nAlso need to use arrow notation and decision. Provide explanation after each line.\n\nMake sure each line has exactly one step, no actual code.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字典 counts = {} // 用於記錄雜誌中每個字母的數量  \n→ Step 2: 對 magazine 的每個字母 c 循環  \n  → counts[c] += 1 // 將字母 c 的計數加一  \n→ Step 3: 對 ransomNote 的每個字母 c 循環  \n  → Decision: counts[c] 是否大於 0？ // 檢查雜誌中是否還有此字母可用  \n    Yes → counts[c] -= 1 // 使用一次該字母，減少其計數  \n    No → Step 4: 返回 False // 沒有足夠字母，無法構造贈禮信  \n→ Step 5: 返回 True // 所有字母都已成功匹配，贈禮信可構造  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport collections\nimport re\n\ndef can_construct(ransom_note: str, magazine: str) -> bool:\n    \"\"\"判斷是否能用雜誌中的字母構造贈禮信。\"\"\"\n    ransom_count = collections.Counter(ransom_note)\n    magazine_count = collections.Counter(magazine)\n    for char, cnt in ransom_count.items():\n        if cnt > magazine_count.get(char, 0):\n            return False\n    return True\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中抓取兩個被雙引號包起來的字串\n    parts = re.findall(r'\"(.*?)\"', data)\n    if len(parts) >= 2:\n        ransom_note, magazine = parts[0], parts[1]\n    else:\n        # 若沒有雙引號，直接使用等號分隔\n        parts = re.split(r',\\s*', data)\n        ransom_note = parts[0].split('=')[1].strip()\n        magazine = parts[1].split('=')[1].strip()\n\n    result = can_construct(ransom_note, magazine)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ransomNote = \"a\", magazine = \"b\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "ransomNote = \"aa\", magazine = \"ab\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "ransomNote = \"aa\", magazine = \"aab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode376.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Subsequence",
    "description_snippet": "A wiggle sequence is a sequence where the differences between successive numbers strictly alternate ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for solution: longest wiggle subsequence. Probably DP approach: keep up and down arrays. Steps: if array empty, return 0; if length 1, return1; else iterate, maintain up[i] and down[i] or just two variables. For each i from1 to n-1, if nums[i]>nums[i-1], up=down+1 else if <, down=up+1 else unchanged. Finally max(up,down). Virtual code lines with explanation. Use Start, End, Decision etc. Provide step-by-step. Use arrows. We'll produce pseudo algorithm.\n\nLet's craft lines:\n\nStart\n→ Step 1: If nums is empty → Return 0 // handle empty\n→ Step 2: Initialize up = 1, down = 1 // each element can start wiggle\n→ Step 3: For i from 1 to length(nums)-1 // iterate through sequence\n    → Decision: if nums[i] > nums[i-1] ?\n        Yes → up = down + 1 // current diff positive, extend down sequence\n        No → Decision: if nums[i] < nums[i-1] ?\n            Yes → down = up + 1 // current diff negative, extend up sequence\n            No → // diff zero, no change\n→ Step 4: Return max(up, down) // longest wiggle length\n\nWe need to use virtual code arrows with Start, End, Decision. Provide each line with explanation.\n\nWe should produce lines maybe nested decisions as indent. Ensure each line ends with // explanation. Use \"→\" for steps and \"Decision:\" for if.\n\nLet's format properly. Use spaces. Also include comments in Chinese.\n\nReturn final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: If nums is empty → Return 0 // 空陣列直接回傳 0  \n→ Step 2: Initialize up = 1, down = 1 // 以第一個元素為起點，兩種方向都至少長度 1  \n→ Step 3: For i from 1 to length(nums)-1 // 逐一檢查相鄰差值  \n  Decision: 如果 nums[i] > nums[i-1]? // 差值為正  \n   Yes → up = down + 1 // 正差可延伸前一個負方向的序列  \n   No  → Decision: 如果 nums[i] < nums[i-1]? // 差值為負  \n    Yes → down = up + 1 // 負差可延伸前一個正方向的序列  \n    No  → // 差值為零，無須改變 up / down  \n→ Step 4: Return max(up, down) // 最長的 wiggle 子序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\n# ---------------------------------------------\n# 主要解法：使用兩個變數 up 和 down\n# up 代表最後一個差值為正時能得到的最長 wiggle 子序列長度\n# down 代表最後一個差值為負時能得到的最長 wiggle 子序列長度\n# ---------------------------------------------\nclass Solution:\n    def wiggleMaxLength(self, nums):\n        # 空陣列直接回傳 0\n        if not nums:\n            return 0\n        # 至少有一個元素，兩種方向都至少長度 1\n        up = down = 1\n        # 從第二個元素開始檢查\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                # 正差，延伸前一個負方向的序列\n                up = down + 1\n            elif nums[i] < nums[i - 1]:\n                # 負差，延伸前一個正方向的序列\n                down = up + 1\n            # 差為 0 時不改變 up / down\n        # 兩個方向中較長的即為答案\n        return max(up, down)\n\n# ---------------------------------------------\n# main：從標準輸入讀取資料並輸出答案\n# ---------------------------------------------\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 從輸入中抓取列表部分，例如 \"nums = [1,7,4,9,2,5]\"\n    nums_list = []\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        # 用 ast.literal_eval 解析成 Python 列表\n        nums_list = ast.literal_eval(match.group(0))\n    else:\n        # 若無符合格式，直接嘗試 eval\n        try:\n            nums_list = eval(data)\n        except Exception:\n            nums_list = []\n\n    # 計算最長 wiggle 子序列長度\n    result = Solution().wiggleMaxLength(nums_list)\n    # 將結果輸出到標準輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,7,4,9,2,5]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1,17,5,10,13,15,10,5,16,8]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4,5,6,7,8,9]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1249.json",
    "problem_index_in_file": 0,
    "title": "Minimum Remove to Make Valid Parentheses",
    "description_snippet": "Given a string s of '(' , ')' and lowercase English characters.\n\nYour task is to remove the minimum ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to remove minimum parentheses to make valid. Standard algorithm: use stack or counter to remove invalid closing and then from right remove invalid opening. Or we can use two-pass: first mark indices to remove. Approach: iterate, count, remove closing. Then reverse iterate to remove opening.\n\nWe need to produce step-by-step virtual code lines with explanation comments. Use \"Start\" \"End\" etc.\n\nLet's design:\n\nStart\n→ Step 1: Initialize empty stack or counter for open positions\n→ Step 2: For each character with index i in s:\n    If char is '(' → push index onto stack\n    Else if char is ')' → If stack not empty, pop; else mark i to remove\n→ Step 3: After loop, all indices left in stack are unmatched '(' → mark them to remove\n→ Step 4: Build result by iterating s again, skipping marked indices\n→ End\n\nExplain.\n\nUse decision for each step. Provide minimal lines.\n\nNeed arrow formatting: \"→ Step 1: ...\" etc.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Step 1: Initialize empty stack and empty set removeIdx // 用於記錄要刪除的位置\n→ Step 2: For each index i, char c in s:\n    If c == '(' → push i onto stack // 將左括號位置入棧\n    Else if c == ')' → \n        If stack not empty → pop from stack // 匹配成功\n        Else → add i to removeIdx // 無法匹配，標記刪除\n→ Step 3: While stack not empty:\n    pop index j → add j to removeIdx // 右側未匹配的左括號\n→ Step 4: Build result string res by iterating s:\n    For each index i, char c in s:\n        If i not in removeIdx → append c to res // 只保留合法字符\n→ End // 程式結束\n\nBut need arrow for each decision block. Also need to use \"Decision:\" maybe for if statements.\n\nLet's detail:\n\nStart\n→ Step 1: Initialize stack ← empty list // 用於記錄 '(' 的位置\n→ Step 1: Initialize removeIdx ← empty set // 記錄需要刪除的索引\n→ Step 2: For i, c in enumerate(s):\n    Decision: 如果 c 為 '('? // 判斷左括號\n        Yes → push i onto stack // 記錄位置\n        No → Decision: 如果 c 為 ')' ? // 判斷右括號\n            Yes → Decision: 如果 stack 非空？ \n                Yes → pop stack // 匹配成功\n                No → add i to removeIdx // 沒有匹配的右括號，刪除\n            No → // 其他字符，直接跳過\n→ Step 3: Decision: 如果 stack 非空？\n    Yes → While stack 非空:\n        pop j → add j to removeIdx // 右側未匹配的左括號\n→ Step 4: res ← empty string\n→ Step 4: For i, c in enumerate(s):\n    Decision: i 是否在 removeIdx？ \n        Yes → continue // 跳過\n        No  → append c to res // 保留\n→ End\n\nNeed to maintain arrow indentation. Provide consistent formatting.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: Initialize stack ← empty list // 用於記錄 '(' 的位置\n→ Step 1: Initialize removeIdx ← empty set // 記錄需要刪除的索引\n→ Step 2: For i, c in enumerate(s):\n    Decision: 如果 c 為 '('? // 判斷左括號\n        Yes → push i onto stack // 將左括號索引存入棧\n        No → Decision: 如果 c 為 ')' ? // 判斷右括號\n            Yes → Decision: 如果 stack 非空？\n                Yes → pop stack // 匹配成功，消除對應 '('\n                No  → add i to removeIdx // 沒有匹配的左括號，標記刪除\n            No → // 非括號字符，直接忽略\n→ Step 3: Decision: 如果 stack 非空？\n    Yes → While stack 非空:\n        pop j → add j to removeIdx // 右側未匹配的左括號，全部標記刪除\n→ Step 4: res ← empty string // 用於組裝最終結果\n→ Step 4: For i, c in enumerate(s):\n    Decision: i 是否在 removeIdx？\n        Yes → continue // 跳過需要刪除的字符\n        No  → append c to res // 保留合法字符\n→ End // 程式執行結束",
      "generated_code": "import sys\n\ndef min_remove_to_make_valid(s: str) -> str:\n    \"\"\"移除最少括號使得字串合法，返回任意合法字串。\"\"\"\n    s_list = list(s)\n    stack = []\n\n    for i, c in enumerate(s_list):\n        if c == '(':\n            stack.append(i)\n        elif c == ')':\n            if stack:\n                stack.pop()\n            else:\n                s_list[i] = ''  # 無法匹配的右括號\n\n    for i in stack:\n        s_list[i] = ''  # 右側未匹配的左括號\n\n    return ''.join(s_list)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 若輸入類似 's = \"text\"'，取雙引號內的內容；否則直接使用整行\n    first_quote = data.find('\"')\n    second_quote = data.find('\"', first_quote + 1)\n    if first_quote != -1 and second_quote != -1:\n        s = data[first_quote + 1:second_quote]\n    else:\n        s = data\n\n    result = min_remove_to_make_valid(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"lee(t(c)o)de)\"",
          "expected_output": "\"lee(t(c)o)de\"",
          "success": true,
          "output": "lee(t(c)o)de"
        },
        {
          "example_index": 1,
          "input": "s = \"a)b(c)d\"",
          "expected_output": "\"ab(c)d\"",
          "success": true,
          "output": "ab(c)d"
        },
        {
          "example_index": 2,
          "input": "s = \"))((\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode239.json",
    "problem_index_in_file": 0,
    "title": "Sliding Window Maximum",
    "description_snippet": "You are given an array of integers nums, there is a sliding window of size k which is moving from th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for sliding window maximum problem. Provide each line with \"虛擬碼步驟\" plus // explanation. Use Start, End, Decision:, arrow. Should be line by line. Probably use a deque approach. So steps: initialize deque, iterate i from 0 to n-1. Remove indices out of window. Remove smaller values. Add current index. When i>=k-1, record max = nums[deque[0]]. Output result. Then End.\n\nLet's write lines accordingly. Use arrow: \"→\" for next step, \"Yes →\" \"No →\" for decisions. We'll keep simple.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空雙端佇列 deque, 空結果陣列 result // 用來存儲滑動窗口的最大值  \n→ Step 2: 迴圈 i 從 0 到 nums.length - 1 // 遍歷整個陣列  \n    → Decision: i - deque[0] >= k? // 檢查佇列首元素是否已離開滑動窗口  \n        Yes → Step 3: 從 deque 移除首元素 // 刪除已不在窗口範圍內的索引  \n        No → // 保留首元素  \n    → Decision: nums[i] <= nums[deque.last]? // 檢查當前數字是否大於佇列尾部的數字  \n        Yes → Step 4: 從 deque 移除尾元素 // 刪除比當前數字小的元素，因為它們不可能成為最大值  \n        No → // 保留尾部元素  \n    → Step 5: 將 i 加入 deque 的尾部 // 把當前索引加入佇列  \n    → Decision: i >= k - 1? // 確定已經形成完整的滑動窗口  \n        Yes → Step 6: 將 nums[deque[0]] 加入 result // 佇列首元素即為窗口最大值  \n        No → // 尚未形成完整窗口，繼續迴圈  \nEnd // 程式執行結束，result 為所有滑動窗口的最大值陣列",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\ndef max_sliding_window(nums, k):\n    \"\"\"\n    Return a list containing the maximum of each sliding window of size k.\n    Uses a deque to keep indices of useful elements in decreasing order.\n    \"\"\"\n    if not nums or k == 0:\n        return []\n\n    deq = deque()\n    res = []\n\n    for i, val in enumerate(nums):\n        # Remove indices that are out of the current window\n        while deq and deq[0] < i - k + 1:\n            deq.popleft()\n\n        # Remove indices whose corresponding values are smaller than current\n        while deq and nums[deq[-1]] < val:\n            deq.pop()\n\n        deq.append(i)\n\n        # When the window has reached size k, record the maximum\n        if i >= k - 1:\n            res.append(nums[deq[0]])\n\n    return res\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Extract nums and k using regular expressions\n    pattern = r\"nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*k\\s*=\\s*(-?\\d+)\"\n    match = re.search(pattern, data)\n    if not match:\n        print(\"[]\")\n        sys.exit()\n\n    nums_str, k_str = match.groups()\n    nums = ast.literal_eval(nums_str)\n    k = int(k_str)\n\n    result = max_sliding_window(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "expected_output": "[3,3,5,5,6,7]",
          "success": true,
          "output": "[3, 3, 5, 5, 6, 7]"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode628.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product of Three Numbers",
    "description_snippet": "Given an integer array nums, find three numbers whose product is maximum and return the maximum prod...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need virtual code for finding maximum product of three numbers in array. Typical solution: sort array, product of top 3 or two smallest and largest. Provide step-by-step. Use Start, Decision, etc. Provide each line with explanation. Avoid real code. Let's craft.\n\nStart\n→ Step 1: 確認輸入陣列長度 // 取得 nums\n→ Decision: 如果陣列長度 < 3? // 檢查能否取三個\n    Yes → Step 2: 回傳 0 // 或錯誤訊息\n    No  → Step 3: 進行排序 // 以便找最大最小\n→ Step 4: 取得最大三個元素 max1, max2, max3 // 從排序後的尾部\n→ Step 5: 取得最小兩個元素 min1, min2 // 從排序後的頭部\n→ Step 6: 計算 product1 = max1 * max2 * max3 // 可能最大\n→ Step 7: 計算 product2 = min1 * min2 * max1 // 可能最大\n→ Decision: 如果 product1 > product2? // 比較兩種組合\n    Yes → Step 8: 回傳 product1 // 最大為三個最大值\n    No  → Step 9: 回傳 product2 // 最大為兩個最小值與最大值\nEnd\n\nWe need to use arrow format. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 確保有數值可供處理  \n→ Decision: 如果 nums 長度 < 3? // 需要至少三個數字才能計算乘積  \n  Yes → Step 2: 回傳 0 // 直接返回或報錯，表示無法計算  \n  No → Step 3: 對 nums 進行遞增排序 // 排序後可輕易取得最大與最小值  \n→ Step 4: 取得排序後陣列最後三個元素 max1, max2, max3 // 三個最大的數字  \n→ Step 5: 取得排序後陣列前兩個元素 min1, min2 // 最小的兩個數字  \n→ Step 6: 計算 product1 = max1 × max2 × max3 // 三個最大值的乘積  \n→ Step 7: 計算 product2 = min1 × min2 × max1 // 最小兩個與最大值的乘積  \n→ Decision: 如果 product1 > product2? // 判斷哪種組合產生更大的乘積  \n  Yes → Step 8: 回傳 product1 // 三個最大值的乘積是最大的  \n  No → Step 9: 回傳 product2 // 最小兩個加最大值的乘積更大  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maximumProduct(self, nums):\n        \"\"\"Return the maximum product of any three numbers in nums.\"\"\"\n        n = len(nums)\n        if n < 3:\n            return 0  # Not enough numbers to form a product of three\n        nums.sort()\n        # Product of the three largest numbers\n        prod1 = nums[-1] * nums[-2] * nums[-3]\n        # Product of the two smallest (possibly negative) and the largest\n        prod2 = nums[0] * nums[1] * nums[-1]\n        return max(prod1, prod2)\n\ndef parse_input(data: str):\n    \"\"\"Parse the input string into a list of integers.\n    Expected format: 'nums = [1,2,3]' or just a list literal.\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    # If an '=' sign exists, take the part after it\n    if '=' in data:\n        _, _, part = data.partition('=')\n        data = part.strip()\n    # Safely evaluate the list literal\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        nums = []\n    if not isinstance(nums, list):\n        nums = []\n    return nums\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    sol = Solution()\n    result = sol.maximumProduct(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "24",
          "success": true,
          "output": "24"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-2,-3]",
          "expected_output": "-6",
          "success": true,
          "output": "-6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode68.json",
    "problem_index_in_file": 0,
    "title": "Text Justification",
    "description_snippet": "Given an array of strings words and a width maxWidth, format the text such that each line has exactl...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. Should follow the format. No actual code, just steps. Steps should be like Start, End, Decision, etc.\n\nWe need to represent algorithm: iterate through words, pack into lines, then for each line, build justification.\n\nOutline:\n- Initialize result list\n- Initialize index = 0\n- While index < words length:\n    - Determine end index: find how many words fit in line (maxWidth)\n    - Count total chars of words\n    - Determine number of spaces needed: maxWidth - total chars\n    - If last line or only one word in line: left justify\n    - Else fully justify: distribute spaces evenly, left slots get more\n    - Build line string accordingly\n    - Append to result\n    - index = end index\n- End\n\nWe'll produce virtual code accordingly. Use arrow ->. Use decision: ... ?. Use Yes ->, No ->.\n\nMake sure each line has comment after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: words ← 輸入字串陣列 // 取得輸入文字列陣列\n→ Step 2: maxWidth ← 輸入最大寬度 // 取得每行最大字元數\n→ Step 3: result ← 空列表 // 用於儲存每行文字\n→ Step 4: index ← 0 // 初始化單詞索引\n→ Decision: index < words.length? // 是否還有未處理的單詞\n    Yes → Step 5: lineStart ← index // 記錄本行第一個單詞索引\n    → Step 6: lineEnd ← index // 記錄本行最後一個單詞索引\n    → Step 7: lineLen ← 0 // 本行單詞總長\n    → While: index < words.length AND lineLen + words[index].length + (index - lineStart) ≤ maxWidth? // 判斷是否還能加單詞（考慮空格）\n        Yes → lineLen ← lineLen + words[index].length // 累加單詞長度\n        → index ← index + 1 // 移動到下一個單詞\n        → lineEnd ← index - 1 // 更新本行最後一個單詞索引\n        No  → Break // 無法再加單詞，結束本行組合\n    → Step 8: spaceCount ← maxWidth - lineLen // 本行需要插入的空格總數\n    → Decision: (index == words.length) OR (lineEnd == lineStart)? // 本行是最後一行或只有一個單詞？\n        Yes → // 左對齊\n            → Step 9: line ← words[lineStart] // 開始字串為第一個單詞\n            → For i from lineStart+1 to lineEnd:\n                → line ← line + ' ' + words[i] // 加入單詞與單一空格\n            → Step 10: line ← line + ' ' * (maxWidth - line.length) // 右側填充空格\n        No  → // 全部對齊\n            → Step 11: gaps ← lineEnd - lineStart // 單詞之間的空格數\n            → Step 12: baseSpace ← spaceCount ÷ gaps // 每個空格的基礎數\n            → Step 13: extraSpace ← spaceCount mod gaps // 額外多出來的空格\n            → Step 14: line ← words[lineStart] // 從第一個單詞開始\n            → For i from lineStart+1 to lineEnd:\n                → spaces ← baseSpace + (extraSpace > 0 ? 1 : 0) // 左側多出來的空格\n                → line ← line + ' ' * spaces + words[i] // 加入空格與單詞\n                → If extraSpace > 0: extraSpace ← extraSpace - 1 // 先用完額外空格\n            → Step 15: // 本行已正好為 maxWidth 長\n    → Step 16: result.append(line) // 把組好的行加入結果\n    → Step 17: index ← lineEnd + 1 // 移動到下一行的起點\n    No  → End // 所有單詞已處理完畢\nEnd // 程式執行結束，result 為已格式化的文字列列表",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # Determine how many words can fit in the current line\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])  # add 1 for the space\n                j += 1\n\n            # Build the line\n            line_words = words[i:j]\n            gaps = len(line_words) - 1\n            spaces_needed = maxWidth - sum(len(w) for w in line_words)\n\n            if j == n or gaps == 0:\n                # Last line or a line with a single word: left-justify\n                line = ' '.join(line_words)\n                line += ' ' * (maxWidth - len(line))\n            else:\n                # Fully justify\n                space, extra = divmod(spaces_needed, gaps)\n                line = ''\n                for k in range(gaps):\n                    line += line_words[k]\n                    line += ' ' * (space + (1 if k < extra else 0))\n                line += line_words[-1]  # add the last word\n\n            res.append(line)\n            i = j\n\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    Parses input of the form:\n    words = [\"This\", \"is\", ...], maxWidth = 16\n    \"\"\"\n    words_match = re.search(r'words\\s*=\\s*(\\[[^\\]]*\\])', data)\n    max_match = re.search(r'maxWidth\\s*=\\s*(\\d+)', data)\n    if not words_match or not max_match:\n        raise ValueError(\"Input format is incorrect.\")\n    words = ast.literal_eval(words_match.group(1))\n    max_width = int(max_match.group(1))\n    return words, max_width\n\ndef main():\n    data = sys.stdin.read()\n    words, max_width = parse_input(data)\n    solver = Solution()\n    result = solver.fullJustify(words, max_width)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "success": true,
          "output": "['This    is    an', 'example  of text', 'justification.  ']"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "success": true,
          "output": "['What   must   be', 'acknowledgment  ', 'shall be        ']"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "success": true,
          "output": "['Science  is  what we', 'understand      well', 'enough to explain to', 'a  computer.  Art is', 'everything  else  we', 'do                  ']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode38.json",
    "problem_index_in_file": 0,
    "title": "Count and Say",
    "description_snippet": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\ncountAn...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. The algorithm: generate count-and-say sequence up to n. So steps: Start, input n, initialize current=\"1\", loop i from 2 to n, produce next via RLE of current. RLE: iterate over current string, count runs, build next string by appending count + char. After loop, output current. End.\n\nWe need to use decision structures? maybe loop and decisions inside RLE. We need to produce each step line with explanation. Use arrow \"→\" for flow. Let's produce lines. Provide clear explanation. Use \"Decision:\" for branching. For RLE, maybe \"Decision: 目前字符是否與前一個相同?\" etc. Let's write.\n\nLet's start:\n\nStart\n→ Input n // 取得使用者輸入的正整數\n→ Initialize current = \"1\" // 設定序列第一項\n→ Decision: 如果 n = 1? // 判斷是否已是第一項\n    Yes → Output current // 直接輸出結果\n    No  → Begin loop i = 2 to n // 若 n > 1，進入迴圈生成後續項\n        → Initialize next = \"\" // 準備儲存下一項\n        → Initialize count = 1 // 計數器初始化\n        → For j = 1 to length(current)-1 // 遍歷目前字串除最後一個\n            → Decision: current[j] == current[j+1]? // 檢查相同\n                Yes → Increment count // 相同則計數累加\n                No  → Append count and current[j] to next // 不同則輸出計數與字符\n                     → Reset count = 1 // 重置計數\n        → Append count and current[last] to next // 處理最後一個字符\n        → Set current = next // 以新字串為下一項\n        → Increment i // 迴圈索引增量\n        → Decision: i <= n? // 檢查是否完成所有項\n            Yes → Go back to loop start\n            No  → Exit loop\n    → Output current // 輸出第 n 項\nEnd // 程式結束\n\nMake sure each line has arrow? For non-loop? For decision we indent. Use indentation maybe.\n\nLet's format as per example: each line starts with \"Start\" or arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 取得使用者輸入的正整數  \n→ Initialize current = \"1\" // 設定序列第一項為 \"1\"  \n→ Decision: 如果 n = 1? // 判斷是否已是第一項  \n Yes → Output current // 直接輸出結果並結束  \n No  → Begin loop i = 2 to n // 若 n > 1，開始生成後續項  \n  → Initialize next = \"\" // 準備儲存下一項的字串  \n  → Initialize count = 1 // 計數器初始為 1  \n  → For j = 1 to length(current)-1 // 遍歷目前字串除最後一個字符  \n   → Decision: current[j] == current[j+1]? // 檢查相鄰字符是否相同  \n    Yes → Increment count // 相同則累加計數  \n    No  → Append count + current[j] to next // 不同則將計數與字符追加至 next  \n      → Reset count = 1 // 重置計數器  \n  → Append count + current[last] to next // 處理最後一個字符  \n  → Set current = next // 將新字串設為下一項  \n  → Increment i // 迴圈索引加 1  \n  → Decision: i <= n? // 檢查是否還有項需要產生  \n   Yes → Go back to loop start  \n   No  → Exit loop  \n → Output current // 輸出第 n 項的結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countAndSay(self, n: int) -> str:\n        \"\"\"\n        Generate the nth term of the count-and-say sequence.\n        \"\"\"\n        if n == 1:\n            return \"1\"\n\n        prev = self.countAndSay(n - 1)\n        result = []\n        count = 1\n\n        for i in range(1, len(prev)):\n            if prev[i] == prev[i - 1]:\n                count += 1\n            else:\n                result.append(str(count))\n                result.append(prev[i - 1])\n                count = 1\n\n        # Append the last run\n        result.append(str(count))\n        result.append(prev[-1])\n\n        return \"\".join(result)\n\ndef main() -> None:\n    \"\"\"\n    Read an integer n from standard input, compute the nth count-and-say term,\n    and print it enclosed in double quotes.\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # Extract the first integer found in the input\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n\n    n = int(match.group())\n    solution = Solution()\n    term = solution.countAndSay(n)\n\n    # Output with surrounding double quotes as per the examples\n    print(f'\"{term}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "\"1211\"",
          "success": true,
          "output": "\"1211\""
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "\"1\"",
          "success": true,
          "output": "\"1\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode287.json",
    "problem_index_in_file": 0,
    "title": "Find the Duplicate Number",
    "description_snippet": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for finding the repeated number in array without modifying array and using constant space. Classic Floyd's cycle detection. Virtual code: Start, initialize slow and fast pointers, step to find intersection, then find entrance. Provide each line with explanation. Use \"Start\", \"End\", \"Decision:\" etc. Let's produce. Ensure no actual code. Use lines like \"→ Step 1: 初始化 slow 和 fast 為 nums[0]\". Provide arrow lines. Use indentation for nested decisions. Provide only virtual code and explanation. Ensure each line has virtual code step + space + // explanation. Use proper structure. Provide lines. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 slow ← nums[0]，fast ← nums[0] // 為雙指標設定起點  \n→ Decision: 迭代至 slow 與 fast 相遇？ // 判斷是否已進入循環  \n    Yes → Step 2: 進入循環搜尋相遇點  \n    No  → Step 3: slow ← nums[slow]，fast ← nums[nums[fast]]，返回 Decision // 透過指標移動尋找相遇  \n→ Step 4: 初始化 finder ← nums[0] // 準備尋找週期入口  \n→ Decision: finder 與 slow 相遇？ // 判斷是否已找到重複數字  \n    Yes → Step 5: 重複數字為 finder // 重複數字已確定  \n    No  → Step 6: finder ← nums[finder]，slow ← nums[slow]，返回 Decision // 同時移動兩指標直到相遇  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # Floyd's Tortoise and Hare algorithm\n        slow = fast = nums[0]\n        # First phase: find intersection point\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        # Second phase: find entrance to the cycle\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # Find the list assigned to nums in the input\n    match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not match:\n        # If no assignment found, try to parse the whole input as a list\n        try:\n            nums = ast.literal_eval(data.strip())\n        except Exception:\n            raise ValueError(\"Input format is incorrect.\")\n    else:\n        nums = ast.literal_eval(match.group(1))\n    result = Solution().findDuplicate(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,4,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3,3,3,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode714.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock with Transaction Fee",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day, and an i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for solving maximum profit with transaction fee. Classic DP. Provide steps with arrows. Should be structured like pseudocode. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision.\n\nWe need to cover algorithm: iterate over days, maintain hold and cash. But we need step by step.\n\nWe'll produce Start. Then initialize hold and cash. Then loop over days with Decision: update hold, cash. At end output cash. End.\n\nEach line: \"Start // 程式開始執行\". Next line arrow.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 建立變數 cash = 0, hold = -prices[0] // 初始時持有股票的成本\n→ Decision: 循環從 i = 1 到 n-1 // 遍歷所有天數\n    Yes → Step 2: 更新 hold = max(hold, cash - prices[i]) // 以當天價格買入或保留持股\n    Yes → Step 3: 更新 cash = max(cash, hold + prices[i] - fee) // 以當天價格賣出並扣除手續費\n    Yes → End Decision // 完成一天的更新\n→ Step 4: 輸出 cash // 最終最大利潤\nEnd // 程式執行結束\n\nBut need arrow formatting properly. Use \"→\" before each step? The example uses \"→ Step 1\". Also nested decision: \"Decision:\" lines.\n\nThus we need to indent inside Decision? We'll use indentation with tab or spaces. Provide each line. For nested, we show Decision: and indent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立變數 cash = 0, hold = -prices[0] // 初始時持有股票的成本，cash 代表已賣出的現金  \n→ Decision: 循環 i 從 1 到 n-1 // 遍歷所有剩餘天數  \n  Yes → Step 2: hold = max(hold, cash - prices[i]) // 用今天價格買入或保持原有持股  \n  Yes → Step 3: cash = max(cash, hold + prices[i] - fee) // 用今天價格賣出並扣除交易費  \n  Yes → End Decision // 完成一天的更新  \n→ Step 4: 輸出 cash // 最終可得到的最大利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef max_profit_with_fee(prices, fee):\n    \"\"\"Return maximum profit with a transaction fee.\"\"\"\n    if not prices:\n        return 0\n    hold = -prices[0]   # 最大持股時的現金（負值）\n    cash = 0            # 已經賣出的現金\n    for price in prices[1:]:\n        # 賣出決策：若以今天價格賣出且扣除手續費\n        cash = max(cash, hold + price - fee)\n        # 買入決策：若今天買入並保留持股\n        hold = max(hold, cash - price)\n    return cash\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，預期格式如 \"prices = [1,3,2,8,4,9], fee = 2\"\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析價格列表\n    prices_match = re.search(r'prices\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if prices_match:\n        prices = ast.literal_eval(prices_match.group(1))\n    else:\n        prices = []\n\n    # 解析手續費\n    fee_match = re.search(r'fee\\s*=\\s*(-?\\d+)', data)\n    fee = int(fee_match.group(1)) if fee_match else 0\n\n    result = max_profit_with_fee(prices, fee)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [1,3,2,8,4,9], fee = 2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "prices = [1,3,7,5,10,3], fee = 3",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode406.json",
    "problem_index_in_file": 0,
    "title": "Queue Reconstruction by Height",
    "description_snippet": "You are given an array of people, people, which are the attributes of some people in a queue (not ne...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: reconstruct queue by height and k. Known solution: sort by height descending, if equal height ascending by k. Then insert each into result at index k. Let's produce stepwise pseudo code.\n\nNeed to use arrow format Start, Decision, etc. Provide each line with explanation.\n\nLet's produce something like:\n\nStart\n→ Step 1: Sort people by height descending; if equal height, sort k ascending.\n→ Step 2: Initialize empty list queue.\n→ Step 3: For each person in sorted people:\n    → Decision: Insert person at index k in queue.\n→ End\n\nBut we need more granular steps: sort algorithm maybe using sorting function. Use decision to handle equal heights.\n\nWe'll produce pseudo lines.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort array `people` in descending order of height; for equal heights, sort ascending by k // 先把較高的人排在前面，對同高的人則把 k 小的先放  \n→ Step 2: Initialize empty list `queue` // 建立一個空的佇列來儲存重建後的順序  \n→ Step 3: For each `person` in the sorted `people` array // 逐一處理已排序好的每個人  \n  → Decision: 把 `person` 插入到 `queue` 的第 `k` 個位置? // 依照 k 值決定插入位置  \n   Yes → Step 4: 插入 `person` 至 `queue` 的索引 `k` // 直接將人插入到正確位置  \n   No  → Step 4: （不會發生） // 此分支僅作結構示意  \n→ Step 5: 返回 `queue` // 完成後將重新排好順序的佇列傳回  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def reconstructQueue(self, people):\n        # Sort by descending height; for equal height, ascending k\n        people.sort(key=lambda x: (-x[0], x[1]))\n        res = []\n        for p in people:\n            res.insert(p[1], p)\n        return res\n\ndef parse_input(input_str):\n    \"\"\"\n    解析形如 'people = [[7,0],[4,4],...]' 的字串，返回對應的 list。\n    \"\"\"\n    input_str = input_str.strip()\n    if '=' in input_str:\n        # 取等號右邊的部分\n        _, expr = input_str.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = input_str\n    # 使用 literal_eval 以避免 eval 的安全問題\n    return ast.literal_eval(expr)\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    people = parse_input(data)\n    solution = Solution()\n    queue = solution.reconstructQueue(people)\n    # 輸出時移除空格以符合範例格式\n    print(str(queue).replace(' ', ''))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]",
          "expected_output": "[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]",
          "success": true,
          "output": "[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]"
        },
        {
          "example_index": 1,
          "input": "people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]",
          "expected_output": "[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]",
          "success": true,
          "output": "[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode381.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
    "description_snippet": "RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code step by step. We must not output actual code but pseudocode lines with explanation. We need to cover class definition, initialization, data structures, insert, remove, getRandom. Use arrows. Should be clear, step by step. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 RandomizedCollection 類別 // 建立資料結構的類別\n→ Step 2: 內部使用 List<int> values // 存放所有元素，方便隨機取值\n→ Step 3: 內部使用 Dictionary<int, HashSet<int>> indices // 對每個值，存放其在 values 中的所有索引\n→ Decision: 初始化時 values 及 indices 為空容器 // 準備好資料結構\n\nStart // 進入 constructor\n→ Step 4: 建構子 RandomizedCollection() // 初始化空的 values 與 indices\n→ Step 5: values = new List<int>() // 空列表\n→ Step 6: indices = new Dictionary<int, HashSet<int>>() // 空字典\n→ End // 建構子完成\n\nStart // 進入 insert 方法\n→ Step 7: 方法 insert(int val) → bool // 定義插入方法\n→ Step 8: Append val 到 values 列表 // values.add(val)\n→ Step 9: currentIndex = values.size - 1 // 取得新元素的索引\n→ Step 10: 若 indices 沒有 key val，建立新的 HashSet // 如果是第一次插入\n→ Step 11: indices[val].add(currentIndex) // 把索引加入對應集合\n→ Step 12: 若 indices[val] 的大小等於 1，表示此前不存在，返回 true // 第一個插入返回 true\n→ Step 13: 否則，返回 false // 重複值返回 false\n→ End // insert 方法完成\n\nStart // 進入 remove 方法\n→ Step 14: 方法 remove(int val) → bool // 定義刪除方法\n→ Step 15: 若 indices 不含 key val 或 indices[val] 為空，返回 false // 沒有此值時直接返回\n→ Step 16: 從 indices[val] 取得一個任意索引 removeIndex // 取一個要刪除的元素位置\n→ Step 17: 若 removeIndex 不是 values 的最後一個索引\n    → Step 18: lastVal = values.last() // 取得最後一個元素\n    → Step 19: lastIndex = values.size - 1 // 最後索引\n    → Step 20: values[removeIndex] = lastVal // 用最後一個元素覆蓋被刪除位置\n    → Step 21: indices[lastVal].remove(lastIndex) // 移除 lastVal 在最後索引的紀錄\n    → Step 22: indices[lastVal].add(removeIndex) // 加入新的索引\n→ End // 如果 removeIndex 是最後一個索引，直接跳過覆蓋步驟\n→ Step 23: values.removeLast() // 刪除列表最後一個元素\n→ Step 24: indices[val].remove(removeIndex) // 移除 val 在該索引的紀錄\n→ Step 25: 若 indices[val] 為空，從字典中移除 key val // 清理空集合\n→ Step 26: 返回 true // 成功刪除一個元素\n→ End // remove 方法完成\n\nStart // 進入 getRandom 方法\n→ Step 27: 方法 getRandom() → int // 定義隨機取值方法\n→ Step 28: 隨機產生一個 0~values.size-1 的整數 idx // 隨機索引\n→ Step 29: 返回 values[idx] // 直接回傳該索引的值\n→ End // getRandom 方法完成\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 存放所有元素的列表，方便隨機取值\n        self.data = []\n        # 每個值對應一組其在 data 中的索引，使用 set 方便 O(1) 插入與刪除\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        # 把 val 加到 data 最後\n        self.data.append(val)\n        # 記錄該值的索引\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若是第一次插入該值，返回 True，否則 False\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        # 如果沒有此值，直接返回 False\n        if not self.idx_map[val]:\n            return False\n        # 隨便取出一個該值的索引\n        remove_idx = self.idx_map[val].pop()\n        # 把 data 最後一個元素搬到 remove_idx 的位置\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            self.idx_map[last_val].remove(last_idx)\n            self.idx_map[last_val].add(remove_idx)\n        # 刪除最後一個元素\n        self.data.pop()\n        # 如果該值已經沒有索引了，從字典中移除它\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        # 隨機選取 data 的一個索引並返回對應值\n        return random.choice(self.data)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，將兩個列表包在外層方括號後解析\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    # 例如 input: [\"RandomizedCollection\", \"insert\", ...], [[], [1], ...]\n    # 轉成 ['[\"RandomizedCollection\", \"insert\", ...], [[], [1], ...]']\n    wrapped = f'[{raw_input}]'\n    try:\n        methods, params = json.loads(wrapped)\n    except json.JSONDecodeError:\n        # 如果解析失敗，直接退出\n        sys.exit(1)\n\n    obj = RandomizedCollection()\n    results = [None]  # 第一次為 constructor，返回 null\n\n    for method, arg in zip(methods[1:], params[1:]):\n        if method == 'insert':\n            res = obj.insert(arg[0])\n        elif method == 'remove':\n            res = obj.remove(arg[0])\n        elif method == 'getRandom':\n            res = obj.getRandom()\n        else:\n            res = None\n        results.append(res)\n\n    # 輸出符合 JSON 的格式（None -> null, True/False -> true/false）\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode132.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning II",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with arrows, decision, etc. No actual code. We need to compute minimum cuts for palindrome partition. Standard DP: precompute palindrome table, then dp[i] = min cuts for prefix s[:i], dp[0]= -1 or 0? For min cuts: dp[i] min cuts for s[0:i], so dp[0] = -1 to represent no cuts needed before start. Then for i from 1 to n: dp[i] = min_{j<i, s[j:i] palindrome} dp[j]+1. Use palindrome table or check on the fly. We'll produce high-level algorithm. Steps: Input string, length n. Precompute palindrome bool matrix of size n x n. Then dp array length n+1. Initialize dp[0] = -1. Loop i from 1 to n: set dp[i] = large. For j from 0 to i-1: if palindrome[j][i-1] true then dp[i] = min(dp[i], dp[j]+1). End loops. Output dp[n]. Use Start/End. Provide explanatory comments. Use arrow notation. We'll include decisions? We can have decision for palindrome check. Use structure: Start → Step 1: Input string s → Step 2: Compute n → Step 3: Initialize palindrome matrix → etc. We'll include decision: If palindrome? Then dp[i] update. We'll use Yes → dp[i] update. No → do nothing.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input string s // 從使用者取得要分割的字串  \n→ Step 2: 計算 s 的長度 n = length(s) // 方便後續迴圈使用  \n→ Step 3: 建立 2D 布林矩陣 palindrome[n][n] // 用來記錄子字串是否為回文  \n\n→ Step 4: 依序填寫 palindrome  \n    → For i = 0 to n-1  \n        → For j = i downto 0  \n            → Decision: 如果 s[j]==s[i] 且 (i-j<2 或 palindrome[j+1][i-1])? // 判斷子字串 s[j:i+1] 是否為回文  \n                Yes → palindrome[j][i] = true // 設為回文  \n                No  → palindrome[j][i] = false // 非回文  \n\n→ Step 5: 建立 DP 陣列 dp[n+1]  \n    → dp[0] = -1 // 前置位置無分割時的切割數（方便計算）  \n\n→ Step 6: 逐位計算最小切割數  \n    → For i = 1 to n  \n        → dp[i] = Infinity // 初始化為最大值  \n        → For j = 0 to i-1  \n            → Decision: 如果 palindrome[j][i-1]? // 子字串 s[j:i] 是否為回文  \n                Yes → dp[i] = min(dp[i], dp[j] + 1) // 更新為更小的切割數  \n                No  → (do nothing)  \n\n→ Step 7: 輸出 dp[n] // 最小切割數即為整個字串的答案  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        \"\"\"Return the minimum number of cuts needed to partition s into palindromic substrings.\"\"\"\n        n = len(s)\n        if n == 0:\n            return 0\n\n        # dp[i] : minimum cuts for prefix s[:i+1]\n        dp = [0] * n\n        # pal[j][i] : whether s[j:i+1] is a palindrome\n        pal = [[False] * n for _ in range(n)]\n\n        for i in range(n):\n            # Assume worst case: cut before each character\n            min_cut = i\n            for j in range(i + 1):\n                # Check if s[j] == s[i] and the middle part is a palindrome\n                if s[j] == s[i] and (i - j <= 1 or pal[j + 1][i - 1]):\n                    pal[j][i] = True\n                    # If the whole prefix s[:i+1] is a palindrome, no cut needed\n                    if j == 0:\n                        min_cut = 0\n                    else:\n                        # Else, cut after s[:j] and before s[j:i+1]\n                        min_cut = min(min_cut, dp[j - 1] + 1)\n            dp[i] = min_cut\n\n        return dp[-1]\n\n\ndef parse_input() -> str:\n    \"\"\"\n    Parse the input from stdin. Accepts two common formats:\n    1. A raw string (e.g., aab)\n    2. A line like: s = \"aab\"  (quotes optional)\n    \"\"\"\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return \"\"\n\n    # Handle the \"s = ...\" format\n    if '=' in raw:\n        _, value = raw.split('=', 1)\n        value = value.strip()\n        # Remove surrounding quotes if present\n        if (value.startswith('\"') and value.endswith('\"')) or \\\n           (value.startswith(\"'\") and value.endswith(\"'\")):\n            value = value[1:-1]\n        return value\n    else:\n        # Assume raw is the string itself\n        return raw\n\n\ndef main() -> None:\n    s = parse_input()\n    solution = Solution()\n    result = solution.minCut(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode521.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence I",
    "description_snippet": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce pseudocode lines with arrows, explanations. Problem: Longest Uncommon Subsequence (LUS). Known result: If a == b => -1 else max(len(a), len(b)). So algorithm: compare strings; if equal output -1; else output max lengths. We'll produce pseudocode. Use Start, End, Decision. Provide steps. Ensure each line is \"虛擬碼步驟 // 解釋\". Include arrows, indent decision branches.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 a, b // 取得兩個輸入字串  \n→ Decision: 如果 a 等於 b? // 檢查兩字串是否完全相同  \n  Yes → Step 2: 輸出 -1 // 若相同，沒有不相同的子序列  \n  No  → Step 3: 計算 lenA = 長度(a), lenB = 長度(b) // 分別取得兩字串長度  \n  → Step 4: 計算 result = max(lenA, lenB) // 取較長字串長度作為 LUS  \n  → Step 5: 輸出 result // 顯示最長不相同子序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        \"\"\"Return the length of the longest uncommon subsequence between a and b.\"\"\"\n        if a == b:\n            return -1\n        return max(len(a), len(b))\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input data that may come in two forms:\n    1. One line like: \"aba\", \"cdc\"\n    2. Two separate lines: aba\\ncdc\n    \"\"\"\n    # Remove leading/trailing whitespace\n    data = data.strip()\n    # If there's a comma, split by it\n    if ',' in data:\n        parts = data.split(',')\n        a = parts[0].strip().strip('\"').strip(\"'\")\n        b = parts[1].strip().strip('\"').strip(\"'\")\n        return a, b\n    # Otherwise, assume two separate lines\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n    # Fallback: use entire data as first string, empty second\n    return data, \"\"\n\ndef main():\n    raw_input = sys.stdin.read()\n    a, b = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findLUSlength(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"aba\", \"cdc\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "\"aaa\", \"bbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "\"aaa\", \"aaa\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode322.json",
    "problem_index_in_file": 0,
    "title": "Coin Change",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for coin change problem. Provide steps line by line, using virtual code syntax with arrow etc. Should reflect DP or BFS. Provide explanation each line. Avoid actual code. Just structure.\n\nUse DP approach: initialize array dp[0..amount] with large value. dp[0]=0. For each coin iterate amount. For each j from coin to amount: dp[j] = min(dp[j], dp[j-coin]+1). After loop, if dp[amount]==INF return -1 else dp[amount]. Provide steps accordingly.\n\nWe need to use virtual code format: Start, Step, Decision, End, etc.\n\nWe can use loops, but maybe use iterative steps. Provide steps: initialize dp array, loop coins, loop amounts, update, final decision. Provide explanation.\n\nMake sure to include each step on separate line with virtual code arrow. Use indentation? We can indent decisions within loops. Provide arrow arrow. Let's produce.\n\nAlso need to indicate loop iterations. Eg: \"Step 1: 初始化 dp[0] = 0, 其餘 dp[i] = INF\" etc.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定常數 INF 為一個足夠大的整數 // 代表「無法達成」的初始值  \n→ Step 2: 建立長度為 amount+1 的陣列 dp，並把所有索引設定為 INF // dp[i] 代表組成金額 i 所需的最少硬幣數  \n→ Step 3: 將 dp[0] 設為 0 // 0 元不需要任何硬幣  \n→ Decision: 是否有硬幣可供使用？  \n  Yes → Loop 1: 對每個 coin 在 coins 裡面執行  \n   → Step 4: 取下一個 coin // 取得目前硬幣面額  \n   → Loop 2: 對 j 從 coin 到 amount 逐一遞增  \n     → Step 5: 若 dp[j-coin] 不是 INF  \n      → Decision: 是否可以透過 j-coin 的組合再加上一枚 coin 取得更少硬幣？  \n        Yes → Step 6: 設定 dp[j] = min(dp[j], dp[j-coin] + 1) // 更新為更優解  \n        No  → Step 7: 不更新 // 目前已是最少硬幣數  \n     → Step 8: j 增 1，繼續 Loop 2  \n   → Step 9: j 完成，回到 Loop 1  \n  No  → End // 若 coins 為空，直接結束  \n→ Decision: dp[amount] 是否仍為 INF？  \n  Yes → Step 10: 回傳 -1 // 無法組成目標金額  \n  No  → Step 11: 回傳 dp[amount] // 取得最少硬幣數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def coinChange(self, coins, amount):\n        # dp[i] 代表組成金額 i 所需最少硬幣數\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n        return dp[amount] if dp[amount] != float('inf') else -1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入格式: \"coins = [1,2,5], amount = 11\"\n    pattern = r'coins\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*amount\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        return\n    coins_str = match.group(1)\n    amount_str = match.group(2)\n    try:\n        coins = eval(coins_str, {\"__builtins__\": None}, {})\n        amount = int(amount_str)\n    except Exception:\n        return\n    sol = Solution()\n    result = sol.coinChange(coins, amount)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "coins = [2], amount = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "coins = [1], amount = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode213.json",
    "problem_index_in_file": 0,
    "title": "House Robber II",
    "description_snippet": "You are a professional robber planning to rob houses along a street. Each house has a certain amount...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the house robber in circle problem (LeetCode 213). Provide step-by-step pseudocode with comments, using arrow syntax and decisions.\n\nWe must output line by line, each line: \"虛擬碼步驟 // 解釋/說明\"\n\nWe need to consider circular arrangement: cannot rob both first and last. Approach: consider two scenarios: exclude first house (rob houses 1..n-1) and exclude last house (rob houses 0..n-2). Compute max using standard house robber DP (linear). Edge cases: nums length 0,1.\n\nSo virtual code: Start, Decision: length? etc.\n\nWe produce steps:\n\nStart // 程式開始執行\n\n→ Decision: 如果 nums 長度 == 0? // 檢查是否無房子\n\n    Yes → Step: 返回 0 // 無錢\n\n    No → Decision: 如果 nums 長度 == 1? // 只有一棟房子\n\n        Yes → Step: 返回 nums[0] // 直接偷\n\n        No → Step 1: 定義函式 linearRob(start, end) // 計算線性序列的最大偷錢\n\n        → Step 2: 在 linearRob 裡使用 DP 變量 prev2, prev1\n\n        … etc.\n\nWe should output each step separately. We should produce for linearRob function too.\n\nLet's outline.\n\nI'll produce:\n\nStart\n\n→ Decision: len(nums) == 0? Yes → Return 0 No → Decision: len(nums) == 1? Yes → Return nums[0] No → Step: 計算 scenario1 = linearRob(0, len(nums)-2) // 省略最後一棟\n\n→ Step: 計算 scenario2 = linearRob(1, len(nums)-1) // 省略第一棟\n\n→ Step: 返回 max(scenario1, scenario2)\n\nDefine linearRob(start, end):\n\nStart function\n\n→ Decision: start > end? Yes → Return 0 No →\n\n→ Step: prev2 = 0 // dp[i-2]\n\n→ Step: prev1 = nums[start] // dp[i-1]\n\n→ Decision: start == end? Yes → Return prev1 No →\n\n→ For i from start+1 to end: // iterate houses\n\n    → Step: current = max(prev1, prev2 + nums[i]) // choose rob or skip\n\n    → Step: prev2 = prev1\n\n    → Step: prev1 = current\n\n→ Return prev1\n\nEnd function\n\nWe need to use arrow syntax: → Step: ... // comment\n\nFor loops maybe use \"→ For i = start+1 to end:\"\n\nAlso decisions indentation: we need to indent under Decision block.\n\nLet's craft the final answer with each line.\n\nBe careful with spacing: after each line, a space before // comment.\n\nWe must ensure each line is separate. Use arrow or other markers.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Decision: 如果 nums 長度 == 0? // 檢查是否無房子\n    Yes → Step: 返回 0 // 沒有房子可偷\n    No → Decision: 如果 nums 長度 == 1? // 只有一棟房子\n        Yes → Step: 返回 nums[0] // 直接偷取\n        No → Step: 定義函式 linearRob(start, end) // 計算線性序列最大偷錢\n→ Step: scenario1 = linearRob(0, len(nums)-2) // 省略最後一棟\n→ Step: scenario2 = linearRob(1, len(nums)-1) // 省略第一棟\n→ Step: 返回 max(scenario1, scenario2) // 選擇較大的偷錢量\nEnd // 程式結束\n\nNow we need to write linearRob function steps.\n\nDefine linearRob(start, end):\nStart // 進入線性偷錢計算\n→ Decision: start > end? // 檢查範圍是否有效\n    Yes → Step: 返回 0 // 無房子\n    No →\n→ Step: prev2 = 0 // dp[i-2] 初始化\n→ Step: prev1 = nums[start] // dp[i-1] 為第一棟\n→ Decision: start == end? // 只有一棟\n    Yes → Step: 返回 prev1 // 直接回傳\n    No →\n→ Step: For i = start+1 to end: // 遍歷剩餘房子\n    → Step: current = max(prev1, prev2 + nums[i]) // 決定是否偷\n    → Step: prev2 = prev1 // 更新 dp[i-2]\n    → Step: prev1 = current // 更新 dp[i-1]\n→ Step: 返回 prev1 // 最終結果\n\nBut we must use arrow formatting. Use \"→\" at each step. Indentation: Decision blocks.\n\nMake sure each line ends with comment.\n\nWe need to use \"Start\" and \"End\" to denote function boundaries? Use \"Start function linearRob\" maybe.\n\nWe'll do:\n\nStart function linearRob(start, end) // 進入線性偷錢計算\n→ Decision: start > end? // 檢查範圍是否有效\n    Yes → Step: 返回 0 // 無房子\n    No →\n→ Step: prev2 = 0 // dp[i-2] 初始化\n→ Step: prev1 = nums[start] // dp[i-1] 為第一棟\n→ Decision: start == end? // 只有一棟\n    Yes → Step: 返回 prev1 // 直接回傳\n    No →\n→ Step: For i = start+1 to end: // 遍歷剩餘房子\n    → Step: current = max(prev1, prev2 + nums[i]) // 決定是否偷\n    → Step: prev2 = prev1 // 更新 dp[i-2]\n    → Step: prev1 = current // 更新 dp[i-1]\n→ Step: 返回 prev1 // 最終結果\nEnd function linearRob // 退出線性偷錢計算\n\nBut we might not need \"function\" tags, but for clarity.\n\nHowever, we need each line separate. So we need to produce all lines. Let's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 nums 長度 == 0? // 檢查是否無房子  \n  Yes → Step: 返回 0 // 沒有房子可偷  \n  No → Decision: 如果 nums 長度 == 1? // 只有一棟房子  \n    Yes → Step: 返回 nums[0] // 直接偷取  \n    No → Step: 定義函式 linearRob(start, end) // 計算線性序列最大偷錢  \n→ Step: scenario1 = linearRob(0, len(nums)-2) // 省略最後一棟  \n→ Step: scenario2 = linearRob(1, len(nums)-1) // 省略第一棟  \n→ Step: 返回 max(scenario1, scenario2) // 選擇較大的偷錢量  \nEnd // 程式結束  \n\nStart function linearRob(start, end) // 進入線性偷錢計算  \n→ Decision: start > end? // 檢查範圍是否有效  \n  Yes → Step: 返回 0 // 無房子  \n  No →  \n→ Step: prev2 = 0 // dp[i-2] 初始化  \n→ Step: prev1 = nums[start] // dp[i-1] 為第一棟  \n→ Decision: start == end? // 只有一棟  \n  Yes → Step: 返回 prev1 // 直接回傳  \n  No →  \n→ Step: For i = start+1 to end: // 遍歷剩餘房子  \n   → Step: current = max(prev1, prev2 + nums[i]) // 決定是否偷  \n   → Step: prev2 = prev1 // 更新 dp[i-2]  \n   → Step: prev1 = current // 更新 dp[i-1]  \n→ Step: 返回 prev1 // 最終結果  \nEnd function linearRob // 退出線性偷錢計算",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def rob(self, nums):\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n\n        def rob_linear(houses):\n            prev, curr = 0, 0\n            for num in houses:\n                prev, curr = curr, max(curr, prev + num)\n            return curr\n\n        return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # parse input; assume format like \"nums = [1,2,3]\" or just a list literal\n    try:\n        if data.startswith(\"nums\"):\n            _, _, list_part = data.partition(\"=\")\n            list_part = list_part.strip()\n            nums = ast.literal_eval(list_part)\n        else:\n            nums = ast.literal_eval(data)\n    except Exception as e:\n        # fallback: try to extract numbers via regex\n        import re\n        nums = [int(x) for x in re.findall(r'-?\\d+', data)]\n    result = Solution().rob(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode402.json",
    "problem_index_in_file": 0,
    "title": "Remove K Digits",
    "description_snippet": "Given string num representing a non-negative integer num, and an integer k, return the smallest poss...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the algorithm: remove k digits to get smallest possible integer, typical stack algorithm. Provide step-by-step virtual code lines with explanation. Use Start, Decision, Yes→, No→, End. Provide one line per step. Should reflect algorithm: input string, k. Use stack (list). For each digit, while k>0 and stack top > current digit, pop. Push digit. After loop, if k>0, remove from end. Then build result from stack, strip leading zeros, return result or \"0\". We need to produce virtual code line by line, with explanation. Use arrow lines. Let's design.\n\nLine 1: Start // 程式開始\nLine 2: → Input: num, k // 取得輸入\nLine 3: → Initialize stack as empty list // 用於存儲數字\nLine 4: → Initialize index i = 0 // 迭代指標\nLine 5: → Decision: 是否還有字元可處理? // 檢查是否已到字串結束\nLine 6:     Yes → Step: current_digit = num[i] // 取得當前位數\nLine 7:     → Decision: 是否 k > 0 且 stack 不是空且 stack[-1] > current_digit? // 判斷是否需要刪除\nLine 8:         Yes → Step: Pop stack // 移除比當前大位\nLine 9:         Yes → Step: Decrement k // 已刪除一位\nLine 10:         → Decision: 重複判斷上一步? // 需要不斷比較\nLine 11:            Yes → Repeat Step 8-9 // 迴圈\nLine 12:            No → Step: Push current_digit onto stack // 推入\nLine 13:     No → Step: Push current_digit onto stack // 如果不滿足刪除條件\nLine 14: → Step: i = i + 1 // 移動到下一位\nLine 15: → 回到 Decision 5 // 重新檢查\nLine 16: → Decision: k > 0? // 剩餘要刪除的數量\nLine 17:     Yes → Step: Remove last k digits from stack // 刪除尾部多餘位\nLine 18:     No → No action // 若已刪除足夠\nLine 19: → Step: Build result string from stack // 拼接\nLine 20: → Step: Remove leading zeros from result // 清除前導零\nLine 21: → Decision: 結果是否為空? // 檢查是否有數字\nLine 22:     Yes → Step: Return \"0\" // 若無數字返回 0\nLine 23:     No → Step: Return result // 返回最小數字\nLine 24: End // 結束\n\nBut we need to format with arrows and indentation. Use indentation for substeps. Ensure each line with explanation.\n\nWe also need to use \"Decision:\" lines for if statements. The above lines 8-11 could be simplified: use a loop within decision. Let's produce simpler. Provide pseudocode: For each digit, while k>0 and stack[-1]>digit: pop and k--. Then push digit. After loop, if k>0: pop last k. Build string.\n\nLet's produce lines:\n\nStart\n→ Input num, k\n→ Initialize stack as empty list\n→ For each digit d in num: (Decision: iterate over digits)\n    → Decision: while k>0 and stack not empty and stack[-1] > d? (Decision)\n        Yes → Step: Pop stack\n        Yes → Step: k = k - 1\n        → Decision: repeat while condition? // loop continues\n    No → No action // exit while\n    → Step: Push d onto stack\n→ After loop: Decision: if k > 0? \n    Yes → Step: Remove last k elements from stack\n    No → No action\n→ Step: Build result from stack\n→ Step: Remove leading zeros\n→ Decision: if result empty? \n    Yes → Step: Return \"0\"\n    No → Step: Return result\nEnd\n\nBut we need to produce line by line, with arrow. Use indentation: for nested decisions use tab or spaces. We'll use four spaces indent.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Input num, k // 取得輸入值\n→ Initialize stack = [] // 用於儲存已選擇的位元\n→ Decision: 迭代 num 中的每個字符? // 開始遍歷字串\n    Yes → For each character d in num // 取得目前位元\n        → Decision: 是否需要刪除較大的前置位? (k>0 且 stack 非空 且 stack[-1] > d) // 判斷是否可削減\n            Yes → Step: Pop stack // 移除比 d 大的前置位\n            Yes → Step: k = k - 1 // 已刪除一位\n            → Decision: 仍滿足刪除條件? // 重新檢查條件，若是重複上一步\n                Yes → 回到 “Decision: 是否需要刪除較大的前置位?”\n                No → Step: Push d onto stack // 將 d 推入堆疊\n        No  → Step: Push d onto stack // 若不滿足刪除條件，直接推入\n    No  → // 已完成字串遍歷\n→ Decision: k > 0? // 是否還剩未刪除的位元\n    Yes → Step: Remove last k elements from stack // 刪除尾部多餘位元\n    No  → // 無需進一步刪除\n→ Step: Build result_string from stack // 由堆疊中的位元組成字串\n→ Step: Remove leading zeros from result_string // 清除前導零\n→ Decision: result_string 為空? // 判斷是否仍有數字\n    Yes → Step: Return \"0\" // 所有位元被刪除，返回 0\n    No  → Step: Return result_string // 返回最小化後的數字\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n        \"\"\"Return the smallest number after removing k digits from num.\"\"\"\n        stack = []\n        for digit in num:\n            while k > 0 and stack and stack[-1] > digit:\n                stack.pop()\n                k -= 1\n            stack.append(digit)\n\n        # If k remains, remove from the end\n        while k > 0:\n            stack.pop()\n            k -= 1\n\n        # Build result and strip leading zeros\n        result = ''.join(stack).lstrip('0')\n        return result if result else \"0\"\n\ndef parse_input(data: str):\n    \"\"\"Parse input from stdin, supporting various formats.\"\"\"\n    # Try to find patterns like num = \"12345\", k = 3\n    num_match = re.search(r'num\\s*=\\s*[\"\\'](\\d+)[\"\\']', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if num_match and k_match:\n        return num_match.group(1), int(k_match.group(1))\n\n    # If the input is two separate tokens (digits and integer)\n    tokens = re.findall(r'\\d+', data)\n    if len(tokens) >= 2:\n        return tokens[0], int(tokens[1])\n\n    # Fallback: first line digits, second line integer\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), int(lines[1].strip())\n\n    raise ValueError(\"Unable to parse input\")\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    num, k = parse_input(data)\n    sol = Solution()\n    result = sol.removeKdigits(num, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"1432219\", k = 3",
          "expected_output": "\"1219\"",
          "success": true,
          "output": "1219"
        },
        {
          "example_index": 1,
          "input": "num = \"10200\", k = 1",
          "expected_output": "\"200\"",
          "success": true,
          "output": "200"
        },
        {
          "example_index": 2,
          "input": "num = \"10\", k = 2",
          "expected_output": "\"0\"",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode125.json",
    "problem_index_in_file": 0,
    "title": "Valid Palindrome",
    "description_snippet": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and remov...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps. Let's design algorithm: iterate string, filter alphanumeric and lower. Then compare to reverse. Or use two pointers.\n\nWe'll produce steps:\n\nStart\n→ Step 1: initialize left = 0, right = len(s)-1\n→ Step 2: while left < right\n→ Decision: if s[left] not alphanumeric? // skip\n    Yes → left++ → continue\n→ Decision: if s[right] not alphanumeric? // skip\n    Yes → right-- → continue\n→ Decision: compare lower(s[left]) vs lower(s[right])?\n    Yes → left++ , right-- \n    No  → return False\nEnd: return True\n\nAlso need explanation comments.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 0, right = s.length - 1 // 初始化雙指標  \n→ Step 2: while left < right // 只要兩指標未交叉就持續比較  \n    → Decision: 如果 s[left] 不是字母或數字? // 檢查左邊字符是否可被保留  \n        Yes → left = left + 1 // 跳過非字母數字，移動左指標  \n        No  → Decision: 如果 s[right] 不是字母或數字? // 檢查右邊字符  \n            Yes → right = right - 1 // 跳過非字母數字，移動右指標  \n            No  → Decision: 比較 lower(s[left]) 與 lower(s[right])? // 兩邊字符大小寫統一後比較  \n                Yes → left = left + 1, right = right - 1 // 相等，繼續向內縮小範圍  \n                No  → Return False // 不相等，非回文  \n→ End // 兩指標已交叉，所有可比字符均相等  \n→ Return True // 字符串符合回文定義  \n\n---  \n\n此虛擬碼以雙指標方式，忽略非字母數字並將字母轉為小寫，逐步比較兩端字符，最終決定是否為回文。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        \"\"\"\n        判斷給定字串 s 是否為回文。\n        步驟:\n        1. 以雙指標從左右兩端往中間移動。\n        2. 跳過所有非字母數字字符。\n        3. 將剩下的字母轉為小寫後比較。\n        4. 如有任何不相等即返回 False，否則整個過程結束時返回 True。\n        \"\"\"\n        left, right = 0, len(s) - 1\n        while left < right:\n            # 跳過左邊非字母數字\n            while left < right and not s[left].isalnum():\n                left += 1\n            # 跳過右邊非字母數字\n            while left < right and not s[right].isalnum():\n                right -= 1\n            # 比較兩端字符（大小寫不敏感）\n            if s[left].lower() != s[right].lower():\n                return False\n            left += 1\n            right -= 1\n        return True\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入中的字串，提取實際要檢查的內容，\n    並使用 Solution.isPalindrome 判斷是否為回文，輸出\n    小寫的 'true' 或 'false'。\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 如果輸入格式類似 `s = \"...\"`，則提取雙引號中的內容\n    match = re.search(r'\"(.*?)\"', data, re.S)\n    if match:\n        s = match.group(1)\n    else:\n        s = data.strip()\n\n    solution = Solution()\n    result = solution.isPalindrome(s)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"A man, a plan, a canal: Panama\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"race a car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \" \"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode169.json",
    "problem_index_in_file": 0,
    "title": "Majority Element",
    "description_snippet": "Given an array nums of size n, return the majority element.\n\nThe majority element is the element tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with arrows and comments. The problem: find majority element in array, known to exist. We can use Boyer-Moore voting algorithm. Steps: initialize candidate and count, iterate through array, update candidate and count. Finally return candidate. So produce Start, Step 1: set candidate and count, Step 2: loop over each num in nums, Decision: if count==0? -> set candidate and count=1 else if num==candidate -> count++ else count--. After loop, Step 3: return candidate. End.\n\nWe need each line with explanation. Use \"→ Step ...\" lines. Ensure \"Decision:\" lines. Use arrow notation.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 初始化 candidate = nums[0], count = 0 // 初始化候選元素與計數\n→ Step 2: 對 nums 中每個元素 num 進行遍歷 // 逐一檢查元素\n    → Decision: 如果 count 為 0? // 需要重新選擇候選者\n        Yes → Step 2a: candidate = num, count = 1 // 取新元素作為候選者並重置計數\n        No  → Decision: 如果 num 等於 candidate? // 判斷是否為同一元素\n            Yes → Step 2b: count = count + 1 // 同一元素計數加一\n            No  → Step 2c: count = count - 1 // 不同元素計數減一\n→ Step 3: 回傳 candidate // 候選者即為多數元素\nEnd // 程式執行結束\n\nMake sure each line with explanation after //.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 candidate = nums[0], count = 0 // 初始化候選元素與計數  \n→ Step 2: 對 nums 中每個元素 num 進行遍歷 // 逐一檢查元素  \n  → Decision: 如果 count 為 0? // 需要重新選擇候選者  \n   Yes → Step 2a: candidate = num, count = 1 // 取新元素作為候選者並重置計數  \n   No → Decision: 如果 num 等於 candidate? // 判斷是否為同一元素  \n    Yes → Step 2b: count = count + 1 // 同一元素計數加一  \n    No → Step 2c: count = count - 1 // 不同元素計數減一  \n→ Step 3: 回傳 candidate // 候選者即為多數元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef majority_element(nums):\n    \"\"\"使用 Boyer–Moore 投票演算法找出多數元素。\"\"\"\n    count = 0\n    candidate = None\n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += 1 if num == candidate else -1\n    return candidate\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 去掉可能存在的 \"nums =\" 前綴\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n\n    # 解析成列表\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        # 若 eval 失敗，使用正則表達式擷取數字\n        import re\n        nums = list(map(int, re.findall(r'-?\\d+', expr)))\n\n    result = majority_element(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,1,1,1,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode468.json",
    "problem_index_in_file": 0,
    "title": "Validate IP Address",
    "description_snippet": "Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IP is a valid IPv6 ad...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with explanations for the algorithm that given a string queryIP returns \"IPv4\" or \"IPv6\" or \"Neither\". We must output each line: Virtual code step + space + // explanation. Use arrows and structure. Let's produce pseudocode.\n\nWe need steps: Start, check contains '.' -> if IPv4 pattern, else contains ':' -> IPv6 pattern else Neither. For IPv4: split by '.'; length 4; each part non-empty, no leading zeros unless single '0'; digits only; int <= 255. For IPv6: split by ':'; length 8; each part length 1-4; only hex digits. No leading zeros restrictions.\n\nNeed to use Decision arrows etc.\n\nLet's write:\n\nStart\n→ Step 1: Check if queryIP contains '.' // Determine possible IPv4\n    Yes → Decision: If queryIP contains ':'? // Cannot have both separators\n        Yes → Step 2: Return \"Neither\" // Invalid mixed separators\n        No  → Step 3: ValidateIPv4(queryIP) // Proceed to IPv4 validation\n    No  → Decision: If queryIP contains ':'? // Possible IPv6\n        Yes → Step 4: ValidateIPv6(queryIP) // Proceed to IPv6 validation\n        No  → Step 5: Return \"Neither\" // No separators\nEnd\n\nDefine ValidateIPv4:\nStart IPv4Validation\n→ Step 1: parts ← Split(queryIP, '.') // split into segments\n→ Decision: If parts.length != 4? // must have 4 parts\n    Yes → Step 2: Return \"Neither\" // invalid\n    No  → Continue\n→ For each part in parts: // iterate segments\n    → Decision: If part is empty? // empty segment invalid\n        Yes → Step 3: Return \"Neither\"\n        No  → Continue\n    → Decision: If part length > 1 AND part[0] == '0'? // leading zero\n        Yes → Step 4: Return \"Neither\"\n        No  → Continue\n    → Decision: If part contains non-digit? // only digits allowed\n        Yes → Step 5: Return \"Neither\"\n        No  → Continue\n    → num ← Convert(part) // to integer\n    → Decision: If num < 0 OR num > 255? // out of range\n        Yes → Step 6: Return \"Neither\"\n        No  → Continue\n→ Step 7: Return \"IPv4\" // all checks passed\nEnd\n\nDefine ValidateIPv6 similarly.\n\nImplement ValidateIPv6:\nStart IPv6Validation\n→ Step 1: parts ← Split(queryIP, ':')\n→ Decision: If parts.length != 8? // must have 8 parts\n    Yes → Step 2: Return \"Neither\"\n    No  → Continue\n→ For each part in parts:\n    → Decision: If part is empty? // cannot be empty\n        Yes → Step 3: Return \"Neither\"\n        No  → Continue\n    → Decision: If part.length < 1 OR part.length > 4? // length 1-4\n        Yes → Step 4: Return \"Neither\"\n        No  → Continue\n    → Decision: If part contains characters not in [0-9a-fA-F]? // invalid char\n        Yes → Step 5: Return \"Neither\"\n        No  → Continue\n→ Step 6: Return \"IPv6\"\nEnd\n\nFinally, End.\n\nAlso maybe need to incorporate functions.\n\nWe need to output lines with arrow notation and comments.\n\nMake sure each line includes \"虛擬碼步驟\" then space then \"// 解釋/說明\".\n\nLet's produce lines with indentation for decisions.\n\nLet's output final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: queryIP 是否包含 '.'? // 判斷是否有 IPv4 可能  \n  Yes → Decision: queryIP 是否同時包含 ':'? // 不能同時含有兩種分隔符  \n    Yes → Step: 返回 \"Neither\" // 同時有兩種分隔符，無效  \n    No → Step: ValidateIPv4(queryIP) // 進行 IPv4 驗證  \n  No → Decision: queryIP 是否包含 ':'? // 判斷是否有 IPv6 可能  \n    Yes → Step: ValidateIPv6(queryIP) // 進行 IPv6 驗證  \n    No → Step: 返回 \"Neither\" // 既不含 '.' 也不含 ':'  \nEnd // 程式執行結束  \n\n---  \n\nValidateIPv4: Start IPv4Validation // IPv4 驗證流程開始  \n→ Step: parts ← Split(queryIP, '.') // 把字串以 '.' 分割  \n→ Decision: parts.length != 4? // 必須恰好 4 個部分  \n  Yes → Step: 返回 \"Neither\" // 不符合長度，直接失敗  \n  No → Continue  \n→ For each part in parts: // 逐一檢查每個子串  \n   Decision: part 為空? // 空子串不合法  \n    Yes → Step: 返回 \"Neither\"  \n    No → Continue  \n   Decision: part.length > 1 且 part[0] == '0'? // 前導零不允許（除 '0'）  \n    Yes → Step: 返回 \"Neither\"  \n    No → Continue  \n   Decision: part 是否含非數字字符? // 只允許 0-9  \n    Yes → Step: 返回 \"Neither\"  \n    No → Continue  \n   num ← Convert(part) // 轉成整數  \n   Decision: num < 0 或 num > 255? // 數值範圍檢查  \n    Yes → Step: 返回 \"Neither\"  \n    No → Continue  \n→ Step: 返回 \"IPv4\" // 所有檢查通過  \nEnd // IPv4 驗證流程結束  \n\n---  \n\nValidateIPv6: Start IPv6Validation // IPv6 驗證流程開始  \n→ Step: parts ← Split(queryIP, ':') // 把字串以 ':' 分割  \n→ Decision: parts.length != 8? // 必須恰好 8 個部分  \n  Yes → Step: 返回 \"Neither\" // 不符合長度，直接失敗  \n  No → Continue  \n→ For each part in parts: // 逐一檢查每個子串  \n   Decision: part 為空? // 空子串不合法  \n    Yes → Step: 返回 \"Neither\"  \n    No → Continue  \n   Decision: part.length < 1 或 part.length > 4? // 長度必須在 1-4 之間  \n    Yes → Step: 返回 \"Neither\"  \n    No → Continue  \n   Decision: part 是否含非十六進位字符? // 只能是 0-9, a-f, A-F  \n    Yes → Step: 返回 \"Neither\"  \n    No → Continue  \n→ Step: 返回 \"IPv6\" // 所有檢查通過  \nEnd // IPv6 驗證流程結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validIPAddress(self, queryIP: str) -> str:\n        # Helper to validate IPv4\n        def isIPv4(s: str) -> bool:\n            parts = s.split('.')\n            if len(parts) != 4:\n                return False\n            for part in parts:\n                if not part.isdigit():\n                    return False\n                if part[0] == '0' and len(part) != 1:  # leading zero not allowed\n                    return False\n                num = int(part)\n                if num < 0 or num > 255:\n                    return False\n            return True\n\n        # Helper to validate IPv6\n        def isIPv6(s: str) -> bool:\n            parts = s.split(':')\n            if len(parts) != 8:\n                return False\n            hexdigits = \"0123456789abcdefABCDEF\"\n            for part in parts:\n                if not 1 <= len(part) <= 4:\n                    return False\n                if any(c not in hexdigits for c in part):\n                    return False\n            return True\n\n        if queryIP.count('.') == 3 and isIPv4(queryIP):\n            return \"IPv4\"\n        elif queryIP.count(':') == 7 and isIPv6(queryIP):\n            return \"IPv6\"\n        else:\n            return \"Neither\"\n\ndef main() -> None:\n    # Read entire input from stdin\n    raw_input = sys.stdin.read()\n    # Extract the IP address from the input (supports format: queryIP = \"IP\")\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if match:\n        ip = match.group(1)\n    else:\n        ip = raw_input.strip()\n\n    solution = Solution()\n    result = solution.validIPAddress(ip)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "queryIP = \"172.16.254.1\"",
          "expected_output": "IPv4",
          "success": true,
          "output": "IPv4"
        },
        {
          "example_index": 1,
          "input": "queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"",
          "expected_output": "IPv6",
          "success": true,
          "output": "IPv6"
        },
        {
          "example_index": 2,
          "input": "queryIP = \"256.256.256.256\"",
          "expected_output": "Neither",
          "success": true,
          "output": "Neither"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode433.json",
    "problem_index_in_file": 0,
    "title": "Minimum Genetic Mutation",
    "description_snippet": "A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line. The task is to find minimal mutations from startGene to endGene via BFS. Should consider gene bank set. Steps: start with queue, visited set, level. Return -1 if end not reachable.\n\nWe'll output in required format. Use Start, End. Use Decision. Use arrows. For BFS: while queue not empty, pop gene, level. If gene equals end return level. For each position, for each char in 'ACGT', create newGene, if in bank and not visited, enqueue, mark visited. After loop return -1. Also check if end not in bank return -1 early? but algorithm will handle.\n\nWe'll produce virtual code with comments. Provide line by line. Use \"→\" arrow indent for sub-steps. Ensure each line has one step and comment.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義字元集合 chars = ['A', 'C', 'G', 'T'] // 用來產生單字元替換\n→ Step 2: 將 bank 轉成 Set bankSet // 方便 O(1) 查找\n→ Step 3: 初始化 Queue q = [(startGene, 0)] // 每項為 (基因字串, 已經變異數)\n→ Step 4: 初始化 Set visited = {startGene} // 記錄已探訪基因\n→ Decision: q 是否為空? // 檢查是否還有未處理的基因\n    No → Step 5: 取出 (gene, steps) = q.pop_front() // 取得最早進入佇列的基因\n    → Decision: gene == endGene? // 檢查是否已到達目標\n        Yes → Step 6: 回傳 steps // 找到最小變異數，結束\n        No  → Step 7: 對於位置 i 從 0 到 7 做循環 // 逐字元嘗試變異\n            → For 每個 char 在 chars 做循環\n                → Decision: char == gene[i]? // 如果相同不變\n                    Yes → Step 8: 繼續下一個字元 // 跳過\n                    No  → Step 9: 建立 newGene = gene[0:i] + char + gene[i+1:] // 產生新基因\n                    → Decision: newGene 是否在 bankSet 且不在 visited? // 是否合法且未訪問\n                        Yes → Step 10: 將 newGene 加入 visited // 標記已探訪\n                        → Step 11: 將 (newGene, steps+1) 加入 q // 探索下一層\n                        No  → Step 12: 繼續下一個字元 // 跳過\n    Yes → Step 13: 回傳 -1 // 佇列已空，無法到達目標\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list) -> int:\n        \"\"\"\n        Use BFS to find the minimum number of mutations from start to end.\n        A mutation changes one character to another valid nucleotide.\n        \"\"\"\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])   # (current_gene, steps_taken)\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n\n            # Generate all one‑character mutations\n            for i in range(len(current)):\n                for g in genes:\n                    if g == current[i]:\n                        continue\n                    mutation = current[:i] + g + current[i + 1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n\n        return -1  # no valid mutation path found\n\n\ndef parse_input(text: str):\n    \"\"\"\n    Extract startGene, endGene, and bank from the input text.\n    Expected format: startGene = \"XXXXX\", endGene = \"XXXXX\", bank = [...]\n    \"\"\"\n    start_match = re.search(r'startGene\\s*=\\s*\"([ACGT]{8})\"', text)\n    end_match = re.search(r'endGene\\s*=\\s*\"([ACGT]{8})\"', text)\n    bank_match = re.search(r'bank\\s*=\\s*(\\[.*?\\])', text, re.S)\n\n    if not start_match or not end_match or not bank_match:\n        raise ValueError(\"Input format is incorrect\")\n\n    start_gene = start_match.group(1)\n    end_gene = end_match.group(1)\n    bank_list = ast.literal_eval(bank_match.group(1))\n\n    return start_gene, end_gene, bank_list\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    try:\n        start, end, bank = parse_input(raw_input)\n    except Exception:\n        # If parsing fails, output -1 as per problem constraints\n        print(-1)\n        sys.exit(0)\n\n    solution = Solution()\n    result = solution.minMutation(start, end, bank)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode168.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Title",
    "description_snippet": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for algorithm: convert number to Excel column title. Use loop, modulo 26, adjust for 1-indexed letters. Provide explanation per line. Ensure no real code, only virtual code. Use \"Start\", \"End\", \"Decision:\" etc. Provide arrow arrows.\n\nWe need to output: Start // etc, → Step 1: 等. Use \"虛擬碼步驟\" text. Let's construct.\n\nPseudo algorithm:\n- Initialize empty result string.\n- While columnNumber > 0:\n  - decrement columnNumber by 1 to convert to 0-indexed\n  - remainder = columnNumber % 26\n  - char = chr('A' + remainder)\n  - prepend char to result\n  - columnNumber = columnNumber // 26\n- Return result\n\nNeed to use Decision: maybe while loop. Use Step lines.\n\nWe'll produce lines like:\nStart // 程式開始執行\n→ Step 1: result ← \"\" // 初始化結果字串\n→ Step 2: 循環開始 // 進入迴圈，直到 columnNumber 為 0\n    Decision: columnNumber > 0? // 判斷是否仍有數字需要轉換\n        Yes →\n            Step 3: columnNumber ← columnNumber - 1 // 轉為 0 為基底\n            Step 4: remainder ← columnNumber mod 26 // 取餘數得到字母索引\n            Step 5: char ← chr('A' + remainder) // 轉為對應字母\n            Step 6: result ← char + result // 將字母加到前面\n            Step 7: columnNumber ← columnNumber div 26 // 移除已處理的部分\n        No  → // 結束迴圈\n→ Step 8: return result // 回傳最終列名\nEnd // 程式執行結束\n\nMake sure to maintain virtual code with arrows. Also each line must have \"虛擬碼步驟\" followed by // explanation. They used earlier \"→ Step 1:\" style. So we need each line to contain arrow symbol before step, then \"Step ...\" etc. Also include \"Decision:\" lines with indentation maybe. We'll replicate formatting.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← \"\" // 初始化空字串，用於儲存 Excel 列名  \n→ Step 2: 循環開始 // 進入 while 迴圈，處理 columnNumber 直到為 0  \n Decision: columnNumber > 0? // 判斷是否仍有數字需要轉換  \n  Yes → Step 3: columnNumber ← columnNumber - 1 // 先減 1，使字母對應 0~25  \n   → Step 4: remainder ← columnNumber mod 26 // 取得餘數，對應字母索引  \n   → Step 5: char ← chr('A' + remainder) // 將索引轉為對應字母  \n   → Step 6: result ← char + result // 將字母加到結果字串前面  \n   → Step 7: columnNumber ← columnNumber div 26 // 刪除已處理的部分  \n  No  → // columnNumber 已為 0，結束迴圈  \n→ Step 8: return result // 回傳最終得到的 Excel 列名  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        \"\"\"\n        Convert a positive integer to its corresponding Excel column title.\n        \"\"\"\n        result = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1                     # Adjust to 0-indexed\n            remainder = columnNumber % 26          # Find current letter\n            result = chr(ord('A') + remainder) + result\n            columnNumber //= 26                    # Move to next digit\n        return result\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, process it, and print the Excel column title.\n    Expected input format examples:\n        columnNumber = 1\n        columnNumber = 28\n        columnNumber = 701\n    \"\"\"\n    data = sys.stdin.read()\n    # Extract the first integer found in the input\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    column_number = int(match.group())\n\n    solution = Solution()\n    title = solution.convertToTitle(column_number)\n\n    # Print the result surrounded by double quotes as shown in the examples\n    print(f'\"{title}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnNumber = 1",
          "expected_output": "\"A\"",
          "success": true,
          "output": "\"A\""
        },
        {
          "example_index": 1,
          "input": "columnNumber = 28",
          "expected_output": "\"AB\"",
          "success": true,
          "output": "\"AB\""
        },
        {
          "example_index": 2,
          "input": "columnNumber = 701",
          "expected_output": "\"ZY\"",
          "success": true,
          "output": "\"ZY\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode23.json",
    "problem_index_in_file": 0,
    "title": "Merge k Sorted Lists",
    "description_snippet": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerg...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, not actual code. Need to produce step-by-step algorithm: merge k sorted linked lists into one sorted list. Use min-heap or priority queue. Provide steps with arrows, decisions.\n\nWe must output in traditional Chinese (繁體). Use Start, End, Decision. Each line: \"虛擬碼步驟 // 解釋\". Must not output actual code.\n\nWe need to list steps: start, initialize min-heap, push heads of each list, then loop while heap not empty, pop smallest node, append to result, if popped node has next, push that into heap, else continue. End. Possibly handle empty input.\n\nAlso, use decision: if list empty? But we can skip.\n\nWe need to use arrows →. For decisions: Decision: if heap empty? Yes → End. No → pop.\n\nWe also maybe decide to use sentinel node for result list.\n\nLet's produce. Use \"Start\", \"End\".\n\nLet's produce step by step:\n\nStart // 程式開始\n→ Initialize an empty min-heap // 建立最小堆以儲存目前各鏈表頭\n→ For each linked-list in lists: if head != null, push (head.value, head) into heap // 把每個非空鏈表的頭節點加入堆中\n→ Decision: if heap is empty? // 檢查是否有可合併節點\n    Yes → End // 沒有任何節點，直接結束\n    No  → Continue // 有節點可以合併\n→ Create a dummy head for result list // 用偵測節點作為合併後結果的起點\n→ Set current = dummy // 指向結果鏈表目前位置\n→ Decision: while heap is not empty? // 只要堆中還有節點就繼續\n    Yes → \n        → Pop minNode from heap // 取出最小節點\n        → Append minNode to result list by setting current.next = minNode // 將最小節點加到結果鏈表\n        → Move current = current.next // 移動到新加入的節點\n        → Decision: if minNode.next != null? // 若此節點還有後續\n            Yes → Push (minNode.next.value, minNode.next) into heap // 把後續節點加入堆\n            No  → Do nothing // 無後續節點\n        → Decision: continue while loop // 回到 while 判斷\n    No  → \n        → End // 堆已空，合併完成\n→ Return dummy.next // 返回合併後的鏈表頭\n\nBut we need to maintain structure: arrow after each step. Decision lines should show indented options.\n\nLet's produce each line as described. Use spaces after arrows.\n\nAlso include decisions properly: For while loop, we can use Decision: 迴圈? but we can embed inside. Might show:\n\n→ Decision: heap 為空? \n    Yes → End\n    No → ...\nBut to show loop, we can just have a Decision and then inside branch. But might be simpler: use \"Decision: heap 不是空?\" with Yes branch that includes rest of steps until next decision; after those steps, flow goes back to decision.\n\nWe must ensure each line ends with // 解釋.\n\nAlso no actual code. Use plain words. Use Traditional Chinese.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始\n\n→ 初始化一個空的最小堆 // 建立堆以儲存各鏈表當前最小節點\n\n→ 對於每個鏈表：若頭節點不為空，將 (節點值, 節點) 插入堆中 // 把所有非空鏈表的第一個節點加入堆\n\n→ Decision: 堆是否為空？ // 判斷是否有節點可合併\n    Yes → End // 若堆為空，表示所有鏈表都為空，直接結束\n    No  → // 進入合併流程\n\n→ 創建一個偵測節點 dummy 作為結果鏈表的起點 // 用於簡化鏈表連接\n\n→ 設置 current = dummy // 指向結果鏈表目前的位置\n\n→ Decision: 堆是否為空？ // 只要堆中還有節點就繼續\n    Yes → \n        → End // 堆空，合併完成，結束循環\n    No  → \n        → 從堆中取出最小節點 minNode // 取得目前全局最小的節點\n        → 將 minNode 接到結果鏈表：current.next = minNode // 將節點加入結果\n        → 移動 current = current.next // 更新結果鏈表指標\n        → Decision: minNode 是否有 next？ // 檢查該節點是否還有後續節點\n            Yes → \n                → 將 minNode.next 插入堆中 // 把後續節點加入堆\n            No  → // 無後續節點，無需操作\n        → 回到「Decision: 堆是否為空？」判斷，繼續循環\n\n→ Return dummy.next // 返回合併後的鏈表頭節點\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport heapq\n\n# Definition for singly-linked list node.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(values):\n    \"\"\"將列表轉換為鏈表並返回頭節點。\"\"\"\n    dummy = ListNode(0)\n    cur = dummy\n    for v in values:\n        cur.next = ListNode(v)\n        cur = cur.next\n    return dummy.next\n\ndef merge_k_lists(lists):\n    \"\"\"合併 k 個已排序的鏈表，返回排序後的整個鏈表。\"\"\"\n    # 把每個鏈表放進堆，堆的鍵是節點值\n    heap = []\n    counter = 0  # 用來在節點值相同時做唯一標識\n    for head in lists:\n        if head:\n            heapq.heappush(heap, (head.val, counter, head))\n            counter += 1\n\n    dummy = ListNode(0)\n    cur = dummy\n\n    while heap:\n        _, _, node = heapq.heappop(heap)\n        cur.next = node\n        cur = cur.next\n        if node.next:\n            heapq.heappush(heap, (node.next.val, counter, node.next))\n            counter += 1\n\n    # 將合併後的鏈表轉成 Python 列表回傳\n    res = []\n    node = dummy.next\n    while node:\n        res.append(node.val)\n        node = node.next\n    return res\n\ndef main():\n    # 讀取標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        lists_of_lists = []\n    else:\n        # 支援「lists = ...」或直接輸入列表字串\n        if '=' in data:\n            _, rhs = data.split('=', 1)\n            rhs = rhs.strip()\n        else:\n            rhs = data.strip()\n        try:\n            lists_of_lists = ast.literal_eval(rhs)\n        except Exception:\n            lists_of_lists = []\n\n    # 把每個子列表轉為鏈表\n    linked_lists = [build_linked_list(sublist) for sublist in lists_of_lists]\n    result = merge_k_lists(linked_lists)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
          "expected_output": "[1,1,2,3,4,4,5,6]",
          "success": true,
          "output": "[1, 1, 2, 3, 4, 4, 5, 6]"
        },
        {
          "example_index": 1,
          "input": "lists = []",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "lists = [[]]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode295.json",
    "problem_index_in_file": 0,
    "title": "Find Median from Data Stream",
    "description_snippet": "The median is the middle value in an ordered integer list. If the size of the list is even, there is...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for a MedianFinder with addNum and findMedian, using two heaps (max-heap for lower half, min-heap for upper half). Provide line-by-line virtual code with explanation. Use arrows. Ensure Start/End etc.\n\nLet's design steps:\n\nStart\n→ Initialize maxHeap (lower half)\n→ Initialize minHeap (upper half)\n\nMethod addNum(num):\n→ Insert into maxHeap\n→ Balance: if size(maxHeap) > size(minHeap)+1 => move top of maxHeap to minHeap\n→ else if size(minHeap) > size(maxHeap) => move top of minHeap to maxHeap\n\nMethod findMedian:\n→ If size(maxHeap) == size(minHeap) => return (top(maxHeap)+top(minHeap))/2\n→ else => return top(maxHeap)\n\nWe must represent the class initialization and methods as virtual steps. Use Decision lines.\n\nWe need each line in format \"虛擬碼步驟 // 解釋\". We'll list the class and its methods.\n\nUse Start, End. Probably start at class creation? Might have:\n\nStart // 程式開始執行\n→ Class MedianFinder: // 定義 MedianFinder 類別\n    → Constructor: // 建構子初始化\n        → maxHeap = new MaxHeap()\n        → minHeap = new MinHeap()\n    → Method addNum(num):\n        → maxHeap.insert(num)\n        → Decision: maxHeap.size > minHeap.size + 1?\n            Yes → maxHeap.extractTop() → minHeap.insert(...)\n            No → Decision: minHeap.size > maxHeap.size?\n                Yes → minHeap.extractTop() → maxHeap.insert(...)\n                No → // Balanced\n    → Method findMedian():\n        → Decision: maxHeap.size == minHeap.size?\n            Yes → median = (maxHeap.top + minHeap.top)/2.0\n            No → median = maxHeap.top\nEnd // 程式結束\n\nWe must use arrow symbols: →, Decision:, Yes →, No →. Need to maintain indentation? We can indent lines after Decision.\n\nEnsure each line ends with // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class MedianFinder: // 定義 MedianFinder 類別  \n → Constructor: // 建構子初始化資料結構  \n  → maxHeap = new MaxHeap() // 最大堆，存放較小的一半數值  \n  → minHeap = new MinHeap() // 最小堆，存放較大的一半數值  \n → Method addNum(num): // 新增數值到資料結構  \n  → maxHeap.insert(num) // 先將數值插入最大堆，保持較小的一半  \n  → Decision: maxHeap.size > minHeap.size + 1? // 檢查最大堆是否比最小堆多超過一個元素  \n   Yes → maxHeap.extractTop() → minHeap.insert(...) // 把最大堆最小值移到最小堆，保持平衡  \n   No → Decision: minHeap.size > maxHeap.size? // 檢查最小堆是否比最大堆多元素  \n    Yes → minHeap.extractTop() → maxHeap.insert(...) // 把最小堆最大值移到最大堆，保持平衡  \n    No → // 堆已平衡，無需處理  \n → Method findMedian(): // 取得目前所有數值的中位數  \n  → Decision: maxHeap.size == minHeap.size? // 判斷堆大小是否相等  \n   Yes → median = (maxHeap.top + minHeap.top) / 2.0 // 兩堆大小相等，取兩個中位數平均  \n   No → median = maxHeap.top // 最大堆多一個元素，中位數為最大堆頂部值  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport ast\nimport json\nimport heapq\n\nclass MedianFinder:\n    \"\"\"\n    使用兩個堆來維持已插入元素的中位數。\n    small：最大堆（存放較小的一半數值，使用負值實現）\n    large：最小堆（存放較大的一半數值）\n    \"\"\"\n    def __init__(self):\n        self.small = []  # 最大堆，存負值\n        self.large = []  # 最小堆\n\n    def addNum(self, num: int) -> None:\n        # 先把新數插入最大堆\n        heapq.heappush(self.small, -num)\n\n        # 若兩堆的最大值和最小值互相交叉，需調整\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 保持兩堆大小差不超過 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    # 解析輸入：兩個列表，中間以 '],' 分隔\n    split_idx = raw.find('],')\n    first_part = raw[:split_idx + 1]\n    second_part = raw[split_idx + 2:].strip()\n    # 確保兩部分都是合法的 Python 列表字面量\n    if not first_part.startswith('['):\n        first_part = '[' + first_part\n    if not second_part.startswith('['):\n        second_part = '[' + second_part\n\n    ops = ast.literal_eval(first_part)\n    args = ast.literal_eval(second_part)\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            result.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            result.append(None)\n        elif op == \"findMedian\":\n            result.append(obj.findMedian())\n        else:\n            # 若出現未知操作，可忽略或抛出錯誤\n            result.append(None)\n\n    # 用 json.dumps 以符合期望的 null、數字格式輸出\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode352.json",
    "problem_index_in_file": 0,
    "title": "Data Stream as Disjoint Intervals",
    "description_snippet": "Given a data stream input of non-negative integers a_1, a_2, ..., a_n, summarize the numbers seen so...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing SummaryRanges class that maintains intervals. We'll outline steps: store intervals sorted, addNum merges, getIntervals returns list. The virtual code lines should reflect operations. We'll produce step-by-step algorithm.\n\nWe'll need pseudocode for class with init, addNum, getIntervals. We can use a data structure like list of intervals.\n\nLet's produce:\n\nStart SummaryRanges // class init\n→ Step 1: intervals ← empty list // store intervals\nEnd // initialization complete\n\nThen addNum method:\n\nStart addNum // method begin\n→ Step 1: i ← find insertion position (first interval with start > value) // binary search\n→ Decision: Does value already in any interval? // check left interval end >= value\n    Yes → Step 2: return // already present\n    No  → Step 3: left ← interval at i-1 if i>0 and end+1 == value else null\n        Step 4: right ← interval at i if i < size and start-1 == value else null\n        Decision: If left and right exist? // value bridges two intervals\n            Yes → Step 5: merge left and right into new interval [left.start, right.end] // combine\n                → Step 6: remove left and right from list\n                → Step 7: insert new interval at i-1 // maintain order\n            No → Decision: If left exists? // extend left interval\n                Yes → Step 8: left.end ← value // extend\n                No → Decision: If right exists? // extend right interval\n                    Yes → Step 9: right.start ← value // extend\n                    No  → Step 10: insert new interval [value,value] at position i // new single number\nEnd // addNum complete\n\ngetIntervals:\n\nStart getIntervals\n→ Step 1: return copy of intervals // as list of [start,end]\nEnd\n\nWe need to incorporate binary search etc. Provide explanation.\n\nLet's craft each line. Use arrows and decision.\n\nWe'll need to include indentation for decisions. Provide explanation in Chinese. Let's produce final answer.\n...done thinking.\n\n```\nStart // 初始化 SummaryRanges 對象\n→ Step 1: intervals ← empty list // 用於儲存所有不相交區間，按 start 升序排列\nEnd // 初始化完成\n\nStart addNum(value) // 新增一個數字到資料流\n→ Step 1: i ← binarySearch(intervals, value) // 找到第一個 start 大於 value 的區間索引\n→ Decision: 是否已有區間包含 value? // 檢查 i-1 的區間是否覆蓋 value\n    Yes → Step 2: return // value 已存在，無需再做任何處理\n    No  → \n        Step 3: left ← (i>0 and intervals[i-1].end + 1 == value) ? intervals[i-1] : null // 左側可延伸的區間\n        Step 4: right ← (i < intervals.size() and intervals[i].start - 1 == value) ? intervals[i] : null // 右側可延伸的區間\n        Decision: left 並且 right 均存在? // value 連結兩個區間，需合併\n            Yes → \n                Step 5: merged ← [left.start, right.end] // 合併後的新區間\n                → Step 6: remove intervals[i-1] // 刪除左側區間\n                → Step 7: remove intervals[i-1] // 刪除右側區間（索引已變動）\n                → Step 8: insert merged at position i-1 // 插入合併後區間，保持排序\n            No  → Decision: left 存在? // 只可延伸左側區間\n                Yes → \n                    Step 9: left.end ← value // 把 value 加入左側區間\n                No  → Decision: right 存在? // 只可延伸右側區間\n                    Yes → \n                        Step 10: right.start ← value // 把 value 加入右側區間\n                    No  → \n                        Step 11: insert [value, value] at position i // 新增獨立區間\nEnd // addNum 完成\n\nStart getIntervals() // 取得目前所有區間\n→ Step 1: return copy of intervals // 返回一份區間清單，保證不被外部修改\nEnd // getIntervals 完成\n```",
      "generated_code": "import sys\nimport ast\n\nclass SummaryRanges:\n    def __init__(self):\n        self.intervals = []  # store disjoint intervals sorted by start\n\n    def addNum(self, val: int) -> None:\n        \"\"\"Add a number to the data stream and merge intervals if needed.\"\"\"\n        new_interval = [val, val]\n        res = []\n        placed = False\n        for start, end in self.intervals:\n            if end + 1 < val:\n                # Current interval is completely before the new number\n                res.append([start, end])\n            elif val + 1 < start:\n                # Current interval is completely after the new number\n                if not placed:\n                    res.append(new_interval)\n                    placed = True\n                res.append([start, end])\n            else:\n                # Overlap or adjacency – merge into new_interval\n                new_interval[0] = min(start, new_interval[0])\n                new_interval[1] = max(end, new_interval[1])\n        if not placed:\n            res.append(new_interval)\n        self.intervals = res\n\n    def getIntervals(self):\n        \"\"\"Return a list of the current disjoint intervals.\"\"\"\n        return self.intervals\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # Parse the two input lines as Python literals\n    commands = ast.literal_eval(data[0])\n    arguments = ast.literal_eval(data[1])\n\n    obj = None\n    outputs = []\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"SummaryRanges\":\n            obj = SummaryRanges()\n            outputs.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(arg[0])\n            outputs.append(None)\n        elif cmd == \"getIntervals\":\n            outputs.append(obj.getIntervals())\n\n    # Format the output list: replace None with null\n    formatted = []\n    for out in outputs:\n        if out is None:\n            formatted.append(\"null\")\n        else:\n            formatted.append(repr(out))\n    print(\"[\" + \", \".join(formatted) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "success": true,
          "output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode717.json",
    "problem_index_in_file": 0,
    "title": "1-bit and 2-bit Characters",
    "description_snippet": "We have two special characters:\\n- The first character can be represented by one bit 0.\\n- The secon...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. The user has described problem: \"two special characters: first is 0 single bit, second is two bits (10 or 11). Given a binary array bits that ends with 0, return true if the last character must be a one-bit character.\"\n\nSo we produce pseudocode steps. Must follow format: each line \"虛擬碼步驟 [space] // 解釋/說明\". Use arrows and structure Start, End, Decision:. Each step must be line.\n\nWe need to produce algorithm: iterate through array until second last bit? Actually typical solution: if bits[-1]==0 and bits[-2]==0 => true else if bits[-1]==0 and bits[-2]==1 => need to check if there's a two-bit preceding? Actually algorithm: start i=0; while i < n-1: if bits[i]==1: i+=2 else: i+=1. After loop, return bits[i]==0? Actually algorithm: while i < n-1, because last bit is 0. So if bits[i]==1, skip next bit. After loop ends, check if i==n-1 (point to last 0). If yes return true else false.\n\nWe need to produce virtual code with explanation.\n\nLet's create steps:\n\nStart // 開始\n\n→ Step 1: 定義 n 為 bits 的長度 // 取得陣列長度\n\n→ Step 2: 設定指標 i 為 0 // 從第一個位元開始\n\n→ Decision: i < n-1? // 檢查是否還有下一個位元可供判斷\n\n    Yes → Step 3: 如果 bits[i] == 1? // 判斷當前位元是否為 1\n\n        Yes → Step 4: i += 2 // 兩位元代表一個字符，跳過兩個位元\n\n        No  → Step 5: i += 1 // 0 是單位元字符，跳過一個位元\n\n    No  → Decision: i == n-1? // 判斷指標是否停在最後一個 0\n\n        Yes → Step 6: Return true // 最後一個 0 必須是單位元字符\n\n        No  → Step 7: Return false // 否則最後一個 0 不是單位元字符\n\nEnd // 程式結束\n\nWe must include arrow lines: \"→ Step X: ...\" For decision branches, we need indentation: Yes →, No → lines. Also start and end lines.\n\nMake sure each line includes \"虛擬碼步驟\" plus space plus comment. Use arrow for steps. For Decision lines, use \"Decision:\" and then indent.\n\nSo produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n 為 bits 數組長度 // 取得整體位元長度  \n→ Step 2: 初始化指標 i 為 0 // 從第一個位元開始處理  \n→ Decision: i < n - 1? // 判斷是否還有下一個位元可供判斷  \n  Yes → Step 3: 如果 bits[i] == 1? // 檢查當前位元是否為 1  \n    Yes → Step 4: i += 2 // 兩個位元表示一個字符，跳過兩個位元  \n    No  → Step 5: i += 1 // 0 是單位元字符，跳過一個位元  \n  No  → Decision: i == n - 1? // 判斷指標是否停在最後一個 0  \n    Yes → Step 6: Return true // 最後一個 0 必須是單位元字符  \n    No  → Step 7: Return false // 否則最後一個 0 不是單位元字符  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isOneBitCharacter(self, bits):\n        i = 0\n        n = len(bits)\n        while i < n - 1:\n            if bits[i] == 1:\n                i += 2\n            else:\n                i += 1\n        return i == n - 1\n\ndef main():\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    bits = list(map(int, nums))\n    result = Solution().isOneBitCharacter(bits)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "bits = [1,0,0]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "bits = [1,1,1,0]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode47.json",
    "problem_index_in_file": 0,
    "title": "Permutations II",
    "description_snippet": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to generate all unique permutations from a list that may contain duplicates. Must produce step-by-step lines with comments. Should include Start, End, Decision. Use arrow. Ensure each line contains virtual code step + space + // explanation.\n\nWe need to produce algorithm: sort array, backtrack with used array, avoid duplicates by checking if nums[i]==nums[i-1] && !used[i-1] then skip. Each recursion builds current permutation. Use list for results.\n\nWe'll produce pseudo steps:\n\nStart\n→ Sort nums ascending // To group duplicates together\n→ Initialize result list // To store all unique permutations\n→ Initialize used boolean array same length // To track if element used in current path\n→ Define backtrack function(current) // Recursively build permutations\n    → Decision: If current length == nums length? // All numbers used\n        Yes → Append copy of current to result // Store permutation\n        No → For i from 0 to nums length-1\n            → Decision: If used[i]? // Already used in this path\n                Yes → Continue // Skip\n                No → Decision: If i>0 AND nums[i]==nums[i-1] AND !used[i-1]? // Duplicate skip condition\n                    Yes → Continue // Skip duplicate\n                    No → used[i] = true // Mark used\n                    → Append nums[i] to current // Add to current permutation\n                    → backtrack(current) // Recurse\n                    → Remove last from current // Backtrack\n                    → used[i] = false // Unmark\n→ Call backtrack(empty list) // Start recursion\n→ Return result // All unique permutations\nEnd\n\nBut need to output line-by-line with arrow formatting. Each line should be separate. Use Start, End. Use Decision lines. Use indentation.\n\nWe need to maintain line format: each line: \"虛擬碼步驟 // 解釋\". Use arrow as needed. Eg \"→ Step 1: ...\" etc.\n\nLet's craft.\n\nLine 1: Start // 程式開始\n\nLine 2: → Sort nums ascending // 先排序以方便後續排重\n\nLine 3: → Initialize result list // 用於儲存所有唯一排列\n\nLine 4: → Initialize used boolean array // 標記每個位置是否已被使用\n\nLine 5: → Define backtrack(current) // 遞迴建立排列\n\nLine 6:     → Decision: If current length == nums length? // 檢查是否已使用全部數字\n\nLine 7:         Yes → Append copy of current to result // 存入結果\n\nLine 8:         No → For i from 0 to nums length-1 // 嘗試每個位置\n\nLine 9:             → Decision: If used[i]? // 已使用的數字\n\nLine 10:                Yes → Continue // 跳過\n\nLine 11:                No → Decision: If i>0 AND nums[i]==nums[i-1] AND !used[i-1]? // 重複數字且前一個未使用\n\nLine 12:                    Yes → Continue // 跳過重複排列\n\nLine 13:                    No → used[i] = true // 標記使用\n\nLine 14:                    → Append nums[i] to current // 加入當前數字\n\nLine 15:                    → backtrack(current) // 進一步遞迴\n\nLine 16:                    → Remove last from current // 回溯\n\nLine 17:                    → used[i] = false // 解除標記\n\nLine 18: → Call backtrack(empty list) // 開始遞迴\n\nLine 19: → Return result // 回傳所有唯一排列\n\nLine 20: End // 程式結束\n\nNeed to ensure arrow characters properly. Each line may have nested indentation. Use proper indentation.\n\nMake sure each line has a single arrow if it's a step, otherwise use \"→\" before each. Use \"    →\" for indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Sort nums ascending // 先將數字排序，方便後續判斷重複\n→ Initialize result list // 用來儲存所有唯一排列\n→ Initialize used boolean array // 用來標記每個位置是否已被使用\n→ Define backtrack(current) // 以遞迴方式建立排列\n    → Decision: If current length == nums length? // 檢查是否已使用全部數字\n        Yes → Append copy of current to result // 把完整排列加入結果\n        No → For i from 0 to nums length-1 // 嘗試每個位置\n            → Decision: If used[i]? // 已使用的數字\n                Yes → Continue // 跳過已使用\n                No → Decision: If i>0 AND nums[i]==nums[i-1] AND !used[i-1]? // 同值且前一個未使用，避免重複\n                    Yes → Continue // 跳過重複選項\n                    No → used[i] = true // 標記為已使用\n                    → Append nums[i] to current // 加入當前數字\n                    → backtrack(current) // 進一步遞迴\n                    → Remove last from current // 回溯，移除最後一個數字\n                    → used[i] = false // 解除已使用標記\n→ Call backtrack(empty list) // 從空排列開始遞迴\n→ Return result // 回傳所有唯一排列\nEnd // 程式結束執行",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permuteUnique(self, nums):\n        res = []\n        nums.sort()  # 先排序方便去重\n        used = [False] * len(nums)\n\n        def backtrack(path):\n            if len(path) == len(nums):\n                res.append(path[:])\n                return\n            for i in range(len(nums)):\n                if used[i]:\n                    continue\n                if i > 0 and nums[i] == nums[i-1] and not used[i-1]:\n                    continue  # 避免重複排列\n                used[i] = True\n                path.append(nums[i])\n                backtrack(path)\n                path.pop()\n                used[i] = False\n\n        backtrack([])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 解析輸入，支持形如 \"nums = [1,1,2]\" 或僅列表 \"[1,1,2]\"\n    try:\n        if '=' in data:\n            # 取等號右側\n            list_str = data.split('=', 1)[1].strip()\n        else:\n            list_str = data\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # 若解析失敗，輸出空列表\n        nums = []\n\n    sol = Solution()\n    result = sol.permuteUnique(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "[[1,1,2],[1,2,1],[2,1,1]]",
          "success": true,
          "output": "[[1, 1, 2], [1, 2, 1], [2, 1, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": true,
          "output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode719.json",
    "problem_index_in_file": 0,
    "title": "Find K-th Smallest Pair Distance",
    "description_snippet": "The distance of a pair of integers a and b is defined as the absolute difference between a and b.\\nG...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to find kth smallest pair distance. Likely using sorting + binary search over distance. Steps: sort array, define count of pairs <= mid, binary search distance low=0 high=max-min. Return low after loop.\n\nWe need line-by-line virtual steps with explanation. Use Start, Decision, etc. Provide arrow lines. Let's produce code-like pseudocode.\n\nWe'll outline:\n\nStart\n→ Input array nums, integer k\n→ Sort nums ascending\n→ low ← 0 // min possible distance\n→ high ← nums[n-1] - nums[0] // max possible distance\n→ while low < high\n    → mid ← (low + high) / 2\n    → count ← countPairsLE(nums, mid) // number of pairs with distance <= mid\n    → Decision: count >= k?\n        Yes → high ← mid // kth distance is <= mid, search left half\n        No  → low ← mid + 1 // need larger distances\n→ Return low // smallest distance with at least k pairs\n\nNeed to detail countPairsLE: two-pointer sliding window.\n\nWe'll add sub-step:\n\n→ Function countPairsLE(nums, limit)\n    → count ← 0\n    → j ← 0\n    → for i from 0 to n-1\n        → while j < n and nums[j] - nums[i] <= limit\n            → j ← j + 1\n        → count ← count + (j - i - 1) // pairs between i and j-1\n    → Return count\n\nNow we produce virtual steps line-by-line with explanation.\n\nUse arrows for each line.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: 數組 nums 與整數 k // 取得要處理的資料  \n→ Sort(nums) // 先把數組升冪排序，方便後續計算距離  \n\n→ low ← 0 // 距離最小可能值  \n→ high ← nums[nums.length-1] - nums[0] // 距離最大可能值  \n\n→ Decision: low < high? // 只要左邊小於右邊就持續搜尋  \n    Yes → mid ← (low + high) / 2 // 取中間距離作為候選  \n    → count ← countPairsLE(nums, mid) // 計算所有距離 ≤ mid 的對數  \n    → Decision: count ≥ k? // 需要的對數是否已達 k  \n        Yes → high ← mid // k 最小距離在左半區間，縮小上限  \n        No  → low ← mid + 1 // k 最小距離在右半區間，提升下限  \n    → Decision: low < high? // 重新判斷是否繼續迴圈  \n        Yes → 回到 Decision: low < high?  \n        No  → End // 當 low == high 時，已找到答案  \n\n→ Return low // low 為第 k 小距離  \n\n// ------------------------  \n→ Function countPairsLE(nums, limit) // 計算距離 ≤ limit 的所有對數  \n    → count ← 0  \n    → j ← 0  \n    → for i from 0 to nums.length-1  \n        → while j < nums.length and nums[j] - nums[i] ≤ limit  \n            → j ← j + 1 // 找到 j 使得距離 > limit  \n        → count ← count + (j - i - 1) // i 與 i+1…j-1 的對數  \n    → Return count // 回傳計算結果  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def smallestDistancePair(self, nums, k):\n        nums.sort()\n\n        def count_pairs(limit):\n            count = 0\n            left = 0\n            for right in range(len(nums)):\n                while nums[right] - nums[left] > limit:\n                    left += 1\n                count += right - left\n            return count\n\n        low, high = 0, nums[-1] - nums[0]\n        while low < high:\n            mid = (low + high) // 2\n            if count_pairs(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        return low\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the list of numbers\n    list_match = re.search(r'\\[([^\\]]*)\\]', data)\n    if list_match:\n        nums = [int(x.strip()) for x in list_match.group(1).split(',') if x.strip()]\n    else:\n        nums = []\n\n    # Extract k\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    k = int(k_match.group(1)) if k_match else 0\n\n    solution = Solution()\n    result = solution.smallestDistancePair(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,1], k = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1], k = 2",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [1,6,1], k = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode452.json",
    "problem_index_in_file": 0,
    "title": "Minimum Number of Arrows to Burst Balloons",
    "description_snippet": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps. We should explain each line. Use Start, End, Decision. Provide arrow lines. Should be step by step. For solution: sort balloons by end coordinate; iterate; maintain count and current arrow position (end). If next balloon's start > current arrow position, need new arrow: count++, update arrow position to this balloon's end. That's classic.\n\nNeed to output in plain text, each line: \"虛擬碼步驟 // 解釋\". Provide arrow symbol \"→\". Provide indentation. Use \"Decision:\".\n\nLet's produce lines:\n\nStart // Program start\n\n→ Step 1: Sort points by x_end ascending // 排序\n\n→ Step 2: Initialize arrows = 0, current_end = -∞ // 初始箭數及位置\n\n→ Step 3: For each balloon in sorted points // 遍歷每個氣球\n\n    → Decision: if balloon.x_start <= current_end? // 檢查是否已被現有箭擊中\n\n        Yes → Continue // 已被現有箭擊中，跳過\n\n        No  → Step 4: arrows = arrows + 1 // 需要新箭\n\n            → Step 5: current_end = balloon.x_end // 將箭位置設為此氣球的 x_end\n\n→ End // 返回箭數\n\nBut need to format each line with step names. Use \"Step\" maybe.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: Sort points by x_end ascending // 以右邊界升序排列氣球\n\n→ Step 2: Set arrows = 0, current_end = -∞ // 初始化箭數和當前箭擊中範圍\n\n→ Step 3: For each balloon in sorted points // 遍歷所有氣球\n\n    → Decision: 是否 balloon.x_start <= current_end? // 判斷該氣球是否已被現有箭擊中\n\n        Yes → Continue // 已被擊中，跳過\n\n        No  → Step 4: arrows = arrows + 1 // 需要發射新箭\n\n            → Step 5: current_end = balloon.x_end // 更新箭的終點為該氣球的右邊界\n\n→ End // 程式結束，返回 arrows\n\nBut we need to produce code lines exactly following format: \"虛擬碼步驟 [空格] // 解釋\". And each line preceded by arrow? Actually the example uses \"→ Step 1:\" etc. So each line start with \"→\" then step description. Indentation for decisions uses spaces. So we need to produce exactly lines. Provide \"Decision:\" lines. Provide arrow \"→\" before each. For nested lines, indent with spaces. So produce:\n\nStart // 程式開始執行\n→ Step 1: Sort points by x_end ascending // 以右邊界升序排列氣球\n→ Step 2: Set arrows = 0, current_end = -∞ // 初始化箭數和現有箭的覆蓋範圍\n→ Step 3: For each balloon in sorted points // 遍歷每個氣球\n    → Decision: balloon.x_start <= current_end? // 判斷氣球是否已被現有箭擊中\n        Yes → Continue // 已被擊中，跳過\n        No  → Step 4: arrows = arrows + 1 // 需要新箭\n            → Step 5: current_end = balloon.x_end // 更新箭的終點為該氣球右邊界\nEnd // 程式執行結束，返回箭數\n\nWe need to maybe include \"Return arrows\" line after end. But the format has End. In example, they show End // 程式執行結束. So we can include End. Should we also output \"Return arrows\" inside End? The pseudocode might show \"End // 返回箭數\". Let's combine: \"End // 程式結束，返回 arrows\". That is fine.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort points by x_end ascending // 以右邊界升序排列氣球  \n→ Step 2: Set arrows = 0, current_end = -∞ // 初始化箭數和現有箭的覆蓋範圍  \n→ Step 3: For each balloon in sorted points // 遍歷每個氣球  \n  → Decision: balloon.x_start <= current_end? // 判斷氣球是否已被現有箭擊中  \n   Yes → Continue // 已被擊中，跳過  \n   No  → Step 4: arrows = arrows + 1 // 需要新箭  \n    → Step 5: current_end = balloon.x_end // 更新箭的終點為該氣球右邊界  \nEnd // 程式結束，返回箭數",
      "generated_code": "import sys\nimport ast\n\ndef find_min_arrow_shots(points):\n    \"\"\"\n    返回擊破所有氣球所需的最小箭數。\n    算法：先根據右端點升序排序，然後贪心選擇箭的位置。\n    \"\"\"\n    if not points:\n        return 0\n\n    # 以右端點為關鍵字排序\n    points.sort(key=lambda x: x[1])\n\n    arrows = 1                 # 至少需要一支箭\n    current_end = points[0][1] # 当前箭能擊中的最右端點\n\n    # 從第二個氣球開始遍歷\n    for start, end in points[1:]:\n        # 若下一個氣球的左端點在 current_end 右側，則需要新箭\n        if start > current_end:\n            arrows += 1\n            current_end = end\n\n    return arrows\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析輸入，預期格式類似 \"points = [[10,16],[2,8],[1,6],[7,12]]\"\n    try:\n        # 找到等號後的部分，並安全評估為 Python 資料結構\n        _, _, value_part = raw_input.partition('=')\n        points = ast.literal_eval(value_part.strip())\n    except Exception:\n        # 若解析失敗，假設整個輸入就是列表\n        points = ast.literal_eval(raw_input)\n\n    result = find_min_arrow_shots(points)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,2],[3,4],[5,6],[7,8]]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "points = [[1,2],[2,3],[3,4],[4,5]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode123.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock III",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the i^th day.\n\nFind t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step by step. It's classic two transaction max profit. Approach: iterate once, track max profit up to day i with 0,1,2 transactions, or do forward and backward passes. For simplicity, use DP with four variables: firstBuy, firstSell, secondBuy, secondSell. Start with firstBuy = -inf, firstSell=0, secondBuy=-inf, secondSell=0. For each price p: firstBuy = max(firstBuy, -p); firstSell = max(firstSell, firstBuy+p); secondBuy = max(secondBuy, firstSell - p); secondSell = max(secondSell, secondBuy + p). End: return secondSell. Need to produce virtual code step by step with explanations. Also we need to use Start, End, Decision etc. Provide each line.\n\nWe must output each line like \"Start // 程式開始執行\". Use arrow notation. Let's produce code. The steps: initialization, loop start, inside loop update variables. At end return.\n\nNeed to incorporate decision? The algorithm is sequential updates, not decision based. Could incorporate Decision:  if i < len(prices) maybe? But simpler: \"→ For each price p in prices:\". Use arrow. For each price, do updates. We'll produce pseudo-code lines:\n\nStart // 程式開始\n→ Step 1: firstBuy ← -∞, firstSell ← 0, secondBuy ← -∞, secondSell ← 0 // 初始化四個變數\n→ Step 2: For each p in prices: // 遍歷每個股價\n    → Step 3: firstBuy ← max(firstBuy, -p) // 可能在今天買進，更新第一次買進的最佳負值\n    → Step 4: firstSell ← max(firstSell, firstBuy + p) // 可能在今天賣出，更新第一次賣出的最佳利潤\n    → Step 5: secondBuy ← max(secondBuy, firstSell - p) // 可能在今天再次買進，更新第二次買進的最佳值\n    → Step 6: secondSell ← max(secondSell, secondBuy + p) // 可能在今天賣出第二次，更新第二次賣出的最佳利潤\nEnd // 程式結束\n\nWe might need to return result: \"→ Step 7: Return secondSell // 回傳最多兩筆交易的最大利潤\". Add to End maybe after loop. Let's produce.\n\nEnsure formatting lines: each line \"→ Step X: ... // ...\". For decisions, we don't need but we can include \"Decision:\" if we want to show conditional? In Step 3 etc we use \"←\" but the format expects \"Step:\". We can use \"→ Step 3: firstBuy ← max(firstBuy, -p) // ...\". Good.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: firstBuy ← -∞, firstSell ← 0, secondBuy ← -∞, secondSell ← 0 // 初始化四個變數，用來追蹤四種交易狀態  \n→ Step 2: For each p in prices: // 遍歷每一天的股價  \n → Step 3: firstBuy ← max(firstBuy, -p) // 可能今天買進，更新第一次買進的最佳負值  \n → Step 4: firstSell ← max(firstSell, firstBuy + p) // 可能今天賣出，更新第一次賣出的最佳利潤  \n → Step 5: secondBuy ← max(secondBuy, firstSell - p) // 可能今天再次買進，更新第二次買進的最佳值  \n → Step 6: secondSell ← max(secondSell, secondBuy + p) // 可能今天賣出第二次，更新第二次賣出的最佳利潤  \n→ Step 7: Return secondSell // 回傳最多兩筆交易的最大利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_profit(prices):\n    if not prices:\n        return 0\n    buy1 = float('-inf')\n    sell1 = 0\n    buy2 = float('-inf')\n    sell2 = 0\n    for p in prices:\n        buy1 = max(buy1, -p)\n        sell1 = max(sell1, buy1 + p)\n        buy2 = max(buy2, sell1 - p)\n        sell2 = max(sell2, buy2 + p)\n    return sell2\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 如果輸入以 \"prices =\" 開頭，去掉前綴\n    if data.lower().startswith(\"prices\"):\n        data = data.split(\"=\", 1)[1].strip()\n    try:\n        prices = ast.literal_eval(data)\n    except Exception:\n        # 若解析失敗，嘗試提取整數\n        import re\n        nums = re.findall(r\"-?\\d+\", data)\n        prices = [int(n) for n in nums]\n    print(max_profit(prices))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [3,3,5,0,0,3,1,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode57.json",
    "problem_index_in_file": 0,
    "title": "Insert Interval",
    "description_snippet": "You are given an array of non-overlapping intervals intervals where intervals[i] = [start_i, end_i] ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with comments. Steps: Start, iterate intervals, add before newInterval, merge, etc. Use Decision arrows. Should not output actual code. Use virtual code.\n\nLet's draft:\n\nStart\n→ Step 1: 初始化 result list // 空列表用來儲存結果\n→ Step 2: 取 newInterval 的 start 與 end\n→ Decision: 對於每個 interval in intervals: // 逐一處理原始區間\n    → Decision: interval.end < newInterval.start? // 原區間結束在新區間開始之前\n        Yes → Step 3: result.append(interval) // 直接加入\n        No  → Decision: interval.start > newInterval.end? // 原區間開始在新區間結束之後\n            Yes → Step 4: result.append(newInterval) // 插入新區間\n                → Step 5: newInterval = interval // 把當前區間視為新的新區間，繼續處理剩餘\n                → Decision: 是否已處理完? // 若已迴圈完畢則跳到結尾\n                No → (continue loop)\n            No  → Step 6: newInterval.start = min(newInterval.start, interval.start) // 合併起始\n                → Step 7: newInterval.end = max(newInterval.end, interval.end) // 合併結束\n                → (continue loop)\n→ Decision: newInterval 是否已加入? // 若仍在 result 中未加入\n    Yes → (已加入)\n    No  → Step 8: result.append(newInterval) // 將剩餘的新區間加入\n→ End // 返回 result\n\nNeed to include arrow lines with decisions and actions.\n\nWe should produce each line with \"→\" or \"Decision:\" accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← empty list // 初始化結果集合  \n→ Step 2: newStart ← newInterval.start, newEnd ← newInterval.end // 取新區間的起點與終點  \n\n→ Decision: 迭代 intervals 中每個 interval // 對每個原始區間逐一處理  \n    → Decision: interval.end < newStart? // 原區間結束在新區間開始之前  \n        Yes → Step 3: result.append(interval) // 直接加入結果，無需合併  \n        No  → Decision: interval.start > newEnd? // 原區間開始在新區間結束之後  \n            Yes → Step 4: result.append([newStart, newEnd]) // 插入新區間到結果  \n                → Step 5: newStart ← interval.start, newEnd ← interval.end // 以此區間作為新的待合併區間  \n                → Decision: 迴圈已結束? // 若已完成所有區間則跳出迴圈  \n                No  → (繼續迭代)  \n            No  → Step 6: newStart ← min(newStart, interval.start) // 合併起點  \n                → Step 7: newEnd ← max(newEnd, interval.end) // 合併終點  \n                → (繼續迭代)  \n\n→ Decision: 新區間是否已加入結果? // 若仍在 result 中未插入  \n    Yes → (已插入，無需額外處理)  \n    No  → Step 8: result.append([newStart, newEnd]) // 將剩餘的新區間加入結果  \n\nEnd // 程式執行結束，返回 result",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # 先把所有不與 newInterval 重疊且在前面的區間加入結果\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # 合併所有與 newInterval 有重疊的區間\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # 新區間（已合併完）加入結果\n        result.append(newInterval)\n\n        # 把剩下的區間直接加入\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中擷取 intervals 與 newInterval。\"\"\"\n    # 取得第一個區間列表\n    m1 = re.search(r'intervals\\s*=\\s*(\\[.*?\\])', data, re.S)\n    # 取得第二個區間列表\n    m2 = re.search(r'newInterval\\s*=\\s*(\\[.*?\\])', data, re.S)\n    if not m1 or not m2:\n        raise ValueError(\"輸入格式錯誤\")\n    intervals = ast.literal_eval(m1.group(1))\n    new_interval = ast.literal_eval(m2.group(1))\n    return intervals, new_interval\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    intervals, new_interval = parse_input(raw)\n    solution = Solution()\n    res = solution.insert(intervals, new_interval)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpwdbl7t5y.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpwdbl7t5y.py\", line 48, in main\n    intervals, new_interval = parse_input(raw)\n                              ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwdbl7t5y.py\", line 40, in parse_input\n    intervals = ast.literal_eval(m1.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpl1d3b1eo.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpl1d3b1eo.py\", line 48, in main\n    intervals, new_interval = parse_input(raw)\n                              ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpl1d3b1eo.py\", line 40, in parse_input\n    intervals = ast.literal_eval(m1.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode592.json",
    "problem_index_in_file": 0,
    "title": "Fraction Addition and Subtraction",
    "description_snippet": "Given a string expression representing an expression of fraction addition and subtraction, return th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: parse fraction addition/subtraction expression string, compute result as irreducible fraction. Steps: parse string, tokenization: fractions separated by '+' or '-'. Use sign. Each fraction string \"a/b\". Convert to integer numerator and denominator. Keep cumulative numerator/denominator using lcm or adding: result = sum_i sign_i * (a_i/b_i). We can maintain current fraction result_n, result_d. For each term, compute new_n = result_n * b_i + sign_i * a_i * result_d; new_d = result_d * b_i; then reduce by gcd. After all, result is numerator/denominator. Return string `${numerator}/${denominator}`.\n\nEdge: sign before first term: default '+'. Also negative numbers? fractions might be negative? Might not; but we treat sign separately.\n\nOk produce virtual code lines accordingly. Provide comments. Ensure each line with arrow.\n\nLet's produce steps: Start; Tokenize; Initialize result_n=0, result_d=1; For each token: parse sign and fraction; compute new_n, new_d; reduce; assign; End; Return string. Also handle negative sign.\n\nWe need to output virtual code line by line with comments. Use arrows. Use Decision: for sign. For each fraction.\n\nLet's produce.\n\nAlso we might use a function to compute gcd.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: token_list ← Split expression by '+' and '-' while keeping signs // 以 '+'、'-' 為分隔符並保留符號，得到每個分式字串  \n→ Step 2: result_num ← 0 // 初始化累積分子  \n→ Step 3: result_den ← 1 // 初始化累積分母  \n→ Step 4: For each token in token_list: // 逐一處理每個分式  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: token starts with '-'? // 判斷符號  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → sign ← -1 // 前面有負號  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → sign ← 1 // 前面沒有負號（默認正號）  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: fraction_str ← token stripped of leading '-' if any // 去掉符號，僅保留分式部分  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: a, b ← Parse fraction_str split by '/' into integers // 取得分子 a 與分母 b  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: new_num ← result_num * b + sign * a * result_den // 共同分母相加或相減分子  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: new_den ← result_den * b // 共同分母的乘積  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 9: g ← GCD(new_num, new_den) // 計算最大公因數  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 10: result_num ← new_num / g // 約簡分子  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 11: result_den ← new_den / g // 約簡分母  \n→ End // 所有分式處理完畢  \n→ Step 12: If result_den == 0 // 防止分母為零（理論上不會發生）  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Return error // 回傳錯誤訊息  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 13: Return string representation: result_num + \"/\" + result_den // 回傳簡化後的分式字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom fractions import Fraction\nfrom math import gcd\n\nclass Solution:\n    def fractionAddition(self, expression: str) -> str:\n        # Find all fractions with optional leading + or - signs\n        fractions = re.findall(r'[+-]?\\d+/\\d+', expression)\n        result = sum(Fraction(frac) for frac in fractions)\n        return f\"{result.numerator}/{result.denominator}\"\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    將輸入資料中「expression = \\\"...\\\"」或「expression = '...'」的內容取出。\n    若找不到，直接返回整個輸入內容（去除首尾空白）。\n    \"\"\"\n    # 支援單引號或雙引號\n    m = re.search(r'expression\\s*=\\s*[\\'\"]([^\\'\"]+)[\\'\"]', data)\n    if m:\n        return m.group(1)\n    # 直接可能就是表達式本身\n    return data.strip()\n\ndef main():\n    raw = sys.stdin.read()\n    expr = parse_input(raw)\n    sol = Solution()\n    print(sol.fractionAddition(expr))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"-1/2+1/2\"",
          "expected_output": "0/1",
          "success": true,
          "output": "0/1"
        },
        {
          "example_index": 1,
          "input": "expression = \"-1/2+1/2+1/3\"",
          "expected_output": "1/3",
          "success": true,
          "output": "1/3"
        },
        {
          "example_index": 2,
          "input": "expression = \"1/3-1/2\"",
          "expected_output": "-1/6",
          "success": true,
          "output": "-1/6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode624.json",
    "problem_index_in_file": 0,
    "title": "Maximum Distance in Arrays",
    "description_snippet": "You are given m arrays, where each array is sorted in ascending order.\nYou can pick up two integers ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps: input m arrays sorted ascending. We can pick two integers from two different arrays, compute absolute difference. Return maximum distance among all such pairs. So basically max over i<j of |max_i - min_j|? Actually arrays sorted ascending. We can pick any integer from each array. To maximize absolute difference, pick one array's largest element and another array's smallest element. But careful: choose two arrays. So maximum difference is max over all pairs of arrays of (max_i - min_j) absolute. Since difference could be negative if max_i < min_j but absolute value. So it's essentially max of max_i - min_j and max_j - min_i. Equivalent to max overall max minus min overall? Wait if we choose largest of one array and smallest of another. The absolute difference will be largest difference between any element from array A and any element from array B. Because arrays sorted, the max difference between arrays is between one array's max and another array's min. So overall max distance = max(max of all arrays) - min(min of all arrays). That's answer. So algorithm: find global max among all arrays (max of each array's last element), global min among all arrays (min of each array's first element). If only one array? Problem says pick from two different arrays. If m<2, maybe undefined but maybe return 0. We'll handle.\n\nVirtual code: Start, input arrays, iterate over each array to get min and max, update globalMin and globalMax. Decision: if m<2? maybe return 0. Else compute difference globalMax - globalMin, return. End.\n\nProvide step-by-step with explanations.\n\nLet's produce code lines like:\n\nStart\n→ Input m // number of arrays\n→ Input arrays // read each sorted array\n→ Initialize globalMin = +∞ // store minimum\n→ Initialize globalMax = -∞ // store maximum\n→ For each array i from 1 to m:\n    → Set arrMin = first element of array i\n    → Set arrMax = last element of array i\n    → Update globalMin = min(globalMin, arrMin)\n    → Update globalMax = max(globalMax, arrMax)\n→ Decision: 如果 m < 2? // check if at least two arrays\n    Yes → Step: 輸出 0 // cannot pick two different arrays\n    No  → Step: 計算 maxDistance = globalMax - globalMin\n        → Output maxDistance\nEnd\n\nAdd comments. Ensure each line has virtual code then comment.\n\nLet's write.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Input m // 讀取陣列數量\n→ Input arrays // 讀取每個已排序的陣列\n→ Initialize globalMin = +∞ // 記錄全域最小值\n→ Initialize globalMax = -∞ // 記錄全域最大值\n→ Decision: 如果 m < 2? // 檢查是否至少有兩個陣列\n    Yes → Output 0 // 沒法從兩個不同陣列挑選，返回 0\n    No  →\n        → For i = 1 to m: // 逐一遍歷每個陣列\n            → Set arrMin = arrays[i][0] // 陣列 i 的最小值\n            → Set arrMax = arrays[i][-1] // 陣列 i 的最大值\n            → Update globalMin = min(globalMin, arrMin) // 更新全域最小值\n            → Update globalMax = max(globalMax, arrMax) // 更新全域最大值\n        → Set maxDistance = globalMax - globalMin // 計算最大距離\n        → Output maxDistance // 輸出結果\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxDistance(self, arrays):\n        \"\"\"Return the maximum absolute difference between two integers taken from two different sorted arrays.\"\"\"\n        n = len(arrays)\n        if n < 2:\n            # Less than two arrays – cannot pick two different elements\n            return 0\n\n        # Initialise with the first array's extremes\n        min_val = arrays[0][0]\n        max_val = arrays[0][-1]\n        res = 0\n\n        # Iterate over the remaining arrays\n        for arr in arrays[1:]:\n            # Candidate distances: largest from current vs global smallest,\n            # and global largest vs smallest from current\n            res = max(res, abs(arr[-1] - min_val), abs(max_val - arr[0]))\n            # Update global extremes for the next iterations\n            min_val = min(min_val, arr[0])\n            max_val = max(max_val, arr[-1])\n\n        return res\n\ndef main():\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # Extract the expression after '=' if present\n    if '=' in raw_input:\n        _, expr = raw_input.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = raw_input\n\n    # Safely evaluate the list of arrays\n    try:\n        arrays = ast.literal_eval(expr)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        return\n\n    # Compute and output the result\n    sol = Solution()\n    result = sol.maxDistance(arrays)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arrays = [[1,2,3],[4,5],[1,2,3]]",
          "expected_output": " 4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": " arrays = [[1],[1]]",
          "expected_output": " 0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode20.json",
    "problem_index_in_file": 0,
    "title": "Valid Parentheses",
    "description_snippet": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the in...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Each line includes virtual code step + space + comment. Must use Start, End, Decision: arrows. We'll produce algorithm: use stack, iterate over chars. For each char: if opening, push; if closing, check stack top matches, if not invalid. After loop, if stack empty valid. We'll produce steps accordingly.\n\nWe must output in traditional Chinese. Let's craft steps:\n\nStart\n→ Step 1: 初始化空棧 stack // 建立存放開括號的棧\n→ Step 2: 對於 s 中每個字符 ch 循環 // 逐字符檢查\n    → Decision: ch 是否為開括號 '('、'{'、'['? // 判斷開括號\n        Yes → Step 3: 將 ch 推入 stack // 存入棧\n        No → Decision: ch 是否為閉括號 ')'、'}'、']'? // 判斷閉括號\n            Yes → Decision: stack 是否為空? // 檢查棧是否有對應開括號\n                Yes → Step 4: 回傳 False // 沒有對應開括號\n                No  → Step 5: pop_top = stack.pop() // 取出最上開括號\n                        Decision: pop_top 與 ch 的類型是否匹配? // 檢查類型\n                            Yes → Step 6: 繼續下一個字符 // 正常匹配\n                            No  → Step 7: 回傳 False // 類型不符\n            No  → Step 8: 繼續下一個字符 // 非括號字符忽略\n→ Step 9: 循環結束 // 完成所有字符檢查\n→ Decision: stack 是否為空? // 最後是否還有未匹配的開括號\n    Yes → Step 10: 回傳 True // 有效\n    No  → Step 11: 回傳 False // 未匹配\nEnd // 程式結束\n\nBut we must ensure format: each line \"虛擬碼步驟 [space] // 解釋\". Also need arrows in lines? The example uses \"→ Step 1: ...\" and \"Decision:\" with indent for nested. Let's follow similar.\n\nWe'll use proper indentation with 4 spaces maybe? We'll mimic example style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空棧 stack // 建立用來存放開括號的棧  \n→ Step 2: 對於 s 中每個字符 ch 循環 // 逐字符檢查  \n    → Decision: ch 是否為開括號 '('、'{'、'['? // 判斷是否為開括號  \n        Yes → Step 3: 將 ch 推入 stack // 將開括號壓入棧  \n        No  → Decision: ch 是否為閉括號 ')'、'}'、']'? // 判斷是否為閉括號  \n            Yes → Decision: stack 是否為空? // 檢查棧中是否有對應開括號  \n                Yes → Step 4: 回傳 False // 沒有對應開括號，非法  \n                No  → Step 5: pop_top = stack.pop() // 取出棧頂開括號  \n                        Decision: pop_top 與 ch 的類型是否匹配? // 檢查類型是否相符  \n                            Yes → Step 6: 繼續下一個字符 // 正常匹配，進行下一輪  \n                            No  → Step 7: 回傳 False // 類型不符，非法  \n            No  → Step 8: 繼續下一個字符 // 非括號字符直接忽略  \n→ Step 9: 循環結束 // 所有字符已檢查完畢  \n→ Decision: stack 是否為空? // 檢查是否還有未匹配的開括號  \n    Yes → Step 10: 回傳 True // 完全匹配，合法  \n    No  → Step 11: 回傳 False // 仍有未匹配的開括號，非法  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        Check if the string s containing parentheses is valid.\n        \"\"\"\n        stack = []\n        mapping = {')': '(', '}': '{', ']': '['}\n\n        for char in s:\n            if char in mapping:                     # char is a closing bracket\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else:                                   # char is an opening bracket\n                stack.append(char)\n\n        return not stack\n\ndef main() -> None:\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n\n    # Parse the input string\n    if '=' in data:\n        # Input format like: s = \"()\"\n        _, value = data.split('=', 1)\n        s = value.strip()\n    else:\n        # Input might be just the parentheses string\n        s = data\n\n    # Remove surrounding quotes if present\n    if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n        s = s[1:-1]\n\n    # Evaluate validity\n    solution = Solution()\n    result = solution.isValid(s)\n\n    # Output result in lower case\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"()[]{}\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"(]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 3,
          "input": "s = \"([])\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 4,
          "input": "s = \"([)]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode204.json",
    "problem_index_in_file": 0,
    "title": "Count Primes",
    "description_snippet": "Given an integer n, return the number of prime numbers that are strictly less than n....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for a function that given integer n returns number of primes < n. Use virtual code with arrows, Start, Decision, etc. Provide each line: \"虛擬碼步驟 // 解釋\". We need to output step by step. Probably steps: Start, check n <= 2 return 0, else create boolean array isPrime size n, initialize true for 2..n-1, set 0,1 false. Then Sieve of Eratosthenes: for i from 2 to sqrt(n-1), if isPrime[i] then mark multiples i*i to n-1 step i false. Then count primes: iterate i from 2 to n-1, if isPrime[i] count++. Return count. End.\n\nBut using virtual code style: \"Start\", \"→ Step 1: ...\", \"→ Decision: ...\", \"Yes → ...\", \"No → ...\" etc.\n\nWe need to output lines in order. Use \"Start // 程式開始執行\". Then \"→ Step 1: 檢查 n 是否小於等於 2? // 低於 2 沒有素數\" then decision. Yes → Step 2: 回傳 0 // 結束. No → continue. Then \"→ Step 3: 建立布林陣列 isPrime[0..n-1] 並將 0,1 設為 false, 其餘 true // 初始化素數標記\". Then \"→ Step 4: 進行埃拉托斯特尼篩選\" which may be a loop. We could break into steps: \"→ Decision: 是否需要進行篩選? // i <= sqrt(n-1)\" etc. But maybe simpler: \"→ Step 4: 從 i=2 到 sqrt(n-1) 迴圈\" and inside another loop.\n\nWe must follow format. Use \"Decision:\" lines. We'll have nested decisions for the sieve.\n\nSimplify: use \"→ Step 4: For i from 2 to floor(sqrt(n-1))\". Then \"→ Decision: 如果 isPrime[i] 為真? // 檢查 i 是否為素數\". Yes -> \"→ Step 5: 將 i 的倍數從 i*i 開始標記為非素數\". That includes inner loop \"→ Step 5a: For j from i*i to n-1 step i\". Then inside mark false. After loops finish, we go to count.\n\nThen \"→ Step 6: 計算素數個數\" then loop over i from 2 to n-1, if isPrime[i] count++. Then \"→ Step 7: 回傳 count\". End.\n\nMake sure each line uses \"→\" or \"Decision:\". Use \"Yes →\" and \"No →\".\n\nLet's craft:\n\nLine 1: Start // 程式開始執行\nLine 2: → Step 1: 檢查 n 是否小於等於 2? // 沒有小於 n 的素數\nLine 3:     Yes → Step 2: 回傳 0 // n <= 2 時直接回傳 0\nLine 4:     No  → Step 3: 建立布林陣列 isPrime[0..n-1] 並將 0,1 設為 false，其餘為 true // 初始化素數標記\nLine 5: → Step 4: 進行埃拉托斯特尼篩選\nLine 6:     → Decision: i <= floor(sqrt(n-1))? // 迴圈條件\nLine 7:         Yes → Step 5: 若 isPrime[i] 為真\nLine 8:             Yes → Step 6a: 從 j = i*i 到 n-1 以步長 i 將 isPrime[j] 設為 false // 標記非素數\nLine 9:             No  → Step 6b: 進行下一個 i\nLine 10:         No  → Step 6c: 迴圈結束 // 完成篩選\nLine 11: → Step 7: 計算素數個數\nLine 12:     → Decision: i <= n-1? // 迴圈條件\nLine 13:         Yes → Step 8: 若 isPrime[i] 為真，count++\nLine 14:         No  → Step 8b: 迴圈結束 // 統計完成\nLine 15: → Step 9: 回傳 count // 回傳結果\nEnd // 程式執行結束\n\nNeed to ensure each line uses \"虛擬碼步驟 // 解釋\". But the instructions say each line must contain \"虛擬碼步驟\" + space + \"// 解釋/說明\". So we need to format like:\n\nStart // 程式開始執行\n\n→ Step 1: ... // ...\n\nBut we also need arrows for each line. The example uses \"→ Step 1:\" with arrow. For decisions they use \"Decision:\" lines. So we must follow that.\n\nLet's produce final output accordingly. Ensure no actual code. Just virtual steps.\n\nCheck formatting: Each line: start with \"Start\" or \"→ ...\", etc. After space, comment. So like:\n\nStart // 程式開始執行\n\n→ Step 1: 檢查 n 是否小於等於 2? // 沒有小於 n 的素數\n\nYes → Step 2: 回傳 0 // n <= 2 時直接回傳 0\n\nNo → Step 3: 建立布林陣列 isPrime[0..n-1] 並將 0,1 設為 false，其餘為 true // 初始化素數標記\n\n→ Step 4: 進行埃拉托斯特尼篩選 // 執行篩選算法\n\nDecision: i <= floor(sqrt(n-1))? // 迴圈條件\n\nYes → Step 5: 若 isPrime[i] 為真 // 檢查 i 是否為素數\n\nYes → Step 6a: 從 j = i*i 到 n-1 以步長 i 將 isPrime[j] 設為 false // 標記非素數\n\nNo → Step 6b: 進行下一個 i // 略過非素數 i\n\nNo → Step 6c: 迴圈結束 // 完成篩選\n\n...\n\nBut need nested indentation? The example shows indent with spaces.\n\nLet's output each line exactly as example, with arrow and indentation.\n\nMake sure to include \"Decision:\" lines correctly.\n\nWe need to ensure that we have \"Decision:\" lines that branch. For example:\n\nDecision: i <= floor(sqrt(n-1))?\n\nYes → Step 5...\n\nNo → Step 6c: 迴圈結束\n\nSimilarly for counting loop.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 檢查 n 是否小於等於 2? // 判斷是否存在小於 n 的素數  \n  Yes → Step 2: 回傳 0 // n <= 2 時直接回傳 0  \n  No  → Step 3: 建立布林陣列 isPrime[0..n-1] 並將 0,1 設為 false，其餘為 true // 初始化素數標記  \n→ Step 4: 進行埃拉托斯特尼篩選 // 執行篩選算法  \n  Decision: i <= floor(sqrt(n-1))? // 迴圈條件  \n   Yes → Step 5: 若 isPrime[i] 為真 // 檢查 i 是否為素數  \n    Yes → Step 6a: 從 j = i*i 到 n-1 以步長 i 將 isPrime[j] 設為 false // 標記非素數  \n    No  → Step 6b: 進行下一個 i // 略過非素數 i  \n   No  → Step 6c: 迴圈結束 // 完成篩選  \n→ Step 7: 計算素數個數 // 累計素數個數  \n  Decision: i <= n-1? // 迴圈條件  \n   Yes → Step 8: 若 isPrime[i] 為真，count++ // 累加素數  \n   No  → Step 8b: 迴圈結束 // 統計完成  \n→ Step 9: 回傳 count // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_primes(n: int) -> int:\n    \"\"\"\n    回傳小於 n 的素數個數。\n    \"\"\"\n    if n <= 2:\n        return 0\n    # 建立布林陣列，預設為 True\n    is_prime = [True] * n\n    # 0 和 1 不是素數\n    is_prime[0] = is_prime[1] = False\n    # 執行埃拉托斯特尼篩選\n    limit = int(n ** 0.5) + 1\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    # 計算素數個數\n    return sum(is_prime)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有內容\n    data = sys.stdin.read()\n    # 取出第一個出現的整數，若無則視為 0\n    nums = re.findall(r'-?\\d+', data)\n    n = int(nums[0]) if nums else 0\n    # 計算並輸出結果\n    print(count_primes(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode264.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number II",
    "description_snippet": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. \n\nGiven an inte...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines step by step to solve nth ugly number. Use standard algorithm with three pointers or priority queue. We'll produce algorithm: initialize ugly[0]=1, p2=p3=p5=0; for i=1..n-1: next= min(ugly[p2]*2, ugly[p3]*3, ugly[p5]*5); ugly[i]=next; if next==ugly[p2]*2: p2++; if next==ugly[p3]*3: p3++; if next==ugly[p5]*5: p5++; end; return ugly[n-1]. Provide virtual code with arrows. Each line with // explanation.\n\nAlso need Start, End, Decision. Provide lines sequentially. Use \"Step\" for assignments. Provide decision branches for increment pointers. Provide loop for building array. Provide final return. Ensure each line ends with // explanation. Use \"Start // 程式開始執行\". Let's craft.\n\nWe should ensure we follow arrow formatting: \"→ Step 1: ...\" Use Decision: ... with Yes →, No → etc. For loops, we might just show \"→ Step ...\". Use Decision for loop condition? Could use Decision: if i < n? But easier: \"→ Step 2: for i from 1 to n-1\". But that is not exactly a decision arrow. But allowed. Provide minimal.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化 ugly[0] = 1 // 第一個丑數為 1\n→ Step 2: 初始化指標 p2 = p3 = p5 = 0 // 三個指標分別指向 2、3、5 的候選乘數\n→ Step 3: 初始化 i = 1 // 從第二個丑數開始計算\n→ Decision: 是否 i < n? // 判斷是否已計算到第 n 個丑數\n    Yes → Step 4: next = min(ugly[p2]*2, ugly[p3]*3, ugly[p5]*5) // 找出三個候選中的最小值\n    Yes → Step 5: ugly[i] = next // 將最小值加入丑數序列\n    Yes → Decision: next == ugly[p2]*2? // 若 next 是以 2 為因子\n        Yes → Step 6: p2 = p2 + 1 // 進一步指向下一個可能的 2 倍\n        No  → Decision: next == ugly[p3]*3? // 若 next 是以 3 為因子\n            Yes → Step 7: p3 = p3 + 1 // 進一步指向下一個可能的 3 倍\n            No  → Step 8: p5 = p5 + 1 // 否則為以 5 為因子，進一步指向下一個可能的 5 倍\n    Yes → Step 9: i = i + 1 // 進行下一個索引\n    Yes → // 返回 Decision: i < n? 的判斷（循環繼續）\n    No  → // 退出循環，完成所有丑數\n→ Step 10: return ugly[n-1] // 返回第 n 個丑數\nEnd // 程式執行結束\n\nMake sure each line ends with // 解釋. Use proper spacing. Provide arrow \"→\" at start of each step. For decisions use \"Decision:\".\n\nLet's format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 ugly[0] = 1 // 第 1 個丑數為 1  \n→ Step 2: 初始化 p2 = 0, p3 = 0, p5 = 0 // 三個指標分別指向 2、3、5 的候選乘數  \n→ Step 3: 初始化 i = 1 // 從第 2 個丑數開始計算  \n→ Decision: i < n? // 判斷是否已計算到第 n 個丑數  \n Yes → Step 4: next = min(ugly[p2]*2, ugly[p3]*3, ugly[p5]*5) // 找出三個候選中的最小值  \n Yes → Step 5: ugly[i] = next // 將最小值加入丑數序列  \n Yes → Decision: next == ugly[p2]*2? // 檢查是否為 2 的倍數  \n  Yes → Step 6: p2 = p2 + 1 // 指向下一個 2 的倍數候選  \n  No  → Decision: next == ugly[p3]*3? // 檢查是否為 3 的倍數  \n   Yes → Step 7: p3 = p3 + 1 // 指向下一個 3 的倍數候選  \n   No  → Step 8: p5 = p5 + 1 // 否則為 5 的倍數，指向下一個 5 的倍數候選  \n Yes → Step 9: i = i + 1 // 進行下一個索引  \n Yes → // 重新進入 Decision: i < n? 的判斷，循環繼續  \n No  → // i >= n，結束循環，所有丑數已計算完成  \n→ Step 10: return ugly[n-1] // 回傳第 n 個丑數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef nth_ugly_number(n: int) -> int:\n    \"\"\"返回第 n 個丑數（只包含質因數 2、3、5）。\"\"\"\n    ugly = [1]            # 以 1 為第一個丑數\n    i2 = i3 = i5 = 0      # 三個指標，分別指向下一個乘以 2、3、5 的位置\n\n    while len(ugly) < n:\n        next2 = ugly[i2] * 2\n        next3 = ugly[i3] * 3\n        next5 = ugly[i5] * 5\n        next_ugly = min(next2, next3, next5)\n\n        ugly.append(next_ugly)\n\n        # 若有多個候選相同，所有相應的指標都要前進\n        if next_ugly == next2:\n            i2 += 1\n        if next_ugly == next3:\n            i3 += 1\n        if next_ugly == next5:\n            i5 += 1\n\n    return ugly[-1]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入（支持多行或單行輸入）\n    raw_input = sys.stdin.read()\n    # 從輸入中擷取第一個出現的整數\n    match = re.search(r\"\\d+\", raw_input)\n    if match:\n        n = int(match.group())\n        result = nth_ugly_number(n)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "12",
          "success": true,
          "output": "12"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode316.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicate Letters",
    "description_snippet": "Given a string s, remove duplicate letters so that every letter appears once and only once. You must...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for removing duplicate letters while ensuring smallest lexicographical order. Standard algorithm: Use stack, track count of remaining occurrences, track visited set. For each char in s: decrement count, if visited skip; while stack not empty and top > current and count[top] > 0, pop and mark visited false; push current, mark visited true. At end join stack.\n\nWe need to produce virtual code with arrows, Start, End, Decision, etc. Provide each step with explanation. Use proper structure.\n\nWe need to be \"逐行\" output. Each line: \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows for flow.\n\nWe should include initialization steps: count occurrences, visited map, stack.\n\nImplement logic: for each char c in s: decrement count; if visited[c] true: continue; while stack not empty and stack.top > c and count[stack.top] > 0: pop stack; visited[pop] = false; push c; visited[c] = true.\n\nAfter loop, result = join stack.\n\nMake sure to include decision points: e.g., if visited? yes skip; else while condition; yes pop; else break; etc.\n\nAlso include loops: for each char. Provide pseudo arrow for loop: \"→ Loop: iterate over s characters\". Provide condition inside.\n\nWe need to output only virtual code lines, no actual code.\n\nMake sure each line ends with // explanation.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字母出現次數表 count[26] // 計算每個字母在 s 中剩餘的出現次數  \n→ Step 2: 初始化 visited[26] 為 false // 標記每個字母是否已在結果中  \n→ Step 3: 初始化空 stack // 用來構造最小字典序的字母序列  \n→ Loop: 針對 s 中每個字母 c 做下列處理 // 主迴圈遍歷整個輸入字串  \n  → Decision: 如果 visited[c] 為 true? // 已經放入堆疊的字母再次遇到  \n    Yes → Next // 跳過此字母，直接處理下一個  \n    No → Step 4: 將 count[c] 減 1 // 移除已讀取的字母，更新剩餘次數  \n     → Decision: 堆疊不為空且 stack.top > c 且 count[stack.top] > 0? // 可以安全移除較大字母  \n      Yes → Step 5: pop stack // 移除堆疊頂部字母  \n        → Step 6: visited[pop] 設為 false // 重新允許此字母被加入  \n        → 再次判斷 Decision（回到同一條件）  \n      No → Step 7: push c 到 stack // 將當前字母加入堆疊  \n        → Step 8: visited[c] 設為 true // 標記已加入結果  \n        → Next // 處理下一個字母  \n→ End Loop  \n→ Step 9: 將 stack 轉換為字串 result // 堆疊中按順序即為最小字典序結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef remove_duplicate_letters(s: str) -> str:\n    \"\"\"\n    Return the lexicographically smallest string that contains each\n    letter of s exactly once by removing duplicate letters.\n    \"\"\"\n    stack = []          # 用來構造結果的字母序列\n    seen = set()        # 標記字母是否已加入 stack\n    # 每個字母最後一次出現的位置\n    last_occurrence = {c: i for i, c in enumerate(s)}\n\n    for i, c in enumerate(s):\n        if c in seen:\n            continue  # 已經加入過，跳過\n        # 若堆疊頂部字母比當前字母大且未來仍會出現，則可移除\n        while stack and c < stack[-1] and i < last_occurrence[stack[-1]]:\n            removed = stack.pop()\n            seen.discard(removed)\n        stack.append(c)\n        seen.add(c)\n\n    return ''.join(stack)\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, process it, and print the result.\n    Expected input format: either just the string, or a line like\n    s = \"bcabc\". The output is the processed string without quotes.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 處理可能的 's = \"...\"' 格式\n    if '=' in data:\n        _, value = data.split('=', 1)\n        s = value.strip().strip('\"').strip(\"'\")\n    else:\n        s = data.strip('\"').strip(\"'\")\n\n    result = remove_duplicate_letters(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"bcabc\"",
          "expected_output": "\"abc\"",
          "success": true,
          "output": "abc"
        },
        {
          "example_index": 1,
          "input": "s = \"cbacdcbc\"",
          "expected_output": "\"acdb\"",
          "success": true,
          "output": "acdb"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode432.json",
    "problem_index_in_file": 0,
    "title": "All O`one Data Structure",
    "description_snippet": "Design a data structure to store the strings' count with the ability to return the strings with mini...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps, line by line, with explanation, using virtual code syntax as specified. Must describe design for AllOne data structure. Likely use doubly linked list of count nodes, each node holds count and set of keys; also a hashmap key->node. Provide operations inc, dec, getMaxKey, getMinKey. All in O(1). Provide pseudocode step by step.\n\nWe output as lines, starting with Start, etc. We should produce steps like:\n\nStart // 程式開始執行\n→ Step 1: 定義 AllOne 類別 // ... etc.\n\nWe need to explain each line.\n\nWe need to break into initialization, inc, dec, getMaxKey, getMinKey functions.\n\nUse Decision arrows for branches.\n\nLet's produce a comprehensive pseudocode:\n\nStart\n→ Step 1: Define AllOne class // ...\n→ Step 2: 在 AllOne 中建立 head 和 tail 指標，指向 dummy head 和 tail 節點 // ...\n→ Step 3: 建立 key_to_node map // ...\n→ Decision: 初始狀態 // ...\nWe might just give high-level steps.\n\nBetter to list steps for each method.\n\nI will output as one continuous flow: Start, AllOne init, inc, dec, getMaxKey, getMinKey, End.\n\nBut each step must be a line with \"虛擬碼步驟\" + // explanation.\n\nUse arrows like \"→ Step X: ...\" for sequential. For decisions, use \"Decision: ...\" with Yes →, No →.\n\nWe need to be careful: For inc and dec, we need to check if key exists.\n\nSo pseudocode:\n\nAllOne.Init:\n→ Step 1: create dummy head and tail nodes // ...\n→ Step 2: link head.next = tail, tail.prev = head // ...\n→ Step 3: key_to_node = empty map // ...\n→ Step 4: return // ...\n\ninc(key):\n→ Step 1: if key not in key_to_node then create node for count 1 else increment\n→ Decision: key exists? // ...\nYes → ...\nNo → ...\n\nSimilarly for dec.\n\nLet's write.\n\nAlso getMaxKey: return tail.prev.key_set[0] if not empty else \"\"\n\ngetMinKey: return head.next.key_set[0] if not empty else \"\"\n\nWe'll need to explain that key_set is set of keys.\n\nLet's produce each line. We'll include comments after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n\n→ Step 1: 定義 AllOne 類別 // 建立一個類別來封裝資料結構  \n→ Step 2: 在 AllOne 中建立兩個 dummy 節點 head 與 tail，並將 head.next 指向 tail、tail.prev 指向 head // 用於維護一個空的雙向連結串列  \n→ Step 3: 建立 key_to_node 映射，鍵為 string，值為指向 CountNode 的指標 // 用於 O(1) 取得某個 key 所在的節點  \n→ Step 4: 定義 CountNode 結構，包含 count、keys（set of string）、prev、next // 每個節點代表一個計數值  \n\n// ---------- 初始化 ----------\n→ Step 5: AllOne() 初始化函式 // 建構子  \n→ Decision: 是否已有任何元素？ // 初始時沒有  \n    No  → Step 6: 只保留 head 與 tail，key_to_node 為空 // 這樣可以直接操作連結串列  \n\n// ---------- inc ----------\n→ Step 7: inc(key) // 進行遞增操作  \n→ Decision: key 是否存在於 key_to_node？ // 檢查 key 是否已存在  \n    Yes → Step 8: node = key_to_node[key] // 取得現有節點  \n        → Step 9: next_node = node.next // 取得後續節點  \n        → Decision: next_node 是否存在且 next_node.count == node.count + 1？ // 檢查是否已經有下一個計數節點  \n            Yes → Step 10: next_node.keys.add(key) // 把 key 加到下一個節點  \n            No  → Step 11: create new_node with count = node.count + 1, keys = {key} // 建立新節點  \n                  → Step 12: 插入 new_node 於 node 與 next_node 之間  \n        → Step 13: node.keys.remove(key) // 從舊節點移除 key  \n        → Decision: node.keys 是否為空？ // 判斷是否要刪除舊節點  \n            Yes → Step 14: 刪除 node，更新連結串列  \n            No  → Step 15: 保留 node  \n        → Step 16: key_to_node[key] = new_node or next_node // 更新映射  \n    No  → Step 17: // key 為新 key  \n        → Decision: head.next 是否為 tail 或 head.next.count == 1？ // 判斷是否已有 count=1 節點  \n            Yes → Step 18: head.next.keys.add(key) // 加入已有節點  \n            No  → Step 19: create node1 with count=1, keys={key}  \n                  → Step 20: 插入 node1 於 head 與 head.next 之間  \n        → Step 21: key_to_node[key] = node1 或 head.next // 更新映射  \n\n// ---------- dec ----------\n→ Step 22: dec(key) // 進行遞減操作  \n→ Decision: key 是否存在於 key_to_node？ // 由題目保證一定存在  \n    Yes → Step 23: node = key_to_node[key] // 取得節點  \n        → Step 24: prev_node = node.prev // 取得前一節點  \n        → Decision: node.count == 1？ // 若計數為 1，將要移除 key  \n            Yes → Step 25: node.keys.remove(key) // 從節點移除 key  \n                  → Step 26: delete node from linked list // 刪除整個節點  \n                  → Step 27: remove key from key_to_node // 刪除映射  \n            No  → Step 28: Decision: prev_node.count == node.count - 1？ // 檢查是否已有前一計數節點  \n                Yes → Step 29: prev_node.keys.add(key) // 把 key 加到前一節點  \n                No  → Step 30: create new_node with count = node.count - 1, keys = {key} // 建立新節點  \n                      → Step 31: 插入 new_node 於 prev_node 與 node 之間  \n            → Step 32: node.keys.remove(key) // 從舊節點移除 key  \n            → Decision: node.keys 是否為空？ // 判斷是否要刪除舊節點  \n                Yes → Step 33: 刪除 node，更新連結串列  \n                No  → Step 34: 保留 node  \n            → Step 35: key_to_node[key] = prev_node or new_node // 更新映射  \n\n// ---------- getMaxKey ----------\n→ Step 36: getMaxKey() // 取得最大計數的 key  \n→ Decision: tail.prev == head？ // 判斷是否有任何元素  \n    Yes → Step 37: return \"\" // 沒有元素，回傳空字串  \n    No  → Step 38: return any element from tail.prev.keys // 直接回傳任一 key  \n\n// ---------- getMinKey ----------\n→ Step 39: getMinKey() // 取得最小計數的 key  \n→ Decision: head.next == tail？ // 判斷是否有任何元素  \n    Yes → Step 40: return \"\" // 沒有元素，回傳空字串  \n    No  → Step 41: return any element from head.next.keys // 直接回傳任一 key  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass Node:\n    def __init__(self):\n        self.keys = set()\n        self.prev = None\n        self.next = None\n        self.count = 0\n\nclass AllOne:\n    def __init__(self):\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}\n\n    def _insert_after(self, prev_node, count):\n        node = Node()\n        node.count = count\n        node.prev = prev_node\n        node.next = prev_node.next\n        prev_node.next.prev = node\n        prev_node.next = node\n        return node\n\n    def _remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key):\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            next_count = node.count + 1\n            if node.next == self.tail or node.next.count > next_count:\n                new_node = self._insert_after(node, next_count)\n            else:\n                new_node = node.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            if self.head.next == self.tail or self.head.next.count > 1:\n                new_node = self._insert_after(self.head, 1)\n            else:\n                new_node = self.head.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n\n    def dec(self, key):\n        if key not in self.key_to_node:\n            return\n        node = self.key_to_node[key]\n        node.keys.remove(key)\n        prev_count = node.count - 1\n        if prev_count == 0:\n            del self.key_to_node[key]\n        else:\n            if node.prev == self.head or node.prev.count < prev_count:\n                new_node = self._insert_after(node.prev, prev_count)\n            else:\n                new_node = node.prev\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self):\n        if self.tail.prev == self.head:\n            return \"\"\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self):\n        if self.head.next == self.tail:\n            return \"\"\n        return next(iter(self.head.next.keys))\n\ndef main():\n    lines = [line.strip() for line in sys.stdin if line.strip() != \"\"]\n    if not lines:\n        return\n    # Remove optional \"Input\" header\n    if lines[0].lower().startswith(\"input\"):\n        lines = lines[1:]\n    if not lines:\n        return\n    methods = json.loads(lines[0])\n    args_list = json.loads(lines[1]) if len(lines) > 1 else []\n\n    obj = AllOne()\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"AllOne\":\n            results.append(None)\n        elif method == \"inc\":\n            obj.inc(*args)\n            results.append(None)\n        elif method == \"dec\":\n            obj.dec(*args)\n            results.append(None)\n        elif method == \"getMaxKey\":\n            results.append(obj.getMaxKey())\n        elif method == \"getMinKey\":\n            results.append(obj.getMinKey())\n\n    print(\"Output\")\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "success": true,
          "output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode344.json",
    "problem_index_in_file": 0,
    "title": "Reverse String",
    "description_snippet": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for reversing a string in place, array of characters. Steps: start, set left=0, right=len-1, loop while left<right, swap s[left] and s[right], increment left, decrement right, end loop, end. Provide each line with // explanation. Use arrows and Decision. Let's follow format.\n\nWe need to output step-by-step.\n\nWe'll produce:\n\nStart // start\n\n→ Step 1: Set left = 0 // initialize left pointer\n\n→ Step 2: Set right = length of s - 1 // initialize right pointer\n\n→ Decision: 是否 left < right? // check if pointers have crossed\n\n    Yes → Step 3: Swap s[left] 和 s[right] // exchange characters\n\n    Yes → Step 4: left = left + 1 // move left pointer\n\n    Yes → Step 5: right = right - 1 // move right pointer\n\n    Yes → Go back to Decision // repeat loop\n\n    No  → End // finished\n\nBut we need \"Yes →\" for each step? Actually in format, after Decision we list branches with Yes → ... No → ... Each branch should lead to next step. So we can structure:\n\n→ Decision: left < right? // compare pointers\n\n    Yes → Step 3: swap s[left] with s[right] // swap\n\n    Yes → Step 4: left = left + 1 // increment left\n\n    Yes → Step 5: right = right - 1 // decrement right\n\n    Yes → Go back to Decision // loop\n\n    No  → End // exit\n\nBut we need to use \"→\" for sequential steps, but branches after Decision should be Yes → Step, No → ... So we could embed multiple Yes lines but each Yes goes to a single step? Typically after Decision, we choose a single branch. But we have multiple operations within the loop. We can treat it as:\n\n→ Decision: left < right? // check condition\n\n    Yes → Step 3: swap s[left] with s[right] // swap\n\n    Yes → Step 4: left = left + 1 // increment\n\n    Yes → Step 5: right = right - 1 // decrement\n\n    Yes → Go back to Decision // loop again\n\n    No  → End // exit\n\nBut that's not typical, but acceptable as per specification? They didn't forbid multiple Yes branches, but it's weird. We can restructure: After swapping, we go to increment step then go back. Use separate Decision only for the loop condition. So:\n\nStart\n\n→ Step 1: left = 0\n\n→ Step 2: right = len(s) - 1\n\n→ Decision: left < right? // loop condition\n\n    Yes → Step 3: swap s[left] and s[right]\n\n    Yes → Step 4: left = left + 1\n\n    Yes → Step 5: right = right - 1\n\n    Yes → Go back to Decision\n\n    No  → End\n\nBut we have repeated Yes lines for the same branch. Usually we should have a single Yes → Step. But we can chain steps after a single Yes: maybe combine them: Yes → Step 3: swap..., Step 4: left++, Step 5: right--, then go back. But we can't express multi-step in one line. Maybe we can express as:\n\n    Yes → Step 3: swap s[left] and s[right] // swap\n\n    Yes → Step 4: left = left + 1 // increment\n\n    Yes → Step 5: right = right - 1 // decrement\n\n    Yes → Go back to Decision // loop\n\nOk.\n\nAlternatively, we can have \"→ Decision: left < right?\" with branches: Yes → Step 3: swap and go back. But we need to increment pointers. Maybe we can do:\n\n    Yes → Step 3: swap s[left] and s[right]; left++; right--; // combine in one line.\n\nBut we need one step per line. Could combine with semicolon? It says each line must be `虛擬碼步驟` + space + `//`. So we can write \"→ Step 3: swap s[left] and s[right]; left = left + 1; right = right - 1 // swap and move pointers\". That satisfies one line. Then we loop back. Yes.\n\nSo:\n\n→ Decision: left < right? // loop until pointers cross\n\n    Yes → Step 3: swap s[left] and s[right]; left = left + 1; right = right - 1 // exchange and move pointers\n\n    Yes → Go back to Decision // repeat loop\n\n    No  → End // exit\n\nBut \"Yes → Go back to Decision\" is a branch; but after Step 3 we automatically go back to Decision? Might need explicit branch. But we can say \"→ Decision: left < right?\" then Yes leads to Step 3. After Step 3, we go to next line which is a new Decision? That would be automatic flow. We might need \"→ Decision: left < right?\" repeated. But we can just keep as sequential: after Step 3 we go back to Decision. So we don't need separate \"Yes → Go back\". The natural flow is to loop. But spec uses arrows for flow. To be safe, we can express as:\n\n→ Decision: left < right? // loop condition\n\n    Yes → Step 3: swap s[left] and s[right]; left = left + 1; right = right - 1 // exchange and move pointers\n\n    No  → End // finish\n\nBecause after Step 3, we go back to Decision automatically (loop). That is fine.\n\nLet's produce final output accordingly.\n\nWe need to start with \"Start\". Use arrow for steps. Provide explanation. Use array s. We'll use \"len(s)\" or \"length of s\". Ok.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: left = 0 // 設定左指標為陣列起點\n→ Step 2: right = length of s - 1 // 設定右指標為陣列結尾\n→ Decision: left < right? // 檢查左右指標是否尚未相遇或交叉\n    Yes → Step 3: swap s[left] and s[right]; left = left + 1; right = right - 1 // 交換兩端字元，並將指標向中間移動\n    No  → End // 指標相遇或交叉，字元已完全反轉，程式結束\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def reverseString(self, s):\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取出等號右邊的字串（如果存在等號）\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n    else:\n        rhs = data\n    rhs = rhs.strip()\n\n    # 解析為 Python 的 list 物件\n    try:\n        s = ast.literal_eval(rhs)\n    except Exception:\n        # 若解析失敗，直接終止\n        return\n\n    # 反轉字串\n    Solution().reverseString(s)\n\n    # 輸出結果，使用 JSON 格式以符合範例輸出\n    print(json.dumps(s))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = [\"h\",\"e\",\"l\",\"l\",\"o\"]",
          "expected_output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]",
          "success": true,
          "output": "[\"o\", \"l\", \"l\", \"e\", \"h\"]"
        },
        {
          "example_index": 1,
          "input": "s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
          "expected_output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
          "success": true,
          "output": "[\"h\", \"a\", \"n\", \"n\", \"a\", \"H\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2220.json",
    "problem_index_in_file": 0,
    "title": "Minimum Bit Flips to Convert Number",
    "description_snippet": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from ei...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: given start and goal, minimal number of bit flips to convert start to goal. That's basically count of differing bits between start and goal, including leading zeros? But any bit in infinite width? Usually minimal flips equals XOR popcount. Because we can flip any bit in binary representation (including leading zeros). But if leading zeros infinite, we only consider bits up to max bits of start or goal? If we can flip any bit, we could always flip leading zeros to ones to increase number of bits; but minimal flips is just XOR popcount up to maximum bit position where either has 1. Actually flipping leading zeros beyond that adds extra flips unnecessary. So minimal flips equals popcount(start XOR goal). So algorithm: compute XOR = start XOR goal, then count set bits using built-in or loop.\n\nWe produce virtual code line-by-line with explanations.\n\nNeed to include Start, End, Decision? No decision. Just steps.\n\nPseudo:\n\nStart\n→ Step 1: Compute xor = start XOR goal // difference bits\n→ Step 2: Initialize count = 0\n→ Step 3: While xor > 0\n    → Step 4: If xor AND 1 == 1\n        → Step 5: count = count + 1\n    → Step 6: xor = xor >> 1 // shift right\n→ Step 7: Return count // minimal flips\nEnd\n\nAlso could use built-in bitcount: Step 2: count = popcount(xor). But to show generic, use loop.\n\nNeed explanation each line. Include arrow and decision? Not required but fine.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: xor = start XOR goal // 取得兩數不同的位元組合  \n→ Step 2: count = 0 // 初始化不同位元的計數  \n→ Step 3: While xor > 0 // 若仍有位元未檢查  \n  → Step 4: If (xor AND 1) == 1 // 檢查最低位是否為 1  \n     → Step 5: count = count + 1 // 這位需要翻轉  \n  → Step 6: xor = xor >> 1 // 右移一位，準備檢查下一位  \n→ Step 7: Return count // count 即為最小翻轉次數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_bit_flips(start: int, goal: int) -> int:\n    \"\"\"Return the minimum number of bit flips to convert start to goal.\"\"\"\n    xor = start ^ goal          # bits that differ\n    flips = 0\n    while xor:\n        flips += xor & 1        # count the lowest set bit\n        xor >>= 1\n    return flips\n\ndef main() -> None:\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    # Extract all integers (handles optional minus sign)\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(numbers) < 2:\n        raise ValueError(\"Input must contain two integers: start and goal.\")\n    start, goal = numbers[0], numbers[1]\n    result = min_bit_flips(start, goal)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "start = 10, goal = 7",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "start = 3, goal = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode767.json",
    "problem_index_in_file": 0,
    "title": "Reorganize String",
    "description_snippet": "Given a string s, rearrange the characters of s so that any two adjacent characters are not the same...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrow etc. Each line includes virtual code step and // explanation. The algorithm: count frequencies, use a max heap to reorder. If any char count > (len+1)/2 impossible.\n\nSteps:\nStart\n→ Step: Calculate length n\n→ Step: Count frequencies of each char\n→ Decision: If any freq > (n+1)/2 then return \"\"\n→ Step: Build max heap of (freq, char)\n→ Step: Initialize result empty string\n→ Decision: While heap not empty\n   → Step: Pop top char1\n   → Decision: If result not empty and result.last == char1 then\n        → Step: Pop next top char2\n        → Step: Append char2 to result\n        → Step: Decrease freq char2, if >0 push back\n        → Step: Push back char1\n   → Else\n        → Step: Append char1 to result\n        → Step: Decrease freq char1, if >0 push back\n→ Step: Return result\n\nNeed to reflect arrow for decisions and loops.\n\nMake sure each line ends with // explanation.\n\nLet's craft.\n\nUse Start, End.\n\nWe need virtual code with arrows and decisions.\n\nWe'll write:\n\nStart // 程式開始執行\n→ Step 1: n ← length of s // 取得字串長度\n→ Step 2: freq ← count occurrences of each character in s // 計算每個字元出現頻率\n→ Decision: any freq > (n+1)/2? // 判斷是否有字元太多\n    Yes → Step 3: return \"\" // 不能重排，直接回傳空字串\n    No  → \n→ Step 4: heap ← max-heap of (freq, char) from freq // 建立最大堆疊以取得出現頻率最高的字元\n→ Step 5: result ← \"\" // 初始化結果字串\n→ Decision: heap is not empty? // 循環處理堆疊\n    Yes → \n        → Step 6: (cnt1, ch1) ← pop heap // 取出頻率最高的字元\n        → Decision: result is not empty and last character of result == ch1? // 檢查是否與前一個字元相同\n            Yes → \n                → Step 7: (cnt2, ch2) ← pop heap // 取出第二高頻的字元\n                → Step 8: result ← result + ch2 // 加入第二高頻字元\n                → Step 9: cnt2 ← cnt2 - 1 // 這個字元使用一次\n                → Decision: cnt2 > 0? // 若仍有剩餘\n                    Yes → → Step 10: push (cnt2, ch2) back into heap // 放回堆疊\n                    No  → \n                → Step 11: push (cnt1, ch1) back into heap // 把最初取出的字元重新放回堆疊\n            No  → \n                → Step 12: result ← result + ch1 // 加入字元\n                → Step 13: cnt1 ← cnt1 - 1 // 這個字元使用一次\n                → Decision: cnt1 > 0? // 若仍有剩餘\n                    Yes → → Step 14: push (cnt1, ch1) back into heap // 放回堆疊\n                    No  → \n        → Decision: heap is not empty? // 迴圈是否繼續\n            Yes → Go back to Decision step 4\n            No  → \n→ Step 15: return result // 回傳重排後的字串\nEnd // 程式執行結束\n\nWe need arrows for decisions and loops. For loops we might use \"Decision: heap is not empty?\" and then Yes loop back. Use indentation.\n\nWe need to make sure each line ends with // explanation. The decision lines should include // explanation too.\n\nAlso we need to use arrow '→' after Start, End. For Decision lines, 'Decision:' and Yes/No arrows.\n\nWe'll produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length of s // 取得字串長度  \n→ Step 2: freq ← count occurrences of each character in s // 計算每個字元的出現頻率  \n→ Decision: any freq > (n+1)/2? // 判斷是否有字元太多，無法重排  \n  Yes → Step 3: return \"\" // 無法重排，直接回傳空字串  \n  No →  \n→ Step 4: heap ← max-heap of (freq, char) from freq // 建立最大堆疊，按頻率排序  \n→ Step 5: result ← \"\" // 初始化結果字串  \n→ Decision: heap is not empty? // 若堆疊還有字元，繼續重排  \n  Yes →  \n   → Step 6: (cnt1, ch1) ← pop heap // 取出頻率最高的字元  \n   → Decision: result is not empty and last character of result == ch1? // 檢查是否與前一個字元相同  \n     Yes →  \n      → Step 7: (cnt2, ch2) ← pop heap // 取出第二高頻字元  \n      → Step 8: result ← result + ch2 // 加入第二高頻字元  \n      → Step 9: cnt2 ← cnt2 - 1 // 使用一次第二高頻字元  \n      → Decision: cnt2 > 0? // 仍有剩餘嗎？  \n        Yes → → Step 10: push (cnt2, ch2) back into heap // 放回堆疊  \n        No →  \n      → Step 11: push (cnt1, ch1) back into heap // 把最初取出的字元重新放回堆疊  \n     No →  \n      → Step 12: result ← result + ch1 // 加入字元  \n      → Step 13: cnt1 ← cnt1 - 1 // 使用一次字元  \n      → Decision: cnt1 > 0? // 仍有剩餘嗎？  \n        Yes → → Step 14: push (cnt1, ch1) back into heap // 放回堆疊  \n        No →  \n    → Decision: heap is not empty? // 是否還有字元待處理  \n      Yes → (回到 Decision: heap is not empty?)  \n      No →  \n→ Step 15: return result // 回傳重排後的字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def reorganizeString(self, s: str) -> str:\n        n = len(s)\n        freq = Counter(s)\n\n        # 若任一字符出現次數超過 (n+1)//2，無法重排\n        if any(v > (n + 1) // 2 for v in freq.values()):\n            return \"\"\n\n        # 建立最大堆（使用負頻率）\n        heap = [(-v, k) for k, v in freq.items()]\n        heapq.heapify(heap)\n\n        prev_freq, prev_char = 0, ''\n        res = []\n\n        while heap:\n            f, ch = heapq.heappop(heap)   # 取出頻率最高的字元\n            res.append(ch)\n            # 將上一輪使用的字元重新放回堆，確保不會連續相同\n            if prev_freq < 0:\n                heapq.heappush(heap, (prev_freq, prev_char))\n            # 更新上一輪字元資訊\n            prev_freq, prev_char = f + 1, ch\n\n        return ''.join(res)\n\n\ndef main():\n    data = sys.stdin.read()\n    # 從輸入中尋找被雙引號包圍的字串\n    m = re.search(r'\"([^\"]*)\"', data)\n    if m:\n        s = m.group(1)\n    else:\n        s = data.strip()\n\n    solution = Solution()\n    result = solution.reorganizeString(s)\n\n    # 按範例輸出帶雙引號的結果\n    print(f'\"{result}\"')\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "\"aba\"",
          "success": true,
          "output": "\"aba\""
        },
        {
          "example_index": 1,
          "input": "s = \"aaab\"",
          "expected_output": "\"\"",
          "success": true,
          "output": "\"\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode312.json",
    "problem_index_in_file": 0,
    "title": "Burst Balloons",
    "description_snippet": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it repre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the classic \"Burst Balloons\" DP problem. Provide step by step. Virtual code not actual code. Use Start, Decision, etc. Must be in Traditional Chinese. Provide each line with explanation. Should be algorithmic approach: dynamic programming over intervals, with augmented array adding 1 at both ends. Use memoization or bottom-up. Provide steps: prepare extended array, initialize DP table, iterate over lengths, for each i,j, choose k to maximize dp[i][j] = max(dp[i][k-1]+dp[k+1][j]+extended[i-1]*extended[k]*extended[j+1]). End. Also handle base cases. Provide pseudocode.\n\nWe must ensure each line is one step, no actual code. We'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 讀入陣列 nums // 取得原始氣球數字\n→ Step 2: 建立擴充陣列 balloons，首尾各加 1 // 處理邊界條件\n→ Step 3: 初始化 2D DP 陣列 dp，尺寸為 len(balloons) × len(balloons) // 用於存儲子問題結果\n→ Decision: 是否需要處理子陣列長度為 0? // 初始化基本情況\n    Yes → Step 4: 對所有 i 設置 dp[i][i] = 0 // 子陣列僅含一個氣球時沒有可得到硬幣\n    No  → ...\n→ Step 5: 從長度 2 到 balloons.length - 1 逐層擴大 // 計算所有子問題\n    → Step 6: for l in 2..len(balloons)-1\n        → Step 7: for i in 0..len(balloons)-l-1\n            → Step 8: j = i + l - 1 // 子陣列右端索引\n            → Step 9: 設 dp[i][j] = 0 // 初始化最大值\n            → Step 10: for k in i+1..j-1 // 選擇最後一個爆破的氣球\n                → Step 11: coins = dp[i][k-1] + dp[k+1][j] + balloons[i]*balloons[k]*balloons[j]\n                → Decision: coins > dp[i][j]?\n                    Yes → Step 12: dp[i][j] = coins // 更新最大值\n                    No  → ...\n→ Step 13: 回傳 dp[0][len(balloons)-1] // 取得整個陣列的最大硬幣\nEnd // 程式執行結束\n\nBut need to keep structure: use arrow lines. Each line: 虛擬碼步驟 + space + // explanation.\n\nWe should include \"Start\" line.\n\nWe can include decision lines and sub-steps accordingly.\n\nWe need to maintain indentation? In example, indentations show nested decisions.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 讀取陣列 nums // 取得原始氣球數字\n→ Step 2: 建立陣列 balloons = [1] + nums + [1] // 在兩端補 1 以處理邊界\n→ Step 3: 設定 m = len(balloons) // 總氣球數量（含補 1）\n→ Step 4: 初始化 2D 陣列 dp(m, m, 0) // dp[i][j] 儲存區間 (i,j) 的最大硬幣\n→ Decision: 是否需要基礎條件? // 設定子陣列長度為 0 的結果\n    Yes → Step 5: 對 i 在 0..m-1 設置 dp[i][i] = 0 // 單一氣球區間無硬幣\n    No → ...\n→ Step 6: 從長度 2 開始遞增至 m-1 // 逐層處理所有區間\n    → Step 7: for len_interval in 2 .. m-1\n        → Step 8: for left in 0 .. m - len_interval - 1\n            → Step 9: right = left + len_interval - 1 // 計算右端索引\n            → Step 10: dp[left][right] = 0 // 初始化此區間最大值\n            → Step 11: for mid in left+1 .. right-1\n                → Step 12: coins = dp[left][mid-1] + dp[mid+1][right] + balloons[left]*balloons[mid]*balloons[right]\n                → Decision: coins > dp[left][right]?\n                    Yes → Step 13: dp[left][right] = coins // 更新最大硬幣\n                    No → ...\n→ Step 14: 回傳 dp[0][m-1] // 整個陣列的最大硬幣\nEnd // 程式結束\n\nNeed to use arrows as \"→\". For Decision lines, use \"Decision:\" etc.\n\nLet's produce final. Ensure each line has arrow except Start and End. For nested decisions, indent with spaces before arrow? The example uses indentation. We'll follow that. Use \"Yes →\" and \"No →\". Provide explanation for each.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取陣列 nums // 取得原始氣球數字  \n→ Step 2: 建立陣列 balloons = [1] + nums + [1] // 在兩端補 1 以處理邊界  \n→ Step 3: 設定 m = len(balloons) // 總氣球數量（含補 1）  \n→ Step 4: 初始化 2D 陣列 dp(m, m, 0) // dp[i][j] 儲存區間 (i,j) 的最大硬幣  \n→ Decision: 是否需要基礎條件? // 設定子陣列長度為 0 的結果  \n&nbsp;&nbsp;Yes → Step 5: 對 i 在 0..m-1 設置 dp[i][i] = 0 // 單一氣球區間無硬幣  \n&nbsp;&nbsp;No  → …  \n→ Step 6: 從長度 2 開始遞增至 m-1 // 逐層處理所有區間  \n&nbsp;&nbsp;→ Step 7: for len_interval in 2 .. m-1  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: for left in 0 .. m - len_interval - 1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 9: right = left + len_interval - 1 // 計算右端索引  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 10: dp[left][right] = 0 // 初始化此區間最大值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 11: for mid in left+1 .. right-1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 12: coins = dp[left][mid-1] + dp[mid+1][right] + balloons[left]*balloons[mid]*balloons[right] // 计算此 mid 为最后爆破气球时可获得硬币  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: coins > dp[left][right]?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 13: dp[left][right] = coins // 更新最大硬币  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → …  \n→ Step 14: 回傳 dp[0][m-1] // 整個陣列的最大硬幣  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxCoins(self, nums):\n        # 在前後加 1 方便計算\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        # 遍歷所有長度\n        for length in range(2, n):\n            for left in range(0, n - length):\n                right = left + length\n                # i 為最後一個被戳破的氣球\n                for i in range(left + 1, right):\n                    dp[left][right] = max(\n                        dp[left][right],\n                        nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]\n                    )\n        return dp[0][n - 1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中提取陣列字串\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        nums_str = data\n    else:\n        nums_str = data[start:end + 1]\n\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        nums = []\n\n    solution = Solution()\n    print(solution.maxCoins(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,1,5,8]",
          "expected_output": "167",
          "success": true,
          "output": "167"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode166.json",
    "problem_index_in_file": 0,
    "title": "Fraction to Recurring Decimal",
    "description_snippet": "Given two integers representing the numerator and denominator of a fraction, return the fraction in ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the fraction to string conversion. Provide step by step with decisions, loops, etc. Avoid actual code. Each line: \"虛擬碼步驟 // 解釋\". Use arrow notation. We'll include Start, End, decisions. For loops, use \"While\". Use representation of map. We'll output as per example. Let's craft algorithm: handle sign, absolute values, integer part, remainder, remainder map to index, detect repeat, build string. Let's produce virtual code lines.\n\nWe need to keep each line in format: \"虛擬碼步驟 // 解釋\". Use \"→\" arrows. Example: \"Start // 程式開始\". Let's produce.\n\nWill produce about 20 lines. Use indentation. Ensure every line ends with explanation. Let's proceed.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: numerator 為 0? // 檢查分子是否為 0  \n    Yes → Step: 回傳 \"0\" // 分子為 0 時答案為 \"0\"  \n    No  → Step: 判斷正負號 // 需要先決定結果字串的符號  \n        → Step: 計算 sign ← (numerator < 0) XOR (denominator < 0) // 只要一方負則整數結果負  \n        → Step: 取得 |numerator| ← abs(numerator) // 取分子絕對值  \n        → Step: 取得 |denominator| ← abs(denominator) // 取分母絕對值  \n        → Step: integerPart ← |numerator| ÷ |denominator| // 取整數部分  \n        → Step: remainder ← |numerator| mod |denominator| // 取餘數  \n        → Step: result ← \"\" // 初始化結果字串  \n        → Step: 若 sign 為負，則 result ← \"-\" // 加上負號  \n        → Step: result ← result + integerPart.toString() // 加上整數部分  \n        → Decision: remainder 為 0? // 檢查是否無小數部分  \n            Yes → Step: 回傳 result // 若餘數為 0，直接回傳整數部分  \n            No  → Step: result ← result + \".\" // 加上小數點  \n                → Step: remainderMap ← {} // 建立餘數到位數的映射表  \n                → Step: decimalPart ← \"\" // 小數位字串  \n                → Step: pos ← 0 // 位數計數器  \n                → While: remainder ≠ 0 // 只要餘數不為 0，持續擴展小數  \n                    → Decision: remainder 在 remainderMap? // 判斷餘數是否重複  \n                        Yes → Step: repeatIndex ← remainderMap[remainder] // 取得重複開始位置  \n                            → Step: nonRepeat ← decimalPart.substring(0, repeatIndex) // 不重複部分  \n                            → Step: repeat ← decimalPart.substring(repeatIndex) // 重複部分  \n                            → Step: decimalPart ← nonRepeat + \"(\" + repeat + \")\" // 將重複部分包括於括號  \n                            → Step: break // 跳出 While 循環  \n                        No  → Step: remainderMap[remainder] ← pos // 記錄餘數出現的位置  \n                            → Step: remainder ← remainder * 10 // 將餘數左移一位  \n                            → Step: digit ← remainder ÷ |denominator| // 取得新小數位  \n                            → Step: decimalPart ← decimalPart + digit.toString() // 將新位加入小數字串  \n                            → Step: remainder ← remainder mod |denominator| // 更新餘數  \n                            → Step: pos ← pos + 1 // 位數加一  \n                → Step: result ← result + decimalPart // 將完整小數部分加入結果  \n                → Step: 回傳 result // 回傳最終字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        # Handle zero numerator\n        if numerator == 0:\n            return \"0\"\n        res = []\n        # Determine sign\n        if (numerator < 0) ^ (denominator < 0):\n            res.append(\"-\")\n        # Work with absolute values\n        numerator, denominator = abs(numerator), abs(denominator)\n        # Integer part\n        res.append(str(numerator // denominator))\n        remainder = numerator % denominator\n        # No fractional part\n        if remainder == 0:\n            return \"\".join(res)\n        # Fractional part starts\n        res.append(\".\")\n        seen = {}\n        while remainder != 0:\n            # Repeat detected\n            if remainder in seen:\n                idx = seen[remainder]\n                res.insert(idx, \"(\")\n                res.append(\")\")\n                break\n            seen[remainder] = len(res)\n            remainder *= 10\n            res.append(str(remainder // denominator))\n            remainder %= denominator\n        return \"\".join(res)\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read()\n    # Extract all integers (handles negative numbers)\n    nums = re.findall(r'-?\\d+', data)\n    if len(nums) < 2:\n        return\n    numerator, denominator = int(nums[0]), int(nums[1])\n    sol = Solution()\n    result = sol.fractionToDecimal(numerator, denominator)\n    # Output result surrounded by double quotes as per examples\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numerator = 1, denominator = 2",
          "expected_output": "\"0.5\"",
          "success": true,
          "output": "\"0.5\""
        },
        {
          "example_index": 1,
          "input": "numerator = 2, denominator = 1",
          "expected_output": "\"2\"",
          "success": true,
          "output": "\"2\""
        },
        {
          "example_index": 2,
          "input": "numerator = 4, denominator = 333",
          "expected_output": "\"0.(012)\"",
          "success": true,
          "output": "\"0.(012)\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode30.json",
    "problem_index_in_file": 0,
    "title": "Substring with Concatenation of All Words",
    "description_snippet": "You are given a string s and an array of strings words. All the strings of words are of the same len...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate a virtual code algorithm for the problem: find all starting indices of concatenated substrings in s that consist of each word in words exactly once, any permutation. All words same length.\n\nTypical solution: sliding window of size word_len * num_words, maintain hashmap of word counts, compare with target counts.\n\nWe need to output virtual code step-by-step.\n\nWe need to use virtual code arrow notation: Start, → Step, Decision: etc. Provide explanation in Chinese.\n\nWe should produce each line with virtual code then // explanation.\n\nWe'll need to show loops: for each offset from 0 to word_len-1, sliding window.\n\nOk let's craft.\n\nImportant: The virtual code lines might be many. Provide line by line.\n\nWe'll produce:\n\nStart // program start\n\n→ Step 1: Let word_len = length of words[0]; num_words = length of words; window_len = word_len * num_words // compute lengths\n\n→ Step 2: Build target_counts map from words array // frequency map\n\n→ Step 3: Initialize result list // to hold indices\n\n→ Decision: If s length < window_len? // if string too short\n\n    Yes → End // no possible substring\n\n→ For offset in 0 to word_len-1: // slide with each offset\n\n    → Step 4: Initialize left = offset, right = offset, current_counts = empty map, matched = 0 // window variables\n\n    → While right + word_len <= len(s): // while we can take a word\n\n        → Step 5: word = substring s[right:right+word_len] // current word\n\n        → right += word_len // move right pointer\n\n        → Step 6: If word in target_counts: // valid word\n\n            → current_counts[word] += 1 // increase count\n\n            → If current_counts[word] == target_counts[word]: // count matches\n\n                → matched += 1 // one word count satisfied\n\n            → While current_counts[word] > target_counts[word]: // too many of this word\n\n                → left_word = substring s[left:left+word_len] // word at left\n\n                → left += word_len\n\n                → If left_word in target_counts:\n\n                    → If current_counts[left_word] == target_counts[left_word]: // dropping a matched word\n\n                        → matched -= 1\n\n                    → current_counts[left_word] -= 1\n\n        → Else: // word not in target\n\n            → current_counts.clear() // reset counts\n\n            → matched = 0\n\n            → left = right // move left to next word\n\n        → Decision: If matched == num_words? // all words matched\n\n            → Yes → Step 7: Append left to result // starting index found\n\n    → End While\n\n→ End For\n\n→ Step 8: Return result\n\nEnd // program ends\n\nNeed to include comments after each line. Use the arrow syntax as described: \"→ Step 1: ...\" etc.\n\nWe need to include \"Decision:\" lines with Yes → and No → branches.\n\nAlso need to maintain correct indentation? Not necessary but maybe.\n\nLet's produce each line.\n\nMake sure each line has virtual code and // explanation.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: word_len ← length(words[0])  // 每個單詞的長度  \n→ Step 2: num_words ← length(words)  // 單詞總數  \n→ Step 3: window_len ← word_len * num_words  // 窗口長度（整個連接字串長度）  \n→ Step 4: target_counts ← map from words array  // 建立單詞頻率表  \n→ Step 5: result ← empty list  // 儲存符合條件的起始索引  \n→ Decision: length(s) < window_len?  // 字串長度是否不足以包含一個完整連接字串  \n    Yes → End // 直接結束，無符合子字串  \n→ For offset ← 0 to word_len - 1:  // 為每個起始偏移量建立滑動窗口  \n    → Step 6: left ← offset  // 窗口左邊界  \n    → Step 7: right ← offset  // 窗口右邊界  \n    → Step 8: current_counts ← empty map  // 當前窗口內單詞頻率表  \n    → Step 9: matched ← 0  // 目前已滿足的單詞頻率數量  \n    → While right + word_len ≤ length(s):  // 右邊界可以再取一個單詞  \n        → Step 10: word ← s.substring(right, right + word_len)  // 取得右邊的新單詞  \n        → right ← right + word_len  // 右邊界向右移動一個單詞長度  \n        → Decision: word ∈ target_counts?  // 這個單詞是否是目標單詞之一  \n            Yes →  \n                → Step 11: current_counts[word] ← current_counts[word] + 1  // 更新頻率  \n                → Decision: current_counts[word] == target_counts[word]?  // 頻率剛好滿足  \n                    Yes → matched ← matched + 1  // 有一個單詞頻率已完全匹配  \n                    No  → // 仍在進行調整，無需特別處理  \n                → While current_counts[word] > target_counts[word]:  // 該單詞出現過多  \n                    → Step 12: left_word ← s.substring(left, left + word_len)  // 左邊最舊單詞  \n                    → left ← left + word_len  // 左邊界向右移動一個單詞長度  \n                    → Decision: left_word ∈ target_counts?  \n                        Yes →  \n                            → Decision: current_counts[left_word] == target_counts[left_word]?  // 從匹配中移除  \n                                Yes → matched ← matched - 1  // 減少已匹配數量  \n                                No → // 無影響  \n                            → current_counts[left_word] ← current_counts[left_word] - 1  // 減少頻率  \n                        No → // 若左邊單詞不在目標，直接忽略  \n            No →  \n                → Step 13: current_counts.clear()  // 重置窗口頻率表  \n                → matched ← 0  // 重置已匹配數量  \n                → left ← right  // 將左邊界移至右邊界，開始新窗口  \n        → Decision: matched == num_words?  // 是否所有單詞頻率都匹配完畢  \n            Yes →  \n                → Step 14: result.append(left)  // 目前左邊界即為有效子字串起始索引  \n            No  → // 继续循环，无需任何操作  \n    → End While  \n→ End For  \n→ Step 15: return result  // 返回所有符合條件的起始索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findSubstring(self, s, words):\n        if not words or not s:\n            return []\n\n        word_len = len(words[0])\n        num_words = len(words)\n        total_len = word_len * num_words\n        if total_len > len(s):\n            return []\n\n        target_counts = Counter(words)\n        result = []\n\n        # slide window starting from each possible offset\n        for offset in range(word_len):\n            left = offset\n            right = offset\n            current_counts = Counter()\n            matched = 0\n\n            while right + word_len <= len(s):\n                word = s[right:right + word_len]\n                right += word_len\n\n                if word in target_counts:\n                    current_counts[word] += 1\n                    if current_counts[word] == target_counts[word]:\n                        matched += 1\n\n                    # too many occurrences of this word, shrink from left\n                    while current_counts[word] > target_counts[word]:\n                        left_word = s[left:left + word_len]\n                        left += word_len\n                        if left_word in target_counts:\n                            if current_counts[left_word] == target_counts[left_word]:\n                                matched -= 1\n                            current_counts[left_word] -= 1\n                else:\n                    # reset window\n                    current_counts.clear()\n                    matched = 0\n                    left = right\n\n                if matched == num_words:\n                    result.append(left)\n\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print([])\n        return\n\n    # Extract s and words from input\n    s_part, _, words_part = data.partition('words')\n    s_match = re.search(r's\\s*=\\s*[\"\\'](.*?)[\"\\']', s_part)\n    s_str = s_match.group(1) if s_match else \"\"\n\n    words_match = re.search(r'=\\s*(\\[.*\\])', words_part)\n    words_list = ast.literal_eval(words_match.group(1)) if words_match else []\n\n    sol = Solution()\n    ans = sol.findSubstring(s_str, words_list)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "success": true,
          "output": "[0, 9]"
        },
        {
          "example_index": 1,
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "success": true,
          "output": "[6, 9, 12]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode553.json",
    "problem_index_in_file": 0,
    "title": "Optimal Division",
    "description_snippet": "You are given an integer array nums. The adjacent integers in nums will perform the float division.\n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for solution. Steps: parse array, dynamic programming to find max expression string. Use recursion with memoization: for each subarray, compute best expression and value. For division, maximizing value: for left >1 maybe want to divide left by right minimized? Actually maximize result of division chain with parentheses: known problem: for numbers >1, best is to divide first by product of rest? Actually maximizing x1/x2/...xn. Parentheses affect. For maximizing, we want to minimize denominator by grouping as much as possible: i.e., x1 / (x2 / x3 / ... / xn) gives x1 * x3 * ... * xn / x2. So DP: compute best value for subarray and expression string. For len==1 value is number, expr=number. For len>1, evaluate all splits: left best and right best; value = left_val / right_val. But division non-commutative. For maximizing, we compute maximum. Also we need minimal parentheses: no redundant parentheses. If subexpression is a single number or the whole expression, no parentheses; else if chosen expression is a division, we need parentheses around subexpression unless it's top-level? Use rules: only put parentheses if subexpression length >1 and not top-level. We'll just attach parentheses around expression if it's not top level.\n\nSimplify: recursion with memo: returns value and expr. For each i<j splits: left = solve(i,k), right=solve(k+1,j). val=left.val/right.val. keep max. expr= left.expr + '/' + right.expr; if right.len>1 -> wrap with parentheses? Actually parentheses around right side when splitting? In expression \"a/(b/c)\" we need parentheses around right side. In general, we need parentheses around any subexpression that is not a single number or the entire expression. So during building, when concatenating, we may need to wrap left/right if they contain division. We'll store flag indicating if subexpr is a single number or not. For building string: if left.isSingle then left.expr else '('+left.expr+')'; same for right. But top-level should not have parentheses; but if we compute root, we won't wrap. So for root, we can decide.\n\nWe will produce virtual code line by line.\n\nLet's write steps: Start, define function MaxExpression(nums), call helper(0,n-1, isRoot=true). Helper returns (value, expr, isSingle). Use memoization map key (i,j). Inside helper: if i==j: return value=nums[i], expr=str(nums[i]), isSingle=true. Else: bestVal=-inf, bestExpr=''; bestIsSingle=false. For each split k from i to j-1: left=helper(i,k,false), right=helper(k+1,j,false). currVal = left.val / right.val. currExpr = left.expr+'/'+right.expr; // parentheses added later. if currVal>bestVal: update. After loop, determine if expression should be wrapped: if isRoot==false and (i!=0 or j!=n-1) -> maybe wrap? Actually root is true only at initial call; we will not wrap root. For subexpressions used in bigger expression, we need parentheses around if length>1. So isSingle=false for length>1. We'll just set isSingle=false. But for string building, we need to add parentheses when concatenating: In parent function, when using left or right, if they are not single, wrap with parentheses.\n\nSimpler: In helper return expr that already has necessary parentheses except top-level? For non-root, we might wrap entire expr in parentheses. So at root, skip wrapping. So in helper, after determining bestExpr, if not root: bestExpr='('+bestExpr+')'; and isSingle=false. For root: isSingle=true? maybe false. But we just need to output expression without redundant parentheses. So if we always wrap subexpr when returning, root won't have outer parentheses. Good.\n\nLet's craft virtual code accordingly.\n\nWe'll output step by step.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義函式 MaxExpression(nums) // 入口，傳入整數陣列\n→ Step 2: 初始化 memo = {} // 用於記錄子問題結果\n→ Decision: 如果 nums 只包含一個元素? // 判斷是否已到最小子陣列\n    Yes → Step 3: Return nums[0] as string // 單一數字直接回傳\n    No  → Step 4: 呼叫 Helper(0, len(nums)-1, true) // 開始遞迴，根節點需要全程無括號\n→ Step 5: Return Helper(0, len(nums)-1, true) // 最終回傳最大化表達式\n→ End // 程式執行結束\n\nStart Helper(i, j, isRoot) // i~j 為子陣列區間\n→ Decision: i == j? // 子陣列只剩一個數字\n    Yes → Step 6: Return (value=nums[i], expr=str(nums[i]), isSingle=true) // 單個數字不需括號\n    No  → Step 7: 初始化 bestVal = -∞, bestExpr = \"\" // 用於追蹤最佳子問題\n→ Step 8: 對 k 從 i 到 j-1 做分割 // 每一次切分決定左右子表達式\n    → SubStep: left = Helper(i, k, false) // 左子陣列\n    → SubStep: right = Helper(k+1, j, false) // 右子陣列\n    → SubStep: currVal = left.value / right.value // 計算當前切分的表達式值\n    → SubStep: currExpr = left.expr + \"/\" + right.expr // 先拼接子表達式\n    → Decision: currVal > bestVal? // 比較是否為目前最佳\n        Yes → Step 9: bestVal = currVal, bestExpr = currExpr // 更新最佳值與字串\n        No  → Do nothing // 留下舊最佳\n→ Step 10: // 對 bestExpr 加上必要的括號\n    → Decision: isRoot? // 根節點不需要外部括號\n        Yes → Step 11: finalExpr = bestExpr // 直接使用\n        No  → Step 12: finalExpr = \"(\" + bestExpr + \")\" // 非根節點包裝括號\n→ Step 13: Return (value=bestVal, expr=finalExpr, isSingle=false) // 結果回傳\n→ End Helper // 子問題遞迴結束\n```",
      "generated_code": "import sys\nimport ast\n\ndef optimal_division(nums):\n    \"\"\"Return the expression string that maximizes the value of the division chain.\"\"\"\n    if len(nums) == 1:\n        return str(nums[0])\n    if len(nums) == 2:\n        return f\"{nums[0]}/{nums[1]}\"\n    # For more than two numbers, place all numbers after the first inside parentheses\n    inner = \"/\".join(str(x) for x in nums[1:])\n    return f\"{nums[0]}/({inner})\"\n\nif __name__ == \"__main__\":\n    # Read the entire input, strip whitespace and parse it as a Python list\n    raw = sys.stdin.read().strip()\n    try:\n        nums = ast.literal_eval(raw)\n    except Exception:\n        # If parsing fails, assume the input is a comma-separated list without brackets\n        nums = [int(x) for x in raw.replace(',', ' ').split()]\n\n    # Ensure the input is a list of integers\n    if not isinstance(nums, list):\n        raise ValueError(\"Input must be a list of integers\")\n\n    result = optimal_division(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1000,100,10,2]",
          "expected_output": "\"1000/(100/10/2)\"",
          "success": true,
          "output": "1000/(100/10/2)"
        },
        {
          "example_index": 1,
          "input": "[2,3,4]",
          "expected_output": "\"2/(3/4)\"",
          "success": true,
          "output": "2/(3/4)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode368.json",
    "problem_index_in_file": 0,
    "title": "Largest Divisible Subset",
    "description_snippet": "Given a set of distinct positive integers nums, return the largest subset answer such that every pai...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the algorithm to find largest divisible subset. We'll design algorithm: sort array, dynamic programming longest divisible subset. Steps: Start, sort, initialize dp array length, prev array, maxLen, maxIndex. Iterate i, inner j check divisibility, update dp. After loops, reconstruct subset from maxIndex via prev. End. We need to output step lines with explanations. Each line: Virtual step + // explanation.\n\nWe must not output actual code; only steps.\n\nLet's produce.\n\nNeed to include decision branches.\n\nWe must be careful with indentation: use arrow '→' for steps. For loops we can just describe loop. For decision: if condition. Provide explanation.\n\nWe also need to handle reconstruction. Provide steps: start reconstruction, while index != -1, push to result, move to prev.\n\nLet's produce.\n\nWe might need to indicate variable names.\n\nLet's produce lines:\n\nStart // 開始執行\n→ Step 1: 輸入 nums // 取得輸入陣列\n→ Step 2: 將 nums 依升序排序 // 方便後續可除性檢查\n→ Step 3: 取得 n = nums.length // 陣列長度\n→ Step 4: 建立 dp[n]，初始值皆為 1 // dp[i] 代表到 i 為止可達的最大子集長度\n→ Step 5: 建立 prev[n]，初始值皆為 -1 // prev[i] 追蹤前一個在子集中的索引\n→ Step 6: 變數 maxLen = 1 // 目前已知最大子集長度\n→ Step 7: 變數 maxIdx = 0 // 目前已知最大子集結尾索引\n→ Decision: 是否已完成所有 i 從 0 到 n-1 之迴圈？ // 進入主迴圈\n    → For i 0 到 n-1:\n        → For j 0 到 i-1:\n            → Decision: nums[i] % nums[j] == 0 或 nums[j] % nums[i] == 0 ? // 可除性判斷\n                Yes → Decision: dp[j] + 1 > dp[i] ? // 是否能延長子集\n                    Yes → Step 8: dp[i] = dp[j] + 1 // 更新 dp\n                    Yes → Step 9: prev[i] = j // 記錄前一個索引\n                    No  → // 無需更新\n                No  → // 兩數不可互除，跳過\n        → Decision: dp[i] > maxLen ? // 更新全局最大長度\n            Yes → Step 10: maxLen = dp[i] // 更新最大長度\n            Yes → Step 11: maxIdx = i // 更新最大子集結尾索引\n            No  → // 不更新\n→ Step 12: 建立空陣列 subset // 用於儲存結果\n→ Step 13: 變數 idx = maxIdx // 從最大結尾索引開始\n→ Decision: idx != -1 ? // 開始回溯子集\n    → While idx != -1:\n        → Step 14: 將 nums[idx] 加入 subset // 將目前元素加入結果\n        → Step 15: idx = prev[idx] // 移動到前一個元素\n→ Step 16: 反轉 subset // 由尾到頭插入，需正向排列\n→ End // 程式結束\n\nWe should format each line exactly with virtual code and comment. Use arrow for steps. For loops, we may just indicate 'Loop i=0 to n-1' as step, but need to maintain structure. But we can keep it simple: we can show as 'Step X: For i from 0 to n-1' etc.\n\nHowever requirement: use virtual code arrow '→' and structure Start, End, Decision:. Loops can be described as '→ Step: For i from 0 to n-1' but that's a step. The decision for loop condition can be part of the loop.\n\nSimplify: we can not use actual loops; we can use steps that represent loops.\n\nLet's output each line with arrow and comment.\n\nBe careful to keep each line distinct.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 nums // 取得輸入陣列  \n→ Step 2: 將 nums 依升序排序 // 方便後續可除性檢查  \n→ Step 3: 取得 n = nums.length // 陣列長度  \n→ Step 4: 建立 dp[n]，全部初值為 1 // dp[i] 表示以 nums[i] 為結尾的最大子集長度  \n→ Step 5: 建立 prev[n]，全部初值為 -1 // prev[i] 追蹤前一個可除關係的索引  \n→ Step 6: 設定 maxLen = 1 // 目前已知的最大子集長度  \n→ Step 7: 設定 maxIdx = 0 // 目前已知最大子集結尾的索引  \n→ Decision: 是否完成 i 從 0 到 n-1 的迴圈？ // 進入主迴圈  \n → For i = 0 到 n-1  \n  → For j = 0 到 i-1  \n   → Decision: nums[i] % nums[j] == 0 或 nums[j] % nums[i] == 0？ // 檢查兩數是否互相可除  \n    Yes → Decision: dp[j] + 1 > dp[i]？ // 能否延長子集  \n     Yes → Step 8: dp[i] = dp[j] + 1 // 更新 dp  \n     Yes → Step 9: prev[i] = j // 記錄前一個索引  \n     No  → // 無需更新  \n    No  → // 不可互除，跳過  \n  → Decision: dp[i] > maxLen？ // 檢查是否更新全局最大值  \n   Yes → Step 10: maxLen = dp[i] // 更新最大長度  \n   Yes → Step 11: maxIdx = i // 更新最大子集結尾索引  \n   No  → // 不更新  \n→ Step 12: 建立空陣列 subset // 用於儲存結果  \n→ Step 13: 設定 idx = maxIdx // 從最大結尾索引開始回溯  \n→ Decision: idx != -1？ // 開始回溯子集  \n  → While idx != -1  \n    → Step 14: subset.push(nums[idx]) // 將目前元素加入結果  \n    → Step 15: idx = prev[idx] // 移動到前一個索引  \n→ Step 16: 反轉 subset // 使子集順序由小到大  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def largestDivisibleSubset(self, nums):\n        if not nums:\n            return []\n        nums.sort()\n        n = len(nums)\n        dp = [1] * n\n        prev = [-1] * n\n        max_index = 0\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0 and dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n                    prev[i] = j\n            if dp[i] > dp[max_index]:\n                max_index = i\n\n        res = []\n        while max_index >= 0:\n            res.append(nums[max_index])\n            max_index = prev[max_index]\n\n        return res[::-1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 尋找第一個 '[' 與最後一個 ']'\n    lpos = data.find('[')\n    rpos = data.rfind(']')\n    if lpos != -1 and rpos != -1:\n        list_str = data[lpos:rpos+1]\n        nums = ast.literal_eval(list_str)\n    else:\n        nums = ast.literal_eval(data)\n\n    sol = Solution()\n    result = sol.largestDivisibleSubset(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,4,8]",
          "expected_output": "[1,2,4,8]",
          "success": true,
          "output": "[1, 2, 4, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode705.json",
    "problem_index_in_file": 0,
    "title": "Design HashSet",
    "description_snippet": "Design a HashSet without using any built-in hash table libraries.\n\nImplement MyHashSet class:\n\nvoid ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for a HashSet implementation without built-in hash table libraries. Use array of buckets with linked lists or something. Virtual code steps with explanations, using arrows, Start, End, Decision, etc.\n\nWe need to produce step-by-step pseudo code for MyHashSet class with methods add, contains, remove. Use separate methods, maybe use array of buckets of size N. Use simple hashing: key mod N.\n\nNeed to explain each line.\n\nWe should produce multiple lines: Start, then define class, then define array, then add method, etc.\n\nWe must use virtual code arrows: → Step etc.\n\nLet's generate:\n\nStart // 程式開始執行\n→ Step 1: 定義常量 CAPACITY = 1000 // 預設哈希表桶數\n→ Step 2: 建立陣列 buckets[CAPACITY] // 每個位置存放鏈表節點\n→ Step 3: 設定 MyHashSet() 初始化所有桶為空 // 建構子\n\nThen methods:\n\n→ Step 4: 方法 add(key) // 插入鍵\n→ Decision: key 是否已存在? // 判斷重複\n   Yes → Step 5: 返回 // 已存在不重複插入\n   No → Step 6: 計算 bucketIndex = key mod CAPACITY\n→ Step 7: 取出 head = buckets[bucketIndex]\n→ Decision: head 為空? // 若桶空\n   Yes → Step 8: 建立新節點 node(key)\n           → Step 9: buckets[bucketIndex] = node // 新節點成為頭\n   No → Step 10: 將 node(key) 插入鏈表前面\n            → Step 11: node.next = head\n            → Step 12: buckets[bucketIndex] = node\n→ End // add 方法結束\n\nSimilarly contains:\n\n→ Step 13: 方法 contains(key) // 查找鍵\n→ Step 14: bucketIndex = key mod CAPACITY\n→ Step 15: node = buckets[bucketIndex]\n→ Decision: node 為空? // 無鍵\n   Yes → Step 16: 返回 false\n   No → Step 17: Decision: node.key == key? // 第一個節點\n        Yes → Step 18: 返回 true\n        No → Step 19: 迴圈 node = node.next while node != null\n            → Decision: node.key == key? // 在鏈表中尋找\n                Yes → Step 20: 返回 true\n                No → Step 21: node = node.next\n            → Step 22: 返回 false // 未找到\n→ End // contains 方法結束\n\nRemove:\n\n→ Step 23: 方法 remove(key) // 刪除鍵\n→ Step 24: bucketIndex = key mod CAPACITY\n→ Step 25: prev = null, curr = buckets[bucketIndex]\n→ Decision: curr 為空? // 沒有桶\n   Yes → Step 26: 返回 // 不存在，直接返回\n   No → Step 27: Decision: curr.key == key? // 需要刪除頭節點\n        Yes → Step 28: buckets[bucketIndex] = curr.next // 直接指向下一節點\n        No → Step 29: prev = curr, curr = curr.next\n            → Decision: curr == null? // 循環到結尾\n                Yes → Step 30: 返回 // 未找到\n                No → Decision: curr.key == key?\n                     Yes → Step 31: prev.next = curr.next // 跳過節點\n                     No → Step 32: prev = curr, curr = curr.next\n→ End // remove 方法結束\n\nEnd // 程式結束\n\nBut we need to ensure each line with arrow and explanation. Also we need to use indentation for decisions with Yes / No lines.\n\nWe'll produce the output accordingly.\n\nWe need to ensure each line is a separate line.\n\nLet's format. We'll use spaces after arrows.\n\nAlso we must start with Start and End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義常量 CAPACITY = 1000 // 設定哈希表桶的數量  \n→ Step 2: 建立陣列 buckets[CAPACITY] // 每個桶儲存鏈表節點  \n→ Step 3: MyHashSet() 初始化所有桶為空 // 建構子，將 buckets[i] = null  \n\n// ---------- add 方法 ----------\n→ Step 4: 方法 add(key) // 插入鍵  \n→ Decision: 是否已存在 key? // 先檢查是否重複  \n    Yes → Step 5: 返回 // 若已存在，直接返回  \n    No  → Step 6: bucketIndex = key mod CAPACITY // 計算對應桶索引  \n→ Step 7: head = buckets[bucketIndex] // 取出該桶的頭節點  \n→ Decision: head 為空? // 判斷桶是否為空  \n    Yes → Step 8: 建立新節點 node(key) // 新節點儲存鍵  \n           → Step 9: buckets[bucketIndex] = node // 將新節點設為桶頭  \n    No  → Step 10: node.next = head // 將新節點插入鏈表前面  \n           → Step 11: buckets[bucketIndex] = node // 更新桶頭為新節點  \n→ End // add 方法結束  \n\n// ---------- contains 方法 ----------\n→ Step 12: 方法 contains(key) // 檢查鍵是否存在  \n→ Step 13: bucketIndex = key mod CAPACITY // 找到對應桶  \n→ Step 14: node = buckets[bucketIndex] // 取出該桶頭節點  \n→ Decision: node 為空? // 沒有任何節點  \n    Yes → Step 15: 返回 false // 直接返回 false  \n    No  → Step 16: Decision: node.key == key? // 第一個節點即是目標  \n        Yes → Step 17: 返回 true // 找到，返回 true  \n        No  → Step 18: node = node.next // 進入鏈表循環  \n            → Decision: node 為 null? // 到尾部未找到  \n                Yes → Step 19: 返回 false // 未找到，返回 false  \n                No  → Decision: node.key == key? // 目前節點是否為目標  \n                    Yes → Step 20: 返回 true // 找到，返回 true  \n                    No  → Step 21: node = node.next // 繼續搜尋  \n→ End // contains 方法結束  \n\n// ---------- remove 方法 ----------\n→ Step 22: 方法 remove(key) // 刪除鍵  \n→ Step 23: bucketIndex = key mod CAPACITY // 找到對應桶  \n→ Step 24: prev = null, curr = buckets[bucketIndex] // 初始化指標  \n→ Decision: curr 為空? // 桶中沒有節點  \n    Yes → Step 25: 返回 // 不存在，直接返回  \n    No  → Decision: curr.key == key? // 是否要刪除頭節點  \n        Yes → Step 26: buckets[bucketIndex] = curr.next // 直接跳過頭節點  \n        No  → Step 27: prev = curr, curr = curr.next // 移到下一節點  \n            → Decision: curr 為 null? // 遍歷完畢仍未找到  \n                Yes → Step 28: 返回 // 未找到，返回  \n                No  → Decision: curr.key == key? // 目前節點是否為目標  \n                    Yes → Step 29: prev.next = curr.next // 刪除節點  \n                    No  → Step 30: prev = curr, curr = curr.next // 繼續搜尋  \n→ End // remove 方法結束  \n\nEnd // 程式結束執行",
      "generated_code": "import sys\nimport ast\n\nclass MyHashSet:\n    def __init__(self):\n        self.size = 10000\n        self.buckets = [set() for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def add(self, key: int) -> None:\n        h = self._hash(key)\n        self.buckets[h].add(key)\n\n    def remove(self, key: int) -> None:\n        h = self._hash(key)\n        self.buckets[h].discard(key)  # discard() 不會拋出錯誤\n\n    def contains(self, key: int) -> bool:\n        h = self._hash(key)\n        return key in self.buckets[h]\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    ops_line = data[0].strip()\n    args_line = data[1].strip()\n    try:\n        ops = ast.literal_eval(ops_line)\n        args = ast.literal_eval(args_line)\n    except Exception:\n        return\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyHashSet\":\n            obj = MyHashSet()\n            results.append(None)\n        elif op == \"add\":\n            obj.add(arg[0])\n            results.append(None)\n        elif op == \"remove\":\n            obj.remove(arg[0])\n            results.append(None)\n        elif op == \"contains\":\n            res = obj.contains(arg[0])\n            results.append(res)\n\n    # Convert results to LeetCode style string\n    formatted = []\n    for val in results:\n        if val is None:\n            formatted.append(\"null\")\n        elif isinstance(val, bool):\n            formatted.append(\"true\" if val else \"false\")\n        else:\n            formatted.append(str(val))\n    output = \"[\" + \", \".join(formatted) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]",
          "expected_output": "[null, null, null, true, false, null, true, null, false]",
          "success": true,
          "output": "[null, null, null, true, false, null, true, null, false]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode645.json",
    "problem_index_in_file": 0,
    "title": "Set Mismatch",
    "description_snippet": "You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving problem: find duplicate and missing numbers in array of 1..n with one duplicate and one missing. Approach: compute sum and sum of squares or use freq array. We'll do frequency array for simplicity. Steps: create array freq of size n+1. iterate nums, mark freq. then iterate 1..n find where freq=2 (dup) and freq=0 (miss). Output [dup, miss].\n\nProduce virtual code line by line with explanation. Use Start, Decision, etc. Need to produce step-by-step pseudocode.\n\nLet's produce:\n\nStart\n→ Step 1: let n = length(nums) // determine n\n→ Step 2: create freq array of size n+1 initialized to 0 // frequency counter\n→ Step 3: for each number num in nums // iterate through nums\n    → Step 3a: freq[num] = freq[num] + 1 // increment count\n→ Step 4: set duplicate = -1, missing = -1 // placeholders\n→ Step 5: for i from 1 to n\n    → Decision: if freq[i] == 2? // duplicate found\n        Yes → duplicate = i // record duplicate\n    → Decision: if freq[i] == 0? // missing found\n        Yes → missing = i // record missing\n→ Step 6: return array [duplicate, missing] // output\nEnd\n\nWe should include explanation after each line. Ensure we use the format: \"虛擬碼步驟 // 解釋\".\n\nLet's write in Traditional Chinese. Use \"Start // 程式開始執行\" etc. Ensure each line ends with // 解釋.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: let n = length(nums) // 確定陣列長度，亦即原始集合中元素個數  \n→ Step 2: create freq array of size n+1 initialized to 0 // 建立頻率陣列，索引 1~n 對應原始數值  \n→ Step 3: for each number num in nums // 逐一掃描輸入陣列  \n    → Step 3a: freq[num] = freq[num] + 1 // 將對應索引的計數加一  \n→ Step 4: set duplicate = -1, missing = -1 // 初始化重複數與缺失數的儲存變數  \n→ Step 5: for i from 1 to n // 依序檢查 1~n  \n    → Decision: if freq[i] == 2? // 判斷是否為重複出現的數字  \n        Yes → duplicate = i // 找到重複數，記錄  \n    → Decision: if freq[i] == 0? // 判斷是否為缺失的數字  \n        Yes → missing = i // 找到缺失數，記錄  \n→ Step 6: return array [duplicate, missing] // 回傳結果陣列，第一個元素為重複數，第二個為缺失數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findErrorNums(self, nums):\n        \"\"\"找出重複數與缺失數\"\"\"\n        n = len(nums)\n        freq = [0] * (n + 1)          # 1~n 的頻率表\n        duplicate = missing = -1\n        for num in nums:\n            freq[num] += 1\n        for i in range(1, n + 1):\n            if freq[i] == 2:\n                duplicate = i\n            elif freq[i] == 0:\n                missing = i\n        return [duplicate, missing]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料，可能是形如 \"nums = [1,2,2,4]\" 的字串\n    raw_input = sys.stdin.read().strip()\n    if raw_input.startswith(\"nums =\"):\n        raw_input = raw_input[len(\"nums =\"):].strip()\n    try:\n        nums = ast.literal_eval(raw_input)\n    except Exception:\n        # 如果輸入格式不符，直接返回空結果\n        nums = []\n    solution = Solution()\n    result = solution.findErrorNums(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2,4]",
          "expected_output": "[2,3]",
          "success": true,
          "output": "[2, 3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode458.json",
    "problem_index_in_file": 0,
    "title": "Poor Pigs",
    "description_snippet": "There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out wh...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code explaining algorithm: minimal pigs needed to identify single poisonous bucket among buckets, given time constraints. Classic problem: number of pigs = ceil(log_{(minutesToTest/minutesToDie)+1} buckets). Steps: calculate rounds = floor(minutesToTest/minutesToDie). Each pig can represent base (rounds+1) digits. Minimum pigs = ceil(log_buckets base (rounds+1)). Provide virtual code with decisions and loops. We must output step by step with explanation. Use Start, End, Decision.\n\nWe'll produce lines like:\n\nStart\n→ Step 1: Calculate rounds = minutesToTest / minutesToDie // integer division\n→ Decision: rounds > 0? // ensure at least one round\n    Yes → Step 2: base = rounds + 1 // each pig can distinguish base possibilities\n    No  → Step 3: Return 0 // no time to test\n→ Step 4: Initialize pigs = 0 // counter\n→ Step 5: temp = base // for power calculation\n→ Decision: temp^pigs < buckets? // check if current pigs enough\n    Yes → Step 6: pigs += 1 // need more pigs\n    No  → Step 7: Return pigs // minimal pigs found\n… loop back to decision until condition false.\n\nNeed to represent loop via decision and arrow.\n\nOk produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: rounds ← minutesToTest ÷ minutesToDie // 計算可以進行的完整測試輪次\n→ Decision: rounds > 0? // 檢查是否有足夠時間進行至少一輪測試\n    Yes → Step 2: base ← rounds + 1 // 每隻豬在每輪可以區分 base 種可能性\n    No  → Step 3: Return 0 // 沒有時間測試，無法辨識毒桶\n→ Step 4: pigs ← 0 // 初始化所需豬的數量\n→ Step 5: power ← base // 用於計算 base^pigs\n→ Decision: power^pigs < buckets? // 判斷目前豬數是否已足夠區分所有桶\n    Yes → Step 6: pigs ← pigs + 1 // 需要再增加一隻豬\n    No  → Step 7: Return pigs // 找到最小所需豬數，結束\n    → Back to Step 5 // 重新計算 power^pigs 以檢查新的豬數\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nimport math\n\nclass Solution:\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n        \"\"\"\n        Calculate the minimal number of pigs needed to identify the poisonous bucket.\n        Each pig can distinguish (rounds + 1) states where\n        rounds = minutesToTest // minutesToDie.\n        The number of pigs is the smallest integer p such that (rounds + 1) ** p >= buckets.\n        \"\"\"\n        rounds = minutesToTest // minutesToDie\n        states = rounds + 1\n        pigs = 0\n        # Increase pig count until the total distinguishable states cover all buckets.\n        while pow(states, pigs) < buckets:\n            pigs += 1\n        return pigs\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read()\n    # Extract integers from the input string\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 3:\n        raise ValueError(\"Input must contain three integers: buckets, minutesToDie, minutesToTest\")\n    buckets, minutesToDie, minutesToTest = nums[0], nums[1], nums[2]\n    # Compute and output the result\n    result = Solution().poorPigs(buckets, minutesToDie, minutesToTest)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 15",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 30",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode49.json",
    "problem_index_in_file": 0,
    "title": "Group Anagrams",
    "description_snippet": "Given an array of strings strs, group the anagrams together. You can return the answer in any order....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with comments. The problem: group anagrams. Approach: hash map keyed by sorted string. Steps: start, input array, loop each string, compute sorted key, add to map, after loop collect values into result list, return.\n\nNeed to follow the format exactly: each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use arrows \"→\". Use Decision if needed. Should include Start, End.\n\nSo produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義空字典 anagramMap // 用於儲存以排序字串為鍵的字串清單\n\n→ Step 2: 對每個字串 word 在 strs 迭代 // 逐一處理輸入字串\n\n→ Step 3: 取得 word 的字元排序後的字串 key = sort(word) // 產生標準鍵\n\n→ Decision: key 是否已在 anagramMap? // 檢查字典中是否已有此鍵\n\n... etc.\n\nNeed to produce a clear algorithm.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義空字典 anagramMap // 用於將排序後的字串作為鍵，對應一組原始字串  \n→ Step 2: 初始化結果列表 result = [] // 最終存放所有雜湊值的清單  \n→ Step 3: 對每個字串 word 在 strs 迭代 // 逐一處理輸入字串  \n→ Step 4: 取得 word 的字元排序後的字串 key = sort(word) // 將字串轉為標準化鍵  \n→ Decision: key 是否已在 anagramMap? // 判斷是否已存在此類型的 anagram 組  \n  Yes → Step 5: anagramMap[key].append(word) // 若存在，將字串加入對應清單  \n  No  → Step 6: anagramMap[key] = [word] // 若不存在，建立新清單並加入字串  \n→ Step 7: 迭代結束後，將 anagramMap 的所有 value 逐個追加至 result // 收集所有雜湊值  \n→ Step 8: 回傳 result // 將分組後的雜湊值輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"Group anagrams from a list of strings.\"\"\"\n        anagrams = defaultdict(list)\n        for s in strs:\n            # 以排序後的字元序列作為鍵，將同一組 anagram 放在同一列表\n            key = tuple(sorted(s))\n            anagrams[key].append(s)\n        return list(anagrams.values())\n\ndef main():\n    # 從 stdin 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將形如 'strs = [\"a\", \"b\"]' 的字串轉成真正的 Python list\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    # 以安全方式解析列表\n    try:\n        strs = ast.literal_eval(expr)\n    except Exception:\n        # 若解析失敗，直接嘗試 eval\n        strs = eval(expr)\n    # 產生答案\n    sol = Solution()\n    result = sol.groupAnagrams(strs)\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
          "success": true,
          "output": "[['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]"
        },
        {
          "example_index": 1,
          "input": "strs = [\"\"]",
          "expected_output": "[[\"\"]]",
          "success": true,
          "output": "[['']]"
        },
        {
          "example_index": 2,
          "input": "strs = [\"a\"]",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[['a']]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode546.json",
    "problem_index_in_file": 0,
    "title": "Remove Boxes",
    "description_snippet": "You are given several boxes with different colors represented by different positive numbers.\n\nYou ma...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: Remove Boxes (LeetCode 546). We should produce step-by-step pseudo-code, not actual code, with explanation after each line. Use Start, End, Decision, etc.\n\nWe need to design algorithm: DP with state (i, j, k) representing max points for subarray boxes[i..j] with k boxes of same color as boxes[i] appended to left. Recurrence: DP[i][j][k] = max of: (k+1)^2 + DP[i+1][j][0] (remove first block of (k+1) boxes) OR for any m in (i+1..j) where boxes[m]==boxes[i], DP[i+1][m-1][0] + DP[m][j][k+1]. Use memoization.\n\nWe need to produce pseudo-code line by line. The algorithm might include function solve(), recursive DP, memo map. We need to show steps: read boxes array, call helper(0, n-1, 0), return result.\n\nWe need to show recursion with memoization. Use decision branching. Let's produce pseudo-code with structure. We'll write Start, Step 1: Define function DP(i, j, k). etc.\n\nMake sure to use arrow. Provide explanation after //.\n\nWe need to keep lines simple and linear. We can indent decision lines with tabs or spaces? The example shows indentation for sub-steps. We'll mimic that.\n\nWe'll output lines like:\n\nStart // 程式開始執行\n→ Step 1: Read boxes array // 讀取盒子顏色序列\n\n→ Step 2: Define memoization map // 用於存儲子問題結果\n\n→ Function: DP(i, j, k) // 主要遞迴函式\n    → Decision: i > j? // 判斷子陣列是否為空\n        Yes → Return 0 // 空陣列得 0 分\n        No  →\n            → Decision: (i, j, k) 已計算? // 檢查快取\n                Yes → Return memo[(i,j,k)] // 直接取快取值\n                No  →\n                    → Decision: boxes[i] == boxes[i+1]? // 判斷連續相同顏色\n                        Yes →\n                            → Step 3: 扩大 k, 呼叫 DP(i+1, j, k+1) // 合併左側相同顏色\n                            → Step 4: memo[(i,j,k)] = DP(i+1,j,k+1) // 存入快取\n                            → Return memo[(i,j,k)] // 回傳\n                        No →\n                            → Step 5: maxScore = (k+1)^2 + DP(i+1, j, 0) // 直接刪除左側塊\n                            → Decision: m from i+1 to j where boxes[m]==boxes[i]? // 搜尋可合併位置\n                                For each such m:\n                                    → temp = DP(i+1, m-1, 0) + DP(m, j, k+1) // 合併後的分數\n                                    → maxScore = max(maxScore, temp) // 更新最大分數\n                            → memo[(i,j,k)] = maxScore // 存入快取\n                            → Return memo[(i,j,k)] // 回傳\n→ Step 6: Call DP(0, n-1, 0) // 計算整個序列\n→ Step 7: Return result // 輸出最大分數\nEnd // 程式結束\n\nBut we need to use arrow lines. Each line has \"虛擬碼步驟\" plus comment. Use \"→\". For decisions we use \"Decision:\". Indent maybe with tab.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Read boxes array // 讀取盒子顏色序列\n→ Step 2: Initialize memoization map // 用於存儲子問題結果\n→ Function: DP(i, j, k) // 主要遞迴函式\n    → Decision: i > j? // 判斷子陣列是否為空\n        Yes → Return 0 // 空陣列得 0 分\n        No  →\n            → Decision: (i, j, k) 已計算? // 檢查快取\n                Yes → Return memo[(i,j,k)] // 直接取快取值\n                No  →\n                    → Decision: boxes[i] == boxes[i+1]? // 判斷左側是否有相同顏色盒子\n                        Yes →\n                            → Step 3: Call DP(i+1, j, k+1) // 合併左側相同顏色盒子到 k\n                            → Step 4: memo[(i,j,k)] = DP(i+1,j,k+1) // 存入快取\n                            → Return memo[(i,j,k)] // 回傳結果\n                        No →\n                            → Step 5: maxScore = (k+1)^2 + DP(i+1, j, 0) // 直接刪除左側 (k+1) 個盒子\n                            → Decision: m 在 (i+1..j) 且 boxes[m] == boxes[i]? // 搜尋可合併位置\n                                For each such m:\n                                    → temp = DP(i+1, m-1, 0) + DP(m, j, k+1) // 合併後的分數\n                                    → maxScore = max(maxScore, temp) // 更新最大分數\n                            → memo[(i,j,k)] = maxScore // 存入快取\n                            → Return memo[(i,j,k)] // 回傳結果\n→ Step 6: result = DP(0, n-1, 0) // 計算整個序列的最大分數\n→ Step 7: Return result // 輸出最大分數\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\nsys.setrecursionlimit(10000)\n\nclass Solution:\n    def removeBoxes(self, boxes):\n        memo = {}\n        n = len(boxes)\n\n        def dp(l, r, k):\n            if l > r:\n                return 0\n            if (l, r, k) in memo:\n                return memo[(l, r, k)]\n\n            # 合併右側相同顏色的盒子\n            while r > l and boxes[r] == boxes[r - 1]:\n                r -= 1\n                k += 1\n\n            # 直接刪除右側的 (k+1) 個盒子\n            res = dp(l, r - 1, 0) + (k + 1) ** 2\n\n            # 搜尋可合併的相同顏色盒子\n            for i in range(l, r):\n                if boxes[i] == boxes[r]:\n                    res = max(res, dp(l, i, k + 1) + dp(i + 1, r - 1, 0))\n\n            memo[(l, r, k)] = res\n            return res\n\n        return dp(0, n - 1, 0)\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    # 找到最左、最右的方括號，提取裡面的列表字串\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        print(\"0\")\n        return\n    try:\n        boxes = ast.literal_eval(data[start:end+1])\n    except Exception:\n        print(\"0\")\n        return\n\n    if not isinstance(boxes, list):\n        print(\"0\")\n        return\n\n    result = Solution().removeBoxes(boxes)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "boxes = [1,3,2,2,2,3,4,3,1]",
          "expected_output": "23",
          "success": true,
          "output": "23"
        },
        {
          "example_index": 1,
          "input": "boxes = [1,1,1]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 2,
          "input": "boxes = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode488.json",
    "problem_index_in_file": 0,
    "title": "Zuma Game",
    "description_snippet": "You are playing a variation of the game Zuma. \nIn this variation of Zuma, there is a single row of c...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for solving this problem. It is essentially Zuma game removal with BFS/DFS backtracking. Provide virtual code line by line with comments. Use Start, End, Decision, steps. Not actual code. Provide algorithm: recursively try each hand ball, insert at possible positions, perform collapse, and compute min insertions. Use memoization with state of board and hand counts. Return min or -1.\n\nWe should outline the steps: define function solve(board, hand). Use DFS search with memo. For each possible insertion position and color from hand with count >0: generate new board after insertion, collapse groups, recursively call. Keep track of min. If board empty return 0. If no move possible return INF.\n\nWe'll produce pseudo-code lines. Must be in Traditional Chinese. Use \"→\" arrow.\n\nWe need to produce each line as \"虛擬碼步驟 // 解釋\". Use start, decisions.\n\nLet's outline structure:\n\nStart\n→ Step: 初始化字典 memo // 用於記錄已計算的狀態\n→ Step: 呼叫 DFS(board, hand_counts) // hand_counts: map color->count\nDefine DFS:\n→ Decision: If board 為空? // 確定是否贏\n    Yes → Return 0 // 無需插入\n→ Decision: If hand_counts 無任何球? // 沒有手牌\n    Yes → Return INF // 不能清空\n→ Key = board + hand_counts // 用於 memo\n→ Decision: Key 在 memo? // 已計算\n    Yes → Return memo[Key]\n→ Variable minInsert = INF\n→ Loop: For each color in hand_counts with count>0\n    → For each position i in [0, len(board)]\n        → Step: newBoard = board.insert(i, color) // 插入\n        → Step: collapsedBoard = collapse(newBoard) // 刪除連續三個以上\n        → Step: newHand = hand_counts[color] - 1\n        → Step: result = DFS(collapsedBoard, newHand)\n        → Decision: result != INF? // 可行\n            Yes → minInsert = min(minInsert, result + 1)\n→ memo[Key] = minInsert\n→ Return minInsert\n\nAfter DFS, in main:\n→ Result = DFS(board, hand_counts)\n→ Decision: Result == INF? // 不能清空\n    Yes → Return -1\n    No  → Return Result\n\nNeed collapse function:\n→ Function collapse(board):\n    → Loop: flag = False\n        → Find longest runs of same color >=3\n        → If found: remove, set flag=True\n        → If no flag: break\n    → Return board\n\nAlso need hand_counts from hand string: count each char.\n\nWe need to produce each line with explanation. Use \"→\" arrow for steps and decisions. Use indentation? The format example shows indent for decisions. We can follow that.\n\nWe should write in Chinese but using English letters for variable names maybe. Use \"board\" \"hand_counts\". Keep consistent.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 建立 memo = {} // 用於記錄已計算的 (board, hand) 狀態  \n→ Step: hand_counts = Counter(hand) // 轉換手牌字串為顏色計數表  \n→ Step: result = DFS(board, hand_counts) // 開始遞迴搜尋  \n→ Decision: result == INF? // 不能以任何方式清空棋盤  \n    Yes → Return -1 // 回傳失敗  \n    No  → Return result // 回傳最小插入數  \nEnd // 程式結束  \n\n// -----------------------------------------------------  \n// 定義遞迴函式 DFS\nDFS(board, hand_counts)  \n→ Decision: board == \"\"? // 棋盤已空  \n    Yes → Return 0 // 無需再插入  \n→ Decision: All(hand_counts[color] == 0 for color in hand_counts)? // 手牌空  \n    Yes → Return INF // 無法繼續，視為無解  \n→ Step: key = board + \"#\" + str(hand_counts) // 產生唯一鍵值  \n→ Decision: key in memo? // 已計算過此狀態  \n    Yes → Return memo[key] // 直接回傳  \n→ Step: minInsert = INF // 初始化最小插入數  \n→ Loop: for color in hand_counts: // 逐顏色嘗試  \n    → Decision: hand_counts[color] == 0? // 沒有此顏色球  \n        Yes → Continue  \n    → Loop: for pos in range(len(board)+1): // 可能插入的位置  \n        → Step: newBoard = board[:pos] + color + board[pos:] // 插入球  \n        → Step: collapsed = collapse(newBoard) // 連續三個以上自動刪除  \n        → Step: hand_counts[color] -= 1 // 使用一顆球  \n        → Step: res = DFS(collapsed, hand_counts) // 進一步遞迴  \n        → Decision: res != INF? // 此路徑可行  \n            Yes → minInsert = min(minInsert, res + 1) // 更新最小值  \n        → Step: hand_counts[color] += 1 // 回溯手牌計數  \n→ Step: memo[key] = minInsert // 記錄結果  \n→ Return minInsert  \n\n// -----------------------------------------------------  \n// 定義 collapse 函式，重複刪除連續三個以上同色球  \ncollapse(board)  \n→ Step: changed = True  \n→ Loop: while changed:  \n    → Step: changed = False  \n    → Step: i = 0  \n    → Loop: while i < len(board):  \n        → Step: j = i + 1  \n        → Loop: while j < len(board) and board[j] == board[i]:  \n            → j += 1  \n        → Decision: (j - i) >= 3? // 找到長度≥3的段  \n            Yes → board = board[:i] + board[j:] // 刪除該段  \n            → changed = True  \n            → Break // 重新從頭開始判斷  \n            No  → i = j  \n→ Return board   // 無更多可刪除的段時返回  \n\n// 以上即為完成清空棋盤所需最小插入數的虛擬碼流程。",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\n# ------------------------------ 主要邏輯 ------------------------------------\norder = ['R', 'Y', 'B', 'G', 'W']\nINF = 10 ** 9\n\n\ndef collapse(s: str) -> str:\n    \"\"\"\n    連續三個以上同色的球全部消除，並重複直至無法再消除。\n    使用堆疊演算法。\n    \"\"\"\n    stack = []  # (顏色, 連續數量)\n    i = 0\n    while i < len(s):\n        color = s[i]\n        cnt = 1\n        i += 1\n        while i < len(s) and s[i] == color:\n            cnt += 1\n            i += 1\n        if stack and stack[-1][0] == color:\n            cnt += stack[-1][1]\n            stack.pop()\n        # 如果消除，直接跳過\n        if cnt >= 3:\n            # 可能再次連結前面的同色，故需要重新檢查\n            if stack and stack[-1][0] == color:\n                stack[-1] = (color, stack[-1][1] + cnt)\n            else:\n                # 這裡已經消除，直接不推入堆疊\n                pass\n        else:\n            stack.append((color, cnt))\n\n    # 重新組合剩下的球\n    return \"\".join(color * cnt for color, cnt in stack)\n\n\ndef dfs(board: str, hand_counts: dict, memo: dict) -> int:\n    \"\"\"\n    回傳從目前棋盤狀態和手牌開始，最少需要插入多少球才能清空棋盤。\n    若無法清空，回傳 INF。\n    \"\"\"\n    if not board:\n        return 0\n\n    key = (board, tuple(hand_counts[c] for c in order))\n    if key in memo:\n        return memo[key]\n\n    min_res = INF\n\n    # 逐個位置嘗試插入每一顏色\n    for i in range(len(board) + 1):\n        for color in order:\n            if hand_counts[color] == 0:\n                continue\n            # 若插入的位置與相鄰球同色，且不會造成 3 組合，仍可嘗試\n            new_board = board[:i] + color + board[i:]\n            collapsed = collapse(new_board)\n\n            hand_counts[color] -= 1\n            res = dfs(collapsed, hand_counts, memo)\n            hand_counts[color] += 1\n\n            if res != INF:\n                min_res = min(min_res, res + 1)\n\n    memo[key] = min_res\n    return min_res\n\n\ndef solve(board: str, hand: str) -> int:\n    hand_counts = {c: hand.count(c) for c in order}\n    memo = {}\n    ans = dfs(board, hand_counts, memo)\n    return -1 if ans == INF else ans\n\n\n# ------------------------------ main --------------------------------------\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n\n    # 嘗試解析 \"board = \\\"...\\\", hand = \\\"...\\\"\" 這種格式\n    board_match = re.search(r'board\\s*=\\s*\"([^\"]*)\"', data)\n    hand_match = re.search(r'hand\\s*=\\s*\"([^\"]*)\"', data)\n\n    if board_match and hand_match:\n        board_str = board_match.group(1)\n        hand_str = hand_match.group(1)\n    else:\n        # 直接以空白或換行分隔的兩個字串\n        parts = data.replace('\\n', ' ').split()\n        board_str = parts[0] if parts else \"\"\n        hand_str = parts[1] if len(parts) > 1 else \"\"\n\n    result = solve(board_str, hand_str)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "board = \"WRRBBW\", hand = \"RB\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode564.json",
    "problem_index_in_file": 0,
    "title": "Find the Closest Palindrome",
    "description_snippet": "Given a string n representing an integer, return the closest integer (not including itself), which i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudo-code steps. Not actual code. Step-by-step. Provide virtual code with arrows and comments. Should cover reading string, converting to integer maybe, then find nearest palindrome not equal to n. Approach: generate candidate palindromes by mirroring digits, adjust middle. Evaluate. We need steps: get length, produce base palindrome by mirroring. Then produce next higher and next lower palindromes by adjusting the middle prefix. Compute differences. Return the one with smaller diff, tie choose smaller. Use decisions.\n\nWe must produce step-by-step. Use virtual arrows like \"→\" etc. Provide explanation comments after //. Should be line by line. We should also handle edge cases: 0, 1-digit numbers etc. But for simplicity, we can assume general algorithm.\n\nWe'll include steps: Input string n, convert to long integer N. Get length len. Build base palindrome by mirroring first half. If base == N, need adjust. Then generate candidates: base, base+1, base-1 adjustments. Actually to produce nearest palindrome not equal, we can generate candidates by manipulating prefix. We'll produce candidate list: pal(mid-1), pal(mid), pal(mid+1). Also handle overflow/underflow.\n\nSimplify: algorithm:\n\n1. nStr input.\n2. N = parse.\n3. if N < 10: handle trivial: return N-1 or N+1? For single digit, nearest palindrome not equal: 9 if N>0 else 1? But spec not needed; we can treat generically.\n\nBut we need pseudo-code, not actual code. We'll produce steps accordingly.\n\nLet's outline:\n\nStart\n→ Read string nStr\n→ Convert nStr to integer N\n→ len = length of nStr\n→ Extract leftHalf = first ceil(len/2) digits of nStr\n→ Mirror leftHalf to form palindrome base\n→ If base == N:\n    → Decrement leftHalf by 1\n    → Build candidate1 by mirroring new leftHalf\n    → Increment leftHalf by 2 (so original +1)\n    → Build candidate2 by mirroring new leftHalf\nElse:\n    → candidate1 = base (since not equal)\n    → Decrement leftHalf by 1 to form candidateLow\n    → Build candidateLow palindrome\n    → Increment leftHalf by 1 to form candidateHigh\n    → Build candidateHigh palindrome\n\nCompute diffLow = abs(candidateLow - N)\nCompute diffHigh = abs(candidateHigh - N)\nCompute diffMid = abs(candidate1 - N) if exists\n\nSelect min diff; if tie choose smaller number.\n\nEdge: handle when leftHalf decrement causes shorter length e.g., 1000 -> leftHalf=10; decrement gives 9 -> need to produce 999? Our algorithm handle: if decrement results in fewer digits, candidateLow becomes 9 repeated len-1 times.\n\nAlso increment overflow produce 100...1 length+1.\n\nBut in pseudo, we can mention.\n\nOk produce pseudo lines with explanations.\n\nLet's generate code lines.\n\nAlso we need to use Decision lines for ties.\n\nLet's start.\n\nWill produce steps as described.\n\nWe'll maintain variable candidateLow, candidateHigh, candidateMid (optional). After computing diffs, decide.\n\nLet's write.\n\nUse \"Decision:\" lines.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 nStr // 取得要轉換的整數字串  \n→ Step 2: N ← 轉換為整數 // 用於後續計算  \n→ Step 3: len ← nStr 的長度 // 數字位數  \n→ Step 4: leftHalfLen ← (len + 1) // 2 // 取得左半部位數（含中位）  \n→ Step 5: leftHalfStr ← nStr 前 leftHalfLen 位 // 左半部字串  \n→ Step 6: leftHalfNum ← 轉換為整數 // 方便加減  \n→ Step 7: basePalStr ← 將 leftHalfStr 反轉後貼在右半部（按 len 的奇偶性） // 生成對稱數  \n→ Step 8: basePalNum ← 轉換 basePalStr 為整數 // 基本回文  \n→ Decision: basePalNum 等於 N? // 判斷基本回文是否與原數相同  \n    Yes →  \n        → Step 9a: leftHalfNum ← leftHalfNum - 1 // 將前綴減 1 產生較小回文  \n        → Step 9b: candLowStr ← 將 leftHalfNum 轉回字串並對稱生成回文 // 低值候選  \n        → Step 9c: leftHalfNum ← leftHalfNum + 2 // 前綴加 1 產生較大回文  \n        → Step 9d: candHighStr ← 將 leftHalfNum 轉回字串並對稱生成回文 // 高值候選  \n    No →  \n        → Step 9e: candMidStr ← basePalStr // 原本回文可作為中間候選  \n        → Step 9f: leftHalfNum ← leftHalfNum - 1 // 產生較小回文  \n        → Step 9g: candLowStr ← 將 leftHalfNum 轉回字串並對稱生成回文 // 低值候選  \n        → Step 9h: leftHalfNum ← leftHalfNum + 2 // 產生較大回文  \n        → Step 9i: candHighStr ← 將 leftHalfNum 轉回字串並對稱生成回文 // 高值候選  \n→ Step 10: candLowNum ← 轉換 candLowStr 為整數 // 低值候選整數  \n→ Step 11: candHighNum ← 轉換 candHighStr 為整數 // 高值候選整數  \n→ Decision: candMidStr 是否存在? // 判斷是否有中間候選  \n    Yes → candMidNum ← 轉換 candMidStr 為整數  \n    No  → candMidNum ← NULL  \n→ Step 12: diffLow ← abs(candLowNum - N) // 低值與原數的距離  \n→ Step 13: diffHigh ← abs(candHighNum - N) // 高值與原數的距離  \n→ Step 14: diffMid ← candMidNum ≠ NULL ? abs(candMidNum - N) : INF // 中間距離，若不存在則視為無限大  \n→ Decision: diffLow 與 diffHigh 與 diffMid 之中哪個最小? // 選擇最近的回文  \n    → 若 diffLow 最小 → Answer ← candLowNum  \n    → 若 diffHigh 最小 → Answer ← candHighNum  \n    → 若 diffMid 最小 → Answer ← candMidNum  \n    → 若兩個或三個距離相同 →  \n        → Decision: 哪個數值更小? // tie-breaking 取較小數  \n            → Yes → Answer ← min 值  \n            → No  → Answer ← min 值 // 同樣取最小的回文  \n→ Step 15: 輸出 Answer // 回傳最接近的回文（非自身）  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        length = len(n)\n        num = int(n)\n        candidates = set()\n\n        # 特殊情況：長度變化時的回文\n        candidates.add(str(10 ** length + 1))          # e.g., 999 -> 1001\n        candidates.add(str(10 ** (length - 1) - 1))    # e.g., 100 -> 99\n\n        # 前綴（包括中位數）作為基準\n        prefix_len = (length + 1) // 2\n        prefix = int(n[:prefix_len])\n\n        for delta in (-1, 0, 1):\n            new_prefix = str(prefix + delta)\n            if length % 2 == 0:\n                palin = new_prefix + new_prefix[::-1]\n            else:\n                palin = new_prefix + new_prefix[:-1][::-1]\n            candidates.add(palin)\n\n        # 移除原本的數字\n        candidates.discard(n)\n\n        # 選擇最近的回文，若距離相同則取較小的數字\n        best = None\n        for cand in candidates:\n            cand_num = int(cand)\n            if best is None:\n                best = cand\n            else:\n                best_num = int(best)\n                diff_cand = abs(cand_num - num)\n                diff_best = abs(best_num - num)\n                if diff_cand < diff_best or (diff_cand == diff_best and cand_num < best_num):\n                    best = cand\n        return best\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，找出第一個數字串\n    data = sys.stdin.read()\n    match = re.search(r'\\\"(\\d+)\\\"', data)\n    if match:\n        n_str = match.group(1)\n    else:\n        # 若沒有引號，直接取整個輸入作為數字\n        n_str = data.strip()\n\n    sol = Solution()\n    result = sol.nearestPalindromic(n_str)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = \"123\"",
          "expected_output": "\"121\"",
          "success": true,
          "output": "121"
        },
        {
          "example_index": 1,
          "input": "n = \"1\"",
          "expected_output": "\"0\"",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode442.json",
    "problem_index_in_file": 0,
    "title": "Find All Duplicates in an Array",
    "description_snippet": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and e...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code in Traditional Chinese. The problem: find all numbers that appear twice in an array of length n where values in [1,n] each appears at most twice. O(n) time and constant extra space. Standard approach: iterate through array, for each number x, mark position |x|-1 negative to indicate visited. If already negative then duplicate. We should output duplicates.\n\nThus algorithm: Start, initialize empty list duplicates. For i from 0 to n-1: val = abs(nums[i]); index = val-1; if nums[index] < 0 then duplicates.append(val); else nums[index] = -nums[index]; End, return duplicates.\n\nWe need to produce virtual code lines with explanation.\n\nWe must include Start, End, Decision, loops etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義空列表 duplicates // 用於儲存重複的數字\n→ Step 2: 迭代 i 從 0 到 n-1 // 遍歷整個陣列\n    → Step 2.1: 取出值 val = abs(nums[i]) // 獲取當前元素的正值\n    → Step 2.2: 計算 index = val - 1 // 對應的索引位置\n    → Decision: nums[index] 是否小於 0? // 判斷該位置是否已被標記\n        Yes → Step 2.3: duplicates.append(val) // 已負值，表示重複，加入結果\n        No  → Step 2.4: nums[index] = -nums[index] // 位置未標記，將其取反標記\n→ End // 完成所有元素的處理\n→ Step 3: 返回 duplicates // 輸出結果\n\nMake sure each line has \"虛擬碼步驟\" then space then \"// 解釋\". Use Chinese. Use \"Start\", \"End\". Use \"Decision:\" lines.\n\nAlso we can include \"→\" arrow after Start, etc. The format: \"Start // 說明\". For steps inside loops, we need indentation or we can just put lines with arrow. But the format demands each line must contain 虛擬碼步驟 + space + // 說明. Use arrow \"→\".\n\nWe need to ensure consistent formatting: \"Start // ...\", \"→ Step 1: ...\", \"→ Step 2: ...\", \"→ Decision: ...\", \"    Yes → Step ...\", \"    No  → Step ...\", etc. The example uses indentation. We should follow that style.\n\nThus produce lines:\n\nStart // 程式開始執行\n→ Step 1: 建立空清單 duplicates // 用來儲存所有重複出現的數字\n→ Step 2: 從 i = 0 到 n-1 進行迴圈 // 遍歷 nums 陣列\n    → Step 2.1: 取出 val = abs(nums[i]) // 取得當前元素的正整數值\n    → Step 2.2: 計算 index = val - 1 // 對應的位置索引\n    → Decision: nums[index] < 0? // 判斷該位置是否已被標記為負\n        Yes → Step 2.3: duplicates.append(val) // 已負值，表示此數字已重複，加入結果\n        No  → Step 2.4: nums[index] = -nums[index] // 未標記，將其取反做標記\n→ End // 迴圈結束，所有元素已處理\n→ Step 3: 回傳 duplicates // 輸出所有重複的數字\n\nMake sure each line ends with // 解釋. Use Traditional Chinese characters.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空清單 duplicates // 用來儲存所有重複出現的數字  \n→ Step 2: 從 i = 0 到 n-1 進行迴圈 // 遍歷 nums 陣列  \n&nbsp;&nbsp;→ Step 2.1: 取出 val = abs(nums[i]) // 取得當前元素的正整數值  \n&nbsp;&nbsp;→ Step 2.2: 計算 index = val - 1 // 對應的位置索引  \n&nbsp;&nbsp;→ Decision: nums[index] < 0? // 判斷該位置是否已被標記為負  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2.3: duplicates.append(val) // 已負值，表示此數字已重複，加入結果  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 2.4: nums[index] = -nums[index] // 未標記，將其取反做標記  \n→ End // 迴圈結束，所有元素已處理  \n→ Step 3: 回傳 duplicates // 輸出所有重複的數字",
      "generated_code": "class Solution:\n    def findDuplicates(self, nums):\n        res = []\n        for num in nums:\n            idx = abs(num) - 1\n            if nums[idx] < 0:\n                res.append(abs(num))\n            else:\n                nums[idx] = -nums[idx]\n        return res\n\n\ndef main():\n    import sys\n    import ast\n\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，支援 \"nums = [1,2,3]\" 或直接 \"[1,2,3]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        # 若 eval 失敗，嘗試以逗號分隔的數字列表解析\n        nums = [int(x) for x in expr.replace('[', '').replace(']', '').split(',') if x.strip()]\n\n    result = Solution().findDuplicates(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[2,3]",
          "success": true,
          "output": "[2, 3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,2]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode146.json",
    "problem_index_in_file": 0,
    "title": "LRU Cache",
    "description_snippet": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplemen...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing LRU cache with O(1). We'll use doubly linked list and hashmap. Provide step-by-step pseudocode lines. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Decision, Start, End. Provide per line. Should be readable. We'll include class definition, constructor, get, put, helper methods. Each line is separate. Use \"Start\" etc. We'll structure flow.\n\nLet's craft lines:\n\nStart\n→ Step 1: Define Node structure with key, value, prev, next // node for doubly linked list\n→ Step 2: Define LRUCache class with capacity, map, head, tail // map stores key to node; head and tail are dummy nodes\n→ Step 3: Constructor: set capacity; initialize map; create head and tail dummy nodes; link head.next = tail; tail.prev = head // setup empty list\n→ Step 4: Helper: moveToFront(node) // move node right after head\n→ Step 5: Helper: removeNode(node) // detach node from list\n→ Step 6: Helper: addToFront(node) // insert node after head\n→ Step 7: Helper: evictIfNeeded() // if size > capacity remove tail.prev\n→ Step 8: get(key)\n    → Decision: if key exists in map?\n        Yes → Step 9: node = map[key]\n               Step 10: moveToFront(node)\n               Step 11: return node.value\n        No  → Step 12: return -1\n→ Step 13: put(key, value)\n    → Decision: if key exists in map?\n        Yes → Step 14: node = map[key]\n               Step 15: node.value = value\n               Step 16: moveToFront(node)\n        No  → Step 17: node = new Node(key, value)\n               Step 18: map[key] = node\n               Step 19: addToFront(node)\n               Step 20: evictIfNeeded()\nEnd\n\nBut each line must be separate. So we need to break into lines. Use indentation for decisions: \"Decision:\" line then \"Yes →\" lines and \"No →\". Ensure each line ends with // explanation.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define Node structure with key, value, prev, next // 建立雙向鏈表節點，存儲鍵值與前後指標  \n→ Step 2: Define LRUCache class with capacity, map, head, tail // LRUCache 內含容量、雜湊表及兩個 dummy 節點  \n→ Step 3: Constructor: set capacity; initialize map; create head and tail dummy nodes; link head.next = tail; tail.prev = head // 建立空的雙向鏈表，準備儲存元素  \n→ Step 4: Helper: moveToFront(node) // 將節點移至最前方（即最近使用）  \n→ Step 5: Helper: removeNode(node) // 從鏈表中刪除指定節點  \n→ Step 6: Helper: addToFront(node) // 在 head 之後插入新節點  \n→ Step 7: Helper: evictIfNeeded() // 若元素數量超過容量，移除最舊節點（tail.prev）  \n→ Step 8: get(key) // 取得鍵對應的值  \n  → Decision: if key exists in map? // 檢查鍵是否存在  \n   Yes → Step 9: node = map[key] // 取得節點  \n    Step 10: moveToFront(node) // 標記為最近使用  \n    Step 11: return node.value // 回傳值  \n   No  → Step 12: return -1 // 鍵不存在，回傳 -1  \n→ Step 13: put(key, value) // 插入或更新鍵值對  \n  → Decision: if key exists in map? // 判斷鍵是否已存在  \n   Yes → Step 14: node = map[key] // 取得節點  \n    Step 15: node.value = value // 更新值  \n    Step 16: moveToFront(node) // 標記為最近使用  \n   No  → Step 17: node = new Node(key, value) // 建立新節點  \n    Step 18: map[key] = node // 將節點加入雜湊表  \n    Step 19: addToFront(node) // 放入鏈表最前面  \n    Step 20: evictIfNeeded() // 如超容量則移除最舊節點  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import OrderedDict\n\nclass LRUCache:\n    \"\"\"O(1) LRU Cache implementation using OrderedDict.\"\"\"\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # Move key to the end to mark it as recently used\n        value = self.cache.pop(key)\n        self.cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            # Remove old entry\n            self.cache.pop(key)\n        self.cache[key] = value\n        # Evict least recently used item if capacity exceeded\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Split the two top‑level lists: commands and arguments\n    idx = data.find('],')\n    if idx == -1:\n        sys.exit(0)\n\n    # Parse command list and argument list\n    cmd_list = ast.literal_eval(data[:idx+1])\n    arg_list = ast.literal_eval(data[idx+2:])\n\n    results = []\n    cache = None\n\n    for cmd, args in zip(cmd_list, arg_list):\n        if cmd == \"LRUCache\":\n            cache = LRUCache(args[0])\n            results.append(None)          # null in LeetCode output\n        elif cmd == \"put\":\n            cache.put(args[0], args[1])\n            results.append(None)\n        elif cmd == \"get\":\n            val = cache.get(args[0])\n            results.append(val if val != -1 else -1)\n        else:\n            results.append(None)          # Undefined command\n\n    # Convert Python None to 'null' to match expected output format\n    out = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(out)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "success": true,
          "output": "[null, null, null, 1, null, -1, null, -1, 3, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode9.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Number",
    "description_snippet": "Given an integer x, return true if x is a palindrome, and false otherwise....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user asks for pseudocode for: Given an integer x, return true if x is a palindrome, false otherwise. They want it in traditional Chinese. They want a step-by-step pseudocode with explanations. No actual code. They want arrow syntax. We'll produce Start, End, decisions. We need to handle negative numbers: negative numbers cannot be palindrome. We need to compare digits reversed. We can convert to string or do math reverse. Since it's pseudocode, we can do string conversion.\n\nThus: Start, Step1: if x < 0 → Decision: negative? → No → return false. Then convert x to string s. Then Step2: Set left=0, right=len-1. While left < right → compare s[left] vs s[right] → if mismatch → return false. Else left++ right--. After loop → return true. Then End.\n\nWe need each line with explanation. Use \"→\" for arrows. Let's produce.\n\nWe must include \"Start\" and \"End\".\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 若 x < 0? // 檢查輸入是否為負數\n    Yes → Step 2: 回傳 false // 負數不可能是迴文\n    No  → Step 3: 將 x 轉成字串 s // 方便逐位比較\n→ Step 4: 初始化 left = 0, right = len(s)-1 // 設定左右指標\n→ Decision: 是否 left < right? // 判斷是否還有未比較的位元\n    Yes → Step 5: 若 s[left] ≠ s[right]? // 比較對稱位元\n        Yes → Step 6: 回傳 false // 發現不相等，非迴文\n        No  → Step 7: left = left + 1; right = right - 1 // 移動指標繼續比較\n    No  → Step 8: 回傳 true // 所有位元已對稱，為迴文\nEnd // 程式執行結束\n\nMake sure each line has the arrow before step. In decision blocks, use indent. But we need to keep the format. We can write like:\n\nStart // 程式開始執行\n→ Step 1: 若 x < 0? // 檢查是否為負數\n    Yes → Step 2: 回傳 false // 負數不是迴文\n    No  → Step 3: 將 x 轉成字串 s // 方便逐位比較\n→ Step 4: left ← 0; right ← len(s)-1 // 設定左右指標\n→ Decision: left < right? // 判斷是否還有未比較的位元\n    Yes → Step 5: 若 s[left] ≠ s[right]? // 比較對稱位元\n        Yes → Step 6: 回傳 false // 不相等，非迴文\n        No  → Step 7: left ← left + 1; right ← right - 1 // 移動指標\n    No  → Step 8: 回傳 true // 所有位元已對稱\nEnd // 程式結束\n\nWe need to maintain arrow \"→\" before each step. For decisions we use \"Decision:\".\n\nAlso we might include \"←\" for assignment but not required.\n\nLet's produce the final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 若 x < 0? // 檢查輸入是否為負數  \n    Yes → Step 2: 回傳 false // 負數不可能是迴文  \n    No  → Step 3: 將 x 轉成字串 s // 方便逐位比較  \n→ Step 4: left ← 0; right ← len(s)-1 // 設定左右指標  \n→ Decision: left < right? // 判斷是否還有未比較的位元  \n    Yes → Step 5: 若 s[left] ≠ s[right]? // 比較對稱位元  \n        Yes → Step 6: 回傳 false // 發現不相等，非迴文  \n        No  → Step 7: left ← left + 1; right ← right - 1 // 移動指標繼續比較  \n    No  → Step 8: 回傳 true // 所有位元已對稱，為迴文  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"檢查整數是否為迴文。\"\"\"\n        if x < 0:\n            return False\n        s = str(x)\n        return s == s[::-1]\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取輸入，判斷並輸出結果。\"\"\"\n    # 讀取所有輸入並取第一個非空行\n    content = sys.stdin.read()\n    if not content:\n        return\n    lines = [line.strip() for line in content.splitlines() if line.strip()]\n    if not lines:\n        return\n    line = lines[0]\n\n    # 嘗試從「x = 數值」格式提取整數\n    if '=' in line:\n        _, value_part = line.split('=', 1)\n        value_part = value_part.strip()\n        # 只保留第一個出現的整數\n        m = re.search(r'[-]?\\d+', value_part)\n        if m:\n            x = int(m.group())\n        else:\n            # 若無法找到整數，則直接終止\n            return\n    else:\n        # 直接嘗試將整行轉為整數\n        try:\n            x = int(line)\n        except ValueError:\n            return\n\n    solution = Solution()\n    result = solution.isPalindrome(x)\n    # 按題目要求輸出小寫字串\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 121",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = -121",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 10",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode421.json",
    "problem_index_in_file": 0,
    "title": "Maximum XOR of Two Numbers in an Array",
    "description_snippet": "Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step: start, steps, decision, etc. For the task: given an integer array, find maximum XOR of any two numbers. Virtual code steps: build trie, iterate numbers, find max XOR. But we need to explain each line.\n\nWe need to output \"虛擬碼步驟\" + space + \"// 解釋\". So we must produce each line. Use arrows. Provide structure. Must be \"逐行\". Use Start, End. For decisions, use Decision:.\n\nWe need to produce a clear algorithm: Build a binary trie of numbers; for each number, query maximum XOR with trie; track max.\n\nAlso handle input array; maybe skip input part? The requirement: just algorithm steps.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize binary trie root // Create root node for trie\n→ Step 2: For each number num in nums: // Iterate through array\n    → Insert num into trie // Add bits of num to trie\n→ Step 3: Initialize maxXor = 0 // Variable to store maximum XOR\n→ Step 4: For each number num in nums: // Iterate again to find max XOR\n    → current = 0 // Temporary XOR value\n    → node = trie root\n    → For bit from 31 downto 0: // Check bits\n        → bitVal = (num >> bit) & 1 // Get current bit\n        → preferred = 1 - bitVal // Opposite bit gives higher XOR\n        → If node has child preferred: // Try to go opposite bit\n            → current |= (1 << bit) // Set this bit in XOR\n            → node = node.child[preferred] // Move to that child\n        → Else:\n            → node = node.child[bitVal] // Move to same bit\n    → If current > maxXor: maxXor = current // Update max\n→ Step 5: Return maxXor // Final result\nEnd\n\nWe need to include explanation after each line. Each line must have \"虛擬碼步驟\" + space + \"// 解釋\". We'll use the arrow or decision lines accordingly. Ensure each line contains the virtual code and explanation.\n\nAlso must include decisions: maybe for existence of child. But not necessary, we can show as decision: If node has child preferred? Yes → else. We'll format accordingly:\n\nDecision: node.has_child(preferred) ?\n\nYes → current |= (1 << bit)\n    node = node.child[preferred]\n\nNo → node = node.child[bitVal]\n\nBut the example uses \"Decision:\" lines, not nested indentation? In example, they indent the decision block. We'll do similar.\n\nWe need to maintain formatting. Use arrow lines and decision lines.\n\nLet's craft.\n\nUse \"虛擬碼步驟\" like \"Start\" \"→ Step 1: ...\" etc. Provide explanation after //.\n\nLet's write.\n\nEnsure each line ends with explanation.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize binary trie root // 建立一個空的二元位元樹  \n→ Step 2: For each number num in nums: // 逐一將每個數字插入樹  \n    → Insert num into trie // 把 num 的位元逐位加入樹中  \n→ Step 3: Initialize maxXor = 0 // 用來儲存目前找到的最大 XOR 值  \n→ Step 4: For each number num in nums: // 再次遍歷，為每個數字尋找最佳配對  \n    → current = 0 // 暫存本次數字與樹中某個數字的 XOR 結果  \n    → node = trie root // 從樹根開始搜尋  \n    → For bit from 31 downto 0: // 逐位檢查從最高位到最低位  \n        → bitVal = (num >> bit) & 1 // 取得 num 在此位元的值  \n        → Decision: node has child (1 - bitVal)? // 檢查是否有對立位元的子節點  \n            Yes → current |= (1 << bit) // 設定此位元為 1，提升 XOR 值  \n                → node = node.child[1 - bitVal] // 跳到對立位元節點  \n            No  → node = node.child[bitVal] // 沒有對立位元，走同位元節點  \n    → Decision: current > maxXor? // 檢查本次 XOR 是否比目前最大更大  \n        Yes → maxXor = current // 更新最大值  \n        No  → // 保持目前最大值不變  \n→ Step 5: Return maxXor // 傳回整個陣列中最大的 XOR 結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def findMaximumXOR(self, nums: List[int]) -> int:\n        max_xor = 0\n        mask = 0\n        # iterate from most significant bit to least significant bit\n        for i in range(31, -1, -1):\n            mask |= (1 << i)\n            prefixes = set(num & mask for num in nums)\n            # try to set current bit to 1\n            temp = max_xor | (1 << i)\n            for p in prefixes:\n                if (temp ^ p) in prefixes:\n                    max_xor = temp\n                    break\n        return max_xor\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list part from input such as \"nums = [3,10,5]\"\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n        list_str = list_str.strip()\n    else:\n        list_str = data\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # fallback: evaluate directly\n        nums = eval(list_str)\n    solution = Solution()\n    result = solution.findMaximumXOR(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,10,5,25,2,8]",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 1,
          "input": "nums = [14,70,53,83,49,91,36,80,92,51,66,70]",
          "expected_output": "127",
          "success": true,
          "output": "127"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode524.json",
    "problem_index_in_file": 0,
    "title": "Longest Word in Dictionary through Deleting",
    "description_snippet": "Given a string s and a string array dictionary, return the longest string in the dictionary that can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce step-by-step pseudo code. Must follow format: each line \"虛擬碼步驟 // 解釋\". Use arrows, Decision. Should produce algorithm.\n\nWe need to consider sorting dictionary by length desc, lex ascending. Then for each word check subsequence. Return first match. Else return empty string.\n\nWe must ensure we follow \"逐行\" output.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Sort dictionary by length descending, then lex ascending // 排序以便先檢查最長且字典序最小\n→ Step 2: 將 sortedList 初始化為排序後的字典 // 取得排序結果\n→ Step 3: For each word in sortedList 循環 // 遍歷每個候選單字\n    → Decision: 是否為 s 的子序列? // 檢查字串是否可由 s 形成\n        Yes → Return word // 找到符合條件的最長且字典序最小\n        No → 繼續下一個單字 // 不符合，跳到下一個\n→ Step 4: Return \"\" // 沒有任何單字符合條件，返回空字串\nEnd // 程式結束\n\nNeed to add arrow indent lines. Use \"→\" arrow for steps, indentation for nested decisions. Use \"Decision:\" line. Provide explanation after //.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 dictionary 按字長降序、字典序升序排序 // 先找最長且字典序最小的單字  \n→ Step 2: 取得已排序的字典 list // 用於遍歷  \n→ Step 3: 遍歷 list 中的每個 word // 檢查每個候選單字  \n  Decision: word 是否為 s 的子序列? // 判斷是否能由 s 的字元構成  \n   Yes → Step 3a: 回傳 word // 找到符合條件的最長且字典序最小的單字  \n   No  → Step 3b: 繼續下一個 word // 不符合條件，檢查下一個  \n→ Step 4: 回傳 \"\" // 所有單字都不符合，返回空字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_longest_word(s: str, dictionary: list[str]) -> str:\n    # 按字長降序、字典序升序排序\n    dictionary.sort(key=lambda x: (-len(x), x))\n    for word in dictionary:\n        it = iter(s)\n        if all(ch in it for ch in word):\n            return word\n    return \"\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入轉成 (s, dictionary) 的形式\n    # 例如：\"abpcplea\", [\"ale\",\"apple\",\"monkey\",\"plea\"] 會被轉成 ('abpcplea', ['ale', 'apple', 'monkey', 'plea'])\n    try:\n        s, dictionary = ast.literal_eval(f\"({data})\")\n    except Exception:\n        # 若解析失敗，直接退出\n        return\n    result = find_longest_word(s, dictionary)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abpcplea\", [\"ale\",\"apple\",\"monkey\",\"plea\"]",
          "expected_output": "\"apple\"",
          "success": true,
          "output": "apple"
        },
        {
          "example_index": 1,
          "input": "\"abpcplea\", [\"a\",\"b\",\"c\"]",
          "expected_output": "\"a\"",
          "success": true,
          "output": "a"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode599.json",
    "problem_index_in_file": 0,
    "title": "Minimum Index Sum of Two Lists",
    "description_snippet": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\n\nA co...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. No actual code. We should handle the algorithm: mapping list1 indices, iterate list2, compute sums, track min, store results.\n\nWe need step-by-step with decisions.\n\nAlso handle multiple results with same sum.\n\nWe produce lines like:\n\nStart // Start\n→ Step 1: 建立字典 map1 // map string to index in list1\n\nThen loop.\n\nWe can structure: Decision: If string in map1? etc.\n\nWe need to record minSum variable, result list.\n\nPseudo code lines.\n\nWe need to keep order of steps. We'll include steps for initialization, loops, updates, final return.\n\nWe need to show arrow and decisions.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 map1：key 為 list1 的字串，value 為該字串在 list1 中的索引 // 將 list1 的元素映射到索引，方便快速查找  \n→ Step 2: 初始化 minSum = Infinity，results = 空列表 // 用來記錄目前已知的最小索引和，與對應的共通字串集合  \n→ Decision: 迴圈遍歷 list2，索引為 j // 從左到右逐個檢查 list2 的每個字串  \n    Yes → Step 3: 取得 currentString = list2[j] // 取得目前要檢查的字串  \n    Decision: 如果 currentString 在 map1 中? // 判斷該字串是否同時出現在 list1  \n        Yes → Step 4: 取得 i = map1[currentString] // 找到該字串在 list1 的索引  \n        Yes → Step 5: 計算 indexSum = i + j // 兩個索引之和即為此次共通字串的總和  \n        Decision: indexSum < minSum? // 判斷是否為目前已知的最小總和  \n            Yes → Step 6: minSum = indexSum，results = [currentString] // 重新設定最小總和，並以此字串作為唯一結果  \n            No  → Decision: indexSum == minSum? // 若等於已知最小總和，需將此字串加入結果  \n                Yes → Step 7: results.append(currentString) // 加入同樣最小總和的另一個共通字串  \n                No → No action // 總和大於最小值時不做任何改動  \n    No → No action // 若字串不在 list1，直接跳過  \n→ Step 8: 結束迴圈 // 所有 list2 的字串已檢查完畢  \n→ Step 9: 返回 results // 回傳所有最小索引和的共通字串集合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findRestaurant(self, list1, list2):\n        \"\"\"返回兩個列表中索引和最小的共同字符串。\"\"\"\n        index_map = {name: i for i, name in enumerate(list1)}\n        min_sum = float('inf')\n        res = []\n\n        for j, name in enumerate(list2):\n            if name in index_map:\n                total_index = j + index_map[name]\n                if total_index < min_sum:\n                    min_sum = total_index\n                    res = [name]\n                elif total_index == min_sum:\n                    res.append(name)\n        return res\n\ndef parse_input(data: str):\n    \"\"\"解析標準輸入中包含 list1 與 list2 的字串。\"\"\"\n    data = data.strip()\n    # 先嘗試找出 'list1 =' 與 'list2 =' 的位置\n    start1 = data.find('list1 =')\n    start2 = data.find('list2 =')\n    if start1 != -1 and start2 != -1:\n        # 擷取兩個列表的原始字串\n        list1_str = data[start1 + len('list1 ='):start2].strip()\n        if list1_str.endswith(','):\n            list1_str = list1_str[:-1].strip()\n        list2_str = data[start2 + len('list2 ='):].strip()\n        # 用 ast.literal_eval 解析為 Python list\n        list1 = ast.literal_eval(list1_str)\n        list2 = ast.literal_eval(list2_str)\n    else:\n        # 如果沒有明確的關鍵字，直接以逗號分隔兩個列表\n        parts = data.split(',', 1)\n        list1 = ast.literal_eval(parts[0].strip())\n        list2 = ast.literal_eval(parts[1].strip())\n    return list1, list2\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    # 解析出兩個列表\n    list1, list2 = parse_input(raw_input)\n    # 建立解題物件並執行\n    solution = Solution()\n    result = solution.findRestaurant(list1, list2)\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]",
          "expected_output": "[\"Shogun\"]",
          "success": true,
          "output": "['Shogun']"
        },
        {
          "example_index": 1,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]",
          "expected_output": "[\"Shogun\"]",
          "success": true,
          "output": "['Shogun']"
        },
        {
          "example_index": 2,
          "input": "list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]",
          "expected_output": "[\"sad\",\"happy\"]",
          "success": true,
          "output": "['sad', 'happy']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode629.json",
    "problem_index_in_file": 0,
    "title": "K Inverse Pairs Array",
    "description_snippet": "For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.leng...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to count arrays of 1..n with exactly k inversions, modulo 1e9+7. Use DP: dp[i][j] = number arrays of length i with j inversions. Recurrence: dp[i][j] = sum_{t=0}^{min(j, i-1)} dp[i-1][j-t]. Use prefix sums to optimize: dp[i][j] = dp[i][j-1] + dp[i-1][j] - (j>=i? dp[i-1][j-i] : 0). We'll produce steps: Start, input n,k, initialize dp arrays, loop i from 1..n, j from 0..k, compute, mod, final answer dp[n][k]. End.\n\nVirtual code lines: each line as step. Use arrow and decision.\n\nWe need to output step by step, not actual code but pseudocode. Use `Start`, `→`, `Decision:` etc.\n\nLet's craft:\n\nStart // 開始程式\n→ Input n, k // 讀入整數 n 和 k\n→ If k > n*(n-1)/2 → End // 若 k 超過最大可能逆序數，直接結束（結果 0）\n→ Initialize dp array size (n+1) x (k+1) with zeros // 建立 DP 表\n→ Set dp[0][0] = 1 // 空陣列只有 0 個逆序對\n→ For i = 1 to n: // 逐步加入第 i 個元素\n    → For j = 0 to k: // 計算長度 i、逆序數 j\n        → Decision: if j == 0? // 若逆序數為 0\n            Yes → dp[i][j] = 1 // 只有遞增序列\n            No → \n                → temp = dp[i][j-1] + dp[i-1][j] // 前一個逆序數累加\n                → If j >= i: temp -= dp[i-1][j-i] // 減去超過 i 個元素的部分\n                → dp[i][j] = (temp mod MOD + MOD) mod MOD // 取模正整數\n→ Output dp[n][k] // 最終答案\nEnd // 結束\n\nWe need to follow format exactly: each line \"虛擬碼步驟 // 解釋\". Must use arrow and decision etc.\n\nWe need to ensure no actual code. Use placeholders like `Initialize dp array` etc.\n\nWe must ensure each line is in form: `虛擬碼步驟 // 解釋`. For loops we might use `For i = 1 to n: // ...`. Use arrow to indicate step.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n, k // 讀取整數 n 與 k  \n→ Decision: 是否 k 大於最大逆序對數 (n*(n-1)/2)? // 檢查 k 是否可達  \n    Yes → End // 若 k 不可能達到，直接結束，答案為 0  \n    No  → // 繼續計算  \n→ Initialize dp[0…n][0…k] 為 0 // 建立 DP 表格  \n→ dp[0][0] = 1 // 空陣列只有 0 個逆序對  \n→ For i = 1 to n: // 逐步加入第 i 個元素  \n    → For j = 0 to k: // 計算長度 i、逆序數 j 的排列數  \n        → Decision: 是否 j == 0? // 逆序數為 0 時只存在遞增序列  \n            Yes → dp[i][j] = 1 // 直接設為 1  \n            No  → // 使用前一行累加並調整過度項  \n                → temp = dp[i][j-1] + dp[i-1][j] // 前一逆序數累加  \n                → Decision: 是否 j >= i? // 需要扣除超過 i 個元素的情況  \n                    Yes → temp -= dp[i-1][j-i] // 扣除不合法部分  \n                    No  → // 不需要扣除  \n                → dp[i][j] = (temp mod MOD + MOD) mod MOD // 取模並保證非負  \n→ Output dp[n][k] // 輸出最終答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nMOD = 10**9 + 7\n\ndef k_inverse_pairs(n: int, k: int) -> int:\n    if k > n * (n - 1) // 2:\n        return 0\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n        for j in range(1, k + 1):\n            val = dp[i][j - 1] + dp[i - 1][j]\n            if j >= i:\n                val -= dp[i - 1][j - i]\n            dp[i][j] = val % MOD\n    return dp[n][k] % MOD\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    # Extract integers from input\n    nums = [int(x) for x in data if x.lstrip('-').isdigit()]\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    result = k_inverse_pairs(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 0",
          "expected_output": "1",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 1",
          "expected_output": "2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      ''"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode693.json",
    "problem_index_in_file": 0,
    "title": "Binary Number with Alternating Bits",
    "description_snippet": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code steps. Should use Start, End, Decision: etc. Provide each line with arrow. Use Chinese explanations. Ensure no actual code. Virtual code steps like \"Step 1: 取得輸入\" etc. Should check alternating bits. So steps: input n. If n<=0? maybe skip. Then convert to binary string? Could check by bit operations. Approach: Compute n XOR (n >> 1). Then check if all bits are 1. That is, mask = n ^ (n >> 1). Then if mask & (mask + 1) == 0 then alternating. We'll do simpler: convert to binary string, iterate.\n\nBut we just need pseudocode. We'll produce steps.\n\nLet's outline:\n\nStart\n→ Step 1: 讀取正整數 N // 從使用者輸入\n→ Decision: N 是否為正整數? // 確保合法\n    Yes → Step 2: 取得 N 的二進位表示為字串 S // 轉換為位元串\n    No  → Step 3: 輸出 '輸入無效' // 結束程式\n→ Step 4: 設定 flag 為 true // 假設交替\n→ Step 5: 從 i=1 到 S.length-1\n→   Decision: S[i] 與 S[i-1] 是否相同?\n        Yes → flag = false; 跳出迴圈 // 不是交替\n        No  → 繼續\n→ Decision: flag 為 true?\n    Yes → Step 6: 輸出 '有交替位元'\n    No  → Step 7: 輸出 '無交替位元'\nEnd\n\nBut we need use arrow notation and include decisions with Yes → No → lines. Use indentation maybe.\n\nLet's produce exactly with format:\n\nStart // 程式開始執行\n→ Step 1: 讀取正整數 N // 從使用者取得輸入\n→ Decision: N > 0? // 確認輸入為正整數\n    Yes → Step 2: 將 N 轉換為二進位字串 S // 取得位元表示\n    No  → Step 3: 輸出 '輸入無效' // 結束程式\n→ Step 4: 設 flag 為 true // 初始假設交替\n→ Step 5: i ← 1 // 設定迴圈起點\n→ Decision: i < S.length? // 判斷是否還有相鄰位元\n    Yes → Decision: S[i] = S[i-1]? // 比較相鄰兩位\n        Yes → flag ← false // 兩位相同，非交替\n        No  → // 兩位不同，保持 flag\n        → i ← i + 1 // 進行下一輪\n        → (回到上一行的 Decision)\n    No  → // 迴圈結束\n→ Decision: flag 為 true? // 判斷結果\n    Yes → Step 6: 輸出 '有交替位元' // 交替\n    No  → Step 7: 輸出 '無交替位元' // 不交替\nEnd // 程式執行結束\n\nBut ensure each line contains only one arrow step. We can't combine loops as nested. Maybe we can use Step 5 loop. But the pseudocode formatting requires each line \"→ Step ...\". Use \"→ Decision: ...\" etc. For loops, we can create loop steps.\n\nLet's rewrite more systematically:\n\nStart // 程式開始\n→ Step 1: 讀取正整數 N // 從使用者取得輸入\n→ Decision: N > 0? // 檢查正整數\n    Yes → Step 2: 將 N 轉換為二進位字串 S // 取得位元串\n    No  → Step 3: 輸出 '輸入無效' // 結束程式\n→ Step 4: 設 flag 為 true // 假設交替\n→ Step 5: i ← 1 // 從第二個位元開始\n→ Decision: i < S.length? // 是否還有下一個位元\n    Yes → Decision: S[i] = S[i-1]? // 比較相鄰位元\n        Yes → flag ← false // 兩位相同，非交替\n        No  → // 兩位不同，保持 flag\n        → i ← i + 1 // 進行下一輪\n        → (回到 Step 5 的 Decision)\n    No  → // 迴圈結束\n→ Decision: flag 為 true? // 判斷是否交替\n    Yes → Step 6: 輸出 '有交替位元' // 是交替\n    No  → Step 7: 輸出 '無交替位元' // 否交替\nEnd // 程式結束\n\nWe need to keep each line separate. However we have nested Decision inside Decision. Must use indentation. For clarity, we can separate.\n\nWe'll present like:\n\nStart // 程式開始執行\n→ Step 1: 讀取正整數 N // 從使用者取得輸入\n→ Decision: N > 0? // 檢查輸入為正整數\n    Yes → Step 2: 將 N 轉換為二進位字串 S // 取得位元串\n    No  → Step 3: 輸出 '輸入無效' // 結束程式\n→ Step 4: 設 flag 為 true // 假設交替\n→ Step 5: i ← 1 // 從第二個位元開始\n→ Decision: i < S.length? // 判斷是否還有相鄰位元\n    Yes →\n        Decision: S[i] = S[i-1]? // 比較相鄰位元\n            Yes → flag ← false // 兩位相同，非交替\n            No  → // 兩位不同，保持 flag\n        → i ← i + 1 // 進行下一輪\n        → (回到上方 Decision: i < S.length?)\n    No  → // 迴圈結束\n→ Decision: flag 為 true? // 判斷結果\n    Yes → Step 6: 輸出 '有交替位元' // 交替\n    No  → Step 7: 輸出 '無交替位元' // 不交替\nEnd // 程式執行結束\n\nWe need to ensure \"→ (回到上方 Decision: i < S.length?)\" is okay? Might not be typical but acceptable as pseudo.\n\nBut maybe simpler: Use Step 6 loop as \"→ Step 6: 如果 i < S.length 循環\" but we need decisions. Maybe keep as above.\n\nEnsure each line ends with comment. The \"→ (回到上方 Decision: i < S.length?)\" line may not be needed; we can just note loop. But we need step for loop.\n\nSimplify: Use Step 5 loop: \"→ Step 5: i ← 1; while i < S.length do ...\". But need Decision arrows.\n\nMaybe we can create Step 5: i ← 1 // 設定起始索引\n→ Decision: i < S.length? // 是否有下一個位元\n    Yes → Step 6: if S[i] = S[i-1] then flag ← false // 比較相鄰\n    Yes → Step 7: i ← i + 1 // 進行下一輪\n    → (回到 Decision: i < S.length?)\n    No  → // 迴圈結束\n\nThat seems simpler. Let's adopt that.\n\nNow produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取正整數 N // 從使用者取得輸入  \n→ Decision: N > 0? // 檢查輸入為正整數  \n&nbsp;&nbsp;Yes → Step 2: 將 N 轉換為二進位字串 S // 取得位元串  \n&nbsp;&nbsp;No  → Step 3: 輸出 '輸入無效' // 結束程式  \n→ Step 4: 設 flag 為 true // 初始假設交替  \n→ Step 5: i ← 1 // 設定起始索引  \n→ Decision: i < S.length? // 是否還有下一個位元  \n&nbsp;&nbsp;Yes → Step 6: if S[i] = S[i-1] then flag ← false // 比較相鄰兩位，若相同則非交替  \n&nbsp;&nbsp;Yes → Step 7: i ← i + 1 // 進行下一輪  \n&nbsp;&nbsp;→ (回到 Decision: i < S.length?) // 迴圈  \n&nbsp;&nbsp;No  → // 迴圈結束  \n→ Decision: flag 為 true? // 判斷是否為交替位元  \n&nbsp;&nbsp;Yes → Step 8: 輸出 '有交替位元' // 是交替  \n&nbsp;&nbsp;No  → Step 9: 輸出 '無交替位元' // 不是交替  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def hasAlternatingBits(self, n: int) -> bool:\n        \"\"\"\n        檢查正整數 n 的二進位表示是否為交替位元。\n        思路：逐位檢查相鄰位元是否相同。\n        \"\"\"\n        prev_bit = n & 1          # 取得最低位元\n        n >>= 1\n        while n > 0:\n            curr_bit = n & 1\n            if curr_bit == prev_bit:   # 相鄰兩位相同，則不是交替\n                return False\n            prev_bit = curr_bit\n            n >>= 1\n        return True\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從輸入字串中擷取第一個整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        print(\"false\")\n        sys.exit(0)\n\n    n = int(match.group())\n    solution = Solution()\n    result = solution.hasAlternatingBits(n)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = 11",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode13.json",
    "problem_index_in_file": 0,
    "title": "Roman to Integer",
    "description_snippet": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Val...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm to convert Roman numeral to integer. Provide each line with // explanation. Use virtual code arrows, Decision etc. Should be step by step. We can design algorithm: create mapping value of each char. Iterate over string from left to right, if current value < next value, subtract else add. Or we can use reverse iterate. Let's produce pseudo code.\n\nWe'll start: Start. Step 1: 初始化總和為 0. Step 2: 定義符號到數值映射. Step 3: 將輸入字串存入 roman. Step 4: 從左到右遍歷每個字符。 Step 5: 取得當前字符的值 currentVal. Step 6: 若不是最後一個字符，取得下一字符的值 nextVal. Step 7: Decision: currentVal < nextVal? Yes → Subtract currentVal from total. No → Add currentVal to total. Step 8: Move to next index. Step 9: End. Output total.\n\nAdd explanation lines.\n\nWe also could handle case-insensitivity? Not necessary.\n\nOk produce.\n\nWe need to include arrow \"→\" after each step line. Use \"Decision:\" with indentation.\n\nLet's produce.\n\nMake sure each line: `虛擬碼步驟 // 解釋/說明`.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 total 為 0 // 設定累加和為 0  \n→ Step 2: 定義映射 table：{I:1, V:5, X:10, L:50, C:100, D:500, M:1000} // 建立符號對應數值的字典  \n→ Step 3: 讀取輸入字串 roman // 從使用者取得羅馬數字  \n→ Step 4: 設定 idx 為 0 // 初始化索引為第一個字符  \n→ Step 5: Decision: idx < roman.length? // 是否還有字符未處理？  \n  Yes → Step 6: currentVal ← table[roman[idx]] // 取得目前字符的數值  \n   Decision: idx+1 < roman.length? // 是否還有下一個字符？  \n    Yes → nextVal ← table[roman[idx+1]] // 取得下一字符的數值  \n     Decision: currentVal < nextVal? // 判斷是否為減法情形  \n      Yes → total ← total - currentVal // 以減法方式累加  \n      No  → total ← total + currentVal // 正常累加  \n    No → total ← total + currentVal // 末尾字符直接累加  \n   idx ← idx + 1 // 移動到下一個字符  \n   → Go back to Step 4 // 重複處理下一個字符  \n  No  → Step 7: 輸出 total // 所有字符已處理，輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    \"\"\"將羅馬數字轉換為整數的解法\"\"\"\n    def romanToInt(self, s: str) -> int:\n        roman_map = {\n            'I': 1, 'V': 5, 'X': 10, 'L': 50,\n            'C': 100, 'D': 500, 'M': 1000\n        }\n        total = 0\n        prev_value = 0\n        # 從右往左遍歷，便於判斷減法情況\n        for char in reversed(s):\n            value = roman_map[char]\n            if value < prev_value:\n                total -= value\n            else:\n                total += value\n            prev_value = value\n        return total\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從類似 's = \"III\"' 的字串中提取羅馬數字字串。\n    \"\"\"\n    if '=' in raw:\n        _, val = raw.split('=', 1)\n    else:\n        val = raw\n    val = val.strip()\n    # 去掉外層的單引號或雙引號\n    if (val.startswith('\"') and val.endswith('\"')) or (val.startswith(\"'\") and val.endswith(\"'\")):\n        val = val[1:-1]\n    return val\n\ndef main():\n    raw_input = sys.stdin.read()\n    roman_str = parse_input(raw_input)\n    result = Solution().romanToInt(roman_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"III\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"LVIII\"",
          "expected_output": "58",
          "success": true,
          "output": "58"
        },
        {
          "example_index": 2,
          "input": "s = \"MCMXCIV\"",
          "expected_output": "1994",
          "success": true,
          "output": "1994"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode134.json",
    "problem_index_in_file": 0,
    "title": "Gas Station",
    "description_snippet": "There are n gas stations along a circular route, where the amount of gas at the i^th station is gas[...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: find starting gas station index for circular tour if possible. The virtual code must use arrow etc. No actual code, just steps.\n\nWe need to output line by line, each line \"虛擬碼步驟 // 解釋\". Use arrows →, Yes →, No →. Use Start, End, Decision:.\n\nLet's think: algorithm: total_gas >= total_cost? if not return -1. Else, iterate stations, keep tank. If tank becomes negative, reset start to next index and tank=0. At end return start.\n\nSo produce steps: Start, Step: 初始化 total_gas, total_cost, start, tank. Loop over i from 0 to n-1. Add gas[i] to tank, subtract cost[i]. Decision: if tank <0 then reset start, tank=0. After loop, Decision: if total_gas >= total_cost then output start else -1. End.\n\nLet's produce each step line. Use \"→\" to denote sequential step.\n\nThe virtual code lines:\n\nStart // 程式開始執行\n→ Step 1: 計算 gas 與 cost 的總和 total_gas, total_cost // 求總燃料與總消耗\n→ Step 2: 如果 total_gas < total_cost → return -1 // 若總燃料不足，無法完成一圈\n→ Decision: 否則 // 總燃料足夠\n    → Step 3: 初始化 start = 0, tank = 0 // 起點設為 0，油箱空\n    → For i from 0 to n-1 // 循環遍歷所有加油站\n        → Step 4: tank += gas[i] - cost[i] // 加油後消耗\n        → Decision: 如果 tank < 0? // 油箱不足以抵達下一站\n            Yes → Step 5: start = i + 1 // 將起點移至下一個站\n            Yes → Step 6: tank = 0 // 重置油箱\n        EndDecision\n    → Step 7: return start // 返回找到的起點\nEnd // 程式結束\n\nWe need to use \"Decision:\" lines for the if inside loop. Also final decision maybe not needed because we already guaranteed existence if total_gas >= total_cost.\n\nBut we need to include final decision to return -1 else start. Already covered.\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Use arrow for sequential. Use Decision: indentation.\n\nLet's format each line with the arrow and comments. Use \"→\" at start of each step.\n\nAlso we can include \"Decision:\" lines separately. Example: \"Decision: 如果 total_gas < total_cost?\" etc.\n\nBetter to maintain style of example.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Decision: 如果 total_gas < total_cost? // 檢查是否有足夠總燃料\n\nBut total_gas not defined yet. We need compute total_gas and total_cost first. So Step 1 compute sums.\n\nLine 2: → Step 1: 計算 total_gas = sum(gas), total_cost = sum(cost) // 求燃料與消耗總和\n\nLine 3: → Decision: total_gas < total_cost? // 判斷是否有足夠燃料\n\nLine 4: Yes → Step 2: return -1 // 總燃料不足，直接返回失敗\n\nLine 5: No → Step 3: 初始化 start = 0, tank = 0 // 總燃料足夠，設定起點與油箱\n\nLine 6: → For i from 0 to n-1 // 遍歷每個加油站\n\nBut we need arrow for loop: maybe \"→ Step 4: for i = 0 to n-1\". Then inside loop we have steps.\n\nLet's write:\n\nLine 6: → Step 4: for i = 0 to n-1 // 開始遍歷\n\nLine 7: → Step 5: tank += gas[i] - cost[i] // 加油後消耗\n\nLine 8: → Decision: tank < 0? // 油箱是否不足以到下一站\n\nLine 9: Yes → Step 6: start = i + 1 // 更新起點為下一站\n\nLine 10: Yes → Step 7: tank = 0 // 重置油箱為空\n\nLine 11: EndDecision\n\nLine 12: EndFor\n\nLine 13: → Step 8: return start // 回傳找到的起點\n\nLine 14: End // 程式結束\n\nLet's ensure each line has \"虛擬碼步驟 // 解釋\". Use arrow for each. But EndFor and EndDecision maybe not necessary, but we can treat them as steps too.\n\nAlso we need \"Decision:\" style, but \"EndDecision\" is not required. We can just use indentation. In example, they didn't include \"EndDecision\". But we can omit.\n\nSimplify: Use Decision: with Yes → and No → lines, and no explicit end.\n\nWe need to indent inside loop accordingly.\n\nLet's produce final output.\n\nCheck formatting: Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need arrow characters. Use \"→\".\n\nLet's output final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 total_gas = sum(gas), total_cost = sum(cost) // 求燃料與消耗總和  \n→ Decision: total_gas < total_cost? // 判斷是否有足夠燃料  \n    Yes → Step 2: return -1 // 總燃料不足，直接返回失敗  \n    No  → Step 3: 初始化 start = 0, tank = 0 // 總燃料足夠，設定起點與油箱  \n→ Step 4: for i = 0 to n-1 // 遍歷每個加油站  \n    → Step 5: tank += gas[i] - cost[i] // 加油後消耗  \n    → Decision: tank < 0? // 油箱是否不足以到下一站  \n        Yes → Step 6: start = i + 1 // 更新起點為下一站  \n        Yes → Step 7: tank = 0 // 重置油箱為空  \n→ Step 8: return start // 回傳找到的起點  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canCompleteCircuit(self, gas, cost):\n        # 如果總燃料不足，直接返回 -1\n        if sum(gas) < sum(cost):\n            return -1\n\n        start = 0\n        tank = 0\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            # 若油箱不足以抵達下一站，重新設定起點\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        return start\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取 gas 與 cost 的兩個列表。\n    期望的格式如：'gas = [1,2,3], cost = [4,5,6]'\n    \"\"\"\n    gas_match = re.search(r'gas\\s*=\\s*\\[([^\\]]*)\\]', data)\n    cost_match = re.search(r'cost\\s*=\\s*\\[([^\\]]*)\\]', data)\n\n    if not gas_match or not cost_match:\n        return [], []\n\n    # 轉成整數列表，忽略多餘空白\n    gas = [int(x.strip()) for x in gas_match.group(1).split(',') if x.strip()]\n    cost = [int(x.strip()) for x in cost_match.group(1).split(',') if x.strip()]\n    return gas, cost\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    gas, cost = parse_input(input_data)\n    sol = Solution()\n    result = sol.canCompleteCircuit(gas, cost)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "gas = [2,3,4], cost = [3,4,3]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode540.json",
    "problem_index_in_file": 0,
    "title": "Single Element in a Sorted Array",
    "description_snippet": "You are given a sorted array consisting of only integers where every element appears exactly twice, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm. Problem: find unique element in sorted array with pairs. O(log n) time, O(1) space. Use binary search on indices with property that before unique index, pairs start at even index, after unique index, pairs start at odd index. So we find low=0 high=n-1. While low<high: mid = (low+high)//2. Ensure mid is even index: if mid%2==1: mid--. Compare arr[mid] with arr[mid+1]. If equal, unique is after mid+2, low=mid+2. Else unique is at or before mid, high=mid. Loop ends; low==high is unique. Return arr[low].\n\nWe must output virtual code step-by-step. Each line with // explanation. Use arrows. Provide start and end. Use decision steps.\n\nMake sure each line is virtual code, not actual code. Format: \"Start // 程式開始執行\". Then \"→\" for next step. Use Decision: for conditional. Provide indentation.\n\nWe need to produce steps. Let's design:\n\nStart\n→ Step 1: 初始化 low=0, high=array.length-1 // 設定搜尋範圍\n→ Decision: low < high? // 判斷是否還有多於一個元素需要搜尋\n    Yes → Step 2: mid = (low+high) // 2 // 計算中間索引\n        → Decision: mid % 2 == 1? // 確保 mid 為偶數索引\n            Yes → Step 3: mid = mid - 1 // 若 mid 為奇數，調整至偶數\n            No → // 何事不做\n        → Decision: array[mid] == array[mid+1]? // 檢查偶數索引與其相鄰偶數+1\n            Yes → Step 4: low = mid + 2 // 唯一值在右半邊，更新 low\n            No → Step 5: high = mid // 唯一值在左半邊或即在 mid，更新 high\n    No → // 搜尋結束\n→ Step 6: return array[low] // low 即為唯一元素\n\nEnd\n\nBut we need to maintain proper indentation. Use \"→\" for each step; \"Decision:\" lines have indents. Let's format:\n\nStart // 程式開始執行\n→ Step 1: low = 0, high = array.length - 1 // 初始化搜尋範圍\n→ Decision: low < high? // 若仍有多個元素需要搜尋\n    Yes → Step 2: mid = (low + high) // 2 // 計算中間索引\n        → Decision: mid % 2 == 1? // 若 mid 為奇數\n            Yes → Step 3: mid = mid - 1 // 調整為偶數索引\n            No  → // 保持 mid 原值\n        → Decision: array[mid] == array[mid + 1]? // 檢查偶數索引與相鄰索引\n            Yes → Step 4: low = mid + 2 // 唯一值在右側\n            No  → Step 5: high = mid // 唯一值在左側\n    No  → // low >= high，搜尋結束\n→ Step 6: return array[low] // low 即為唯一元素\nEnd // 程式執行結束\n\nBut we need to ensure that \"→ Decision:\" lines show arrows and indentation. Let's ensure each step line after decision is indented. Use four spaces for indent? Not necessary. Use consistent.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 0, high = array.length - 1 // 初始化搜尋範圍  \n→ Decision: low < high? // 若仍有多個元素需要搜尋  \n  Yes → Step 2: mid = (low + high) // 2 // 計算中間索引  \n   → Decision: mid % 2 == 1? // 若 mid 為奇數  \n    Yes → Step 3: mid = mid - 1 // 調整為偶數索引  \n    No  → // 保持 mid 原值  \n   → Decision: array[mid] == array[mid + 1]? // 檢查偶數索引與其相鄰索引  \n    Yes → Step 4: low = mid + 2 // 唯一值在右側  \n    No  → Step 5: high = mid // 唯一值在左側  \n  No  → // low >= high，搜尋結束  \n→ Step 6: return array[low] // low 即為唯一元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_single(nums):\n    \"\"\"找出排序陣列中只出現一次的元素（O(log n) 時間，O(1) 空間）。\"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        # 使 mid 為偶數索引\n        if mid % 2 == 1:\n            mid -= 1\n        # 如果偶數索引與其相鄰索引相同，則唯一元素在右半邊\n        if nums[mid] == nums[mid + 1]:\n            left = mid + 2\n        else:\n            # 否則唯一元素在左半邊（包含 mid）\n            right = mid\n    return nums[left]\n\ndef main():\n    # 從 stdin 讀取整個輸入，並解析為列表\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums = ast.literal_eval(data)\n    result = find_single(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,1,2,3,3,4,4,8,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[3,3,7,7,10,11,11]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode622.json",
    "problem_index_in_file": 0,
    "title": "Design Circular Queue",
    "description_snippet": "Design your implementation of the circular queue. The circular queue is a linear data structure in w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing implementation of MyCircularQueue. Each line: virtual code step + space + comment. Use arrow symbols, decision, etc. Should not output actual code. Provide step by step. Probably starting with class definition. Then constructor, enqueue, dequeue, front, rear, isEmpty, isFull. Use array of size k, head, tail pointers. Represent indices with modulo. Should describe each step. Let's craft.\n\nWe need to use \"Start\" and \"End\" as per format. Each line is a step: e.g., Start // 程式開始執行. Then arrow lines: \"→ Step 1: 定義 MyCircularQueue 類別\" etc. Use decisions for if queue empty, full. Also mention modulo.\n\nWe must not output actual code but steps. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 MyCircularQueue 類別，並宣告私有屬性 capacity, data[capacity], frontIndex, rearIndex, count // 初始化資料結構與指標  \n→ Step 2: MyCircularQueue(k)  \n    → Assign capacity = k  \n    → Allocate data array長度為 k  \n    → frontIndex = 0  \n    → rearIndex = 0  \n    → count = 0 // 形成空佇列  \n\n→ Step 3: Front()  \n    → Decision: 若 count == 0? // 判斷佇列是否為空  \n        Yes → Return -1 // 空佇列無前項  \n        No  → Return data[frontIndex] // 取得前項  \n\n→ Step 4: Rear()  \n    → Decision: 若 count == 0? // 判斷佇列是否為空  \n        Yes → Return -1 // 空佇列無後項  \n        No  → Return data[(rearIndex - 1 + capacity) mod capacity] // 取得後項  \n\n→ Step 5: enQueue(value)  \n    → Decision: 若 count == capacity? // 判斷佇列是否已滿  \n        Yes → Return false // 無法插入  \n        No  →  \n            → data[rearIndex] = value // 將值放入 rear 指標位置  \n            → rearIndex = (rearIndex + 1) mod capacity // 後指標往右移，並環繞  \n            → count = count + 1 // 更新佇列長度  \n            → Return true // 成功插入  \n\n→ Step 6: deQueue()  \n    → Decision: 若 count == 0? // 判斷佇列是否為空  \n        Yes → Return false // 無法刪除  \n        No  →  \n            → frontIndex = (frontIndex + 1) mod capacity // 前指標往右移，並環繞  \n            → count = count - 1 // 更新佇列長度  \n            → Return true // 成功刪除  \n\n→ Step 7: isEmpty()  \n    → Return count == 0 // 直接判斷 count 是否為 0  \n\n→ Step 8: isFull()  \n    → Return count == capacity // 直接判斷 count 是否等於容量  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MyCircularQueue:\n    def __init__(self, k):\n        self.size = k\n        self.queue = [0] * k\n        self.head = self.tail = -1\n\n    def isEmpty(self):\n        return self.head == -1\n\n    def isFull(self):\n        return (self.tail + 1) % self.size == self.head\n\n    def enQueue(self, value):\n        if self.isFull():\n            return False\n        if self.isEmpty():\n            self.head = 0\n        self.tail = (self.tail + 1) % self.size\n        self.queue[self.tail] = value\n        return True\n\n    def deQueue(self):\n        if self.isEmpty():\n            return False\n        if self.head == self.tail:\n            self.head = self.tail = -1\n        else:\n            self.head = (self.head + 1) % self.size\n        return True\n\n    def Front(self):\n        if self.isEmpty():\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self):\n        if self.isEmpty():\n            return -1\n        return self.queue[self.tail]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data or len(data) < 2:\n        sys.exit()\n\n    commands = json.loads(data[0])\n    params_list = json.loads(data[1])\n\n    results = []\n    obj = None\n\n    for cmd, params in zip(commands, params_list):\n        if cmd == \"MyCircularQueue\":\n            obj = MyCircularQueue(*params)\n            results.append(None)\n        else:\n            method = getattr(obj, cmd)\n            res = method(*params)\n            results.append(res)\n\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCircularQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"Rear\", \"isFull\", \"deQueue\", \"enQueue\", \"Rear\"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 3, true, true, true, 4]",
          "success": true,
          "output": "[null, true, true, true, false, 3, true, true, true, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode22.json",
    "problem_index_in_file": 0,
    "title": "Generate Parentheses",
    "description_snippet": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parenthes...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all combinations of well-formed parentheses given n pairs. We should output step-by-step algorithm, using virtual code with arrows and decisions. Likely recursive backtracking generating string with counts of open and close. We'll produce Start, function, recursion, decision whether to add '(' or ')' depending on counts. Use End. Provide explanation each line. Ensure each line ends with // explanation. Use arrow \"→\". Use Decision lines with Yes/No branches. Need to maintain indentation. Let's craft.\n\nOutline:\n\nStart\n→ Step 1: Define function generateParentheses(n) // initial entry\n→ Step 2: Initialize result list\n→ Step 3: Call backtrack(currentString, openCount, closeCount)\n→ Step 4: Return result\n→ Function backtrack(current, open, close)\n    Decision: If current length == 2*n? \n        Yes → Step: Add current to result\n        No  → Decision: If open < n? \n               Yes → Add '(' and recurse\n               No  → Decision: If close < open? \n                     Yes → Add ')' and recurse\n                     No  → Step: return\n\nEnd\n\nMake sure we use proper arrows. Provide each line with explanation. Use Start, End. Provide \"→\" to next line. For decisions, use Decision: If ...? and indent inside.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 generateParentheses(n) // 接收括號對數量  \n→ Step 2: 初始化空列表 result // 用於存放所有合法組合  \n→ Step 3: 呼叫 backtrack(“”, 0, 0) // 從空字串開始回溯  \n→ Step 4: 回傳 result // 完成後返回所有組合  \n→ Function backtrack(current, open, close) // 參數：目前字串、已開啟括號數、已關閉括號數  \n    Decision: 如果 current 長度 == 2*n? // 檢查是否已生成完整字串  \n        Yes → Step: result 加入 current // 完整字串加入結果集合  \n        No → Decision: 如果 open < n? // 仍有未開啟的括號可加入  \n            Yes → Step: backtrack(current + “(”, open + 1, close) // 加 '(' 並遞迴  \n            No → Decision: 如果 close < open? // 仍有可關閉的括號  \n                Yes → Step: backtrack(current + “)”, open, close + 1) // 加 ')' 並遞迴  \n                No → Step: 返回 // 兩個條件都不符合，回到上一層  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef generate_parentheses(n: int):\n    \"\"\"生成所有合法的 n 對括號組合\"\"\"\n    res = []\n\n    def backtrack(curr: str, open_cnt: int, close_cnt: int):\n        # 若字串長度達到 2n，已經是一個完整且合法的組合\n        if len(curr) == 2 * n:\n            res.append(curr)\n            return\n        # 若還有未使用的左括號，可以再加一個 '('\n        if open_cnt < n:\n            backtrack(curr + \"(\", open_cnt + 1, close_cnt)\n        # 只在右括號數小於左括號數時才可以加 ')'\n        if close_cnt < open_cnt:\n            backtrack(curr + \")\", open_cnt, close_cnt + 1)\n\n    backtrack(\"\", 0, 0)\n    return res\n\ndef main():\n    # 讀取整個輸入，並從中找出第一個整數作為 n\n    data = sys.stdin.read().strip()\n    match = re.search(r\"\\d+\", data)\n    if not match:\n        return\n    n = int(match.group())\n\n    result = generate_parentheses(n)\n    # 直接打印 list，Python 會產生期望的格式\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
          "success": true,
          "output": "['((()))', '(()())', '(())()', '()(())', '()()()']"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[\"()\"]",
          "success": true,
          "output": "['()']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode217.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate",
    "description_snippet": "Given an integer array nums, return true if any value appears at least twice in the array, and retur...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps, line by line, with arrow and decision. The requirement: \"逐行地產生對應的虛擬碼 (Virtual Code)\" and after each line, immediate explanation. No real code. Use Start, End, Decision, arrow, etc. Should reflect the algorithm: use hash set to check duplicates. Provide pseudo code lines like: Start, Step 1: initialize empty set, etc.\n\nLet's produce steps. Use indentation for decisions. The example uses tabs or spaces. Use arrow → and indentation. We need to ensure each line contains \"虛擬碼步驟\" then space then \"// 解釋/說明\". Use Chinese explanation. Use arrow for transitions. Use Decision: and Yes/No.\n\nWe need to output purely the pseudo-code, no actual code. No extra commentary. Each line must be like \"→ Step 1: ... // explanation\". The example uses Start, then arrow lines.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 初始化一個空集合 seen // 用於儲存已遇過的數值\n→ Step 2: 對於陣列 nums 中的每個元素 num 做以下操作 // 逐一檢查每個數\n    → Decision: num 是否已在 seen 中？ // 判斷是否重複\n        Yes → Step 3: 返回 true // 找到重複值，結束程式\n        No  → Step 4: 將 num 加入 seen // 未重複，將值存入集合\n→ Step 5: 所有元素均已檢查完成，返回 false // 沒有重複，結束程式\nEnd // 程式執行結束\n\nBut need to maintain arrow for decisions and sub-steps. Should indent inside decision block. Use \"Yes →\" and \"No →\" lines. Use proper indentation.\n\nWe must ensure each line ends with explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個空集合 seen // 用來儲存已檢查過的數值  \n→ Step 2: 對陣列 nums 的每個元素 num 做以下操作 // 逐一檢查每個元素  \n → Decision: num 是否已存在於 seen？ // 判斷是否為重複值  \n  Yes → Step 3: 返回 true // 找到重複，直接結束並回傳真  \n  No  → Step 4: 將 num 加入 seen // 若未重複，將其記錄下來  \n→ Step 5: 所有元素已檢查完畢，返回 false // 沒有任何重複，回傳假  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def containsDuplicate(self, nums):\n        \"\"\"\n        判斷列表中是否存在重複元素。\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return True\n            seen.add(num)\n        return False\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入，預期格式為類似 \"nums = [1,2,3,1]\"\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    # 取得等號右側的列表字串，並安全地解析為 Python 列表\n    try:\n        _, list_str = input_data.split('=', 1)\n        nums = ast.literal_eval(list_str.strip())\n    except (ValueError, SyntaxError):\n        # 若輸入格式不符合預期，直接結束\n        sys.exit(0)\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.containsDuplicate(nums)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode389.json",
    "problem_index_in_file": 0,
    "title": "Find the Difference",
    "description_snippet": "You are given two strings s and t.\n\nString t is generated by random shuffling string s and then add ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The task: find added letter by comparing two strings. Approach: Count characters, or XOR. We'll produce steps: Start, compute length difference, if not 1? but we assume correct. Iterate over characters, count frequency, find difference. Provide virtual code lines.\n\nWe need to use arrow syntax. Example: \"Start // 程式開始執行\". Then \"→ Step 1: Initialize count array of size 26 with zeros // 建立字母計數表\". Then \"→ Step 2: For each char in s: increment count[char] // 累加 s 字母頻率\". \"→ Step 3: For each char in t: decrement count[char] // 減少 t 字母頻率\". \"→ Step 4: For i in 0..25: if count[i] < 0: added = chr(i+'a'); break // 找到負值對應的字母\" or if positive? Actually t has one extra, so count after subtract will be negative for added? Wait: We increment for s, decrement for t. Then final count = freq_s - freq_t. The added letter will have negative 1. So we check <0.\n\nAlternatively, XOR all chars: XOR all char codes of s and t, result is added char. But I'll use count.\n\nWe must include explanation comments after each line. Use appropriate arrow and indentation for decision? Not necessary decision. Provide simple linear steps.\n\nWe should also output End. Possibly handle multiple languages but just one.\n\nLet's craft lines.\n\nStart // 程式開始執行\n→ Step 1: Initialize array count[26] = 0 // 建立 26 個字母計數器\n→ Step 2: For each character ch in s: count[ch - 'a'] += 1 // 累加 s 中每個字母的出現次數\n→ Step 3: For each character ch in t: count[ch - 'a'] -= 1 // 減少 t 中每個字母的出現次數\n→ Step 4: For i from 0 to 25: if count[i] < 0: added = chr('a' + i); break // 找到負值即為多出字母\n→ Step 5: Return added // 回傳找到的額外字母\nEnd // 程式執行結束\n\nBut need to include arrows and decision maybe not. Use '→' for each line. The arrow after Start? Start // maybe not arrow. Example uses \"Start // 程式開始執行\" with no arrow. The subsequent lines have arrow.\n\nThus produce output accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Initialize array count[26] = 0 // 建立 26 個字母計數器\n→ Step 2: For each character ch in s: count[ch - 'a'] += 1 // 累加 s 中每個字母的出現次數\n→ Step 3: For each character ch in t: count[ch - 'a'] -= 1 // 減少 t 中每個字母的出現次數\n→ Step 4: For i from 0 to 25: if count[i] < 0: added = chr('a' + i); break // 找到負值即為多出字母\n→ Step 5: Return added // 回傳找到的額外字母\nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\ndef find_the_difference(s: str, t: str) -> str:\n    \"\"\"\n    找出 t 中比 s 多出的一個字母。\n    透過 Counter 逐個字母計數，差值非零即為多出的字母。\n    \"\"\"\n    cnt_s = Counter(s)\n    cnt_t = Counter(t)\n    for ch in cnt_t:\n        if cnt_t[ch] != cnt_s.get(ch, 0):\n            return ch\n    return ''  # 理論上不會到這裡\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料，支援兩種格式：\n    1. 兩行分別為 s 與 t\n    2. 形如 s = \"abcd\", t = \"abcde\" 的單行或多行字串\n    \"\"\"\n    import re\n    # 先嘗試從引號中提取字串\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        return matches[0], matches[1]\n    # 若沒有引號，直接按行拆分\n    lines = [line.strip() for line in data.splitlines() if line.strip() != '']\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    # 只剩一行，試著用逗號分隔\n    parts = [p.strip() for p in data.split(',')]\n    if len(parts) >= 2:\n        # 移除可能的 s = 或 t = 前綴\n        s = parts[0].split('=')[-1].strip()\n        t = parts[1].split('=')[-1].strip()\n        return s, t\n    # 預設返回空字串\n    return '', ''\n\ndef main():\n    raw_data = sys.stdin.read()\n    s, t = parse_input(raw_data)\n    result = find_the_difference(s, t)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcd\", t = \"abcde\"",
          "expected_output": "\"e\"",
          "success": true,
          "output": "e"
        },
        {
          "example_index": 1,
          "input": "s = \"\", t = \"y\"",
          "expected_output": "\"y\"",
          "success": true,
          "output": "y"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode75.json",
    "problem_index_in_file": 0,
    "title": "Sort Colors",
    "description_snippet": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for Dutch national flag problem. Each line: virtual code step, space, // explanation. Use arrow syntax. Provide Start, End, Decision. Use virtual code lines.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 left=0, right=n-1, current=0 // indices\n→ Decision: 如果 current <= right? // iterate while current <= right\n    Yes → Decision: 如果 nums[current]==0? // handle 0\n        Yes → Step 2: 交換 nums[current] 與 nums[left] // 0 to left\n            → Step 3: left++ // move left boundary\n            → Step 4: current++ // move current forward\n        No → Decision: 如果 nums[current]==2? // handle 2\n            Yes → Step 5: 交換 nums[current] 與 nums[right] // 2 to right\n                → Step 6: right-- // shrink right boundary\n                // Note: current 不加 1，因為新交換進來的數字還需檢查\n            No → Step 7: current++ // 白色直接往前\nEnd\n\nMake sure each line has \"→\" if nested. Provide the exact format: \"Start // ...\". Use \"Decision:\" lines with \"Yes →\" \"No →\". For nested decisions, indent? The example uses indentation. We'll use spaces for indentation to show hierarchy. Provide each step accordingly.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 left=0, right=n-1, current=0 // 設定三個指標\n→ Decision: 如果 current <= right? // 只要 current 未越過右邊界就繼續\n    Yes → Decision: 如果 nums[current]==0? // 當前為紅色\n        Yes → Step 2: 交換 nums[current] 與 nums[left] // 把紅色移到左端\n            → Step 3: left++ // 左邊界往右移\n            → Step 4: current++ // current 也往右移\n        No → Decision: 如果 nums[current]==2? // 當前為藍色\n            Yes → Step 5: 交換 nums[current] 與 nums[right] // 把藍色移到右端\n                → Step 6: right-- // 右邊界往左移\n                // 留下 current 不變，因為交換進來的元素還需檢查\n            No → Step 7: current++ // 當前為白色，直接往右移\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef sort_colors(nums):\n    \"\"\"\n    In-place sort of nums containing only 0, 1, 2.\n    Uses the Dutch National Flag algorithm.\n    \"\"\"\n    low, mid, high = 0, 0, len(nums) - 1\n    while mid <= high:\n        if nums[mid] == 0:\n            nums[low], nums[mid] = nums[mid], nums[low]\n            low += 1\n            mid += 1\n        elif nums[mid] == 1:\n            mid += 1\n        else:  # nums[mid] == 2\n            nums[mid], nums[high] = nums[high], nums[mid]\n            high -= 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 將輸入字串解析為 nums 列表\n    if \"nums\" in data:\n        # 取等號右邊的部分\n        expr = data.split(\"=\", 1)[1].strip()\n        try:\n            nums = ast.literal_eval(expr)\n        except Exception:\n            # 若解析失敗則直接 eval（僅作備用）\n            nums = eval(expr)\n    else:\n        # 直接將整個輸入視為列表\n        try:\n            nums = ast.literal_eval(data)\n        except Exception:\n            nums = eval(data)\n\n    sort_colors(nums)\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,0,2,1,1,0]",
          "expected_output": "[0,0,1,1,2,2]",
          "success": true,
          "output": "[0, 0, 1, 1, 2, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [2,0,1]",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode378.json",
    "problem_index_in_file": 0,
    "title": "K^th Smallest Element in a Sorted Matrix",
    "description_snippet": "Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the k^...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for finding kth smallest element in sorted matrix, O(n^2) memory not allowed. We need to use binary search on value range or min-heap of size n. We choose binary search on value range. Steps: find min and max, binary search. For each mid, count elements <= mid by scanning rows with binary search in each row. Count. Adjust low/high. When low==high return low.\n\nWe need to output line by line pseudocode with arrow syntax. Provide explanation after each line.\n\nLet's produce steps:\n\nStart\n→ Step 1: Read matrix M and integers n, k // input\n→ Step 2: Set low = M[0][0] // smallest element\n→ Step 3: Set high = M[n-1][n-1] // largest element\n→ Decision: While low < high? // loop until low equals high\n    Yes → Step 4: mid = floor((low + high)/2) // middle value\n    → Step 5: count = 0 // initialize counter\n    → Step 6: For i from 0 to n-1: // iterate rows\n        → Step 7: count += upper_bound(M[i], mid) // number of elements <= mid in row i\n    → Decision: If count < k? // fewer than k elements <= mid\n        Yes → low = mid + 1 // need larger values\n        No  → high = mid // mid might be kth smallest\nEnd // return low\n\nBut we need to produce explanation lines.\n\nWe need to use Decision structure: \"Decision: If count < k?\" with Yes and No.\n\nAlso we need to define upper_bound pseudocode: we can use binary search per row. But we can mention: \"count += upper_bound in row i for mid\".\n\nLet's produce step by step. Ensure each line has \"虛擬碼步驟\" then space then comment.\n\nLet's write lines.\n\nAlso include comment after each line.\n\nWe also need to include \"Start\" and \"End\" markers.\n\nAlso we need to use arrow after \"Start\" maybe \"→\".\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取矩陣 M 與整數 n, k // 取得輸入資料  \n→ Step 2: low = M[0][0] // 設定最小值為矩陣左上角元素  \n→ Step 3: high = M[n-1][n-1] // 設定最大值為矩陣右下角元素  \n→ Decision: low < high? // 只要 low 還未等於 high 就繼續搜尋  \n    Yes → Step 4: mid = (low + high) / 2 // 計算中間值  \n    → Step 5: count = 0 // 初始化小於等於 mid 的元素個數  \n    → Step 6: For i = 0 to n-1: // 逐行處理  \n        → Step 7: count += upper_bound_in_row(M[i], mid) // 在第 i 行中找出 ≤ mid 的元素數量  \n    → Decision: count < k? // 小於 k 個元素時，需要搜尋更大的值  \n        Yes → low = mid + 1 // 將 lower bound 上調  \n        No  → high = mid // mid 仍有可能是第 k 小的元素  \nEnd // 回傳 low 為第 k 小的元素 (因 low == high)",
      "generated_code": "import sys\nimport heapq\n\nclass Solution:\n    def kthSmallest(self, matrix, k):\n        \"\"\"\n        使用最小堆取得第 k 小元素。\n        堆中存放三元組 (value, row, col)。\n        初始時將每一行的第一個元素放入堆。\n        每次彈出最小元素後，若該元素所在行有下一個元素，則把它推入堆。\n        重複 k-1 次後，堆頂即為第 k 小元素。\n        \"\"\"\n        n = len(matrix)\n        # 初始化堆：每行的第一個元素\n        heap = [(matrix[i][0], i, 0) for i in range(n)]\n        heapq.heapify(heap)\n\n        # 彈出前 k-1 個最小元素\n        for _ in range(k - 1):\n            val, r, c = heapq.heappop(heap)\n            if c + 1 < n:\n                heapq.heappush(heap, (matrix[r][c + 1], r, c + 1))\n\n        # 堆頂即為第 k 小的元素\n        return heapq.heappop(heap)[0]\n\n\ndef main():\n    \"\"\"\n    讀取標準輸入，內容預期為類似\n        matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n    使用 exec 解析變數，然後計算結果並輸出。\n    \"\"\"\n    data = sys.stdin.read()\n    local_vars = {}\n    exec(data, {}, local_vars)          # 解析矩陣與 k\n    matrix = local_vars['matrix']\n    k = local_vars['k']\n\n    result = Solution().kthSmallest(matrix, k)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp1deqsx_n.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmp1deqsx_n.py\", line 36, in main\n    exec(data, {}, local_vars)          # 解析矩陣與 k\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmptejkleku.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmptejkleku.py\", line 36, in main\n    exec(data, {}, local_vars)          # 解析矩陣與 k\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    matrix = [[-5]], k = 1\n    ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode164.json",
    "problem_index_in_file": 0,
    "title": "Maximum Gap",
    "description_snippet": "Given an integer array nums, return the maximum difference between two successive elements in its so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find max gap in sorted array using bucket sort (Pigeonhole principle). The steps: handle <2, find min max, compute bucket size, number of buckets, initialize buckets with min/max values, iterate to assign, then find max gap across buckets. Use linear time and space. Provide each line with explanation. Use virtual code arrows. Provide Start, Decision etc. Need to output each line.\n\nWe must obey \"逐行\" output. Use format \"虛擬碼步驟 // 解釋\".\n\nLet's craft steps.\n\nStart\n\n→ Step 1: Check if length(nums) < 2 // If less than two elements\n\nDecision: 如果長度小於 2?\n\nYes → Step 2: Return 0 // Return 0 for insufficient elements\n\nNo → Step 3: Find minVal and maxVal in nums // Determine range\n\n→ Step 4: If minVal == maxVal then Return 0 // All elements equal\n\n→ Step 5: Compute bucketSize = max(1, (maxVal - minVal) / (len(nums)-1)) // Size of each bucket\n\n→ Step 6: bucketCount = ((maxVal - minVal) / bucketSize) + 1 // Number of buckets\n\n→ Step 7: Initialize arrays bucketMin[bucketCount] with +∞, bucketMax[bucketCount] with -∞ // Bucket placeholders\n\n→ Step 8: For each number x in nums\n\nDecision: If x == minVal or x == maxVal? (Optional but not required)\n\nBut we can just place.\n\n→ Step 9: idx = (x - minVal) / bucketSize // Determine bucket index\n\n→ Step 10: bucketMin[idx] = min(bucketMin[idx], x) // Update min of bucket\n\n→ Step 11: bucketMax[idx] = max(bucketMax[idx], x) // Update max of bucket\n\n→ Step 12: After loop, set prevMax = minVal, maxGap = 0 // Initialize\n\n→ Step 13: For i from 0 to bucketCount-1\n\nDecision: If bucketMin[i] == +∞ (bucket empty)? // Skip empty\n\nYes → continue\n\nNo → Step 14: maxGap = max(maxGap, bucketMin[i] - prevMax) // Gap between buckets\n\n→ Step 15: prevMax = bucketMax[i] // Update previous max\n\n→ Step 16: Return maxGap // Final answer\n\nEnd\n\nWe need to include explanations. Provide each line.\n\nWe must ensure arrow usage consistent: Use \"→\" at each step. For decisions, use \"Decision: ...\". Provide \"Yes →\" and \"No →\" as per format.\n\nWe also need to incorporate \"End\" after final return? The algorithm flow may end after return. But we can still show End.\n\nLet's produce final output lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: If length(nums) < 2 // 檢查是否少於兩個元素  \nDecision: 長度小於 2?  \n Yes → Step 2: Return 0 // 少於兩個元素，直接回傳 0  \n No → Step 3: minVal = min(nums)，maxVal = max(nums) // 找到數組最小值與最大值  \n→ Step 4: If minVal == maxVal Then Return 0 // 所有元素相同時差為 0  \n→ Step 5: bucketSize = max(1, (maxVal - minVal) / (len(nums) - 1)) // 計算每個桶的大小，確保至少 1  \n→ Step 6: bucketCount = ((maxVal - minVal) / bucketSize) + 1 // 計算桶的數量  \n→ Step 7: Initialize bucketMin[0…bucketCount-1] with +∞，bucketMax[0…bucketCount-1] with -∞ // 為每個桶設置初始最小最大值  \n→ Step 8: For each x in nums // 將每個數放入相應桶中  \n  idx = (x - minVal) / bucketSize // 決定 x 所屬的桶索引  \n  bucketMin[idx] = min(bucketMin[idx], x) // 更新桶內最小值  \n  bucketMax[idx] = max(bucketMax[idx], x) // 更新桶內最大值  \n→ Step 9: prevMax = minVal，maxGap = 0 // 初始化上一個非空桶的最大值與最大差距  \n→ Step 10: For i from 0 to bucketCount - 1 // 遍歷所有桶  \n  Decision: bucketMin[i] == +∞? // 判斷桶是否為空  \n   Yes → Continue // 空桶跳過  \n   No → Step 11: maxGap = max(maxGap, bucketMin[i] - prevMax) // 计算跨桶差距  \n    → Step 12: prevMax = bucketMax[i] // 更新上一個非空桶的最大值  \n→ Step 13: Return maxGap // 返回最大的差距  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maximumGap(self, nums):\n        \"\"\"Return the maximum difference between successive elements in the sorted array.\"\"\"\n        n = len(nums)\n        if n < 2:\n            return 0\n\n        min_val = min(nums)\n        max_val = max(nums)\n        if min_val == max_val:\n            return 0\n\n        # Bucket size and number of buckets\n        bucket_size = max(1, (max_val - min_val) // (n - 1))\n        bucket_count = (max_val - min_val) // bucket_size + 1\n\n        bucket_min = [float('inf')] * bucket_count\n        bucket_max = [float('-inf')] * bucket_count\n\n        # Place each number into its bucket\n        for x in nums:\n            idx = (x - min_val) // bucket_size\n            bucket_min[idx] = min(bucket_min[idx], x)\n            bucket_max[idx] = max(bucket_max[idx], x)\n\n        # Scan buckets to find maximum gap\n        prev_max = min_val\n        max_gap = 0\n        for i in range(bucket_count):\n            if bucket_min[i] == float('inf'):  # empty bucket\n                continue\n            max_gap = max(max_gap, bucket_min[i] - prev_max)\n            prev_max = bucket_max[i]\n\n        return max_gap\n\n\ndef parse_nums(data: str):\n    \"\"\"Extract all integers from the input string.\"\"\"\n    return list(map(int, re.findall(r'-?\\d+', data)))\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_nums(raw_input)\n    result = Solution().maximumGap(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,6,9,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [10]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode350.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays II",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for intersection of two integer arrays, with counts. Use hash map to count frequencies. Steps: Start, input arrays, create map counts for nums1, iterate nums2 decrement count, push to result when count>0, output result. Use virtual code with arrows and decision. Let's produce lines. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End. Use arrow lines. For loops, we can use \"Loop: 迭代 nums1\". Decision: check if element exists in map. Use \"Yes →\" etc. Provide straightforward steps. Ensure each line ends with // explanation. Use simplified pseudocode. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空 HashMap countMap // 用來存放 nums1 中每個數字的出現次數  \n→ Step 2: 初始化空 ArrayList result // 存放最終交集結果  \n→ Loop: 遍歷 nums1 的每個元素 num1  \n  → Decision: 如果 countMap 已包含 num1? // 檢查是否已經紀錄此數字  \n    Yes → countMap[num1] = countMap[num1] + 1 // 已存在則次數累加  \n    No  → countMap[num1] = 1 // 新數字則設為 1  \n→ Loop: 遍歷 nums2 的每個元素 num2  \n  → Decision: 如果 countMap 包含 num2 且 countMap[num2] > 0? // 有可用的交集數字  \n    Yes → result.add(num2) // 加入結果  \n      countMap[num2] = countMap[num2] - 1 // 次數減一，避免重複使用  \n    No  → // 不做任何事，該數字不在交集中或已被消耗完  \n→ Step 3: 輸出 result // 回傳交集陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        # Count occurrences in each list\n        c1 = Counter(nums1)\n        c2 = Counter(nums2)\n        result = []\n        # For each number in the first counter, add the minimum common occurrences\n        for num in c1:\n            if num in c2:\n                result.extend([num] * min(c1[num], c2[num]))\n        return result\n\ndef parse_list(s, start):\n    \"\"\"Extract a Python list literal from string s starting at index start.\"\"\"\n    end = s.find(']', start)\n    return ast.literal_eval(s[start:end+1])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Find first list (nums1)\n    idx1 = data.find('[')\n    nums1 = parse_list(data, idx1)\n    # Find second list (nums2)\n    idx2 = data.find('[', idx1 + 1)\n    nums2 = parse_list(data, idx2)\n    # Compute intersection\n    res = Solution().intersect(nums1, nums2)\n    print(res)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2,2]",
          "success": true,
          "output": "[2, 2]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "success": true,
          "output": "[4, 9]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode691.json",
    "problem_index_in_file": 0,
    "title": "Stickers to Spell Word",
    "description_snippet": "We are given n different types of stickers. Each sticker has a lowercase English word on it.\nYou wou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm solving sticker to spell target problem. Essentially it's Leetcode 1079. Approach: DP over subsets or recursion with memo. Use bitmask or recursion with frequency counts. We output steps.\n\nWe should produce a step-by-step pseudo-code with explanation comments. Use Start, End, Decision. The algorithm: Preprocess stickers into freq arrays. Recursively pick a sticker that contributes to remaining target, reduce target, memoize. Use bitmask for target characters? For string length up to maybe 15? But target length maybe up to 15? Use DP over state of remaining characters multiset. Represent remaining target string sorted, or use count array.\n\nSimpler: recursion with memo on remaining string: function dp(rem). If rem empty return 0. For each sticker freq, if sticker contains first char of rem, create new string rem' by subtracting sticker counts. Then result = 1 + dp(rem'). Keep min. If none works return INF. Return memo[rem].\n\nThus pseudo-code steps.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 轉換每張貼紙成字頻表 // 將 sticker words 轉為 26 機制頻率\n→ Step 2: 初始化 memo 空字典 // 用於快取子問題結果\n→ Decision: 目標字串是否為空? // 判斷是否已完成\n    Yes → Step 3: 返回 0 // 需要 0 張貼紙\n    No  → Step 4: 取得目標字串第一個字母 // 觸發搜尋\n→ Step 5: 遍歷每張貼紙 // 嘗試使用貼紙\n    → Decision: 貼紙是否含有目標首字母? // 檢查貢獻性\n        Yes → Step 6: 用貼紙減少目標字串 // 生成新剩餘字串\n            → Step 7: 若新字串已在 memo? // 快取\n                Yes → Step 8: 取得 memo[new] // 直接使用\n                No  → Step 9: 递归呼叫 dp(new) // 計算\n            → Step 10: 更新最佳答案 minAns = min(minAns, 1 + 子問題結果)\n        No  → continue // 這張貼紙不幫助\n→ Decision: 是否有可行貼紙? // 判斷是否可完成\n    Yes → Step 11: 記錄 memo[rem] = bestAns // 保存結果\n    No  → Step 12: memo[rem] = INF // 表示不可完成\n→ End // 程式執行結束\n\nBut we need to use arrow notation and structure. Let's produce each line with explanation.\n\nAlso include memo initialization and base.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: stickersFreq ← 轉換每張貼紙為 26 個字母頻率表 // 方便後續快速減少字元\n→ Step 2: memo ← 空字典 // 用於快取已計算的子問題\n→ Decision: target 是否為空? // 判斷是否已完成拼字\n    Yes → Step 3: 返回 0 // 無需貼紙即可完成\n    No  → Step 4: curr ← target // 目前需要拼寫的剩餘字串\n→ Step 5: 如果 curr 已存在於 memo? // 使用快取避免重複計算\n    Yes → Step 6: 返回 memo[curr]\n    No  → continue\n→ Step 7: best ← ∞ // 初始化最佳貼紙數\n→ Step 8: 遍歷 stickersFreq 中每張貼紙 freq\n    → Decision: freq 是否包含 curr 首字母? // 只考慮能減少字元的貼紙\n        Yes → Step 9: newCurr ← 用 freq 減少 curr 的字頻，得到新的剩餘字串\n            → Step 10: result ← dp(newCurr) // 递归求解剩餘部分\n            → Decision: result 是否為 ∞? // 表示 newCurr 不能完成\n                Yes → continue // 該貼紙不進一步更新 best\n                No  → Step 11: best ← min(best, 1 + result) // 加上一張貼紙\n        No  → continue // 該貼紙無法減少首字母，跳過\n→ Decision: best 是否仍為 ∞? // 判斷是否存在可行解\n    Yes → Step 12: memo[curr] ← -1 // 表示無法完成拼字\n    No  → Step 13: memo[curr] ← best // 儲存最小貼紙數\n→ Step 14: 返回 memo[curr] // 結束遞迴，返回結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def minStickers(self, stickers, target):\n        # 將每張貼紙轉成字頻表\n        sticker_counts = [Counter(s) for s in stickers]\n        memo = {}\n\n        def dp(rem):\n            if rem == \"\":\n                return 0\n            if rem in memo:\n                return memo[rem]\n\n            rem_count = Counter(rem)\n            ans = float(\"inf\")\n\n            for sc in sticker_counts:\n                # 只考慮能減少首字母的貼紙\n                if rem[0] not in sc:\n                    continue\n                # 生成新的剩餘字串\n                new_rem = []\n                for ch, cnt in rem_count.items():\n                    remain = cnt - sc.get(ch, 0)\n                    if remain > 0:\n                        new_rem.append(ch * remain)\n                new_rem = \"\".join(new_rem)\n\n                sub = dp(new_rem)\n                if sub != -1:\n                    ans = min(ans, 1 + sub)\n\n            memo[rem] = -1 if ans == float(\"inf\") else ans\n            return memo[rem]\n\n        return dp(target)\n\ndef parse_input(data: str):\n    \"\"\"\n    從字串中解析 stickers 和 target。\n    支援形如：\n    stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"\n    \"\"\"\n    # 移除換行，將整段文字放在一行\n    data = data.replace(\"\\n\", \" \").strip()\n\n    # 取得 stickers list\n    stickers_match = re.search(r'stickers\\s*=\\s*(\\[[^\\]]*\\])', data)\n    stickers = ast.literal_eval(stickers_match.group(1)) if stickers_match else []\n\n    # 取得 target string\n    target_match = re.search(r'target\\s*=\\s*([\\'\"][^\\'\"]+[\\'\"])', data)\n    target = ast.literal_eval(target_match.group(1)) if target_match else \"\"\n\n    return stickers, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    stickers, target = parse_input(raw_input)\n    sol = Solution()\n    result = sol.minStickers(stickers, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "stickers = [\"notice\",\"possible\"], target = \"basicbasic\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode583.json",
    "problem_index_in_file": 0,
    "title": "Delete Operation for Two Strings",
    "description_snippet": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and wor...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for problem: given two strings, return min number of deletions to make them equal. Equivalent to find longest common subsequence (LCS), then deletions = len(word1)+len(word2)-2*len(LCS). So need DP. Provide line-by-line virtual code with explanations. Use Start, Decision, etc. Also need to use arrow \"→\". Provide each line. Use indentation perhaps. But format: each line: virtual code step + space + // explanation.\n\nUse Start, End. Use Decision: if. Use loops. Use DP array maybe. Steps:\n\nStart\n→ Step 1: Define m = length(word1), n = length(word2)\n→ Step 2: Create 2D array dp of size (m+1) x (n+1) initialized to 0 // LCS dp table\n→ Decision: Iterate i from 1 to m // Outer loop\n    → Step: For each i, iterate j from 1 to n // Inner loop\n        → Decision: if word1[i-1] == word2[j-1]?\n            Yes → Step: dp[i][j] = dp[i-1][j-1] + 1 // characters match, extend LCS\n            No  → Step: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) // take best of skipping one char\n→ Step: lcsLength = dp[m][n]\n→ Step: deletions = m + n - 2 * lcsLength\n→ Step: return deletions\nEnd\n\nNeed to follow format: each line virtual code then // explanation. Use arrow \"→\" and maybe indentation with spaces. Use Decision: etc.\n\nWe should use \"Start\" line. Then \"→\" lines. For loops, we might not need to specify arrow per line, but each line must be separate. Indent loops maybe with spaces but still same line.\n\nWe need to ensure each line has \"虛擬碼步驟\" followed by space then comment. The code may include \"Decision:\" lines.\n\nWe should include \"Decision:\" lines for if conditions, and \"Yes →\" and \"No →\" lines.\n\nLet's produce. Use Chinese explanation.\n\nNeed to keep each line separate; can't merge loops with condition in same line? It's okay to separate.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: m ← length(word1) // 取得第一字串長度\n→ Step 2: n ← length(word2) // 取得第二字串長度\n→ Step 3: dp ← 2D array of size (m+1) × (n+1) initialized to 0 // 用於存儲 LCS 長度\n→ Decision: i from 1 to m // 外層迴圈\n    Yes → Step 4: For i = 1 to m // 迭代第一字串\n        → Decision: j from 1 to n // 內層迴圈\n            Yes → Step 5: For j = 1 to n // 迭代第二字串\n                → Decision: word1[i-1] == word2[j-1] // 檢查對應字元是否相等\n                    Yes → Step 6: dp[i][j] ← dp[i-1][j-1] + 1 // 字元相同，LCS 延長\n                    No  → Step 7: dp[i][j] ← max(dp[i-1][j], dp[i][j-1]) // 字元不同，取較大值\n→ Step 8: lcsLen ← dp[m][n] // 最長公共子序列長度\n→ Step 9: deletions ← m + n - 2 * lcsLen // 計算最小刪除步數\n→ Step 10: return deletions // 回傳結果\nEnd // 程式執行結束\n\nBut we need each line separate; not too many nested Decision. Might simplify: Use loop lines without Decision: we can do:\n\n→ Decision: For i = 1 to m // 迴圈\n    → Step: For j = 1 to n // 內層迴圈\n        → Decision: if word1[i-1] == word2[j-1]?\n            Yes → Step: dp[i][j] = dp[i-1][j-1] + 1\n            No  → Step: dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\nWe need to ensure format: Each line: code, space, // comment.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: m ← length(word1) // 取得第一個字串的長度  \n→ Step 2: n ← length(word2) // 取得第二個字串的長度  \n→ Step 3: dp ← 2D array of size (m+1) × (n+1) initialized to 0 // 用於儲存 LCS 長度的 DP 表  \n→ Decision: i from 1 to m // 逐行迭代第一個字串  \n    Yes → Step 4: For i = 1 to m // 外層迴圈  \n        → Decision: j from 1 to n // 逐行迭代第二個字串  \n            Yes → Step 5: For j = 1 to n // 內層迴圈  \n                → Decision: if word1[i-1] == word2[j-1] // 比較兩個對應字元  \n                    Yes → Step 6: dp[i][j] ← dp[i-1][j-1] + 1 // 字元相同，LCS 延長  \n                    No  → Step 7: dp[i][j] ← max(dp[i-1][j], dp[i][j-1]) // 字元不同，取較大值  \n→ Step 8: lcsLen ← dp[m][n] // 取得最長公共子序列的長度  \n→ Step 9: deletions ← m + n - 2 * lcsLen // 計算最少刪除步數  \n→ Step 10: return deletions // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_distance(word1: str, word2: str) -> int:\n    \"\"\"Return the minimal number of deletions needed to make word1 and word2 equal.\"\"\"\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Base cases: deleting all characters from one string\n    for i in range(1, m + 1):\n        dp[i][0] = i\n    for j in range(1, n + 1):\n        dp[0][j] = j\n\n    # DP transition\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n\n    return dp[m][n]\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the input data and extract two strings.\n    Supports formats like:\n        word1 = \"sea\", word2 = \"eat\"\n    or two separate lines / words.\n    \"\"\"\n    # Look for quoted substrings\n    words = re.findall(r'\"([^\"]*)\"', data)\n    if len(words) >= 2:\n        return words[0], words[1]\n\n    # Split by lines and strip possible surrounding quotes\n    parts = [p.strip().strip('\"') for p in data.replace('\\r', '').splitlines() if p.strip()]\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # Fallback: split by whitespace\n    parts = data.split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # Default to empty second string\n    return data, \"\"\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    word1, word2 = parse_input(raw)\n    print(min_distance(word1, word2))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "word1 = \"sea\", word2 = \"eat\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "word1 = \"leetcode\", word2 = \"etco\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode28.json",
    "problem_index_in_file": 0,
    "title": "Implement strStr()",
    "description_snippet": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystac...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for searching substring. Provide step by step, using Start, End, Decision. Must produce each line with virtual code step + // explanation. Use arrow. Use Yes→, No→. Ensure we use virtual code not actual code. The problem is \"find index of first occurrence of needle in haystack\" standard. So algorithm: iterate haystack index i from 0 to len(haystack)-len(needle). For each, check if substring starting at i matches needle. If match, return i. After loop, return -1.\n\nWe produce virtual code steps. Use \"Start\", \"→ Step 1: 初始化變數\" etc. Provide explanation.\n\nWe need to adhere to format: Each line: \"虛擬碼步驟 // 解釋\". So line begins with \"Start\" or \"→ Step ...\".\n\nMake sure to use arrow for transitions. The decision lines: \"Decision:\" with Yes and No branches.\n\nAlso we need to include \"End\".\n\nLet's produce. Use Chinese comments.\n\nWe may need to include variable names: haystack, needle, i, n, m, found.\n\nAlso we should show nested loops? Use decision to break out.\n\nSimplify: Outer loop: i from 0 to haystackLen - needleLen.\n\nInside, set j=0. While j < needleLen and haystack[i+j] == needle[j] → j++.\n\nAfter inner loop, if j == needleLen, return i.\n\nAfter loop, return -1.\n\nImplement virtual steps: Step 1: 計算 haystackLen, needleLen // etc.\n\nWe'll produce each step with explanation.\n\nLet's write.\n\nEnsure each line ends with // explanation. Use consistent formatting.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 haystack 長度並存於 haystackLen // 取得搜尋範圍  \n→ Step 2: 計算 needle 長度並存於 needleLen // 確定子字串長度  \n→ Step 3: 如果 needleLen > haystackLen? // 檢查子字串是否過長  \n    Yes → Step 4: 回傳 -1 // 子字串長度大於搜尋字串，直接返回 -1  \n    No  → Decision: 是否開始外層迴圈? // 如果足夠長則進行搜尋  \n→ Decision: 是否進入外層迴圈?  \n    Yes → Step 5: 設定 i = 0 // 初始化外層迴圈指標  \n    No  → Step 6: 回傳 -1 // 迴圈結束但未找到，返回 -1  \n→ Decision: i <= haystackLen - needleLen? // 確認仍有位置可比對  \n    Yes → Step 7: 設定 j = 0 // 初始化內層比對指標  \n    No  → Step 8: 回傳 -1 // 所有位置已檢查完畢，返回 -1  \n→ Decision: j < needleLen AND haystack[i + j] == needle[j]? // 逐字比對子字串  \n    Yes → Step 9: j++ // 比對成功，遞增內層指標  \n    No  → Step 10: i++ // 比對失敗，移動外層指標  \n→ Decision: j == needleLen? // 內層比對完成且完全匹配  \n    Yes → Step 11: 回傳 i // 找到第一個出現的位置  \n    No  → 回到 Step 7 // 內層比對未完成，繼續比對  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef str_str(haystack: str, needle: str) -> int:\n    \"\"\"\n    Return the index of the first occurrence of needle in haystack,\n    or -1 if needle is not found.\n    \"\"\"\n    if needle == \"\":\n        return 0\n    n, m = len(haystack), len(needle)\n    for i in range(n - m + 1):\n        if haystack[i:i+m] == needle:\n            return i\n    return -1\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 透過正則表達式抓取第一個雙引號內的字串作為 haystack\n    # 以及第二個雙引號內的字串作為 needle\n    strings = re.findall(r'\"([^\"]*)\"', data)\n    haystack = strings[0] if len(strings) > 0 else \"\"\n    needle = strings[1] if len(strings) > 1 else \"\"\n\n    result = str_str(haystack, needle)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "haystack = \"sadbutsad\", needle = \"sad\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "haystack = \"leetcode\", needle = \"leeto\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode605.json",
    "problem_index_in_file": 0,
    "title": "Can Place Flowers",
    "description_snippet": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: Given array of 0/1, n new flowers to plant without adjacent 1s. Standard solution: iterate, check if spot empty and neighbors zero, plant, decrement n. After loop, return n<=0.\n\nWe need to output line by line virtual code with explanation comments. Use Start, End, Decision etc. No actual code. Just pseudo steps.\n\nLet's produce steps:\n\nStart\n→ Step 1: Initialize index i = 0 // start at first plot\n→ Step 2: While i < length of flowerbed // iterate through plots\n   → Decision: Is flowerbed[i] == 0? // spot empty\n      Yes →\n         → Decision: (i==0 or flowerbed[i-1]==0) and (i==len-1 or flowerbed[i+1]==0)? // neighbors empty\n            Yes →\n               → Step 3: Set flowerbed[i] = 1 // plant flower\n               → Step 4: Decrement n by 1 // one less to plant\n               → Decision: n <= 0? // all planted\n                  Yes → Step 5: Return true // done\n                  No  →\n            No →\n         No →\n   → Decision: i++ // move to next\nEnd // loop finished\n→ Decision: n <= 0? // check remaining\n   Yes → Step 6: Return true\n   No  → Step 7: Return false\n\nBut must use structure arrows. Use \"Decision:\" lines and indent. Provide explanation comments.\n\nWe need to ensure each line has virtual code step and comment.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定索引 i ← 0 // 從第一個地塊開始  \n→ Step 2: While i < flowerbed.length // 迭代整個花床  \n  Decision: flowerbed[i] == 0? // 現在的地塊是否空著  \n   Yes → Decision: (i == 0 或 flowerbed[i-1] == 0) 且 (i == len-1 或 flowerbed[i+1] == 0)? // 檢查左右鄰居是否為空  \n    Yes → Step 3: flowerbed[i] ← 1 // 種下新花  \n     Step 4: n ← n - 1 // 需要種的花數減一  \n     Decision: n <= 0? // 是否已經種完所有花  \n      Yes → Step 5: Return true // 成功完成  \n      No  → // 繼續搜尋  \n    No  → // 無法種此處，跳過  \n  No  → // 當前地塊已被占用，直接跳過  \n  Step 6: i ← i + 1 // 移動到下一個地塊  \nEnd // 迴圈結束  \nDecision: n <= 0? // 最後檢查是否還有未種的花  \n  Yes → Step 7: Return true // 所有花已種完  \n  No  → Step 8: Return false // 仍有花未種，無法滿足需求",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def canPlaceFlowers(self, flowerbed, n):\n        \"\"\"\n        迭代花床，若該位置為空且左右鄰居也為空，則種下花並減少需要種的數量。\n        \"\"\"\n        count = 0\n        length = len(flowerbed)\n        i = 0\n        while i < length:\n            if flowerbed[i] == 0:\n                empty_prev = (i == 0) or (flowerbed[i-1] == 0)\n                empty_next = (i == length-1) or (flowerbed[i+1] == 0)\n                if empty_prev and empty_next:\n                    flowerbed[i] = 1\n                    count += 1\n                    if count >= n:\n                        return True\n                    i += 1\n            i += 1\n        return count >= n\n\ndef main():\n    \"\"\"\n    讀取輸入，解析花床和 n 的值，呼叫解法並輸出結果。\n    輸入格式示例：\n        flowerbed = [1,0,0,0,1], n = 1\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 嘗試解析「flowerbed = [...], n = ...」的格式\n    pattern = r'flowerbed\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*n\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data)\n    if match:\n        flowerbed = ast.literal_eval(match.group(1))\n        n = int(match.group(2))\n    else:\n        # 若輸入分行，例如第一行是列表，第二行是 n\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            flowerbed = ast.literal_eval(lines[0])\n            n = int(lines[1])\n        else:\n            # 無法解析輸入\n            return\n\n    solution = Solution()\n    result = solution.canPlaceFlowers(flowerbed, n)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "flowerbed = [1,0,0,0,1], n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "flowerbed = [1,0,0,0,1], n = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode768.json",
    "problem_index_in_file": 0,
    "title": "Max Chunks To Make Sorted II",
    "description_snippet": "You are given an integer array arr.\n\nWe split arr into some number of chunks (i.e., partitions), and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate a virtual code solution to problem: Largest Number of Equal Sum? Actually it's \"Largest Number of Chunk To Make Sorted II\" or \"Maximum Number of chunks to make sorted\" variant with duplicates. For array with duplicates, the known solution is to use prefix sums or counts. Approach: iterate, maintain cumulative sum and cumulative sorted sum. When prefix sums equal sorted prefix sums, we can cut. Equivalent: track frequencies. Use a map counts difference. When difference empty => cut.\n\nWe produce pseudo-code with virtual steps. Provide line-by-line.\n\nWe'll write steps:\n\nStart\n→ Step 1: create sorted copy sortedArr = sort(arr) // sorted target\n→ Step 2: initialize empty map countDiff\n→ Step 3: initialize chunkCount = 0\n→ Step 4: for i from 0 to n-1:\n    → Step 4a: increment countDiff[arr[i]] by 1\n    → Step 4b: decrement countDiff[sortedArr[i]] by 1\n    → Step 4c: if all counts are zero (map empty or all zero) → increment chunkCount and clear map\nEnd\n\nAlso explain map emptiness check: when diff map size zero.\n\nLet's produce each line with comments.\n\nInclude arrow notation.\n\nMake sure each line has the format: virtual code step + space + // explanation.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: sortedArr ← sort(arr) // 先取得原陣列的全域排序結果  \n→ Step 2: countDiff ← empty map // 用於儲存當前前綴區間內各數值的差異  \n→ Step 3: chunkCount ← 0 // 先把切塊數目初始化為 0  \n→ Step 4: for i from 0 to n-1 do // 逐個掃描陣列  \n  → Step 4a: countDiff[arr[i]] ← countDiff.get(arr[i], 0) + 1 // 原陣列中數值出現一次  \n  → Step 4b: countDiff[sortedArr[i]] ← countDiff.get(sortedArr[i], 0) - 1 // 排序後陣列中相同位置的數值減去一次  \n  → Decision: if all values in countDiff are 0? // 檢查目前前綴區間是否已經可切分  \n    Yes → Step 4c: chunkCount ← chunkCount + 1 // 切一次，累加結果  \n      → Step 4d: clear countDiff // 清空差異表，為下一塊做準備  \n    No  → // 仍不等，繼續掃描下一個元素  \nEnd // 程式執行結束，chunkCount 為最大可切分數目",
      "generated_code": "import sys\nimport ast\n\ndef max_chunks_to_sorted(arr):\n    \"\"\"\n    依照題意，用「前綴頻數差」的方式判斷可以切幾個區塊。\n    - sorted_arr 代表整個陣列排序後的結果。\n    - diff 用來記錄原陣列與排序後陣列在同一個前綴下各數值的差異。\n    - 當 diff 為空時，說明前綴已經可以切分，累加一次結果。\n    \"\"\"\n    sorted_arr = sorted(arr)\n    diff = {}\n    chunks = 0\n    for a, b in zip(arr, sorted_arr):\n        # 原陣列的數值多一個\n        diff[a] = diff.get(a, 0) + 1\n        if diff[a] == 0:\n            diff.pop(a)\n        # 排序後陣列的數值少一個\n        diff[b] = diff.get(b, 0) - 1\n        if diff[b] == 0:\n            diff.pop(b)\n        # 若差異表空，表示可以切分\n        if not diff:\n            chunks += 1\n    return chunks\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入文字，取得陣列。\n    支援類似 'arr = [1,2,3]' 的輸入格式。\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    # 只取等號右邊的部分\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n        data = rhs.strip()\n    # 使用 literal_eval 解析為 list\n    return ast.literal_eval(data)\n\ndef main():\n    raw = sys.stdin.read()\n    arr = parse_input(raw)\n    result = max_chunks_to_sorted(arr)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [5,4,3,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "arr = [2,1,3,4,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode664.json",
    "problem_index_in_file": 0,
    "title": "Strange Printer",
    "description_snippet": "There is a strange printer with the following two special properties:\n\nThe printer can only print a ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code algorithm to compute minimum turns for strange printer. Classic DP problem: min turns to print string s. Known solution: dp[i][j] minimal turns for substring i..j inclusive. Recurrence: dp[i][j] = dp[i][j-1] + 1 then for k in i..j-1 if s[k]==s[j] then dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j-1]). Or alternative: dp[l][r] = min over k splitting plus maybe merging when s[l]==s[k]. We'll generate pseudo-code with loops, decisions. Provide line by line.\n\nNeed to start: Start, read string s, compute n, initialize dp array. Then nested loops over lengths. Use Decision to compute min. Provide explanations. Avoid actual code, just pseudo.\n\nLet's craft lines:\n\nStart // program start\n→ Step 1: Read string s //取得輸入字串\n→ Step 2: Let n = length(s) //字串長度\n→ Step 3: Initialize 2D array dp[n][n] //dp[i][j] 為子字串 i..j 的最小印刷次數\n→ Step 4: For i from 0 to n-1: dp[i][i] = 1 //單字元只需一次印刷\n→ Step 5: For len from 2 to n: //子字串長度\n    → Step 6: For i from 0 to n-len: //子字串起始位置\n        → Step 7: Let j = i + len - 1 //子字串結束位置\n        → Step 8: Set dp[i][j] = dp[i][j-1] + 1 //假設最後一次印刷只印 j 字元\n        → Step 9: For k from i to j-1: //尋找與 j 相同的字符\n            → Decision: If s[k] == s[j]?\n                Yes → Step 10: Set dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j-1]) //合併兩段印刷\n        → Step 11: End //結束 k 迴圈\n    → Step 12: End //結束 i 迴圈\n→ Step 13: End //結束 len 迴圈\n→ Step 14: Return dp[0][n-1] //答案為整個字串的最小印刷次數\nEnd //程序結束\n\nWe should add proper arrows and explanation. Format requires each line with \"虛擬碼步驟\" and comment after //.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read string s // 取得使用者輸入的字串  \n→ Step 2: Let n = length(s) // 計算字串長度  \n→ Step 3: Initialize 2D array dp[n][n] // dp[i][j] 代表子字串 i~j 的最小印刷次數  \n→ Step 4: For i from 0 to n-1: dp[i][i] = 1 // 單個字元只需一次印刷  \n→ Step 5: For len from 2 to n: // 子字串長度從 2 開始  \n    → Step 6: For i from 0 to n-len: // 子字串起始位置  \n        → Step 7: Let j = i + len - 1 // 子字串結束位置  \n        → Step 8: Set dp[i][j] = dp[i][j-1] + 1 // 預設最後一次印刷僅印 j 字元  \n        → Step 9: For k from i to j-1: // 尋找與 j 相同的字元  \n            → Decision: If s[k] == s[j]? // 檢查字符是否相同  \n                Yes → Step 10: Set dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j-1]) // 合併印刷段，降低次數  \n        → Step 11: End // 結束 k 迴圈  \n    → Step 12: End // 結束 i 迴圈  \n→ Step 13: End // 結束 len 迴圈  \n→ Step 14: Return dp[0][n-1] // 回傳整個字串的最小印刷次數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef strange_printer(s: str) -> int:\n    \"\"\"Return the minimum number of turns the strange printer needs to print s.\"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # dp[i][j] : minimal turns to print substring s[i..j] (inclusive)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1  # a single character needs one turn\n        for j in range(i + 1, n):\n            # Default: print s[i] separately, then print s[i+1..j]\n            dp[i][j] = dp[i + 1][j] + 1\n            # Try to merge printing s[i] with some later identical character\n            for k in range(i + 1, j + 1):\n                if s[k] == s[i]:\n                    if k + 1 <= j:\n                        val = dp[i][k - 1] + dp[k + 1][j]\n                    else:  # k == j, nothing after k\n                        val = dp[i][k - 1]\n                    if val < dp[i][j]:\n                        dp[i][j] = val\n    return dp[0][n - 1]\n\n\ndef extract_string(raw: str) -> str:\n    \"\"\"\n    Extract the string to be printed from the raw input.\n    Handles formats like:\n        - aaabbb\n        - s = \"aaabbb\"\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return \"\"\n    # Look for quoted string\n    if '\"' in raw or \"'\" in raw:\n        quote = '\"' if '\"' in raw else \"'\"\n        start = raw.find(quote)\n        end = raw.rfind(quote)\n        if start != -1 and end != -1 and end > start:\n            return raw[start + 1:end]\n    # No quotes, return the whole line\n    return raw\n\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    s = extract_string(raw_input)\n    result = strange_printer(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aaabbb\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode377.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum IV",
    "description_snippet": "Given an array of distinct integers nums and a target integer target, return the number of possible ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, for problem: number of combinations that add up to target, using distinct integers nums. It's classic \"Combination Sum II\" but counting combinations (order matters?) Actually \"combinations that add up to target\" typical Leetcode 39/DP: count number of combinations where order matters? There is \"Combination Sum IV\" where order matters and uses DP. Problem statement: \"return the number of possible combinations that add up to target.\" Usually this is combination sum IV where order matters. But also numbers are distinct. It's same as count of sequences using nums. So DP: dp[0] = 1; for i from 1..target: for num in nums: if num <= i: dp[i] += dp[i-num]. Complexity O(target * n). Provide virtual code. Provide Start, End, Decision lines, etc. Provide each line with comment. Provide arrow. Also need to avoid actual code, only virtual. So we produce something like:\n\nStart\n→ Step 1: Sort nums // Not necessary but optional\n→ Step 2: 初始化 dp[0..target] 為 0\n→ Step 3: dp[0] ← 1 // 基本情況\n→ Step 4: Decision: i從1到target // 外層迴圈\n    → For each i:\n        → Decision: 遍歷每個 num 在 nums\n            → If num <= i\n                → dp[i] ← dp[i] + dp[i - num]\n→ Step 5: Return dp[target]\nEnd\n\nBut need line by line virtual code: each line must include \"虛擬碼步驟 [空格] // 解釋/說明\". Also use arrows. The virtual code must not be actual code. Use \"Step\" etc. Use \"Decision:\" etc. We'll produce each line accordingly.\n\nWe need to include arrow lines. For loops, we can indicate with Decision and sub-lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列長度 target+1 並初始化為 0 // 用於儲存到各目標的組合數\n→ Step 2: 設定 dp[0] ← 1 // 目標為0時只有一種空組合\n→ Decision: i 從 1 到 target // 逐個目標值進行計算\n    Yes → Step 3: 設定 dp[i] ← 0 // 初始為0\n    Yes → Decision: 遍歷 nums 中每個 num\n        Yes → Step 4: 如果 num ≤ i\n            Yes → Step 5: dp[i] ← dp[i] + dp[i - num] // 加上以 num 結尾的組合數\n        No  → Step 6: 跳過該 num // 不能使用\n→ Step 7: 返回 dp[target] // 最終答案\nEnd // 程式執行結束\n\nBut the format uses arrow \"→\" before each step, indent. For Decision we use \"Decision:\".\n\nWe must adhere to sample format: For Decision: we have indentation for Yes/No lines. For loops we can treat as Decision but not requiring Yes/No. Could use \"Decision: i from 1 to target\". But maybe use \"Decision:\" to show loops? It's okay. But sample uses Decision: If X > 0? then Yes/No. For loops, we can write \"Decision: i from 1 to target\". Might not need Yes/No. But to follow format we can use \"Decision: i from 1 to target\" and no Yes/No. But maybe better to use \"Decision: 迴圈 i: 1~target\". But the sample shows Decision: \"如果數字大於 0?\" etc. For loops maybe \"Decision: i 從 1 到 target?\" then Yes→ Step? This is unnatural. Instead we could use \"Decision: i < target?\" etc. But simplest: we can use \"Decision: i from 1 到 target\" and then indent sub-steps.\n\nLet's propose:\n\nStart // 程式開始執行\n→ Step 1: 建立長度為 target+1 的 dp 陣列並全部設為 0 // dp[i] 表示達到 i 的組合數\n→ Step 2: 設定 dp[0] ← 1 // 目標 0 只有一種空組合\n→ Decision: i 從 1 到 target\n    Yes → Step 3: dp[i] ← 0 // 初始化\n    Yes → Decision: 遍歷每個 num 於 nums\n        Yes → Step 4: 若 num ≤ i\n            Yes → Step 5: dp[i] ← dp[i] + dp[i - num] // 加上以 num 結尾的組合\n        No  → Step 6: 跳過 // num 大於 i，無法使用\n→ Step 7: 返回 dp[target] // 最終答案\nEnd // 程式執行結束\n\nBut \"Yes →\" is not logical for loops. But sample uses Yes → for branch; we can use \"Yes →\" to denote each iteration step. The arrow after Yes leads to step inside the loop.\n\nBetter: Use \"Decision: i 從 1 到 target?\" then Yes → Step. But then Step includes loop body. But we need step per line.\n\nLet's try to keep it simple: Use \"Decision: i 從 1 到 target?\" then Yes → Step 3: dp[i] ← 0 ; then Yes → Decision: 遍歷 nums ; then Yes → Step 4 etc. This might create many Yes lines.\n\nBut we can produce simpler: Each line can be a step; we don't need to label each as Yes →. We can still maintain arrow for each step. The sample uses arrow for each line. So we will produce each line with arrow.\n\nLet's produce final output accordingly. Use \"Step 1\", \"Step 2\", etc. Each line: \"虛擬碼步驟 // 解釋\". We'll incorporate arrow before Step lines. For loops, we use Decision: i from 1 to target. But we need a line for that. Then subsequent lines are nested indented.\n\nI'll craft:\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列長度 target+1 且全部設為 0 // dp[i] 表示達到 i 的組合數\n→ Step 2: dp[0] ← 1 // 目標為 0 時只有一種空組合\n→ Decision: i 從 1 到 target\n    Yes → Step 3: dp[i] ← 0 // 初始化此目標的組合數\n    Yes → Decision: 遍歷 nums 中的每個 num\n        Yes → Step 4: 若 num ≤ i\n            Yes → Step 5: dp[i] ← dp[i] + dp[i - num] // 加上以 num 結束的組合\n        No  → Step 6: 跳過該 num // 無法使用\n→ Step 7: 返回 dp[target] // 最終答案\nEnd // 程式執行結束\n\nBut maybe we need arrow before Decision lines? The sample: \"Decision: 如果數字大於 0?\" includes arrow. So we need \"→ Decision:\" lines. So we should start with \"→ Decision:\" for loops too. Let's adjust:\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列長度 target+1 且全部設為 0 // dp[i] 表示達到 i 的組合數\n→ Step 2: dp[0] ← 1 // 目標為 0 時只有一種空組合\n→ Decision: i 從 1 到 target // 外層迴圈\n    Yes → Step 3: dp[i] ← 0 // 初始化此目標的組合數\n    Yes → Decision: 遍歷 nums 中每個 num // 內層迴圈\n        Yes → Step 4: 若 num ≤ i\n            Yes → Step 5: dp[i] ← dp[i] + dp[i - num] // 加上以 num 結束的組合\n        No  → Step 6: 跳過該 num // num 大於 i，無法使用\n→ Step 7: 返回 dp[target] // 最終答案\nEnd // 程式執行結束\n\nOk.\n\nWe need to ensure each line includes [空格] between virtual code and comment. Use // for comment. Provide explanation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 dp 陣列長度 target+1 且全部設為 0 // dp[i] 表示達到 i 的組合數  \n→ Step 2: dp[0] ← 1 // 目標為 0 時只有一種空組合  \n→ Decision: i 從 1 到 target // 外層迴圈，逐個目標值進行計算  \n    Yes → Step 3: dp[i] ← 0 // 初始化此目標的組合數  \n    Yes → Decision: 遍歷 nums 中每個 num // 內層迴圈，嘗試以每個數字結尾  \n        Yes → Step 4: 若 num ≤ i  \n            Yes → Step 5: dp[i] ← dp[i] + dp[i - num] // 加上以 num 結束的組合  \n        No → Step 6: 跳過該 num // num 大於 i，無法使用  \n→ Step 7: 返回 dp[target] // 最終答案，即所有組合數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def combinationSum4(self, nums, target):\n        dp = [0] * (target + 1)\n        dp[0] = 1  # base case: one way to reach 0\n        for i in range(1, target + 1):\n            for num in nums:\n                if i - num >= 0:\n                    dp[i] += dp[i - num]\n        return dp[target]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # split into two parts: nums part and target part\n    parts = data.split(', target =')\n    nums_part = parts[0].strip()\n    target_part = parts[1].strip() if len(parts) > 1 else ''\n    # extract the list from the nums part\n    nums_str = nums_part.replace('nums =', '').strip()\n    nums = ast.literal_eval(nums_str)\n    target = int(target_part)\n    # compute and output the result\n    result = Solution().combinationSum4(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "nums = [9], target = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode726.json",
    "problem_index_in_file": 0,
    "title": "Number of Atoms",
    "description_snippet": "Given a string formula representing a chemical formula, return the count of each atom.\n\nThe atomic e...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps. Must not output actual code. Provide step-by-step algorithm for parsing chemical formula and counting atoms. Use virtual code with arrows. Must be in Traditional Chinese. Provide explanation after each line. Use Start, End, Decision, Steps.\n\nWe need to parse string formula, handle parentheses and numbers, element names (capital + lowercase). We'll need stack of dicts.\n\nOutline:\n\nStart\n→ Step: Initialize index to 0, length, stack with empty map\n→ Decision: while index < length? Yes loop body.\nInside loop:\n    Decision: current char '('? Yes: push new empty map onto stack, increment index\n    No: Decision: current char ')'?\n        Yes: increment index, parse number after ')'\n            parse number (digits) if present else 1\n            pop map from stack as groupMap\n            multiply groupMap values by multiplier\n            merge into map now on top of stack\n    No: parse element name: read uppercase + following lowercase letters\n        parse count digits if any else 1\n        add to top map\nAfter loop End\n→ Step: Convert top map to sorted list, build output string\n\nNeed to handle parse number function.\n\nOk produce virtual code lines. Use arrows and indentation. Provide explanation.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 index = 0，len = formula 長度，stack = [空字典] // 初始化指標、長度與堆疊  \n→ Decision: index < len? // 是否還有字元要處理  \n    Yes →  \n        → Decision: formula[index] == '('? // 檢查是否進入小括號  \n            Yes →  \n                → Step 2: stack.Push(空字典) // 推入新組合層級  \n                → Step 3: index++ // 移到下一個字元  \n            No →  \n                → Decision: formula[index] == ')'? // 檢查是否結束小括號  \n                    Yes →  \n                        → Step 4: index++ // 跳過 ')'\n                        → Step 5: multiplier = ParseNumber() // 解析括號後可能的數字，若無則為 1\n                        → Step 6: group = stack.Pop() // 取出括號內的原子計數\n                        → Step 7: For each (atom, cnt) in group: group[atom] = cnt * multiplier // 乘以乘子\n                        → Step 8: For each (atom, cnt) in group: stack.Top()[atom] += cnt // 合併回上一層\n                    No →  \n                        → Step 9: atom = ParseElement() // 解析元素名稱\n                        → Step 10: count = ParseNumber() // 解析後面的數字，若無則為 1\n                        → Step 11: stack.Top()[atom] += count // 更新最上層的計數\n        → Step 12: Continue loop // 回到 Decision: index < len?  \n    No →  \nEnd // 已完成所有字元的處理  \n\n// 以下是輔助函式說明  \n\n→ Step 13: ParseElement() // 解析元素名稱  \n    → atom = formula[index] // 讀取大寫字母  \n    → index++  \n    → While index < len 且 formula[index] 是小寫字母:  \n        → atom += formula[index]  \n        → index++  \n    → Return atom  \n\n→ Step 14: ParseNumber() // 解析數字，若無則回傳 1  \n    → start = index  \n    → While index < len 且 formula[index] 是數字:  \n        → index++  \n    → If start == index:  \n        → Return 1 // 無數字  \n    → Else:  \n        → Return int(formula[start:index])  \n\n→ Step 15: OutputResult() // 將最上層字典轉為字串  \n    → atoms = stack.Top().Keys sorted lexicographically  \n    → result = \"\"  \n    → For atom in atoms:  \n        → result += atom  \n        → If stack.Top()[atom] > 1:  \n            → result += str(stack.Top()[atom])  \n    → Return result   // 形成符合規則的輸出字串",
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def countOfAtoms(self, formula: str) -> str:\n        n = len(formula)\n        i = 0\n\n        def parse() -> Counter:\n            nonlocal i\n            cnt = Counter()\n            while i < n and formula[i] != ')':\n                if formula[i] == '(':\n                    i += 1\n                    inner = parse()\n                    i += 1  # skip ')'\n                    mult = 0\n                    while i < n and formula[i].isdigit():\n                        mult = mult * 10 + int(formula[i])\n                        i += 1\n                    if mult == 0:\n                        mult = 1\n                    for atom, c in inner.items():\n                        cnt[atom] += c * mult\n                else:\n                    start = i\n                    i += 1\n                    while i < n and formula[i].islower():\n                        i += 1\n                    atom = formula[start:i]\n                    num = 0\n                    while i < n and formula[i].isdigit():\n                        num = num * 10 + int(formula[i])\n                        i += 1\n                    if num == 0:\n                        num = 1\n                    cnt[atom] += num\n            return cnt\n\n        counts = parse()\n        parts = []\n        for atom in sorted(counts):\n            parts.append(atom + (str(counts[atom]) if counts[atom] > 1 else \"\"))\n        return \"\".join(parts)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Accept input like: formula = \"H2O\" or just H2O\n    if '=' in data:\n        _, value = data.split('=', 1)\n        formula = value.strip().strip('\"').strip(\"'\")\n    else:\n        formula = data.strip().strip('\"').strip(\"'\")\n    sol = Solution()\n    result = sol.countOfAtoms(formula)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "formula = \"H2O\"",
          "expected_output": "\"H2O\"",
          "success": true,
          "output": "H2O"
        },
        {
          "example_index": 1,
          "input": "formula = \"Mg(OH)2\"",
          "expected_output": "\"H2MgO2\"",
          "success": true,
          "output": "H2MgO2"
        },
        {
          "example_index": 2,
          "input": "formula = \"K4(ON(SO3)2)2\"",
          "expected_output": "\"K4N2O14S4\"",
          "success": true,
          "output": "K4N2O14S4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode575.json",
    "problem_index_in_file": 0,
    "title": "Distribute Candies",
    "description_snippet": "Alice has n candies, where the i^th candy is of type candyType[i]. Alice noticed that she started to...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, no actual code. The problem: maximize distinct types when choosing n/2 candies. Solution: distinct types count limited by n/2. Use set to count unique types, answer = min(uniqueCount, n/2). So pseudocode: start, input array, n = length, uniqueCount = size of set of candyType, half = n/2, result = min(uniqueCount, half), output result, end. Provide line-by-line with explanation.\n\nWe need to use virtual arrows etc. Format as shown.\n\nWe should use \"Start\" \"End\". Use \"Step\" labels.\n\nOk. Provide step lines.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取 candyType 陣列，n ← 長度 // 取得糖果類型陣列與總數\n→ Step 2: 建立空集合 uniqueSet // 用於儲存不同類型的糖果\n→ Step 3: 對於每個 type 在 candyType:\n    → Add type 至 uniqueSet // 只記錄一次每個類型\n→ Step 4: uniqueCount ← uniqueSet 的大小 // 取得不同類型的總數\n→ Step 5: half ← n / 2 // 只能吃的糖果數量\n→ Step 6: result ← 最小值(uniqueCount, half) // 最大不同類型數受限制於可吃數\n→ Step 7: 輸出 result // 回傳答案\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    \"\"\"\n    主函式：從標準輸入讀取一行，例如\n        candyType = [1,1,2,2,3,3]\n    解析出數字列，計算 Alice 可以吃到的不同糖果類型數量，\n    並將結果輸出到標準輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找出 '[' 與 ']' 之間的文字並轉成列表\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        # 無效輸入，直接回傳\n        print(0)\n        return\n    list_str = data[start:end+1]\n    try:\n        candy_type = eval(list_str, {\"__builtins__\": None}, {})\n    except Exception:\n        # 若 eval 失敗，則輸出 0\n        print(0)\n        return\n\n    # 計算可吃的糖果數量 (n/2) 以及不同類型的個數\n    n = len(candy_type)\n    half = n // 2\n    unique_count = len(set(candy_type))\n\n    # 結果為兩者之小者\n    result = min(unique_count, half)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candyType = [1,1,2,2,3,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "candyType = [1,1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "candyType = [6,6,6,6]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode532.json",
    "problem_index_in_file": 0,
    "title": "K-diff Pairs in an Array",
    "description_snippet": "Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the ar...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for counting unique k-diff pairs in an array. The algorithm: use a hash map of counts. For k=0: pairs of same numbers with count >=2. For k>0: for each unique number, check if num+k exists. Count unique pairs.\n\nWe need to output step by step with explanations. Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow →, Decision, Start, End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 countMap // 用於儲存每個數字出現的頻率  \n→ Step 2: 對 nums 中的每個 num 執行  \n    → Step 2a: countMap[num] = countMap.get(num, 0) + 1 // 更新頻率計數  \n→ Step 3: 設定 pairsCount = 0 // 初始化符合條件的唯一對數  \n→ Decision: 如果 k < 0? // k 的絕對值必須是非負數  \n    No → Step 4: 若 k == 0? // 特殊處理 k = 0 的情況  \n        Yes → Step 4a: 對 countMap 的每個 (num, freq) 執行  \n            → Decision: 若 freq >= 2? // 至少出現兩次才能成對  \n                Yes → pairsCount = pairsCount + 1 // 加入一對相同數字  \n                No  → No action // 不足兩次不算對  \n        → Step 4b: End // 走完 k=0 的處理  \n        No → Step 5: 對 countMap 的每個 (num, _) 執行  \n            → Decision: 若 num + k 存於 countMap? // 檢查對應的數字是否存在  \n                Yes → pairsCount = pairsCount + 1 // 有符合的 k 差值，算一對  \n                No  → No action // 沒有則跳過  \n→ Step 6: 回傳 pairsCount // 結果即為唯一 k-diff 對的數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findPairs(self, nums, k):\n        # k 必須非負，否則不存在任何對\n        if k < 0:\n            return 0\n        # 統計每個數字的出現頻率\n        freq = Counter(nums)\n        if k == 0:\n            # k=0 時，只計算出現次數至少為 2 的數字\n            return sum(1 for v in freq.values() if v > 1)\n        # k>0 時，計算每個數字是否存在其 +k 的數字\n        return sum(1 for n in freq if n + k in freq)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入格式 \"[1,2,3], 2\"\n    # 找到最後一次 ']' 的位置\n    idx = data.rfind(']')\n    list_part = data[:idx+1]\n    k_part = data[idx+2:].strip()  # 跳過 '],'\n    nums = ast.literal_eval(list_part)\n    k = int(k_part)\n    solution = Solution()\n    result = solution.findPairs(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,1,4,1,5], 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4,5], 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "[1,3,1,5,4], 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode611.json",
    "problem_index_in_file": 0,
    "title": "Valid Triangle Number",
    "description_snippet": "Given an integer array nums, return the number of triplets chosen from the array that can make trian...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, with comments. Problem: count number of triplets in array that can form triangle: for sides a,b,c with a<b<c: need a+b>c. Standard approach: sort array, then for each pair (i,j) find largest k such that nums[i]+nums[j]>nums[k]. Use two loops i<j<k.\n\nWe produce pseudo code: Start, Step: sort nums. For i from 0 to n-3, for j from i+1 to n-2, find k. Use while loop or binary search.\n\nSimplify: Use for i, for j, set k=j+1; while k<n and nums[i]+nums[j]>nums[k], k++. Then add k-j-1 to count.\n\nAlternatively binary search: For each i,j, use binary search on index>j to find largest valid k. But we'll use while pointer.\n\nWe must output line by line, with virtual code arrow lines. Provide comments. Use structure like Start, → Step 1: sort array.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 將陣列 nums 進行升序排序 // 方便使用三角不等式\n→ Step 2: 初始化變數 count 為 0 // 用來累計符合條件的三元組數\n→ Step 3: 取得陣列長度 n = nums.length // 方便迴圈範圍判斷\n→ Decision: n < 3? // 若元素不足三個則無法構成三角形\n    Yes → Step 4: Return 0 // 直接回傳 0\n    No  →\n→ Step 5: 外層迴圈 for i from 0 to n-3 // i 為第一條邊\n→ Decision: i < n-2? // 確保至少還有兩個元素可作第二、第三條邊\n    Yes → Step 6: 中層迴圈 for j from i+1 to n-2 // j 為第二條邊\n    No  →\n→ Decision: j < n-1? // 確保還有第三條邊存在\n    Yes → Step 7: 初始化 k = j+1 // k 為第三條邊的指標\n    No  →\n→ Decision: k < n? // 確保指標未超過陣列長度\n    Yes → Step 8: while nums[i] + nums[j] > nums[k] and k < n // 連續檢查能否以 nums[k] 作第三邊\n        → Step 9: k = k + 1 // 使 k 指向下一個可能的第三邊\n    No  →\n→ Step 10: count = count + (k - j - 1) // 所有在 j 與 k 之間的索引皆可成三角形\n→ Step 11: 迴圈結束 // 返回 count\nEnd // 程式執行結束\n\nNeed to keep the indentation for Decision branches maybe. But keep lines as plain.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將陣列 nums 進行升序排序 // 方便後續使用三角不等式  \n→ Step 2: 初始化變數 count 為 0 // 用來累計符合條件的三元組數  \n→ Step 3: 取得陣列長度 n = nums.length // 方便迴圈範圍判斷  \n→ Decision: n < 3? // 若元素不足三個則無法構成三角形  \n Yes → Step 4: Return 0 // 直接回傳 0  \n No →  \n→ Step 5: 外層迴圈 for i from 0 to n-3 // i 為第一條邊  \n Decision: i < n-2? // 確保至少還有兩個元素可作第二、第三條邊  \n  Yes → Step 6: 中層迴圈 for j from i+1 to n-2 // j 為第二條邊  \n  No →  \n  Decision: j < n-1? // 確保還有第三條邊存在  \n   Yes → Step 7: 初始化 k = j+1 // k 為第三條邊的指標  \n   No →  \n  Decision: k < n? // 確保指標未超過陣列長度  \n   Yes → Step 8: while nums[i] + nums[j] > nums[k] and k < n // 連續檢查能否以 nums[k] 作第三邊  \n    → Step 9: k = k + 1 // 使 k 指向下一個可能的第三邊  \n   No →  \n  Step 10: count = count + (k - j - 1) // 所有在 j 與 k 之間的索引皆可成三角形  \n→ Step 11: 回傳 count // 完成計算並回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def triangleNumber(self, nums):\n        \"\"\"計算能形成三角形的三元組數量\"\"\"\n        nums.sort()                       # 先排序，方便使用三角不等式\n        count = 0\n        n = len(nums)\n        for k in range(n - 1, 1, -1):      # k 為第三邊的索引，從右往左\n            i, j = 0, k - 1                # i、j 為前兩條邊的指標\n            while i < j:\n                if nums[i] + nums[j] > nums[k]:\n                    # 當 nums[i] + nums[j] > nums[k] 時，所有 i~j-1 的 i 都能與 j、k 組成三角形\n                    count += j - i\n                    j -= 1\n                else:\n                    i += 1\n        return count\n\ndef main():\n    # 從標準輸入讀取整段資料\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取出陣列部分，允許輸入如 \"nums = [2,2,3,4]\" 或直接 \"[2,2,3,4]\"\n    try:\n        start = data.index('[')\n        end = data.rindex(']') + 1\n        list_str = data[start:end]\n    except ValueError:\n        list_str = data\n\n    # 安全地解析為 Python list\n    nums = ast.literal_eval(list_str)\n\n    sol = Solution()\n    result = sol.triangleNumber(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [4,2,3,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode3.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring Without Repeating Characters",
    "description_snippet": "Given a string s, find the length of the longest substring without duplicate characters....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for longest substring without repeating characters. Use sliding window. Provide line-by-line virtual code with explanation. Each line: \"虛擬碼步驟 // 解釋\". Use arrow, Start, Decision. Ensure structure.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化哈希表 visited 字典，left = 0, maxLen = 0 // 初始化\n→ Decision: 遍歷每個字符 char 在 s 的索引 i? // 迴圈\n    Yes → Step 2: 如果 char 已存在於 visited 且 visited[char] >= left? // 重複\n        Yes → Step 3: left = visited[char] + 1 // 移動左指標\n    No  → // 這裡不做任何\n    → Step 4: 更新 visited[char] = i // 記錄索引\n    → Step 5: maxLen = max(maxLen, i - left + 1) // 更新最大長度\nEnd\n\nBut must be arrow lines with Decision. For each decision, indent. Provide step numbers maybe. We'll produce using arrows.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 visited 為空字典，left ← 0，maxLen ← 0 // 設置滑動窗口起始點與最大長度  \n→ Decision: 對於 i 從 0 到 len(s)-1，取字符 c ← s[i]? // 遍歷字符串中的每個字符  \n  Yes → Step 2: 如果 c 在 visited 且 visited[c] ≥ left? // 檢查是否已在當前窗口內重複  \n   Yes → Step 3: left ← visited[c] + 1 // 把左指標移到重複字符右側  \n   No → // 若未重複，則不改動左指標  \n  → Step 4: visited[c] ← i // 更新字符最後出現位置  \n  → Step 5: maxLen ← max(maxLen, i - left + 1) // 計算並更新最大子串長度  \nEnd // 程式執行結束，返回 maxLen 為最長不重複子串長度",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        \"\"\"Return the length of the longest substring without repeating characters.\"\"\"\n        last_seen = {}          # 存放字符最近一次出現的位置\n        left = 0                # 左指標，窗口左邊界\n        max_len = 0\n\n        for right, char in enumerate(s):\n            # 如果該字符已在窗口內，將左指標移到它上次出現位置的下一個位置\n            if char in last_seen and last_seen[char] >= left:\n                left = last_seen[char] + 1\n            last_seen[char] = right           # 更新字符最新位置\n            max_len = max(max_len, right - left + 1)  # 更新最大長度\n\n        return max_len\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，支持「s = \"abcabcbb\"」或直接輸入字串\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 從輸入中提取字串\n    match = re.search(r'\"(.*)\"', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有引號，直接視整個輸入為字串\n        s = raw_input\n\n    result = Solution().lengthOfLongestSubstring(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcabcbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"bbbbb\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \"pwwkew\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode715.json",
    "problem_index_in_file": 0,
    "title": "Range Module",
    "description_snippet": "A Range Module is a module that tracks ranges of numbers. Design a data structure to track the range...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. We must design a data structure. We should likely use an interval tree or a sorted list of non-overlapping intervals. We will produce steps to implement class, methods. Provide start, end. The virtual code is step by step, not actual code. So we need to describe logic like Start, Step 1: 初始化 interval list, etc. Use Decision, loops.\n\nLet's outline:\n\nStart\nStep 1: 初始化空的 interval list // list of [l,r] sorted, non-overlapping\nStep 2: Define addRange method\n   2.1: Find position to insert left, merging with overlapping intervals\n   2.2: Remove fully covered intervals\n   2.3: Insert new interval merging with neighbors\nStep 3: Define queryRange\n   3.1: Find interval containing left\n   3.2: If not found or right > that interval's end, return false\n   3.3: Else true\nStep 4: Define removeRange\n   4.1: Find intervals overlapping with [left,right)\n   4.2: For each, adjust or split\n   4.3: Remove fully overlapped intervals\nEnd\n\nBut must be line-by-line. Use arrows.\n\nWe must include \"Start\" and \"End\". Each line: \"虛擬碼步驟 // 解釋\". Use arrow for transitions.\n\nWe need to use \"→\" for steps, \"Decision:\" etc. Also use \"Yes →\" \"No →\".\n\nWe should produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 empty interval list // 用於存放已追蹤的半開區間\n\nThen maybe \"→ Decision: 是否有初始資料?\" but not needed.\n\nImplement methods as separate sections.\n\nLet's produce.\n\nWe might produce code skeleton like:\n\nClass RangeModule\n  → Step 2: 宣告 intervals // 儲存已追蹤區間\n  → Step 3: constructor // 初始化 intervals 為空\n\nThen each method.\n\nBut we need to output \"虛擬碼步驟\" lines. Use \"→\" for each step. For method definitions, we can use \"→ Step X: 方法 addRange(left,right)\" etc.\n\nBut the user wants \"逐行地產生對應的虛擬碼\". So we should produce code lines describing each step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 RangeModule // 建立區間追蹤結構\n→ Step 2: 宣告 intervals: List of pairs // 儲存已追蹤的半開區間，保持排序且無重疊\n→ Step 3: 定義構造函數 RangeModule() // 初始化 intervals 為空\n\n→ Step 4: 定義方法 addRange(left, right) // 增加區間\n    → Decision: intervals 是否為空? // 判斷是否已有區間\n        Yes → Step 5: 插入 [left,right] 為唯一區間 // 新增整個區間\n        No  → Step 6: 搜尋左側插入點 idxL // 找到第一個 interval.end >= left\n        → Step 7: 搜尋右側插入點 idxR // 找到最後一個 interval.start <= right\n        → Decision: idxL <= idxR? // 是否有重疊區間\n            Yes → Step 8: 計算 newLeft = min(left, intervals[idxL].start)\n            → Step 9: 計算 newRight = max(right, intervals[idxR].end)\n            → Step 10: 刪除 intervals[idxL … idxR] // 移除已重疊的區間\n            → Step 11: 插入 [newLeft, newRight] // 新的合併區間\n            No  → Step 12: 插入 [left,right] // 沒重疊，直接插入並保持排序\n\n→ Step 13: 定義方法 queryRange(left, right) // 查詢區間\n    → Decision: intervals 是否存在 interval 使 interval.start <= left < interval.end? // 判斷左端是否被追蹤\n        No  → Step 14: 回傳 False // 左端不在任何區間內\n        Yes → Step 15: 取得該 interval // 進一步檢查右端\n            → Decision: right <= interval.end? // 右端是否在同一區間內\n                Yes → Step 16: 回傳 True // 整個 [left,right) 被追蹤\n                No  → Step 17: 回傳 False // 右端超出追蹤區間\n\n→ Step 18: 定義方法 removeRange(left, right) // 移除區間\n    → Decision: intervals 是否為空? // 若無區間直接返回\n        Yes → Step 19: 返回 // 無需處理\n        No  → Step 20: 搜尋所有與 [left,right) 重疊的區間 idxL … idxR\n        → Step 21: 針對每個重疊區間進行調整\n            → Decision: intervals[i].start < left? // 是否需要保留左半部分\n                Yes → Step 22: 若 intervals[i].end > right? // 兩端都保留\n                    Yes → Step 23: 將 intervals[i] 分成兩個區間: [intervals[i].start, left) 與 [right, intervals[i].end)\n                    No  → Step 24: 將 intervals[i].end = left // 只保留左半部分\n                No → Decision: intervals[i].end > right? // 只保留右半部分\n                    Yes → Step 25: 將 intervals[i].start = right // 只保留右半部分\n                    No  → Step 26: 刪除 intervals[i] // 完全被覆蓋\n\nEnd // 程式執行結束\n\nThis is good. But we need to format each line with \"虛擬碼步驟 // 解釋\". Also we need to use \"→\" and \"Decision:\" etc. Each line must be separate. Use \"Start\" and \"End\".\n\nWe should keep each line as one step. Let's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 RangeModule // 建立區間追蹤結構  \n→ Step 2: 宣告 intervals: List of pairs // 儲存已追蹤的半開區間，保持排序且無重疊  \n→ Step 3: 定義構造函數 RangeModule() // 初始化 intervals 為空  \n\n→ Step 4: 定義方法 addRange(left, right) // 增加區間  \n    → Decision: intervals 是否為空? // 判斷是否已有區間  \n        Yes → Step 5: 插入 [left,right] 為唯一區間 // 新增整個區間  \n        No  → Step 6: 搜尋左側插入點 idxL // 找到第一個 interval.end >= left  \n        → Step 7: 搜尋右側插入點 idxR // 找到最後一個 interval.start <= right  \n        → Decision: idxL <= idxR? // 是否有重疊區間  \n            Yes → Step 8: 計算 newLeft = min(left, intervals[idxL].start) // 取最左端  \n            → Step 9: 計算 newRight = max(right, intervals[idxR].end) // 取最右端  \n            → Step 10: 刪除 intervals[idxL … idxR] // 移除已重疊的區間  \n            → Step 11: 插入 [newLeft, newRight] // 新的合併區間  \n            No  → Step 12: 插入 [left,right] // 沒重疊，直接插入並保持排序  \n\n→ Step 13: 定義方法 queryRange(left, right) // 查詢區間  \n    → Decision: intervals 是否存在 interval 使 interval.start <= left < interval.end? // 判斷左端是否被追蹤  \n        No  → Step 14: 回傳 False // 左端不在任何區間內  \n        Yes → Step 15: 取得該 interval // 進一步檢查右端  \n            → Decision: right <= interval.end? // 右端是否在同一區間內  \n                Yes → Step 16: 回傳 True // 整個 [left,right) 被追蹤  \n                No  → Step 17: 回傳 False // 右端超出追蹤區間  \n\n→ Step 18: 定義方法 removeRange(left, right) // 移除區間  \n    → Decision: intervals 是否為空? // 若無區間直接返回  \n        Yes → Step 19: 返回 // 無需處理  \n        No  → Step 20: 搜尋所有與 [left,right) 重疊的區間 idxL … idxR  \n        → Step 21: 針對每個重疊區間進行調整  \n            → Decision: intervals[i].start < left? // 是否需要保留左半部分  \n                Yes → Decision: intervals[i].end > right? // 兩端都保留  \n                    Yes → Step 22: 將 intervals[i] 分成兩個區間: [intervals[i].start, left) 與 [right, intervals[i].end) // 左右兩端皆保留  \n                    No  → Step 23: 將 intervals[i].end = left // 只保留左半部分  \n                No → Decision: intervals[i].end > right? // 只保留右半部分  \n                    Yes → Step 24: 將 intervals[i].start = right // 只保留右半部分  \n                    No  → Step 25: 刪除 intervals[i] // 完全被覆蓋  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []  # list of [start, end), non-overlapping, sorted\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:  # overlapping\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i - 1][0] <= left and right <= self.ranges[i - 1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    rm = RangeModule()\n    outputs = []\n\n    for line in data:\n        line = line.strip()\n        if not line:\n            continue\n        # remove semicolon and newlines\n        line = line.replace(';', '')\n        # skip initialization line\n        if line.startswith('RangeModule') or line.startswith('rangeModule = new RangeModule()'):\n            continue\n        # replace punctuation with spaces for easy split\n        cleaned = line.replace(')', ' ').replace('(', ' ').replace(',', ' ').split()\n        if not cleaned:\n            continue\n        cmd = cleaned[0]\n        if cmd == 'addRange' and len(cleaned) >= 3:\n            left, right = int(cleaned[1]), int(cleaned[2])\n            rm.addRange(left, right)\n            outputs.append('null')\n        elif cmd == 'removeRange' and len(cleaned) >= 3:\n            left, right = int(cleaned[1]), int(cleaned[2])\n            rm.removeRange(left, right)\n            outputs.append('null')\n        elif cmd == 'queryRange' and len(cleaned) >= 3:\n            left, right = int(cleaned[1]), int(cleaned[2])\n            res = rm.queryRange(left, right)\n            outputs.append('true' if res else 'false')\n        else:\n            # unknown command, ignore\n            continue\n\n    print('[' + ', '.join(outputs) + ']')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode641.json",
    "problem_index_in_file": 0,
    "title": "Design Circular Deque",
    "description_snippet": "Design your implementation of the circular double-ended queue (deque).\n\nImplement the MyCircularDequ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanations line by line. Need to design MyCircularDeque implementation. Use a circular array. Provide steps: Start, initialize array, front, rear, count. Provide methods.\n\nWe need to output in that format: each line: \"虛擬碼步驟 // 解釋\". Use arrows. Let's structure like:\n\nStart\n→ 初始化 MyCircularDeque: allocate array of size k, front = 0, rear = k-1, count = 0\n→ Method insertFront(value):\n    Decision: 如果 isFull? Yes → return false No →\n    front = (front - 1 + k) % k\n    array[front] = value\n    count++\n    return true\nAnd similar for insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.\n\nWe need to maintain separate methods. Provide each as separate blocks. Use arrow for each step. Each line should be a single step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ 初始化 MyCircularDeque(k): \n    array = new int[k] // 用於存儲元素\n    front = 0 // 前端指標\n    rear = k-1 // 後端指標\n    count = 0 // 目前元素個數\nEnd // 建構完成\n\nThen methods:\n\nMethod: insertFront(value)\nStart // 執行 insertFront\n→ Decision: 如果 count == k? // 判斷是否已滿\n    Yes → return false // 不能插入\n    No  → \n        front = (front - 1 + k) % k // 向前移動前端指標\n        array[front] = value // 存入值\n        count++ // 元素個數加一\n        return true // 插入成功\nEnd\n\nSimilarly for insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.\n\nWe need to ensure each line is a step, but can include sub-steps. Use indentation maybe? Not required. Just each line separated. For Decision block, we can include Yes → ... No → ... lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化 MyCircularDeque(k):  \n array = new int[k] // 用於存儲元素  \n front = 0 // 前端指標  \n rear = k-1 // 後端指標  \n count = 0 // 目前元素個數  \nEnd // 建構完成  \n\nMethod: insertFront(value) // 新增前端元素  \nStart // 執行 insertFront  \n→ Decision: 如果 count == k? // 判斷是否已滿  \n Yes → return false // 不能插入，已滿  \n No →  \n  front = (front - 1 + k) % k // 向前移動前端指標  \n  array[front] = value // 存入值  \n  count++ // 元素個數加一  \n  return true // 插入成功  \nEnd  \n\nMethod: insertLast(value) // 新增後端元素  \nStart // 執行 insertLast  \n→ Decision: 如果 count == k? // 判斷是否已滿  \n Yes → return false // 不能插入，已滿  \n No →  \n  rear = (rear + 1) % k // 向後移動後端指標  \n  array[rear] = value // 存入值  \n  count++ // 元素個數加一  \n  return true // 插入成功  \nEnd  \n\nMethod: deleteFront() // 刪除前端元素  \nStart // 執行 deleteFront  \n→ Decision: 如果 count == 0? // 判斷是否為空  \n Yes → return false // 無法刪除，空  \n No →  \n  front = (front + 1) % k // 向後移動前端指標  \n  count-- // 元素個數減一  \n  return true // 刪除成功  \nEnd  \n\nMethod: deleteLast() // 刪除後端元素  \nStart // 執行 deleteLast  \n→ Decision: 如果 count == 0? // 判斷是否為空  \n Yes → return false // 無法刪除，空  \n No →  \n  rear = (rear - 1 + k) % k // 向前移動後端指標  \n  count-- // 元素個數減一  \n  return true // 刪除成功  \nEnd  \n\nMethod: getFront() // 取得前端元素  \nStart // 執行 getFront  \n→ Decision: 如果 count == 0? // 判斷是否為空  \n Yes → return -1 // 空時回傳 -1  \n No →  \n  return array[front] // 回傳前端值  \nEnd  \n\nMethod: getRear() // 取得後端元素  \nStart // 執行 getRear  \n→ Decision: 如果 count == 0? // 判斷是否為空  \n Yes → return -1 // 空時回傳 -1  \n No →  \n  return array[rear] // 回傳後端值  \nEnd  \n\nMethod: isEmpty() // 檢查是否為空  \nStart // 執行 isEmpty  \n→ return count == 0 // 為空則回傳 true，否則 false  \nEnd  \n\nMethod: isFull() // 檢查是否已滿  \nStart // 執行 isFull  \n→ return count == k // 已滿則回傳 true，否則 false  \nEnd  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0\n        self.count = 0\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])\n    args = json.loads(data[1]) if len(data) > 1 else []\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(arg[0])\n            res.append(None)\n        elif op == \"insertFront\":\n            res.append(obj.insertFront(arg[0]))\n        elif op == \"insertLast\":\n            res.append(obj.insertLast(arg[0]))\n        elif op == \"deleteFront\":\n            res.append(obj.deleteFront())\n        elif op == \"deleteLast\":\n            res.append(obj.deleteLast())\n        elif op == \"getFront\":\n            res.append(obj.getFront())\n        elif op == \"getRear\":\n            res.append(obj.getRear())\n        elif op == \"isEmpty\":\n            res.append(obj.isEmpty())\n        elif op == \"isFull\":\n            res.append(obj.isFull())\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmprz3ndc03.py\", line 88, in <module>\n    main()\n  File \"/tmp/tmprz3ndc03.py\", line 61, in main\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode410.json",
    "problem_index_in_file": 0,
    "title": "Split Array Largest Sum",
    "description_snippet": "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the la...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps for algorithm to split array into k subarrays minimize largest sum. Classic problem: split array largest sum minimal: binary search on answer, using greedy check.\n\nWe should output step by step pseudocode, each line with explanation.\n\nInclude Start, End, Decision, Steps.\n\nWe need to output each line in plain text, no code.\n\nLet's produce something like:\n\nStart\n→ Step 1: Set low = max(nums), high = sum(nums) // bounds\n→ Decision: while low < high? etc.\n\nWe need to produce line by line.\n\nBe careful about using arrow arrow, indent for decisions.\n\nLet's craft pseudocode.\n\nWe'll structure:\n\nStart\n→ Step 1: low = max(nums) // min possible largest sum\n→ Step 2: high = sum(nums) // max possible largest sum\n→ Decision: while low < high? // binary search loop\n    → Step 3: mid = (low + high) // 2 // candidate largest sum\n    → Step 4: if canSplit(nums, k, mid) then high = mid else low = mid + 1 // adjust bounds\n→ Step 5: Return low // minimal largest sum\nEnd\n\nWe also need to describe canSplit function:\n\n→ Function canSplit(nums, k, target)\n    → Step 6: count = 1 // current subarray\n    → Step 7: currentSum = 0\n    → For each num in nums\n        → Step 8: if currentSum + num <= target\n            → currentSum += num\n        → Else\n            → count += 1\n            → currentSum = num\n        → Decision: if count > k?\n            → return False\n    → Return True\n\nBut we should incorporate in pseudocode lines.\n\nWe can embed within same flow.\n\nProbably easier: after Step 4, we call canSplit; inside we provide pseudo.\n\nWe must use arrows appropriately.\n\nLet's create:\n\nStart\n→ Step 1: low = max(nums) // min possible largest sum\n→ Step 2: high = sum(nums) // max possible largest sum\n→ Decision: while low < high? // binary search\n    → Step 3: mid = (low + high) // 2 // candidate\n    → Step 4: Decision: if canSplit(nums, k, mid)? // check feasibility\n        Yes → high = mid // try smaller maximum\n        No  → low = mid + 1 // need larger maximum\n→ Step 5: Return low // minimal largest sum\nEnd\n\nNow define canSplit:\n\n→ Function canSplit(nums, k, target) // returns True/False\n    → Step 6: count = 1\n    → Step 7: current = 0\n    → For each n in nums\n        → Decision: if current + n <= target? // fits current subarray\n            Yes → current += n\n            No  → count += 1 // start new subarray\n                  current = n\n        → Decision: if count > k? // exceed allowed splits\n            Yes → return False\n    → Return True // all numbers split within k subarrays\n\nAdd arrows accordingly.\n\nNeed to maintain formatting: each line \"→\" maybe used.\n\nWe must ensure each line ends with // explanation.\n\nLet's format lines as:\n\nStart // 程式開始執行\n→ Step 1: low = max(nums) // 初始最小最大子陣列和為陣列最大值\n→ Step 2: high = sum(nums) // 初始最大最大子陣列和為所有元素之和\n→ Decision: while low < high? // 進行二分搜尋尋找最小可行最大和\n    → Step 3: mid = (low + high) // 2 // 候選最大和\n    → Decision: if canSplit(nums, k, mid)? // 檢查此候選是否能切割成 k 個子陣列\n        Yes → high = mid // 若可行，嘗試更小的最大和\n        No  → low = mid + 1 // 若不可行，需增大最大和\n→ Step 4: Return low // low 為最小化後的最大子陣列和\nEnd // 程式結束\n\nThen define canSplit:\n\n→ Function canSplit(nums, k, target) // 判斷是否能在 target 最大和下切成 ≤k 個子陣列\n    → Step 5: count = 1 // 初始子陣列數\n    → Step 6: currentSum = 0 // 當前子陣列和\n    → For each n in nums\n        → Decision: if currentSum + n <= target? // 若加上 n 不超過 target\n            Yes → currentSum += n // 加入當前子陣列\n            No  → count += 1 // 新子陣列\n                  currentSum = n\n        → Decision: if count > k? // 子陣列數超過 k\n            Yes → return False\n    → Return True // 能在 k 個子陣列內完成\n\nBut each line after '→' should be separate. For loops need separate lines.\n\nLet's write lines like:\n\n→ Function canSplit(nums, k, target)\n→     Step 5: count = 1\n→     Step 6: currentSum = 0\n→     For each n in nums\n→         Decision: if currentSum + n <= target?\n→             Yes → currentSum += n\n→             No  → count += 1\n→                 currentSum = n\n→         Decision: if count > k?\n→             Yes → return False\n→     Return True\n\nBut indentation can be indicated by spaces. Each line after '→' may include spaces.\n\nNeed to follow arrow usage: For decisions inside function, use Decision:.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = max(nums) // 初始最小最大子陣列和為陣列最大值  \n→ Step 2: high = sum(nums) // 初始最大最大子陣列和為所有元素之和  \n→ Decision: while low < high? // 進行二分搜尋尋找最小可行最大和  \n    → Step 3: mid = (low + high) // 2 // 候選最大和  \n    → Decision: if canSplit(nums, k, mid)? // 檢查此候選是否能切割成 k 個子陣列  \n        Yes → high = mid // 若可行，嘗試更小的最大和  \n        No  → low = mid + 1 // 若不可行，需增大最大和  \n→ Step 4: Return low // low 為最小化後的最大子陣列和  \nEnd // 程式結束  \n\n→ Function canSplit(nums, k, target) // 判斷是否能在 target 最大和下切成 ≤k 個子陣列  \n→     Step 5: count = 1 // 初始子陣列數  \n→     Step 6: currentSum = 0 // 當前子陣列和  \n→     For each n in nums  \n→         Decision: if currentSum + n <= target? // 若加上 n 不超過 target  \n→             Yes → currentSum += n // 加入當前子陣列  \n→             No  → count += 1 // 開啟新子陣列  \n→                 currentSum = n  \n→         Decision: if count > k? // 子陣列數超過 k  \n→             Yes → return False  \n→     Return True // 能在 k 個子陣列內完成切割",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def splitArray(self, nums, m):\n        def can_split(mid):\n            count, curr_sum = 1, 0\n            for num in nums:\n                if curr_sum + num > mid:\n                    count += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return count <= m\n        \n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if can_split(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match = re.search(r',\\s*k\\s*=\\s*(\\d+)', data)\n    if not nums_match or not k_match:\n        return\n\n    nums_str = nums_match.group(1)\n    nums = ast.literal_eval(nums_str)\n    k = int(k_match.group(1))\n\n    solution = Solution()\n    result = solution.splitArray(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [7,2,5,10,8], k = 2",
          "expected_output": "18",
          "success": true,
          "output": "18"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,5], k = 2",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode274.json",
    "problem_index_in_file": 0,
    "title": "H-Index",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for computing h-index. Should be step-by-step, each line with arrow and comment. Use Start, End, Decision, etc. Avoid real code. Just high-level pseudocode steps. Should cover sorting or counting. Provide simple approach: sort descending, find first where index+1 > citation. Use count.\n\nWe need to output each line: \"Start // 程式開始執行\" etc. Use arrows.\n\nLet's produce:\n\nStart\n→ Step 1: 取得 citations 陣列 // 從輸入取得\n→ Step 2: 以降序排序 citations // 讓高引用排前面\n→ Step 3: 初始化 hIndex 為 0 // 先假設\n→ Step 4: 針對每個排序後的引用 i 從 0 開始迭代 // 計算\n    → Decision: 如果 citations[i] >= i+1? // 判斷是否符合\n        Yes → Update hIndex = i+1 // 更新 hIndex\n        No → 跳出迴圈 // 無法再更新\n→ End // 完成\n\nWe need arrow for loop? Use Step 4 and inside we need Decision and loops.\n\nMaybe we can use For loop representation:\n\n→ For i from 0 to length-1: // 逐筆檢查\n    → Decision: 如果 citations[i] >= i+1? // ...\n        Yes → hIndex = i+1\n        No → 斷開迴圈\n\nBut we need proper arrow for break.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: citations ← 輸入陣列 // 取得論文引用次數\n→ Step 2: citations ← 論文引用數降序排序 // 讓高引用值靠前\n→ Step 3: hIndex ← 0 // 初始化 h-index\n→ Step 4: 針對每個索引 i 從 0 到 citations.length-1:\n    → Decision: citations[i] >= i+1? // 這篇論文至少被 i+1 次引用？\n        Yes → hIndex ← i+1 // 取得新的 h-index\n        No  → Break // 無法再提升 h-index，結束迴圈\nEnd // 程式執行結束\n\nBut need arrow formatting. Use → and maybe \"→ Step 4:\" then inside indent.\n\nLet's produce exactly:\n\nStart // 程式開始執行\n→ Step 1: citations ← 輸入陣列 // 取得論文引用次數\n→ Step 2: citations ← 論文引用數降序排序 // 讓高引用值靠前\n→ Step 3: hIndex ← 0 // 初始化 h-index\n→ Step 4: 針對每個索引 i 從 0 到 citations.length-1:\n    → Decision: citations[i] >= i+1? // 判斷是否符合 h-index 條件\n        Yes → hIndex ← i+1 // 更新 h-index 為 i+1\n        No  → Break // 不能再提升，結束迴圈\nEnd // 程式執行結束\n\nEnsure each line ends with // 解釋. Indentation maybe with spaces. But each line must start with virtual code step.\n\nBetter produce each line as separate line.\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: citations ← 輸入陣列 // 取得論文引用次數\n→ Step 2: citations ← 論文引用數降序排序 // 讓高引用值靠前\n→ Step 3: hIndex ← 0 // 初始化 h-index\n→ Step 4: 針對每個索引 i 從 0 到 citations.length-1:\n    → Decision: citations[i] >= i+1? // 判斷是否符合 h-index 條件\n        Yes → hIndex ← i+1 // 更新 h-index 為 i+1\n        No  → Break // 不能再提升，結束迴圈\nEnd // 程式執行結束\n\nBut \"→ Step 4:\" line includes colon; next lines indented. That is fine.\n\nWe should ensure each line contains arrow or \"Decision:\" etc. Indentation should be visible. Maybe add 4 spaces indent for nested lines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: citations ← 輸入陣列 // 取得論文引用次數  \n→ Step 2: citations ← 論文引用數降序排序 // 讓高引用值靠前  \n→ Step 3: hIndex ← 0 // 初始化 h-index  \n→ Step 4: 針對每個索引 i 從 0 到 citations.length-1:  \n    → Decision: citations[i] >= i+1? // 判斷此篇論文是否至少被 i+1 次引用  \n        Yes → hIndex ← i+1 // 更新 h-index 為 i+1  \n        No  → Break // 無法再提升 h-index，結束迴圈  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef h_index(citations):\n    \"\"\"計算 h-index：排序後找出最大的 h，使得至少有 h 篇論文每篇被引用至少 h 次。\"\"\"\n    citations.sort(reverse=True)\n    h = 0\n    for i, c in enumerate(citations):\n        if c >= i + 1:\n            h = i + 1\n        else:\n            break\n    return h\n\ndef main():\n    # 讀取全部輸入，預期格式如: \"citations = [3,0,6,1,5]\"\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 以 '=' 分割，取得方括號內的列表字串\n    try:\n        _, list_part = raw_input.split('=', 1)\n    except ValueError:\n        raise ValueError(\"輸入格式不正確，應為 'citations = [...]'\")\n    list_part = list_part.strip()\n    # 解析為 Python 列表\n    citations = ast.literal_eval(list_part)\n    # 計算 h-index\n    result = h_index(citations)\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [3,0,6,1,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "citations = [1,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode462.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements II",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following format. Steps: Start, read array, find median, compute moves as sum of abs differences from median. Use sorting to find median. So steps: Start, Step1: Input nums, Step2: n = length, Step3: sort nums, Step4: if n odd median=nums[n/2], else median = nums[n/2] (or average? For integer min moves, any between two middle works, choose lower median). Step5: initialize total = 0, Step6: for each num in nums: total += abs(num - median). Step7: Output total. End.\n\nNeed to add decision? Not many decisions. Possibly decision for even/odd. Use Decision block.\n\nThus produce lines:\n\nStart // 程式開始執行\n→ Step 1: 讀取整數陣列 nums // 從輸入取得陣列\n→ Step 2: n ← length(nums) // 取得陣列長度\n→ Step 3: sort(nums) // 依值排序以便找中位數\n→ Decision: n 為奇數? // 判斷是否為奇數長度\n    Yes → Step 4: median ← nums[n // 2] // 奇數時中位數為中間元素\n    No  → Step 5: median ← nums[n // 2] // 偶數時取左側中位數（任一值均可）\n→ Step 6: total ← 0 // 初始化總移動步數\n→ Step 7: for each x in nums // 遍歷陣列\n        → total ← total + abs(x - median) // 加上與中位數差的絕對值\n→ Step 8: output total // 顯示最小移動步數\nEnd // 程式執行結束\n\nNeed ensure each line ends with // 解釋. Use arrow. For For loop we might have nested line: we need arrow indent? Use standard pattern: arrow with indent? Provide as new line.\n\nWe'll produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取整數陣列 nums // 從輸入取得陣列\n→ Step 2: n ← length(nums) // 取得陣列長度\n→ Step 3: sort(nums) // 依值排序以便找中位數\n→ Decision: n 為奇數? // 判斷陣列長度是否為奇數\n    Yes → Step 4: median ← nums[n // 2] // 奇數時中位數為中間元素\n    No  → Step 5: median ← nums[n // 2] // 偶數時取左側中位數（任一值均可）\n→ Step 6: total ← 0 // 初始化總移動步數\n→ Step 7: for each x in nums // 遍歷陣列中的每個元素\n        → total ← total + abs(x - median) // 加上與中位數差的絕對值\n→ Step 8: output total // 顯示最小移動步數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def minMoves2(self, nums):\n        \"\"\"\n        找出將所有元素調整到同一值所需的最小步數。\n        對於 1 步加減的操作，將所有數字移到中位數可使總步數最小。\n        \"\"\"\n        nums.sort()\n        median = nums[len(nums) // 2]  # 取中位數（對偶數長度可任選一個中位數）\n        moves = 0\n        for num in nums:\n            moves += abs(num - median)\n        return moves\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入為 nums 列表\n    if 'nums' in data:\n        _, _, list_str = data.partition('=')\n        nums = ast.literal_eval(list_str.strip())\n    else:\n        nums = ast.literal_eval(data)\n\n    # 計算並輸出結果\n    solution = Solution()\n    result = solution.minMoves2(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,10,2,9]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode209.json",
    "problem_index_in_file": 0,
    "title": "Minimum Size Subarray Sum",
    "description_snippet": "Given an array of positive integers nums and a positive integer target, return the minimal length of...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem: minimal length of subarray sum >= target. Classic sliding window. So we need steps: Start, input, init pointers, sum, minLen = large, iterate with right pointer, add nums[right], while sum >= target: update minLen, subtract nums[left], left++. After loop, if minLen unchanged, return 0 else return minLen. End.\n\nWe must output each line: \"虛擬碼步驟 // 解釋\". Use arrow for steps. Also use Decision: Yes, No.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 nums 與目標值 target // 取得參數\n→ Step 2: 初始化左指標 left = 0，右指標 right = 0，當前和 currentSum = 0，最小長度 minLen = 無限大 // 設定初始變數\n→ Decision: 右指標 right 是否小於 nums.length? // 開始滑動窗口\n    Yes → Step 3: 將 nums[right] 加到 currentSum，right += 1 // 向右擴展窗口\n    No  → Decision: minLen 是否仍為無限大? // 確認是否找到符合條件的子陣列\n        Yes → Step 4: 返回 0 // 沒有找到\n        No  → Step 5: 返回 minLen // 返回最小長度\n→ Decision: currentSum 是否 ≥ target? // 判斷是否需要收縮左側\n    Yes → Step 6: 更新 minLen 為 min(minLen, right - left) // 計算當前窗口長度\n        → Step 7: 從 currentSum 中減去 nums[left]，left += 1 // 收縮左側\n        → Decision: currentSum 是否仍 ≥ target? // 仍可能需要繼續收縮\n            Yes → ...（重複 Step 6-7） // 透過迴圈\n            No  → Back to Decision: 右指標 right 是否小於 nums.length? // 回到右移\n    No  → Back to Decision: 右指標 right 是否小於 nums.length? // 直接右移\n\nBut we need structure: arrow lines. We can use \"→\" for steps. For decisions use \"Decision:\".\n\nWe must produce each line separately.\n\nLet's outline:\n\n1. Start // ...\n2. → Step 1: 輸入 nums, target\n3. → Step 2: left=0; right=0; currentSum=0; minLen=∞\n4. → Decision: right < nums.length?\n5. Yes → Step 3: currentSum += nums[right]; right += 1\n6. No → Decision: minLen == ∞?\n7. Yes → Step 4: 返回 0\n8. No  → Step 5: 返回 minLen\n9. Decision: currentSum >= target?\n10. Yes → Step 6: minLen = min(minLen, right - left)\n11. → Step 7: currentSum -= nums[left]; left += 1\n12. → Decision: currentSum >= target?\n13. Yes → (loop back to Step 6) but we should not duplicate lines? But we can write: → Step 6 again? It's okay. Maybe we can use a loop label? But each line is separate.\n\nBut the format requires that each line has one virtual code step. We can use \"→\" before each step or decision. For decisions, we use \"Decision:\".\n\nAlso we need to ensure the arrow is before each line? The format shows:\n\nStart // 程式開始執行\n→ Step 1: ...\n→ Decision: ... ?\n\nYes.\n\nThus each line must start with either Start, End, or \"→\" or \"Decision:\"? The example uses \"→\" for steps and \"Decision:\" for decisions. But the example used \"Decision:\" without arrow? Actually in example:\n\n```\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // ...\n    No  → Decision: ...\n```\n\nSo Decision: lines start with \"→ Decision:\"? They used \"→ Decision:\"? Wait example: \"→ Decision: 如果數字大於 0?\" Yes it had arrow. So each line starts with \"→\" for steps or decisions.\n\nThus we must start each line with \"→\" except Start and End. Example: Start, End have no arrow.\n\nThus produce lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入 nums 與 target // 取得輸入參數\n→ Step 2: 初始化 left = 0, right = 0, currentSum = 0, minLen = ∞ // 設定初始變數\n→ Decision: right < nums.length? // 判斷是否還有元素可擴展窗口\n    Yes → Step 3: currentSum += nums[right]; right += 1 // 向右擴大窗口\n    No  → Decision: minLen == ∞? // 檢查是否有符合條件的子陣列\n        Yes → Step 4: 返回 0 // 沒有找到\n        No  → Step 5: 返回 minLen // 返回最小長度\n→ Decision: currentSum >= target? // 判斷是否需要收縮左側\n    Yes → Step 6: minLen = min(minLen, right - left) // 更新最小長度\n        → Step 7: currentSum -= nums[left]; left += 1 // 收縮左側\n        → Decision: currentSum >= target? // 仍可能需要繼續收縮\n            Yes → Step 6 // 重新檢查（迴圈）\n            No  → Back to Decision: right < nums.length? // 回到擴展窗口\n    No  → Back to Decision: right < nums.length? // 直接擴展窗口\nEnd // 程式結束執行\n\nBut we must use arrow for all lines, including the \"Back to\" etc. But maybe we don't need Back to lines; we can structure with nested decisions; typical pseudo-code loops: while right < len(nums): ... while currentSum >= target: ... So we can represent:\n\n→ Decision: right < nums.length?\n    Yes → Step 3: currentSum += nums[right]; right += 1\n    Yes → Decision: currentSum >= target?\n        Yes → Step 6: minLen = min(minLen, right - left)\n            → Step 7: currentSum -= nums[left]; left += 1\n            → Decision: currentSum >= target? (loop)\n                Yes → (back to Step 6) ...\n                No  → (continue)\n    No  → Decision: minLen == ∞?\n        Yes → Step 4: 返回 0\n        No  → Step 5: 返回 minLen\n\nWe can produce linear steps with nested decisions. The pseudo-code should represent loops; we can use \"Yes →\" lines that refer back. But maybe easier: Use while loops as steps:\n\n→ Step 3: while right < nums.length:\n        currentSum += nums[right]; right += 1\n        while currentSum >= target:\n            minLen = min(minLen, right - left)\n            currentSum -= nums[left]; left += 1\n\nBut we must keep \"逐行\" and \"箭頭\". So maybe each loop can be represented by a step line with while? We can treat \"Step\" lines as while loops. Example:\n\n→ Step 3: while right < nums.length:\n        currentSum += nums[right]; right += 1\n        while currentSum >= target:\n            minLen = min(minLen, right - left)\n            currentSum -= nums[left]; left += 1\n\nBut the format expects each line a step. We can treat each line inside loops as nested steps but still keep arrow. So we need to flatten into lines with indentation maybe not required; but we can indent with spaces? The example had indentation for nested decisions but not required. We can just produce as separate lines but with indentation for clarity.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入 nums 與 target // 取得輸入參數\n→ Step 2: 初始化 left = 0, right = 0, currentSum = 0, minLen = ∞ // 設定初始變數\n→ Step 3: while right < nums.length: // 開始滑動窗口\n        currentSum += nums[right]; right += 1 // 向右擴大窗口\n        while currentSum >= target: // 需要收縮左側以尋找最小長度\n            minLen = min(minLen, right - left) // 更新最小長度\n            currentSum -= nums[left]; left += 1 // 收縮左側\n→ Decision: minLen == ∞? // 判斷是否找到子陣列\n    Yes → Step 4: 返回 0 // 沒有符合條件\n    No  → Step 5: 返回 minLen // 返回結果\nEnd // 程式結束執行\n\nBut we need each line to start with \"→\" or \"Start\"/\"End\". But \"Step 3:\" contains nested lines; the nested lines may not start with arrow? In example, nested lines inside decision start with arrow. So we should keep arrows for nested lines.\n\nThus we need:\n\n→ Step 3: while right < nums.length: // ...\n    → Step 3.1: currentSum += nums[right]; right += 1 // ...\n    → Step 3.2: while currentSum >= target: // ...\n        → Step 3.2.1: minLen = min(minLen, right - left) // ...\n        → Step 3.2.2: currentSum -= nums[left]; left += 1 // ...\n\nYes.\n\nThus produce.\n\nWe must be careful to keep consistent numbering? Not necessary but helpful.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 nums 與 target // 取得輸入參數  \n→ Step 2: 初始化 left = 0, right = 0, currentSum = 0, minLen = ∞ // 設定初始變數  \n→ Step 3: while right < nums.length: // 開始滑動窗口  \n → Step 3.1: currentSum += nums[right]; right += 1 // 向右擴大窗口  \n → Step 3.2: while currentSum >= target: // 需要收縮左側以尋找最小長度  \n  → Step 3.2.1: minLen = min(minLen, right - left) // 更新最小長度  \n  → Step 3.2.2: currentSum -= nums[left]; left += 1 // 收縮左側  \n→ Decision: minLen == ∞? // 判斷是否有符合條件的子陣列  \n Yes → Step 4: 返回 0 // 沒有找到符合條件的子陣列  \n No  → Step 5: 返回 minLen // 返回最小長度  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minSubArrayLen(self, target, nums):\n        left = 0\n        total = 0\n        min_len = float('inf')\n        for right in range(len(nums)):\n            total += nums[right]\n            while total >= target:\n                min_len = min(min_len, right - left + 1)\n                total -= nums[left]\n                left += 1\n        return 0 if min_len == float('inf') else min_len\n\ndef parse_input(data: str):\n    data = data.strip()\n    if not data:\n        return None, None\n    # Try to extract \"target = X, nums = [a,b,...]\"\n    target_match = re.search(r'target\\s*=\\s*([-\\d]+)', data)\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*\\])', data)\n    if target_match and nums_match:\n        target = int(target_match.group(1))\n        nums = eval(nums_match.group(1))\n        return target, nums\n    # Fallback: first token is target, rest are numbers\n    parts = re.split(r'[\\s,]+', data)\n    if not parts:\n        return None, None\n    target = int(parts[0])\n    nums = list(map(int, parts[1:]))\n    return target, nums\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    target, nums = parse_input(raw)\n    if target is None or nums is None:\n        print(0)\n    else:\n        sol = Solution()\n        result = sol.minSubArrayLen(target, nums)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "target = 7, nums = [2,3,1,2,4,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "target = 4, nums = [1,4,4]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode633.json",
    "problem_index_in_file": 0,
    "title": "Sum of Square Numbers",
    "description_snippet": "Given a non-negative integer c, decide whether there're two integers a and b such that a^2 + b^2 = c...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm that given a non-negative integer c, decides whether there exist integers a and b such that a^2 + b^2 = c. It's like checking if c can be expressed as sum of two squares.\n\nWe need to produce step-by-step algorithm in virtual code: Start, loop over a from 0 to sqrt(c), compute b^2 = c - a^2, check if b^2 is a perfect square. If yes, return true. If loop ends, return false. We need to include decision points etc.\n\nWe must adhere to output format: each line \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows.\n\nWe should also include \"Start\" and \"End\".\n\nWe can write:\n\nStart\n→ Decision: 是否 c < 0? No, assume non-negative; but we can include check.\nBut maybe just start.\n\nWe need to produce steps:\n\nStart // 程式開始執行\n→ Step 1: 計算 limit = floor(sqrt(c)) // 獲取 a 的上限\n→ Step 2: 設置 a = 0 // 初始化 a\n→ Decision: a <= limit? // 判斷 a 是否超出上限\n    Yes → Step 3: 計算 remainder = c - a^2 // 將 c 減去 a 的平方\n    → Step 4: 判斷 remainder 是否為完全平方 // 判斷是否存在 b\n        Yes → Step 5: 計算 b = sqrt(remainder) // 計算 b\n        → Step 6: 輸出 True // 找到符合條件，返回真\n        No  → Step 7: a = a + 1 // 進行下一個 a 值\n        → 回到 Decision: a <= limit? // 重新判斷\n    No  → Step 8: 輸出 False // 未找到，返回假\nEnd\n\nNeed to include arrow syntax like \"Yes →\" and \"No →\".\n\nAlso maybe include \"Decision:\" for decisions. Use \"Decision:\" for checks.\n\nLet's produce the virtual code accordingly. Ensure each line has \"//\" comment.\n\nWe need to adhere to \"逐行輸出\" and each line with \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow arrow characters.\n\nMake sure we use \"→\" after Step lines, but for decisions we use \"Decision:\" preceding arrow.\n\nBetter to follow the example formatting: each line: \"→ Step ...\" etc.\n\nAlso need to incorporate \"Yes →\" \"No →\".\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: limit = floor(sqrt(c)) // 計算 a 的最大值\n→ Step 2: a = 0 // 初始化 a\n→ Decision: a <= limit? // 檢查 a 是否在允許範圍內\n    Yes → Step 3: remainder = c - a^2 // 計算剩餘值\n    → Decision: remainder 是完全平方? // 判斷是否能得到整數 b\n        Yes → Step 4: b = sqrt(remainder) // 計算 b\n        → Step 5: output True // 找到符合條件的 (a,b)\n        No  → Step 6: a = a + 1 // 將 a 加 1 進行下一輪\n        → 回到 Decision: a <= limit? // 重新判斷 a 是否超出上限\n    No  → Step 7: a = a + 1 // 當 remainder 不是完全平方時，遞增 a\n    → 回到 Decision: a <= limit? // 重新判斷\nNo  → Step 8: output False // 所有 a 都嘗試完畢仍未找到，返回假\nEnd // 程式執行結束\n\nBut need to maintain consistent arrow usage: after a decision block, we list Yes → and No →.\n\nLet's format properly. The \"Decision:\" lines may be at indentation. The arrow after Yes or No points to next step. Use proper indentation.\n\nAlso each line should end with comment after //.\n\nEnsure no actual code, just virtual.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: limit = floor(sqrt(c)) // 計算 a 的最大值\n→ Step 2: a = 0 // 初始化 a\n→ Decision: a <= limit? // 檢查 a 是否在允許範圍內\n    Yes → Step 3: remainder = c - a^2 // 計算剩餘值\n    → Decision: remainder 是完全平方? // 判斷是否能得到整數 b\n        Yes → Step 4: b = sqrt(remainder) // 計算 b\n        → Step 5: output True // 找到符合條件的 (a,b)\n        No  → Step 6: a = a + 1 // 將 a 加 1 進行下一輪\n        → 回到 Decision: a <= limit? // 重新判斷 a 是否超出上限\n    No  → Step 7: a = a + 1 // 當 remainder 不是完全平方時，遞增 a\n    → 回到 Decision: a <= limit? // 重新判斷\nNo  → Step 8: output False // 所有 a 都嘗試完畢仍未找到，返回假\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport math\n\nclass Solution:\n    def judgeSquareSum(self, c: int) -> bool:\n        \"\"\"判斷是否能表示成兩個平方和的形式\"\"\"\n        left, right = 0, math.isqrt(c)          # 右指標初始化為 c 的整數平方根\n        while left <= right:\n            total = left * left + right * right\n            if total == c:\n                return True\n            elif total < c:\n                left += 1\n            else:\n                right -= 1\n        return False\n\ndef main() -> None:\n    \"\"\"主程式：從標準輸入讀取 c，並輸出結果\"\"\"\n    data = sys.stdin.read()\n    numbers = re.findall(r'\\d+', data)        # 擷取輸入中的整數\n    if not numbers:\n        return\n    c = int(numbers[0])\n    sol = Solution()\n    print('true' if sol.judgeSquareSum(c) else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "c = 5",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "c = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode667.json",
    "problem_index_in_file": 0,
    "title": "Beautiful Arrangement II",
    "description_snippet": "Given two integers n and k, construct a list answer that contains n different positive integers rang...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for constructing list answer with n distinct ints from 1..n such that absolute differences between consecutive elements produce exactly k distinct values.\n\nThis is a known problem. Approach: Construct array by starting from 1 and alternating adding 1 and subtracting 1? Actually known solution: Use first k+1 elements as 1, k+1, 2, k, 3, k-1,... to create k distinct differences. Then remaining elements just fill with remaining numbers.\n\nPseudo:\n\nInitialize answer list.\nleft=1, right=n\nUse pattern for k distinct differences:\nfor i in 0..k:\n    if i%2==0: append left; left++\n    else: append right; right--\nAfter constructing k+1 elements, append remaining numbers from left to right.\n\nThis gives exactly k distinct differences.\n\nWe'll produce virtual steps.\n\nLet's craft virtual code lines.\n\nStart\n→ Input n, k\n→ Initialize empty list answer\n→ Set left = 1, right = n\n→ Set count = 0\n→ While count <= k:\n    → Decision: If count is even? // Determine which side to take\n        Yes → Step: Append left to answer // add smallest remaining\n        No  → Step: Append right to answer // add largest remaining\n    → Step: Increment count\n    → Decision: If count <= k? // continue\n        Yes → Continue loop\n        No  → Exit loop\n→ Decision: If left <= right? // remaining numbers\n    Yes → Step: While left <= right:\n        → Append left to answer\n        → Increment left\n    No  → No action\n→ Return answer\n\nBut we need to show the k distinct difference property. The pattern ensures distinct differences because the differences between consecutive elements will be decreasing sequence: k, k-1, ...,1.\n\nThus, explanation lines.\n\nLet's craft final output. Ensure each line ends with // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n 與 k // 從使用者取得 n 和 k  \n→ Step 2: 初始化空列表 answer // 用於存放答案  \n→ Step 3: 設定 left = 1, right = n // left 代表最小剩餘數, right 代表最大剩餘數  \n→ Step 4: 設定 count = 0 // 用於計算已加入的元素數量  \n→ Decision: count <= k? // 需要建立 k+1 個元素以產生 k 個不同差值  \n  Yes → Step 5: Decision: count 為偶數? // 決定取 left 或 right  \n    Yes → Step 6: Append left 到 answer // 取最小剩餘數  \n     → Step 7: Increment left // 移動到下一個最小數  \n    No  → Step 8: Append right 到 answer // 取最大剩餘數  \n     → Step 9: Decrement right // 移動到下一個最大數  \n    → Step 10: Increment count // 已加入一個元素  \n    → Decision: count <= k? // 是否還需繼續構造前 k+1 個元素  \n     Yes → 迴圈回到 Step 5  \n     No → 退出構造前 k+1 個元素  \n→ Decision: left <= right? // 是否還有未使用的數字  \n  Yes → Step 11: While left <= right:  \n     → Step 12: Append left 到 answer // 把剩餘數字順序填入  \n     → Step 13: Increment left // 移動至下一個數  \n    → Step 14: End While  \n  No  → Step 15: 沒有剩餘數字，直接進行  \n→ Step 16: 返回 answer // 輸出符合條件的列表  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef construct_array(n: int, k: int) -> list[int]:\n    \"\"\"\n    Construct an array of length n with values 1..n such that the\n    list of absolute differences between consecutive elements\n    contains exactly k distinct values.\n    \"\"\"\n    result = []\n    left, right = 1, k + 1  # use numbers 1..k+1 for the pattern\n\n    # Build the first k+1 elements to guarantee k distinct differences\n    for i in range(k + 1):\n        if i % 2 == 0:\n            result.append(left)\n            left += 1\n        else:\n            result.append(right)\n            right -= 1\n\n    # Append the remaining numbers in increasing order\n    for num in range(k + 2, n + 1):\n        result.append(num)\n\n    return result\n\ndef main() -> None:\n    # Read all input and extract integers (works for formats like\n    # \"n = 3, k = 1\" or \"3 1\")\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(numbers) < 2:\n        return  # insufficient data\n    n, k = numbers[0], numbers[1]\n\n    answer = construct_array(n, k)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 1",
          "expected_output": "[1,2,3]",
          "success": true,
          "output": "[1, 2, 3]"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 2",
          "expected_output": "[1,3,2]",
          "success": true,
          "output": "[1, 3, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode69.json",
    "problem_index_in_file": 0,
    "title": "Sqrt(x)",
    "description_snippet": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for integer square root using binary search. Each line with virtual code and explanation.\n\nWe need to output using the required format: \"虛擬碼步驟 // 解釋/說明\". Use arrows, Decision, etc.\n\nWe need to include Start, End, decisions. Use \"Step\" maybe.\n\nLet's produce:\n\nStart\n→ Step 1: Set low = 0, high = x // 初始化搜索範圍\n→ Decision: If x < 2? // 特殊情況處理\n    Yes → Step 2: Return x // 0或1的平方根就是自身\n    No → Decision: If x == 2? // 特殊處理 2\n        Yes → Step 3: Return 1 // 因為1^2 <=2<2^2\n        No → Step 4: 進入二分搜尋 // 一般情況\n\nBut perhaps simpler: For any x, binary search between 0 and x.\n\nWe should compute mid = low + (high - low) / 2\n\nIf mid*mid <= x and (mid+1)*(mid+1) > x then mid is answer.\n\nElse if mid*mid < x: low = mid+1\n\nElse high = mid-1\n\nFinally return high or low-1.\n\nWe need to show each step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Initialize low = 0, high = x // 設定搜尋區間\n→ Decision: While low <= high? // 只要範圍仍合法才繼續\n    Yes →\n        → Step 2: mid = low + (high - low) / 2 // 計算中點\n        → Decision: If mid*mid <= x? // 判斷 mid 是否太小\n            Yes →\n                → Decision: If (mid+1)*(mid+1) > x? // 是否已經是最大平方根\n                    Yes →\n                        → Step 3: Return mid // mid 為平方根\n                        → End // 程式結束\n                    No  →\n                        → Step 4: low = mid + 1 // mid 太小，縮小區間\n            No  →\n                → Step 5: high = mid - 1 // mid 太大，縮小區間\n    No  →\n        → Step 6: Return high // 循環結束時 high 是平方根\nEnd // 程式執行結束\n\nEnsure each line has virtual code + space + // 解釋.\n\nAlso we should maybe specify types or not.\n\nMake sure no real code. Use pseudo.\n\nLet's output as lines.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 low = 0, high = x // 設定搜尋區間\n→ Decision: low <= high? // 判斷區間是否仍合法\n    Yes →\n        → Step 2: mid = low + (high - low) / 2 // 計算中點\n        → Decision: mid * mid <= x? // 判斷 mid 是否過小\n            Yes →\n                → Decision: (mid + 1) * (mid + 1) > x? // 檢查是否已經是最大平方根\n                    Yes →\n                        → Step 3: 回傳 mid // mid 為整數平方根\n                        → End // 程式結束\n                    No  →\n                        → Step 4: low = mid + 1 // mid 太小，調整下界\n            No  →\n                → Step 5: high = mid - 1 // mid 太大，調整上界\n    No  →\n        → Step 6: 回傳 high // 循環結束時 high 即為平方根\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef my_sqrt(x: int) -> int:\n    \"\"\"\n    計算 x 的整數平方根（向下取整），使用二分搜尋。\n    \"\"\"\n    if x < 2:\n        return x\n\n    left, right = 1, x // 2\n    while left <= right:\n        mid = left + (right - left) // 2\n        prod = mid * mid\n\n        if prod == x:\n            return mid\n        elif prod < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return right  # 搜尋結束時 right 是最大的平方根\n\ndef main() -> None:\n    \"\"\"\n    讀取輸入，解析整數 x，計算平方根並輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return  # 若無合法整數，直接返回\n\n    x = int(match.group())\n    result = my_sqrt(x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 8",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode385.json",
    "problem_index_in_file": 0,
    "title": "Mini Parser",
    "description_snippet": "Given a string s represents the serialization of a nested list, implement a parser to deserialize it...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for deserializing nested list string representation into NestedInteger object. Use virtual code with arrows and decisions. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe'll design algorithm: If s does not start with '[', just parse integer and return NestedInteger(int). Else, use stack to hold NestedInteger, iterate over characters, parse numbers, handle brackets, commas. When '[' push new list; when ']' pop and add to previous. When comma skip. At end return stack[0].\n\nWe'll output step by step. Use Start, End. Provide Decision nodes for s[0] check. Provide loops.\n\nLet's produce step-by-step.\n\nWe should consider handling negative numbers, multi-digit numbers.\n\nLet's craft pseudocode:\n\nStart\n→ Decision: 如果 s 為單一數字? // 判斷是否為整數\n    Yes → Step: 解析整數 num ← parseInt(s) // 轉換為整數\n        → Step: Return NestedInteger(num) // 返回單個整數\n    No  → Step: 初始化 stack ← empty list // 建立棧以儲存 NestedInteger\n        → Step: 初始化 current_num ← 0, negative ← False, num_active ← False // 數字解析狀態\n        → Step: 對於每個字符 ch in s:\n            Decision: 如果 ch 是 '['? // 新開始子串\n                Yes → Step: Push new NestedInteger() onto stack // 新建空列表\n                    → Step: Set current_num ← 0, negative ← False, num_active ← False // 重置數字狀態\n                No  → Decision: 如果 ch 是 ']'? // 結束子串\n                    Yes → Decision: 是否有未解析數字? // 檢查 num_active\n                        Yes → Step: 若 negative then current_num ← -current_num\n                            → Step: stack.top.add(NestedInteger(current_num)) // 添加數字到當前列表\n                        No  → 無\n                    → Step: 完成當前列表，pop cur ← stack.pop()\n                        → Decision: 是否還有父列表? // 檢查棧非空\n                            Yes → stack.top.add(cur) // 添加到父列表\n                            No  → 無\n                    → Step: Reset num_active ← False\n                No  → Decision: 如果 ch 是 ','? // 分隔符\n                    Yes → Decision: 是否有未解析數字? // 檢查 num_active\n                        Yes → Step: 若 negative then current_num ← -current_num\n                            → Step: stack.top.add(NestedInteger(current_num)) // 添加數字\n                        No  → 無\n                    → Step: Reset num_active ← False\n                No  → Decision: 如果 ch 是 '-'? // 負號\n                    Yes → Step: negative ← True; num_active ← True\n                No  → Decision: 如果 ch 是數字字符? // 0-9\n                    Yes → Step: current_num ← current_num * 10 + int(ch); num_active ← True\n        → Step: 返回 stack[0] // 最終結果\nEnd\n\nWe need to output each step line separately, using \"虛擬碼步驟 // 解釋\". Use Start, End. Use arrow with indentation? The example shows indentation with arrows and Decision. We'll produce accordingly.\n\nWe need to ensure each line is separate. Use proper indentation maybe spaces. Provide \"Start\" line. Use arrows and indentation for decision branches.\n\nLet's write.\n\nWe'll need to use \"→\" for continuation, \"Decision:\" lines. We'll indent using spaces. We'll keep each step line as separate line. Provide explanation after //. Provide each step line.\n\nWe need to ensure not to output actual code. Just pseudocode.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: s 是否為單一整數? // 判斷輸入是否僅包含數字（沒有 '['）\n    Yes → Step: num ← parseInt(s) // 直接將字串轉為整數\n        → Step: Return NestedInteger(num) // 回傳單個整數型 NestedInteger\n    No  → Step: stack ← empty list // 建立棧以儲存 NestedInteger 物件\n        → Step: current_num ← 0, negative ← False, num_active ← False // 數字解析初始狀態\n        → Step: 對於每個字元 ch in s:\n            Decision: ch 是否為 '['? // 開始一個新列表\n                Yes → Step: stack.push(NestedInteger()) // 新建空列表並進入棧\n                    → Step: current_num ← 0, negative ← False, num_active ← False // 重設數字狀態\n                No  → Decision: ch 是否為 ']'? // 結束當前列表\n                    Yes → Decision: num_active 是否為 True? // 是否有正在解析的數字\n                        Yes → Step: 若 negative 為 True 則 current_num ← -current_num // 處理負號\n                            → Step: stack.top.add(NestedInteger(current_num)) // 把數字加入上層列表\n                        No  → 無操作 // 無待處理數字\n                    → Step: cur ← stack.pop() // 完成當前列表，彈出\n                        → Decision: stack 非空? // 是否還有父列表\n                            Yes → stack.top.add(cur) // 加入到父列表\n                            No  → 無操作 // cur 為最外層，直接返回\n                    → Step: num_active ← False // 重置數字狀態\n                No  → Decision: ch 是否為 ','? // 元素分隔符\n                    Yes → Decision: num_active 是否為 True? // 是否有待處理數字\n                        Yes → Step: 若 negative 為 True 則 current_num ← -current_num\n                            → Step: stack.top.add(NestedInteger(current_num)) // 把數字加入列表\n                        No  → 無操作 // 無待處理數字\n                    → Step: num_active ← False // 重置數字狀態\n                No  → Decision: ch 是否為 '-'? // 負號符號\n                    Yes → Step: negative ← True; num_active ← True // 設定負號並啟動數字解析\n                No  → Decision: ch 是否為數字字符? // '0'~'9'\n                    Yes → Step: current_num ← current_num * 10 + int(ch); num_active ← True // 累加數字\n        → Step: Return stack[0] // 返回最外層的 NestedInteger 物件\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass NestedInteger:\n    \"\"\"A simplified NestedInteger implementation for this problem.\"\"\"\n    def __init__(self, value=None):\n        if value is None:\n            self._list = []\n            self._int = None\n        else:\n            self._int = int(value)\n            self._list = None\n\n    def isInteger(self):\n        return self._int is not None\n\n    def add(self, ni):\n        if self.isInteger():\n            raise ValueError(\"Cannot add to an integer NestedInteger\")\n        self._list.append(ni)\n\n    def getInteger(self):\n        return self._int\n\n    def getList(self):\n        return self._list\n\n    def __str__(self):\n        if self.isInteger():\n            return str(self._int)\n        return '[' + ','.join(str(x) for x in self._list) + ']'\n\n\nclass Solution:\n    def deserialize(self, s: str) -> NestedInteger:\n        \"\"\"Deserialize a string into a NestedInteger.\"\"\"\n        if not s:\n            return NestedInteger()\n        # Single integer case\n        if s[0] != '[':\n            return NestedInteger(int(s))\n\n        stack = []\n        num_str = ''\n        negative = False\n\n        for ch in s:\n            if ch == '-':\n                negative = True\n            elif ch.isdigit():\n                num_str += ch\n            elif ch == '[':\n                stack.append(NestedInteger())\n            elif ch in ',]':\n                # If there is a pending number, add it to the current list\n                if num_str:\n                    value = int(num_str)\n                    if negative:\n                        value = -value\n                    stack[-1].add(NestedInteger(value))\n                    num_str = ''\n                    negative = False\n                if ch == ']':\n                    # Finish the current list\n                    cur = stack.pop()\n                    if stack:\n                        stack[-1].add(cur)\n                    else:\n                        # This was the outermost list\n                        return cur\n        # In case the input was just a single integer (handled earlier), we should never reach here\n        return stack[0] if stack else NestedInteger()\n\n\ndef parse_input(raw: str) -> str:\n    \"\"\"Extract the serialized string from the raw input.\"\"\"\n    raw = raw.strip()\n    if '=' in raw:\n        _, val = raw.split('=', 1)\n        val = val.strip()\n    else:\n        val = raw\n    if val and val[0] in ('\"', \"'\") and val[-1] == val[0]:\n        val = val[1:-1]\n    return val\n\n\nif __name__ == \"__main__\":\n    raw_input_data = sys.stdin.read()\n    serialized_str = parse_input(raw_input_data)\n    solution = Solution()\n    result = solution.deserialize(serialized_str)\n    print(str(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"324\"",
          "expected_output": "324",
          "success": true,
          "output": "324"
        },
        {
          "example_index": 1,
          "input": "s = \"[123,[456,[789]]]\"",
          "expected_output": "[123,[456,[789]]]",
          "success": true,
          "output": "[123,[456,[789]]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode477.json",
    "problem_index_in_file": 0,
    "title": "Total Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: sum of Hamming distances between all pairs in array nums. The solution: For each bit position (0-31), count number of numbers with bit set (ones) and zeros, add ones*zeros*2? Actually distance between pair counts difference at that bit for each unordered pair. For unordered pairs, each pair contributes 1 if bits differ. For all unordered pairs, sum over bits: countOnes*countZeros. Since each pair counted once. However, sometimes problem counts ordered pairs? Usually Leetcode 1868 sum of Hamming distances: sum over all unordered pairs. Each unordered pair contributes 1 if bits differ. So sum over bits of countOnes*countZeros. But if counting ordered pairs, multiply by 2. But problem statement? \"sum of Hamming distances between all the pairs of the integers in nums.\" Usually means unordered pairs. But we need to produce virtual code accordingly. Provide steps: Start, iterate bit positions 0-31, count ones, compute contribution ones*(n-ones), add to result. End.\n\nWe need to output step-by-step virtual code with explanations after each line.\n\nWe need to ensure each line uses arrow syntax.\n\nLet's produce:\n\nStart // program starts\n→ Step 1: Let n = length of nums // get number of elements\n→ Step 2: Initialize result = 0 // total Hamming distance sum\n→ Step 3: For bit = 0 to 31 // iterate all 32 bit positions\n    → Step 4: Initialize countOnes = 0 // number of elements with current bit set\n    → Step 5: For each number in nums // iterate through array\n        → Step 6: If (number >> bit) & 1 == 1 // check if current bit is 1\n            → Step 7: countOnes += 1 // increment count of ones\n    → Step 8: countZeros = n - countOnes // number of zeros at this bit\n    → Step 9: contribution = countOnes * countZeros // pairs differing at this bit\n    → Step 10: result += contribution // add to total sum\n→ End // finished calculation\n→ Step 11: return result // output the sum\n\nBut we should use Decision arrows for loops? The example shows arrow for steps but loops could be indicated as Step: For loop... Maybe we need to use Decision: for condition? But loops may not require Decision. We can just show Step lines.\n\nWe can show indentation using spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n = nums.length // 取得陣列長度  \n→ Step 2: Initialize result = 0 // 用於累加所有 Hamming 距離  \n→ Step 3: For bit = 0 to 31 // 逐位檢查 32 位整數  \n  → Step 4: Initialize countOnes = 0 // 目前位為 1 的數字數目  \n  → Step 5: For each num in nums // 遍歷所有數字  \n    → Step 6: If (num >> bit) & 1 == 1 // 判斷此位是否為 1  \n      → Step 7: countOnes += 1 // 1 的數目加 1  \n  → Step 8: countZeros = n - countOnes // 0 的數目  \n  → Step 9: contribution = countOnes * countZeros // 當位不同的對數  \n  → Step 10: result += contribution // 累加到總距離  \n→ End // 迴圈結束  \n→ Step 11: return result // 回傳所有對之 Hamming 距離總和",
      "generated_code": "import sys\nimport ast\n\ndef total_hamming_distance(nums):\n    \"\"\"Return the sum of Hamming distances between all unordered pairs in nums.\"\"\"\n    n = len(nums)\n    total = 0\n    for bit in range(32):  # consider 32-bit integers\n        count_ones = sum((num >> bit) & 1 for num in nums)\n        count_zeros = n - count_ones\n        total += count_ones * count_zeros\n    return total\n\ndef parse_input(data):\n    \"\"\"Parse input string into a list of integers.\"\"\"\n    data = data.strip()\n    if not data:\n        return []\n\n    # If the input contains an assignment like 'nums = [1,2,3]'\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n\n    # Try to evaluate as a Python literal\n    try:\n        nums = ast.literal_eval(data)\n        if isinstance(nums, list):\n            return [int(x) for x in nums]\n        elif isinstance(nums, (int, float)):\n            return [int(nums)]\n    except Exception:\n        pass\n\n    # Fallback: split by whitespace and convert to ints\n    parts = data.replace(',', ' ').split()\n    return [int(p) for p in parts if p]\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    result = total_hamming_distance(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,14,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [4,14,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode115.json",
    "problem_index_in_file": 0,
    "title": "Distinct Subsequences",
    "description_snippet": "Given two strings s and t, return the number of distinct subsequences of s which equals t.\n\nThe test...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for computing number of distinct subsequences of s that equal t. This is classic DP problem. Virtual code: Start, read s,t, DP table dp[ i ][ j ]. We'll produce steps line by line with comments. Use arrows. Ensure each line is: virtual code step + space + // explanation. Use Decision and loops. Provide DP logic: dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1]==t[j-1] else dp[i-1][j]. Use 0-index maybe. For simplicity: initialize dp array of size (len(t)+1) as 1 for dp[0]=1. Then iterate over s and update backwards for j. But we can use 2D. Let's use 2D for clarity: dp[i][j] represent number of ways using first i chars of s to form first j of t. dp[0][0]=1, dp[i][0]=1. dp[0][j>0]=0. Then loops. After loops, return dp[len(s)][len(t)]. Provide pseudo. Use Decision to handle char match.\n\nLet's produce virtual code lines. Format: each line as \"虛擬碼步驟 // 解釋\". Use Start, End. Use arrow \"→\". Use Decision.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s, t // 取得兩個字串 s 與 t  \n→ m ← length(s) // 取得 s 的長度  \n→ n ← length(t) // 取得 t 的長度  \n→ Allocate dp[0…m][0…n] // 建立 2 維 DP 陣列  \n→ For i ← 0 to m  \n    → dp[i][0] ← 1 // 任意字串的空子序列只有一種  \n→ For j ← 1 to n  \n    → dp[0][j] ← 0 // 空 s 無法產生非空 t  \n→ For i ← 1 to m  \n    → For j ← 1 to n  \n        → Decision: s[i‑1] == t[j‑1] ? // 比較 s 與 t 的對應字元  \n            Yes → dp[i][j] ← dp[i‑1][j] + dp[i‑1][j‑1] // 匹配時加上使用與不使用的情況  \n            No  → dp[i][j] ← dp[i‑1][j] // 不匹配時只能忽略 s[i‑1]  \n→ Result ← dp[m][n] // 最終答案  \n→ Output Result // 將答案回傳  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef num_distinct_subsequences(s: str, t: str) -> int:\n    \"\"\"Return number of distinct subsequences of s that equal t.\"\"\"\n    m, n = len(s), len(t)\n    # dp[i][j] = number of ways first i chars of s can form first j chars of t\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Empty t can be formed in exactly one way (delete all chars)\n    for i in range(m + 1):\n        dp[i][0] = 1\n\n    # Fill DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                # Match: either use this character or skip it\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                # No match: only option is to skip this character of s\n                dp[i][j] = dp[i - 1][j]\n    return dp[m][n]\n\n\ndef parse_input() -> tuple[str, str]:\n    \"\"\"\n    Parse stdin to extract strings s and t.\n    Supports:\n    - Two lines, each containing a string (with or without quotes).\n    - One line containing two quoted strings.\n    - One line containing two space‑separated strings.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return \"\", \"\"\n\n    # Try to find quoted strings first\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n\n    # If no quotes, split by whitespace\n    parts = data.split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # Fallback: return the entire data as s, empty t\n    return data, \"\"\n\n\nif __name__ == \"__main__\":\n    s, t = parse_input()\n    result = num_distinct_subsequences(s, t)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"rabbbit\", t = \"rabbit\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"babgbag\", t = \"bag\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode211.json",
    "problem_index_in_file": 0,
    "title": "Design Add and Search Words Data Structure",
    "description_snippet": "Design a data structure that supports adding new words and finding if a string matches any previousl...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for WordDictionary supporting addWord and search with '.' wildcard. This is typical Trie with DFS. We'll produce line by line with arrow syntax. Must use Start, End, Decision, etc.\n\nWe need to produce \"虛擬碼步驟\" each line with comment. The pseudo-code will include: define Node, WordDictionary class, constructor, addWord, search, helper dfs. We'll include the search with recursion.\n\nWe need to produce \"逐行\" and each line ends with comment. Provide arrow syntax. We'll include indentation? They didn't forbid but using arrow for steps. We can use indentation with arrows for nested steps. Use \"Decision:\" for condition checks. Use \"Yes →\" \"No →\" branches. Use \"→\" for next step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 TrieNode 類別 // 定義字典節點結構\n→ Decision: node是否含有字母子節點? // 判斷節點是否已存在子節點\n...\nBut maybe easier: show high-level steps.\n\nWe need to include \"虛擬碼步驟\" such as \"WordDictionary() 初始化物件\" etc.\n\nLet's structure:\n\nStart\n→ Step 1: 定義 TrieNode // 節點包含子節點字典和終止標誌\n→ Step 2: 定義 WordDictionary 類別\n    → Step 2.1: WordDictionary() // 建構子：創建根節點\n    → Step 2.2: addWord(word) // 將單字插入 Trie\n        → Step 2.2.1: 逐字遍歷 current = root\n            → Step 2.2.1.1: 如果 char 未在 current.children, 創建新節點\n            → Step 2.2.1.2: 移動到該子節點\n        → Step 2.2.2: 標記 current.isWord = true\n    → Step 2.3: search(word) // 判斷是否存在匹配字串\n        → Step 2.3.1: 呼叫 DFS(node=root, index=0)\n            → Decision: index 是否等於 word 長度? // 判斷是否到達字串結尾\n                Yes → Decision: node.isWord? // 是否為完整單字\n                    Yes → Return true\n                    No  → Return false\n                No  → Decision: word[index] 是否為 '.'? // 判斷是否為萬用字元\n                    Yes → For each child in node.children:\n                            → If DFS(child, index+1) 返回 true → Return true\n                        → Return false\n                    No  → If word[index] 在 node.children:\n                            → Return DFS(node.children[word[index]], index+1)\n                        Else → Return false\n        → Step 2.3.2: Return DFS結果\nEnd\n\nNeed to include comments in Chinese.\n\nAlso we might include small sub-steps for DFS. Use \"Step 3\" etc. We need to ensure each line ends with comment.\n\nLet's format lines with arrows. Use spaces as indentation. The arrow for steps: \"→ Step ...\". For nested steps, indent more maybe with extra arrow?\n\nSimplify: We'll produce lines each separate step, using arrow for each. For nested decisions, use \"Decision:\" and then \"Yes →\" \"No →\".\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode // 建立 Trie 節點結構，包含子節點映射與是否為單字結尾的標誌  \n→ Step 2: 定義 WordDictionary 類別 // 包含根節點與三個主要方法  \n  → Step 2.1: WordDictionary() // 建構子：創建空白根節點  \n  → Step 2.2: addWord(word) // 將單字插入 Trie  \n    → Step 2.2.1: current ← root // 從根節點開始遍歷  \n    → Decision: 是否已存在 char 子節點? // 檢查當前字母是否已有節點  \n      Yes → current ← current.children[char] // 跳到已有節點  \n      No  → current.children[char] ← 新 TrieNode() // 新增節點  \n    → Step 2.2.2: current.isWord ← true // 標記為完整單字  \n  → Step 2.3: search(word) // 判斷是否有匹配字串  \n    → Step 2.3.1: result ← DFS(root, 0) // 以遞迴方式搜尋  \n    → Step 2.3.2: return result // 回傳搜尋結果  \n      → 定義 DFS(node, idx) // idx 為目前字元索引  \n       → Decision: idx == len(word)? // 已到字串結尾  \n         Yes → Decision: node.isWord? // 是否為完整單字  \n           Yes → return true  \n           No  → return false  \n        No  → Decision: word[idx] == '.'? // 是否為萬用字元  \n          Yes → For each child in node.children: // 逐一嘗試子節點  \n            → If DFS(child, idx+1) == true → return true  \n           → return false  \n          No  → Decision: word[idx] in node.children? // 具體字母是否存在  \n            Yes → return DFS(node.children[word[idx]], idx+1)  \n            No  → return false  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word):\n        def dfs(node, i):\n            if i == len(word):\n                return node.is_end\n            if word[i] == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                if word[i] not in node.children:\n                    return False\n                return dfs(node.children[word[i]], i + 1)\n        return dfs(self.root, 0)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # The input format is two JSON arrays separated by a comma.\n    # Example: '[\"WordDictionary\",\"addWord\"],[[],[\"bad\"]]'\n    parts = data.split(',', 1)\n    ops = json.loads(parts[0])\n    args = json.loads(parts[1])\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"WordDictionary\":\n            obj = WordDictionary()\n            results.append(None)\n        elif op == \"addWord\":\n            obj.addWord(arg[0])\n            results.append(None)\n        elif op == \"search\":\n            results.append(obj.search(arg[0]))\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpnl_ee1i3.py\", line 43, in <module>\n    ops = json.loads(parts[0])\n          ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 18 (char 17)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode556.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element III",
    "description_snippet": "Given a positive integer n, find the smallest integer which has exactly the same digits existing in ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: given integer n, find next greater permutation of its digits; if none, return -1; also check 32-bit int overflow. We need to output each line with arrow and comments. Use \"Start\", \"End\", \"Decision:\". Steps: Convert to digits array, find pivot where digits[i] < digits[i+1] scanning from right, if none return -1. Find rightmost digit > pivot, swap, reverse suffix, recombine to integer, check bounds, return. Also need to handle overflow: 32-bit signed int range [-2^31,2^31-1], but positive integer. So if result > 2^31-1 return -1. Provide virtual code lines.\n\nLet's craft lines:\n\nStart\n→ Step 1: Convert n to list of digits // 將整數轉成數位陣列\n→ Step 2: Set i = len(digits) - 2 // 從倒數第二位開始\n→ Decision: i >= 0 and digits[i] < digits[i+1]? // 找 pivot\n    No → Step 3: Return -1 // 已是最高排列\n    Yes → Step 4: While i >= 0 and digits[i] >= digits[i+1] → i = i - 1 // 確保 i 為 pivot\n→ Step 5: Set j = len(digits) - 1 // 從尾部尋找交換目標\n→ Decision: digits[j] > digits[i]? // 找比 pivot 大的最右數位\n    Yes → Step 6: Swap digits[i] and digits[j] // 交換\n    No  → (should not happen) // 但為安全處理\n→ Step 7: Reverse digits from i+1 to end // 重新排序後半段升序\n→ Step 8: Convert digits back to integer result // 重新組成數字\n→ Decision: result > 2^31 - 1? // 檢查 32 位整數上限\n    Yes → Step 9: Return -1 // 超過上限\n    No  → Step 10: Return result // 合格答案\nEnd\n\nBut we need each line with arrow, and comments. Also \"Decision:\" lines may have nested Yes/No branches. Use indentation as needed. Ensure each line includes virtual code step and comment.\n\nWe need to avoid actual code but use virtual representation like \"Step 1\". Use \"Yes →\" and \"No →\" branches. For nested decisions, indent further.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Convert n to list of digits // 將整數轉成數位陣列  \n→ Step 2: Set i = len(digits) - 2 // 從倒數第二位開始尋找 pivot  \n→ Decision: i >= 0 and digits[i] < digits[i+1]? // 判斷是否有更大的排列  \n  No → Step 3: Return -1 // 已經是最大的排列，直接返回  \n  Yes → Step 4: While i >= 0 and digits[i] >= digits[i+1] → i = i - 1 // 找到第一個從右往左遞減的數位作為 pivot  \n→ Step 5: Set j = len(digits) - 1 // 從尾部尋找可交換的目標  \n→ Decision: digits[j] > digits[i]? // 是否找到比 pivot 大的數位  \n  Yes → Step 6: Swap digits[i] and digits[j] // 交換兩個數位  \n  No  → (此情況不應發生，保留安全分支)  \n→ Step 7: Reverse digits from i+1 to end // 將 pivot 右側的子序列重新排序為升序  \n→ Step 8: Convert digits back to integer result // 重新組合成整數  \n→ Decision: result > 2^31 - 1? // 檢查是否超過 32 位正整數上限  \n  Yes → Step 9: Return -1 // 超過上限，回傳 -1  \n  No  → Step 10: Return result // 回傳符合條件的下一個更大數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        digits = list(str(n))\n        i = len(digits) - 2\n        # 找出第一個遞減的數位\n        while i >= 0 and digits[i] >= digits[i + 1]:\n            i -= 1\n        if i == -1:\n            return -1\n        # 從尾部尋找比 digits[i] 大的最右數位\n        j = len(digits) - 1\n        while digits[j] <= digits[i]:\n            j -= 1\n        # 交換\n        digits[i], digits[j] = digits[j], digits[i]\n        # 將 i+1 之後的子序列倒序，即升序\n        digits[i + 1:] = reversed(digits[i + 1:])\n        result = int(\"\".join(digits))\n        # 32 位整數上限\n        return result if result < 2 ** 31 else -1\n\ndef main():\n    data = sys.stdin.read()\n    # 只取輸入中的數字，忽略其他字符\n    num_str = ''.join(filter(str.isdigit, data))\n    if not num_str:\n        print(-1)\n        return\n    n = int(num_str)\n    solution = Solution()\n    print(solution.nextGreaterElement(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12",
          "expected_output": "21",
          "success": true,
          "output": "21"
        },
        {
          "example_index": 1,
          "input": "n = 21",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode507.json",
    "problem_index_in_file": 0,
    "title": "Perfect Number",
    "description_snippet": "A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps per line, no actual code. Format as described. Steps to check perfect number. Use Start, End, Decision, Step. We need to loop to find divisors up to sqrt(n). Sum them. Exclude n. Then compare sum to n. Return boolean. We'll produce virtual code lines: Start, input n, compute sum = 0, for i=1 to sqrt(n) etc. Use Decision to check. Use Yes/No for conditions. Use End. Provide explanation after each line with //.\n\nWe need no actual code, just pseudocode lines. Use arrow notation. Provide step numbers? Not necessary but could. We'll include steps with numbering optional but must be clear. We'll keep format: \"→ Step 1: ...\" etc. Provide explanation after space. Ensure \"虛擬碼步驟\" maybe the step. Provide Chinese comments.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 sum ← 0 // 初始化除數之和為 0  \n→ Step 2: 設定 limit ← ⌊√n⌋ // 取得 n 的平方根下限，用於迴圈  \n→ Step 3: 若 n = 1? // 特殊情況，1 不是完全數  \n  Yes → End // 直接返回 false（程式結束）  \n  No → 進行下一步  \n→ Step 4: 從 i = 1 到 limit 逐一檢查  \n  → Decision: i | n? // 判斷 i 是否為 n 的除數  \n   Yes → Step 5: sum ← sum + i // 加入 i  \n    Decision: i ≠ n / i? // 判斷對應除數 n/i 是否不同於 i  \n     Yes → sum ← sum + (n / i) // 加入對應除數  \n     No → // i 為平方根，不重複加  \n   No → // i 不是除數，跳過  \n→ Step 6: Decision: sum = n? // 檢查總和是否等於 n  \n  Yes → End // 若相等，返回 true（程式結束）  \n  No → End // 若不相等，返回 false（程式結束）",
      "generated_code": "import sys\nimport math\n\nclass Solution:\n    def checkPerfectNumber(self, num: int) -> bool:\n        \"\"\"Return True if num is a perfect number, otherwise False.\"\"\"\n        if num < 2:\n            return False\n\n        # Sum of proper divisors starts with 1\n        total = 1\n        # Only need to iterate up to sqrt(num)\n        limit = int(math.isqrt(num))\n        for i in range(2, limit + 1):\n            if num % i == 0:\n                total += i\n                other = num // i\n                if other != i:\n                    total += other\n        return total == num\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    try:\n        n = int(data.split()[0])\n    except ValueError:\n        # If the input cannot be parsed as an integer, treat as not perfect\n        print(\"false\")\n        return\n\n    sol = Solution()\n    result = sol.checkPerfectNumber(n)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "28",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "7",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode476.json",
    "problem_index_in_file": 0,
    "title": "Number Complement",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. The task: compute complement of integer by flipping bits in binary representation. Usually, we find mask of same bit length. Then XOR with mask. Steps: input num, find binary length, create mask all ones of that length, compute complement = num XOR mask, return. Also handle zero? For zero, complement is 1? Actually complement of 0? 0 in binary \"0\" complement \"1\" => 1. Many definitions: The integer complement as per LeetCode 476: if num==0, return 1. So include that.\n\nWe'll produce line-by-line steps. Use Start, Decision, etc. Provide brief explanation. Let's craft.\n\nUse steps: Start. Step1: Input num. Step2: If num == 0 → return 1. Step3: Determine bit length: convert to binary string or count bits. Step4: Create mask of all 1's length bits. Step5: Compute complement = num XOR mask. Step6: Return complement. End.\n\nUse decision arrows. We'll include indentation for decisions.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入整数 num // 取得使用者提供的數值  \n→ Decision: 如果 num 為 0? // 0 的特殊情況，補碼為 1  \n  Yes → Step 2: 回傳 1 // 直接返回結果  \n  No  → Step 3: 計算 num 的二進位位數 len // 找出需要翻轉的位數  \n      → Step 4: 建立 mask = (1 << len) - 1 // 生成全為 1 的位遮罩  \n      → Step 5: 取反數 = num XOR mask // 用 XOR 取反所有位  \n      → Step 6: 回傳 取反數 // 輸出補碼結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        \"\"\"\n        取得 num 的二進位位數，生成全 1 掩碼，\n        再將 num 與掩碼 XOR，得到補碼。\n        \"\"\"\n        bit_length = num.bit_length()\n        mask = (1 << bit_length) - 1\n        return num ^ mask\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取資料，找出第一個整數，\n    計算其補碼後輸出結果。\n    \"\"\"\n    data = sys.stdin.read()\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        return\n    num = int(numbers[0])\n    solution = Solution()\n    print(solution.findComplement(num))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode703.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in a Stream",
    "description_snippet": "You are part of a university admissions office and need to keep track of the kth highest test score ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for class KthLargest with constructor and add method. Should use min-heap of size k to maintain kth largest. Steps: initialize min-heap, add initial nums elements via add. add method: push val; if heap size > k, pop min; return heap.peek(). Provide lines. Ensure format: each line \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Start End. Use Decision. Probably include class definition. Let's produce.\n\nFormat example: \nStart\n→ Class KthLargest // 定義 KthLargest 類別\n→ Constructor KthLargest(k, nums) // 初始化 k 和初始分數陣列\n    → Step: Set this.k = k // 設定 k\n    → Step: 初始化空 min-heap // 建立最小堆\n    → Decision: nums 是否為空? // 檢查陣列\n        Yes → No action\n        No → Step: 遍歷 nums，調用 add() 以加入堆 // 加入初始分數\n→ Method add(val) // 新分數加入\n    → Step: 插入 val 至 min-heap // 放入堆\n    → Decision: 堆大小 > k? // 檢查是否超過 k\n        Yes → Step: 移除堆頂最小值 // 保持大小\n        No → No action\n    → Step: 回傳堆頂元素 // kth largest\nEnd\n\nNeed line breaks and each line with // explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class KthLargest // 定義 KthLargest 類別  \n→ Constructor KthLargest(k, nums) // 初始化 k 與初始分數陣列  \n  → Step: Set this.k = k // 設定 k 的值  \n  → Step: 初始化空 min-heap // 建立最小堆用於追蹤前 k 個最高分  \n  → Decision: nums 是否為空? // 判斷是否有預先提供的分數  \n   Yes → No action // 若無預設分數，略過  \n   No  → Step: For each number n in nums, 呼叫 add(n) // 將初始分數逐一加入堆  \n→ Method add(val) // 新分數加入並回傳第 k 高分  \n  → Step: 插入 val 至 min-heap // 將新分數放入堆  \n  → Decision: min-heap 大小 > this.k? // 檢查堆是否超過 k 個元素  \n   Yes → Step: 移除堆頂最小值 // 只保留 k 個最高分  \n   No  → No action // 不需要移除  \n  → Step: 回傳堆頂元素 // 堆頂即為第 k 大分數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nimport heapq\n\nclass KthLargest:\n    \"\"\"KthLargest 透過最小堆維持前 k 個最大值，堆頂即為第 k 大值。\"\"\"\n\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        \"\"\"加入新值，若堆大小超過 k 則移除最小值，最後回傳堆頂即第 k 大值。\"\"\"\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\nif __name__ == \"__main__\":\n    # 讀取整行輸入，將其轉成兩個列表的元組\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n    # 用 ast.literal_eval 將字串轉成 (commands, args) 的 tuple\n    commands, args = ast.literal_eval('(' + raw + ')')\n\n    output = []\n    obj = None\n    for idx, cmd in enumerate(commands):\n        if cmd == \"KthLargest\":\n            k, nums = args[idx]\n            obj = KthLargest(k, nums)\n            output.append(None)  # 代表 null\n        else:  # cmd == \"add\"\n            val = args[idx][0]\n            res = obj.add(val)\n            output.append(res)\n\n    # 使用 json.dumps 讓 None 轉成 null，符合題目輸出格式\n    print(json.dumps(output))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "success": true,
          "output": "[null, 4, 5, 5, 8, 8]"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "success": true,
          "output": "[null, 7, 7, 7, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode315.json",
    "problem_index_in_file": 0,
    "title": "Count of Smaller Numbers After Self",
    "description_snippet": "Given an integer array nums, return an integer array counts where counts[i] is the number of smaller...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for the problem: Given an integer array nums, return counts array where counts[i] is number of smaller elements to the right of nums[i].\n\nWe need to produce line by line pseudocode with comments. Use Start, End, Decision: etc. Use arrows. Provide concise explanations.\n\nWe need to implement algorithm: maybe use Binary Indexed Tree / Fenwick tree or merge sort counting. We should produce pseudocode: e.g., Use Fenwick tree after coordinate compression.\n\nLet's produce virtual code:\n\nStart\n→ Step 1: 取得 nums 長度 n // n = len(nums)\n→ Step 2: 建立 counts array of size n，初始化為 0\n→ Step 3: 建立 valueToIndex map (value -> rank) 進行座標壓縮 // 先把所有 nums 排序去重\n→ Step 4: 計算 ranks：把 nums 轉為 rank 以便 BIT\n→ Step 5: 初始化 Fenwick tree size = unique values count\n→ Decision: 是否需要 BIT? // Use BIT\n→ Yes → Step 6: 逆序遍歷 nums 從右到左\n→ Step 7: 取得 current rank r = rank[nums[i]]\n→ Step 8: Query BIT: sum(0 to r-1) // count of numbers smaller than current\n→ Step 9: 設定 counts[i] = 該 sum\n→ Step 10: 更新 BIT: add 1 at index r // insert current element\n→ End loop\n→ End // return counts\n\nAdd details: Fenwick tree operations: update, query. We can include steps for BIT operations.\n\nLet's produce lines.\n\nWe should use arrow and Decision: maybe one Decision for reverse loop? No.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: n ← length(nums) // 獲取陣列長度\n→ Step 2: counts ← array of n zeros // 初始化答案\n→ Step 3: sortedVals ← sort(unique(nums)) // 取出所有不重複的值並排序\n→ Step 4: rankMap ← empty map // value -> rank\n→ Step 5: for idx, val in enumerate(sortedVals): rankMap[val] ← idx + 1 // 建立座標壓縮索引，從1開始\n→ Step 6: fenwick ← FenwickTree(size=length(sortedVals)) // 初始化 Fenwick 樹\n→ Step 7: for i from n-1 downto 0: // 逆序遍歷\n→ Step 8: r ← rankMap[nums[i]] // 取得當前元素的壓縮索引\n→ Step 9: counts[i] ← fenwick.query(r-1) // 查詢比 r 小的元素數量\n→ Step 10: fenwick.update(r, 1) // 插入當前元素\n→ End // 程式結束，返回 counts\n\nAdd explanations for Fenwick operations:\n\nWe need to include fenwick operations: query and update. Maybe we can include steps for them as separate functions but maybe it's fine.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得輸入陣列長度  \n→ Step 2: counts ← array of n zeros // 初始化答案陣列  \n→ Step 3: sortedVals ← sort(unique(nums)) // 取出所有不重複的值並排序  \n→ Step 4: rankMap ← empty map // 建立值到壓縮索引的對應表  \n→ Step 5: for idx, val in enumerate(sortedVals):  \n  rankMap[val] ← idx + 1 // 壓縮索引從 1 開始  \n→ Step 6: fenwick ← FenwickTree(size = length(sortedVals)) // 初始化 Fenwick 樹  \n→ Step 7: for i from n-1 downto 0: // 從右到左遍歷陣列  \n  r ← rankMap[nums[i]] // 取得當前元素的壓縮索引  \n  counts[i] ← fenwick.query(r-1) // 查詢比 r 小的元素數量  \n  fenwick.update(r, 1) // 插入當前元素到 Fenwick 樹  \n→ End // 程式執行結束，返回 counts",
      "generated_code": "import sys\nimport re\n\nclass BIT:\n    def __init__(self, size: int):\n        # 1-based Fenwick tree\n        self.tree = [0] * (size + 1)\n        self.size = size\n\n    def update(self, index: int, delta: int) -> None:\n        # add delta at position index\n        while index <= self.size:\n            self.tree[index] += delta\n            index += index & -index\n\n    def query(self, index: int) -> int:\n        # sum of [1, index]\n        res = 0\n        while index > 0:\n            res += self.tree[index]\n            index -= index & -index\n        return res\n\ndef count_smaller(nums):\n    # coordinate compression\n    sorted_unique = sorted(set(nums))\n    rank = {num: i + 1 for i, num in enumerate(sorted_unique)}\n\n    bit = BIT(len(rank))\n    res = []\n\n    # process from right to left\n    for num in reversed(nums):\n        r = rank[num]\n        res.append(bit.query(r - 1))  # count smaller elements\n        bit.update(r, 1)\n\n    return res[::-1]\n\ndef main():\n    data = sys.stdin.read()\n    # find all integers (including negatives)\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    result = count_smaller(nums)\n    # output in the format shown in the examples: no spaces after commas\n    print('[' + ','.join(map(str, result)) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,2,6,1]",
          "expected_output": "[2,1,1,0]",
          "success": true,
          "output": "[2,1,1,0]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-1]",
          "expected_output": "[0,0]",
          "success": true,
          "output": "[0,0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode537.json",
    "problem_index_in_file": 0,
    "title": "Complex Number Multiplication",
    "description_snippet": "A complex number can be represented as a string on the form \"real+imaginaryi\" where:\n\nreal is the re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing algorithm for multiplying two complex numbers given as strings like \"a+bi\". Steps: parse strings, extract real and imaginary ints, multiply: (a+bi)*(c+di) = (ac - bd) + (ad + bc)i. Format output as \"real+imaginaryi\". Provide step by step.\n\nNeed to use Start, End, Decision. Possibly handle negative signs. Simplify: parse by finding '+' or '-' sign between real and imaginary part, but imaginary part always has 'i' at end. We can parse by splitting at 'i', then find last '+' or '-' before 'i', but real part may be negative and no sign for positive. For example \"3+2i\" or \"-3-2i\". So we can find index of 'i', remove it, then find last '+' or '-' before index-? Actually imaginary part sign is at position of last '+' or '-' before the number representing imaginary part. We can just use regex but in pseudo. Use decision to handle sign.\n\nBut virtual code: Step 1: Parse string num1 into real1 and imag1. Step 2: Parse num2 into real2 and imag2. Step 3: Compute realPart = real1*real2 - imag1*imag2. Step 4: Compute imagPart = real1*imag2 + imag1*real2. Step 5: Format result string as realPart + '+' + imagPart + 'i'. However need to handle sign of imagPart; if imagPart negative, string should have '-' not '+'. But spec says \"real+imaginaryi\" where imaginary is integer in range. For negative imaginary part, representation likely like \"3-2i\". So we need to format accordingly.\n\nAlso need to handle if real part negative: leading '-' automatically by string conversion. The plus sign between real and imaginary: if imagPart >=0, use '+' else use ''.\n\nWe can produce decision: If imagPart >=0 then sign = '+' else sign = '' (since negative includes '-').\n\nLet's create virtual code:\n\nStart\n→ Step 1: num1Parts ← ParseComplex(num1) // 提取實部與虛部\n→ Step 2: real1 ← num1Parts.real // 實部1\n→ Step 3: imag1 ← num1Parts.imag // 虛部1\n→ Step 4: num2Parts ← ParseComplex(num2) // 同上\n→ Step 5: real2 ← num2Parts.real\n→ Step 6: imag2 ← num2Parts.imag\n→ Step 7: realResult ← real1 * real2 - imag1 * imag2 // 計算實部\n→ Step 8: imagResult ← real1 * imag2 + imag1 * real2 // 計算虛部\n→ Decision: imagResult >= 0? // 虛部正負決定符號\n    Yes → Step 9: sign ← '+'\n    No  → Step 9: sign ← '' // 負號已在 imagResult 中\n→ Step 10: result ← ToString(realResult) + sign + ToString(imagResult) + 'i' // 組合字串\n→ End\n\nNeed to describe ParseComplex pseudocode maybe. Let's add step inside ParseComplex:\n\nStep 1: Find position of 'i'; remove it; find last '+' or '-' before that; split into realPart string and imagPart string; convert to int. But we can keep as separate function.\n\nWe need to list each line. Let's enumerate.\n\nWe'll produce virtual code lines as requested. Ensure each line has \"虛擬碼步驟\" + \" // 解釋/說明\". Use arrows.\n\nAlso need to include Start and End. Let's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: num1Parts ← ParseComplex(num1) // 解析第 1 個複數字串為實部與虛部  \n→ Step 2: real1 ← num1Parts.real // 取得第 1 個複數的實部  \n→ Step 3: imag1 ← num1Parts.imag // 取得第 1 個複數的虛部  \n→ Step 4: num2Parts ← ParseComplex(num2) // 解析第 2 個複數字串為實部與虛部  \n→ Step 5: real2 ← num2Parts.real // 取得第 2 個複數的實部  \n→ Step 6: imag2 ← num2Parts.imag // 取得第 2 個複數的虛部  \n→ Step 7: realResult ← real1 * real2 - imag1 * imag2 // 計算乘法後的實部 (ac - bd)  \n→ Step 8: imagResult ← real1 * imag2 + imag1 * real2 // 計算乘法後的虛部 (ad + bc)  \n→ Decision: imagResult ≥ 0? // 判斷虛部正負以決定字串符號  \n    Yes → Step 9: sign ← '+' // 虛部為正，使用加號  \n    No  → Step 9: sign ← '' // 虛部為負，負號已包含於 imagResult  \n→ Step 10: result ← ToString(realResult) + sign + ToString(imagResult) + 'i' // 組合為「實部+虛部i」格式  \nEnd // 程式執行結束\n\n// --- ParseComplex 函式 (虛擬碼) ------------------------------------------------  \nStart // 進入 ParseComplex 函式  \n→ Step 1: idxI ← FindIndex(str, 'i') // 找到字串中 'i' 的位置  \n→ Step 2: strNoI ← RemoveCharAt(str, idxI) // 去除 'i'  \n→ Decision: FindLastSign(strNoI)? // 找最後一個 '+' 或 '-' 作為分隔符  \n    Yes → Step 3: sepIdx ← LastIndexOfSign(strNoI) // 分隔符位置  \n    No  → Step 3: sepIdx ← -1 // 無符號，表示純實數（此題不發生）  \n→ Step 4: realStr ← Substring(strNoI, 0, sepIdx) // 取得實部字串  \n→ Step 5: imagStr ← Substring(strNoI, sepIdx + 1) // 取得虛部字串  \n→ Step 6: realVal ← ToInt(realStr) // 轉成整數  \n→ Step 7: imagVal ← ToInt(imagStr) // 轉成整數  \n→ End // 回傳 realVal 與 imagVal  \n// ------------------------------------------------------------------------------",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        def parse(s: str):\n            real_str, imag_str = s.split('+')\n            return int(real_str), int(imag_str[:-1])  # remove trailing 'i'\n        \n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n        \n        real_part = a_real * b_real - a_imag * b_imag\n        imag_part = a_real * b_imag + a_imag * b_real\n        \n        return f\"{real_part}+{imag_part}i\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Extract the two complex number strings inside quotes\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) < 2:\n        # Fallback if no quotes are present; assume comma-separated\n        parts = [p.strip() for p in data.split(',')]\n        if len(parts) >= 2:\n            num1, num2 = parts[0], parts[1]\n        else:\n            raise ValueError(\"Invalid input format\")\n    else:\n        num1, num2 = matches[0], matches[1]\n\n    sol = Solution()\n    result = sol.complexNumberMultiply(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"1+1i\", \"1+1i\"",
          "expected_output": "\"0+2i\"",
          "success": true,
          "output": "0+2i"
        },
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "success": true,
          "output": "0+-2i"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode609.json",
    "problem_index_in_file": 0,
    "title": "Find Duplicate File in System",
    "description_snippet": "Given a list paths of directory info, including the directory path, and all the files with contents ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution step by step for the described problem. Must output in requested format: each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision etc. No actual code. Just virtual. Each line must contain step and explanation. Should be line-by-line.\n\nNeed to describe algorithm: parse each path string, extract directory path and files with contents. Use map content->list of paths. Then iterate to produce duplicates. Provide steps accordingly.\n\nLet's craft the virtual code:\n\nStart\n→ Step 1: 初始化映射 contentToPaths: 內容字符串 → 路徑列表\n→ Decision: 是否有輸入資料? // 檢查輸入是否為空\n    Yes → Step 2: 遍歷每個 directoryInfo in inputList // 逐行處理每個資料字串\n        → Step 3: 分離 directoryPath 與 filesString // 以空格拆分第一個空格前後\n        → Step 4: 將 filesString 以空格拆分得到每個 fileWithContent // 逐檔案處理\n            → Decision: fileWithContent 包含 '('? // 確認格式\n                Yes → Step 5: 提取 fileName 與 fileContent // 拆分 '(' 位置\n                No  → Step 5: 跳過此檔案 // 格式不正確，忽略\n            → Step 6: 組成 fullPath = directoryPath + \"/\" + fileName // 完整路徑\n            → Step 7: 將 fullPath 加入 contentToPaths[fileContent] // 建立映射\n        → End // 文件處理完成\n    No  → Step 8: 返回空列表 // 沒有輸入資料，直接結束\n→ Step 9: 初始化 resultList: List<List<string>>\n→ Decision: 是否存在 contentToPaths 內有多於一個路徑的條目? // 檢查是否有重複\n    Yes → Step 10: 遍歷每個 entry in contentToPaths\n            → Decision: entry.Value.size >= 2? // 至少兩個檔案\n                Yes → Step 11: 將 entry.Value 加入 resultList // 收集重複組\n                No  → No operation\n    No  → No operation\n→ Step 12: 返回 resultList // 輸出所有重複檔案組\nEnd // 程式結束\n\nNeed to maintain formatting exactly. Each line should have virtual code then space then comment. Use arrow \"→\". Need to indent decisions? In example they indent inside Decision. We'll replicate similar style.\n\nAlso, must not output actual code. The lines must show virtual steps like \"Start // 程式開始執行\".\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立映射 contentToPaths：內容 → 路徑清單 // 用來把相同內容的檔案路徑聚集  \n→ Decision: 輸入列表 nonEmpty? // 判斷是否有資料  \n    Yes → Step 2: 逐個處理每個 directoryInfo in inputList // 逐行解析  \n        → Step 3: 分離 directoryPath 與 filesPart // 以第一個空格切開  \n        → Step 4: 以空格拆分 filesPart 為 fileEntries // 取得每個檔案資訊  \n            → Decision: fileEntry 包含 '('? // 確認格式正確  \n                Yes → Step 5: 取得 fileName 與 fileContent // 拆分 '(' 位置  \n                No → Step 5: 跳過此檔案 // 非預期格式  \n            → Step 6: 組成 fullPath = directoryPath + \"/\" + fileName // 完整路徑  \n            → Step 7: 把 fullPath 加入 contentToPaths[fileContent] // 更新映射  \n        → End // 完成該 directoryInfo 的檔案處理  \n    No → Step 8: 直接返回空列表 // 無輸入資料，結束  \n→ Step 9: 建立 resultList // 用來收集重複檔案組  \n→ Decision: contentToPaths 中是否存在至少一個值長度 >= 2? // 是否有重複  \n    Yes → Step 10: 逐項檢查 contentToPaths  \n             → Decision: 目前值 listSize >= 2? // 需要至少兩個檔案  \n                    Yes → Step 11: 把此 list 加入 resultList // 收集一組重複檔案  \n                    No → No operation  \n    No → No operation  \n→ Step 12: 返回 resultList // 輸出所有重複檔案組  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\ndef find_duplicate(paths):\n    \"\"\"Return groups of duplicate file paths based on file content.\"\"\"\n    content_map = defaultdict(list)\n\n    for entry in paths:\n        parts = entry.split()\n        root = parts[0]\n        for file_info in parts[1:]:\n            name, content = file_info.split('(')\n            content = content[:-1]  # remove trailing ')'\n            content_map[content].append(f\"{root}/{name}\")\n\n    # Only keep groups that have more than one file\n    return [files for files in content_map.values() if len(files) > 1]\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # If input contains a leading variable assignment, strip it\n    if raw_input.startswith('paths'):\n        raw_input = raw_input.split('=', 1)[1].strip()\n\n    # Safely evaluate the list literal\n    try:\n        paths = ast.literal_eval(raw_input)\n    except Exception:\n        # If evaluation fails, treat the whole input as a single path string\n        paths = [raw_input]\n\n    result = find_duplicate(paths)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\", \"root/4.txt\"]]'"
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\"]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode208.json",
    "problem_index_in_file": 0,
    "title": "Implement Trie (Prefix Tree)",
    "description_snippet": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and r...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for implementing a Trie class with insert, search, startsWith. Provide step-by-step pseudo-code with explanations. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: with arrows. Let's design high-level structure: Start → initialize root node → Methods: insert, search, startsWith. But we should produce pseudo-code for each method with decisions. Probably we need to produce a single flow that covers the entire class? Could provide top-level skeleton, then each method.\n\nWe need to output line by line, each line has the virtual code plus explanation. So produce lines like:\n\nStart // 程式開始執行\n→ Class Trie // 定義 Trie 類別\n    → Method: Trie() // 建構子，初始化根節點\n        → Create node root // 建立根節點\n        → root.isEnd = false // 標記根節點不是單詞結束\n        → root.children = map<string, Node> // 儲存子節點\n        → End // 建構子結束\n    → Method: insert(word) // 插入單詞\n        → node = root // 從根節點開始\n        → For each char ch in word\n            → Decision: node.children contains ch?\n                Yes → node = node.children[ch] // 移動到已有子節點\n                No  → node.children[ch] = new Node() // 新建子節點\n                     → node = node.children[ch] // 移動到新節點\n            → End Decision\n        → node.isEnd = true // 標記單詞結束\n        → End // 插入結束\n    → Method: search(word) // 搜尋單詞\n        → node = root\n        → For each char ch in word\n            → Decision: node.children contains ch?\n                Yes → node = node.children[ch]\n                No  → Return false // 詞不在字典\n            → End Decision\n        → Return node.isEnd // 判斷是否為完整單詞\n        → End\n    → Method: startsWith(prefix) // 判斷前綴\n        → node = root\n        → For each char ch in prefix\n            → Decision: node.children contains ch?\n                Yes → node = node.children[ch]\n                No  → Return false // 無此前綴\n            → End Decision\n        → Return true // 前綴存在\n        → End\nEnd // 程式結束\n\nNeed to ensure each line has the virtual code plus // explanation. Provide arrows with → etc.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Class Trie // 定義 Trie 類別\n    → Method: Trie() // 建構子，初始化根節點\n        → Create node root // 建立根節點\n        → root.isEnd = false // 標記根節點不是單詞結束\n        → root.children = map<string, Node> // 儲存子節點\n        → End // 建構子結束\n    → Method: insert(word) // 插入單詞\n        → node = root // 從根節點開始\n        → For each char ch in word\n            → Decision: node.children contains ch?\n                Yes → node = node.children[ch] // 移動到已有子節點\n                No  → node.children[ch] = new Node() // 新建子節點\n                     → node = node.children[ch] // 移動到新節點\n            → End Decision\n        → node.isEnd = true // 標記單詞結束\n        → End // 插入結束\n    → Method: search(word) // 搜尋單詞\n        → node = root\n        → For each char ch in word\n            → Decision: node.children contains ch?\n                Yes → node = node.children[ch]\n                No  → Return false // 詞不在字典\n            → End Decision\n        → Return node.isEnd // 判斷是否為完整單詞\n        → End\n    → Method: startsWith(prefix) // 判斷前綴\n        → node = root\n        → For each char ch in prefix\n            → Decision: node.children contains ch?\n                Yes → node = node.children[ch]\n                No  → Return false // 無此前綴\n            → End Decision\n        → Return true // 前綴存在\n        → End\nEnd // 程式結束\n```",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass TrieNode:\n    \"\"\"Trie node holding children and end flag.\"\"\"\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    \"\"\"Trie (prefix tree) implementation.\"\"\"\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\ndef main() -> None:\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Convert the input string into two lists: operations and arguments\n    # The input format is like: ['Trie', 'insert', ...], [[], ['apple'], ...]\n    # Wrap it with parentheses to evaluate as a tuple.\n    try:\n        ops, args = ast.literal_eval(f'({data})')\n    except Exception as e:\n        raise ValueError(\"Input format is incorrect.\") from e\n\n    trie = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == 'Trie':\n            trie = Trie()\n            results.append(None)\n        elif op == 'insert':\n            trie.insert(arg[0])\n            results.append(None)\n        elif op == 'search':\n            results.append(trie.search(arg[0]))\n        elif op == 'startsWith':\n            results.append(trie.startsWith(arg[0]))\n        else:\n            raise ValueError(f\"Unknown operation: {op}\")\n\n    # Output results in JSON format (null, true, false)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "success": true,
          "output": "[null, null, true, false, true, null, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode268.json",
    "problem_index_in_file": 0,
    "title": "Missing Number",
    "description_snippet": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations, following format. We need to solve: given array nums of n distinct numbers from 0 to n inclusive, missing one number. Use XOR or arithmetic. Provide steps.\n\nWe'll produce steps:\n\nStart\n→ Step 1: compute expected XOR of 0..n\n→ Step 2: compute actual XOR of array elements\n→ Step 3: XOR the two results to get missing number\n→ Step 4: output missing number\nEnd\n\nAdd explanation after each line.\n\nAlso must use decision? Not necessary but we could have decision for empty array? Not needed.\n\nUse the specified arrow format.\n\nWe produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 0 到 n 的 XOR 總和 // 先算出完整數列的 XOR 值  \n→ Step 2: 計算陣列 nums 內所有元素的 XOR 總和 // 對現有數字進行 XOR  \n→ Step 3: missing ← Step1_XOR XOR Step2_XOR // 兩個 XOR 結果相減即可得到缺失數字  \n→ Step 4: 輸出 missing // 顯示唯一缺失的數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef missing_number(nums):\n    \"\"\"計算缺失的數字，使用算術總和差法。\"\"\"\n    n = len(nums)\n    total = n * (n + 1) // 2          # 0~n 的總和\n    return total - sum(nums)          # 缺失值 = 總和 - 目前元素總和\n\ndef main():\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 只取等號右邊的部分（可能含有前後空白或換行）\n    if '=' in raw_input:\n        _, list_part = raw_input.split('=', 1)\n    else:\n        list_part = raw_input\n    list_part = list_part.strip()\n\n    # 將字串轉成實際的 list\n    nums = ast.literal_eval(list_part)\n\n    # 計算缺失的數字並輸出\n    result = missing_number(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [9,6,4,2,3,5,7,0,1]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode470.json",
    "problem_index_in_file": 0,
    "title": "Implement Rand10() Using Rand7()",
    "description_snippet": "Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to generate uniform 1-10 from rand7. Classic approach: use two calls to rand7 to get range 1-49, reject 41-49 to get 1-40, then map 1-40 to 1-10 via mod 10. Steps:\n\nStart\n→ Step: Generate x = rand7()\n→ Step: Generate y = rand7()\n→ Step: Compute val = (x-1)*7 + y  // range 1-49\n→ Decision: 如果 val <= 40? // accept\n    Yes → Step: Return (val-1) mod 10 + 1\n    No → Repeat entire process (loop)\nBut need to produce loop. We'll use Decision with loop.\n\nAlso we must not call other APIs. So only rand7.\n\nWe produce virtual code lines with explanations.\n\nWe need to show loop using decision: \"Repeat until success\".\n\nWe can use Start and End.\n\nLet's produce steps:\n\nStart\n→ Step: 重複\n   → Step: x = rand7() // first random\n   → Step: y = rand7() // second random\n   → Step: val = (x-1)*7 + y // combine to 1-49\n   → Decision: val <= 40? // check acceptance\n      Yes → Step: result = (val-1) % 10 + 1 // map to 1-10\n           → Step: Return result // exit\n      No → Go back to start of loop\n\nEnd\n\nBut need explicit loop structure. Use Decision with No → repeat.\n\nWe should use \"Repeat\" or \"Loop\" placeholder.\n\nLet's craft virtual code:\n\nStart\n→ Decision: 是否需要生成新數? // initial flag\n    Yes → Step: x = rand7() // 1-7\n    → Step: y = rand7() // 1-7\n    → Step: val = (x-1)*7 + y // 1-49\n    → Decision: val <= 40? // acceptable?\n        Yes → Step: result = (val-1) % 10 + 1 // 1-10\n              → Step: Return result\n        No  → Go back to start // repeat loop\nEnd\n\nBut we might need explicit 'Loop' indicator. Use \"Loop:\" label.\n\nBetter:\n\nStart\n→ Loop: // 開始迴圈\n    → Step: x = rand7() // 取得 1-7\n    → Step: y = rand7() // 取得 1-7\n    → Step: val = (x-1)*7 + y // 合併為 1-49\n    → Decision: val <= 40? // 是否在可接受區間\n        Yes → Step: result = (val-1) % 10 + 1 // 轉換為 1-10\n              → Step: Return result // 結束\n        No  → Go to Loop // 重複\n\nEnd\n\nAlso mention \"Return\" step.\n\nWe need to include explanation after each line.\n\nLet's format:\n\nStart // 程式開始執行\n→ Loop: // 進入重複迴圈，直到得到合法結果\n    → Step: x = rand7() // 產生第一個隨機數 1-7\n    → Step: y = rand7() // 產生第二個隨機數 1-7\n    → Step: val = (x-1)*7 + y // 組合為 1-49 的隨機數\n    → Decision: val <= 40? // 檢查是否在可接受區間\n        Yes → Step: result = (val-1) % 10 + 1 // 將 1-40 映射為 1-10\n              → Step: Return result // 回傳結果並離開迴圈\n        No  → Go to Loop // 若 val > 40，重複整個過程\nEnd // 程式結束\n\nMake sure each line has \"虛擬碼步驟\" + \" // 解釋\". Need to include indentation properly. Use the arrow and decision formatting exactly.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Loop: // 進入重複迴圈，直到得到合法結果  \n → Step: x = rand7() // 產生第一個隨機數 1-7  \n → Step: y = rand7() // 產生第二個隨機數 1-7  \n → Step: val = (x-1)*7 + y // 組合為 1-49 的隨機數  \n → Decision: val <= 40? // 檢查是否在可接受區間  \n  Yes → Step: result = (val-1) % 10 + 1 // 將 1-40 映射為 1-10  \n   → Step: Return result // 回傳結果並離開迴圈  \n  No  → Go to Loop // 若 val > 40，重複整個過程  \nEnd // 程式結束",
      "generated_code": "import sys\nimport random\nimport re\n\ndef rand7():\n    \"\"\"返回 1~7 的均勻隨機整數。\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        \"\"\"\n        透過兩次 rand7() 產生 1~49 的均勻分布，\n        再利用 rejection sampling 取得 1~40 的數字，\n        最後映射到 1~10。\n        \"\"\"\n        while True:\n            # (rand7() - 1) * 7 + rand7() 產生 1~49\n            num = (rand7() - 1) * 7 + rand7()\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\ndef main():\n    # 讀取 stdin，例如 \"n = 3\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從字串中擷取數字\n    match = re.search(r'(\\d+)', data)\n    if not match:\n        return\n    n = int(match.group(1))\n\n    sol = Solution()\n    # 呼叫 rand10() n 次，收集結果\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[7]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[7]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[10,6]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[10, 6]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[5,10,7]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[5, 10, 7]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode7.json",
    "problem_index_in_file": 0,
    "title": "Reverse Integer",
    "description_snippet": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step, with comments. Should be in Chinese. Need to handle reversing integer digits with overflow detection, but cannot use 64-bit ints. Must use 32-bit operations. We need to use algorithm: take sign, work with absolute value, extract digits via modulo and division, build reversed number with overflow check: before adding digit, check if result > (INT_MAX - digit)/10 etc. Because cannot use 64-bit. Should treat negative separately. Use INT_MAX=2147483647, INT_MIN=-2147483648. For negative numbers, we can use positive absolute value but must watch overflow for INT_MIN? Since abs(INT_MIN) overflows 32-bit, can't convert. Better treat sign separately: store sign = 1 if x>=0 else -1. Work with unsigned 32-bit? but environment cannot store 64-bit. Use unsigned 32-bit is okay. But absolute of INT_MIN cannot be represented as positive 32-bit. But we can treat by using x < 0 separately: we can set num = -(int64)x? Not allowed. So better use while loop: we can process digits by taking negative of x? Approach: Use sign, but for negative numbers, we can't compute abs easily. We can process x as negative value, and reverse using negative operations to avoid overflow: but algorithm for reversal can be applied on positive absolute; but for INT_MIN, we need to handle specially: reversing INT_MIN results in -8463847412 which is outside range, so return 0. But we cannot compute abs(INT_MIN). However we can convert to positive via long long? not allowed. But we can treat by converting to unsigned 32-bit? Since environment cannot store 64-bit, but unsigned 32-bit can represent abs(INT_MIN) because 2147483648 > 2^31-1 but within 2^32-1. But standard C might treat unsigned 32-bit but still allowed? The requirement says environment does not allow storing 64-bit integers. Unsigned 32-bit is allowed. So we can store num = (unsigned int)(-x) when x negative? Wait -INT_MIN overflows signed 32-bit, but we can cast to unsigned: (unsigned int)(-(long)x) maybe? But that uses 64-bit. Instead we can use: unsigned int num = (unsigned int)(x); if negative, num = (unsigned int)(-x)? That still overflows. So we can use approach: let num = (unsigned int)(x); if negative, num = (unsigned int)(-x)? Not good.\n\nAlternate: Instead of abs, we can reverse directly with sign handling: While x != 0: pop = x % 10; x = x / 10; // integer division truncates toward zero. For negative numbers, pop will be negative. Build rev: rev = rev * 10 + pop. Use overflow check before multiplication: if rev > INT_MAX/10 or (rev == INT_MAX/10 and pop > 7) then overflow. For negative, rev negative: if rev < INT_MIN/10 or (rev == INT_MIN/10 and pop < -8). Because INT_MIN = -2147483648, the last digit is -8. So we can use signless algorithm without abs. This works and no 64-bit needed.\n\nThus algorithm: rev = 0; while x != 0: pop = x % 10; x = x / 10; // integer division truncates toward zero (C++ truncates toward zero)\nCheck overflow: if rev > INT_MAX/10 or (rev == INT_MAX/10 and pop > 7) => return 0. Similarly rev < INT_MIN/10 or (rev == INT_MIN/10 and pop < -8) => return 0. Then rev = rev * 10 + pop.\n\nFinally return rev.\n\nWe need virtual code steps.\n\nLet's produce lines:\n\nStart\n→ Step 1: 定義 INT_MAX = 2147483647, INT_MIN = -2147483648 // 定義 32 位元整數範圍\n→ Step 2: 初始化 rev = 0 // 儲存反轉結果\n→ Decision: 如果 x == 0? // 若輸入為 0，直接返回 0\n    Yes → Step 3: 返回 rev // 回傳 0\n    No  → Step 4: 開始 while 迴圈 // 進行數字反轉\n→ Step 5: pop = x % 10 // 取最右邊位數\n→ Step 6: x = x / 10 // 去除已取位\n→ Decision: 是否發生正溢? // 檢查 rev > INT_MAX/10 或等於且 pop > 7\n    Yes → Step 7: 返回 0 // 溢出，回傳 0\n    No  → Decision: 是否發生負溢? // 檢查 rev < INT_MIN/10 或等於且 pop < -8\n        Yes → Step 8: 返回 0 // 溢出，回傳 0\n        No  → Step 9: rev = rev * 10 + pop // 更新反轉值\n→ Decision: 是否 x == 0? // 迴圈結束條件\n    Yes → Step 10: 返回 rev // 迴圈結束，回傳結果\n    No  → Step 11: 回到 Step 5 // 重複迴圈\n\nEnd\n\nWe must format each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" before each step, \"Decision:\" lines. Ensure indentation of Yes/No lines? We can indent.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 INT_MAX = 2147483647, INT_MIN = -2147483648 // 設定 32 位元整數的最大與最小值  \n→ Step 2: 初始化 rev = 0 // 用於儲存反轉後的整數  \n→ Decision: 如果 x == 0? // 若輸入已經是 0  \n  Yes → Step 3: 返回 rev // 回傳 0  \n  No  → Step 4: 開始 while 迴圈 // 進行數字反轉操作  \n→ Step 5: pop = x % 10 // 取得目前最右邊的位數（可能為負）  \n→ Step 6: x = x / 10 // 去除已取出的位數，整數除法向零截斷  \n→ Decision: 是否發生正溢? // 檢查 rev * 10 + pop 會否超過 INT_MAX  \n  Yes → Step 7: 返回 0 // 正溢，回傳 0  \n  No  → Decision: 是否發生負溢? // 檢查是否會低於 INT_MIN  \n    Yes → Step 8: 返回 0 // 負溢，回傳 0  \n    No  → Step 9: rev = rev * 10 + pop // 安全更新 rev  \n→ Decision: 是否 x == 0? // 判斷是否已經處理完所有位數  \n  Yes → Step 10: 返回 rev // 迴圈結束，回傳結果  \n  No  → Step 11: 回到 Step 5 // 重新取下一位數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reverse(self, x: int) -> int:\n        \"\"\"\n        反轉 32 位元有符號整數，若溢出則回傳 0。\n        這裡使用與 C/C++ 相同的除法與取餘邏輯，避免使用 64 位元整數。\n        \"\"\"\n        INT_MAX = 2 ** 31 - 1\n        INT_MIN = -2 ** 31\n\n        rev = 0\n        while x != 0:\n            # 取得最右邊一位數，模擬 C/C++ 的 % 行為\n            if x > 0:\n                pop = x % 10\n            else:\n                pop = -((-x) % 10)\n\n            # 依照 C/C++ 的整數除法 (向 0 截斷) 取出剩餘部分\n            x = int(x / 10)\n\n            # 檢查乘以 10 再加上 pop 會不會超出範圍\n            if rev > INT_MAX // 10 or (rev == INT_MAX // 10 and pop > 7):\n                return 0\n            if rev < INT_MIN // 10 or (rev == INT_MIN // 10 and pop < -8):\n                return 0\n\n            rev = rev * 10 + pop\n\n        return rev\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整數，格式可能是「x = 123」或「-123」等\n    data = sys.stdin.read().strip()\n    match = re.search(r'(-?\\d+)', data)\n    if match:\n        x = int(match.group(1))\n    else:\n        x = 0  # 若找不到數字則預設為 0\n\n    result = Solution().reverse(x)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 123",
          "expected_output": "321",
          "success": true,
          "output": "321"
        },
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "success": true,
          "output": "-321"
        },
        {
          "example_index": 2,
          "input": "x = 120",
          "expected_output": "21",
          "success": true,
          "output": "21"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode67.json",
    "problem_index_in_file": 0,
    "title": "Add Binary",
    "description_snippet": "Given two binary strings a and b, return their sum as a binary string....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for adding two binary strings a and b, returning sum binary string. No actual code. Use virtual code syntax with arrow, Decision, etc. Each line: virtual step + space + // explanation.\n\nWe need to produce lines: Start, Step 1: input a,b, maybe pointer indices i, j at end, carry 0. While i>=0 or j>=0 or carry, get bit from a and b if exist else 0, sum = bitA+bitB+carry, result bit = sum%2, carry = sum/2, prepend to result string. After loop, End. Use Decision: if i>=0 or j>=0 or carry? Yes -> loop else exit. Also Decision: if i>=0? etc.\n\nLet's produce clear steps.\n\nUse virtual arrows.\n\nWe need to adhere to format: \"虛擬碼步驟 [space] // 解釋\". Let's write.\n\nWe can use \"→\" for next steps.\n\nWe need to include \"Start\" and \"End\".\n\nOk produce.\n\nLet's do:\n\nStart // 開始執行\n→ Step 1: i ← length(a) - 1 // 初始化 a 的指標指向最後一位\n→ Step 2: j ← length(b) - 1 // 初始化 b 的指標指向最後一位\n→ Step 3: carry ← 0 // 初始化進位為 0\n→ Step 4: result ← \"\" // 用於存放累積的結果\n\n→ Decision: 是否還有位需要處理? // 判斷 i>=0 或 j>=0 或 carry\n    Yes → Step 5: bitA ← i>=0 ? a[i] : 0 // 取 a 的當前位，若已遍歷完則為 0\n    → Step 6: bitB ← j>=0 ? b[j] : 0 // 取 b 的當前位，若已遍歷完則為 0\n    → Step 7: sum ← bitA + bitB + carry // 計算兩位與進位之和\n    → Step 8: resultBit ← sum mod 2 // 計算本位結果\n    → Step 9: carry ← sum div 2 // 更新進位\n    → Step 10: result ← resultBit + result // 將結果位加到最前面\n    → Step 11: i ← i - 1 // 移動 a 的指標\n    → Step 12: j ← j - 1 // 移動 b 的指標\n    → Decision: 是否仍需處理? // 回到判斷\n        Yes → [回到] Decision: 是否還有位需要處理?\n        No → End // 所有位已處理，程式結束\n    No → End // 若初始判斷為 No，直接結束\n\nWe need to include End after loop. But we need to ensure final result returned. Might add Step 13: return result // 返回最終二進位字串.\n\nLet's include after loop ends: Step 13: return result // 輸出累積的二進位結果\n\nBetter restructure: After loop, return.\n\nLet's incorporate. Also we need to avoid nested loops but we can use Decision and arrow to loop.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← length(a) - 1 // 將指標 i 指向字串 a 的最後一位  \n→ Step 2: j ← length(b) - 1 // 將指標 j 指向字串 b 的最後一位  \n→ Step 3: carry ← 0 // 初始化進位為 0  \n→ Step 4: result ← \"\" // 用於累積最終的二進位字串  \n\n→ Decision: 是否還有位需要處理? // 判斷 i>=0 或 j>=0 或 carry  \n    Yes → Step 5: bitA ← i>=0 ? a[i] : 0 // 取得 a 的當前位，若已遍歷完則為 0  \n    → Step 6: bitB ← j>=0 ? b[j] : 0 // 取得 b 的當前位，若已遍歷完則為 0  \n    → Step 7: sum ← bitA + bitB + carry // 計算兩位與進位之和  \n    → Step 8: resultBit ← sum mod 2 // 本位計算結果為 sum 的餘數  \n    → Step 9: carry ← sum div 2 // 更新進位為 sum 的整除 2 的結果  \n    → Step 10: result ← resultBit + result // 將本位結果加到前面  \n    → Step 11: i ← i - 1 // 移動 a 的指標向左  \n    → Step 12: j ← j - 1 // 移動 b 的指標向左  \n    → Decision: 是否仍需處理? // 回到判斷條件  \n        Yes → [回到] Decision: 是否還有位需要處理?  \n        No  → Step 13: return result // 所有位已處理，返回累積結果  \n    No → Step 13: return result // 初始時已無位需要處理，直接返回結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i, j = len(a) - 1, len(b) - 1\n        carry = 0\n        result = []\n\n        while i >= 0 or j >= 0 or carry:\n            total = carry\n            if i >= 0:\n                total += int(a[i])\n                i -= 1\n            if j >= 0:\n                total += int(b[j])\n                j -= 1\n            result.append(str(total % 2))\n            carry = total // 2\n\n        return ''.join(reversed(result))\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract quoted strings (the binary numbers)\n    nums = re.findall(r'\"([^\"]*)\"', data)\n    if len(nums) >= 2:\n        a, b = nums[0], nums[1]\n    else:\n        # Fallback: assume each line is a binary string\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            a, b = lines[0], lines[1]\n        else:\n            # If only one string is provided, treat second as empty\n            a, b = lines[0], ''\n\n    solution = Solution()\n    result = solution.addBinary(a, b)\n    # Print result wrapped in double quotes as shown in examples\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = \"11\", b = \"1\"",
          "expected_output": "\"100\"",
          "success": true,
          "output": "\"100\""
        },
        {
          "example_index": 1,
          "input": "a = \"1010\", b = \"1011\"",
          "expected_output": "\"10101\"",
          "success": true,
          "output": "\"10101\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode371.json",
    "problem_index_in_file": 0,
    "title": "Sum of Two Integers",
    "description_snippet": "Given two integers a and b, return the sum of the two integers without using the operators + and -....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for adding two integers without + or -. Classic bitwise addition: use while b != 0: carry = a & b; a = a ^ b; b = carry << 1. Return a. Virtual code lines with comments. Use Start, End, Decision. Also no actual code. Provide step lines with arrows. Should include decisions? We can do simple algorithm. But maybe need loop decision: while b != 0. Use Decision: b == 0? etc.\n\nLet's craft:\n\nStart // begin\n→ Step 1: a ← input a // get first integer\n→ Step 2: b ← input b // get second integer\n→ Decision: b == 0? // check if no carry left\n    Yes → Step 3: return a // addition complete\n    No  → Step 4: carry ← a AND b // compute carry bits\n→ Step 5: a ← a XOR b // add bits without carry\n→ Step 6: b ← carry LEFT SHIFT 1 // move carry to next bit\n→ Step 7: Go back to Decision // repeat until carry zero\nEnd // finish\n\nNeed arrows and indentation? Use arrow for each line. Provide explanation. Use Yes→ etc. Provide structure. Use \"Decision:\" line. Provide \"Yes →\" \"No →\".\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: a ← 輸入第一個整數 // 取得第一個整數  \n→ Step 2: b ← 輸入第二個整數 // 取得第二個整數  \n→ Decision: b == 0? // 檢查是否已無進位  \n  Yes → Step 3: return a // 進位為 0，結果即為 a  \n  No  → Step 4: carry ← a AND b // 計算進位位元  \n→ Step 5: a ← a XOR b // 將不帶進位的位相加  \n→ Step 6: b ← carry 左移 1 位 // 將進位搬到下一位  \n→ Step 7: 回到 Decision // 重新檢查進位是否為 0  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def getSum(self, a: int, b: int) -> int:\n        MASK = 0xFFFFFFFF          # 32‑bit mask\n        MAX_INT = 0x7FFFFFFF       # maximum positive 32‑bit signed integer\n\n        # Add a and b without using + or -\n        while b != 0:\n            carry = (a & b) & MASK\n            a = (a ^ b) & MASK\n            b = (carry << 1) & MASK\n\n        # Convert from unsigned to signed if needed\n        return a if a <= MAX_INT else ~(a ^ MASK)\n\n\ndef main() -> None:\n    # Read entire input from stdin\n    data = sys.stdin.read()\n\n    # Extract the first two integers (handles negative numbers)\n    numbers = re.findall(r'-?\\d+', data)\n    if len(numbers) < 2:\n        return  # Not enough numbers provided\n\n    a = int(numbers[0])\n    b = int(numbers[1])\n\n    # Compute the sum using the bitwise algorithm\n    result = Solution().getSum(a, b)\n\n    # Output the result\n    print(f\"{result}\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 1, b = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode593.json",
    "problem_index_in_file": 0,
    "title": "Valid Square",
    "description_snippet": "Given the coordinates of four points in 2D space p1, p2, p3 and p4, return true if the four points c...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to determine if four points form a square. Steps: calculate all pairwise distances squared (6 distances). Find min distance >0 => side length. Count occurrences: side length should appear exactly 4 times. Diagonal length appears twice and equals 2 * side^2. Then return true else false. Need to handle input unordered. Also need to handle no duplicates. Steps: compute distances list. Sort. Check distinct values. Check counts. Provide steps.\n\nWe need to output line by line virtual code with explanations. Use Start, End, Decision, Yes→, No→. Ensure each line has \"虛擬碼步驟 // 解釋\".\n\nWe'll create steps:\n\nStart\n→ Step 1: 計算所有 6 個點對距離平方 // 得到距離列表\n→ Step 2: 將距離列表排序 // 方便分辨邊長與對角線\n→ Decision: 是否存在相同距離？ // 檢查是否有至少兩種距離\n    Yes → Step 3: 設 side = 第一個距離 // 最短距離為邊長\n           → Decision: side > 0? // 確保邊長正\n               Yes → Step 4: 计数 side 出现次数 // 边长出现次数\n                      → Decision: 次数 == 4? // 四条边相等\n                          Yes → Step 5: 设 diagonal = 第五个距离 // 对角线距离\n                                 → Decision: diagonal == 2 * side^2? // 对角线关系\n                                     Yes → Step 6: 返回 true // 满足正方形条件\n                                     No  → Step 7: 返回 false // 对角线不符合\n                          No  → Step 8: 返回 false // 边长不出现四次\n               No  → Step 9: 返回 false // 边长为 0\n    No  → Step 10: 返回 false // 只有一种距离或不足两种\n\nBut we also need to consider duplicates? We could add earlier check: unique points count == 4. Let's include Step 0 before Step 1: 检查点数是否为 4 并且无重复. But input is 4 points; duplicates may be possible. We can add.\n\nLet's produce final virtual code.\n\nEnsure each line has \"虛擬碼步驟 // 解釋\".\n\nWe need arrow format: → etc. We need to indent decisions maybe. Use \"Decision:\" and \"Yes →\", \"No →\" lines. Provide consistent spacing. Use Start, End. Provide each line. Use bullet? Not required.\n\nWe'll output accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 檢查是否四個點且各點唯一 // 確保不含重複座標  \n→ Decision: 重複點存在? // 若有重複，無法構成正方形  \n  Yes → Step 1a: 返回 false // 直接結束  \n  No  → Step 1: 計算所有 6 個點對距離平方 // 取得距離列表  \n→ Step 2: 將距離列表排序 // 方便區分邊長與對角線  \n→ Decision: 是否至少兩種不同距離? // 正方形需有邊長與對角線兩種距離  \n  Yes → Step 3: side = 第一個距離 // 最短距離視為邊長  \n   → Decision: side > 0? // 邊長必為正  \n    Yes → Step 4: 計算 side 出現的次數 // 边長出現次數  \n     → Decision: 次數 == 4? // 四條邊長相等  \n      Yes → Step 5: diagonal = 第五個距離 // 对角线距离  \n       → Decision: diagonal == 2 * side^2? // 对角线应为边长平方的两倍  \n        Yes → Step 6: 返回 true // 满足正方形条件  \n        No  → Step 7: 返回 false // 对角线不符合正方形比例  \n     No  → Step 8: 返回 false // 边长未出现四次  \n  No  → Step 9: 返回 false // 边长为 0 或不符合正方形条件  \n  No  → Step 10: 返回 false // 仅有一种距离，无法构成正方形  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0]-b[0])**2 + (a[1]-b[1])**2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n\n        for i in range(4):\n            for j in range(i+1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n\n        return (\n            dists[0] > 0 and\n            dists[0] == dists[1] == dists[2] == dists[3] and\n            dists[4] == dists[5] and\n            dists[4] == 2 * dists[0]\n        )\n\ndef main():\n    data = sys.stdin.read()\n    # Extract all integer values (including negatives)\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) != 8:\n        print('false')\n        return\n    points = [[nums[i], nums[i + 1]] for i in range(0, 8, 2)]\n    p1, p2, p3, p4 = points\n    sol = Solution()\n    result = sol.validSquare(p1, p2, p3, p4)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 1,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode35.json",
    "problem_index_in_file": 0,
    "title": "Search Insert Position",
    "description_snippet": "Given a sorted array of distinct integers and a target value, return the index if the target is foun...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. The requirement: \"逐行產生虛擬碼\" and explanation after space. Use arrow \"→\" and Decision etc. Must not output actual code, only pseudo steps.\n\nWe need to handle binary search returning index or insertion point. Steps: Start, initialize left=0, right=length-1. While left <= right, compute mid, compare mid value to target. If equal return mid. If mid value < target left=mid+1; else right=mid-1. After loop return left (insertion index). End.\n\nWe need to include explanation. Format each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision: etc. Provide step numbers maybe but not required.\n\nLet's craft lines:\n\nStart // 程式開始\n→ Step 1: 初始化 left = 0, right = n-1 // 設定搜尋範圍\n→ Step 2: 進入循環: Decision: 如果 left ≤ right? // 判斷是否還有範圍可搜尋\n    Yes → Step 3: 計算 mid = (left + right) / 2 // 取中點索引\n    → Decision: 如果 nums[mid] == target? // 檢查中點是否為目標\n        Yes → Step 4: 返回 mid // 找到目標，返回其索引\n        No  → Decision: 如果 nums[mid] < target? // 中點值小於目標，目標在右半\n            Yes → Step 5: left = mid + 1 // 將左指標移至 mid+1\n            No  → Step 6: right = mid - 1 // 否則將右指標移至 mid-1\n    No → Step 7: 循環結束 // 左指標已超過右指標，停止搜尋\n→ Step 8: 返回 left // left 為插入位置\nEnd // 程式結束\n\nNeed to ensure each line is separate, with arrow and explanation. Ensure no code. Use the format.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 left = 0, right = n-1 // 設定搜尋範圍  \n→ Decision: 如果 left ≤ right? // 判斷是否還有範圍可搜尋  \n Yes → Step 2: 計算 mid = (left + right) / 2 // 取中點索引  \n  Decision: 如果 nums[mid] == target? // 檢查中點是否為目標  \n   Yes → Step 3: 返回 mid // 找到目標，返回其索引  \n   No → Decision: 如果 nums[mid] < target? // 中點值小於目標，目標在右半  \n    Yes → Step 4: left = mid + 1 // 將左指標移至 mid+1  \n    No → Step 5: right = mid - 1 // 將右指標移至 mid-1  \n No → Step 6: 循環結束 // 左指標已超過右指標，停止搜尋  \n→ Step 7: 返回 left // left 為插入位置  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        使用二分搜尋在升序唯一整數陣列中尋找 target 的插入位置。\n        \"\"\"\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中抽取 nums 列表與 target 整數。\n    支援形如「nums = [1,3,5,6], target = 5」的格式。\n    \"\"\"\n    import re\n    nums = []\n    target = None\n\n    # 抽取方括號內的數字\n    list_match = re.search(r'\\[(.*?)\\]', data)\n    if list_match:\n        nums = [int(x.strip()) for x in list_match.group(1).split(',') if x.strip()]\n\n    # 抽取 target\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if target_match:\n        target = int(target_match.group(1))\n\n    return nums, target\n\n\nif __name__ == \"__main__\":\n    import sys\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n\n    solution = Solution()\n    index = solution.searchInsert(nums, target)\n    print(index)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode154.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array II",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanations, for algorithm to find minimum in rotated sorted array with duplicates, minimizing operations. Likely binary search with duplicate handling: use low, high, while low < high, mid, compare nums[mid] with nums[high] etc. Since duplicates, if equal, high--. Let's craft pseudocode lines.\n\nWe need Start, End, Decision, etc.\n\nLet's produce steps:\n\nStart // begin\n→ Step 1: Set low = 0, high = length-1 // indices\n→ Decision: low == high? // if only one element\n    Yes → Step 2: return nums[low] // minimum found\n    No  → Step 3: while low < high: // main loop\n→ Decision: nums[high] == nums[low]? // check equal extremes maybe\n    Yes → Step 4: high-- // shrink search space\n    No  → Decision: nums[mid] > nums[high]? // mid bigger than high, min in right half\n        Yes → Step 5: low = mid + 1 // discard left half\n        No  → Step 6: high = mid // discard right half\n... etc.\n\nBut need mid calculation each loop. We need compute mid inside loop.\n\nBetter structure:\n\n→ Step 3: while low < high: // loop\n    → Step 3.1: mid = (low + high) // 2 // integer division\n    → Decision: nums[mid] > nums[high]? // \n        Yes → low = mid + 1\n        No  → Decision: nums[mid] < nums[high]?\n            Yes → high = mid\n            No  → high = high - 1 // duplicates equal\n    // end loop\n→ Step 7: return nums[low] // after loop min\n\nBut need to handle duplicates: if nums[mid] == nums[high], high--.\n\nAlso, we might need to handle equality at start: if nums[low]==nums[high] and low<high, we could shrink either side; we choose high--.\n\nAlso need to handle if low==high after shrinking.\n\nLet's produce lines with decisions and arrows.\n\nWe should include arrow for decision lines: \"Decision: condition?\" and then \"Yes → ...\" \"No → ...\".\n\nWe should not output actual code, just virtual steps. Use arrows.\n\nAlso need to \"decrease overall operation steps as much as possible\". That implies minimal operations, but we still produce algorithm.\n\nLet's craft final output.\n\nWe must use Start, End.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: low = 0, high = n-1 // 初始化搜尋範圍\n→ Decision: low == high? // 只有一個元素\n    Yes → Step 2: return nums[low] // 直接回傳最小值\n    No  → Step 3: while low < high: // 主搜尋迴圈\n        → Step 3.1: mid = (low + high) // 2 // 取中點\n        → Decision: nums[mid] > nums[high]? // 中點大於右端，最小值在右半\n            Yes → Step 3.2: low = mid + 1 // 刪除左半\n            No  → Decision: nums[mid] < nums[high]? // 中點小於右端，最小值在左半\n                Yes → Step 3.3: high = mid // 刪除右半\n                No  → Step 3.4: high = high - 1 // nums[mid] == nums[high]，縮小右端\n    // 迴圈結束\n→ Step 4: return nums[low] // 循環結束後 low 即為最小值\nEnd // 程式執行結束\n\nBut we need to ensure each line has \"虛擬碼步驟 [space] // 解釋\". We used \"→\" arrows for steps inside loops, etc. But the format expects each line: \"虛擬碼步驟 // 解釋\". For decisions, the line should be \"Decision: condition?\" and then sub-lines \"Yes →\" etc. The example shows \"Decision:\" lines without arrow.\n\nLet's mimic example:\n\nStart // 程式開始執行\n→ Step 1: low = 0, high = n-1 // 初始化搜尋範圍\nDecision: low == high? // 判斷是否只剩一個元素\n    Yes → Step 2: return nums[low] // 返回最小值\n    No  → Step 3: while low < high: // 主搜尋迴圈\n        → Step 3.1: mid = (low + high) // 2 // 計算中點\n        Decision: nums[mid] > nums[high]? // 判斷中點是否大於右端\n            Yes → Step 3.2: low = mid + 1 // 將搜索範圍縮到右半\n            No  → Decision: nums[mid] < nums[high]? // 中點是否小於右端\n                Yes → Step 3.3: high = mid // 將搜索範圍縮到左半\n                No  → Step 3.4: high = high - 1 // 中點等於右端，減少右端\n    // while 迴圈結束\n→ Step 4: return nums[low] // low 即為最小值\nEnd // 程式結束\n\nBut we need to keep each line's indentation consistent? In example, they used indentation to show sub-branches.\n\nWe must ensure each line ends with // 解釋. For decisions we need arrow? The example: \"Decision: 如果數字大於 0?\" then \"Yes → Step 2:\" etc. So we should use similar.\n\nAlso, \"Decision:\" lines may not have arrow.\n\nWe also need to include \"End\" line.\n\nAlso, we need to ensure we do not output actual code; it's virtual pseudocode.\n\nLet's produce final output accordingly. Use Chinese explanation.\n\nAlso note: need to be thorough but concise. Provide explanation for each line.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 0, high = n-1 // 初始化搜尋範圍為整個陣列  \nDecision: low == high? // 只有一個元素可直接返回  \n Yes → Step 2: return nums[low] // 返回唯一元素作為最小值  \n No  → Step 3: while low < high: // 主搜尋迴圈，縮小搜尋區間  \n  → Step 3.1: mid = (low + high) // 2 // 計算中點索引  \n  Decision: nums[mid] > nums[high]? // 判斷中點值是否大於右端  \n   Yes → Step 3.2: low = mid + 1 // 中點右側一定有最小值，刪除左半  \n   No  → Decision: nums[mid] < nums[high]? // 中點小於右端，最小值在左半  \n    Yes → Step 3.3: high = mid // 將右端移到中點  \n    No  → Step 3.4: high = high - 1 // nums[mid] == nums[high]，右端縮小一個  \n  // 迴圈結束時 low == high，指向最小值  \n→ Step 4: return nums[low] // 返回最小元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMin(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n        return nums[left]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入字串轉為列表\n    try:\n        start = data.index('[')\n        end = data.rindex(']')\n        nums_str = data[start:end+1]\n        nums = ast.literal_eval(nums_str)\n    except ValueError:\n        nums = ast.literal_eval(data)\n    solution = Solution()\n    result = solution.findMin(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,0,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode638.json",
    "problem_index_in_file": 0,
    "title": "Shopping Offers",
    "description_snippet": "In LeetCode Store, there are n items to sell. Each item has a price. However, there are some special...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for the algorithm. Problem is LeetCode 638: Shopping Offers. Use DFS with memoization or DP. Provide step-by-step pseudocode. Each line with explanation. Use arrows and decisions.\n\nWe need to produce in Chinese traditional. Output each line with \"虛擬碼步驟 // 解釋\".\n\nWe must be careful: \"每行虛擬碼\" includes \"虛擬碼步驟\" and explanation. Use arrow etc. Start, End, Decision. We need to produce a structured algorithm, maybe recursive function.\n\nLet's produce:\n\nStart // 程式開始執行\n→ 准備函式: DFS(needs) // 將需求作為參數\n    Decision: 如果所有需求為 0? // 檢查是否已購買足夠\n        Yes → Return 0 // 需求已滿，費用為 0\n        No  → 進行下一步\n    Step: 計算不使用特價的價格 total = Σ needs[i] * price[i] // 基本價格\n    Step: best = total // 初始化最佳價格\n    → Loop over每個特殊優惠 special\n        Decision: 是否可使用此優惠? // 檢查每項是否足夠\n            Yes →\n                Step: 創建新需求 newNeeds = needs - special[0..n-1] // 更新需求\n                Step: cost = special[n] + DFS(newNeeds) // 用此優惠後費用\n                Decision: cost < best? // 與目前最佳比較\n                    Yes → best = cost // 更新最佳\n            No  → continue\n    Step: Memo[tuple(needs)] = best // 記錄結果\n    → Return best // 回傳最佳價格\nEnd // 程式結束\n\nBut need arrow formatting. Provide each step as separate line. Use \"→\" for sequence, \"Decision:\" for branching. Use \"Start\" and \"End\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ 建立 memo 字典 // 用於記錄已計算需求組合的最低價格\n→ 定義函式 DFS(需求) // 以需求為參數進行遞迴計算\n    Decision: 所有需求為 0? // 判斷是否已購足\n        Yes → Return 0 // 無需再購買，價格為 0\n        No  → 進行後續計算\n    Step: base = Σ(需求[i] * price[i]) // 僅購買個別商品的總價\n    Step: best = base // 初始化最佳價格\n    → 迴圈遍歷每個特殊優惠 special\n        Decision: 是否能使用 special? // 檢查每項需求是否足夠減少\n            Yes →\n                Step: newNeeds = [需求[i] - special[i] for i in 0..n-1] // 更新需求\n                Step: cost = special[n] + DFS(newNeeds) // 計算使用該優惠後總價\n                Decision: cost < best? // 比較是否更便宜\n                    Yes → best = cost // 更新最佳價格\n            No → // 跳過此優惠\n    Step: memo[tuple(需求)] = best // 記錄結果\n    → Return best // 回傳最佳價格\n→ result = DFS(needs) // 呼叫主函式得到最小價格\n→ Return result // 傳回答案\nEnd // 程式結束\n\nMake sure each line is separate with line breaks. Use \"→\" as arrow. Indent nested lines. Should be fine. Use Chinese. Provide arrow for decisions and loops. Should follow format.\n...done thinking.\n\nStart // 程式開始執行  \n→ 建立 memo 字典 // 用於記錄已計算需求組合的最低價格  \n→ 定義函式 DFS(需求) // 以需求為參數進行遞迴計算  \n Decision: 所有需求為 0? // 判斷是否已購足  \n  Yes → Return 0 // 無需再購買，價格為 0  \n  No  → 進行後續計算  \n Step: base = Σ(需求[i] * price[i]) // 僅購買個別商品的總價  \n Step: best = base // 初始化最佳價格  \n → 迴圈遍歷每個特殊優惠 special  \n  Decision: 是否能使用 special? // 檢查每項需求是否足夠減少  \n   Yes →  \n    Step: newNeeds = [需求[i] - special[i] for i in 0..n-1] // 更新需求  \n    Step: cost = special[n] + DFS(newNeeds) // 計算使用該優惠後總價  \n    Decision: cost < best? // 比較是否更便宜  \n     Yes → best = cost // 更新最佳價格  \n    No → // 跳過此優惠  \n Step: memo[tuple(需求)] = best // 記錄結果  \n → Return best // 回傳最佳價格  \n→ result = DFS(needs) // 呼叫主函式得到最小價格  \n→ Return result // 傳回答案  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # base case: buy all items at regular price\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef parse_input(data):\n    # Extract lists for price, special, needs using regex\n    def get_list(var):\n        m = re.search(rf'{var}\\s*=\\s*(\\[[^\\]]*\\])', data)\n        if m:\n            return ast.literal_eval(m.group(1))\n        return []\n\n    price = get_list('price')\n    special = get_list('special')\n    needs = get_list('needs')\n    return price, special, needs\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    price, special, needs = parse_input(raw_input)\n    sol = Solution()\n    result = sol.shoppingOffers(price, special, needs)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpejwpw309.py\", line 44, in <module>\n    price, special, needs = parse_input(raw_input)\n                            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpejwpw309.py\", line 38, in parse_input\n    special = get_list('special')\n              ^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpejwpw309.py\", line 34, in get_list\n    return ast.literal_eval(m.group(1))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[3,0,5]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpf3qdaboo.py\", line 44, in <module>\n    price, special, needs = parse_input(raw_input)\n                            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpf3qdaboo.py\", line 38, in parse_input\n    special = get_list('special')\n              ^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpf3qdaboo.py\", line 34, in get_list\n    return ast.literal_eval(m.group(1))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,4]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode709.json",
    "problem_index_in_file": 0,
    "title": "To Lower Case",
    "description_snippet": "Given a string s, return the string after replacing every uppercase letter with the same lowercase l...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate a virtual code flow for converting all uppercase letters in a string to lowercase. We produce each line with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow. Should reflect the algorithm. We have to include loop over characters, check uppercase, convert to lowercase, build result string.\n\nAlso we should be careful not to produce actual code. So we might use steps like \"Step 1: 初始化空結果字符串\" etc. Let's produce steps:\n\nStart\n→ Step 1: 建立空字符串 result // 用於儲存轉換後的結果\n→ Step 2: 將輸入字符串 s 分割為字符陣列 chars // 方便逐個處理\n→ Decision: 如果 chars 不為空? // 確認有字符要處理\n    Yes → Step 3: 初始化索引 i = 0 // 從第一個字符開始\n    No  → Step 4: Return result // 若輸入為空，直接返回空字符串\n→ Loop: While i < length(chars) // 逐個遍歷字符\n    → Decision: 如果 chars[i] 為大寫字母? // 判斷是否需要轉換\n        Yes → Step 5: 將 chars[i] 轉換為小寫後追加至 result // 轉換並追加\n        No  → Step 6: 直接將 chars[i] 追加至 result // 直接追加\n    → Step 7: i = i + 1 // 移動到下一個字符\n→ Step 8: Return result // 完成所有轉換後返回結果\nEnd\n\nBut we need to format each line like \"Start // 程式開始執行\". Use arrow \"→\". For loops we can just use \"Loop:\" and show inside. The decision block can have indentation.\n\nMake sure each line has one line of virtual code + comment. Provide arrow only for steps after start. For decisions we use \"Decision:\" then indent.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空結果字符串 result // 用於儲存轉換後的字串  \n→ Step 2: 將輸入字符串 s 轉成字符陣列 chars // 方便逐字符處理  \n→ Decision: 如果 chars 不是空? // 判斷是否有需要處理的字符  \n  Yes → Step 3: 初始化索引 i = 0 // 從第一個字符開始遍歷  \n  No  → Step 4: Return result // 若輸入為空，直接返回空字串  \n→ Loop: While i < length(chars) // 逐個遍歷所有字符  \n  → Decision: 如果 chars[i] 為大寫字母? // 判斷是否需要轉換  \n   Yes → Step 5: 將 chars[i] 轉為小寫後追加到 result // 轉換並存入結果  \n   No  → Step 6: 直接將 chars[i] 追加到 result // 原樣存入  \n  → Step 7: i = i + 1 // 移動到下一個字符  \n→ Step 8: Return result // 所有字符處理完畢，返回轉換後字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def toLowerCase(self, s: str) -> str:\n        \"\"\"\n        將字串中所有大寫字母轉成小寫字母，其他字元保持不變。\n        \"\"\"\n        result = []\n        for c in s:\n            if 'A' <= c <= 'Z':\n                # ASCII 大寫字母與小寫字母相差 32\n                result.append(chr(ord(c) + 32))\n            else:\n                result.append(c)\n        return ''.join(result)\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    從輸入資料中抽取字串內容。\n    期望輸入形如：s = \"Hello\" 或僅為字串本身。\n    \"\"\"\n    # 嘗試找出第一個雙引號與最後一個雙引號之間的內容\n    match = re.search(r'\"(.*)\"', data)\n    if match:\n        return match.group(1)\n    # 若沒有雙引號，直接返回整行字串\n    return data.strip()\n\ndef main() -> None:\n    \"\"\"\n    主程式入口：讀取標準輸入、處理資料並輸出結果。\n    \"\"\"\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n\n    # 取得要處理的字串\n    s = parse_input(raw_input)\n\n    # 進行大小寫轉換\n    solution = Solution()\n    lowered = solution.toLowerCase(s)\n\n    # 依範例輸出，將結果包在雙引號內\n    print(f'\"{lowered}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello\"",
          "expected_output": "\"hello\"",
          "success": true,
          "output": "\"hello\""
        },
        {
          "example_index": 1,
          "input": "s = \"here\"",
          "expected_output": "\"here\"",
          "success": true,
          "output": "\"here\""
        },
        {
          "example_index": 2,
          "input": "s = \"LOVELY\"",
          "expected_output": "\"lovely\"",
          "success": true,
          "output": "\"lovely\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode153.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for finding min in rotated sorted array O(log n). Use binary search. Provide virtual steps with arrows and decision. No actual code. So start, initialize left, right. Loop while left < right. mid = (left+right)//2. if nums[mid] > nums[right] -> left = mid+1 else right = mid. End loop. return nums[left]. Provide explanation each line. Use format: \"Start // ...\", \"→ Step: ...\" etc. Must be line by line. Let's produce. Use arrow \"→\" to denote next line, decisions with \"Decision:\" and indent Yes → etc.\n\nNeed to keep steps simple. Use variable names: left, right, mid. Provide explanation after each line.\n\nLet's craft.\n\nAlso we need to mention the algorithm runs in O(log n). Provide step by step.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0, right = n-1 // 設定搜尋區間的左右邊界\n→ Decision: 是否滿足 left < right? // 判斷是否還有未搜尋的元素\n    Yes → Step 2: 計算 mid = (left + right) // 2 // 找出中間索引\n    Yes → Step 3: 如果 nums[mid] > nums[right]? // 判斷中間值是否大於右邊界值\n        Yes → Step 4: 將 left 設為 mid + 1 // 最小值必在右半區，更新左邊界\n        No  → Step 5: 將 right 設為 mid // 最小值在左半區或為 mid，更新右邊界\n    Yes → 回到 Decision: 是否滿足 left < right? // 重新檢查是否結束迴圈\n    No  → Step 6: 輸出 nums[left] // 循環結束，left 指向最小值\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMin(self, nums):\n        left, right = 0, len(nums) - 1\n        # 如果已經是有序陣列，最小值就是第一個元素\n        if nums[left] <= nums[right]:\n            return nums[left]\n        # 二分搜尋：當 mid 大於右邊界時，最小值必在右半區\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]\n\ndef main():\n    data = sys.stdin.read()\n    # 抓取所有整數，假設輸入中只有想要的陣列元素\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        return\n    result = Solution().findMin(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,4,5,1,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [11,13,15,17]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode552.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record II",
    "description_snippet": "An attendance record for a student can be represented as a string where each character signifies whe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate a virtual code solution for counting attendance records of length n satisfying constraints: fewer than 2 A's total, no 3 consecutive L. This is classic DP problem from Leetcode 552. Use DP with states: number of As used (0 or 1) and count of consecutive L at end (0,1,2). Compute dp[i][a][l]. We output number modulo 1e9+7.\n\nWe need to produce step-by-step pseudocode with explanations, each line followed by //.\n\nWe need to output in the specified format: each line: 虛擬碼步驟 + space + // explanation. Use arrows, Start, End, Decision etc.\n\nLet's design:\n\nStart\n→ Initialize mod = 1e9+7\n→ Create 3D array dp[2][2][3] // current and previous to save memory\n→ Set all to 0\n→ dp[0][0][0] = 1 // empty record, 0 A, 0 L\nFor i from 1 to n:\n    → Reset next array to zeros // next[2][3]\n    → For each a in {0,1}:\n        → For each l in {0,1,2}:\n            → Let cur = dp[a][l]\n            → If cur==0 continue\n            → // Add 'P': reset consecutive L, same a\n            → next[a][0] += cur; next[a][0] %= mod\n            → // Add 'L': only if l<2\n            → If l < 2:\n                → next[a][l+1] += cur; next[a][l+1] %= mod\n            → // Add 'A': only if a==0\n            → If a == 0:\n                → next[1][0] += cur; next[1][0] %= mod\n    → dp = next\nEnd of loop\n→ Sum over a in {0,1}, l in {0,1,2} dp[a][l] % mod // result\n→ Return result\n\nWe need to use decision arrow formatting: Decision: if cur==0? but not necessary; just loops.\n\nBetter to use arrow and decision.\n\nWe need to produce each line, but not all loops as single line? We need to produce multiple lines to be readable. Use indentation style with arrows.\n\nAlso we can incorporate decision lines: Decision: if l<2? etc.\n\nLet's craft virtual code:\n\nStart // 程式開始執行\n→ Set MOD = 1e9+7 // 模數\n→ Create 3D array dp[2][3] // 2 As states, 3 consecutive L states, using current row only\n→ Set all dp values to 0\n→ dp[0][0] = 1 // 初始為空序列，0 個 A，0 個連續 L\n→ For i from 1 to n:\n    → Create next[2][3] and set all to 0\n    → For a in {0,1}:\n        → For l in {0,1,2}:\n            → Decision: 如果 dp[a][l] == 0? // 若該狀態無可能，跳過\n                Yes → Continue\n                No  →\n                    // 加 'P'\n                    → next[a][0] = (next[a][0] + dp[a][l]) % MOD\n                    // 加 'L'\n                    → Decision: 如果 l < 2? // 允許連續 L 不超過 2\n                        Yes → next[a][l+1] = (next[a][l+1] + dp[a][l]) % MOD\n                        No  →\n                    // 加 'A'\n                    → Decision: 如果 a == 0? // 只允許一次 A\n                        Yes → next[1][0] = (next[1][0] + dp[a][l]) % MOD\n                        No  →\n    → dp = next // 更新為下一位的 DP\n→ // 計算所有合法結束狀態\n→ Set ans = 0\n→ For a in {0,1}:\n    → For l in {0,1,2}:\n        → ans = (ans + dp[a][l]) % MOD\n→ End // 程式結束\n\nBut need each line separated. Let's produce final output with lines exactly, each line with explanation. Use arrows.\n\nBe careful: indentation not necessary but can use spaces to show hierarchical structure.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Set MOD = 1_000_000_007 // 定義模數\n→ Create 2D array dp[2][3] // dp[a][l] 代表目前為止使用了 a 個 A 且結尾連續 L 為 l\n→ Set all dp values to 0\n→ dp[0][0] = 1 // 空序列，0 個 A，0 個連續 L\n→ For i from 1 to n:\n    → Create 2D array next[2][3] and set all to 0\n    → For a in {0,1}:\n        → For l in {0,1,2}:\n            → Decision: 如果 dp[a][l] == 0? // 若無此狀態，跳過\n                Yes → Continue\n                No  →\n                    // 加入 'P'\n                    → next[a][0] = (next[a][0] + dp[a][l]) % MOD\n                    // 加入 'L'（最多兩連續）\n                    → Decision: 如果 l < 2? // 允許連續 L 不超過 2\n                        Yes → next[a][l+1] = (next[a][l+1] + dp[a][l]) % MOD\n                        No  →\n                    // 加入 'A'（只能一次）\n                    → Decision: 如果 a == 0? // 只允許一次 A\n                        Yes → next[1][0] = (next[1][0] + dp[a][l]) % MOD\n                        No  →\n    → dp = next // 更新 dp 為下一位的 DP\n→ // 合計所有合法結束狀態\n→ Set ans = 0\n→ For a in {0,1}:\n    → For l in {0,1,2}:\n        → ans = (ans + dp[a][l]) % MOD\n→ End // 程式結束\n```",
      "generated_code": "import sys\n\nMOD = 1_000_000_007\n\ndef count_records(n: int) -> int:\n    # dp[a][l] 表示已使用 a 個 A 且結尾連續 L 為 l 的合法序列數量\n    dp = [[0] * 3 for _ in range(2)]\n    dp[0][0] = 1  # 空序列，0 個 A，0 個連續 L\n\n    for _ in range(n):\n        new_dp = [[0] * 3 for _ in range(2)]\n        for a in range(2):\n            for l in range(3):\n                val = dp[a][l]\n                if val == 0:\n                    continue\n                # 加入 'P'：重置連續 L\n                new_dp[a][0] = (new_dp[a][0] + val) % MOD\n                # 加入 'L'：最多兩個連續 L\n                if l < 2:\n                    new_dp[a][l + 1] = (new_dp[a][l + 1] + val) % MOD\n                # 加入 'A'：只能使用一次\n                if a == 0:\n                    new_dp[1][0] = (new_dp[1][0] + val) % MOD\n        dp = new_dp\n\n    # 合計所有合法結束狀態\n    ans = 0\n    for a in range(2):\n        for l in range(3):\n            ans = (ans + dp[a][l]) % MOD\n    return ans\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    print(count_records(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "10101",
          "expected_output": "183236316",
          "success": true,
          "output": "183236316"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode334.json",
    "problem_index_in_file": 0,
    "title": "Increasing Triplet Subsequence",
    "description_snippet": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i <...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for the problem: find increasing triplet subsequence. Provide step-by-step pseudo code, line by line, each line with \"虛擬碼步驟\" and comment. Use arrows and Decision. Should not produce actual code. Should be structured. Each line with comment after a space, using //.\n\nWe must produce step-by-step algorithm, maybe O(n) solution with two variables min1 and min2. Steps: Initialize min1=inf, min2=inf. Iterate num in nums: if num <= min1: min1=num; else if num <= min2: min2=num; else return true; After loop return false.\n\nWe need to produce in Chinese, using Traditional. Also format must include Start, End, Decision lines.\n\nWe need to incorporate Decision: maybe include Decision: \"是否已找到递增三元组？\" But we can just use Decision for each condition.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 min1 = +∞ // 用於存儲最小值\n→ Step 2: 設定 min2 = +∞ // 用於存儲第二小值\n→ Step 3: 對 nums 中每個數值 num 進行遍歷 // 主循環\n    → Decision: 若 num ≤ min1? // 更新 min1\n        Yes → Step 4: 設定 min1 = num // min1 為新的最小值\n        No  → Decision: 若 num ≤ min2? // 更新 min2\n            Yes → Step 5: 設定 min2 = num // min2 為新的第二小值\n            No  → Step 6: 返回 true // 找到 nums[i] < nums[j] < nums[k]\n→ Step 7: 返回 false // 未找到任何遞增三元組\nEnd // 程式執行結束\n\nMake sure each line ends with comment. Use arrow arrow in lines after Start, but indentation maybe? In format example, they used indentation for nested. We'll mimic that.\n\nNeed to ensure the \"Step\" numbering and arrow style consistent. Use \"→\" at start of each step, maybe not nested lines? In example, they had indentation for nested decisions.\n\nWe will produce:\n\nStart // 程式開始執行\n→ Step 1: 設定 min1 = +∞ // 初始化最小值\n→ Step 2: 設定 min2 = +∞ // 初始化第二小值\n→ Step 3: 對 nums 進行遍歷 // 主循環\n    → Decision: 如果 num ≤ min1? // 判斷是否更新 min1\n        Yes → Step 4: 設定 min1 = num // 更新 min1\n        No  → Decision: 如果 num ≤ min2? // 判斷是否更新 min2\n            Yes → Step 5: 設定 min2 = num // 更新 min2\n            No  → Step 6: 返回 true // 找到遞增三元組\n→ Step 7: 返回 false // 未找到遞增三元組\nEnd // 程式執行結束\n\nMake sure comment after space. Use Traditional Chinese. Should be fine.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 min1 = +∞ // 初始化最小值  \n→ Step 2: 設定 min2 = +∞ // 初始化第二小值  \n→ Step 3: 對 nums 進行遍歷 // 主循環  \n  → Decision: 如果 num ≤ min1? // 判斷是否更新 min1  \n   Yes → Step 4: 設定 min1 = num // 更新 min1  \n   No  → Decision: 如果 num ≤ min2? // 判斷是否更新 min2  \n    Yes → Step 5: 設定 min2 = num // 更新 min2  \n    No  → Step 6: 返回 true // 找到遞增三元組  \n→ Step 7: 返回 false // 未找到遞增三元組  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def increasingTriplet(self, nums):\n        first = second = float('inf')\n        for num in nums:\n            if num <= first:\n                first = num\n            elif num <= second:\n                second = num\n            else:\n                return True\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 找到列表字符串\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        print('false')\n        return\n    list_str = data[start:end+1]\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        print('false')\n        return\n    if not isinstance(nums, list):\n        print('false')\n        return\n    solution = Solution()\n    result = solution.increasingTriplet(nums)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [5,4,3,2,1]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [2,1,5,0,4,6]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode390.json",
    "problem_index_in_file": 0,
    "title": "Elimination Game",
    "description_snippet": "You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for this algorithm. Provide step-by-step algorithm description with Start, End, Decision etc. Should not output actual code. Provide per-line comments. The algorithm essentially elimination game problem. We need to produce virtual code.\n\nWe need to produce something like:\n\nStart\n→ Step: Initialize list arr = [1..n]\n→ Step: left = 0, right = n-1, step = 1, direction = left-to-right\n→ Decision: while left < right\n    ...\nBut we need to produce the elimination logic: We can use elimination logic: keep track of leftmost remaining number, rightmost, step size etc. But we should produce virtual steps explaining elimination.\n\nWe can produce pseudocode:\n\nStart // Start\n→ Step 1: 初始化 arr 為 [1, 2, ..., n] // 建立整數列表\n→ Step 2: left = 0, right = n - 1 // 左右指標\n→ Step 3: step = 1 // 步長\n→ Step 4: leftToRight = True // 方向標誌\n→ Decision: while left < right // 只剩一個時停止\n    Yes → Decision: if leftToRight\n        Yes → Step 5: left = left + step // 從左到右去除第一個\n        Yes → Step 6: step = step * 2 // 步長翻倍\n        Yes → Step 7: leftToRight = False // 改為右到左\n    No  → Decision: if not leftToRight\n        Yes → Step 8: right = right - step // 從右到左去除第一個\n        Yes → Step 9: step = step * 2 // 步長翻倍\n        Yes → Step 10: leftToRight = True // 改為左到右\nEnd // 最後剩下的數字為 arr[left] 或 arr[right]\n\nBut we also need to mention final output.\n\nBut requirement: Provide virtual code and explanation line by line. So each line should contain \"虛擬碼步驟\" and explanation. Use arrows like →, Yes →, No →, Decision:.\n\nWe need to ensure every line has \"虛擬碼步驟\" + space + comment.\n\nBetter produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 1, right = n // 左右邊界，代表剩餘數字範圍\n→ Step 2: step = 1 // 步長，代表每隔多少個數刪除一次\n→ Step 3: leftToRight = True // 當前刪除方向\n→ Decision: left < right? // 是否還有多於一個數\n    Yes → Decision: leftToRight? // 方向判斷\n        Yes → Step 4: left = left + step // 從左到右，刪除最左邊的數\n        Yes → Step 5: step = step * 2 // 下一輪步長翻倍\n        Yes → Step 6: leftToRight = False // 方向切換到右到左\n        No  → Step 7: right = right - step // 從右到左，刪除最右邊的數\n        No  → Step 8: step = step * 2 // 下一輪步長翻倍\n        No  → Step 9: leftToRight = True // 方向切換到左到右\nEnd // 最終剩餘數字為 left (或 right) ，回傳該值\n\nBut we need to mention returning last number.\n\nWe can add Step at End: Output left // 回傳最後剩下的數字\n\nBut End should be last line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: left = 1, right = n // 初始數字範圍 [1,n]\n→ Step 2: step = 1 // 每輪刪除間隔\n→ Step 3: leftToRight = True // 初始方向為左到右\n→ Decision: left < right? // 還有多於一個數字\n    Yes → Decision: leftToRight? // 判斷方向\n        Yes → Step 4: left = left + step // 左到右刪除左端數\n        Yes → Step 5: step = step * 2 // 下一輪步長翻倍\n        Yes → Step 6: leftToRight = False // 改為右到左\n        No  → Step 7: right = right - step // 右到左刪除右端數\n        No  → Step 8: step = step * 2 // 下一輪步長翻倍\n        No  → Step 9: leftToRight = True // 改為左到右\nEnd // 只剩一個數，回傳 left（或 right）作為最後結果\n\nBut we might want to note that left==right at the end.\n\nMaybe add Step 10: return left // 最後剩下的數\n\nBut we can embed into End: // 程式結束，最後剩下的數字即為 left\n\nLet's produce final output accordingly.\n\nMake sure each line includes virtual step and comment separated by space. Use \"虛擬碼步驟\" as placeholder. Actually the user expects \"虛擬碼步驟\" but we don't need to literally write that phrase; we just need to produce the step lines with arrows etc.\n\nBut the format is: \"虛擬碼步驟\" + space + \"// 解釋/說明\"\n\nSo we should produce e.g.:\n\nStart // 程式開始執行\n\n→ Step 1: left = 1, right = n // 初始數字範圍 [1,n]\n\nThus each line is: [虛擬碼] // [說明]\n\nHence we produce accordingly.\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: left = 1, right = n // 設定初始左、右邊界為 1 和 n\n→ Step 2: step = 1 // 初始步長為 1，代表每隔 1 個數刪除一次\n→ Step 3: leftToRight = True // 初始刪除方向為左到右\n→ Decision: left < right? // 判斷是否還有多於一個數字\n    Yes → Decision: leftToRight? // 根據方向決定刪除邊\n        Yes → Step 4: left = left + step // 左到右時，移除左端數字\n        Yes → Step 5: step = step * 2 // 下一輪步長翻倍\n        Yes → Step 6: leftToRight = False // 切換方向為右到左\n        No  → Step 7: right = right - step // 右到左時，移除右端數字\n        No  → Step 8: step = step * 2 // 下一輪步長翻倍\n        No  → Step 9: leftToRight = True // 切換方向為左到右\nEnd // 只剩一個數字，最終結果為 left（或 right）\n\nCheck requirement: Each line must have \"虛擬碼步驟\" + space + \"// 解釋/說明\". So we need to include the \"虛擬碼\" itself. We must not include the phrase \"虛擬碼步驟\". Instead, we produce the step line and comment after //.\n\nThus the lines are as above.\n\nBut maybe we need to include the \"Start\" and \"End\" lines. They are \"Start // 程式開始執行\" and \"End // 程式結束\". Good.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: left = 1, right = n // 設定初始左、右邊界為 1 和 n\n→ Step 2: step = 1 // 初始步長為 1，代表每隔 1 個數刪除一次\n→ Step 3: leftToRight = True // 初始刪除方向為左到右\n→ Decision: left < right? // 判斷是否還有多於一個數字\n    Yes → Decision: leftToRight? // 根據方向決定刪除邊\n        Yes → Step 4: left = left + step // 左到右時，移除左端數字\n        Yes → Step 5: step = step * 2 // 下一輪步長翻倍\n        Yes → Step 6: leftToRight = False // 切換方向為右到左\n        No  → Step 7: right = right - step // 右到左時，移除右端數字\n        No  → Step 8: step = step * 2 // 下一輪步長翻倍\n        No  → Step 9: leftToRight = True // 切換方向為左到右\nEnd // 只剩一個數字，最終結果為 left（或 right）",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def lastRemaining(self, n: int) -> int:\n        head = 1          # 目前剩餘序列的左端數字\n        step = 1          # 每輪刪除的間隔\n        remaining = n     # 目前剩餘的數字個數\n        left = True       # 當前刪除方向，True 表示從左到右\n\n        while remaining > 1:\n            # 如果是左到右，或者剩餘個數為奇數，左端數字會被刪除\n            if left or remaining % 2 == 1:\n                head += step\n            remaining //= 2  # 每輪剩餘數量翻半\n            step *= 2         # 下一輪刪除間隔翻倍\n            left = not left   # 方向切換\n        return head\n\ndef main() -> None:\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    solution = Solution()\n    print(solution.lastRemaining(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 9",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode456.json",
    "problem_index_in_file": 0,
    "title": "132 Pattern",
    "description_snippet": "Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j]...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to detect 132 pattern. We should explain each line. Use Start, Decision, etc. The algorithm: iterate from right to left, maintain a stack for potential '3' (nums[j]) candidates, and track 'second' as maximum '2' seen so far. Implementation: for each num from n-1 to 0: if num < second: return true. else while stack not empty and num > stack.top: second = stack.pop. push num to stack. After loop, return false.\n\nWe need to write virtual code lines with explanations. We'll produce steps like:\n\nStart\n→ Step 1: Initialize empty stack // 用來存放潛在的 nums[j]\n→ Step 2: Set second = -∞ // 代表目前已找到的最大 nums[k]\n→ Step 3: 逆序遍歷 nums 從最後一個元素到第一個 // 這樣能保證 i < j < k\n    → Decision: 迴圈結束條件? // 確保索引 >= 0\n        Yes → Step 4: 當前元素 num = nums[i] // 取得當前數字\n        → Decision: num < second? // 檢查是否符合 132\n            Yes → End // 找到 pattern，返回 true\n            No  → Decision: stack 为空? // 用來決定是否 pop\n                Yes → Step 5: push num 到 stack // 無法 pop，直接放進 stack\n                No  → Decision: num > stack.top? // 若 num 大於 stack.top，意味著可以把 stack.top 當作 nums[k]\n                    Yes → Step 6: second = stack.pop() // 把 pop 出來的作為新的 second\n                        → Decision: num > stack.top? // 重複直到不大於 top\n                            Yes → repeat Step 6\n                            No  → Step 7: push num 到 stack\n                    No  → Step 7: push num 到 stack\n    → Go to Step 4 for next i\n→ End // 迴圈結束未找到 pattern，返回 false\n\nBut we need to express each line with virtual code arrow. Must be in plain text. Each line: `虛擬碼步驟 // 解釋`. Must use arrow notation.\n\nLet's produce more linear representation.\n\nBetter structure:\n\nStart // 程式開始\n→ Step 1: 初始化空棧 stack // 用於存放可能的 nums[j]\n→ Step 2: 設定 second = -∞ // 代表目前已知的最大 nums[k]\n→ Step 3: 從 nums 最後一個元素倒序遍歷 i = n-1 到 0 // 保證 i < j < k\n    → Decision: i >= 0? // 迴圈結束判斷\n        Yes → Step 4: num = nums[i] // 取得當前元素\n        → Decision: num < second? // 檢查是否符合 132\n            Yes → End // 找到 132 pattern，返回 true\n            No  → Decision: stack 為空? // 若棧空，無法 pop\n                Yes → Step 5: push num 到 stack // 把 num 加入棧\n                No  → Decision: num > stack.top? // 若 num 大於棧頂\n                    Yes → Step 6: second = stack.pop() // 把棧頂元素作為新的 second\n                        → Decision: num > stack.top? // 仍然大於棧頂，繼續 pop\n                            Yes → repeat Step 6\n                            No  → Step 7: push num 到 stack // 把 num 推進棧\n                    No  → Step 7: push num 到 stack // num 不能 pop，直接入棧\n    → Go to Step 3 for next i\n→ End // 迴圈結束，未發現 132 pattern，返回 false\n\nWe need to produce final output. Let's ensure each line uses arrow and includes explanation. Also use `Start` and `End`.\n\nMake sure to use `Yes →` and `No →` inside Decision blocks.\n\nLet's write final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空棧 stack // 用於存放可能的 nums[j]  \n→ Step 2: 設定 second = -∞ // 代表目前已知的最大 nums[k]  \n→ Step 3: 從 nums 最後一個元素倒序遍歷 i = n-1 到 0 // 保證 i < j < k  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: i >= 0? // 迴圈結束判斷  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: num = nums[i] // 取得當前元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: num < second? // 檢查是否符合 132 模式  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → End // 找到 132 pattern，返回 true  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Decision: stack 為空? // 若棧空，無法 pop  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: push num 到 stack // 把 num 加入棧  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Decision: num > stack.top? // 若 num 大於棧頂  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: second = stack.pop() // 把棧頂元素作為新的 second  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: num > stack.top? // 仍然大於棧頂，繼續 pop  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → repeat Step 6 // 繼續 pop 直到不大於棧頂  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 7: push num 到 stack // 把 num 推進棧  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 7: push num 到 stack // num 不能 pop，直接入棧  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Go to Step 3 for next i  \nEnd // 迴圈結束，未發現 132 pattern，返回 false",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def find132pattern(self, nums):\n        \"\"\"Return True if there exists a 132 pattern in nums, else False.\"\"\"\n        stack = []               # 用於存放潛在的 nums[j]\n        second = float('-inf')   # 最大的 nums[k] 已經找到\n        # 從右往左遍歷，保證 i < j < k\n        for num in reversed(nums):\n            if num < second:  # 如果 num < second，則找到了 132 模式\n                return True\n            # 讓 stack 中的元素都是大於 num 的候選，並更新 second\n            while stack and stack[-1] < num:\n                second = stack.pop()\n            stack.append(num)\n        return False\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析形如 'nums = [1,2,3,4]' 的輸入\n    # 找到最外層的方括號，提取列表字串\n    left_bracket = data.find('[')\n    right_bracket = data.rfind(']')\n    if left_bracket == -1 or right_bracket == -1:\n        # 如果輸入不符合預期，直接退出\n        sys.exit()\n    list_str = data[left_bracket:right_bracket + 1]\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        sys.exit()\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.find132pattern(nums)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,3,2,0]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode6.json",
    "problem_index_in_file": 0,
    "title": "ZigZag Conversion",
    "description_snippet": "Convert a string to a zigzag pattern and read line by line....",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants pseudocode for converting a string to a zigzag pattern and read line by line. Essentially the classic \"ZigZag Conversion\" problem. They want step by step virtual code with explanations per line. Use Start, End, Decision, arrows.\n\nWe need to produce the pseudocode for given input string s and number of rows numRows. Convert to zigzag pattern and read line by line (i.e., produce the output string). We need to produce virtual code lines: Start, then steps.\n\nWe should consider typical algorithm: if numRows==1 return s. Create array of StringBuilder for each row. Use variable currentRow and direction. For each char, append to builder, then change direction when reaching top or bottom. After loop, concatenate builders.\n\nWe'll produce pseudocode accordingly.\n\nLet's format:\n\nStart // Start\n→ Step 1: Check if numRows <= 1 or s length <= numRows // 若只有一行或字符串太短，直接返回\n    Yes → Step 2: Output s // 直接輸出原始字串\n    No  → Step 3: Initialize array rows of size numRows // 創建每行的儲存\n    → Step 4: Set currentRow = 0 // 初始化目前行\n    → Step 5: Set direction = -1 // 初始方向為下行\n→ For each character c in s\n    → Step 6: Append c to rows[currentRow] // 把字符加到對應行\n    → Decision: 如果 currentRow == 0 or currentRow == numRows-1? // 判斷是否到頂或底\n        Yes → Step 7: direction = -direction // 反轉方向\n    → Step 8: currentRow = currentRow + direction // 移動到下一行\n→ Step 9: Initialize result as empty string // 儲存最終結果\n→ For each row in rows\n    → Step 10: Append row to result // 將各行串接\n→ Step 11: Output result // 輸出最終字串\nEnd // 結束\n\nWe need to add explanation per line. Use [空格] after virtual code. Let's ensure each line has one arrow.\n\nWe need to start with \"Start\". For each step, we need \"→ Step X:\" or \"→ Decision:\" etc. Each line with comment after //.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 檢查 numRows ≤ 1 或 s.length ≤ numRows // 若只有一行或字串太短，直接返回原始字串  \n  Yes → Step 2: 輸出 s // 返回原始字串  \n  No  → Step 3: 初始化 rows 為長度 numRows 的空字串陣列 // 為每一行準備儲存空間  \n  → Step 4: 設 currentRow = 0 // 從第一行開始  \n  → Step 5: 設 direction = -1 // 初始方向為向下（-1 代表向下，1 代表向上）  \n→ Decision: 若 numRows > 1? // 確認是否需要進行 zigzag 轉換  \n  Yes → For each character c in s  \n    → Step 6: 把 c 加到 rows[currentRow] // 把字符放到目前行  \n    → Decision: 如果 currentRow == 0 或 currentRow == numRows-1? // 判斷是否到達頂或底  \n     Yes → Step 7: 把 direction 取反 (direction = -direction) // 反轉行走方向  \n    → Step 8: currentRow = currentRow + direction // 移動到下一行  \n  → Step 9: 初始化 result 為空字串 // 用於儲存最終結果  \n  → For each row in rows  \n    → Step 10: 把 row 加到 result // 將每行內容串接起來  \n  → Step 11: 輸出 result // 輸出 zigzag 讀完後的字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \"\"\"把字串轉成 zigzag 模式後按行讀取\"\"\"\n        # 若只有一行或字串長度小於等於行數，直接回傳原字串\n        if numRows == 1 or numRows >= len(s):\n            return s\n        # 用 list 來儲存每一行的字串\n        rows = [''] * numRows\n        index, step = 0, 1  # index: 當前行，step: 移動方向 (+1 下移，-1 上移)\n        for c in s:\n            rows[index] += c  # 把字元加到對應行\n            if index == 0:       # 到頂部\n                step = 1         # 改為往下\n            elif index == numRows - 1:  # 到底部\n                step = -1        # 改為往上\n            index += step        # 移動到下一行\n        return ''.join(rows)   # 把各行串接得到最終結果\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先嘗試從格式化字串中抓取 s 和 numRows\n    match = re.search(r\"s\\s*=\\s*'(?P<s>[^']*)',\\s*numRows\\s*=\\s*(?P<num>\\d+)\", data)\n    if match:\n        s = match.group('s')\n        numRows = int(match.group('num'))\n    else:\n        # 失敗時，假設輸入分為兩行：第一行是字串，第二行是整數\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            s = lines[0].strip()\n            numRows = int(lines[1].strip())\n        else:\n            # 若只有一行，假設以空白分隔\n            parts = data.split()\n            s = parts[0]\n            numRows = int(parts[1]) if len(parts) > 1 else 1\n\n    result = Solution().convert(s, numRows)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'PAYPALISHIRING', numRows = 3",
          "expected_output": "'PAHNAPLSIIGYIR'",
          "success": true,
          "output": "PAHNAPLSIIGYIR"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode140.json",
    "problem_index_in_file": 0,
    "title": "Word Break II",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for word break problem returning all sentences. Provide step-by-step with decisions. Must not produce actual code, just pseudo-code lines with explanations. Use Start, End, Decision, arrow etc. Should be line by line.\n\nWe need to describe algorithm: e.g., DFS with memoization. Steps: Build set from wordDict, define memo map from substring index to list of sentences. Define recursive function backtrack(start). If start==len(s): return list containing empty string. If start in memo: return memo[start]. Else iterate end from start+1 to len(s). If s[start:end] in dict: recursively get sentences from backtrack(end). For each sentence, combine word + (space + sentence if sentence not empty) and add to results. After loop, memo[start]=results; return results. At top-level, call backtrack(0). Return results.\n\nWe need pseudo-code lines, each line: \"虛擬碼步驟 // 解釋\". Use arrow. Use Start, End, Decision. Use Yes →, No →.\n\nWe also need to incorporate building dictionary, maybe convert to set. Steps: Initialize set, memo map, define function, call. Provide explanation.\n\nWe must not output actual code. Just pseudo steps.\n\nOk produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典集合 dict ← Set(wordDict) // 將字典轉為快速查詢的集合  \n→ Step 2: 初始化記憶化表 memo ← {} // 用於存放已計算的子問題結果  \n→ Step 3: 定義遞迴函式 backtrack(start) // 從索引 start 開始切分字符串  \n→ Decision: 如果 start 等於 s.length? // 檢查是否已到達字符串末尾  \n  Yes → Return list containing empty string // 基本情況：返回空句子代表已完成切分  \n  No  → Decision: start 是否已在 memo?  \n    Yes → Return memo[start] // 若已計算，直接回傳結果  \n    No  → Step 4: results ← [] // 初始化本層結果列表  \n→ Step 5: 對 end 在 range(start+1, s.length] 做迴圈 // 嘗試所有可能的切分位置  \n  Decision: s[start:end] 是否在 dict? // 檢查前綴是否為合法字詞  \n    Yes → Step 6: 子句列表 subSentences ← backtrack(end) // 取得後續切分結果  \n     對 sentence 在 subSentences 做迴圈  \n      Decision: sentence 為空?  \n       Yes → newSentence ← s[start:end] // 只剩單一詞，不加空格  \n       No  → newSentence ← s[start:end] + \" \" + sentence // 加空格連接  \n           newSentence 加入 results // 將新句子加入本層結果  \n           End  \n     End  \n     End  \n     Decision: 未加入任何句子? // 若此切分無效，繼續下個 end  \n      No → continue  \n      Yes → 何不? // 這裡不需要動作  \n     End  \n    End  \n  End  \n→ Step 7: memo[start] ← results // 將本層計算結果存入記憶化表  \n→ Step 8: Return results // 回傳此層得到的所有句子  \n→ End // 定義函式結束  \n→ Step 9: sentences ← backtrack(0) // 從字符串起始位置開始切分  \n→ Step 10: Return sentences // 輸出所有可能的句子列表  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        word_set = set(wordDict)\n        memo = {}\n\n        def backtrack(start):\n            if start in memo:\n                return memo[start]\n            if start == len(s):\n                return [\"\"]\n            res = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in word_set:\n                    for sub_sentence in backtrack(end):\n                        if sub_sentence:\n                            res.append(word + \" \" + sub_sentence)\n                        else:\n                            res.append(word)\n            memo[start] = res\n            return res\n\n        return backtrack(0)\n\ndef parse_input(data: str):\n    \"\"\"Parse the input which can be in several common formats.\"\"\"\n    data = data.strip()\n    if not data:\n        return None, None\n\n    # 1. Two lines: s = '...'\\nwordDict = [...]\n    if \"\\n\" in data:\n        lines = data.splitlines()\n        s_line = lines[0].strip()\n        dict_line = lines[1].strip()\n        s = ast.literal_eval(s_line.split(\"=\", 1)[1].strip())\n        wordDict = ast.literal_eval(dict_line.split(\"=\", 1)[1].strip())\n        return s, wordDict\n\n    # 2. Single line: s = '...', wordDict = [...]\n    # Extract with regex\n    s_match = re.search(r\"s\\s*=\\s*(['\\\"])(.*?)\\1\", data)\n    dict_match = re.search(r\"wordDict\\s*=\\s*(\\[.*\\])\", data, re.DOTALL)\n    if s_match and dict_match:\n        s = s_match.group(2)\n        wordDict = ast.literal_eval(dict_match.group(1))\n        return s, wordDict\n\n    # 3. Fallback: assume the whole string is a valid Python expression\n    #    e.g., ['catsanddog', ['cat', 'cats', ...]]\n    try:\n        parsed = ast.literal_eval(data)\n        if isinstance(parsed, list) and len(parsed) == 2:\n            return parsed[0], parsed[1]\n    except Exception:\n        pass\n\n    # If parsing fails, return None\n    return None, None\n\ndef main():\n    raw_data = sys.stdin.read()\n    s, wordDict = parse_input(raw_data)\n    if s is None or wordDict is None:\n        print(\"[]\")\n        return\n    solution = Solution()\n    result = solution.wordBreak(s, wordDict)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']",
          "expected_output": "['cats and dog','cat sand dog']",
          "success": true,
          "output": "['cat sand dog', 'cats and dog']"
        },
        {
          "example_index": 1,
          "input": "s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']",
          "expected_output": "['pine apple pen apple','pineapple pen apple','pine applepen apple']",
          "success": true,
          "output": "['pine apple pen apple', 'pine applepen apple', 'pineapple pen apple']"
        },
        {
          "example_index": 2,
          "input": "s = 'catsandog', wordDict = ['cats','dog','sand','and','cat']",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode396.json",
    "problem_index_in_file": 0,
    "title": "Rotate Function",
    "description_snippet": "You are given an integer array nums of length n.\n\nAssume arrk to be an array obtained by rotating nu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that compute maximum rotation function value. This is LeetCode 2016 \"Maximum Rotation Function\". Approach: Compute sum of nums, compute initial rotation function F(0). Then iteratively update: F(k) = F(k-1) + sum(nums) - n * arr_{k-1}[0], but careful: for clockwise rotation, arr_k[0] = arr_{k-1}[n-1]. Actually standard formula: F(k) = F(k-1) + sum(nums) - n * nums[n - k], but many solutions: For each rotation, update: F_new = F_prev + total - n * last_element_of_previous_arr. We can maintain index of last element as (n - k) % n.\n\nSimpler: Use original array. For k from 1 to n-1: F = F + sum(nums) - n * nums[(n - k) % n]. Keep max.\n\nWe'll produce virtual code lines accordingly.\n\nNeed to output each line with \"虛擬碼步驟 // 解釋\".\n\nLet's craft:\n\nStart\n→ Step 1: 計算陣列長度 n = nums.length // 取得陣列長度\n→ Step 2: 計算 nums 的總和 total = sum(nums) // 方便更新旋轉函數\n→ Step 3: 計算 F(0)：current = 0; for i in 0..n-1: current += i * nums[i] // 初始旋轉函數\n→ Step 4: 初始化 maxVal = current // 目前最大值\n→ Decision: 需要進一步旋轉? // 如果 n>1\n    Yes → Step 5: for k in 1 .. n-1 // 每一次旋轉\n        → Step 6: lastIndex = (n - k) mod n // 先前陣列的最後一個元素索引\n        → Step 7: current = current + total - n * nums[lastIndex] // 更新 F(k)\n        → Step 8: maxVal = max(maxVal, current) // 更新最大值\n        → Step 9: // 迴圈結束\n    No → // n == 1, 不需要旋轉\nEnd // 回傳 maxVal\n\nBut need virtual code format: \"Start //\", \"→ Step ...\", \"→ Decision:\" etc. Each line.\n\nLet's produce.\n\nAlso need to explain each step briefly.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: n ← nums.length // 取得陣列長度 n\n→ Step 2: total ← 0 // 初始化總和\n    → Decision: 遍歷 nums? // 準備累加總和\n        Yes → Step 3: for each value in nums: total ← total + value // 計算 nums 的總和\n        No  → // 無需額外處理\n→ Step 4: current ← 0 // 初始化 F(0)\n    → Decision: 遍歷 nums? // 計算初始旋轉函數\n        Yes → Step 5: for i ← 0 to n-1: current ← current + i * nums[i] // F(0) = Σ i*nums[i]\n        No  → // n 為 0 時不執行\n→ Step 6: maxVal ← current // 設定目前最大值為 F(0)\n→ Decision: 是否還有其他旋轉? // 若 n > 1\n    Yes → Step 7: for k ← 1 to n-1: // 逐個計算 F(k)\n        → Step 8: lastIndex ← (n - k) mod n // 前一陣列最後一元素的索引\n        → Step 9: current ← current + total - n * nums[lastIndex] // 更新 F(k)\n        → Step 10: if current > maxVal then maxVal ← current // 更新最大值\n        → Step 11: // 迴圈結束\n    No  → // n == 1，僅有 F(0)\nEnd // 程式執行結束，回傳 maxVal",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxRotateFunction(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = sum(nums)\n        # F(0) = Σ i * nums[i]\n        current = sum(i * num for i, num in enumerate(nums))\n        max_val = current\n        # iterate k = 1..n-1\n        for k in range(1, n):\n            last_index = (n - k) % n  # last element of previous rotation\n            current = current + total - n * nums[last_index]\n            if current > max_val:\n                max_val = current\n        return max_val\n\ndef parse_input(input_str):\n    input_str = input_str.strip()\n    if not input_str:\n        return []\n    # Extract the part after '=' if present\n    if '=' in input_str:\n        input_str = input_str.split('=', 1)[1].strip()\n    # Use ast.literal_eval to safely parse the list\n    try:\n        nums = ast.literal_eval(input_str)\n        if isinstance(nums, list):\n            return nums\n        else:\n            raise ValueError\n    except Exception:\n        raise ValueError(\"Invalid input format\")\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = parse_input(data)\n    solution = Solution()\n    result = solution.maxRotateFunction(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "success": true,
          "output": "26"
        },
        {
          "example_index": 1,
          "input": "nums = [100]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode307.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Mutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following types:\n\nUpdate the value of an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing the NumArray class with update and sumRange using e.g., segment tree or fenwick. Provide step by step pseudocode. No actual code. Must include arrow \"→\", Decision, Start, End. Provide explanation per line.\n\nWe need to include initialization, building tree, update, query sum. Likely use Fenwick Tree for simplicity. Provide steps.\n\nLet's design: Start, initialize Fenwick tree array bit of size n+1, fill with zeros. Build by adding each nums[i] to BIT via add(i+1, nums[i]).\n\nUpdate: change value, compute delta = val - nums[index], set nums[index] = val, BIT.add(index+1, delta).\n\nSumRange: sum(right) - sum(left-1). sum(i) returns prefix sum via BIT.\n\nProvide steps: Start, Build BIT, etc.\n\nLet's produce lines:\n\nStart // 程式開始執行\n\n→ Step 1: Receive input array nums and its length n // 初始化輸入\n\n→ Step 2: Create array bit[0…n] initialized to 0 // 建立 Fenwick Tree\n\n→ Step 3: Copy nums to internal array data[0…n-1] // 保留原始資料以便計算 delta\n\n→ Step 4: For i from 0 to n-1: Call add(i+1, data[i]) // 建立樹\n\n→ Step 5: Define function add(idx, delta) // 更新 BIT\n\n→   → Step 5a: While idx ≤ n: bit[idx] += delta; idx += idx & -idx\n\n→ Step 6: Define function prefixSum(idx) // 取得前綴和\n\n→   → Step 6a: sum = 0; While idx > 0: sum += bit[idx]; idx -= idx & -idx\n\n→   → Step 6b: Return sum\n\n→ Step 7: Update(index, val) // 更新元素\n\n→   → Step 7a: delta = val - data[index]\n\n→   → Step 7b: data[index] = val\n\n→   → Step 7c: add(index+1, delta)\n\n→ Step 8: SumRange(left, right) // 計算區間和\n\n→   → Step 8a: return prefixSum(right+1) - prefixSum(left)\n\n→ End // 程式結束\n\nNeed to keep formatting with arrows and decisions? Not necessary decisions here.\n\nBut we need to adhere to format: each line \"虛擬碼步驟\" + \" // 解釋/說明\".\n\nAlso use arrow notation for steps. Provide indentation accordingly.\n\nUse \"→\" before each step. Indent substeps with more arrow? maybe use same arrow but nested? Use indentation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Receive input array nums and its length n // 初始化輸入資料  \n→ Step 2: Create array bit[0…n] initialized to 0 // 建立 Fenwick Tree  \n→ Step 3: Copy nums to internal array data[0…n-1] // 保留原始資料以便計算差值  \n→ Step 4: For i from 0 to n-1: Call add(i+1, data[i]) // 建立樹以便後續查詢  \n→ Step 5: Define function add(idx, delta) // 更新 BIT 的內部函式  \n→   → Step 5a: While idx ≤ n: bit[idx] += delta; idx += idx & -idx // 逐步累加至父節點  \n→ Step 6: Define function prefixSum(idx) // 取得前綴和的內部函式  \n→   → Step 6a: sum = 0; While idx > 0: sum += bit[idx]; idx -= idx & -idx // 逐步減至父節點  \n→   → Step 6b: Return sum // 傳回前綴和結果  \n→ Step 7: Update(index, val) // 更新元素值的外部方法  \n→   → Step 7a: delta = val - data[index] // 計算值的變化量  \n→   → Step 7b: data[index] = val // 更新存儲的原始資料  \n→   → Step 7c: add(index+1, delta) // 在 BIT 中加入差值以維持正確和  \n→ Step 8: SumRange(left, right) // 回傳區間和的外部方法  \n→   → Step 8a: Return prefixSum(right+1) - prefixSum(left) // 先後減得區間和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]\n        self.tree = [0] * (self.n + 1)\n        for i in range(self.n):\n            self._add(i + 1, nums[i])\n\n    def _add(self, i, val):\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._add(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._prefix(right + 1) - self._prefix(left)\n\n    def _prefix(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Split into commands and args\n    idx = data.find(']')\n    cmds_str = data[:idx + 1]\n    args_str = data[idx + 2:].strip()\n    commands = ast.literal_eval(cmds_str)\n    args = ast.literal_eval(args_str)\n\n    obj = None\n    results = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"NumArray\":\n            obj = NumArray(arg[0] if isinstance(arg, list) and len(arg) == 1 else arg)\n            results.append(None)\n        elif cmd == \"update\":\n            obj.update(arg[0], arg[1])\n            results.append(None)\n        elif cmd == \"sumRange\":\n            results.append(obj.sumRange(arg[0], arg[1]))\n        else:\n            results.append(None)\n\n    print(results)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,9,null,8]'\nGot (Norm):      '[None,9,None,8]'\n--- (Raw) ---\nRaw Expected: '[null, 9, null, 8]'\nRaw Got:      '[None, 9, None, 8]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode342.json",
    "problem_index_in_file": 0,
    "title": "Power of Four",
    "description_snippet": "Given an integer n, return true if it is a power of four. Otherwise, return false.\n\nAn integer n is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for this requirement. Should produce step-by-step pseudocode that returns true if integer n is a power of four. Use Start, End, Decision, arrow. Each line with explanation. Use the format exactly.\n\nLet's design algorithm: Check if n > 0 and (n & (n-1)) == 0 (power of two) and (n-1) % 3 == 0? Actually for power of four, need n > 0 and only one bit set, and that bit's position is even. So we can use (n & (n-1)) == 0 and (n-1) % 3 == 0? Wait property: powers of 4 are 4^k, bits: 1 << (2k). So (n & (n-1)) == 0 ensures power of 2. Then check that the bit index is even: we can check (n-1) % 3 == 0? Not exactly. For 1, (1-1)%3=0 yes. For 4, (4-1)=3 %3=0 yes. For 16, (16-1)=15 %3=0 yes. So indeed if n is power of 4, then (n-1)%3==0. Good.\n\nAlternatively can do loop dividing by 4 until 1. Simpler.\n\nWe'll produce pseudocode: Input n. Decision: n <= 0? If Yes → return False. Else loop: While n % 4 == 0: n = n/4. End While. Decision: n == 1? If Yes → return True else → False.\n\nBut need to output steps.\n\nLet's write:\n\nStart // 程式開始\n→ Input n // 取得使用者輸入的整數\n→ Decision: n <= 0? // 檢查 n 是否小於等於 0\n    Yes → Return False // 小於等於 0 時不是 4 的冪\n    No  → Step 1: Set temp = n // 將 n 存入臨時變數\n→ Decision: temp % 4 == 0? // 判斷能否被 4 整除\n    Yes → Step 2: temp = temp / 4 // 進行除以 4 的操作\n        → Decision: temp % 4 == 0? // 重複判斷\n            Yes → Repeat Step 2 // 仍能除 4，繼續\n            No  → Decision: temp == 1? // 檢查剩餘是否為 1\n                Yes → Return True // 若是 1，表示 n 為 4 的冪\n                No  → Return False // 否則不是\nEnd // 程式結束\n\nBut we need to use arrows. Let's format correctly. Use indented arrows maybe.\n\nNeed to include \"→ Decision: ...\" etc.\n\nBetter to produce using a loop but pseudocode uses while. Could express as a Decision with loop. But to follow format, we can have a Decision with Yes/No branching, and inside Yes we do another step then loop back. We'll keep it simple.\n\nLet's produce final virtual code.\n\nWe must not output actual code, just virtual pseudocode. Use \"→ Step X:\" etc.\n\nLet's write:\n\nStart // 程式開始\n→ Input n // 取得使用者輸入的整數\n→ Decision: n <= 0? // 檢查 n 是否小於等於 0\n    Yes → Return False // 小於等於 0 時不是 4 的冪\n    No  → Step 1: temp = n // 將 n 存入 temp\n→ Decision: temp % 4 == 0? // 判斷 temp 是否能被 4 整除\n    Yes → Step 2: temp = temp / 4 // 除以 4\n        → Decision: temp % 4 == 0? // 再次判斷\n            Yes → Repeat Step 2 // 仍能除 4，繼續\n            No  → Decision: temp == 1? // 檢查剩餘是否為 1\n                Yes → Return True // 若為 1，則 n 為 4 的冪\n                No  → Return False // 否則不是\nEnd // 程式結束\n\nBut \"Repeat Step 2\" not exactly pseudocode. We can use a loop arrow: \"→ Step 2:\" and back to decision. Use loop concept: maybe \"→ Step 2: temp = temp / 4\" then \"→ Decision: temp % 4 == 0?\" back to Step 2? We can mention loop by using arrow pointing to Step 2 again.\n\nSimplify: Use while loop: \"→ While temp % 4 == 0: temp = temp / 4\" but arrow style? maybe \"→ Decision: temp % 4 == 0?\" then Yes → Step 2: temp = temp / 4 → Decision: temp % 4 == 0? repeating. It's okay.\n\nLet's produce final answer with lines each \"→\". Each line ends with // explanation.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始  \n→ Input n // 取得使用者輸入的整數  \n→ Decision: n <= 0? // 檢查 n 是否小於等於 0  \n    Yes → Return False // 小於等於 0 時不是 4 的冪  \n    No  → Step 1: temp = n // 將 n 存入 temp  \n→ Decision: temp % 4 == 0? // 判斷 temp 是否能被 4 整除  \n    Yes → Step 2: temp = temp / 4 // 除以 4  \n        → Decision: temp % 4 == 0? // 再次判斷是否還能被 4 整除  \n            Yes → Repeat Step 2 // 仍能除 4，繼續除  \n            No  → Decision: temp == 1? // 檢查剩餘是否為 1  \n                Yes → Return True // 若為 1，則 n 為 4 的冪  \n                No  → Return False // 否則不是  \nEnd // 程式結束",
      "generated_code": "import sys, re\n\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        return n > 0 and (n & (n - 1)) == 0 and (n - 1) % 3 == 0\n\ndef main():\n    data = sys.stdin.read()\n    m = re.search(r'-?\\d+', data)\n    if not m:\n        return\n    n = int(m.group())\n    sol = Solution()\n    result = sol.isPowerOfFour(n)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode327.json",
    "problem_index_in_file": 0,
    "title": "Count of Range Sum",
    "description_snippet": "Given an integer array nums and two integers lower and upper, return the number of range sums that l...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for computing number of range sums within [lower, upper]. This is typical problem: count range sum with prefix sums and divide and conquer or BIT with coordinate compression. We produce algorithmic steps.\n\nWe will produce a virtual pseudocode that uses divide and conquer merge sort approach: compute prefix sums, then count pairs i<j with difference in [lower, upper]. Use recursion.\n\nWe need to output line-by-line, each line with virtual code and explanation.\n\nLet's create steps:\n\nStart\n→ Step: compute prefix sums array of size n+1\n→ Step: call recursive function countWhileMergeSort on prefix sums array with left=0 right=n\n→ Step: return result\n\nDefine recursive function:\n→ Decision: if left == right? Actually when subarray size 1, return 0\n\nImplementation: \nIf left < right:\n    mid = (left+right)/2\n    count = countWhileMergeSort(left, mid) + countWhileMergeSort(mid+1, right)\n    count += countCrossPairs(prefix, left, mid, right)\n    merge sorted halves\n    return count\n\nDefine countCrossPairs:\n    For each i from left to mid:\n        while p <= right and prefix[p] - prefix[i] < lower: p++\n        while q <= right and prefix[q] - prefix[i] <= upper: q++\n        count += q - p\n\nNeed to maintain sorted order of prefix sums.\n\nBut we need virtual code lines.\n\nOk produce.\n\nLet's structure as:\n\nStart // 程式開始執行\n→ Step 1: Build prefix sums array sums // 計算前綴和\n→ Step 2: result ← countWhileMergeSort(sums, 0, n) // 進行遞迴分治\n→ Step 3: return result // 輸出最終計數\nEnd // 程式結束\n\nDefine function countWhileMergeSort(arr, left, right):\n→ Decision: 如果 left == right? // 基本情況，子陣列只有一個元素\n    Yes → Step: return 0 // 沒有兩個不同索引可形成區間\n    No → Step: mid ← (left+right)/2 // 分成左右兩半\n→ Step: leftCount ← countWhileMergeSort(arr, left, mid) // 計算左半部\n→ Step: rightCount ← countWhileMergeSort(arr, mid+1, right) // 計算右半部\n→ Step: crossCount ← countCrossPairs(arr, left, mid, right) // 計算跨越左右兩半的區間\n→ Step: merge(arr, left, mid, right) // 合併兩個已排序的子陣列\n→ Step: return leftCount + rightCount + crossCount // 返回總計數\nEnd // 返迴結束\n\nDefine function countCrossPairs(arr, left, mid, right):\n→ Step: i ← left // 左半部指標\n→ Step: p ← mid+1 // 用於 lower 判斷\n→ Step: q ← mid+1 // 用於 upper 判斷\n→ Step: count ← 0\n→ While i ≤ mid:\n    → While p ≤ right and arr[p] - arr[i] < lower:\n        → p ← p + 1\n    → While q ≤ right and arr[q] - arr[i] ≤ upper:\n        → q ← q + 1\n    → count ← count + (q - p) // 所有符合條件的 j\n    → i ← i + 1\n→ Step: return count\n\nDefine function merge(arr, left, mid, right):\n→ Step: temp ← empty list\n→ Step: i ← left; j ← mid+1\n→ While i ≤ mid and j ≤ right:\n    → Decision: 如果 arr[i] ≤ arr[j]?\n        Yes → temp.append(arr[i]); i ← i+1\n        No  → temp.append(arr[j]); j ← j+1\n→ While i ≤ mid: temp.append(arr[i]); i←i+1\n→ While j ≤ right: temp.append(arr[j]); j←j+1\n→ Step: for k in range(left, right+1): arr[k] ← temp[k-left] // copy back\n\nOk.\n\nWe must not output actual code; but we produce virtual code lines with arrows.\n\nWe must include virtual code step and explanation separated by space and //.\n\nUse '→' arrow to indicate flow. Use 'Decision:' etc.\n\nWe should produce as lines. For each step we produce like:\n\nStart // 程式開始執行\n\nLet's craft lines accordingly.\n\nWe also need to consider function definitions: we can represent as \"Function countWhileMergeSort(arr, left, right):\" but it's a virtual code. We need to include arrows inside function.\n\nWe might represent with indentation using spaces.\n\nSimplify: Use lines with '→' for subsequent steps.\n\nOk, produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: sums ← Array of size nums.length + 1 // 建立前綴和陣列  \n→ Step 2: sums[0] ← 0  \n→ Step 3: For i from 1 to nums.length: sums[i] ← sums[i-1] + nums[i-1] // 計算前綴和  \n→ Step 4: result ← countWhileMergeSort(sums, 0, nums.length) // 呼叫遞迴分治計數  \n→ Step 5: return result // 輸出最終區間和的數量  \nEnd // 程式結束  \n\nFunction countWhileMergeSort(arr, left, right)  \n→ Decision: 如果 left == right? // 子陣列只有一個元素  \n  Yes → Step: return 0 // 無法形成區間  \n  No  → Step: mid ← (left + right) / 2 // 計算中點  \n→ Step: leftCount ← countWhileMergeSort(arr, left, mid) // 計算左半部  \n→ Step: rightCount ← countWhileMergeSort(arr, mid+1, right) // 計算右半部  \n→ Step: crossCount ← countCrossPairs(arr, left, mid, right) // 計算跨越左右兩半的區間  \n→ Step: merge(arr, left, mid, right) // 合併兩個已排序的子陣列  \n→ Step: return leftCount + rightCount + crossCount // 回傳總計數  \n\nFunction countCrossPairs(arr, left, mid, right)  \n→ Step: i ← left // 左半部指標  \n→ Step: p ← mid + 1 // 用於 lower 判斷的指標  \n→ Step: q ← mid + 1 // 用於 upper 判斷的指標  \n→ Step: count ← 0  \n→ While i ≤ mid:  \n  While p ≤ right and arr[p] - arr[i] < lower: p ← p + 1 // 找到第一個滿足 lower 的 j  \n  While q ≤ right and arr[q] - arr[i] ≤ upper: q ← q + 1 // 找到最後一個滿足 upper 的 j  \n  Step: count ← count + (q - p) // 累加符合條件的 j 數量  \n  i ← i + 1  \n→ Step: return count  \n\nFunction merge(arr, left, mid, right)  \n→ Step: temp ← Empty list // 暫存合併結果  \n→ Step: i ← left; j ← mid + 1  \n→ While i ≤ mid and j ≤ right:  \n  Decision: 如果 arr[i] ≤ arr[j]?  \n   Yes → temp.append(arr[i]); i ← i + 1  \n   No  → temp.append(arr[j]); j ← j + 1  \n→ While i ≤ mid: temp.append(arr[i]); i ← i + 1  \n→ While j ≤ right: temp.append(arr[j]); j ← j + 1  \n→ Step: For k from left to right: arr[k] ← temp[k - left] // 把合併好的結果複回原陣列  \nEnd // 完成合併與回傳  \nEnd // 函式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countRangeSum(self, nums, lower, upper):\n        # 建立前綴和陣列\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n\n        # 遞迴分治計數\n        def sort_and_count(lo, hi):\n            if hi - lo <= 1:        # 子陣列長度 <= 1 時無法形成區間\n                return 0\n            mid = (lo + hi) // 2\n            count = sort_and_count(lo, mid) + sort_and_count(mid, hi)\n\n            # 計算跨越左右兩半的區間\n            i = j = mid\n            for left in prefix[lo:mid]:\n                while i < hi and prefix[i] - left < lower:\n                    i += 1\n                while j < hi and prefix[j] - left <= upper:\n                    j += 1\n                count += j - i\n\n            # 合併兩個已排序的子陣列\n            prefix[lo:hi] = sorted(prefix[lo:hi])\n            return count\n\n        return sort_and_count(0, len(prefix))\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整內容\n    data = sys.stdin.read().strip()\n\n    # 解析 nums 列表\n    nums = []\n    m_list = re.search(r'\\[([^\\]]*)\\]', data)\n    if m_list:\n        nums_str = m_list.group(1)\n        nums = [int(x) for x in nums_str.split(',') if x.strip()]\n\n    # 解析 lower 與 upper\n    lower = 0\n    upper = 0\n    m_lower = re.search(r'lower\\s*=\\s*(-?\\d+)', data)\n    if m_lower:\n        lower = int(m_lower.group(1))\n    m_upper = re.search(r'upper\\s*=\\s*(-?\\d+)', data)\n    if m_upper:\n        upper = int(m_upper.group(1))\n\n    # 計算並輸出結果\n    sol = Solution()\n    result = sol.countRangeSum(nums, lower, upper)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,5,-1], lower = -2, upper = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0], lower = 0, upper = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode228.json",
    "problem_index_in_file": 0,
    "title": "Summary Ranges",
    "description_snippet": "You are given a sorted unique integer array nums.\n\nA range [a,b] is the set of all integers from a t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code with line-by-line steps to solve the problem: summarizing ranges of sorted unique integers array. Should output ranges as \"a->b\" if a != b else \"a\". Provide step-by-step algorithm.\n\nWe need to use Start, End, Decision, etc. Provide virtual steps like Step 1: initialize result list, Step 2: set start = nums[0], prev = nums[0], loop from index 1 to len-1, etc.\n\nAlso handle case empty array.\n\nWe need to produce in Chinese explanation. Format: each line: virtual code step + space + // explanation.\n\nUse arrow arrows.\n\nOk. Let's craft.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Decision: nums 為空? // 判斷輸入是否為空陣列\n    Yes → Step: 輸出空列表 // 空陣列直接回傳空列表\n    No  → Step: 初始化 start, prev 為 nums[0] // 開始值與前一個值設為第一個元素\n→ For each num in nums[1:]: // 迭代剩餘元素\n    → Decision: num == prev + 1? // 檢查是否為連續\n        Yes → Step: 更新 prev 為 num // 連續，延長當前區間\n        No  → Step: 添加範圍(start, prev) 到結果 // 非連續，將前一區間加入結果\n             → Step: 設定 start, prev 為 num // 開始新的區間\n→ After loop: Step: 添加最後一個範圍(start, prev) 到結果 // 追加最後區間\n→ Step: 轉換結果為字串格式 // 將範圍轉為 \"a->b\" 或 \"a\"\nEnd // 程式執行結束\n\nAlso need a sub-step to convert each range to string: if a==b then str(a) else f\"{a}->{b}\". That could be part of the conversion step.\n\nWe'll keep it simple. Also mention the variable names: start, prev, result.\n\nWe'll include indentation in decisions.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: nums 為空? // 判斷輸入是否為空陣列  \n  Yes → Step: 輸出空列表 // 空陣列直接回傳空列表  \n  No  → Step: 初始化 start, prev 為 nums[0] // 開始值與前一個值設為第一個元素  \n→ For each num in nums[1:]: // 迭代剩餘元素  \n  → Decision: num == prev + 1? // 檢查是否為連續的整數  \n    Yes → Step: 更新 prev 為 num // 連續，延長當前區間  \n    No  → Step: 添加範圍(start, prev) 到結果 // 非連續，將前一區間加入結果  \n       → Step: 設定 start, prev 為 num // 開始新的區間  \n→ After loop: Step: 添加最後一個範圍(start, prev) 到結果 // 追加最後區間  \n→ Step: 轉換結果為字串格式 // 將範圍轉為 \"a->b\" 或 \"a\"  \n  → For each (a, b) in result: // 逐一處理範圍  \n    → Decision: a == b? // 判斷區間是否只有一個數字  \n      Yes → Step: 輸出字串 str(a) // 單一數字顯示為「a」  \n      No  → Step: 輸出字串 f\"{a}->{b}\" // 範圍顯示為「a->b」  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def summaryRanges(self, nums):\n        if not nums:\n            return []\n        res = []\n        start = end = nums[0]\n        for n in nums[1:]:\n            if n == end + 1:\n                end = n\n            else:\n                res.append(f\"{start}->{end}\" if start != end else str(start))\n                start = end = n\n        res.append(f\"{start}->{end}\" if start != end else str(start))\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    sol = Solution()\n    result = sol.summaryRanges(nums)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,2,4,5,7]",
          "expected_output": "[\"0->2\",\"4->5\",\"7\"]",
          "success": true,
          "output": "[\"0->2\", \"4->5\", \"7\"]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,2,3,4,6,8,9]",
          "expected_output": "[\"0\",\"2->4\",\"6\",\"8->9\"]",
          "success": true,
          "output": "[\"0\", \"2->4\", \"6\", \"8->9\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode731.json",
    "problem_index_in_file": 0,
    "title": "My Calendar II",
    "description_snippet": "You are implementing a program to use as your calendar. We can add a new event if adding the event w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MyCalendarTwo class with book method that allows double booking but not triple. This is classic problem: maintain intervals and overlapping. One way: store all bookings; also store overlaps of double bookings. For each new event, check if it overlaps any double booking; if so reject. Else add event; for each existing event, compute intersection; if any intersection exists, add to double bookings. Virtual steps.\n\nWe need to output line by line: virtual code with arrows, decisions, etc.\n\nLet's craft:\n\nStart\n→ Initialize: events list ← [] // store all bookings\n→ Initialize: overlaps list ← [] // store double booking intervals\n→ Method: book(start, end)\n    → Decision: 是否与任何 overlaps 交叉? // check triple\n        Yes → Return false\n        No → Decision: 是否与任何 events 交叉? // double or single\n            Yes → For each event e in events\n                    Compute intersection = [max(start,e.start), min(end,e.end))\n                    If intersection is non-empty → overlaps.add(intersection)\n                End For\n            No → // no intersection, no double booking needed\n    → events.add([start,end]) // add booking\n    → Return true\nEnd\n\nNeed to use appropriate arrow syntax: Start, → Step, Decision. Use indentation.\n\nMake sure each line ends with // 解釋. Provide arrow for decisions: Yes →, No →. For loops maybe indicate: For each. Use Start, End.\n\nLet's format.\n\nEnsure we include \"虛擬碼步驟\" before // explanation.\n\nLet's write:\n\nStart // 程式開始執行\n→ Initialize: events ← [] // 儲存所有已新增的事件\n→ Initialize: overlaps ← [] // 儲存所有已形成的雙重重疊區間\n→ Define Method: book(start, end) // 嘗試加入新事件\n    → Decision: 若 new event 與 overlaps 任何區間重疊? // 檢查是否會產生三重預約\n        Yes → Return false // 會三重預約，拒絕\n        No  → // 仍可嘗試加入\n        → Decision: 若 new event 與 events 任何事件重疊? // 檢查是否會形成雙重預約\n            Yes → // 產生新的雙重區間\n                → For each event e in events // 逐一檢查\n                    → Compute intersection = [max(start, e.start), min(end, e.end))\n                    → Decision: 若 intersection 非空? // 有重疊\n                        Yes → overlaps.add(intersection) // 加入雙重重疊列表\n                        No  → // 無重疊，忽略\n                → End For\n            No  → // 無任何重疊，單重預約\n        → events.add([start, end]) // 把新事件加入主列表\n        → Return true // 成功加入\n→ End Method: book\nEnd // 程式執行結束\n\nWe should use arrow for each line. Indent with spaces.\n\nBut need to be careful to use \"→\" before each statement. Use \"→\" for nested lines. For decisions, we need \"Decision:\".\n\nMake sure each line ends with // 解釋.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize: events ← [] // 儲存所有已新增的事件  \n→ Initialize: overlaps ← [] // 儲存所有已形成的雙重重疊區間  \n→ Define Method: book(start, end) // 嘗試加入新事件  \n    → Decision: 若 new event 與 overlaps 任何區間重疊? // 檢查是否會產生三重預約  \n        Yes → Return false // 會三重預約，拒絕  \n        No  → // 仍可嘗試加入  \n        → Decision: 若 new event 與 events 任何事件重疊? // 檢查是否會形成雙重預約  \n            Yes → // 產生新的雙重區間  \n                → For each event e in events // 逐一檢查  \n                    → Compute intersection = [max(start, e.start), min(end, e.end)) // 求交集區間  \n                    → Decision: 若 intersection 非空? // 有重疊  \n                        Yes → overlaps.add(intersection) // 加入雙重重疊列表  \n                        No  → // 無重疊，忽略  \n                → End For  \n            No  → // 無任何重疊，單重預約  \n        → events.add([start, end]) // 把新事件加入主列表  \n        → Return true // 成功加入  \n→ End Method: book  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport re\n\nclass MyCalendarTwo:\n    def __init__(self):\n        self.booked = []\n        self.overlaps = []\n\n    def book(self, start: int, end: int) -> bool:\n        # Check triple booking\n        for s, e in self.overlaps:\n            if max(s, start) < min(e, end):\n                return False\n        # Record new double bookings\n        for s, e in self.booked:\n            if max(s, start) < min(e, end):\n                self.overlaps.append((max(s, start), min(e, end)))\n        self.booked.append((start, end))\n        return True\n\ndef parse_input(data: str):\n    # Extract two JSON arrays from the input\n    parts = re.split(r'\\]\\s*,\\s*\\[', data.strip(), maxsplit=1)\n    if len(parts) != 2:\n        raise ValueError(\"Invalid input format\")\n    first = parts[0] + ']'\n    second = '[' + parts[1]\n    cmds = json.loads(first)\n    args = json.loads(second)\n    return cmds, args\n\ndef main():\n    raw = sys.stdin.read()\n    if not raw.strip():\n        return\n    commands, arguments = parse_input(raw)\n\n    result = []\n    calendar = None\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"MyCalendarTwo\":\n            calendar = MyCalendarTwo()\n            result.append(None)\n        elif cmd == \"book\":\n            if calendar is None:\n                raise RuntimeError(\"Calendar not initialized\")\n            start, end = arg\n            res = calendar.book(start, end)\n            result.append(res)\n        else:\n            raise ValueError(f\"Unknown command {cmd}\")\n\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, true, true, true, false, true, true]",
          "success": true,
          "output": "[null, true, true, true, false, true, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode560.json",
    "problem_index_in_file": 0,
    "title": "Subarray Sum Equals K",
    "description_snippet": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for the problem: count subarrays with sum equal to k. Standard algorithm: use hashmap of prefix sums. Steps: Start, read input, initialize count=0, prefixSum=0, map with {0:1}. Loop each number: prefixSum += num; if prefixSum-k in map, count += map[prefixSum-k]; map[prefixSum]++ ; End. Output count.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\". Use arrow syntax. Format lines with \"Start\" etc. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化計數器 count = 0, 前綴和 prefixSum = 0, 和表 prefixMap = {0:1} // 設定計數器、前綴和與映射表\n→ Step 2: 針對 nums 中的每個元素 num 進行迴圈 // 遍歷陣列\n    → Step 2.1: prefixSum += num // 更新前綴和\n    → Step 2.2: 若 (prefixSum - k) 存於 prefixMap? // 檢查是否存在符合子陣列和\n        Yes → Step 2.2a: count += prefixMap[prefixSum - k] // 這個前綴和的差值表示有多少個子陣列總和為 k\n        No  → // 無需操作\n    → Step 2.3: prefixMap[prefixSum] = prefixMap.get(prefixSum, 0) + 1 // 更新前綴和在映射表中的計數\nEnd // 程式執行結束\n→ Step 3: 回傳 count // 結果輸出\n\nBut need each line with \"虛擬碼步驟 // 解釋\". For nested steps we indent with arrow. Use \"→\" for sequence. For decision: \"Decision:\".\n\nLet's craft accordingly:\n\nStart // 程式開始執行\n→ Step 1: 設定 count = 0, prefixSum = 0, prefixMap = {0:1} // 初始化計數器、前綴和與映射表\n→ Step 2: 迴圈 for each num in nums // 遍歷陣列\n    → Step 2.1: prefixSum = prefixSum + num // 更新前綴和\n    → Decision: 是否存在 key (prefixSum - k) in prefixMap? // 判斷是否有子陣列和為 k\n        Yes → Step 2.2: count = count + prefixMap[prefixSum - k] // 加入符合條件的子陣列數量\n        No  → // 無操作\n    → Step 2.3: prefixMap[prefixSum] = prefixMap.get(prefixSum, 0) + 1 // 更新前綴和的出現次數\nEnd // 程式執行結束\n→ Step 3: 回傳 count // 回傳總數\n\nMake sure each line separate. Let's provide final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 count = 0, prefixSum = 0, prefixMap = {0:1} // 初始化計數器、前綴和與映射表  \n→ Step 2: 迴圈 for 每個 num 在 nums 中 // 遍歷陣列  \n  → Step 2.1: prefixSum = prefixSum + num // 更新前綴和  \n  → Decision: 是否存在 key (prefixSum - k) in prefixMap? // 判斷是否已出現符合條件的前綴和差  \n   Yes → Step 2.2: count = count + prefixMap[prefixSum - k] // 加入符合條件的子陣列數量  \n   No  → // 無需操作  \n  → Step 2.3: prefixMap[prefixSum] = prefixMap.get(prefixSum, 0) + 1 // 更新前綴和的出現次數  \nEnd // 程式執行結束  \n→ Step 3: 回傳 count // 回傳總數",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def subarraySum(self, nums, k):\n        \"\"\"Return the number of contiguous subarrays whose sum equals k.\"\"\"\n        count = 0\n        prefix_sum = 0\n        # map from prefix sum value to its occurrence count\n        sum_map = defaultdict(int)\n        sum_map[0] = 1\n\n        for num in nums:\n            prefix_sum += num\n            # if there exists a previous prefix sum such that\n            # prefix_sum - prev_prefix = k, we found a valid subarray\n            if (prefix_sum - k) in sum_map:\n                count += sum_map[prefix_sum - k]\n            sum_map[prefix_sum] += 1\n\n        return count\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form:\n        [a,b,c], k = d\n    or with spaces and possible negative numbers.\n    Returns (nums_list, k_value).\n    \"\"\"\n    # Remove all whitespace for easier regex\n    data = re.sub(r'\\s+', '', data)\n    # Find the array part inside brackets\n    array_match = re.search(r'\\[(.*?)\\]', data)\n    if not array_match:\n        raise ValueError(\"Invalid input: array not found\")\n    array_str = array_match.group(1)\n\n    # Extract k value after 'k='\n    k_match = re.search(r'k=(-?\\d+)', data)\n    if not k_match:\n        raise ValueError(\"Invalid input: k not found\")\n    k = int(k_match.group(1))\n\n    # Convert array string to list of integers\n    if array_str.strip() == '':\n        nums = []\n    else:\n        nums = [int(x) for x in array_str.split(',')]\n    return nums, k\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    nums, k = parse_input(raw_input)\n    sol = Solution()\n    result = sol.subarraySum(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,1,1], k = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[1,2,3], k = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode600.json",
    "problem_index_in_file": 0,
    "title": "Non-negative Integers without Consecutive Ones",
    "description_snippet": "Given a positive integer n, return the number of the integers in the range [0, n] whose binary repre...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the algorithm: count numbers <= n without consecutive ones in binary. Classic DP with Fibonacci numbers and bit scanning. The pseudocode: compute bits of n, traverse from MSB to LSB, keep track of previous bit, accumulate count using Fibonacci array. Also handle case if consecutive ones appear. Also include base counts.\n\nWe need to produce line-by-line steps with comments.\n\nWe should produce a start, steps for initialization, bit extraction, loop over bits, decision for consecutive ones, accumulation using Fibonacci. Finally output result. Also include End.\n\nLet's design steps:\n\nStart\n→ Step 1: Convert n to binary array bits // get bits of n\n→ Step 2: Determine length m of bits // number of bits\n→ Step 3: Create fib array of size m+2 // Fibonacci numbers for counts\n    → Substep: fib[0] = 1, fib[1] = 2 // base cases\n    → Loop i from 2 to m+1: fib[i] = fib[i-1] + fib[i-2] // fill fib\n→ Step 4: Initialize count = 0, prevBit = 0 // count result, previous bit flag\n→ Step 5: For i from 0 to m-1 (MSB to LSB):\n    → Decision: If bits[i] == 1? // current bit is 1\n        → count += fib[m - i] // add combinations for remaining bits\n        → Decision: If prevBit == 1? // consecutive ones detected\n            → No  → Return count // stop counting, since n itself invalid\n            → Yes → Set prevBit = 1 // update flag\n        → Else: // bits[i] == 0\n            → Set prevBit = 0 // reset flag\n→ Step 6: After loop, count += 1 // include n itself if valid\n→ End // output count\n\nBut we need to be careful: In decision after adding fib, we need to update prevBit. Actually algorithm: for each bit i:\nif bit[i] == 1:\n  count += fib[m-i]\n  if prevBit == 1: // found consecutive ones\n    return count\n  prevBit = 1\nelse:\n  prevBit = 0\nAt the end, return count+1? Actually typical algorithm adds 1 to include n itself. But our loop includes adding counts for numbers less than n. Then if no consecutive ones in n, we add 1 for n. So we should do count++ after loop. But we must ensure we only add if not returned early. In pseudocode, we can do after loop: count += 1 // include n itself.\n\nAlso need to mention computing bits from MSB: we can generate array bits from highest bit to lowest.\n\nLet's produce step lines accordingly. Each line must have code and comment separated by a space. Use \"→\" etc.\n\nLet's produce each step:\n\nStart\n→ Step 1: bits = binary representation of n as array // get bits of n\n→ Step 2: m = length(bits) // number of bits\n→ Step 3: fib[0] = 1; fib[1] = 2 // base Fibonacci values\n→ Decision: If m >= 2? // prepare fib array length\n    Yes → Loop i from 2 to m:\n        → fib[i] = fib[i-1] + fib[i-2] // fill fib array\n    No → // no loop needed\n→ Step 4: count = 0; prevBit = 0 // init counter and previous bit flag\n→ Step 5: For i from 0 to m-1: // iterate bits from MSB to LSB\n    → Decision: If bits[i] == 1? // current bit is 1\n        Yes → count += fib[m - i] // add possibilities for remaining bits\n            Decision: If prevBit == 1? // consecutive ones detected\n                Yes → End // return count // stop early\n                No  → prevBit = 1 // set flag for next iteration\n        No  → prevBit = 0 // reset flag if current bit 0\n→ Step 6: count += 1 // include n itself if it has no consecutive ones\nEnd // return count\n\nBut need to structure End properly. The algorithm might return earlier. In virtual code we can represent early exit with \"Return count\". Or \"End\" inside decision.\n\nLet's rewrite more clearly.\n\nWe can have \"Return count\" as a line with comment. We'll use \"Return count\" as step. In decision we can say \"Yes → Return count // consecutive ones found, stop\".\n\nAlso final step: \"→ count += 1 // include n\" then \"→ Return count\".\n\nNow produce final output. Ensure each line has \"→\" except Start and End. Use consistent formatting. Provide explanation comments.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: bits = binary representation of n as array // 取得 n 的二進位位元陣列\n→ Step 2: m = length(bits) // 取得位元長度\n→ Step 3: fib[0] = 1; fib[1] = 2 // 初始化 Fibonacci 數列，對應 0、1 位元的合法數量\n→ Decision: 如果 m >= 2? // 若位元長度足以填充 fib 陣列\n    Yes → Loop i from 2 to m:\n        → fib[i] = fib[i-1] + fib[i-2] // 填充 Fibonacci 數列\n    No  → // 無需填充，已在前兩個位置初始化\n→ Step 4: count = 0; prevBit = 0 // 初始化計數器與前一位元標誌\n→ Step 5: For i from 0 to m-1: // 從最高位元往最低位元逐位處理\n    → Decision: 如果 bits[i] == 1? // 當前位元為 1\n        Yes → count += fib[m - i] // 加入剩餘位元可組成的合法數量\n            Decision: 如果 prevBit == 1? // 檢查是否連續兩個 1\n                Yes → Return count // 發現連續 1，直接回傳結果\n                No  → prevBit = 1 // 設置前一位元為 1，繼續迭代\n        No  → prevBit = 0 // 當前位元為 0，重置前一位元標誌\n→ Step 6: count += 1 // 包含 n 本身（已證明不含連續 1）\n→ Return count // 程式執行結束，回傳最終計數結果\nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findIntegers(self, n: int) -> int:\n        # dp[i] 表示長度為 i 的二進制不含連續1的數量\n        dp = [0] * 32\n        dp[0] = 1\n        dp[1] = 2\n        for i in range(2, 32):\n            dp[i] = dp[i-1] + dp[i-2]\n        \n        ans = 0\n        prev_bit = 0\n        for i in range(31, -1, -1):\n            if n & (1 << i):\n                ans += dp[i]\n                if prev_bit:   # 發現連續 1，直接回傳\n                    return ans\n                prev_bit = 1\n            else:\n                prev_bit = 0\n        return ans + 1  # 包含 n 本身（已確認不含連續 1）\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 從輸入中擷取第一個整數\n    match = re.search(r'-?\\d+', data)\n    n = int(match.group()) if match else 0\n    solution = Solution()\n    result = solution.findIntegers(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "n = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode282.json",
    "problem_index_in_file": 0,
    "title": "Expression Add Operators",
    "description_snippet": "Given a string num that contains only digits and an integer target, return all possibilities to inse...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce pseudo-code with step-by-step lines. We must adhere to format. Use Start, End, Decision: arrows. No actual code, just pseudo. Provide each line: \"虛擬碼步驟 // 解釋\". Each step can be \"Step N:\".\n\nWe need algorithm: backtracking generating expressions.\n\nPseudo-code: Start, input num, target, result list, call dfs(index=0, prevNum=0, curVal=0, expr=\"\") etc.\n\nWe need to handle leading zeros: skip segments with leading zeros unless length 1.\n\nUse recursion. We'll produce step lines: \"→ Step 1: Initialize result list\" etc.\n\nWe'll need decisions: e.g., if segment starts with '0' and length>1, skip.\n\nAlso decision for recursion: at each call, for i from idx to len-1: take current part = num[idx:i+1], if len>1 and part[0]=='0' skip. Parse part to numVal. If idx==0: call dfs(i+1, partNum, partNum, part). Else: consider plus, minus, multiply. For plus: dfs(i+1, partNum, curVal+partNum, expr+\"+\"+part). For minus: dfs(i+1, partNum, curVal-partNum, expr+\"-\"+part). For multiply: dfs(i+1, partNum, curVal-prevNum + prevNum*partNum, expr+\"*\"+part). If curVal==target at idx==len, add expr to result.\n\nNeed step lines with arrows and decisions accordingly.\n\nWe should use \"Decision:\" lines for condition checks.\n\nAlso for recursion base case: Decision: If index==len? Then if curVal==target? Add.\n\nAlso need to show recursion call lines.\n\nWe produce each line with \"虛擬碼步驟\" and explanation.\n\nLet's craft.\n\nPseudo-code outline:\n\nStart\n→ Step 1: 定義遞迴函式 DFS(index, prevNum, curVal, expr)\n    → Decision: 如果 index==len(num) ? // 檢查是否已經處理完字串\n        Yes → Decision: 如果 curVal==target? // 是否符合目標值\n            Yes → Step 2: 把 expr 加到結果清單\n            No  → Step 3: 不執行任何操作\n        No  → Step 4: 循環 i 從 index 到 len-1 // 選取子字串\n            → Step 5: 取得子字串 part = num[index:i+1]\n            → Decision: 如果 part 以 '0' 開頭且長度>1? // 檢查領先零\n                Yes → Step 6: 跳過這個子字串\n                No  → Step 7: 轉換 part 為整數 partNum\n                    → Decision: 如果 index==0? // 第一個子字串\n                        Yes → Step 8: 呼叫 DFS(i+1, partNum, partNum, part) // 初始情況\n                        No  → Step 9: 呼叫 DFS(i+1, partNum, curVal+partNum, expr+\"+\"+part) // 加號\n                        → Step 10: 呼叫 DFS(i+1, partNum, curVal-partNum, expr+\"-\"+part) // 減號\n                        → Step 11: 呼叫 DFS(i+1, partNum, curVal-prevNum+prevNum*partNum, expr+\"*\"+part) // 乘號\nEnd\n\nBut we need more detail: Step numbering and decisions properly.\n\nWe should also add Step 1: Initialize result list.\n\nAlso we might need Step 0: Input num, target.\n\nBetter: Start -> Step 0: 接收輸入 num, target, 初始化結果 list。\n\nThen Step 1: 定義遞迴函式 DFS(index, prevNum, curVal, expr)\n\nThen inside define recursion as lines.\n\nWe need arrow representation: \"→\" before each line. Use indentation for decision branches.\n\nWe need to include arrows for decisions: \"Decision:\" lines and then indent for Yes/No branches.\n\nLet's create each line:\n\nStart // 程式開始執行\n→ Step 0: 接收輸入 num、target，並初始化結果 list // 記錄符合目標值的表達式\n\n→ Step 1: 定義遞迴函式 DFS(index, prevNum, curVal, expr) // index: 當前處理位置，prevNum: 上一個操作數，curVal: 目前表達式值，expr: 目前表達式字串\n\n    → Decision: 如果 index == len(num)? // 是否已處理完整字串\n        Yes → Decision: 如果 curVal == target? // 是否等於目標值\n            Yes → Step 2: 把 expr 加入結果清單 // 符合目標，存入答案\n            No  → Step 3: 不做任何操作 // 不符合目標，回溯\n        No  → Step 4: 循環 i 從 index 到 len(num)-1 // 選取不同長度的子字串\n            → Step 5: part = num[index:i+1] // 取得子字串\n            → Decision: 如果 part 以 '0' 開頭且 len(part) > 1? // 檢查領先零\n                Yes → Step 6: 跳過這個子字串 // 跳過非法表達式\n                No  → Step 7: partNum = int(part) // 轉為整數\n                    → Decision: 如果 index == 0? // 第一個子字串\n                        Yes → Step 8: 呼叫 DFS(i+1, partNum, partNum, part) // 初始表達式\n                        No  → Step 9: 呼叫 DFS(i+1, partNum, curVal + partNum, expr + \"+\" + part) // 加號\n                        → Step 10: 呼叫 DFS(i+1, partNum, curVal - partNum, expr + \"-\" + part) // 減號\n                        → Step 11: 呼叫 DFS(i+1, partNum, curVal - prevNum + prevNum * partNum, expr + \"*\" + part) // 乘號\n\n→ End // 程式執行結束\n\nBut we need arrow indentation: for each decision branch we indent. Use \"    Yes →\" etc.\n\nAlso need to include \"Start\" and \"End\". For each line we must show \"虛擬碼步驟 // 解釋\". So we need to provide explanation after //.\n\nAlso we must use \"→\" arrow before each step line. For decisions we need \"Decision:\" and then inside indent with \"Yes →\" and \"No →\".\n\nLet's format accordingly:\n\nStart // 程式開始執行\n→ Step 0: 接收輸入 num、target，並初始化結果清單 // 用來儲存符合目標值的表達式\n→ Step 1: 定義遞迴函式 DFS(index, prevNum, curVal, expr) // index: 當前索引，prevNum: 前一個操作數，curVal: 目前表達式值，expr: 目前表達式字串\n    → Decision: 如果 index == len(num)？ // 判斷是否已經處理完所有字元\n        Yes → Decision: 如果 curVal == target？ // 判斷是否達到目標值\n            Yes → Step 2: 把 expr 加入結果清單 // 符合目標，加入答案\n            No  → Step 3: 不做任何操作 // 不符合目標，直接回溯\n        No  → Step 4: 循環 i 從 index 到 len(num)-1 // 選取不同長度的子字串\n            → Step 5: part = num[index : i+1] // 取得子字串\n            → Decision: 如果 part 以 '0' 開頭且 len(part) > 1？ // 檢查是否有前導零\n                Yes → Step 6: 跳過此子字串 // 無效子字串，跳過\n                No  → Step 7: partNum = int(part) // 轉換為整數\n                    → Decision: 如果 index == 0？ // 第一個子字串的特殊處理\n                        Yes → Step 8: 呼叫 DFS(i+1, partNum, partNum, part) // 初始表達式\n                        No  → Step 9: 呼叫 DFS(i+1, partNum, curVal + partNum, expr + \"+\" + part) // 加號\n                        → Step 10: 呼叫 DFS(i+1, partNum, curVal - partNum, expr + \"-\" + part) // 減號\n                        → Step 11: 呼叫 DFS(i+1, partNum, curVal - prevNum + prevNum * partNum, expr + \"*\" + part) // 乘號\n→ End // 程式執行結束\n\nBut each line must start with \"→\" except \"Start\" and \"End\"? According to format example, Start and End have no arrow? In example, they used \"Start\" without arrow and \"End\". The lines after use arrow \"→\". But we can keep that.\n\nAlso each line must include \"虛擬碼步驟 // 解釋\". So we need to write \"虛擬碼步驟\" part as the line. We'll keep the same format.\n\nNeed to ensure no actual code like parentheses etc. It's fine as pseudo.\n\nBut the explanation part must be short and intuitive. We already have.\n\nWe should ensure we don't use actual code syntax like \"num[index : i+1]\" maybe considered code. But it's still pseudo. It's fine.\n\nHowever might be better to avoid code-like syntax, but it's okay.\n\nWe also need to include \"虛擬碼步驟\" which we already have.\n\nLet's produce final output with lines exactly as required.\n\nEnsure each line includes \"→\" except Start and End.\n\nWe also need indentation for branches with \"    Yes →\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 0: 接收輸入 num、target，並初始化結果清單 // 用來儲存符合目標值的表達式\n→ Step 1: 定義遞迴函式 DFS(index, prevNum, curVal, expr) // index: 當前索引，prevNum: 前一個操作數，curVal: 目前表達式值，expr: 目前表達式字串\n    → Decision: 如果 index == len(num)？ // 判斷是否已經處理完所有字元\n        Yes → Decision: 如果 curVal == target？ // 判斷是否達到目標值\n            Yes → Step 2: 把 expr 加入結果清單 // 符合目標，加入答案\n            No  → Step 3: 不做任何操作 // 不符合目標，直接回溯\n        No  → Step 4: 循環 i 從 index 到 len(num)-1 // 選取不同長度的子字串\n            → Step 5: part = num[index : i+1] // 取得子字串\n            → Decision: 如果 part 以 '0' 開頭且 len(part) > 1？ // 檢查是否有前導零\n                Yes → Step 6: 跳過此子字串 // 無效子字串，跳過\n                No  → Step 7: partNum = int(part) // 轉換為整數\n                    → Decision: 如果 index == 0？ // 第一個子字串的特殊處理\n                        Yes → Step 8: 呼叫 DFS(i+1, partNum, partNum, part) // 初始表達式\n                        No  → Step 9: 呼叫 DFS(i+1, partNum, curVal + partNum, expr + \"+\" + part) // 加號\n                        → Step 10: 呼叫 DFS(i+1, partNum, curVal - partNum, expr + \"-\" + part) // 減號\n                        → Step 11: 呼叫 DFS(i+1, partNum, curVal - prevNum + prevNum * partNum, expr + \"*\" + part) // 乘號\n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp,\n                              value - last + last * curr,\n                              last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    num = None\n    target = None\n\n    # Try to parse \"num = \"123\", target = 6\" style\n    num_match = re.search(r'num\\s*=\\s*[\"\\']([^\"\\']+)[\"\\']', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if num_match:\n        num = num_match.group(1)\n    if target_match:\n        target = int(target_match.group(1))\n\n    # Fallback to separate lines\n    if num is None or target is None:\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            num = lines[0].strip().strip('\"').strip(\"'\")\n            target = int(lines[1].strip())\n\n    solution = Solution()\n    result = solution.addOperators(num, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1+2+3\",\"1*2*3\"]",
          "success": true,
          "output": "['1+2+3', '1*2*3']"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2+3*2\",\"2*3+2\"]",
          "success": true,
          "output": "['2+3*2', '2*3+2']"
        },
        {
          "example_index": 2,
          "input": "num = \"3456237490\", target = 9191",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode167.json",
    "problem_index_in_file": 0,
    "title": "Two Sum II - Input Array Is Sorted",
    "description_snippet": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code in Chinese, step by step, using Start, End, Decision. We need to explain each line. The code is to find two numbers in sorted array that sum to target. Use two-pointer technique: left at 0, right at len-1. While left < right: sum = numbers[left] + numbers[right]; if sum == target return [left+1, right+1]; else if sum < target left++ else right--. Need to mention constant space. Provide virtual steps.\n\nWe output each line with virtual code step and comment after //.\n\nWe'll use format: `Start // ...`. Then `→ Step ...` or `→ Decision: ...`. Indentation for nested decisions maybe using `    Yes →` etc. We need to reflect the loop. We can express loop with Decision: while left < right? Actually we can express as `→ Decision: left < right?` then Yes branch continues with sum calculation etc. But loops may be expressed as repeated decisions. We can express loop as Decision and use `→` back to previous step. But easier: represent loop by Decision with Yes -> continue steps, No -> End. Use a note that loop repeats. That's acceptable.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 left = 0, right = numbers.length - 1 // 左指針設為第一個元素，右指針設為最後一個元素\n→ Decision: left < right? // 判斷是否還有未比較的元素\n    Yes → Step 2: sum = numbers[left] + numbers[right] // 計算左右指針指向數字之和\n    → Decision: sum == target? // 檢查是否找到目標\n        Yes → Step 3: return [left + 1, right + 1] // 回傳 1-indexed 的索引\n        No  → Decision: sum < target? // 若和小於目標，需把左指針往右移\n            Yes → Step 4: left = left + 1 // 左指針右移，尋找更大的數\n            No  → Step 5: right = right - 1 // 右指針左移，尋找更小的數\n    // 從 Step 1 或 2 回到 Decision 的頂端，形成迴圈\n    // （此處省略實際迴圈語法，僅示意流程）\n    // 繼續執行 Decision: left < right?，直到找到解或結束\n→ No → End // 若 left >= right，結束搜尋（理論上不會發生，因為題目保證唯一解）\nEnd // 程式結束\n\nBut the format requires each line to have virtual code step and comment. We need to include `→` before each step. Indentation for nested decisions: we can indent lines under decisions. Use consistent arrow.\n\nLet's produce each line separately:\n\n1. `Start // 程式開始執行`\n2. `→ Step 1: left = 0, right = numbers.length - 1 // 初始化左右指針`\n3. `→ Decision: left < right? // 判斷是否還有未比較的元素`\n4. `    Yes → Step 2: sum = numbers[left] + numbers[right] // 計算兩指針之和`\n5. `    → Decision: sum == target? // 檢查是否符合目標`\n6. `        Yes → Step 3: return [left + 1, right + 1] // 找到解，返回 1-indexed 索引`\n7. `        No  → Decision: sum < target? // 若和小於目標，需要調整左指針`\n8. `            Yes → Step 4: left = left + 1 // 左指針往右移動`\n9. `            No  → Step 5: right = right - 1 // 右指針往左移動`\n10. `    // 從 Step 2 或 4/5 回到 Decision: left < right?，形成迴圈`\n11. `→ No → End // 左右指針相遇，搜尋結束（理論上不會到此，題目保證唯一解）`\n12. `End // 程式結束`\n\nNeed to ensure each line is a single line. The comment part after // should explain. Use `→` before each line. For the `Start` line, no arrow. But the example had `Start //` not preceded by arrow. So we should follow: `Start //`. Then `→` lines. For `End`, same.\n\nLine 10 might not be a step but a comment. But it's okay. It's not necessary to have step arrow. But each line must contain \"虛擬碼步驟\" plus comment. The comment part can be explanatory. The comment is after //. So line 10 is fine: `→ //`? but we don't need arrow. It should have a virtual step; maybe `→ Step 6: loop_back` etc. But we can just skip. To stay consistent, we can keep it as a comment line without arrow: `// 迴圈回到 Decision: left < right?` but the format requires each line must include 虛擬碼步驟. So better not include that line, or we can convert to `→ Loop: left < right?` but we already had the decision at line 3. So we can omit line 10. The arrow lines are enough.\n\nLet's restructure:\n\nStart // 程式開始執行\n→ Step 1: left = 0, right = numbers.length - 1 // 初始化左右指針\n→ Decision: left < right? // 判斷是否還有未比較的元素\n    Yes → Step 2: sum = numbers[left] + numbers[right] // 計算兩指針之和\n    → Decision: sum == target? // 檢查是否符合目標\n        Yes → Step 3: return [left + 1, right + 1] // 找到解，返回 1-indexed 索引\n        No  → Decision: sum < target? // 若和小於目標，需要調整左指針\n            Yes → Step 4: left = left + 1 // 左指針往右移動\n            No  → Step 5: right = right - 1 // 右指針往左移動\n→ No → End // 左右指針相遇，搜尋結束（理論上不會到此，題目保證唯一解）\nEnd // 程式結束\n\nBut we need a line for \"loop back\" to Decision. But in flowcharts, after step 4/5, we go back to Decision: left < right? That is implied by the structure: after decisions, control goes back to top. We can just rely on that. The format may be accepted.\n\nMake sure each line has arrow except Start and End. Indentation for nested decisions: we should indent the lines inside the Decision. In the example, they indented with spaces.\n\nThus final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: left = 0, right = numbers.length - 1 // 初始化左右指針\n→ Decision: left < right? // 判斷是否還有未比較的元素\n    Yes → Step 2: sum = numbers[left] + numbers[right] // 計算兩指針之和\n    → Decision: sum == target? // 檢查是否符合目標\n        Yes → Step 3: return [left + 1, right + 1] // 找到解，返回 1-indexed 索引\n        No  → Decision: sum < target? // 若和小於目標，需要調整左指針\n            Yes → Step 4: left = left + 1 // 左指針往右移動\n            No  → Step 5: right = right - 1 // 右指針往左移動\n→ No → End // 左右指針相遇，搜尋結束（理論上不會到此，題目保證唯一解）\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def twoSum(self, numbers, target):\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            s = numbers[left] + numbers[right]\n            if s == target:\n                return [left + 1, right + 1]\n            elif s < target:\n                left += 1\n            else:\n                right -= 1\n\ndef parse_input():\n    content = sys.stdin.read().strip()\n    if not content:\n        return [], 0\n\n    # Try to find the list of numbers\n    numbers_match = re.search(r'numbers\\s*=\\s*(\\[[^\\]]*\\])', content)\n    if numbers_match:\n        numbers_str = numbers_match.group(1)\n    else:\n        # If the input is just a list without \"numbers =\"\n        if content.startswith('['):\n            numbers_str = content.split(', target')[0].strip()\n        else:\n            # Assume first line is the list\n            numbers_str = content.splitlines()[0].strip()\n    numbers = eval(numbers_str)\n\n    # Find the target value\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', content)\n    if target_match:\n        target = int(target_match.group(1))\n    else:\n        # If not found, try to extract the first integer from the remaining content\n        nums_after = content.split(']')[-1]\n        target = int(re.search(r'-?\\d+', nums_after).group())\n\n    return numbers, target\n\nif __name__ == \"__main__\":\n    numbers, target = parse_input()\n    solution = Solution()\n    result = solution.twoSum(numbers, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numbers = [2,7,11,15], target = 9",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "numbers = [2,3,4], target = 6",
          "expected_output": "[1,3]",
          "success": true,
          "output": "[1, 3]"
        },
        {
          "example_index": 2,
          "input": "numbers = [-1,0], target = -1",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode682.json",
    "problem_index_in_file": 0,
    "title": "Baseball Game",
    "description_snippet": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with comments in Chinese. The problem is standard LeetCode 682. Approach: use stack. Iterate operations. For each:\n\n- if integer: push value.\n- if '+': pop last two? Actually need to sum top two. Approach: peek top1, top2, sum, push sum.\n- 'D': double last, push.\n- 'C': pop last.\n\nAt end sum stack.\n\nWe must produce virtual code step by step with arrows and decisions.\n\nUse Start, End. For each op, Decision: check if op == '+' etc.\n\nWe'll produce steps: Start, → Step: initialize stack, total sum, loop over ops, Decision based on op. For integer: push.\n\nImplementation details: When '+' need to get top two; but stack operations: top1 = stack.peek(); top2 = stack.get(stack.size-2). Compute sum. push sum.\n\nWe'll write pseudo steps accordingly.\n\nAlso sum final: compute sum of stack or accumulate while pushing.\n\nSimpler: maintain stack and sum variable updated. When push new score, add to sum. When pop, subtract from sum.\n\nThus we can avoid sum loop.\n\nPseudo: Start\n→ Step 1: 初始化空 stack ← []\n→ Step 2: 初始化總分 sum ← 0\n→ Step 3: 循環每個操作 op in operations\n    → Decision: 如果 op == 'C' ?\n        Yes → Step: pop last score, subtract from sum\n        No → Decision: 如果 op == 'D' ?\n            Yes → Step: 取上一次 score = stack.last, newScore = 2 * last, push, sum += newScore\n            No → Decision: 如果 op == '+' ?\n                Yes → Step: 取 top1 = stack.last, top2 = stack[stack.size-2], newScore = top1 + top2, push, sum += newScore\n                No → Step: 解析 op 為 整數 val，push, sum += val\nEnd\n→ Step: 返回 sum\n\nLet's output each line with arrow and comment.\n\nWe need to include \"Start\", \"End\". Each line with \"虛擬碼步驟\" plus comment.\n\nUse arrow lines.\n\nLet's produce.\n\nMake sure to use \"→\" for steps.\n\nMake decisions with \"Decision:\".\n\nWill include brackets for indentation? In example, indentation used.\n\nWe can just use indentation with spaces.\n\nWill produce like:\n\nStart // 程式開始執行\n→ Step 1: stack ← [] // 初始化空記錄\n→ Step 2: sum ← 0 // 初始化總分\n→ Step 3: for each op in operations // 逐個處理操作\n    → Decision: op == 'C'? // 檢查是否為撤銷操作\n        Yes → Step: removed ← stack.pop(); sum ← sum - removed // 刪除最近一次得分並更新總分\n        No → Decision: op == 'D'? // 檢查是否為翻倍操作\n            Yes → Step: last ← stack.last(); newScore ← 2 * last; stack.push(newScore); sum ← sum + newScore // 取上一次得分翻倍\n            No → Decision: op == '+'? // 檢查是否為累加操作\n                Yes → Step: last1 ← stack.last(); last2 ← stack[stack.size-2]; newScore ← last1 + last2; stack.push(newScore); sum ← sum + newScore // 取前兩次得分相加\n                No → Step: value ← parseInt(op); stack.push(value); sum ← sum + value // 解析整數並加入\nEnd // 程式結束\n→ Step 4: return sum // 回傳最終總分\n\nNeed to ensure each line has \"虛擬碼步驟\" (like Step 1 etc.) The example used \"Step 1:\" but not required to include Step number? But we should follow pattern: \"Step 1:\" etc.\n\nWe should keep \"虛擬碼步驟\" preceding each line.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: stack ← [] // 初始化空的得分記錄  \n→ Step 2: sum ← 0 // 初始化總分為 0  \n→ Step 3: for each op in operations // 逐個處理每個操作  \n  → Decision: op == 'C'? // 檢查是否為撤銷操作  \n   Yes → Step 4: removed ← stack.pop(); sum ← sum - removed // 刪除最近一次得分並更新總分  \n   No → Decision: op == 'D'? // 檢查是否為翻倍操作  \n    Yes → Step 5: last ← stack.last(); newScore ← 2 * last; stack.push(newScore); sum ← sum + newScore // 取上一次得分翻倍並加入記錄  \n    No → Decision: op == '+'? // 檢查是否為累加操作  \n     Yes → Step 6: last1 ← stack.last(); last2 ← stack[stack.size-2]; newScore ← last1 + last2; stack.push(newScore); sum ← sum + newScore // 取前兩次得分相加並加入記錄  \n     No → Step 7: value ← parseInt(op); stack.push(value); sum ← sum + value // 解析整數並加入記錄  \nEnd // 程式結束  \n→ Step 8: return sum // 回傳最終總分",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def calPoints(self, ops):\n        stack = []\n        for op in ops:\n            if op == \"C\":\n                stack.pop()\n            elif op == \"D\":\n                stack.append(2 * stack[-1])\n            elif op == \"+\":\n                stack.append(stack[-1] + stack[-2])\n            else:\n                stack.append(int(op))\n        return sum(stack)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        ops = []\n    else:\n        # 可能有前綴 \"ops = \"\n        if \"=\" in raw_input:\n            _, expr = raw_input.split(\"=\", 1)\n            expr = expr.strip()\n        else:\n            expr = raw_input\n        # 解析為 Python list\n        try:\n            ops = ast.literal_eval(expr)\n        except Exception:\n            # 若解析失敗，直接使用空列表\n            ops = []\n\n    result = Solution().calPoints(ops)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]",
          "expected_output": "30",
          "success": true,
          "output": "30"
        },
        {
          "example_index": 1,
          "input": "ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]",
          "expected_output": "27",
          "success": true,
          "output": "27"
        },
        {
          "example_index": 2,
          "input": "ops = [\"1\",\"C\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode981.json",
    "problem_index_in_file": 0,
    "title": "Time Based Key-Value Store",
    "description_snippet": "Design a time-based key-value data structure that can store multiple values for the same key at diff...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Must not output actual code, just virtual steps. We need to design a time-based key-value data structure: TimeMap with set and get. Virtual code steps, line by line, using arrows, decision structure, Start, End, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" for steps, \"Yes →\" and \"No →\" for decisions.\n\nWe need to design algorithm: For each key, maintain a list of (timestamp, value) sorted by timestamp. For get, binary search for largest timestamp <= query. For set, insert maintaining order. Could use insertion at end because timestamp increasing? Not specified, but typical LeetCode problem uses increasing timestamps but can be arbitrary. We'll just insert and keep sorted by timestamp.\n\nVirtual code: Start, Initialize data structure: map key->list of pairs.\n\nSet operation: get list, append pair, maybe keep sorted.\n\nGet operation: retrieve list, binary search.\n\nWe'll produce steps with pseudo operations: \"Initialize map\", \"Set key/value/timestamp\", \"Insert pair\", \"Get key/timestamp\", \"If list exists\", \"Binary search\", etc.\n\nWe need to output each line with virtual code step followed by explanation. Use \"→\" arrow before each step. Indentation for decisions.\n\nAlso maybe include \"End\" after each method? Probably not; just at the end of algorithm. Let's produce a high-level design:\n\nStart\n→ Initialize data structure: map<string, list<timestamp,value>> // create empty map\n\n→ Method: set(key,value,timestamp)\n    → Retrieve list for key from map // get existing list\n    → If list exists\n        → Append (timestamp, value) to list // maintain order\n    → Else\n        → Create new list with (timestamp,value)\n        → Insert into map // add entry\n\n→ Method: get(key,timestamp)\n    → Retrieve list for key from map\n    → If list is null or empty\n        → Return \"\" // no data\n    → Binary search in list for largest timestamp <= query\n        → If found\n            → Return corresponding value\n        → Else\n            → Return \"\" // no timestamp <= query\n\nEnd\n\nBut we need to use the structure: Decision: ... Yes → ... No → ... with indent.\n\nLet's craft properly. Also need to indicate \"Method\" maybe with Step header. Use \"Step 1:\" etc. But requirement is \"虛擬碼步驟 // 解釋\". Use arrow and colon.\n\nLet's produce each step: Example:\n\nStart // 程式開始執行\n→ Initialize map<string, list<pair<int,string>>> dataStore // 建立空的 key-時間值儲存結構\n→ Method set(key, value, timestamp) // 進入 set 操作\n    → Retrieve list = dataStore[key] // 取得該 key 對應的時間序列\n    → Decision: list 存在? // 檢查是否已有此 key\n        Yes → Append (timestamp, value) to list // 已有，直接加入\n        No  → Create new list = [(timestamp, value)] // 無，建立新列表\n             → Insert list into dataStore[key] // 將新列表存回 map\n→ Method get(key, timestamp) // 進入 get 操作\n    → Retrieve list = dataStore[key] // 取得該 key 對應的時間序列\n    → Decision: list 為空? // 若無資料\n        Yes → Return \"\" // 回傳空字串\n        No  → Binary search list for largest t <= timestamp // 在序列中搜尋最近的時間\n              → Decision: 找到? // 是否有符合條件的時間戳\n                Yes → Return value at found index // 回傳對應值\n                No  → Return \"\" // 若沒有任何時間戳 <= timestamp，回傳空字串\nEnd // 程式執行結束\n\nBut need to format each line with arrow. Use indentation for decision branches. Ensure each line ends with // 解釋.\n\nAlso we should not output actual code like 'list = dataStore[key]'; but still pseudo.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize dataStore // 建立一個空的 map，key 為字串，值為時間戳與對應值的序列  \n\n→ Method set(key, value, timestamp) // 進入 set 操作  \n    → Retrieve list ← dataStore[key] // 取得此 key 目前的時間序列（若不存在則為 null）  \n    → Decision: list 存在? // 判斷是否已有此 key  \n        Yes → Append (timestamp, value) to list // 已有，直接把新的時間戳和值加入序列  \n        No  → Create newList ← [(timestamp, value)] // 無此 key，建立新的序列  \n             → Insert newList into dataStore[key] // 把新序列放回 map  \n\n→ Method get(key, timestamp) // 進入 get 操作  \n    → Retrieve list ← dataStore[key] // 取得此 key 的時間序列  \n    → Decision: list 為空? // 若此 key 沒有任何資料  \n        Yes → Return \"\" // 回傳空字串，表示沒有對應值  \n        No  → BinarySearch(list, timestamp) // 在序列中尋找最接近且不超過的時間戳  \n              → Decision: 找到符合條件? // 是否有時間戳 <= timestamp  \n                Yes → Return value at found index // 回傳對應的值  \n                No  → Return \"\" // 若沒有符合條件，回傳空字串  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\nimport bisect\n\nclass TimeMap:\n    def __init__(self):\n        self.store = defaultdict(list)\n\n    def set(self, key, value, timestamp):\n        self.store[key].append((timestamp, value))\n\n    def get(self, key, timestamp):\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        i = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if i == 0:\n            return \"\"\n        return arr[i - 1][1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # split the two lists: operations and arguments\n    idx = data.find(']')\n    ops_str = data[:idx + 1]\n    args_str = data[idx + 2:].strip()\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    tm = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == \"TimeMap\":\n            tm = TimeMap()\n            outputs.append(None)\n        elif op == \"set\":\n            tm.set(*arg)\n            outputs.append(None)\n        elif op == \"get\":\n            outputs.append(tm.get(*arg))\n\n    print(json.dumps(outputs))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "success": true,
          "output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode31.json",
    "problem_index_in_file": 0,
    "title": "Next Permutation",
    "description_snippet": "A permutation of an array of integers is an arrangement of its members into a sequence or linear ord...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with explanations. The algorithm for next permutation: find largest index i such that nums[i] < nums[i+1]; if none, reverse whole array; else find largest index j > i with nums[j] > nums[i]; swap nums[i], nums[j]; reverse subarray from i+1 to end. Provide step by step.\n\nUse virtual code syntax: Start, → Step 1: description, → Decision, Yes → ... etc.\n\nWe must output each line with comment after space. Use virtual arrow arrows. Provide explanation after //.\n\nLet's produce.\n\nNeed to include Start and End. For each step, mention array indices.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 i = len(nums) - 2 // 從倒數第二個元素開始向前掃描\n→ Decision: 如果 i >= 0 且 nums[i] < nums[i+1]? // 找到第一個升序對\n    Yes → Step 2: 找出 j = len(nums) - 1 // 從末尾開始尋找第一個大於 nums[i] 的元素\n    → Decision: 如果 nums[j] <= nums[i]? // 如果當前 j 不是大於 nums[i] 的元素\n        Yes → Step 3: j = j - 1 // 向前移動 j\n        No  → Continue // j 已找到\n    No  → Step 2 // 若 i < 0，直接進行逆序\n    No  → Step 4: 交換 nums[i] 與 nums[j] // 交換得到更大的排列\n    No  → Step 5: 逆序 nums[i+1 … end] // 將後半部分變為最小排列\n→ Decision: 如果 i < 0? // 原排列已是最高序\n    Yes → Step 6: 逆序 nums[0 … end] // 重新排為最小序\n    No  → Continue // 已處理完畢\nEnd // 程式執行結束\n\nBut need to keep lines minimal. Also may include loops. Use arrow arrows for each decision branch.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← len(nums) - 2 // 從倒數第二個位置開始向前掃描  \n→ Decision: i ≥ 0 且 nums[i] < nums[i+1] ? // 找到第一個升序對  \n Yes → Step 2: j ← len(nums) - 1 // 從尾端開始尋找大於 nums[i] 的元素  \n → Decision: nums[j] ≤ nums[i] ? // 確認 j 是否已滿足條件  \n  Yes → Step 3: j ← j - 1 // 向前移動 j，直到找到 nums[j] > nums[i]  \n  No  → Continue // j 已找到，直接往下  \n No  → Step 4: 逆序 nums[0 … end] // 整個陣列已降冪，重新排為升冪  \n  → End // 程式結束  \n→ Step 5: 交換 nums[i] 與 nums[j] // 交換得到更大的排列  \n→ Step 6: 逆序 nums[i+1 … end] // 後半部份重新排為最小順序  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef next_permutation(nums):\n    n = len(nums)\n    i = n - 2\n    # 找出第一個升序對\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = n - 1\n        # 找到第一個大於 nums[i] 的元素\n        while nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n    # 將後半部分反轉成升序\n    left, right = i + 1, n - 1\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 解析輸入，預期格式為 \"nums = [1,2,3]\"\n    try:\n        _, list_part = data.split('=', 1)\n    except ValueError:\n        list_part = data\n    nums = ast.literal_eval(list_part.strip())\n    next_permutation(nums)\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,3,2]",
          "success": true,
          "output": "[1, 3, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1]",
          "expected_output": "[1,2,3]",
          "success": true,
          "output": "[1, 2, 3]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,5]",
          "expected_output": "[1,5,1]",
          "success": true,
          "output": "[1, 5, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode678.json",
    "problem_index_in_file": 0,
    "title": "Valid Parenthesis String",
    "description_snippet": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is va...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Problem: Valid Parenthesis String with wildcards '*'. Typical solution uses two counters for min and max open parentheses. We need to produce virtual code lines for algorithm.\n\nLet's outline:\n\nStart\n→ Step 1: initialize minOpen = 0, maxOpen = 0\n→ For each character c in s:\n    → Decision: if c == '('\n        → minOpen++ // treat '(' as open\n        → maxOpen++ // treat '(' as open\n        No  → Decision: if c == ')'\n            → Decision: if minOpen > 0\n                → minOpen-- // consume an open for this ')'\n                No → minOpen = 0 // if none, set 0\n            → maxOpen-- // consume open, might become negative\n            No  → Decision: if c == '*'\n                → Decision: if minOpen > 0\n                    → minOpen-- // treat '*' as ')'\n                    No → minOpen = 0\n                → maxOpen++ // treat '*' as '('\n        // else not needed\n    // after loop: Decision: if maxOpen < 0\n        → End with false\n        No → Decision: if minOpen == 0\n            → End with true\n            No → End with false\n\nBut need to structure in virtual code. Use \"Decision:\" and \"Yes →\" \"No →\".\n\nLet's produce lines accordingly.\n\nWe need to be careful to keep one line per step with explanation. Use \"Start // ...\" and \"End // ...\".\n\nAlso we need to manage loops: \"→ For each character c in s: // iterate over characters\".\n\nWe can use nested decisions.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 初始化 minOpen = 0, maxOpen = 0 // 用於追蹤最小和最大可能的左括號數量\n→ For each character c in s: // 逐個處理字串\n    → Decision: c == '('? // 判斷是否為 '('\n        Yes → Step 2: minOpen++ // 把 '(' 視為一個左括號，最小開口數增加\n        Yes → Step 3: maxOpen++ // 同時最大開口數也增加\n        No  → Decision: c == ')'?\n            Yes → Decision: minOpen > 0?\n                Yes → Step 4: minOpen-- // 用一個左括號配對此 ')'\n                No  → Step 5: minOpen = 0 // 無左括號可配，保持 0\n            Yes → Step 6: maxOpen-- // 盡可能減少最大開口數\n            No  → Decision: c == '*'\n                Yes → Decision: minOpen > 0?\n                    Yes → Step 7: minOpen-- // 以 ')' 處理 '*'\n                    No  → Step 8: minOpen = 0 // 無左括號可配\n                Yes → Step 9: maxOpen++ // 以 '(' 處理 '*'\n    // Loop ends\n→ Decision: maxOpen < 0?\n    Yes → End // 有負數表示不可能有足夠左括號，返回 false\n    No  → Decision: minOpen == 0?\n        Yes → End // 最小開口數為 0，表示可以配對完畢，返回 true\n        No  → End // 仍有未配對的左括號，返回 false\n\nBut we need to end with true/false. Provide comments. But the End line must show result. We can just put End // 程式結束 (true/false). But need to indicate result. Could use \"End // 返回 true\" etc. We'll use separate End lines per outcome. But structure expects one End. We can use decisions earlier to output true/false. Could incorporate \"Step X: return true/false\". Let's incorporate.\n\nAfter loop, we can decide:\n\n→ Decision: maxOpen < 0?\n    Yes → Step 10: return false // 不可能匹配\n    No  → Decision: minOpen == 0?\n        Yes → Step 11: return true // 成功匹配\n        No  → Step 12: return false // 仍有未匹配左括號\n\nThen End.\n\nLet's produce that.\n\nAlso add \"Start\" and \"End\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 minOpen = 0, maxOpen = 0 // 用於追蹤最小與最大可能的左括號數量  \n→ For each character c in s: // 逐個遍歷字串  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: c == '('? // 判斷是否為左括號  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2: minOpen++ // 將 '(' 視為一個左括號，最小開口數加 1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: maxOpen++ // 同時最大開口數也加 1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Decision: c == ')'? // 判斷是否為右括號  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Decision: minOpen > 0? // 有可配對的左括號？  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: minOpen-- // 用一個左括號配對此 ')'  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 5: minOpen = 0 // 沒有左括號可配，保持最小開口數為 0  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: maxOpen-- // 最大開口數減 1（假設 ')' 需要配對）  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Decision: c == '*'? // 判斷是否為 '*'  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Decision: minOpen > 0? // 以 ')' 處理 '*', 有左括號可配？  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 7: minOpen-- // 用一個左括號配對 '*' 作為 ')'  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 8: minOpen = 0 // 沒有左括號可配，保持 0  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 9: maxOpen++ // 以 '(' 處理 '*', 最大開口數加 1  \n&nbsp;&nbsp;&nbsp;&nbsp; // 每個字符處理完畢  \n→ Decision: maxOpen < 0? // 有負數表示左括號不足，無法匹配  \n&nbsp;&nbsp;Yes → Step 10: return false // 返回假，字串無效  \n&nbsp;&nbsp;No  → Decision: minOpen == 0? // 最小開口數為 0 表示所有左括號都已被配對  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 11: return true // 返回真，字串有效  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 12: return false // 仍有未配對左括號，返回假  \nEnd // 程式執行結束 (已返回結果)",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def checkValidString(self, s: str) -> bool:\n        low = 0\n        high = 0\n        for c in s:\n            if c == '(':\n                low += 1\n                high += 1\n            elif c == ')':\n                if low > 0:\n                    low -= 1\n                high -= 1\n            else:  # '*'\n                if low > 0:\n                    low -= 1\n                high += 1\n            if high < 0:\n                return False\n        return low == 0\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n    # 尋找字串中的引號內容\n    m = re.search(r'[\"\\'](.*?)[\"\\']', data)\n    if m:\n        s = m.group(1)\n    else:\n        # 直接使用等號後的內容或整個輸入\n        if '=' in data:\n            s = data.split('=', 1)[1].strip()\n        else:\n            s = data\n    sol = Solution()\n    result = sol.checkValidString(s)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"(*)\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"(*))\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode70.json",
    "problem_index_in_file": 0,
    "title": "Climbing Stairs",
    "description_snippet": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user: \"You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\" This is classic climbing stairs problem. Need to generate virtual code step by step with explanations. We need to output lines like:\n\nStart // 程式開始執行\n→ Step 1: Input n // 取得步數\n\nWe need to produce virtual code that solves the problem. Since they said \"逐行地產生對應的虛擬碼 (Virtual Code)\" we need to describe algorithm. Maybe dynamic programming.\n\nWe should output each line with explanation comment. Use arrow arrows etc.\n\nThus produce something like:\n\nStart // 程式開始執行\n→ Step 1: 取得 n // Input number of steps\n→ Decision: n ≤ 0? // handle invalid\n   Yes → Step 2: Return 0 // No ways\n   No → Decision: n == 1? // single step\n      Yes → Step 3: Return 1 // Only one way\n      No → Decision: n == 2? // two steps\n         Yes → Step 4: Return 2 // two ways\n         No → Step 5: 初始化 dp[0] = 1, dp[1] = 1, dp[2] = 2 // base cases\n→ Step 6: For i from 3 to n: dp[i] = dp[i-1] + dp[i-2] // compute\n→ Step 7: Return dp[n] // result\nEnd // 程式結束\n\nBut we should use arrow syntax: \"→ Step X:\" each line. For decisions we indent. We can produce like example:\n\nDecision: n <= 0? // handle\n\nYes → Step ...\n\nNo → Decision: n == 1? // etc\n\nWe can also use \"Start\" and \"End\".\n\nThey didn't specify to use variables names but we can.\n\nThe virtual code should be line by line.\n\nOk.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入 n // 取得要爬的台階總數  \n→ Decision: n ≤ 0? // 檢查是否為無效值  \n  Yes → Step 2: 回傳 0 // 沒有台階時無法上爬  \n  No → Decision: n == 1? // 只剩一階  \n    Yes → Step 3: 回傳 1 // 只能一步走  \n    No → Decision: n == 2? // 只剩兩階  \n      Yes → Step 4: 回傳 2 // 走法：1+1 或 2  \n      No → Step 5: 初始化 dp[0] = 1, dp[1] = 1, dp[2] = 2 // 基礎值，dp[i] 表示走到第 i 階的方法數  \n→ Step 6: 循環 i 從 3 到 n  \n  → dp[i] = dp[i-1] + dp[i-2] // 走到第 i 階的方式等於前一階加前兩階的方式總和  \n→ Step 7: 回傳 dp[n] // 最終結果是走到第 n 階的方法總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef climb_stairs(n: int) -> int:\n    \"\"\"\n    Return the number of distinct ways to climb to the top of a staircase with n steps,\n    where each move can be either 1 or 2 steps.\n    \"\"\"\n    if n <= 2:\n        return n\n\n    first, second = 1, 2  # dp[1] = 1, dp[2] = 2\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n    return second\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, parse the integer n, compute the answer,\n    and print it to stdout.\n    \"\"\"\n    data = sys.stdin.read()\n    # Extract the first integer found in the input (handles formats like \"n = 2\" or just \"2\")\n    numbers = re.findall(r'\\d+', data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n\n    result = climb_stairs(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode372.json",
    "problem_index_in_file": 0,
    "title": "Super Pow",
    "description_snippet": "Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large pos...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for algorithm computing a^b mod 1337 where b is large given as array of digits? Actually typical LeetCode 372 \"Super Pow\". Input: a integer, b array of digits, compute pow(a, pow(b)) mod 1337. We need to generate virtual code step by step. Use Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow → etc. Provide algorithm: Use Euler totient? Since modulus 1337 = 7*191. But typical solution uses exponent mod phi(1337)= 1337*(1-1/7)*(1-1/191)=1337*(6/7)*(190/191)=1337*6*190/(7*191)=? Wait compute: phi(1337)=1337* (1-1/7)*(1-1/191)=1337*(6/7)*(190/191)=1337*6*190/(7*191)=? 1337/191=7; 7*6*190/(7)=6*190=1140. So phi=1140. Then compute b mod 1140 using digits. Then compute pow(a, exp_mod + 1140) mod 1337 if needed. But simpler: recursive compute pow(a, b mod 1140 + 1140 if b>0). Use big integer mod function.\n\nWe produce steps: Input a, array b. Compute exponent = compute_mod(b, 1140). If b all zeros? Actually if b array represent number maybe zero. If b is zero, result 1. Else if exponent==0, set exponent +=1140. Then compute pow_mod(a, exponent, 1337). Output.\n\nProvide pseudo-code line by line.\n\nLet's produce.\n\nNeed to use arrow lines.\n\nLet's produce.\n\nUse Start // Program start\n\n→ Step 1: Read a // Get base\n\n→ Step 2: Read b array // Get exponent digits\n\n→ Decision: If b array all zeros? // Check if exponent is 0\n\n    Yes → Step 3: Output 1 // a^0 mod 1337 =1\n\n    No → Step 4: Compute exp_mod = ModArray(b, 1140) // Compute b mod 1140\n\n        → Step 5: If exp_mod == 0 → exp_mod = 1140 // Ensure exponent not zero\n\n        → Step 6: Compute result = ModPow(a, exp_mod, 1337) // fast pow\n\n        → Step 7: Output result\n\nEnd // Program finish\n\nNow we need ModArray and ModPow pseudo steps.\n\nWe can embed them as subprocedures.\n\nDefine:\n\n→ Procedure ModArray(arr, mod) // Compute integer represented by arr modulo mod\n\n    → Step X: result=0\n\n    → For each digit d in arr:\n\n        → result = (result*10 + d) mod mod\n\n    → Return result\n\n→ Procedure ModPow(base, exp, mod)\n\n    → result=1\n\n    → base = base mod mod\n\n    → While exp >0\n\n        → If exp %2 ==1 → result = (result*base) mod mod\n\n        → base = (base*base) mod mod\n\n        → exp = exp/2\n\n    → Return result\n\nWe should include these as steps in the flow.\n\nThus the pseudo-code will list them sequentially.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 a // 取得底數  \n→ Step 2: 讀取 b[ ] // 取得指數的數字陣列  \n→ Decision: b[ ] 是否全為 0? // 判斷指數是否為 0  \n    Yes → Step 3: 輸出 1 // a^0 mod 1337 = 1  \n    No  → Step 4: 計算 exp_mod ← ModArray(b, 1140) // 把大數 b 取 1140 取餘  \n        → Step 5: If exp_mod == 0 → exp_mod ← 1140 // 確保指數不為 0  \n        → Step 6: 計算 result ← ModPow(a, exp_mod, 1337) // 快速取冪  \n        → Step 7: 輸出 result // 顯示 a^b mod 1337  \nEnd // 程式執行結束  \n\nProcedure ModArray(arr, mod) // 計算陣列所表示的整數取 mod  \n    → Step 8: result ← 0  \n    → For each digit d in arr  \n        → result ← (result * 10 + d) mod mod // 逐位累積餘數  \n    → Return result  \n\nProcedure ModPow(base, exp, mod) // 快速取冪模  \n    → Step 9: result ← 1  \n    → base ← base mod mod  \n    → While exp > 0  \n        → If exp mod 2 == 1 → result ← (result * base) mod mod // 奇數位乘入  \n        → base ← (base * base) mod mod // 平方  \n        → exp ← exp / 2 // 右移一次  \n    → Return result",
      "generated_code": "import sys\nimport re\n\nMOD = 1337\n\ndef super_pow(a, b):\n    result = 1\n    for digit in b:\n        result = pow(result, 10, MOD) * pow(a, digit, MOD) % MOD\n    return result\n\nif __name__ == \"__main__\":\n    data = re.findall(r'\\d+', sys.stdin.read())\n    if not data:\n        sys.exit(0)\n    a = int(data[0])\n    b = list(map(int, data[1:]))\n    print(super_pow(a, b))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 2, b = [3]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = [1,0]",
          "expected_output": "1024",
          "success": true,
          "output": "1024"
        },
        {
          "example_index": 2,
          "input": "a = 1, b = [4,3,3,8,5,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode466.json",
    "problem_index_in_file": 0,
    "title": "Count The Repetitions",
    "description_snippet": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: given s1, n1, s2, n2, find maximum m such that s2 repeated m times is subsequence of s1 repeated n1 times. This is classic Leetcode 466. Approach: use cycle detection to find how many s2 segments can be extracted per n1 s1 cycles.\n\nPseudo steps: maintain indices i in s1, j in s2. For each repeat of s1 (counter for n1), increment count of s2 when j reaches len(s2). Use map to record state (j index) to pair (count_s2, i_count). When repeat seen, compute cycle length and count increment, compute remaining repeats.\n\nWe'll output virtual code line by line with explanation. Let's produce steps:\n\nStart\n→ Initialize variables: i = 0 (position in s1), j = 0 (position in s2), countS2 = 0 (how many s2 completed), repeat = 0 (how many s1 repetitions done)\n→ Map record = empty dictionary\n→ While repeat < n1:\n    → repeat += 1\n    → For each character c in s1:\n        → If c == s2[j]: j += 1\n            → If j == len(s2): j = 0; countS2 += 1\n    → If state (j) already in record: // cycle detected\n        → previousRepeat, previousCount = record[j]\n        → cycleRepeat = repeat - previousRepeat\n        → cycleCount = countS2 - previousCount\n        → remainingRepeat = n1 - repeat\n        → cycles = remainingRepeat // cycleRepeat\n        → countS2 += cycles * cycleCount\n        → repeat += cycles * cycleRepeat\n    → Else: record[j] = (repeat, countS2)\n→ Return countS2 // number of s2 inside str1\n→ m = countS2 // since each s2 contributes once? Wait need maximum m such that str2 repeated m times subsequence. We have countS2 as number of s2 segments we can extract. So m = countS2 // 1? Actually we want m such that [str2, m] is subsequence. Each s2 segment counts as one. So m = countS2 // 1. But also divide by 1? We need to return countS2 // 1? Wait we need number of times str2 can be obtained. So m = countS2 // 1, but if we used m directly as countS2. But we should return countS2 // 1? Actually we want m such that str2 repeated m times is subsequence. So m = countS2 // 1. So just return countS2 // 1? But no dividing by n2? Let's think: str2 is [s2, n2]. We want m such that [s2, n2] repeated m times (so s2 repeated m*n2 times) is subsequence. So we need to find how many times we can get s2 repeated n2 times? Wait we compute countS2 = number of s2 copies we can get. Each copy of s2 corresponds to one s2. But str2 = s2 repeated n2 times. So m = countS2 // n2. Yes.\n\nSo after loop, compute m = countS2 // n2. Return m.\n\nOk produce virtual code accordingly.\n\nLet's write each line with comment. Use arrow indentation.\n\nRemember to include \"Start\" and \"End\".\n\nAlso we need to mention \"Decision:\" for cycle detection.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化變數  \n  i ← 0 // 在 s1 中的游標位置（此處未實際使用）  \n  j ← 0 // 在 s2 中的游標位置  \n  countS2 ← 0 // 已完成的 s2 數量  \n  repeat ← 0 // 已完成的 s1 重複次數  \n  record ← 空字典 // 用於記錄 (j) → (repeat, countS2)  \n→ 進入主循環，直到完成所有 s1 重複  \n  Decision: repeat < n1? // 是否還有 s1 循環未處理  \n   Yes → repeat ← repeat + 1 // 處理下一個 s1 重複  \n    → For 每個字元 c in s1: // 遍歷 s1 中的每個字符  \n      Decision: c == s2[j]? // 字符是否與 s2 的當前位置相符  \n       Yes → j ← j + 1 // 游標向前移動  \n         Decision: j == len(s2)? // 是否完成一個 s2  \n          Yes → j ← 0 // 重置為 s2 開頭  \n            countS2 ← countS2 + 1 // 完成一個 s2",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        # 若一次都沒有重複，直接返回 0\n        if n1 == 0:\n            return 0\n\n        # 目前已完成的 s1 重複次數、已完成的 s2 數量\n        s1_count = 0\n        s2_count = 0\n        # 在 s2 中的游標位置\n        index = 0\n        # 記錄每一次在 s1 完成後，index 對應的 (s1_count, s2_count)\n        recall = {}\n\n        # 進行主循環，直到完成 n1 次 s1\n        while s1_count < n1:\n            for ch in s1:\n                if ch == s2[index]:\n                    index += 1\n                    if index == len(s2):\n                        index = 0\n                        s2_count += 1\n            s1_count += 1\n\n            # 如果遇到重複的 index，表示進入循環\n            if index in recall:\n                s1_prev, s2_prev = recall[index]\n                # 循環前的結果\n                pre_loop_s1, pre_loop_s2 = s1_prev, s2_prev\n                # 循環中的增量\n                in_loop_s1 = s1_count - s1_prev\n                in_loop_s2 = s2_count - s2_prev\n\n                # 先把循環前的結果加上\n                ans = pre_loop_s2\n                # 循環可以重複的次數\n                remaining = n1 - pre_loop_s1\n                cycle_times = remaining // in_loop_s1\n                ans += cycle_times * in_loop_s2\n                # 對剩餘的 s1 重複次數做一次完整模擬\n                rest = remaining % in_loop_s1\n                for _ in range(rest):\n                    for ch in s1:\n                        if ch == s2[index]:\n                            index += 1\n                            if index == len(s2):\n                                index = 0\n                                ans += 1\n                # 每次得到的 s2 數量除以 n2，即為可以得到的 str2 數量\n                return ans // n2\n\n            # 若未出現重複的 index，記錄當前狀態\n            recall[index] = (s1_count, s2_count)\n\n        # 若未進入循環，直接返回\n        return s2_count // n2\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 把所有被雙引號包裹的字符串找出\n    strings = re.findall(r'\"([^\"]*)\"', data)\n    # 把所有純數字找出\n    numbers = re.findall(r'\\b\\d+\\b', data)\n\n    if len(strings) < 2 or len(numbers) < 2:\n        # 如果輸入格式不符合預期，直接結束\n        sys.exit(0)\n\n    s1 = strings[0]\n    n1 = int(numbers[0])\n    s2 = strings[1]\n    n2 = int(numbers[1])\n\n    sol = Solution()\n    result = sol.getMaxRepetitions(s1, n1, s2, n2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode526.json",
    "problem_index_in_file": 0,
    "title": "Beautiful Arrangement",
    "description_snippet": "Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem of counting beautiful arrangements. This is Leetcode 1353 Beautiful Arrangement. Typical solution: backtracking with bitmask or array used.\n\nWe need step-by-step pseudocode lines, each with // explanation.\n\nWe must produce in Chinese Traditional.\n\nWe should not output actual code, just virtual code lines with arrows. Use Start, End, Decision, etc.\n\nSo we produce steps: define function countBeautifulArrangement(n). Use backtracking recursion. Use array used[1..n] or bitmask. Steps: count=0. Define recursive function dfs(position). If position>n, count++ return. For candidate from 1 to n: if not used and (candidate%position==0 or position%candidate==0) then mark used, dfs(position+1), unmark.\n\nReturn count.\n\nWe should present virtual code with line numbers? Not necessary but each line as step. We need to produce \"虛擬碼步驟\" + space + // 解釋.\n\nThus, line: \"Start // 程式開始執行\". Then steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化變數 count ← 0 // 記錄美麗排列總數\n→ Step 2: 建立 bool used[1..n] 全部設為 false // 標記已使用的數字\n→ Step 3: 定義遞迴函式 dfs(pos) // pos 表示目前排列到第 pos 位\n→ Step 4: Decision: 如果 pos > n? // 所有位都已填完\n    Yes → Step 5: count ← count + 1 // 找到一個合法排列\n    No  → Step 6: for num from 1 to n\n                Decision: 如果 used[num] 為 true? // 已使用的數字跳過\n                    Yes → Continue // 跳過本次迴圈\n                    No  → Decision: 如果 num % pos == 0 或 pos % num == 0? // 是否滿足美麗條件\n                        Yes → Step 7: used[num] ← true // 標記使用\n                                    → dfs(pos + 1) // 進行下一位\n                                    → used[num] ← false // 回溯\n                        No  → Continue // 不符合條件，嘗試下個 num\n→ Step 8: 呼叫 dfs(1) // 從第一位開始遞迴\n→ Step 9: Return count // 回傳美麗排列總數\nEnd // 程式執行結束\n\nMake sure each line has \"虛擬碼步驟\" but we just show step lines with arrows. The requirement: each line \"虛擬碼步驟\" + space + \"// 解釋\". So we just include the step description. We can put \"→\" as arrow. Also \"Decision:\" lines. Ok.\n\nWe need to ensure we don't output actual code, just virtual. Also maintain Chinese. Let's format.\n\nUse \"Start\", \"End\".\n\nI think good. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 count ← 0 // 記錄美麗排列總數  \n→ Step 2: 建立 bool used[1..n] 全部設為 false // 標記已使用的數字  \n→ Step 3: 定義遞迴函式 dfs(pos) // pos 表示目前排列到第 pos 位  \n→ Step 4: Decision: 如果 pos > n? // 所有位都已填完  \n  Yes → Step 5: count ← count + 1 // 找到一個合法排列  \n  No  → Step 6: for num from 1 to n  \n    Decision: 如果 used[num] 為 true? // 已使用的數字跳過  \n     Yes → Continue // 跳過本次迴圈  \n     No  → Decision: 如果 num % pos == 0 或 pos % num == 0? // 是否滿足美麗條件  \n      Yes → Step 7: used[num] ← true // 標記使用  \n        → dfs(pos + 1) // 進行下一位  \n        → used[num] ← false // 回溯  \n      No  → Continue // 不符合條件，嘗試下個 num  \n→ Step 8: 呼叫 dfs(1) // 從第一位開始遞迴  \n→ Step 9: Return count // 回傳美麗排列總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def countArrangement(self, n: int) -> int:\n        \"\"\"\n        Count the number of beautiful arrangements for the given n.\n        A beautiful arrangement satisfies:\n        - perm[i] is divisible by i\n        - or i is divisible by perm[i]\n        \"\"\"\n        # Memoization dictionary for dynamic programming\n        memo = {}\n\n        def dfs(mask: int) -> int:\n            \"\"\"\n            Recursively count arrangements using bitmask to represent\n            which numbers have already been placed.\n            mask: bit i (0-indexed) indicates whether number (i+1) is used.\n            \"\"\"\n            # Position to place next number (1-indexed)\n            pos = bin(mask).count(\"1\") + 1\n            if pos > n:\n                return 1  # All positions filled\n\n            if mask in memo:\n                return memo[mask]\n\n            total = 0\n            # Try every number from 1 to n\n            for num in range(1, n + 1):\n                bit = 1 << (num - 1)\n                if mask & bit:\n                    continue  # Number already used\n                if num % pos == 0 or pos % num == 0:\n                    total += dfs(mask | bit)\n\n            memo[mask] = total\n            return total\n\n        return dfs(0)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    n = int(data)\n    sol = Solution()\n    result = sol.countArrangement(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode324.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Sort II",
    "description_snippet": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\n\nYou may...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that reorders array to wiggle sort: nums[0] < nums[1] > nums[2] < nums[3]....\n\nWe should produce step-by-step virtual code.\n\nWe need to not output actual code, only pseudo steps.\n\nWe need to produce each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrow symbols and decisions.\n\nWe can use the known approach: iterate over array, for each index i from 1 to n-1, if i is odd and nums[i-1] >= nums[i], swap; if i is even and nums[i-1] <= nums[i], swap.\n\nAlternatively, we can do two passes.\n\nSimpler: for i in 1..n-1: if (i%2==1 && nums[i-1] >= nums[i]) swap; else if (i%2==0 && nums[i-1] <= nums[i]) swap.\n\nThus produce virtual code.\n\nWe need Start, End, Decision etc.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 i = 1 // 設定從第二個元素開始\n→ Decision: i < n? // 判斷是否還有元素需要檢查\n    Yes → Step 2: 檢查索引 i 的奇偶性 // 決定比較方向\n        Decision: i is odd? // 是否為奇數索引\n            Yes → Step 3: 如果 nums[i-1] >= nums[i]，交換兩者 // 讓前一個小於後一個\n            No  → Step 4: 如果 nums[i-1] <= nums[i]，交換兩者 // 讓前一個大於後一個\n    No  → Step 5: i = i + 1 // 前進到下一個索引\n    Yes → Step 6: 回到 Decision: i < n? // 重新檢查\nEnd\n\nBut we need to ensure correct flow. Maybe restructure:\n\nStart\n→ Step 1: Set i = 1\n→ Decision: i < length? // if there is next element\n    Yes → Decision: i is odd? // check parity\n        Yes → Decision: nums[i-1] >= nums[i]? // if violation\n            Yes → Step 2: Swap nums[i-1] and nums[i] // fix wiggle\n            No → No action\n        No → Decision: nums[i-1] <= nums[i]? // if violation for even index\n            Yes → Step 3: Swap nums[i-1] and nums[i]\n            No → No action\n    No → Step 4: i = i + 1 // increment\n    Yes → Go back to Decision: i < length? // loop\nEnd\n\nBut the flow with increments: we need to increment i after each iteration. So Step 4 should increment i and go back.\n\nBetter to present loop.\n\nAlternatively we can express as:\n\nStart\n→ Step 1: i = 1 // start from second element\n→ Decision: i < n? // check loop condition\n    Yes → Decision: i is odd?\n        Yes → Decision: nums[i-1] >= nums[i]?\n            Yes → Step 2: Swap nums[i-1], nums[i]\n            No → No operation\n        No → Decision: nums[i-1] <= nums[i]?\n            Yes → Step 3: Swap nums[i-1], nums[i]\n            No → No operation\n    No → Step 4: i = i + 1 // advance index\n    Yes → Step 5: Go back to Decision: i < n?\nEnd\n\nBut we need to include 'End'.\n\nWe also need to ensure that the \"Yes\" and \"No\" branches point correctly.\n\nLet's produce final answer.\n\nEnsure each line ends with // explanation. Use arrow and decisions properly.\n\nAlso use proper indentation? It's fine.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← 1 // 從第二個元素開始檢查  \n→ Decision: i < n? // 判斷是否還有未檢查的元素  \n    Yes → Decision: i 是奇數? // 奇數索引需檢查「<」關係  \n        Yes → Decision: nums[i-1] ≥ nums[i]? // 若前一個不小於後一個，違規  \n            Yes → Step 2: 交換 nums[i-1] 與 nums[i] // 使 nums[i-1] < nums[i]  \n            No  → No operation // 已符合規則，保持不變  \n        No → Decision: nums[i-1] ≤ nums[i]? // 偶數索引需檢查「>」關係  \n            Yes → Step 3: 交換 nums[i-1] 與 nums[i] // 使 nums[i-1] > nums[i]  \n            No  → No operation // 已符合規則，保持不變  \n    No → Step 4: i ← i + 1 // 移動到下一個索引  \n    Yes → Go back to Decision: i < n? // 重新檢查條件，形成迴圈  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wiggleSort(self, nums):\n        nums.sort()\n        n = len(nums)\n        half = (n + 1) // 2\n        left = nums[:half][::-1]\n        right = nums[half:][::-1]\n        nums[::2] = left\n        nums[1::2] = right\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入轉換成列表\n    match = re.search(r'\\[(.*?)\\]', data)\n    if not match:\n        return\n    nums = eval('[' + match.group(1) + ']')\n    Solution().wiggleSort(nums)\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "success": true,
          "output": "[1, 6, 1, 5, 1, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "success": true,
          "output": "[2, 3, 1, 3, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode32.json",
    "problem_index_in_file": 0,
    "title": "Longest Valid Parentheses",
    "description_snippet": "Given a string containing just the characters '(' and ')', return the length of the longest valid (w...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output a virtual code solution. We should produce a step-by-step algorithm: use stack or two-pass counting. Provide lines with arrows. Provide explanation after each line. Let's produce a stack approach.\n\nWe need to be careful: \"Start\", \"End\", \"Decision:\" lines. Use \"→\" for steps.\n\nLet's produce something like:\n\nStart\n→ Step 1: Initialize stack with -1 // store base index\n→ Step 2: Initialize maxLen = 0 // to store longest length\n→ Step 3: For i from 0 to length-1 // iterate over characters\n    → Decision: If s[i] == '('?\n        Yes → Push i onto stack // push index of '('\n        No  → Pop from stack // closing parenthesis\n            → Decision: If stack is empty?\n                Yes → Push i onto stack // reset base index\n                No  → Update maxLen = max(maxLen, i - stack.top()) // compute length\n\nAfter loop, End.\n\nLet's ensure each line includes \"虛擬碼步驟 [space] // 解釋\". We must keep the arrow \"→\". Also \"Decision:\" lines with indentation. Indent by spaces? Example had 4 spaces indentation. Use 4 spaces for inner lines. Use \"Yes →\" and \"No →\". Provide explanation comments.\n\nAlso mention End.\n\nLet's produce the final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 stack 以存放索引，並將 -1 推進去 // -1 作為基準點，方便計算長度  \n→ Step 2: 初始化 maxLen 為 0 // 用來保存目前找到的最大有效長度  \n→ Step 3: 迴圈遍歷字串 s，i 從 0 到 s.length-1  \n    → Decision: 如果 s[i] 是 '('?  \n        Yes → Push i onto stack // 推入 '(' 的索引，等待匹配  \n        No → Pop stack // 遇到 ')'，先嘗試配對  \n            → Decision: stack 目前是否空？  \n                Yes → Push i onto stack // 沒有可配對的 '('，將此 ')' 的索引作為新的基準點  \n                No → maxLen = max(maxLen, i - stack.top()) // 以 stack.top() 為開啟 '(' 的索引，計算有效長度並更新最大值  \nEnd // 程式執行結束，返回 maxLen 為最長有效括號子字串長度",
      "generated_code": "import sys\n\ndef longest_valid_parentheses(s: str) -> int:\n    \"\"\"\n    Returns the length of the longest valid (well‑formed) parentheses substring.\n    \"\"\"\n    stack = [-1]          # Stack stores indices; -1 is a sentinel for the base.\n    max_len = 0\n\n    for i, ch in enumerate(s):\n        if ch == '(':\n            stack.append(i)                    # Push index of '('\n        else:                                 # ch == ')'\n            stack.pop()                        # Try to match with the last '('\n            if not stack:                      # No matching '(' left\n                stack.append(i)                # Reset base to current index\n            else:\n                max_len = max(max_len, i - stack[-1])  # Valid substring length\n\n    return max_len\n\ndef main() -> None:\n    data = sys.stdin.read()\n    s = data.strip()\n\n    if not s:\n        print(0)\n        return\n\n    # Handle possible assignment syntax like `s = \"(())\"`\n    if s.lower().startswith('s'):\n        if '=' in s:\n            _, val = s.split('=', 1)\n            s = val.strip()\n    # Strip surrounding quotes if present\n    if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n        s = s[1:-1]\n\n    result = longest_valid_parentheses(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"(()\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \")()())\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode565.json",
    "problem_index_in_file": 0,
    "title": "Array Nesting",
    "description_snippet": "You are given an integer array nums of length n where nums is a permutation of the numbers in the ra...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: Given array nums permutation of 0..n-1. For each k, we form set by starting at nums[k], then follow indices until duplicate occurs. Find longest length among all k.\n\nWe need to output virtual code line by line, each line with \"→\" etc, comments. We need no actual code. Just structure.\n\nWe need to produce steps: start, iterate over all k, maintain visited set for each start or use global visited to avoid recomputing? But algorithm: find cycle lengths. Actually each sequence will eventually enter a cycle because permutation. So the longest cycle length is answer. So algorithm: for each i not visited, traverse following indices, record path length. Use visited array to avoid reprocessing. Keep max length.\n\nThus produce virtual code accordingly. We'll produce steps:\n\nStart\n→ Initialize n = length of nums // number of elements\n→ Create array visited[n] all false // to mark processed indices\n→ Set maxLen = 0\n→ For each i from 0 to n-1: // iterate all starting indices\n    Decision: if visited[i] ? // already processed\n        Yes → continue // skip\n        No → // start new cycle\n        → Set current = i\n        → Set currentLen = 0\n        → While visited[current] == false: // traverse until duplicate\n            → visited[current] = true\n            → currentLen = currentLen + 1\n            → current = nums[current]\n        → Decision: if currentLen > maxLen?\n            Yes → maxLen = currentLen\n            No → // keep previous max\n→ End // return maxLen\n\nWe need to output each line as virtual code step. Use arrow and comments. Should we indent for Decision substeps? Format example uses indent with spaces before each sub-step? Use 4 spaces indentation. Provide the lines. We'll also include comment lines maybe as separate? The requirement: Each line must contain virtual code step + space + comment. So no separate comment lines. For Decision, we need nested lines with indentation and arrow. Use \"Decision:\" line and then sub-lines starting with \"Yes →\" and \"No →\". Should include indentation. For each line we add comment after space.\n\nAlso maybe need to include \"Start\" and \"End\". Provide.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Set n = length(nums) // 取得陣列長度  \n→ Create visited[n] all false // 標記每個索引是否已被處理  \n→ Set maxLen = 0 // 儲存目前找到的最大集合長度  \n→ For i from 0 to n-1: // 檢查每個可能的起始索引  \n    Decision: visited[i] ? // 此索引已被處理過？  \n        Yes → Continue // 跳過，進入下一個 i  \n        No  → // 開始新的循環追蹤  \n            → Set current = i // 從此索引開始  \n            → Set currentLen = 0 // 本次循環長度計數器  \n            → While visited[current] == false: // 直到遇到重複為止  \n                → visited[current] = true // 標記此索引已處理  \n                → currentLen = currentLen + 1 // 计入长度  \n                → current = nums[current] // 跳到下一個索引  \n            → Decision: currentLen > maxLen ? // 比較長度  \n                Yes → maxLen = currentLen // 更新最大長度  \n                No  → // 保留先前的 maxLen  \n→ End // 程式執行結束，返回 maxLen 作为结果",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def arrayNesting(self, nums):\n        \"\"\"\n        Find the longest length of a set s[k] defined by following indices\n        in the permutation nums until a duplicate appears.\n        This is equivalent to finding the longest cycle length in the permutation.\n        \"\"\"\n        visited = [False] * len(nums)\n        max_len = 0\n\n        for i in range(len(nums)):\n            if not visited[i]:\n                current = i\n                current_len = 0\n                while not visited[current]:\n                    visited[current] = True\n                    current_len += 1\n                    current = nums[current]\n                if current_len > max_len:\n                    max_len = current_len\n        return max_len\n\ndef main():\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    # Find the first '[' and the last ']' to extract the list representation\n    left = raw_input.find('[')\n    right = raw_input.rfind(']')\n    if left == -1 or right == -1 or left > right:\n        # If no list found, treat entire input as the list\n        list_str = raw_input.strip()\n    else:\n        list_str = raw_input[left:right+1]\n    # Safely evaluate the list string\n    nums = ast.literal_eval(list_str)\n    # Compute the result using the Solution class\n    result = Solution().arrayNesting(nums)\n    # Print the result to stdout\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,4,0,3,1,6,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode706.json",
    "problem_index_in_file": 0,
    "title": "Design HashMap",
    "description_snippet": "Design a HashMap without using any built-in hash table libraries.\n\nImplement the MyHashMap class:\n\nM...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for implementing a HashMap without built-in libraries. The requirement: MyHashMap class with init, put, get, remove. Provide pseudocode lines each with explanation comment. Use structure Start, End, Decision. Use arrow. Provide each step line by line. Likely need to include initialization of array of buckets, each bucket is a linked list of nodes. Use simple hash function: key mod capacity. Steps: define Node structure, define array of Node pointers. Define capacity. Use resize when load factor exceeds threshold. For simplicity we can omit resize. But we can mention optional. Provide steps for each method. Let's produce.\n\nAlso need to mention that we can't use built-in hash table libraries. So we implement our own. Use simple array.\n\nWe need to output in Chinese.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 定義 Node 結構，包含 key, value, next // 建立節點結構\n→ Step 2: 定義 MyHashMap 類，內部變數:\n    • capacity = 10000 // 緩衝區大小\n    • buckets = 新建長度為 capacity 的 Node 陣列 // 存放鏈表頭\n    • size = 0 // 現有鍵數 // End // 物件初始化\n\nImplement put:\n\n→ Step 3: Method put(key, value)\n    → Decision: key 是否已存在?\n        Yes → Update該節點的 value // 找到節點後更新\n        No  → Insert新節點到 bucket 前面\n→ Step 4: 先計算 hash = key % capacity // 簡單哈希\n→ Step 5: bucketIndex = hash\n→ Step 6: current = buckets[bucketIndex]\n→ Step 7: While current != null:\n        Decision: current.key == key?\n            Yes → current.value = value // 更新\n                → size unchanged\n                → Exit\n            No  → current = current.next\n→ Step 8: // 若迴圈結束，鍵不存在\n    → newNode = Node(key, value, buckets[bucketIndex]) // 新節點指向舊頭\n    → buckets[bucketIndex] = newNode\n    → size += 1\n\nGet:\n\n→ Step 9: Method get(key)\n    → Decision: 先 hash key // 同上\n        bucketIndex = key % capacity\n    → current = buckets[bucketIndex]\n    → While current != null:\n        Decision: current.key == key?\n            Yes → Return current.value\n            No  → current = current.next\n    → Return -1\n\nRemove:\n\n→ Step 10: Method remove(key)\n    → bucketIndex = key % capacity\n    → current = buckets[bucketIndex]\n    → prev = null\n    → While current != null:\n        Decision: current.key == key?\n            Yes → // 刪除\n                Decision: prev == null?\n                    Yes → buckets[bucketIndex] = current.next\n                    No  → prev.next = current.next\n                → size -= 1\n                → Exit\n            No  → prev = current; current = current.next\n    // 若未找到，直接返回\n\nEnd // 程式結束\n\nWe need to ensure each line is a separate line of virtual code with comment. Use arrow notation: \"→\" before each step. For decisions we use \"Decision:\" lines.\n\nLet's produce each line accordingly. Ensure that each line has comment after space.\n\nAlso need to include class definition, constructors, etc. Use pseudo-code with steps.\n\nLet's create:\n\nStart\n→ Step 1: class MyHashMap // 定義 MyHashMap 類\n    → Step 2: 定義 Node 結構\n        → Step 3: Node.key: int\n        → Step 4: Node.value: int\n        → Step 5: Node.next: Node\n    → Step 6: MyHashMap.capacity = 10000 // 設定桶數\n    → Step 7: MyHashMap.buckets = new Node[capacity] // 初始化桶陣列\n    → Step 8: MyHashMap.size = 0 // 初始化大小\nEnd\n\nBut we need to keep \"Start\" and \"End\". Actually \"Start\" and \"End\" are top-level.\n\nLet's craft accordingly.\n\nBe careful: each line must be separated. Use \"→\" to indicate flow.\n\nWe'll structure as:\n\nStart\n→ Step 1: 定義 Node 結構 // 建立鍵值節點\n    → Step 2: Node.key: int\n    → Step 3: Node.value: int\n    → Step 4: Node.next: Node\n→ Step 5: class MyHashMap // 定義哈希表類\n    → Step 6: MyHashMap.capacity = 10000 // 桶容量\n    → Step 7: MyHashMap.buckets = new Node[capacity] // 桶陣列\n    → Step 8: MyHashMap.size = 0 // 已存鍵數\n    → Step 9: MyHashMap.put(key, value) // 插入或更新\n        → Decision: key 是否已存在\n            Yes → Update節點.value\n            No  → Insert新節點\n    ... etc.\n\nBut we need to ensure each line has comment. Use arrow each line.\n\nAlso need to include \"End\" after all. Use \"End\" line with comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Node 結構 // 建立鍵值節點  \n    → Step 2: Node.key: int // 存放鍵  \n    → Step 3: Node.value: int // 存放值  \n    → Step 4: Node.next: Node // 指向下一節點  \n→ Step 5: class MyHashMap // 定義哈希表類  \n    → Step 6: MyHashMap.capacity = 10000 // 桶的容量  \n    → Step 7: MyHashMap.buckets = new Node[capacity] // 初始化桶陣列  \n    → Step 8: MyHashMap.size = 0 // 已存鍵的數量  \n→ Step 9: 方法 put(key, value) // 插入或更新鍵值對  \n    → Decision: 是否已存在 key? // 判斷 key 是否存在  \n        Yes → Step 10: 尋找該 key 的節點並更新其 value // 更新舊值  \n        No  → Step 11: 進行插入操作  \n            → Step 12: hash = key % capacity // 計算哈希索引  \n            → Step 13: bucketIndex = hash  \n            → Step 14: newNode = Node(key, value, buckets[bucketIndex]) // 新節點指向舊頭  \n            → Step 15: buckets[bucketIndex] = newNode // 插入到桶頭  \n            → Step 16: size += 1 // 更新大小  \n→ Step 17: 方法 get(key) // 查詢鍵對應的值  \n    → Step 18: hash = key % capacity // 計算哈希索引  \n    → Step 19: bucketIndex = hash  \n    → Step 20: current = buckets[bucketIndex]  \n    → While current != null: // 遍歷鏈表  \n        → Decision: current.key == key? // 檢查是否為目標鍵  \n            Yes → Step 21: return current.value // 返回對應值  \n            No  → Step 22: current = current.next // 移動到下一節點  \n    → Step 23: return -1 // 未找到時返回 -1  \n→ Step 24: 方法 remove(key) // 刪除鍵對應的節點  \n    → Step 25: hash = key % capacity // 計算哈希索引  \n    → Step 26: bucketIndex = hash  \n    → Step 27: current = buckets[bucketIndex]  \n    → Step 28: prev = null  \n    → While current != null: // 遍歷鏈表尋找要刪除的節點  \n        → Decision: current.key == key? // 判斷是否為目標鍵  \n            Yes → // 刪除操作  \n                → Decision: prev == null? // 該節點是否為桶頭  \n                    Yes → Step 29: buckets[bucketIndex] = current.next // 更新桶頭  \n                    No  → Step 30: prev.next = current.next // 跳過要刪除的節點  \n                → Step 31: size -= 1 // 減少已存鍵數  \n                → Step 32: return // 完成刪除  \n            No  → Step 33: prev = current // 更新 prev  \n                → Step 34: current = current.next // 移動到下一節點  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass MyHashMap:\n    def __init__(self):\n        self.size = 10000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def put(self, key: int, value: int) -> None:\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        for i, (k, _) in enumerate(bucket):\n            if k == key:\n                bucket[i] = (key, value)\n                return\n        bucket.append((key, value))\n\n    def get(self, key: int) -> int:\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        for k, v in bucket:\n            if k == key:\n                return v\n        return -1\n\n    def remove(self, key: int) -> None:\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        for i, (k, _) in enumerate(bucket):\n            if k == key:\n                bucket.pop(i)\n                return\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    ops_line = data[0].strip()\n    params_line = data[1].strip() if len(data) > 1 else \"[]\"\n    ops = ast.literal_eval(ops_line)\n    params = ast.literal_eval(params_line)\n\n    obj = None\n    results = []\n\n    for op, param in zip(ops, params):\n        if op == \"MyHashMap\":\n            obj = MyHashMap()\n            results.append(\"null\")\n        elif op == \"put\":\n            obj.put(param[0], param[1])\n            results.append(\"null\")\n        elif op == \"get\":\n            results.append(obj.get(param[0]))\n        elif op == \"remove\":\n            obj.remove(param[0])\n            results.append(\"null\")\n\n    output_parts = [str(r) if r != \"null\" else \"null\" for r in results]\n    print(\"[\" + \", \".join(output_parts) + \"]\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]",
          "expected_output": "[null, null, null, 1, -1, null, 1, null, -1]",
          "success": true,
          "output": "[null, null, null, 1, -1, null, 1, null, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode399.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Division",
    "description_snippet": "You are given an array of variable pairs equations and an array of real numbers values, where equati...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code for solving equations and queries. We should provide step-by-step algorithm. Likely we need to build graph adjacency list with weights as division ratios, then BFS/DFS per query. Steps: Build graph, process queries, output result. Provide virtual code line by line with comments. Ensure use of Start, End, Decision, etc. Let's craft.\n\nWe need to use virtual code syntax: \"Start\", \"→ Step 1:\", \"Decision:\" etc. For loops, we can use \"→ For each equation:\". Use arrow and maybe indentation with spaces.\n\nWe should ensure each line ends with // explanation. Use proper Chinese explanation. Each line with code and comment separated by space? They said `虛擬碼步驟` + `[空格]` + `// 解釋/說明`. So code and comment separated by space, not colon? We'll follow example: `→ Step 1: ... // ...`.\n\nLet's produce.\n\nPseudo:\n\nStart\n→ Build adjacency list graph // 建立圖\n→ For each equation i:\n    → Add edge Ai -> Bi weight values[i] // Ai/Bi = value\n    → Add edge Bi -> Ai weight 1/values[i] // Bi/Ai = 1/value\n→ For each query j:\n    → If Cj or Dj not in graph: answer -1.0 // 未定義\n    → If Cj == Dj: answer 1.0 // 同一變量\n    → Else: BFS from Cj to find path to Dj\n        → Initialize queue with Cj, product = 1\n        → While queue not empty:\n            → Dequeue node\n            → If node == Dj: record product, break\n            → For each neighbor:\n                → If not visited:\n                    → Enqueue neighbor, update product * weight\n        → If found: store product\n        → Else: store -1.0\n→ Output answers list\nEnd\n\nNeed to use Decision syntax. For loops we can use \"→ For each ...\". For BFS we may need Decision inside loop.\n\nLet's produce with line numbers? Not necessary but each line separate. Indent decisions accordingly.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Build graph // 建立圖的資料結構  \n→ For each equation i: // 逐一處理輸入的等式  \n  → Add edge Ai → Bi weight values[i] // 代表 Ai / Bi = value  \n  → Add edge Bi → Ai weight 1 / values[i] // 代表 Bi / Ai = 1/value  \n→ For each query j: // 逐一處理查詢  \n  Decision: 是否存在 Cj 或 Dj 未在 graph? // 判斷變數是否已定義  \n   Yes → Append -1.0 to answers // 未定義則答案為 -1.0  \n   No  → Decision: Cj == Dj? // 是否相同變數  \n    Yes → Append 1.0 to answers // 相同變數商為 1  \n    No  → Begin BFS from Cj to Dj // 需要尋找連結  \n     → Initialize queue with (Cj, 1.0) // 起點商為 1  \n     → Mark Cj visited  \n     → While queue not empty: // BFS 主迴圈  \n       → Dequeue (node, prod)  \n       Decision: node == Dj? // 到達目標嗎  \n        Yes → Append prod to answers // 找到商，記錄答案  \n        No  → For each neighbor of node: // 探索鄰接節點  \n         Decision: neighbor 未 visited?  \n          Yes → Enqueue (neighbor, prod * weight[node→neighbor])  \n          No → Continue  \n       Decision: 找到 Dj? // BFS 結束判斷  \n       Yes → 已在前面處理，跳出循環  \n       No  → 循環結束後仍未找到  \n       Decision: 找不到路徑?  \n        Yes → Append -1.0 to answers // 無路徑  \n        No → 這種情況不會發生（已在找到時處理）  \n→ Return answers // 回傳所有查詢結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1.0 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\ndef parse_input(line: str):\n    # Find positions of the three parts\n    eq_start = line.find('equations =')\n    val_start = line.find('values =')\n    qry_start = line.find('queries =')\n\n    equations_str = line[eq_start + len('equations ='):val_start].strip()\n    values_str = line[val_start + len('values ='):qry_start].strip()\n    queries_str = line[qry_start + len('queries ='):].strip()\n\n    equations = ast.literal_eval(equations_str)\n    values = ast.literal_eval(values_str)\n    queries = ast.literal_eval(queries_str)\n    return equations, values, queries\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    equations, values, queries = parse_input(data)\n    sol = Solution()\n    ans = sol.calcEquation(equations, values, queries)\n    formatted = '[' + ','.join(f'{x:.5f}' for x in ans) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpqek22d_1.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpqek22d_1.py\", line 51, in main\n    ans = sol.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqek22d_1.py\", line 9, in calcEquation\n    graph[a][b] = val\n    ~~~~~^^^\nTypeError: unhashable type: 'list'"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpb6depdkf.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpb6depdkf.py\", line 51, in main\n    ans = sol.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpb6depdkf.py\", line 8, in calcEquation\n    for (a, b), val in zip(equations, values):\n        ^^^^^^\nValueError: too many values to unpack (expected 2)"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpjelfizwt.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpjelfizwt.py\", line 51, in main\n    ans = sol.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjelfizwt.py\", line 8, in calcEquation\n    for (a, b), val in zip(equations, values):\n        ^^^^^^\nValueError: not enough values to unpack (expected 2, got 1)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode707.json",
    "problem_index_in_file": 0,
    "title": "Design Linked List",
    "description_snippet": "Design your implementation of the linked list. You can choose to use a singly or doubly linked list....",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with arrows, each line with explanation. Implement MyLinkedList class with singly linked list. Provide operations. Virtual code steps for each method? Should provide general structure and steps per method. We need to include Start, End, Decision. Provide step-by-step pseudo code for each method. Use arrow. We should not output actual code. So each line like \"Start // 程式開始執行\" etc.\n\nWe'll design singly linked list. Provide steps:\n\nStart\n→ Define Node structure with val, next\n→ Define MyLinkedList class with head pointer, size\n\nConstructor: Initialize head null, size 0\n\nget(index):\n→ Decision: index < 0 or index >= size? // check invalid\n    No → return -1\n    Yes → \n→ Traverse from head to index node\n→ Return node.val\n\naddAtHead(val):\n→ Create new node with val\n→ new.next = head\n→ head = new\n→ size++\n\naddAtTail(val):\n→ Create new node with val\n→ If head null:\n    → head = new\n→ Else:\n    → Traverse to last node\n    → last.next = new\n→ size++\n\naddAtIndex(index, val):\n→ Decision: index < 0? index = 0 // allow negative as 0\n→ Decision: index > size? return\n→ Decision: index == 0? call addAtHead\n→ Else:\n    → Traverse to node before index\n    → new.next = current.next\n    → current.next = new\n→ size++\n\ndeleteAtIndex(index):\n→ Decision: index <0 or >= size? return\n→ Decision: index ==0? head = head.next\n→ Else:\n    → Traverse to node before index\n    → nodeToDelete = current.next\n    → current.next = nodeToDelete.next\n→ size--\n\nEnd\n\nWe need to output step-by-step virtual code lines, each line has arrow \"→\" except Start and End. Also include Decision branches with Yes/No indent.\n\nLet's craft final output accordingly. Use comments in Chinese. Provide each step. Use proper indentation with spaces maybe. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Node: val // Node 儲存資料  \n→ Define Node: next // Node 指向下一個節點  \n→ Define MyLinkedList: head // 指向鏈表頭部  \n→ Define MyLinkedList: size // 追蹤節點數量  \n\n// MyLinkedList() 初始化  \n→ MyLinkedList()  \n    → head ← null // 初始化為空鏈表  \n    → size ← 0 // 節點數量為 0  \n\n// int get(int index)  \n→ get(index)  \n    → Decision: index < 0 OR index ≥ size? // 檢查索引有效性  \n        Yes → Return -1 // 無效索引回傳 -1  \n        No →  \n            → current ← head // 從頭節點開始  \n            → i ← 0 // 計數器  \n            → Decision: i < index? // 迴圈直到到達目標節點  \n                Yes → current ← current.next  \n                      i ← i + 1  \n                      → Repeat Decision  \n                No →  \n                    → Return current.val // 取得目標節點值  \n\n// void addAtHead(int val)  \n→ addAtHead(val)  \n    → newNode ← new Node(val) // 建立新節點  \n    → newNode.next ← head // 指向舊頭部  \n    → head ← newNode // 新節點成為頭部  \n    → size ← size + 1 // 節點數量加一  \n\n// void addAtTail(int val)  \n→ addAtTail(val)  \n    → newNode ← new Node(val) // 建立新節點  \n    → Decision: head == null? // 判斷鏈表是否為空  \n        Yes → head ← newNode // 空鏈表直接指向新節點  \n        No →  \n            → current ← head // 從頭開始尋找尾節點  \n            → Decision: current.next != null? // 迴圈直到最後一個節點  \n                Yes → current ← current.next  \n                      → Repeat Decision  \n                No →  \n                    → current.next ← newNode // 尾節點指向新節點  \n    → size ← size + 1  \n\n// void addAtIndex(int index, int val)  \n→ addAtIndex(index, val)  \n    → Decision: index < 0?  \n        Yes → index ← 0 // 負索引視為 0  \n    → Decision: index > size? // 若索引大於長度不插入  \n        Yes → Return // 結束方法  \n        No →  \n            → Decision: index == 0? // 需要在頭部插入  \n                Yes → → addAtHead(val) // 呼叫 addAtHead  \n                No →  \n                    → current ← head // 從頭開始尋找前一個節點  \n                    → i ← 0  \n                    → Decision: i < index - 1? // 迴圈至前一個節點  \n                        Yes → current ← current.next  \n                              i ← i + 1  \n                              → Repeat Decision  \n                        No →  \n                            → newNode ← new Node(val) // 建立新節點  \n                            → newNode.next ← current.next // 指向原來的下一節點  \n                            → current.next ← newNode // 插入新節點  \n                    → size ← size + 1  \n\n// void deleteAtIndex(int index)  \n→ deleteAtIndex(index)  \n    → Decision: index < 0 OR index ≥ size? // 檢查索引有效性  \n        Yes → Return // 無效索引不做任何事  \n        No →  \n            → Decision: index == 0? // 刪除頭節點  \n                Yes → head ← head.next // 讓頭部指向第二個節點  \n                No →  \n                    → current ← head // 從頭開始尋找前一個節點  \n                    → i ← 0  \n                    → Decision: i < index - 1? // 迴圈至前一個節點  \n                        Yes → current ← current.next  \n                              i ← i + 1  \n                              → Repeat Decision  \n                        No →  \n                            → nodeToDelete ← current.next // 要刪除的節點  \n                            → current.next ← nodeToDelete.next // 跳過該節點  \n                    → // nodeToDelete 自動被垃圾回收  \n    → size ← size - 1  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MyLinkedList:\n    class Node:\n        def __init__(self, val=0):\n            self.val = val\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.size = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n        curr = self.head\n        for _ in range(index):\n            curr = curr.next\n        return curr.val\n\n    def addAtHead(self, val: int) -> None:\n        node = self.Node(val)\n        node.next = self.head\n        self.head = node\n        self.size += 1\n\n    def addAtTail(self, val: int) -> None:\n        node = self.Node(val)\n        if not self.head:\n            self.head = node\n        else:\n            curr = self.head\n            while curr.next:\n                curr = curr.next\n            curr.next = node\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0 or index > self.size:\n            return\n        if index == 0:\n            self.addAtHead(val)\n            return\n        node = self.Node(val)\n        curr = self.head\n        for _ in range(index - 1):\n            curr = curr.next\n        node.next = curr.next\n        curr.next = node\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n        if index == 0:\n            self.head = self.head.next\n        else:\n            curr = self.head\n            for _ in range(index - 1):\n                curr = curr.next\n            curr.next = curr.next.next\n        self.size -= 1\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    ops = json.loads(data[0])\n    args_list = json.loads(data[1])\n    result = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"MyLinkedList\":\n            obj = MyLinkedList()\n            result.append(None)\n        else:\n            method = getattr(obj, op)\n            if op == \"get\":\n                res = method(*args)\n                result.append(res)\n            else:\n                method(*args)\n                result.append(None)\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n[[], [1], [3], [1, 2], [1], [1], [1]]",
          "expected_output": "[null, null, null, null, 2, null, 3]",
          "success": true,
          "output": "[null, null, null, null, 2, null, 3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode481.json",
    "problem_index_in_file": 0,
    "title": "Magical String",
    "description_snippet": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for computing the number of '1's in the first n numbers of magical string s. The algorithm: Build magical string until length >= n, count '1's. Known problem: Magical string, from LeetCode. Approach: Use array s, start with [1,2,2], then use index idx=2 (point to current group), count=1? Actually s[0]=1 counts 1. Then while length < n: next = s[idx]; repeat next times adding 3 - s[-1] (toggle). Then idx++. Count 1s accordingly. Output count of 1's in first n.\n\nWe need to produce pseudo steps line by line with comments.\n\nLet's craft steps:\n\nStart\n→ Initialize array s with [1,2,2] // base of magical string\n→ Initialize pointer idx = 2 // index of group to read next\n→ Initialize count1 = 1 // number of 1's seen so far (first element is 1)\n→ While length of s < n: // build until reach desired length\n    → Let groupSize = s[idx] // number of times to append next digit\n    → Let nextDigit = 3 - s[s.length -1] // toggle between 1 and 2\n    → For i from 1 to groupSize: // append group\n        → Append nextDigit to s\n        → If nextDigit == 1: increment count1\n    → Increment idx // move to next group\n→ If n < s.length: // trim to first n if overshoot\n    → If s[n-1] == 1: decrement count1? Actually we might have overcounted if appended beyond n. Simpler: After loop, count1 = number of 1's in first n elements. We can count by scanning first n elements again.\n→ Return count1\n\nBut we can incorporate trimming.\n\nLet's write virtual steps:\n\nStart\n→ Create list s = [1,2,2] // initial magical string\n→ Set idx = 2 // current group index to read\n→ Set count1 = 1 // count of '1's in s so far\n→ While length(s) < n:\n    → groupSize = s[idx]\n    → nextDigit = 3 - s[-1] // toggle 1↔2\n    → For i = 1 to groupSize:\n        → Append nextDigit to s\n        → If nextDigit == 1: count1 += 1\n    → idx += 1\n→ If length(s) > n:\n    → // need to adjust count if we appended extra '1's beyond n\n    → Let excess = length(s) - n\n    → If last appended digit was 1: count1 -= excess\n→ Return count1\n\nBut the last part may not be correct. Instead we can compute count1 by scanning first n elements after building. That may be simpler.\n\nThus after building until length >= n, we can compute count1 = number of 1's in first n.\n\nSo:\n\n→ After loop, set count1 = 0\n→ For i = 0 to n-1:\n    → If s[i] == 1: count1 += 1\n→ Return count1\n\nLet's format.\n\nUse arrow for steps. Ensure each line ends with // comment.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立列表 s = [1, 2, 2] // 初始化魔法字串的前3個數字  \n→ Step 2: 設定指標 idx = 2 // 指向下一個需要讀取的連續段  \n→ Step 3: 初始化計數 count1 = 0 // 目前已經看到的 1 的個數  \n→ Step 4: 進入迴圈 While length(s) < n // 持續擴充字串直到長度至少為 n  \n&nbsp;&nbsp;→ Decision: 若 s 已滿足長度?  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Step 5: 取 groupSize = s[idx] // 這個段要重複多少次  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Step 6: 取 nextDigit = 3 - s[-1] // 1 與 2 交替  \n&nbsp;&nbsp;&nbsp;&nbsp;No → For i = 1 到 groupSize: // 把這個段的數字加入 s  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: Append nextDigit 到 s // 把數字放進字串  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 如果 nextDigit 為 1?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 8: count1 += 1 // 1 的個數加一  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 9: 何也不做 // 不是 1，計數保持不變  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Step 10: idx += 1 // 移到下一段的索引  \n&nbsp;&nbsp;→ Decision: 迴圈結束?  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → 退出迴圈  \n→ Step 11: 若 s 的長度超過 n，重新計算前 n 個位置的 1 的個數  \n&nbsp;&nbsp;→ Step 12: 設定 count1 = 0  \n&nbsp;&nbsp;→ For i = 0 到 n-1:  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 如果 s[i] == 1?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 13: count1 += 1 // 重新統計 1 的數量  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → 何也不做  \n→ Step 14: Return count1 // 回傳前 n 個數字中 1 的個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def magicalString(self, n: int) -> int:\n        if n == 0:\n            return 0\n        if n <= 3:\n            return 1\n\n        s = [1, 2, 2]          # 初始魔法字串\n        head = 2                # 指向下個要讀取的段位\n        num = 1                 # 下個要添加的數字（1 或 2）\n        while len(s) < n:\n            # 以 s[head] 次數添加 num\n            s.extend([num] * s[head])\n            # 交替 1 與 2\n            num ^= 3\n            head += 1\n        return s[:n].count(1)\n\ndef main():\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    sol = Solution()\n    result = sol.magicalString(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode200.json",
    "problem_index_in_file": 0,
    "title": "Number of Islands",
    "description_snippet": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanation lines. The algorithm: count islands using DFS/BFS. Use visited matrix. Steps: Start, iterate over cells, if grid[i][j]==1 and not visited, increment count, call DFS to mark all connected cells. End.\n\nWe'll produce lines with \"Step\" and \"Decision\" etc.\n\nEnsure no real code. Provide explanation after each line. Use arrow. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 visited[][] 為 false，islandCount = 0 // 建立已訪問標記與計數器  \n→ Step 2: 建立 directions 陣列表示上下左右四個方向 // 用於鄰域搜尋  \n→ Step 3: 迭代 i 從 0 到 m-1 // 遍歷所有行  \n→     迭代 j 從 0 到 n-1 // 遍歷所有列  \n→         Decision: grid[i][j] == '1' 且 visited[i][j] == false? // 檢查是否為未標記的陸地  \n→             Yes → Step 4: islandCount += 1 // 新島嶼，計數加一  \n→             Yes → Step 5: 呼叫 DFS(i, j) // 以此格為起點遞迴標記整個島嶼  \n→         No → Continue // 若已訪問或為水，跳過  \n→ Step 6: 返回 islandCount // 結果輸出  \nEnd // 程式執行結束  \n\n// 下面為 DFS 虛擬碼  \nDFS(row, col): // 定義 DFS 函式  \n→     visited[row][col] = true // 標記為已訪問  \n→     迭代每個 (dr, dc) 在 directions  \n→         newRow = row + dr  \n→         newCol = col + dc  \n→         Decision: newRow, newCol 在邊界內且 grid[newRow][newCol] == '1' 且 visited[newRow][newCol] == false?  \n→             Yes → DFS(newRow, newCol) // 進一步遞迴  \n→         No → 無操作 // 避免超出邊界或已訪問的格  \n→ End DFS // 結束遞迴",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def numIslands(self, grid):\n        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return\n            if grid[i][j] == '0' or visited[i][j]:\n                return\n            visited[i][j] = True\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    dfs(i, j)\n                    count += 1\n        return count\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 若輸入中包含 \"grid =\"，則取等號後面的部分\n    if '=' in raw_input:\n        _, grid_str = raw_input.split('=', 1)\n    else:\n        grid_str = raw_input\n    # 清除可能的前後空白\n    grid_str = grid_str.strip()\n    # 解析成 Python 資料結構\n    try:\n        grid = ast.literal_eval(grid_str)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    sol = Solution()\n    result = sol.numIslands(grid)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode762.json",
    "problem_index_in_file": 0,
    "title": "Prime Number of Set Bits in Binary Representation",
    "description_snippet": "Given two integers left and right, return the count of numbers in the inclusive range [left, right] ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with comments explaining each line. Use Start, Decision, arrows. For each step: input left/right, iterate from left to right, count set bits, check if prime, increment result. Precompute primes up to 31 maybe. Let's produce. Use Start, then step 1 input, step 2 init result 0, step 3 for i from left to right, step 4 compute setbits, step 5 decision: isPrime? Yes increment result. Step 6 end for, step 7 output result. Need to use arrow and decision with Yes/No. We'll include function to count bits maybe separate step. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入變數 left, right // 讀入區間兩端  \n→ Step 2: 初始化 result = 0 // 用於計數符合條件的數  \n→ Step 3: 準備預先計算的質數集合 primes = {2,3,5,7,11,13,17,19,23,29,31} // 所有可能的 set bits 質數  \n→ Step 4: 迴圈 i 從 left 到 right 包括兩端 // 遍歷區間內所有整數  \n  → Step 5: 計算 i 的 set bits 數 count = CountSetBits(i) // 取得二進制 1 的個數  \n  → Decision: count 是否在 primes 集合中? // 判斷是否為質數  \n    Yes → Step 6: result = result + 1 // 符合條件則累加  \n    No  → // 不符合，直接跳過  \n→ Step 7: 輸出 result // 回傳符合條件的數量  \nEnd // 程式執行結束  \n\n// CountSetBits 函式說明  \nCountSetBits(number) // 取得整數的二進制 1 的個數  \n  → Step a: count = 0  \n  → Step b: while number > 0  \n    → count = count + (number & 1) // 若最低位為 1，加 1  \n    → number = number >> 1 // 右移一位  \n  → Step c: return count  \n// 以上為輔助函式，用於計算 set bits。",
      "generated_code": "import sys\nimport re\n\ndef count_prime_set_bits(left: int, right: int) -> int:\n    \"\"\"\n    計算在區間 [left, right] 內，二進制表示中 1 的個數為質數的整數個數。\n    \"\"\"\n    # 可能出現的質數 set bits 數（0~31 位元的範圍）\n    primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31}\n    count = 0\n    for num in range(left, right + 1):\n        bits = bin(num).count('1')  # 取得 set bits 數\n        if bits in primes:\n            count += 1\n    return count\n\ndef main() -> None:\n    \"\"\"\n    讀取 stdin，解析左、右邊界，計算結果並輸出。\n    \"\"\"\n    data = sys.stdin.read()\n    # 找出所有整數（支援「left = 6, right = 10」等格式）\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return  # 若輸入不足，直接結束\n    left, right = nums[0], nums[1]\n    result = count_prime_set_bits(left, right)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 6, right = 10",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "left = 10, right = 15",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode215.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in an Array",
    "description_snippet": "Given an integer array nums and an integer k, return the k^th largest element in the array.\n\nNote th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solution to find kth largest element in array without sorting. Typical approach: use min-heap of size k, iterate array, push element, if size>k pop smallest. At end heap root is kth largest. Or quickselect algorithm. We'll produce virtual code using min-heap approach. Provide line-by-line virtual code with comments. Use arrow syntax.\n\nLet's produce steps: Start, Step 1: Initialize min-heap of capacity k. Step 2: For each num in nums: push num to heap; if heap size > k pop min. Step 3: After loop, root of heap is kth largest. Step 4: Return root. End.\n\nNeed to include decisions? Not much. But we can include decision to check heap size > k. Also we may need to mention data structures: MinHeap.\n\nLet's craft.\n\nEnsure format: each line: `虛擬碼步驟 // 解釋`. Use arrow `→`. Example: `Start // 程式開始執行`. Provide steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Initialize min-heap H with capacity k // 建立大小為 k 的最小堆\n→ Step 2: For each number x in nums // 逐一處理陣列元素\n    → Decision: If H.size < k? // 判斷堆是否已滿\n        Yes → H.insert(x) // 堆未滿，直接加入\n        No  → H.insert(x) // 堆已滿，先加入\n               Decision: If H.size > k? // 檢查是否超過 k\n                    Yes → H.removeMin() // 移除最小元素，使堆長度回到 k\n                    No  → // 不做任何事\n→ Step 3: kthLargest = H.peek() // 堆頂即為第 k 大元素\n→ Step 4: Return kthLargest // 回傳結果\nEnd // 程式結束\n\nBut we need \"逐行\" meaning each line printed separately. For nested decisions we need indent lines. Provide consistent indentation: maybe use spaces or tabs. Use `→` for each step. Use `Decision:` for decisions. For nested lines, indent with two spaces.\n\nAlso we need to include `Yes →` and `No →`. Provide explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化最小堆 H，容量為 k // 建立一個能容納 k 個元素的最小堆  \n→ Step 2: 遍歷 nums 中的每個元素 x // 逐一處理陣列中的每個數值  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: 如果 H 的大小還小於 k? // 判斷堆是否已經填滿 k 個元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → H.insert(x) // 堆未滿，直接插入元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → H.insert(x) // 堆已滿，先插入再做調整  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decision: 如果 H 的大小大於 k? // 檢查插入後是否超過容量  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → H.removeMin() // 移除最小值，保持堆長度為 k  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 何事不做，已符合條件  \n→ Step 3: kthLargest ← H.peek() // 堆頂即為第 k 大元素  \n→ Step 4: Return kthLargest // 將結果返回給呼叫者  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\nimport ast\nimport heapq\n\nclass Solution:\n    def findKthLargest(self, nums, k):\n        # 建立最小堆，大小為 k\n        heap = nums[:k]\n        heapq.heapify(heap)\n        # 逐一檢視後續元素，若比堆頂大則替換\n        for num in nums[k:]:\n            if num > heap[0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, num)\n        # 堆頂即為第 k 大元素\n        return heap[0]\n\ndef main():\n    # 從標準輸入讀取完整內容\n    data = sys.stdin.read()\n    # 用正則找出 nums 與 k\n    pattern = r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*k\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"輸入格式不符合規範\")\n    nums_str, k_str = match.group(1), match.group(2)\n    nums = ast.literal_eval(nums_str)   # 安全地解析列表\n    k = int(k_str)\n    solution = Solution()\n    result = solution.findKthLargest(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1,5,6,4], k = 2",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode318.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product of Word Lengths",
    "description_snippet": "Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode with explanation. Should cover reading words array, iterate pairs, check common letters, compute product. Use bitmask optimization perhaps. But requirement: generate virtual code with each line having \"虛擬碼步驟 // 解釋\". Use arrows. Should start with Start and End. Also include Decision. Provide step-by-step algorithm. Use bitmask approach maybe.\n\nLet's craft lines.\n\nStart\n→ Step 1: 建立陣列 bitmask 為每個單字對應的 26 位整數 // 將單字字母映射成位元掩碼\n→ Decision: 如果 words 為空? // 判斷輸入是否有效\n    Yes → Step 2: 回傳 0 // 無單字時結果為 0\n    No → Step 3: 進行迴圈處理 // 進入主計算\n→ Step 3: For i from 0 to length(words)-1 // 外層迴圈遍歷單字\n    → Step 4: For j from i+1 to length(words)-1 // 內層迴圈遍歷剩餘單字\n        → Decision: bitmask[i] & bitmask[j] == 0? // 判斷兩單字是否無共同字母\n            Yes → Step 5: 計算 product = length(words[i]) * length(words[j]) // 乘積\n                → Step 6: Update maxProduct if product > maxProduct // 更新最大值\n            No → Step 7: 跳過此對 // 兩單字有重複字母，跳過\n→ Step 8: 回傳 maxProduct // 結果輸出\nEnd\n\nWe also need to include bitmask calculation earlier.\n\nLet's write the code lines accordingly. Ensure each line has arrow format.\n\nStart // 程式開始執行\n→ Step 1: 初始化 maxProduct 為 0 // 用來存儲目前找到的最大乘積\n→ Step 2: 建立空陣列 bitmask // 存放每個單字的 26 位字母位掩碼\n→ Step 3: For each index i, word in words // 轉換每個單字為位掩碼\n    → Step 4: 設置 mask = 0\n    → Step 5: For each character c in word\n        → Step 6: mask = mask OR (1 << (c - 'a')) // 將對應字母位置設為 1\n    → Step 7: bitmask[i] = mask // 存入陣列\n→ Decision: words 為空? // 判斷輸入是否有效\n    Yes → Step 8: 回傳 0 // 無單字時結果為 0\n    No → Step 9: 進行兩兩比較 // 進入主計算\n→ Step 9: For i from 0 to length(words)-1 // 外層迴圈遍歷單字\n    → Step 10: For j from i+1 to length(words)-1 // 內層迴圈遍歷剩餘單字\n        → Decision: bitmask[i] AND bitmask[j] == 0? // 判斷兩單字是否無共同字母\n            Yes → Step 11: product = length(words[i]) * length(words[j]) // 乘積\n                → Step 12: If product > maxProduct, 設置 maxProduct = product // 更新最大值\n            No → Step 13: 跳過此對 // 兩單字有重複字母，跳過\n→ Step 14: 回傳 maxProduct // 結果輸出\nEnd // 程式執行結束\n\nNeed to ensure each line ends with // 解釋. Also need arrow formatting consistent. Use \"→\" preceding each step lines. Ensure step numbers unique.\n\nLet's produce final output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 maxProduct 為 0 // 用來存儲目前找到的最大乘積\n→ Step 2: 建立空陣列 bitmask // 存放每個單字的 26 位字母位掩碼\n→ Step 3: For 每個 index i, word in words // 轉換每個單字為位掩碼\n    → Step 4: 設置 mask = 0\n    → Step 5: For 每個字元 c in word\n        → Step 6: mask = mask OR (1 << (c - 'a')) // 將對應字母位置設為 1\n    → Step 7: bitmask[i] = mask // 存入陣列\n→ Decision: words 為空? // 判斷輸入是否有效\n    Yes → Step 8: 回傳 0 // 無單字時結果為 0\n    No → Step 9: 進行兩兩比較 // 進入主計算\n→ Step 9: For i 從 0 到 length(words)-1 // 外層迴圈遍歷單字\n    → Step 10: For j 從 i+1 到 length(words)-1 // 內層迴圈遍歷剩餘單字\n        → Decision: bitmask[i] AND bitmask[j] == 0? // 判斷兩單字是否無共同字母\n            Yes → Step 11: product = length(words[i]) * length(words[j]) // 乘積\n                → Step 12: If product > maxProduct, 設置 maxProduct = product // 更新最大值\n            No → Step 13: 跳過此對 // 兩單字有重複字母，跳過\n→ Step 14: 回傳 maxProduct // 結果輸出\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProduct(self, words):\n        n = len(words)\n        masks = [0] * n\n        for i, word in enumerate(words):\n            mask = 0\n            for ch in word:\n                mask |= 1 << (ord(ch) - ord('a'))\n            masks[i] = mask\n\n        max_prod = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if masks[i] & masks[j] == 0:\n                    prod = len(words[i]) * len(words[j])\n                    if prod > max_prod:\n                        max_prod = prod\n        return max_prod\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Remove possible variable assignment (e.g., \"words = [...]\")\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    try:\n        words = ast.literal_eval(expr)\n    except Exception:\n        # Fallback: split by commas and strip quotes\n        words = [w.strip().strip('\"\\'') for w in expr.split(',') if w.strip()]\n\n    result = Solution().maxProduct(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        },
        {
          "example_index": 1,
          "input": "words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode698.json",
    "problem_index_in_file": 0,
    "title": "Partition to K Equal Sum Subsets",
    "description_snippet": "Given an integer array nums and an integer k, return true if it is possible to divide this array int...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps, no actual code, just steps. It's a typical partition to k equal sum subsets problem. We need to use Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow arrow \"→\". Must use Start, End. For each line.\n\nWe need to generate algorithm: compute total sum, check divisible by k. Target sum = total/k. Use backtracking: sort array descending to prune. Use visited bitmask. Try to assign numbers to k buckets.\n\nSince it's pseudocode, we can outline recursion function. Use decision steps.\n\nLet's produce step by step.\n\nWe'll structure:\n\nStart // Program start\n→ Step 1: Compute total sum of nums // sum all elements\n→ Decision: If total sum mod k != 0? // check divisibility\n    Yes → Step 2: Return false // cannot partition\n    No  → Step 3: target = total sum / k // desired subset sum\n→ Step 4: Sort nums in descending order // sorting to improve pruning\n→ Step 5: Initialize array used[nums.length] to false // track used elements\n→ Step 6: Define recursive function backtrack(k_remaining, start_index, current_sum) // attempt to fill buckets\n    → Decision: If k_remaining == 1? // only one bucket left\n        Yes → Step 7: Return true // remaining numbers must sum to target\n        No  →\n            → Decision: If current_sum == target? // current bucket completed\n                Yes → Step 8: Return backtrack(k_remaining-1, 0, 0) // start filling next bucket\n                No  →\n                    → Decision: If current_sum > target? // overfilled\n                        Yes → Step 9: Return false\n                        No  →\n                            → Decision: If start_index >= nums.length? // reached end of array\n                                Yes → Step 10: Return false\n                                No  →\n                                    → Decision: If used[start_index]? // skip if already used\n                                        Yes → Step 11: Return backtrack(k_remaining, start_index+1, current_sum) // skip\n                                        No  →\n                                            → Step 12: Mark used[start_index] = true // pick number\n                                            → Step 13: If backtrack(k_remaining, start_index+1, current_sum + nums[start_index]) == true? // try deeper\n                                                Yes → Step 14: Return true // success\n                                                No  →\n                                                    → Step 15: Mark used[start_index] = false // backtrack\n                                                    → Step 16: Return backtrack(k_remaining, start_index+1, current_sum) // try next index\n    End of function\n→ Step 17: Return backtrack(k, 0, 0) // start recursion\nEnd // Program ends\n\nBut need to follow format exactly: each line with \"虛擬碼步驟\" + space + \"// 解釋\". Use arrows \"→\". Must maintain indentation for decisions. Use 'Yes →', 'No →'. Ensure consistent.\n\nLet's produce each line.\n\nAlso need to label lines: Start, End. We'll embed recursion function as lines. Use indentation.\n\nWe must avoid actual code, but still use pseudocode steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: total ← sum(nums) // 計算陣列所有元素的總和\n→ Decision: 如果 total mod k ≠ 0? // 檢查是否能平均分配\n    Yes → Step 2: Return false // 不能分成 k 個等和子集\n    No  → Step 3: target ← total / k // 每個子集需要達到的目標和\n→ Step 4: nums ← sort_descending(nums) // 先將數字降冪排序，以便更快剪枝\n→ Step 5: used ← array_of_false(length(nums)) // 建立一個布林陣列，記錄哪些數已被使用\n→ Step 6: 定義函式 backtrack(k_remaining, idx, curr_sum) // 回溯填充子集\n    → Decision: 如果 k_remaining == 1? // 只剩最後一個子集\n        Yes → Step 7: Return true // 剩下的數一定能凑成 target，直接成功\n        No  →\n            → Decision: 如果 curr_sum == target? // 當前子集已滿\n                Yes → Step 8: Return backtrack(k_remaining-1, 0, 0) // 開始填充下一個子集\n                No  →\n                    → Decision: 如果 curr_sum > target? // 超過目標和\n                        Yes → Step 9: Return false // 無法再添加元素，回溯\n                        No  →\n                            → Decision: 如果 idx >= length(nums)? // 已經檢查完所有元素\n                                Yes → Step 10: Return false // 無法再組合，回溯\n                                No  →\n                                    → Decision: 如果 used[idx]? // 該元素已被使用\n                                        Yes → Step 11: Return backtrack(k_remaining, idx+1, curr_sum) // 跳過此元素\n                                        No  →\n                                            → Step 12: used[idx] ← true // 選取此元素\n                                            → Step 13: 如果 backtrack(k_remaining, idx+1, curr_sum + nums[idx]) == true? // 深入遞歸\n                                                Yes → Step 14: Return true // 成功找到合法組合\n                                                No  →\n                                                    → Step 15: used[idx] ← false // 解除選取，回溯\n                                                    → Step 16: Return backtrack(k_remaining, idx+1, curr_sum) // 嘗試下一個元素\n→ End of backtrack 函式\n→ Step 17: Return backtrack(k, 0, 0) // 從第一個子集開始，從頭遍歷所有數字\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom typing import List\n\nclass Solution:\n    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\n        total = sum(nums)\n        if total % k != 0:\n            return False\n        target = total // k\n        n = len(nums)\n        nums.sort(reverse=True)\n\n        # If the largest number exceeds the target, impossible\n        if nums[0] > target:\n            return False\n\n        memo = {}\n\n        def dfs(used: int, curr_sum: int, k_remaining: int) -> bool:\n            if k_remaining == 0:\n                return True\n            key = (used, curr_sum, k_remaining)\n            if key in memo:\n                return memo[key]\n            for i in range(n):\n                if not (used >> i) & 1 and curr_sum + nums[i] <= target:\n                    next_used = used | (1 << i)\n                    next_sum = curr_sum + nums[i]\n                    next_k_remaining = k_remaining\n                    # When a bucket is filled, move to next bucket\n                    if next_sum == target:\n                        next_k_remaining -= 1\n                        next_sum = 0\n                    if dfs(next_used, next_sum, next_k_remaining):\n                        memo[key] = True\n                        return True\n            memo[key] = False\n            return False\n\n        return dfs(0, 0, k)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Extract nums and k from the input\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not k_match:\n        print(\"false\")\n        sys.exit()\n\n    nums = ast.literal_eval(nums_match.group(1))\n    k = int(k_match.group(1))\n\n    sol = Solution()\n    result = sol.canPartitionKSubsets(nums, k)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,3,5,2,1], k = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode740.json",
    "problem_index_in_file": 0,
    "title": "Delete and Earn",
    "description_snippet": "You are given an integer array nums. You want to maximize the number of points you get by performing...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: \"Delete and Earn\" akin to Leetcode 740. Provide algorithm: count frequencies, sort unique values, dynamic programming with lastTwo and lastOne. Use 64-bit. Provide steps.\n\nWe must output line by line. No actual code, only virtual code steps with explanation. Should include Start, End, Decision. Use arrows.\n\nWe'll produce steps: read array, compute freq map, sort keys, DP. We'll use variables: prev1, prev2, curr. We'll produce decision: if current value == prevVal+1? then take max(prev2+points, prev1) else curr=prev1+points.\n\nAlso handle base case. Provide steps: Step1: Initialize freq, Step2: Sort unique values, Step3: DP loop. End.\n\nLet's produce.\n\nMake sure each line has \"虛擬碼步驟\" plus comment. Use arrow \"→\". Provide indent for decisions.\n\nLet's produce:\n\nStart // 開始\n→ Step 1: 建立空頻率表 freq // 準備儲存每個數值出現次數\n→ Step 2: 對每個 nums[i] in nums → freq[nums[i]] += 1 // 統計頻率\n→ Step 3: 建立 sortedValues 為 freq.keys() 從小到大排序 // 方便 DP\n→ Step 4: 初始化 prev1 = 0, prev2 = 0, lastVal = -1 // DP 兩個前一個值\n→ Decision: 若 sortedValues 为空? // 判斷是否有元素\n    Yes → Step 5: 回傳 0 // 無數值，分數為0\n    No  →  // 進入迴圈\n        → For each val in sortedValues\n            → Step 6: points = val * freq[val] // 可得分\n            → Decision: val == lastVal + 1? // 相鄰數\n                Yes → Step 7: take = prev2 + points // 取 current\n                        Step 8: skip = prev1 // 跳過\n                        Step 9: curr = max(take, skip) // 取較大\n                No  → Step 10: curr = prev1 + points // 非相鄰可加\n            → Step 11: prev2 = prev1 // 更新 prev2\n            → Step 12: prev1 = curr // 更新 prev1\n            → Step 13: lastVal = val // 更新 lastVal\n→ Step 14: 回傳 prev1 // prev1 為最大分數\nEnd // 程式結束\n\nNeed to ensure each line has comment. Provide each line like:\n\nStart // 程式開始\n\n→ Step 1: ...\n\nMake sure each line includes arrow before the step. Provide decision indentations. Provide //.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 建立空頻率表 freq // 準備儲存每個數值出現次數\n→ Step 2: 對每個 nums[i] in nums → freq[nums[i]] += 1 // 統計頻率\n→ Step 3: 建立 sortedValues 為 freq.keys() 從小到大排序 // 方便 DP\n→ Step 4: 初始化 prev1 = 0, prev2 = 0, lastVal = -1 // DP 兩個前一個值\n→ Decision: 若 sortedValues 为空? // 判斷是否有元素\n    Yes → Step 5: 回傳 0 // 無數值，分數為0\n    No  → // 進入迴圈\n        → For each val in sortedValues\n            → Step 6: points = val * freq[val] // 可得分\n            → Decision: val == lastVal + 1? // 相鄰數\n                Yes → Step 7: take = prev2 + points // 取 current\n                        Step 8: skip = prev1 // 跳過\n                        Step 9: curr = max(take, skip) // 取較大\n                No  → Step 10: curr = prev1 + points // 非相鄰可加\n            → Step 11: prev2 = prev1 // 更新 prev2\n            → Step 12: prev1 = curr // 更新 prev1\n            → Step 13: lastVal = val // 更新 lastVal\n→ Step 14: 回傳 prev1 // prev1 為最大分數\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef delete_and_earn(nums):\n    \"\"\"Return maximum points that can be earned from the list `nums`.\"\"\"\n    if not nums:                       # 空列表直接返回 0\n        return 0\n\n    # 統計每個數字出現的頻率\n    count = Counter(nums)\n\n    # 最大值決定 DP 陣列的長度\n    max_val = max(count)\n\n    # dp[i] 表示考慮數字 0..i 時能得到的最大分數\n    dp = [0] * (max_val + 1)\n    dp[0] = 0\n    dp[1] = count.get(1, 0) * 1        # i=1 的特例\n\n    # 逐個從 2 到 max_val 迭代\n    for i in range(2, max_val + 1):\n        # 如果選擇刪除 i，則前一個數 i-1 必須被刪除，從 dp[i-2] 取值\n        take = dp[i - 2] + count.get(i, 0) * i\n        # 或者跳過 i，直接取 dp[i-1]\n        skip = dp[i - 1]\n        dp[i] = max(take, skip)\n\n    return dp[max_val]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，預期是 Python 列表文字表示，例如 \"[3,4,2]\"\n    data = sys.stdin.read().strip()\n    if not data:\n        # 若輸入為空，直接輸出 0\n        print(0)\n    else:\n        # 使用 ast.literal_eval 解析輸入，安全地得到列表\n        nums = ast.literal_eval(data)\n        result = delete_and_earn(nums)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,4,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "[2,2,3,3,3,4]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode66.json",
    "problem_index_in_file": 0,
    "title": "Plus One",
    "description_snippet": "You are given a large integer represented as an integer array digits, where each digits[i] is the it...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for adding one to a big integer represented as array of digits. We'll output step-by-step with arrows. Provide explanation after each line.\n\nWe'll use Start, End, Decision. For loop over digits from last index to first, handle carry. If carry remains after loop, insert 1 at beginning.\n\nLet's craft steps.\n\nStart\n→ Step 1: Set carry = 1 // initial increment\n→ Step 2: Set i = len(digits) - 1 // start from least significant digit\n→ Decision: While i >= 0? // process each digit\n    Yes → Step 3: sum = digits[i] + carry // add carry\n    → Step 4: digits[i] = sum % 10 // store new digit\n    → Step 5: carry = sum // 10 // new carry\n    → Step 6: i = i - 1 // move to next digit\n    No → Decision: carry > 0? // after loop, check carry\n        Yes → Step 7: Insert 1 at front of digits // prepend carry\n        No  → Step 8: // nothing, digits already updated\nEnd\n\nLet's make explanation concise. Ensure format: \"虛擬碼步驟 // 解釋\". Use arrow lines.\n\nWe need to include arrow for each step? According to format, each line must be \"虛擬碼步驟 [空格] // 解釋\". For decision branches, we include lines indented with Yes →, No →.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 carry = 1 // 初始加一的進位  \n→ Step 2: 設定 i = len(digits) - 1 // 從最低有效位開始  \n→ Decision: i >= 0? // 是否還有位數需要處理  \n    Yes → Step 3: sum = digits[i] + carry // 將進位加到當前位  \n    → Step 4: digits[i] = sum % 10 // 更新位數  \n    → Step 5: carry = sum // 10 // 計算新的進位  \n    → Step 6: i = i - 1 // 移動到下一位  \n    No → Decision: carry > 0? // 迴圈結束後是否還有進位  \n        Yes → Step 7: 在 digits 前插入 1 // 進位留在最高位  \n        No → Step 8: // 無需額外處理，結果已更新  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        Increment a big integer represented as a list of digits.\n        \"\"\"\n        # Iterate from the least significant digit to the most significant\n        for i in range(len(digits) - 1, -1, -1):\n            if digits[i] < 9:\n                # If the current digit is not 9, just increment it and finish\n                digits[i] += 1\n                return digits\n            # If the digit is 9, it becomes 0 and we carry over\n            digits[i] = 0\n        # If we exited the loop, all digits were 9 -> result starts with 1\n        return [1] + digits\n\ndef main():\n    # Read the whole input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expected format: \"digits = [1,2,3]\"\n    # Find the part after '=' and parse it as a Python literal\n    try:\n        _, list_part = data.split('=', 1)\n    except ValueError:\n        list_part = data  # If no '=' present, assume raw list\n    digits = ast.literal_eval(list_part.strip())\n    \n    sol = Solution()\n    result = sol.plusOne(digits)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "digits = [1,2,3]",
          "expected_output": "[1,2,4]",
          "success": true,
          "output": "[1, 2, 4]"
        },
        {
          "example_index": 1,
          "input": "digits = [4,3,2,1]",
          "expected_output": "[4,3,2,2]",
          "success": true,
          "output": "[4, 3, 2, 2]"
        },
        {
          "example_index": 2,
          "input": "digits = [9]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode646.json",
    "problem_index_in_file": 0,
    "title": "Maximum Length of Pair Chain",
    "description_snippet": "You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti.\n\nA pair...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for solving longest chain of pairs problem. Use DP or greedy: sort by right, then longest chain similar to LIS. Provide step-by-step virtual code. Let's produce virtual code lines.\n\nWe need to follow format: each line: \"虛擬碼步驟 // 解釋\". Use Start, Decision etc.\n\nLet's design algorithm: Input array pairs. Sort by right ascending. Use dp array of length n. For each i, dp[i] = 1 + max dp[j] where pairs[j].right < pairs[i].left. Or use greedy: maintain end of current chain? But longest chain like LIS by right. We'll do DP.\n\nPseudo:\n\nStart\n→ Step 1: Read pairs array\n→ Step 2: Sort pairs by right value ascending\n→ Step 3: Initialize dp array of size n with 1\n→ Step 4: For i from 0 to n-1\n    → Step 4.1: For j from 0 to i-1\n        → Decision: if pairs[j].right < pairs[i].left\n            → Step 4.1.1: dp[i] = max(dp[i], dp[j] + 1)\n→ Step 5: answer = max(dp)\n→ Step 6: Output answer\nEnd\n\nAdd explanation lines. Use arrow lines. Provide decision indent.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入的 pairs 陣列 // 取得所有的 [left, right] 片段\n→ Step 2: 按 right 升序排序 pairs // 方便之後按右端點進行 DP\n→ Step 3: 建立 dp 陣列，長度為 n，初始值全為 1 // 每個片段至少能成為一長度的鏈\n→ Step 4: 循環遍歷每個片段 i (0 ≤ i < n)\n    → Step 4.1: 循環遍歷前面的片段 j (0 ≤ j < i)\n        → Decision: 若 pairs[j].right < pairs[i].left? // j 可以連接到 i\n            Yes → Step 4.1.1: dp[i] = max(dp[i], dp[j] + 1) // 更新 i 的最大鏈長\n            No  → // j 不能連接，保持 dp[i] 原值\n→ Step 5: 取得 dp 陣列中的最大值 ans // 最長鏈長度\n→ Step 6: 輸出 ans // 給使用者結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLongestChain(self, pairs):\n        # Sort pairs by their right endpoint\n        pairs.sort(key=lambda x: x[1])\n        curr_end = float('-inf')\n        count = 0\n        for left, right in pairs:\n            # If the current pair starts after the previous pair's end, extend the chain\n            if left > curr_end:\n                curr_end = right\n                count += 1\n        return count\n\ndef main():\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(0)\n        return\n\n    # Extract the list from input like \"pairs = [[1,2],[3,4]]\"\n    if raw_input.lower().startswith('pairs'):\n        _, data = raw_input.split('=', 1)\n        raw_input = data.strip()\n\n    try:\n        pairs = ast.literal_eval(raw_input)\n    except Exception:\n        print(0)\n        return\n\n    # Ensure the input is a list of pairs\n    if not isinstance(pairs, list):\n        print(0)\n        return\n\n    solution = Solution()\n    result = solution.findLongestChain(pairs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "pairs = [[1,2],[2,3],[3,4]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "pairs = [[1,2],[7,8],[4,5]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode472.json",
    "problem_index_in_file": 0,
    "title": "Concatenated Words",
    "description_snippet": "Given an array of strings words (without duplicates), return all the concatenated words in the given...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: given array words, no duplicates, find all concatenated words that can be formed by concatenating at least two other words in list. Approach: sort words by length, use a set/dictionary for prefix checks, dynamic programming per word to check if it can be formed by shorter words.\n\nSimplify: Steps: Start, load words, sort, initialize set, result list. For each word in sorted order: check if word can be segmented using DP with set of words seen so far. If yes, add to result; else add to set. End. Provide line-by-line virtual code with arrows and explanation.\n\nWe must not output actual code but pseudo steps: e.g.,\n\nStart // 程式開始執行\n→ Step 1: 將 words 按字串長度升序排序 // 讓較短的字先加入集合\n→ Step 2: 初始化 empty set wordSet // 存放已處理的單字\n→ Step 3: 初始化 empty list result // 存放符合條件的連接字\n\nThen iterate:\n\n→ Decision: 是否還有未處理字? Yes → Step 4: 取下列表首 word // 取得下一個要檢查的字\n\nNow DP function:\n\n→ Step 5: 建立布林陣列 dp[0..len(word)] 並設 dp[0]=true // 代表空字串可拆分\n→ Decision: 迴圈 i from 1 to len(word) // 逐個字元檢查\n    → Step 6: Decision: 如果 dp[i] 已為 true? No → continue? Actually we need nested loops: for i from 1..len, if dp[i] then for j from i+1..len, check substring word[i:j] in wordSet. If yes, set dp[j]=true.\n\nBut we can express simply:\n\n→ Decision: For i in 1..len(word)\n    → Decision: 如果 dp[i] 為 true? Yes → Step 7: For j in i+1..len(word)\n        → Decision: substring = word[i:j] 是否在 wordSet? Yes → Step 8: dp[j] = true\n\nAfter loops:\n\n→ Decision: 如果 dp[len(word)] 為 true 且 word 由至少兩個單字組成? Use count? Instead we can check if dp[len] true and not just word itself. Because wordSet doesn't contain current word, so if dp[len] true, it means segmentation using previous words, which ensures at least one split. But could be whole word? Since word not yet added to set, dp[len] true only if segmentation exists with at least two parts. Good.\n\n→ Decision: 是否 dp[len(word)] 為 true? Yes → Step 9: 將 word 加入 result // 符合條件\n    No → Step 10: 將 word 加入 wordSet // 供後續字使用\n\n→ Step 11: 回到 Decision: 是否還有未處理字? 以此迴圈。\n\n→ End // 完成\n\nBut need to produce line-by-line virtual code with arrow notation. Use \"Decision:\" for if. For loops, we can use \"For i in 1..len\" etc. Provide explanation after //.\n\nAlso need to include the DP step as nested decision loops. Use arrow lines.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 將 words 按字串長度升序排序 // 讓較短的字先加入集合\n→ Step 2: 初始化空集合 wordSet // 存放已處理的單字\n→ Step 3: 初始化空列表 result // 存放符合條件的連接字\n\n→ Decision: 是否還有未處理字? Yes → Step 4: 取出第一個字 word // 取得下一個要檢查的字\n\n→ Step 5: 建立布林陣列 dp[0..len(word)] 並設 dp[0] = true // 代表空字串可拆分\n→ For i from 1 to len(word) // 逐個位置\n    → Decision: 是否 dp[i] 為 true? Yes → For j from i+1 to len(word) // 往後搜尋可分割位置\n        → Decision: substring = word[i:j] 是否在 wordSet? Yes → dp[j] = true // 記錄此位置可拆分\n\n→ Decision: 是否 dp[len(word)] 為 true? Yes → Step 6: 將 word 加入 result // 此字可由至少兩個較短字串組成\n    No  → Step 7: 將 word 加入 wordSet // 此字無法拆分，將其加入集合供後續使用\n\n→ Step 8: 回到 Decision: 是否還有未處理字? // 迴圈繼續\n\nEnd // 程式執行結束\n\nWe need to ensure each line has \"虛擬碼步驟\" then space then \"// 解釋\".\n\nAlso arrow indent: Use \"→\" for next step, and \"Decision:\" lines with indentation maybe. We'll include \"→\" for each new line. Use \"Decision:\" lines for condition.\n\nWe need to ensure each line includes the step content and explanation. Use Chinese. Provide final output exactly as specified.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 words 按字串長度升序排序 // 讓較短的字先加入集合  \n→ Step 2: 初始化空集合 wordSet // 存放已處理的單字  \n→ Step 3: 初始化空列表 result // 存放符合條件的連接字  \n\n→ Decision: 是否還有未處理字?  \n Yes → Step 4: 取出第一個字 word // 取得下一個要檢查的字  \n\n→ Step 5: 建立布林陣列 dp[0..len(word)] 並設 dp[0] = true // 代表空字串可拆分  \n→ For i from 1 to len(word) // 逐個位置  \n  Decision: 是否 dp[i] 為 true?  \n   Yes → For j from i+1 to len(word) // 往後搜尋可分割位置  \n    Decision: substring = word[i:j] 是否在 wordSet?  \n     Yes → dp[j] = true // 記錄此位置可拆分  \n\n→ Decision: 是否 dp[len(word)] 為 true?  \n Yes → Step 6: 將 word 加入 result // 此字可由至少兩個較短字串組成  \n No → Step 7: 將 word 加入 wordSet // 此字無法拆分，將其加入集合供後續使用  \n\n→ Step 8: 回到 Decision: 是否還有未處理字? // 迴圈繼續  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        words.sort(key=len)\n        word_set = set()\n        res = []\n        for w in words:\n            if not w:  # skip empty strings\n                continue\n            if self._can_form(w, word_set):\n                res.append(w)\n            word_set.add(w)\n        return res\n\n    def _can_form(self, word, word_set):\n        dp = [False] * (len(word) + 1)\n        dp[0] = True\n        for i in range(1, len(word) + 1):\n            for j in range(0, i):\n                if not dp[j]:\n                    continue\n                if word[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(word)]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Extract the list literal from the input string\n    try:\n        start = data.index('[')\n        end = data.rindex(']') + 1\n        list_str = data[start:end]\n        words = ast.literal_eval(list_str)\n    except (ValueError, SyntaxError):\n        words = []\n\n    sol = Solution()\n    result = sol.findAllConcatenatedWordsInADict(words)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      \"['dogcatsdog', 'catsdogcats', 'ratcatdogcat']\""
        },
        {
          "example_index": 1,
          "input": "words = [\"cat\",\"dog\",\"catdog\"]",
          "expected_output": "[\"catdog\"]",
          "success": true,
          "output": "['catdog']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode341.json",
    "problem_index_in_file": 0,
    "title": "Flatten Nested List Iterator",
    "description_snippet": "You are given a nested list of integers nestedList. Each element is either an integer or a list whos...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that implements NestedIterator class with constructor, next, hasNext. Provide steps in pseudocode style, with arrow structure, no actual code, just steps. We need to output line by line with \"虛擬碼步驟\" then space then \"// 解釋/說明\". Use arrows and decisions. For example:\n\nStart // program begins\n→ Step 1: 定義 NestedIterator 類別 // define class\n→ Step 2: 初始化空棧 // initialize stack\n→ Step 3: 將 nestedList 逆序壓入棧 // push elements in reverse\n→ Decision: 是否有剩餘? // check if stack not empty\n...\n\nWe need to cover constructor, next, hasNext. Also the process of flattening.\n\nWe'll produce structure like:\n\nStart // 程式開始執行\n→ Step 1: 定義 NestedIterator 類別 // 定義迭代器類別\n    → Step 2: 建構子 NestedIterator(nestedList) // 初始化\n        → Step 3: 建立空棧 stack // 用於保存待處理元素\n        → Step 4: 逆序遍歷 nestedList 並推入棧 // 保持正確順序\n→ Step 5: 定義 next() 方法 // 返回下一個整數\n        → Decision: 需要檢查並展開棧頂 // 確保棧頂是整數\n            Yes → Step 6: 從棧頂彈出整數並返回 // 取得整數\n            No  → Step 7: 從棧頂彈出列表並推入其元素（逆序） // 展開列表\n                → 回到 Decision\n→ Step 8: 定義 hasNext() 方法 // 判斷是否還有元素\n        → Decision: 棧是否非空? // 有元素就返回 true\n            Yes → Step 9: Return true\n            No  → Step 10: Return false\nEnd // 程式執行結束\n\nBut we need to show that next() will call hasNext() logic to flatten. Could integrate.\n\nWe can produce steps for constructor, hasNext, next.\n\nLet's produce detailed virtual steps.\n\nUse arrows: → Step ... // explanation\n\nAlso decisions: Decision: if ...? // explanation\n\nWe'll produce each line with virtual code step, space, // explanation.\n\nAlso we might include \"Start\", \"End\".\n\nLet's craft the final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 NestedIterator 類別 // 建立一個用於展開嵌套列表的迭代器  \n  → Step 2: 建構子 NestedIterator(nestedList) // 接收原始的嵌套列表  \n    → Step 3: 建立空棧 stack // 用來存放待處理的元素  \n    → Step 4: 逆序遍歷 nestedList 並將每個元素 push 到 stack // 逆序入棧確保後彈出時順序正確  \n→ Step 5: 定義 hasNext() 方法 // 判斷是否還有剩餘整數可讀取  \n   → Decision: stack 是否為空？ // 若棧非空則可能還有元素  \n    Yes → Step 6: Return true // 有剩餘元素，返回真  \n    No  → Step 7: Return false // 棧空，返回假  \n→ Step 8: 定義 next() 方法 // 取得並返回下一個整數  \n   → Decision: stack 是否為空？ // 必須先確保有元素  \n    Yes → Step 9: 執行 while 循環展開棧頂直到頂部是整數  \n       → Step 9.1: 重複以下操作直到 stack.top() 為整數  \n         → Step 9.1.1: pop element = stack.pop() // 取出棧頂  \n           Decision: element 是整數？ // 判斷型別  \n            Yes → Step 9.1.2: push element back onto stack // 若是整數先重新推回以保留順序  \n            No  → Step 9.1.3: 取得 element 內部的列表 list // 取出子列表  \n              → Step 9.1.3.1: 逆序遍歷 list 並將每個子元素 push 到 stack // 展開子列表  \n              → 回到 Step 9.1.1  \n         → Decision: stack.top() 為整數？ // 重新檢查棧頂  \n           Yes → Step 9.2: pop 整數並 return // 取得最終整數  \n           No  → 回到 Step 9.1  \n         → Step 9.3: 如果棧已空則拋出錯誤 // 表示不應該在此情況呼叫 next()  \n        → Step 9.4: 返回彈出的整數 // 返回下一個值  \n       → Decision: stack 為空？ // 若棧空則不應進入此分支  \n         No → Step 9.5: 呼叫 hasNext() 以展開必要元素後再次執行 Step 9.2  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass NestedIterator:\n    def __init__(self, nestedList):\n        # 使用逆序列表作為棧，方便 pop 取得正確順序\n        self.stack = list(reversed(nestedList))\n\n    def hasNext(self):\n        # 確保棧頂為整數；若不是，展開該子列表\n        while self.stack:\n            top = self.stack[-1]\n            if isinstance(top, int):\n                return True\n            # 把列表展開，逆序壓入棧\n            self.stack.pop()\n            self.stack.extend(reversed(top))\n        return False\n\n    def next(self):\n        # 必須先確保有下一個整數\n        if not self.hasNext():\n            raise StopIteration(\"No more elements\")\n        return self.stack.pop()\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析輸入，例如 \"nestedList = [[1,1],2,[1,1]]\"\n    if '=' in raw_input:\n        _, expr = raw_input.split('=', 1)\n        nested_str = expr.strip()\n    else:\n        nested_str = raw_input\n\n    # 使用 ast.literal_eval 以安全方式評估表達式\n    try:\n        nested_list = ast.literal_eval(nested_str)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    iterator = NestedIterator(nested_list)\n    result = []\n    while iterator.hasNext():\n        result.append(iterator.next())\n\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nestedList = [[1,1],2,[1,1]]",
          "expected_output": "[1,1,2,1,1]",
          "success": true,
          "output": "[1, 1, 2, 1, 1]"
        },
        {
          "example_index": 1,
          "input": "nestedList = [1,[4,[6]]]",
          "expected_output": "[1,4,6]",
          "success": true,
          "output": "[1, 4, 6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode485.json",
    "problem_index_in_file": 0,
    "title": "Max Consecutive Ones",
    "description_snippet": "Given a binary array nums, return the maximum number of consecutive 1's in the array....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for the algorithm that finds max consecutive 1's in binary array. Must be line by line with explanation. Use virtual code steps with arrows, decisions. Provide for each line. Should follow format: \"Start // 程式開始執行\". Then \"→ Step 1: ...\" etc. Let's design algorithm:\n\n- Start\n- Step 1: Initialize maxCount = 0, currentCount = 0\n- Step 2: For each element num in nums:\n    - Decision: if num == 1?\n        Yes → Step 3: currentCount += 1\n        No  → Step 4: maxCount = max(maxCount, currentCount); currentCount = 0\n- After loop, Decision: currentCount > maxCount? -> update\n- End\n\nWe need to output each line. The loop lines should be represented as steps too. Use \"→ Step 2: For each num in nums:\" then arrow decisions inside. Use \"→ Decision:\" etc.\n\nLet's craft.\n\nWe'll number steps? Not necessary but \"Step X\". Provide explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 maxCount = 0, currentCount = 0 // 設定最大連續 1 的計數與目前連續 1 的計數  \n→ Step 2: 對陣列 nums 中每個元素 num 做以下處理 // 開始遍歷整個二元陣列  \n    → Decision: 若 num 為 1? // 判斷目前元素是否為 1  \n        Yes → Step 3: currentCount += 1 // 若是 1，累加目前連續 1 的計數  \n        No  → Step 4: maxCount = max(maxCount, currentCount); currentCount = 0 // 若不是 1，更新最大值並重置目前計數  \n→ Step 5: 遍歷結束後 // 迴圈完成，仍可能有連續 1 未被更新  \n    → Decision: 若 currentCount > maxCount? // 檢查最後一段連續 1 是否為最大  \n        Yes → Step 6: maxCount = currentCount // 若是，更新最大值  \n        No  → // 無需更新，最大值已正確  \n→ Step 7: 回傳 maxCount // 回傳最長的連續 1 的數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"Return the maximum number of consecutive 1's in a binary list.\"\"\"\n        max_count = 0\n        count = 0\n        for num in nums:\n            if num == 1:\n                count += 1\n                if count > max_count:\n                    max_count = count\n            else:\n                count = 0\n        return max_count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 如果輸入像是 \"nums = [1,1,0,1,1,1]\"，去掉變數名並解析列表\n    if \"=\" in data:\n        _, expr = data.split(\"=\", 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        # 若無法解析，則直接嘗試 eval\n        nums = eval(expr)\n\n    solution = Solution()\n    result = solution.findMaxConsecutiveOnes(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,0,1,1,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode453.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: given array, min moves to equalize using moves that increment n-1 elements by 1. Equivalent to decrement one element by 1 each move. So answer is sum(nums) - n*min(nums). We'll provide virtual code algorithm.\n\nWe need to output line by line: Start, steps, decisions etc. No actual code. Provide brief explanation after each line. Use arrows and decision statements. Provide algorithm steps: input array, compute min, compute sum, compute result, output result, End. Also need to consider if array empty? but n>0.\n\nLet's craft.\n\nStart\n→ Step 1: Input array nums of size n // 取得輸入陣列\n→ Step 2: 計算最小值 minVal = min(nums) // 找出陣列最小值\n→ Step 3: 計算總和 totalSum = sum(nums) // 求陣列所有元素之和\n→ Step 4: 計算最小移動數 moves = totalSum - n * minVal // 依公式算出最小移動步數\n→ Step 5: 輸出 moves // 顯示結果\nEnd\n\nBut we need decision? Not really. Could add decision for n==0? Might not needed. But we can include decision: If n==0? then output 0. Might be safe.\n\nLet's include:\n\n→ Decision: n == 0? // 檢查陣列是否為空\n    Yes → Step 5: 輸出 0 // 空陣列不需要移動\n    No  → (continue steps 2-5)\n\nBut if we want step numbers consistent. We'll incorporate.\n\nAlso ensure each line ends with // explanation.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數陣列 nums 以及其大小 n // 從使用者處取得陣列與長度  \n→ Decision: n == 0? // 檢查陣列是否為空  \n  Yes → Step 5: 輸出 0 // 空陣列不需要任何移動  \n  No  → // 進入後續計算流程  \n→ Step 2: 計算 minVal = min(nums) // 找出陣列中最小的數字  \n→ Step 3: 計算 totalSum = sum(nums) // 求陣列所有元素的總和  \n→ Step 4: 計算 moves = totalSum - n * minVal // 依題目公式得到最小移動步數  \n→ Step 5: 輸出 moves // 顯示答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef min_moves(nums):\n    \"\"\"Return the minimum number of moves to equalize the array.\"\"\"\n    return sum(nums) - min(nums) * len(nums)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Try to parse the input; it may be in the form \"nums = [1,2,3]\"\n    try:\n        if \"nums\" in data:\n            _, expr = data.split(\"=\", 1)\n            nums = ast.literal_eval(expr.strip())\n        else:\n            nums = ast.literal_eval(data)\n    except Exception:\n        # Fallback: assume space-separated integers\n        nums = [int(x) for x in data.split()]\n\n    result = min_moves(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode225.json",
    "problem_index_in_file": 0,
    "title": "Implement Stack using Queues",
    "description_snippet": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should suppo...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing LIFO stack using two queues. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Decision, etc. We need to outline the class MyStack with push, pop, top, empty. Use two queues: q1 and q2. Approach: push by enqueuing to q1. For pop, move all but last element from q1 to q2, then dequeue last element from q1 as result, then swap q1 and q2. For top, similar but instead of discarding last, peek it. But to avoid duplication we can implement pop that returns value. Top can call pop then push back? But simpler: in top, do same as pop but keep last and re-enqueue it to q2. After operation, swap q1 and q2.\n\nLet's outline virtual steps. We'll start with Start, then initialize queues, then each method's steps. Use Decision structures for checking empty. Use loops maybe represented generically.\n\nWe need to not output actual code but pseudocode lines with explanation. Use arrows.\n\nWe will show flow: Start, Initialize q1,q2 empty. Then method push: q1.enqueue(x). etc.\n\nFor pop: If empty -> return null? But we can show Decision: If empty? No -> return error. else -> loop while size(q1)>1: q2.enqueue(q1.dequeue()). Then last = q1.dequeue(). Then swap q1,q2. Return last.\n\nTop similar: same loop, but store last and re-enqueue it into q2 after loop? Actually after loop, last = q1.dequeue(); then q2.enqueue(last) to keep it. Then swap q1,q2; return last.\n\nEmpty: return q1.isEmpty() && q2.isEmpty().\n\nLet's produce virtual steps. We'll denote loops with \"While\" but keep arrow. Might show \"While q1.size() > 1 → ...\".\n\nWe need to adhere to format: each line \"虛擬碼步驟 // 解釋\". Use \"→\" arrow. Use \"Decision:\" with Yes→, No→.\n\nLet's write. We'll start with \"Start\". Then initialize. Then method definitions. We'll separate methods. We'll use indentation for substeps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個空佇列 q1, q2 // 用來儲存堆疊元素  \n\n// -------------------- push 方法 --------------------\n→ Step 2: 方法 push(x) // 新增元素到堆疊頂部  \n→     q1.enqueue(x) // 直接把元素加入 q1 的尾部  \n\n// -------------------- pop 方法 --------------------\n→ Step 3: 方法 pop() // 移除並返回堆疊頂部元素  \n→     Decision: q1.isEmpty() 且 q2.isEmpty()? // 判斷堆疊是否為空  \n        Yes → Return null // 空堆疊時返回空值  \n        No  →  \n            → Step 4: While q1.size() > 1 → // 移動除最後一個外的所有元素  \n                →     q2.enqueue(q1.dequeue()) // 從 q1 前端移除並加入 q2  \n            → Step 5: topElement ← q1.dequeue() // 取得堆疊頂部元素  \n            → Step 6: Swap(q1, q2) // 交換兩個佇列，恢復為原來的 q1  \n            → Return topElement // 回傳被移除的元素  \n\n// -------------------- top 方法 --------------------\n→ Step 7: 方法 top() // 取得堆疊頂部元素但不移除  \n→     Decision: q1.isEmpty() 且 q2.isEmpty()?  \n        Yes → Return null  \n        No  →  \n            → Step 8: While q1.size() > 1 → // 與 pop 類似移動元素  \n                →     q2.enqueue(q1.dequeue())  \n            → Step 9: topElement ← q1.dequeue() // 取得頂部元素  \n            → Step 10: q2.enqueue(topElement) // 再把它放回 q2  \n            → Step 11: Swap(q1, q2) // 交換佇列  \n            → Return topElement // 回傳頂部值  \n\n// -------------------- empty 方法 --------------------\n→ Step 12: 方法 empty() // 判斷堆疊是否為空  \n→     Return q1.isEmpty() AND q2.isEmpty() // 若兩佇列皆空，堆疊為空  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        # 把新元素放到 q1 的尾部\n        self.q1.append(x)\n\n    def pop(self) -> int:\n        # 若兩個佇列都為空，直接拋出錯誤\n        if not self.q1 and not self.q2:\n            raise IndexError(\"pop from empty stack\")\n        # 把 q1 中除最後一個外的元素都轉移到 q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # 取出頂部元素\n        top_elem = self.q1.popleft()\n        # 交換兩個佇列，恢復原始結構\n        self.q1, self.q2 = self.q2, self.q1\n        return top_elem\n\n    def top(self) -> int:\n        if not self.q1 and not self.q2:\n            raise IndexError(\"top from empty stack\")\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top_elem = self.q1.popleft()\n        # 再把頂部元素放回 q2，保持堆疊不變\n        self.q2.append(top_elem)\n        self.q1, self.q2 = self.q2, self.q1\n        return top_elem\n\n    def empty(self) -> bool:\n        return not self.q1 and not self.q2\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 去除可能的前導文字，例如 \"Input \"\n    if data.startswith(\"Input\"):\n        data = data[5:].strip()\n    # 轉成合法的 Python 兩個列表的元組\n    try:\n        data_tuple = ast.literal_eval(\"(\" + data + \")\")\n    except Exception:\n        # 如果解析失敗，直接結束\n        return\n    commands, arguments = data_tuple\n    stack = None\n    result = []\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"MyStack\":\n            stack = MyStack()\n            result.append(None)\n        elif cmd == \"push\":\n            stack.push(arg[0])\n            result.append(None)\n        elif cmd == \"pop\":\n            result.append(stack.pop())\n        elif cmd == \"top\":\n            result.append(stack.top())\n        elif cmd == \"empty\":\n            result.append(stack.empty())\n    # 輸出結果\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,2,2,false]'\nGot (Norm):      '[None,None,None,2,2,False]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 2, 2, false]'\nRaw Got:      '[None, None, None, 2, 2, False]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode279.json",
    "problem_index_in_file": 0,
    "title": "Perfect Squares",
    "description_snippet": "Given an integer n, return the least number of perfect square numbers that sum to n.\n\nA perfect squa...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode (virtual code) line by line with explanations. The task: Given integer n, return the least number of perfect squares summing to n. This is classic problem \"Perfect Squares\" Leetcode 279. Approach: dynamic programming or BFS. Use DP: dp[0]=0; for i 1..n: dp[i]=min(dp[i-j*j]+1 for j such that j*j<=i). Return dp[n].\n\nWe need to produce pseudocode lines: Start, → Step etc.\n\nWe need to follow the format: Each line: \"虛擬碼步驟 [space] // 解釋\". Use arrows. Use Decision, Yes→, No→.\n\nWe'll produce stepwise: Start, initialize array dp length n+1 with large values, dp[0]=0, for i from 1 to n: inner loop j from 1 to floor(sqrt(i)), compute square, update dp[i], etc. Then output dp[n]. End.\n\nLet's produce pseudocode with lines:\n\nStart // 開始執行\n→ Step 1: 初始化 dp[0…n] 為無窮大 // 建立 dp 陣列\n→ Step 2: dp[0] ← 0 // 0 需要 0 個平方數\n→ Step 3: for i ← 1 to n do // 遍歷所有目標數字\n→ Decision: i 是否小於等於 n? // 確認範圍（實際 always true）\n→ Step 4: dp[i] ← 無窮大 // 將 dp[i] 設為初始大值\n→ Step 5: for j ← 1 to ⌊√i⌋ do // 試所有平方根\n→ Decision: j^2 是否小於等於 i? // 檢查平方是否不超過 i\n→ Step 6: square ← j^2 // 計算平方值\n→ Step 7: candidate ← dp[i - square] + 1 // 用一個平方數減去\n→ Decision: candidate < dp[i] ? // 是否更小\n→ Yes → Step 8: dp[i] ← candidate // 更新 dp[i]\n→ No → // 保持 dp[i] 不變\n→ End for // j 迴圈結束\n→ End for // i 迴圈結束\n→ Step 9: return dp[n] // 回傳最小個數\nEnd // 程式結束\n\nWe can condense decisions. We should maintain format: Decision lines then indented Yes → Step, No → Step. For the loops, we can just write \"for\" lines. Use arrows.\n\nWe need to follow the example format: Use \"→\" before each step. For Decision: indent the Yes/No lines with leading spaces and \"→\". The example shows \"Decision: 如果數字大於 0?\" then \"Yes → Step 2: ...\" etc.\n\nLet's follow similar.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 dp[0…n] 為無窮大 // 建立 dp 陣列\n→ Step 2: dp[0] ← 0 // 0 需要 0 個平方數\n→ Step 3: for i ← 1 to n do // 遍歷所有目標數字\n    → Decision: i ≤ n? // 確保在範圍內\n        Yes → Step 4: dp[i] ← 無窮大 // 將 dp[i] 設為初始大值\n        No  → // 不會發生\n    → Step 5: for j ← 1 to ⌊√i⌋ do // 試所有平方根\n        → Decision: j^2 ≤ i? // 檢查平方是否不超過 i\n            Yes → Step 6: square ← j^2 // 計算平方值\n                 → Step 7: candidate ← dp[i - square] + 1 // 用一個平方數減去\n                 → Decision: candidate < dp[i] ?\n                    Yes → Step 8: dp[i] ← candidate // 更新 dp[i]\n                    No  → // 保持 dp[i] 不變\n            No  → // 不會發生\n    → End for // j 迴圈結束\n→ End for // i 迴圈結束\n→ Step 9: return dp[n] // 回傳最小個數\nEnd // 程式執行結束\n\nWe need to ensure formatting: Each line: \"虛擬碼步驟 [space] // 解釋\". So include space after step code. Indentation maybe not required. Use arrows properly.\n\nBetter to format as:\n\nStart // 程式開始執行\n→ Step 1: 初始化 dp[0…n] 為無窮大 // 建立 dp 陣列\n→ Step 2: dp[0] ← 0 // 0 需要 0 個平方數\n→ Step 3: for i ← 1 to n do // 遍歷所有目標數字\n→ Decision: i ≤ n? // 確保在範圍內\n    Yes → Step 4: dp[i] ← 無窮大 // 將 dp[i] 設為初始大值\n    No  → // 不會發生\n→ Step 5: for j ← 1 to ⌊√i⌋ do // 試所有平方根\n→ Decision: j^2 ≤ i? // 檢查平方是否不超過 i\n    Yes → Step 6: square ← j^2 // 計算平方值\n        → Step 7: candidate ← dp[i - square] + 1 // 用一個平方數減去\n        → Decision: candidate < dp[i] ?\n            Yes → Step 8: dp[i] ← candidate // 更新 dp[i]\n            No  → // 保持 dp[i] 不變\n    No  → // 不會發生\n→ End for // j 迴圈結束\n→ End for // i 迴圈結束\n→ Step 9: return dp[n] // 回傳最小個數\nEnd // 程式執行結束\n\nBut the example had arrow before Decision line. We should maintain the arrow for Decision. So maybe:\n\n→ Decision: i ≤ n? // 確保在範圍內\n    Yes → Step 4: dp[i] ← 無窮大 // ...\n    No  → // ...\n\nAlso, we should keep indentation consistent. But the problem says: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)。\" So we should follow that.\n\nAlso, we may not need to include a Decision for i ≤ n? since we know it always true. But we can skip that. Let's produce a cleaner version:\n\nStart // 程式開始執行\n→ Step 1: 初始化 dp[0…n] 為無窮大 // 建立 dp 陣列\n→ Step 2: dp[0] ← 0 // 0 需要 0 個平方數\n→ Step 3: for i ← 1 to n do // 遍歷所有目標數字\n    → Step 4: dp[i] ← 無窮大 // 將 dp[i] 設為初始大值\n    → Step 5: for j ← 1 to ⌊√i⌋ do // 試所有平方根\n        → Step 6: square ← j^2 // 計算平方值\n        → Step 7: candidate ← dp[i - square] + 1 // 用一個平方數減去\n        → Decision: candidate < dp[i] ?\n            Yes → Step 8: dp[i] ← candidate // 更新 dp[i]\n            No  → // 保持 dp[i] 不變\n    → End for // j 迴圈結束\n→ End for // i 迴圈結束\n→ Step 9: return dp[n] // 回傳最小個數\nEnd // 程式執行結束\n\nBut we need to add // at end of each line. Let's produce final answer accordingly.\n\nMake sure each line contains \"虛擬碼步驟\" plus space then // explanation. So format: \"Start // 程式開始執行\" etc.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 dp[0…n] 為無窮大 // 建立 dp 陣列，為每個數字準備最小平方數個數  \n→ Step 2: dp[0] ← 0 // 0 需要 0 個平方數  \n→ Step 3: for i ← 1 to n do // 遍歷所有目標數字  \n → Step 4: dp[i] ← 無窮大 // 將 dp[i] 設為初始大值，等待更新  \n → Step 5: for j ← 1 to ⌊√i⌋ do // 試所有平方根 j  \n  → Step 6: square ← j^2 // 計算平方值  \n  → Step 7: candidate ← dp[i - square] + 1 // 用一個平方數減去後的剩餘需要  \n  → Decision: candidate < dp[i] ? // 是否更少  \n   Yes → Step 8: dp[i] ← candidate // 更新 dp[i] 為更小值  \n   No  → // 保持 dp[i] 不變  \n → End for // j 迴圈結束  \n→ End for // i 迴圈結束  \n→ Step 9: return dp[n] // 回傳最小平方數個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport math\n\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        \"\"\"\n        Return the least number of perfect square numbers that sum to n.\n        \"\"\"\n        # dp[i] = minimum number of perfect squares summing to i\n        dp = [math.inf] * (n + 1)\n        dp[0] = 0\n\n        for i in range(1, n + 1):\n            j = 1\n            while j * j <= i:\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\n                j += 1\n        return int(dp[n])\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Extract the first integer found in the input\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        sys.exit()\n    n = int(nums[0])\n\n    # Compute and output the result\n    sol = Solution()\n    result = sol.numSquares(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 13",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode330.json",
    "problem_index_in_file": 0,
    "title": "Patching Array",
    "description_snippet": "Given a sorted integer array nums and an integer n, add/patch elements to the array such that any nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Let's design algorithm: greedy using reachable range. Standard patching problem.\n\nPseudo: start with reach=1 (smallest missing). iterate through nums while reach <= n. If current num <= reach: extend reach += num. else patch reach: add reach, patch_count++, reach+=reach. Continue.\n\nImplementation details: use index pointer i. While reach <= n: if i < len(nums) and nums[i] <= reach: reach += nums[i]; i++ else: reach += reach; patches++.\n\nReturn patches.\n\nWe need to produce steps line by line with arrow syntax.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize index i = 0, patches = 0, reach = 1 // set up variables\n→ Decision: while reach <= n? // loop condition\n    Yes → Decision: if i < len(nums) and nums[i] <= reach? // check if current element can extend range\n        Yes → Step 2: reach = reach + nums[i]; i = i + 1 // use existing element\n        No  → Step 3: reach = reach + reach; patches = patches + 1 // patch the missing value\n    No  → End // exit loop\n→ Step 4: Return patches // output result\n\nWe should output each step line with arrow, and comments.\n\nEnsure each line ends with // explanation. Use \"→\" arrow preceding each step after decision.\n\nWe need to maintain indentation? Example format: they used indentation for nested decisions. We'll mimic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← 0, patches ← 0, reach ← 1 // 初始化索引、補丁數量與可達最大值  \n→ Decision: 只要 reach ≤ n? // 判斷是否已覆蓋所有 1~n 的數值  \n    Yes → Decision: 若 i < len(nums) 且 nums[i] ≤ reach? // 檢查現有數字能否延伸可達範圍  \n        Yes → Step 2: reach ← reach + nums[i]; i ← i + 1 // 使用當前數字，擴充範圍  \n        No  → Step 3: reach ← reach + reach; patches ← patches + 1 // 補上缺失的最小數值，並計數  \n    No  → End // 已達到或超過 n，結束循環  \n→ Step 4: Return patches // 回傳所需的最小補丁數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minPatches(self, nums, n):\n        patches = 0\n        miss = 1\n        i = 0\n        while miss <= n:\n            if i < len(nums) and nums[i] <= miss:\n                miss += nums[i]\n                i += 1\n            else:\n                miss += miss\n                patches += 1\n        return patches\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入格式:\n        nums = [1,3], n = 6\n    \"\"\"\n    pattern = r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*n\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data, re.S)\n    if not match:\n        raise ValueError(\"輸入格式不符合預期\")\n    nums_str, n_str = match.groups()\n    nums = eval(nums_str)  # 只在受控環境下使用 eval，輸入已被正則表達式過濾\n    n = int(n_str)\n    return nums, n\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums, n = parse_input(input_data)\n    result = Solution().minPatches(nums, n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3], n = 6",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,10], n = 20",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,2], n = 5",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode210.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule II",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for topological sorting of prerequisites graph. Steps: build graph, indegree array, queue, BFS/DFS Kahn's algorithm. Return order or empty.\n\nWe produce line-by-line virtual code with arrows and decision.\n\nWe must not produce actual code but pseudo-code steps. Provide each line like \"→ Step X: Build adjacency list\" etc.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化圖形 adjacency list 與 indegree 陣列\n→ Step 2: 對每個 [a,b] 在 prerequisites 內，將 b 加入 a 的前驅? Wait direction: to take a, need b first, so edge b->a? Typically prerequisites[i] = [a,b] means b before a: edge b->a. So adjacency list from b to a, indegree[a]++.\n→ Step 3: 初始化 queue 為所有 indegree == 0 的課程\n→ Decision: 如果 queue 不是空? Actually we process all nodes\n→ Step 4: 迴圈 while queue not empty: pop u; add u 到 order; for each v in adjacency[u]: indegree[v]--; if indegree[v]==0 push v\n→ Decision: 是否所有課程已處理? i.e., order length == numCourses\n   Yes → Step 5: 回傳 order\n   No  → Step 6: 回傳空陣列\n\nAdd End.\n\nWe need arrow formatting: use Start, End, Decision. Provide each line with explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的 adjacency list 與 indegree 陣列，長度為 numCourses // 初始化圖形結構  \n→ Step 2: 對每個 pair [a, b] 在 prerequisites 內  \n  → Decision: 是否已將 b 加入 a 的前驅? // 判斷是否需要新增邊  \n   Yes → // 已處理，跳過  \n   No →  \n     → Step 3: 在 adjacency[b] 中加入 a，並將 indegree[a] 加 1 // 建立邊 b → a，更新入度  \n→ Step 4: 建立一個 queue，加入所有 indegree 為 0 的課程 // 找到可立即開始的課程  \n→ Step 5: 建立空的 order 陣列 // 儲存最終課程順序  \n→ Step 6: while queue 不為空  \n  → Step 7: 取出 queue 的前端節點 u，並將 u 加入 order // 處理一門課  \n  → Step 8: 對於每個 v 在 adjacency[u] 中  \n    → Step 9: indegree[v] 減 1 // 檢查 v 的剩餘前驅  \n    → Decision: 是否 indegree[v] 等於 0? // 判斷 v 是否已無剩餘前驅  \n     Yes → → Step 10: 將 v 加入 queue // 可以開始學習 v  \n     No  → // v 仍有未完成的前驅，等待  \n→ Decision: 是否所有課程已處理? // 檢查是否可完成所有課程  \n  Yes → → Step 11: 回傳 order // 成功得到一個合法的課程順序  \n  No  → → Step 12: 回傳空陣列 // 無法完成所有課程，返回空結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: list[list[int]]) -> list[int]:\n        \"\"\"Return a valid ordering of courses using Kahn's algorithm.\"\"\"\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # Build graph and indegree count\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # Initialize queue with courses having no prerequisites\n        queue = deque([i for i, deg in enumerate(indegree) if deg == 0])\n        order = []\n\n        # Process courses in topological order\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # If all courses are processed, return the order; otherwise, impossible\n        return order if len(order) == numCourses else []\n\ndef main() -> None:\n    \"\"\"Read input from stdin, compute course order, and print the result.\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        return\n\n    # Extract numCourses and prerequisites using regular expressions\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    pre_match = re.search(r'prerequisites\\s*=\\s*(\\[.*\\])', data)\n\n    if not num_match or not pre_match:\n        print(\"[]\")\n        return\n\n    numCourses = int(num_match.group(1))\n    prerequisites = ast.literal_eval(pre_match.group(1))\n\n    solution = Solution()\n    result = solution.findOrder(numCourses, prerequisites)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "success": true,
          "output": "[0, 1, 2, 3]"
        },
        {
          "example_index": 2,
          "input": "numCourses = 1, prerequisites = []",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode516.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Subsequence",
    "description_snippet": "Given a string s, find the longest palindromic subsequence's length in s.\n\nA subsequence is a sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need virtual code for longest palindromic subsequence length. Typical DP: let dp[i][j] length for s[i..j]. Compute length. Complexity O(n^2). Need to produce step-by-step pseudocode. Use Start, Decision, etc. Provide each line with explanation. Use arrow. We need to output line by line. Let's plan:\n\nStart // begin\n→ Step 1: read string s // input\n→ Step 2: n = length of s // get length\n→ Step 3: create 2D array dp[n][n] initialized to 0 // DP table\n→ Decision: if n == 0? // empty string\n    Yes → Step 4: output 0 // no subsequence\n    No → Step 5: for i from 0 to n-1: dp[i][i] = 1 // single chars\n→ Step 6: for length from 2 to n: // substring length\n    → Step 7: for i from 0 to n-length:\n        j = i + length - 1\n        → Decision: if s[i] == s[j]?\n            Yes → dp[i][j] = dp[i+1][j-1] + 2 // chars match\n            No → dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // skip one end\n→ Step 8: result = dp[0][n-1] // full string\n→ Step 9: output result // print\nEnd // finish\n\nNow produce lines with arrow. Each line format: \"Step X: ...\" but need arrow \"→\". Decision lines with indentation. Use // explanation. For Decision: include Yes → ... No → ... lines. Use indentation as per sample.\n\nLet's craft each line. Ensure no actual code syntax, just virtual. Provide explanatory comments. We'll follow format: \"Start // 程式開始執行\". Use arrow \"→\". Indent using spaces maybe. Use \"Decision:\" lines. Provide explanation. Use [空格] between virtual code and explanation.\n\nLet's craft.\n\nAlso need to mention dp[i][j] table. Use step numbers maybe but not necessary. Provide unique labels.\n\nWill output:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 s // 從使用者取得字串\n→ Step 2: 設定 n = 長度(s) // 獲取字串長度\n→ Step 3: 建立 2D 陣列 dp[n][n]，初始化為 0 // 用於存儲子問題結果\n→ Decision: 如果 n == 0? // 判斷字串是否為空\n    Yes → Step 4: 輸出 0 // 空字串的最長回文子序列長度為 0\n    No  → Step 5: 從 i = 0 到 n-1: dp[i][i] = 1 // 單個字符本身為長度 1 的回文\n→ Step 6: 對於子串長度 len 從 2 到 n:\n    → Step 7: 對於起始索引 i 從 0 到 n - len:\n        j = i + len - 1\n        → Decision: 如果 s[i] == s[j]?\n            Yes → dp[i][j] = dp[i+1][j-1] + 2 // 外兩字符相同，長度加 2\n            No  → dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取兩種刪除方式中的較長\n→ Step 8: 結果 = dp[0][n-1] // 整個字串的最長回文子序列長度\n→ Step 9: 輸出 結果 // 將結果輸出給使用者\nEnd // 程式執行結束\n\nCheck formatting: Each line must include \"虛擬碼步驟\" + \" \" + \"// 解釋/說明\". The virtual code step can be \"Step X:\" etc. Indentation should be as sample. We'll follow sample style. For Decision lines, indent the Yes and No branches with spaces. Provide the arrow \"→\" at start of each line. For nested steps, indent appropriately. Use spaces for indentation. Also include \"Decision:\" label.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 從使用者取得字串  \n→ Step 2: 設定 n = 長度(s) // 獲取字串長度  \n→ Step 3: 建立 2D 陣列 dp[n][n]，初始化為 0 // 用於存儲子問題結果  \n→ Decision: 如果 n == 0? // 判斷字串是否為空  \n Yes → Step 4: 輸出 0 // 空字串的最長回文子序列長度為 0  \n No  → Step 5: 從 i = 0 到 n-1: dp[i][i] = 1 // 單個字符本身為長度 1 的回文  \n→ Step 6: 對於子串長度 len 從 2 到 n: // 開始處理較長子串  \n → Step 7: 對於起始索引 i 從 0 到 n - len: // 遍歷所有子串  \n  j = i + len - 1  \n  → Decision: 如果 s[i] == s[j]? // 判斷兩端字符是否相同  \n   Yes → dp[i][j] = dp[i+1][j-1] + 2 // 外兩字符相同，長度加 2  \n   No  → dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取兩種刪除方式中的較長  \n→ Step 8: 結果 = dp[0][n-1] // 整個字串的最長回文子序列長度  \n→ Step 9: 輸出 結果 // 將結果輸出給使用者  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n        # 建立 n x n 的 DP 陣列，初始化為 0\n        dp = [[0] * n for _ in range(n)]\n        # 從後往前填表，確保 dp[i+1][j-1] 已經計算完成\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1  # 單個字元本身就是長度 1 的回文子序列\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    # 讀取輸入字串，移除首尾空白\n    s = sys.stdin.readline().strip()\n    solution = Solution()\n    result = solution.longestPalindromeSubseq(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"bbbab\"",
          "expected_output": "4",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '6'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '6'"
        },
        {
          "example_index": 1,
          "input": "\"cbbd\"",
          "expected_output": "2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '4'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode4.json",
    "problem_index_in_file": 0,
    "title": "Median of Two Sorted Arrays",
    "description_snippet": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm: find median of two sorted arrays in O(log(m+n)). Typical approach: binary search partition. Use virtual code with Start, Decision, steps. Provide per line explanation.\n\nWe should break down algorithm:\n\n- Ensure nums1 is smaller array; if not swap.\n\n- Define total = m+n, half = total/2.\n\n- Binary search on smaller array: low=0, high=m.\n\n- While low <= high:\n\n   - partitionX = (low+high)/2\n\n   - partitionY = half - partitionX\n\n   - maxLeftX = if partitionX==0? -∞ : nums1[partitionX-1]\n\n   - minRightX = if partitionX==m? ∞ : nums1[partitionX]\n\n   - similarly for Y.\n\n   - if maxLeftX <= minRightY and maxLeftY <= minRightX:\n\n        - if total is even: median = (max(maxLeftX, maxLeftY)+min(minRightX, minRightY))/2\n\n        - else median = max(maxLeftX, maxLeftY)\n\n   - else if maxLeftX > minRightY: high = partitionX-1\n\n   - else low = partitionX+1\n\n- Return median.\n\nWe need to produce virtual code lines with explanation. Each line must include step and explanation after //.\n\nWe must use arrows and Decision. The algorithm has loops and decisions. Provide Start, End.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 若 nums1 的長度 > nums2 的長度? // 確保較短陣列為 nums1  \n    Yes → Step 1: 交換 nums1 與 nums2；交換 m 與 n // 讓 nums1 為較短陣列  \n    No  → Step 1: 無需交換 // 兩陣列已符合條件  \n→ Step 2: 計算 total = m + n, half = total / 2 // 取得總長度與中位分割點  \n→ Step 3: 初始化 low = 0, high = m // 設定二分搜尋範圍於 nums1  \n→ Decision: low ≤ high? // 開始二分搜尋迴圈  \n    Yes → → Step 4: partitionX = (low + high) / 2 // 取 nums1 的中點作分割  \n        → Step 5: partitionY = half - partitionX // 讓兩邊總元素數相等  \n        → Step 6: maxLeftX = (partitionX == 0) ? -∞ : nums1[partitionX - 1] // 左邊最大值  \n        → Step 7: minRightX = (partitionX == m) ? ∞ : nums1[partitionX] // 右邊最小值  \n        → Step 8: maxLeftY = (partitionY == 0) ? -∞ : nums2[partitionY - 1] // 左邊最大值  \n        → Step 9: minRightY = (partitionY == n) ? ∞ : nums2[partitionY] // 右邊最小值  \n        → Decision: maxLeftX ≤ minRightY AND maxLeftY ≤ minRightX? // 分割是否正確  \n            Yes → → Decision: total 為偶數? // 判斷中位數計算方式  \n                Yes → → Step 10: median = (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2 // 偶數長度取平均  \n                No  → → Step 11: median = max(maxLeftX, maxLeftY) // 奇數長度取左側最大值  \n                → Step 12: Return median // 結束演算法  \n            No → → Decision: maxLeftX > minRightY? // 需要向左調整 partitionX  \n                Yes → → Step 13: high = partitionX - 1 // 向左縮小搜尋範圍  \n                No  → → Step 14: low = partitionX + 1 // 向右擴大搜尋範圍  \n        → Step 15: 回到 Decision: low ≤ high? // 迴圈判斷是否繼續  \n    No → Step 16: End // 程式執行結束，未找到分割點（理論上不會發生）",
      "generated_code": "import sys\nimport re\nimport ast\nimport math\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        # 確保 nums1 為較短陣列\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        m, n = len(nums1), len(nums2)\n        total = m + n\n        half = total // 2\n\n        low, high = 0, m\n        while low <= high:\n            partitionX = (low + high) // 2\n            partitionY = half - partitionX\n\n            maxLeftX = -math.inf if partitionX == 0 else nums1[partitionX - 1]\n            minRightX = math.inf if partitionX == m else nums1[partitionX]\n\n            maxLeftY = -math.inf if partitionY == 0 else nums2[partitionY - 1]\n            minRightY = math.inf if partitionY == n else nums2[partitionY]\n\n            if maxLeftX <= minRightY and maxLeftY <= minRightX:\n                if total % 2 == 0:\n                    return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2.0\n                else:\n                    return max(maxLeftX, maxLeftY)\n            elif maxLeftX > minRightY:\n                high = partitionX - 1\n            else:\n                low = partitionX + 1\n        # 理論上不會進到這裡\n        return 0.0\n\ndef parse_input(input_str: str):\n    \"\"\"\n    解析形如 'nums1 = [1,3], nums2 = [2]' 的輸入字串，回傳兩個 list。\n    \"\"\"\n    pattern = r'nums1\\s*=\\s*(\\[.*?\\])\\s*,\\s*nums2\\s*=\\s*(\\[.*?\\])'\n    match = re.search(pattern, input_str, re.S)\n    if match:\n        nums1 = ast.literal_eval(match.group(1))\n        nums2 = ast.literal_eval(match.group(2))\n        return nums1, nums2\n    # 若輸入格式不同，嘗試直接 eval\n    try:\n        data = eval(input_str, {}, {})\n        if isinstance(data, dict) and 'nums1' in data and 'nums2' in data:\n            return data['nums1'], data['nums2']\n    except Exception:\n        pass\n    raise ValueError(\"無法解析輸入\")\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    try:\n        nums1, nums2 = parse_input(raw_input)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        return\n\n    sol = Solution()\n    median = sol.findMedianSortedArrays(nums1, nums2)\n    print(f\"{median:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,3], nums2 = [2]",
          "expected_output": "2.00000",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2.00000'\nGot (Norm):      '1.00000'\n--- (Raw) ---\nRaw Expected: '2.00000'\nRaw Got:      '1.00000'"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,2], nums2 = [3,4]",
          "expected_output": "2.50000",
          "success": true,
          "output": "2.50000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode201.json",
    "problem_index_in_file": 0,
    "title": "Bitwise AND of Numbers Range",
    "description_snippet": "Given two integers left and right that represent the range [left, right], return the bitwise AND of ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: given left and right inclusive, compute bitwise AND of all numbers. This is known: the result is the common prefix of left and right. So algorithm: while left < right, shift right and left right by 1, count shifts, then shift left back. Implementation: steps.\n\nWe must output each line as \"虛擬碼步驟 // 解釋\". Use arrow etc. Must be in Traditional Chinese. Include Start, End. Use decision structure.\n\nWe need to produce a virtual code with line-by-line steps.\n\nLet's outline steps:\n\nStart\n\n→ Step 1: 初始化 counter = 0 // 计数记录右移次数\n\n→ Decision: 如果 left == right? // 若两数相等，直接返回\n\n    Yes → Step 2: 返回 left // 当左右相等时，结果即该数\n\n    No  → Decision: 如果 left < right? // 若左小于右，继续循环\n\n        Yes → Step 3: while left < right: // 循环计算相同前缀\n\n                → Step 4: left = left >> 1 // 右移左边\n\n                → Step 5: right = right >> 1 // 右移右边\n\n                → Step 6: counter = counter + 1 // 记录移位次数\n\n        No  → End // 左不小于右不应出现，安全结束\n\n→ Step 7: result = left << counter // 将保留的高位左移回原位\n\n→ Step 8: 返回 result // 输出结果\n\nEnd\n\nBut we must use proper formatting and arrow. Also maintain \"Decision:\" etc.\n\nMake sure to use \"Yes →\" and \"No →\" indented lines.\n\nWe must be careful to use proper indentation but each line separate. Provide each line with \"虛擬碼步驟 // 解釋\".\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: counter ← 0 // 記錄右移次數，用以回復高位  \n→ Decision: 如果 left = right? // 檢查兩端是否已相等  \n    Yes → Step 2: 返回 left // 若相等，直接回傳該數  \n    No → Decision: 如果 left < right? // 若左小於右，需進行處理  \n        Yes → Step 3: while left < right do // 找到相同前綴  \n            → Step 4: left ← left >> 1 // 右移左側數字  \n            → Step 5: right ← right >> 1 // 右移右側數字  \n            → Step 6: counter ← counter + 1 // 右移次數加一  \n        No → End // 左不小於右不會發生，程式結束  \n→ Step 7: result ← left << counter // 將保留的高位左移回原位  \n→ Step 8: 返回 result // 輸出最終 AND 結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        \"\"\"計算區間 [left, right] 所有整數的位運算 AND。\"\"\"\n        shift = 0\n        # 只要 left 與 right 不相等，將兩者右移，直到相等\n        while left < right:\n            left >>= 1\n            right >>= 1\n            shift += 1\n        # 將保留的高位左移回原位置\n        return left << shift\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取 left 與 right，輸出範圍 AND 的結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 允許輸入形如 \"left = 5, right = 7\" 或 \"5 7\" 等格式\n    numbers = re.findall(r'-?\\d+', data)\n    if len(numbers) < 2:\n        raise ValueError(\"輸入中至少應包含兩個整數\")\n    left, right = int(numbers[0]), int(numbers[1])\n\n    solution = Solution()\n    result = solution.rangeBitwiseAnd(left, right)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 5, right = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "left = 0, right = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "left = 1, right = 2147483647",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode313.json",
    "problem_index_in_file": 0,
    "title": "Super Ugly Number",
    "description_snippet": "A super ugly number is a positive integer whose prime factors are in the array primes.\n\nGiven an int...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps to compute nth super ugly number. We should use typical algorithm: use min-heap or multiple pointers. We'll produce steps like: Start, initialize array ugly[1..n] with 1, initialize indices for each prime all 0, initialize nextVals for each prime as primes[i]*ugly[idx[i]]; then for i from 2 to n: nextUgly = min(nextVals); ugly[i] = nextUgly; for each j where nextVals[j] == nextUgly: idx[j]++; nextVals[j] = primes[j]*ugly[idx[j]]; After loop return ugly[n]; End.\n\nWe'll output as virtual code lines with explanations. Use \"Decision:\" for min. Might need loops.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 初始化 array ugly[1..n]，ugly[1] = 1 // 第一個超醜數\n→ Step 2: 為每個 prime 建立指標 index[i] = 1 // 指向 ugly 序列的起點\n→ Step 3: 計算每個 prime 的候選值 next[i] = primes[i] * ugly[index[i]] // 初始候選值\n→ Step 4: 循環 i 從 2 到 n // 生成後續超醜數\n    → Decision: next[i] 中最小值 minVal = min(next[1..k]) // 找到下個超醜數\n    → Step 5: ugly[i] = minVal // 將最小值存入序列\n    → Decision: 哪些 next[j] 等於 minVal?\n        → For each j where next[j] == minVal:\n            → Step 6: index[j]++ // 移動指標\n            → Step 7: next[j] = primes[j] * ugly[index[j]] // 更新候選值\n→ Step 8: 返回 ugly[n] // 結果\nEnd // 程式結束\n\nWe should maintain formatting exactly: each line with \"虛擬碼步驟 // 解釋\". For Decision: we may include indentation. Use arrows.\n\nLet's produce lines accordingly. Use \"Decision:\" with Yes/No? But we have for loops. Could use \"Decision: 找到最小值\" but we can also use \"Decision: if\" for min. We'll just use a generic Decision. Use indentation with tab maybe? The format example uses indentation for nested lines. Use tabs or spaces? The example uses two spaces indentation after Decision. We'll mimic that: 4 spaces? We'll use 4 spaces.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 array ugly[1..n]，ugly[1] = 1 // 第一個超醜數設定為 1  \n→ Step 2: 為每個 prime 建立指標 index[i] = 1 // 指標指向 ugly 序列的起點  \n→ Step 3: 計算每個 prime 的候選值 next[i] = primes[i] * ugly[index[i]] // 初始候選值  \n→ Step 4: 循環 i 從 2 到 n // 生成後續超醜數  \n    → Decision: 找到 next[1..k] 的最小值 minVal // 選取下一個超醜數  \n        Yes → Step 5: ugly[i] = minVal // 將最小值存入序列  \n        No  → (無操作)  \n    → Decision: 哪些 next[j] 等於 minVal？ // 需要更新對應指標與候選值  \n        Yes → For each j where next[j] == minVal:  \n            → Step 6: index[j]++ // 移動指標  \n            → Step 7: next[j] = primes[j] * ugly[index[j]] // 更新候選值  \n        No  → (無操作)  \n→ Step 8: 返回 ugly[n] // 回傳第 n 個超醜數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nthSuperUglyNumber(self, n, primes):\n        # 初始化超醜數列，第一個元素固定為 1\n        ugly = [1]\n        # 每個 prime 對應的指標，初始指向 ugly[0]（即 1）\n        indices = [0] * len(primes)\n        # 初始候選值：prime * ugly[0] = prime\n        next_vals = list(primes)\n\n        for _ in range(1, n):\n            # 找到最小的候選值，即下一個超醜數\n            next_ugly = min(next_vals)\n            ugly.append(next_ugly)\n\n            # 更新所有等於 next_ugly 的 prime 對應指標與候選值\n            for i, val in enumerate(next_vals):\n                if val == next_ugly:\n                    indices[i] += 1\n                    next_vals[i] = primes[i] * ugly[indices[i]]\n\n        return ugly[-1]\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從輸入中提取所有整數\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        return\n    n = nums[0]\n    primes = nums[1:]\n    solution = Solution()\n    result = solution.nthSuperUglyNumber(n, primes)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12, primes = [2,7,13,19]",
          "expected_output": "32",
          "success": true,
          "output": "32"
        },
        {
          "example_index": 1,
          "input": "n = 1, primes = [2,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode448.json",
    "problem_index_in_file": 0,
    "title": "Find All Numbers Disappeared in an Array",
    "description_snippet": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for finding missing numbers in array nums of length n with values 1..n. They want line by line virtual code with explanations, using virtual code arrows and structure. So need algorithm: iterate over array, mark presence via negative marking or use set, then collect missing. Since typical solution: first mark indices: for each num, index = abs(num)-1, set nums[index] = -abs(nums[index]). Then loop to collect indices where nums[i] > 0 => missing i+1. But since we can't modify input? It's fine.\n\nWe need to produce virtual code. Each line with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc.\n\nSo something like:\n\nStart // 程式開始執行\n→ Step 1: Let n = length(nums) // 獲取陣列長度\n→ Step 2: For i from 0 to n-1: // 遍歷所有元素\n    → Step 3: index = abs(nums[i]) - 1 // 取得對應索引\n    → Step 4: nums[index] = -abs(nums[index]) // 標記存在\n→ Step 5: missing = [] // 初始化缺失數列\n→ Step 6: For i from 0 to n-1:\n    → Decision: If nums[i] > 0? // 判斷是否未被標記\n        Yes → Step 7: missing.append(i+1) // 加入缺失數\nEnd // 程式結束\n\nBut we need virtual code arrow, \"→\". The decision should use \"Decision:\" then Yes → and No →.\n\nAlso maybe need to handle duplicates.\n\nAlso note: we cannot use actual code but just pseudocode. Use words.\n\nAlso we need to avoid actual programming syntax.\n\nSo output:\n\nStart // 程式開始\n→ Step 1: n = length(nums) // 取得輸入陣列長度\n→ Step 2: for each index i in [0, n-1] // 遍歷陣列\n    → Step 3: idx = abs(nums[i]) - 1 // 對應目標索引\n    → Step 4: nums[idx] = -abs(nums[idx]) // 標記該位置已出現\n→ Step 5: missing = [] // 建立空缺失結果\n→ Step 6: for each index i in [0, n-1] // 再次遍歷\n    → Decision: nums[i] > 0? // 未被標記代表缺失\n        Yes → Step 7: missing.add(i+1) // 加入缺失數\n        No  → Step 8: continue // 已標記，忽略\nEnd // 結束程式\n\nAlso need to include \"Decision:\" lines inside loops. The user requires each line must contain \"虛擬碼步驟\" + space + \"// 解釋\".\n\nThus each line should be like:\n\nStart // 程式開始執行\n\n→ Step 1: n = length(nums) // 取得陣列長度\n\nBut also \"→ Step\" maybe not necessary but fine.\n\nWe should ensure each line starts with either \"Start\" or \"→\" or \"Decision:\" etc. Each line ends with explanation after //.\n\nThus final answer should be like:\n\nStart // 程式開始執行\n→ Step 1: n = length(nums) // 取得輸入陣列長度\n→ Step 2: for i = 0 to n-1 // 遍歷每個索引\n    → Step 3: idx = abs(nums[i]) - 1 // 對應的目標索引\n    → Step 4: nums[idx] = -abs(nums[idx]) // 將該位置標記為已出現\n→ Step 5: missing = [] // 初始化缺失數字列表\n→ Step 6: for i = 0 to n-1 // 再次遍歷所有索引\n    → Decision: nums[i] > 0? // 判斷該位置是否未被標記\n        Yes → Step 7: missing.add(i+1) // 將 i+1 加入缺失數字\n        No  → Step 8: continue // 已標記，跳過\nEnd // 程式結束\n\nBut need to maintain format exactly: \"虛擬碼步驟 [空格] // 解釋\". So \"→ Step 1:\" is the virtual code step. For Decision, \"Decision:\" part. We need to indent decisions maybe.\n\nOk, produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = length(nums) // 取得輸入陣列長度  \n→ Step 2: for i = 0 to n-1 // 遍歷陣列中的每個元素  \n  → Step 3: idx = abs(nums[i]) - 1 // 對應要標記的位置索引  \n  → Step 4: nums[idx] = -abs(nums[idx]) // 用負值標記該位置已出現  \n→ Step 5: missing = [] // 初始化缺失數字的儲存容器  \n→ Step 6: for i = 0 to n-1 // 再次遍歷所有索引以找出未被標記的  \n  → Decision: nums[i] > 0? // 判斷此位置是否還為正值（未被標記）  \n   Yes → Step 7: missing.add(i+1) // 將 i+1 加入缺失數字列表  \n   No  → Step 8: continue // 已被標記，直接跳過  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef findDisappearedNumbers(nums):\n    \"\"\"\n    找出 nums 中缺失的數字，nums 的長度為 n，且所有元素都在 [1, n] 之間。\n    透過將對應索引位置設為負數來標記已出現的元素。\n    \"\"\"\n    n = len(nums)\n    for num in nums:\n        index = abs(num) - 1            # 取得對應索引\n        nums[index] = -abs(nums[index]) # 標記已出現\n    # 收集所有未被標記的索引（正數），加 1 為缺失的數字\n    return [i + 1 for i in range(n) if nums[i] > 0]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read()\n\n    # 用正則表達式找出第一個出現的方括號列表\n    match = re.search(r'\\[.*?\\]', raw_input, re.S)\n    if match:\n        nums_str = match.group(0)\n        try:\n            nums = ast.literal_eval(nums_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    # 呼叫解題函式並輸出結果\n    result = findDisappearedNumbers(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[5,6]",
          "success": true,
          "output": "[5, 6]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode273.json",
    "problem_index_in_file": 0,
    "title": "Integer to English Words",
    "description_snippet": "Convert a non-negative integer num to its English words representation....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need virtual code for converting non-negative integer to English words. Provide steps, decision points. Use virtual code arrow. We'll list steps: Start, input num, if num==0 output \"Zero\", else define arrays for ones, teens, tens, thousands etc. Loop over segments of three digits. For each segment produce words. Provide decisions for hundreds, tens. Provide mapping. End. Provide concise explanations. Let's produce lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: 取得非負整數 num // 從使用者取得輸入數字  \n→ Decision: 如果 num 為 0? // 檢查是否為零  \n  Yes → Output: 輸出 'Zero' // 直接輸出零  \n  No  → Continue  \n→ Initialize: ones = ['','One','Two','Three','Four','Five','Six','Seven','Eight','Nine'] // 數字 0-9 的英文  \n→ Initialize: teens = ['Ten','Eleven','Twelve','Thirteen','Fourteen','Fifteen','Sixteen','Seventeen','Eighteen','Nineteen'] // 10-19  \n→ Initialize: tens = ['','','Twenty','Thirty','Forty','Fifty','Sixty','Seventy','Eighty','Ninety'] // 20-90  \n→ Initialize: thousands = ['','Thousand','Million','Billion'] // 10^3,10^6,10^9  \n→ Split: segments = 把 num 依三位一組切割成數組 // 方便逐段處理  \n→ Initialize: result = '' // 儲存最終字串  \n→ For 每個 segment 在 segments 從右到左遍歷: // 逐段處理  \n  → segmentNum = 取得該段的整數值  \n  → Decision: 如果 segmentNum 為 0? // 若此段為 0 則跳過  \n    Yes → Continue to next segment  \n    No  → ProcessSegment: // 處理非零段  \n     → hundreds = segmentNum / 100 // 數位 0-9  \n     → remainder = segmentNum % 100 // 兩位數  \n     → Decision: 如果 hundreds > 0? // 是否有百位  \n       Yes → Append: ones[hundreds] + ' Hundred' // 加百位詞  \n       No → Do nothing  \n     → Decision: 如果 remainder >= 20? // 十位≥20  \n       Yes → Append: tens[remainder / 10] // 十位詞  \n        Decision: 如果 remainder % 10 > 0? // 是否有個位  \n         Yes → Append: ones[remainder % 10] // 個位詞  \n         No  → Do nothing  \n       No → Decision: 如果 remainder >= 10? // 10-19  \n        Yes → Append: teens[remainder - 10] // 對應詞  \n        No → Decision: 如果 remainder > 0? // 1-9  \n         Yes → Append: ones[remainder] // 個位詞  \n         No  → Do nothing  \n     → Append: thousands[段索引] // 加位數詞（千、萬、億等）  \n     → result = result + ' ' + 目前段詞 // 合併到總結果  \n→ End For  \n→ Trim: 去除結果首尾空白  \n→ Output: 輸出 result // 完整英文文字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        def one(n: int) -> str:\n            switcher = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\",\n                        \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n            return switcher[n]\n\n        def two_less_20(n: int) -> str:\n            switcher = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\",\n                        \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n            return switcher[n - 10]\n\n        def ten(n: int) -> str:\n            switcher = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\",\n                        \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n            return switcher[n]\n\n        def two(n: int) -> str:\n            if n == 0:\n                return \"\"\n            elif n < 10:\n                return one(n)\n            elif n < 20:\n                return two_less_20(n)\n            else:\n                tens = n // 10\n                rest = n % 10\n                return ten(tens) + (\" \" + one(rest) if rest != 0 else \"\")\n\n        def three(n: int) -> str:\n            hundred = n // 100\n            rest = n % 100\n            if hundred != 0 and rest != 0:\n                return one(hundred) + \" Hundred \" + two(rest)\n            elif hundred == 0 and rest != 0:\n                return two(rest)\n            elif hundred != 0 and rest == 0:\n                return one(hundred) + \" Hundred\"\n            else:\n                return \"\"\n\n        billion = num // 1_000_000_000\n        million = (num % 1_000_000_000) // 1_000_000\n        thousand = (num % 1_000_000) // 1_000\n        rest = num % 1_000\n\n        parts = []\n        if billion:\n            parts.append(three(billion) + \" Billion\")\n        if million:\n            parts.append(three(million) + \" Million\")\n        if thousand:\n            parts.append(three(thousand) + \" Thousand\")\n        if rest:\n            parts.append(three(rest))\n\n        return \" \".join(parts)\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        sys.exit(0)\n    num = int(match.group())\n    solution = Solution()\n    result = solution.numberToWords(num)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 123",
          "expected_output": "\"One Hundred Twenty Three\"",
          "success": true,
          "output": "One Hundred Twenty Three"
        },
        {
          "example_index": 1,
          "input": "num = 12345",
          "expected_output": "\"Twelve Thousand Three Hundred Forty Five\"",
          "success": true,
          "output": "Twelve Thousand Three Hundred Forty Five"
        },
        {
          "example_index": 2,
          "input": "num = 1234567",
          "expected_output": "\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"",
          "success": true,
          "output": "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode632.json",
    "problem_index_in_file": 0,
    "title": "Smallest Range Covering Elements from K Lists",
    "description_snippet": "You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm: given k sorted lists, find smallest range containing at least one element from each list. Standard solution: use min-heap to keep current smallest among k pointers, track max among current elements. Iterate pointers.\n\nWe need line-by-line virtual code with explanations. Use Start, End, Decision, arrows. Each line \"虛擬碼步驟\" + space + \"// 解釋\".\n\nLet's design algorithm:\n\nStart\n→ Initialize min-heap H with first element of each list along with list index and element index\n→ Set current_max to max of first elements\n→ Set best_range_start, best_range_end to large values (e.g., inf)\n\n→ Decision: while H not empty\n    Yes →\n        → Pop min element (val, list_id, elem_idx) from H\n        → If current_max - val < best_range_end - best_range_start OR (current_max - val == best_range_end - best_range_start AND val < best_range_start)\n            → Update best_range_start = val, best_range_end = current_max\n        → If next element exists in same list\n            → Push next element into H\n            → Update current_max if next element > current_max\n        → Else\n            → No more elements in that list -> break loop\n\n→ End\n\nNeed to include decisions for updating best_range and for pushing next.\n\nAlso initial check: if any list empty? Might ignore.\n\nWe'll produce each step line by line. Use \"Step:\" format? In example they use \"Step 1: ...\" but we can use \"Step:\" maybe.\n\nWe'll include Decision: If H empty? Or we can just loop while not empty. But the example uses Decision: If condition? We can express \"Decision: H 是否為空?\" etc.\n\nOk produce steps:\n\nStart // 開始程式\n→ Step 1: 建立空的最小堆 H // 初始化最小堆\n→ Step 2: 將每個列表的第一個元素加入 H，並紀錄該元素的列表索引與位置 // 初始化堆\n→ Step 3: 計算 current_max 為 H 中所有元素的最大值 // 追蹤目前最大值\n→ Step 4: 設定 best_range_start, best_range_end 為無窮大 // 儲存最佳範圍\n→ Decision: H 是否為空？ // 檢查是否有元素可處理\n    Yes → Step 5: 重複以下步驟直到 H 為空\n        → Step 5a: 從 H 中彈出最小值 (val, list_id, elem_idx) // 取出最小\n        → Step 5b: 判斷目前範圍 [val, current_max] 是否更小於 best_range\n            Yes → Step 5b1: 更新 best_range_start = val, best_range_end = current_max // 更新最佳範圍\n            No → Step 5b2: 不更新\n        → Decision: 是否存在同一列表的下一個元素？\n            Yes → Step 5c: 取得下一個元素 next_val，push (next_val, list_id, elem_idx+1) 到 H // 推入下一元素\n                → Decision: next_val > current_max？\n                    Yes → Step 5c1: 更新 current_max = next_val // 更新最大值\n                    No → Step 5c2: 不更新\n            No → Step 5d: 沒有更多元素，結束迴圈 // 無法再擴展\n        → End of loop // 迴圈結束條件\n\n→ End // 程式結束\n\nNeed to incorporate \"End\" after loop. Also need to include Decision for loop continuation? The example uses while H not empty inside Decision: Yes -> Step... The \"Yes\" case covers the loop. The \"No\" case can be just exit.\n\nBetter format:\n\nDecision: H 是否為空? \n    Yes → (no loop)  // skip\n    No → (loop start)\n\nBut easier: just a while loop: Decision: H 非空? \n    Yes → [loop body] \n    No → End loop.\n\nOk.\n\nLet's produce final code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的最小堆 H // 初始化最小堆  \n→ Step 2: 將每個列表的第一個元素加入 H，並紀錄該元素的列表索引與位置 // 初始化堆  \n→ Step 3: 計算 current_max 為 H 中所有元素的最大值 // 追蹤目前最大值  \n→ Step 4: 設定 best_range_start, best_range_end 為無窮大 // 儲存最佳範圍  \n→ Decision: H 是否為空? // 檢查堆是否已空  \n    No → Step 5: 開始主迴圈  \n        → Decision: H 是否為空? // 迴圈結束條件  \n            Yes → End // 堆已空，結束迴圈  \n            No →  \n                → Step 5a: 從 H 中彈出最小值 (val, list_id, elem_idx) // 取出最小元素  \n                → Step 5b: 判斷目前範圍 [val, current_max] 是否更小於 best_range  \n                    → Decision: (current_max - val) < (best_range_end - best_range_start) OR  \n                                     ((current_max - val) == (best_range_end - best_range_start) AND val < best_range_start)?  \n                        Yes → Step 5b1: 更新 best_range_start = val, best_range_end = current_max // 更新最佳範圍  \n                        No → Step 5b2: 不更新  \n                → Decision: 是否存在同一列表的下一個元素？ // 檢查是否能往前移  \n                    Yes → Step 5c: 取得下一個元素 next_val，push (next_val, list_id, elem_idx+1) 到 H // 推入下一個元素  \n                        → Decision: next_val > current_max？  \n                            Yes → Step 5c1: 更新 current_max = next_val // 更新最大值  \n                            No → Step 5c2: 不更新  \n                    No → Step 5d: 沒有更多元素，跳出主迴圈 // 無法再擴展  \n                → Step 5e: 回到 Decision: H 是否為空? // 重新檢查堆  \n        → End // 主迴圈結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass Solution:\n    def smallestRange(self, nums):\n        # 建立最小堆，儲存每個列表目前指向的元素\n        heap = []\n        max_val = float('-inf')\n        for i, lst in enumerate(nums):\n            # (值, 列表索引, 在該列表中的索引)\n            heapq.heappush(heap, (lst[0], i, 0))\n            max_val = max(max_val, lst[0])\n\n        min_range = float('inf')\n        start, end = -1, -1\n\n        while heap:\n            min_val, list_idx, elem_idx = heapq.heappop(heap)\n            # 若目前範圍更小，更新答案\n            if max_val - min_val < min_range or (max_val - min_val == min_range and min_val < start):\n                min_range = max_val - min_val\n                start, end = min_val, max_val\n\n            # 若該列表還有下一個元素，推入堆中並更新最大值\n            if elem_idx + 1 < len(nums[list_idx]):\n                next_val = nums[list_idx][elem_idx + 1]\n                heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))\n                if next_val > max_val:\n                    max_val = next_val\n            else:\n                # 其中一個列表已無更多元素，無法再擴展，結束\n                break\n\n        return [start, end]\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    # 若輸入為形如 'nums = [[...], [...]]'，去除變數名稱\n    if '=' in input_data:\n        input_data = input_data.split('=', 1)[1].strip()\n\n    # 解析為 Python 結構\n    try:\n        nums = ast.literal_eval(input_data)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    result = Solution().smallestRange(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]",
          "expected_output": "[20,24]",
          "success": true,
          "output": "[20, 24]"
        },
        {
          "example_index": 1,
          "input": "nums = [[1,2,3],[1,2,3],[1,2,3]]",
          "expected_output": "[1,1]",
          "success": true,
          "output": "[1, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode567.json",
    "problem_index_in_file": 0,
    "title": "Permutation in String",
    "description_snippet": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. No actual code, just steps. We need to implement algorithm: check if s2 contains permutation of s1. Standard sliding window with frequency count. Steps: Start, compute len1, len2, if len1>len2 return false. Build freq1 array of 26. Build freq2 for first window. Compare arrays. Then slide window. Use Decision blocks.\n\nWe must use virtual code arrows. Format: each line: \"虛擬碼步驟 // 解釋\". Use \"Start\" and \"End\". Use arrows → for step flow. Use Decision: for if conditions. Must include Yes → and No → indentation. We must include step numbers maybe. Let's produce.\n\nWe need to keep in mind use Chinese explanation: 輸入s1, s2, etc. Provide explanation. Use 26 char freq arrays.\n\nLet's produce steps:\n\nStart\n→ Step 1: 輸入 s1, s2 // 取得兩個字串\n→ Step 2: 計算 len1, len2 // 取得長度\n→ Decision: 是否 len1 > len2? // 如果 s1 更長，無法存在\n    Yes → Step 3: 回傳 false // 直接返回\n    No  → Step 4: 建立 freq1[26] 全零 // 角色頻率表\n→ Step 5: 對 s1 的每個字符 c: freq1[c]++ // 記錄 s1 字符頻率\n→ Step 6: 建立 freq2[26] 全零 // 滑動窗口頻率表\n→ Step 7: 取 s2 前 len1 個字符，對每個字符 c: freq2[c]++ // 初始窗口\n→ Step 8: 判斷 freq1 與 freq2 是否相等? // 第一窗口檢查\n    Yes → Step 9: 回傳 true // 找到排列\n    No  → Step 10: 若 len1 == len2? // 沒有更多窗口\n        Yes → Step 11: 回傳 false // 完全檢查結束\n        No  → Step 12: 進入滑動窗口迴圈 // 開始移動\n→ Step 13: i 從 len1 到 len2-1: // 每次滑動\n    → Step 14: 加入進入窗口的字符 newChar = s2[i] // 新字符\n    → Step 15: 移除離開窗口的字符 oldChar = s2[i-len1] // 舊字符\n    → Step 16: freq2[newChar]++ // 更新新字符頻率\n    → Step 17: freq2[oldChar]-- // 更新舊字符頻率\n    → Step 18: 判斷 freq1 與 freq2 是否相等? // 判斷\n        Yes → Step 19: 回傳 true // 找到\n        No  → // 迴圈繼續\n→ Step 20: 回傳 false // 所有窗口都沒找到\nEnd\n\nWe must ensure indentation with Yes → etc. Provide each step line with explanation. Use \"→\" arrows. Provide code with Chinese explanation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 s1, s2 // 取得兩個字串  \n→ Step 2: 計算 len1, len2 // 取得字串長度  \n→ Decision: len1 > len2? // s1 更長時無法出現其排列  \n  Yes → Step 3: 回傳 false // 直接結束  \n  No  → Step 4: 建立 freq1[26] 全零 // 角色頻率表  \n→ Step 5: 對 s1 的每個字符 c: freq1[c]++ // 記錄 s1 字符頻率  \n→ Step 6: 建立 freq2[26] 全零 // 滑動窗口頻率表  \n→ Step 7: 取 s2 前 len1 個字符，對每個字符 c: freq2[c]++ // 初始窗口  \n→ Step 8: 判斷 freq1 與 freq2 是否相等? // 第一窗口檢查  \n  Yes → Step 9: 回傳 true // 找到排列  \n  No  → Step 10: len1 == len2? // 只有一個窗口  \n    Yes → Step 11: 回傳 false // 沒找到  \n    No  → Step 12: 進入滑動窗口迴圈 // 開始移動窗口  \n→ Step 13: i 從 len1 到 len2-1: // 每次滑動一次  \n  → Step 14: newChar = s2[i] // 新加入的字符  \n  → Step 15: oldChar = s2[i-len1] // 從窗口移出的字符  \n  → Step 16: freq2[newChar]++ // 更新新字符頻率  \n  → Step 17: freq2[oldChar]-- // 更新舊字符頻率  \n  → Step 18: 判斷 freq1 與 freq2 是否相等? // 判斷當前窗口  \n    Yes → Step 19: 回傳 true // 找到排列  \n    No  → // 繼續下一輪滑動  \n→ Step 20: 回傳 false // 所有窗口都未匹配到排列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        len1, len2 = len(s1), len(s2)\n        if len1 > len2:\n            return False\n\n        s1_count = Counter(s1)\n        window = Counter(s2[:len1])\n\n        if s1_count == window:\n            return True\n\n        for i in range(len1, len2):\n            start_char = s2[i - len1]\n            end_char = s2[i]\n\n            window[end_char] += 1\n            window[start_char] -= 1\n            if window[start_char] == 0:\n                del window[start_char]\n\n            if window == s1_count:\n                return True\n\n        return False\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input in the form:\n        s1 = \"ab\", s2 = \"eidbaooo\"\n    or similar variations.\n    \"\"\"\n    pattern = r's1\\s*=\\s*\"([^\"]*)\"\\s*,\\s*s2\\s*=\\s*\"([^\"]*)\"'\n    match = re.search(pattern, data)\n    if match:\n        return match.group(1), match.group(2)\n    # Fallback: assume first line is s1, second line is s2\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    raise ValueError(\"Input format not recognized\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit(0)\n    s1, s2 = parse_input(raw_input)\n    solution = Solution()\n    result = solution.checkInclusion(s1, s2)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode89.json",
    "problem_index_in_file": 0,
    "title": "Gray Code",
    "description_snippet": "An n-bit gray code sequence is a sequence of 2^n integers where:\n\nEvery integer is in the inclusive ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating Gray code sequence of length 2^n, with properties. We need to use decision structures, loops, etc. The virtual code will describe algorithm; e.g., use recursion or iterative method: for i from 0 to 2^n-1, produce gray code g = i ^ (i>>1). That yields sequence but ensures adjacency? Standard Gray code is sequence of 2^n numbers where each adjacent differs by one bit, but also wrap-around property holds. The standard formula for ith Gray code yields such sequence if iterated in order i from 0 to 2^n-1: adjacent differ by one bit, yes. So we can produce that.\n\nAlternatively use recursive construction: gray(n) = [0 + gray(n-1)] + [1<<(n-1) + reverse(gray(n-1))]. Provide steps.\n\nWe'll output virtual code lines: Start, etc.\n\nNeed to include decisions like for loop, if, etc.\n\nAlso note need to produce 2^n numbers. Use variable size. Use bit shift.\n\nWe can present algorithm:\n\n- Start\n- Compute total = 1 << n\n- Initialize list result empty\n- For i from 0 to total-1:\n  - g = i ^ (i >> 1)\n  - Append g to result\n- End\n\nAlso we might check if need to ensure last and first differ by one bit; standard Gray code ensures it. We might mention Decision: verify last and first differ by one bit? Not necessary.\n\nWe'll just produce code.\n\nMake sure each line has `// explanation`.\n\nUse arrow `→` for steps. Use `Decision:` when if condition.\n\nWe will include a decision maybe for verifying adjacency? Not needed.\n\nOk produce virtual code.\n\nMake sure each line separated.\n\nLet's craft.\n\nPotential steps:\n\nStart // 程式開始執行\n→ Step 1: 計算 total = 1 << n // 2^n 個數\n→ Step 2: 初始化 result = 空列表 // 用於儲存 Gray 代碼序列\n→ Step 3: 設定 i = 0 // 迴圈起始指標\n→ Decision: i < total? // 檢查是否已完成所有數字\n    Yes → Step 4: 計算 gray = i ^ (i >> 1) // Gray 代碼公式\n    → Step 5: 將 gray 加入 result // 保存當前 Gray 代碼\n    → Step 6: i = i + 1 // 移動到下一個 i\n    No → End // 迴圈結束\nEnd // 程式執行結束\n\nBut this loses the loop structure? Actually we used decision for while loop. Should represent iteration.\n\nAlternatively use loop arrow.\n\nSimpler: use loop arrow: `→ Loop i = 0; i < total; i++: ...`.\n\nBut need to follow format: we can represent loop as `→ Step 3: For i in 0..total-1:`. But the example uses decision.\n\nWe'll produce as above.\n\nLet's ensure each line uses arrow and explanation.\n\nAlso we might include a final return result.\n\nAdd: → Step 7: Return result // 最終 Gray 代碼序列\n\nAlso maybe verify adjacency? Not necessary.\n\nOk produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 計算 total = 1 << n // 2^n 個數，為 Gray 代碼長度\n→ Step 2: 初始化 result = 空列表 // 用於儲存 Gray 代碼序列\n→ Step 3: 設定 i = 0 // 迴圈起始指標\n→ Decision: i < total? // 檢查是否已完成所有數字\n    Yes → Step 4: 計算 gray = i ^ (i >> 1) // Gray 代碼公式：i XOR (i 右移 1 位)\n    → Step 5: 將 gray 加入 result // 保存當前 Gray 代碼\n    → Step 6: i = i + 1 // 移動到下一個 i\n    No → End // 迴圈結束\n→ Step 7: 返回 result // 最終 Gray 代碼序列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def grayCode(self, n: int):\n        result = [0]\n        for i in range(n):\n            add = 1 << i\n            result += [x + add for x in reversed(result)]\n        return result\n\ndef main():\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    sol = Solution()\n    ans = sol.grayCode(n)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,3,2]",
          "success": true,
          "output": "[0, 1, 3, 2]"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode16.json",
    "problem_index_in_file": 0,
    "title": "3Sum Closest",
    "description_snippet": "Given an integer array nums of length n and an integer target, find three integers in nums such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for three sum closest problem. Provide steps: sort array, iterate i, two pointers left right, compute sum, update best, move pointers accordingly. Provide one solution guarantee. Provide explanation per line. Format: Start, → Step etc.\n\nWe must not output actual code. Just virtual steps with arrow notation. Use decision structure. Ensure each line ends with // 解釋/說明. Use spaces appropriately. Use arrow \"→\" after Start? Actually Start line itself not arrow. Use \"Start // 程式開始執行\". Then \"→\" lines. Should maintain decision branches.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums in non‑decreasing order // 方便使用雙指標  \n→ Step 2: 初始化 best_sum ← nums[0] + nums[1] + nums[2] // 初始候選答案  \n→ For i from 0 to n-3 // 固定第一個數字  \n  → Set left ← i+1, right ← n-1 // 設定雙指標  \n  → While left < right // 進行雙指標掃描  \n    → current_sum ← nums[i] + nums[left] + nums[right] // 計算三數之和  \n    → If abs(current_sum - target) < abs(best_sum - target) // 找到更接近的答案  \n      → best_sum ← current_sum // 更新最佳答案  \n    → If current_sum > target // 和太大，需要減少總和  \n      → right ← right - 1 // 移動右指標左移  \n    → Else // current_sum ≤ target  \n      → left ← left + 1 // 移動左指標右移  \n→ End // 程式執行結束，best_sum 為三數之和的最接近目標值  \n→ Return best_sum // 傳回最終答案",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def threeSumClosest(self, nums, target):\n        \"\"\"Return the sum of the three integers in nums that is closest to target.\"\"\"\n        nums.sort()\n        n = len(nums)\n        closest_sum = nums[0] + nums[1] + nums[2]  # initial candidate\n\n        for i in range(n - 2):\n            left, right = i + 1, n - 1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                # 更新更接近的答案\n                if abs(total - target) < abs(closest_sum - target):\n                    closest_sum = total\n\n                if total > target:\n                    right -= 1          # 總和太大，右指標往左移\n                elif total < target:\n                    left += 1           # 總和太小，左指標往右移\n                else:\n                    return total        # 完全等於目標，直接返回\n\n        return closest_sum\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中解析出 nums 列表和 target 整數。\"\"\"\n    # 嘗試從 'nums = [...]' 以及 'target = ...' 兩個模式中抓取\n    nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    if nums_match:\n        nums_str = nums_match.group(1)\n        nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n    else:\n        # 可能第一行就是數列\n        first_line = data.strip().splitlines()[0]\n        nums = [int(x.strip()) for x in first_line.strip('[]').split(',') if x.strip()]\n\n    if target_match:\n        target = int(target_match.group(1))\n    else:\n        # 可能第二行是 target\n        lines = data.strip().splitlines()\n        if len(lines) >= 2:\n            target = int(lines[1].strip())\n        else:\n            target = 0  # 預設值，若找不到就用 0\n\n    return nums, target\n\nif __name__ == \"__main__\":\n    # 讀取所有標準輸入\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n\n    result = Solution().threeSumClosest(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,2,1,-4], target = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,0], target = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode747.json",
    "problem_index_in_file": 0,
    "title": "Largest Number At Least Twice of Others",
    "description_snippet": "You are given an integer array nums where the largest integer is unique.\n\nDetermine whether the larg...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line by line, each line with explanation. Use arrows, Start, End, Decision. Must not output actual code. Provide step-by-step. Use \"→\" for flow lines. Provide decision blocks.\n\nNeed to consider algorithm: find max and second max, or track max index. Also check if max >= 2* others. Let's produce steps:\n\nStart\n→ Step 1: Initialize maxVal = -∞, maxIdx = -1 // find largest\n→ Step 2: Iterate i from 0 to len(nums)-1 // traverse array\n→   Decision: if nums[i] > maxVal? // check if current bigger\n→     Yes → Step 3: maxVal = nums[i]; maxIdx = i // update max\n→     No → Step 4: continue // no change\nAfter loop\n→ Step 5: Initialize flag = True // assume condition holds\n→ Step 6: Iterate i from 0 to len(nums)-1 // check each element\n→   Decision: if i == maxIdx? // skip max itself\n→     Yes → Step 7: continue // skip\n→     No → Decision: if maxVal >= 2*nums[i]? // check condition\n→         Yes → Step 8: continue // condition holds for this element\n→         No  → Step 9: flag = False; break // fails\nAfter second loop\n→ Decision: if flag == True? // all others satisfied\n→   Yes → Step 10: return maxIdx // return index\n→   No  → Step 11: return -1 // otherwise\n\nEnd\n\nMake sure to format lines. Use arrow for each line except Start and End.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 maxVal 為負無窮，maxIdx 為 -1 // 準備尋找最大值\n→ Step 2: 從 i = 0 開始遍歷 nums 陣列 // 逐個檢查每個元素\n→   Decision: nums[i] > maxVal? // 判斷當前元素是否更大\n→     Yes → Step 3: 設置 maxVal = nums[i]；maxIdx = i // 更新最大值與其索引\n→     No  → Step 4: 繼續迴圈 // 目前最大值不變\nAfter loop // 完成第一次遍歷\n→ Step 5: 初始化 flag 為 True // 預設最大值至少兩倍\n→ Step 6: 再次遍歷 nums 陣列 // 檢查所有其他元素\n→   Decision: i == maxIdx? // 是否為最大值所在位置\n→     Yes → Step 7: 繼續迴圈 // 跳過最大值本身\n→     No  → Decision: maxVal >= 2 * nums[i]? // 判斷最大值是否至少兩倍\n→         Yes → Step 8: 繼續迴圈 // 條件成立，檢查下一個元素\n→         No  → Step 9: flag = False; break // 條件不滿，終止循環\nAfter second loop // 完成條件檢查\n→ Decision: flag == True? // 是否所有元素均符合條件\n→   Yes → Step 10: 返回 maxIdx // 回傳最大值的索引\n→   No  → Step 11: 返回 -1 // 否則返回 -1\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def dominantIndex(self, nums):\n        \"\"\"\n        找出數組中最大的數字是否至少是其他所有數字的兩倍。\n        若符合條件，返回該最大數字的索引；否則返回 -1。\n        \"\"\"\n        if not nums:\n            return -1\n\n        # 找到最大值及其索引\n        max_val = max(nums)\n        max_index = nums.index(max_val)\n\n        # 檢查所有其他元素\n        for i, num in enumerate(nums):\n            if i == max_index:\n                continue\n            if max_val < 2 * num:\n                return -1\n\n        return max_index\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個輸入內容\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        # 將字符串解析成列表\n        nums = ast.literal_eval(raw_input)\n        solution = Solution()\n        result = solution.dominantIndex(nums)\n        print(result)\n    else:\n        # 若輸入為空，直接輸出 -1\n        print(-1)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,6,1,0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode65.json",
    "problem_index_in_file": 0,
    "title": "Valid Number",
    "description_snippet": "Given a string s, return whether s is a valid number.\n\nFor example, all the following are valid numb...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for algorithm to validate number string. Provide step-by-step pseudocode with explanation. Ensure each line has `虛擬碼步驟 // 解釋`. Use arrows and decision. Should cover trimming spaces, optional sign, integer part, decimal part, exponent part. Use state machine? Provide simple logic: parse optional sign, parse integer part digits, parse decimal part if dot, parse exponent if 'e'/'E'.\n\nWe need to produce virtual code line by line. Let's design:\n\nStart\n→ Trim spaces\n→ If empty -> invalid\n→ Set idx=0\n→ Decision: if s[idx] is sign -> idx++\n→ Decision: if s[idx] is digit -> parse integer digits -> store hasDigits=true\n→ Decision: if s[idx]=='.' -> parse decimal part: if digits before dot? allow none; then parse digits after dot\n→ Decision: if s[idx]=='e' or 'E' -> parse exponent: must have at least one digit after optional sign\n→ Validate that we have consumed all chars\n→ Return true/false\n\nWe also need to check that number has either integer or decimal part, and exponent part requires integer after 'e'.\n\nLet's produce lines:\n\nStart\n→ Step 1: Remove leading/trailing whitespace from s // 清除兩端空白\n→ Step 2: If s is empty → Return False // 空字串不合法\n\nSet idx=0; length=n\n\n→ Decision: if s[idx] is '+' or '-' → idx++ // 處理符號\n\n→ Decision: if s[idx] is digit → While digit → idx++ // 整數部分\n    set hasDigits=true\n\n→ Decision: if s[idx] == '.' → idx++ // 小數點\n    set hasDot=true\n    While s[idx] is digit → idx++ // 小數部分\n    set hasDigits=true\n\n→ Decision: if s[idx] is 'e' or 'E' → idx++ // 指數符\n    set hasExponent=true\n    Decision: if s[idx] is '+' or '-' → idx++ // 指數符號\n    Decision: if s[idx] is digit → While digit → idx++ // 指數整數\n        set expDigits=true\n    else → Return False // 指數後必須有數字\n\n→ Decision: if idx == n and hasDigits and (not hasExponent or expDigits) → Return True\n→ Return False\n\nBut need to handle case where dot present but no digits before or after: e.g., \".9\" allowed; \"4.\" allowed. So hasDigits must be true after integer or decimal digits. We handle as above: we set hasDigits when parse digits. If there is dot, but no digits before or after, e.g., \".\" should be invalid; but we will not set hasDigits. So final check ensures hasDigits true.\n\nAlso handle scenario where no dot but digits present: hasDigits true. Good.\n\nEdge: \"e3\" invalid: no digits before exponent; our logic: after optional sign, s[0]='e', we skip to decision for digit? we will not parse digits, hasDigits false, but we see 'e' at idx=0; we go to exponent path: hasExponent true; parse sign? none; need digits after; we parse digits: '3' yes. But hasDigits still false; final check requires hasDigits true -> invalid. Good.\n\nAlso \"1e\" -> after exponent, we parse digits none -> return false.\n\nAlso \"1.\" -> hasDigits true from integer digits; hasDot true; after dot we parse digits none; still hasDigits true; final check passes.\n\nAlso \"1.e10\" -> integer part digits; dot; decimal part digits none; hasDigits true; exponent parsed digits; passes.\n\nEdge: \".e10\" -> dot but no digits before; parse '.'; then while digits none; hasDigits still false; exponent digits parse -> but final check fails.\n\nOk.\n\nLet's craft lines.\n\nNeed to show arrows. Use `→` before each step. Use decision: lines with indentation.\n\nWe must ensure each line has the code then space then `// explanation`.\n\nWe must start with Start, End.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: s ← TrimWhitespace(s) // 去除字串兩端空白  \n→ Decision: 若 s 為空字串? // 判斷字串是否為空  \n  Yes → Return False // 空字串不是合法數字  \n  No  → Proceed  \n→ Step 2: idx ← 0, n ← Length(s) // 初始化索引與長度  \n→ Decision: 若 s[idx] 為 '+' 或 '-'? // 處理符號  \n  Yes → idx ← idx + 1 // 跳過符號  \n  No  → 不做任何事  \n→ Step 3: hasDigits ← False // 標誌是否已經解析到至少一位數字  \n→ Decision: 若 s[idx] 為數字? // 解析整數部分  \n  Yes → While s[idx] 為數字 → idx ← idx + 1  \n    hasDigits ← True // 已經有數字  \n  No  → 不做任何事  \n→ Decision: 若 s[idx] 為 '.'? // 解析小數點  \n  Yes → idx ← idx + 1  \n    hasDot ← True  \n    While s[idx] 為數字 → idx ← idx + 1  \n     hasDigits ← True // 無論前後是否有數字，只要後面有即可  \n  No  → 不做任何事  \n→ Decision: 若 s[idx] 為 'e' 或 'E'? // 解析指數部分  \n  Yes → idx ← idx + 1  \n    hasExponent ← True  \n    Decision: 若 s[idx] 為 '+' 或 '-'? // 指數符號  \n     Yes → idx ← idx + 1  \n     No  → 不做任何事  \n    Decision: 若 s[idx] 為數字? // 指數必須有數字  \n     Yes → While s[idx] 為數字 → idx ← idx + 1  \n      hasExpDigits ← True // 解析到指數數字  \n     No  → Return False // 指數後無數字，非法  \n  No  → 不做任何事  \n→ Decision: 若 idx = n 且 hasDigits = True 且 (hasExponent = False 或 hasExpDigits = True)? // 檢查是否已消費完字串且至少有數字  \n  Yes → Return True // 合法數字  \n  No  → Return False // 不合法  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        判斷字串 s 是否為合法的數字\n        \"\"\"\n        s = s.strip()                       # 去除前後空白\n        if not s:                           # 空字串直接失敗\n            return False\n\n        n = len(s)\n        i = 0\n\n        # 解析正負號\n        if i < n and s[i] in '+-':\n            i += 1\n\n        has_num = False                     # 至少有一個數字\n\n        # 整數部分\n        while i < n and s[i].isdigit():\n            i += 1\n            has_num = True\n\n        # 小數點後的數字\n        if i < n and s[i] == '.':\n            i += 1\n            while i < n and s[i].isdigit():\n                i += 1\n                has_num = True\n\n        # 指數部分\n        if i < n and s[i] in 'eE':\n            i += 1\n            # 指數的正負號\n            if i < n and s[i] in '+-':\n                i += 1\n            exp_has_num = False\n            while i < n and s[i].isdigit():\n                i += 1\n                exp_has_num = True\n            if not exp_has_num:           # 指數後必須有數字\n                return False\n\n        # 檢查是否消費完所有字元，且至少有一個數字\n        return i == n and has_num\n\n\nif __name__ == \"__main__\":\n    # 讀取輸入，支援兩種格式：\n    # 1. s = \"0\"\n    # 2. 直接輸入數字字串，例如 0\n    raw_input = sys.stdin.read().strip()\n    if '\"' in raw_input:\n        first_quote = raw_input.find('\"')\n        last_quote = raw_input.rfind('\"')\n        s = raw_input[first_quote + 1:last_quote]\n    else:\n        s = raw_input\n\n    solution = Solution()\n    print(solution.isNumber(s))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"0\"",
          "expected_output": "True",
          "success": true,
          "output": "True"
        },
        {
          "example_index": 1,
          "input": "s = \"e\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        },
        {
          "example_index": 2,
          "input": "s = \".\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode121.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou wan...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for problem: best time to buy and sell stock, single transaction maximize profit. Use virtual code steps. Let's produce steps: Start, input array, initialize minPrice to first price, maxProfit to 0. Loop over each price: update maxProfit if price - minPrice > maxProfit. Update minPrice if price < minPrice. After loop, return maxProfit. End. Use Decision structure maybe. Provide explanation after each line.\n\nWe must obey format: each line: \"虛擬碼步驟 // 解釋\". Use arrow →, Decision: etc. Example from prompt. We'll produce lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入陣列 prices // 取得股票價格序列\n→ Step 2: 初始化 minPrice 為 prices[0] // 設定初始最低價格\n→ Step 3: 初始化 maxProfit 為 0 // 設定初始最大利潤\n→ Step 4: 從 i = 1 開始遍歷 prices // 循環檢查後續價格\n    → Decision: 如果 prices[i] - minPrice > maxProfit? // 判斷是否能提高利潤\n        Yes → Step 5: 設定 maxProfit = prices[i] - minPrice // 更新最大利潤\n        No  → No action // 無需更新\n    → Decision: 如果 prices[i] < minPrice? // 判斷是否遇到更低買入價\n        Yes → Step 6: 設定 minPrice = prices[i] // 更新最低價格\n        No  → No action // 保持現有最低價格\n→ Step 7: 回傳 maxProfit // 回傳最終最大利潤\nEnd // 程式執行結束\n\nBut need to ensure syntax: Use arrows for steps; Decision block indentation. The example shows \"Decision:\" lines and then \"Yes →\" etc. We'll produce accordingly.\n\nMake sure each line has arrow or no arrow? For Step lines use \"→ Step X: ...\". For Decision lines, use \"Decision: ...\". For Yes/No, use \"Yes → ...\", \"No → ...\". For No action maybe just \"No →\" but example uses \"No →\" followed by next line. We can skip no action? In example they still had \"No → Decision:...\" So we should produce \"No →\" maybe with comment. But we can simply not have a line for No action? The format requires each line contains virtual code and comment. So we need to produce lines for Yes and No. For No, we can just say \"No →\" and maybe comment \"不需要更新\". But then arrow? \"No →\" alone may be confusing. Let's produce \"No →\" with no action comment: \"No →\" but the next line after that is maybe next step. In example they had \"No  → Decision: ...\" So for decision blocks, we need two branches, each with arrow. We'll produce:\n\nDecision: 如果 prices[i] - minPrice > maxProfit? // 檢查是否可增加利潤\n    Yes → Step 5: 設定 maxProfit = prices[i] - minPrice // 更新最大利潤\n    No  → No action // 無需更新\nDecision: 如果 prices[i] < minPrice? // 檢查是否找到更低買入價\n    Yes → Step 6: 設定 minPrice = prices[i] // 更新最低價格\n    No  → No action // 保持現有最低價格\n\nBut each line must be \"虛擬碼步驟 // 解釋\". For \"No action\" line, we still produce a line with \"No  → // 無需更新\". The virtual code could be \"No  →\" but that may not fit. The example used \"No  → Decision:\" etc. They didn't show empty. For simplicity, we can skip No branch lines if not needed? But spec: each line must contain virtual code. So include.\n\nWe can write \"No  → // 無需更新\" but we need a virtual code before comment. We could write \"No  →\" as code; it's okay.\n\nLet's produce final answer with lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入陣列 prices // 取得股票價格序列  \n→ Step 2: 初始化 minPrice 為 prices[0] // 設定初始最低價格  \n→ Step 3: 初始化 maxProfit 為 0 // 設定初始最大利潤  \n→ Step 4: 從 i = 1 開始遍歷 prices // 循環檢查後續價格  \n Decision: 如果 prices[i] - minPrice > maxProfit? // 判斷是否能提高利潤  \n  Yes → Step 5: 設定 maxProfit = prices[i] - minPrice // 更新最大利潤  \n  No  → // 不需要更新  \n Decision: 如果 prices[i] < minPrice? // 判斷是否遇到更低買入價  \n  Yes → Step 6: 設定 minPrice = prices[i] // 更新最低價格  \n  No  → // 保持現有最低價格  \n→ Step 7: 回傳 maxProfit // 回傳最終最大利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def maxProfit(self, prices):\n        if not prices:\n            return 0\n        min_price = prices[0]\n        max_profit = 0\n        for price in prices[1:]:\n            if price - min_price > max_profit:\n                max_profit = price - min_price\n            if price < min_price:\n                min_price = price\n        return max_profit\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        sys.exit()\n    # 找出第一個完整的列表\n    match = re.search(r'\\[.*\\]', data)\n    if not match:\n        print(0)\n        sys.exit()\n    try:\n        prices = ast.literal_eval(match.group())\n    except Exception:\n        print(0)\n        sys.exit()\n    result = Solution().maxProfit(prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode44.json",
    "problem_index_in_file": 0,
    "title": "Wildcard Matching",
    "description_snippet": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for wildcard pattern matching using '?' and '*', covering entire string. Likely DP or recursion. Provide steps line by line. Use Start, End, Decision, etc. Need to output virtual code lines with explanation.\n\nWe should show algorithm: maybe DP table dp[i][j] indicating match s[0:i] with p[0:j]. Steps to initialize, iterate, handle '?' and '*', final result.\n\nLet's produce steps:\n\nStart\n→ Step 1: 定義變數 n = s.Length, m = p.Length // string and pattern lengths\n→ Step 2: 建立二維布林表 dp[n+1][m+1] // dp[i][j] 表示 s 前 i 個字元與 p 前 j 個字元是否匹配\n→ Decision: 是否需要初始化空字符串匹配 // ...\nSet dp[0][0] = true // 空字串與空模式匹配\n→ For j = 1 to m: // 初始化模式為 '*' 時的匹配\n    Decision: p[j-1] == '*'? // 是否為星號\n        Yes → dp[0][j] = dp[0][j-1] // '*' 可以匹配空字串\n        No  → dp[0][j] = false\nEnd For\n→ For i = 1 to n: // 主迴圈遍歷字串\n    Set dp[i][0] = false // 字串非空，空模式不匹配\n    → For j = 1 to m: // 遍歷模式\n        Decision: p[j-1] == s[i-1] OR p[j-1] == '?'? // 直接字符或問號\n            Yes → dp[i][j] = dp[i-1][j-1] // 前一個位置匹配\n            No  → Decision: p[j-1] == '*'? // 是否為星號\n                Yes → dp[i][j] = dp[i][j-1] OR dp[i-1][j] // '*' 匹配空或一個以上字元\n                No  → dp[i][j] = false\n    End For\nEnd For\n→ Step 3: 回傳 dp[n][m] // 完整匹配結果\nEnd\n\nBut must use \"虛擬碼步驟\" in each line, with arrow arrows.\n\nWe need to ensure format: each line like:\n\nStart // 程式開始執行\n\n→ Step 1: ...\n\nUse proper indentation? Might not necessary but can indent.\n\nLet's produce lines accordingly. Ensure each line includes arrow or Start or End. Use arrow for each step.\n\nWe must include decision blocks with Yes→, No→.\n\nLet's craft.\n\nAlso incorporate explanation in Chinese.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義 n = s.Length, m = p.Length // 取得字串與模式的長度\n→ Step 2: 建立二維布林表 dp[n+1][m+1] // dp[i][j] 代表 s 前 i 個字元與 p 前 j 個字元是否完全匹配\n→ Decision: 初始化空字串與空模式的匹配情況\n    Yes → dp[0][0] = true // 空字串與空模式匹配\n    No  → dp[0][0] = false\nEnd Decision\n→ Step 3: 初始化 dp[0][j]（空字串與前 j 個模式字元的匹配）\n    For j = 1 to m\n        Decision: p[j-1] == '*'? // 模式字元是否為星號\n            Yes → dp[0][j] = dp[0][j-1] // '*' 可以匹配空序列\n            No  → dp[0][j] = false\n    End For\n→ Step 4: 主迴圈遍歷字串\n    For i = 1 to n\n        dp[i][0] = false // 非空字串無法匹配空模式\n        → For j = 1 to m\n            Decision: p[j-1] == s[i-1] OR p[j-1] == '?'? // 直接匹配或問號通配\n                Yes → dp[i][j] = dp[i-1][j-1] // 需要前一位置匹配成功\n                No  → Decision: p[j-1] == '*'? // 模式字元為星號\n                    Yes → dp[i][j] = dp[i][j-1] OR dp[i-1][j] // '*' 匹配空或至少一個字元\n                    No  → dp[i][j] = false\n            End Decision\n        End For\n    End For\n→ Step 5: 回傳 dp[n][m] // 判斷整個字串是否完全匹配整個模式\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '?':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n                else:\n                    dp[i][j] = False\n        return dp[m][n]\n\ndef parse_input(data: str):\n    # 尝试解析 \"s = \"xx\", p = \"yy\"\" 的格式\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\"\\s*,\\s*p\\s*=\\s*\"([^\"]*)\"', data)\n    if match:\n        return match.group(1), match.group(2)\n\n    # 如果不是上述格式，尝试按行读取\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    # 仅一行，尝试用逗号分隔\n    parts = [part.strip() for part in data.split(',')]\n    if len(parts) == 2:\n        return parts[0], parts[1]\n    # 仍无法解析，返回空字符串\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    s, p = parse_input(raw_data)\n    sol = Solution()\n    result = sol.isMatch(s, p)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"cb\", p = \"?a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode216.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum III",
    "description_snippet": "Find all valid combinations of k numbers that sum up to n such that the following conditions are tru...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code, step-by-step, following the format. Must produce Start, → steps, Decision blocks, etc. Must not output actual code, just pseudo. Should cover combination sum with numbers 1-9, unique, sum to n, k numbers. Should return all combos.\n\nWe'll produce steps:\n\nStart\n→ Step: Read n and k // input\n→ Step: Initialize result list // store combos\n→ Step: Define backtrack function with parameters startIndex, remainingSum, path // recursion\n→ Decision: If remainingSum == 0 and path length == k -> record path\n→ Decision: If remainingSum < 0 or path length > k -> backtrack\n→ Loop i from startIndex to 9\n   → Decision: If i > remainingSum -> break // optimization\n   → Decision: If i already in path? But using incremental ensures unique.\n   → Step: Add i to path\n   → Step: Call backtrack(i+1, remainingSum - i, path)\n   → Step: Remove i from path\n→ Call backtrack(1, n, empty list)\n→ Return result list\nEnd\n\nNeed to include arrow and comments. Use indentation for decisions inside.\n\nLet's produce each line as \"→ Step: ... // ...\" etc. For decisions, use \"→ Decision: ...\" and inside lines with indentation. Use \"Yes →\" or \"No →\" style.\n\nWe need to be careful about formatting: Each line must be a separate line. For decisions, indent following lines with spaces. Use \"→ Decision:\" then indent each branch.\n\nAlso need to include Start and End lines.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step: 輸入 n 與 k // 取得目標和與組合長度\n→ Step: 初始化 result 為空列表 // 用於儲存所有合法組合\n→ Step: 定義遞迴函式 backtrack(start, remain, path) // start: 下一個可選數字；remain: 還需凑合的數值；path: 當前組合\n→ Decision: 如果 remain = 0 且 path 長度 = k? // 檢查是否已達到目標\n    Yes → Step: 將 path 的拷貝加入 result // 保存一個完整組合\n    No  → Decision: 如果 remain < 0 或 path 長度 > k? // 超過限制則停止\n        Yes → Step: 返回 // 回溯\n        No  → Step: 否則進行數字迴圈\n→ Step: 循環 i 從 start 到 9\n    → Decision: 如果 i > remain? // 無法再凑合\n        Yes → Step: break // 結束循環\n        No  → Step: 繼續\n    → Step: 將 i 加入 path\n    → Step: backtrack(i + 1, remain - i, path) // 進一步搜尋\n    → Step: 移除 path 中的 i // 回溯\n→ Step: 呼叫 backtrack(1, n, 空列表) // 開始搜尋\n→ Step: 回傳 result // 結果\nEnd // 程式執行結束\n\nWe need to maintain consistent format: Use \"→ Step:\" or \"→ Decision:\" and then indent following lines. For indented lines, we can indent with two spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 輸入 n 與 k // 取得目標和與組合長度\n→ Step: 初始化 result 為空列表 // 用於儲存所有合法組合\n→ Step: 定義遞迴函式 backtrack(start, remain, path) // start: 下一個可選數字；remain: 還需凑合的數值；path: 當前組合\n→ Decision: 如果 remain = 0 且 path 長度 = k? // 檢查是否已達到目標\n    Yes → Step: 將 path 的拷貝加入 result // 保存一個完整組合\n    No  → Decision: 如果 remain < 0 或 path 長度 > k? // 超過限制則停止\n        Yes → Step: 返回 // 回溯\n        No  → Step: 否則進行數字迴圈\n→ Step: 循環 i 從 start 到 9\n  → Decision: 如果 i > remain? // 無法再凑合\n      Yes → Step: break // 結束循環\n      No  → Step: 繼續\n  → Step: 將 i 加入 path\n  → Step: backtrack(i + 1, remain - i, path) // 進一步搜尋\n  → Step: 移除 path 中的 i // 回溯\n→ Step: 呼叫 backtrack(1, n, 空列表) // 開始搜尋\n→ Step: 回傳 result // 結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combinationSum3(self, k: int, n: int):\n        res = []\n\n        def backtrack(start: int, path: list[int], total: int):\n            if len(path) == k and total == n:\n                res.append(path[:])\n                return\n            if len(path) > k or total > n:\n                return\n            for i in range(start, 10):\n                if i > n - total:  # pruning: cannot reach target\n                    break\n                path.append(i)\n                backtrack(i + 1, path, total + i)\n                path.pop()\n\n        backtrack(1, [], 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) >= 2:\n        k, n = nums[0], nums[1]\n    else:\n        # 如果輸入不足兩個數字，直接輸出空列表\n        print([])\n        sys.exit(0)\n\n    solution = Solution()\n    result = solution.combinationSum3(k, n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 3, n = 7",
          "expected_output": "[[1,2,4]]",
          "success": true,
          "output": "[[1, 2, 4]]"
        },
        {
          "example_index": 1,
          "input": "k = 3, n = 9",
          "expected_output": "[[1,2,6],[1,3,5],[2,3,4]]",
          "success": true,
          "output": "[[1, 2, 6], [1, 3, 5], [2, 3, 4]]"
        },
        {
          "example_index": 2,
          "input": "k = 4, n = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode721.json",
    "problem_index_in_file": 0,
    "title": "Accounts Merge",
    "description_snippet": "Given a list of accounts where each element accounts[i] is a list of strings, where the first elemen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem is LeetCode \"Accounts Merge\". We need to produce steps: building graph of emails, DFS/BFS, grouping, sorting, output.\n\nWe produce pseudocode lines with arrows.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化圖形、映射和名稱\n→ Step 2: 遍歷 accounts，對每個帳戶建立 email 關聯\n→ Decision: 需要將第一個 email 設為根\n    Yes → Step 3: 對於每個後續 email, 建立雙向邊\n→ Step 4: 建立 email -> name 映射（使用第一個 email）\n→ Step 5: 初始化 visited 集合\n→ Decision: 是否有未訪問的 email?\n    Yes → Step 6: 使用 DFS 找到連通分量\n        → Step 7: 收集此分量內的所有 email\n        → Step 8: 將 email 排序\n        → Step 9: 將 name + sorted emails 加入結果\n        → Step 10: 標記為已訪問\n        → Step 11: 回到 Decision\n    No → End\n\nAlso need mapping from email to name stored. So final code lines.\n\nLet's produce each line.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\" with arrow \"→\". Start and End.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 建立空圖形 adj (email → email 列表) 和空字典 emailToName // 準備儲存 email 關聯與對應名稱\n→ Step 2: 建立空集合 visited // 標記已處理的 email\n→ Step 3: 建立空列表 result // 儲存合併後的帳戶\n→ Decision: 是否還有帳戶未處理? // 準備進入帳戶迴圈\n    Yes → Step 4: 針對每個 account 進行處理\n        → Step 5: 取 name = account[0] // 取得帳戶名稱\n        → Step 6: 取 emails = account[1:] // 取得所有 email\n        → Decision: emails 是否至少有一個? // 確保非空\n            Yes → Step 7: 取 firstEmail = emails[0] // 選擇第一個 email 作為根\n                → Step 8: 將 firstEmail 與 name 相關聯於 emailToName\n                → Decision: 是否有其他 email? // 建立邊\n                    Yes → Step 9: 針對每個 otherEmail in emails[1:]:\n                        → Step 10: adj[firstEmail].add(otherEmail)\n                        → Step 11: adj[otherEmail].add(firstEmail)\n                    No → No-op\n            No → No-op\n        → Step 12: 完成所有帳戶的圖構建\n→ Decision: 是否還有未訪問的 email? // 檢查是否完成 DFS\n    Yes → Step 13: 針對每個未訪問的 email e:\n        → Step 14: 建立空列表 component // 收集此連通分量的 email\n        → Step 15: 使用 DFS( e ):\n            → Step 16: 標記 current email為已訪問\n            → Step 17: 將 current email 加入 component\n            → Step 18: 針對每個相鄰 email nei in adj[current]:\n                → Decision: nei 是否已訪問?\n                    Yes → No-op\n                    No  → DFS( nei )\n        → Step 19: 取得 component 中的名稱 name = emailToName[e]\n        → Step 20: 對 component 進行字母排序\n        → Step 21: 將 [name] + component 連接成 list // 合併後帳戶\n        → Step 22: 將此 list 加入 result\n        → Step 23: 回到 Decision\n    No → End // 程式結束\n\nWe must ensure each line uses '→' and includes explanatory comment. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空圖形 adj (email → email 列表) 和空字典 emailToName // 準備儲存 email 關聯與對應名稱  \n→ Step 2: 建立空集合 visited // 標記已處理的 email  \n→ Step 3: 建立空列表 result // 儲存合併後的帳戶  \n→ Decision: 是否還有帳戶未處理? // 準備進入帳戶迴圈  \n Yes → Step 4: 針對每個 account 進行處理  \n  → Step 5: 取 name = account[0] // 取得帳戶名稱  \n  → Step 6: 取 emails = account[1:] // 取得所有 email  \n  → Decision: emails 是否至少有一個? // 確保非空  \n   Yes → Step 7: 取 firstEmail = emails[0] // 選擇第一個 email 作為根  \n    → Step 8: adj[firstEmail] ← 空列表 // 為根建立鄰接列表  \n    → Step 9: emailToName[firstEmail] ← name // 將根 email 與名稱對應  \n    → Decision: 是否有其他 email? // 建立邊  \n     Yes → Step 10: 針對每個 otherEmail in emails[1:]:  \n      → Step 11: adj[firstEmail].add(otherEmail) // 建立雙向連結  \n      → Step 12: adj[otherEmail] ← adj.get(otherEmail, 空列表) // 確保存在  \n      → Step 13: adj[otherEmail].add(firstEmail)  \n     No → No-op  \n   No → No-op  \n → Step 14: 完成所有帳戶的圖構建  \n→ Decision: 是否還有未訪問的 email? // 檢查是否完成 DFS  \n Yes → Step 15: 針對每個未訪問的 email e:  \n  → Step 16: 建立空列表 component // 收集此連通分量的 email  \n  → Step 17: 執行 DFS(e)  \n   → Step 18: 標記 e 為已訪問  \n   → Step 19: component.add(e) // 加入分量  \n   → Decision: 是否存在相鄰 email nei?  \n    Yes → Step 20: 若 nei 未訪問, 進行 DFS(nei)  \n    No → No-op  \n  → Step 21: 取得 component 中的名稱 name = emailToName[e] // 取根的名稱  \n  → Step 22: 對 component 進行字母排序  \n  → Step 23: 將 [name] + component 連接成 list // 合併後帳戶  \n  → Step 24: 將此 list 加入 result  \n  → Step 25: 回到 Decision  \n No → End // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        \"\"\"\n        使用 DSU（并查集）將所有具有共同郵件的帳號合併。\n        \"\"\"\n        parent = {}  # email -> 父節點\n\n        def find(x):\n            \"\"\"\n            找到 x 的根節點，並進行路徑壓縮。\n            \"\"\"\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}  # email -> 名稱\n\n        # 建立並查集結構\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                # 連結所有 email 到第一個 email\n                root_email = find(first_email)\n                root_current = find(email)\n                parent[root_current] = root_email\n                email_to_name[email] = name\n\n        # 收集同一個根節點下的所有 email\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        # 產生最終結果，並對每個帳號的 email 做排序\n        return [[email_to_name[root]] + sorted(emails) for root, emails in merged.items()]\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print([])\n        sys.exit(0)\n\n    # 取出列表部分並安全解析\n    idx = raw_input.find('[')\n    accounts_part = raw_input[idx:]\n    accounts = ast.literal_eval(accounts_part)\n\n    # 執行合併\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n\n    # 輸出結果\n    print(merged_accounts)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "expected_output": "[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "success": true,
          "output": "[['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], ['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com']]"
        },
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode763.json",
    "problem_index_in_file": 0,
    "title": "Partition Labels",
    "description_snippet": "You are given a string s. We want to partition the string into as many parts as possible so that eac...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation. The problem: partition string into as many parts as possible such that each letter appears in at most one part. Equivalent to LeetCode 763 Partition Labels. The algorithm: find last occurrence of each character; iterate through string keeping current max last index; when current index equals max last index, cut. Record length.\n\nWe must produce virtual code steps line by line, each with comment. Format: `虛擬碼步驟 // 解釋`. Using arrows etc. Steps: Start, Input s, Compute last occurrence map, Initialize variables, Iterate, Update max, Check equality, If equal, record part size, reset, End.\n\nNeed to ensure each line is virtual code step, not actual code. So use descriptions like \"Step 1: Compute last index map\" etc. Use arrow notation.\n\nLet's craft step lines:\n\nStart // program start\n\n→ Step 1: Input string s // get the input string\n\n→ Step 2: Initialize dictionary lastPos // map each character to its last index\n\n→ Step 3: For each character c with index i in s: set lastPos[c] = i // record last occurrence\n\n→ Step 4: Initialize currentMax = -1 // current furthest last position\n\n→ Step 5: Initialize startIndex = 0 // start index of current part\n\n→ Step 6: Initialize result list // store sizes\n\n→ Step 7: For each character c with index i in s: // iterate\n\n    → Update currentMax = max(currentMax, lastPos[c]) // furthest last pos\n\n    → Decision: If i == currentMax? // end of part?\n\n        Yes → Step 8: Append (i - startIndex + 1) to result // part size\n\n        Yes → Step 9: Set startIndex = i + 1 // next part starts\n\n        No  → // continue\n\n→ End // output result\n\nBut we need to produce each line with virtual code step and explanation. Use arrow format like:\n\nStart // 程式開始執行\n\n→ Step 1: 輸入字串 s // 取得輸入字串\n\n→ Step 2: 初始化字典 lastPos // 用來儲存每個字母最後出現的位置\n\n→ Step 3: For i in 0..len(s)-1: lastPos[s[i]] = i // 記錄每個字母的最後索引\n\n→ Step 4: currentMax ← -1 // 當前分區能延伸到的最遠位置\n\n→ Step 5: startIndex ← 0 // 當前分區的起始索引\n\n→ Step 6: result ← 空清單 // 儲存每個分區的長度\n\n→ Step 7: For i in 0..len(s)-1: // 逐字串處理\n\n    → currentMax ← max(currentMax, lastPos[s[i]]) // 更新最遠結束位置\n\n    → Decision: i == currentMax? // 判斷是否到達分區終點\n\n        Yes → result.append(i - startIndex + 1) // 記錄分區長度\n\n        Yes → startIndex ← i + 1 // 設定下一個分區的起始\n\n        No → // 繼續\n\n→ End // 結束並輸出結果\n\nWe must ensure \"→\" arrow before each step.\n\nAlso we should format like:\n\nStart // 程式開始執行\n\n→ Step 1: 輸入字串 s // 取得輸入字串\n\n...\n\nUse \"Decision:\" line.\n\nWe need to include \"Decision:\" for decision, with Yes →, No →.\n\nAlso maybe we need to show indentation of Yes and No.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 取得輸入字串\n→ Step 2: 初始化字典 lastPos // 用來儲存每個字母最後出現的位置\n→ Step 3: For i = 0 to len(s)-1: lastPos[s[i]] = i // 記錄每個字母的最後索引\n→ Step 4: currentMax ← -1 // 當前分區能延伸到的最遠位置\n→ Step 5: startIndex ← 0 // 當前分區的起始索引\n→ Step 6: result ← [] // 儲存每個分區的長度\n→ Step 7: For i = 0 to len(s)-1: // 逐字串處理\n    → currentMax ← max(currentMax, lastPos[s[i]]) // 更新最遠結束位置\n    → Decision: i == currentMax? // 判斷是否到達分區終點\n        Yes → result.append(i - startIndex + 1) // 記錄分區長度\n        Yes → startIndex ← i + 1 // 設定下一個分區的起始\n        No  → // 繼續\nEnd // 程式結束\n\nYes. Also we may include that final result is returned.\n\nAdd \"→ Step 8: 返回 result // 輸出分區長度列表\"\n\nAdd that.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 取得輸入字串\n→ Step 2: 初始化字典 lastPos // 用來儲存每個字母最後出現的位置\n→ Step 3: For i = 0 to len(s)-1: lastPos[s[i]] = i // 記錄每個字母的最後索引\n→ Step 4: currentMax ← -1 // 當前分區能延伸到的最遠位置\n→ Step 5: startIndex ← 0 // 當前分區的起始索引\n→ Step 6: result ← [] // 儲存每個分區的長度\n→ Step 7: For i = 0 to len(s)-1: // 逐字串處理\n    → currentMax ← max(currentMax, lastPos[s[i]]) // 更新最遠結束位置\n    → Decision: i == currentMax? // 判斷是否到達分區終點\n        Yes → result.append(i - startIndex + 1) // 記錄分區長度\n        Yes → startIndex ← i + 1 // 設定下一個分區的起始\n        No  → // 繼續\n→ Step 8: 返回 result // 輸出分區長度列表\nEnd // 程式結束",
      "generated_code": "import sys\n\ndef partition_labels(s: str) -> list[int]:\n    \"\"\"\n    Partition the string into as many parts as possible so that each letter\n    appears in at most one part, and return the sizes of these parts.\n    \"\"\"\n    # 1. 先找出每個字母最後一次出現的索引\n    last_pos = {c: i for i, c in enumerate(s)}\n\n    # 2. 初始化分割點和結果清單\n    start, end = 0, 0\n    partitions = []\n\n    # 3. 遍歷字串，更新目前可延伸的最遠結束位置\n    for i, ch in enumerate(s):\n        end = max(end, last_pos[ch])\n        # 4. 當目前索引等於最遠結束位置時，即可完成一個分區\n        if i == end:\n            partitions.append(i - start + 1)\n            start = i + 1\n\n    return partitions\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read().strip()\n\n    # 解析輸入，支援 \"s = \\\"...\\\"\" 或純字串兩種形式\n    if '=' in raw_input:\n        # 取等號右側的部分\n        raw_input = raw_input.split('=', 1)[1].strip()\n\n    # 移除外層引號（單引號或雙引號）\n    if (raw_input.startswith('\"') and raw_input.endswith('\"')) or \\\n       (raw_input.startswith(\"'\") and raw_input.endswith(\"'\")):\n        raw_input = raw_input[1:-1]\n\n    # 執行分割演算法並輸出結果\n    result = partition_labels(raw_input)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ababcbacadefegdehijhklij\"",
          "expected_output": "[9,7,8]",
          "success": true,
          "output": "[9, 7, 8]"
        },
        {
          "example_index": 1,
          "input": "s = \"eccbbbbdec\"",
          "expected_output": "[10]",
          "success": true,
          "output": "[10]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode126.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder II",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: find all shortest transformation sequences (Word Ladder II). Use BFS to build graph, then DFS/backtracking to get paths. Use virtual code with arrows. Each line include explanation comment.\n\nWe produce steps:\n\nStart\n→ Step 1: 初始化資料結構：wordSet、visited、distance map、adjacency list\n→ Step 2: BFS: queue beginWord, level 0, record distances, build adjacency\n→ Decision: queue empty? ...\nBut we need to produce the algorithm, not actual code.\n\nWe produce each step with virtual code and explanation. Must be line by line. Provide arrows.\n\nLet's craft:\n\nStart // 開始\n→ Step 1: 建立字典集合 wordSet = set(wordList) // 方便 O(1) 查詢\n→ Decision: 若 endWord not in wordSet? // 若目標不在字典，直接結束\n    No → End // 直接返回空列表\n    Yes → ...\nBut we need to produce steps that show BFS, adjacency, DFS.\n\nWe need to produce all shortest paths.\n\nWe need to maintain distance map to ensure BFS depth. While BFS, record adjacency.\n\nLet's produce pseudocode.\n\nWe may need to include loops: For each level, for each word, generate neighbors by changing each character to 'a' to 'z'.\n\nWe'll represent loops with steps and decisions.\n\nWe need to output \"虛擬碼步驟 [space] // 解釋/說明\".\n\nWe'll produce lines with arrow: \"→ Step 2: ...\" etc.\n\nWe need to use \"Start\", \"End\".\n\nWe need to include \"Decision:\" lines.\n\nOk produce.\n\nLet's plan structure:\n\nStart\n→ Step 1: 初始化 wordSet, visited dict, adjacency dict\n→ Decision: 若 endWord not in wordSet\n    No → End // 無路徑\n    Yes → ...\n→ Step 2: BFS 初始化 queue with beginWord, distance[beginWord] = 0\n→ Step 3: While queue not empty:  // BFS 逐層探索\n    → Step 4: current = dequeue\n    → Step 5: currentDist = distance[current]\n    → Step 6: For i in 0..len(current)-1:\n        → Step 7: For c in 'a'..'z':\n            → Step 8: nextWord = replace char i with c\n            → Decision: nextWord == current? // skip same word\n                No → ...\n                Yes → Continue\n            → Decision: nextWord in wordSet? // 是否在字典\n                Yes → ...\n                No → Continue\n            → Decision: nextWord not in distance? // 未訪問\n                Yes → set distance[nextWord] = currentDist + 1; enqueue\n                No → // Already visited\n            → Step 9: If distance[nextWord] == currentDist + 1:\n                → Step 10: Add edge current -> nextWord in adjacency\n                → Step 11: If nextWord == endWord: found shortest length = distance[nextWord]\n→ Decision: if shortest length not found? // 沒有路徑\n    No → End\n    Yes → ...\n→ Step 12: DFS 產生所有路徑\n    → Step 13: function dfs(word, path):\n        → Decision: word == endWord?\n            Yes → append path to result\n            No → For each neighbor in adjacency[word]:\n                → Step 14: dfs(neighbor, path + [neighbor])\n→ Step 15: Call dfs(beginWord, [beginWord])\n→ End // 回傳結果\n\nWe should also handle when beginWord not in wordSet: it's okay; we still BFS from it.\n\nAlso we need to ensure we record adjacency only for shortest path edges: that ensures we don't produce longer paths.\n\nWe need to ensure that we only process BFS until we reach endWord, then we stop exploring deeper levels? But typical algorithm still processes same level. But for clarity, we can note we only expand neighbors that are at distance +1.\n\nWe'll produce the steps accordingly.\n\nWe need to keep lines sequential. Use arrow for each step.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: wordSet ← Set(wordList) // 建立字典集合，方便 O(1) 查詢  \n→ Decision: 若 endWord 不在 wordSet? // 若目標單詞不在字典，無法形成變換序列  \n    Yes → End // 直接回傳空列表，程式結束  \n    No  →  \n→ Step 2: visited ← {}  // 記錄已訪問單詞及其距離  \n→ Step 3: adjacency ← {}  // 存放每個單詞到下一層單詞的邊，僅保留最短路徑邊  \n→ Step 4: queue ← [beginWord]  // BFS 隊列，初始為起始單詞  \n→ Step 5: visited[beginWord] ← 0  // 起始單詞距離為 0  \n→ Step 6: foundShortest ← False  // 標記是否已找到最短終點  \n→ Step 7: While queue not empty:  // BFS 逐層搜尋  \n    → Step 8: current ← queue.pop(0)  // 取出隊首單詞  \n    → Step 9: curDist ← visited[current]  // 目前單詞的距離  \n    → Step 10: For i in 0 .. len(current)-1:  // 逐字位替換  \n        → Step 11: For c in 'a'..'z':  // 可能替換的字母  \n            → Step 12: next ← current[0:i] + c + current[i+1:]  // 產生鄰接單詞  \n            → Decision: next == current?  // 跳過自己  \n                Yes → Continue  \n                No  →  \n            → Decision: next not in wordSet?  // 不是字典單詞則忽略  \n                Yes → Continue  \n                No  →  \n            → Decision: next not in visited?  // 未訪問，則設距離並入隊  \n                Yes → visited[next] ← curDist + 1  \n                → queue.append(next)  // 加入 BFS 隊列  \n            → Decision: visited[next] == curDist + 1?  // 只保留最短層的邊  \n                Yes →  \n                    → Step 13: adjacency.setdefault(current, []).append(next)  // 建立邊  \n                    → Decision: next == endWord?  // 判斷是否到達終點  \n                        Yes → foundShortest ← True  // 記錄已找到最短終點  \n                        No  →  \n                No  →  \n    → Decision: foundShortest?  // 一旦找到終點，後續層已不需探索  \n        Yes → Break  // 退出 BFS 循環  \n        No  →  \n→ Decision: not foundShortest?  // 若 BFS 完成仍未找到終點  \n    Yes → End // 回傳空列表，程式結束  \n    No  →  \n→ Step 14: result ← []  // 儲存所有最短路徑  \n→ Step 15: Function dfs(word, path):  // 深度優先搜尋回朔所有路徑  \n    → Decision: word == endWord?  // 到達終點  \n        Yes → result.append(path)  // 加入結果  \n        No  →  \n            → For neighbor in adjacency.get(word, []):  // 遍歷所有最短邊  \n                → dfs(neighbor, path + [neighbor])  // 進行遞迴  \n→ Step 16: dfs(beginWord, [beginWord])  // 從起始單詞開始 DFS  \n→ End // 程式執行結束，返回 result",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS to find the shortest distance to each word and record parents\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n\n        queue = deque([beginWord])\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n\n    # 使用正則表達式擷取 beginWord, endWord, wordList\n    bw_match = re.search(r'beginWord\\s*=\\s*\"([^\"]+)\"', data)\n    ew_match = re.search(r'endWord\\s*=\\s*\"([^\"]+)\"', data)\n    wl_match = re.search(r'wordList\\s*=\\s*(\\[[^\\]]*\\])', data)\n\n    if not (bw_match and ew_match and wl_match):\n        print(\"[]\")\n        sys.exit(0)\n\n    beginWord = bw_match.group(1)\n    endWord = ew_match.group(1)\n    wordList = ast.literal_eval(wl_match.group(1))\n\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "success": true,
          "output": "[['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode436.json",
    "problem_index_in_file": 0,
    "title": "Find Right Interval",
    "description_snippet": "You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps with comments. It's algorithm: For each interval, find interval with start >= end. Unique start ensures no duplicates. Approach: sort intervals by start, maintain original index mapping. For each interval, binary search for first start >= end. If found, record its original index else -1. Complexity O(n log n).\n\nWe need to produce step-by-step virtual code lines with explanation. Use Start, End, Decision, etc. Include loops, sorting, binary search. Provide each line.\n\nWe need to think of how many lines. For clarity:\n\nStart\n→ Step 1: Create list of tuples (start, end, original_index) // gather data\n→ Step 2: Sort the list by start // sorted starts for binary search\n→ Step 3: Initialize result array of size n with -1 // placeholder\n→ Step 4: For each interval in original order (loop i from 0 to n-1) // process each interval\n   → Step 5: end_value = intervals[i][1] // get end\n   → Step 6: Binary search on sorted list to find first start >= end_value // find index\n   → Decision: If found? // check result\n        Yes → Step 7: result[i] = sorted_list[found_index].original_index // assign found index\n        No  → Step 8: result[i] remains -1 // no right interval\n→ End // return result\n\nWe need to express binary search details: maybe separate steps.\n\nLet's create virtual code with indentation. Use arrow lines. We'll use '→' for next line. For decisions use 'Decision:'. Provide explanation comment after each line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入 intervals 列表 // 取得原始區間資料\n→ Step 2: 產生 tuples = [(start, end, 原始索引) for each interval] // 加入原始索引以便回傳\n→ Step 3: 將 tuples 按 start 進行升冪排序 // 方便後續二分搜尋\n→ Step 4: 建立 result 陣列，大小為 intervals.length，預設值為 -1 // 用於儲存答案\n→ Step 5: 從 0 開始，對每個原始區間 i 進行迴圈 // 逐一處理每個區間\n   → Step 6: end_i ← intervals[i][1] // 取得該區間的結束點\n   → Step 7: 初始化 low ← 0, high ← tuples.length // 為二分搜尋做準備\n   → Step 8: Decision: 是否能找到 start_j ≥ end_i? // 判斷是否存在右區間\n        Yes →\n            → Step 9: binary search 迴圈：當 low < high 時\n                → Decision: tuples[mid].start < end_i?\n                    Yes → low ← mid + 1 // 在右半區尋找更大的 start\n                    No  → high ← mid // 可能是答案，繼續在左半區尋找\n            → Step 10: found_index ← low // low 指向第一個 start ≥ end_i 的位置\n            → Step 11: result[i] ← tuples[found_index].original_index // 記錄對應索引\n        No  →\n            → Step 12: result[i] ← -1 // 無符合條件的右區間，保持預設值\n→ End // 程式結束，返回 result 陣列\n\n(Note：以上虛擬碼僅為結構示意，實際實作時可根據程式語言調整語法)",
      "generated_code": "import sys\nimport bisect\nimport ast\n\nclass Solution:\n    def findRightInterval(self, intervals):\n        # 建立 (開始時間, 原始索引) 的有序列表，方便二分搜尋\n        starts = sorted((interval[0], i) for i, interval in enumerate(intervals))\n        res = []\n\n        for interval in intervals:\n            # 找到第一個開始時間 >= 結束時間\n            idx = bisect.bisect_left(starts, (interval[1],))\n            if idx < len(starts):\n                res.append(starts[idx][1])\n            else:\n                res.append(-1)\n\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，移除可能的前綴 \"intervals =\"，並解析成 Python 物件\n    raw_input = sys.stdin.read().strip()\n    if raw_input.startswith(\"intervals\"):\n        raw_input = raw_input.split(\"=\", 1)[1].strip()\n    try:\n        intervals = ast.literal_eval(raw_input)\n    except Exception as e:\n        # 若解析失敗，輸出空列表\n        print(\"[]\")\n        sys.exit(0)\n\n    sol = Solution()\n    answer = sol.findRightInterval(intervals)\n    print(answer)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2]]",
          "expected_output": "[-1]",
          "success": true,
          "output": "[-1]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[3,4],[2,3],[1,2]]",
          "expected_output": "[-1,0,1]",
          "success": true,
          "output": "[-1, 0, 1]"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,4],[2,3],[3,4]]",
          "expected_output": "[-1,2,-1]",
          "success": true,
          "output": "[-1, 2, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode517.json",
    "problem_index_in_file": 0,
    "title": "Super Washing Machines",
    "description_snippet": "You have n super washing machines on a line. Initially, each washing machine has some dresses or is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps explaining algorithm: classic Leetcode 517. Steps: compute total dresses, if not divisible by n return -1. Then compute prefix imbalance. For each i, compute moves as max(absolute(prefix), current cumulative). Return max moves.\n\nWe produce line-by-line pseudo code with explanations. Use Start, End, Decision etc. Each line: \"Step X: ... // explanation\". Use arrows.\n\nLet's create:\n\nStart\n→ Step 1: Let n = length of machines // get number of machines\n→ Step 2: Compute total = sum(machines) // total dresses\n→ Decision: If total % n != 0? // check equal distribution possible\n    Yes → Step 3: Return -1 // impossible\n    No  → Step 4: target = total / n // desired dresses per machine\n→ Step 5: Initialize prefix = 0, maxMoves = 0 // running imbalance and max moves\n→ For i from 0 to n-1: // iterate each machine\n    → Step 6: prefix += machines[i] - target // imbalance after i-th machine\n    → Step 7: maxMoves = max(maxMoves, abs(prefix), machines[i] - target) // record moves\n→ Step 8: Return maxMoves // minimal moves\nEnd\n\nBut we need virtual code format. Use arrows.\n\nInclude Decision structure.\n\nLet's craft each line accordingly.\n\nMake sure each line ends with \"//\".\n\nUse 'Decision: ...' block with Yes and No arrows. In loop, we might use 'For each machine i:' then steps inside with indentation maybe but keep simple.\n\nWe can include comment after each.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n = length of machines // 取得洗衣機總數  \n→ Step 2: Compute total = sum(machines) // 計算總衣服數量  \n→ Decision: 如果 total mod n 不為 0? // 檢查是否能平均分配  \n    Yes → Step 3: Return -1 // 不可能，直接返回 -1  \n    No  → Step 4: target = total / n // 目標每台機器應有的衣服數  \n→ Step 5: Initialize prefix = 0, maxMoves = 0 // 用於累積不平衡與記錄最大移動數  \n→ For i from 0 to n-1: // 遍歷每台洗衣機  \n    → Step 6: prefix += machines[i] - target // 更新到第 i 台機器的累積不平衡  \n    → Step 7: maxMoves = max(maxMoves, abs(prefix), machines[i] - target) // 取最大的移動需求  \n→ Step 8: Return maxMoves // 回傳最小移動次數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_min_moves(machines):\n    total = sum(machines)\n    n = len(machines)\n    if total % n != 0:\n        return -1\n    target = total // n\n    max_moves = 0\n    prefix = 0\n    for load in machines:\n        diff = load - target\n        prefix += diff\n        max_moves = max(max_moves, abs(prefix), diff)\n    return max_moves\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    machines = ast.literal_eval(data)\n    result = find_min_moves(machines)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,0,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[0,3,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,2,0]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode657.json",
    "problem_index_in_file": 0,
    "title": "Robot Return to Origin",
    "description_snippet": "There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, with comments. The logic: start at (0,0), iterate through moves, update coordinates accordingly, then check if coordinates back to origin. Use Decision for checking final. So produce steps: Start, Step 1: initialize x=0, y=0, Step 2: for each char in moves, Decision: if char== 'R'? etc. Then after loop, Decision: if x==0 && y==0? Yes → Return true else false. End. Use arrow syntax. Provide explanation. Use virtual code arrows. Let's craft.\n\nAlso use '→' for transitions. We need indentation with decisions: \"Decision: ...\" with Yes/No branches. Ensure each line ends with comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: x ← 0, y ← 0 // 初始化座標為原點  \n→ Step 2: for each move in moves // 逐一處理每個移動指令  \n  Decision: move == 'R'? // 判斷指令是否為向右  \n   Yes → x ← x + 1 // 向右移動座標 x 加 1  \n   No → Decision: move == 'L'? // 否則判斷是否為向左  \n    Yes → x ← x - 1 // 向左移動座標 x 減 1  \n    No → Decision: move == 'U'? // 否則判斷是否為向上  \n     Yes → y ← y + 1 // 向上移動座標 y 加 1  \n     No → Decision: move == 'D'? // 否則判斷是否為向下  \n      Yes → y ← y - 1 // 向下移動座標 y 減 1  \n      No → // 無效指令，略過  \n→ Decision: x == 0 && y == 0? // 判斷最終座標是否回到原點  \n  Yes → Return true // 回到原點，返回 true  \n  No  → Return false // 未回到原點，返回 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        \"\"\"判斷機器人是否回到原點。\"\"\"\n        x = y = 0\n        for move in moves:\n            if move == 'U':\n                y += 1\n            elif move == 'D':\n                y -= 1\n            elif move == 'L':\n                x -= 1\n            elif move == 'R':\n                x += 1\n        return x == 0 and y == 0\n\ndef parse_moves(input_str: str) -> str:\n    \"\"\"\n    從輸入字串中提取移動序列。\n    支援兩種格式：\n      1. moves = \"UD\"\n      2. 直接給出 UD\n    \"\"\"\n    # 找到第一對雙引號之間的內容\n    quotes = re.findall(r'\"([^\"]*)\"', input_str)\n    if quotes:\n        return quotes[0]\n    # 若沒有引號，直接使用整行或多行合併後的內容\n    return input_str.strip()\n\nif __name__ == \"__main__\":\n    # 讀取所有標準輸入\n    raw_input = sys.stdin.read()\n    moves = parse_moves(raw_input)\n    sol = Solution()\n    result = sol.judgeCircle(moves)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "moves = \"UD\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "moves = \"LL\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode738.json",
    "problem_index_in_file": 0,
    "title": "Monotone Increasing Digits",
    "description_snippet": "An integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisf...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. For given problem: find largest number <= n with monotone increasing digits. The standard solution: convert to array of digits, find first place where digit decreases, decrement that digit by 1, set all following digits to 9, then again ensure monotonic by backtracking.\n\nWe'll produce pseudocode step by step.\n\nWe need to output lines: Start, etc.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將輸入整數 n 轉成字串 s，並將每個字元轉為數字陣列 digits // 方便逐位處理  \n→ Decision: 若 n 為單一位數? // 單位數已是單調  \n    Yes → Step 2: 回傳 n // 回傳原數字  \n    No  → Decision: 轉換後的 digits 是否已滿足 monotone? // 檢查是否已經單調  \n        Yes → Step 3: 回傳 n // 已單調，直接回傳  \n        No  → Step 4: 設定 idx = length(digits) - 1 // 從右往左尋找下降位置  \n→ Decision: 找到第一個 i 使得 digits[i] > digits[i+1]? // 從左往右尋找下降點  \n    Yes → Step 5: 位置 pos = i // 下降點的索引  \n    No  → Step 6: 回傳 n // 若不存在下降點，已單調，回傳  \n→ Step 7: digits[pos] = digits[pos] - 1 // 下降點數字減一  \n→ Step 8: 對於 j 從 pos+1 到 end 依序設為 9 // 之後的位數全部設 9  \n→ Decision: 需要再回溯檢查 monotone? // 下降點減一可能造成前面不單調  \n    Yes → Step 9: 回到 pos-1 位置，如果 digits[pos-1] > digits[pos]  \n        → If true: digits[pos-1] = digits[pos-1] - 1;  \n        → For k 從 pos 到 end 設為 9;  \n        → 重複此步直到不再需要回溯 // 進行必要的回溯調整  \n    No  → Step 10: 繼續 // 不需要回溯  \n→ Step 11: 將 digits 重新組成整數 result // 轉回整數形式  \n→ End // 程式結束，輸出 result",
      "generated_code": "import sys\nimport re\n\ndef monotone_increasing_digits(n: int) -> int:\n    \"\"\"Return the largest integer <= n with monotone increasing digits.\"\"\"\n    digits = list(str(n))  # digits as list of characters\n    i = 1\n    # Find first position where the sequence decreases\n    while i < len(digits) and digits[i] >= digits[i - 1]:\n        i += 1\n    if i == len(digits):\n        return n  # already monotone\n\n    # Backtrack to adjust the digits\n    while i > 0 and digits[i] < digits[i - 1]:\n        digits[i - 1] = str(int(digits[i - 1]) - 1)\n        i -= 1\n\n    # Set all following digits to '9'\n    for j in range(i + 1, len(digits)):\n        digits[j] = '9'\n\n    return int(''.join(digits))\n\nif __name__ == \"__main__\":\n    # Read all input, extract the first integer\n    input_text = sys.stdin.read()\n    match = re.search(r'-?\\d+', input_text)\n    if not match:\n        raise ValueError(\"No integer found in input.\")\n    n = int(match.group())\n    result = monotone_increasing_digits(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "n = 1234",
          "expected_output": "1234",
          "success": true,
          "output": "1234"
        },
        {
          "example_index": 2,
          "input": "n = 332",
          "expected_output": "299",
          "success": true,
          "output": "299"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode729.json",
    "problem_index_in_file": 0,
    "title": "My Calendar I",
    "description_snippet": "You are implementing a program to use as your calendar. We can add a new event if adding the event w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code that describes the implementation of MyCalendar with book method. We'll use a data structure like list of intervals and check overlaps. Or use BST. We'll produce pseudocode with steps. Must follow format: each line \"虛擬碼步驟 // 解釋\". Use arrows. Provide Start, End. So produce stepwise algorithm. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 MyCalendar 類別，內部持有空的事件列表 intervals // 初始化日曆，事件以 [start, end) 存儲\n→ Step 2: 定義 book(start, end) 方法 // 該方法嘗試新增事件並回傳布林值\n→     Decision: 是否有任何已存在事件與 [start, end) 重疊? // 檢查重複預約\n→         Yes → Step 3: 回傳 false，並且不新增事件 // 發現重疊，保留日曆不變\n→         No  → Step 4: 把 [start, end) 加入 intervals 列表 // 事件可安全加入\n→             Step 5: 回傳 true // 成功預約\nEnd // 程式執行結束\n\n// 以上虛擬碼描述了 MyCalendar 的核心邏輯：維護一個事件列表，使用簡單的線性掃描來檢查是否有重疊，若無則新增並回傳成功。",
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MyCalendar:\n    \"\"\"\n    以簡單的列表儲存已預約的區間。\n    book 方法會檢查與現有區間是否重疊，若無則加入。\n    \"\"\"\n    def __init__(self):\n        self.bookings = []\n\n    def book(self, start, end):\n        for s, e in self.bookings:\n            # 兩區間有重疊時 max(start, s) < min(end, e)\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入文字成 (operations, arguments)。\n    支援以下兩種格式：\n    1. 兩行：第一行為操作列表，第二行為參數列表。\n    2. 單行：操作列表與參數列表以「,」分隔，兩者均為合法 Python 文字。\n    \"\"\"\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if not lines:\n        return [], []\n\n    if len(lines) == 1:\n        # 單行模式：需要自行拆分成兩個表達式\n        line = lines[0]\n        parts = []\n        buf = ''\n        depth = 0\n        for ch in line:\n            if ch == '[':\n                depth += 1\n            if ch == ']':\n                depth -= 1\n            buf += ch\n            if depth == 0 and ch == ']':\n                parts.append(buf)\n                buf = ''\n        ops, args = parts\n    else:\n        ops, args = lines[0], lines[1]\n\n    # 使用 ast.literal_eval 以安全方式解析\n    ops_list = ast.literal_eval(ops)\n    args_list = ast.literal_eval(args)\n    return ops_list, args_list\n\n\ndef main():\n    raw_input = sys.stdin.read()\n    ops, args = parse_input(raw_input)\n\n    if not ops:\n        print('[]')\n        return\n\n    result = []\n    instance = None\n\n    for op, arg in zip(ops, args):\n        if op == 'MyCalendar':\n            instance = MyCalendar()\n            result.append(None)   # MyCalendar 返回 null\n        elif op == 'book':\n            if instance is None:\n                raise RuntimeError(\"MyCalendar instance not created before book()\")\n            res = instance.book(*arg)\n            result.append(res)\n        else:\n            # 若未定義的操作，可視需求擴充\n            result.append(None)\n\n    # 使用 json.dumps 產生符合範例的輸出格式\n    print(json.dumps(result, ensure_ascii=False))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpra3efc1r.py\", line 87, in <module>\n    main()\n  File \"/tmp/tmpra3efc1r.py\", line 60, in main\n    ops, args = parse_input(raw_input)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpra3efc1r.py\", line 54, in parse_input\n    args_list = ast.literal_eval(args)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    , [[], [10, 20], [15, 25], [20, 30]]\n    ^\nSyntaxError: invalid syntax"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode278.json",
    "problem_index_in_file": 0,
    "title": "First Bad Version",
    "description_snippet": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with line-by-line, each line with `虛擬碼步驟` then `// 解釋`. Use arrow, Decision. We need to implement binary search to find first bad version. Use Start, End, Decision. Provide code. Let's produce lines. We'll include variable declarations. Let's produce pseudo-code. Should minimize API calls.\n\nWe produce:\n\nStart // Program start\n\n→ Step 1: Set low = 1, high = n // Initialize search range\n\n→ Decision: while low < high? // loop until range narrowed\n\nYes → Step 2: mid = low + (high - low) / 2 // mid point to check\n\n→ Decision: isBadVersion(mid)? // check if mid is bad\n\nYes → Step 3: high = mid // bad, so first bad is <= mid\n\nNo → Step 4: low = mid + 1 // good, so first bad > mid\n\nBack to while loop condition\n\nWhen low == high, exit loop\n\n→ Step 5: return low // low is first bad\n\nEnd\n\nWe need to format with arrow lines. Use indentation. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: low = 1, high = n // 初始化搜尋範圍\n→ Decision: low < high? // 當區間還有多個版本時進入迴圈\n    Yes → Step 2: mid = low + (high - low) / 2 // 計算中間版本號\n    → Decision: isBadVersion(mid)? // 判斷中間版本是否為壞版本\n        Yes → Step 3: high = mid // 若 mid 為壞版本，第一個壞版本必在 [low, mid] 之間\n        No  → Step 4: low = mid + 1 // 若 mid 為好版本，第一個壞版本必在 [mid+1, high] 之間\n    // 回到 while 條件檢查\n    No  → Step 5: return low // low 已經等於 high，為第一個壞版本號\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\n# Global variable to hold the first bad version number\nbad_version = None\n\ndef isBadVersion(version: int) -> bool:\n    \"\"\"API that tells whether a given version is bad.\"\"\"\n    return version >= bad_version\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        \"\"\"Finds the first bad version using binary search.\"\"\"\n        left, right = 1, n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read()\n\n    # Extract all integers from the input (handles formats like\n    # \"n = 5, bad = 4\" or \"5 4\" or \"5,4\")\n    nums = re.findall(r'\\d+', data)\n\n    if len(nums) < 2:\n        raise ValueError(\"Input must contain at least two integers: n and bad\")\n\n    n = int(nums[0])\n    bad_version = int(nums[1])  # Set the global bad version for the API\n\n    solution = Solution()\n    first_bad = solution.firstBadVersion(n)\n    print(first_bad)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5, bad = 4",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 1, bad = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode81.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array II",
    "description_snippet": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for searching target in rotated sorted array with duplicates. Classic algorithm: modified binary search, find pivot or handle duplicates. We can implement search with while low <= high: mid, if nums[mid]==target return true. else if nums[low]==nums[mid]==nums[high] -> increment low, decrement high. else if nums[low] <= nums[mid] -> left sorted; check if target in [low, mid] then high=mid-1 else low=mid+1. else -> right sorted; check if target in [mid, high] then low=mid+1 else high=mid-1.\n\nWe need virtual code line by line with arrow syntax. Provide comments after space.\n\nLet's produce lines:\n\nStart\n→ Step 1: 初始化 low = 0, high = length(nums)-1 // 设定搜索区间\n→ While low <= high: // 主循环\n    → Step 2: mid = (low + high) // 2 // 取中点\n    → Decision: 如果 nums[mid] == target? // 检查是否找到\n        Yes → Return true // 找到目标\n        No  → Decision: 如果 nums[low] == nums[mid] == nums[high]? // 处理重复\n            Yes → low = low + 1 // 消除边界重复\n               → high = high - 1\n               → Continue // 重新循环\n            No  → Decision: 如果 nums[low] <= nums[mid]? // 判断左侧是否有序\n                Yes → Decision: 如果 nums[low] <= target < nums[mid]? // 目标在左侧\n                    Yes → high = mid - 1 // 限定左侧\n                    No  → low = mid + 1 // 移到右侧\n                No  → Decision: 如果 nums[mid] < target <= nums[high]? // 目标在右侧\n                    Yes → low = mid + 1\n                    No  → high = mid - 1\n→ End // 循环结束\n→ Return false // 未找到\n\nWe need each line with virtual code and comment. Use arrow for steps and decisions. Must be clear and sequential. Use indentation for nested decisions.\n\nMake sure to include \"End\" line. Provide line for \"Return false\".\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 0, high = length(nums) - 1 // 設定搜尋區間  \n→ While low <= high: // 主搜尋迴圈  \n    → Step 2: mid = (low + high) // 2 // 計算中點  \n    → Decision: 如果 nums[mid] == target? // 判斷是否已找到目標  \n        Yes → Return true // 找到目標，結束程式  \n        No  → Decision: 如果 nums[low] == nums[mid] == nums[high]? // 處理重複值  \n            Yes → low = low + 1 // 消除左邊重複  \n               → high = high - 1 // 消除右邊重複  \n               → Continue // 重新進入 While  \n            No  → Decision: 如果 nums[low] <= nums[mid]? // 判斷左半部是否有序  \n                Yes → Decision: 如果 nums[low] <= target < nums[mid]? // 目標是否在左半部  \n                    Yes → high = mid - 1 // 將搜尋範圍縮小到左半部  \n                    No  → low = mid + 1 // 目標在右半部，移到右邊  \n                No  → Decision: 如果 nums[mid] < target <= nums[high]? // 目標是否在右半部  \n                    Yes → low = mid + 1 // 移到右半部  \n                    No  → high = mid - 1 // 目標在左半部，縮小範圍  \n→ End // 主搜尋迴圈結束  \n→ Return false // 未找到目標，回傳假值",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[left] == nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中擷取 nums 與 target。\"\"\"\n    pattern = r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)'\n    m = re.search(pattern, data)\n    if not m:\n        return [], None\n    nums_str, target_str = m.group(1), m.group(2)\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n    return nums, target\n\ndef main():\n    raw = sys.stdin.read().strip()\n    nums, target = parse_input(raw)\n    if target is None:\n        return\n    sol = Solution()\n    result = sol.search(nums, target)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,5,6,0,0,1,2], target = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [2,5,6,0,0,1,2], target = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode648.json",
    "problem_index_in_file": 0,
    "title": "Replace Words",
    "description_snippet": "In English, we have a concept called root, which can be followed by some other word to form another ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps in Chinese, following the format. We need to output line by line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. The logic: given dictionary of roots, sentence string. For each word, find the root that is prefix and shortest. Replace word with that root. So steps: Start, parse dictionary into set, maybe array, maybe sort by length ascending. Split sentence into words. For each word: find replacement. Replace if found. Build result. Output End.\n\nNeed to show algorithm not actual code. Use arrows for steps. We'll use arrow \"→\" before each step. For decision: \"Decision: 是否有根匹配?\" etc. Also need nested loops? We'll show for each word iterate over roots sorted by length, if word startsWith root, set replaced word. Then break.\n\nLet's produce.\n\nWe must not output actual code, only pseudo. So lines like \"→ Step 1: 將根字典轉成集合\" etc. Use proper Chinese.\n\nMake sure each line includes comment.\n\nWe'll produce about maybe 10-12 lines.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將根字典轉成陣列並按長度升序排序 // 方便先找到最短根  \n→ Step 2: 將句子以空格分割成單字陣列 // 逐字處理  \n→ Decision: 是否有任何單字？ // 判斷句子是否非空  \n    Yes → Loop: 為每個單字執行以下子流程  \n        → Step 3: 設定 currentWord 為單字 // 用於替換  \n        → Step 4: 設定 foundRoot 為 null // 暫存匹配到的根  \n        → Decision: 是否有根可匹配 currentWord？ // 循環檢查每個根  \n            Yes → Step 5: 若 currentWord 以此根為前綴，則  \n                → Step 6: 若 foundRoot 為 null 或此根長度 < foundRoot 長度，則  \n                    → Step 7: 設定 foundRoot 為此根 // 取得最短匹配  \n            No  → Step 8: 進入下一個根 // 連續嘗試其他根  \n        → Decision: foundRoot 是否不為 null？ // 判斷是否找到匹配  \n            Yes → Step 9: 把 currentWord 換成 foundRoot // 替換為根  \n            No  → Step 10: 留下 currentWord 原樣 // 無匹配則保留  \n        → Step 11: 把處理後的單字加入結果陣列  \n    No → Step 12: 結果陣列保持空 // 句子為空時不處理  \n→ Step 13: 用空格將結果陣列重新組成句子 // 生成最終字串  \n→ Step 14: 回傳替換後的句子 // 完成任務  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def replaceWords(self, dictionary, sentence):\n        # 建立 Trie 結構\n        trie = {}\n        END = \"__END__\"          # 結束標記\n\n        for root in dictionary:\n            node = trie\n            for ch in root:\n                node = node.setdefault(ch, {})\n            node[END] = root    # 存儲完整根字串\n\n        def replace(word):\n            node = trie\n            for ch in word:\n                if ch not in node:\n                    break\n                node = node[ch]\n                if END in node:\n                    return node[END]   # 找到最短前綴\n            return word\n\n        return ' '.join(map(replace, sentence.split()))\n\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中提取 dictionary 與 sentence。\"\"\"\n    dict_match = re.search(r'dictionary\\s*=\\s*(\\[.*?\\])', data, re.S)\n    sent_match = re.search(r'sentence\\s*=\\s*(\"(?:\\\\.|[^\"])*\")', data, re.S)\n\n    if dict_match and sent_match:\n        dictionary = ast.literal_eval(dict_match.group(1))\n        sentence = ast.literal_eval(sent_match.group(1))\n    else:\n        # 若輸入格式不同，嘗試每行一項\n        lines = data.strip().splitlines()\n        dictionary = ast.literal_eval(lines[0].strip())\n        sentence = ast.literal_eval(lines[1].strip())\n    return dictionary, sentence\n\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    dictionary, sentence = parse_input(data)\n    sol = Solution()\n    result = sol.replaceWords(dictionary, sentence)\n    # 根據範例輸出，前後加雙引號\n    print(f'\"{result}\"')\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"",
          "expected_output": "\"the cat was rat by the bat\"",
          "success": true,
          "output": "\"the cat was rat by the bat\""
        },
        {
          "example_index": 1,
          "input": "dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"",
          "expected_output": "\"a a b c\"",
          "success": true,
          "output": "\"a a b c\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode435.json",
    "problem_index_in_file": 0,
    "title": "Non-overlapping Intervals",
    "description_snippet": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm: remove minimum intervals to make non-overlapping. Known solution: sort by end time, iterate, keep count of non-overlapping intervals, track last_end. Number to remove = total - keep. Or directly count removals. Steps: sort intervals by end ascending; initialize last_end = -∞; removals = 0; for each interval [s, e]: if s < last_end: overlapping -> removals++ else last_end = e. Output removals. Provide virtual code lines with explanations. Use Start, Decision, etc. Let's produce.\n\nAlso need to be careful: use Start, End. Provide decision lines.\n\nWe'll output like:\n\nStart // start\n→ Step 1: Sort intervals by ascending end // sort\n→ Step 2: 初始化 last_end = -∞ // last_end\n→ Step 3: 初始化 removals = 0 // counter\n→ Decision: 迴圈遍歷 intervals? // loop\n    Yes → Step 4: s = interval.start, e = interval.end // assign\n    → Decision: s < last_end? // overlap?\n        Yes → Step 5: removals++ // remove this interval\n        No  → Step 6: last_end = e // update last_end\n    No → Step 7: Output removals // result\nEnd\n\nBut they want each line of virtual code. Should we include loop structure? Could use \"For Each interval in intervals\". Represent with Decision: For Each? Not typical. But we can express as Decision: 迴圈結束? Actually, we need to use the pattern with decision arrows. Perhaps we can use \"Decision: 迴圈條件?\" to decide loop.\n\nSimplify: Use \"Decision: 是否還有 interval?\" with Yes → process. No → Output.\n\nLet's craft.\n\nAlso use arrow formatting. Need to use \"→\" after step, and \"Yes →\" and \"No →\" inside decision.\n\nExample format: \"→ Decision: 是否還有 interval? // 判斷是否還有要處理的 interval\"\n\"Yes → Step X: ...\" \"No → Step Y: ...\" etc.\n\nLet's produce full.\n\nEnsure no code. Just virtual code.\n\nAlso need to include End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 排序 intervals 按照結束時間升序 // 先按結束時間排序，以便 Greedy 選擇  \n→ Step 2: 初始化 last_end = -∞ // 追蹤最後一個被保留區間的結束點  \n→ Step 3: 初始化 removals = 0 // 記錄需要移除的區間數量  \n→ Decision: 是否還有 interval? // 判斷是否還有區間要處理  \n    Yes → Step 4: 取出下一個 interval 的 start 為 s，end 為 e // 取得目前區間的端點  \n    → Decision: s < last_end? // 判斷是否與上一個保留區間重疊  \n        Yes → Step 5: removals++ // 此區間重疊，計算為需要移除  \n        No  → Step 6: last_end = e // 此區間不重疊，更新 last_end 為目前結束點  \n    No  → Step 7: 輸出 removals // 所有區間已處理完畢，輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef eraseOverlapIntervals(intervals):\n    \"\"\"返回需要移除的最小區間數量，使得剩下的區間互不重疊。\"\"\"\n    if not intervals:\n        return 0\n    # 先按結束時間升序排序\n    intervals.sort(key=lambda x: x[1])\n    last_end = intervals[0][1]\n    count = 1  # 已保留的區間數\n    for s, e in intervals[1:]:\n        # 若當前區間與上一次保留的區間不重疊\n        if s >= last_end:\n            last_end = e\n            count += 1\n    # 需要移除的區間 = 總區間數 - 已保留區間數\n    return len(intervals) - count\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 解析格式為 \"intervals = [[...]]\" 或直接 \"[[...]]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    try:\n        intervals = ast.literal_eval(expr)\n    except Exception:\n        intervals = []\n    result = eraseOverlapIntervals(intervals)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[1,2],[1,2]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,2],[2,3]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode710.json",
    "problem_index_in_file": 0,
    "title": "Random Pick with Blacklist",
    "description_snippet": "You are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with comments. The algorithm: typical solution: mapping for blacklisted numbers that are less than W = n - blackCount. Use hash map to remap black numbers < W to some white numbers >= W. On pick, generate random r in [0, W-1]; if r in mapping, return mapping[r]; else r.\n\nNeed to produce steps: Start, Initialize: store n, blacklist, calculate W, build mapping, etc. Then pick() uses random call once. Provide pseudo code.\n\nWe must output each line as \"虛擬碼步驟 // 解釋\".\n\nWe need to adhere to format, use arrows and Decision structure.\n\nSo produce Start, Step lines: e.g.,\n\nStart // 程式開始執行\n\n→ Step 1: Set N ← input n // Store original range size\n\n→ Step 2: Set B ← input blacklist array // Store blacklist\n\n→ Step 3: Compute W ← N - size(B) // Number of allowed integers\n\n→ Decision: If size(B) == 0? // No blacklist, trivial case\n\n    Yes → Step 4: mapping ← empty // No mapping needed\n\n    No → Step 5: Initialize empty dictionary M // Mapping for black numbers < W\n\n        → For each x in B: // Iterate over blacklist\n\n            → Decision: If x < W? // Black number inside [0, W-1]\n\n                Yes → Add x to set S // S holds black numbers that need remapping\n\n                No → Continue // ignore\n\n        → Set Y ← N-1 // Start of high range to assign mapping\n\n            → For each x in B: // Assign high numbers to replace black numbers in low range\n\n                → Decision: If x < W? // Only map those inside low range\n\n                    Yes → While Y in B: Y ← Y-1 // Find a high number not blacklisted\n\n                    → M[x] ← Y // Map low black to high white\n\n                    → Y ← Y-1 // Move to next high number\n\n                No → Continue\n\nEnd of initialization\n\nThen pick method:\n\n→ Step 6: r ← randomInt(0, W-1) // Generate random integer within allowed low range\n\n→ Decision: If r in M? // If r is a black number mapped\n\n    Yes → Return M[r] // Return mapped white number\n\n    No  → Return r // Return r itself\n\nEnd // End of algorithm\n\nWe need to include all lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set N ← n // 先儲存整體範圍大小  \n→ Step 2: Set B ← blacklist // 先儲存黑名單  \n→ Step 3: Compute W ← N - size(B) // 允許數字的數量 (白名單長度)  \n\n→ Decision: If size(B) == 0? // 若無黑名單，直接返回  \n    Yes → Step 4: mapping ← empty // 沒有需要的映射  \n    No → Step 5: Initialize empty dictionary M // 用於映射需要重新指派的數字  \n\n        → For each x in B: // 遍歷黑名單  \n            → Decision: If x < W? // 只處理落在低區 [0, W-1] 的黑數  \n                Yes → Add x to set S // 將需要映射的黑數存入集合  \n                No → Continue // 其餘不處理  \n\n        → Set Y ← N-1 // 從最高數字開始尋找可映射的白數  \n            → For each x in B: // 再次遍歷黑名單，進行映射  \n                → Decision: If x < W? // 只對低區黑數進行映射  \n                    Yes → While Y in B: Y ← Y-1 // 找到一個不在黑名單的高數字  \n                    → M[x] ← Y // 建立映射 x → Y  \n                    → Y ← Y-1 // 准備下一個高數字  \n                No → Continue // 跳過高區黑數  \n\nEnd // 初始設定結束  \n\n→ Step 6: r ← randomInt(0, W-1) // 隨機產生 [0, W-1] 範圍內的數字  \n→ Decision: If r in M? // 檢查 r 是否需要映射  \n    Yes → Return M[r] // 回傳映射後的白數  \n    No  → Return r // 回傳原數字  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        index = random.randint(0, self.size - 1)\n        return self.mapping.get(index, index)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    # Parse commands and arguments\n    commands = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n    outputs = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            outputs.append(None)\n        elif cmd == \"pick\":\n            outputs.append(obj.pick())\n        else:\n            # Unsupported command, skip\n            outputs.append(None)\n    print(json.dumps(outputs))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,6,0,6,6,1,1,0]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 6, 0, 6, 6, 1, 1, 0]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode677.json",
    "problem_index_in_file": 0,
    "title": "Map Sum Pairs",
    "description_snippet": "Design a map that allows you to do the following:\n\nMaps a string key to a given value.\nReturns the s...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for MapSum class. Should include initialization, insert, sum. Use virtual code with arrows, decisions etc. Provide line by line. Use Start, End, Decision, etc. We'll produce a high-level algorithm: Use a Trie with cumulative sums. Insert updates sums along path. Need to maintain previous value for key to adjust. We'll keep map key->val. Steps:\n\nStart\n→ Step 1: Initialize MapSum object\n    → Initialize empty trie root node with children map, sum=0\n    → Initialize empty hashmap keyToVal\n→ Step 2: insert(key, val)\n    → Retrieve oldVal = keyToVal.getOrDefault(key, 0)\n    → diff = val - oldVal\n    → keyToVal.put(key, val)\n    → Node curr = root\n    → For each char c in key:\n        → If curr.children doesn't contain c:\n             → curr.children[c] = new TrieNode()\n        → curr = curr.children[c]\n        → curr.sum += diff\n→ Step 3: sum(prefix)\n    → Node curr = root\n    → For each char c in prefix:\n        → If curr.children doesn't contain c:\n             → return 0\n        → curr = curr.children[c]\n    → return curr.sum\nEnd\n\nWe need to produce virtual code with arrows.\n\nWe'll format like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 MapSum 物件 // 創建根節點和 key-to-value 的雜湊表\n    → TrieNode root = new TrieNode() // 根節點\n    → Map<String, Integer> keyToVal = new HashMap() // 儲存鍵對應值\n→ Step 2: insert(key, val) // 插入或更新鍵值對\n    → Integer oldVal = keyToVal.getOrDefault(key, 0) // 取得舊值\n    → Integer diff = val - oldVal // 需要累加的差值\n    → keyToVal.put(key, val) // 更新鍵對應值\n    → TrieNode node = root // 從根節點開始\n    → Decision: 迭代 key 的每個字元? // 處理字串\n        Yes → \n            → Decision: node.children 是否包含 char? // 若沒有節點則新建\n                Yes →\n                No  → node.children.put(char, new TrieNode()) // 新節點\n            → node = node.children.get(char) // 進入子節點\n            → node.sum += diff // 累加差值\n        No → // 完成插入\n→ Step 3: sum(prefix) // 計算前綴總和\n    → TrieNode node = root\n    → Decision: 迭代 prefix 的每個字元?\n        Yes →\n            → Decision: node.children 是否包含 char?\n                Yes → node = node.children.get(char)\n                No  → return 0 // 前綴不存在\n        No → // 所有字元遍歷完畢\n    → return node.sum\nEnd // 程式結束\n\nBut we need to produce exactly virtual code lines each with // explanation. Use arrow for decisions etc. We'll produce consistent formatting. Ensure each line ends with // 解釋. Use Chinese. Provide lines for all steps.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 建立 MapSum 物件 // 初始化根節點與鍵值雜湊表\n    → TrieNode root = new TrieNode() // 根節點，sum 先為 0\n    → Map<String, Integer> keyToVal = new HashMap() // 儲存鍵對應的原始值\n→ Step 2: insert(key, val) // 插入或覆寫鍵值對\n    → Integer oldVal = keyToVal.getOrDefault(key, 0) // 取得舊值，若無則 0\n    → Integer diff = val - oldVal // 計算需要更新的差值\n    → keyToVal.put(key, val) // 更新鍵對應值\n    → TrieNode node = root // 從根節點開始\n    → Decision: 逐字處理 key? // 逐個字元往下走\n        Yes →\n            → Decision: node.children 是否有 char? // 若沒有則新建節點\n                Yes →\n                No  → node.children.put(char, new TrieNode()) // 新建子節點\n            → node = node.children.get(char) // 進入子節點\n            → node.sum += diff // 在此節點累加差值\n        No → // 完成 insert\n→ Step 3: sum(prefix) // 取得前綴總和\n    → TrieNode node = root // 從根節點開始\n    → Decision: 逐字處理 prefix? // 逐個字元往下走\n        Yes →\n            → Decision: node.children 是否有 char? // 若不存在直接回 0\n                Yes → node = node.children.get(char)\n                No  → return 0 // 前綴不存在\n        No → // 所有字元已處理\n    → return node.sum // 返回累加的總和\nEnd // 程式結束\n\nMake sure each line ends with // 解釋. Provide each line individually.\n\nAlso ensure arrow syntax: Use \"→\" before each step. For decisions, we use \"Decision:\" then indentation for Yes/No. Provide lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 MapSum 物件 // 初始化根節點與鍵值雜湊表  \n    → TrieNode root = new TrieNode() // 根節點，sum 初始為 0  \n    → Map<String, Integer> keyToVal = new HashMap() // 儲存鍵對應的原始值  \n→ Step 2: insert(key, val) // 插入或覆寫鍵值對  \n    → Integer oldVal = keyToVal.getOrDefault(key, 0) // 取得舊值，若無則 0  \n    → Integer diff = val - oldVal // 計算需要更新的差值  \n    → keyToVal.put(key, val) // 更新鍵對應值  \n    → TrieNode node = root // 從根節點開始  \n    → Decision: 逐字處理 key? // 逐個字元往下走  \n        Yes →  \n            → Decision: node.children 是否有 char? // 若沒有則新建節點  \n                Yes →  \n                No  → node.children.put(char, new TrieNode()) // 新建子節點  \n            → node = node.children.get(char) // 進入子節點  \n            → node.sum += diff // 在此節點累加差值  \n        No → // 完成 insert  \n→ Step 3: sum(prefix) // 取得前綴總和  \n    → TrieNode node = root // 從根節點開始  \n    → Decision: 逐字處理 prefix? // 逐個字元往下走  \n        Yes →  \n            → Decision: node.children 是否有 char? // 若不存在直接回 0  \n                Yes → node = node.children.get(char)  \n                No  → return 0 // 前綴不存在  \n        No → // 所有字元已處理  \n    → return node.sum // 返回累加的總和  \nEnd // 程式結束",
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n\nclass MapSum:\n    def __init__(self):\n        # 根節點\n        self.root = TrieNode()\n        # 儲存鍵對應的原始值\n        self.key_val = {}\n\n    def insert(self, key: str, val: int) -> None:\n        old_val = self.key_val.get(key, 0)\n        diff = val - old_val\n        self.key_val[key] = val\n\n        node = self.root\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += diff\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，預期為 JSON 格式\n    data = json.loads(sys.stdin.read())\n    commands, args = data\n\n    obj = None\n    results = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MapSum\":\n            obj = MapSum()\n            results.append(None)\n        elif cmd == \"insert\":\n            key, val = arg[0], arg[1]\n            obj.insert(key, val)\n            results.append(None)\n        elif cmd == \"sum\":\n            prefix = arg[0]\n            results.append(obj.sum(prefix))\n\n    # 輸出結果，使用 JSON 轉換以得到 `null` 的表示\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmperjw8wk5.py\", line 39, in <module>\n    data = json.loads(sys.stdin.read())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 45 (char 44)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode137.json",
    "problem_index_in_file": 0,
    "title": "Single Number II",
    "description_snippet": "Given an integer array nums where every element appears three times except for one, which appears ex...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: find single number appearing once while others thrice, linear time, constant space. Classic solution: bitwise counting modulo 3. We'll produce pseudo code steps: iterate array, for each bit maintain counts mod 3 via two variables. Or use 32-bit counters. We can produce bit count per bit. Let's produce pseudocode:\n\nStart\n→ Initialize res = 0\n→ For each num in nums:\n    → For i from 0 to 31:\n        → Extract bit (num >> i) & 1\n        → Update count array of size 32 using modulo 3: cnt[i] = (cnt[i] + bit) % 3\n→ For i from 0 to 31:\n    → If cnt[i] % 3 == 1:\n        → Set bit i in res\n→ Return res\nEnd\n\nBut we need constant space: use two 32-bit integers to track ones and twos? Actually typical solution: use bitwise logic: ones, twos. We'll produce that algorithm.\n\nPseudo:\n\nStart\n→ Initialize ones = 0, twos = 0\n→ For each num in nums:\n    → twos = twos | (ones & num)\n    → ones = ones ^ num\n    → common_bit_mask = ~(ones & twos)\n    → ones = ones & common_bit_mask\n    → twos = twos & common_bit_mask\n→ Return ones\nEnd\n\nBut explanation.\n\nLet's produce each line with explanation. Ensure each line includes virtual code step and comment. Use arrows accordingly. Use \"Decision:\" where necessary? Not needed.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 `ones = 0`，`twos = 0` // 用來紀錄每個位元出現一次與兩次的情況  \n→ Step 2: 迭代陣列 `nums` 中的每個數字 `num`  \n  → Sub-Step: 更新 `twos` 為 `twos | (ones & num)` // 若此位元已出現一次且目前數字也有此位，則加入兩次集  \n  → Sub-Step: 更新 `ones` 為 `ones ^ num` // 若此位元首次出現則加到 `ones`，已出現兩次則移除  \n  → Sub-Step: 計算 `common_bit_mask = ~(ones & twos)` // 找出同時在 `ones` 與 `twos` 的位元，這些位元將被重置  \n  → Sub-Step: 清除這些位元  \n    → `ones = ones & common_bit_mask` // 只保留未同時出現兩次的位元  \n    → `twos = twos & common_bit_mask` // 同上  \n→ Step 3: 迴圈結束後，`ones` 內即為只出現一次的數字 // 其餘數字已被除外  \n→ Step 4: 回傳 `ones` // 結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef singleNumber(nums):\n    \"\"\"\n    找到只出現一次的數字，其他數字都出現三次。\n    這個方法只使用常數空間，時間複雜度為 O(n)。\n    \"\"\"\n    ones = twos = 0            # 兩個 32 位整數，分別記錄「已出現一次」和「已出現兩次」的位元\n    for num in nums:\n        # 如果 num 的某位元已經在 ones 裡，則把它加到 twos；否則不改\n        twos |= ones & num\n        # 對 ones 進行 XOR，得到 num 這個數字的位元\n        ones ^= num\n        # 同時在 ones 和 twos 的位元表示出現了三次，這些位元需要被清除\n        common = ~(ones & twos)\n        ones &= common\n        twos &= common\n    return ones\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個資料\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，支援「nums = [ ... ]」或僅 \"[ ... ]\" 的格式\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_str = list_part.strip()\n    else:\n        list_str = data\n\n    # 使用 ast.literal_eval 以安全方式解析字串為列表\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    # 計算並輸出結果\n    result = singleNumber(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "success": true,
          "output": "99"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode478.json",
    "problem_index_in_file": 0,
    "title": "Generate Random Point in a Circle",
    "description_snippet": "Given the radius and the position of the center of a circle, implement the function randPoint which ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the task: generate uniform random point inside circle. So algorithm: use polar coordinates: generate random radius sqrt(r)*radius; generate random angle uniform 0 to 2π. Then x = center_x + r * cos(theta); y = center_y + r * sin(theta). Provide step-by-step virtual code lines with explanation comments.\n\nAlso include initialization steps: storing radius, center.\n\nVirtual code must use Start, End, Decision, etc.\n\nWe need to produce each line with \"虛擬碼步驟 // 解釋\". Use arrow lines.\n\nWe need to reflect function calls: constructor, randPoint. Provide internal steps.\n\nWe should include the random number generation calls: rand() for angle and for sqrt.\n\nThus structure: Start -> Step 1: initialize attributes -> Step 2: define randPoint -> inside it: generate u=random uniform [0,1], v=random uniform [0,1], r = sqrt(u)*radius, theta=2π*v, compute x, y. Return [x,y].\n\nAlso decision not needed. But we can still show if needed. But minimal.\n\nLet's craft virtual code lines.\n\nUse \"→\" for progression.\n\nWe might need \"Decision:\" for generating random? Not necessary. We'll just show steps.\n\nWe should include comment after each line.\n\nLet's output as requested.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告屬性 radius, x_center, y_center // 儲存圓半徑與中心座標  \n→ Step 2: Solution(radius, x_center, y_center) // 建構子初始化物件  \n    → Step 2.1: this.radius ← radius  \n    → Step 2.2: this.x_center ← x_center  \n    → Step 2.3: this.y_center ← y_center  \n→ Step 3: 定義方法 randPoint() // 產生隨機點  \n    → Step 3.1: u ← RandomUniform(0, 1) // 產生 [0,1] 之隨機數  \n    → Step 3.2: v ← RandomUniform(0, 1) // 再產生另一個隨機數  \n    → Step 3.3: r ← sqrt(u) * this.radius // 轉換為半徑以保證均勻分布  \n    → Step 3.4: theta ← 2 * PI * v // 生成均勻角度  \n    → Step 3.5: x ← this.x_center + r * cos(theta) // 計算 X 座標  \n    → Step 3.6: y ← this.y_center + r * sin(theta) // 計算 Y 座標  \n    → Step 3.7: return [x, y] // 傳回隨機點座標  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    \"\"\"\n    用於在指定圓內產生均勻隨機點的類別。\n    \"\"\"\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        \"\"\"\n        初始化圓的半徑與中心座標。\n        \"\"\"\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        \"\"\"\n        隨機產生一個位於圓內（含邊界）的點。\n\n        產生方式：\n        1. 產生 0~1 的均勻隨機數 u，用 sqrt(u)*radius 取得半徑，\n           這樣能保證在圓面內部的分布均勻。\n        2. 產生 0~1 的均勻隨機數 v，並以 2πv 轉成角度 theta。\n        3. 依極座標轉為直角座標，得到 (x, y)。\n        \"\"\"\n        u = random.random()          # [0, 1)\n        v = random.random()          # [0, 1)\n        r = math.sqrt(u) * self.radius\n        theta = 2 * math.pi * v\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    \"\"\"\n    讀取 stdin 的兩行輸入，分別為指令列表與參數列表，\n    並依序執行，最後將結果輸出為 JSON 格式。\n    \"\"\"\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n\n    commands = json.loads(data[0])          # 例: [\"Solution\", \"randPoint\", ...]\n    arguments = json.loads(data[1]) if len(data) > 1 else []\n\n    results = []\n    obj = None\n\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)             # 建構子回傳 null\n        else:\n            # 取得對應方法並呼叫\n            method = getattr(obj, cmd)\n            results.append(method())\n\n    # 輸出 JSON，Python 的 None 會被轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.2582003476764494,-0.07081969434570758],[0.15546188903744834,0.22780690980349808],[0.6985607466821037,-0.28177591559361953]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.2582003476764494, -0.07081969434570758], [0.15546188903744834, 0.22780690980349808], [0.6985607466821037, -0.28177591559361953]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode77.json",
    "problem_index_in_file": 0,
    "title": "Combinations",
    "description_snippet": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for generating combinations. Use backtracking. Provide each line with explanation. Use Start, End, Decision. Should be simple.\n\nWe'll produce lines:\n\nStart // begin\n\n→ Step 1: define function combine(n, k) // main entry\n\n→ Step 2: initialize result list // store combinations\n\n→ Step 3: call backtrack(start=1, current=[]) // start backtracking\n\n→ Step 4: return result // final return\n\nDefine backtrack:\n\n→ Step 5: if len(current) == k: // found combination\n\n    → Step 6: append copy of current to result // add to answer\n\n    → Step 7: return // end this branch\n\n→ Decision: if start > n: // no more numbers to consider\n\n    Yes → Step 8: return // exit\n\nNo → For i in range(start, n+1): // iterate\n\n    → Step 9: append i to current // add number\n\n    → Step 10: backtrack(i+1, current) // next level\n\n    → Step 11: pop last from current // backtrack\n\nEnd\n\nNeed to format each line with \"→\" arrow? For steps maybe. But must match format requirement: Each line: 虛擬碼步驟 + space + // 解釋. Use arrows accordingly. For decisions, we indent sub-steps with tab or spaces? The example uses indentation.\n\nLet's produce. Use 'Start' and 'End' as top-level. We'll use function combine and backtrack defined within.\n\nWe need to maintain indentation. Let's show using spaces before lines after decision.\n\nMake sure each line ends with // explanation. Provide comments after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: function combine(n, k) // 定義主函式，接收範圍上限 n 與組合長度 k\n→ Step 2: result ← [] // 建立儲存所有組合的清單\n→ Step 3: backtrack(start = 1, current = []) // 從 1 開始，空的暫存組合進行回溯\n→ Step 4: return result // 回傳完成的組合清單\nEnd // 程式結束\n\nStart // 回溯子函式\n→ Step 5: function backtrack(start, current) // start 為下一個可選數字，current 為目前已選的數字集合\n→ Decision: 如果 len(current) == k? // 檢查是否已選到所需長度\n    Yes → Step 6: result.append(copy_of(current)) // 將完整組合加入結果\n    Yes → Step 7: return // 回到上一層\n→ Decision: 如果 start > n? // 沒有更多數字可選\n    Yes → Step 8: return // 結束此分支\n→ For i ← start to n do // 嘗試從 start 開始到 n 的每個數字\n    → Step 9: current.append(i) // 把 i 加入目前組合\n    → Step 10: backtrack(i + 1, current) // 以 i+1 為新起點遞迴\n    → Step 11: current.pop() // 從目前組合移除 i，回溯\nEnd // 回溯子函式結束",
      "generated_code": "import sys\nimport re\n\ndef combine(n: int, k: int):\n    \"\"\"Return all combinations of k numbers from 1 to n.\"\"\"\n    res = []\n\n    def backtrack(start: int, path: list):\n        # Decision: If the current combination has reached the desired length\n        if len(path) == k:\n            res.append(path[:])   # Store a copy of the current combination\n            return\n        # Iterate over remaining numbers\n        for i in range(start, n + 1):\n            path.append(i)            # Choose number i\n            backtrack(i + 1, path)    # Recurse with next start\n            path.pop()                # Backtrack: remove i\n\n    backtrack(1, [])  # Start backtracking with the first number\n    return res\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read()\n    # Extract all integers from the input string\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) >= 2:\n        n, k = nums[0], nums[1]\n    else:\n        # If insufficient numbers are provided, default to zeros (invalid case)\n        n, k = 0, 0\n    # Compute and print the combinations\n    result = combine(n, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4, k = 2",
          "expected_output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
          "success": true,
          "output": "[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode365.json",
    "problem_index_in_file": 0,
    "title": "Water and Jug Problem",
    "description_snippet": "You are given two jugs with capacities x liters and y liters. You have an infinite water supply. Ret...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate a virtual code algorithm for the water jug problem, using the operations. Essentially standard approach: Check if target <= x+y and target is multiple of gcd(x,y). Also handle trivial cases. Provide steps. Need to use Start, Decision, Yes→ etc. Provide line by line with explanations. Use 虛擬碼步驟 and //. Let's craft. Use Start, End. Steps: input x,y,target. Check if target<0 or target> x+y -> No. Check gcd(x,y). If target % gcd !=0 -> No. else Yes. Also handle trivial target 0 -> yes. So produce steps. Use arrow and decisions. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入兩個水壺容量 x、y 及目標水量 target // 從使用者處取得必要參數  \n→ Decision: target 是否為負數？ // 檢查目標值是否合法  \n  Yes → Step 2: 回傳 False // 目標為負數，無法達成  \n  No  → Decision: target 是否等於 0？ // 零水量總是可達  \n    Yes → Step 3: 回傳 True // 目標為 0，直接回傳成功  \n    No  → Decision: target 是否大於 x + y？ // 超過兩個水壺總容量，無法達成  \n     Yes → Step 4: 回傳 False // 目標超過最大容量，失敗  \n     No  → Step 5: 計算 gcd_x_y ← GCD(x, y) // 取得兩個水壺容量的最大公因數  \n     Decision: target 是否能被 gcd_x_y 整除？ // 必要條件：目標為 gcd 的倍數  \n      Yes → Step 6: 回傳 True // 目標符合可達性條件，回傳成功  \n      No  → Step 7: 回傳 False // 目標不是 gcd 的倍數，無法達成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef gcd(a, b):\n    \"\"\"計算兩個數的最大公因數（Euclid 演算法）\"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef can_measure(x: int, y: int, target: int) -> bool:\n    \"\"\"\n    判斷是否能用容量為 x、y 的兩個水壺測量出 target 公升。\n    主要判斷條件：\n        1. target 必須不為負數。\n        2. target 為 0 時總是可達。\n        3. target 不能超過兩個水壺的總容量 x + y。\n        4. target 必須能被 gcd(x, y) 整除。\n    \"\"\"\n    if target < 0:\n        return False\n    if target == 0:\n        return True\n    if target > x + y:\n        return False\n    return target % gcd(x, y) == 0\n\ndef main() -> None:\n    \"\"\"從 stdin 讀取輸入，計算並輸出結果。\"\"\"\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if len(nums) < 3:\n        return  # 輸入不足，直接結束\n    x, y, target = map(int, nums[:3])\n    result = can_measure(x, y, target)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 3, y = 5, target = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = 2, y = 6, target = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 1, y = 2, target = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode689.json",
    "problem_index_in_file": 0,
    "title": "Maximum Sum of 3 Non-Overlapping Subarrays",
    "description_snippet": "Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step for algorithm. The problem: find three non-overlapping subarrays length k with maximum sum. Known solution uses prefix sums, left best array, right best array, and then iterate middle. Provide steps. Provide virtual code lines. Each line with // explanation. Use Start, End, Decision, etc. Let's craft.\n\nWe'll start with Start. Then Step: compute prefix sums. Then Step: compute sums of each subarray of length k. Then Step: compute left best indices array of size n-k+1, where left[i] gives best starting index up to i. Then Step: compute right best indices array, similar from right. Then Step: iterate middle subarray start from k to n-2k. For each middle, compute left index via left[i-k], right index via right[i+k]. Compute total sum. Keep best sum and lexicographically smallest indices.\n\nWe also need to handle ties: if total sum > best, update. If equal, compare lexicographically.\n\nWe produce virtual code lines with arrow etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 n ← 長度(nums) // 取得陣列長度  \n→ Step 2: 建立 prefix[0..n]，prefix[0] ← 0 // 前綴和，方便計算子陣列和  \n→ Decision: for i in 1..n? // 計算前綴和  \n  Yes → Step 3: prefix[i] ← prefix[i-1] + nums[i-1] // 前綴和累加  \n→ End // 完成前綴和  \n→ Step 4: 計算 subSum[0..n-k]，其中 subSum[i] = prefix[i+k] - prefix[i] // 每個長度為 k 的子陣列和  \n→ Step 5: 建立 leftBest[0..n-k]，左側最佳起點陣列  \n→ Decision: for i in 0..n-k? // 遍歷所有子陣列起點  \n  Yes → Decision: i == 0? // 第一個子陣列  \n    Yes → Step 6: leftBest[i] ← i // 初始左側最佳  \n    No  → Decision: subSum[i] > subSum[leftBest[i-1]]? // 比較與前一最佳  \n      Yes → Step 7: leftBest[i] ← i // 取較大和的起點  \n      No  → Step 8: leftBest[i] ← leftBest[i-1] // 保留較早的最佳起點  \n→ End // 完成左側最佳起點  \n→ Step 9: 建立 rightBest[0..n-k]，右側最佳起點陣列  \n→ Decision: for i in (n-k) downto 0? // 從右往左遍歷  \n  Yes → Decision: i == n-k? // 最後一個子陣列  \n    Yes → Step 10: rightBest[i] ← i // 初始右側最佳  \n    No  → Decision: subSum[i] > subSum[rightBest[i+1]]? // 與右側下一個最佳比較  \n      Yes → Step 11: rightBest[i] ← i // 取較大和的起點  \n      No  → Step 12: rightBest[i] ← rightBest[i+1] // 保留較晚的最佳起點  \n→ End // 完成右側最佳起點  \n→ Step 13: 初始化 bestSum ← -∞，answer ← [0,0,0] // 儲存最優結果  \n→ Step 14: 對 middleStart 在 k..(n-2k) 進行遍歷 // 中間子陣列起點  \n  → Decision: 取左側最佳 left ← leftBest[middleStart - k] // 不重疊左側  \n    Yes → Decision: 取右側最佳 right ← rightBest[middleStart + k] // 不重疊右側  \n      Yes → Step 15: total ← subSum[left] + subSum[middleStart] + subSum[right] // 三個子陣列總和  \n      → Decision: total > bestSum? // 是否更優  \n       Yes → Step 16: bestSum ← total // 更新最佳和  \n         → Step 17: answer ← [left, middleStart, right] // 更新最佳索引  \n       No → Decision: total == bestSum? // 可能有多組答案  \n        Yes → Step 18: if [left, middleStart, right] lexicographically smaller than answer?  \n          Yes → Step 19: answer ← [left, middleStart, right] // 優先更小的索引組合  \n         No → Step 20: // 既有更大和或索引更大，保持原 answer  \n→ End // 遍歷完所有中間起點  \n→ Step 21: 回傳 answer // 返回三個子陣列的起始索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        m = n - k + 1  # number of subarrays of length k\n\n        # Step 1: compute sums of all length-k subarrays\n        w = [0] * m\n        window_sum = sum(nums[:k])\n        w[0] = window_sum\n        for i in range(1, m):\n            window_sum += nums[i + k - 1] - nums[i - 1]\n            w[i] = window_sum\n\n        # Step 2: left best indices (earliest on ties)\n        left = [0] * m\n        best = 0\n        for i in range(m):\n            if w[i] > w[best]:\n                best = i\n            left[i] = best\n\n        # Step 3: right best indices (earliest on ties)\n        right = [0] * m\n        best = m - 1\n        for i in range(m - 1, -1, -1):\n            if w[i] >= w[best]:\n                best = i\n            right[i] = best\n\n        # Step 4: iterate middle subarray\n        best_sum = -1\n        answer = []\n        for mid in range(k, m - k):\n            left_idx = left[mid - k]\n            right_idx = right[mid + k]\n            total = w[left_idx] + w[mid] + w[right_idx]\n\n            if total > best_sum:\n                best_sum = total\n                answer = [left_idx, mid, right_idx]\n            elif total == best_sum:\n                # choose lexicographically smaller indices\n                if [left_idx, mid, right_idx] < answer:\n                    answer = [left_idx, mid, right_idx]\n\n        return answer\n\ndef parse_input(text: str):\n    \"\"\"Parse input like 'nums = [1,2,1,2,6,7,5,1], k = 2'.\"\"\"\n    nums_match = re.search(r'\\[([^\\]]*)\\]', text)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', text)\n\n    if not nums_match or not k_match:\n        raise ValueError(\"Input format is incorrect.\")\n\n    nums_str = nums_match.group(1)\n    nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n    k = int(k_match.group(1))\n    return nums, k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    nums, k = parse_input(data)\n    sol = Solution()\n    result = sol.maxSumOfThreeSubarrays(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1,2,6,7,5,1], k = 2",
          "expected_output": "[0,3,5]",
          "success": true,
          "output": "[0, 3, 5]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,1,2,1,2,1,2,1], k = 2",
          "expected_output": "[0,2,4]",
          "success": true,
          "output": "[0, 2, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode680.json",
    "problem_index_in_file": 0,
    "title": "Valid Palindrome II",
    "description_snippet": "Given a string s, return true if the s can be palindrome after deleting at most one character from i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step pseudocode with explanation per line. We need to adhere to format: each line \"虛擬碼步驟 // 解釋\". Use arrow and decision.\n\nWe need to solve problem: check if string can become palindrome after at most one deletion.\n\nWe need to produce algorithm. Typical solution: two-pointer, when mismatch occurs, check if skipping left or right yields palindrome. Use helper function isPalindromeRange(i,j). If mismatch occurs at positions i,j: if (isPal(i+1,j) or isPal(i,j-1)) return true else false. If no mismatch, return true.\n\nWe'll produce steps accordingly.\n\nMake sure to use Start, End.\n\nWe'll produce lines:\n\nStart\n→ Step 1: 定義指標 left = 0, right = len(s)-1 // 初始化左右指標\n→ Decision: while left < right? // 進入循環比對\n    Yes → Step 2: 如果 s[left] == s[right]? // 同字元\n        Yes → Step 3: left +=1, right -=1 // 移動指標\n        No  → Decision: 可以刪除左邊字元? // 嘗試刪除左邊\n            Yes → Step 4: 檢查子串 s[left+1...right] 是否為回文? // 呼叫檢查\n                Yes → Step 5: 返回 true // 成功\n                No  → Decision: 可以刪除右邊字元? // 嘗試刪除右邊\n                    Yes → Step 6: 檢查子串 s[left...right-1] 是否為回文?\n                        Yes → Step 7: 返回 true\n                        No  → Step 8: 返回 false\n                    No  → Step 8: 返回 false\n    // loop ends\n    No → Step 9: 返回 true // 完全回文\nEnd\n\nBut must be structured.\n\nLet's write lines with arrow. Use proper indentation with tabs/spaces maybe. Must follow format: \"虛擬碼步驟 // 解釋\".\n\nWe need to include \"Decision:\" lines with Yes → and No →.\n\nMake sure each step is clear.\n\nAlso need helper: Step 4 \"調用 isPalindromeRange\" etc.\n\nWe'll include function isPalindromeRange(i,j) definition.\n\nBetter: define function isPalindromeRange(i,j) first.\n\nLet's produce:\n\nStart\n→ Step 1: 定義函式 isPalindromeRange(start, end): // 判斷子串是否為回文\n    → Decision: start >= end?\n        Yes → Return true // 空串或單一字符自動回文\n        No  → Decision: s[start] == s[end]?\n            Yes → Return isPalindromeRange(start+1, end-1)\n            No  → Return false\n→ Step 2: 初始化 left = 0, right = len(s)-1 // 設定左右指標\n→ Decision: left < right?\n    Yes → Step 3: 如果 s[left] == s[right]?\n        Yes → Step 4: left +=1, right -=1 // 移動指標\n        No  → Decision: isPalindromeRange(left+1, right)?\n            Yes → Step 5: 返回 true // 刪除左側字符後為回文\n            No  → Decision: isPalindromeRange(left, right-1)?\n                Yes → Step 6: 返回 true // 刪除右側字符後為回文\n                No  → Step 7: 返回 false // 兩種刪除皆非回文\n    No  → Step 8: 返回 true // 沒有不匹配字符，已是回文\nEnd\n\nBut we need to indicate Start and End.\n\nMake sure each line includes // explanation.\n\nLet's format properly.\n\nAlso ensure we include \"Yes →\" and \"No →\" lines inside Decision.\n\nAlso note that in pseudocode, we need to show arrows for transitions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 isPalindromeRange(start, end): // 用於判斷子串是否為回文  \n    → Decision: start >= end? // 判斷子串長度是否已至基底情況  \n        Yes → Return true // 空串或單字元自動是回文  \n        No  → Decision: s[start] == s[end]? // 比對首尾字元  \n            Yes → Return isPalindromeRange(start+1, end-1) // 進入下一層判斷  \n            No  → Return false // 不匹配即非回文  \n→ Step 2: 初始化 left = 0, right = len(s)-1 // 設定左右指標  \n→ Decision: left < right? // 若仍有待比對字元  \n    Yes → Step 3: 如果 s[left] == s[right]? // 同字元時可直接進一步  \n        Yes → Step 4: left +=1, right -=1 // 左右指標向內移動  \n        No  → Decision: isPalindromeRange(left+1, right)? // 嘗試刪除左側字元  \n            Yes → Step 5: 返回 true // 刪除左側後為回文  \n            No  → Decision: isPalindromeRange(left, right-1)? // 嘗試刪除右側字元  \n                Yes → Step 6: 返回 true // 刪除右側後為回文  \n                No  → Step 7: 返回 false // 兩種刪除皆非回文  \n    No  → Step 8: 返回 true // 已完全比對且無不匹配，為回文  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        \"\"\"判斷是否可以刪除最多一個字元後成為回文。\"\"\"\n        def is_palindrome_range(i: int, j: int) -> bool:\n            \"\"\"檢查子串 s[i:j+1] 是否為回文。\"\"\"\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n\n        i, j = 0, len(s) - 1\n        while i < j:\n            if s[i] != s[j]:\n                # 嘗試刪除左側或右側字元\n                return is_palindrome_range(i + 1, j) or is_palindrome_range(i, j - 1)\n            i += 1\n            j -= 1\n        return True\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先嘗試從字串中找出被雙引號包住的內容\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有引號，直接使用整行資料（去除可能的前綴）\n        s = data.replace('s =', '').strip()\n\n    sol = Solution()\n    result = sol.validPalindrome(s)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aba\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"abca\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"abc\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode730.json",
    "problem_index_in_file": 0,
    "title": "Count Different Palindromic Subsequences",
    "description_snippet": "Given a string s, return the number of different non-empty palindromic subsequences in s. Since the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. It's an algorithm: count distinct non-empty palindromic subsequences. Classic DP with dp[i][j]. Approach: for each pair i,j, if s[i]==s[j], then dp[i][j] = dp[i+1][j] + dp[i][j-1] + 1; else dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]; handle duplicates: if same character appears inside. Use next/prev arrays. Modulo. We'll produce virtual steps line by line. Not code, but steps. Use Start, End, Decision, etc. Provide explanation after each line. Let's craft.\n\nWe need to outline steps: Input string s; n=length; init dp[n][n]; fill base cases dp[i][i]=1. Then iterate length from 2 to n. For each i start, j=i+len-1. Decision: if s[i]==s[j]. Then find next[i], prev[j] inside. Depending on count. etc. Compute. Mod. Return dp[0][n-1] % MOD.\n\nLet's produce each step line by line. Use arrow. Use decision block. Let's craft.\n\nWe need not give actual code, just pseudo steps. Provide explanation comments.\n\nLet's produce maybe around 20-25 lines. Each line must have \"虛擬碼步驟\" and comment.\n\nWe'll use \"Start\" first. Then \"→ Step 1: 讀取字串 s\" etc.\n\nWe need to decide about DP initialization, loops, etc. Provide decisions inside loops. We'll use nested decision.\n\nLet's produce.\n\nNote: Provide lines like \"→ Step 2: 計算字串長度 n\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 從使用者取得要處理的字串  \n→ Step 2: 計算字串長度 n = length(s) // 用來建立 DP 表格  \n→ Step 3: 初始化 2D 數組 dp[n][n] 為 0 // dp[i][j] 將存放子字串 s[i..j] 的答案  \n→ Decision: n 是否為 0? // 檢查字串是否為空  \n    Yes → Step 4: 回傳 0 // 空字串沒有非空子序列  \n    No → Step 5: 進入主程序 // 進行 DP 計算  \n→ Step 6: 對 i 從 0 到 n-1 做循環  \n    → Step 7: 設定 dp[i][i] = 1 // 單個字符本身就是一個回文子序列  \n→ Step 8: 對 length 從 2 到 n 做循環 // 依子字串長度遞增  \n    → Decision: length 是否為 1? // 只在此階段需要判斷  \n        Yes → (跳過)  \n        No →  \n            → Step 9: 對 i 從 0 到 n - length 做循環  \n                → Step 10: 設 j = i + length - 1 // 子字串結尾位置  \n                → Decision: s[i] == s[j]? // 判斷首尾字符是否相同  \n                    Yes →  \n                        → Step 11: 找到 i 之後第一次出現 s[i] 的位置 next_i  \n                        → Step 12: 找到 j 之前最後一次出現 s[j] 的位置 prev_j  \n                        → Decision: next_i > prev_j? // 是否在中間沒有相同字符  \n                            Yes → Step 13: dp[i][j] = dp[i+1][j] + dp[i][j-1] + 1  \n                            No →  \n                                → Decision: next_i == prev_j? // 只出現一次中間字符  \n                                    Yes → Step 14: dp[i][j] = dp[i+1][j] + dp[i][j-1] + 1  \n                                    No → Step 15: dp[i][j] = dp[i+1][j] + dp[i][j-1] + 1 - dp[next_i+1][prev_j-1]  \n                            // 需要扣除重複計算的子序列  \n                    No →  \n                        → Step 16: dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]  \n                        // 當首尾不同時，結合左右子問題並扣除重疊  \n                    // 以上皆須模 MOD  \n                    → Step 17: dp[i][j] = (dp[i][j] % MOD + MOD) % MOD // 保證非負且取模  \n→ Step 18: 回傳 dp[0][n-1] // 最終答案為整個字串的計算結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # Build next occurrence array: next_pos[i][c] is the first index >= i where s[index] == c\n    next_arr = [[-1] * 26 for _ in range(n + 1)]\n    next_pos = [-1] * 26\n    for i in range(n - 1, -1, -1):\n        next_pos[ord(s[i]) - 97] = i\n        next_arr[i] = next_pos.copy()\n    # next_arr[n] stays all -1\n\n    # Build previous occurrence array: prev_pos[i][c] is the last index <= i where s[index] == c\n    prev_arr = [[-1] * 26 for _ in range(n)]\n    prev_pos = [-1] * 26\n    for i in range(n):\n        prev_pos[ord(s[i]) - 97] = i\n        prev_arr[i] = prev_pos.copy()\n\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n + 1):\n        for i in range(0, n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                c = ord(s[i]) - 97\n                left = next_arr[i + 1][c]\n                right = prev_arr[j - 1][c]\n                if left == -1 or left > right:\n                    val = dp[i + 1][j - 1] * 2 + 2\n                elif left == right:\n                    val = dp[i + 1][j - 1] * 2 + 1\n                else:\n                    val = dp[i + 1][j - 1] * 2 - dp[left + 1][right - 1]\n            else:\n                val = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]\n            dp[i][j] = val % MOD\n\n    return dp[0][n - 1] % MOD\n\ndef main():\n    data = sys.stdin.read()\n    # Try to extract a quoted string; if none, use the whole input\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        s = data.strip()\n    print(count_palindromic_subsequences(s))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "success": true,
          "output": "104860361"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode5.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Substring",
    "description_snippet": "Given a string s, return the longest palindromic substring in s....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm: find longest palindromic substring. Common approach: Expand around center or DP or Manacher's. We'll choose expand around center for simplicity. Provide each step line with explanation. Format with \"Start\", \"→\", \"Decision:\", \"Yes →\", \"No →\". Use 虛擬碼步驟 + // explanation. Each line separate.\n\nWe must output step-by-step. Provide pseudo-code.\n\nLet's outline:\n\nStart\n→ Step 1: Define maxLen = 0, startIndex = 0 // init variables\n→ Step 2: For each index i from 0 to len(s)-1:\n   → Decision: expandOdd = expand(i, i) // get length\n   → Decision: expandEven = expand(i, i+1)\n   → Decide longer\n   → Update maxLen and startIndex if longer\n\n→ Function expand(left, right): while left>=0 && right< len(s) && s[left]==s[right] { left--, right++ }; return right-left-1\n\n→ After loop, return substring(startIndex, startIndex+maxLen)\n\nEnd\n\nNow convert to virtual code with arrows.\n\nWe need to put each step in its own line, with \"→\" indentation maybe.\n\nUse \"→ Step ...\"\n\nMake sure to include decision arrows.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 maxLen = 0, startIndex = 0 // 用來追蹤目前最長回文的長度與起始位置  \n→ Step 2: For i 從 0 到 len(s)-1 迴圈 // 對每個字元作為中心點  \n    → Decision: length1 = expand(i, i) // 以 i 為單一中心擴展（奇數長回文）  \n    → Decision: length2 = expand(i, i+1) // 以 i 與 i+1 為中心擴展（偶數長回文）  \n    → Decision: 如果 length1 > length2?  \n        Yes → longest = length1  \n        No  → longest = length2  \n    → Decision: 如果 longest > maxLen?  \n        Yes → maxLen = longest  \n        No  → // 保持目前的 maxLen  \n    → Decision: 如果 longest > maxLen? // 更新起始位置  \n        Yes → startIndex = i - (longest-1)//2  \n        No  → // 不變  \n→ Function expand(left, right):  \n    → While left >= 0 且 right < len(s) 且 s[left] == s[right] 循環 // 兩邊相等則擴大  \n        left = left - 1  \n        right = right + 1  \n    → Return right - left - 1 // 回傳擴展後的回文長度  \n→ Step 3: Return s.substring(startIndex, startIndex + maxLen) // 取得最長回文子字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        Find the longest palindromic substring in s using expand-around-center.\n        \"\"\"\n        if not s:\n            return \"\"\n\n        start, max_len = 0, 0\n\n        for i in range(len(s)):\n            # Odd length palindrome (center at i)\n            len1 = self._expand(s, i, i)\n            # Even length palindrome (center between i and i+1)\n            len2 = self._expand(s, i, i + 1)\n            # Choose the longer one\n            longest = max(len1, len2)\n\n            if longest > max_len:\n                max_len = longest\n                start = i - (longest - 1) // 2\n\n        return s[start:start + max_len]\n\n    def _expand(self, s: str, left: int, right: int) -> int:\n        \"\"\"\n        Expand around the center (left, right) and return the length of the palindrome.\n        \"\"\"\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        # After the loop, left+1 .. right-1 are the palindrome indices\n        return right - left - 1\n\n\ndef _extract_string(raw_input: str) -> str:\n    \"\"\"\n    Extract the string value from a line like: s = 'babad'\n    \"\"\"\n    raw_input = raw_input.strip()\n    # Find the first quote (single or double)\n    for quote in (\"'\", '\"'):\n        start = raw_input.find(quote)\n        if start != -1:\n            end = raw_input.find(quote, start + 1)\n            if end != -1:\n                return raw_input[start + 1:end]\n    # If no quotes, return the whole trimmed line\n    return raw_input\n\n\ndef main():\n    # Read entire stdin\n    raw = sys.stdin.read()\n    # Extract the string to be processed\n    s = _extract_string(raw)\n    # Compute longest palindrome\n    sol = Solution()\n    result = sol.longestPalindrome(s)\n    # Print with surrounding single quotes as required by the examples\n    print(f\"'{result}'\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'babad'",
          "expected_output": "'bab'",
          "success": true,
          "output": "'bab'"
        },
        {
          "example_index": 1,
          "input": "s = 'cbbd'",
          "expected_output": "'bb'",
          "success": true,
          "output": "'bb'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode454.json",
    "problem_index_in_file": 0,
    "title": "4Sum II",
    "description_snippet": "Given four integer arrays A, B, C, and D all of length n, return the number of tuples (i, j, k, l) s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for counting 4-sum tuples. We should produce algorithm: compute pair sums of A+B and C+D, sort or hash, count matching negative sums. Use hash map to store sum frequencies. Complexity O(n^2). Virtual code lines. Let's craft step by step. Ensure use Start, End, Decision. Use arrow →. For loops, maybe represent as Step: For each i in range. Provide explanation. Provide virtual code. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空哈希表 sumAB → // 用於儲存 A[i]+B[j] 的頻率\n→ Step 2: 初始化答案 counter = 0 → // 統計符合條件的四元組數\n→ Step 3: 對 i 從 0 到 n-1 迭代 → // 遍歷陣列 A\n    → Step 3.1: 對 j 從 0 到 n-1 迭代 → // 遍歷陣列 B\n        → Step 3.1.1: 計算 s = A[i] + B[j] → // 兩數之和\n        → Step 3.1.2: sumAB[s] = sumAB.get(s, 0) + 1 → // 進行頻率累加\n→ Step 4: 對 k 從 0 到 n-1 迭代 → // 遍歷陣列 C\n    → Step 4.1: 對 l 從 0 到 n-1 迭代 → // 遍歷陣列 D\n        → Step 4.1.1: 計算 t = C[k] + D[l] → // 兩數之和\n        → Step 4.1.2: 再次計算 target = -t → // 需要的 A+B 之和\n        → Step 4.1.3: counter = counter + sumAB.get(target, 0) → // 若存在則累加\n→ End // 程式執行結束，counter 為符合條件的四元組總數",
      "generated_code": "import sys\nimport re\nimport collections\nimport ast\n\ndef four_sum_count(A, B, C, D):\n    \"\"\"\n    計算四個陣列中滿足 A[i] + B[j] + C[k] + D[l] == 0 的四元組個數。\n    先把 A 和 B 的所有兩兩和存成頻率表，然後對 C、D 的兩兩和查找其相對應的負值。\n    時間複雜度：O(n^2)，空間複雜度：O(n^2)。\n    \"\"\"\n    # A + B 的所有可能和及其頻率\n    ab_counter = collections.Counter(a + b for a in A for b in B)\n    count = 0\n    # C + D 的所有可能和，檢查是否有對應的 -(c + d) 在 ab_counter\n    for c in C:\n        for d in D:\n            target = -(c + d)\n            count += ab_counter.get(target, 0)\n    return count\n\ndef parse_input(input_str):\n    \"\"\"\n    從形如 'A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]' 的字串\n    解析出四個列表 A, B, C, D。\n    \"\"\"\n    # 找出所有方括號內的內容\n    lists = re.findall(r'\\[.*?\\]', input_str)\n    if len(lists) != 4:\n        raise ValueError(\"輸入格式錯誤，應包含四個列表。\")\n    # 使用 ast.literal_eval 轉成 Python list，確保安全\n    A = ast.literal_eval(lists[0])\n    B = ast.literal_eval(lists[1])\n    C = ast.literal_eval(lists[2])\n    D = ast.literal_eval(lists[3])\n    return A, B, C, D\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read()\n    # 去除首尾空白，避免換行影響解析\n    raw_input = raw_input.strip()\n    if not raw_input:\n        sys.exit(0)\n    try:\n        A, B, C, D = parse_input(raw_input)\n    except Exception as e:\n        print(f\"輸入解析錯誤: {e}\", file=sys.stderr)\n        sys.exit(1)\n    result = four_sum_count(A, B, C, D)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "A = [0], B = [0], C = [0], D = [0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode50.json",
    "problem_index_in_file": 0,
    "title": "Pow(x, n)",
    "description_snippet": "Implement pow(x, n), which calculates x raised to the power n (i.e., x^n)....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps for implementing pow(x, n). Provide step-by-step pseudocode with explanations. Should use virtual code structure with arrows, Start, End, Decision, Yes/No, etc. Need to produce lines like \"Start // 程式開始執行\". Provide algorithm maybe using exponentiation by squaring. Show input x, n. Could handle negative n by computing 1/(x^|n|). Also handle n=0. Also negative n maybe produce reciprocal.\n\nWe must output lines sequentially. Each line has virtual code step + space + explanation comment in Chinese.\n\nWe should not output actual code.\n\nLet's produce algorithm:\n\nStart\n→ Step 1: 獲取輸入 x, n // 取得底數與指數\n→ Decision: n < 0? // 檢查指數是否為負\n    Yes → Step 2: 設置 sign = -1; n = -n // 取正數\n    No  → Step 3: 設置 sign = 1\n→ Step 4: 計算 abs_n = n // 取指數的絕對值\n→ Step 5: 初始化 result = 1 // 結果初始值\n→ Step 6: 初始化 base = x // 基底\n→ Decision: abs_n > 0? // 是否還有剩餘指數\n    Yes → Decision: abs_n is odd? // 判斷指數奇偶\n        Yes → Step 7: result = result * base // 把基底乘到結果\n        No  → // 不操作\n    → Step 8: base = base * base // 基底平方\n    → Step 9: abs_n = abs_n / 2 // 整除二\n    → Go back to Decision: abs_n > 0?\n        // loop\n    No  → // 指數用完\n→ Decision: sign == -1? // 是否需要倒數\n    Yes → Step 10: result = 1 / result // 取倒數\n    No  → // 保持 result\n→ Step 11: 返回 result // 結束\nEnd\n\nWe need to use arrow syntax: \"→\" for each step, \"Decision:\" etc.\n\nWe need to include indentation: maybe indent inside Decision? The example shows indentation with 4 spaces. We can use same style.\n\nLet's produce the final answer with each line. Ensure each line ends with comment in Chinese.\n\nAlso we need to incorporate \"End\". Provide \"End // 程式執行結束\".\n\nMake sure lines count.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 獲取輸入 x, n // 取得底數與指數  \n→ Decision: n < 0? // 檢查指數是否為負  \n    Yes → Step 2: 設置 sign = -1; n = -n // 取指數的正值  \n    No  → Step 3: 設置 sign = 1 // 正指數不需調整  \n→ Step 4: 計算 abs_n = n // 取指數的絕對值  \n→ Step 5: 初始化 result = 1 // 結果初始為 1  \n→ Step 6: 初始化 base = x // 基底設為 x  \n→ Decision: abs_n > 0? // 是否還有剩餘指數  \n    Yes → Decision: abs_n 是奇數? // 判斷指數奇偶  \n        Yes → Step 7: result = result * base // 把基底乘到結果  \n        No  → // 沒有操作，因為偶數不需要直接乘  \n    → Step 8: base = base * base // 基底平方  \n    → Step 9: abs_n = abs_n / 2 // 指數除以二  \n    → 回到 Decision: abs_n > 0? // 重複直到指數為 0  \n    No  → // 指數用完，結束迴圈  \n→ Decision: sign == -1? // 是否需要取倒數  \n    Yes → Step 10: result = 1 / result // 取倒數  \n    No  → // 保持 result  \n→ Step 11: 返回 result // 傳回最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        \"\"\"計算 x 的 n 次方，使用快速冪算法，支援負指數\"\"\"\n        # n 為 0 時直接回傳 1\n        if n == 0:\n            return 1.0\n        # n 為負數時，先取倒數，再把 n 取正\n        if n < 0:\n            x = 1.0 / x\n            n = -n\n\n        def fastPow(a: float, b: int) -> float:\n            \"\"\"遞迴快速冪\"\"\"\n            if b == 0:\n                return 1.0\n            half = fastPow(a, b // 2)\n            if b % 2 == 0:\n                return half * half\n            else:\n                return half * half * a\n\n        return fastPow(x, n)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行字串，例如: 'x = 2.00000, n = 10'\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析 x 和 n\n    parts = [p.strip() for p in data.split(',')]\n    x_val = float(parts[0].split('=')[1].strip())\n    n_val = int(parts[1].split('=')[1].strip())\n\n    solver = Solution()\n    result = solver.myPow(x_val, n_val)\n    # 輸出保留五位小數\n    print(f\"{result:.5f}\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 2.00000, n = 10",
          "expected_output": "1024.00000",
          "success": true,
          "output": "1024.00000"
        },
        {
          "example_index": 1,
          "input": "x = 2.10000, n = 3",
          "expected_output": "9.26100",
          "success": true,
          "output": "9.26100"
        },
        {
          "example_index": 2,
          "input": "x = 2.00000, n = -2",
          "expected_output": "0.25000",
          "success": true,
          "output": "0.25000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode8.json",
    "problem_index_in_file": 0,
    "title": "String to Integer (atoi)",
    "description_snippet": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\n\nThe al...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. Use the arrow notation and decisions. Must not output actual code. Use the format: each line \"虛擬碼步驟 // 解釋\". Steps include Start, decisions, loops maybe. We need to implement algorithm: ignore whitespace, determine sign, read integer skipping leading zeros until non-digit, handle no digits => 0, clamp to 32-bit signed range. Let's produce steps.\n\nWe need to use \"Start\" at top, \"End\" at bottom. Use \"Decision:\" for checks. For loops, maybe \"Loop:\" but spec didn't define but we can use \"Loop:\"? It says use arrow and structure (Start, End, Decision:). We can use \"Loop:\" as a generic but not specified. We can just use \"While\" maybe. But we can keep it simple: use Decision for loops: Decision: next char is digit? Yes -> add digit to number; No -> break. For skipping leading zeros: we can decide next char is '0' skip. Use pointer index.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標於字串起始位置\n→ Step 2: n ← length(s) // 取得字串長度\n→ Step 3: While i < n and s[i] == ' ': i ← i + 1 // 跳過前導空白\n→ Decision: i >= n? // 若已到結尾，直接返回 0\n    Yes → Step 4: result ← 0 // 沒有數字，結果為 0\n    No  →\n→ Step 5: sign ← 1 // 預設正號\n→ Decision: s[i] == '-'? // 判斷符號\n    Yes → sign ← -1; i ← i + 1 // 設為負號並移動指標\n    No  →\n→ Decision: s[i] == '+'? // 判斷正號符號\n    Yes → i ← i + 1 // 移動指標\n    No  →\n→ Step 6: num ← 0 // 用於累積數值\n→ Decision: i >= n? // 若無更多字符，結束轉換\n    Yes → Step 7: result ← 0 // 無數字\n    No  →\n→ Step 8: While i < n and s[i] == '0': i ← i + 1 // 跳過前導零\n→ Step 9: While i < n and '0' <= s[i] <= '9': // 讀取數字\n        digit ← s[i] - '0' // 取得數字值\n        num ← num * 10 + digit // 累加\n        i ← i + 1 // 移動指標\n→ Step 10: num ← num * sign // 加上符號\n→ Step 11: If num < -2^31: num ← -2^31 // 下限截斷\n→ Decision: num > 2^31-1? // 上限截斷\n    Yes → num ← 2^31 - 1\n    No  →\n→ Step 12: result ← num // 設定最終結果\n→ Step 13: Return result // 回傳結果\nEnd // 程式執行結束\n\nBut we need each line format: \"虛擬碼步驟 // 解釋\". Use arrow. For decision, we need indent. Let's use consistent indent. Use spaces. Provide line for each step.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← 0 // 初始化指標至字串首位置  \n→ Step 2: n ← length(s) // 取得字串長度  \n→ Step 3: While i < n and s[i] == ' ': i ← i + 1 // 跳過前導空白字符  \n→ Decision: i ≥ n? // 若已到字串結尾  \n  Yes → Step 4: result ← 0 // 無數字，直接回傳 0  \n  No → // 繼續後續流程  \n→ Step 5: sign ← 1 // 預設正號  \n→ Decision: s[i] == '-'? // 判斷是否為負號  \n  Yes → sign ← -1; i ← i + 1 // 設為負號並移動指標  \n  No → // 留意後續可能為正號或數字  \n→ Decision: s[i] == '+'? // 判斷是否為正號符號  \n  Yes → i ← i + 1 // 移動指標跳過 '+'  \n  No → // 繼續讀取數字  \n→ Step 6: num ← 0 // 用於累積整數值  \n→ Decision: i ≥ n? // 若已無字符可讀  \n  Yes → Step 7: result ← 0 // 無數字，結果為 0  \n  No → // 繼續讀取  \n→ Step 8: While i < n and s[i] == '0': i ← i + 1 // 跳過前導零  \n→ Step 9: While i < n and '0' ≤ s[i] ≤ '9': // 讀取有效數字  \n  digit ← s[i] - '0' // 取得單個數字值  \n  num ← num * 10 + digit // 累加至整數  \n  i ← i + 1 // 移動至下一字符  \n→ Step 10: num ← num * sign // 加上符號  \n→ Decision: num < -2^31? // 判斷是否低於下限  \n  Yes → num ← -2^31 // 進行截斷  \n  No → // 留意上限  \n→ Decision: num > 2^31-1? // 判斷是否高於上限  \n  Yes → num ← 2^31 - 1 // 進行截斷  \n  No → // 正常範圍內  \n→ Step 11: result ← num // 將處理後的數值設為最終結果  \n→ Step 12: Return result // 回傳整數結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        # 移除前導空白\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        sign = 1\n        index = 0\n\n        # 處理符號\n        if s[0] == '+':\n            index += 1\n        elif s[0] == '-':\n            sign = -1\n            index += 1\n\n        result = 0\n        while index < len(s) and s[index].isdigit():\n            result = result * 10 + int(s[index])\n            index += 1\n\n        result *= sign\n\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n\n        if result < INT_MIN:\n            return INT_MIN\n        if result > INT_MAX:\n            return INT_MAX\n\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 從 \"s = \\\"...\\\"\" 這種格式中提取引號內的內容\n    match = re.search(r'\"(.*?)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有引號，直接使用整個輸入\n        s = data\n\n    sol = Solution()\n    result = sol.myAtoi(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"42\"",
          "expected_output": "42",
          "success": true,
          "output": "42"
        },
        {
          "example_index": 1,
          "input": "s = \" -042\"",
          "expected_output": "-42",
          "success": true,
          "output": "-42"
        },
        {
          "example_index": 2,
          "input": "s = \"1337c0d3\"",
          "expected_output": "1337",
          "success": true,
          "output": "1337"
        },
        {
          "example_index": 3,
          "input": "s = \"0-1\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 4,
          "input": "s = \"words and 987\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode151.json",
    "problem_index_in_file": 0,
    "title": "Reverse Words in a String",
    "description_snippet": "Given an input string s, reverse the order of the words.\n\nA word is defined as a sequence of non-spa...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for reversing words in string, with handling spaces. Use step by step. Provide each line with explanation. Use Start, End, Decision. Provide arrow steps. Ensure each line includes virtual code step and explanation after //.\n\nWe'll produce like:\n\nStart\n→ Step 1: 初始化空列表 words\n→ Step 2: 迭代 s, 建立 word_buffer\n→ Decision: 如果遇到空白? ...\nBut easier: split on spaces, filter out empty, reverse, join. But need to illustrate handling manually. Provide generic algorithm.\n\nWe'll produce:\n\nStart // Program start\n→ Step 1: Initialize empty list words // 用來儲存單詞\n→ Step 2: Set i = 0 // 指標\n→ Decision: i < length of s? // 迴圈條件\n    Yes → Step 3: If s[i] is not space, accumulate to word_buffer // 收集字元\n    No  → Step 4: If word_buffer not empty, append to words, reset // 儲存完整單詞\n    No  → Step 5: Increment i\n...\nBut we need to manage word boundaries.\n\nSimplify: Use split and filter: But might not illustrate manual parsing. But requirement just algorithmic. Could use high-level steps: Split string by spaces, filter out empty strings, reverse, join with single space.\n\nSo Virtual Code:\n\nStart // 程式開始執行\n→ Step 1: Split s by ' ' into tokens // 用空格切分字串\n→ Step 2: Filter tokens, keep only non-empty // 去除多餘空格\n→ Step 3: Reverse tokens list // 反轉單詞順序\n→ Step 4: Join tokens with single space into result // 以單一空格連接\n→ Step 5: Return result // 傳回結果\nEnd // 程式結束\n\nBut maybe need to show Decision: For filtering. So use Decision steps.\n\nLet's produce more detailed:\n\nStart\n→ Step 1: tokens = s.split(' ') // 切分字串成單詞/空格\n→ Step 2: filtered = [] // 初始化空列表\n→ Decision: tokens 仍未遍歷完? // 檢查是否有剩餘 token\n    Yes → Step 3: current = tokens.pop(0) // 取出第一個 token\n        Decision: current is empty? // 判斷是否為空格\n            Yes → Step 4: Continue // 跳過空字串\n            No  → Step 5: Append current to filtered // 將有效單詞加入列表\n    No  → Step 6: Reverse filtered // 反轉單詞順序\n→ Step 7: result = join filtered with ' ' // 連接成字串\n→ Step 8: Return result\nEnd\n\nBut we need to ensure each line has explanation. Use arrow. Provide Step names. Use Start and End. Use Decision with Yes/No. Let's create final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: tokens = s.split(' ') // 把原始字串以空格切成子字串，可能含空字串\n→ Step 2: filtered = [] // 建立空列表用來存放有效單詞\n→ Decision: tokens 仍未遍歷完? // 檢查是否還有子字串要處理\n    Yes → Step 3: current = tokens.pop(0) // 取出第一個子字串\n        Decision: current 為空字串? // 判斷是否是多餘空格\n            Yes → Step 4: Continue // 若是空字串則直接跳過\n            No  → Step 5: filtered.append(current) // 將有效單詞加入列表\n    No  → Step 6: filtered.reverse() // 所有單詞收集完畢後反轉順序\n→ Step 7: result = ' '.join(filtered) // 用單一空格把反轉後的單詞連接成字串\n→ Step 8: return result // 回傳最終結果\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\n\ndef reverse_words(s: str) -> str:\n    # 將字串以空白切開並去除空項，然後反轉順序再用單一空格連接\n    words = s.strip().split()\n    return ' '.join(words[::-1])\n\ndef main() -> None:\n    # 從 stdin 讀取整個輸入\n    data = sys.stdin.read().strip()\n\n    # 若輸入形如 s = \"...\"\n    start = data.find('\"')\n    end = data.rfind('\"')\n    if start != -1 and end != -1 and end > start:\n        s = data[start + 1:end]\n    else:\n        # 若沒有引號，直接使用整個輸入\n        s = data\n\n    result = reverse_words(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"the sky is blue\"",
          "expected_output": "\"blue is sky the\"",
          "success": true,
          "output": "blue is sky the"
        },
        {
          "example_index": 1,
          "input": "s = \"  hello world  \"",
          "expected_output": "\"world hello\"",
          "success": true,
          "output": "world hello"
        },
        {
          "example_index": 2,
          "input": "s = \"a good   example\"",
          "expected_output": "\"example good a\"",
          "success": true,
          "output": "example good a"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode27.json",
    "problem_index_in_file": 0,
    "title": "Remove Element",
    "description_snippet": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps per line. The algorithm: two pointers: i=0 j=0? Actually typical: iterate with idx, if nums[idx] != val, set nums[i] = nums[idx], i++.\n\nReturn i. We need virtual code with steps, decisions. We need to output line by line. Format: each line: virtual code step + space + // explanation. Use Start, End, Decision etc.\n\nLet's write:\n\nStart // 程式開始\n→ Step 1: 初始化指標 i 為 0 // i 用來記錄新陣列長度\n→ Step 2: 從索引 0 開始遍歷 nums // 逐個檢查元素\n    → Decision: nums[idx] 是否等於 val? // 判斷是否要移除\n        Yes → Step 3: 跳過此元素 // 不做任何操作\n        No  → Step 4: 將 nums[i] 設為 nums[idx] // 保留元素\n            → Step 5: i 加 1 // 更新新長度\n→ Step 6: idx 加 1 // 進入下一個元素\n→ Decision: idx 是否已經到達 nums 長度? // 是否結束遍歷\n    Yes → Step 7: 回傳 i // 返回新長度 k\n    No  → (回到) Step 2\nEnd // 程式結束\n\nBut we need to show loops. Virtual code: maybe use While loop. We'll format with Decision: while idx < nums.length? Provide structure. Use arrow for next.\n\nWe need to output lines each with // explanation. Use Start, End.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← 0, idx ← 0 // i 為新陣列長度，idx 為遍歷指標  \n→ Decision: idx < nums.length? // 是否還有未處理的元素  \n  Yes → Step 2: current ← nums[idx] // 取得當前元素  \n    Decision: current = val? // 判斷是否為要移除的值  \n     Yes → Step 3: idx ← idx + 1 // 跳過此元素，繼續下一輪  \n     No → Step 4: nums[i] ← current // 保留此元素  \n      → Step 5: i ← i + 1 // 更新新長度  \n      → Step 6: idx ← idx + 1 // 進入下一個元素  \n      → (回到) Decision: idx < nums.length?  \n       Yes → (重複 Step 2)  \n       No → Step 7: return i // 返回 k，即新陣列長度  \n  No → End // 已處理完所有元素，程式結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        Remove all occurrences of val from nums in-place.\n        Return the number of elements not equal to val.\n        \"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse an input string of the form:\n        nums = [1,2,3], val = 2\n    and return the list of ints and the val.\n    \"\"\"\n    # Find the list part\n    list_match = re.search(r'\\[(.*?)\\]', data)\n    if not list_match:\n        raise ValueError(\"No list found in input.\")\n    list_str = '[' + list_match.group(1) + ']'\n    nums = ast.literal_eval(list_str)\n\n    # Find the val part\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n    if not val_match:\n        raise ValueError(\"No val found in input.\")\n    val = int(val_match.group(1))\n    return nums, val\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    nums, val = parse_input(raw)\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # Build output representation: keep first k elements, replace the rest with '_'\n    output_list = nums[:k] + ['_'] * (len(nums) - k)\n    list_str = ','.join(str(x) for x in output_list)\n    print(f\"{k}, nums = [{list_str}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,2,3], val = 3",
          "expected_output": "2, nums = [2,2,_,_]",
          "success": true,
          "output": "2, nums = [2,2,_,_]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,3,0,4,_,_,_]",
          "success": true,
          "output": "5, nums = [0,1,3,0,4,_,_,_]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode357.json",
    "problem_index_in_file": 0,
    "title": "Count Numbers with Unique Digits",
    "description_snippet": "Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10^n....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: Given integer n, count numbers with unique digits less than 10^n (i.e., numbers with up to n digits). The known Leetcode problem 357. The answer: If n==0 return 1. Else iterate i from 1 to n, accumulate count: result += 9 * P(9, i-1). Where P(9, i-1) is permutations of 9 digits choose i-1. Use variable permutations = 9; For i=1: result += 9; For i=2: result += 9*9; For i=3: result += 9*9*8; etc. But we produce pseudocode steps line by line with explanation.\n\nWe need to output each line like \"Start // 程式開始執行\" etc. Use arrow. Use Decision etc.\n\nWe should consider special case n==0.\n\nAlso for loop, maybe using Decision? We can present for i from 1 to n: but the virtual code can show a Decision for i <= n.\n\nSimplify: Start → Check n==0 → Yes → Result=1 → End. No → Initialize result=1? Wait for n>=1, we need to count numbers of length up to n. Common algorithm: result=1 for zero; but we only count numbers with unique digits less than 10^n, which includes 0. So result=1 for zero.\n\nThen for i from 1 to n: \n    if i==1: result +=9\n    else: permutations*= (10-i); result +=9*permutations.\n\nBut more elegantly: permutations=9; for i=1 to n: result += permutations; permutations*= (10-i).\n\nBut need to handle i=1: permutations=9 (since 9 choices for first digit). For i=2: permutations*=8? Actually for i=2: permutations=9*9? Wait the formula: For length i, number of unique-digit numbers: 9 * P(9, i-1). So permutations start at 9 for i=1; For next i: permutations *= (10-i). For i=2: permutations=9*(9)=81; For i=3: permutations*=8=648 etc. So algorithm:\n\npermutations=9\nfor i from 1 to n:\n    result += permutations\n    permutations *= (10 - i)\nend for\n\nBut need to stop if permutations becomes 0 when i>=10. Since 10^n > 10 digits. So we can add Decision inside loop: If i>=10 → break. Or if permutations==0 → break.\n\nWe'll produce Virtual code accordingly.\n\nWe need to produce each line with arrow and explanation. We also need to use Decision: for loop and conditions. Provide steps.\n\nLet's construct:\n\nStart // 程式開始\n→ Decision: n == 0? // 檢查是否為 0\n    Yes → Step 1: 結果 ← 1 // 只有 0 這個數\n    No  → Step 2: 結果 ← 1 // 包含 0，初始化結果為 1\n           Step 3: permutations ← 9 // 第一位有 9 個選擇\n           → Decision: i = 1, n? // 進入迴圈\n           ...\nBut better to structure:\n\nStart\n→ Decision: n == 0?\n    Yes → Step 1: result ← 1\n    No  → Step 2: result ← 1 // 包括 0\n           Step 3: permutations ← 9\n           Step 4: i ← 1\n           → Decision: i <= n?\n                Yes → Step 5: result ← result + permutations // 加入長度 i 的數\n                      → Decision: i >= 10? // 10 位以上已無唯一數\n                            Yes → Step 6: Break loop // 跳出迴圈\n                            No  → Step 7: permutations ← permutations * (10 - i) // 更新排列數\n                      Step 8: i ← i + 1 // 下一個長度\n                      → Decision: i <= n? // 回到迴圈判斷\n                          Yes → 回到 Step 5\n                          No  → Step 9: End // 完成\n                No  → Step 9: End // 完成\n\nWe should avoid 'Break loop' maybe as Step 6: return result? But we need to break out of loop.\n\nWe can use Decision: permutations == 0? Or i >= 10? For simplicity, add a Decision inside loop to break.\n\nWe need to produce lines with \"→\" or \"Yes →\" etc.\n\nOk produce final answer.\n\nMake sure each line has virtual code step then space then // explanation.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: n == 0? // 檢查輸入是否為 0  \n    Yes → Step 1: result ← 1 // 只有 0 這個數，答案為 1  \n    No → Step 2: result ← 1 // 包含 0，先把結果初始化為 1  \n        Step 3: permutations ← 9 // 第一位有 9 個選擇（1-9）  \n        Step 4: i ← 1 // 從長度 1 開始計算  \n        → Decision: i <= n? // 是否還有長度需要處理  \n            Yes → Step 5: result ← result + permutations // 加入長度 i 的數量  \n                → Decision: i >= 10? // 10 位以上已無唯一數可產生  \n                    Yes → Step 6: Break // 跳出迴圈，結束計算  \n                    No → Step 7: permutations ← permutations * (10 - i) // 更新排列數以備下一個長度  \n            Step 8: i ← i + 1 // 前進到下一個長度  \n            → Decision: i <= n? // 回到迴圈判斷  \n                Yes → 回到 Step 5  \n                No → Step 9: End // 所有長度處理完畢，結束程式  \n            No → Step 9: End // 迴圈結束，程式結束\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_numbers_with_unique_digits(n: int) -> int:\n    \"\"\"Return the count of numbers with unique digits less than 10**n.\"\"\"\n    if n == 0:\n        return 1  # only the number 0\n\n    n = min(n, 10)          # beyond 10 digits numbers must repeat\n    result = 1              # include 0\n    permutations = 9        # first digit: 1-9\n\n    for i in range(1, n + 1):\n        result += permutations\n        permutations *= (10 - i)  # next digit choices\n    return result\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract integer from input (handles \"n = 2\" or just \"2\")\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else int(data)\n    print(count_numbers_with_unique_digits(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "91",
          "success": true,
          "output": "91"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode392.json",
    "problem_index_in_file": 0,
    "title": "Is Subsequence",
    "description_snippet": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\n\nA subsequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow, decision, Start, End. Need to be line by line. Provide steps to check subsequence. Should include initialization, loop over t, match s index, final check. Use Decision statements. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 i = 0 // s 的索引，從頭開始比對\n→ Step 2: 設定 j = 0 // t 的索引，從頭開始遍歷\n→ Decision: i < len(s)? // 是否還有字元需要比對\n    Yes → Step 3: t[j] == s[i]？ // 比對 t 的當前字元是否與 s 的當前字元相同\n        Yes → Step 4: i = i + 1 // 匹配成功，移動到 s 的下一個字元\n        No  → Step 5: // 失敗，保持 i 不變\n    No  → Step 6: // 所有 s 的字元都已匹配完畢，跳出循環\n→ Decision: j < len(t)? // t 是否還有字元可以繼續遍歷\n    Yes → Step 7: j = j + 1 // 移動到 t 的下一個字元\n    No  → Step 8: // t 已遍歷完畢，跳出循環\n→ Decision: i == len(s)? // s 的所有字元是否都已成功匹配\n    Yes → Step 9: 返回 true // s 是 t 的子序列\n    No  → Step 10: 返回 false // s 不是 t 的子序列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef is_subsequence(s: str, t: str) -> bool:\n    \"\"\"\n    Check if string s is a subsequence of string t.\n    \"\"\"\n    if not s:\n        return True\n    idx_s = 0\n    for ch in t:\n        if ch == s[idx_s]:\n            idx_s += 1\n            if idx_s == len(s):\n                return True\n    return False\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    # Extract strings enclosed in double quotes\n    strings = re.findall(r'\"(.*?)\"', data)\n    if len(strings) >= 2:\n        s, t = strings[0], strings[1]\n    else:\n        # Fallback: try to split by comma and strip whitespace\n        parts = data.split(',')\n        s = parts[0].split('=')[1].strip().strip('\"')\n        t = parts[1].split('=')[1].strip().strip('\"')\n    result = is_subsequence(s, t)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abc\", t = \"ahbgdc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"axc\", t = \"ahbgdc\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode91.json",
    "problem_index_in_file": 0,
    "title": "Decode Ways",
    "description_snippet": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm to count number of ways to decode string of digits. Classic Leetcode 91 Decode Ways.\n\nWe produce pseudocode with steps, decisions.\n\nWe must output line by line, each line \"虛擬碼步驟 // 解釋\" format. Use arrow arrows and decision lines.\n\nLet's craft algorithm:\n\nStart\n→ Step 1: If s is empty return 0? Actually if empty string, usually 0? Problem statement: s contains only digits, but could be empty? We can treat empty as 0 or 1? Usually 0. We'll handle.\n\nUse DP array dp[0..n] where dp[i] number ways to decode first i chars. dp[0]=1.\n\nIterate i from 1 to n:\n- Check single digit s[i-1] != '0' → dp[i] += dp[i-1]\n- Check two-digit from i-2 to i-1 if valid (10 <= val <= 26) → dp[i] += dp[i-2]\n\nAt end return dp[n].\n\nEdge cases: s[i-1]=='0' means can't decode alone, but could be part of two-digit 10 or 20.\n\nWe need to output pseudocode lines. Use decision arrows.\n\nLet's produce:\n\nStart\n→ Step 1: Let n = length of s // 獲取字串長度\n→ Step 2: If n == 0 return 0 // 空字串無法解碼\n→ Step 3: Initialize dp[0] = 1 // 基本情況：空前綴有 1 種解碼方式\n→ Decision: 如果 n >= 1? // 檢查是否有第一個字符\n    Yes → Step 4: If s[0] != '0' then dp[1] = 1 else dp[1] = 0 // 單位碼是否有效\n    No → End // n==0 情況已處理\n→ Decision: 如果 n >= 2? // 從第二個字符開始迭代\n    Yes → Step 5: For i from 2 to n: // 循環計算每個位置\n        → Decision: 如果 s[i-1] != '0'? // 檢查單碼有效\n            Yes → dp[i] += dp[i-1] // 加上一種解碼方式\n            No → // 不加\n        → Decision: 是否存在有效的兩位數字? // 判斷 10~26\n            Yes → let two = int(s[i-2:i]) // 取兩位數\n            → Decision: 10 <= two <= 26?\n                Yes → dp[i] += dp[i-2] // 加上一種解碼方式\n                No → // 不加\n    → End For\n    No → // n < 2 已處理\n→ Step 6: Return dp[n] // 最終解碼方式數量\nEnd\n\nNeed to add explanations after each line.\n\nMake sure each line uses \"→\" or \"Decision:\" or \"Start\" \"End\".\n\nWe must use \"虛擬碼步驟\" in Chinese or English? The example uses English steps but Chinese comments. We'll produce Chinese steps and comments. Use the arrow syntax.\n\nLet's write each line:\n\nStart // 程式開始執行\n→ Step 1: let n = length of s // 取得輸入字串長度\n→ Decision: if n == 0? // 檢查是否為空字串\n    Yes → Step 2: return 0 // 空字串無法解碼，返回 0\n    No → Step 3: initialize dp[0] = 1 // dp[0] 表示空前綴的解碼方式數量\n→ Decision: if n >= 1? // 檢查是否至少有一個字符\n    Yes → Step 4: if s[0] != '0' then dp[1] = 1 else dp[1] = 0 // 第一個字符是否可單獨解碼\n    No → End // 只處理了 n==0 的情況，直接結束\n→ Decision: if n >= 2? // 從第二個字符開始處理\n    Yes → Step 5: for i from 2 to n do // 遍歷每個位置\n        → Decision: if s[i-1] != '0'? // 單碼有效判斷\n            Yes → dp[i] += dp[i-1] // 加上單碼解碼方式\n            No →\n        → Decision: is there a valid two-digit number? // 檢查兩位數是否有效\n            Yes → let two = int(s[i-2:i]) // 取得兩位數\n            → Decision: 10 <= two <= 26? // 判斷是否在有效範圍\n                Yes → dp[i] += dp[i-2] // 加上兩位數解碼方式\n                No →\n    → End For\n    No →\n→ Step 6: return dp[n] // 回傳總解碼方式數\nEnd // 程式結束\n\nNeed to ensure each line is separate with the comment after space.\n\nWe must not output any actual code but virtual steps.\n\nAlso the algorithm uses dp array. Need to mention initialization of dp array size n+1 maybe.\n\nAdd step to initialize dp array of size n+1 with zeros.\n\nAdd step after dp[0]=1 to set dp array.\n\nLet's refine:\n\nStep 3: initialize dp[0] = 1 // dp[0] = 1\n\nAlso need to set dp[1] appropriately.\n\nAlso need to initialize dp[2..n] to 0 by default? We can skip as default 0.\n\nLet's produce final output.\n\nMake sure each line ends with comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: let n = length of s // 取得輸入字串長度  \n→ Decision: if n == 0? // 檢查是否為空字串  \n  Yes → Step 2: return 0 // 空字串無法解碼，返回 0  \n  No → Step 3: initialize dp[0] = 1 // dp[0] 表示空前綴的解碼方式數量  \n→ Decision: if n >= 1? // 檢查是否至少有一個字符  \n  Yes → Step 4: if s[0] != '0' then dp[1] = 1 else dp[1] = 0 // 第一個字符是否可單獨解碼  \n  No → End // 只處理了 n==0 的情況，直接結束  \n→ Decision: if n >= 2? // 從第二個字符開始處理  \n  Yes → Step 5: for i from 2 to n do // 遍歷每個位置  \n   → Decision: if s[i-1] != '0'? // 單碼有效判斷  \n     Yes → dp[i] += dp[i-1] // 加上單碼解碼方式  \n     No →  \n   → Decision: is there a valid two-digit number? // 檢查兩位數是否有效  \n     Yes → let two = int(s[i-2:i]) // 取得兩位數  \n      → Decision: 10 <= two <= 26? // 判斷是否在有效範圍  \n       Yes → dp[i] += dp[i-2] // 加上兩位數解碼方式  \n       No →  \n   → End For  \n  No →  \n→ Step 6: return dp[n] // 回傳總解碼方式數  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef num_decodings(s: str) -> int:\n    \"\"\"\n    Count the number of ways to decode the numeric string `s` using the mapping\n    \"1\"->'A', \"2\"->'B', ..., \"26\"->'Z'.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # dp[i] = number of ways to decode the first i characters (0‑based)\n    dp = [0] * (n + 1)\n    dp[0] = 1  # empty string has one way (do nothing)\n\n    # handle first character\n    if s[0] != '0':\n        dp[1] = 1\n    else:\n        dp[1] = 0\n\n    for i in range(2, n + 1):\n        # single digit\n        if s[i - 1] != '0':\n            dp[i] += dp[i - 1]\n\n        # two digits\n        two = int(s[i - 2:i])\n        if 10 <= two <= 26:\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n\n    # Extract digits from input; supports formats like\n    #   s = \"12\"\n    #   12\n    #   06\n    numbers = re.findall(r'\\d+', data)\n    s = numbers[0] if numbers else \"\"\n\n    result = num_decodings(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"12\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \"226\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"06\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode649.json",
    "problem_index_in_file": 0,
    "title": "Dota2 Senate",
    "description_snippet": "In the world of Dota2, there are two parties: the Radiant and the Dire.\n\nThe Dota2 senate consists o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line, with comments, describing algorithm to predict winner. Essentially the known problem: Dota2 Senate (Leetcode 649). Approach: queue counts, track remaining counts, simulate bans until one party zero. So pseudo-code: Start, initialize queues for R and D positions, counts. While both queues non-empty: pop earliest index, compare. The one with smaller index bans the other: increment index by n and enqueue back. Continue. When one queue empty, output winner. Provide explanation each line. Use virtual code format: \"Start\", \"→ Step 1: ...\" etc. Use decision arrow etc.\n\nWe need to generate step by step explanation. Probably need to use decision structure for while loop. Use Step 1 etc. Let's craft.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化兩個隊列 RQueue 和 DQueue，將每個 'R' 的索引加入 RQueue，將每個 'D' 的索引加入 DQueue // 按順序儲存各黨派的席次\n→ Step 2: 取得 senatorsCount = senate.Length // 計算總席次\n→ Decision: 若 RQueue 或 DQueue 為空? // 判斷是否已經有黨派全部失效\n    Yes → Step 3: 如果 RQueue 為空則輸出 \"Dire\" 否則輸出 \"Radiant\" // 決定勝利黨派\n    No  → Step 4: 進入主迴圈 // 開始模擬投票\nStep 4: Decision: RQueue 與 DQueue 是否皆非空? // 只要兩方都有席次才繼續\n    Yes → Step 5: RIndex ← RQueue.Dequeue() // 取出 Radiant 代表最早的席次\n    → Step 6: DIndex ← DQueue.Dequeue() // 取出 Dire 代表最早的席次\n    → Decision: RIndex < DIndex? // Radiant 的席次較早，則 Radiant 可封鎖 Dire\n        Yes → Step 7: RQueue.Enqueue(RIndex + senatorsCount) // Radiant 重新排到最後\n        → Step 8: // Dire 被封鎖，直接丟棄 DIndex\n        No  → Step 9: DQueue.Enqueue(DIndex + senatorsCount) // Dire 重新排到最後\n        → Step 10: // Radiant 被封鎖，直接丟棄 RIndex\n    → Step 11: // 迴圈結束，返回 Step 4\n    No  → Step 12: // 只剩一方\n        Decision: RQueue 是否非空? // 判斷剩餘黨派\n            Yes → Step 13: 輸出 \"Radiant\"\n            No  → Step 14: 輸出 \"Dire\"\nEnd // 程式結束\n\nBut we need to output each line with arrow and explanation.\n\nAlso need to mention using queue operations: Enqueue, Dequeue. Use arrow for step lines. We can combine decisions. Provide explanatory comments. Must not output actual code. It's pseudocode.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 建立兩個空的 FIFO 隊列 RQueue、DQueue // 分別儲存 Radiant 與 Dire 的席次\n→ Step 2: 對於 i 從 0 到 senate.Length-1:\n    → Decision: senate[i] 是 'R'? // 判斷此席次所屬黨派\n        Yes → RQueue.Enqueue(i) // 把席次加入 Radiant 隊列\n        No  → DQueue.Enqueue(i) // 把席次加入 Dire 隊列\n→ Step 3: 設定 total = senate.Length // 取得總席次數，後續用於重新排入隊列\n→ Decision: RQueue.IsEmpty 或 DQueue.IsEmpty? // 若已有黨派全部被封鎖，直接決定勝利方\n    Yes → Decision: RQueue.IsEmpty?\n        Yes → Output \"Dire\" // Radiant 全被封鎖，Dire 勝\n        No  → Output \"Radiant\" // Dire 全被封鎖，Radiant 勝\n    No  → Step 4: 進入主迴圈 // 正式開始模擬投票過程\nStep 4: Decision: RQueue.Count > 0 且 DQueue.Count > 0? // 只要兩方都有席次就繼續\n    Yes → Step 5: RIdx ← RQueue.Dequeue() // 取出 Radiant 最早的席次\n    → Step 6: DIdx ← DQueue.Dequeue() // 取出 Dire 最早的席次\n    → Decision: RIdx < DIdx? // 判斷誰的席次較早\n        Yes → Step 7: RQueue.Enqueue(RIdx + total) // Radiant 重新排到隊尾，延遲 total 個位置\n        → Step 8: // Dire 被封鎖，該席次不再加入任何隊列\n        No  → Step 9: DQueue.Enqueue(DIdx + total) // Dire 重新排到隊尾\n        → Step 10: // Radiant 被封鎖，該席次不再加入任何隊列\n    → Step 11: // 回到 Step 4 重新檢查\n    No  → Step 12: Decision: RQueue.Count > 0? // 判斷剩餘黨派\n        Yes → Output \"Radiant\" // Radiant 剩下，宣布勝利\n        No  → Output \"Dire\" // Dire 剩下，宣布勝利\nEnd // 程式結束\n\nWe must format exactly: each line starts with \"→ Step X:\" or \"Decision:\" etc. We used \"Step 4:\" line with decision. Actually need arrow for decision lines too. For decision, they used \"Decision:\" maybe no arrow? In example, they wrote \"Decision:\" after the step. They used arrow for decision lines? Example shows:\n\n→ Decision: 如果數字大於 0? // ...\n\nYes → ... No → ... etc.\n\nSo we need same.\n\nLet's craft each line accordingly:\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 建立兩個空的 FIFO 隊列 RQueue、DQueue // 分別儲存 Radiant 與 Dire 的席次\n\nLine 3: → Step 2: 對於 i 從 0 到 senate.Length-1:\n    → Decision: senate[i] 是 'R'? // 判斷此席次所屬黨派\n        Yes → RQueue.Enqueue(i) // 把席次加入 Radiant 隊列\n        No  → DQueue.Enqueue(i) // 把席次加入 Dire 隊列\n\nBut we need each line separate. So we need multiple lines: Step 2, Decision, Yes, No. Use arrow each.\n\nLine 4: → Step 3: 設定 total = senate.Length // 取得總席次數，後續用於重新排入隊列\n\nLine 5: → Decision: RQueue.IsEmpty 或 DQueue.IsEmpty? // 若已有黨派全部被封鎖，直接決定勝利方\n\nLine 6:     Yes → Decision: RQueue.IsEmpty?\nLine 7:         Yes → Output \"Dire\" // Radiant 全被封鎖，Dire 勝\nLine 8:         No  → Output \"Radiant\" // Dire 全被封鎖，Radiant 勝\nLine 9:     No  → Step 4: 進入主迴圈 // 正式開始模擬投票過程\n\nLine 10: Step 4: Decision: RQueue.Count > 0 且 DQueue.Count > 0? // 只要兩方都有席次就繼續\n\nLine 11:     Yes → Step 5: RIdx ← RQueue.Dequeue() // 取出 Radiant 最早的席次\nLine 12:         → Step 6: DIdx ← DQueue.Dequeue() // 取出 Dire 最早的席次\nLine 13:         → Decision: RIdx < DIdx? // 判斷誰的席次較早\nLine 14:             Yes → Step 7: RQueue.Enqueue(RIdx + total) // Radiant 重新排到隊尾\nLine 15:                 → Step 8: // Dire 被封鎖，該席次不再加入任何隊列\nLine 16:             No  → Step 9: DQueue.Enqueue(DIdx + total) // Dire 重新排到隊尾\nLine 17:                 → Step 10: // Radiant 被封鎖，該席次不再加入任何隊列\nLine 18:         → Step 11: // 回到 Step 4 重新檢查\nLine 19:     No  → Step 12: Decision: RQueue.Count > 0? // 判斷剩餘黨派\nLine 20:         Yes → Output \"Radiant\" // Radiant 剩下，宣布勝利\nLine 21:         No  → Output \"Dire\" // Dire 剩下，宣布勝利\nLine 22: End // 程式結束\n\nCheck formatting: each line must start with \"Start\" or \"→\" or \"Decision:\".\n\nNeed to maintain consistent indentations: In example, indenting inside decision is two spaces? They used tabs? The example shows:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nThey indent one level for nested lines. Use 4 spaces indentation? They use 4 spaces. Let's use same.\n\nThus for Step 2 and Decision nested: Step 2 then Decision line indented? Actually Step 2 line is outer, then Decision is inside Step 2? In example, they show:\n\n→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nSo Step 1 has no nested Decision. But for loop we may just write multiple lines without nesting. For clarity, we might not need to nest inside Step 2; just write separate Decision lines. But they want each line to be separate. It's okay to have decisions independent. So we can just do:\n\n→ Decision: senate[i] 是 'R'? // ...\n    Yes → RQueue.Enqueue(i) // ...\n    No  → DQueue.Enqueue(i) // ...\n\nBut we need to have i loop; we can just mention loop but not write nested lines.\n\nMaybe simpler: Use steps: Step 2: Build queues, Step 3: etc. And inside step we describe operations.\n\nLet's restructure:\n\nLine 2: → Step 1: 初始化兩個 FIFO 隊列 RQueue、DQueue // 分別儲存 Radiant 與 Dire 的席次\n\nLine 3: → Step 2: 遍歷 senate 字串，對於每個索引 i\nLine 4:     → Decision: senate[i] 是 'R'? // 判斷此席次所屬黨派\nLine 5:         Yes → RQueue.Enqueue(i) // 加入 Radiant 隊列\nLine 6:         No  → DQueue.Enqueue(i) // 加入 Dire 隊列\n\nLine 7: → Step 3: 設定 total = senate.Length // 總席次數，用於重新排入隊列\n\nLine 8: → Decision: RQueue.IsEmpty 或 DQueue.IsEmpty? // 是否已經有黨派全被封鎖\nLine 9:     Yes → Decision: RQueue.IsEmpty?\nLine 10:        Yes → Output \"Dire\" // Radiant 全被封鎖，Dire 勝\nLine 11:        No  → Output \"Radiant\" // Dire 全被封鎖，Radiant 勝\nLine 12:    No  → Step 4: 進入主迴圈\n\nLine 13: Step 4: Decision: RQueue.Count > 0 且 DQueue.Count > 0? // 只要兩方都有席次就繼續\nLine 14:     Yes → Step 5: RIdx ← RQueue.Dequeue() // 取出 Radiant 最早席次\nLine 15:         → Step 6: DIdx ← DQueue.Dequeue() // 取出 Dire 最早席次\nLine 16:         → Decision: RIdx < DIdx? // 判斷誰的席次較早\nLine 17:             Yes → Step 7: RQueue.Enqueue(RIdx + total) // Radiant 重新排隊\nLine 18:                 → Step 8: // Dire 被封鎖，該席次不再加入隊列\nLine 19:             No  → Step 9: DQueue.Enqueue(DIdx + total) // Dire 重新排隊\nLine 20:                 → Step 10: // Radiant 被封鎖，該席次不再加入隊列\nLine 21:         → Step 11: // 重新檢查下一輪\nLine 22:     No  → Step 12: Decision: RQueue.Count > 0? // 判斷剩餘黨派\nLine 23:         Yes → Output \"Radiant\" // Radiant 剩下，宣布勝利\nLine 24:         No  → Output \"Dire\" // Dire 剩下，宣布勝利\n\nLine 25: End // 程式結束\n\nWe must ensure each line starts with either \"Start\", \"→ Step\", \"→ Decision\", \"Yes →\", \"No →\", \"Output\", \"End\". We included \"Output\" lines but not specified. We can use \"Output\" as step.\n\nCheck formatting: lines 14-15 indentation: Step 5, Step 6. We used \"→ Step 5:\" etc. Should be fine.\n\nBut maybe we can simplify to avoid too many nested steps. It's okay.\n\nLet's produce final output lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個 FIFO 隊列 RQueue、DQueue // 分別儲存 Radiant 與 Dire 的席次  \n→ Step 2: 遍歷 senate 字串，對於每個索引 i  \n  → Decision: senate[i] 是 'R'? // 判斷此席次所屬黨派  \n    Yes → RQueue.Enqueue(i) // 加入 Radiant 隊列  \n    No  → DQueue.Enqueue(i) // 加入 Dire 隊列  \n→ Step 3: 設定 total = senate.Length // 總席次數，用於重新排入隊列  \n→ Decision: RQueue.IsEmpty 或 DQueue.IsEmpty? // 是否已經有黨派全被封鎖  \n  Yes → Decision: RQueue.IsEmpty?  \n    Yes → Output \"Dire\" // Radiant 全被封鎖，Dire 勝  \n    No  → Output \"Radiant\" // Dire 全被封鎖，Radiant 勝  \n  No  → Step 4: 進入主迴圈 // 正式開始模擬投票過程  \nStep 4: Decision: RQueue.Count > 0 且 DQueue.Count > 0? // 只要兩方都有席次就繼續  \n  Yes → Step 5: RIdx ← RQueue.Dequeue() // 取出 Radiant 最早席次  \n    → Step 6: DIdx ← DQueue.Dequeue() // 取出 Dire 最早席次  \n    → Decision: RIdx < DIdx? // 判斷誰的席次較早  \n     Yes → Step 7: RQueue.Enqueue(RIdx + total) // Radiant 重新排隊  \n       → Step 8: // Dire 被封鎖，該席次不再加入隊列  \n     No  → Step 9: DQueue.Enqueue(DIdx + total) // Dire 重新排隊  \n       → Step 10: // Radiant 被封鎖，該席次不再加入隊列  \n     → Step 11: // 重新檢查下一輪  \n  No  → Step 12: Decision: RQueue.Count > 0? // 判斷剩餘黨派  \n    Yes → Output \"Radiant\" // Radiant 剩下，宣布勝利  \n    No  → Output \"Dire\" // Dire 剩下，宣布勝利  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def predictPartyVictory(self, senate: str) -> str:\n        \"\"\"Predict which party will win the Dota2 Senate voting.\"\"\"\n        n = len(senate)\n        radiant = deque()\n        dire = deque()\n\n        # Store the index of each senator for each party\n        for i, s in enumerate(senate):\n            if s == 'R':\n                radiant.append(i)\n            elif s == 'D':\n                dire.append(i)\n\n        # Simulate the rounds\n        while radiant and dire:\n            r_index = radiant.popleft()\n            d_index = dire.popleft()\n            # The senator with the smaller index bans the other\n            if r_index < d_index:\n                radiant.append(r_index + n)   # Radiant gets another turn later\n            else:\n                dire.append(d_index + n)      # Dire gets another turn later\n\n        # Return the winner\n        return \"Radiant\" if radiant else \"Dire\"\n\ndef parse_input() -> str:\n    \"\"\"\n    Parse the input from stdin. The input can be:\n    - senate = \"RD\"\n    - \"RD\"\n    - RD\n    Returns the senate string without quotes.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # Try to match 'senate = \"...\"'\n    m = re.search(r'senate\\s*=\\s*\"([^\"]*)\"', data)\n    if m:\n        return m.group(1)\n    # Try to match a quoted string\n    m = re.search(r'\"([^\"]*)\"', data)\n    if m:\n        return m.group(1)\n    # Fallback: return the stripped input directly\n    return data\n\nif __name__ == \"__main__\":\n    senate = parse_input()\n    solution = Solution()\n    print(solution.predictPartyVictory(senate))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "senate = \"RD\"",
          "expected_output": "\"Radiant\"",
          "success": true,
          "output": "Radiant"
        },
        {
          "example_index": 1,
          "input": "senate = \"RDD\"",
          "expected_output": "\"Dire\"",
          "success": true,
          "output": "Dire"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode523.json",
    "problem_index_in_file": 0,
    "title": "Continuous Subarray Sum",
    "description_snippet": "Given an integer array nums and an integer k, return true if nums has a good subarray or false other...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that implement algorithm to determine if array has subarray of length at least 2 whose sum is multiple of k. Classic problem: using prefix sum modulo k and tracking earliest index for each mod value. For length >=2, need j - i >= 2. So we store earliest index of each mod. Initialize mod 0 at index -1? but length constraint: if current index - earliest index >= 2. Approach: iterate, compute cumulative sum mod k, store first occurrence of each mod. When encountering same mod again, check distance >= 2. Also need handle k=0 separately: sum of subarray should be zero. For k=0, need contiguous subarray of at least 2 with sum zero. Use map of cumulative sum and earliest index; when same sum occurs, check distance >= 2. But problem says 0 is multiple of k for any k? It states 0 is always a multiple of k. So for k=0, any subarray sum 0 qualifies. We'll implement logic accordingly.\n\nWe'll produce steps:\n\nStart\n→ Step 1: 初始化 cumulative_sum = 0, map = {0: -1} // map mod->first index\n→ Step 2: 遍歷 nums，索引 i\n    → Step 3: cumulative_sum += nums[i]\n    → Decision: 如果 k != 0? // 是否需要除以 k\n        Yes → Step 4: mod = cumulative_sum % k // 取模\n        No  → Step 4: mod = cumulative_sum // for k=0 case, use sum itself as key\n    → Decision: map 是否包含 mod? // 前一次出現\n        Yes →\n            → Step 5: earliest = map[mod]\n            → Decision: i - earliest >= 2? // 長度至少2\n                Yes → Step 6: 返回 true // 找到符合條件\n                No → Step 7: (無操作) // 仍繼續\n        No →\n            → Step 8: map[mod] = i // 記錄第一次出現\n    → Step 9: (循環結束)\n→ Step 10: 返回 false // 沒有找到\nEnd\n\nWe need each line in that format. Use arrow '→', indentation maybe with spaces. We'll ensure each line ends with comment. For decision we need Yes →, No →.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: cumulative_sum ← 0, map ← {0: -1} // 初始化累加和與模值對應的最早索引（模0對應虛擬索引-1）  \n→ Step 2: for each index i in nums 循環開始 // 遍歷陣列  \n  → Step 3: cumulative_sum ← cumulative_sum + nums[i] // 累加當前元素  \n  → Decision: 如果 k ≠ 0? // 判斷是否需要做模運算  \n   Yes → Step 4: mod ← cumulative_sum mod k // 計算模值  \n   No  → Step 4: mod ← cumulative_sum // k=0 時用累加和本身作為鍵  \n  → Decision: map 是否包含 mod? // 是否之前已遇到相同的模值  \n   Yes →  \n    → Step 5: earliest ← map[mod] // 取出最早索引  \n    → Decision: i - earliest ≥ 2? // 子陣列長度至少為 2  \n     Yes → Step 6: return true // 找到符合條件的子陣列  \n     No  → Step 7: // 不符合長度，繼續遍歷  \n   No  →  \n    → Step 8: map[mod] ← i // 記錄此模值首次出現的索引  \n  → Step 9: // 繼續下一個迴圈  \n→ Step 10: return false // 未找到任何符合條件的子陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def checkSubarraySum(self, nums, k):\n        mod_map = {0: -1}   # 最早出現的模值對應索引\n        total = 0\n        for i, num in enumerate(nums):\n            total += num\n            if k != 0:\n                total %= k\n            if total in mod_map:\n                if i - mod_map[total] > 1:  # 子陣列長度至少為 2\n                    return True\n            else:\n                mod_map[total] = i\n        return False\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    # 解析輸入，例如: \"[23,2,4,6,7], 6\"\n    try:\n        nums, k = ast.literal_eval(raw_input)\n    except Exception:\n        # 若輸入格式不符，直接結束\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.checkSubarraySum(nums, k)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[23,2,4,6,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "[23,2,6,4,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "[23,2,6,4,7], 13",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode41.json",
    "problem_index_in_file": 0,
    "title": "First Missing Positive",
    "description_snippet": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code in Traditional Chinese. The requirement: unsorted integer array nums, return smallest missing positive integer, O(n) time, O(1) space.\n\nWe need to output step-by-step virtual code, with comments. Use Start, End, Decision, etc. Each line: virtual code step [space] // explanation.\n\nWe should include steps like marking indices, swapping, etc. Use typical algorithm: place each number in its correct index (num-1) if within bounds. Then scan for first index where value != index+1. Return index+1. If none, return n+1.\n\nWe'll produce virtual code lines.\n\nWe need to output step-by-step virtual code, not actual code. Let's produce like:\n\nStart // begin\n\n→ Step 1: Initialize n ← length of nums // get array length\n\n→ Step 2: For i from 0 to n-1: // iterate\n\n    → Decision: If nums[i] ≤ 0 or nums[i] > n? // outside range\n\n        Yes → Continue // skip\n\n        No → Proceed to reposition loop\n\nWe'll then include reposition loop: while nums[i] between 1 and n and nums[nums[i]-1] ≠ nums[i] → swap\n\nAfter first loop, we check for missing positive: for i from 0 to n-1: if nums[i] ≠ i+1 then return i+1\n\nIf loop ends, return n+1\n\nLet's produce. Use appropriate virtual code syntax: \"→ Step X:\" etc.\n\nWe must keep each line: \"虛擬碼步驟 [space] // 解釋\". Let's ensure we have Start, End, Decision.\n\nLet's write:\n\nStart // 程式開始執行\n\n→ Step 1: Set n ← length(nums) // 取得陣列長度\n\n→ Step 2: For i ← 0 to n-1: // 遍歷陣列\n\n    → Decision: If nums[i] ≤ 0 或 nums[i] > n? // 非正或超出範圍\n\n        Yes → Continue // 跳過此元素\n\n        No  → Step 3: While nums[i] 在 [1, n] 且 nums[nums[i]-1] ≠ nums[i]: // 位置不正確且目標位置不相同\n\n            → Step 4: Swap nums[i] 與 nums[nums[i]-1] // 交換以把數值放到正確索引\n\n→ Step 5: For i ← 0 to n-1: // 第二次遍歷尋找缺失值\n\n    → Decision: If nums[i] ≠ i+1? // 是否正確位置\n\n        Yes → Step 6: Return i+1 // 找到最小缺失正整數\n\n        No  → Continue // 正確位置，繼續\n\n→ Step 7: Return n+1 // 所有位置正確，缺失值為 n+1\n\nEnd // 程式執行結束\n\nBut each line must be a single virtual code step. The above has indentation lines. We need to produce each line separately. Use indentation inside the virtual code step? The example shows indentation by spaces. We can indent the steps inside the Decision block.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: n ← length(nums) // 取得陣列長度\n\n→ Step 2: For i ← 0 to n-1: // 遍歷陣列元素\n\n    → Decision: 如果 nums[i] ≤ 0 或 nums[i] > n? // 檢查數值是否在 1~n 範圍內\n\n        Yes → Continue // 跳過此元素\n\n        No  → While nums[i] 在 [1, n] 且 nums[nums[i]-1] ≠ nums[i]: // 需要交換\n\n            → Swap nums[i] 與 nums[nums[i]-1] // 把 nums[i] 放到正確索引位置\n\n→ Step 3: For i ← 0 to n-1: // 第二次遍歷尋找缺失的正整數\n\n    → Decision: 如果 nums[i] ≠ i+1? // 該位置的數值是否符合索引+1\n\n        Yes → Return i+1 // 找到最小缺失正整數\n\n        No  → Continue // 正確位置，繼續\n\n→ Step 4: Return n+1 // 所有位置正確，缺失值為 n+1\n\nEnd // 程式執行結束\n\nCheck format: Each line must contain \"虛擬碼步驟\" then a space then \"// 解釋\". Here we have indent lines: We need to ensure each line is separate. Example uses \"→ Decision:\" with indent. So we can indent subsequent lines under the Decision. Each line still must end with // explanation. Yes.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: For i ← 0 to n-1: // 遍歷陣列元素  \n  → Decision: 如果 nums[i] ≤ 0 或 nums[i] > n? // 檢查數值是否在 1~n 範圍內  \n   Yes → Continue // 跳過此元素  \n   No  → While nums[i] 在 [1, n] 且 nums[nums[i]-1] ≠ nums[i]: // 需要交換  \n     → Swap nums[i] 與 nums[nums[i]-1] // 把 nums[i] 放到正確索引位置  \n→ Step 3: For i ← 0 to n-1: // 第二次遍歷尋找缺失的正整數  \n  → Decision: 如果 nums[i] ≠ i+1? // 該位置的數值是否符合索引+1  \n   Yes → Return i+1 // 找到最小缺失正整數  \n   No  → Continue // 正確位置，繼續  \n→ Step 4: Return n+1 // 所有位置正確，缺失值為 n+1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef first_missing_positive(nums):\n    \"\"\"\n    找出最小缺失的正整數，時間複雜度 O(n)，額外空間 O(1)。\n    \"\"\"\n    n = len(nums)\n    # 將每個數字放到它應該在的索引位置：nums[i] 應放在 nums[nums[i]-1]\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            # 交換 nums[i] 與正確位置的數字\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    # 再次遍歷，尋找第一個不對應的索引\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    # 如果所有位置都正確，缺失值就是 n + 1\n    return n + 1\n\ndef main():\n    \"\"\"\n    主函式：從標準輸入讀取陣列，計算結果並輸出。\n    支援類似 'nums = [1,2,0]' 的輸入格式。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找出第一個 '[' 與最後一個 ']'，取出陣列字串\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        nums = []\n    else:\n        nums_str = data[start:end + 1]\n        nums = ast.literal_eval(nums_str)\n\n    result = first_missing_positive(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,0]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [3,4,-1,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [7,8,9,11,12]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode551.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record I",
    "description_snippet": "You are given a string s representing an attendance record for a student where each character signif...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code with explanation lines, following format. The user request: \"You are given a string s representing an attendance record for a student... Return true if eligible else false.\" We need to produce virtual code that checks conditions.\n\nWe must not output actual code; only virtual code with arrow structure. Use Start, End, Decision etc. Each line: \"虛擬碼步驟 // 解釋/說明\".\n\nLet's craft algorithm:\n\nStart\n→ Initialize absentCount = 0\n→ Initialize consecutiveLate = 0\n→ For each character c in s:\n    Decision: If c == 'A'? // check absent\n        Yes → absentCount++ // increment absent\n    No → Decision: If c == 'L'? // check late\n        Yes → consecutiveLate++ // increment consecutive late\n        No  → consecutiveLate = 0 // reset on present\n→ Decision: If absentCount >= 2? // too many absences\n    Yes → Return false // not eligible\n    No → Decision: If consecutiveLate >= 3? // too many consecutive lates\n        Yes → Return false\n        No  → Return true\n\nEnd.\n\nWe need each line with arrow maybe using →. For decision nested. Format:\n\nStart // 程式開始執行\n→ Step 1: 初始 absentCount = 0 // 計算缺席天數\n→ Step 2: 初始 consecutiveLate = 0 // 計算連續遲到天數\n→ Step 3: For each character c in s: // 逐天檢查\n    Decision: c == 'A'? // 判斷是否缺席\n        Yes → Step 3a: absentCount++ // 缺席天數加 1\n        No  → Decision: c == 'L'? // 判斷是否遲到\n            Yes → Step 3b: consecutiveLate++ // 連續遲到天數加 1\n            No  → Step 3c: consecutiveLate = 0 // 出現出席，重置遲到計數\n→ Decision: absentCount >= 2? // 缺席天數是否過多\n    Yes → Step 4: Return false // 不符合條件\n    No  → Decision: consecutiveLate >= 3? // 連續遲到是否超過限制\n        Yes → Step 5: Return false // 不符合條件\n        No  → Step 6: Return true // 符合條件\nEnd // 程式執行結束\n\nMake sure each line ends with // 解釋. Use arrow arrow. Use indentation maybe not necessary. But each line must be \"虛擬碼步驟 [space] // 解釋\". For nested decisions maybe we still output them as separate lines with indent or prefix spaces. The format example used indentation. We can follow similar.\n\nThus produce lines accordingly. Ensure no actual code like variable names? But virtual code can have variable names; just not actual code. It's okay.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 absentCount = 0 // 計算缺席天數  \n→ Step 2: 初始化 consecutiveLate = 0 // 計算連續遲到天數  \n→ Step 3: 逐天遍歷 s 中的每個字符 c // 逐日檢查  \n    Decision: c 是否等於 'A'? // 判斷是否缺席  \n        Yes → Step 3a: absentCount++ // 缺席天數 +1  \n        No → Decision: c 是否等於 'L'? // 判斷是否遲到  \n            Yes → Step 3b: consecutiveLate++ // 連續遲到天數 +1  \n            No → Step 3c: consecutiveLate = 0 // 出席時重置遲到計數  \n→ Decision: absentCount >= 2? // 缺席天數是否超過 1 天  \n    Yes → Step 4: 返回 false // 不符合獎勵條件  \n    No → Decision: consecutiveLate >= 3? // 連續遲到天數是否超過 2 天  \n        Yes → Step 5: 返回 false // 不符合獎勵條件  \n        No → Step 6: 返回 true // 符合所有條件，獲得獎勵  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        \"\"\"Return True if student is eligible for attendance award.\"\"\"\n        return s.count('A') <= 1 and 'LLL' not in s\n\ndef main() -> None:\n    # 讀取輸入，去除首尾空白及可能存在的雙引號\n    raw = sys.stdin.read().strip()\n    s = raw.strip('\"')\n\n    sol = Solution()\n    result = sol.checkRecord(s)\n\n    # 輸出小寫布林值字串\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"PPALLP\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"PPALLL\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode26.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations, following format. The problem is classic remove duplicates from sorted array, returning k. We should produce a straightforward algorithm: use two pointers. Provide Start, Steps, Decision, etc. Let's produce maybe around 15 lines. Use virtual code arrows.\n\nRemember each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use indentation for decisions.\n\nLet's craft:\n\nStart // 程式開始\n\n→ Step 1: 如果 nums 長度為 0 → Return 0 // 空陣列直接返回0\n\n→ Step 2: 初始化 idx = 0 // idx 指向已確定唯一元素的最終位置\n\n→ Step 3: 從 i = 1 到 nums.length-1 遍歷陣列 // 以第二個元素開始比較\n\n    → Decision: 如果 nums[i] ≠ nums[idx]？ // 判斷當前元素是否為新唯一值\n        Yes → idx = idx + 1 // 移動 idx 為下個唯一位置\n        → Step 4: nums[idx] = nums[i] // 將新唯一值寫入 idx 位置\n        No → // 若相同，跳過，繼續迴圈\n\n→ Step 5: 返回 idx + 1 // 唯一元素個數\n\nEnd // 程式結束\n\nMake sure indentation and arrow usage matches guidelines.\n\nWe need to follow format: Each line with \"虛擬碼步驟 // 解釋\". Use arrow \"→\" at start. Decision: with Yes → and No →. Let's include indentation spaces for nested lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 如果 nums 長度為 0？ // 檢查陣列是否為空  \n    Yes → Return 0 // 空陣列直接回傳 0，代表沒有唯一元素  \n    No  →  // 若非空，繼續後續流程  \n\n→ Step 2: 初始化 idx = 0 // idx 指向已確定唯一元素的最後一個位置  \n→ Step 3: 從 i = 1 到 nums.length-1 遍歷陣列 // 從第二個元素開始逐個檢查  \n\n    → Decision: 如果 nums[i] ≠ nums[idx]？ // 判斷當前元素是否為新唯一值  \n        Yes → idx = idx + 1 // idx 前進到下一個唯一元素位置  \n        → Step 4: nums[idx] = nums[i] // 把新唯一值寫入 idx 位置  \n        No  → // 若相同，表示重複，直接跳過  \n\n→ Step 5: 返回 idx + 1 // 唯一元素個數即 idx + 1，並且前 k 個位置已經是唯一值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        Remove duplicates in-place from a sorted list and return the count of unique elements.\n        \"\"\"\n        if not nums:\n            return 0\n        slow = 0\n        for fast in range(1, len(nums)):\n            if nums[fast] != nums[slow]:\n                slow += 1\n                nums[slow] = nums[fast]\n        return slow + 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list representation from the input string\n    start = data.find('[')\n    end = data.find(']', start)\n    if start == -1 or end == -1:\n        return\n    list_str = data[start:end+1]\n    nums = ast.literal_eval(list_str)\n\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n\n    # Build output: show the first k elements and '_' for the rest\n    formatted = ', '.join(str(nums[i]) if i < k else '_' for i in range(len(nums)))\n    print(f\"{k}, nums = [{formatted}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "2, nums = [1,2,_]",
          "success": true,
          "output": "2, nums = [1, 2, _]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
          "expected_output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
          "success": true,
          "output": "5, nums = [0, 1, 2, 3, 4, _, _, _, _, _]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode414.json",
    "problem_index_in_file": 0,
    "title": "Third Maximum Number",
    "description_snippet": "Given an integer array nums, return the third distinct maximum number in this array. If the third ma...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: find third distinct maximum or max if less than 3 distinct numbers. Must output step-by-step virtual code lines with comments. Use Start, End, Decision, Yes →, No →.\n\nWe need to output virtual code lines: Start //, then maybe Step 1: Initialize max1, max2, max3 to None, Step 2: Iterate array, for each number, if it's equal to any of max1/2/3 skip; else update if greater than current max, shift others accordingly. After loop, check if max3 exists, if yes return max3 else return max1. End.\n\nNeed to use decision arrows. Provide each line as \"虛擬碼步驟 // 解釋\". Ensure each line includes arrow or label. Use \"→\" after Start? Format sample uses \"Start\" then arrow lines with \"→ Step 1:\" etc. Should maintain style: \"→ Step 1:\" etc. We can include decisions like \"Decision: 是否有第三大?\" with Yes →, No →.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 將 max1、max2、max3 設為 null // 初始化三個最大值\n→ Step 2: 對陣列中的每個 num 進行迴圈 // 遍歷所有數字\n    → Decision: 如果 num 等於 max1、max2 或 max3? // 忽略重複值\n        Yes → Step 2.1: 跳過這個數字 // 跳過重複\n        No  → Decision: num 大於 max1? // 新值是否為最大的\n            Yes → Step 2.2: max3 ← max2 // 右移第二大\n                → Step 2.3: max2 ← max1 // 右移第一大\n                → Step 2.4: max1 ← num // 將 num 設為最大\n                → Decision: max1 已經更新, 跳至下個 num\n            No  → Decision: num 大於 max2? // 新值是否為第二大\n                Yes → Step 2.5: max3 ← max2 // 右移第二大\n                    → Step 2.6: max2 ← num // 將 num 設為第二大\n                No  → Decision: num 大於 max3? // 新值是否為第三大\n                    Yes → Step 2.7: max3 ← num // 將 num 設為第三大\n                    No  → Step 2.8: 不做任何事 // 小於三者不變\n→ Step 3: Decision: max3 為 null? // 檢查是否存在第三大\n    Yes → Step 3.1: 回傳 max1 // 沒有第三大，回傳最大\n    No  → Step 3.2: 回傳 max3 // 有第三大，回傳\nEnd // 程式結束\n\nWe need to ensure each line begins with appropriate arrow? According to format, each line should contain \"虛擬碼步驟 [space] // 解釋\". The sample shows \"Start\" as first line without arrow. Then lines starting with \"→ Step 1:\" etc. Decision lines start with \"Decision:\".\n\nAlso nested decisions lines should be indented? Sample shows indentation. We can keep same style: indent inside decision.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 max1、max2、max3 為 null // 用來存儲前三個不同最大值  \n→ Step 2: 循環遍歷陣列 nums 中的每個數字 num // 逐一檢查每個元素  \n    → Decision: 如果 num 與 max1、max2 或 max3 相等? // 排除重複值  \n        Yes → Step 2.1: 跳過此數字 // 重複值不處理  \n        No → Decision: num 大於 max1? // 判斷是否為新最大值  \n            Yes → Step 2.2: max3 ← max2 // 將第二大右移為第三大  \n                → Step 2.3: max2 ← max1 // 將第一大右移為第二大  \n                → Step 2.4: max1 ← num // 將 num 設為新最大值  \n            No → Decision: num 大於 max2? // 判斷是否為新第二大值  \n                Yes → Step 2.5: max3 ← max2 // 將第二大右移為第三大  \n                    → Step 2.6: max2 ← num // 將 num 設為新第二大值  \n                No → Decision: num 大於 max3? // 判斷是否為新第三大值  \n                    Yes → Step 2.7: max3 ← num // 將 num 設為新第三大值  \n                    No → Step 2.8: 不做任何事 // 小於三者，保持不變  \n→ Step 3: Decision: max3 為 null? // 檢查是否存在第三大數字  \n    Yes → Step 3.1: 回傳 max1 // 沒有第三大，返回最大值  \n    No → Step 3.2: 回傳 max3 // 有第三大，返回該值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def thirdMax(self, nums):\n        # 用三個變數儲存前三個不同的最大值，初始為負無窮\n        first = second = third = float('-inf')\n        # 去除重複元素\n        nums_set = set(nums)\n        for num in nums_set:\n            if num > first:\n                third = second\n                second = first\n                first = num\n            elif num > second:\n                third = second\n                second = num\n            elif num > third:\n                third = num\n        # 若 distinct 數量不足 3，回傳最大值\n        return third if len(nums_set) >= 3 else first\n\ndef main():\n    # 讀取全部輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        print()\n        return\n    # 從輸入中提取列表字串\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        list_str = match.group()\n        try:\n            nums = ast.literal_eval(list_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n    # 計算結果\n    sol = Solution()\n    result = sol.thirdMax(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [2,2,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode639.json",
    "problem_index_in_file": 0,
    "title": "Decode Ways II",
    "description_snippet": "A message containing letters from A-Z can be encoded into numbers using the following mapping:\n\n'A' ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: decoding number of ways with '*', standard DP with mod. Provide each line of virtual code with explanation. Use Start, End, Decision, etc. Each line includes virtual code step then comment.\n\nWe need to produce step-by-step for algorithm. Provide virtual code steps:\n\nStart\n→ Initialize mod, dp array of length n+1\n→ Set dp[0] = 1\n→ If s[0] == '*': dp[1] = 9 else if s[0] != '0': dp[1] = 1 else dp[1] = 0\n→ Loop i from 2 to n\n    -> current char c1 = s[i-1], prev char c0 = s[i-2]\n    -> singleDigitWays = determine based on c1\n    -> twoDigitWays = determine based on c0 and c1\n    -> dp[i] = (dp[i-1]*singleDigitWays + dp[i-2]*twoDigitWays) mod mod\n→ Return dp[n] mod mod\nEnd\n\nWe need to show decisions for singleDigitWays calculation and twoDigitWays calculation with star conditions.\n\nWe should produce virtual code lines for each step. Use Decision blocks to handle if conditions.\n\nWe also need to incorporate modulo and large number.\n\nLet's produce more detailed lines:\n\nStart\n→ Step 1: Initialize mod = 1000000007\n→ Step 2: n = length of s\n→ Step 3: dp = array of size n+1, all zeros\n→ Step 4: dp[0] = 1 // base case: empty string has one way\n→ Step 5: // Handle first character\n    Decision: If s[0] == '*'\n        Yes → dp[1] = 9 // '*' can be 1-9\n        No  → Decision: If s[0] == '0'\n                Yes → dp[1] = 0 // '0' cannot be decoded alone\n                No  → dp[1] = 1 // any other digit 1-9 valid\n→ Step 6: For i from 2 to n\n    Decision: Compute ways for single digit s[i-1]\n        // We'll store in variable single\n        Decision: If s[i-1] == '*'\n            Yes → single = 9\n            No  → Decision: If s[i-1] == '0'\n                    Yes → single = 0\n                    No  → single = 1\n    Decision: Compute ways for two-digit s[i-2]s[i-1]\n        // Store in variable two\n        Decision: If s[i-2] == '*' and s[i-1] == '*'\n            Yes → two = 15 // 11-19 and 21-26? Wait for '*''*': can be 11-19 (9) plus 21-26 (6) = 15\n            No  → Decision: If s[i-2] == '*'\n                Yes → // s[i-2] can be 1 or 2\n                    Decision: If s[i-1] == '0' or s[i-1] == '1' or s[i-1] == '2'\n                        // if second char 0-6 allowed: For 10-26\n                        // When first is 1: 10-19 (10 ways if second is '*'): 10 possibilities 10-19? Actually 10-19 10 possibilities? 10-19 inclusive 10 numbers. But '*''0' case? Wait we handle general formula: when first is '*', second digit d. For first = 1: 10-19; for first=2: 20-26. So number of combinations: if second digit is '*': 15 (10-19 gives 10, 20-26 gives 6). But we are in case s[i-2]=='*' and s[i-1] != '*', so need to compute based on s[i-1].\n                        Decision: If s[i-1] == '0' → two = 2? Actually 10 and 20 both valid: two ways. So two = 2\n                        No  → Decision: If s[i-1] <= '6' → two = 2? Wait: For first '*', and second digit d <=6: two ways: first can be 1 or 2. So two = 2.\n                        No  → // d >=7\n                            two = 1? Only first=1 valid because 27-29 invalid. So two = 1\n                    No  → // s[i-2] != '*'\n                        Decision: If s[i-2] == '1' or s[i-2] == '2'\n                            Yes → // two-digit formed by s[i-2] and s[i-1]\n                                Decision: If s[i-2] == '1' → any s[i-1] '0'-'9' gives 10 possibilities? Actually we need to check if second digit is '*' or digit.\n                                // But we are in case s[i-2] != '*', s[i-1] == '*': We are inside else.\nBut this is getting too complex for step-by-step.\n\nWe can simplify: Instead of detailed logic per each char, we can provide high-level pseudo with helper functions to compute single and two-digit ways. Provide decision blocks for each case.\n\nBut the requirement: produce virtual code lines and explanation. So we can write generic algorithm with decisions.\n\nLet's produce algorithm in pseudo:\n\nDefine function waysSingle(c) returns number of ways c can represent a single digit.\n\nDefine function waysTwo(a,b) returns number of ways to represent two-digit number formed by a and b.\n\nWe can implement these as separate steps.\n\nWe can write:\n\n→ Step 7: Define function singleWays(char c) // compute ways for one char\n    Decision: If c == '*': return 9\n    No → Decision: If c == '0': return 0\n    No → return 1\n\n→ Step 8: Define function twoWays(char a, char b)\n    Decision: If a == '*' and b == '*':\n        Yes → return 15\n    No  → Decision: If a == '*':\n        Yes → // a can be 1 or 2\n            Decision: If b == '0':\n                Yes → return 2 // 10 and 20\n                No  → Decision: If b <= '6':\n                        Yes → return 2 // 1b or 2b\n                        No  → return 1 // only 1b\n    No  → Decision: If b == '*':\n        Yes → // b can be 1-9\n            Decision: If a == '1':\n                Yes → return 9 // 10-19\n                No  → Decision: If a == '2':\n                        Yes → return 6 // 20-26\n                        No  → return 0\n    No  → // both are digits\n        Decision: If a == '1' or a == '2':\n            Yes → Decision: If (a == '1' and b <= '9') or (a == '2' and b <= '6'):\n                    Yes → return 1\n                    No  → return 0\n        No → return 0\n\nBut we can compress.\n\nGiven the instruction, we should produce line-by-line pseudocode, not function definitions, but we can include functions as steps. That might be okay.\n\nWe also need to incorporate modulo each step.\n\nOk produce final output.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: MOD ← 1000000007 // 取模常數  \n→ Step 2: N ← length(s) // 計算輸入字串長度  \n→ Step 3: dp ← array(N+1, 0) // dp[i] 代表前 i 個字元的解碼方式數  \n→ Step 4: dp[0] ← 1 // 空字串只有一種解碼方式  \n\n// 初始化第一個字元的解碼方式  \n→ Decision: s[0] == '*'?  \n Yes → dp[1] ← 9 // '*' 可為 1~9 共 9 種  \n No  → Decision: s[0] == '0'?  \n  Yes → dp[1] ← 0 // '0' 無合法解碼  \n  No  → dp[1] ← 1 // 1~9 皆合法  \n\n// 主迴圈，從第二個字元開始處理  \n→ For i from 2 to N  \n → c1 ← s[i-1] // 目前字元  \n → c0 ← s[i-2] // 前一個字元  \n\n // 計算單個字元的可能數  \n → Decision: c1 == '*'?  \n  Yes → single ← 9  \n  No  → Decision: c1 == '0'?  \n   Yes → single ← 0  \n   No  → single ← 1  \n\n // 計算兩個字元組合的可能數  \n → Decision: c0 == '*' AND c1 == '*'?  \n  Yes → two ← 15 // 11-19 (9) + 21-26 (6)  \n  No  → Decision: c0 == '*'?  \n   Yes → // 前一個字元是 '*'  \n    Decision: c1 == '0'?  \n     Yes → two ← 2 // 10 和 20  \n     No  → Decision: c1 <= '6'?  \n      Yes → two ← 2 // 1x 或 2x  \n      No  → two ← 1 // 1x 只有一種（10-19 以外）  \n   No  → Decision: c1 == '*'?  \n    Yes → // 後一個字元是 '*'  \n     Decision: c0 == '1'?  \n      Yes → two ← 9 // 10-19  \n      No  → Decision: c0 == '2'?  \n       Yes → two ← 6 // 20-26  \n       No  → two ← 0  \n   No  → // 兩個字元都是數字  \n    Decision: c0 == '1' OR c0 == '2'?  \n     Yes → Decision: (c0 == '1' AND c1 <= '9') OR (c0 == '2' AND c1 <= '6')?  \n      Yes → two ← 1 // 有效的兩位數  \n      No  → two ← 0  \n     No  → two ← 0  \n\n → dp[i] ← (dp[i-1] * single + dp[i-2] * two) mod MOD // 更新 dp  \n\nEnd // 程式執行結束  \n→ Return dp[N] // 回傳整個字串的解碼方式數，已取模\n\n此虛擬碼以逐行方式描述解碼算法的核心邏輯，包含單字元與雙字元組合的計算，並以模數運算確保數值不溢出。",
      "generated_code": "import sys\nimport re\n\nMOD = 10**9 + 7\n\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n\n        for i in range(1, n + 1):\n            # single character contribution\n            if s[i-1] == '*':\n                dp[i] = 9 * dp[i-1]\n            elif s[i-1] != '0':\n                dp[i] = dp[i-1]\n\n            # two character contribution\n            if i > 1:\n                a, b = s[i-2], s[i-1]\n                if a == '*' and b == '*':\n                    dp[i] += 15 * dp[i-2]\n                elif a == '*':\n                    dp[i] += (2 if b <= '6' else 1) * dp[i-2]\n                elif b == '*':\n                    if a == '1':\n                        dp[i] += 9 * dp[i-2]\n                    elif a == '2':\n                        dp[i] += 6 * dp[i-2]\n                else:\n                    if 10 <= int(a + b) <= 26:\n                        dp[i] += dp[i-2]\n\n            dp[i] %= MOD\n\n        return dp[n]\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    Extracts the string value from an input like:\n        s = \"*\"\n    or simply:\n        *\n    \"\"\"\n    # Look for quoted string\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        return match.group(1)\n    # If no quotes, remove possible variable name and equal sign\n    data = data.strip()\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n    return data\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = Solution().numDecodings(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"*\"",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "s = \"1*\"",
          "expected_output": "18",
          "success": true,
          "output": "18"
        },
        {
          "example_index": 2,
          "input": "s = \"2*\"",
          "expected_output": "15",
          "success": true,
          "output": "15"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode367.json",
    "problem_index_in_file": 0,
    "title": "Valid Perfect Square",
    "description_snippet": "Given a positive integer num, return true if num is a perfect square or false otherwise.\nA perfect s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step. Input: positive integer num. Output true/false whether perfect square. No built-in sqrt. Use binary search approach or integer square root. Use loop.\n\nWe need to output each line with \"虛擬碼步驟 // 解釋\". Use arrows. Use Start, End, Decision.\n\nLet's design:\n\nStart\n\n→ Step 1: If num < 0 → return false. (though num positive)\n\n→ Step 2: Initialize left = 0, right = num // binary search boundaries\n\n→ Decision: If left > right? Not needed\n\n→ Step 3: While left ≤ right: // loop\n\n   → mid = (left + right) / 2\n\n   → square = mid * mid\n\n   → Decision: If square == num? // check equality\n\n        Yes → return true\n\n        No → Decision: If square < num? // adjust range\n\n            Yes → left = mid + 1\n\n            No → right = mid - 1\n\n→ End // not found return false\n\nAlso handle large num: product may overflow? But assume within 64-bit. Use BigInt? But pseudocode.\n\nAdd comments. Format each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Indent decisions.\n\nLet's produce.\n\nRemember to not output actual code. Just virtual pseudocode.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入 num // 取得待判斷的正整數  \n→ Step 2: 如果 num < 0 → return false // 負數無法為完全平方，直接返回 false  \n→ Step 3: 初始化 left = 0, right = num // 設定二分搜尋的左右邊界  \n→ Decision: 循環條件：當 left ≤ right 時繼續搜尋 // 確保搜尋範圍仍有效  \n  Yes → While left ≤ right: // 執行二分搜尋循環  \n    → mid = (left + right) / 2 // 計算中點，作為候選平方根  \n    → square = mid * mid // 取得 mid 的平方值  \n    → Decision: 如果 square == num? // 檢查是否正好等於目標數  \n      Yes → return true // 找到完全平方，返回真  \n      No → Decision: 如果 square < num? // 若平方小於目標，搜尋右半區  \n        Yes → left = mid + 1 // 將左邊界調到 mid 之上  \n        No → right = mid - 1 // 否則平方大於目標，將右邊界調到 mid 之下  \n→ End // 未找到完全平方，返回假  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        \"\"\"Return True if num is a perfect square, otherwise False.\"\"\"\n        if num < 2:\n            return True\n        left, right = 2, num // 2\n        while left <= right:\n            mid = (left + right) // 2\n            guess = mid * mid\n            if guess == num:\n                return True\n            elif guess > num:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return False\n\ndef main() -> None:\n    # Read all input from stdin\n    data = sys.stdin.read()\n    # Extract the first integer from the input (handles formats like \"num = 16\")\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        return\n    num = int(numbers[0])\n\n    solution = Solution()\n    result = solution.isPerfectSquare(num)\n    # Print lowercase 'true' or 'false' to match expected output\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "num = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode53.json",
    "problem_index_in_file": 0,
    "title": "Maximum Subarray",
    "description_snippet": "Given an integer array nums, find the subarray with the largest sum, and return its sum....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for Kadane's algorithm. Provide step by step: Start, read array, initialize maxSoFar, maxEndingHere, iterate through array, update maxEndingHere = max(num, maxEndingHere+num), maxSoFar = max(maxSoFar, maxEndingHere). Return maxSoFar. End. Use arrows and decisions? Could incorporate decision if maxEndingHere<0 then reset. But we can use decision step: if current sum negative then reset to current element. But maybe simpler: use max function. But to show decision we can use Decision: If maxEndingHere < 0? No, it's always updated. Maybe we can show Decision: If maxEndingHere < 0? No? Actually in Kadane we reset if maxEndingHere < 0 then set to current num. So we can include decision.\n\nLet's produce each line with explanation. Use Start, End. Use arrows. Let's produce about maybe 12-15 lines. Let's proceed.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 從使用者或函式取得整數陣列  \n→ Step 2: 初始化 maxSoFar ← nums[0] // 最大子陣列和，先設為第一個元素  \n→ Step 3: 初始化 maxEndingHere ← nums[0] // 以目前為止子陣列的累積和  \n→ Step 4: 從 i = 1 開始遍歷 nums // 從第二個元素開始逐個處理  \n    → Decision: 如果 nums[i] > maxEndingHere + nums[i]? // 判斷是單獨開始新子陣列還是延續現有子陣列  \n        Yes → maxEndingHere ← nums[i] // 以當前元素作為新子陣列的起點  \n        No  → maxEndingHere ← maxEndingHere + nums[i] // 延續現有子陣列，累加當前元素  \n    → Decision: 如果 maxEndingHere > maxSoFar? // 檢查是否更新全局最大值  \n        Yes → maxSoFar ← maxEndingHere // 更新全局最大子陣列和  \n        No  → // 目前無需更新  \n→ Step 5: 返回 maxSoFar // 輸出最大子陣列和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef max_subarray(nums):\n    \"\"\"\n    計算最大子陣列和 (Kadane 演算法)\n    \"\"\"\n    max_current = max_global = nums[0]\n    for num in nums[1:]:\n        # 決定是以當前元素開始新子陣列還是延續現有子陣列\n        max_current = max(num, max_current + num)\n        # 若當前子陣列和超過全局最大值，更新全局最大值\n        if max_current > max_global:\n            max_global = max_current\n    return max_global\n\ndef main():\n    \"\"\"\n    主程式：從標準輸入讀取陣列資料，計算並輸出最大子陣列和\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 從輸入字串中找出第一個 '[' 與最後一個 ']' 包含的子字串\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if not match:\n        return\n\n    nums_str = match.group(0)          # 取得 \"[...]\"\n    nums = eval(nums_str)              # 轉成 list，假設輸入格式正確\n\n    result = max_subarray(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [5,4,-1,7,8]",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode14.json",
    "problem_index_in_file": 0,
    "title": "Longest Common Prefix",
    "description_snippet": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrows and comments. Steps: Start, get array, if empty return empty, set prefix = first string, loop each string, while current string doesn't start with prefix, shorten prefix, if empty break, end loop, return prefix. End. Use decision steps. Provide line by line. Ensure each line includes arrow and comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串陣列 strs // 取得輸入的字串陣列  \n→ Decision: 若 strs 為空? // 檢查陣列是否為空  \n    Yes → Step 2: 回傳 \"\" // 若空陣列，直接回傳空字串  \n    No  → Step 3: 設定 prefix = strs[0] // 以第一個字串作為初始前綴  \n→ For i 從 1 到 strs.length-1 // 逐一檢查其餘字串  \n    → Decision: 是否 prefix 為空? // 若前綴已經縮為空，無需繼續  \n        Yes → Break // 退出迴圈  \n        No  →  \n            → Decision: strs[i] 是否以 prefix 開頭? // 檢查當前字串是否包含前綴  \n                Yes → Continue // 若是，繼續檢查下一個字串  \n                No  → → Step 4: 將 prefix 截短 1 個字符 // 去掉最後一個字元  \n                    → Repeat: 重複檢查 strs[i] 是否以新 prefix 開頭? // 直到符合或前綴變空  \n                        Yes → Continue 從上一層 For 迴圈  \n                        No  → Repeat 截短 prefix  \n→ Step 5: 回傳 prefix // 所有字串共同的前綴已確定  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        Find the longest common prefix string among an array of strings.\n        If there is no common prefix, return an empty string \"\".\n        \"\"\"\n        if not strs:                     # 若輸入為空列表，直接回傳空字串\n            return \"\"\n\n        prefix = strs[0]                 # 初始前綴設為第一個字串\n        for s in strs[1:]:               # 循環檢查其餘字串\n            while not s.startswith(prefix):  # 若當前字串不以 prefix 開頭\n                prefix = prefix[:-1]         # 將 prefix 截短一個字元\n                if not prefix:               # 若前綴已縮為空，無共同前綴\n                    return \"\"\n        return prefix\n\ndef parse_input(input_str):\n    \"\"\"\n    解析輸入字串，預期格式為 `strs = [\"flower\",\"flow\",\"flight\"]` 等。\n    允許多種空白與換行，使用 ast.literal_eval 以安全方式解析列表。\n    \"\"\"\n    input_str = input_str.strip()\n    if not input_str:\n        return []\n    # 移除可能的變數名稱與等號\n    if '=' in input_str:\n        input_str = input_str.split('=', 1)[1].strip()\n    try:\n        # ast.literal_eval 只允許安全的 Python 字面量\n        return ast.literal_eval(input_str)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整段內容\n    raw_input = sys.stdin.read()\n    strs = parse_input(raw_input)\n\n    # 呼叫解法\n    sol = Solution()\n    result = sol.longestCommonPrefix(strs)\n\n    # 依題目範例輸出，需帶上雙引號\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"flower\",\"flow\",\"flight\"]",
          "expected_output": "\"fl\"",
          "success": true,
          "output": "\"fl\""
        },
        {
          "example_index": 1,
          "input": "strs = [\"dog\",\"racecar\",\"car\"]",
          "expected_output": "\"\"",
          "success": true,
          "output": "\"\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode72.json",
    "problem_index_in_file": 0,
    "title": "Edit Distance",
    "description_snippet": "Given two strings word1 and word2, return the minimum number of operations required to convert word1...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for edit distance DP. Outline: Start, initialize DP table of size (len1+1)x(len2+1). Fill base cases: dp[i][0]=i, dp[0][j]=j. Then nested loops i=1..len1, j=1..len2: if char equal then dp[i][j]=dp[i-1][j-1]; else dp[i][j]=1+min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]). After loops, result dp[len1][len2]. End.\n\nWe need each line of virtual code with explanation. Use arrows. We'll include Start, End, decisions. Need to use \"→\" for next steps. Use \"Decision:\" lines. Provide lines with // explanation.\n\nLet's produce lines:\n\nStart // 開始\n→ Step 1: 將 word1 長度設為 m，word2 長度設為 n // 取得字串長度\n→ Step 2: 初始化 m+1 行 n+1 列的 dp 表格 // 建立 DP 表\n→ Step 3: 逐行設定 dp[i][0] = i // 將 word1 的前 i 個字刪除\n→ Step 4: 逐列設定 dp[0][j] = j // 插入 word2 的前 j 個字\n→ Decision: 是否還有 i 從 1 到 m? // 進入雙層迴圈\n    Yes → Step 5: 對於每個 i 從 1 到 m\n        → Step 6: 對於每個 j 從 1 到 n\n            → Decision: word1[i-1] 是否等於 word2[j-1]? // 判斷字符是否相同\n                Yes → Step 7: dp[i][j] = dp[i-1][j-1] // 相同無需操作\n                No  → Step 8: dp[i][j] = 1 + min(\n                        dp[i-1][j],    // 刪除\n                        dp[i][j-1],    // 插入\n                        dp[i-1][j-1]   // 替換\n                    ) // 三種操作的最小值\n            → End\n        → End\n    → End\n→ Step 9: 回傳 dp[m][n] // 取得最小編輯距離\nEnd // 結束\n\nMake sure each line has arrow or decision. Ensure format. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 m = word1.length // 取得 word1 的長度  \n→ Step 2: 設定 n = word2.length // 取得 word2 的長度  \n→ Step 3: 初始化 dp 為 (m+1)×(n+1) 的表格 // 建立 DP 表格  \n→ Step 4: 對 i 從 0 到 m 設定 dp[i][0] = i // 將前 i 個字從 word1 刪除  \n→ Step 5: 對 j 從 0 到 n 設定 dp[0][j] = j // 插入前 j 個字到空字串  \n→ Decision: 是否還有 i 從 1 到 m? // 進入雙層迴圈  \n Yes → Step 6: 對 i 從 1 到 m  \n  → Step 7: 對 j 從 1 到 n  \n   → Decision: word1[i-1] == word2[j-1]? // 判斷兩字是否相同  \n    Yes → Step 8: dp[i][j] = dp[i-1][j-1] // 相同，遞延上一行  \n    No  → Step 9: dp[i][j] = 1 + min( dp[i-1][j], dp[i][j-1], dp[i-1][j-1] ) // 刪除/插入/替換之最小  \n      // dp[i-1][j]：刪除 word1[i-1]  \n      // dp[i][j-1]：插入 word2[j-1]  \n      // dp[i-1][j-1]：替換 word1[i-1] 為 word2[j-1]  \n      // 取三者最小後加 1  \n      // 回到 Step 7  \n   → End  \n  → End  \n → End  \n→ Step 10: 回傳 dp[m][n] // 最小編輯距離  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        \"\"\"計算兩個字串之最小編輯距離（插入、刪除、替換）。\"\"\"\n        m, n = len(word1), len(word2)\n        # 建立 DP 表格 (m+1) x (n+1)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        # 基礎條件：將 word1 的前 i 個字刪除或插入 word2 的前 j 個字\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n\n        # 填表格\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(\n                        dp[i - 1][j],      # 刪除\n                        dp[i][j - 1],      # 插入\n                        dp[i - 1][j - 1]   # 替換\n                    )\n        return dp[m][n]\n\ndef parse_input(text: str):\n    \"\"\"從輸入文字中抽取 word1 與 word2。\"\"\"\n    # 先嘗試找字串字面值\n    w1 = re.search(r'word1\\s*=\\s*\"([^\"]*)\"', text)\n    w2 = re.search(r'word2\\s*=\\s*\"([^\"]*)\"', text)\n    if w1 and w2:\n        return w1.group(1), w2.group(1)\n\n    # 如果沒有字面值，假設每行一個字串\n    lines = [line.strip() for line in text.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    # 若仍無法解析，回傳空字串\n    return '', ''\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read()\n    word1, word2 = parse_input(input_text)\n    result = Solution().minDistance(word1, word2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "word1 = \"horse\", word2 = \"ros\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "word1 = \"intention\", word2 = \"execution\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode765.json",
    "problem_index_in_file": 0,
    "title": "Couples Holding Hands",
    "description_snippet": "There are n couples sitting in 2n seats arranged in a row and want to hold hands.\n\nThe people and se...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the algorithm: given array row length 2n, couples are IDs pairs (0,1),(2,3),... want minimal swaps to seat each couple adjacent. This is a classic problem. Approach: treat as graph: each pair of seats should have matching couples; we can treat each couple as a node; swap between seat positions to bring couple together. Minimum swaps equal number of edges in cycle minus one. We can iterate seats: for each seat i, if partner not adjacent, swap with seat containing partner of current person.\n\nImplementation: map person->index. For i in 0 to 2n-1 step 2: let a=row[i], b=row[i+1]; partner = a ^ 1 (since couples are consecutive with xor 1). if row[i+1]==partner then continue. else we need to swap partner into position i+1. Find index j = pos[partner]; swap row[i+1] with row[j]; update pos of the swapped persons; increment swaps.\n\nReturn swaps.\n\nWe need to produce virtual code with arrows and explanation. Each line: Step. We'll provide comments after //.\n\nLet's produce lines:\n\nStart\n→ Step 1: n ← length(row) / 2 // compute number of couples\n→ Step 2: pos ← array mapping person ID to current seat index // build index map\n    For each i from 0 to 2n-1: pos[row[i]] ← i\n→ Step 3: swaps ← 0 // counter for swaps\n→ Step 4: For seat i from 0 to 2n-1 step 2: // process each couple seat pair\n    → Step 4.1: a ← row[i] // first person in the pair\n    → Step 4.2: b ← row[i+1] // second person in the pair\n    → Step 4.3: partner ← a XOR 1 // partner ID for a\n    → Step 4.4: If b == partner Then continue // already a correct couple\n        Else // need to swap\n            → Step 4.5: j ← pos[partner] // seat where partner currently sits\n            → Step 4.6: row[i+1] ↔ row[j] // swap the two persons\n            → Step 4.7: pos[row[j]] ← j // update position of person now at j\n            → Step 4.8: pos[row[i+1]] ← i+1 // update position of person now at i+1\n            → Step 4.9: swaps ← swaps + 1 // increment swap counter\n→ Step 5: return swaps // minimum swaps required\nEnd\n\nWe need to use the arrow format and indentation. Use \"→\" for steps and \"Decision:\" for if. Use \"Yes →\" \"No →\". Let's produce properly.\n\nWe'll use \"Decision: b == partner?\" etc.\n\nAlso, \"Start // 程式開始執行\" etc.\n\nWe need to ensure each line has virtual code step and comment. We'll include the mapping loops as multiple steps or summarise. Provide explanation each line.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(row) / 2 // 計算夫妻對數  \n→ Step 2: pos ← array of size 2n // 建立人員到座位的映射  \n→ Step 3: For i from 0 to 2n-1: pos[row[i]] ← i // 填寫索引表  \n→ Step 4: swaps ← 0 // 初始化交換次數計數器  \n→ Step 5: For i from 0 to 2n-1 step 2: // 逐對處理座位  \n→ Step 5.1: a ← row[i] // 第一個座位的人  \n→ Step 5.2: b ← row[i+1] // 第二個座位的人  \n→ Step 5.3: partner ← a XOR 1 // a 的配偶 ID  \n→ Decision: b == partner? // 兩人已是正確夫妻？  \n  Yes → Continue // 若已配對，跳過此對  \n  No → Step 5.4: j ← pos[partner] // 找到配偶所在座位  \n   → Step 5.5: Swap row[i+1] and row[j] // 交換兩人座位  \n   → Step 5.6: pos[row[j]] ← j // 更新被交換者的新座位  \n   → Step 5.7: pos[row[i+1]] ← i+1 // 更新新座位人的映射  \n   → Step 5.8: swaps ← swaps + 1 // 計算一次交換  \n→ Step 6: return swaps // 最小交換數完成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef min_swaps_couples(row):\n    n = len(row)\n    pos = [0] * n\n    for i, x in enumerate(row):\n        pos[x] = i\n    swaps = 0\n    for i in range(0, n, 2):\n        x = row[i]\n        partner = x ^ 1\n        if row[i + 1] != partner:\n            j = pos[partner]\n            row[i + 1], row[j] = row[j], row[i + 1]\n            pos[row[j]] = j\n            pos[row[i + 1]] = i + 1\n            swaps += 1\n    return swaps\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 允許輸入形如 \"row = [0,2,1,3]\" 或僅 [0,2,1,3]\n    if data.startswith(\"row\"):\n        start = data.find('[')\n        if start != -1:\n            data = data[start:]\n    try:\n        row = ast.literal_eval(data)\n    except Exception:\n        print(\"Invalid input\")\n        sys.exit(1)\n    result = min_swaps_couples(row)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "row = [0,2,1,3]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "row = [3,2,0,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode374.json",
    "problem_index_in_file": 0,
    "title": "Guess Number Higher or Lower",
    "description_snippet": "We are playing the Guess Game. The game is as follows: \n\nI pick a number from 1 to n. You have to gu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code that solves the guess game. It's basically binary search between 1 and n, using guess API. Provide steps line by line with explanation. Use Start, End, Decision: with arrows. No actual code. We'll produce lines.\n\nProbably: Start // begin; Set low=1, high=n; while low <= high: mid = low + (high-low)/2; result = guess(mid); Decision: result==0? Yes -> return mid; No -> Decision: result== -1? Yes -> high = mid -1; else -> low = mid +1. End.\n\nBut must output as virtual code lines with arrows and explanation. Let's produce.\n\nWe also need to mention returning the number, but we don't show actual return. Provide final step.\n\nOk. Use appropriate indentation.\n\nMake sure each line: 虛擬碼步驟 // 解釋. For decisions indent with tabs maybe? We just need format: `Decision: 如果 result == 0? // 檢查猜對與否`. Then Yes → Step: return mid. No → Decision: result == -1? etc.\n\nLet's craft.\n\nWe'll use:\n\nStart // 程式開始執行\n→ Step 1: low = 1 // 初始化最小值\n→ Step 2: high = n // 初始化最大值\n→ Decision: while low <= high? // 判斷是否仍有可能的範圍\n    Yes →\n        → Step 3: mid = low + (high - low) / 2 // 計算中間值\n        → Step 4: result = guess(mid) // 呼叫 API 取得結果\n        → Decision: 如果 result == 0? // 判斷是否猜中\n            Yes →\n                → Step 5: return mid // 回傳正確答案\n            No →\n                → Decision: 如果 result == -1? // 判斷猜的數字是否太大\n                    Yes →\n                        → Step 6: high = mid - 1 // 調整上界\n                    No →\n                        → Step 7: low = mid + 1 // 調整下界\n        → Step 8: repeat while loop // 重新判斷條件\n    No →\n        → Step 9: return -1 // 無法找到數字（理論上不會發生）\nEnd // 程式結束\n\nNeed to ensure arrow formatting: use `→` preceding each step. For decision lines, indent? Use spaces. The format: `Decision: ...` then indentation for Yes/No. Provide Yes → ... with spaces.\n\nOk. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 1 // 初始化最小值  \n→ Step 2: high = n // 初始化最大值  \n→ Decision: 是否還有可能的範圍 (low <= high)? // 檢查搜尋區間是否非空  \n    Yes →  \n        → Step 3: mid = low + (high - low) / 2 // 計算中間值  \n        → Step 4: result = guess(mid) // 呼叫 API 取得判斷結果  \n        → Decision: result == 0? // 判斷是否猜中  \n            Yes →  \n                → Step 5: return mid // 正確答案，結束搜尋  \n            No →  \n                → Decision: result == -1? // 判斷猜的數字是否太大  \n                    Yes →  \n                        → Step 6: high = mid - 1 // 調整上界  \n                    No →  \n                        → Step 7: low = mid + 1 // 調整下界  \n        → Step 8: 重新進入 Decision 判斷 (循環) // 重新檢查條件，持續搜尋  \n    No →  \n        → Step 9: return -1 // 失敗（理論上不會發生，為備用）  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\n# 全域變數，用於模擬 guess API\npick_value = None\n\ndef guess(num: int) -> int:\n    \"\"\"\n    模擬預測 API。\n    返回 -1：num 大於正確答案\n    返回 1：num 小於正確答案\n    返回 0：num 等於正確答案\n    \"\"\"\n    global pick_value\n    if num > pick_value:\n        return -1\n    elif num < pick_value:\n        return 1\n    else:\n        return 0\n\nclass Solution:\n    def guessNumber(self, n: int) -> int:\n        \"\"\"\n        使用二分搜尋與 guess API 找出正確答案。\n        \"\"\"\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            res = guess(mid)\n            if res == 0:\n                return mid\n            elif res < 0:   # mid 大於 pick\n                right = mid - 1\n            else:           # mid 小於 pick\n                left = mid + 1\n        return -1  # 這裡理論上不會到達\n\nif __name__ == \"__main__\":\n    # 讀取輸入並擷取 n 與 pick\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) >= 2:\n        n, pick_value = nums[0], nums[1]\n    else:\n        # 若輸入格式不符，直接終止\n        sys.exit(0)\n\n    solution = Solution()\n    answer = solution.guessNumber(n)\n    print(answer)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10, pick = 6",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 1, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode18.json",
    "problem_index_in_file": 0,
    "title": "4Sum",
    "description_snippet": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the four sum problem. Steps: sort array, nested loops for first two indices, then two pointers for remaining two. Avoid duplicates. Use decision points for bounds and duplicate checks. We'll output line by line with virtual code arrows, decision labels, etc.\n\nNeed to ensure \"逐行\" meaning each line is a step.\n\nWe should produce something like:\n\nStart\n→ Step 1: Sort nums ascending\n→ Step 2: Initialize result list\n→ Step 3: For i from 0 to n-4\n    Decision: If i > 0 and nums[i]==nums[i-1] → Skip duplicate\n    → Step 4: For j from i+1 to n-3\n        Decision: If j > i+1 and nums[j]==nums[j-1] → Skip duplicate\n        → Step 5: left = j+1, right = n-1\n        → Decision: while left < right\n            → Step 6: sum = nums[i]+nums[j]+nums[left]+nums[right]\n            → Decision: if sum == target\n                → Step 7: Add [nums[i], nums[j], nums[left], nums[right]] to result\n                → Step 8: while left < right and nums[left]==nums[left+1] → left++\n                → Step 9: while left < right and nums[right]==nums[right-1] → right--\n                → Step 10: left++; right--\n            → Decision: if sum < target → left++\n            → Decision: if sum > target → right--\nEnd\n\nMake sure each line ends with // explanation.\n\nAlso ensure to use \"Decision:\" line for decisions and \"Yes →\" \"No →\". But we can use single decision with Yes/No arrow.\n\nBetter to align with format: each line has arrow or indent. Use arrow ->. For decision we indent.\n\nWe'll produce code with proper formatting.\n\nAlso need to mention complexity perhaps not necessary but okay.\n\nLet's craft.\n\nWe'll produce something like:\n\n```\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 為方便後續兩指標法\n→ Step 2: 初始化 result 為空陣列 // 用來存所有符合條件的四元組\n→ Step 3: For i in 0 to n-4 // 第一個指標\n    Decision: 如果 i>0 且 nums[i]==nums[i-1]? // 避免重複的第一個數字\n        Yes → Continue // 跳過重複\n        No  → Step 4: For j in i+1 to n-3 // 第二個指標\n            Decision: 如果 j>i+1 且 nums[j]==nums[j-1]? // 避免重複的第二個數字\n                Yes → Continue\n                No  → Step 5: left ← j+1, right ← n-1 // 設定兩指標\n                    Decision: 當 left < right?\n                        Yes → Step 6: sum ← nums[i]+nums[j]+nums[left]+nums[right] // 計算四數之和\n                            Decision: sum == target?\n                                Yes → Step 7: 將 [nums[i], nums[j], nums[left], nums[right]] 加入 result\n                                    Decision: left < right 且 nums[left]==nums[left+1]? \n                                        Yes → left++ // 跳過重複左邊數字\n                                        No\n                                    Decision: left < right 且 nums[right]==nums[right-1]?\n                                        Yes → right-- // 跳過重複右邊數字\n                                        No\n                                    → Step 8: left++ ; right-- // 移動兩指標\n                                No  → Decision: sum < target?\n                                    Yes → Step 9: left++ // 需要更大的數\n                                    No  → Step 10: right-- // 需要更小的數\n                        No  → // left>=right 結束內層迴圈\nEnd // 程式執行結束\n```\n\nMake sure each line ends with // explanation.\n\nWe need to be careful: after decision, we need to indent subsequent steps under Yes or No. The format requires \"Yes →\" \"No →\". Example earlier. We'll produce accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先排序，方便兩指標法與去重  \n→ Step 2: 初始化 result 為空陣列 // 用來儲存所有符合條件的四元組  \n\n→ Step 3: For i in 0 to n-4 // 第一個指標  \n Decision: 如果 i > 0 且 nums[i] == nums[i-1]? // 避免第一個數字重複  \n  Yes → Continue // 跳過重複的第一個數  \n  No  → Step 4: For j in i+1 to n-3 // 第二個指標  \n   Decision: 如果 j > i+1 且 nums[j] == nums[j-1]? // 避免第二個數字重複  \n    Yes → Continue // 跳過重複的第二個數  \n    No  → Step 5: left ← j+1, right ← n-1 // 設定左右兩指標  \n\n    Decision: 當 left < right? // 確保兩指標不重疊  \n     Yes → Step 6: sum ← nums[i] + nums[j] + nums[left] + nums[right] // 計算四數之和  \n      Decision: sum == target?  \n       Yes → Step 7: 將 [nums[i], nums[j], nums[left], nums[right]] 加入 result // 找到一組合法四元組  \n        Decision: left < right 且 nums[left] == nums[left+1]?  \n         Yes → left++ // 跳過左側重複數字  \n        No  \n        Decision: left < right 且 nums[right] == nums[right-1]?  \n         Yes → right-- // 跳過右側重複數字  \n        No  \n        → Step 8: left++ ; right-- // 同時移動兩指標  \n       No  → Decision: sum < target?  \n        Yes → Step 9: left++ // 需要更大的和，移動左指標  \n        No  → Step 10: right-- // 需要更小的和，移動右指標  \n\n     No  → // left >= right，結束內層 while  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def fourSum(self, nums, target):\n        nums.sort()\n        n = len(nums)\n        res = []\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form:\n        nums = [1,0,-1,0,-2,2], target = 0\n    or any similar single line.\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], 0\n    # Split by ', target ='\n    parts = data.split(', target =')\n    nums_part = parts[0].replace('nums =', '').strip()\n    target_part = parts[1].strip() if len(parts) > 1 else '0'\n    nums = ast.literal_eval(nums_part)\n    target = int(target_part)\n    return nums, target\n\ndef main():\n    raw = sys.stdin.read()\n    nums, target = parse_input(raw)\n    sol = Solution()\n    result = sol.fourSum(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,0,-1,0,-2,2], target = 0",
          "expected_output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
          "success": true,
          "output": "[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2], target = 8",
          "expected_output": "[[2,2,2,2]]",
          "success": true,
          "output": "[[2, 2, 2, 2]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode509.json",
    "problem_index_in_file": 0,
    "title": "Fibonacci Number",
    "description_snippet": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for computing Fibonacci number given n. We need to output line by line with \"虛擬碼步驟 // 解釋\". We need to use arrow symbols and structure. Should cover input n, then compute recursively or iteratively. Probably iterative loop to avoid recursion stack. Provide base cases. So let's produce steps:\n\nStart\n→ Step 1: 輸入 n // 取得使用者輸入的整數 n\n→ Decision: 如果 n == 0? // 檢查是否為 0\n   Yes → Step 2: 輸出 0 // F(0)=0\n   No → Decision: 如果 n == 1? // 檢查是否為 1\n      Yes → Step 3: 輸出 1 // F(1)=1\n      No → Step 4: 初始化 a=0, b=1, i=2 // 用迴圈計算\n      → Step 5: 迴圈 while i ≤ n // 計算到第 n 個\n          → Step 6: c = a + b // 計算下一個 Fibonacci\n          → Step 7: a = b // 更新\n          → Step 8: b = c // 更新\n          → Step 9: i = i + 1 // 增量\n      → Decision: i > n? // 迴圈結束\n          Yes → Step 10: 輸出 b // 最後一個 b 是 F(n)\n          No → Step 5 // 繼續迴圈\nEnd\n\nWe need to format exactly each line with arrow. For nested decisions, we need indentation. The sample uses indentation by spaces. Let's follow that. Each line: \"→\" then text. For decisions use \"Decision:\".\n\nEnsure each line ends with \"// 說明\". We must not output actual code. Use Chinese. The line for each step must include the virtual code step text and explanation.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入 n // 取得使用者輸入的整數 n\n→ Decision: 如果 n == 0? // 檢查是否為 0\n    Yes → Step 2: 輸出 0 // F(0)=0\n    No  → Decision: 如果 n == 1? // 檢查是否為 1\n        Yes → Step 3: 輸出 1 // F(1)=1\n        No  → Step 4: 初始化 a=0, b=1, i=2 // 用迴圈計算\n        → Step 5: 迴圈 while i ≤ n // 計算到第 n 個\n            → Step 6: c = a + b // 計算下一個 Fibonacci\n            → Step 7: a = b // 更新\n            → Step 8: b = c // 更新\n            → Step 9: i = i + 1 // 增量\n        → Decision: i > n? // 迴圈結束\n            Yes → Step 10: 輸出 b // 最後一個 b 是 F(n)\n            No  → Step 5 // 繼續迴圈\nEnd // 程式執行結束\n\nBut we need each line in a separate line. For decisions, the nested lines are indented. The sample shows indentation with spaces.\n\nWe must ensure each line ends with explanation.\n\nLet's ensure proper indentation: For each nested block, indent with 4 spaces? In sample they used 4 spaces indentation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入 n // 取得使用者輸入的整數 n\n→ Decision: 如果 n == 0? // 檢查是否為 0\n    Yes → Step 2: 輸出 0 // F(0)=0\n    No  → Decision: 如果 n == 1? // 檢查是否為 1\n        Yes → Step 3: 輸出 1 // F(1)=1\n        No  → Step 4: 初始化 a=0, b=1, i=2 // 用迴圈計算\n        → Step 5: 迴圈 while i ≤ n // 計算到第 n 個\n            → Step 6: c = a + b // 計算下一個 Fibonacci\n            → Step 7: a = b // 更新 a 為前一個數\n            → Step 8: b = c // 更新 b 為下一個數\n            → Step 9: i = i + 1 // 迴圈計數器加 1\n        → Decision: i > n? // 迴圈結束判斷\n            Yes → Step 10: 輸出 b // 最後一次更新的 b 即為 F(n)\n            No  → Step 5 // 重新進入迴圈\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef fib(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\ndef main():\n    data = sys.stdin.read()\n    # 找出第一個出現的整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = fib(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode15.json",
    "problem_index_in_file": 0,
    "title": "3Sum",
    "description_snippet": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following format. Steps for 3Sum problem. Provide pseudo steps. Use Start, End, Decision. We should outline algorithm: sort array, iterate i, use two pointers j,k. Avoid duplicates. We'll produce step lines.\n\nWe need each line: \"虛擬碼步驟 // 解釋\".\n\nWe'll produce like:\n\nStart\n→ Step 1: Sort nums ascending // sorting helps two-pointer and duplicate skip\n→ Step 2: For i from 0 to len(nums)-3 // iterate first element\n    → Decision: If i>0 and nums[i]==nums[i-1]? // skip duplicate first\n        Yes → Continue // skip duplicate\n    → Set left = i+1, right = len(nums)-1 // two pointers\n    → Decision: While left < right? // loop\n        Yes → Step: sum = nums[i]+nums[left]+nums[right] // compute sum\n            → Decision: If sum == 0? // found triplet\n                Yes → Step: Append [nums[i],nums[left],nums[right]] to result\n                    → Step: left++ // move left\n                    → Step: right-- // move right\n                    → Decision: While left<right and nums[left]==nums[left-1]? // skip duplicate left\n                        Yes → left++ // skip\n                    → Decision: While left<right and nums[right]==nums[right+1]? // skip duplicate right\n                        Yes → right-- // skip\n                No → Decision: If sum < 0? // need larger sum\n                    Yes → left++ // move left to increase\n                    No  → right-- // decrease sum\n→ End\n\nBut we need each line separated. Need to ensure each line ends with comment. Use arrow arrows: → Step ... etc. Use Decision lines with Yes →, No →. We must use proper indent? Not necessary but we can show indentation with spaces.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先將陣列排序，方便後續雙指標及去重  \n→ Step 2: For i from 0 to len(nums)-3 // 遍歷每個可能作為三元組首項的索引  \n    → Decision: If i>0 and nums[i]==nums[i-1]? // 判斷首項是否為重複值  \n        Yes → Continue // 若是重複，跳過此 i 以避免重複三元組  \n    → Step 3: Set left = i+1, right = len(nums)-1 // 初始化兩個指標  \n    → Decision: While left < right? // 在左指標小於右指標時進行搜尋  \n        Yes → Step 4: sum = nums[i] + nums[left] + nums[right] // 計算三個數的總和  \n            → Decision: If sum == 0? // 找到符合條件的三元組  \n                Yes → Step 5: Append [nums[i], nums[left], nums[right]] to result // 保存結果  \n                    → Step 6: left++ // 左指標右移以尋找新解  \n                    → Step 7: right-- // 右指標左移以尋找新解  \n                    → Decision: While left < right and nums[left] == nums[left-1]? // 去除左指標重複  \n                        Yes → left++ // 跳過重複值  \n                    → Decision: While left < right and nums[right] == nums[right+1]? // 去除右指標重複  \n                        Yes → right-- // 跳過重複值  \n            No → Decision: If sum < 0? // 總和小於 0，需增大總和  \n                Yes → left++ // 左指標右移，取較大的數值  \n                No → right-- // 右指標左移，取較小的數值  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Find all unique triplets in the array which gives the sum of zero.\n        \"\"\"\n        nums.sort()                     # Step 1: sort the array\n        res: List[List[int]] = []\n        n = len(nums)\n\n        for i in range(n):              # Step 2: iterate over the first element\n            if i > 0 and nums[i] == nums[i - 1]:  # skip duplicate first elements\n                continue\n            left, right = i + 1, n - 1            # two-pointer initialization\n            while left < right:                   # Step 4: two-pointer search\n                total = nums[i] + nums[left] + nums[right]\n                if total == 0:                    # found a triplet\n                    res.append([nums[i], nums[left], nums[right]])\n                    # skip duplicates for left\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    # skip duplicates for right\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n                elif total < 0:                   # need larger sum\n                    left += 1\n                else:                             # need smaller sum\n                    right -= 1\n        return res\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, parse the list, compute 3Sum, and print the result.\n    Expected input format examples:\n        nums = [-1,0,1,2,-1,-4]\n        [-1,0,1,2,-1,-4]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list expression after '=' if present\n    if '=' in data:\n        _, arr_str = data.split('=', 1)\n        arr_str = arr_str.strip()\n    else:\n        arr_str = data\n\n    try:\n        nums = ast.literal_eval(arr_str)\n    except (SyntaxError, ValueError):\n        # If parsing fails, assume the input is already a valid Python list string\n        nums = []\n\n    solution = Solution()\n    result = solution.threeSum(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,1,2,-1,-4]",
          "expected_output": "[[-1,-1,2],[-1,0,1]]",
          "success": true,
          "output": "[[-1, -1, 2], [-1, 0, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,0,0]",
          "expected_output": "[[0,0,0]]",
          "success": true,
          "output": "[[0, 0, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode474.json",
    "problem_index_in_file": 0,
    "title": "Ones and Zeroes",
    "description_snippet": "You are given an array of binary strings strs and two integers m and n.\n\nReturn the size of the larg...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a virtual code flow that solves the problem: given array of binary strings, find largest subset size with at most m zeros and n ones. Classic DP: 2D knapSack.\n\nWe need to output in requested format: line per step with \"虛擬碼步驟\" then space then comment.\n\nWe must use virtual code arrow \"→\", \"Yes →\", \"No →\" etc.\n\nWe need to produce structured steps: Start, compute counts, DP table initialization, iterate strings, inner loops, update DP, return answer, End.\n\nWe need to keep it simple. For each step, provide explanation.\n\nWe must not output actual code. Just steps. Let's craft.\n\nFirst: Start // begin\n\n→ Step 1: Input strs, m, n // get data\n\n→ Step 2: Initialize dp array (m+1) x (n+1) to 0 // DP table\n\n→ Decision: For each string s in strs? // iterate\n\n   → Step 3: Count zeros z and ones o in s // compute counts\n\n   → Decision: If z <= m and o <= n? // check feasibility\n\n       Yes → Step 4: For i from m down to z\n\n           → Step 5: For j from n down to o\n\n               → Step 6: dp[i][j] = max(dp[i][j], dp[i - z][j - o] + 1) // update\n\n       No → Step 7: Continue // skip string\n\n→ Step 8: Find max value in dp[][] // after all strings processed\n\n→ Step 9: Return max // result\n\nEnd // finished\n\nWe also need to use \"Decision:\" format with nested arrows.\n\nAlso \"Yes →\" and \"No →\" inside.\n\nMake sure each line is a separate virtual code step line, with explanation.\n\nWe must also consider the nested loops. Use arrows for loops.\n\nWe need to output each step as separate line. We'll output in order.\n\nLet's craft the lines:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 strs、整數 m、n // 取得問題參數\n→ Step 2: 建立 dp 二維表 dp[m+1][n+1]，並初始化為 0 // 動態規劃表\n→ Decision: 對於陣列中每個字串 s? // 逐一處理\n    Yes → Step 3: 計算 s 中 0 的數量 z 和 1 的數量 o // 獲取限制\n    → Decision: z <= m 且 o <= n? // 確認能否放入表中\n        Yes → Step 4: 由 i = m 降至 z\n            → Step 5: 由 j = n 降至 o\n                → Step 6: dp[i][j] = max(dp[i][j], dp[i - z][j - o] + 1) // 更新 DP\n        No → Step 7: 跳過此字串 // 超過限制不處理\n→ Step 8: 從 dp 表中找出最大值 // 取得答案\n→ Step 9: 回傳最大值 // 結果輸出\nEnd // 程式執行結束\n\nMake sure each step line ends with comment.\n\nAlso use \"→\" at start. Ensure indentation for nested decisions maybe using spaces.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 strs、整數 m、n // 取得問題參數\n→ Step 2: 建立 dp 二維表 dp[m+1][n+1]，並初始化為 0 // 動態規劃表\n→ Decision: 對於陣列中每個字串 s? // 逐一處理\n    Yes → Step 3: 計算 s 中 0 的數量 z 和 1 的數量 o // 獲取限制\n    → Decision: z <= m 且 o <= n? // 確認能否放入表中\n        Yes → Step 4: 由 i = m 降至 z\n            → Step 5: 由 j = n 降至 o\n                → Step 6: dp[i][j] = max(dp[i][j], dp[i - z][j - o] + 1) // 更新 DP\n        No → Step 7: 跳過此字串 // 超過限制不處理\n→ Step 8: 從 dp 表中找出最大值 // 取得答案\n→ Step 9: 回傳最大值 // 結果輸出\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 逆序遍歷，避免重複使用同一個字串\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 用 exec 解析類似 \"strs = [...], m = 5, n = 3\" 的輸入\n    local_vars = {}\n    exec(data, {}, local_vars)\n    strs = local_vars.get('strs', [])\n    m = local_vars.get('m', 0)\n    n = local_vars.get('n', 0)\n    result = Solution().findMaxForm(strs, m, n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpuq2053sr.py\", line 20, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp78dzp3ah.py\", line 20, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\n    ^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode227.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator II",
    "description_snippet": "Given a string s which represents an expression, evaluate this expression and return its value.\n\nThe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for evaluating a string expression with + - * / and integer truncation towards zero, no eval. Typical algorithm: use stack to handle precedence: iterate through string, parse numbers, keep current operator, for * and / do immediate calculation with stack top. Finally sum stack. Virtual code line by line.\n\nWe must follow format: \"Start // 程式開始執行\" etc. Use arrow notation. For decision use Decision: ... Yes → ... No → ... Need to include comments after each line.\n\nLet's craft.\n\nSteps: initialize stack empty, num = 0, last_op = '+', iterate i from 0 to len(s). For each char c: if digit accumulate num. If c in '+-*/' or last char, then handle previous operator: if last_op == '+': push num; if '-', push -num; if '*': pop stack top, push top * num; if '/': pop stack top, push int division of top / num trunc toward zero. Then set last_op = c, reset num=0. At end after loop also process last number. Then sum stack to result. Return result.\n\nAlso handle spaces: skip.\n\nOk produce virtual code. Use arrows, decisions maybe for operator check. We'll need a Decision for operator type. Use Yes/No with further steps.\n\nLet's write.\n\nNote: In virtual code, \"Start\", \"End\" markers. We'll produce step names: Step 1: Initialize stack, num, op. Step 2: For i in 0..len(s)-1: get char. Decision: Is char digit? etc. Also Decision: Is char operator or last index? etc. Let's produce.\n\nWe also need to handle integer division trunc toward zero: use int(top/num) if top>=0 else -int(abs(top)/abs(num)). But simpler: use int(top/num) in Python truncates toward zero. We'll note.\n\nLet's produce.\n\nAlso at end: Step: sum stack and assign result.\n\nMake sure to include comment for each line.\n\nLet's craft output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: stack ← [] , num ← 0 , last_op ← '+' // 初始化堆疊、目前數字及上一個運算子  \n→ Step 2: for i ← 0 to len(s)-1: char ← s[i] // 逐字遍歷輸入字串  \n  Decision: 是否為空白? // 檢查是否是空格  \n   Yes → Continue // 跳過空格  \n   No  → Decision: 是否為數字?  \n    Yes → num ← num * 10 + int(char) // 累積數字  \n    No  → Decision: char 是否為運算子 '+-*/' 或 i 為最後一個字元? // 判斷是否需要處理上一個運算子  \n     Yes → Decision: last_op 是 '+'?  \n      Yes → stack.append(num) // 加法：將數字入堆疊  \n      No → Decision: last_op 是 '-'?  \n       Yes → stack.append(-num) // 減法：將負數入堆疊  \n       No → Decision: last_op 是 '*'?  \n        Yes → temp ← stack.pop() ; stack.append(temp * num) // 乘法：立即計算並入堆疊  \n        No → Decision: last_op 是 '/'?  \n         Yes → temp ← stack.pop() ; // 整數除法，向 0 截斷  \n           division ← int(temp / num) ; stack.append(division)  \n           // Python 的 int() 會對負數向 0 截斷  \n           // 例如 int(-3/2) = -1  \n           // 所以可直接使用 int(temp/num)  \n           // 其餘情況不會出現  \n           No → // 若 last_op 不是這四個，直接跳過（理論上不會發生）  \n           Continue  \n           // 以上處理完成後  \n           last_op ← char ; num ← 0 // 更新運算子與重設數字  \n           Continue  \n           // 迴圈結束後，還需處理最後一個數字  \n           Decision: i 為 len(s)-1?  \n            Yes → Decision: last_op 是 '+'?  \n             Yes → stack.append(num)  \n             No → Decision: last_op 是 '-'?  \n              Yes → stack.append(-num)  \n              No → Decision: last_op 是 '*'?  \n               Yes → temp ← stack.pop() ; stack.append(temp * num)  \n               No → Decision: last_op 是 '/'?  \n                Yes → temp ← stack.pop() ; stack.append(int(temp / num))  \n                No → // 不可能發生  \n            No → // 不需要額外操作  \n→ Step 3: result ← sum(stack) // 將堆疊中所有數字相加得到最終結果  \n→ Step 4: return result // 回傳計算結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        \"\"\"計算給定字串中的算式，支持 + - * /，除法向 0 截斷。\"\"\"\n        stack = []\n        num = 0\n        sign = '+'\n        s += '+'  # 方便最後一次處理\n\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c in '+-*/':\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack.append(stack.pop() * num)\n                elif sign == '/':\n                    top = stack.pop()\n                    # 整數除法向 0 截斷\n                    stack.append(int(top / num))\n                sign = c\n                num = 0\n\n        return sum(stack)\n\ndef parse_input(raw: str) -> str:\n    \"\"\"從輸入文字中提取算式字串。\"\"\"\n    # 先嘗試找出等號右邊的內容\n    match = re.search(r'=\\s*(.+)', raw)\n    if match:\n        expr = match.group(1)\n    else:\n        expr = raw\n    # 移除可能的引號與空白\n    expr = expr.strip()\n    if expr.startswith('\"') and expr.endswith('\"'):\n        expr = expr[1:-1]\n    elif expr.startswith(\"'\") and expr.endswith(\"'\"):\n        expr = expr[1:-1]\n    return expr\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    expression = parse_input(raw_input)\n    sol = Solution()\n    result = sol.calculate(expression)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3+2*2\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \" 3/2 \"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \" 3+5 / 2 \"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode673.json",
    "problem_index_in_file": 0,
    "title": "Number of Longest Increasing Subsequence",
    "description_snippet": "Given an integer array nums, return the number of longest increasing subsequences.\n\nNotice that the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for the problem: Given an integer array nums, return the number of longest increasing subsequences. Need to output pseudo-code with lines, explanation. Must use Start, End, Decision, arrow, etc. The pseudo-code needs to represent algorithm to solve. We should use dynamic programming: dpLen[i] = length of LIS ending at i. dpCnt[i] = number of LIS ending at i. For each i, iterate j < i: if nums[j] < nums[i], then if dpLen[j]+1 > dpLen[i] update len and count; else if equal, add count. After all, find maxLen, sum counts where dpLen[i]==maxLen. Also handle duplicates etc.\n\nWe need to produce pseudo-code step by step, with each line including comment.\n\nLet's produce lines:\n\nStart\n→ Step 1: Read array nums // input array\n→ Step 2: n ← length(nums) // number of elements\n→ Decision: If n == 0? // check empty\n    Yes → Step 3: Return 0 // no subsequences\n    No  → Step 4: Initialize arrays dpLen[n] with 1 // each element itself is LIS of length 1\n    → Step 5: Initialize arrays dpCnt[n] with 1 // one subsequence for each element\n→ Step 6: For i from 0 to n-1: // iterate each element\n    → Step 7: For j from 0 to i-1: // compare with previous elements\n        → Decision: If nums[j] < nums[i]? // strictly increasing\n            Yes → Decision: If dpLen[j] + 1 > dpLen[i]? // longer subsequence found\n                Yes → Step 8: dpLen[i] ← dpLen[j] + 1 // update length\n                → Step 9: dpCnt[i] ← dpCnt[j] // set count to count of j\n                No  → Decision: If dpLen[j] + 1 == dpLen[i]? // equal length\n                    Yes → Step 10: dpCnt[i] ← dpCnt[i] + dpCnt[j] // add counts\n                    No → // nothing\n            No → // nums[j] not smaller, skip\n→ Step 11: maxLen ← 0 // track maximum length\n→ Step 12: totalCount ← 0 // sum counts of LIS of max length\n→ Step 13: For i from 0 to n-1:\n    → Decision: If dpLen[i] > maxLen?\n        Yes → Step 14: maxLen ← dpLen[i]\n        → Step 15: totalCount ← dpCnt[i]\n        No  → Decision: If dpLen[i] == maxLen?\n            Yes → Step 16: totalCount ← totalCount + dpCnt[i]\n            No → // skip\n→ Step 17: Return totalCount // number of longest increasing subsequences\n\nWe must follow format: each line \"虛擬碼步驟 [space] // 解釋\". Use arrows and decisions. Also ensure indentation consistent. Use → for steps, Decision: etc. Include Start and End.\n\nNeed to ensure each line starts with \"Start\", \"→ Step X:\", \"Decision:\", \"Yes →\", \"No →\", etc.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Read array nums // 取得輸入陣列\n→ Step 2: n ← length(nums) // 取得陣列長度\n→ Decision: 如果 n == 0? // 檢查是否為空陣列\n    Yes → Step 3: Return 0 // 空陣列時沒有遞增子序列\n    No  → Step 4: 初始化 dpLen[0..n-1] 為 1 // 每個元素本身是一個長度 1 的遞增子序列\n    → Step 5: 初始化 dpCnt[0..n-1] 為 1 // 每個元素只有一種長度 1 的子序列\n→ Step 6: 對 i 從 0 到 n-1 做\n    → Step 7: 對 j 從 0 到 i-1 做\n        → Decision: 如果 nums[j] < nums[i]? // 必須嚴格遞增\n            Yes → Decision: 如果 dpLen[j] + 1 > dpLen[i]? // 找到更長的子序列\n                Yes → Step 8: dpLen[i] ← dpLen[j] + 1 // 更新長度\n                → Step 9: dpCnt[i] ← dpCnt[j] // 取 j 的計數\n                No  → Decision: 如果 dpLen[j] + 1 == dpLen[i]? // 相同長度\n                    Yes → Step 10: dpCnt[i] ← dpCnt[i] + dpCnt[j] // 累加計數\n                    No → // 無需改動\n            No → // nums[j] 不小於 nums[i]，不做處理\n→ Step 11: maxLen ← 0 // 追蹤最大的長度\n→ Step 12: totalCount ← 0 // 追蹤最大的長度子序列數量\n→ Step 13: 對 i 從 0 到 n-1 做\n    → Decision: 如果 dpLen[i] > maxLen?\n        Yes → Step 14: maxLen ← dpLen[i] // 更新最大長度\n        → Step 15: totalCount ← dpCnt[i] // 重新設定計數\n        No  → Decision: 如果 dpLen[i] == maxLen?\n            Yes → Step 16: totalCount ← totalCount + dpCnt[i] // 累加同長度的計數\n            No → // 跳過\n→ Step 17: Return totalCount // 回傳最長遞增子序列的數量\nEnd // 程式執行結束\n\nWe need to use arrows, but we can use \"→\" and \"Decision:\" lines. The arrow before each step. Indentation can use spaces.\n\nWe should also maintain proper formatting: each line with \"虛擬碼步驟\" then space then comment. So e.g., \"Start // 程式開始執行\" is okay. \"→ Step 1: Read array nums // 取得輸入陣列\". For decisions: \"→ Decision: 如果 n == 0? // 檢查是否為空陣列\". Then inside indentation: \"Yes → Step 3: Return 0 // 空陣列時沒有遞增子序列\". Indent the lines under Decision. Should maintain consistency.\n\nThus produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read array nums // 取得輸入陣列  \n→ Step 2: n ← length(nums) // 取得陣列長度  \n→ Decision: 如果 n == 0? // 檢查是否為空陣列  \n Yes → Step 3: Return 0 // 空陣列時沒有遞增子序列  \n No  → Step 4: 初始化 dpLen[0..n-1] 為 1 // 每個元素本身是一個長度 1 的遞增子序列  \n  → Step 5: 初始化 dpCnt[0..n-1] 為 1 // 每個元素只有一種長度 1 的子序列  \n→ Step 6: 對 i 從 0 到 n-1 做  \n → Step 7: 對 j 從 0 到 i-1 做  \n  → Decision: 如果 nums[j] < nums[i]? // 必須嚴格遞增  \n   Yes → Decision: 如果 dpLen[j] + 1 > dpLen[i]? // 找到更長的子序列  \n    Yes → Step 8: dpLen[i] ← dpLen[j] + 1 // 更新長度  \n     → Step 9: dpCnt[i] ← dpCnt[j] // 取 j 的計數  \n    No  → Decision: 如果 dpLen[j] + 1 == dpLen[i]? // 相同長度  \n     Yes → Step 10: dpCnt[i] ← dpCnt[i] + dpCnt[j] // 累加計數  \n     No → // 無需改動  \n   No → // nums[j] 不小於 nums[i]，不做處理  \n→ Step 11: maxLen ← 0 // 追蹤最大的長度  \n→ Step 12: totalCount ← 0 // 追蹤最大的長度子序列數量  \n→ Step 13: 對 i 從 0 到 n-1 做  \n  → Decision: 如果 dpLen[i] > maxLen?  \n   Yes → Step 14: maxLen ← dpLen[i] // 更新最大長度  \n    → Step 15: totalCount ← dpCnt[i] // 重新設定計數  \n   No  → Decision: 如果 dpLen[i] == maxLen?  \n    Yes → Step 16: totalCount ← totalCount + dpCnt[i] // 累加同長度的計數  \n    No → // 跳過  \n→ Step 17: Return totalCount // 回傳最長遞增子序列的數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findNumberOfLIS(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        lengths = [1] * n          # lengths[i] = length of LIS ending at i\n        counts = [1] * n           # counts[i] = number of LIS ending at i\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if lengths[j] + 1 > lengths[i]:\n                        lengths[i] = lengths[j] + 1\n                        counts[i] = counts[j]\n                    elif lengths[j] + 1 == lengths[i]:\n                        counts[i] += counts[j]\n\n        longest = max(lengths)\n        return sum(c for l, c in zip(lengths, counts) if l == longest)\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    result = Solution().findNumberOfLIS(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,4,7]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode686.json",
    "problem_index_in_file": 0,
    "title": "Repeated String Match",
    "description_snippet": "Given two strings a and b, return the minimum number of times you should repeat string a so that str...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code with each line and explanation. Use the arrow format. We need to produce steps to solve the problem: repeating string a until b is substring, minimum repeats, else -1. So we will design algorithm: Let len_a, len_b. The minimal repeats needed is ceil(len_b / len_a) because need at least enough length to cover b. But we might need one more repeat if b spans across end of repeated a, requiring 1 more. So algorithm: start with repeats = ceil(len_b / len_a). Build repeated string by repeating a repeats times. If b in repeated string: return repeats. Else build repeated string with repeats+1 times. If b in that: return repeats+1 else -1. Or simpler: Build repeated string with repeats+2 to cover worst case? Actually if b length > len_a, but b can start near the end of repeated a and need to go into next repeat. So maximum repeats needed is ceil(len_b / len_a)+1. So check both. Provide steps accordingly.\n\nWe need to generate pseudocode lines: Start, input a, b, compute lengths, compute repeats = ceil(len_b/len_a). Build repeated string. Decision: if b in repeated? Yes -> return repeats. No -> build repeated string with repeats+1, decision: if b in that? Yes -> return repeats+1 else return -1. End.\n\nUse arrow syntax. We need to mention string operations, substring check.\n\nLet's produce. Use \"→ Step X:\" lines. Use \"Decision:\" lines with Yes →, No →.\n\nWe need to provide each line with explanation comment. Use Chinese explanation. Provide minimal steps.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 讀取字串 a、b // 取得輸入的兩個字串\n→ Step 2: 計算 len_a ← 長度(a)，len_b ← 長度(b) // 取得兩字串長度\n→ Step 3: 計算最小重複數 repeats ← ceil(len_b / len_a) // 至少需要的重複次數\n→ Step 4: 建立重複字串 repeated ← a 重複 repeats 次 // 產生候選字串\n→ Decision: 是否包含子字串 b？ // 判斷 b 是否已是 repeated 的子字串\n    Yes → Step 5: 回傳 repeats // 找到最小重複數\n    No  → Step 6: 建立重複字串 repeated2 ← a 重複 (repeats+1) 次 // 再多一次以防跨界\n        → Decision: 是否包含子字串 b？ // 再次判斷\n            Yes → Step 7: 回傳 repeats+1 // 成功\n            No  → Step 8: 回傳 -1 // 無法成為子字串\nEnd // 程式結束\n\nBut we need to incorporate the arrow lines and the structure. Use \"→\" each step. Indent Decision branches accordingly.\n\nNeed to ensure each line is separate. Provide explanation after //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取字串 a、b // 取得輸入的兩個字串\n→ Step 2: 計算 len_a ← 長度(a)，len_b ← 長度(b) // 取得兩字串長度\n→ Step 3: 計算最小重複數 repeats ← ceil(len_b / len_a) // 至少需要的重複次數\n→ Step 4: 建立重複字串 repeated ← a 重複 repeats 次 // 產生候選字串\n→ Decision: 重複字串 repeated 是否包含子字串 b？ // 判斷 b 是否已是 repeated 的子字串\n    Yes → Step 5: 回傳 repeats // 找到最小重複數\n    No  → Step 6: 建立重複字串 repeated2 ← a 重複 (repeats+1) 次 // 再多一次以防跨界\n        → Decision: 重複字串 repeated2 是否包含子字串 b？ // 再次判斷\n            Yes → Step 7: 回傳 repeats+1 // 成功\n            No  → Step 8: 回傳 -1 // 無法成為子字串\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nfrom math import ceil\n\nclass Solution:\n    def repeatedStringMatch(self, a: str, b: str) -> int:\n        \"\"\"Return minimal repeats of a so that b is a substring, or -1.\"\"\"\n        # 最少重複次數: 讓長度至少不小於 b 的長度\n        repeat = (len(b) + len(a) - 1) // len(a)\n        s = a * repeat\n        if b in s:\n            return repeat\n        # 可能需要再多一次，以處理跨界情況\n        if b in s + a:\n            return repeat + 1\n        return -1\n\ndef parse_input(text: str):\n    \"\"\"從輸入文字中抽取兩個字串 a 與 b。\"\"\"\n    # 先嘗試尋找雙引號內的字串\n    matches = re.findall(r'\"([^\"]*)\"', text)\n    if len(matches) >= 2:\n        return matches[0], matches[1]\n    # 若找不到，嘗試按行或空白分割\n    lines = text.strip().splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n    parts = text.strip().split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # 最終退化: 直接回傳整段文字與空字串\n    return text.strip(), ''\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read()\n    a, b = parse_input(raw_input)\n    solution = Solution()\n    result = solution.repeatedStringMatch(a, b)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = \"abcd\", b = \"cdabcdab\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "a = \"a\", b = \"aa\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode152.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product Subarray",
    "description_snippet": "Given an integer array nums, find a subarray that has the largest product, and return the product.\n\n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for maximum product subarray algorithm. Standard solution: maintain max_ending_here, min_ending_here, global_max. Iterate through nums. For each element, if negative, swap max/min. Update max = max(num, max * num), min = min(num, min * num). global_max = max(global_max, max). At end return global_max.\n\nWe must produce step-by-step virtual code lines, with arrows. Include Start, End. Use Decision lines for negative check? We'll show decision if current num < 0? Then swap. Then compute new max/min. Then update global. Provide explanation each line.\n\nWe need \"逐行\" output. Each line: \"虛擬碼步驟 // 解釋\". Use arrow. Use decision. Provide Start, End.\n\nLet's produce. Use variable names: max_so_far, min_so_far, global_max.\n\nPseudo steps:\n\nStart\n→ Initialize max_so_far = nums[0] // first element as current max\n→ Initialize min_so_far = nums[0] // current min\n→ Initialize global_max = nums[0] // best so far\n→ For i from 1 to length-1: // iterate remaining elements\n    → Decision: if nums[i] < 0? // check sign\n        Yes → Swap max_so_far and min_so_far // negative flips\n        No  → (do nothing)\n    → Update max_so_far = max(nums[i], max_so_far * nums[i]) // new max\n    → Update min_so_far = min(nums[i], min_so_far * nums[i]) // new min\n    → Decision: if max_so_far > global_max?\n        Yes → global_max = max_so_far // update best\n        No  → (do nothing)\nEnd // return global_max\n\nWe should include comments for each step.\n\nLet's write with indentation for decision branches.\n\nWe might need to show arrows for decisions and sub-steps. Use indentation or prefix spaces.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: max_so_far = nums[0] // 以第一個數值作為目前最大乘積\n→ Step 2: min_so_far = nums[0] // 以第一個數值作為目前最小乘積\n→ Step 3: global_max = nums[0] // 目前全局最大乘積初始化為第一個數值\n→ Step 4: For i from 1 to nums.length - 1: // 遍歷陣列中其餘元素\n    → Decision: nums[i] < 0? // 檢查當前數字是否為負\n        Yes → Step 4.1: Swap max_so_far and min_so_far // 負數會將最大乘積轉為最小，反之亦然\n        No  → (do nothing) // 正數不需要交換\n    → Step 4.2: max_so_far = max(nums[i], max_so_far * nums[i]) // 更新目前子陣列的最大乘積\n    → Step 4.3: min_so_far = min(nums[i], min_so_far * nums[i]) // 更新目前子陣列的最小乘積\n    → Decision: max_so_far > global_max? // 判斷是否需要更新全局最大\n        Yes → Step 4.4: global_max = max_so_far // 更新全局最大乘積\n        No  → (do nothing) // 仍保持舊值\nEnd // 程式執行結束，返回 global_max 為答案",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProduct(self, nums):\n        if not nums:\n            return 0\n\n        max_prod = min_prod = result = nums[0]\n\n        for num in nums[1:]:\n            if num < 0:\n                max_prod, min_prod = min_prod, max_prod\n\n            max_prod = max(num, max_prod * num)\n            min_prod = min(num, min_prod * num)\n\n            result = max(result, max_prod)\n\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取整數列表。\n    只搜尋第一個形如 [ ... ] 的片段並以 eval 解析。\n    \"\"\"\n    match = re.search(r'\\[.*?\\]', data, re.S)\n    if match:\n        return eval(match.group(0))\n    return []\n\ndef main():\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    sol = Solution()\n    print(sol.maxProduct(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,-2,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [-2,0,-1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode494.json",
    "problem_index_in_file": 0,
    "title": "Target Sum",
    "description_snippet": "You are given an integer array nums and an integer target.\n\nYou want to build an expression out of n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: target sum by assigning + or - to each element of array nums, count number of expressions evaluating to target. Standard DP or backtracking. We'll produce a high-level algorithm: use recursion with memoization (DP) or DP with offset. Virtual code lines with explanation.\n\nWe must output step-by-step virtual code lines: Start, steps, decisions, etc. We'll show algorithm: use DFS recursion. We'll illustrate base case when index reaches length. Use memoization map of (index, current_sum). Use DP table maybe.\n\nLet's design:\n\nStart\n→ Step 1: Initialize memo map // store computed results\n→ Step 2: Call DFS(index=0, current_sum=0)\n→ Step 3: DFS function: if index == len(nums) → return 1 if current_sum==target else 0\n→ Decision: if memo contains (index, current_sum) → return memo\n→ Step 4: Compute res = DFS(index+1, current_sum + nums[index]) + DFS(index+1, current_sum - nums[index])\n→ Memoize result\n→ Return res\nEnd\n\nBut we need step-by-step within virtual code. Provide arrow for decisions.\n\nAlso can include DP table approach: offset array size 2*sum+1.\n\nBut we will stick to recursion with memoization.\n\nEnsure each line includes virtual code + comment. Use \"→\" to indicate next step. Indent decisions accordingly.\n\nOk. We'll produce.\n\nLet's craft output:\n\nStart // 程式開始執行\n→ Step 1: Define memo = {} // 用於儲存已計算的子問題結果\n→ Step 2: Define function DFS(idx, curr) // idx: 當前數字索引, curr: 目前累計總和\n    → Decision: idx == len(nums) ? // 檢查是否已處理完所有數字\n        Yes → Return 1 if curr == target else 0 // 完成遞歸，判斷是否達到目標\n        No  → Decision: memo contains (idx, curr) ?\n            Yes → Return memo[(idx, curr)] // 直接使用已計算結果\n            No  →\n                → Step 3: pos = DFS(idx+1, curr + nums[idx]) // 加上正號\n                → Step 4: neg = DFS(idx+1, curr - nums[idx]) // 加上負號\n                → Step 5: memo[(idx, curr)] = pos + neg // 记录结果\n                → Step 6: Return memo[(idx, curr)] // 返回累计计数\n→ Step 7: result = DFS(0, 0) // 从第一个数开始，初始和为 0\n→ End // 程式執行結束\n\nWe must keep arrow indentation. Also need to include '→' at start of each line. Ensure each line has explanation after //.\n\nCheck each line.\n\nWe also might include variable names: nums array, target integer.\n\nOk. Provide final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: memo = {} // 用於儲存已計算的子問題結果  \n→ Step 2: 定義函式 DFS(idx, curr) // idx：目前處理到的索引, curr：目前累計總和  \n    → Decision: idx == len(nums) ? // 檢查是否已處理完所有數字  \n        Yes → Return 1 if curr == target else 0 // 完成遞歸，判斷是否達到目標  \n        No  → Decision: memo contains (idx, curr) ?  \n            Yes → Return memo[(idx, curr)] // 直接使用已計算結果  \n            No  →  \n                → Step 3: pos = DFS(idx + 1, curr + nums[idx]) // 加上正號  \n                → Step 4: neg = DFS(idx + 1, curr - nums[idx]) // 加上負號  \n                → Step 5: memo[(idx, curr)] = pos + neg // 記錄此子問題的答案  \n                → Step 6: Return memo[(idx, curr)] // 回傳累計計數  \n→ Step 7: result = DFS(0, 0) // 從第一個數字開始，初始總和為 0  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\ndef find_target_sum_ways(nums, target):\n    dp = defaultdict(int)\n    dp[0] = 1\n    for num in nums:\n        next_dp = defaultdict(int)\n        for s in dp:\n            next_dp[s + num] += dp[s]\n            next_dp[s - num] += dp[s]\n        dp = next_dp\n    return dp[target]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    nums = eval(nums_match.group(1)) if nums_match else []\n    target = int(target_match.group(1)) if target_match else 0\n    result = find_target_sum_ways(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,1,1], target = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1], target = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode447.json",
    "problem_index_in_file": 0,
    "title": "Number of Boomerangs",
    "description_snippet": "You are given n points in the plane that are all distinct, where points[i] = [x_i, y_i]. A boomerang...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for counting boomerangs. We need step by step with explanation comments. Use arrows. Format as described. Use Start, End, Decision. Should iterate over points, compute distances, count frequencies. For each point i, compute distances to others, count freq. For each distance, number of boomerangs contributed is freq * (freq - 1). Sum over all i. Provide pseudocode lines. Let's produce something like:\n\nStart\n→ Step 1: let n = number of points\n→ Step 2: let result = 0\n→ For i from 0 to n-1:\n   → Step 3: create empty map distanceCount\n   → For j from 0 to n-1:\n      → If i == j: continue\n      → Step 4: compute dx = x_j - x_i, dy = y_j - y_i\n      → Step 5: distSq = dx*dx + dy*dy\n      → Step 6: increment distanceCount[distSq]\n   → Step 7: for each count in distanceCount values:\n      → Step 8: result += count * (count - 1)\n→ End\n\nAdd decision if needed? But they require Decision: structure. Might not need decision inside loops except for skip i==j. But we can add Decision. Use Decision: If i == j? etc. Provide explanation.\n\nLet's write step lines each with arrow.\n\nUse \"→\" for normal step. Use \"Decision:\" for if. Use \"Yes →\" \"No →\".\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: let n = points.length // 取得點的總數  \n→ Step 2: let result = 0 // 初始化計算結果  \n\n→ Decision: 迴圈 i 從 0 到 n-1? // 遍歷每個點作為中心  \n    Yes → For i = 0 to n-1  \n        → Step 3: let distanceCount = {} // 建立距離對應的計數映射  \n        \n        → For j = 0 to n-1  \n            → Decision: 如果 i == j? // 跳過自身  \n                Yes → continue // 跳過本次迴圈  \n                No →  \n                    → Step 4: let dx = points[j][0] - points[i][0] // 計算 x 差  \n                    → Step 5: let dy = points[j][1] - points[i][1] // 計算 y 差  \n                    → Step 6: let distSq = dx*dx + dy*dy // 用平方距離作為鍵  \n                    → Step 7: if distSq in distanceCount  \n                        → Yes → distanceCount[distSq] += 1 // 同距離再加一次  \n                        → No  → distanceCount[distSq] = 1 // 首次出現設為 1  \n        → Step 8: for each count in distanceCount.values()  \n            → Step 9: result += count * (count - 1) // 每個距離的組合數  \n\nEnd // 程式執行結束，返回結果 result",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def numberOfBoomerangs(self, points):\n        total = 0\n        for x1, y1 in points:\n            dist_count = defaultdict(int)\n            for x2, y2 in points:\n                if x1 != x2 or y1 != y2:\n                    d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n                    dist_count[d] += 1\n            for count in dist_count.values():\n                total += count * (count - 1)\n        return total\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    # Remove optional prefix \"points =\" if present\n    if raw_input.lower().startswith(\"points\"):\n        _, raw_input = raw_input.split(\"=\", 1)\n        raw_input = raw_input.strip()\n    # Safely parse the list of points\n    points = ast.literal_eval(raw_input)\n    # Compute and print the number of boomerangs\n    result = Solution().numberOfBoomerangs(points)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[0,0],[1,0],[2,0]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,1],[2,2],[3,3]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "points = [[1,1]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode384.json",
    "problem_index_in_file": 0,
    "title": "Shuffle an Array",
    "description_snippet": "Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for solution class with methods: constructor, reset, shuffle. Provide step-by-step pseudo-code lines, with explanations. Use Start, End, Decision arrows. We should include initialization storing original array, and a copy for shuffling. shuffle: Fisher-Yates shuffle. Need random number generator. Provide steps accordingly. Let's produce output lines.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 宣告 Solution 類別\n→ Step 2: 在 Solution 中宣告兩個屬性：original: 整數陣列 // 儲存原始陣列\n    → Step 3: current: 整數陣列 // 儲存目前陣列（可被洗牌）\n→ Decision: 若使用者呼叫建構子？ // 判斷是否有傳入陣列\n    Yes → Step 4: Solution(nums: 整數陣列) // 建構子接收整數陣列\n        → Step 5: original ← 複製 nums // 複製陣列以保留原始順序\n        → Step 6: current ← 複製 nums // 初始 current 與 original 相同\n        → End // 建構子完成\n→ Step 7: 定義方法 reset() // 重設陣列\n    → Step 8: current ← 複製 original // 把 current 重新設為原始順序\n    → Step 9: return current // 回傳重設後的陣列\n→ Step 10: 定義方法 shuffle() // 隨機洗牌\n    → Step 11: size ← current 的長度 // 取得陣列長度\n    → Decision: 若 size ≤ 1？ // 如果陣列長度小於等於1\n        Yes → Step 12: return current // 直接回傳，無需洗牌\n        No  → Step 13: for i from size-1 downto 1 // Fisher-Yates 循環\n                → Step 14: j ← 隨機整數 0 到 i inclusive // 隨機選取索引\n                → Step 15: swap current[i] 與 current[j] // 交換兩個位置\n        → End // 洗牌完成\n    → Step 16: return current // 回傳洗牌後的陣列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列的拷貝，方便 reset\n        self.original = list(nums)\n        # current 用於 shuffle，初始時與 original 相同\n        self.current = list(nums)\n\n    def reset(self):\n        # 把 current 重新設為原始順序\n        self.current = list(self.original)\n        return self.current\n\n    def shuffle(self):\n        n = len(self.current)\n        # Fisher‑Yates 洗牌\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            self.current[i], self.current[j] = self.current[j], self.current[i]\n        return self.current\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把輸入字串包成 tuple 以符合 literal_eval 的語法\n    try:\n        methods, args = ast.literal_eval(f\"({data})\")\n    except Exception as e:\n        raise ValueError(\"Invalid input format\") from e\n\n    outputs = []\n    obj = None\n    for meth, arg in zip(methods, args):\n        if meth == \"Solution\":\n            obj = Solution(arg[0])\n            outputs.append(None)\n        elif meth == \"reset\":\n            outputs.append(obj.reset())\n        elif meth == \"shuffle\":\n            outputs.append(obj.shuffle())\n        else:\n            raise ValueError(f\"Unknown method: {meth}\")\n\n    # 使用 json.dumps 以得到 null 代替 None\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,3,2],[2,3,1],[2,3,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 3, 2], [2, 3, 1], [2, 3, 1]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode405.json",
    "problem_index_in_file": 0,
    "title": "Convert a Number to Hexadecimal",
    "description_snippet": "Given a 32-bit integer num, return a string representing its hexadecimal representation. For negativ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem: convert a 32-bit integer num to its hex string. Use two's complement for negative numbers. Lowercase letters. No leading zeros except for zero. No built-in methods. Provide virtual code line by line with comments. Use Start, Decision, etc.\n\nWe need to show steps: handle num==0, else loop dividing by 16, map remainder to hex digit. For negative numbers, use two's complement: i.e., treat as unsigned 32-bit value. In two's complement representation, negative num modulo 2^32 yields its positive equivalent. We can handle by using bitwise mask 0xFFFFFFFF or by adding 2^32 to negative number? But we can't use built-in functions for bitwise? But we can use bitwise AND. It's allowed. So for negative numbers, compute unsigned = num & 0xFFFFFFFF. Then loop until unsigned > 0.\n\nWe need to avoid leading zeros: loop while value > 0, append digits to stack, then reverse.\n\nSteps:\n\nStart // start\n\n→ Decision: If num == 0? // handle zero case\n\n    Yes → Step: Return '0' // zero string\n\n    No → Step: If num < 0? // negative\n\n        Yes → Step: unsigned = num & 0xFFFFFFFF // get 32-bit two's complement\n\n        No → Step: unsigned = num // positive\n\n→ Step: Initialize empty list digits // to store hex chars\n\n→ Step: While unsigned > 0 // main loop\n\n    → Step: remainder = unsigned % 16 // get least significant hex digit\n\n    → Step: digit = map remainder to hex char // 0-9 a-f\n\n    → Step: Append digit to digits // push\n\n    → Step: unsigned = unsigned // 16 // shift right\n\n→ Step: Reverse digits // to correct order\n\n→ Step: result = join digits // convert list to string\n\n→ Step: Return result\n\nEnd\n\nNeed to express with virtual code lines.\n\nLet's craft each line. Use arrow '→' before steps. Use Decision for conditions.\n\nLet's write:\n\nStart // 程式開始\n\n→ Decision: 如果 num == 0? // 檢查是否為 0\n\n    Yes → Step: 回傳 '0' // 直接回傳字串\n\n    No → Decision: 如果 num < 0? // 檢查是否為負數\n\n        Yes → Step: unsigned = num & 0xFFFFFFFF // 取 32 位兩補數表示\n\n        No → Step: unsigned = num // 正數直接使用\n\n→ Step: digits = 空列表 // 用於儲存十六進位字元\n\n→ Step: While unsigned > 0 // 只要剩餘數值不為 0\n\n    → Step: remainder = unsigned % 16 // 取最低位的 4 bit\n\n    → Step: digit = 對應字元(remainder) // 0-9 或 a-f\n\n    → Step: digits.append(digit) // 放進列表\n\n    → Step: unsigned = unsigned // 16 // 去除已處理位\n\n→ Step: digits.reverse() // 反轉順序\n\n→ Step: result = join(digits) // 連接成字串\n\n→ Step: 回傳 result // 回傳十六進位字串\n\nEnd // 程式結束\n\nWe need to keep format: each line: 虛擬碼步驟 + space + // 解釋/說明\n\nSo each line must have code then comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n\n→ Decision: 如果 num == 0? // 檢查是否為 0\n\n    Yes → Step: 回傳 '0' // 直接回傳字串\n\n    No → Decision: 如果 num < 0? // 檢查是否為負數\n\n        Yes → Step: unsigned = num & 0xFFFFFFFF // 取 32 位兩補數表示\n\n        No → Step: unsigned = num // 正數直接使用\n\n→ Step: digits = 空列表 // 用於儲存十六進位字元\n\n→ Step: While unsigned > 0 // 只要剩餘數值不為 0\n\n    → Step: remainder = unsigned % 16 // 取最低位的 4 bit\n\n    → Step: digit = 對應字元(remainder) // 0-9 或 a-f\n\n    → Step: digits.append(digit) // 放進列表\n\n    → Step: unsigned = unsigned // 16 // 去除已處理位\n\n→ Step: digits.reverse() // 反轉順序\n\n→ Step: result = join(digits) // 連接成字串\n\n→ Step: 回傳 result // 回傳十六進位字串\n\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def toHex(self, num: int) -> str:\n        # 零的特例\n        if num == 0:\n            return \"0\"\n        # 負數時取 32 位兩補數表示\n        if num < 0:\n            num = num & 0xFFFFFFFF\n        # 十六進位字符表\n        hex_map = \"0123456789abcdef\"\n        digits = []\n        # 逐 4 位進行轉換\n        while num > 0:\n            remainder = num & 0xF          # 取最低 4 位\n            digits.append(hex_map[remainder])\n            num >>= 4                      # 去除已處理的 4 位\n        # 逆序得到最終字串\n        digits.reverse()\n        return \"\".join(digits)\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    # 從輸入中擷取第一個整數（包含負號）\n    match = re.search(r'-?\\d+', data)\n    if match:\n        num = int(match.group())\n    else:\n        # 若沒有找到數字，視作 0\n        num = 0\n    # 呼叫轉換函式並輸出結果\n    solution = Solution()\n    result = solution.toHex(num)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 26",
          "expected_output": "1a",
          "success": true,
          "output": "1a"
        },
        {
          "example_index": 1,
          "input": "num = -1",
          "expected_output": "ffffffff",
          "success": true,
          "output": "ffffffff"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode722.json",
    "problem_index_in_file": 0,
    "title": "Remove Comments",
    "description_snippet": "Given a C++ program, remove comments from it. The program source is an array of strings source where...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line, following syntax: \"虛擬碼步驟 // 解釋\". Use arrows. The algorithm: iterate over lines, maintain state whether inside block comment. For each line, process char by char building output string. If inside block comment, search for \"*/\". If found, exit block state and continue after it. If not found, skip entire line. If not inside block comment, look for \"//\" or \"/*\". When encountering \"//\", break line. When encountering \"/*\", set block state, skip comment, but if end on same line, may resume. Build result lines if non-empty after trimming? Actually must keep content as is (except removed comments). Should we trim whitespace? If line becomes empty after removing comments, not output. But we keep original whitespace preceding? Not required? Usually they keep code lines exactly as input but comments removed. So after processing, if resulting string length>0, add to result.\n\nEdge cases: overlapping: when see \"/*\", but then inside that comment see \"/*\" again? Since inside block, ignore any nested comment markers. So only exit when find \"*/\" not overlapping.\n\nImplement pseudocode: Start. Initialize output list. block = False. For each line in source: i=0, cur=\"\" While i< len(line): if block: check if line[i:i+2]==\"*/\": block=False; i+=2; continue. else: block=False; i+=2; continue. else: # not inside block: check for \"/*\": if line[i:i+2]==\"/*\": block=True; i+=2; continue. if line[i:i+2]==\"//\": break. else: cur+=line[i]; i+=1. After loop, if not block and cur length>0: append cur to output.\n\nAfter all lines processed, return output.\n\nNow produce virtual code steps accordingly. Provide explanation for each step. Use arrows. Provide Start, End. For decisions, include Yes→ and No→. Must be line by line.\n\nLet's craft virtual code:\n\nStart // 程式開始\n→ Step 1: 初始化 resultList ← 空列表 // 用於儲存處理後的程式碼行\n→ Step 2: 初始化 inBlockComment ← False // 判斷是否處於區塊註解中\n→ Step 3: 對於每一行 line in source 逐行遍歷 // 逐行處理原始程式碼\n    → Step 4: 設定 i ← 0 // 字元索引\n    → Step 5: 設定 currentLine ← \"\" // 用於儲存該行去除註解後的內容\n    → Step 6: Decision: 若 inBlockComment 為 True? // 判斷目前是否在區塊註解內\n        Yes → Step 7: Decision: 是否在 line 內找到 \"*/\" 從索引 i 開始? // 搜尋結束符號\n            Yes → Step 8: 設定 inBlockComment ← False // 結束區塊註解\n            Yes → Step 9: i ← i + 2 // 跳過 \"*/\"\n            Yes → Step 10: 轉到 Step 6 // 重新檢查是否還在區塊註解\n            No  → Step 11: 轉到 EndOfLine // 本行已全部被區塊註解覆蓋\n        No  → Step 12: Decision: line[i:i+2] 是否為 \"/*\"? // 判斷是否開始新區塊註解\n            Yes → Step 13: 設定 inBlockComment ← True // 開始區塊註解\n            Yes → Step 14: i ← i + 2 // 跳過 \"/*\"\n            Yes → Step 15: 轉到 Step 6 // 重新檢查狀態\n            No  → Step 16: Decision: line[i:i+2] 是否為 \"//\"? // 判斷是否為行註解\n                Yes → Step 17: 轉到 EndOfLine // 跳出本行\n                No  → Step 18: currentLine ← currentLine + line[i] // 將字元加入結果\n                No  → Step 19: i ← i + 1 // 前進一個字元\n    → Step 20: EndOfLine // 目前行處理完成\n    → Decision: inBlockComment 為 False 且 currentLine 非空? // 判斷是否將結果加入列表\n        Yes → Step 21: resultList.append(currentLine) // 添加處理後的行\n        No  → Step 22: 不操作 // 空行不加入\n→ Step 23: End // 程式結束\n→ Step 24: 回傳 resultList // 返回處理完成的程式碼\n\nBut need to use the specified format. Ensure each line has arrow. For decisions, indent with tab? Example format shows indentation. We'll use spaces.\n\nUse \"→ Decision:\" lines with Yes → and No →. We need to align.\n\nAlso \"Step\" lines can be numbered. Use \"→ Step X:\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 resultList ← 空列表 // 用於儲存去除註解後的程式碼行  \n→ Step 2: 初始化 inBlockComment ← False // 判斷是否處於區塊註解中  \n\n→ Step 3: 對於每一行 line in source 逐行遍歷 // 逐行處理原始程式碼  \n  → Step 4: 設定 i ← 0 // 字元索引起點  \n  → Step 5: 設定 currentLine ← \"\" // 用於累積本行有效內容  \n\n  → Decision: 是否在區塊註解內? inBlockComment?  \n   Yes → Step 6: Decision: line[i:i+2] 是否為 \"*/\"?  \n    Yes → Step 7: 設定 inBlockComment ← False // 結束區塊註解  \n    Yes → Step 8: i ← i + 2 // 跳過 \"*/\"  \n    Yes → Step 9: 轉到 Step 6 // 重新判斷是否仍在區塊註解  \n   No  → Step 10: Decision: line[i:i+2] 是否為 \"/*\"?  \n    Yes → Step 11: 設定 inBlockComment ← True // 開始新的區塊註解  \n    Yes → Step 12: i ← i + 2 // 跳過 \"/*\"  \n    Yes → Step 13: 轉到 Step 6 // 重新判斷狀態  \n    No  → Step 14: Decision: line[i:i+2] 是否為 \"//\"?  \n     Yes → Step 15: 轉到 EndOfLine // 行註解結束本行處理  \n     No  → Step 16: currentLine ← currentLine + line[i] // 加入字元  \n     No  → Step 17: i ← i + 1 // 前進一個字元  \n\n  → EndOfLine // 本行處理結束  \n\n  → Decision: inBlockComment 為 False 且 currentLine 非空?  \n   Yes → Step 18: resultList.append(currentLine) // 將有效行加入結果  \n   No  → Step 19: 無操作 // 空行不加入  \n\nEnd // 程式執行結束  \n→ Step 20: 回傳 resultList // 返回移除註解後的程式碼列表",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeComments(self, source):\n        res = []\n        in_block = False\n        new_line = []\n\n        for line in source:\n            i = 0\n            if not in_block:\n                new_line = []\n            while i < len(line):\n                if not in_block and i + 1 < len(line) and line[i] == '/' and line[i + 1] == '*':\n                    in_block = True\n                    i += 2\n                elif in_block and i + 1 < len(line) and line[i] == '*' and line[i + 1] == '/':\n                    in_block = False\n                    i += 2\n                elif not in_block and i + 1 < len(line) and line[i] == '/' and line[i + 1] == '/':\n                    break\n                elif not in_block:\n                    new_line.append(line[i])\n                    i += 1\n                else:\n                    i += 1\n            if new_line and not in_block:\n                res.append(''.join(new_line))\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data.startswith(\"source\"):\n        _, expr = data.split(\"=\", 1)\n        source = ast.literal_eval(expr.strip())\n    else:\n        source = ast.literal_eval(data)\n    result = Solution().removeComments(source)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "source = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]",
          "expected_output": "[\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]",
          "success": true,
          "output": "['int main()', '{ ', '  ', 'int a, b, c;', 'a = b + c;', '}']"
        },
        {
          "example_index": 1,
          "input": "source = [\"a/*comment\", \"line\", \"more_comment*/b\"]",
          "expected_output": "[\"ab\"]",
          "success": true,
          "output": "['ab']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode292.json",
    "problem_index_in_file": 0,
    "title": "Nim Game",
    "description_snippet": "You are playing the following Nim Game with your friend:\n\nInitially, there is a heap of stones on th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for Nim game. Must follow format. Each line: virtual step then // explanation. Use arrows and Decision etc. Need to produce step-by-step pseudocode that decides win. Since we need to return true if we can win. Nim with 1-3 removal: winning positions are those where n % 4 != 0. So algorithm: if n % 4 == 0 => lose else win. We need to produce virtual code. Use Start, End, Decision.\n\nLet's produce:\n\nStart\n→ Step 1: Input n //取得石子數\n→ Decision: If n % 4 == 0? //檢查能否直接失敗\n    Yes → Step 2: Return false // 你無法贏\n    No  → Step 3: Return true // 你能贏\nEnd\n\nBut need explanation comments. Provide short. Also we might need to compute modulo. Could add step to compute remainder.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Read n // 取得石子總數\n→ Step 2: Compute r = n mod 4 // 取餘數決定勝負\n→ Decision: If r == 0? // 檢查餘數是否為 0\n    Yes → Step 3: Return false // 無法獲勝\n    No  → Step 4: Return true // 有勝算\nEnd // 程式結束\n\nAdd arrow for steps. Use arrow syntax: → Step etc. Ensure each line has comment after //.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read n // 取得石子總數  \n→ Step 2: Compute r = n mod 4 // 取餘數決定勝負  \n→ Decision: If r == 0? // 檢查餘數是否為 0  \n    Yes → Step 3: Return false // 無法獲勝  \n    No  → Step 4: Return true // 有勝算  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef can_win_nim(n: int) -> bool:\n    # 先手若石子數是 4 的倍數就必輸，否則必勝\n    return n % 4 != 0\n\ndef main():\n    data = sys.stdin.read()\n    # 從輸入文字中抓取第一個數字\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = can_win_nim(n)\n    # 按題目要求輸出小寫字串\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 2",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode263.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number",
    "description_snippet": "An ugly number is a positive integer which does not have a prime factor other than 2, 3, and 5.\n\nGiv...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code line by line with comments. Use Start, End, Decision. Provide step by step: Input n, handle <=0 -> false. Then while n%2==0 divide, same for 3,5. After loop, if n==1 return true else false.\n\nLet's produce virtual code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入 n // 取得待檢測的整數  \n→ Decision: 如果 n ≤ 0? // Ugly 數必須為正整數  \n  Yes → Step 2: 回傳 False // 非正數直接非 Ugly  \n  No  → Step 3: 進行除法循環 // 開始判斷 2,3,5 的因子  \n→ Step 4: While n mod 2 == 0, n = n / 2 // 先消除所有 2 的因子  \n→ Step 5: While n mod 3 == 0, n = n / 3 // 再消除所有 3 的因子  \n→ Step 6: While n mod 5 == 0, n = n / 5 // 最後消除所有 5 的因子  \n→ Decision: 如果 n == 1? // 只剩下 1 表示全部因子都是 2,3,5  \n  Yes → Step 7: 回傳 True // n 為 Ugly 數  \n  No  → Step 8: 回傳 False // 還有其他質因子，非 Ugly  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef is_ugly(n: int) -> bool:\n    \"\"\"\n    判斷 n 是否為 Ugly 數。\n    Ugly 數只允許質因子 2、3、5。\n    \"\"\"\n    if n <= 0:\n        return False\n    for p in (2, 3, 5):\n        while n % p == 0:\n            n //= p\n    return n == 1\n\ndef main() -> None:\n    # 讀取整個標準輸入，並尋找第一個整數\n    data = sys.stdin.read()\n    match = re.search(r'[-+]?\\d+', data)\n    if not match:\n        # 若無數字輸入，直接輸出 false\n        print('false')\n        return\n    n = int(match.group())\n    print('true' if is_ugly(n) else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode78.json",
    "problem_index_in_file": 0,
    "title": "Subsets",
    "description_snippet": "Given an integer array nums of unique elements, return all possible subsets (the power set).\n\nThe so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code for algorithm: generate all subsets of a set of unique integers, return all subsets, no duplicates. We need to provide line by line virtual code with explanation. Format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc. Should produce pseudo code but not actual code. Use arrows and decisions. Should cover input, recursion or iterative approach. Provide step-by-step. Each line should be a step. So we produce pseudo steps: Start, sort array? Not needed. But we can produce approach: use backtracking. Steps: function to generate subsets. Or iterative: start with empty set and for each element, add to existing subsets. Provide decisions for recursion base case, etc.\n\nWe need to produce code only, no commentary. Each line as \"Start // ...\". Each line must include \"→\" for arrows? In format, we can start with \"Start // ...\". Then \"→ Step 1: ...\". For decision use \"Decision:\" lines. Let's produce about 12-15 lines.\n\nWe must ensure each line includes step text + \" // explanation\".\n\nWe will produce:\n\nStart // 程式開始執行\n→ Step 1: 定義輸入陣列 nums // 取得使用者提供的唯一整數陣列\n→ Step 2: 初始化結果 list subsets = [[]] // 以空集合開始，為後續擴充做準備\n→ Step 3: 遍歷 nums 中每個元素 num // 逐一處理每個數字\n→ Decision: 目前 subsets 是否為空? // 確認是否還有已生成的子集\n    Yes → Step 4: subsets = [] // 若為空，重置為空列表（理論上不會發生）\n    No  → Step 5: 針對每個已存在子集 new_subset = subset + [num] // 將 num 加入到現有子集\n        → Step 6: 將 new_subset 加入 subsets // 將新子集加入結果集合\n→ Step 7: 回傳 subsets // 最終回傳所有子集\nEnd // 程式執行結束\n\nBut we need to produce for each step line: the code plus explanation. Also for loops, decisions.\n\nBetter to use \"Decision:\" and then indent.\n\nWe should produce something like:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入陣列 nums // 從使用者取得唯一整數列表\n→ Step 2: 建立結果 subsets = [[]] // 初始化子集列表，先加入空集合\n→ Step 3: For each element num in nums // 遍歷所有元素\n    → Decision: 是否需要將 num 加入所有已存在子集? // 確認是否有子集可擴充\n        Yes → Step 4: 針對 subsets 中的每個子集 subset\n            → Step 5: new_subset = subset + [num] // 新增元素後產生新子集\n            → Step 6: 將 new_subset 加入 subsets // 把新子集加入結果集合\n        No  → Step 7: （此情況不會發生，因為 subsets 至少包含空集合）\n→ Step 8: 回傳 subsets // 完成所有子集的生成\nEnd // 程式結束\n\nBut \"Decision\" inside for loop may be mis-specified. We can skip decision if not necessary. The requirement: Use Decision: and arrow. But we can use a decision: \"Decision: 是否需要處理新元素?\" But it's always yes. We can simply not use decision.\n\nBut guidelines require use of Decision, arrows. We can incorporate a simple decision: check if num is not null.\n\nLet's produce more steps:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入陣列 nums // 取得使用者提供的唯一整數陣列\n→ Step 2: 建立結果 subsets = [[]] // 初始化子集列表，先加入空集合\n→ Step 3: 逐一處理 nums 中的每個元素 num // 用迴圈遍歷\n    → Decision: 是否已經處理完所有元素? // 判斷是否完成遍歷\n        Yes → Step 4: 跳出迴圈 // 迴圈結束\n        No  → Step 5: 針對目前 subsets 中的每個子集 subset\n            → Step 6: new_subset = subset + [num] // 將 num 加入子集\n            → Step 7: 將 new_subset 加入 subsets // 把新子集存入結果\n→ Step 8: 回傳 subsets // 回傳所有子集\nEnd // 程式結束\n\nBut \"Decision: 是否已經處理完所有元素?\" is not typical; we could skip. But guidelines: Use Decision for if else. We can incorporate decision at start: If nums 為空則只返回 [[]]. Let's include.\n\nLet's craft final code:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入陣列 nums // 取得使用者提供的唯一整數陣列\n→ Decision: nums 是否為空? // 檢查輸入是否為空\n    Yes → Step 2: 回傳 [[]] // 空集合本身即為唯一子集\n    No  → Step 3: 建立結果 subsets = [[]] // 初始化子集列表，先加入空集合\n→ Step 4: 逐一處理 nums 中的每個元素 num // 用迴圈遍歷\n    → Decision: 是否有子集可以擴充? // 判斷 subsets 是否為空（理論上不會）\n        Yes → Step 5: 針對 subsets 中的每個子集 subset\n            → Step 6: new_subset = subset + [num] // 新子集是現有子集加上 num\n            → Step 7: 將 new_subset 加入 subsets // 把新子集加入結果\n        No  → Step 8: （此情況不會發生，因為 subsets 至少包含空集合）\n→ Step 9: 回傳 subsets // 完成所有子集的生成\nEnd // 程式結束\n\nBut the decision inside loop may be unnecessary but okay. Provide as required.\n\nLet's finalize.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 nums // 取得使用者提供的唯一整數陣列  \n→ Decision: nums 是否為空? // 檢查輸入是否為空  \n    Yes → Step 2: 回傳 [[]] // 空集合本身即為唯一子集  \n    No  → Step 3: 建立結果 subsets = [[]] // 初始化子集列表，先加入空集合  \n→ Step 4: 逐一處理 nums 中的每個元素 num // 用迴圈遍歷  \n    → Decision: 是否有子集可以擴充? // 判斷 subsets 是否為空（理論上不會）  \n        Yes → Step 5: 針對 subsets 中的每個子集 subset  \n            → Step 6: new_subset = subset + [num] // 新子集是現有子集加上 num  \n            → Step 7: 將 new_subset 加入 subsets // 把新子集加入結果  \n        No  → Step 8: （此情況不會發生，因為 subsets 至少包含空集合）  \n→ Step 9: 回傳 subsets // 完成所有子集的生成  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            res.append(path[:])                # 加入目前的子集\n            for i in range(start, len(nums)):\n                path.append(nums[i])           # 將 nums[i] 加入子集\n                backtrack(i + 1, path)         # 以新的子集繼續遞迴\n                path.pop()                     # 回溯，移除最後一個元素\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從輸入字串中擷取方括號內的列表字串\n    left = data.find('[')\n    right = data.rfind(']')\n    if left == -1 or right == -1:\n        print([])\n        sys.exit(0)\n\n    nums = ast.literal_eval(data[left:right+1])\n\n    sol = Solution()\n    result = sol.subsets(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[], [0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode423.json",
    "problem_index_in_file": 0,
    "title": "Reconstruct Original Digits from English",
    "description_snippet": "Given a string s containing an out-of-order English representation of digits 0-9, return the digits ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for the problem: Given a string s containing letters of digit words (e.g., \"owoztneoer\" which contains \"one\", \"two\", \"zero\") out of order, return digits in ascending order. We need to produce virtual code line by line with explanation. The output should use virtual code arrow, etc. It should not be actual code. Just the virtual code steps.\n\nWe need to design algorithm: Count letter frequencies. For each unique digit word, identify unique letters: zero(Z), two(W), four(U), six(X), eight(G). Use them to identify counts. Then use remaining letters to identify others: one(O), three(H), five(F), seven(S), nine(I). Classic approach.\n\nSo steps:\n\nStart.\n\n→ Step: Count letter frequencies in input string.\n\n→ Decision: For each unique letter digit in order: Z→0, W→2, U→4, X→6, G→8: If count >0, determine number of that digit = frequency of that unique letter. Append digit count times to output list. Then subtract used letters count times from frequency map.\n\n→ Decision: Next for O for 1, H for 3, F for 5, S for 7, I for 9: similar.\n\n→ Step: After all digits determined, sort digits ascending.\n\n→ Step: Convert list of digits to string.\n\n→ End.\n\nWe need to be more granular: each sub-step with explanation. Use arrow and decision syntax.\n\nLet's produce the virtual code. Ensure each line ends with // explanation.\n\nAlso we might need to handle letter removal properly: after counting, for each digit, subtract its letters count times.\n\nLet's write:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化字母頻率表 // 建立每個字母出現次數\n\n→ Step 2: 對於輸入字串 s 中每個字符 c: 進行頻率累計 // 收集所有字母\n\n→ Decision: 檢查是否包含 'Z'（代表 0）? // 判斷 'zero' 的唯一字母\n\n    Yes → Step 3: 計算 digit0 = freq['Z'] // 0 的數量\n\n    → Step 4: 將 '0' 重複 digit0 次加入結果清單 // 添加 0\n\n    → Step 5: 從 freq 表中減去 'zero' 的字母數量乘以 digit0 // 移除已計算字母\n\n    No → 省略 // 若無 'Z' 則不處理\n\n→ Decision: 檢查是否包含 'W'（代表 2）? // 判斷 'two' 的唯一字母\n\n    Yes → Step 6: 計算 digit2 = freq['W']\n\n    → Step 7: 將 '2' 重複 digit2 次加入結果清單\n\n    → Step 8: 從 freq 表中減去 'two' 的字母數量乘以 digit2\n\n    No → 省略\n\n... continue similarly for U (4), X (6), G (8)\n\nAfter unique digits, for remaining digits:\n\n→ Decision: 檢查 'O'（代表 1）? // 依靠 'one' 剩餘字母\n\n    Yes → Step 9: 計算 digit1 = freq['O']\n\n    → Step 10: 加入 '1' digit1 次\n\n    → Step 11: 從 freq 表中減去 'one' 的字母數量乘以 digit1\n\n    No → 省略\n\n... and so on for H (3), F (5), S (7), I (9)\n\nAfter all digits processed:\n\n→ Step 12: 將結果清單中所有數字按升序排序 // 以字母順序\n\n→ Step 13: 將排序後的數字列表轉換為字串 // 給出最終答案\n\n→ End // 程式執行結束\n\nAlso note we need to describe that 'one' letters: O,N,E; 'three': T,H,R,E,E; 'five': F,I,V,E; 'seven': S,E,V,E,N; 'nine': N,I,N,E.\n\nNeed to subtract correctly.\n\nWe can mention a generic step: Subtract counts of each letter for that digit times the count.\n\nMaybe we can include a generic \"SubtractLetterCounts(digit, count)\" step.\n\nLet's craft more detailed steps.\n\nMake sure each line uses `→` and `Decision:` and indent for Yes/No.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字母頻率表 freq ← 空字典 // 用於統計每個字母出現次數  \n→ Step 2: 對於輸入字串 s 中每個字符 c: freq[c] += 1 // 收集所有字母頻率  \n\nDecision: s 是否包含字母 'Z'（唯一字母代表 0）? // 判斷 \"zero\" 的唯一標誌  \n Yes → Step 3: digit0 ← freq['Z'] // 0 的個數  \n  → Step 4: 把 '0' 重複 digit0 次加入結果清單 result // 添加 0  \n  → Step 5: 從 freq 中減去字母 'z','e','r','o' 各乘以 digit0 // 移除已計算字母  \n No  → (省略)  \n\nDecision: s 是否包含字母 'W'（代表 2）? // 判斷 \"two\" 的唯一標誌  \n Yes → Step 6: digit2 ← freq['W']  \n  → Step 7: 把 '2' 重複 digit2 次加入 result  \n  → Step 8: 從 freq 中減去字母 't','w','o' 各乘以 digit2  \n No  → (省略)  \n\nDecision: s 是否包含字母 'U'（代表 4）? // 判斷 \"four\" 的唯一標誌  \n Yes → Step 9: digit4 ← freq['U']  \n  → Step 10: 把 '4' 重複 digit4 次加入 result  \n  → Step 11: 從 freq 中減去字母 'f','o','u','r' 各乘以 digit4  \n No  → (省略)  \n\nDecision: s 是否包含字母 'X'（代表 6）? // 判斷 \"six\" 的唯一標誌  \n Yes → Step 12: digit6 ← freq['X']  \n  → Step 13: 把 '6' 重複 digit6 次加入 result  \n  → Step 14: 從 freq 中減去字母 's','i','x' 各乘以 digit6  \n No  → (省略)  \n\nDecision: s 是否包含字母 'G'（代表 8）? // 判斷 \"eight\" 的唯一標誌  \n Yes → Step 15: digit8 ← freq['G']  \n  → Step 16: 把 '8' 重複 digit8 次加入 result  \n  → Step 17: 從 freq 中減去字母 'e','i','g','h','t' 各乘以 digit8  \n No  → (省略)  \n\n// 以上步驟處理所有帶唯一字母的數字，剩下的數字只能靠已減少字母的頻率來判斷  \n\nDecision: s 是否包含字母 'O'（代表 1）? // 判斷 \"one\" 剩餘字母  \n Yes → Step 18: digit1 ← freq['O']  \n  → Step 19: 把 '1' 重複 digit1 次加入 result  \n  → Step 20: 從 freq 中減去字母 'o','n','e' 各乘以 digit1  \n No  → (省略)  \n\nDecision: s 是否包含字母 'H'（代表 3）? // 判斷 \"three\" 剩餘字母  \n Yes → Step 21: digit3 ← freq['H']  \n  → Step 22: 把 '3' 重複 digit3 次加入 result  \n  → Step 23: 從 freq 中減去字母 't','h','r','e','e' 各乘以 digit3  \n No  → (省略)  \n\nDecision: s 是否包含字母 'F'（代表 5）? // 判斷 \"five\" 剩餘字母  \n Yes → Step 24: digit5 ← freq['F']  \n  → Step 25: 把 '5' 重複 digit5 次加入 result  \n  → Step 26: 從 freq 中減去字母 'f','i','v','e' 各乘以 digit5  \n No  → (省略)  \n\nDecision: s 是否包含字母 'S'（代表 7）? // 判斷 \"seven\" 剩餘字母  \n Yes → Step 27: digit7 ← freq['S']  \n  → Step 28: 把 '7' 重複 digit7 次加入 result  \n  → Step 29: 從 freq 中減去字母 's','e','v','e','n' 各乘以 digit7  \n No  → (省略)  \n\nDecision: s 是否包含字母 'I'（代表 9）? // 判斷 \"nine\" 剩餘字母  \n Yes → Step 30: digit9 ← freq['I']  \n  → Step 31: 把 '9' 重複 digit9 次加入 result  \n  → Step 32: 從 freq 中減去字母 'n','i','n','e' 各乘以 digit9  \n No  → (省略)  \n\n// 至此所有數字已計算完成  \n\nStep 33: 將 result 清單中所有數字進行升序排序 // 使輸出為 0~9 的升序  \nStep 34: 將排序後的數字列表轉換為字符串 answer // 生成最終答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def originalDigits(self, s: str) -> str:\n        # Count frequency of each letter\n        count = Counter(s)\n\n        # Determine each digit using unique letters first\n        out = {}\n        out['0'] = count['z']\n        out['2'] = count['w']\n        out['4'] = count['u']\n        out['6'] = count['x']\n        out['8'] = count['g']\n\n        # Remaining digits use letters that are no longer unique after previous removals\n        out['3'] = count['h'] - out['8']\n        out['5'] = count['f'] - out['4']\n        out['7'] = count['s'] - out['6']\n        out['1'] = count['o'] - out['0'] - out['2'] - out['4']\n        out['9'] = count['i'] - out['5'] - out['6'] - out['8']\n\n        # Build the result string in ascending order\n        res = []\n        for digit in sorted(out.keys()):\n            res.append(digit * out[digit])\n        return ''.join(res)\n\ndef main():\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Try to extract the string value inside quotes if present\n    match = re.search(r'\\\"([^\\\"]*)\\\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # If no quotes, treat the whole input as the string\n        s = data\n\n    solution = Solution()\n    result = solution.originalDigits(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "success": true,
          "output": "012"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "success": true,
          "output": "45"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode479.json",
    "problem_index_in_file": 0,
    "title": "Largest Palindrome Product",
    "description_snippet": "Given an integer n, return the largest palindromic integer that can be represented as the product of...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce pseudocode steps line by line. It's an algorithm to find largest palindrome product of two n-digit numbers modulo 1337. Usually known problem from LeetCode: largest palindrome product modulo 1337. Approach: iterate over i from high down to low, j from i down to low, compute product, if palindrome, track max, break loops when product <= max. Finally return max % 1337.\n\nWe need pseudocode steps with arrow. Let's craft:\n\nStart\n→ Step 1: 定義 low = 10^(n-1), high = 10^n - 1 // n-digit range\n→ Step 2: max_palindrome = 0 // 儲存最大的回文乘積\n→ Step 3: For i from high down to low\n    → Decision: 是否可以停止外層迴圈? // If i*i <= max_palindrome, break\n    → Yes → End // 不可能再找到更大的回文\n    → No\n        → For j from i down to low\n            → Decision: 是否可以停止內層迴圈? // If i*j <= max_palindrome, break\n            → Yes → Continue // 跳出內層\n            → No\n                → Step 4: product = i * j // 計算乘積\n                → Step 5: Decision: product 是否為回文? // 判斷回文\n                → Yes → Decision: product > max_palindrome?\n                        → Yes → Step 6: max_palindrome = product // 更新最大\n                        → No → No op\n                → No → No op\n→ Step 7: return max_palindrome mod 1337 // 最終結果\nEnd\n\nBut need format exactly as per requirement: each line \"虛擬碼步驟\" + space + \"// 解釋/說明\". Also use arrows like \"→\" and \"Yes →\", \"No →\".\n\nAlso include indentation? In example they didn't indent. They used \"→ Decision:\" etc. For nested decisions, they show indentation. We can mimic that.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: low = 10^(n-1), high = 10^n - 1 // 計算 n 位數的最小與最大值\n→ Step 2: max_palindrome = 0 // 初始化最大回文乘積\n→ Step 3: For i from high down to low\n    → Decision: if i * i <= max_palindrome? // 若最小可能乘積已不大於已知最大，結束外層\n        Yes → End // 退出所有循環\n        No\n            → For j from i down to low\n                → Decision: if i * j <= max_palindrome? // 內層提前結束\n                    Yes → Continue // 跳過此 j\n                    No\n                        → Step 4: product = i * j // 計算乘積\n                        → Decision: product 是否為回文? // 判斷是否回文\n                            Yes → Decision: product > max_palindrome?\n                                Yes → Step 5: max_palindrome = product // 更新最大值\n                                No → No op // 仍不更新\n                            No → No op // 不是回文\n→ Step 6: return max_palindrome % 1337 // 取模後回傳結果\nEnd // 程式執行結束\n\nNeed to ensure formatting: each line separate, no indentation? Example shows indentation with spaces. We should mimic that. Use spaces before substeps. Provide each line with appropriate spaces. Provide arrow on lines with decisions etc. Let's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 10^(n-1), high = 10^n - 1 // 計算 n 位數的最小與最大值  \n→ Step 2: max_palindrome = 0 // 初始化最大回文乘積  \n→ Step 3: For i from high down to low  \n&nbsp;&nbsp;→ Decision: if i * i <= max_palindrome? // 若最小可能乘積已不大於已知最大，結束外層  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → End // 退出所有循環  \n&nbsp;&nbsp;&nbsp;&nbsp;No  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ For j from i down to low  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: if i * j <= max_palindrome? // 內層提前結束  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Continue // 跳過此 j  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: product = i * j // 計算乘積  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: product 是否為回文? // 判斷是否回文  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Decision: product > max_palindrome?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: max_palindrome = product // 更新最大值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → No op // 仍不更新  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → No op // 不是回文  \n→ Step 6: return max_palindrome % 1337 // 取模後回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def largestPalindrome(self, n: int) -> int:\n        \"\"\"Return the largest palindrome product of two n‑digit integers.\"\"\"\n        if n == 1:\n            return 9\n\n        low = 10 ** (n - 1)\n        high = 10 ** n - 1\n        max_palindrome = 0\n\n        for i in range(high, low - 1, -1):\n            # If the smallest possible product with this i is already <= max,\n            # no larger palindrome can be found for any smaller i.\n            if i * i <= max_palindrome:\n                break\n\n            for j in range(i, low - 1, -1):\n                prod = i * j\n                # Early exit: further j will only make prod smaller.\n                if prod <= max_palindrome:\n                    break\n                if str(prod) == str(prod)[::-1]:\n                    max_palindrome = prod\n                    # For this i, the first palindrome found is the largest,\n                    # so we can stop searching smaller j.\n                    break\n\n        return max_palindrome\n\n\nif __name__ == \"__main__\":\n    # Read all input, extract the first integer found.\n    data = sys.stdin.read()\n    match = re.search(r\"\\d+\", data)\n    if not match:\n        sys.exit(0)\n    n = int(match.group())\n\n    solution = Solution()\n    result = solution.largestPalindrome(n) % 1337\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "987",
          "success": true,
          "output": "987"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2410.json",
    "problem_index_in_file": 0,
    "title": "Maximum Matching of Players With Trainers",
    "description_snippet": "You are given a 0-indexed integer array players, where players[i] represents the ability of the i^th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines, with each line ending with // explanation. We must not output actual code. It's a matching problem: match players and trainers with ability <= capacity, one-to-one. Classic greedy: sort both arrays, use two pointers to match. We need to produce steps.\n\nWe produce Start, then sort players, sort trainers. Then initialize i=0, j=0, count=0. Then while i<players.length and j<trainers.length: if players[i] <= trainers[j] then count++, i++, j++; else j++ (move to next trainer). Then End.\n\nNeed to include decision arrows.\n\nWe must format each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". For decision: \"Decision:\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 將 players 陣列按升序排序 // 方便後續匹配\n→ Step 2: 將 trainers 陣列按升序排序 // 方便後續匹配\n→ Step 3: 設置指標 i = 0, j = 0, count = 0 // i 指向玩家, j 指向教練\n→ Decision: 是否還有未處理的玩家與教練? // 檢查是否達到陣列尾\n    Yes → Decision: 玩家能力 ≤ 教練容量? // 判斷是否能匹配\n        Yes → Step 4: count++, i++, j++ // 匹配成功，計數並移動兩指標\n        No  → Step 5: j++ // 玩家無法匹配，嘗試更高容量的教練\n    No  → End // 所有匹配完成\nEnd // 回傳 count\n\nBut we need each line to be one step. We also need to use \"→\" to go to next step. For decision, we need indentation? In sample, they indent. Use spaces.\n\nLet's produce lines accordingly.\n\nCheck: Each line must contain step + space + comment. The arrow is part of the step.\n\nWe must ensure we have \"Start\" and \"End\" at top and bottom. The decision lines use \"Decision:\".\n\nWe also need to indicate arrow after decision lines for each branch.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 將 players 陣列按升序排序 // 方便後續匹配\n→ Step 2: 將 trainers 陣列按升序排序 // 方便後續匹配\n→ Step 3: 初始化 i = 0, j = 0, count = 0 // i 指向玩家，j 指向教練\n→ Decision: 是否還有未處理的玩家與教練? // 檢查索引是否超過陣列長度\n    Yes → Decision: players[i] <= trainers[j]? // 判斷能否匹配\n        Yes → Step 4: count++; i++; j++; // 成功匹配，更新計數與指標\n        No  → Step 5: j++; // 玩家無法匹配，移動至下一名教練\n    No  → End // 所有可能的匹配已完成\nEnd // 回傳 count\n\nBut we need End inside the decision branch maybe? The sample shows End outside the branches. It ends the program. We might put End after the decision. That is fine.\n\nAlternatively, we can have a Step 6: return count // 返回匹配數量. But we can just End.\n\nBetter: After the decision when No, we go to End. So End is step.\n\nWe might include return count but not necessary.\n\nWe also need to keep consistent formatting: each line \"Step X:\" etc. The arrow \"→\" at beginning. For decision, we use \"Decision:\" preceded by arrow.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 players 陣列按升序排序 // 方便後續匹配  \n→ Step 2: 將 trainers 陣列按升序排序 // 方便後續匹配  \n→ Step 3: 初始化 i = 0, j = 0, count = 0 // i 指向玩家，j 指向教練  \n→ Decision: 是否還有未處理的玩家與教練? // 檢查索引是否超過陣列長度  \n Yes → Decision: players[i] <= trainers[j]? // 判斷能否匹配  \n  Yes → Step 4: count++; i++; j++; // 成功匹配，更新計數與指標  \n  No  → Step 5: j++; // 玩家無法匹配，移動至下一名教練  \n No  → End // 所有可能的匹配已完成  \nEnd // 回傳 count",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中抽取玩家與訓練師的能力陣列\n    player_match = re.search(r'players\\s*=\\s*(\\[\\s*[\\d,\\s]*\\s*\\])', data)\n    trainer_match = re.search(r'trainers\\s*=\\s*(\\[\\s*[\\d,\\s]*\\s*\\])', data)\n\n    if not player_match or not trainer_match:\n        return\n\n    players = ast.literal_eval(player_match.group(1))\n    trainers = ast.literal_eval(trainer_match.group(1))\n\n    # 先將兩個陣列升序排序\n    players.sort()\n    trainers.sort()\n\n    i = j = matches = 0\n    while i < len(players) and j < len(trainers):\n        if players[i] <= trainers[j]:\n            matches += 1\n            i += 1\n        j += 1\n\n    print(matches)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "players = [4,7,9], trainers = [8,2,5,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "players = [1,1,1], trainers = [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode704.json",
    "problem_index_in_file": 0,
    "title": "Binary Search",
    "description_snippet": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for binary search. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Use arrows and indent as in example. Provide line-by-line. Should not output actual code, only steps. Should follow format: e.g., \"Start // 程式開始執行\". Then \"→ Step 1: ...\". Use Decision lines with Yes →, No →. So produce:\n\nStart // 程式開始執行\n→ Step 1: Set left = 0, right = length(nums) - 1 // 初始化左右指標\n→ Decision: 是否 left <= right? // 判斷是否仍有搜索範圍\n    Yes → Step 2: mid = left + (right - left) // 計算中間索引\n    Yes → Step 3: If nums[mid] == target? // 檢查中間元素是否為目標\n        Yes → Step 4: Return mid // 找到目標，返回索引\n        No  → Step 5: Decision: nums[mid] < target? // 判斷目標是否在右半段\n            Yes → Step 6: left = mid + 1 // 移動左指標到右半段\n            No  → Step 7: right = mid - 1 // 移動右指標到左半段\n    No  → Step 8: Return -1 // 沒有找到，返回 -1\nEnd // 程式結束\n\nBut need each line preceded by arrow? In example, the first line after Start is \"→ Step 1: ...\" etc. Decision lines are indented. Should be \"→ Decision: ...\" and then Yes → Step ... etc. So produce exactly.\n\nBe careful about indentation. Use spaces or tabs? Use 4 spaces maybe.\n\nWill produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0, right = length(nums) - 1 // 初始化左右指標，範圍為整個陣列  \n→ Decision: left <= right? // 判斷是否還有未搜索的區間  \n Yes → Step 2: mid = left + (right - left) // 計算中間索引，避免溢位  \n Yes → Decision: nums[mid] == target? // 檢查中間元素是否為目標值  \n  Yes → Step 3: return mid // 找到目標，返回其索引  \n  No → Decision: nums[mid] < target? // 判斷目標值位於右半段或左半段  \n   Yes → Step 4: left = mid + 1 // 目標在右側，更新左指標  \n   No → Step 5: right = mid - 1 // 目標在左側，更新右指標  \n No → Step 6: return -1 // 範圍已空，表示目標不存在  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def search(self, nums, target):\n        \"\"\"Binary search in a sorted list, returns index or -1.\"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"Extract nums list and target integer from input string.\"\"\"\n    # Try to match the pattern: nums = [...], target = ...\n    pattern = r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)'\n    m = re.search(pattern, data, re.S)\n    if m:\n        nums_str, target_str = m.group(1), m.group(2)\n        nums = ast.literal_eval(nums_str)\n        target = int(target_str)\n        return nums, target\n\n    # If above fails, try to interpret the input as two lines\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        try:\n            nums = ast.literal_eval(lines[0].strip())\n            target = int(lines[1].strip())\n            return nums, target\n        except:\n            pass\n\n    # As a last resort, try to split by comma and parse manually\n    parts = data.split(',')\n    if len(parts) >= 2:\n        try:\n            nums = ast.literal_eval(parts[0].split('=', 1)[-1].strip())\n            target = int(parts[1].split('=', 1)[-1].strip())\n            return nums, target\n        except:\n            pass\n\n    # If all parsing fails, return empty defaults\n    return [], -1\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    nums, target = parse_input(raw_input)\n    sol = Solution()\n    result = sol.search(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,3,5,9,12], target = 9",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0,3,5,9,12], target = 2",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode724.json",
    "problem_index_in_file": 0,
    "title": "Find Pivot Index",
    "description_snippet": "Given an array of integers nums, calculate the pivot index of this array.\n\nThe pivot index is the in...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for the problem: pivot index. Use the given format. Provide each line: virtual step, then // explanation.\n\nWe must not output actual code but virtual pseudocode with arrows.\n\nWe should include Start, End, Decision, steps, loops. The algorithm: compute total sum, then iterate index with leftSum, check if leftSum == total - leftSum - nums[i]. If yes return i. else leftSum += nums[i]. After loop return -1.\n\nWe need to produce line by line steps, with arrows. Use \"→\" and \"Yes →\", \"No →\". Provide explanations. Should be clear.\n\nLet's produce:\n\nStart // 開始程式\n→ Step 1: 計算陣列 nums 的總和 total // 求出所有元素總和\n→ Step 2: 初始化 leftSum 為 0 // 左側已累加的總和初始為 0\n→ Step 3: 初始化 index 為 0 // 開始從第一個索引進行檢查\n→ Decision: index < nums.length? // 檢查是否還有元素可檢查\n    Yes → Step 4: 計算 rightSum = total - leftSum - nums[index] // 右側總和\n    → Decision: leftSum == rightSum? // 判斷當前索引是否為 pivot\n        Yes → Step 5: 回傳 index // 找到 pivot，結束\n        No  → Step 6: leftSum = leftSum + nums[index] // 將當前元素加入左側總和\n        → Step 7: index = index + 1 // 移動到下一個索引\n        → Go back to Decision: index < nums.length? // 重新檢查\n    No  → Step 8: 回傳 -1 // 沒有找到 pivot，返回 -1\nEnd // 程式結束\n\nEnsure each line uses the format \"虛擬碼步驟 // 解釋\". Use proper arrow formatting.\n\nWe need to add arrow indentation maybe but format is simple.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算陣列 nums 的總和 total // 求出所有元素總和  \n→ Step 2: 初始化 leftSum 為 0 // 左側已累加的總和初始為 0  \n→ Step 3: 初始化 index 為 0 // 開始從第一個索引進行檢查  \n→ Decision: index < nums.length? // 檢查是否還有元素可檢查  \n  Yes → Step 4: 計算 rightSum = total - leftSum - nums[index] // 右側總和  \n  → Decision: leftSum == rightSum? // 判斷當前索引是否為 pivot  \n    Yes → Step 5: 回傳 index // 找到 pivot，結束  \n    No  → Step 6: leftSum = leftSum + nums[index] // 將當前元素加入左側總和  \n    → Step 7: index = index + 1 // 移動到下一個索引  \n    → Go back to Decision: index < nums.length? // 重新檢查  \n  No  → Step 8: 回傳 -1 // 沒有找到 pivot，返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def pivotIndex(self, nums):\n        total = sum(nums)\n        left_sum = 0\n        for i, num in enumerate(nums):\n            if left_sum == total - left_sum - num:\n                return i\n            left_sum += num\n        return -1\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 找出括號內的列表字串\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1 and start < end:\n        list_str = data[start:end + 1]\n        try:\n            nums = ast.literal_eval(list_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    # 計算 pivot index\n    result = Solution().pivotIndex(nums)\n\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,7,3,6,5,6]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "nums = [2,1,-1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode761.json",
    "problem_index_in_file": 0,
    "title": "Special Binary String",
    "description_snippet": "Special binary strings are binary strings with the following two properties:\n\nThe number of 0's is e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step algorithm to find lexicographically largest string after swapping consecutive special substrings. This is similar to Codeforces problem 1738C? Actually known problem: \"Largest Special Binary String\" from LeetCode. The solution: recursively process string: break into groups of balanced parentheses like pairs of 0 and 1. For each group, sort inside. Then sort groups descending. Virtual code should capture algorithm: parse string into special substrings recursively, convert to list of strings, sort, etc.\n\nWe need to output lines: each with \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nWe need to produce algorithm in natural pseudo-code lines.\n\nWe'll design:\n\nStart\n\n→ Step 1: Define function solve(s): // main function\n\n→ Decision: If s empty? // base case\n\n→ Step 2: Parse s into list of immediate special substrings (balance counter logic). // splitting\n\n→ Step 3: For each substring in list: recursively call solve(sub). // transform inner\n\n→ Step 4: Sort list of transformed substrings in descending lex order. // to get largest\n\n→ Step 5: Concatenate sorted substrings into result. // final string\n\n→ End\n\nAdditionally we need step to parse:\n\n→ Step 6: Initialize counter=0, start=0\n\n→ Loop i from 0 to len(s)-1:\n\n→ If s[i]== '1' → counter++\n\n→ else → counter--\n\n→ If counter==0: substring = s[start:i+1]; add to list; start=i+1\n\nEnd Loop.\n\nAlso we need to handle recursion base: when string length 2 -> return s.\n\nNow produce virtual code lines with explanations.\n\nLet's craft. Ensure we use arrows as per format: \"Start // ...\" then \"→ Step 1:\" etc.\n\nWe also need indentation maybe but just each line separate.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define function `solve(s)` // 主函式，用於處理任意長度的特殊二進位字串  \n→ Decision: 若 `s` 為空串? // 基礎情況  \n  Yes → Step 2: 回傳空串 // 空串直接回傳  \n  No → Step 3: 進入處理流程 // 非空字串進一步分解  \n\n→ Step 4: 初始化空清單 `parts = []` 及計數器 `balance = 0`  // 用於分割特殊子字串  \n→ Step 5: 設定起始索引 `start = 0` // 分段起點  \n\n→ Loop `i` 從 0 到 `len(s)-1`: // 逐位掃描  \n  Decision: 若 `s[i] == '1'`? // 判斷符號  \n   Yes → `balance += 1` // 1 增加平衡值  \n   No → `balance -= 1` // 0 減少平衡值  \n  Decision: 若 `balance == 0`? // 完整一個特殊子字串  \n   Yes → Step 6: `sub = s[start : i+1]` // 抽取子字串  \n    → Step 7: `parts.append(sub)` // 加入清單  \n    → Step 8: `start = i + 1` // 更新起點  \n\n→ End Loop // 完成所有子字串的分割  \n\n→ Step 9: 對 `parts` 進行遞迴處理：  \n  Loop 每個 `p` in `parts`:  \n   → Step 10: `parts[i] = solve(p)` // 內部結構轉換  \n\n→ Step 11: 對 `parts` 進行字典序降序排序  \n  → `parts.sort(reverse=True)` // 取得最大小寫序  \n\n→ Step 12: 合併所有子字串  \n  → `result = ''.join(parts)` // 連接成最終字串  \n\n→ Step 13: 回傳 `result` // 完成一次遞迴回傳  \n\n→ End // 程式執行結束  \n\n// 呼叫入口  \n→ Step 14: `final_str = solve(input_string)` // 對給定的特殊字串執行  \n→ Step 15: 輸出 `final_str` // 顯示最大的可能字串",
      "generated_code": "import sys\n\ndef makeLargestSpecial(s: str) -> str:\n    \"\"\"\n    Recursively transform a special binary string into the lexicographically largest\n    string obtainable by swapping consecutive special substrings.\n    \"\"\"\n    if not s:\n        return \"\"\n\n    parts = []\n    balance = 0\n    start = 0\n\n    # Split s into the minimal special substrings.\n    for i, c in enumerate(s):\n        if c == '1':\n            balance += 1\n        else:\n            balance -= 1\n        if balance == 0:\n            # Recursively process the inner part of this substring.\n            inner = makeLargestSpecial(s[start + 1:i])\n            parts.append('1' + inner + '0')\n            start = i + 1\n\n    # Sort the processed substrings in descending lexicographical order.\n    parts.sort(reverse=True)\n    return ''.join(parts)\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n\n    # Extract the string value from possible formats like:\n    #   s = \"11011000\"\n    # or just the raw string 11011000\n    if raw_input.startswith('s'):\n        # Split on '=' and take the part after it\n        _, value = raw_input.split('=', 1)\n        raw_input = value.strip()\n\n    # Remove surrounding quotes if present\n    if raw_input.startswith('\"') and raw_input.endswith('\"'):\n        raw_input = raw_input[1:-1]\n    raw_input = raw_input.strip('\"')\n\n    result = makeLargestSpecial(raw_input)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"11011000\"",
          "expected_output": "\"11100100\"",
          "success": true,
          "output": "11100100"
        },
        {
          "example_index": 1,
          "input": "s = \"10\"",
          "expected_output": "\"10\"",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode461.json",
    "problem_index_in_file": 0,
    "title": "Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps, line by line, with explanation comment after space. Format: Start, →, Decision, Yes→, No→, End.\n\nRequirement: Virtual code only, no actual code. Steps: get x, y, compute bitwise XOR, count set bits, return count.\n\nWe need to use virtual code style. Use arrows.\n\nExamples: \"Start // 程式開始執行\" etc.\n\nWe'll create steps: input x and y (though they are given), compute XOR, initialize counter, loop while xor != 0, increment counter, shift right etc. Could also count bits using built-in but virtual.\n\nI'll produce step names: Step 1: assign x, y; Step 2: compute xor = x XOR y; Step 3: set counter = 0; Step 4: while xor > 0; Step 5: if lowest bit of xor is 1 → increment counter; Step 6: shift xor right by 1; Step 7: end loop; Step 8: return counter.\n\nInclude decision points inside loop: Decision: lowest bit = 1? Yes→ increment counter; No→ skip. Also loop condition: Decision: xor > 0? Yes→ process; No→ exit loop.\n\nAlso need start, end.\n\nLet's produce.\n\nUse \"Decision:\" for each. Use \"Yes →\" \"No →\". Also include \"End\" for loop and final.\n\nWe'll also provide comment.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將輸入的兩個整數 x 與 y 存入變數 // 取得兩個待比較的數字\n→ Step 2: 計算 xor = x XOR y // 取得兩數不同位元的差異\n→ Step 3: 初始化 counter = 0 // 記錄不同位元的數量\n→ Decision: xor > 0? // 是否還有位元需要檢查\n    Yes → Step 4: 取 xor 的最低位 // 檢查目前最低位是否為 1\n        → Decision: 最低位 = 1? // 判斷此位是否不同\n            Yes → Step 5: counter = counter + 1 // 若不同，累加計數\n            No  → // 這位相同，無需更動\n        → Step 6: xor = xor >> 1 // 右移一位，準備檢查下一位\n        → Step 7: // 重新回到 Step 4 的前面，重複檢查\n        → End // Step 4 循環結束\n    No  → // xor 為 0，所有位元已檢查完畢\n→ Step 8: 返回 counter // 傳回最終的 Hamming 距離\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        \"\"\"Return the Hamming distance between two integers.\"\"\"\n        xor = x ^ y\n        distance = 0\n        while xor:\n            distance += xor & 1\n            xor >>= 1\n        return distance\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 提取所有整數（含負號）\n    nums = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(nums) < 2:\n        raise ValueError(\"輸入必須包含兩個整數\")\n    x, y = nums[0], nums[1]\n    sol = Solution()\n    result = sol.hammingDistance(x, y)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 1, y = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 3, y = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode754.json",
    "problem_index_in_file": 0,
    "title": "Reach a Number",
    "description_snippet": "You are standing at position 0 on an infinite number line. There is a destination at position target...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps with explanation for algorithm to find minimal number of moves to reach target. Problem: \"Reach a number by sum of first k integers with signs\". Known solution: minimal k such that sum >= |target| and parity matches. So algorithm: let t=abs(target). let sum=0, k=0; while sum< t or (sum - t) % 2 !=0: k++; sum+=k; return k. So produce virtual code lines with explanation.\n\nWe must output each line: \"虛擬碼步驟 // 解釋\" and use arrows. Provide Start, End, Decision. So we can write:\n\nStart // 開始\n→ Step 1: 設定目標 t = |target| // 取目標絕對值\n→ Step 2: 初始化 sum = 0, k = 0 // 累計步長總和與步數\n→ Decision: sum < t 或 (sum - t) % 2 != 0? // 判斷是否足夠且奇偶相符\n    Yes → Step 3: k += 1 // 增加一步數\n    Yes → Step 4: sum += k // 累加當前步長\n    Yes → Go back to Decision // 重新檢查條件\n    No  → End // 退出循環\n→ Step 5: 返回 k // 最小步數\n\nBut we need to use arrow syntax: \"→ Step ...\" maybe. Use \"→\" before step. For Decision: we need \"Decision: ...\" with Yes and No arrow.\n\nWe must use \"Start\" \"End\". Provide explanation after each line. Ensure each line has \"虛擬碼步驟 [空格] // 解釋/說明\". Use arrows. So lines:\n\nStart // 程式開始\n→ Step 1: t = abs(target) // 取得目標位置的絕對值\n→ Step 2: sum = 0 // 累計總步長\n→ Step 3: k = 0 // 步數計數器\n→ Decision: sum < t 或 (sum - t) % 2 != 0? // 檢查是否足夠且奇偶匹配\n    Yes → Step 4: k += 1 // 增加一步長數\n    Yes → Step 5: sum += k // 加上新的步長至總和\n    Yes → Go back to Decision // 重新判斷條件\n    No  → End // 條件滿足，結束循環\n→ Step 6: return k // 回傳最小步數\n\nWe need to ensure correct indent and arrow for decision. The format for decision lines: \"Decision: ...\". Indent \"Yes →\" etc. Provide explanation.\n\nBetter to combine Step 1, 2, 3 maybe separate.\n\nLet's craft final output. Ensure no actual code. Use Chinese. Use virtual code arrows.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: t = abs(target) // 取得目標位置的絕對值\n→ Step 2: sum = 0 // 累計已走的總步長\n→ Step 3: k = 0 // 步數計數器\n→ Decision: sum < t 或 (sum - t) % 2 != 0? // 判斷是否足夠且奇偶性匹配\n    Yes → Step 4: k += 1 // 增加一步長\n    Yes → Step 5: sum += k // 加上當前步長到總和\n    Yes → Go back to Decision // 重新檢查條件\n    No  → End // 條件滿足，結束循環\n→ Step 6: return k // 回傳最小步數\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reachNumber(self, target: int) -> int:\n        \"\"\"Return the minimal number of moves to reach `target`.\"\"\"\n        target = abs(target)\n        step = 0\n        total = 0\n        # 持續增加步長，直到總和不小於目標且總和與目標同奇偶性\n        while total < target or (total - target) % 2 != 0:\n            step += 1\n            total += step\n        return step\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取目標值，計算並輸出最小步數。\"\"\"\n    data = sys.stdin.read()\n    # 從輸入字串中找出第一個整數（可能帶符號）\n    match = re.search(r'[-]?\\d+', data)\n    if not match:\n        return\n    target = int(match.group())\n    answer = Solution().reachNumber(target)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "target = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "target = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode621.json",
    "problem_index_in_file": 0,
    "title": "Task Scheduler",
    "description_snippet": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CP...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (like pseudocode) for scheduling tasks with cooling interval n. Standard problem: Leetcode 621. Algorithm: count frequencies, find max freq, count how many tasks have that max freq. Then compute empty slots: (maxCount-1)*(n+1) + countMax. Or formula: (maxFreq-1)*(n+1)+numMaxFreq. Then answer is max(totalTasks, emptySlots). So produce steps. We need to output each line with virtual code and explanation.\n\nWe'll produce structure with Start, decisions. We'll not produce actual code, just steps. Use arrow →. Each line: \"虛擬碼步驟 // 解釋\".\n\nLet's produce lines:\n\nStart\n→ Step 1: Initialize frequency map for tasks // Count how many of each task\n→ Step 2: Determine max frequency among tasks // Highest repeat count\n→ Step 3: Count how many tasks have that max frequency // For tie\n→ Step 4: Calculate empty slots: (maxFreq - 1) * (n + 1) // slots between highest tasks\n→ Decision: If countMax > 1? // adjust for multiple max tasks\n    Yes → Step 5: emptySlots += countMax // add extra tasks into the last slot\n    No  → (skip)\n→ Step 6: Compute intervalsNeeded = max(totalTasks, emptySlots) // minimum intervals\n→ Step 7: Return intervalsNeeded\nEnd\n\nBut also might need to handle cases where n=0. The formula still works: emptySlots = (maxFreq-1)*(0+1) = maxFreq-1, plus countMax. Might produce less than total tasks. So max ensures.\n\nAdd more detailed decisions maybe: if emptySlots < totalTasks? we return totalTasks else emptySlots. But we already have max.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立任務頻率表 // 逐一統計陣列中每個字母出現的次數  \n→ Step 2: 找出最高頻率 maxFreq // 從頻率表取出最大的重複次數  \n→ Step 3: 計算具有 maxFreq 的任務數 countMax // 這些任務會決定空間的佔用  \n→ Step 4: 計算空閒槽數 emptySlots = (maxFreq - 1) * (n + 1) // 兩個相同任務之間的最小間隔  \n→ Decision: countMax > 1? // 是否有多個任務共擁最高頻率  \n    Yes → Step 5: emptySlots += countMax // 多個最高頻任務會佔用最後一組槽  \n    No  → （略）  \n→ Step 6: intervalsNeeded = max(totalTasks, emptySlots) // 取較大值作為最少 CPU 時間  \n→ Step 7: 回傳 intervalsNeeded // 結束並輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef least_interval(tasks, n):\n    \"\"\"\n    計算完成所有任務所需的最少 CPU 時間間隔。\n    \"\"\"\n    if not tasks:\n        return 0\n\n    # 1. 統計每個任務的出現頻率\n    freq = Counter(tasks)\n\n    # 2. 找出最高頻率\n    max_freq = max(freq.values())\n\n    # 3. 計算有最高頻率的任務數量\n    max_count = sum(1 for count in freq.values() if count == max_freq)\n\n    # 4. 計算空閒槽數：在最高頻率任務之間的最小空隙\n    empty_slots = (max_freq - 1) * (n + 1) + max_count\n\n    # 5. 結果為任務總數與空閒槽數的較大值\n    return max(len(tasks), empty_slots)\n\ndef parse_input(data: str):\n    \"\"\"\n    解析標準輸入，支援兩種常見格式：\n    - tasks = [...], n = ...\n    - 任務列表\\nn\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], 0\n\n    # 去掉 'tasks =' 與 'n ='，方便後續拆分\n    data = data.replace('tasks =', '').replace('n =', '')\n\n    # 先嘗試以逗號分隔（但要排除方括號內的逗號）\n    parts = re.split(r',(?![^\\[]*\\])', data, maxsplit=1)\n    if len(parts) == 2:\n        tasks_part, n_part = parts\n        tasks = eval(tasks_part.strip())\n        n = int(n_part.strip())\n        return tasks, n\n\n    # 若格式為兩行\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        tasks = eval(lines[0].strip())\n        n = int(lines[1].strip())\n        return tasks, n\n\n    # 兜底處理\n    return [], 0\n\ndef main():\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    tasks, n = parse_input(raw_input)\n    result = least_interval(tasks, n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode355.json",
    "problem_index_in_file": 0,
    "title": "Design Twitter",
    "description_snippet": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line with arrow and decision etc. It's a simplified Twitter: operations postTweet, getNewsFeed, follow, unfollow. Need to include data structures: maybe dict user->followers set, user->tweets list, global timestamp counter. The pseudo-code for each method.\n\nWe'll design main class with init, methods. Provide pseudo-code. The output should be step-by-step, each line with arrow and comment. Use Start, End, Decision.\n\nProbably we need to outline the entire class operations. Each method separate block. We might start with Start of Twitter() initialization.\n\nWe might create pseudocode for each function: PostTweet, GetNewsFeed, Follow, Unfollow. We need to illustrate data structures and logic. Let's produce lines accordingly.\n\nWe need to use arrow \"→\". For decisions use \"Decision:\".\n\nWe need to give a line per step, but also group them logically.\n\nLet's produce:\n\nStart Twitter class // initialize data structures\n→ Initialize global timestamp = 0 // for ordering tweets\n→ Initialize users dict mapping userId to set of followees // follow relationships\n→ Initialize tweets dict mapping userId to list of (timestamp, tweetId) // user tweets\n→ Initialize empty user sets for new users when first referenced\n\nMethod: postTweet(userId, tweetId)\n→ If userId not in users → add empty follow set\n→ Increment timestamp\n→ Append (timestamp, tweetId) to tweets[userId] // store tweet\n→ End\n\nMethod: getNewsFeed(userId)\n→ If userId not in users → add empty follow set\n→ Collect followees = users[userId] ∪ {userId} // self included\n→ Initialize min-heap (size 10) // to keep top 10 recent\n→ For each followee in followees\n    → For each tweet in tweets[followee] (from most recent)\n        → If heap size <10 → push tweet\n        → Else if tweet.timestamp > heap[0].timestamp → replace\n        → Break when older than current 10 threshold? maybe break after 10? We'll just iterate all\n→ Extract tweetIds from heap, sort descending by timestamp\n→ Return list of tweetIds\n→ End\n\nMethod: follow(followerId, followeeId)\n→ If followerId not in users → add empty set\n→ If followeeId not in users → add empty set\n→ Add followeeId to users[followerId] // start following\n→ End\n\nMethod: unfollow(followerId, followeeId)\n→ If followerId in users and followeeId in users[followerId] → remove\n→ End\n\nBut we need step-by-step lines, including decisions.\n\nAlso we should show structure like:\n\nStart // 初始化\n→ ...\n\nWe'll produce separate blocks: Start, each method as block with Start, steps, End.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize timestamp ← 0 // 全域時間戳，確保每條推文按發佈順序排序  \n→ Initialize users ← {} // userId → set of followeeId，存放追蹤關係  \n→ Initialize tweets ← {} // userId → list of (timestamp, tweetId)，存放每位使用者的推文  \n\n// ---------- postTweet 方法 ----------  \nStart // postTweet() 開始  \n→ If userId not in users → users[userId] ← {} // 新使用者加入追蹤集合  \n→ If userId not in tweets → tweets[userId] ← [] // 新使用者加入推文列表  \n→ timestamp ← timestamp + 1 // 時間戳遞增  \n→ Append (timestamp, tweetId) to tweets[userId] // 儲存新推文  \nEnd // postTweet() 結束  \n\n// ---------- getNewsFeed 方法 ----------  \nStart // getNewsFeed() 開始  \n→ If userId not in users → users[userId] ← {} // 若無使用者，初始化空追蹤集合  \n→ followees ← users[userId] ∪ {userId} // 自己與追蹤者皆為訊息來源  \n→ Initialize minHeap ← empty priority queue ordered by timestamp // 用來取前 10 條最新推文  \n→ Decision: followees 是否為空?  \n    Yes → Return [] // 無追蹤者且自己沒有推文，回傳空列表  \n    No → Proceed  \n→ For each f in followees // 遍歷所有訊息來源  \n    → For each (ts, id) in tweets[f] in reverse chronological order // 由最新推文開始  \n        → Decision: minHeap size < 10?  \n            Yes → Push (ts, id) into minHeap // 補足至 10 條  \n            No → Decision: ts > minHeap.peek().timestamp? // 與當前最小時間戳比較  \n                Yes → Pop minHeap → Push (ts, id) // 用更新推文取代舊的  \n                No → Continue // 仍較舊，忽略  \n        → Decision: 已收集 10 條且 ts <= minHeap.peek().timestamp?  \n            Yes → Break // 後續推文不可能更新，跳出內層循環  \n            No → Continue // 仍可能更新，繼續檢查  \n→ Extract all entries from minHeap, sort by timestamp descending // 轉回由新到舊順序  \n→ newsFeed ← list of tweetIds from sorted entries  \n→ Return newsFeed // 回傳 10 條最新推文  \nEnd // getNewsFeed() 結束  \n\n// ---------- follow 方法 ----------  \nStart // follow() 開始  \n→ If followerId not in users → users[followerId] ← {} // 新使用者加入追蹤集合  \n→ If followeeId not in users → users[followeeId] ← {} // 確保追蹤對象存在  \n→ Add followeeId to users[followerId] // 開始追蹤  \nEnd // follow() 結束  \n\n// ---------- unfollow 方法 ----------  \nStart // unfollow() 開始  \n→ Decision: followerId in users AND followeeId in users[followerId]?  \n    Yes → Remove followeeId from users[followerId] // 取消追蹤  \n    No → No action // 若條件不滿足，直接忽略  \nEnd // unfollow() 結束  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0  # 全局時間戳，確保推文順序\n        self.tweets = defaultdict(list)  # userId -> list of (timestamp, tweetId)\n        self.following = defaultdict(set)  # userId -> set of followeeIds\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        # 自己自動跟隨自己，方便查找自己的推文\n        self.following[userId].add(userId)\n\n    def getNewsFeed(self, userId: int) -> list[int]:\n        # 如果使用者不存在，返回空列表\n        if userId not in self.following:\n            return []\n\n        followees = self.following[userId] | {userId}\n        heap = []  # 儲存最近的推文，使用負時間戳做最大堆\n\n        # 初始時把每個追蹤者最近的一條推文放進堆\n        for fid in followees:\n            tweets = self.tweets.get(fid)\n            if tweets:\n                idx = len(tweets) - 1\n                ttime, tid = tweets[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n\n        res = []\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx - 1 >= 0:\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        # 追蹤者自動存在於 following 集合中\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            # 不能取消自我追蹤\n            return\n        self.following[followerId].discard(followeeId)\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    ops, args_list = eval(data)  # 解析輸入為兩個列表\n\n    result = []\n    twitter_obj = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"Twitter\":\n            twitter_obj = Twitter()\n            result.append(None)\n        elif op == \"postTweet\":\n            twitter_obj.postTweet(*args)\n            result.append(None)\n        elif op == \"getNewsFeed\":\n            res = twitter_obj.getNewsFeed(*args)\n            result.append(res)\n        elif op == \"follow\":\n            twitter_obj.follow(*args)\n            result.append(None)\n        elif op == \"unfollow\":\n            twitter_obj.unfollow(*args)\n            result.append(None)\n        else:\n            # 若遇到未知操作，直接返回 None\n            result.append(None)\n\n    # 輸出結果，使用 json.dumps 以得到 null 的表示\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "success": true,
          "output": "[null, null, [5], null, null, [6, 5], null, [5]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode670.json",
    "problem_index_in_file": 0,
    "title": "Maximum Swap",
    "description_snippet": "You are given an integer num. You can swap two digits at most once to get the maximum valued number....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. The user request is in Chinese: \"You are given an integer num. You can swap two digits at most once to get the maximum valued number. Return the maximum valued number you can get.\"\n\nWe need to output pseudo-code line by line, each line: `虛擬碼步驟 // 解釋`. Use arrows and Decision, Start, End. No actual code. Each line must have the arrow. The arrow pattern: `→ Step 1: ...`. The decisions: `Decision: ...` with Yes →, No → lines indented.\n\nWe need to produce steps. Let's outline algorithm:\n\n1. Convert num to list of digits.\n2. For each digit position i from left to right, find the maximum digit to the right of i that is greater than digits[i], and record its index j. But we only need the rightmost max? Actually we need to find the earliest i where there's a larger digit later; we want to swap with the largest possible digit to the right, but if there are multiple same digits, swap with the rightmost occurrence. Standard algorithm: traverse from right to left keeping max digit seen; record the index of max digit. Then traverse from left to right to find first i where digits[i] < maxDigit; swap with index of rightmost maxDigit greater than digits[i]. Implementation details: Keep track of maxDigit and its index while scanning from right.\n\nSimplify: for each position i, find the largest digit to its right; if that digit > digits[i], record the swap. But need to ensure we pick the farthest right occurrence of the largest digit.\n\nSimpler: For i from 0 to n-1:\n    max_digit = -1\n    max_index = -1\n    for j from n-1 downto i+1:\n        if digits[j] > max_digit:\n            max_digit = digits[j]\n            max_index = j\n    if max_digit > digits[i]:\n        swap digits[i] with digits[max_index]\n        break\nReturn int(''.join(digits))\n\nWe can pseudo-code like that.\n\nNow produce virtual code lines:\n\nStart\n→ Step 1: Convert num to list of digits // 轉換整數為數字陣列\n→ Step 2: 設定 n 為 digits 的長度 // 取得陣列長度\n→ Step 3: 進行外層迴圈 i 從 0 到 n-1 // 檢查每個位置\n    → Decision: 是否已完成交換? // 檢查是否已交換一次\n        Yes → End // 程式結束\n        No  →\n            → Step 4: 初始化 max_digit 為 -1, max_index 為 -1 // 準備尋找右側最大數字\n            → Step 5: 進行內層迴圈 j 從 n-1 到 i+1 步進 -1 // 從右往左找最大數字\n                → Decision: digits[j] > max_digit? // 判斷是否為更大的數字\n                    Yes → Step 6: 設定 max_digit = digits[j], max_index = j // 更新最大值和索引\n                    No  → (無操作)\n            → Decision: max_digit > digits[i]? // 判斷是否需要交換\n                Yes →\n                    → Step 7: 交換 digits[i] 與 digits[max_index] // 執行交換\n                    → Step 8: 設定 已交換 = True // 標記已完成交換\n                No  → (無操作)\n→ Step 9: 將 digits 轉回整數 // 把陣列重新組合成整數\n→ End // 程式結束\n\nBut we need to use arrow and Decision. The indentation with \"→\" maybe. The example shows arrows with Step and Decision. For nested steps we can indent. Let's produce proper format.\n\nLet's craft final output:\n\n```\nStart // 程式開始執行\n→ Step 1: 將 num 轉為字元陣列 digits // 取得每個數字\n→ Step 2: 設定 n = digits 長度 // 準備迴圈\n→ Step 3: 進行外層迴圈 i 從 0 到 n-1 // 檢查每個位置\n    → Decision: 是否已完成交換? // 檢查是否已交換一次\n        Yes → End // 已交換，結束程式\n        No  →\n            → Step 4: 設定 max_digit = -1, max_index = -1 // 用於尋找右側最大數字\n            → Step 5: 進行內層迴圈 j 從 n-1 到 i+1 步進 -1 // 從右往左搜尋\n                → Decision: digits[j] > max_digit? // 判斷是否為更大數字\n                    Yes → Step 6: max_digit = digits[j], max_index = j // 更新最大值及其位置\n                    No  → (無操作)\n            → Decision: max_digit > digits[i]? // 是否需要交換\n                Yes →\n                    → Step 7: 交換 digits[i] 與 digits[max_index] // 執行一次交換\n                    → Step 8: 已交換 = True // 標記已完成\n                No  → (無操作)\n→ Step 9: 把 digits 重新組成整數結果 // 將陣列轉回數字\n→ End // 程式結束\n```\n\nWe need each line to have `虛擬碼步驟 // 解釋`. Also we need to include arrows. The indentation with spaces may not matter but we show hierarchical.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 num 轉為字元陣列 digits // 取得每個數字  \n→ Step 2: 設定 n = digits 長度 // 準備迴圈  \n→ Step 3: 進行外層迴圈 i 從 0 到 n-1 // 檢查每個位置  \n  → Decision: 是否已完成交換? // 檢查是否已交換一次  \n   Yes → End // 已交換，結束程式  \n   No →  \n    → Step 4: 設定 max_digit = -1, max_index = -1 // 用於尋找右側最大數字  \n    → Step 5: 進行內層迴圈 j 從 n-1 到 i+1 步進 -1 // 從右往左搜尋  \n      → Decision: digits[j] > max_digit? // 判斷是否為更大數字  \n       Yes → Step 6: max_digit = digits[j], max_index = j // 更新最大值及其位置  \n       No → (無操作)  \n    → Decision: max_digit > digits[i]? // 是否需要交換  \n      Yes →  \n       → Step 7: 交換 digits[i] 與 digits[max_index] // 執行一次交換  \n       → Step 8: 已交換 = True // 標記已完成  \n      No → (無操作)  \n→ Step 9: 把 digits 重新組成整數結果 // 將陣列轉回數字  \n→ End // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef maximumSwap(num: int) -> int:\n    \"\"\"\n    找出最多一次交換兩位數字後能得到的最大整數。\n    \"\"\"\n    digits = list(str(num))\n    # 建立每個數字最後一次出現的位置\n    last = {int(x): i for i, x in enumerate(digits)}\n\n    for i, x in enumerate(digits):\n        # 從 9 到目前數字 x+1 之間尋找是否存在更大的數字\n        for d in range(9, int(x), -1):\n            if d in last and last[d] > i:\n                # 執行一次交換\n                digits[i], digits[last[d]] = digits[last[d]], digits[i]\n                return int(\"\".join(digits))\n    # 若無法交換，直接回傳原值\n    return int(\"\".join(digits))\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，解析出數字，計算最大交換後的數字並輸出。\n    支援輸入形式：\n        2736\n        num = 2736\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 取出第一個連續的數字字串\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n\n    num = int(nums[0])\n    result = maximumSwap(num)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 2736",
          "expected_output": "7236",
          "success": true,
          "output": "7236"
        },
        {
          "example_index": 1,
          "input": "num = 9973",
          "expected_output": "9973",
          "success": true,
          "output": "9973"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode303.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Immutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following type:\n\nCalculate the sum of th...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step: Start, constructor, sumRange method, using prefix sum approach. Provide each line with explanation. Use arrows. Use virtual steps: Start, define class, initialize, compute prefix sums, etc.\n\nWe must not output actual code, just pseudo-code with arrows and explanation. Use \"Start\", \"End\". For decisions, use Decision: If left > right? maybe not necessary. But we might show validation.\n\nLet's produce stepwise:\n\nStart\n→ Step 1: 定義 NumArray 類別 // 開始定義類別\n→ Step 2: 宣告 變數 prefix // 儲存前綴和\n→ Decision: 檢查 nums 是否為 null? // 若為 null 初始化為空陣列\n    Yes → Step 3: prefix ← 空陣列 // 若 null，prefix 為空\n    No  → Step 4: 產生 prefix 陣列長度為 nums.length+1 // 建立前綴和陣列\n        → Step 5: prefix[0] ← 0 // 前綴和起始值\n        → Step 6: 循環 i 從 1 到 nums.length\n            → Step 7: prefix[i] ← prefix[i-1] + nums[i-1] // 計算前綴和\n→ End // 建構完成\n→ Step 8: 定義 sumRange 方法 // 方法開始\n→ Decision: 檢查 left, right 是否在合法範圍? // 位置檢查\n    Yes → Step 9: sum ← prefix[right+1] - prefix[left] // 前綴和差得到區間和\n    No  → Step 10: sum ← 0 // 若無效索引，回傳 0\n→ Step 11: 回傳 sum // 結果\nEnd // 程式結束\n\nMake sure each line ends with // 解釋. Use virtual code arrow and indentation? The sample uses arrows. Let's format similar to sample:\n\nStart // 程式開始執行\n→ Step 1: 定義 NumArray 類別 // 開始定義類別\n→ Step 2: 宣告 變數 prefix // 儲存前綴和\n→ Decision: 如果 nums 為 null? // 檢查輸入陣列是否為 null\n    Yes → Step 3: prefix ← 空陣列 // 若為 null，前綴和為空\n    No  → Step 4: prefix ← 新陣列長度 nums.length + 1 // 建立前綴和陣列\n        → Step 5: prefix[0] ← 0 // 前綴和起始值\n        → Step 6: 循環 i 從 1 到 nums.length\n            → Step 7: prefix[i] ← prefix[i-1] + nums[i-1] // 計算前綴和\n→ End // 建構完成\n→ Step 8: 定義 sumRange 方法 // 方法開始\n→ Decision: left, right 是否有效? // 檢查索引合法性\n    Yes → Step 9: sum ← prefix[right+1] - prefix[left] // 取得區間和\n    No  → Step 10: sum ← 0 // 無效索引回傳 0\n→ Step 11: 回傳 sum // 結果\nEnd // 程式結束\n\nNeed to ensure each line has 虛擬碼步驟 + space + // 解釋. Use arrow arrow. For nested steps, indent. Use sample style: \"→ Decision:\" with Yes/No arrows. Good.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 NumArray 類別 // 開始定義類別  \n→ Step 2: 宣告 變數 prefix // 用於儲存前綴和  \n→ Decision: 如果 nums 為 null? // 檢查輸入陣列是否為 null  \n  Yes → Step 3: prefix ← 空陣列 // 若為 null，前綴和為空  \n  No  → Step 4: prefix ← 新陣列長度 nums.length + 1 // 建立前綴和陣列  \n    → Step 5: prefix[0] ← 0 // 前綴和起始值為 0  \n    → Step 6: 循環 i 從 1 到 nums.length  \n      → Step 7: prefix[i] ← prefix[i-1] + nums[i-1] // 計算前綴和  \n→ End // 建構完成  \n→ Step 8: 定義 sumRange 方法 // 方法開始  \n→ Decision: left, right 是否有效? // 檢查索引合法性  \n  Yes → Step 9: sum ← prefix[right+1] - prefix[left] // 取得區間和  \n  No  → Step 10: sum ← 0 // 無效索引回傳 0  \n→ Step 11: 回傳 sum // 結果  \nEnd // 程式結束",
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 分離兩個 JSON 陣列\n    first_bracket_end = data.find(']')\n    ops_str = data[:first_bracket_end+1]\n    args_str = data[first_bracket_end+2:].strip()  # 跳過逗號與空格\n\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            obj = NumArray(arg[0]) if isinstance(arg, list) else NumArray(arg)\n            results.append(None)  # null\n        elif op == \"sumRange\":\n            if obj is not None:\n                res = obj.sumRange(arg[0], arg[1])\n                results.append(res)\n            else:\n                results.append(None)\n        else:\n            results.append(None)\n\n    # 輸出 JSON 陣列，None 會轉為 null\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "success": true,
          "output": "[null, 1, -1, -3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode80.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array II",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce step-by-step pseudocode for removing duplicates with at most two occurrences, in-place, O(1) memory. Provide each line with explanation. Use virtual code arrows.\n\nWe need to output in Chinese, with explanations.\n\nLet's craft:\n\nStart\n→ Initialize write pointer w = 0 // pointer to position to write next allowed element\n→ Initialize count = 0 // current count of same element being processed\n→ Initialize prev = None // previous element value\n→ Decision: 遍歷 nums? // iterate over each element in array\n    For each num in nums:\n        Decision: 如果 num == prev? // same as previous?\n            Yes → count = count + 1 // increment count\n            No  → prev = num ; count = 1 // new element encountered\n        Decision: count <= 2? // allow at most two occurrences\n            Yes → nums[w] = num ; w = w + 1 // write to array\n            No  → // skip writing, ignore this occurrence\nEnd // return w as k\n\nBut we need line-by-line structure with arrows. Use decision structure with Yes and No lines indented.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: Set write = 0 // 用於寫入允許的元素位置\n→ Step 2: Set count = 0 // 當前元素重複計數\n→ Step 3: Set prev = None // 前一個元素值\n→ Step 4: For each num in nums: // 遍歷整個陣列\n    → Decision: num == prev? // 是否與前一個相同\n        Yes → count = count + 1 // 重複計數加一\n        No  → prev = num ; count = 1 // 重新開始計數\n    → Decision: count <= 2? // 是否允許寫入\n        Yes → nums[write] = num ; write = write + 1 // 寫入並遞增寫指標\n        No  → // 忽略此重複元素\nEnd // 程式結束，write 為 k\n\nBut we need each line with arrow and explanation. Use '→' for steps, 'Decision:' for decision. For For loop we can treat as Step with arrow then substeps.\n\nBetter to structure:\n\n→ Step 4: 遍歷 nums 中每個元素 num // start loop\n    → Decision: num == prev? // 判斷是否與前一個元素相同\n        Yes → count = count + 1 // 更新重複計數\n        No  → prev = num ; count = 1 // 設定新元素並重設計數\n    → Decision: count <= 2? // 判斷是否允許寫入\n        Yes → nums[write] = num ; write = write + 1 // 寫入\n        No  → // 不寫入，直接跳過\n\nNeed to include 'End' after loop.\n\nBut we also need to handle initialization of write, count, prev. That's fine.\n\nLet's produce final answer in proper format.\n\nEnsure each line is:\n\n虛擬碼步驟 [space] // 解釋\n\nAlso maintain indentation inside decision.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: write ← 0 // 用於寫入允許的元素位置\n→ Step 2: count ← 0 // 當前相同元素的重複計數\n→ Step 3: prev ← None // 前一個元素的值\n→ Step 4: For each num in nums: // 遍歷整個陣列\n    → Decision: num == prev? // 判斷是否與前一個元素相同\n        Yes → count ← count + 1 // 重複計數加一\n        No  → prev ← num ; count ← 1 // 設定新元素並重設計數\n    → Decision: count <= 2? // 判斷是否允許寫入\n        Yes → nums[write] ← num ; write ← write + 1 // 寫入並遞增寫指標\n        No  → // 忽略此重複元素，直接跳過\nEnd // 程式結束，write 為 k（保留元素數量）",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        移除 sorted 數組中重複出現的元素，允許每個元素最多出現兩次。\n        輸入: nums (list[int])，已經升序排序\n        返回: int, 最終保留元素的個數 k\n        \"\"\"\n        if not nums:\n            return 0\n        write = 1          # 下一個寫入位置\n        count = 1          # 同一個元素目前的重複次數\n        prev = nums[0]     # 前一個元素的值\n\n        for i in range(1, len(nums)):\n            num = nums[i]\n            if num == prev:\n                count += 1\n            else:\n                prev = num\n                count = 1\n\n            if count <= 2:          # 只允許最多兩個\n                nums[write] = num\n                write += 1\n\n        return write\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，找出列表部分\n    match = re.search(r'\\[.*?\\]', data)\n    if not match:\n        raise ValueError(\"輸入格式錯誤，找不到列表\")\n    nums = ast.literal_eval(match.group(0))\n\n    # 執行解法\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n\n    # 補齊剩餘位置以便輸出與範例一致\n    remaining = ['_'] * (len(nums) - k)\n    full = nums[:k] + remaining\n\n    # 以符合範例的格式輸出\n    print(f\"{k}, nums = [{', '.join(str(x) for x in full)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "success": true,
          "output": "5, nums = [1, 1, 2, 2, 3, _]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "expected_output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "success": true,
          "output": "7, nums = [0, 0, 1, 1, 2, 3, 3, _, _]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode29.json",
    "problem_index_in_file": 0,
    "title": "Divide Two Integers",
    "description_snippet": "Given two integers dividend and divisor, divide two integers without using multiplication, division,...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Provide algorithm for division using bit manipulation subtraction. Steps: handle edge cases: dividend == INT_MIN, divisor == -1 produce overflow. Convert to long long or 64-bit by absolute values using negative domain to avoid overflow. Use bit shift doubling method. Count quotient bits. Finally apply sign and clamp to INT range. Provide explanation per line.\n\nWe must adhere to output format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc. Use arrows.\n\nWe must avoid actual code, only virtual steps.\n\nLet's craft.\n\nStart\n→ Step 1: 定義 INT_MIN, INT_MAX // 設定 32 位整數極限\n→ Decision: 如果 dividend == INT_MIN 與 divisor == -1? // 檢查溢出情況\n    Yes → Step 2: 返回 INT_MAX // 超出上限時回傳最大值\n    No  → Step 3: 進行常規除法 // 其他情況\n→ Step 4: 計算正負符號 // 判斷結果符號\n    Set negative = (dividend < 0) XOR (divisor < 0)\n→ Step 5: 取得絕對值的負數形式 // 為了避免 overflow\n    dividendNeg = dividend < 0 ? dividend : -dividend\n    divisorNeg = divisor < 0 ? divisor : -divisor\n→ Step 6: 初始化 quotient = 0 // 結果\n→ Step 7: Decision: 如果 divisorNeg == 0? // 檢查除以零\n    Yes → Step 8: 返回 INT_MAX // 或處理錯誤\n    No  → Continue\n→ Step 9: 循環從最高位開始檢查 // 位移方法\n    For i from 31 downto 0:\n        Decision: 如果 (divisorNeg << i) ≥ dividendNeg? // 可被減\n            Yes → Step 10: dividendNeg -= divisorNeg << i // 減去\n                    Step 11: quotient |= 1 << i // 設置位\n→ Step 12: 依符號調整 quotient\n    If negative → quotient = -quotient\n→ Step 13: Decision: 如果 quotient > INT_MAX? // 限制上界\n    Yes → Step 14: 返回 INT_MAX\n    No  → Decision: quotient < INT_MIN? // 下界\n        Yes → Step 15: 返回 INT_MIN\n        No  → Step 16: 返回 quotient\nEnd\n\nNeed to follow the arrow syntax. Use \"Decision:\" lines and indent Yes/No.\n\nAlso ensure no actual code, just words. We'll use Chinese.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 INT_MIN = -2^31, INT_MAX = 2^31-1 // 定義 32 位整數極限  \n→ Decision: 如果 dividend == INT_MIN 且 divisor == -1? // 檢查可能的溢出情況  \n    Yes → Step 2: 返回 INT_MAX // 直接回傳最大值避免超出範圍  \n    No  → Step 3: 進行正常除法流程 // 其他所有情況  \n→ Step 4: 計算結果符號 // 判斷正負號  \n    Set negative = (dividend < 0) XOR (divisor < 0) // 只有一個負數時為負  \n→ Step 5: 將兩數轉成負數的絕對值 // 以負數形式避免 INT_MIN 的正值溢出  \n    dividendNeg = dividend < 0 ? dividend : -dividend  \n    divisorNeg  = divisor < 0 ? divisor : -divisor  \n→ Step 6: 初始化 quotient = 0 // 儲存最終商  \n→ Step 7: Decision: 如果 divisorNeg == 0? // 防止除以零  \n    Yes → Step 8: 返回 INT_MAX // 可自訂錯誤處理方式  \n    No  → 進入位移循環  \n→ Step 9: 從最高位 31 到 0 逐位檢查  \n    For i from 31 downto 0:  \n        Decision: 如果 (divisorNeg << i) >= dividendNeg? // 能完整減去的判斷  \n            Yes → Step 10: dividendNeg -= divisorNeg << i // 減去相應倍數  \n                    Step 11: quotient |= 1 << i // 設置商的第 i 位  \n→ Step 12: 依符號調整商的正負  \n    If negative → quotient = -quotient  \n→ Step 13: Decision: 如果 quotient > INT_MAX? // 上限檢查  \n    Yes → Step 14: 返回 INT_MAX  \n    No  → Decision: quotient < INT_MIN? // 下限檢查  \n        Yes → Step 15: 返回 INT_MIN  \n        No  → Step 16: 返回 quotient  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        INT_MIN, INT_MAX = -2**31, 2**31 - 1\n\n        # Handle division by zero\n        if divisor == 0:\n            return INT_MAX\n\n        # Handle overflow case\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n\n        negative = (dividend < 0) != (divisor < 0)\n\n        a, b = abs(dividend), abs(divisor)\n        quotient = 0\n\n        # Use bit shifting to perform division\n        while a >= b:\n            temp, multiple = b, 1\n            while a >= (temp << 1):\n                temp <<= 1\n                multiple <<= 1\n            a -= temp\n            quotient += multiple\n\n        if negative:\n            quotient = -quotient\n\n        # Clamp to 32‑bit signed integer range\n        if quotient < INT_MIN:\n            return INT_MIN\n        if quotient > INT_MAX:\n            return INT_MAX\n        return quotient\n\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read()\n\n    # Extract all integers from the input (handles formats like \"dividend = 10, divisor = 3\")\n    numbers = re.findall(r'[-]?\\d+', data)\n\n    if len(numbers) >= 2:\n        dividend, divisor = int(numbers[0]), int(numbers[1])\n    else:\n        # Fallback: assume input is two space‑separated numbers\n        parts = data.strip().split()\n        dividend, divisor = int(parts[0]), int(parts[1])\n\n    solution = Solution()\n    result = solution.divide(dividend, divisor)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "dividend = 10, divisor = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "dividend = 7, divisor = -3",
          "expected_output": "-2",
          "success": true,
          "output": "-2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode290.json",
    "problem_index_in_file": 0,
    "title": "Word Pattern",
    "description_snippet": "Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match,...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps for solving the problem: pattern match bijection. Should produce a virtual code flow with arrows, Start, Decision, etc. Each line has code step and comment.\n\nWe need to produce step-by-step algorithm: probably split s into words array. Check lengths equal to pattern length. Use two hash maps: charToWord, wordToChar. Iterate over pattern indices, get current letter and word. If letter not in map: check word not in wordToChar, then add mapping. Else if mapping exists: check matches. At end return true else false. Need virtual code.\n\nLet's produce lines:\n\nStart\n→ Step 1: Split s by space into words array // 得到單字列表\n→ Decision: If words.length != pattern.length? // 檢查長度是否相同\n    Yes → Step 2: Return false // 長度不符，無法匹配\n    No  → Step 3: Initialize charToWord map // 建立字母→單字對照表\n    → Step 4: Initialize wordToChar map // 建立單字→字母對照表\n→ Step 5: For i from 0 to pattern.length-1 // 遍歷每個字母\n    → Decision: Is pattern[i] in charToWord? // 檢查字母是否已映射\n        Yes → Decision: charToWord[pattern[i]] == words[i]? // 匹配單字\n            Yes → Step 6: Continue // 正確匹配，繼續\n            No  → Step 7: Return false // 匹配失敗，返回 false\n        No  → Decision: words[i] in wordToChar? // 檢查單字是否已被其他字母映射\n            Yes → Step 8: Return false // 同一單字已被映射，返回 false\n            No  → Step 9: charToWord[pattern[i]] = words[i] // 建立字母→單字映射\n            → Step 10: wordToChar[words[i]] = pattern[i] // 建立單字→字母映射\n→ Step 11: Return true // 所有字母都成功映射，返回 true\nEnd\n\nAdd comments after each line.\n\nWe must ensure \"逐行\" output, each line contains step + comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Split s by space into words array // 將輸入字串切割成單字列表\n→ Decision: 如果 words.length ≠ pattern.length? // 檢查單字數量是否與模式長度一致\n    Yes → Step 2: Return false // 長度不符，直接返回不符合\n    No  → Step 3: Initialize charToWord map // 建立字母 → 單字 的映射表\n    → Step 4: Initialize wordToChar map // 建立單字 → 字母 的映射表\n→ Step 5: For i from 0 to pattern.length - 1 // 循環遍歷每個模式字母\n    → Decision: 是否已在 charToWord 中存在 pattern[i]? // 判斷字母是否已經映射\n        Yes → Decision: charToWord[pattern[i]] ≠ words[i]? // 若已映射，檢查映射是否正確\n            Yes → Step 6: Return false // 映射不一致，返回不符合\n            No  → Step 7: Continue // 映射正確，繼續下一個字母\n        No  → Decision: words[i] 是否已在 wordToChar 中存在? // 檢查單字是否被其他字母映射\n            Yes → Step 8: Return false // 同一單字已被映射，返回不符合\n            No  → Step 9: charToWord[pattern[i]] = words[i] // 建立字母 → 單字 的映射\n            → Step 10: wordToChar[words[i]] = pattern[i] // 建立單字 → 字母 的映射\n→ Step 11: Return true // 所有字母都成功映射，返回符合\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        \"\"\"\n        檢查字串 s 是否符合 pattern 的單字對應規則。\n        \"\"\"\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n\n        char_to_word = {}\n        word_to_char = {}\n\n        for c, w in zip(pattern, words):\n            # 字母已經映射，檢查映射是否相同\n            if c in char_to_word:\n                if char_to_word[c] != w:\n                    return False\n            else:\n                char_to_word[c] = w\n\n            # 單字已經映射，檢查映射是否相同\n            if w in word_to_char:\n                if word_to_char[w] != c:\n                    return False\n            else:\n                word_to_char[w] = c\n\n        return True\n\ndef parse_input(raw: str):\n    \"\"\"\n    從輸入字串中抽取 pattern 與 s。\n    期望格式：pattern = \"abba\", s = \"dog cat cat dog\"\n    \"\"\"\n    pattern_match = re.search(r'pattern\\s*=\\s*\"([^\"]+)\"', raw)\n    s_match = re.search(r's\\s*=\\s*\"([^\"]+)\"', raw)\n    if not pattern_match or not s_match:\n        raise ValueError(\"輸入格式不正確\")\n    return pattern_match.group(1), s_match.group(1)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    pattern, s = parse_input(raw_input)\n    sol = Solution()\n    result = sol.wordPattern(pattern, s)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "pattern = \"abba\", s = \"dog cat cat fish\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "pattern = \"aaaa\", s = \"dog cat cat dog\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode581.json",
    "problem_index_in_file": 0,
    "title": "Shortest Unsorted Continuous Subarray",
    "description_snippet": "Given an integer array nums, you need to find one continuous subarray such that if you only sort thi...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm. Problem: find shortest subarray which if sorted, whole array sorted. Classic Leetcode 581. Approach: find left boundary where element > next, and right boundary where element < prev. Compute min and max of that subarray then expand left and right to include any elements that are out of range. Output length. We need step-by-step virtual code with explanation after each line. Use structure Start, End, Decision, etc.\n\nWe need to produce step lines: Start, Step 1: Input array, Step 2: Initialize n, left = -1, right = -1, etc.\n\nLet's craft. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Use decisions for loop etc.\n\nWe need to produce lines as per format: \"虛擬碼步驟 [space] // 解釋\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 獲取陣列長度 n // 取得 nums 的長度\n→ Step 2: 設定 left = -1, right = -1 // 初始化最左、最右邊界\n→ Step 3: 從 i = 0 到 n-2 做:\n    → Decision: 如果 nums[i] > nums[i+1]? // 發現下降點\n        Yes → left = i // 設左邊界為 i\n        No  → 無操作\n→ Step 4: 從 i = n-1 到 1 做:\n    → Decision: 如果 nums[i] < nums[i-1]? // 發現上升點逆向\n        Yes → right = i // 設右邊界為 i\n        No  → 無操作\n→ Decision: 如果 left == -1? // 整個陣列已排序\n    Yes → Step 5: 返回 0 // 無需排序\n    No  → 無操作\n→ Step 6: 計算 subMin = min(nums[left..right]) // 找子陣列最小值\n→ Step 7: 計算 subMax = max(nums[left..right]) // 找子陣列最大值\n→ Step 8: 從 i = 0 到 left-1 做:\n    → Decision: 如果 nums[i] > subMin? // 需要擴左邊界\n        Yes → left = i\n        No  → 無操作\n→ Step 9: 從 i = right+1 到 n-1 做:\n    → Decision: 如果 nums[i] < subMax? // 需要擴右邊界\n        Yes → right = i\n        No  → 無操作\n→ Step 10: 計算 length = right - left + 1 // 子陣列長度\n→ Step 11: 返回 length // 結果輸出\nEnd // 程式執行結束\n\nNeed to ensure format with arrow lines. Use indentation? We can use line for decisions with indented steps? The example shows indentation. Let's replicate but with simple lines, each line preceded by arrow.\n\nWe need to keep the arrow symbol for each step: \"→ Step ...\". For decisions we use \"→ Decision: ...\". For substeps under decision we can indent? The example uses indentation inside decisions but we can just output separate lines starting with \"→\" and indent with spaces. Let's keep same.\n\nWe must not output actual code but virtual steps. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 獲取陣列長度 n // 取得 nums 的長度\n→ Step 2: 設定 left = -1, right = -1 // 初始化最左、最右邊界\n→ Step 3: 從 i = 0 到 n-2 做:\n → Decision: 如果 nums[i] > nums[i+1]? // 發現下降點\n  Yes → left = i // 設左邊界為 i\n  No  → 無操作\n→ Step 4: 從 i = n-1 到 1 做:\n → Decision: 如果 nums[i] < nums[i-1]? // 發現上升點逆向\n  Yes → right = i // 設右邊界為 i\n  No  → 無操作\n→ Decision: 如果 left == -1? // 整個陣列已排序\n Yes → Step 5: 返回 0 // 無需排序\n No  → 無操作\n→ Step 6: 計算 subMin = min(nums[left..right]) // 找子陣列最小值\n→ Step 7: 計算 subMax = max(nums[left..right]) // 找子陣列最大值\n→ Step 8: 從 i = 0 到 left-1 做:\n → Decision: 如果 nums[i] > subMin? // 需要擴左邊界\n  Yes → left = i\n  No  → 無操作\n→ Step 9: 從 i = right+1 到 n-1 做:\n → Decision: 如果 nums[i] < subMax? // 需要擴右邊界\n  Yes → right = i\n  No  → 無操作\n→ Step 10: 計算 length = right - left + 1 // 子陣列長度\n→ Step 11: 返回 length // 結果輸出\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findUnsortedSubarray(self, nums):\n        n = len(nums)\n        left, right = -1, -1\n\n        # 找到第一個下降點作為左邊界\n        for i in range(n - 1):\n            if nums[i] > nums[i + 1]:\n                left = i\n                break\n\n        # 找到第一個上升點（逆向）作為右邊界\n        for i in range(n - 1, 0, -1):\n            if nums[i] < nums[i - 1]:\n                right = i\n                break\n\n        # 若已排序，直接回傳 0\n        if left == -1:\n            return 0\n\n        sub_min = min(nums[left:right + 1])\n        sub_max = max(nums[left:right + 1])\n\n        # 擴展左邊界\n        while left > 0 and nums[left - 1] > sub_min:\n            left -= 1\n\n        # 擴展右邊界\n        while right < n - 1 and nums[right + 1] < sub_max:\n            right += 1\n\n        return right - left + 1\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入，例如 \"nums = [2,6,4,8,10,9,15]\"\n    try:\n        # 如果輸入中有等號，取等號右側的字串\n        if '=' in data:\n            _, array_str = data.split('=', 1)\n        else:\n            array_str = data\n        array_str = array_str.strip()\n        nums = ast.literal_eval(array_str)\n        if not isinstance(nums, list):\n            raise ValueError\n    except Exception:\n        # 如果解析失敗，直接輸出 0\n        print(0)\n        sys.exit(0)\n\n    solution = Solution()\n    result = solution.findUnsortedSubarray(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,6,4,8,10,9,15]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode400.json",
    "problem_index_in_file": 0,
    "title": "Nth Digit",
    "description_snippet": "Given an integer n, return the n^th digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with arrow and explanation. Problem: find nth digit in concatenated sequence of natural numbers. Approach: Determine which number contains nth digit. Iterate length of numbers by digit length: 1-digit numbers count=9, 2-digit=90, etc. Compute cumulative digits until reaching block that contains nth. Then find exact number and digit offset.\n\nPseudocode steps: Start, input n, set digitLen=1, startNum=1, digitsInBlock = 9 * digitLen, while n > digitsInBlock: subtract, increase digitLen, startNum += 9*prevLen? Actually startNum=10^(digitLen-1). Compute count numbers in block: 9 * 10^(digitLen-1). digitsInBlock = count * digitLen. Subtract until n <= digitsInBlock.\n\nThen numberIndex = (n-1) / digitLen (0-index). actualNumber = startNum + numberIndex. digitIndex = (n-1) % digitLen. Convert actualNumber to string, get char at digitIndex. Return digit.\n\nWrite each step line. Use arrow.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 從使用者取得要查詢的第 n 個數位  \n→ Step 2: 設定 digitLen = 1 // 先考慮 1 位數  \n→ Step 3: 設定 startNum = 1 // 1 位數的起始值  \n→ Decision: n 是否大於 9 * digitLen? // 判斷 n 是否已超過目前位數區塊的總數位  \n    Yes → Step 4: n ← n - 9 * digitLen // 移除已處理的位數  \n    Yes → Step 5: digitLen ← digitLen + 1 // 進入下一個位數區塊  \n    Yes → Step 6: startNum ← 10^(digitLen-1) // 計算該區塊起始數值  \n    Yes → Goto Decision: n 是否大於 9 * digitLen? // 重新檢查是否還需跳到更高位數  \n    No  → Step 7: numberCount ← 9 * 10^(digitLen-1) // 該區塊內的數字個數  \n    No  → Step 8: numberIndex ← (n-1) / digitLen // 位於該區塊的第 numberIndex 個數字（0 起始）  \n    No  → Step 9: actualNumber ← startNum + numberIndex // 找到實際的數字  \n    No  → Step 10: digitIndex ← (n-1) % digitLen // 需要取出的位數索引（0 起始）  \n    No  → Step 11: resultDigit ← 字符串(actualNumber)[digitIndex] // 把數字轉成字串並取指定位數  \n    No  → Step 12: 輸出 resultDigit // 顯示第 n 個數位  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef find_nth_digit(n: int) -> int:\n    \"\"\"\n    找到無限整數序列 [1, 2, 3, …] 的第 n 個數位。\n    \"\"\"\n    digit_len = 1            # 數字的位數\n    count = 9                # 目前位數的數字個數（1 位有 9 個，2 位有 90 個，以此類推）\n    start = 1                # 目前位數的起始數字\n\n    # 先把 n 從「整個序列」對應到「某個位數區塊」。\n    while n > digit_len * count:\n        n -= digit_len * count\n        digit_len += 1\n        count *= 10\n        start *= 10\n\n    # 在該區塊中，找到真正的數字。\n    start += (n - 1) // digit_len\n    s = str(start)\n\n    # 從該數字取出正確的位數。\n    return int(s[(n - 1) % digit_len])\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並從中擷取第一個整數作為 n。\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        raise ValueError(\"輸入中未找到數字\")\n    n = int(match.group())\n\n    result = find_nth_digit(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 11",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode769.json",
    "problem_index_in_file": 0,
    "title": "Max Chunks To Make Sorted",
    "description_snippet": "You are given an integer array arr of length n that represents a permutation of the integers in the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps. The task: largest number of chunks to sort array to sorted order. Known problem \"Maximum Chunks To Make Sorted II\". Approach: maintain max of left side and min of right side. When max_left <= min_right, can split. Or use hash map counting differences. We'll produce steps. Provide virtual code. Let's craft step by step.\n\nWe need array arr. We'll produce pseudocode. Steps:\n\nStart\n→ Step 1: Initialize n = length(arr)\n→ Step 2: Create array min_right of length n\n→ Step 3: Set current_min = +∞\n→ Step 4: Iterate i from n-1 down to 0: current_min = min(current_min, arr[i]); min_right[i] = current_min\n→ Step 5: Initialize max_left = -∞; chunks = 0\n→ Step 6: Iterate i from 0 to n-1: max_left = max(max_left, arr[i]); if max_left <= min_right[i] then chunks++ \n→ End\n\nLet's produce with comments.\n\nAlso we need to handle the input array being permutation 0..n-1, but we can ignore. Provide explanation.\n\nWe'll output each line with arrow and comment.\n\nMake sure each line includes virtual code step and explanation separated by space. Use arrow \"→\" before step. Provide indentation for decision? There's no decision branch here besides if.\n\nWe'll include maybe a Decision line: \"Decision: max_left <= min_right[i]?\" then Yes → increment.\n\nBut simpler: combine.\n\nBut example used Decision: ... Yes →. Let's include Decision for clarity.\n\nSo lines:\n\nStart // 程式開始執行\n→ Step 1: n ← length(arr) // 取得陣列長度\n→ Step 2: min_right ← new array of size n // 用於儲存每個位置右邊最小值\n→ Step 3: current_min ← +∞ // 初始化右邊最小值\n→ Decision: i從 n-1 下降到 0? // 反向掃描陣列\n    Yes → Step 4: current_min ← min(current_min, arr[i]) // 更新右邊最小值\n    Yes → Step 5: min_right[i] ← current_min // 記錄在此位置的右邊最小值\n    No → // 迴圈結束\n→ Step 6: max_left ← -∞ // 初始化左邊最大值\n→ Step 7: chunks ← 0 // 片段計數\n→ Decision: i從 0 增加到 n-1? // 正向掃描陣列\n    Yes → Step 8: max_left ← max(max_left, arr[i]) // 更新左邊最大值\n    Yes → Decision: max_left ≤ min_right[i]? // 是否可切分\n        Yes → Step 9: chunks ← chunks + 1 // 可以切分，計數加一\n        No  → // 不能切分\n    No → // 迴圈結束\n→ End // 回傳 chunks\n\nBut we need to output code only, no actual programming language. Use arrow lines.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(arr) // 取得陣列長度  \n→ Step 2: min_right ← new array of size n // 用於儲存每個位置右邊最小值  \n→ Step 3: current_min ← +∞ // 初始化右邊最小值  \n→ Decision: i從 n-1 下降到 0? // 反向掃描陣列  \n Yes → Step 4: current_min ← min(current_min, arr[i]) // 更新右邊最小值  \n Yes → Step 5: min_right[i] ← current_min // 記錄在此位置的右邊最小值  \n No  → // 迴圈結束  \n→ Step 6: max_left ← -∞ // 初始化左邊最大值  \n→ Step 7: chunks ← 0 // 片段計數  \n→ Decision: i從 0 增加到 n-1? // 正向掃描陣列  \n Yes → Step 8: max_left ← max(max_left, arr[i]) // 更新左邊最大值  \n Yes → Decision: max_left ≤ min_right[i]? // 是否可切分  \n  Yes → Step 9: chunks ← chunks + 1 // 可以切分，計數加一  \n  No  → // 不能切分  \n No  → // 迴圈結束  \n→ End // 回傳 chunks 取得最大的分塊數量",
      "generated_code": "import sys\nimport ast\n\ndef max_chunks(arr):\n    \"\"\"\n    計算可以分割成的最大塊數。  \n    由於 arr 是 0~n-1 的排列，當左邊最大值等於當前索引 i 時，表示\n    0~i 的所有元素都已經在左邊，左邊可以切分成一個塊。\n    \"\"\"\n    chunks = 0\n    left_max = -1\n    for i, val in enumerate(arr):\n        left_max = max(left_max, val)\n        if left_max == i:\n            chunks += 1\n    return chunks\n\ndef parse_input(data):\n    \"\"\"\n    從輸入字串解析出陣列。支援以下兩種格式：\n      1. 直接寫成 list，例如 [4,3,2,1,0]\n      2. 前面有 'arr ='，例如 arr = [4,3,2,1,0]\n    \"\"\"\n    s = data.strip()\n    if not s:\n        return []\n    # 若有 '='，去掉左側的變數名稱\n    if '=' in s:\n        _, rest = s.split('=', 1)\n        s = rest.strip()\n    try:\n        arr = ast.literal_eval(s)\n    except Exception:\n        # 如果 literal_eval 失敗，改用 eval（此處假設輸入安全）\n        arr = eval(s)\n    return arr if isinstance(arr, list) else [arr]\n\ndef main():\n    input_data = sys.stdin.read()\n    arr = parse_input(input_data)\n    result = max_chunks(arr)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [4,3,2,1,0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "arr = [1,0,2,3,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode504.json",
    "problem_index_in_file": 0,
    "title": "Base 7",
    "description_snippet": "Given an integer num, return a string of its base 7 representation....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for converting integer to base 7 string, with explanations. Use Start, Decision, etc. Steps: input integer num. If num==0 return \"0\". Else determine sign, work with abs(num). Build result string by repeatedly dividing by 7 and recording remainders. Then reverse string. If negative, prepend '-'. Return string. Provide step-by-step. Use virtual code syntax. Let's produce maybe 15-20 lines.\n\nUse indentation for decisions.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 num // 從使用者取得輸入值  \n→ Decision: 如果 num 等於 0? // 檢查是否為零  \n    Yes → Step 2: 輸出 \"0\" // 零的七進位是 \"0\"  \n    No  → Step 3: 判斷正負號並記錄 sign // 取得數字的符號  \n        → Step 4: num ← abs(num) // 取絕對值以便處理  \n→ Step 5: 初始化空字串 result // 用於存放七進位位數  \n→ Decision: 如果 num 大於 0? // 開始進行除以 7 的循環  \n    Yes → Step 6: 計算 remainder ← num mod 7 // 取餘數  \n        → Step 7: 把 remainder 轉為字符並追加到 result // 建立字串  \n        → Step 8: num ← num div 7 // 更新 num 為商  \n        → Step 9: 回到 Decision: 如果 num 大於 0? // 繼續循環  \n    No  → End of Loop // 完成除法循環  \n→ Step 10: 反轉 result // 因為從低位到高位追加，需反向  \n→ Decision: 如果 sign 為負? // 判斷是否需要負號  \n    Yes → Step 11: result ← \"-\" + result // 在前面加負號  \n    No  → Step 12: result 保持不變  \n→ Step 13: 輸出 result // 回傳七進位字串  \nEnd // 程式執行結束",
      "generated_code": "# -*- coding: utf-8 -*-\n\"\"\"\n將整數轉換為七進制的字串表示。\n\"\"\"\n\nclass Solution:\n    def convertToBase7(self, num: int) -> str:\n        \"\"\"\n        將給定的整數 num 轉換為七進制字串。\n\n        1. 如果 num 為 0，直接回傳 \"0\"。\n        2. 取得 num 的符號，並對 abs(num) 做除法循環。\n        3. 透過除以 7 的餘數得到各位數，最後將結果反轉。\n        4. 若原數為負，前面加上 '-'。\n        \"\"\"\n        if num == 0:\n            return \"0\"\n\n        # 記錄符號並取絕對值\n        negative = num < 0\n        num = abs(num)\n\n        # 用 list 儲存各位數的字元，最後再反轉\n        digits = []\n        while num > 0:\n            digits.append(str(num % 7))\n            num //= 7\n\n        if negative:\n            digits.append('-')\n\n        # 反轉後連接成字串\n        return ''.join(reversed(digits))\n\nif __name__ == \"__main__\":\n    import sys\n\n    # 從標準輸入讀取一個整數\n    data = sys.stdin.read().strip()\n    if data:\n        try:\n            num = int(data)\n        except ValueError:\n            # 如果輸入不是合法整數，直接終止\n            sys.exit(1)\n\n        result = Solution().convertToBase7(num)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "100",
          "expected_output": "\"202\"",
          "success": true,
          "output": "202"
        },
        {
          "example_index": 1,
          "input": "-7",
          "expected_output": "\"-10\"",
          "success": true,
          "output": "-10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode460.json",
    "problem_index_in_file": 0,
    "title": "LFU Cache",
    "description_snippet": "Design and implement a data structure for a Least Frequently Used (LFU) cache.\n\nImplement the LFUCac...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for LFU cache design. Provide steps line by line. Must not output actual code. Use structure Start, End, Decision etc. Need to explain each step. Should include initialization, get, put, eviction logic, freq lists, etc. Virtual code, not actual code, but show algorithm steps. Provide one line per step. Should be comprehensible. Use arrows. Provide explanation after //.\n\nWe need to outline algorithm: Use hashmap key->node, frequency->DLL of nodes. Use minFreq tracking. On get: if key not found return -1; else increment freq: remove from old freq list, add to new freq list; update node freq; update minFreq if needed; return value. On put: if capacity 0, return. If key exists: update value, same as get for freq. Else: if cache at capacity: find minFreq list, remove LRU node from that list, delete from key map. Insert new node with freq=1, add to freq list 1; update key map; set minFreq=1. Done.\n\nWe need to break into steps. Let's structure like: Start, Decision etc. Provide maybe substeps for get and put. Since it's virtual code, each line can be like \"→ Step: description\".\n\nWe need to use arrows. We can have nested decisions: e.g. Decision: key exists? Yes/No.\n\nOk produce step-by-step.\n\nWe should start with initialization: store capacity, create hashmap, freq map, minFreq.\n\nThen get: Check key exists, else return -1. If exists, call incrementFreq, return value.\n\nDefine incrementFreq: remove node from current freq list, add to next freq list, update node freq, if old freq list empty and freq==minFreq, increment minFreq.\n\nPut: If capacity==0, return. If key exists: update value, call incrementFreq. Else: if size==capacity: evict LRU from minFreq list: remove tail, delete key from hashmap. Then insert new node with freq=1, add to freq list 1, set minFreq=1.\n\nWe also need to maintain freq lists with order: use doubly linked list. We can just refer to operations: addNode, removeNode, popTail.\n\nOk produce each step line.\n\nUse \"Start\", \"End\".\n\nLet's produce.\n\nWe need to provide explanation after //.\n\nLet's start.\n\nWe'll produce maybe 30-40 lines.\n\nWe must ensure arrow usage.\n\nWe can have nested decisions like:\n\nDecision: capacity > 0? yes/no\n\nBut simpler: just describe steps.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 變數 init: capacity, keyMap, freqMap, minFreq ← 0 // 初始化容量與資料結構  \n→ Decision: 若 capacity 為 0? // 檢查是否能建立快取  \n    Yes → End // 失敗直接結束（容量為 0 的快取不作任何操作）  \n    No  → Continue  \n\n→ Step 2: keyMap ← 空字典 // key ↦ 節點  \n→ Step 3: freqMap ← 空字典 // freq ↦ 雙向鏈表 (LRU 順序)  \n→ Step 4: minFreq ← 0 // 目前最小使用頻率  \n\n// ==================== get 方法 ====================\n\n→ Step 5: get(key): // 取得鍵值  \n→ Decision: 若 key 不在 keyMap? // 檢查是否存在  \n    Yes → Step 6: return -1 // 未找到，回傳 -1  \n    No  → Continue  \n\n→ Step 7: node ← keyMap[key] // 取得節點  \n→ Step 8: node.value ← node.value // (保持不變，但用於說明)  \n→ Step 9: Call incrementFreq(node) // 更新頻率  \n→ Step 10: return node.value // 回傳值  \n\n// ==================== put 方法 ====================\n\n→ Step 11: put(key, value): // 新增或更新鍵值  \n→ Decision: 若 capacity 為 0? // 無法存儲任何項目  \n    Yes → End // 直接結束  \n    No  → Continue  \n\n→ Decision: 若 key 在 keyMap? // 已存在的鍵  \n    Yes → Step 12: keyMap[key].value ← value // 更新值  \n          → Call incrementFreq(keyMap[key]) // 更新頻率  \n          → End  \n    No  → Continue  \n\n→ Decision: 若 keyMap.size == capacity? // 容量已滿，需驅逐  \n    Yes → Step 13: list ← freqMap[minFreq] // 最小頻率的鏈表  \n          → Step 14: lruNode ← list.popTail() // 移除最舊節點  \n          → Step 15: Delete keyMap[lruNode.key] // 從 keyMap 刪除  \n          → Step 16: If list is empty → Delete freqMap[minFreq] // 清空空鏈表  \n          → End (驅逐完成)  \n    No  → End (不需要驅逐)  \n\n→ Step 17: newNode ← Node(key, value, freq=1) // 建立新節點  \n→ Step 18: If freqMap[1] 不存在 → freqMap[1] ← 新鏈表  \n→ Step 19: freqMap[1].addToHead(newNode) // 加到頻率 1 的頭部（最近使用）  \n→ Step 20: keyMap[key] ← newNode // 加入 keyMap  \n→ Step 21: minFreq ← 1 // 最小頻率重新設為 1  \n→ End // put 完成  \n\n// ==================== incrementFreq 方法 ====================\n\n→ Step 22: incrementFreq(node): // 將節點頻率加 1  \n→ Step 23: oldFreq ← node.freq  \n→ Step 24: newFreq ← oldFreq + 1  \n→ Step 25: node.freq ← newFreq // 更新節點頻率  \n\n→ Step 26: freqMap[oldFreq].remove(node) // 從舊頻率鏈表移除  \n→ Decision: 若 freqMap[oldFreq] 為空? // 若舊頻率鏈表已空  \n    Yes → Step 27: Delete freqMap[oldFreq] // 刪除空鏈表  \n          → Decision: 若 oldFreq == minFreq?  \n              Yes → Step 28: minFreq ← newFreq // minFreq 需升級  \n              No  → Continue  \n    No  → Continue  \n\n→ Step 29: If freqMap[newFreq] 不存在 → freqMap[newFreq] ← 新鏈表  \n→ Step 30: freqMap[newFreq].addToHead(node) // 加到新頻率鏈表頭部  \n→ End // incrementFreq 完成  \n\n// ==================== 資料結構說明 ====================\n\n→ Step 31: Node: key, value, freq, prev, next // 節點存儲鍵值、頻率及鏈表指針  \n→ Step 32: DoublyLinkedList: head, tail, addToHead(node), remove(node), popTail() // 典型雙向鏈表操作  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity          # 最大容量\n        self.min_freq = 0                 # 最小頻率\n        self.key_to_val_freq = {}         # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys (LRU order)\n\n    def _update(self, key: int) -> None:\n        \"\"\"將 key 的頻率加 1，並維持 min_freq 的正確性。\"\"\"\n        value, freq = self.key_to_val_freq[key]\n        # 從舊頻率字典移除\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # 加入新頻率字典\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # 更新值並提升頻率\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        # 若快取已滿，驅逐 LFU+LRU\n        if len(self.key_to_val_freq) >= self.capacity:\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # 新增項目，頻率為 1\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 分離兩個列表\n    parts = data.split('],', 1)\n    ops_part = parts[0] + ']'\n    args_part = '[' + parts[1]\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            obj = LFUCache(arg[0])\n            results.append(None)\n        elif op == \"put\":\n            obj.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            val = obj.get(arg[0])\n            results.append(val)\n        else:\n            results.append(None)\n\n    # 將 None 轉換成 null 以符合 LeetCode 輸出格式\n    print(str(results).replace(\"None\", \"null\"))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmponkti4eb.py\", line 60, in <module>\n    args = ast.literal_eval(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [ [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode241.json",
    "problem_index_in_file": 0,
    "title": "Different Ways to Add Parentheses",
    "description_snippet": "Given a string expression of numbers and operators, return all possible results from computing all t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code (pseudo steps) for computing all possible results from different parenthesizations of an arithmetic expression string. This is typical \"different ways to add parentheses\" problem. We need to produce step-by-step pseudo-code.\n\nWe need to produce virtual code line by line, each line with arrow and explanation. Must use Start, End, Decision, etc. Must not output actual code. Just virtual steps.\n\nWe must parse expression string into numbers and operators. Use recursion or DP: for each operator position split expression, compute left results recursively, right results recursively, combine.\n\nWe need to ensure output is within 10^4.\n\nThus pseudo-code lines:\n\nStart\n→ Step 1: Parse expression into list of tokens // split into numbers and operators\n→ Decision: If expression length == 1? // only number\n    Yes → Step 2: Return list containing that number // base case\n    No → Step 3: Initialize result list empty\n→ Step 4: For each operator index in tokens:\n    → Step 5: Split left tokens up to index-1 and right tokens index+1 onwards\n    → Step 6: Recursively compute left results\n    → Step 7: Recursively compute right results\n    → Step 8: For each l in left results:\n        → For each r in right results:\n            → Step 9: Compute l op r\n            → Step 10: Append to result list\n→ Step 11: Return result list\nEnd\n\nAlso maybe use memoization to avoid recomputation. We can include step to check memo dictionary.\n\nWe should include a decision for memo: check if subexpression already computed.\n\nAdd step for memo: Use map key string. If key in memo then return memo[key].\n\nAdd step to store computed results.\n\nLet's produce with arrows. Use '→' after Start, End.\n\nAdd indentation for nested loops? We can represent as arrow steps but nested decisions.\n\nWe need to produce in Chinese explanation after //.\n\nLet's produce.\n\nBe careful to keep each line single line. Use arrow and explanation.\n\nLet's write the virtual code.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空的記憶表 memo // 用來快取子表達式的結果  \n→ Decision: 如果輸入 expression 為空? // 檢查是否有輸入  \n Yes → Step 2: 回傳空列表 // 空表達式無結果  \n No  → Step 3: 將 expression 轉成 tokens (數字與運算子) // 方便後續分割  \n→ Decision: 若 tokens 僅包含一個數字? // 單一元素即為基礎情況  \n Yes → Step 4: 回傳 [該數字] // 基礎遞迴回傳  \n No  → Step 5: 取得 expression 作為 memo 的 key  \n  → Decision: 若 key 已存在於 memo?  \n   Yes → Step 6: 回傳 memo[key] // 直接回傳快取結果  \n   No  → Step 7: 初始化空結果列表 results  \n    → For each operator index i in tokens (i 指向運算子位置)  \n     → Step 8: 形成左子表達式 left_expr = tokens[0…i-1]  \n     → Step 9: 形成右子表達式 right_expr = tokens[i+1…end]  \n     → Step 10: Recursively compute left_results = AllWays(left_expr)  \n     → Step 11: Recursively compute right_results = AllWays(right_expr)  \n      → For each l in left_results  \n       → For each r in right_results  \n        → Step 12: 根據 tokens[i] 計算 l op r，得到 value  \n         → Step 13: 把 value 加到 results  \n       → End loops  \n     → Step 14: 把 results 存入 memo[key]  \n     → Step 15: 回傳 results  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:\n                                res.append(l * r)\n            if not res:\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 尝试匹配 expression = \"...\"\n    match = re.search(r'expression\\s*=\\s*\"(.*?)\"', data)\n    if match:\n        expr = match.group(1)\n    else:\n        # 若输入不是上述格式，直接使用整行字符串\n        expr = data\n\n    sol = Solution()\n    results = sol.diffWaysToCompute(expr)\n    print(results)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[2,0]",
          "success": true,
          "output": "[2, 0]"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-10,-14,-10,10]",
          "success": true,
          "output": "[-34, -10, -14, -10, 10]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode260.json",
    "problem_index_in_file": 0,
    "title": "Single Number III",
    "description_snippet": "Given an integer array nums, in which exactly two elements appear only once and all the other elemen...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode lines with explanation. Algorithm: XOR all numbers to get xor = a ^ b. Then find rightmost set bit. Use it to partition into two groups, XOR each group to get a and b. Provide steps. Include Start, End. Each line with \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nNeed to output in Traditional Chinese. Use \"虛擬碼步驟\" meaning the pseudocode step. We'll produce something like \"Start // 程式開始\". Then each line with arrow.\n\nWe should use arrow lines \"→\". Provide indentation for decisions. Provide explanation.\n\nWe'll produce lines:\n\nStart // 程式開始\n\n→ Step 1: xor ← 0 // 初始化 XOR 結果為 0\n\n→ For each num in nums: // 遍歷陣列\n    → xor ← xor XOR num // 將每個元素 XOR 進去\n\n→ Step 2: rightmostBit ← xor AND (-xor) // 找到 xor 中最低位的 1\n\n→ Step 3: a ← 0 // 初始化第一個唯一元素\n→ Step 4: b ← 0 // 初始化第二個唯一元素\n\n→ For each num in nums: // 再次遍歷陣列\n    → If (num AND rightmostBit) ≠ 0: // 根據右邊位分組\n        → a ← a XOR num // 將屬於第一組的元素 XOR\n    → Else:\n        → b ← b XOR num // 將屬於第二組的元素 XOR\n\n→ Step 5: Return [a, b] // 返回唯一出現一次的兩個元素\n\nEnd // 程式結束\n\nMake sure each line has \"虛擬碼步驟\" and explanation. Eg: \"Start // 程式開始執行\".\n\nThe arrow lines with indentation: we need to include arrow symbol \"→\". We need to include \"Decision:\" for decision branches? We can show decision as \"Decision:\" line. But we can also use \"If\" and \"Else\". The format example used Decision: but we can adapt. Use \"Decision: ...\" then Yes and No branches. Let's use Decision for grouping check.\n\nImplement:\n\n→ Decision: 是否還有元素需要處理? but simpler to just loop. Use For loop lines. It's okay.\n\nWe need to follow formatting: Each line must contain the pseudocode step and a space and comment.\n\nWe must ensure each line is separate. Provide \"Start //\". Then \"→ Step 1: ...\" etc. Provide comments in Traditional Chinese.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: xor ← 0 // 初始化 XOR 結果為 0  \n→ For each num in nums: // 遍歷陣列  \n  → xor ← xor XOR num // 將每個元素 XOR 進去  \n→ Step 2: rightmostBit ← xor AND (-xor) // 找到 xor 中最低位的 1  \n→ Step 3: a ← 0 // 初始化第一個唯一元素  \n→ Step 4: b ← 0 // 初始化第二個唯一元素  \n→ For each num in nums: // 再次遍歷陣列  \n  → Decision: (num AND rightmostBit) ≠ 0? // 根據右邊位分組  \n   Yes → a ← a XOR num // 把屬於第一組的元素 XOR  \n   No  → b ← b XOR num // 把屬於第二組的元素 XOR  \n→ Step 5: Return [a, b] // 返回唯一出現一次的兩個元素  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def singleNumber(self, nums):\n        xor = 0\n        for num in nums:\n            xor ^= num\n        \n        # 找到 xor 的最右邊 1\n        diff_bit = xor & -xor\n        \n        a = b = 0\n        for num in nums:\n            if num & diff_bit:\n                a ^= num\n            else:\n                b ^= num\n        return [a, b]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從輸入字串中擷取陣列部分\n    match = re.search(r'\\[.*\\]', data)\n    if not match:\n        print(\"[]\")\n        sys.exit(0)\n\n    # 評估陣列字串成為實際列表\n    nums = eval(match.group(0))\n\n    # 呼叫解法並輸出結果\n    result = Solution().singleNumber(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1,3,2,5]",
          "expected_output": "[3,5]",
          "success": true,
          "output": "[3, 5]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0]",
          "expected_output": "[-1,0]",
          "success": true,
          "output": "[-1, 0]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,1]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode224.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator",
    "description_snippet": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and r...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for a basic calculator evaluating a string s with + - * / and parentheses? The problem statement says given a string s representing a valid expression, implement a basic calculator to evaluate it, return the result. Usually includes + - * / and parentheses. The requirement no eval. So we produce algorithm with stack and precedence. Provide line by line with arrows. We'll produce high-level steps: Start, parse string, stack for numbers, stack for operators, precedence function, handle numbers (multi-digit), handle operators: if stack top has same or higher precedence, compute first. At end compute remaining. Return result. Use integer division? typical LeetCode 227: Basic Calculator II without parentheses, or 224 Basic Calculator with parentheses? The problem likely is Basic Calculator (LC 224) includes + - * / parentheses. But the statement not specify parentheses. We'll assume includes + - * /. Might include parentheses? We'll include support for parentheses too. So algorithm: Use stack for values and operators, parse char by char. When encountering '(', push operator stack. When encountering ')', evaluate until '('.\n\nBut virtual code can be simplified: Use two stacks: values, ops. Helper functions: applyOp(op, b, a). Precedence. We'll output pseudo code.\n\nWe need each line with arrow or Start End, decision etc.\n\nLet's create:\n\nStart\n→ Step 1: Initialize empty stack values and stack ops // 存儲數字和運算符\n→ Step 2: Append a sentinel '(' to ops and a sentinel ')' to s // 方便最終計算\n→ Step 3: Initialize index i = 0 // 迭代字符串\n→ Decision: i < len(s)? // 是否還有字符需要處理\n    Yes → Step 4: current = s[i] // 取得當前字符\n    → Decision: current 是空格? // 跳過空格\n        Yes → Step 5: i = i + 1 // 移動到下一個字符\n        No → Decision: current 是數字? // 數字處理\n            Yes → Step 6: num = 0 // 開始讀取整數\n            → While i < len(s) and s[i] 是數字:\n                → Step 7: num = num * 10 + int(s[i]) // 累積數字\n                → Step 8: i = i + 1 // 移動\n            → Step 9: Push num onto values // 送入值棧\n            No → Decision: current 是 '('? // 開啟括號\n                Yes → Step 10: Push '(' onto ops // 記錄左括號\n                No → Decision: current 是 ')' ? // 關閉括號\n                    Yes → Step 11: While ops.top != '(':\n                        → Step 12: op = ops.pop()\n                        → Step 13: b = values.pop()\n                        → Step 14: a = values.pop()\n                        → Step 15: Push applyOp(op, a, b) onto values // 計算子表達式\n                    → Step 16: ops.pop() // 移除 '('\n                    No → Decision: current 是運算符 '+', '-', '*', '/'? // 運算符處理\n                        Yes → Step 17: While ops not empty and precedence(ops.top) >= precedence(current):\n                            → Step 18: op = ops.pop()\n                            → Step 19: b = values.pop()\n                            → Step 20: a = values.pop()\n                            → Step 21: Push applyOp(op, a, b) onto values // 優先計算\n                        → Step 22: Push current onto ops // 儲存當前運算符\n                        No → Step 23: i = i + 1 // 非處理字符直接跳過\n            // End of nested decisions\n    No → End // 處理完所有字符\n\n// After loop, compute remaining ops\n→ Decision: ops not empty?\n    Yes → Step 24: While ops.top != '(':\n        → Step 25: op = ops.pop()\n        → Step 26: b = values.pop()\n        → Step 27: a = values.pop()\n        → Step 28: Push applyOp(op, a, b) onto values\n    → Step 29: ops.pop() // 移除初始 '('\n    No → // nothing\n\n→ Step 30: result = values.pop() // 最終結果\n→ End // 回傳結果\n\nNeed to include helper applyOp and precedence functions as separate steps:\n\n→ Step 31: Function applyOp(op, a, b) // 計算 a op b\n    → Decision: op == '+'? // +處理\n        Yes → Step 32: Return a + b\n        No → Decision: op == '-'?\n            Yes → Step 33: Return a - b\n            No → Decision: op == '*'?\n                Yes → Step 34: Return a * b\n                No → Decision: op == '/'?\n                    Yes → Step 35: Return int(a / b) // 取整除\n                    No → Step 36: Return 0\n\n→ Step 37: Function precedence(op) // 運算符優先級\n    → Decision: op == '+' or op == '-'? \n        Yes → Step 38: Return 1\n        No → Step 39: Return 2\n\nBut this is outside main flow maybe defined earlier. In pseudo we can just reference.\n\nThe user requirement: \"逐行地產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋。\" So we must list lines with arrow and comment. We can include function definitions as separate steps.\n\nHowever, we need to keep it within format: each line with arrow or Start End. We must not output actual code. So the function bodies must be represented as pseudo code lines too.\n\nLet's create final output with many lines.\n\nWe can group lines but each line must be separate with arrow and comment.\n\nWe need to maintain readability.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空棧 values 與 ops // 用於儲存數值與運算符\n→ Step 2: 在 ops 內推入 '(' 作為基準符號 // 方便最終計算\n→ Step 3: 將 s 拓展為 s + ')' // 在結尾加上右括號以收束所有運算\n→ Step 4: i ← 0 // 迭代指標\n→ Decision: i < len(s) ? // 是否還有字符待處理\n    Yes → Step 5: ch ← s[i] // 取得當前字符\n    → Decision: ch 是空格 ? // 跳過空白\n        Yes → Step 6: i ← i + 1 // 移至下一字符\n        No → Decision: ch 是數字 ? // 數字處理\n            Yes → Step 7: num ← 0 // 準備累積多位數\n            → While i < len(s) 且 s[i] 是數字 :\n                → Step 8: num ← num * 10 + int(s[i]) // 更新數字\n                → Step 9: i ← i + 1 // 讀取下一位\n            → Step 10: values.push(num) // 將整數推入值棧\n            No → Decision: ch == '(' ? // 左括號\n                Yes → Step 11: ops.push('(') // 記錄左括號\n                No → Decision: ch == ')' ? // 右括號\n                    Yes → Step 12: While ops.top() ≠ '(' :\n                        → Step 13: op ← ops.pop() // 取出運算符\n                        → Step 14: b ← values.pop() // 右操作數\n                        → Step 15: a ← values.pop() // 左操作數\n                        → Step 16: values.push(applyOp(op, a, b)) // 計算並推回\n                    → Step 17: ops.pop() // 移除左括號\n                    No → Decision: ch 是運算符 (+,-,*,/) ? // 運算符處理\n                        Yes → Step 18: While ops NOT EMPTY AND precedence(ops.top()) ≥ precedence(ch) :\n                            → Step 19: op ← ops.pop()\n                            → Step 20: b ← values.pop()\n                            → Step 21: a ← values.pop()\n                            → Step 22: values.push(applyOp(op, a, b))\n                        → Step 23: ops.push(ch) // 存儲當前運算符\n                        No → Step 24: i ← i + 1 // 非處理字符直接跳過\n            // 結束內部 Decision\n        // 結束外部 Decision\n    No → End // 所有字符已處理完畢\n\n→ Step 25: // 處理剩餘運算符\n→ Decision: ops NOT EMPTY ? // 確認是否還有待處理的運算符\n    Yes → While ops.top() ≠ '(' :\n        → Step 26: op ← ops.pop()\n        → Step 27: b ← values.pop()\n        → Step 28: a ← values.pop()\n        → Step 29: values.push(applyOp(op, a, b))\n    → Step 30: ops.pop() // 移除初始的 '('\n    No → // 無剩餘運算符\n\n→ Step 31: result ← values.pop() // 最終結果從值棧中取出\n→ End // 回傳結果\n\n// ----------------- 辅助函数定义 -----------------\n→ Function applyOp(op, a, b) // 計算 a op b\n    → Decision: op == '+' ?\n        Yes → Return a + b\n        No → Decision: op == '-' ?\n            Yes → Return a - b\n            No → Decision: op == '*' ?\n                Yes → Return a * b\n                No → Decision: op == '/' ?\n                    Yes → Return int(a / b) // 采用整除，符合题目约定\n                    No → Return 0\n\n→ Function precedence(op) // 返回运算符优先级\n    → Decision: op == '+' OR op == '-' ?\n        Yes → Return 1\n        No → Return 2\n\n// End of virtual code",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        # 用於儲存數值與運算符\n        values, ops = [], []\n        # 在運算符棧中先加入 '(' 作為基準\n        ops.append('(')\n        # 在輸入字串結尾加入 ')' 以收束所有運算\n        s += ')'\n\n        i = 0\n        while i < len(s):\n            ch = s[i]\n            # 跳過空白\n            if ch.isspace():\n                i += 1\n                continue\n\n            # 數字處理（支援多位數）\n            if ch.isdigit():\n                num = 0\n                while i < len(s) and s[i].isdigit():\n                    num = num * 10 + int(s[i])\n                    i += 1\n                values.append(num)\n                continue\n\n            # 左括號\n            if ch == '(':\n                ops.append('(')\n                i += 1\n                continue\n\n            # 右括號，先計算直到對應 '('\n            if ch == ')':\n                while ops[-1] != '(':\n                    op = ops.pop()\n                    b = values.pop()\n                    a = values.pop()\n                    values.append(self.apply_op(op, a, b))\n                ops.pop()   # 移除 '('\n                i += 1\n                continue\n\n            # 運算符 + - * /\n            if ch in '+-*/':\n                # 先把優先級相同或更高的運算符算完\n                while ops and ops[-1] != '(' and self.precedence(ops[-1]) >= self.precedence(ch):\n                    op = ops.pop()\n                    b = values.pop()\n                    a = values.pop()\n                    values.append(self.apply_op(op, a, b))\n                ops.append(ch)\n                i += 1\n                continue\n\n            # 若遇到其他字符直接跳過\n            i += 1\n\n        # 所有運算完成後，值棧中的唯一元素即為答案\n        return values.pop()\n\n    def apply_op(self, op: str, a: int, b: int) -> int:\n        if op == '+':\n            return a + b\n        if op == '-':\n            return a - b\n        if op == '*':\n            return a * b\n        if op == '/':\n            # 與題目預期相符，截斷到整數\n            return int(a / b)\n        return 0\n\n    def precedence(self, op: str) -> int:\n        if op in '+-':\n            return 1\n        if op in '*/':\n            return 2\n        return 0\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    從輸入資料中提取出第一個雙引號內的字串。\n    若找不到引號，直接返回去除首尾空白的整個輸入。\n    \"\"\"\n    m = re.search(r'\"([^\"]*)\"', data)\n    if m:\n        return m.group(1)\n    return data.strip()\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    expression = parse_input(raw)\n    result = Solution().calculate(expression)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"1 + 1\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \" 2-1 + 2 \"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode561.json",
    "problem_index_in_file": 0,
    "title": "Array Partition",
    "description_snippet": "Given an integer array nums of 2n integers, group these integers into n pairs (a_1, b_1), (a_2, b_2)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving problem: maximize sum of min of each pair. Known solution: sort array ascending, sum every other element starting from index 0 (since min will be the smaller in pair). Actually sort ascending, pair adjacent: (a[0], a[1]), (a[2], a[3]), ... sum a[0]+a[2]+... Because min of each adjacent pair will be first element.\n\nThus algorithm: Input array nums length 2n. Sort ascending. sum=0. for i=0; i<nums.length; i+=2 sum+=nums[i]. Return sum.\n\nWe need virtual code lines with arrow and explanation.\n\nLet's craft.\n\nStart\n\n→ Step 1: Input array nums // 取得輸入的整數陣列\n\n→ Step 2: Sort nums in non‑decreasing order // 依大小排序\n\n→ Step 3: Initialize sum = 0 // 儲存最終結果\n\n→ Decision: i < nums.length? // 迴圈控制\n\n    Yes → Step 4: sum = sum + nums[i] // 加上每個偶數索引的數字（即 min 值）\n\n    Yes → Step 5: i = i + 2 // 跳到下一個偶數索引\n\n    No → Step 6: Return sum // 結束並回傳結果\n\nEnd\n\nBut need to align with format: Use arrows: \"→\" before each step, decisions using \"Decision:\" etc.\n\nLet's produce with each line: Virtual code step + comment. Format: \"Start // ...\". So first line Start.\n\nLet's produce.\n\nCheck format: In example, they used \"→ Step 1:\" etc. And Decision lines: \"Decision: 如果數字大於 0?\" Then indent Yes/No. We'll use similar.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 取得長度為 2n 的整數陣列  \n→ Step 2: 將 nums 依升序排序 // 使得較小的數值排在前面  \n→ Step 3: 設定 sum = 0 // 用來累積最終結果  \n→ Step 4: 設定 i = 0 // 用來遍歷陣列  \n→ Decision: i < nums.length? // 是否還有元素可處理？  \n  Yes → Step 5: sum = sum + nums[i] // 加上偶數索引處的元素，即 min(ai, bi)  \n  Yes → Step 6: i = i + 2 // 跳到下一對的第一個元素  \n  No  → Step 7: 回傳 sum // 結束並輸出最大化的總和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def arrayPairSum(self, nums):\n        \"\"\"\n        1. 把陣列按升序排序\n        2. 取排序後的每個偶數索引（0,2,4,…) 的數字，它們就是各對 (a_i,b_i) 的 min\n        3. 將這些 min 累加得到答案\n        \"\"\"\n        nums.sort()\n        return sum(nums[::2])\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 解析輸入為 Python 列表\n    nums = ast.literal_eval(data)\n    # 計算並輸出答案\n    solution = Solution()\n    result = solution.arrayPairSum(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,4,3,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "[6,2,6,5,1,2]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode55.json",
    "problem_index_in_file": 0,
    "title": "Jump Game",
    "description_snippet": "You are given an integer array nums. You are initially positioned at the array's first index, and ea...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for Jump Game problem: given array, determine if can reach last index. Use greedy algorithm: maintain maxReach.\n\nWe must produce step-by-step pseudocode with explanations per line. Use arrows etc.\n\nWe need to adhere to format: each line: virtual code + space + // explanation.\n\nInclude Start, End, Decision.\n\nLet's design:\n\nStart\n→ Step 1: Initialize maxReach = 0 // start position\n→ Step 2: For i from 0 to length-1\n    → Decision: if i > maxReach? // cannot reach index i\n        → Yes → Return False // cannot reach further\n        → No → Update maxReach = max(maxReach, i + nums[i]) // extend reach\n    → Decision: if maxReach >= length-1? // can reach end\n        → Yes → Return True\n    // loop continues\nEnd\n\nBut need line per line. Use indentation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Set maxReach = 0 // 最大可達索引\n→ Step 2: For i from 0 to nums.length-1\n    → Decision: i > maxReach? // 目前索引是否不可達\n        Yes → Step 3: Return False // 無法再前進，直接返回\n        No  → Step 4: Update maxReach = max(maxReach, i + nums[i]) // 擴展可達範圍\n    → Decision: maxReach >= nums.length-1? // 是否已能到達最後索引\n        Yes → Step 5: Return True // 成功到達，返回真\n        No  → Continue // 仍在迴圈中\nEnd // 程式執行結束\n\nBut we need each line separate. For indentation, use spaces? Format shows each line as separate.\n\nWe need to show arrow lines for decisions etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: maxReach ← 0 // 最大可達索引\n→ Step 2: i ← 0 // 設定迴圈索引\n→ Decision: i < nums.length? // 是否還有索引要處理\n    Yes → → Step 3: If i > maxReach? // 目前索引是否不可達\n        Yes → → Step 4: Return False // 無法再前進，返回偽\n        No  → → Step 5: maxReach ← max(maxReach, i + nums[i]) // 更新最大可達\n    No  → → Step 6: // 迴圈結束\n→ Decision: maxReach >= nums.length - 1? // 最後是否可達\n    Yes → → Step 7: Return True // 成功\n    No  → → Step 8: Return False // 失敗\nEnd // 程式結束\n\nBut this is messy. The example uses arrows per step, but not nested inside loops. They use indentation for decision branches.\n\nMaybe better:\n\nStart // 程式開始執行\n→ Step 1: maxReach ← 0 // 初始化最大可達索引\n→ Step 2: For i ← 0 to nums.length-1 // 遍歷每個索引\n    → Decision: i > maxReach? // 若當前索引不可達\n        Yes → Step 3: Return False // 無法到達終點\n        No  → Step 4: maxReach ← max(maxReach, i + nums[i]) // 更新最大可達\n    → Decision: maxReach >= nums.length-1? // 可否已到達最後\n        Yes → Step 5: Return True // 成功\n        No  → // 迴圈繼續\nEnd // 程式結束\n\nLet's produce exactly that. Ensure each line ends with // explanation. Use \"→\" arrow for steps.\n\nWe need to output step-by-step lines exactly as required. Use spaces between each component.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: maxReach ← 0 // 初始化最大可達索引  \n→ Step 2: For i ← 0 to nums.length-1 // 遍歷每個索引  \n  Decision: i > maxReach? // 檢查目前索引是否不可達  \n   Yes → Step 3: Return False // 無法再前進，直接返回偽  \n   No  → Step 4: maxReach ← max(maxReach, i + nums[i]) // 更新最大可達範圍  \n  Decision: maxReach >= nums.length-1? // 檢查是否已能到達最後索引  \n   Yes → Step 5: Return True // 成功到達終點  \n   No  → // 迴圈繼續執行  \nEnd // 程式執行結束",
      "generated_code": "import sys, re\n\ndef can_jump(nums):\n    max_reach = 0\n    for i, jump in enumerate(nums):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + jump)\n    return True\n\ndef parse_input(data):\n    # Remove 'nums =' prefix if present\n    data = data.strip()\n    if data.startswith('nums'):\n        # Find first '='\n        idx = data.find('=')\n        if idx != -1:\n            data = data[idx+1:].strip()\n    # Evaluate the list safely\n    try:\n        return eval(data, {\"__builtins__\":None}, {})\n    except Exception:\n        # Fallback: extract integers via regex\n        nums = list(map(int, re.findall(r'-?\\d+', data)))\n        return nums\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    if not input_data.strip():\n        sys.exit(0)\n    nums = parse_input(input_data)\n    result = can_jump(nums)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,0,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode220.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate III",
    "description_snippet": "You are given an integer array nums and two integers indexDiff and valueDiff.\n\nFind a pair of indice...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps, each line: \"虛擬碼步驟 // 解釋\". Use arrows, Decision etc. We should not output actual code, just steps. We need to provide algorithm: check all pairs within indexDiff and valueDiff. Perhaps sliding window approach. Use set or multiset. Steps: Start, create data structure, iterate. For each index, maintain window of last indexDiff elements. Check value condition. Use two nested loops or maintain set. Simpler: For i from 0 to n-1, for j from i-1 down to max(0,i-indexDiff), if abs(nums[i]-nums[j])<=valueDiff return true. Complexity O(n*indexDiff). That's fine.\n\nLet's produce virtual code with loops, decisions. Each step. Use arrow indentation. We'll follow format. Use Start, End. Use Decision. Use loops with indices. We must show nested loops. Use 'for i' and 'for j'. Represent loops as steps maybe.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize n = length of nums // 取得陣列長度\n→ Step 2: For i from 0 to n-1 // 逐個遍歷陣列\n    → Step 3: jStart = max(0, i - indexDiff) // 計算 j 的起始位置\n    → Step 4: For j from jStart to i-1 // 遍歷可接受的 j\n        → Decision: abs(nums[i] - nums[j]) <= valueDiff? // 檢查值差是否符合\n            Yes → Step 5: Return true // 找到符合條件的對，返回真\n            No  → Step 6: Continue // 否則繼續下一個 j\n    → Step 7: Continue // i 迴圈繼續\n→ Step 8: Return false // 未找到任何符合條件的對，返回假\nEnd\n\nNeed to add explanations. Ensure each line has \" // \" after code. Use \"→\". The Start line should be \"Start\". End line \"End\". Use indent? Not necessary but good.\n\nAlso include arrow for Decision and Yes/No. Each line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: for i ← 0 to n-1 // 逐個遍歷陣列  \n  → Step 3: jStart ← max(0, i - indexDiff) // 計算可比對的 j 的起始位置  \n  → Step 4: for j ← jStart to i-1 // 遍歷與 i 距離 ≤ indexDiff 的索引  \n    → Decision: abs(nums[i] - nums[j]) ≤ valueDiff? // 檢查數值差是否符合條件  \n      Yes → Step 5: return true // 找到符合條件的對，直接返回真  \n      No  → Step 6: continue // 不符合，繼續檢查下一個 j  \n  → Step 7: continue // i 迴圈繼續到下一個索引  \n→ Step 8: return false // 未找到任何符合條件的對，返回假  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef contains_nearby_almost_duplicate(nums, index_diff, value_diff):\n    n = len(nums)\n    for i in range(n):\n        start = max(0, i - index_diff)\n        for j in range(start, i):\n            if abs(nums[i] - nums[j]) <= value_diff:\n                return True\n    return False\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read().strip()\n    # Extract the list and two integers using regular expressions\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', input_text)\n    index_match = re.search(r'indexDiff\\s*=\\s*(-?\\d+)', input_text)\n    value_match = re.search(r'valueDiff\\s*=\\s*(-?\\d+)', input_text)\n\n    if not (nums_match and index_match and value_match):\n        print(\"false\")\n        sys.exit(0)\n\n    nums = eval(nums_match.group(1))\n    index_diff = int(index_match.group(1))\n    value_diff = int(value_match.group(1))\n\n    result = contains_nearby_almost_duplicate(nums, index_diff, value_diff)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode229.json",
    "problem_index_in_file": 0,
    "title": "Majority Element II",
    "description_snippet": "Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for algorithm: find all elements in array that appear more than floor(n/3) times. Classic Boyer-Moore majority vote algorithm extended for k=3. So steps: 1) handle null or length 0. 2) set candidate1, candidate2, count1, count2. 3) iterate array: if number == candidate1, count1++; else if number == candidate2, count2++; else if count1==0, set candidate1 to number, count1=1; else if count2==0, set candidate2 to number, count2=1; else count1--, count2--. 4) After first pass, reset count1, count2 to 0. 5) second pass: count occurrences. 6) result list. 7) output.\n\nWe must provide each line with virtual code step and explanation. Use Start, End, Decision. Also use arrow →.\n\nWe should produce lines like:\nStart // ...\n→ Step 1: Check if array is null or empty // ...\n→ Decision: If array length < 1? // ...\n    Yes → End // no elements\n    No → Step 2: Initialize candidates and counts // ...\n...\n\nNeed to be careful to keep it line by line.\n\nWe'll produce code steps with comments.\n\nWe don't output actual code, just pseudo steps.\n\nLet's outline steps:\n\nStart\n→ Step 1: Initialize n = array length // get size\n→ Decision: If n == 0? // no elements\n    Yes → End\n    No → Step 2: Initialize candidate1 = None, candidate2 = None, count1 = 0, count2 = 0 // placeholders\n→ Step 3: First pass for potential candidates // Boyer-Moore\n    → Loop over each num in array\n        → Decision: If candidate1 == num?\n            Yes → count1++\n            No →\n                Decision: If candidate2 == num?\n                    Yes → count2++\n                    No →\n                        Decision: If count1 == 0?\n                            Yes → candidate1 = num, count1 = 1\n                            No →\n                                Decision: If count2 == 0?\n                                    Yes → candidate2 = num, count2 = 1\n                                    No →\n                                        → count1--\n                                        → count2--\n→ Step 4: Reset count1 = 0, count2 = 0 // count actual occurrences\n→ Step 5: Second pass to count occurrences\n    → Loop over each num in array\n        → Decision: If num == candidate1?\n            Yes → count1++\n            No →\n                Decision: If num == candidate2?\n                    Yes → count2++\n→ Step 6: Initialize result list // []\n→ Step 7: Decision: If count1 > n/3?\n    Yes → Add candidate1 to result // record\n→ Decision: If count2 > n/3?\n    Yes → Add candidate2 to result // record\n→ End // return result\n\nWe need to use virtual code arrows and decisions, but we cannot indent lines too deeply maybe allowed.\n\nWe will format each line as: \"虛擬碼步驟 // 解釋\"\n\nLet's write each step with appropriate indentation.\n\nMake sure each line ends with // Explanation. Use arrow \"→\" to denote next step.\n\nWe should also maintain the formatting of decisions with Yes → and No →.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: n = array.length // 取得陣列長度\n→ Decision: n == 0? // 判斷陣列是否為空\n    Yes → End // 若為空則直接結束，無需進一步處理\n    No  → Step 2: candidate1 = null, candidate2 = null, count1 = 0, count2 = 0 // 初始化候選值與計數\n→ Step 3: First pass – 找出可能的候選者 // 應用擴充版 Boyer‑Moore\n    → Loop for each num in array\n        → Decision: num == candidate1?\n            Yes → count1++ // 與第一候選者相同，計數加一\n            No  → Decision: num == candidate2?\n                Yes → count2++ // 與第二候選者相同，計數加一\n                No  → Decision: count1 == 0?\n                    Yes → candidate1 = num, count1 = 1 // 重新指派第一候選者\n                    No  → Decision: count2 == 0?\n                        Yes → candidate2 = num, count2 = 1 // 重新指派第二候選者\n                        No  → count1--, count2-- // 同時遞減兩個計數\n→ Step 4: Reset count1 = 0, count2 = 0 // 重新為第二輪計數做準備\n→ Step 5: Second pass – 重新計算實際出現次數\n    → Loop for each num in array\n        → Decision: num == candidate1?\n            Yes → count1++ // 對第一候選者計數\n            No  → Decision: num == candidate2?\n                Yes → count2++ // 對第二候選者計數\n→ Step 6: result = [] // 建立結果清單\n→ Decision: count1 > n/3?\n    Yes → result.append(candidate1) // 若第一候選者超過閾值，加入結果\n→ Decision: count2 > n/3?\n    Yes → result.append(candidate2) // 若第二候選者超過閾值，加入結果\nEnd // 程式執行結束，返回結果列表",
      "generated_code": "import sys\n\nclass Solution:\n    def majorityElement(self, nums):\n        \"\"\"\n        找出所有出現次數大於 ⌊ n/3 ⌋ 的元素。\n        使用擴充版 Boyer‑Moore 演算法，時間 O(n)，空間 O(1)。\n        \"\"\"\n        if not nums:\n            return []\n\n        # 1. 第一輪：找出可能的兩個候選者\n        candidate1, candidate2 = None, None\n        count1, count2 = 0, 0\n\n        for num in nums:\n            if candidate1 == num:\n                count1 += 1\n            elif candidate2 == num:\n                count2 += 1\n            elif count1 == 0:\n                candidate1, count1 = num, 1\n            elif count2 == 0:\n                candidate2, count2 = num, 1\n            else:\n                count1 -= 1\n                count2 -= 1\n\n        # 2. 第二輪：實際計算候選者出現次數\n        count1, count2 = 0, 0\n        for num in nums:\n            if num == candidate1:\n                count1 += 1\n            elif num == candidate2:\n                count2 += 1\n\n        # 3. 依閾值判斷是否加入結果\n        n = len(nums)\n        result = []\n        if count1 > n // 3:\n            result.append(candidate1)\n        if count2 > n // 3:\n            result.append(candidate2)\n\n        return result\n\n\ndef main():\n    # 從標準輸入讀取資料\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 支援兩種輸入格式：1) \"nums = [1,2,3]\" 2) \"[1,2,3]\"\n    nums = []\n    try:\n        # 嘗試執行代碼，取得變數 nums\n        local_vars = {}\n        exec(data, {}, local_vars)\n        nums = local_vars.get('nums', [])\n    except Exception:\n        try:\n            # 若 exec 失敗，嘗試直接 eval\n            nums = eval(data)\n        except Exception:\n            nums = []\n\n    # 取得結果並輸出\n    sol = Solution()\n    result = sol.majorityElement(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "[3]",
          "success": true,
          "output": "[3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode748.json",
    "problem_index_in_file": 0,
    "title": "Shortest Completing Word",
    "description_snippet": "Given a string licensePlate and an array of strings words, find the shortest completing word in word...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for algorithm. Use virtual code syntax. Steps: preprocess licensePlate to count letters, case-insensitive, ignore non-letters. For each word in words: check if word contains required counts. If yes and length < bestLen, update bestWord. Return bestWord.\n\nUse Decision, etc.\n\nWe need to produce lines with '虛擬碼步驟 // 解釋'.\n\nLet's produce structure:\n\nStart\n→ Step: 初始化字母頻率表 counts[26] = 0\n→ Step: 逐字掃描 licensePlate\n   → Decision: 字元是否為字母? // 判斷是否為字母\n       Yes → Step: 轉小寫並增加 counts[char]\n       No  → Step: 跳過\n→ Step: bestWord = null; bestLen = Infinity\n→ Step: 逐個 word 在 words\n   → Step: wordCount[26] = 0\n   → Step: 逐字掃描 word\n        → Decision: 字元是否為字母? // 但 word 只由小寫? still check\n           Yes → Step: 轉小寫並增加 wordCount[char]\n           No  → Step: skip\n   → Decision: word是否完成? // check all counts <= wordCount\n        Yes → Decision: word.length < bestLen? // shorter?\n             Yes → Step: bestWord = word; bestLen = word.length\n             No  → Step: skip\n        No  → Step: skip\n→ Step: Return bestWord\nEnd\n\nWe need to maintain the format: \"虛擬碼步驟 // 解釋\" with each line.\n\nLet's produce each line accordingly. Use arrow \"→\" for substeps.\n\nWe need to include structure names: Start, End, Decision: etc. Provide explanation after //.\n\nLet's write each line. Count number of lines. We'll produce many lines. Ensure each line contains '虛擬碼步驟' and explanation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step: counts[26] = 0 // 建立字母頻率表，索引 0~25 對應 a~z\n→ Step: for ch in licensePlate // 逐字掃描車牌字串\n   → Decision: 是否為字母(ch)? // 判斷字元是否為英文字母\n        Yes → Step: idx = lower(ch) - 'a' ; counts[idx] += 1 // 轉小寫後累計頻率\n        No  → Step: // 跳過非字母字元\n→ Step: bestWord = \"\" ; bestLen = Infinity // 初始化最佳答案\n→ Step: for word in words // 逐一檢查每個單字\n   → Step: wordCount[26] = 0 // 為當前單字建立頻率表\n   → Step: for c in word // 逐字掃描單字\n        → Decision: 是否為字母(c)? // 處理可能含非字母但一般情況為小寫字母\n             Yes → Step: idx = c - 'a' ; wordCount[idx] += 1 // 累計頻率\n             No  → Step: // 跳過非字母\n   → Decision: 是否完成(wordCount, counts)? // 檢查所有需要的字母是否足夠\n        Yes → Decision: word.length < bestLen? // 若更短則更新\n             Yes → Step: bestWord = word ; bestLen = word.length // 更新最佳答案\n             No  → Step: // 仍然更長，保持原答案\n        No  → Step: // 不是完成單字，跳過\n→ Step: return bestWord // 回傳最短完成字\nEnd // 程式執行結束\n\nWe need to ensure arrow formatting consistent. Each sub-level line must have an arrow too. For sub-steps inside loops, we need to indent with arrow? In example they used \"→ Step 1: ...\" etc. So we keep \"→\" at start for all steps, and \"→ Decision:\" for decisions. For nested steps, we might use \"→\" again with indentation but still arrow.\n\nLet's keep simple: each line with arrow. The indent inside loops can be represented with space. But we maintain arrow for each line. Use consistent.\n\nWe must include \"Step\" or \"Decision\". For decisions we use \"Decision:\".\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: counts[26] = 0 // 建立字母頻率表，索引 0~25 對應 a~z  \n→ Step: for ch in licensePlate // 逐字掃描車牌字串  \n   → Decision: 是否為字母(ch)? // 判斷字元是否為英文字母  \n        Yes → Step: idx = lower(ch) - 'a' ; counts[idx] += 1 // 轉小寫後累計頻率  \n        No  → Step: // 跳過非字母字元  \n→ Step: bestWord = \"\" ; bestLen = Infinity // 初始化最佳答案  \n→ Step: for word in words // 逐一檢查每個單字  \n   → Step: wordCount[26] = 0 // 為當前單字建立頻率表  \n   → Step: for c in word // 逐字掃描單字  \n        → Decision: 是否為字母(c)? // 處理可能含非字母但一般情況為小寫字母  \n             Yes → Step: idx = c - 'a' ; wordCount[idx] += 1 // 累計頻率  \n             No  → Step: // 跳過非字母  \n   → Decision: 是否完成(wordCount, counts)? // 檢查所有需要的字母是否足夠  \n        Yes → Decision: word.length < bestLen? // 若更短則更新  \n             Yes → Step: bestWord = word ; bestLen = word.length // 更新最佳答案  \n             No  → Step: // 仍然更長，保持原答案  \n        No  → Step: // 不是完成單字，跳過  \n→ Step: return bestWord // 回傳最短完成字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nimport collections\n\ndef shortest_completing_word(license_plate: str, words):\n    plate_count = collections.Counter(c.lower() for c in license_plate if c.isalpha())\n    best = None\n    for w in words:\n        w_count = collections.Counter(w)\n        if all(w_count[c] >= plate_count[c] for c in plate_count):\n            if best is None or len(w) < len(best):\n                best = w\n    return best\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 匹配 licensePlate = \"...\" , words = [...]\n    pattern = r'licensePlate\\s*=\\s*\"([^\"]*)\",\\s*words\\s*=\\s*(\\[.*\\])'\n    match = re.search(pattern, data, re.S)\n    if not match:\n        # 如果格式不同，嘗試直接 eval\n        try:\n            namespace = {}\n            exec(data, {}, namespace)\n            license_plate = namespace.get('licensePlate', '')\n            words = namespace.get('words', [])\n        except Exception:\n            return\n    else:\n        license_plate = match.group(1)\n        words = ast.literal_eval(match.group(2))\n    result = shortest_completing_word(license_plate, words)\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]",
          "expected_output": "\"steps\"",
          "success": true,
          "output": "\"steps\""
        },
        {
          "example_index": 1,
          "input": "licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"]",
          "expected_output": "\"pest\"",
          "success": true,
          "output": "\"pest\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode136.json",
    "problem_index_in_file": 0,
    "title": "Single Number",
    "description_snippet": "Given a non-empty array of integers nums, every element appears twice except for one. Find that sing...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines, with virtual code and explanation. Must not output actual code. Use Start, End, Decision, etc. Each line: virtual code step + space + // explanation. The user requirement: find single number in array where every element appears twice except one. Linear runtime, constant space. Classic solution: XOR all numbers. So pseudocode: Start, Step: initialize result = 0, iterate over nums: result = result XOR num, end loop, output result, End.\n\nWe need to produce step-by-step with arrow →, Decision if needed? Not necessary. We can include decision maybe to check array empty but problem says non-empty. Could just iterate.\n\nWe need to produce virtual code lines. Eg:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result = 0 // 設定累積 XOR 結果為 0\n→ Step 2: 對每個 num 進行迴圈 // 遍歷陣列\n    → Step 3: result = result XOR num // 將目前數字 XOR 到累積結果\n→ Step 4: 輸出 result // 單一出現的數字\nEnd // 程式執行結束\n\nWe need to ensure each line includes virtual code step + space + // explanation. Also use arrow notation. Provide all lines as described.\n\nWe might also mention that XOR property ensures duplicates cancel. But that's explanation.\n\nMake sure to keep lines consistent: use \"Step X:\" or \"Decision:\" if needed. For loops, we can denote as Step 2: 迴圈 ... But could also use \"Decision:\" to check? Not necessary.\n\nLet's produce final answer in Chinese. Use traditional Chinese. Ensure each line ends with // explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result = 0 // 設定 XOR 累計變數為 0，準備累加所有數字  \n→ Step 2: 針對陣列 nums 中每個元素 num 進行迴圈 // 遍歷整個陣列  \n    → Step 3: result = result XOR num // 將目前元素與累計值進行 XOR，重複的數字會抵消  \n→ Step 4: 輸出 result // result 即為唯一出現一次的數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNumber(self, nums):\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Extract the list part from input like 'nums = [2,2,1]'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        nums = []\n    else:\n        list_str = data[start:end+1]\n        nums = ast.literal_eval(list_str)\n\n    solution = Solution()\n    single = solution.singleNumber(nums)\n    print(single)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,1,2,1,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1991.json",
    "problem_index_in_file": 0,
    "title": "Find the Middle Index in Array",
    "description_snippet": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanation comments. Use Start, End, Decision, arrows. We need to solve problem: find leftmost equilibrium index. Approach: compute total sum, iterate, maintain left sum, compare left sum to total-leftSum-currentVal. Need to handle edges.\n\nWe will produce virtual code steps. Example:\n\nStart\n→ Step 1: 計算總和 totalSum = sum(nums) // 計算陣列總和\n→ Step 2: 初始化 leftSum = 0 // 左側累加初始為0\n→ Step 3: 從 i=0 到 nums.length-1 迭代 // 遍歷每個索引\n→ Decision: 如果 leftSum == totalSum - leftSum - nums[i]? // 判斷是否為平衡點\n    Yes → Step 4: 返回 i // 找到左側最小平衡索引\n    No  → Step 5: 更新 leftSum = leftSum + nums[i] // 否則更新左側和\nEnd // 若未找到則返回 -1\n\nBut need \"Return -1\" when not found: we need a final Step: Return -1 // 沒有符合條件\n\nLet's craft.\n\nWe must include all virtual steps line by line. Use arrow, indent for Decision.\n\nLet's produce final answer in Chinese.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: totalSum ← Sum(nums) // 計算陣列 nums 的總和\n→ Step 2: leftSum ← 0 // 初始化左側累加和為 0\n→ Step 3: i ← 0 // 設定起始索引\n→ Decision: i < Length(nums)? // 檢查是否還有未遍歷的索引\n    Yes → Decision: leftSum == totalSum - leftSum - nums[i]? // 判斷當前索引是否為平衡點\n        Yes → Step 4: Return i // 找到左側最小的平衡索引，立即返回\n        No  → Step 5: leftSum ← leftSum + nums[i] // 否則把 nums[i] 加到左側累加和\n    No  → Step 6: Return -1 // 所有索引都已檢查，未找到平衡點，返回 -1\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMiddleIndex(self, nums):\n        \"\"\"返回左側最小的平衡索引，若不存在則回傳 -1\"\"\"\n        total = sum(nums)\n        left_sum = 0\n        for i, num in enumerate(nums):\n            if left_sum == total - left_sum - num:\n                return i\n            left_sum += num\n        return -1\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    # 若輸入為空，直接輸出 -1\n    if not data:\n        print(-1)\n        sys.exit(0)\n\n    # 找出第一個 '[' 和最後一個 ']'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        # 無法解析，直接輸出 -1\n        print(-1)\n        sys.exit(0)\n\n    list_str = data[start:end+1]\n    try:\n        nums = ast.literal_eval(list_str)\n        if not isinstance(nums, list):\n            raise ValueError\n    except Exception:\n        print(-1)\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.findMiddleIndex(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,-1,8,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,-1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [2,5]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode520.json",
    "problem_index_in_file": 0,
    "title": "Detect Capital",
    "description_snippet": "We define the usage of capitals in a word to be right when one of the following cases holds:\n\nAll le...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode. The user wants a step-by-step virtual code, with each line: \"虛擬碼步驟 // 解釋\". Use arrows, decision blocks. Use Chinese explanations. Must not output actual code. Just virtual pseudocode. We'll output lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 IsCorrectCapitalUsage(word) // 定義檢查字母大寫使用的函式\n\nBut need to maintain structure: Use arrows, Decision: etc.\n\nLet's craft.\n\nWe'll create high-level logic: Check if all letters are uppercase, if all lowercase, if only first uppercase and rest lowercase.\n\nPseudo steps:\n\n1. Initialize flag variables: isAllUpper, isAllLower, isCapitalFirst.\n\n2. For each char in word, update flags.\n\n3. After loop, if any two flags true? We can check conditions.\n\nAlternative simpler: Use built-in functions: if word == word.upper() or word == word.lower() or (word[0].isupper() and word[1:].islower()) then true else false.\n\nBut we need to produce virtual code lines; can use those.\n\nLet's produce steps:\n\nStart\n→ Step 1: 接收輸入字串 word\n→ Decision: 如果 word 全部大寫? // 判斷整個字串是否為大寫\n    Yes → Step 2: 回傳 true // 全部大寫是合法\n    No → Decision: 如果 word 全部小寫? // 判斷整個字串是否為小寫\n        Yes → Step 3: 回傳 true // 全部小寫是合法\n        No → Decision: 如果 word 第一個字母大寫且其餘小寫? // 判斷首字母大寫其餘小寫\n            Yes → Step 4: 回傳 true // 只首字母大寫是合法\n            No  → Step 5: 回傳 false // 其餘皆不合法\nEnd\n\nBut we need to show the logic to check each condition. Use arrows inside decisions? Provide explanation after each line. Use \"Decision:\" for each check. Use arrow indentation to show hierarchy.\n\nAlso we need to show \"Start\" and \"End\" lines. Provide each line with // explanation. Use arrow for indentation.\n\nLet's produce the virtual code accordingly.\n\nWill include steps like:\n\n→ Step 1: 比較 word 與 word.upper() // 檢查是否全大寫\n→ Step 2: 比較 word 與 word.lower() // 檢查是否全小寫\n→ Step 3: 比較 word[0] 與 word[0].upper() 且 word[1:] 與 word[1:].lower() // 檢查首字母大寫其餘小寫\n\nBut use decisions to avoid multiple conditions. Provide code accordingly.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入字串 word // 從使用者或呼叫者取得待檢查的字串  \n→ Decision: 若 word 與 word.upper() 相等? // 判斷整個字串是否全為大寫  \n  Yes → Step 2: 回傳 true // 全大寫的情況符合規則  \n  No → Decision: 若 word 與 word.lower() 相等? // 判斷整個字串是否全為小寫  \n    Yes → Step 3: 回傳 true // 全小寫的情況符合規則  \n    No → Decision: 若 word[0] 與 word[0].upper() 相等 且 word[1:] 與 word[1:].lower() 相等? // 判斷首字母大寫且其餘小寫  \n     Yes → Step 4: 回傳 true // 只首字母大寫的情況符合規則  \n     No → Step 5: 回傳 false // 以上皆不符，使用方式錯誤  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef detectCapitalUse(word: str) -> bool:\n    \"\"\"判斷字串的大小寫使用是否正確。\"\"\"\n    return word.isupper() or word.islower() or word.istitle()\n\ndef main() -> None:\n    # 從標準輸入讀取全部資料\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n\n    # 取第一行（或整段文字）並去除前後空白\n    word = raw_input.strip()\n\n    # 若輸入時有包裹在雙引號或單引號中，去掉這些引號\n    if len(word) >= 2 and ((word[0] == '\"' and word[-1] == '\"') or\n                           (word[0] == \"'\" and word[-1] == \"'\")):\n        word = word[1:-1]\n\n    # 判斷並輸出結果，符合題目要求輸出小寫字串\n    print(str(detectCapitalUse(word)).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"USA\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"FlaG\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode171.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Number",
    "description_snippet": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. So algorithm: Start, input string columnTitle. Convert each character to number 1-26, accumulate as base-26. Use loop over characters. For each char: value = ord(char)-ord('A')+1; result = result*26 + value. End.\n\nWe need to output each line with \"虛擬碼步驟 // 解釋\". Use arrow syntax. So:\n\nStart\n→ Step 1: Initialize result = 0 // set initial column number\n→ Step 2: For each character c in columnTitle // iterate through string\n→     Value = ord(c) - ord('A') + 1 // map letter to 1-26\n→     result = result * 26 + Value // shift base-26 and add\n→ End\n\nBut we also need Decision? Maybe if string empty? Not necessary. Provide loop with decision to continue.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化結果為 0\n→ Step 2: For i ← 0 to length(columnTitle)-1 // 逐字元遍歷\n→     char ← columnTitle[i] // 取得當前字元\n→     Decision: char is between 'A' and 'Z'? // 確認合法字母\n→         Yes → value ← (char - 'A' + 1) // 將字母轉成 1-26\n→         No  → Error // 非法輸入\n→     result ← result * 26 + value // 進行 base‑26 累加\n→ End // 程式執行結束\n\nBut the instruction: Use virtual code arrows and structure. Each line must be \"虛擬碼步驟 [space] // 解釋\". Use \"Start\", \"End\", \"Decision:\" etc. We can include loops. Use \"→\" for steps. Use \"Decision:\" line.\n\nWe should produce each step separate line, not block indentation? The example shows indentation using spaces for nested steps. We'll mimic.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化結果為 0\n→ Step 2: For i ← 0 to length(columnTitle)-1 // 從左至右遍歷每個字元\n→     Decision: columnTitle[i] 為 'A'~'Z'? // 確認字元合法\n→         Yes → value ← (columnTitle[i] - 'A' + 1) // 將字母映射到 1~26\n→         No  → Error // 非法字元處理\n→     result ← result * 26 + value // 在 base-26 中累加\nEnd // 程式執行結束\n\nBut each line must contain only the step and comment. In the example, they didn't separate lines with multiple steps? Actually each line is a step with arrow, but if Decision has nested lines, they indent but still each line separate. So we need to output lines with arrow plus step, then comment. For nested Decision: indent.\n\nThus final answer lines as described.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← 0 // 初始化結果為 0  \n→ Step 2: For i ← 0 to length(columnTitle)-1 // 從左至右遍歷每個字元  \n  Decision: columnTitle[i] 為 'A'~'Z'? // 確認字元合法  \n   Yes → value ← (columnTitle[i] - 'A' + 1) // 將字母映射到 1~26  \n   No  → Error // 非法字元處理  \n  result ← result * 26 + value // 在 base‑26 中累加  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef title_to_number(column_title: str) -> int:\n    \"\"\"Convert Excel column title to its corresponding number.\"\"\"\n    result = 0\n    for char in column_title:\n        result = result * 26 + (ord(char) - ord('A') + 1)\n    return result\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read()\n\n    # 從輸入中尋找單引號或雙引號包住的字串\n    match = re.search(r\"['\\\"](.*?)['\\\"]\", data)\n    if match:\n        column_title = match.group(1)\n    else:\n        # 若沒有引號，直接去除前後空白及可能的前置文字\n        column_title = data.strip().replace(\"columnTitle = \", \"\").strip(\"'\\\"\")\n\n    # 計算並輸出結果\n    result = title_to_number(column_title)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnTitle = 'A'",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "columnTitle = 'AB'",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 2,
          "input": "columnTitle = 'ZY'",
          "expected_output": "701",
          "success": true,
          "output": "701"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode39.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum",
    "description_snippet": "Given an array of distinct integers candidates and a target integer target, return a list of all uni...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for combination sum problem. Use recursion/backtracking. Provide step-by-step pseudo code lines. Each line with explanation. Use Start, End, Decision, etc. Must not output actual code. Just virtual steps.\n\nWe need to cover: Start, read array candidates, target. Possibly sort. Then define recursive function combinationSum(index, remaining, currentPath). Use for loop from index to end. Decision if candidate > remaining skip or break if sorted. For each, add to path, recursive call with same index (since unlimited). Then pop. After loop return.\n\nCollect results list.\n\nAt the top-level, call function with index 0, target, empty path.\n\nEnd.\n\nEnsure each line includes arrow. Use '→' for steps, 'Decision:' for conditions. Provide explanation after '//'.\n\nLet's produce. Ensure each line includes arrow or not? Format example: Start // comment, then arrow steps. We'll produce each line with arrow for steps, but Start without arrow. Use indentation for decision branches.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 載入 candidates 陣列並設定 target // 取得輸入資料\n→ Step 2: 將 candidates 陣列排序 // 方便後續剪枝\n→ Step 3: 初始化結果 list combinations 為空 // 用於儲存所有有效組合\n→ Step 4: 呼叫 Backtrack(0, target, 空清單) // 開始遞迴搜尋\n\nNow define Backtrack:\n\n→ Function Backtrack(startIndex, remaining, currentPath) // 定義遞迴函式\n    → Decision: remaining == 0? // 檢查是否已達目標\n        Yes → Step: 將 currentPath 的拷貝加入 combinations // 存入有效組合\n        No  → Step: 若 startIndex 等於 candidates 長度? // 沒有更多數字可選\n            Yes → Step: 返回 // 結束此分支\n            No  → Step: 從 startIndex 到 candidates 長度 循環\n                → Decision: candidates[i] > remaining? // 若數字大於剩餘值\n                    Yes → Step: 跳過此分支並結束循環 // 以後數字更大，同樣不符合\n                    No  → Step: 將 candidates[i] 加入 currentPath // 選取此數字\n                    → Step: 呼叫 Backtrack(i, remaining - candidates[i], currentPath) // 同索引可重複選取\n                    → Step: 移除 currentPath 中最後一個數字 // 回溯到上一狀態\n\nFinally End.\n\nBut we need each line exactly one line with arrow and comment. For nested lines, use indentation with spaces? In example they indent under Decision: with spaces. We'll follow that. Each line of code ends with comment.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 載入 candidates 陣列並設定 target // 取得輸入資料  \n→ Step 2: 將 candidates 陣列排序 // 方便後續剪枝  \n→ Step 3: 初始化結果 list combinations 為空 // 用於儲存所有有效組合  \n→ Step 4: 呼叫 Backtrack(0, target, 空清單) // 開始遞迴搜尋  \n\n→ Function Backtrack(startIndex, remaining, currentPath) // 定義遞迴函式  \n    → Decision: remaining == 0? // 檢查是否已達目標  \n        Yes → Step: 將 currentPath 的拷貝加入 combinations // 存入有效組合  \n        No  → Decision: startIndex == candidates.length? // 沒有更多數字可選  \n            Yes → Step: 返回 // 結束此分支  \n            No  → Step: 從 startIndex 到 candidates.length - 1 迴圈  \n                → Decision: candidates[i] > remaining? // 若數字大於剩餘值  \n                    Yes → Step: 跳過此分支並結束循環 // 以後數字更大，同樣不符合  \n                    No  → Step: 將 candidates[i] 加入 currentPath // 選取此數字  \n                    → Step: 呼叫 Backtrack(i, remaining - candidates[i], currentPath) // 同索引可重複選取  \n                    → Step: 移除 currentPath 中最後一個數字 // 回溯到上一狀態  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combinationSum(self, candidates, target):\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, total + candidates[i])\n                path.pop()\n\n        backtrack(0, [], 0)\n        return res\n\ndef parse_input(data: str):\n    # 提取 candidates 列表\n    cand_match = re.search(r'\\[([^\\]]*)\\]', data)\n    candidates = []\n    if cand_match:\n        cand_str = cand_match.group(1).strip()\n        if cand_str:\n            candidates = [int(x.strip()) for x in cand_str.split(',')]\n    # 提取 target 整數\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    target = int(target_match.group(1)) if target_match else 0\n    return candidates, target\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    candidates, target = parse_input(input_data)\n    sol = Solution()\n    result = sol.combinationSum(candidates, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "success": true,
          "output": "[[2, 2, 3], [7]]"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "success": true,
          "output": "[[2, 2, 2, 2], [2, 3, 3], [3, 5]]"
        },
        {
          "example_index": 2,
          "input": "candidates = [2], target = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode525.json",
    "problem_index_in_file": 0,
    "title": "Contiguous Array",
    "description_snippet": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps with comments. Use Start, Decision, etc. We need algorithm: traverse array, maintain counter difference between number of 1s and 0s. Use map of first index of each diff. Use cumulative sum. When diff seen again, compute length. Finally return max.\n\nWe'll produce steps like:\n\nStart\n→ Step 1: Initialize map diffIndex with 0→-1 // store first occurrence\n→ Step 2: Initialize counter diff=0, maxLen=0\n→ Step 3: For i from 0 to len(nums)-1:\n   → Step 3.1: Update diff based on nums[i] (if 1 diff++ else diff--)\n   → Step 3.2: If diff exists in map:\n        → Step 3.2.1: Calculate length = i - diffIndex[diff]\n        → Step 3.2.2: Update maxLen if greater\n      Else:\n        → Step 3.2.3: Store diff→i in map\n→ Step 4: Return maxLen\nEnd\n\nAdd explanation comments.\n\nEnsure each line has code + comment.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 map diffIndex，將差值 0 映射到索引 -1 // 方便處理從頭開始的子陣列  \n→ Step 2: 初始化 counter diff = 0, maxLen = 0 // diff 為 0 與 1 的數量差值，maxLen 為最大長度  \n→ Step 3: 循環 i 從 0 到 len(nums)-1  \n  → Decision: 如果 nums[i] == 1? // 判斷當前元素  \n   Yes → Step 3.1: diff ← diff + 1 // 1 增加差值  \n   No  → Step 3.1: diff ← diff - 1 // 0 減少差值  \n  → Decision: diff 是否已存在於 diffIndex? // 檢查是否之前遇到過相同差值  \n   Yes → Step 3.2.1: length ← i - diffIndex[diff] // 計算子陣列長度  \n    → Step 3.2.2: maxLen ← max(maxLen, length) // 更新最大長度  \n   No  → Step 3.2.3: diffIndex[diff] ← i // 記錄此差值第一次出現的索引  \n→ Step 4: 返回 maxLen // 回傳最長長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaxLength(self, nums):\n        # Map to store first occurrence of each difference value\n        diff_index = {0: -1}\n        max_len = 0\n        diff = 0\n\n        for i, num in enumerate(nums):\n            # Update difference: +1 for 1, -1 for 0\n            diff += 1 if num == 1 else -1\n\n            if diff in diff_index:\n                # Same difference seen before => equal number of 0 and 1 in subarray\n                length = i - diff_index[diff]\n                if length > max_len:\n                    max_len = length\n            else:\n                # Record first index of this difference\n                diff_index[diff] = i\n\n        return max_len\n\nif __name__ == \"__main__\":\n    # Read entire input, e.g. \"[0,1,0]\"\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Convert string representation to list of integers\n    nums = ast.literal_eval(data)\n    result = Solution().findMaxLength(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[0,1,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,1,1,1,1,1,0,0,0]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode207.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the Course Schedule problem. We need to provide each line with explanation. Use Start, End, Decision: etc. Let's design algorithm: use DFS to detect cycle, or Kahn's algorithm. We'll produce a generic solution. Let's go with DFS cycle detection.\n\nSteps: Start, Input numCourses, prerequisites. Build adjacency list. Initialize visited array of size numCourses with 0 (unvisited), 1 (visiting), 2 (visited). For each course, if not visited, call DFS. DFS returns true if no cycle. If cycle found return false. If all courses visited no cycle return true. End.\n\nNow produce virtual code line by line with explanation.\n\nNeed to output with each line having `虛擬碼步驟` + space + `// 解釋`. Use arrows etc.\n\nLet's produce lines:\n\nStart\n→ Step 1: 建立鄰接清單 graph ← 空清單 // 建立圖\n→ Step 2: 針對每個 [a,b] in prerequisites: graph[b].append(a) // 邊代表必修順序\n→ Step 3: 建立 visited 陣列長度 numCourses 初始化 0 // 0未訪問,1訪問中,2已完成\n→ Decision: 是否有循環? // 判斷是否能完成所有課程\n    → For course 0 to numCourses-1\n        → Decision: visited[course] == 0? // 尚未探索\n            Yes → Step 4: 執行 DFS(course) // 深度優先搜尋\n            No → 跳過\n→ Decision: DFS 回傳 False? // 產生循環\n    Yes → Step 5: 回傳 False // 無法完成\n    No  → Step 6: 回傳 True // 可以完成\nEnd\n\nBut we need to provide each line; loops and decisions need formatting.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Step 1: 建立 graph ← 空字典 // 初始化鄰接清單\n→ Step 2: 針對每個 [a, b] 在 prerequisites\n    → Step 2.1: graph.setdefault(b, []).append(a) // 將 a 加入 b 的鄰接\n→ Step 3: 產生 visited 陣列長度 numCourses 全部設為 0 // 標記狀態\n→ Step 4: 定義函式 DFS(course)\n    → Step 4.1: If visited[course] == 1 → return False // 循環檢測\n    → Step 4.2: If visited[course] == 2 → return True // 已完成\n    → Step 4.3: visited[course] ← 1 // 標記正在訪問\n    → Step 4.4: For 每個 neighbor in graph.get(course, [])\n        → Decision: DFS(neighbor) 是否 False?\n            Yes → return False // 子節點產生循環\n            No  → 繼續\n    → Step 4.5: visited[course] ← 2 // 標記已完成\n    → Step 4.6: return True // 無循環\n→ Step 5: For i 從 0 到 numCourses-1\n    → Decision: visited[i] == 0?\n        Yes → Decision: DFS(i) 是否 False?\n            Yes → Step 5.1: return False // 找到循環\n            No  → 繼續\n        No  → 跳過\n→ Step 6: return True // 所有課程可完成\nEnd // 程式結束\n\nBut we must output each line sequentially, including nested lines with indentation maybe. The format says use arrows and Decision: and Yes →, No →. So each line should contain that. We should include nested decisions. Let's produce lines exactly:\n\nStart // 程式開始執行\n→ Step 1: graph ← 空字典 // 建立鄰接清單\n→ Step 2: 針對每個 [a, b] 在 prerequisites\n    → Step 2.1: graph.setdefault(b, []).append(a) // 將 a 加入 b 的鄰接\n→ Step 3: visited ← [0] * numCourses // 建立狀態陣列\n→ Step 4: 定義函式 DFS(course)\n    → Step 4.1: Decision: visited[course] == 1? // 檢查是否在訪問中\n        Yes → Step 4.1a: return False // 找到循環\n        No  → Decision: visited[course] == 2? // 檢查是否已完成\n            Yes → Step 4.1b: return True // 已完成\n            No  → Step 4.1c: visited[course] ← 1 // 標記正在訪問\n    → Step 4.2: For neighbor 在 graph.get(course, [])\n        → Decision: DFS(neighbor) 是否 False?\n            Yes → Step 4.2a: return False // 子節點循環\n            No  → Step 4.2b: 繼續\n    → Step 4.3: visited[course] ← 2 // 標記已完成\n    → Step 4.4: return True // 無循環\n→ Step 5: 針對 i 從 0 到 numCourses-1\n    → Decision: visited[i] == 0? // 尚未探索\n        Yes → Decision: DFS(i) 是否 False?\n            Yes → Step 5.1: return False // 找到循環\n            No  → Step 5.2: 繼續\n        No  → Step 5.3: 繼續\n→ Step 6: return True // 所有課程可完成\nEnd // 程式結束\n\nMake sure each line has `虛擬碼步驟` and then space then `// 解釋`. So we need to prefix each line with e.g., `Start //`. Actually each line: `Start // 程式開始執行`. But earlier example had `Start // 程式開始執行`. They didn't have arrow before Start. So we keep same.\n\nNow for nested steps, we still need to output each line with indentation? In example they used indentation but still each line separate. They used arrow after Step? In example: `→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值`. They used arrow arrow at start. For nested decisions they used indentation but still lines. So we will mimic.\n\nThus final output lines as described. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: graph ← 空字典 // 建立鄰接清單  \n→ Step 2: 針對每個 [a, b] 在 prerequisites  \n    → Step 2.1: graph.setdefault(b, []).append(a) // 將 a 加入 b 的鄰接  \n→ Step 3: visited ← [0] * numCourses // 建立狀態陣列  \n→ Step 4: 定義函式 DFS(course)  \n    → Step 4.1: Decision: visited[course] == 1? // 檢查是否在訪問中  \n        Yes → Step 4.1a: return False // 找到循環  \n        No → Decision: visited[course] == 2? // 檢查是否已完成  \n            Yes → Step 4.1b: return True // 已完成  \n            No → Step 4.1c: visited[course] ← 1 // 標記正在訪問  \n    → Step 4.2: For neighbor 在 graph.get(course, [])  \n        → Decision: DFS(neighbor) 是否 False?  \n            Yes → Step 4.2a: return False // 子節點循環  \n            No → Step 4.2b: 繼續  \n    → Step 4.3: visited[course] ← 2 // 標記已完成  \n    → Step 4.4: return True // 無循環  \n→ Step 5: 針對 i 從 0 到 numCourses-1  \n    → Decision: visited[i] == 0? // 尚未探索  \n        Yes → Decision: DFS(i) 是否 False?  \n            Yes → Step 5.1: return False // 找到循環  \n            No → Step 5.2: 繼續  \n        No → Step 5.3: 繼續  \n→ Step 6: return True // 所有課程可完成  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites) -> bool:\n        # 建立鄰接清單與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # Kahn 的拓撲排序\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        visited = 0\n        while queue:\n            node = queue.popleft()\n            visited += 1\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return visited == numCourses\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 將類似 'numCourses = 2, prerequisites = [[1,0]]' 轉為 dict\n    data = re.sub(r'(\\w+)\\s*=', r\"'\\1':\", data)\n    params = ast.literal_eval('{' + data + '}')\n\n    numCourses = params['numCourses']\n    prerequisites = params['prerequisites']\n\n    sol = Solution()\n    result = sol.canFinish(numCourses, prerequisites)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode459.json",
    "problem_index_in_file": 0,
    "title": "Repeated Substring Pattern",
    "description_snippet": "Given a string s, check if it can be constructed by taking a substring of it and appending multiple ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines following the format. Steps: Start, read string s, find length n, iterate period length from 1 to n/2, if n%len==0 and substring*count equals s. Use Decision branches etc. Should produce virtual code lines with arrows and comments.\n\nWe need to produce line by line: \"Start // ...\", \"→ Step 1: ...\", \"→ Decision:\" with Yes/No branches etc.\n\nMake sure each line has \"虛擬碼步驟\" and comment. Use arrow. Use proper structure.\n\nWe need to include the algorithm logic.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 取得輸入字串\n→ Step 2: 計算長度 n = s.length() // 取得字串長度\n→ Step 3: 初始化布林變數 result = false // 假設無法構造\n→ Decision: n 是否大於 1? // 若單字串不可能構造\n    Yes → → Loop i from 1 to n/2 // 迭代可能的子字串長度\n        → Step 4: 若 n % i == 0? // 只有整除時才可能\n            Yes → → Step 5: 取子字串 sub = s.substr(0, i) // 取得候選子字串\n            → Step 6: 構造重複字串 repeated = sub * (n / i) // 重複多次\n            → Decision: repeated == s? // 比較是否相等\n                Yes → → Step 7: 設置 result = true // 找到匹配\n                No  → // 其他長度繼續搜尋\n        No  → // i 不是整除，跳過\n    No  → // n <= 1，直接判斷為 false\n→ Step 8: 輸出 result // 回傳能否構造的結果\nEnd // 程式結束\n\nNeed to ensure arrow formatting: \"→ Decision:\" etc. For nested arrows maybe we indent but we can keep same arrow.\n\nBetter to show nested decision with indentation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得輸入字串  \n→ Step 2: 計算長度 n = s.length() // 取得字串長度  \n→ Step 3: 初始化布林變數 result = false // 假設無法構造  \n→ Decision: n 是否大於 1? // 若單字串不可能構造  \n&nbsp;&nbsp;Yes → → Loop i from 1 to n/2 // 迭代可能的子字串長度  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: 若 n % i == 0? // 只有整除時才可能  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → → Step 5: 取子字串 sub = s.substr(0, i) // 取得候選子字串  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: 構造重複字串 repeated = sub * (n / i) // 重複多次  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: repeated == s? // 比較是否相等  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → → Step 7: 設置 result = true // 找到匹配  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 其他長度繼續搜尋  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → // i 不是整除，跳過  \n&nbsp;&nbsp;No  → // n <= 1，直接判斷為 false  \n→ Step 8: 輸出 result // 回傳能否構造的結果  \nEnd // 程式結束",
      "generated_code": "import sys\n\nclass Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        \"\"\"判斷是否可以由某個子字串多次重複得到 s\"\"\"\n        n = len(s)\n        # 只需要考慮子字串長度到 n//2，因為至少要重複兩次\n        for i in range(1, n // 2 + 1):\n            if n % i == 0:                     # 長度必須能整除\n                if s[:i] * (n // i) == s:     # 生成的重複字串是否相等\n                    return True\n        return False\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    將可能的輸入格式（例如 s = \"abab\" 或僅有字串）解析成純字串。\n    \"\"\"\n    raw = raw.strip()\n    # 若含有引號，取引號內的內容\n    if '\"' in raw:\n        start = raw.find('\"')\n        end = raw.rfind('\"')\n        if start != -1 and end != start:\n            return raw[start+1:end]\n    # 若含有等號，取等號右側並移除空白\n    if '=' in raw:\n        return raw.split('=', 1)[1].strip()\n    # 直接返回去除首尾空白的字串\n    return raw\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 以換行分割，選擇第一行非空白行作為輸入\n    lines = [line for line in data.splitlines() if line.strip()]\n    raw_input = lines[0] if lines else \"\"\n    s = parse_input(raw_input)\n\n    sol = Solution()\n    result = sol.repeatedSubstringPattern(s)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"abcabcabcabc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode528.json",
    "problem_index_in_file": 0,
    "title": "Random Pick with Weight",
    "description_snippet": "You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith in...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. The requirement: \"You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index. Implement pickIndex() function that returns random index according to weights.\" So we need to design algorithm: precompute prefix sums, generate random number in [1, total], binary search to find index. The virtual code will include initialization steps: compute prefix sums and total weight. Then pickIndex: generate random integer between 1 and total, binary search over prefix sums to find first index where prefix >= random. Then return that index.\n\nWe need to output step-by-step pseudocode with arrow syntax. Should be multiple lines. Use Start, End, Decision. Provide explanation after each line. Use arrows and indentation.\n\nMake sure to show decision for binary search. Possibly separate lines: Step: initialize array prefix. Step: set total. Step: function pickIndex. Step: generate rand. Step: binary search loop: decision: mid <=? etc.\n\nWe'll produce something like:\n\nStart // Program start\n→ Step 1: Compute prefix sums of w // build cumulative weight array\n→ Step 2: Store total weight = prefix[w.length-1] // total sum\n→ Function: pickIndex // start pickIndex function\n    → Step 3: Generate random integer r between 1 and total // inclusive\n    → Step 4: Set low = 0, high = w.length - 1 // binary search bounds\n    → Decision: While low < high? // binary search loop\n        Yes → Step 5: mid = (low + high) // 2 // middle index\n        → Decision: If prefix[mid] < r? // compare cumulative weight\n            Yes → Step 6: low = mid + 1 // move lower bound\n            No  → Step 7: high = mid // shrink upper bound\n        No  → Step 8: Return low // found index\nEnd // End program\n\nWe need to include explanation comments after each line. Also arrow formatting with indentation. Use `→` before each step. For decisions use `Decision:`. For \"Yes →\" and \"No →\".\n\nMake sure to use indentation properly: maybe 4 spaces before nested lines. Provide explanation after comment.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 prefix[ ] 為 w 的累積和 // 先把各重複的加總存成前綴和  \n→ Step 2: 設定 total = prefix[w.length-1] // 總重複量，作為隨機數上限  \n→ Function: pickIndex // 開始 pickIndex 函式  \n    → Step 3: 產生 r = 隨機整數(1, total) // 取得 [1,total] 之隨機數  \n    → Step 4: low = 0, high = w.length - 1 // 二分搜尋的左右指標  \n    → Decision: while low < high? // 是否還有區間可縮小？  \n        Yes → Step 5: mid = (low + high) // 2 // 計算中間索引  \n        → Decision: prefix[mid] < r? // 前綴和是否小於隨機數？  \n            Yes → Step 6: low = mid + 1 // 前半段全不符合，移到後半段  \n            No  → Step 7: high = mid // 前半段有可能包含答案，縮小上限  \n        No  → Step 8: return low // low 即為符合條件的索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        # 建立前綴和\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 產生 [1, total] 之隨機數\n        target = random.randint(1, self.total)\n        # 二分搜尋最小的 prefix >= target\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把輸入包成一個 JSON 陣列，方便解析\n    data_wrapped = '[' + data + ']'\n    methods, args_list = json.loads(data_wrapped)\n\n    obj = None\n    results = []\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(args[0])\n            results.append(None)            # 建構子回傳 null\n        else:\n            res = getattr(obj, method)(*args)\n            results.append(res)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "success": true,
          "output": "[null, 0]"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,0,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 0, 1]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode394.json",
    "problem_index_in_file": 0,
    "title": "Decode String",
    "description_snippet": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: k[encoded_string], where ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for decoding string with k[...]. Use stack approach. Provide line by line with arrow. Each line with comment. Ensure start, decision, etc. Provide steps: parse string, use stack for chars and numbers. While iterating: if digit accumulate number; if '[' push current buffer and num; reset buffer; if ']' pop repeat times and previous string, append. Finally output buffer. Provide pseudocode lines.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 stack ← 空堆疊 // 用來儲存之前的字串\n→ Step 2: 設定 num ← 0 // 儲存目前解析到的重複數字\n→ Step 3: 設定 current ← 空字串 // 暫存目前累積的字元\n→ Step 4: 逐字遍歷輸入字串 s\n    → Decision: 若 s[i] 是數字? // 檢查是否為重複數字\n        Yes → num ← num * 10 + 數字值(s[i]) // 連續數字組成整數\n        No  → Decision: 若 s[i] 是 '['? // 開啟括號\n            Yes → stack.push(current) // 儲存目前字串到堆疊\n            → stack.push(num) // 儲存目前重複數字到堆疊\n            → current ← 空字串 // 重置暫存字串\n            → num ← 0 // 重置重複數字\n            No  → Decision: 若 s[i] 是 ']'? // 關閉括號\n                Yes → repeat ← stack.pop() // 取出重複數字\n                → prev ← stack.pop() // 取出之前的字串\n                → current ← prev + current * repeat // 重複並合併\n                No  → current ← current + s[i] // 普通字元加入暫存\n→ Step 5: output ← current // 最終解碼結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        \"\"\"\n        使用堆疊的方式把編碼字串解碼成最終字串。\n        \"\"\"\n        stack = []          # 追蹤之前的字串與重複數字\n        current_num = 0     # 當前解析到的重複次數\n        current_str = ''    # 當前累積的字串\n\n        for ch in s:\n            if ch.isdigit():\n                # 連續數字組成整數\n                current_num = current_num * 10 + int(ch)\n            elif ch == '[':\n                # 把目前的字串跟重複次數存進堆疊\n                stack.append((current_str, current_num))\n                current_str = ''\n                current_num = 0\n            elif ch == ']':\n                # 把最外層的字串取出並重複\n                prev_str, num = stack.pop()\n                current_str = prev_str + current_str * num\n            else:\n                # 普通字元加入暫存字串\n                current_str += ch\n        return current_str\n\ndef extract_input(raw: str) -> str:\n    \"\"\"\n    從輸入中抽取實際的編碼字串。\n    如果輸入形如 s = \"abc\" 則取出 abc；否則直接使用整個輸入。\n    \"\"\"\n    match = re.search(r'\"(.*?)\"', raw)\n    return match.group(1) if match else raw.strip()\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit()\n\n    encoded_str = extract_input(raw_input)\n    solution = Solution()\n    decoded = solution.decodeString(encoded_str)\n    print(decoded)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3[a]2[bc]\"",
          "expected_output": "\"aaabcbc\"",
          "success": true,
          "output": "aaabcbc"
        },
        {
          "example_index": 1,
          "input": "s = \"3[a2[c]]\"",
          "expected_output": "\"accaccacc\"",
          "success": true,
          "output": "accaccacc"
        },
        {
          "example_index": 2,
          "input": "s = \"2[abc]3[cd]ef\"",
          "expected_output": "\"abcabccdcdcdef\"",
          "success": true,
          "output": "abcabccdcdcdef"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode191.json",
    "problem_index_in_file": 0,
    "title": "Number of 1 Bits",
    "description_snippet": "Given a positive integer n, write a function that returns the number of set bits in its binary repre...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting set bits in a positive integer n. Use standard algorithm: while n > 0, count += n & 1; n >>= 1. Or use n & (n-1) trick. Provide step-by-step with Start, Step, Decision, End.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrows, Decision: etc. Use Start, End. Provide step numbers.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 定義變數 count ← 0 // 初始化計數器\n→ Step 2: 將輸入 n 複製到 temp 變數 // 以免改變原始值\n→ Decision: temp 是否為 0? // 檢查是否還有位元需要處理\n    Yes → End // 若 temp 為 0，結束計算\n    No  → Step 3: count ← count + (temp & 1) // 若最低位為 1，計數器加一\n    → Step 4: temp ← temp >> 1 // 右移一位，丟棄已處理的最低位\n    → Step 5: 前往 Decision: temp 是否為 0? // 重複循環\n→ Step 6: Return count // 回傳計算得到的位元總數\nEnd // 程式執行結束\n\nBut the loop structure: use Decision and loops. Should we add loop arrow? Could do:\n\n→ Decision: temp > 0?\n    Yes → ... \n    No → ...\n\nBut need to show iteration.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 count ← 0 // 初始化計數器  \n→ Step 2: 將輸入 n 複製到 temp 變數 // 以免改變原始值  \n→ Decision: temp > 0? // 檢查是否還有位元需要處理  \n Yes → Step 3: count ← count + (temp & 1) // 若最低位為 1，計數器加一  \n  → Step 4: temp ← temp >> 1 // 右移一位，丟棄已處理的最低位  \n  → Step 5: 前往 Decision: temp > 0? // 重新檢查是否還有位元  \n No  → Step 6: Return count // 回傳計算得到的位元總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        \"\"\"\n        计算整数 n 的二进制表示中 1 的个数（Hamming weight）。\n        通过连续右移并使用按位与操作来统计 1 的数量。\n        \"\"\"\n        count = 0\n        while n:\n            count += n & 1   # 若最低位为 1，则计数器加一\n            n >>= 1          # 右移一位，丢弃已处理的最低位\n        return count\n\ndef main() -> None:\n    \"\"\"\n    从标准输入读取整数 n，并输出其二进制表示中的 1 的个数。\n    输入示例：'n = 11'、'n = 128' 等。\n    \"\"\"\n    data = sys.stdin.read()\n    # 提取所有整数（支持负数，但题目保证为正整数）\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n\n    solution = Solution()\n    result = solution.hammingWeight(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 128",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2147483645",
          "expected_output": "30",
          "success": true,
          "output": "30"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1337.json",
    "problem_index_in_file": 0,
    "title": "The K Weakest Rows in a Matrix",
    "description_snippet": "You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civili...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. The algorithm: count soldiers per row (binary sorted rows). Use binary search to find first zero. Or linear scan. Then store pairs (count, index). Sort by count then index. Then take first k indices. Return.\n\nWe need to output as per format. Use arrows. Steps: Start, Step: compute soldiers per row, store list, Step: sort, Step: extract indices, End.\n\nAdd Decision nodes? Maybe no.\n\nBut we can include Decision for k <= m.\n\nLet's produce. Ensure each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空列表 rowsInfo // 用於儲存每列的 (士兵數, 行索引)  \n→ Decision: 若 mat 為空? // 檢查矩陣是否為空  \n    Yes → End // 空矩陣直接結束，無需處理  \n    No  → Continue  \n→ Step 2: 對每一行 i 從 0 到 m-1 執行  \n→ Step 3: 透過二分搜尋找出第一個 0 的位置 pos // pos 即為士兵數目  \n    // 若整行都是 1，則 pos = n  \n→ Step 4: 將 (pos, i) 加入 rowsInfo // 以士兵數及行索引作為排序依據  \n→ Step 5: 完成所有行的計算後，對 rowsInfo 進行排序  \n    // 排序先按士兵數升序，再按行索引升序，符合「弱」的定義  \n→ Step 6: 取前 k 個元素的行索引並存入 result // 這就是 k 個最弱的行  \n→ End // 程式執行結束，result 為輸出結果",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        # binary search to count soldiers in a row\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        # pair each row with its soldier count\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        # sort by count then by index\n        soldiers.sort()\n        # return indices of the first k weakest rows\n        return [i for _, i in soldiers[:k]]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # extract the matrix and k using a regular expression\n    pattern = r\"mat\\s*=\\s*(\\[\\[.*?\\]\\])\\s*,?\\s*k\\s*=\\s*(\\d+)\"\n    match = re.search(pattern, data, re.S)\n    if not match:\n        print(\"[]\")\n        return\n    mat_str, k_str = match.group(1), match.group(2)\n    mat = ast.literal_eval(mat_str)\n    k = int(k_str)\n\n    result = Solution().kWeakestRows(mat, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "success": true,
          "output": "[2, 0, 3]"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "success": true,
          "output": "[0, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode753.json",
    "problem_index_in_file": 0,
    "title": "Cracking the Safe",
    "description_snippet": "There is a safe protected by a password. The password is a sequence of n digits where each digit can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a virtual algorithm that outputs a string of minimal length that guarantees that the correct password (unknown) appears as a contiguous subsequence of length n in the input sequence of digits 0..k-1. We need to generate a string that contains every possible n-length password as a substring (so that whichever is correct, it will appear). This is De Bruijn sequence problem. We need to produce minimal length = k^n + n -1. The algorithm: build De Bruijn graph of order n over alphabet of size k, find Eulerian circuit, output sequence. Virtual code steps: Start, build graph, find Eulerian circuit using Hierholzer, output first node, then each edge label, etc. Then End. Provide explanation after each line.\n\nWe need to output step-by-step pseudocode with arrow and decision. So structure: Start, Step 1: Build adjacency list for nodes of length n-1, etc. We must use arrow. Let's craft lines.\n\nEnsure we have each line as: `虛擬碼步驟 // 解釋`.\n\nUse Chinese.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 產生所有長度為 n-1 的節點 (所有 (n-1)-長字串) // 建立 De Bruijn 圖的節點  \n→ Step 2: 為每個節點 v 產生 k 條出邊，每條邊標記為 d (0 ≤ d < k)，指向節點 u = (v 的最後 n-2 個字元 + d) // 建立所有可能的遞移  \n→ Decision: 是否所有節點都有出度 k? // 確認圖為正規 De Bruijn 圖  \n  Yes → Step 3: 用 Hierholzer 演算法找到 Euler 循環 // 取得一次完整的 Euler 循環  \n  No  → Step 4: 輸出錯誤訊息並結束 // 若不滿足條件則不可生成序列  \n→ Step 5: 從 Euler 循環取出第一個節點的字串作為起始序列 // 初始 n-1 位數字  \n→ Step 6: 遍歷循環中每條邊，將其標記 d 加到序列尾部 // 形成長度 k^n + n - 1 的序列  \n→ Step 7: 輸出該序列作為最短可能解 // 任何 n 位密碼都將出現在此序列內  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def crackSafe(self, n: int, k: int) -> str:\n        # Special case: n == 1, the shortest sequence is simply all digits\n        if n == 1:\n            return ''.join(str(i) for i in range(k))\n\n        seen = set()\n        res = []\n\n        def dfs(node: str):\n            for d in map(str, range(k)):\n                nxt = node + d\n                if nxt not in seen:\n                    seen.add(nxt)\n                    dfs(nxt[1:])\n                    res.append(d)\n\n        start = '0' * (n - 1)\n        dfs(start)\n        return ''.join(res) + start\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    sol = Solution()\n    answer = sol.crackSafe(n, k)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '01'\n--- (Raw) ---\nRaw Expected: '\"10\"'\nRaw Got:      '01'"
        },
        {
          "example_index": 1,
          "input": "n = 2, k = 2",
          "expected_output": "\"01100\"",
          "success": true,
          "output": "01100"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode172.json",
    "problem_index_in_file": 0,
    "title": "Factorial Trailing Zeroes",
    "description_snippet": "Given an integer n, return the number of trailing zeroes in n!. \n\nNote that n! = n * (n - 1) * (n - ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Problem: trailing zeroes in n! is count of factors of 5 in factorial. So algorithm: count = 0; while n>0: n = n/5; count += n. Actually floor division.\n\nWe need to output line by line: Start, Step 1: Input n, Step 2: initialize count = 0, Step 3: loop while n>0, Step 4: divide n by 5 (integer division), Step 5: add to count, Step 6: end loop, Step 7: output count, End.\n\nAlso we can add decision steps: Decision: n > 0? etc.\n\nLet's format each line as: \"虛擬碼步驟 // 解釋\". Use arrow or \"→\" etc. Let's create:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 從使用者取得 n\n→ Step 2: 設定 count = 0 // 用於累計 5 的倍數個數\n→ Decision: n > 0? // 判斷是否仍有可除以 5 的數\n    Yes → Step 3: n = n / 5 (整數除法) // 取 n 的五分之一\n    → Step 4: count = count + n // 將新得到的 n 加入 count\n    → Decision: n > 0? // 檢查下一輪是否還有更小的 5 倍數\n        Yes → repeat Step 3... // 迴圈\n        No  → Step 5: 輸出 count // 輸出總數\nEnd // 程式結束\n\nBut we need each line separated. Need to include decision and arrow. Let's structure properly:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 從使用者取得 n\n→ Step 2: 設定 count = 0 // 初始化計數器\n→ Decision: n > 0? // 判斷是否仍有數可處理\n    Yes → Step 3: n = n / 5 (整數除法) // 除以 5，取得下一層的 5 倍數\n    → Step 4: count = count + n // 累加\n    → Decision: n > 0? // 檢查是否繼續\n        Yes → Step 3 // 重複迴圈\n        No  → Step 5: 輸出 count // 輸出結果\nEnd // 程式結束\n\nBut each line must be \"虛擬碼步驟 // 解釋\". Need to use \"→\" arrow before each step. For decisions, we might use \"Decision:\" lines. Use indentation? We can just put them on separate lines with indent? Not necessary but can be shown.\n\nLet's produce final answer with each line. Use Chinese comments. Ensure each line ends with \"// 解釋\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 從使用者取得 n  \n→ Step 2: 設定 count = 0 // 初始化計數器  \n→ Decision: n > 0? // 判斷是否仍有數可處理  \n  Yes → Step 3: n = n / 5 (整數除法) // 除以 5，取得下一層的 5 倍數  \n  → Step 4: count = count + n // 將新得到的 n 加入 count  \n  → Decision: n > 0? // 檢查是否繼續  \n    Yes → Step 3 // 重複迴圈  \n    No → Step 5: 輸出 count // 輸出總數  \nEnd // 程式結束",
      "generated_code": "import sys\n\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n        count = 0\n        while n > 0:\n            n //= 5\n            count += n\n        return count\n\ndef parse_input(data: str) -> int:\n    data = data.strip()\n    if '=' in data:\n        # Accept format like \"n = 5\" or \"n=5\"\n        parts = data.split('=', 1)\n        num_part = parts[1].strip()\n    else:\n        num_part = data\n    return int(num_part)\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    n = parse_input(raw_input)\n    result = Solution().trailingZeroes(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode720.json",
    "problem_index_in_file": 0,
    "title": "Longest Word in Dictionary",
    "description_snippet": "Given an array of strings words representing an English Dictionary, return the longest word in words...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. For each line: Virtual code step + // explanation. Use arrows, Start, End, Decision. Provide algorithm: sort words by length and lexicographically, use set to store built words, iterate, if prefix exists add to set, track longest. Let's craft steps line by line.\n\nStart\n→ Step 1: Sort words by length ascending then lexicographic // order so that shorter words processed first\n→ Step 2: Initialize empty set builtWords // holds words that can be built\n→ Step 3: Initialize empty string result // longest valid word found\n→ Decision: For each word in sorted list? // loop through words\n   Yes → Step 4: If word length 1 or its prefix (word without last char) exists in builtWords // check if can build\n        Yes → Step 5: Add word to builtWords // mark as buildable\n        Yes → Step 6: If word longer than result or same length but lexicographically smaller // update best\n             Yes → Step 7: Set result = word\n        No  → Step 8: // cannot build, skip\n   No → // end loop\nEnd // return result\n\nBut need to use virtual code lines with arrows. We'll do like:\n\nStart\n→ Step 1: Sort words by (length, lex) // ensures shorter/earlier lex words first\n→ Step 2: Initialize builtWords as empty set // to track buildable words\n→ Step 3: Initialize result as empty string // stores longest buildable word\n→ Step 4: For each word in words // iterate sorted list\n    → Decision: If word length == 1 OR prefix exists in builtWords // can build?\n        Yes → Step 5: Add word to builtWords // mark as buildable\n        Yes → Decision: If word longer than result OR (same length AND word < result) // better candidate\n            Yes → Step 6: Set result = word // update best\n        No  → // no update\n    No  → // cannot build, skip\nEnd\n\nMake sure each line ends with // explanation. Use \"→\" to indicate next step. Use \"Decision:\" with Yes → etc. Provide each line as separate. Should we include indentation? Possibly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort words by (length ascending, then lexicographical order) // 先將單字依長度再字典序排序，方便先處理較短或較小的字  \n→ Step 2: 初始化 empty set builtWords // 用來記錄已能構造的單字  \n→ Step 3: 初始化 result 為空字串 // 儲存目前找到的最長可構造單字  \n→ Step 4: 逐一遍歷 words  // 依排序順序處理每個單字  \n  → Decision: 如果單字長度為 1 或者它的前綴 (除最後一個字母) 存在於 builtWords? // 判斷是否可構造  \n   Yes → Step 5: 將該單字加入 builtWords // 標記為可構造  \n   Yes → Decision: 該單字是否比目前 result 更長，或長度相同且字典序更小? // 判斷是否為新的最佳答案  \n    Yes → Step 6: 把 result 設為該單字 // 更新最佳答案  \n    No → // 無需更新  \n   No → // 該單字不可構造，直接跳過  \nEnd // 程式結束，result 為答案（若無可構造單字則為空字串）",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def longestWord(self, words):\n        # 用 set 快速查詢前綴是否已存在\n        word_set = set(words)\n        longest = \"\"\n        for word in words:\n            # 檢查從 1 到 len(word) 的所有前綴是否都存在\n            if all(word[:k] in word_set for k in range(1, len(word) + 1)):\n                # 更新答案：更長或同長且字典序更小\n                if len(word) > len(longest) or (len(word) == len(longest) and word < longest):\n                    longest = word\n        return longest\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 嘗試將輸入轉為 Python 資料結構\n    try:\n        words = ast.literal_eval(data)\n    except Exception:\n        # 若是變量賦值式，例如 words = [...], 直接執行\n        namespace = {}\n        exec(data, {}, namespace)\n        words = namespace.get('words', [])\n    # 取得答案\n    sol = Solution()\n    result = sol.longestWord(words)\n    # 輸出\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"w\",\"wo\",\"wor\",\"worl\",\"world\"]",
          "expected_output": "world",
          "success": true,
          "output": "world"
        },
        {
          "example_index": 1,
          "input": "words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]",
          "expected_output": "apple",
          "success": true,
          "output": "apple"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode131.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code outline for algorithm to partition string into palindromic substrings. It's typical backtracking with palindrome check. We need line-by-line steps, using arrows and Decision. Use Start, End. Provide explanation. Provide virtual steps only, no code. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End. Use arrow \"→\". Use Decision lines. The algorithm:\n\nStart\n→ Step 1: 初始化答案列表 result = [] // 用來儲存所有分割\n→ Step 2: 定義遞迴函式 backtrack(start, path) // start 為當前索引，path 為目前已選的子字串\n→ Decision: start == len(s)? // 是否已遍歷完字串\n    Yes → Step 3: 把 path 轉成列表並加入 result // 完成一種分割方式\n    No  → Step 4: For i from start to len(s)-1 // 嘗試以不同長度的子字串\n→ Decision: s[start:i+1] is palindrome? // 檢查子字串是否為回文\n    Yes → Step 5: 將子字串加入 path\n    Yes → Step 6: 呼叫 backtrack(i+1, path) // 進一步分割剩餘字串\n    Yes → Step 7: 從 path 中移除最後一個子字串 // 回溯\n→ End\n\nBut we need to show each line as separate line.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 定義輸入字串 s // 取得需要分割的字串\n→ Step 2: 初始化答案列表 result = [] // 用來收集所有分割結果\n→ Step 3: 定義遞迴函式 backtrack(start, path) // start 為目前索引，path 為已選子字串列表\n→ Decision: start == len(s)? // 檢查是否已到達字串末尾\n    Yes → Step 4: result.append(copy_of(path)) // 完成一個分割方案，加入結果\n    No  → Step 5: for i in range(start, len(s)) // 逐個嘗試以不同長度的子字串\n→ Decision: s[start:i+1] is palindrome? // 判斷當前子字串是否為回文\n    Yes → Step 6: path.append(s[start:i+1]) // 將回文子字串加入路徑\n    Yes → Step 7: backtrack(i+1, path) // 遞迴處理剩餘字串\n    Yes → Step 8: path.pop() // 回溯，移除剛加入的子字串\n→ End // 程式執行結束\n\nBut we need arrows for nested. Use \"→\" for normal steps. For decisions, use \"Decision:\" line, then indent the Yes/No options.\n\nMaybe also include Step 9: return result after recursion. But maybe not needed.\n\nLet's produce final.\n\nWe must produce each line with step number maybe. Format: 虛擬碼步驟 // 解釋.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 取得需要分割的字串\n→ Step 2: 初始化答案列表 result = [] // 用於儲存所有分割方案\n→ Step 3: 定義遞迴函式 backtrack(start, path) // start 為目前索引，path 為已選的子字串列表\n→ Decision: start == len(s)? // 檢查是否已處理完整個字串\n    Yes → Step 4: 把 path 複製並加入 result // 完成一個合法分割，加入答案\n    No  → Step 5: for i from start to len(s)-1 // 嘗試不同長度的子字串\n→ Decision: s[start:i+1] is palindrome? // 判斷子字串是否為回文\n    Yes → Step 6: path.append(s[start:i+1]) // 加入回文子字串\n    Yes → Step 7: backtrack(i+1, path) // 進一步分割剩餘字串\n    Yes → Step 8: path.pop() // 回溯，移除剛加入的子字串\n→ End // 程式執行結束\n\nWe can also include final return result, but maybe not needed.\n\nBut to be safe, add a final Step after recursion: Step 9: return result // 輸出所有分割方案\n\nBut we must keep line order: the function backtrack defined inside, but we can't call return result after backtrack? Usually we call backtrack(0, []) then return result.\n\nSo maybe:\n\n→ Step 5: backtrack(0, []) // 開始遞迴\n→ Step 6: return result // 輸出所有分割結果\n\nBut we need to reflect that Step 5 after definitions? Let's restructure:\n\nAfter Step 3 definition, add:\n\n→ Step 4: backtrack(0, []) // 開始遞迴，從索引0開始\n→ Step 5: return result // 輸出所有分割方案\n\nThen inside backtrack function we have nested steps.\n\nBut we must maintain the structure: In the arrow style, nested lines show as indent? The example shows nested lines after Decision.\n\nThus we produce final answer with lines in order.\n\nLet's craft final output with each line numbered? Not required but helpful.\n\nBut we should not include code. Just virtual steps.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得需要分割的字串  \n→ Step 2: 初始化答案列表 result = [] // 用於儲存所有分割方案  \n→ Step 3: 定義遞迴函式 backtrack(start, path) // start 為目前索引，path 為已選的子字串列表  \n→ Decision: start == len(s)? // 檢查是否已處理完整個字串  \n Yes → Step 4: 把 path 複製並加入 result // 完成一個合法分割，加入答案  \n No  → Step 5: for i in range(start, len(s)) // 嘗試不同長度的子字串  \n  Decision: s[start:i+1] is palindrome? // 判斷子字串是否為回文  \n   Yes → Step 6: path.append(s[start:i+1]) // 加入回文子字串  \n   Yes → Step 7: backtrack(i+1, path) // 進一步分割剩餘字串  \n   Yes → Step 8: path.pop() // 回溯，移除剛加入的子字串  \n→ Step 9: backtrack(0, []) // 開始遞迴，從索引0開始  \n→ Step 10: return result // 輸出所有分割方案  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def partition(self, s: str):\n        res = []\n\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n\n        def dfs(start: int, path: list[str]) -> None:\n            if start == len(s):\n                res.append(path.copy())\n                return\n            for end in range(start + 1, len(s) + 1):\n                if is_palindrome(s[start:end]):\n                    dfs(end, path + [s[start:end]])\n\n        dfs(0, [])\n        return res\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        s = \"\"\n    else:\n        # 尝试解析类似 's = \"aab\"' 的输入\n        if \"=\" in data:\n            _, value = data.split(\"=\", 1)\n            s = value.strip().strip('\\'\"')\n        else:\n            s = data.strip('\\'\"')\n    solution = Solution()\n    result = solution.partition(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
          "success": true,
          "output": "[['a', 'a', 'b'], ['aa', 'b']]"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[['a']]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode43.json",
    "problem_index_in_file": 0,
    "title": "Multiply Strings",
    "description_snippet": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The task: multiply two non-negative integer strings without big int conversion. Use algorithm like long multiplication. So produce pseudocode lines, each line with explanation. Use Start, Decision, etc.\n\nWe must not produce actual code, just virtual code with arrows and explanations. Provide line by line.\n\nLet's produce algorithm:\n\nStart\n→ Step 1: If num1 == \"0\" or num2 == \"0\" → Output \"0\" // handle zero early\n→ Step 2: Initialize result array of length len1+len2 with zeros // store digits\n→ Step 3: For i from len1-1 down to 0 // iterate digits of num1\n→ Step 4: Convert digit1 = num1[i] - '0' // numeric value\n→ Step 5: For j from len2-1 down to 0 // iterate digits of num2\n→ Step 6: Convert digit2 = num2[j] - '0'\n→ Step 7: Multiply = digit1 * digit2 + result[i+j+1] // position in array\n→ Step 8: result[i+j+1] = multiply % 10 // store unit\n→ Step 9: result[i+j] += multiply / 10 // carry to next\n→ Step 10: After loops, convert result array to string, skipping leading zeros\n→ Step 11: Output string // product\n\nBut we need to use decisions etc. Might incorporate decisions for zero, leading zeros removal. Provide explanatory comments.\n\nWe also need to incorporate arrow \"→\" etc.\n\nWe can also use decision: If input string length 0? But not needed.\n\nLet's produce line by line.\n\nRemember format: each line: \"虛擬碼步驟 // 解釋\"\n\nUse arrow \"→\" or \"Yes →\" \"No →\".\n\nStart line: \"Start // 程式開始執行\"\n\nThen \"→ Decision: 若 num1 = '0' 或 num2 = '0'? // 檢查是否有零\" then Yes, No.\n\nYes branch: \"Yes → Step: 輸出 '0' // 直接回傳 0\" and then \"Yes → End // 結束\" maybe.\n\nNo branch: Continue.\n\nWe need to ensure arrow formatting consistent.\n\nOk produce.\n\nLet's craft full pseudocode:\n\nStart\n→ Decision: 若 num1 = '0' 或 num2 = '0'?\n    Yes → Step 1: 輸出 '0' // 若任一輸入為 0，結果即為 0\n    Yes → End // 程式結束\n    No  → Step 2: 設置 len1 = len(num1), len2 = len(num2) // 取得兩數字長度\n→ Step 3: 建立 result 數組，長度 len1+len2，初始化為 0 // 用於存放乘積各位\n→ For i從 len1-1 到 0 步長 -1 // 逐位處理 num1\n    → Step 4: digit1 = num1[i] - '0' // 將字符轉為數字\n    → For j從 len2-1 到 0 步長 -1 // 逐位處理 num2\n        → Step 5: digit2 = num2[j] - '0' // 字符轉數字\n        → Step 6: product = digit1 * digit2 + result[i+j+1] // 乘積加上已存儲的位\n        → Step 7: result[i+j+1] = product % 10 // 儲存單位位\n        → Step 8: result[i+j] += product / 10 // 加進高位（進位）\n→ Step 9: index = 0 // 開始轉換結果到字串\n→ While index < len(result) 且 result[index] == 0\n    → Step 10: index += 1 // 跳過前導 0\n→ Step 11: 若 index == len(result)\n    → Yes → Step 12: 輸出 '0' // 全為零的情況\n    → Yes → End\n    → No  → Step 13: 建立空字串 productStr\n→ While index < len(result)\n    → Step 14: productStr += chr(result[index] + '0') // 將數字轉字符追加\n    → Step 15: index += 1\n→ Step 16: 輸出 productStr // 結果字串\nEnd\n\nMake sure each line uses \"→\" except decisions use \"Decision:\" and Yes/No arrows.\n\nLet's format exactly. Each line:\n\nStart // 程式開始執行\n→ Decision: 若 num1 = '0' 或 num2 = '0'? // 檢查輸入是否為零\n    Yes → Step 1: 輸出 '0' // 直接回傳 0\n    Yes → End // 結束程式\n    No  → Step 2: 設置 len1 = len(num1), len2 = len(num2) // 取得兩數字長度\n→ Step 3: 建立 result 數組，長度 len1+len2，初始化為 0 // 用於存放乘積各位\n→ For i從 len1-1 到 0 步長 -1 // 逐位處理 num1\n    → Step 4: digit1 = num1[i] - '0' // 字符轉數字\n    → For j從 len2-1 到 0 步長 -1 // 逐位處理 num2\n        → Step 5: digit2 = num2[j] - '0' // 字符轉數字\n        → Step 6: product = digit1 * digit2 + result[i+j+1] // 乘積加上已存儲的位\n        → Step 7: result[i+j+1] = product % 10 // 儲存單位位\n        → Step 8: result[i+j] += product / 10 // 加進高位（進位）\n→ Step 9: index = 0 // 開始轉換結果到字串\n→ While index < len(result) 且 result[index] == 0\n    → Step 10: index += 1 // 跳過前導 0\n→ Step 11: 若 index == len(result)?\n    Yes → Step 12: 輸出 '0' // 全為零的情況\n    Yes → End\n    No  → Step 13: 建立空字串 productStr // 準備拼接結果\n→ While index < len(result)\n    → Step 14: productStr += chr(result[index] + '0') // 將數字轉字符追加\n    → Step 15: index += 1\n→ Step 16: 輸出 productStr // 結果字串\nEnd // 程式結束\n\nWe need to ensure each line has one \"虛擬碼步驟\" then // explanation. Indentation is part of the step but still single line? They say each line must include \"虛擬碼步驟\" then space then explanation. But we can break lines with indentation lines like \"    Yes → Step...\" as separate lines.\n\nWe must ensure each line ends with explanation comment after //.\n\nAlso we must use \"Decision:\" lines and \"While\" loops etc. We can use \"While\" as step. They didn't specify but okay.\n\nBetter keep each step as single line.\n\nThus produce.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 若 num1 = '0' 或 num2 = '0'? // 檢查輸入是否為零  \n  Yes → Step 1: 輸出 '0' // 直接回傳 0  \n  Yes → End // 程式結束  \n  No  → Step 2: 設置 len1 = len(num1), len2 = len(num2) // 取得兩數字長度  \n→ Step 3: 建立 result 數組，長度 len1+len2，初始化為 0 // 用於存放乘積各位  \n→ For i從 len1-1 到 0 步長 -1 // 逐位處理 num1  \n  → Step 4: digit1 = num1[i] - '0' // 字符轉數字  \n  → For j從 len2-1 到 0 步長 -1 // 逐位處理 num2  \n    → Step 5: digit2 = num2[j] - '0' // 字符轉數字  \n    → Step 6: product = digit1 * digit2 + result[i+j+1] // 乘積加上已存儲的位  \n    → Step 7: result[i+j+1] = product % 10 // 儲存單位位  \n    → Step 8: result[i+j] += product / 10 // 加進高位（進位）  \n→ Step 9: index = 0 // 開始轉換結果到字串  \n→ While index < len(result) 且 result[index] == 0  \n  → Step 10: index += 1 // 跳過前導 0  \n→ Decision: 若 index == len(result)? // 判斷是否全為 0  \n  Yes → Step 11: 輸出 '0' // 全為零的情況  \n  Yes → End // 程式結束  \n  No  → Step 12: 建立空字串 productStr // 準備拼接結果  \n→ While index < len(result)  \n  → Step 13: productStr += chr(result[index] + '0') // 將數字轉字符追加  \n  → Step 14: index += 1  \n→ Step 15: 輸出 productStr // 結果字串  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # 直接返回 0 的簡化情況\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        m, n = len(num1), len(num2)\n        pos = [0] * (m + n)\n\n        # 從最低位開始進行乘法\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n                sum_ = mul + pos[p2]\n\n                pos[p1] += sum_ // 10\n                pos[p2] = sum_ % 10\n\n        # 把數字陣列轉成字串，去掉前導 0\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result if result else '0'\n\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入文字中解析 num1 與 num2。\n    支援以下兩種常見格式：\n    1. num1 = '123', num2 = '456'\n    2. 兩行分別為 123 456 或 123 456\n    \"\"\"\n    # 嘗試以 'num1 = '...' , num2 = '...' 的格式抽取\n    m1 = re.search(r\"num1\\s*=\\s*'([^']*)'\", text)\n    m2 = re.search(r\"num2\\s*=\\s*'([^']*)'\", text)\n    if m1 and m2:\n        return m1.group(1), m2.group(1)\n\n    # 其它情況：以空白分割，取前兩個非空項\n    parts = [p.strip().strip(\"'\\\"\") for p in re.split(r'\\s+', text) if p.strip()]\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # 最終 fallback：若只剩一個項，第二個項為 '0'\n    return parts[0], '0'\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    num1, num2 = parse_input(data)\n    sol = Solution()\n    product = sol.multiply(num1, num2)\n    # 按範例輸出時帶單引號\n    print(f\"'{product}'\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "success": true,
          "output": "'6'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "success": true,
          "output": "'56088'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode539.json",
    "problem_index_in_file": 0,
    "title": "Minimum Time Difference",
    "description_snippet": "Given a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference b...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing algorithm for min time difference between any two time points in 24h list.\n\nTypical algorithm: convert each time to minutes since midnight, sort, compute min difference between consecutive and wrap-around between last and first + 24*60. Complexity O(n log n). We will describe steps: parse, convert to minutes, sort, compute min diff, consider wrap.\n\nWe must output each line with arrow etc. Use Start, End, Decision. Provide explanation after //.\n\nWe must not output actual code. Use virtual steps.\n\nWe'll need to include loops and decisions. Let's craft:\n\nStart\n→ Step 1: 初始化空陣列 Minutes // 用來存時間點的分鐘表示\n→ Step 2: 對於每個時間字串 TimeStr in TimePoints // 逐一處理輸入\n    → Step 2.1: 解析 Hours 和 MinutesPart 從 TimeStr // 分離小時與分鐘\n    → Step 2.2: 計算 TotalMinutes = Hours*60 + MinutesPart // 轉為分鐘\n    → Step 2.3: 加入 TotalMinutes 到 Minutes 陣列 // 儲存\n→ Step 3: 將 Minutes 陣列排序 // 方便計算相鄰差值\n→ Step 4: 設定 MinDiff 為 Infinity // 初始化最小差\n→ Step 5: 從 i=1 到 n-1 // 遍歷相鄰元素\n    → Step 5.1: 計算 Diff = Minutes[i] - Minutes[i-1] // 差值\n    → Decision: Diff < MinDiff? // 判斷是否更小\n        Yes → Step 5.2: MinDiff = Diff // 更新\n→ Step 6: 取第一個和最後一個時間之差加上一整天的分鐘數 // 週期差\n    → Step 6.1: WrapDiff = (Minutes[0] + 1440) - Minutes[n-1] // 轉向差\n    → Decision: WrapDiff < MinDiff? // 判斷是否更小\n        Yes → Step 6.2: MinDiff = WrapDiff // 更新\n→ Step 7: 回傳 MinDiff // 結果\nEnd\n\nAdd explanation after // each line.\n\nWe need to incorporate arrow. For nested steps, indent with tabs or spaces? Example uses indentation. We can indent with 4 spaces.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空陣列 Minutes // 用來存時間點的分鐘表示\n→ Step 2: 對於每個時間字串 TimeStr in TimePoints // 逐一處理輸入\n    → Step 2.1: 解析 Hours 和 MinutesPart 從 TimeStr // 分離小時與分鐘\n    → Step 2.2: 計算 TotalMinutes = Hours*60 + MinutesPart // 轉為分鐘\n    → Step 2.3: 加入 TotalMinutes 到 Minutes 陣列 // 儲存\n→ Step 3: 將 Minutes 陣列排序 // 方便計算相鄰差值\n→ Step 4: 設定 MinDiff 為 Infinity // 初始化最小差\n→ Step 5: 從 i=1 到 n-1 // 遍歷相鄰元素\n    → Step 5.1: 計算 Diff = Minutes[i] - Minutes[i-1] // 差值\n    → Decision: Diff < MinDiff? // 判斷是否更小\n        Yes → Step 5.2: MinDiff = Diff // 更新\n→ Step 6: 取第一個和最後一個時間之差加上一整天的分鐘數 // 週期差\n    → Step 6.1: WrapDiff = (Minutes[0] + 1440) - Minutes[n-1] // 轉向差\n    → Decision: WrapDiff < MinDiff? // 判斷是否更小\n        Yes → Step 6.2: MinDiff = WrapDiff // 更新\n→ Step 7: 回傳 MinDiff // 結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMinDifference(self, timePoints):\n        minutes = []\n        for t in timePoints:\n            h, m = map(int, t.split(':'))\n            minutes.append(h * 60 + m)\n        minutes.sort()\n        min_diff = float('inf')\n        for i in range(1, len(minutes)):\n            min_diff = min(min_diff, minutes[i] - minutes[i - 1])\n        min_diff = min(min_diff, 1440 - (minutes[-1] - minutes[0]))\n        return min_diff\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    time_points = ast.literal_eval(data)\n    solution = Solution()\n    result = solution.findMinDifference(time_points)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"23:59\",\"00:00\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "[\"00:00\",\"23:59\",\"00:00\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode665.json",
    "problem_index_in_file": 0,
    "title": "Non-decreasing Array",
    "description_snippet": "Given an array nums with n integers, your task is to check if it could become non-decreasing by modi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Problem: given array nums, check if could become non-decreasing by modifying at most one element. We need to output virtual code using arrows and decisions, with Start, End. Use simple algorithm: iterate, count violations, if >1 return false; else handle edge cases by modifying preceding or following element. Approach: for each i from 0 to n-2, if nums[i] > nums[i+1], increment count. If count >1, false. If first violation: if i==0 or nums[i-1] <= nums[i+1] then modify nums[i] to nums[i+1] else modify nums[i+1] to nums[i]. But since we don't modify, just check possibility. After loop, true. Let's produce steps.\n\nWill produce virtual code:\n\nStart\n→ Step 1: Initialize count = 0 // 记录违例次数\n→ Step 2: For i from 0 to n-2 // 遍历相邻元素\n    → Decision: if nums[i] > nums[i+1] ?\n        Yes →\n            → Step 3: Increment count // 发现一次违例\n            → Decision: if count > 1 ?\n                Yes → Step 4: Return False // 超过一次则不可能\n                No  → Decision: 是否为第一次违例? (i==0 or nums[i-1] <= nums[i+1]) ?\n                    Yes → Step 5: 认为可以把 nums[i] 变成 nums[i+1] // 继续检查\n                    No  → Step 6: 认为可以把 nums[i+1] 变成 nums[i] // 继续检查\n        No → Continue // 当前相邻已满足非递减\n→ Step 7: 循环结束\n→ Decision: 如果 count <= 1 ?\n    Yes → Step 8: Return True // 至多一次修改可满足\n    No  → Step 9: Return False // 仅为安全\nEnd\n\nBut need to maintain virtual code format: each line with virtual code step + explanation. Use arrows. For nested decisions, indent? We can show indentation with spaces. Use \"Decision:\" lines. Use \"Yes →\" \"No →\" arrows.\n\nLet's craft final answer.\n\nNeed to adhere to format: each line with `虛擬碼步驟 [space] // 解釋/說明`. Use Start and End. Use arrows for steps, decisions, and choices.\n\nWe need to show the code lines, each with explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize count = 0 // 記錄違例次數  \n→ Step 2: For i from 0 to n-2 // 遍歷相鄰元素  \n  Decision: if nums[i] > nums[i+1] ? // 檢查是否違反非遞減  \n   Yes → Step 3: Increment count // 發現一次違例  \n    Decision: if count > 1 ? // 超過一次則無法修正  \n     Yes → Step 4: Return False // 立即返回不可行  \n     No  → Decision: i == 0 or nums[i-1] <= nums[i+1] ? // 判斷能否調整 nums[i]  \n      Yes → Step 5: // 可以把 nums[i] 變成 nums[i+1]，不需實際修改  \n      No  → Step 6: // 只能把 nums[i+1] 變成 nums[i]，不需實際修改  \n    No  → Continue // 若已符合，直接進行下一對  \n→ Step 7: 循環結束 // 所有相鄰元素已檢查完  \n→ Decision: if count <= 1 ? // 最後判斷是否只遇到一次違例  \n  Yes → Step 8: Return True // 至多修改一次即可變成非遞減  \n  No  → Step 9: Return False // 為安全處理，實際不會進入  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def checkPossibility(self, nums):\n        count = 0\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i-1]:\n                count += 1\n                if count > 1:\n                    return False\n                if i == 1 or nums[i] >= nums[i-2]:\n                    nums[i-1] = nums[i]\n                else:\n                    nums[i] = nums[i-1]\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Find the first '[' and the last ']' to extract the list literal\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        # If no list found, treat as empty list\n        nums = []\n    else:\n        list_str = data[start:end+1]\n        nums = ast.literal_eval(list_str)\n    sol = Solution()\n    result = sol.checkPossibility(nums)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,2,3]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [4,2,1]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode446.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices II - Subsequence",
    "description_snippet": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\n\nA sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for counting number of all arithmetic subsequences of an integer array nums. Classic problem LeetCode 446. Approach: DP with hash maps: dp[i] map difference-> count of arithmetic subsequences ending at i with that difference. For each pair (j,i) compute diff=nums[i]-nums[j]; cnt_j = dp[j][diff]; dp[i][diff] += cnt_j+1 (adding subsequence formed by nums[j], nums[i] of length 2). Sum of cnt_j added to answer. Complexity O(n^2).\n\nWe need to output virtual code step by step with explanation. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Use \"Start\", \"End\". \"Decision:\" maybe for loops.\n\nWe'll produce step lines:\n\nStart // program starts\n\n→ Step 1: Initialize ans=0 // total arithmetic subsequences count\n\n→ Step 2: Create array dp of n empty maps // each map stores difference counts for subsequences ending at i\n\n→ Step 3: For i from 0 to n-1 // iterate each element as end index\n\n    → Step 4: For j from 0 to i-1 // compare with previous elements\n\n        → Step 5: Compute diff = nums[i] - nums[j] // common difference\n\n        → Step 6: cnt_j = dp[j][diff] if exists else 0 // number of subsequences ending at j with diff\n\n        → Step 7: ans += cnt_j // these subsequences extended to length >=3\n\n        → Step 8: dp[i][diff] += cnt_j + 1 // add new subsequences of length 2 and extended ones\n\n→ End // output ans\n\nBut need to use \"Decision:\" maybe for if cnt_j>0? but not needed. Use \"Decision:\" maybe for checking existence of diff key. Use \"Decision:\" to fetch count.\n\nLet's incorporate.\n\nNeed to include arrows: \"→\" at each step. Indentation for nested steps maybe with tabs.\n\nLet's produce:\n\nStart // 開始執行\n→ Step 1: ans ← 0 // 初始化答案\n→ Step 2: dp ← array of n empty maps // dp[i] 會存放以 nums[i] 結尾且相同差值的子序列數\n→ Step 3: For i ← 0 to n-1 // 逐一處理每個結尾\n    → Step 4: For j ← 0 to i-1 // 與前面的每個元素做配對\n        → Step 5: diff ← nums[i] - nums[j] // 計算相鄰差值\n        → Decision: diff 是否已存在於 dp[j]？ // 判斷前面是否已有相同差值的子序列\n            Yes → cnt_j ← dp[j][diff] // 取出該差值的子序列數\n            No  → cnt_j ← 0 // 若不存在，數量為0\n        → Step 6: ans ← ans + cnt_j // 這些子序列延伸後長度至少為3，加入答案\n        → Step 7: dp[i][diff] ← dp[i][diff] + cnt_j + 1 // 加入新的長度2子序列與延伸後的子序列\n→ End // 輸出 ans\n\nWe need also to output ans. But virtual code can show \"→ Step X: Return ans\". But the example only shows steps until End.\n\nWe can include Step 8: Return ans // 返回總數\n\nLet's incorporate.\n\nUse arrow for step numbers. Indentation maybe with tabs.\n\nEnsure each line includes a space then // explanation.\n\nMake sure each line ends with explanation.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: ans ← 0 // 初始化答案為 0  \n→ Step 2: dp ← array of n empty maps // dp[i] 用來存放以 nums[i] 結尾且相同差值的子序列個數  \n→ Step 3: For i ← 0 to n-1 // 逐一處理每個結尾索引  \n  → Step 4: For j ← 0 to i-1 // 與前面的每個元素做配對  \n    → Step 5: diff ← nums[i] - nums[j] // 計算相鄰差值  \n    → Decision: diff 是否已存在於 dp[j]？ // 判斷前面是否已有相同差值的子序列  \n      Yes → cnt_j ← dp[j][diff] // 取出該差值的子序列數  \n      No  → cnt_j ← 0 // 若不存在，數量為 0  \n    → Step 6: ans ← ans + cnt_j // 這些子序列延伸後長度至少為 3，加入答案  \n    → Step 7: dp[i][diff] ← dp[i][diff] + cnt_j + 1 // 加入新的長度 2 子序列與延伸後的子序列  \n→ Step 8: Return ans // 返回所有算術子序列的總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\ndef number_of_arithmetic_slices(nums):\n    n = len(nums)\n    dp = [defaultdict(int) for _ in range(n)]\n    total = 0\n    for i in range(n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            count = dp[j][diff]\n            dp[i][diff] += count + 1\n            total += count\n    return total\n\ndef main():\n    data = sys.stdin.read().strip()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        print(0)\n        return\n    result = number_of_arithmetic_slices(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,4,6,8,10]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "nums = [7,7,7,7,7]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode309.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock with Cooldown",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nFind th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the solution of the problem: Best Time to Buy and Sell Stock with Cooldown. Should be pseudo-code with explanation each line. Use the format: `虛擬碼步驟 // 解釋/說明`. Use arrows and decisions. Must be line-by-line.\n\nWe need to describe dynamic programming approach with states: hold, sold, rest. Provide pseudo code.\n\nLet's create steps: Start, initialize variables for n, if n==0 return 0. Initialize dp[i][state] or use variables: hold, sold, rest. Loop i from 0 to n-1. At day i, update newHold = max(hold, rest - price[i])? Actually hold means holding stock after day i. dp[i][hold] = max(dp[i-1][hold], dp[i-1][rest] - price[i]). dp[i][sold] = dp[i-1][hold] + price[i]. dp[i][rest] = max(dp[i-1][rest], dp[i-1][sold]). At the end, answer = max(sold, rest). Provide pseudo code accordingly.\n\nLet's produce each line:\n\nStart // 程式開始\n\n→ Step 1: n ← length(prices) // 取得天數\n\n→ Decision: n == 0? // 若沒有價格\n\n    Yes → Step 2: Return 0 // 沒有交易可做\n\n    No  → Step 3: Initialize hold, sold, rest // 初始化三種狀態\n\n→ Step 4: hold ← -prices[0] // 第一天買入\n\n→ Step 5: sold ← 0 // 第一天未賣出\n\n→ Step 6: rest ← 0 // 第一天休息\n\n→ Step 7: For i from 1 to n-1 // 迭代後續天數\n\n    → Step 7a: newHold ← max(hold, rest - prices[i]) // 保持持股或在休息後買入\n\n    → Step 7b: newSold ← hold + prices[i] // 賣出手中持股\n\n    → Step 7c: newRest ← max(rest, sold) // 休息狀態可來自上次休息或賣出後\n\n    → Step 7d: hold ← newHold // 更新 hold\n\n    → Step 7e: sold ← newSold // 更新 sold\n\n    → Step 7f: rest ← newRest // 更新 rest\n\n→ Step 8: Result ← max(sold, rest) // 最大獲利為賣出或休息狀態\n\n→ End // 結束\n\nAlso include explanation comments each line.\n\nNeed to incorporate Decision arrow structure. We must ensure formatting: Each line as `虛擬碼步驟 // 解釋`. Use arrow \"→\" to denote steps inside loops or decisions. Let's produce accordingly.\n\nMake sure we don't output actual code. Just pseudo. Use \"Start\", \"End\". Provide decision blocks with Yes/No. Provide indentation? In example, indentation shows nested arrow lines under decision. We can mimic. Let's produce as per format.\n\nWe'll produce pseudo:\n\n```\nStart // 程式開始\n→ Step 1: n ← length(prices) // 取得價格陣列長度\n→ Decision: n == 0? // 若沒有任何天數\n    Yes → Step 2: Return 0 // 無法交易，直接回傳 0\n    No  → Step 3: // 初始化狀態變數\n→ Step 4: hold ← -prices[0] // 在第一天買入股票，持股成本為負值\n→ Step 5: sold ← 0 // 第一日未賣出，賣出利潤為 0\n→ Step 6: rest ← 0 // 第一日休息，沒有任何利潤\n→ Step 7: For i from 1 to n-1 // 逐日處理\n    → Step 7a: newHold ← max(hold, rest - prices[i]) // 保持持股或在休息日後買入\n    → Step 7b: newSold ← hold + prices[i] // 在今天賣出持有的股票\n    → Step 7c: newRest ← max(rest, sold) // 休息狀態可從前一日休息或賣出後進入\n    → Step 7d: hold ← newHold // 更新持股狀態\n    → Step 7e: sold ← newSold // 更新賣出狀態\n    → Step 7f: rest ← newRest // 更新休息狀態\n→ Step 8: Result ← max(sold, rest) // 最大利潤是最後一天賣出或休息的利潤\n→ End // 程式結束\n```\n\nMake sure each line includes `虛擬碼步驟 // 解釋`. Use the correct formatting.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始\n→ Step 1: n ← length(prices) // 取得價格陣列長度\n→ Decision: n == 0? // 若沒有任何天數\n    Yes → Step 2: Return 0 // 無法交易，直接回傳 0\n    No  → Step 3: // 初始化狀態變數\n→ Step 4: hold ← -prices[0] // 第一日買入股票，持股成本為負值\n→ Step 5: sold ← 0 // 第一日未賣出，賣出利潤為 0\n→ Step 6: rest ← 0 // 第一日休息，沒有任何利潤\n→ Step 7: For i from 1 to n-1 // 逐日處理\n    → Step 7a: newHold ← max(hold, rest - prices[i]) // 保持持股或在休息日後買入\n    → Step 7b: newSold ← hold + prices[i] // 在今天賣出持有的股票\n    → Step 7c: newRest ← max(rest, sold) // 休息狀態可從前一日休息或賣出後進入\n    → Step 7d: hold ← newHold // 更新持股狀態\n    → Step 7e: sold ← newSold // 更新賣出狀態\n    → Step 7f: rest ← newRest // 更新休息狀態\n→ Step 8: Result ← max(sold, rest) // 最大利潤是最後一天賣出或休息的利潤\n→ End // 程式結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProfit(self, prices):\n        if not prices:\n            return 0\n        hold = -prices[0]  # 持有股票的最大收益\n        sold = 0           # 剛賣出股票的最大收益\n        rest = 0           # 不持有股票且未剛賣出的最大收益\n        for price in prices[1:]:\n            prev_sold = sold\n            sold = hold + price                # 今天賣出\n            hold = max(hold, rest - price)     # 今天持有或買入\n            rest = max(rest, prev_sold)        # 今天休息\n        return max(sold, rest)\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 從輸入中提取價格列表\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        prices = eval(match.group(0))\n    else:\n        prices = []\n\n    result = Solution().maxProfit(prices)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [1,2,3,0,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "prices = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode275.json",
    "problem_index_in_file": 0,
    "title": "H-Index II",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step, each line with virtual code and comment. Should solve the h-index with binary search (logarithmic). Input sorted non-decreasing. We need to find largest h where citations[n-h] >= h. Use binary search on h from 0 to n. We'll output steps: Start, input citations array length n, set low=0, high=n. While low<high: mid=(low+high+1)//2; if citations[n-mid] >= mid -> low=mid else high=mid-1. After loop, return low. End. Provide comments. Use arrow. Use Decision.\n\nLet's craft lines:\n\nStart\n→ Step 1: n ← length of citations // get number of papers\n→ Step 2: low ← 0 // lower bound of h-index\n→ Step 3: high ← n // upper bound (max possible h-index)\n→ Decision: low < high? // while loop condition\n    Yes → Step 4: mid ← (low + high + 1) // 2 // middle h guess\n    → Decision: citations[n - mid] >= mid? // check if enough papers cited\n        Yes → Step 5: low ← mid // mid is feasible, search higher\n        No  → Step 6: high ← mid - 1 // mid not feasible, search lower\n    No  → Step 7: return low // low is the h-index\nEnd\n\nMake sure use arrow indentation. Provide comments after space. We'll ensure each line has virtual code and comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length of citations // 取得論文總數  \n→ Step 2: low ← 0 // h-index 可能的下限  \n→ Step 3: high ← n // h-index 可能的上限（最多 n）  \n→ Decision: low < high? // 判斷是否仍有搜尋空間  \n    Yes → Step 4: mid ← (low + high + 1) // 2 // 計算中間候選值  \n    → Decision: citations[n - mid] >= mid? // 檢查至少有 mid 篇被至少 mid 次引用  \n        Yes → Step 5: low ← mid // mid 可行，向上搜尋更大的 h  \n        No  → Step 6: high ← mid - 1 // mid 不可行，向下搜尋更小的 h  \n    No  → Step 7: return low // low 為最終的 h-index  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def hIndex(self, citations):\n        \"\"\"\n        Calculate the h-index of a researcher using binary search.\n        citations : List[int] – sorted in non‑decreasing order.\n        \"\"\"\n        n = len(citations)\n        low, high = 0, n  # high is exclusive upper bound (n possible h-index)\n        while low < high:\n            mid = (low + high + 1) // 2  # candidate h-index\n            # Check if at least mid papers have at least mid citations.\n            if citations[n - mid] >= mid:\n                low = mid  # mid is feasible, try larger\n            else:\n                high = mid - 1  # mid not feasible, try smaller\n        return low\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Parse a line like 'citations = [0,1,3,5,6]' into a list of integers.\n    \"\"\"\n    input_str = input_str.strip()\n    if '=' in input_str:\n        _, part = input_str.split('=', 1)\n        part = part.strip()\n    else:\n        part = input_str\n    # Use literal_eval to safely parse the list\n    return ast.literal_eval(part)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit(0)\n    citations = parse_input(data)\n    result = Solution().hIndex(citations)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode403.json",
    "problem_index_in_file": 0,
    "title": "Frog Jump",
    "description_snippet": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code flow for checking if frog can cross. Use DFS/backtracking with memoization. Outline steps. Each line with arrow and comment. Provide algorithm. Use Start, Decision etc. Provide steps: Input stones list. Set stone set. Start DFS from index 0 with last jump 0? Actually first jump must be 1. So from first stone index 0, try jump 1 to stone index 1? Check if stone 1 exists. Use recursion. Use memo key (index, lastJump). Decision: If at last stone return true. else for jump in {lastJump-1, lastJump, lastJump+1} if >0 and stone exists at pos+jump then DFS. Use memo for false states. End.\n\nWe should produce line-by-line. Let's create steps.\n\nWe'll use virtual code like:\n\nStart\n→ Step 1: 獲取石頭位置列表 // ...\n→ Step 2: 建立位置集合 for O(1) 查詢 // ...\n→ Step 3: 定義 DFS 函數 (index, lastJump) // ...\n→ Decision: 是否為最後一塊石頭? // ...\n    Yes → Step ... // return true\n    No → Step ...\n→ Step ... // 生成可能跳躍距離列表\n→ Decision: 跳躍距離 >0? // ...\n    Yes → ...\n    No → ...\n→ Decision: 下一位置是否有石頭? // ...\n    Yes → Step: Recursively DFS\n    No → ...\n→ Step ... // 如果所有跳躍失敗記錄 memo\n→ Step ... // Return false\n→ Step ... // 呼叫 DFS(0,0)\n→ Decision: 是否成功? // ...\n    Yes → Step ... // 輸出 true\n    No → Step ... // 輸出 false\nEnd\n\nWe should also mention memo as set of (index, lastJump) visited false. Provide comment.\n\nLet's produce final output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取石頭位置列表 stones[0 … n-1] // 取得已排序的石頭位置\n→ Step 2: 建立集合 stoneSet = Set(stones) // 讓位置查詢成 O(1)\n→ Step 3: 初始化 memo = {} // 用來記錄已判定失敗的 (index, lastJump) 參數\n→ Step 4: 定義 DFS(index, lastJump) // 從 index 位置，上一跳距離為 lastJump\n    Decision: index == n-1? // 是否已站在最後一塊石頭？\n        Yes → Step 5: 回傳 true // 成功跨河\n        No  → Step 6: 若 memo.contains((index, lastJump))? // 已經失敗過的狀態\n            Yes → Step 7: 回傳 false // 直接失敗\n            No  → Step 8: 創建可能跳距離列表 = [lastJump-1, lastJump, lastJump+1]\n                Decision: 可能跳距離列表中是否存在合法值 > 0?\n                    Yes → Step 9: 對每個 d in 列表執行\n                        Decision: d > 0 AND stoneSet.contains(stones[index] + d)? // 前進到新石頭\n                            Yes → Step 10: 若 DFS(indexOf(stones[index] + d), d) 回傳 true?\n                                Yes → Step 11: 回傳 true // 找到成功路徑\n                                No  → Step 12: 繼續檢查下一個 d\n                            No  → Step 13: 繼續檢查下一個 d\n                    No  → Step 14: // 沒有任何合法跳距離\n                Step 15: memo.add((index, lastJump)) // 記錄此狀態為失敗\n                Step 16: 回傳 false // 所有跳距離皆失敗\n→ Step 17: 呼叫 result = DFS(0, 0) // 起始位置為第一塊石頭，假設上一跳距離為 0\n→ Decision: result?\n    Yes → Step 18: 輸出 \"可跨越\" // 成功跨過河流\n    No  → Step 19: 輸出 \"無法跨越\" // 所有路徑都失敗\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canCross(self, stones):\n        if not stones:\n            return False\n        stone_set = set(stones)\n        last_stone = stones[-1]\n        # 用字典存每塊石頭可達的跳距離集合\n        jumps = {stone: set() for stone in stones}\n        jumps[stones[0]].add(0)   # 初始時上一次跳為 0\n\n        for stone in stones:\n            for k in jumps[stone]:\n                for step in (k - 1, k, k + 1):\n                    if step > 0 and stone + step in stone_set:\n                        jumps[stone + step].add(step)\n\n        return bool(jumps[last_stone])\n\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取石頭位置列表。\n    例如: 'stones = [0,1,3,5,6,8,12,17]'\n    \"\"\"\n    # 找到第一個 '[' 與最後一個 ']'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        return []\n    try:\n        # 安全地使用 eval 來解析列表\n        return eval(data[start:end + 1])\n    except Exception:\n        return []\n\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    stones = parse_input(raw_input)\n    sol = Solution()\n    result = sol.canCross(stones)\n    print('true' if result else 'false')\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "stones = [0,1,3,5,6,8,12,17]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "stones = [0,1,2,3,4,8,9,11]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  }
]