{
  "run_index": 28,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 399,
  "generation_or_validation_failure_count": 40,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[2,5,1,1,4]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[2, 5, 1, 1, 4]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳所有結果的列表。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個程式碼片段\n    code = sys.stdin.read()\n    # 在全域命名空間執行該程式碼\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to output line-by-line virtual code with explanation. No actual code. Just virtual steps with arrows etc. Use Start, End, Decision. For random module, we need to \"Import random\" perhaps. Function roll_dice(n). Simulate n times of 6-sided die, return list of results.\n\nWe need to output virtual code. Example:\n\nStart\n→ Step 1: Import random module\n→ Step 2: Define function roll_dice(n)\n→ Step 3: Initialize empty list results\n→ Step 4: Decision: If n <= 0? // optional validation\n   Yes → Step 5: Return empty list // nothing to roll\n   No  → Step 6: For i from 1 to n\n        → Step 7: Generate random integer between 1 and 6\n        → Step 8: Append to results\n   End For\n→ Step 9: Return results\nEnd\n\nNeed to use arrow formatting. Use \"Decision:\" lines.\n\nWe must not output actual code. Just virtual steps.\n\nMake sure each line has \"虛擬碼步驟\" + space + comment. Use Chinese explanation. Use arrow (→). Use \"Start\" \"End\". Each line is a step. Use indentation? We can indent steps under decision with spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 導入 random 套件，方便產生隨機數  \n→ Step 2: Define function roll_dice(n) // 定義 roll_dice 函式，接受擲骰次數 n  \n→ Step 3: Initialize empty list results // 建立空列表，用來存放每一次擲骰的結果  \n→ Decision: 如果 n <= 0? // 檢查擲骰次數是否為非正數  \n    Yes → Step 4: Return empty list // 如果 n 為 0 或負數，直接回傳空列表  \n    No → Step 5: For i from 1 to n // 依序擲 n 次骰子  \n            → Step 6: Generate random integer between 1 and 6 // 使用 random.randint(1, 6) 產生 1~6 的隨機整數  \n            → Step 7: Append result to results // 將擲出的數字加入 results 列表  \n    End For // 擲骰完成  \n→ Step 8: Return results // 回傳所有擲骰結果的列表  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. It's for a function measure_time(func, *args) that measures execution time, returns result? Wait: \"回傳結果 (四捨五入到小數點 3 位)\" implies the measured time is returned rounded to 3 decimals. Probably the function returns the measured time. The code uses time module. So steps: import time, define function, record start time, call func with args, record end time, compute elapsed = end - start, round to 3 decimals, return elapsed.\n\nLet's produce steps:\n\nStart\n→ Step 1: Import time module\n→ Step 2: Define function measure_time(func, *args)\n    → Step 3: 記錄開始時間 start = time.time() // 取當前時間\n    → Step 4: 執行 func(*args) // 執行傳入函式\n    → Step 5: 記錄結束時間 end = time.time() // 取結束時間\n    → Step 6: 計算 elapsed = end - start // 計算耗時\n    → Step 7: 取三位小數 rounded = round(elapsed, 3) // 四捨五入\n    → Step 8: 回傳 rounded // 返回耗時\nEnd\n\nBut we also need to follow the format: \"虛擬碼步驟 [space] // 解釋\". So we will format each line accordingly. Use arrow characters appropriately. Use Decision? No. Just linear steps.\n\nWe need to ensure each line ends with \"//\" and explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 導入 time 模組以取得時間功能  \n→ Step 2: Define function measure_time(func, *args) // 建立測時函式，接受任意參數  \n→     Step 3: start = time.time() // 記錄開始時間，使用秒為單位  \n→     Step 4: func(*args) // 執行傳入的目標函式並傳遞所有參數  \n→     Step 5: end = time.time() // 記錄結束時間，獲取函式結束後的時間  \n→     Step 6: elapsed = end - start // 計算執行時間差，得到秒數  \n→     Step 7: rounded = round(elapsed, 3) // 將耗時四捨五入到小數點第三位  \n→     Step 8: return rounded // 回傳四捨五入後的秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"apple\",\"orange\",\"melon\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'apple', 'orange', 'melon', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入，儘管本題不需要任何輸入，仍按規範處理\n    _ = sys.stdin.read()\n    fruits = {'apple', 'banana'}\n    fruits.add('orange')\n    fruits.update(['grape', 'melon'])\n    fruits.remove('banana')\n    fruits.discard('pineapple')\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines, each with comment. Use Start, End, Decision if needed. It's simple. Need steps: Initialize set, add, update, remove, discard, print. No decisions. But maybe use Decision for remove? But remove could error if not exist. But user wants discard, but remove should exist. So no decision. Just steps. Provide arrow arrow lines. Use \"→ Step: ...\". Also \"End\". So output like:\n\nStart // 程式開始執行\n→ Step 1: fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除 'pineapple'，不存在不報錯\n→ Step 6: print(fruits) // 輸出集合\nEnd // 程式結束\n\nNeed to ensure each line ends with comment. Use no actual code, only virtual. That is fine. Use arrow. Use \"Step 1\" etc. Provide \"Start\". Should we use Decision? Not required. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits = {'apple', 'banana'} // 初始化集合 fruits  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除 'pineapple'（不存在不報錯）  \n→ Step 6: print(fruits) // 輸出最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.76TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.76 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate():\n    \"\"\"\n    取得美元對台幣的匯率。\n    成功時回傳浮點數；失敗時回傳 None。\n    \"\"\"\n    url = 'https://api.exchangerate-api.com/v4/latest/USD'\n    try:\n        response = requests.get(url, timeout=5)\n        response.raise_for_status()\n        data = response.json()\n        return data['rates']['TWD']\n    except Exception:\n        return None\n\ndef gui_main():\n    \"\"\"\n    啟動 tkinter GUI。\n    \"\"\"\n    win = tk.Tk()\n    win.title('匯率查詢')\n\n    label = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    def update_label():\n        rate = fetch_rate()\n        if rate is not None:\n            label.config(text=f'目前美元匯率：約 {rate} TWD')\n        else:\n            label.config(text='更新失敗，請檢查網路連線')\n\n    tk.Button(win, text='更新匯率', command=update_label).pack(pady=5)\n    win.mainloop()\n\ndef main():\n    \"\"\"\n    主程式入口。\n    讀取 stdin；若輸入包含「更新匯率」，直接輸出匯率並結束；否則啟動 GUI。\n    \"\"\"\n    input_text = sys.stdin.read().strip()\n    if '更新匯率' in input_text:\n        rate = fetch_rate()\n        if rate is not None:\n            print(f'目前美元匯率：約 {rate} TWD')\n        else:\n            print('更新失敗，請檢查網路連線')\n        return\n    gui_main()\n\nif __name__ == '__main__':\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Each line: virtual code step + space + // explanation. Must use arrows and structure. We need to reflect tasks: import requests, tkinter, create main window, label, button, function to fetch rate, update label. Use Start/End. Use Decision etc maybe for error. But keep simple. Provide sequential steps.\n\nLet's produce lines:\n\nStart\n→ Step 1: Import requests and tkinter modules // bring libraries\n→ Step 2: 定義 fetch_rate 函式 // 用於呼叫 API 取得匯率\n→ Step 3: 在 fetch_rate 中使用 requests.get 取得 JSON // 取得 API 回傳\n→ Step 4: 解析 JSON 取出 rates.TWD // 取得台幣匯率\n→ Step 5: 回傳匯率值 // 返回數值\n→ Step 6: 建立主視窗 root // tkinter 主視窗\n→ Step 7: 創建 Label label_rate 幫顯示匯率 // 初始文字\n→ Step 8: 創建 Button btn_update 呼叫 fetch_rate 並更新 label // 互動\n→ Step 9: 將 label_rate 放置在視窗中 // 設置佈局\n→ Step 10: 將 btn_update 放置在視窗中 // 佈局\n→ Decision: 是否已呼叫 fetch_rate 取得初始匯率? // 判斷是否需預先顯示\n    Yes → Step 11: 呼叫 fetch_rate 並設定 label_rate 文字 // 初始化\n    No → // 省略\n→ Step 12: 執行 root.mainloop() // 進入 GUI 事件迴圈\nEnd\n\nAdd explanation. Use arrows and decision indent.\n\nWe must ensure each line has '虛擬碼步驟' which might be the step description. Eg 'Start // 程式開始執行'. Use '→' arrow for subsequent steps. Decision uses 'Decision: ...'.\n\nWe should maintain consistent indentation for Decision block lines: we can indent by 4 spaces.\n\nAlso use 'Yes →' and 'No →' for each branch.\n\nLet's produce.\n\nAlso might need to import typing? not necessary.\n\nBe careful: For fetch_rate function: we might need to handle exceptions: Decision: request success? If Yes: parse, else: return None.\n\nBut keep simple.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests, tkinter modules // 引入所需庫  \n→ Step 2: 定義函式 fetch_rate() 以取得匯率 // 用於呼叫 API  \n→ Step 3: 在 fetch_rate() 裡使用 requests.get('https://api.exchangerate-api.com/v4/latest/USD') // 取得 JSON  \n→ Step 4: Decision: 取得是否成功? // 判斷請求是否成功  \n    Yes → Step 5: 解析 JSON，取出 data['rates']['TWD'] // 取得台幣匯率  \n    No → Step 6: Return None // 失敗時回傳 None  \n→ Step 7: Return 匯率值 // 回傳取得的匯率  \n→ Step 8: 建立主視窗 root = tkinter.Tk() // 初始化 GUI  \n→ Step 9: 創建 Label label_rate = tkinter.Label(root, text='匯率未載入') // 初始文字  \n→ Step 10: 定義更新函式 update_rate() // 點擊時呼叫  \n→ Step 11: 在 update_rate() 內呼叫 fetch_rate() 並取得 rate // 取得匯率  \n→ Step 12: Decision: rate 是否為 None? // 檢查取得是否成功  \n    Yes → Step 13: label_rate.config(text='匯率取得失敗') // 顯示失敗訊息  \n    No → Step 14: label_rate.config(text=f'USD → TWD: {rate}') // 顯示匯率  \n→ Step 15: 創建 Button btn_update = tkinter.Button(root, text='更新匯率', command=update_rate) // 按鈕  \n→ Step 16: 將 label_rate 放置於 root 內部 (label_rate.pack()) // 布局  \n→ Step 17: 將 btn_update 放置於 root 內部 (btn_update.pack()) // 布局  \n→ Decision: 是否需要先行顯示一次匯率? // 初始化顯示  \n    Yes → Step 18: 呼叫 update_rate() 以顯示最新匯率 // 預載入  \n    No → // 可省略  \n→ Step 19: 執行 root.mainloop() // 進入 GUI 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqljqyy9q.py\", line 35, in <module>\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 94 (char 93)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val):\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        if val not in self.val_to_index:\n            return False\n        index = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[index] = last_val\n        self.val_to_index[last_val] = index\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.values)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    ops, args = json.loads(data)\n\n    obj = None\n    results = [None]  # result of constructor is null\n\n    for op, arg in zip(ops[1:], args[1:]):\n        if op == \"insert\":\n            results.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            results.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            results.append(obj.getRandom())\n        elif op == \"RandomizedSet\":\n            obj = RandomizedSet()\n        else:\n            results.append(None)\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step for implementing RandomizedSet class with insert, remove, getRandom. Provide pseudo-code lines with comments. Use Start, End, Decision, etc. Each line should have virtual code step then comment. We need to produce lines that describe the logic. Need to cover initialization, data structures: array/list for values, hashmap for index mapping. Provide insertion, deletion, random get.\n\nWe need to produce in Traditional Chinese explanation. Each line: \"虛擬碼步驟 // 解釋/說明\".\n\nLet's craft. We'll start: Start // 程式開始執行. Then Step: Initialize data structures. Then steps for insert, remove, getRandom. Use decisions for checking existence. For remove: need to swap with last element.\n\nLet's produce a sequence:\n\nStart\n→ Step 1: 建立空 list values ← [] // 用來存儲集合元素\n→ Step 2: 建立空 map indexMap ← {} // value → index in values\nEnd? We'll end initialization after.\n\nThen we need methods: insert, remove, getRandom.\n\nWe can create substeps under a Decision: e.g., Decision: if val exists in indexMap?\n\nBut we need to output each line. Let's do:\n\n→ Decision: 若 val 在 indexMap 中? // 檢查元素是否已存在\n    Yes → Step 3: return False // 已存在，插入失敗\n    No  → Step 4: Append val to values // 新增元素到末尾\n          Step 5: 設定 indexMap[val] = len(values)-1 // 更新索引\n          Step 6: return True // 插入成功\n\nSimilarly remove:\n\n→ Decision: 若 val 在 indexMap 中? // 檢查是否存在\n    Yes → Step 7: 取得 lastVal = values[-1] // 取最後一個元素\n          Step 8: 取得 idx = indexMap[val] // 需要移除元素的位置\n          Step 9: 交換 values[idx] 和 lastVal // 將要刪除元素換到末尾\n          Step 10: 更新 indexMap[lastVal] = idx // 更新換到的位置索引\n          Step 11: 刪除 values[-1] // 刪除最後一個元素（即原來的 val）\n          Step 12: 移除 indexMap[val] // 刪除映射\n          Step 13: return True // 刪除成功\n    No  → Step 14: return False // 不存在，刪除失敗\n\ngetRandom:\n\n→ Step 15: 產生隨機整數 r = RandomInt(0, len(values)-1) // 隨機索引\n→ Step 16: return values[r] // 返回隨機元素\n\nWe also need to show Start and End for each function? Might be separate. But format allows sublines.\n\nWe can wrap each method inside Start/End.\n\nLet's produce:\n\nStart // RandomizedSet 初始化\n→ Step 1: values ← [] // 存儲元素\n→ Step 2: indexMap ← {} // 元素到索引的映射\nEnd // 初始化完成\n\nStart // insert 方法\n→ Decision: 若 val ∈ indexMap? // 檢查是否已存在\n    Yes → Step 1: return False // 已存在\n    No  → Step 2: values.append(val) // 加入末尾\n          Step 3: indexMap[val] ← len(values)-1 // 記錄索引\n          Step 4: return True // 成功插入\nEnd // insert 方法結束\n\nStart // remove 方法\n→ Decision: 若 val ∈ indexMap? // 檢查是否存在\n    Yes → Step 1: lastVal ← values[-1] // 取最後元素\n          Step 2: idx ← indexMap[val] // 要刪除元素位置\n          Step 3: values[idx] ← lastVal // 交換\n          Step 4: indexMap[lastVal] ← idx // 更新索引\n          Step 5: values.pop() // 刪除末尾\n          Step 6: del indexMap[val] // 刪除映射\n          Step 7: return True // 成功刪除\n    No  → Step 8: return False // 不存在\nEnd // remove 方法結束\n\nStart // getRandom 方法\n→ Step 1: r ← RandomInt(0, len(values)-1) // 隨機索引\n→ Step 2: return values[r] // 隨機返回元素\nEnd // getRandom 方法結束\n\nWe need to ensure each line has \"虛擬碼步驟 // 解釋\". Use arrow and step numbers accordingly. Also include Start and End for each method. Provide decisions with indentation and Yes/No arrows.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // RandomizedSet 初始化\n→ Step 1: values ← [] // 用列表儲存集合元素\n→ Step 2: indexMap ← {} // 用映射儲存元素到其在 values 中的索引\nEnd // 初始化完成\n\nStart // insert 方法\n→ Decision: 若 val ∈ indexMap? // 檢查元素是否已存在\n    Yes → Step 1: return False // 元素已在集合中，插入失敗\n    No  → Step 2: values.append(val) // 將新元素加到列表末尾\n          Step 3: indexMap[val] ← len(values)-1 // 記錄新元素的索引\n          Step 4: return True // 成功插入元素\nEnd // insert 方法結束\n\nStart // remove 方法\n→ Decision: 若 val ∈ indexMap? // 檢查元素是否存在\n    Yes → Step 1: lastVal ← values[-1] // 取得列表最後一個元素\n          Step 2: idx ← indexMap[val] // 要刪除元素在列表中的索引\n          Step 3: values[idx] ← lastVal // 用最後一個元素覆蓋待刪除位置\n          Step 4: indexMap[lastVal] ← idx // 更新被覆蓋元素的新索引\n          Step 5: values.pop() // 刪除列表末尾（即原本要刪除的元素）\n          Step 6: del indexMap[val] // 移除被刪除元素的映射\n          Step 7: return True // 成功刪除元素\n    No  → Step 8: return False // 元素不存在，刪除失敗\nEnd // remove 方法結束\n\nStart // getRandom 方法\n→ Step 1: r ← RandomInt(0, len(values)-1) // 隨機產生合法索引\n→ Step 2: return values[r] // 以相同概率返回該索引位置的元素\nEnd // getRandom 方法結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[1,0],[0,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [1, 0], [0, 0], null, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\nimport json\n\nclass Solution:\n    def __init__(self, n_rows, n_cols):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit(0)\n\n    # Wrap the two top‑level lists in parentheses to parse as a tuple\n    expr = f\"({data.strip()})\"\n    commands, args = ast.literal_eval(expr)\n\n    obj = None\n    outputs = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            obj = Solution(*arg)\n            outputs.append(None)\n        elif cmd == \"flip\":\n            outputs.append(obj.flip())\n        elif cmd == \"reset\":\n            obj.reset()\n            outputs.append(None)\n        else:\n            raise ValueError(f\"Unknown command: {cmd}\")\n\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for algorithm. The algorithm is known: Use reservoir or mapping technique. Keep a list of available indices flattened; use random index to pick from [0, remaining-1] and map to actual index via hash map for swapping. Use O(1) random and O(m*n) space at most. We'll output virtual code lines with explanations. Each line includes arrow or decision. We'll cover initialization, flip, reset. Use Start and End markers. We'll provide line numbers maybe? Not required. Just steps. Provide structure with arrows. Ensure each line ends with // explanation. Use 'Start' and 'End'. Use '→' before steps. Use 'Decision:' lines. Provide pseudo steps. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 整理 m, n, total ← m * n // 記錄矩陣尺寸與總格數  \n→ Step 2: 建立 HashMap mapping ← {} // 用於存放隨機交換對應關係  \n→ Step 3: 創建可用格數 rem ← total // 剩餘未翻轉的格數  \n→ Step 4: 建立 resetStack ← [] // 用於儲存已翻轉格的索引，方便重置  \n\n→ Step 5: Function flip() 開始 // 觸發一次翻轉  \n→ Decision: 如果 rem == 0? // 檢查是否已無可翻轉格  \n    No  → Step 6: randIdx ← randomInteger(0, rem-1) // 產生 [0, rem-1] 的隨機整數  \n    Yes → Step 7: 返回空陣列 [] // 若無格可翻，直接回傳空  \n\n→ Step 8: targetIdx ← rem - 1 // 取最後一個可用格的索引  \n→ Step 9: realIdx ← mapping.get(targetIdx, targetIdx) // 若已交換，取其映射，否則使用本身  \n→ Step 10: mapping[targetIdx] ← mapping.get(randIdx, randIdx) // 把隨機索引對應到最後位置  \n→ Step 11: rem ← rem - 1 // 這一步格已被占用，減少可用數量  \n→ Step 12: resetStack.push(realIdx) // 記錄實際索引，便於 reset 時還原  \n\n→ Step 13: i ← realIdx // 轉換為 2D 行列  \n→ Step 14: j ← realIdx % n // 行列計算  \n→ Step 15: return [i, j] // 回傳隨機翻轉的格子座標  \n\n→ Step 16: Function reset() 開始 // 重置所有格子  \n→ Step 17: For each idx in resetStack: // 逐一處理已翻轉格  \n    → mapping.remove(idx) // 移除映射，回復原始位置  \n→ Step 18: resetStack.clear() // 清空堆疊  \n→ Step 19: rem ← total // 重新設定可用格數  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpw8ipwsw0.py\", line 81, in <module>\n    main()\n  File \"/tmp/tmpw8ipwsw0.py\", line 49, in main\n    commands, arguments = parse_input(data)\n                          ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpw8ipwsw0.py\", line 40, in parse_input\n    cmds = ast.literal_eval(m.group(1))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"]\n                                                                              ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass MagicDictionary:\n    \"\"\"高效字典，支持單字變一個字母的查詢。\"\"\"\n    def __init__(self):\n        self.pattern_map = {}          # pattern -> set of words\n\n    def buildDict(self, dictionary):\n        \"\"\"建立字典，預先把所有單字的「一個位置改為 *」模式存起來。\"\"\"\n        self.pattern_map.clear()\n        for word in dictionary:\n            for i in range(len(word)):\n                pattern = word[:i] + '*' + word[i+1:]\n                self.pattern_map.setdefault(pattern, set()).add(word)\n\n    def search(self, searchWord):\n        \"\"\"若能改一個字母使之在字典中，則回傳 True。\"\"\"\n        for i in range(len(searchWord)):\n            pattern = searchWord[:i] + '*' + searchWord[i+1:]\n            if pattern in self.pattern_map:\n                words_set = self.pattern_map[pattern]\n                # 只要有不同於原字的單字即可\n                if len(words_set) > 1 or searchWord not in words_set:\n                    return True\n        return False\n\n\ndef parse_input(s: str):\n    \"\"\"\n    把類似\n    [\"MagicDictionary\",\"buildDict\",\"search\"], [[],[...],[\"hello\"]]\n    這樣的字串解析成兩個列表。\n    \"\"\"\n    # 用正則找出兩個列表\n    m = re.match(r'\\s*(\\[.*\\])\\s*,\\s*(\\[.*\\])\\s*', s)\n    if not m:\n        raise ValueError(\"輸入格式錯誤\")\n    cmds = ast.literal_eval(m.group(1))\n    args = ast.literal_eval(m.group(2))\n    return cmds, args\n\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    commands, arguments = parse_input(data)\n\n    results = []\n    obj = None\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"MagicDictionary\":\n            obj = MagicDictionary()\n            results.append(None)            # constructor 產生 null\n        elif cmd == \"buildDict\":\n            obj.buildDict(arg)\n            results.append(None)            # buildDict 產生 null\n        elif cmd == \"search\":\n            res = obj.search(arg)\n            results.append(res)             # boolean\n        else:\n            results.append(None)\n\n    # 將結果輸出成符合題目要求的格式\n    def fmt(v):\n        if v is None:\n            return \"null\"\n        if v is True:\n            return \"true\"\n        if v is False:\n            return \"false\"\n        return str(v)\n\n    output = \"[\" + \", \".join(fmt(v) for v in results) + \"]\"\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo-code line by line with explanation after space. Use arrow etc. Provide structure: Start, etc. Provide logic: building dictionary, search.\n\nPseudo-code: Build a trie or hash mapping with patterns? Standard approach: For each word, generate all patterns with one wildcard replaced, store in map. Then search: generate patterns from searchWord, if any pattern exists and original word not same? Actually condition: change exactly one character, so must be different. Implementation: For each position, replace char with '*' and check if pattern exists in dictionary map and that the stored words set contains at least one word different from searchWord. In pseudocode we can use map from pattern to set of words. So build: iterate words, for each index produce pattern, add word to set.\n\nSearch: iterate positions, produce pattern, lookup set, if exists and either set size>1 or word not equal to searchWord then return true. else after loop return false.\n\nLet's produce lines:\n\nStart\n→ Step 1: 定義 MagicDictionary 類別 // 初始化類別\n→ Step 2: 建構函式 MagicDictionary() 初始化空字典 // 建構器\n    → Assignment: dictionaryMap ← 空 Map // 以 pattern → 文字集合\n→ End // 但 still inside class\n\nBetter structure: maybe use Start to show algorithm, not inside class? The instruction: generate virtual code step by step for tasks. So we can present pseudo-code for entire class: Start, define class, constructor, buildDict, search, End.\n\nLet's create lines accordingly:\n\nStart // 程式開始執行\n→ Step 1: 定義 MagicDictionary 類別 // 宣告類別\n→ Step 2: 定義建構函式 MagicDictionary() // 初始化字典\n    → Step 2.1: dictionaryMap ← 空 Map<string, Set<string>> // pattern 到單詞集合\n→ Step 3: 定義方法 buildDict(dictionary: String[]) // 設定字典\n    → Decision: dictionary 不是空？ // 若有單詞才進行\n        → Step 3.1: 對每個 word in dictionary 迴圈 // 逐一處理\n            → Step 3.1.1: 對每個 index i in word 迴圈 // 逐字位置\n                → Step 3.1.1.1: pattern ← word 文字串，將第 i 個字元替換成 '*' // 建立萬用字串\n                → Step 3.1.1.2: 如果 pattern 未在 dictionaryMap 中，則新增空集合 // 初始化\n                → Step 3.1.1.3: dictionaryMap[pattern].add(word) // 加入對應單詞\n→ Step 4: 定義方法 search(searchWord: String) : Boolean // 搜尋是否可改一字符合\n    → Step 4.1: 對每個 index i in searchWord 迴圈 // 逐位置產生 pattern\n        → Step 4.1.1: pattern ← searchWord，將第 i 個字元改為 '*' // 產生萬用字串\n        → Decision: pattern 在 dictionaryMap 中？ // 判斷是否存在\n            → Yes →\n                → Step 4.1.1.1: wordsSet ← dictionaryMap[pattern] // 取得對應集合\n                → Decision: wordsSet.size > 1 或 wordsSet 包含除 searchWord 之外的任何字？ // 檢查是否能改為不同單詞\n                    → Yes → Step 4.1.1.1.1: 返回 true // 找到可改成的字\n                    → No  → Step 4.1.1.1.2: 繼續下一個 index\n            → No  → Step 4.1.2: 繼續下一個 index\n    → Step 4.2: 返回 false // 沒有符合條件\nEnd // 程式執行結束\n\nWe must ensure every line has explanation after space.\n\nMake sure arrow usage: Use \"→\" arrow before step, and decisions use \"Decision:\".\n\nAlso indentation can be represented but not required. Provide line by line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MagicDictionary 類別 // 宣告類別  \n→ Step 2: 定義建構函式 MagicDictionary() // 初始化字典  \n  → Step 2.1: dictionaryMap ← 空 Map<string, Set<string>> // pattern → 單詞集合  \n→ Step 3: 定義方法 buildDict(dictionary: String[]) // 設定字典  \n  → Decision: dictionary 不是空？ // 若有單詞才進行  \n   Yes → Step 3.1: 對每個 word in dictionary 迴圈 // 逐一處理  \n    → Step 3.1.1: 對每個 index i in word 迴圈 // 逐字位置  \n     → Step 3.1.1.1: pattern ← word，將第 i 個字元替換成 '*' // 建立萬用字串  \n     → Step 3.1.1.2: 如果 pattern 未在 dictionaryMap 中，則新增空集合 // 初始化  \n     → Step 3.1.1.3: dictionaryMap[pattern].add(word) // 加入對應單詞  \n→ Step 4: 定義方法 search(searchWord: String) : Boolean // 搜尋是否可改一字符合  \n  → Step 4.1: 對每個 index i in searchWord 迴圈 // 逐位置產生 pattern  \n   → Step 4.1.1: pattern ← searchWord，將第 i 個字元改為 '*' // 產生萬用字串  \n   → Decision: pattern 在 dictionaryMap 中？ // 判斷是否存在  \n    Yes → Step 4.1.1.1: wordsSet ← dictionaryMap[pattern] // 取得對應集合  \n     → Decision: wordsSet.size > 1 或 wordsSet 包含除 searchWord 之外的任何字？ // 檢查是否能改為不同單詞  \n      Yes → Step 4.1.1.1.1: 返回 true // 找到可改成的字  \n      No → Step 4.1.1.1.2: 繼續下一個 index  \n    No → Step 4.1.2: 繼續下一個 index  \n  → Step 4.2: 返回 false // 沒有符合條件  \nEnd // 程式執行結束"
    },
    {
      "title": "Next Greater Element I",
      "source_file": "Leetcode/leetcode496.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [4,1,2], nums2 = [1,3,4,2]",
          "expected_output": "[-1,3,-1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4ze1by0y.py\", line 34, in <module>\n    result = next_greater_element(nums1, nums2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4ze1by0y.py\", line 15, in next_greater_element\n    nxt.pop()\nTypeError: pop expected at least 1 argument, got 0"
        },
        {
          "example_index": 1,
          "input": "nums1 = [2,4], nums2 = [1,2,3,4]",
          "expected_output": "[3,-1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbze9xe8a.py\", line 34, in <module>\n    result = next_greater_element(nums1, nums2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbze9xe8a.py\", line 15, in next_greater_element\n    nxt.pop()\nTypeError: pop expected at least 1 argument, got 0"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\ndef next_greater_element(nums1, nums2):\n    \"\"\"Return list of next greater elements for nums1 based on nums2.\"\"\"\n    stack = []\n    nxt = {}\n    for num in nums2:\n        while stack and num > stack[-1]:\n            nxt[stack.pop()] = num\n        stack.append(num)\n    # Remaining elements have no greater element\n    for _ in stack:\n        nxt.pop()\n    return [nxt.get(x, -1) for x in nums1]\n\ndef parse_input(data: str):\n    \"\"\"\n    Extract two lists from input string formatted like:\n    'nums1 = [a,b], nums2 = [c,d]'\n    \"\"\"\n    pattern = r'nums1\\s*=\\s*(\\[.*?\\])\\s*,\\s*nums2\\s*=\\s*(\\[.*?\\])'\n    match = re.search(pattern, data, re.DOTALL)\n    if not match:\n        raise ValueError(\"Input format incorrect\")\n    nums1 = ast.literal_eval(match.group(1))\n    nums2 = ast.literal_eval(match.group(2))\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums1, nums2 = parse_input(data)\n    result = next_greater_element(nums1, nums2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: given two arrays, find next greater element for each element in nums1 based on nums2. Classic problem: Next Greater Element I. Approach: precompute next greater for each element in nums2 using stack O(n). Then iterate nums1 and map. Use hash map for value to next greater. So produce stepwise virtual code lines with explanation. Must use arrow syntax. Should be in Traditional Chinese. Each line: 虛擬碼步驟 // 解釋. Use Start, End, Decision. Provide steps.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化空棧 stack // 用於存儲未找到下一個更大元素的索引\n→ Step 2: 初始化空映射 nextGreaterMap // 將 nums2 的每個值映射到其下一個更大元素\n→ Decision: 循環遍歷 nums2 的索引 i 從 0 到 len(nums2)-1? // 為每個元素計算下一個更大\n    Yes → Step 3: While stack 非空且 nums2[stack.top] < nums2[i] 做:\n        → Step 3.1: idx = stack.pop() // 取出堆頂索引\n        → Step 3.2: nextGreaterMap[nums2[idx]] = nums2[i] // 將 nums2[idx] 的下一個更大設為 nums2[i]\n    → Step 4: push i 到 stack // 將當前索引入棧\n→ Step 5: 循環結束後，棧中剩餘索引對應的元素沒有更大元素\n    → Step 6: While stack 非空:\n        → Step 6.1: idx = stack.pop()\n        → Step 7: nextGreaterMap[nums2[idx]] = -1 // 沒有更大元素設為 -1\n→ Step 8: 初始化結果陣列 ans，長度為 nums1.length\n→ Decision: 循環遍歷 nums1 的索引 k 從 0 到 len(nums1)-1? // 生成答案\n    Yes → Step 9: ans[k] = nextGreaterMap[nums1[k]] // 取映射值\n→ End // 程式執行結束\n\nNeed to ensure each line ends with explanation. Use proper syntax. Also need to ensure we use \"→ Decision:\" only for decision loops; but loops can be \"→ Step: For i in range...\" But spec suggests use decision for if. But loops can be just step with arrow.\n\nWe must maintain format: \"虛擬碼步驟 // 解釋/說明\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空棧 stack // 用於存儲未找到下一個更大元素的索引\n→ Step 2: 初始化空映射 nextGreaterMap // 將 nums2 的每個值映射到其下一個更大元素\n→ Decision: 迭代 nums2 的每個索引 i 從 0 到 len(nums2)-1? // 為每個元素計算下一個更大\n    Yes → Step 3: While stack 非空且 nums2[stack.top] < nums2[i] 做: // 找到前面比現在小的元素\n        → Step 3.1: idx = stack.pop() // 取出堆頂索引\n        → Step 3.2: nextGreaterMap[nums2[idx]] = nums2[i] // 設定 idx 所對應值的下一個更大\n    → Step 4: push i 到 stack // 把目前索引入棧等待後續更大的元素\n→ Step 5: 迭代結束後，棧中剩餘索引對應的元素沒有更大元素\n    → Step 6: While stack 非空:\n        → Step 6.1: idx = stack.pop()\n        → Step 6.2: nextGreaterMap[nums2[idx]] = -1 // 無更大元素時設為 -1\n→ Step 7: 初始化結果陣列 ans，長度為 nums1.length\n→ Decision: 迭代 nums1 的每個索引 k 從 0 到 len(nums1)-1? // 生成答案\n    Yes → Step 8: ans[k] = nextGreaterMap[nums1[k]] // 從映射取得下一個更大元素\n→ End // 程式執行結束"
    },
    {
      "title": "Parse Lisp Expression",
      "source_file": "Leetcode/leetcode736.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"",
          "expected_output": "14",
          "actual_output_or_error": "File \"/tmp/tmpvtkqojiq.py\", line 56\n    if (expr and ((expr[0] == '\"' and expr[-1] == '\"') or (expr[0] == \"'\" and expr[-1] == \"'\")):\n                                                                                               ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "expression = \"(let x 3 x 2 x)\"",
          "expected_output": "2",
          "actual_output_or_error": "File \"/tmp/tmpaugemea3.py\", line 56\n    if (expr and ((expr[0] == '\"' and expr[-1] == '\"') or (expr[0] == \"'\" and expr[-1] == \"'\")):\n                                                                                               ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "expression = \"(let x 1 y 2 x (add x y) (add x y))\"",
          "expected_output": "5",
          "actual_output_or_error": "File \"/tmp/tmp6y4bske1.py\", line 56\n    if (expr and ((expr[0] == '\"' and expr[-1] == '\"') or (expr[0] == \"'\" and expr[-1] == \"'\")):\n                                                                                               ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        def eval_expr(expr: str, env: dict) -> int:\n            # If it's not a parenthesized expression, it's a number or variable\n            if expr[0] != '(':\n                if expr[0].isalpha():          # variable\n                    return env[expr]\n                return int(expr)                # integer literal\n\n            # Strip the outermost parentheses\n            expr = expr[1:-1]\n            tokens = []\n            balance = 0\n            start = 0\n            for i, c in enumerate(expr):\n                if c == '(':\n                    balance += 1\n                elif c == ')':\n                    balance -= 1\n                elif c == ' ' and balance == 0:\n                    tokens.append(expr[start:i])\n                    start = i + 1\n            tokens.append(expr[start:])           # last token\n\n            op = tokens[0]\n            if op == 'add':\n                return eval_expr(tokens[1], env.copy()) + eval_expr(tokens[2], env.copy())\n            elif op == 'mult':\n                return eval_expr(tokens[1], env.copy()) * eval_expr(tokens[2], env.copy())\n            elif op == 'let':\n                new_env = env.copy()\n                i = 1\n                while i < len(tokens) - 1:\n                    var = tokens[i]\n                    val = eval_expr(tokens[i + 1], new_env)\n                    new_env[var] = val\n                    i += 2\n                return eval_expr(tokens[-1], new_env)\n            else:\n                # Should never reach here for valid input\n                raise ValueError(f\"Unknown operator: {op}\")\n\n        return eval_expr(expression, {})\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the expression; input may be like: expression = \"(let x 2 ...)\"\n    if '=' in data:\n        expr = data.split('=', 1)[1].strip()\n        if (expr and ((expr[0] == '\"' and expr[-1] == '\"') or (expr[0] == \"'\" and expr[-1] == \"'\")):\n            expr = expr[1:-1]\n    else:\n        expr = data.strip()\n\n    solution = Solution()\n    result = solution.evaluate(expr)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps to evaluate the given Lisp-like expression. The user just wants the pseudocode with explanations, not actual code. Should be line by line, use arrows and Decision structure. So need to outline algorithm: parse expression, use stack or recursion, maintain environment stack of scopes (hash maps). Steps: Start, parse expression string, call evaluate(expr, env). If expr starts with '(', parse first token to determine type (let, add, mult). For let: parse pairs, evaluate each e_i in current env, push new scope? Actually let introduces new bindings within the let expression's body. Implementation: create new scope dict, evaluate e_i sequentially, adding to current scope. For nested let, need to support variable shadowing. Use stack of scopes: each new let pushes new scope? But let is scoped to its body only, not to subsequent expressions. So we push a new scope frame that is used for evaluating e_i and expr; after evaluation, pop.\n\nSimplify: For evaluation, maintain a stack of scopes. For each let expression: create new empty scope; then for each pair v_i e_i: evaluate e_i with current stack (including this new scope maybe?) But assignments should be visible to later expressions within same let, so we need to add to the new scope after evaluating e_i. So process: push new scope onto stack; for each pair: evaluate e_i, then set variable in current top scope; after all pairs, evaluate expr; pop scope; return result.\n\nFor add, mult: evaluate two expressions recursively.\n\nFor integer: parse to integer and return.\n\nFor variable: find value by searching from top of stack downwards.\n\nAlso need tokenization and parsing; can parse recursively by scanning parentheses.\n\nSimplify: implement a parse function that returns an AST node: type: 'int', 'var', 'let', 'add', 'mult', with children. Then evaluate AST recursively.\n\nPseudo-code will include tokenization, parse, evaluation functions. Provide steps for each.\n\nLet's produce pseudocode with comments. We'll use arrow notation.\n\nWe must not output actual code; just pseudocode.\n\nLet's produce steps:\n\nStart.\n\n→ Tokenize(input) // split string into tokens.\n\n→ Parse(tokens) // parse tokens into expression tree.\n\n→ Evaluate(expression, envStack) // evaluate tree with environment stack.\n\nWhere envStack initial empty.\n\nDefine Evaluate:\n\n→ Decision: If node is integer → return integer.\n\n→ Decision: If node is variable → look up variable in envStack; return value.\n\n→ Decision: If node is add → evaluate left, evaluate right, return sum.\n\n→ Decision: If node is mult → evaluate left, evaluate right, return product.\n\n→ Decision: If node is let → push new scope; for each pair: evaluate e_i, assign to var in top scope; evaluate expr; pop scope; return expr value.\n\nAlso need function Lookup(variable, envStack) scanning from top.\n\nParsing steps:\n\n→ Tokenize: split by spaces, parentheses, numbers.\n\n→ Parse: if token is '(' → read next token as operator; then depending on operator, parse appropriate number of operands; build node.\n\nThis may involve recursion.\n\nAlso mention environment stack as list of dictionaries.\n\nNow produce final answer line by line with pseudocode and explanation.\n\nEnsure each line uses arrow and explanation.\n\nLet's craft.\n\nWe will use Start and End markers.\n\nAlso use Decision lines and Yes/No for decisions.\n\nBut since pseudocode, we don't need many branches. Use simple decisions.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Tokenize(input) // 將輸入字串拆成標記（Token）列表，分離括號、單字與數字\n\n→ Parse(tokens) // 依照語法遞迴解析標記，建立抽象語法樹（AST）\n\n→ envStack ← [] // 環境堆疊，存放變數對應值的字典，最上層為最近的作用域\n\n→ result ← Evaluate(AST, envStack) // 以 AST 為根，遞迴計算整個表達式的整數值\n\n→ Print(result) // 輸出最終計算結果\n\n→ End // 程式執行結束\n\n\n\n--- Tokenize ---\n\n→ Tokenize(input)\n\n    → For each character in input\n\n        → If char is '(' or ')' → add as separate token\n\n        → Else if char is space → skip\n\n        → Else accumulate characters until next space or parenthesis → add as token\n\n    → Return tokens list\n\n\n\n--- Parse ---\n\n→ Parse(tokens)\n\n    → current ← PeekFirst(tokens)\n\n    → Decision: If current == '('\n\n        → Consume '('\n\n        → op ← ConsumeNext(tokens) // 取得 'let', 'add', 'mult' 或變數名\n\n        → Decision: If op == 'let'\n\n            → pairs ← []\n\n            → While PeekNext(tokens) != ')'\n\n                → var ← ConsumeNext(tokens) // 變數名稱\n\n                → expr ← Parse(tokens)     // 解析對應的表達式\n\n                → Append (var, expr) to pairs\n\n            → body ← Parse(tokens) // 最後的 expr\n\n            → Consume ')' \n\n            → Return Node(type='let', pairs=pairs, body=body)\n\n        → Decision: If op == 'add' or op == 'mult'\n\n            → left ← Parse(tokens)\n\n            → right ← Parse(tokens)\n\n            → Consume ')'\n\n            → Return Node(type=op, left=left, right=right)\n\n    → Decision: Else // 非括號開頭，為單一項\n\n        → Decision: If current matches integer pattern\n\n            → Consume and return Node(type='int', value=ParseInt(current))\n\n        → Else // 變數\n\n            → Consume and return Node(type='var', name=current)\n\n\n\n--- Evaluate ---\n\n→ Evaluate(node, envStack)\n\n    → Decision: If node.type == 'int'\n\n        → Yes → Return node.value // 直接回傳整數\n\n    → Decision: If node.type == 'var'\n\n        → Yes → Return Lookup(node.name, envStack) // 依作用域查找變數值\n\n    → Decision: If node.type == 'add'\n\n        → leftVal ← Evaluate(node.left, envStack)\n\n        → rightVal ← Evaluate(node.right, envStack)\n\n        → Return leftVal + rightVal // 兩子表達式相加\n\n    → Decision: If node.type == 'mult'\n\n        → leftVal ← Evaluate(node.left, envStack)\n\n        → rightVal ← Evaluate(node.right, envStack)\n\n        → Return leftVal * rightVal // 兩子表達式相乘\n\n    → Decision: If node.type == 'let'\n\n        → Push newScope ← {} onto envStack // 進入新的作用域\n\n        → For each (var, expr) in node.pairs\n\n            → val ← Evaluate(expr, envStack) // 先計算表達式\n\n            → newScope[var] ← val            // 把變數賦值到最上層作用域\n\n        → bodyVal ← Evaluate(node.body, envStack) // 計算 let 表達式的主體\n\n        → Pop envStack // 退出 let 作用域\n\n        → Return bodyVal\n\n\n\n--- Lookup ---\n\n→ Lookup(varName, envStack)\n\n    → For scope in envStack (從最上層往下)\n\n        → If varName exists in scope\n\n            → Return scope[varName]\n\n    → // 若找不到，說明輸入非法（此情況在題目中不會發生）\n\n    → Raise error or return 0 // 例外處理\n\n\n\n--- Helper Functions ---\n\n→ ConsumeNext(tokens) // 取出並移除 tokens 列表中的第一個元素，並返回其值\n\n→ PeekFirst(tokens) // 取出但不移除第一個元素\n\n→ PeekNext(tokens) // 取出第二個元素（若存在）\n\n\n\n以上虛擬碼完整描述了從輸入字串解析、建立抽象語法樹、維護多層作用域環境，以及遞迴評估 Lisp‑style 表達式的過程。"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[], [1], [2], [1, 2], [2, 2], [1, 2, 2]]'"
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result: List[List[int]] = [[]]\n        for i, num in enumerate(nums):\n            # skip duplicates: only start new subsets from the first occurrence of this number\n            if i > 0 and nums[i] == nums[i - 1]:\n                # start from the subsets that were added in the previous step\n                start = len(result) - (len(result) // 2)\n            else:\n                start = 0\n            new_subsets = []\n            for subset in result[start:]:\n                new_subsets.append(subset + [num])\n            result.extend(new_subsets)\n        return result\n\ndef parse_input(line: str) -> List[int]:\n    line = line.strip()\n    if '=' in line:\n        _, expr = line.split('=', 1)\n        line = expr.strip()\n    return eval(line, {\"__builtins__\": None}, {})\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums = parse_input(data)\n    sol = Solution()\n    subsets = sol.subsetsWithDup(nums)\n    print(subsets)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating power set of an integer array that may contain duplicates, ensuring no duplicate subsets. This is classic backtracking with sorting and skipping duplicates. So produce steps:\n\nStart\n→ Input array nums\n→ Sort nums\n→ Initialize result list\n→ Define backtrack function (index, path)\n→ If index == length: add copy of path to result\n→ Else: 1) include current num: add to path, backtrack(index+1, path), pop\n→ 2) skip duplicates: while index+1 < len and nums[index+1]==nums[index], skip? Actually standard approach: after including, we can skip duplicates when deciding to skip current element. Actually standard pattern: backtrack(i+1, path) after adding; then skip duplicates: while i+1 < n and nums[i+1]==nums[i]: i+=1; then backtrack(i+1, path). But simpler: in recursion we handle two branches: include and exclude, but when exclude, we need to skip duplicates: i+=1 while next equal. We'll do simpler: at each recursion, we loop over indices from start to n-1 and skip duplicates.\n\nSimpler: Use for loop inside backtrack: for i from start to n-1:\n- if i > start and nums[i]==nums[i-1] skip\n- add nums[i] to path, backtrack(i+1,...), pop\n\nAlso need to include empty subset.\n\nImplement steps accordingly.\n\nNow produce virtual code lines with arrows and comments.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: Input integer array nums // 取得原始陣列\n→ Step 2: Sort nums // 先排序，方便後續跳過重複元素\n→ Step 3: Initialize result = [] // 儲存所有子集\n→ Step 4: Define Backtrack(start, path) // 回溯函式，start 為當前起點，path 為目前已選取的元素\n    → Decision: 如果 start == nums.length? // 是否已到達陣列末尾\n        Yes → Step 5: Add copy of path to result // 把目前子集加入結果\n        No  → Step 6: For i from start to nums.length-1 // 遍歷剩餘元素\n              → Decision: 如果 i > start 且 nums[i] == nums[i-1]? // 跳過重複元素\n                  Yes → Continue // 忽略重複的同級元素\n              → Step 7: Append nums[i] to path // 選取當前元素\n              → Step 8: Call Backtrack(i+1, path) // 往下遞歸\n              → Step 9: Remove last element from path // 回溯，取消選取\n→ Step 10: Call Backtrack(0, []) // 從起始位置開始回溯\n→ Step 11: Return result // 回傳所有不重複的子集\nEnd // 程式執行結束\n\nMake sure each line ends with // 解釋. Use arrows properly: Start, →, Decision: Yes →, No →.\n\nCheck format: \"Step X:\" or \"Decision:\" lines.\n\nNeed to ensure each line has a single virtual code step and a comment. Use proper arrows for decision branches.\n\nWe can combine steps 5 and 6 within decision block. Use indenting as shown in example. We'll write:\n\nStart // 程式開始執行\n→ Step 1: Input integer array nums // 取得原始陣列\n→ Step 2: Sort nums // 先排序，方便後續跳過重複元素\n→ Step 3: Initialize result = [] // 儲存所有子集\n→ Step 4: Define Backtrack(start, path) // 回溯函式，start 為當前起點，path 為目前已選取的元素\n    → Decision: 如果 start == nums.length? // 是否已到達陣列末尾\n        Yes → Step 5: Add copy of path to result // 把目前子集加入結果\n        No  → Step 6: For i from start to nums.length-1 // 遍歷剩餘元素\n              → Decision: 如果 i > start 且 nums[i] == nums[i-1]? // 跳過重複元素\n                  Yes → Continue // 忽略重複的同級元素\n              → Step 7: Append nums[i] to path // 選取當前元素\n              → Step 8: Call Backtrack(i+1, path) // 往下遞歸\n              → Step 9: Remove last element from path // 回溯，取消選取\n→ Step 10: Call Backtrack(0, []) // 從起始位置開始回溯\n→ Step 11: Return result // 回傳所有不重複的子集\nEnd // 程式執行結束\n\nEnsure indentation uses spaces before Decision and arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input integer array nums // 取得原始陣列  \n→ Step 2: Sort nums // 先排序，方便後續跳過重複元素  \n→ Step 3: Initialize result = [] // 儲存所有子集  \n→ Step 4: Define Backtrack(start, path) // 回溯函式，start 為當前起點，path 為目前已選取的元素  \n  → Decision: 如果 start == nums.length? // 是否已到達陣列末尾  \n   Yes → Step 5: Add copy of path to result // 把目前子集加入結果  \n   No  → Step 6: For i from start to nums.length-1 // 遍歷剩餘元素  \n     → Decision: 如果 i > start 且 nums[i] == nums[i-1]? // 跳過重複元素  \n      Yes → Continue // 忽略重複的同級元素  \n      No  → Step 7: Append nums[i] to path // 選取當前元素  \n       → Step 8: Call Backtrack(i+1, path) // 往下遞歸  \n       → Step 9: Remove last element from path // 回溯，取消選取  \n→ Step 10: Call Backtrack(0, []) // 從起始位置開始回溯  \n→ Step 11: Return result // 回傳所有不重複的子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_mwykt_4.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmp_mwykt_4.py\", line 26, in main\n    args_list = ast.literal_eval(second_part)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[[1, 2, 3, 3, 3]], [3], [1], [3]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        return random.choice(self.num_indices[target])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 分離兩個列表\n    parts = data.split('],', 1)\n    first_part = parts[0] + ']'\n    second_part = '[' + parts[1].strip()\n\n    methods = ast.literal_eval(first_part)\n    args_list = ast.literal_eval(second_part)\n\n    results = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == 'Solution':\n            # args 是一個列表，裡面只有一個元素是 nums 列表\n            obj = Solution(args[0])\n            results.append(None)\n        else:\n            # args 可能是 [value]，直接解包\n            res = getattr(obj, method)(*args if isinstance(args, list) else [args])\n            results.append(res)\n\n    # 輸出結果，將 None 轉成 null\n    out_str = '[' + ', '.join('null' if x is None else str(x) for x in results) + ']'\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo code steps for solution class. The code includes constructor and pick function. Should provide step-by-step algorithm. Use virtual code lines with arrow etc. Provide explanation after each line. Must not output actual code. Use structure with Start, End, Decision, etc.\n\nWe need to generate pseudo code for: initialization: store nums array, maybe create mapping from target to list of indices. Or on pick: scan array, store candidate indices and choose random. The requirement: can assume target exists. Implementation options: mapping for O(1) pick. Steps: in constructor: iterate over nums, build map target->list of indices. In pick: get list, choose random index from list. Provide pseudo code lines accordingly.\n\nLet's produce virtual code lines:\n\nStart\n→ Step 1: 接收陣列 nums 作為參數並儲存 // store input array\n→ Step 2: 建立空字典 indexMap // mapping from target to list of indices\n→ Decision: 是否需要遍歷 nums? // we will traverse to fill map\n    Yes → For each index i from 0 to length(nums)-1 // iterate\n        → Step 3: targetValue ← nums[i] // get value at index\n        → Decision: indexMap 是否已含 targetValue? // check if key exists\n            Yes → Step 4: 把 i 加入 indexMap[targetValue] // append index\n            No  → Step 5: 建立新列表並加入 i，再賦值給 indexMap[targetValue] // create list\n    No → (none)\n→ Step 6: 建立隨機數產生器 rng // random generator\nEnd // 初始化完成\n\nStart\n→ Step 7: pick(target) // 函數入口\n→ Decision: indexMap 是否含 target? // guaranteed true\n    Yes → Step 8: list ← indexMap[target] // 取得所有對應索引\n    No  → Step 9: 返回錯誤 // 但不會發生\n→ Step 10: n ← list.length // 數量\n→ Step 11: randIndex ← rng.nextInt(n) // 隨機選一個位置\n→ Step 12: result ← list[randIndex] // 取得對應索引\n→ Step 13: 返回 result // 回傳\nEnd // pick 完成\n\nBut must be \"逐行\" and each line includes code arrow plus explanation. We need to use Start, End, Decision, arrow. Use \"Step 1:\" etc. The \"For each index i\" line maybe as \"Decision:\"? Might use \"Decision:\" to iterate? But we can use a loop structure. For virtual code we might use \"Decision: 遍歷所有 i?\" but maybe better to use \"Decision: i < len(nums)?\" etc. Let's produce something like:\n\nStart\n→ Step 1: 參數 nums ← 入參 // 取得輸入陣列\n→ Step 2: indexMap ← 空字典 // 建立映射\n→ Step 3: i ← 0 // 初始化索引\n→ Decision: i < len(nums) ? // 迴圈條件\n    Yes → Step 4: value ← nums[i] // 取得值\n    → Decision: indexMap 是否有 key value ? // 檢查\n        Yes → Step 5: 把 i 加入 indexMap[value] // 附加索引\n        No  → Step 6: 建立新列表 [i] 並設定 indexMap[value] // 初始化\n    → Step 7: i ← i + 1 // 增量\n    No  → (結束迴圈)\n→ Step 8: rng ← 隨機數產生器 // 準備隨機\nEnd\n\nStart\n→ Step 9: pick(target) // 函式入口\n→ Decision: indexMap 是否含 target? // 確認\n    Yes → Step 10: list ← indexMap[target] // 取得索引清單\n    No  → Step 11: 返回錯誤 // (不會發生)\n→ Step 12: n ← list.length // 數量\n→ Step 13: randIdx ← rng.nextInt(n) // 隨機數\n→ Step 14: result ← list[randIdx] // 取值\n→ Step 15: 返回 result // 結果\nEnd\n\nBut each line must have code arrow and explanation. We'll keep the lines as above. Use \"→\" arrow. Ensure we have \"Start\" and \"End\" lines. Provide explanation after \"//\". Use consistent Chinese. Let's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 參數 nums ← 入參 // 取得輸入陣列\n→ Step 2: indexMap ← 空字典 // 建立映射 target → 索引清單\n→ Step 3: i ← 0 // 初始化迴圈索引\n→ Decision: i < len(nums) ? // 判斷是否還有元素可遍歷\n    Yes → Step 4: value ← nums[i] // 取得當前位置的數值\n    → Decision: indexMap 是否已含 key value ? // 檢查映射中是否已有此數值\n        Yes → Step 5: 把 i 加入 indexMap[value] // 將索引追加到已有清單\n        No  → Step 6: 建立新列表 [i] 並設定 indexMap[value] // 初始化清單\n    → Step 7: i ← i + 1 // 進行索引遞增\n    No  → (結束迴圈)\n→ Step 8: rng ← 隨機數產生器 // 準備隨機數字生成器\nEnd // 初始化完成\n\nStart // pick 函式開始執行\n→ Step 9: pick(target) // 函式入口\n→ Decision: indexMap 是否含 target? // 檢查映射中是否存在目標數值\n    Yes → Step 10: list ← indexMap[target] // 取得所有符合目標的索引清單\n    No  → Step 11: 返回錯誤 // 理論上不會發生，因假設 target 必存在\n→ Step 12: n ← list.length // 計算符合條件的索引數量\n→ Step 13: randIdx ← rng.nextInt(n) // 隨機選取 0~n-1 的索引\n→ Step 14: result ← list[randIdx] // 取得對應的實際索引值\n→ Step 15: 返回 result // 回傳隨機選中的索引\nEnd // pick 函式結束執行"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[0,1],[1,0],[2,4],[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[0, 1], [1, 0], [2, 4], [3, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    __slots__ = (\"children\", \"word_index\", \"pal_suffix_indices\")\n    def __init__(self):\n        self.children = {}\n        self.word_index = -1\n        self.pal_suffix_indices = []\n\nclass Solution:\n    def palindromePairs(self, words):\n        root = TrieNode()\n\n        def is_pal(s, left, right):\n            while left < right:\n                if s[left] != s[right]:\n                    return False\n                left += 1\n                right -= 1\n            return True\n\n        # 建立 Trie，儲存回文後綴索引\n        for idx, word in enumerate(words):\n            node = root\n            # 逐字插入反向字串\n            for i, ch in enumerate(reversed(word)):\n                # 如果目前尚未讀到的前綴是回文，將此索引加入節點\n                if is_pal(word, 0, len(word) - i - 1):\n                    node.pal_suffix_indices.append(idx)\n                node = node.children.setdefault(ch, TrieNode())\n            node.word_index = idx\n            # 空字串也為回文，加入最後節點\n            node.pal_suffix_indices.append(idx)\n\n        res = []\n\n        # 搜尋所有符合條件的 pair\n        for i, word in enumerate(words):\n            node = root\n            for j, ch in enumerate(word):\n                # 若目前節點結束於一個單詞，且剩餘部分為回文，則形成 pair\n                if node.word_index != -1 and node.word_index != i and is_pal(word, j, len(word) - 1):\n                    res.append([i, node.word_index])\n                # 若無子節點則停止\n                if ch not in node.children:\n                    break\n                node = node.children[ch]\n            else:\n                # 已完整走完 word，檢查此節點回文後綴列表\n                for j in node.pal_suffix_indices:\n                    if j != i:\n                        res.append([i, j])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    start = data.find('[')\n    if start == -1:\n        words = []\n    else:\n        words = ast.literal_eval(data[start:])\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for palindrome pairs with O(total length) runtime. The classic solution uses a Trie of reversed words, then check splits. However, O(total length) is typical. Provide pseudocode line by line with explanations. Ensure each line starts with \"Start\", \"→ Step\", \"Decision\", \"Yes →\", \"No →\", \"End\". Also we must not output actual code. So provide high-level steps.\n\nWe need to describe building a Trie of reversed words, storing index and palindrome suffix list. Then iterate each word, check each possible split to find matches. Provide steps.\n\nMake sure each line has the virtual code and comment. Also use arrows.\n\nLet's draft.\n\nStart // 程式開始執行\n\n→ Step 1: Build Trie of reversed words, each node stores indices of words whose suffix from node to leaf forms palindrome.\n\n→ Step 2: For each word at index i, traverse the Trie following characters of word, at each node check two conditions:\n   a) If node contains a word index j where j != i and the remaining part of word from current position to end is palindrome → add pair (i, j).\n   b) If node marks end of a word j (j != i) and the remaining part is palindrome? Actually step for checking suffix palindromes.\n\nBut better structure: For each word, we consider splits. Use precomputed palindrome suffix list.\n\nLet's design algorithm:\n\n- Build Trie of reversed words. Node fields: children[26], wordIndex (index of word that ends at this node, -1 if none), palindromeSuffixList (list of indices of words such that the substring from start to current node is palindrome).\n\n- Build: for each word with index idx, traverse reversed word, at each step if current prefix (original word suffix) is palindrome, add idx to node.palindromeSuffixList. After insertion, set node.wordIndex = idx.\n\n- Query: For each word with index i, traverse Trie following word characters from start to end. At each node:\n   * If node.wordIndex != -1 and node.wordIndex != i and remaining part of word from current pos to end is palindrome → add pair (i, node.wordIndex).\n   * Continue to next char; if no child, break.\nAfter traversal, at end of word, for each idx in node.palindromeSuffixList: if idx != i → add pair (i, idx).\n\nAlso need to check reverse splits: We can also check reversed word to handle pairs where second word is prefix. But the above covers all.\n\nComplexities: building O(total length). Query O(total length).\n\nLet's produce virtual code steps.\n\nWe need to output each line with virtual code and explanation. Use \"→ Step ...\" etc.\n\nLet's produce lines.\n\nStart // 程式開始執行\n\n→ Step 1: Initialize empty Trie root node // 建立空 Trie 樹根節點\n\n→ Step 2: For each word in words with index idx: // 逐個處理單詞\n   → Step 3: Let node ← root // 設定為 Trie 根節點\n   → Step 4: For each character ch in reversed word (from last to first): // 反向遍歷字元\n       → Decision: node.children[ch] 存在? // 判斷子節點是否已存在\n           Yes → Step 5: node ← node.children[ch] // 直接進入子節點\n           No  → Step 6: 建立新節點並插入 node.children[ch] // 建立子節點\n       → Decision: 子節點 node 是否存有 palindrome suffix? // 檢查子節點是否已儲存 palindromic suffix 列表\n           // Actually need to check if the remaining part of original word (prefix) is palindrome before this char. We can compute while traversing.\n   // But to keep steps manageable, we can incorporate palindrome check separately.\n\nActually better to break into building palindromeSuffixList step.\n\nSimplify: We can do building in two passes: one for palindromeSuffixList, one for insertion.\n\nLet's propose:\n\n→ Step 7: Precompute for each word a boolean array isPal[i][k] indicating whether suffix from position k is palindrome. // 先預先計算後綴是否為回文\n\nBut that's not O(total). But computing palindrome per word is O(len^2) if naive. We need O(len). Use two-pointer per word.\n\nBut we can compute palindrome of all prefixes using DP. But we can integrate in traversal: while building reversed word, we can check if the prefix (original suffix) is palindrome by referencing the original word.\n\nWe can compute palindrome of all prefixes of each word in O(len) using expanding from center.\n\nBut maybe easier: We can compute palindrome of all prefixes via two-pointer on word: For each split position p, check if word[0:p] is palindrome. We can compute all splits.\n\nOk we can skip details: in virtual code, we can mention \"Check if prefix is palindrome\" as step.\n\nLet's produce pseudocode accordingly.\n\nWe need to ensure each line ends with comment.\n\nOk.\n\nWe will produce a clear list.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 建立空 Trie 樹根節點 // 初始化 Trie\n\n→ Step 2: 先為每個單詞計算所有前綴是否為回文，存於 bool[][] prePal // 以 O(總長度) 方式預先判斷回文\n\n→ Step 3: For each word with index idx in words: // 逐一處理每個單詞\n   → Step 4: Set node ← root // 以根節點為起點\n   → Step 5: For each character ch at position k in word (從首字到尾字): // 正向遍歷\n       → Decision: ch 已存在於 node.children? // 判斷是否已有該子節點\n           Yes → Step 6: node ← node.children[ch] // 進入已有節點\n           No  → Step 7: 建立新節點並指派給 node.children[ch] // 建立子節點\n       → Decision: 前綴 word[0:k+1] 為回文? // 判斷目前已讀取的前綴是否為回文\n           Yes → Step 8: node.palSuffixList.add(idx) // 若為回文，將此單詞索引加入節點的回文後綴列表\n           No  → // 不做任何事\n   → Step 9: node.wordIndex ← idx // 將此單詞的索引標記於結束節點\n\n→ Step 10: 初始化結果列表 pairs // 用來存放所有 (i, j) 組合\n\n→ Step 11: For each word with index i in words: // 針對每個單詞進行查找\n   → Step 12: Set node ← root // 重新從根節點開始\n   → Step 13: For each character ch at position k in word (從首字到尾字): // 正向遍歷\n       → Decision: node.wordIndex ≠ -1 且 node.wordIndex ≠ i 且 word[k+1:] 為回文? // 檢查是否能形成 (i, j) 的組合\n           Yes → Step 14: pairs.add( [i, node.wordIndex] ) // 加入 (i, j)\n           No  → // 不加\n       → Decision: ch 存於 node.children? // 判斷是否能繼續走下去\n           Yes → Step 15: node ← node.children[ch] // 進入下一節點\n           No  → Step 16: 結束此詞的遍歷並跳至下一個 i // 若沒有子節點，無法再找\n   → Step 17: // 走完整個單詞後，檢查回文後綴列表\n   → Decision: node.palSuffixList 非空? // 若此節點存有回文後綴\n       Yes → For each j in node.palSuffixList:\n               → Decision: j ≠ i? // 確保不是同一個單詞\n                   Yes → Step 18: pairs.add( [i, j] ) // 加入 (i, j)\n                   No  → // 跳過\n       No  → // 無需做任何事\n\nEnd // 程式執行結束，返回 pairs\n\n(Note: 本虛擬碼僅示範核心思路，具體實作時需在步驟 5/13 中完成回文判斷與 Trie 操作，確保總時間複雜度為 O(∑|words[i]|)。)"
    },
    {
      "title": "Implement Queue using Stacks",
      "source_file": "Leetcode/leetcode232.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2hiz0zei.py\", line 25, in <module>\n    obj.push(arg[0])\n    ^^^^^^^^\nAttributeError: 'MyQueue' object has no attribute 'push'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyQueue:\n    ...\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    # filter out empty lines\n    lines = [line for line in data if line.strip() != \"\"]\n    # ignore first line if it is \"Input\"\n    if lines and lines[0].strip().lower() == \"input\":\n        lines = lines[1:]\n    if len(lines) < 2:\n        print(\"[]\")\n        sys.exit(0)\n    ops = json.loads(lines[0].strip())\n    args = json.loads(lines[1].strip())\n    obj = None\n    res = []\n    for op, arg in zip(ops, args):\n        if op == \"MyQueue\":\n            obj = MyQueue()\n            res.append(None)\n        elif op == \"push\":\n            obj.push(arg[0])\n            res.append(None)\n        elif op == \"pop\":\n            res.append(obj.pop())\n        elif op == \"peek\":\n            res.append(obj.peek())\n        elif op == \"empty\":\n            res.append(obj.empty())\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanations. The requirement: Use two stacks to implement FIFO queue. Provide push, pop, peek, empty. Only standard stack operations. So we need to outline algorithm: maintain two stacks: stack_in and stack_out. For push, push onto stack_in. For pop/peek: if stack_out empty, transfer all from stack_in to stack_out. Then pop/peek from stack_out. Empty: stack_in empty and stack_out empty.\n\nWe need virtual code steps, each line: \"虛擬碼步驟 // 解釋\". Use arrows. Start, End, Decision. So we need to produce pseudocode for the class and methods.\n\nWe should output lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義 MyQueue 類 // 建立類別\n\nBut we need to represent each step of algorithm. The requirement: \"逐行產生對應的虛擬碼\". So for each line of algorithm, we need explanation.\n\nWe'll structure:\n\nStart // 程式開始執行\n→ Step 1: 定義 MyQueue 類\n→ Step 2: 在 MyQueue 內部定義兩個空堆疊 stack_in, stack_out\n→ Method push(x): // 進入 push 方法\n   → Step 3: stack_in.push(x) // 將元素放入輸入堆疊\n→ Method pop(): // 進入 pop 方法\n   → Decision: if stack_out.isEmpty() // 若輸出堆疊為空\n        Yes → Step 4: while stack_in not empty\n                → Step 5: temp = stack_in.pop()\n                → Step 6: stack_out.push(temp) // 將所有輸入堆疊元素倒轉到輸出堆疊\n        No → ...\n   → Step 7: return stack_out.pop() // 從輸出堆疊彈出並返回\n→ Method peek(): // 進入 peek 方法\n   → Decision: if stack_out.isEmpty()\n        Yes → same transfer steps as above\n   → Step 8: return stack_out.peek() // 返回輸出堆疊頂部元素\n→ Method empty(): // 進入 empty 方法\n   → Step 9: return stack_in.isEmpty() AND stack_out.isEmpty() // 判斷兩個堆疊是否皆空\nEnd // 程式結束\n\nWe need each step as a separate line. The decision lines need branching. For each branch we need \"Yes →\" and \"No →\". For transfer, we might collapse into a separate procedure \"Transfer()\" for clarity, but we need line by line.\n\nLet's produce full virtual code. Use \"Start\", \"End\". Each line: \"虛擬碼步驟 // 解釋\". For decision branches we include \"Decision:\" lines. Example: \"Decision: stack_out.isEmpty()?\" but we need to use arrow. We'll produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 MyQueue 類 // 建立 MyQueue 類別\n    → Step 1.1: 定義空堆疊 stack_in // 用於入隊操作\n    → Step 1.2: 定義空堆疊 stack_out // 用於出隊操作\n→ Method push(x): // 入隊\n    → Step 2: stack_in.push(x) // 將元素推入輸入堆疊\n→ Method pop(): // 出隊\n    → Decision: stack_out.isEmpty()? // 檢查輸出堆疊是否空\n        Yes → Step 3: while not stack_in.isEmpty() // 若空，將所有元素從輸入堆疊轉移\n            → Step 3.1: temp = stack_in.pop() // 取出輸入堆疊頂部元素\n            → Step 3.2: stack_out.push(temp) // 放入輸出堆疊，形成正向順序\n        No  → // 若不空，直接跳過轉移\n    → Step 4: return stack_out.pop() // 從輸出堆疊彈出並返回\n→ Method peek(): // 查看前端\n    → Decision: stack_out.isEmpty()?\n        Yes → Step 5: while not stack_in.isEmpty()\n            → Step 5.1: temp = stack_in.pop()\n            → Step 5.2: stack_out.push(temp)\n        No  →\n    → Step 6: return stack_out.peek() // 返回輸出堆疊頂部元素但不移除\n→ Method empty(): // 判斷是否為空\n    → Step 7: return stack_in.isEmpty() AND stack_out.isEmpty() // 兩堆疊皆空時為空\nEnd // 程式結束\n\nWe need to ensure each line ends with // explanation. Use arrow \"→\" at beginning of each step except maybe inside decisions? In example, decisions are shown as \"Decision:\" with indentation.\n\nWe'll format accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyQueue 類 // 建立 MyQueue 類別  \n → Step 1.1: 定義空堆疊 stack_in // 用於入隊操作  \n → Step 1.2: 定義空堆疊 stack_out // 用於出隊操作  \n→ Method push(x): // 入隊操作  \n → Step 2: stack_in.push(x) // 將元素推入輸入堆疊  \n→ Method pop(): // 出隊操作  \n → Decision: stack_out.isEmpty()? // 檢查輸出堆疊是否空  \n  Yes → Step 3: while not stack_in.isEmpty() // 若空，將所有元素從輸入堆疊轉移  \n   → Step 3.1: temp = stack_in.pop() // 取出輸入堆疊頂部元素  \n   → Step 3.2: stack_out.push(temp) // 放入輸出堆疊，形成正向順序  \n  No → // 若輸出堆疊不空，直接跳過轉移  \n → Step 4: return stack_out.pop() // 從輸出堆疊彈出並返回  \n→ Method peek(): // 查看前端元素  \n → Decision: stack_out.isEmpty()? // 檢查輸出堆疊是否空  \n  Yes → Step 5: while not stack_in.isEmpty() // 若空，將所有元素從輸入堆疊轉移  \n   → Step 5.1: temp = stack_in.pop() // 取出輸入堆疊頂部元素  \n   → Step 5.2: stack_out.push(temp) // 放入輸出堆疊，形成正向順序  \n  No → // 若輸出堆疊不空，直接跳過轉移  \n → Step 6: return stack_out.peek() // 返回輸出堆疊頂部元素但不移除  \n→ Method empty(): // 判斷隊列是否為空  \n → Step 7: return stack_in.isEmpty() AND stack_out.isEmpty() // 兩堆疊皆空時為空  \nEnd // 程式結束執行"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        找出唯一出現的字串，並回傳其中長度最大的值。\n        若所有字串都重複，回傳 -1。\n        \"\"\"\n        # 計算每個字串的出現次數\n        freq = Counter(strs)\n        max_len = -1\n        for s in strs:\n            # 只考慮唯一的字串\n            if freq[s] == 1:\n                max_len = max(max_len, len(s))\n        return max_len\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin，預期是 JSON 格式的字串陣列\n    data = sys.stdin.read()\n    if data.strip():\n        strs = json.loads(data.strip())\n    else:\n        strs = []\n    result = Solution().findLUSlength(strs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for the algorithm. We should include Start, End, decisions, steps. The algorithm: longest uncommon subsequence among array of strings. Known solution: if any string is unique among array, then answer is its length; else -1. Explanation: longest uncommon subsequence is length of longest string that is not a duplicate, else -1. Actually if there is a string that is not repeated, then that string itself is an uncommon subsequence. Because it's not a subsequence of other identical strings? Wait typical solution: longest uncommon subsequence problem Leetcode 964. The answer is the length of longest string that is not a duplicate. Because any other string would be subsequence? But if string repeats, can't use. So algorithm: find frequencies. For each string in array, if frequency==1, consider length, take max. If no such string, return -1.\n\nThus we produce virtual code accordingly. We'll produce steps: Start, compute frequencies, iterate over strings, if freq==1 update maxLen, End return maxLen or -1. Provide line by line.\n\nLet's produce code with arrows: Start, Step 1: build frequency map, Step 2: maxLen= -1, Step 3: for each string in strs, if freq==1 then update maxLen, Step 4: End, return maxLen.\n\nAdd decision: if freq==1? Yes → update. Also after loop: Decision if maxLen==-1? Yes → return -1 else return maxLen.\n\nAlso include explanation after each line. Ensure format: \"虛擬碼步驟 // 解釋/說明\". Use Chinese.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 freqMap // 用來計算每個字串出現的次數  \n→ Step 2: 對每個字串 s in strs 執行  \n  → Decision: s 已存在於 freqMap? // 檢查字串是否已被記錄  \n   Yes → freqMap[s] ← freqMap[s] + 1 // 已存在，次數加一  \n   No  → freqMap[s] ← 1 // 新字串，次數設為 1  \n→ Step 3: 設定 maxLen ← -1 // 代表目前尚未找到不重複的字串  \n→ Step 4: 對每個字串 s in strs 執行  \n  → Decision: freqMap[s] 等於 1? // 判斷字串是否唯一  \n   Yes → Decision: s 的長度 > maxLen? // 若是唯一，檢查是否為目前最長  \n    Yes → maxLen ← len(s) // 更新最大長度  \n    No  → // 目前長度不夠，保持原值  \n   No  → // 字串不是唯一，忽略  \n→ Step 5: Decision: maxLen 等於 -1? // 檢查是否有任何唯一字串  \n  Yes → Return -1 // 沒有不重複的字串，無法形成不常見子序列  \n  No  → Return maxLen // 回傳找到的最大長度  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef find_repeated_dna_sequences(s: str):\n    \"\"\"Return all 10‑letter DNA substrings that appear more than once.\"\"\"\n    if len(s) < 10:\n        return []\n\n    seen = set()\n    repeated = set()\n    for i in range(len(s) - 9):\n        seq = s[i:i+10]\n        if seq in seen:\n            repeated.add(seq)\n        else:\n            seen.add(seq)\n    return list(repeated)\n\ndef parse_input(raw: str) -> str:\n    \"\"\"Extract the DNA string enclosed in quotes from the input.\"\"\"\n    match = re.search(r\"['\\\"](.*?)['\\\"]\", raw)\n    return match.group(1) if match else \"\"\n\ndef main():\n    raw_input = sys.stdin.read()\n    dna_sequence = parse_input(raw_input)\n    result = find_repeated_dna_sequences(dna_sequence)\n\n    # Output in the format [\"seq1\",\"seq2\",...]\n    output = \"[\" + \",\".join(f'\"{seq}\"' for seq in result) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm: find all 10-letter substrings that occur >1. Use sliding window and hash map. Steps: input string s. If len <10 return empty. Use dictionary map of substring->count. For i in 0..len-10: sub = s[i:i+10]; increment count; after loop, result = [sub for sub,count in map.items() if count>1]. Return result.\n\nAlso include start, end, decision etc.\n\nFollow format: each line: \"虛擬碼步驟 // 解釋\". Use arrow '→', Decision etc.\n\nMake sure each step is separate line. Use Chinese explanation.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: s // 取得 DNA 序列字串  \n→ Decision: 如果 len(s) < 10? // 檢查是否足夠長以產生 10 位子序列  \n Yes → Output: [] // 若不足 10，直接回傳空清單  \n No → Decision: 初始化 map = {} // 建立子序列對應計數的雜湊表  \n  No → For i from 0 to len(s) - 10: // 逐個滑動 10 位窗口  \n    sub = s[i : i+10] // 取出當前 10 位子序列  \n    If sub in map?  \n     Yes → map[sub] = map[sub] + 1 // 若已存在，計數加一  \n     No  → map[sub] = 1 // 新子序列，初始化計數為 1  \n    End If  \n   End For  \n  No → Decision: 選取重複子序列? // 檢查哪些子序列計數 > 1  \n   Yes → result = [] // 建立結果清單  \n    For sub, count in map.items():  \n     If count > 1?  \n      Yes → result.append(sub) // 加入重複子序列  \n      No → // 不加入  \n    End For  \n   End If  \n   End For  \n  No → Output: result // 回傳所有重複的 10 位子序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Return all possible permutations of the distinct integer list `nums`.\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])  # store a copy of the current permutation\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # swap to generate new permutation\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # backtrack: restore original order\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the list after the '=' sign\n    if \"=\" in data:\n        _, expr = data.split(\"=\", 1)\n    else:\n        expr = data\n    # Convert the string representation of the list to an actual list\n    nums = ast.literal_eval(expr.strip())\n\n    # Compute permutations\n    solution = Solution()\n    result = solution.permute(nums)\n\n    # Print the result in JSON format (no spaces after commas)\n    print(json.dumps(result, separators=(\",\", \":\")))",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for generating all permutations of an array of distinct integers, using the required format: each line has virtual code step then space then // explanation. Use arrow symbols, Start, End, Decision: etc. Provide step-by-step algorithm. Use recursion/backtracking. Ensure no actual code, just virtual steps.\n\nWe need to show iterative or recursive approach. Provide steps: Start, input array, initialize result list, call backtrack with empty path and used flags. In backtrack: if path length equals nums length, add copy to result. Else iterate over indices, if not used, mark used, add to path, recurse, unmark, pop. Then after recursion, output result. End.\n\nSo produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 nums // 取得整數陣列\n→ Step 2: 初始化 result 為空集合 // 存儲所有排列\n→ Step 3: 初始化 path 為空序列 // 當前排列路徑\n→ Step 4: 初始化 used 為與 nums 長度相同的布林陣列，全部 False // 標記元素是否已加入 path\n→ Step 5: 定義遞迴函數 backtrack // 生成排列的核心\n    → Decision: 路徑長度等於 nums 長度? // 判斷是否已完成一個排列\n        Yes → Step 6: 將 path 的複製加入 result // 存入完整排列\n        No  → Step 7: 循環遍歷 nums 的索引 i\n            → Decision: used[i] 為 False? // 檢查元素是否已使用\n                Yes → Step 8: 設置 used[i] = True // 標記已使用\n                → Step 9: 將 nums[i] 加入 path // 添加到當前排列\n                → Step 10: 調用 backtrack() // 進一步擴展\n                → Step 11: 從 path 移除最後一個元素 // 回溯\n                → Step 12: 設置 used[i] = False // 取消標記\n    // 以上為 backtrack 的完整遞迴流程\n→ Step 13: 調用 backtrack() // 開始遞迴\n→ Step 14: 返回 result // 結果包含所有排列\nEnd // 程式執行結束\n\nWe need to ensure each line ends with space then // explanation. Use virtual arrow characters appropriately.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入陣列 nums // 取得整數陣列  \n→ Step 2: 初始化 result 為空集合 // 存儲所有排列  \n→ Step 3: 初始化 path 為空序列 // 當前排列路徑  \n→ Step 4: 初始化 used 為與 nums 長度相同的布林陣列，全部 False // 標記元素是否已加入 path  \n→ Step 5: 定義遞迴函數 backtrack // 生成排列的核心  \n  → Decision: 路徑長度等於 nums 長度? // 判斷是否已完成一個排列  \n    Yes → Step 6: 將 path 的複製加入 result // 存入完整排列  \n    No  → Step 7: 循環遍歷 nums 的索引 i  \n      → Decision: used[i] 為 False? // 檢查元素是否已使用  \n        Yes → Step 8: 設置 used[i] = True // 標記已使用  \n         → Step 9: 將 nums[i] 加入 path // 添加到當前排列  \n         → Step 10: 調用 backtrack() // 進一步擴展  \n         → Step 11: 從 path 移除最後一個元素 // 回溯  \n         → Step 12: 設置 used[i] = False // 取消標記  \n        No → (do nothing) // 跳過已使用的元素  \n→ Step 13: 調用 backtrack() // 開始遞迴  \n→ Step 14: 返回 result // 結果包含所有排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Rotate Array",
      "source_file": "Leetcode/leetcode189.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "expected_output": "[5,6,7,1,2,3,4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpn0ia10rx.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpn0ia10rx.py\", line 48, in main\n    nums, k = parse_input(raw)\n              ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpn0ia10rx.py\", line 37, in parse_input\n    nums = ast.literal_eval(value.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,-100,3,99], k = 2",
          "expected_output": "[3,99,-1,-100]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy27_8knr.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpy27_8knr.py\", line 48, in main\n    nums, k = parse_input(raw)\n              ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpy27_8knr.py\", line 37, in parse_input\n    nums = ast.literal_eval(value.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [-1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def rotate(self, nums, k):\n        \"\"\"\n        將陣列 nums 右移 k 步\n        使用「先反轉整個陣列，再分段反轉」的 O(n) 方法。\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return nums\n        k %= n\n        if k == 0:\n            return nums\n\n        # 先反轉整個陣列\n        nums[:] = nums[::-1]\n        # 反轉前 k 個元素\n        nums[:k] = nums[:k][::-1]\n        # 反轉剩餘 n-k 個元素\n        nums[k:] = nums[k:][::-1]\n        return nums\n\ndef parse_input(input_str):\n    \"\"\"\n    解析輸入字串，取得 nums 與 k。\n    支援類似 'nums = [1,2,3], k = 2' 或 'nums=[1,2,3],k=2' 的格式。\n    \"\"\"\n    nums = []\n    k = 0\n    # 用逗號分段，再逐段找關鍵字\n    for part in input_str.split(','):\n        part = part.strip()\n        if part.startswith('nums'):\n            _, value = part.split('=', 1)\n            nums = ast.literal_eval(value.strip())\n        elif part.startswith('k'):\n            _, value = part.split('=', 1)\n            k = int(value.strip())\n    return nums, k\n\ndef main():\n    # 讀取整個標準輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    nums, k = parse_input(raw)\n    sol = Solution()\n    rotated = sol.rotate(nums, k)\n    # 輸出為 Python list 的字串表示\n    print(rotated)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, with explanation after each line. The user wants to rotate array to right by k steps. Provide algorithm steps. We need to use arrow, Decision etc.\n\nWe must not output actual code, only structured steps. So produce a pseudo code. Steps: start, input array, input k, normalize k = k % len, reverse whole array, reverse first k, reverse rest. Use decisions for empty array or length zero? Provide decision for k == 0 or array empty. Use arrows and decisions. Provide each line with explanation. Ensure each line: \"虛擬碼步驟 // 解釋\". Use Start and End. Use arrow →.\n\nLet's craft. We'll use lines:\n\nStart // program begins\n→ Step 1: 取得輸入陣列 nums 和整數 k // get input array and shift count\n→ Decision: nums 為空 或 k == 0? // check if no work needed\n    Yes → Step 2: 輸出 nums // return original array\n    No → Step 3: 計算 len = length of nums // get array length\n    → Step 4: k = k mod len // normalize shift\n    → Decision: k == 0? // if shift 0 after normalization\n        Yes → Step 5: 輸出 nums // no change\n        No → Step 6: 反轉整個陣列 // reverse whole array\n        → Step 7: 反轉前 k 個元素 // reverse first k elements\n        → Step 8: 反轉後 k 個元素 // reverse remaining elements\n        → Step 9: 輸出 nums // output rotated array\nEnd // end program\n\nBut we need to format each line with arrow etc. We should use arrow for each step. For decisions, include Yes→ and No→. Let's produce.\n\nAlso we can maybe use \"Decision:\" line separate. Format: \"Decision: 如果 ...?\" and then indent Yes→ and No→ lines. Ensure each line ends with // explanation.\n\nWe need to produce each line separately.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums 與整數 k // 從使用者處取得陣列和移動步數  \n→ Decision: nums 為空 或 k == 0? // 檢查是否需要任何操作  \n  Yes → Step 2: 輸出 nums // 若陣列為空或不需移動，直接返回  \n  No  → Step 3: 計算 len = nums 的長度 // 取得陣列長度  \n  → Step 4: k = k mod len // 將移動步數限制在 0~len-1 範圍內  \n  → Decision: k == 0? // 重新檢查 k 是否為 0  \n    Yes → Step 5: 輸出 nums // 若 k 為 0，陣列不變  \n    No  → Step 6: 反轉整個陣列 // 先將整個陣列反轉  \n    → Step 7: 反轉前 k 個元素 // 再反轉前 k 個元素  \n    → Step 8: 反轉後 k 個元素 // 最後反轉剩餘的元素  \n    → Step 9: 輸出 nums // 輸出旋轉後的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpj79brvx3.py\", line 79, in <module>\n    main()\n  File \"/tmp/tmpj79brvx3.py\", line 59, in main\n    ops, args = parse_input(raw_input)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpj79brvx3.py\", line 49, in parse_input\n    ops = ast.literal_eval(ops_part)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport random\nimport collections\nimport ast\nimport json\n\nclass RandomizedCollection:\n    def __init__(self):\n        # values list stores all elements for O(1) random access\n        self.values = []\n        # mapping from value to a set of indices where it occurs\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"Insert val into the collection. Return True if this is the first occurrence.\"\"\"\n        self.values.append(val)\n        self.idx_map[val].add(len(self.values) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"Remove one occurrence of val. Return True if removed, False if not present.\"\"\"\n        if not self.idx_map[val]:\n            return False\n        # remove an arbitrary index of val\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.values[-1]\n        last_idx = len(self.values) - 1\n        # move last element to the spot of the removed element\n        self.values[remove_idx] = last_val\n        # update index mapping for the moved element\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n        # shrink the list\n        self.values.pop()\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"Return a random element, weighted by frequency.\"\"\"\n        return random.choice(self.values)\n\ndef parse_input(data: str):\n    \"\"\"Parse the two lists of operations and arguments from input.\"\"\"\n    data = data.strip()\n    if not data:\n        return [], []\n    # Handle the case where the two lists are separated by '], [' on one line\n    if '], [' in data:\n        ops_part, args_part = data.split('], [', 1)\n        ops = ast.literal_eval(ops_part)\n        args = ast.literal_eval('[' + args_part)\n    else:\n        lines = data.splitlines()\n        ops = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip())\n    return ops, args\n\ndef main():\n    raw_input = sys.stdin.read()\n    ops, args = parse_input(raw_input)\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == 'RandomizedCollection':\n            obj = RandomizedCollection()\n            res.append(None)\n        elif op == 'insert':\n            # arg can be [value] or just value\n            val = arg[0] if isinstance(arg, (list, tuple)) else arg\n            res.append(obj.insert(val))\n        elif op == 'remove':\n            val = arg[0] if isinstance(arg, (list, tuple)) else arg\n            res.append(obj.remove(val))\n        elif op == 'getRandom':\n            res.append(obj.getRandom())\n    # Convert None to null in JSON output\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanations. Need to describe implementation of RandomizedCollection with insert, remove, getRandom in O(1). Use vector for values and hashmap of value to set of indices. Steps: initialization, insert, remove, getRandom. We'll produce stepwise algorithm.\n\nWe must output per line: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision, arrows.\n\nWe need to structure code: Start, then function definitions. For each function, we break into steps.\n\nOk. Let's craft.\n\nWill show steps:\n\nStart\n→ Define class RandomizedCollection // 定義類別\n→ Constructor RandomizedCollection() // 建構子初始化\n    → vector<int> values // 儲存所有元素\n    → unordered_map<int, set<int>> idxMap // 每個值對應的索引集合\n→ Method insert(int val) // 插入操作\n    → Append val to values // 把 val 加到 vector\n    → index = values.size() - 1 // 取得新索引\n    → idxMap[val].insert(index) // 將索引加入映射\n    → If idxMap[val].size() == 1 // 判斷 val 是否第一次出現\n        Yes → Return true // 新元素，回傳 true\n        No  → Return false // 重複元素，回傳 false\n→ Method remove(int val) // 刪除操作\n    → If idxMap[val] is empty // 若不存在該值\n        Yes → Return false // 無法刪除，回傳 false\n        No  → Continue\n    → Remove an index from idxMap[val] // 取得並移除任意索引\n        (use iterator begin)\n    → idx = removed index\n    → lastVal = values.back() // 取得最後一個元素\n    → lastIdx = values.size() - 1\n    → values[idx] = lastVal // 把最後一個元素移到被刪除位置\n    → Update idxMap[lastVal]: remove lastIdx, insert idx\n    → values.pop_back() // 刪除最後一個元素\n    → If idxMap[val] becomes empty\n        Yes → erase idxMap[val] // 可選，清理空集合\n    → Return true // 刪除成功\n→ Method getRandom() // 隨機取值\n    → randIdx = random integer [0, values.size()-1] // 隨機索引\n    → Return values[randIdx] // 回傳對應元素\nEnd\n\nBut need to format each line with arrow. Use → for steps. Use Decision: lines for if conditions. Use Yes → etc.\n\nWe should produce each line as a separate line. Also we need to show Start/End. For methods, we can show function header as Step. Let's craft.\n\nAlso we need to include comments after //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 RandomizedCollection // 宣告資料結構  \n→ Step 2: 初始化成員變數  \n    → Step 2.1: vector<int> values // 儲存所有元素以便快速隨機存取  \n    → Step 2.2: unordered_map<int, set<int>> idxMap // 每個值對應的所有索引集合  \n→ Function: RandomizedCollection() // 建構子  \n    → Step 3: // 空實作，成員已在宣告時初始化  \n→ Function: bool insert(int val) // 插入元素  \n    → Step 4: Append val 到 values // 把新值加入尾端  \n    → Step 5: index = values.size() - 1 // 計算新元素索引  \n    → Step 6: idxMap[val].insert(index) // 將索引加入對應集合  \n    → Decision: idxMap[val] 大小等於 1? // 判斷是否首次插入  \n        Yes → Step 7: Return true // 新元素，回傳 true  \n        No  → Step 8: Return false // 重複元素，回傳 false  \n→ Function: bool remove(int val) // 刪除元素  \n    → Decision: idxMap[val] 為空? // 判斷元素是否存在  \n        Yes → Step 9: Return false // 無法刪除，回傳 false  \n        No  → Step 10: // 取得並移除任意索引  \n            → iterator it = idxMap[val].begin() // 取集合第一個索引  \n            → idx = *it // 被刪除位置索引  \n            → idxMap[val].erase(it) // 從集合移除該索引  \n    → Step 11: lastVal = values.back() // 取最後一個元素  \n    → Step 12: lastIdx = values.size() - 1 // 最後一個元素索引  \n    → Step 13: values[idx] = lastVal // 把最後一個元素移到被刪位置  \n    → Step 14: idxMap[lastVal].erase(lastIdx) // 移除舊索引  \n    → Step 15: idxMap[lastVal].insert(idx) // 插入新索引  \n    → Step 16: values.pop_back() // 刪除最後一個元素  \n    → Decision: idxMap[val] 為空? // 檢查是否需要清除集合  \n        Yes → Step 17: idxMap.erase(val) // 可選，釋放空集合  \n    → Step 18: Return true // 刪除成功  \n→ Function: int getRandom() // 隨機取得元素  \n    → Step 19: randIdx = random integer [0, values.size()-1] // 產生隨機索引  \n    → Step 20: Return values[randIdx] // 回傳對應元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Merge k Sorted Lists",
      "source_file": "Leetcode/leetcode23.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
          "expected_output": "[1,1,2,3,4,4,5,6]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgjmjoi1w.py\", line 96, in <module>\n    main()\n  File \"/tmp/tmpgjmjoi1w.py\", line 91, in main\n    merged_head = sol.mergeKLists(lists)\n                  ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgjmjoi1w.py\", line 25, in mergeKLists\n    heapq.heappush(heap, (node.val, node))\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists):\n        \"\"\"\n        Merge k sorted linked lists into one sorted linked list.\n        Uses a min-heap to always pick the smallest current node.\n        \"\"\"\n        # 若 lists 為空，直接回傳 None\n        if not lists:\n            return None\n\n        # 建立最小堆，元素為 (node.val, node)\n        heap = []\n        for node in lists:\n            if node:\n                heapq.heappush(heap, (node.val, node))\n\n        dummy = ListNode(0)  # 方便操作的哨兵節點\n        tail = dummy\n\n        while heap:\n            val, node = heapq.heappop(heap)   # 取出最小節點\n            tail.next = node                  # 加到結果鏈表\n            tail = node                       # 移動尾指針\n\n            if node.next:                     # 若後繼節點存在，加入堆\n                heapq.heappush(heap, (node.next.val, node.next))\n\n        return dummy.next\n\ndef build_linked_list(arr):\n    \"\"\"從數值列表建立單向鏈表，返回頭節點。\"\"\"\n    dummy = ListNode()\n    tail = dummy\n    for num in arr:\n        tail.next = ListNode(num)\n        tail = tail.next\n    return dummy.next\n\ndef linked_list_to_list(head):\n    \"\"\"將單向鏈表轉回數值列表。\"\"\"\n    res = []\n    cur = head\n    while cur:\n        res.append(cur.val)\n        cur = cur.next\n    return res\n\ndef parse_input(content):\n    \"\"\"\n    從輸入字串解析出 lists = [[...], [...], ...] 的結構。\n    支援直接傳入列表表示或包含前置文字 'lists = ' 的情況。\n    \"\"\"\n    content = content.strip()\n    if not content:\n        return []\n    # 找到第一個 '['，截取子字串後用 literal_eval\n    idx = content.find('[')\n    if idx != -1:\n        sub = content[idx:]\n    else:\n        sub = content\n    try:\n        data = ast.literal_eval(sub)\n    except Exception:\n        data = []\n    return data\n\ndef main():\n    input_text = sys.stdin.read()\n    data = parse_input(input_text)\n\n    # 建立每條鏈表\n    lists = [build_linked_list(arr) for arr in data if arr]  # 空子列表會產生 None\n\n    # 若所有子列表都空，直接輸出 []\n    if not lists:\n        print([])\n        return\n\n    sol = Solution()\n    merged_head = sol.mergeKLists(lists)\n    result = linked_list_to_list(merged_head)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for merging k sorted linked lists into one sorted list. Should outline using priority queue or divide and conquer. Let's produce straightforward algorithm: use min-heap to repeatedly pick smallest head. Or pairwise merge.\n\nWe'll produce virtual steps: Start, push heads onto min-heap, loop until heap empty, pop min, append to result, push next node from popped list. End.\n\nUse virtual code: Start, initialize result head & tail, initialize min-heap with pairs (value, node). Then loop: Decision: if heap empty? No → pop min, add node to result, push next. Continue. End.\n\nWe need each line with explanation. Use indentation for decisions. Provide arrow → for next steps. Use Decision: lines. Provide No and Yes branches. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空結果鏈表 head ← null, tail ← null // 設定合併後鏈表的頭尾指針  \n→ Step 2: 建立最小堆 heap // 用於快速取得 k 條鏈表中最小的節點  \n→ Decision: 將每條鏈表的頭節點插入堆? // 如果該鏈表非空  \n  Yes → Step 3: 把 (node.val, node) 插入 heap // 將節點值與節點本身加入堆  \n  No  → Step 3: 跳過此鏈表 // 空鏈表不進入堆  \n→ Decision: 堆是否為空? // 判斷是否還有節點可合併  \n  Yes → End // 堆空，合併完成，結束程式  \n  No  → Step 4: 從 heap 中彈出最小節點 (val, node) // 取得目前最小值節點  \n→ Step 5: 若 head 為 null? // 判斷是否為結果鏈表的第一個節點  \n  Yes → head ← node, tail ← node // 第一個節點成為頭尾  \n  No  → Step 6: tail.next ← node, tail ← node // 把節點加到尾部並更新尾指針  \n→ Step 7: 若 node.next 存在? // 判斷彈出的節點是否有後繼  \n  Yes → Step 8: 把 (node.next.val, node.next) 插入 heap // 將後繼節點加入堆  \n  No  → Step 8: 跳過 // 沒有後繼節點不需要加入堆  \n→ Step 9: 回到 Decision: 堆是否為空? // 重複流程直到堆空  \nEnd // 程式執行結束，返回 head 作為合併後的升序鏈表"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7zaxivg4.py\", line 51, in <module>\n    ops = json.loads(ops_str)\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 75 (char 74)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\nimport re\n\nclass MedianFinder:\n    def __init__(self):\n        # 小根堆（最大堆）存放較小的一半數字，使用負值來模擬最大堆\n        self.small = []  # max-heap (invert values)\n        # 大根堆（最小堆）存放較大的一半數字\n        self.large = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        # 先把新數字插入小根堆（最大堆）\n        heapq.heappush(self.small, -num)\n\n        # 保持兩堆之間的值有序：small 最大值不應該大於 large 最小值\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 調整堆大小差距，兩堆大小差不超過 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        # 如果小根堆大，則中位數是小根堆的最大值\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        # 否則兩堆大小相等，中位數是兩個頂部平均值\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並拆分成兩個 JSON 列表\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 使用正則表達式拆分兩個列表\n    match = re.match(r'\\s*(\\[.*\\])\\s*,\\s*(\\[.*\\])\\s*', data, flags=re.S)\n    if not match:\n        raise ValueError(\"輸入格式不正確\")\n    ops_str, args_str = match.group(1), match.group(2)\n\n    # 解析 JSON 列表\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    results = []\n    mf = None\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            mf = MedianFinder()\n            results.append(None)\n        elif op == \"addNum\":\n            mf.addNum(arg[0])\n            results.append(None)\n        elif op == \"findMedian\":\n            results.append(mf.findMedian())\n        else:\n            # 若遇到未知指令，可忽略或拋出錯誤\n            results.append(None)\n\n    # 輸出結果，Python 的 None 會轉為 JSON 的 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for MedianFinder using heaps. Provide line by line. Each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's design: Start, initialize two heaps: maxHeap for lower half, minHeap for upper half. AddNum: if maxHeap empty or num <= maxHeap.top then push to maxHeap else to minHeap. Balance heaps: if size difference >1 then move top from one to other. findMedian: if sizes equal, return average of tops; else return top of larger heap. End.\n\nWe need to output as steps. Use Decision nodes. Provide arrow lines. Let's produce.\n\nRemember to include \"Start\", \"End\".\n\nWe'll use \"Decision:\" lines. We'll use \"→\" for steps. Ensure each line ends with comment.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 建立空最大堆 maxHeap // 存放較小一半數字\n→ Step 2: 建立空最小堆 minHeap // 存放較大一半數字\n→ Step 3: 定義 addNum(num) 方法 // 用於插入新數字\n    → Decision: maxHeap 是否為空? // 判斷是否還沒加入任何數字\n        Yes → Step 4: 將 num 插入 maxHeap // 第一次數字放入最大堆\n        No  → Decision: num <= maxHeap.top? // 判斷 num 是否屬於較小一半\n            Yes → Step 5: 將 num 插入 maxHeap // 插入較小堆\n            No  → Step 6: 將 num 插入 minHeap // 插入較大堆\n    → Step 7: 平衡堆大小 // 保持兩堆大小差不超過 1\n        → Decision: maxHeap.size > minHeap.size + 1? // 最大堆過大\n            Yes → Step 8: 從 maxHeap pop top 並 push 到 minHeap // 平衡\n            No  → Decision: minHeap.size > maxHeap.size + 1? // 最小堆過大\n                Yes → Step 9: 從 minHeap pop top 並 push 到 maxHeap // 平衡\n                No → // 兩堆已平衡，無需操作\n→ Step 10: 定義 findMedian() 方法 // 計算目前的中位數\n    → Decision: maxHeap.size == minHeap.size? // 兩堆大小相等\n        Yes → Step 11: median = (maxHeap.top + minHeap.top) / 2.0 // 平均兩中位數\n        No  → Decision: maxHeap.size > minHeap.size? // 最大堆較大\n            Yes → Step 12: median = maxHeap.top // 最大堆頂即為中位數\n            No  → Step 13: median = minHeap.top // 最小堆頂即為中位數\n    → Step 14: return median // 回傳中位數\nEnd // 程式結束\n\nWe also need to mention initialization of class? But Start is fine. Maybe Step 0? But fine.\n\nMake sure each line ends with comment.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空最大堆 maxHeap // 存放較小一半數字  \n→ Step 2: 建立空最小堆 minHeap // 存放較大一半數字  \n→ Step 3: 定義 addNum(num) 方法 // 用於插入新數字  \n → Decision: maxHeap 是否為空? // 判斷是否還沒加入任何數字  \n  Yes → Step 4: 將 num 插入 maxHeap // 第一次數字放入最大堆  \n  No → Decision: num <= maxHeap.top? // 判斷 num 是否屬於較小一半  \n   Yes → Step 5: 將 num 插入 maxHeap // 插入較小堆  \n   No → Step 6: 將 num 插入 minHeap // 插入較大堆  \n → Step 7: 平衡堆大小 // 保持兩堆大小差不超過 1  \n  → Decision: maxHeap.size > minHeap.size + 1? // 最大堆過大  \n   Yes → Step 8: 從 maxHeap pop top 並 push 到 minHeap // 平衡  \n   No → Decision: minHeap.size > maxHeap.size + 1? // 最小堆過大  \n    Yes → Step 9: 從 minHeap pop top 並 push 到 maxHeap // 平衡  \n    No → // 兩堆已平衡，無需操作  \n→ Step 10: 定義 findMedian() 方法 // 計算目前的中位數  \n → Decision: maxHeap.size == minHeap.size? // 兩堆大小相等  \n  Yes → Step 11: median = (maxHeap.top + minHeap.top) / 2.0 // 平均兩中位數  \n  No → Decision: maxHeap.size > minHeap.size? // 最大堆較大  \n   Yes → Step 12: median = maxHeap.top // 最大堆頂即為中位數  \n   No → Step 13: median = minHeap.top // 最小堆頂即為中位數  \n → Step 14: return median // 回傳中位數  \nEnd // 程式結束"
    },
    {
      "title": "Intersection of Two Arrays II",
      "source_file": "Leetcode/leetcode350.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[4,9]'\nGot (Norm):      '[9,4]'\n--- (Raw) ---\nRaw Expected: '[4,9]'\nRaw Got:      '[9, 4]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\ndef intersect(nums1, nums2):\n    \"\"\"Return the intersection of two integer lists, counting duplicates.\"\"\"\n    freq = {}\n    for num in nums1:\n        freq[num] = freq.get(num, 0) + 1\n\n    result = []\n    for num in nums2:\n        if freq.get(num, 0) > 0:\n            result.append(num)\n            freq[num] -= 1\n    return result\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中擷取兩個列表\n    list_strings = re.findall(r'\\[.*?\\]', data)\n    if len(list_strings) >= 2:\n        nums1 = ast.literal_eval(list_strings[0])\n        nums2 = ast.literal_eval(list_strings[1])\n    else:\n        nums1, nums2 = [], []\n\n    # 計算交集\n    result = intersect(nums1, nums2)\n\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for intersection of two arrays with duplicates counted. We must follow output format: each line: \"虛擬碼步驟 // 解釋\". Use arrows →, Decision: etc. So we need to output step-by-step algorithm.\n\nWe should use simple algorithm: use hash map to count frequency of nums1, then iterate nums2, decrement counts, add to result.\n\nLet's produce:\n\nStart\n→ Step 1: 建立空字典 freq // 儲存 nums1 各數字出現次數\n→ Step 2: 對 nums1 之每個 num 做: freq[num] = freq.get(num,0)+1 // 記錄頻率\n→ Step 3: 建立空陣列 result // 儲存交集結果\n→ Step 4: 對 nums2 之每個 num 做: \n    → Decision: 若 freq[num] > 0? // 是否在 nums1 中存在且尚未完全配對\n        Yes → Step 5: result.add(num) // 加入結果\n        Yes → Step 6: freq[num] = freq[num] - 1 // 減少剩餘次數\n        No  → Decision: 如果不在字典中? // 無需處理\n→ End\n\nNeed to use arrow formatting correctly.\n\nMake sure each line uses `→` only at beginning or after indentation. For decisions, indent lines.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 freq // 用於記錄 nums1 中每個數字的出現次數\n→ Step 2: 對 nums1 迭代，對每個 num 執行 freq[num] = freq.get(num,0) + 1 // 更新頻率\n→ Step 3: 建立空陣列 result // 用於儲存交集\n→ Step 4: 對 nums2 迭代，對每個 num 執行\n    → Decision: 若 freq.get(num,0) > 0? // 判斷 nums1 中是否還有此數字\n        Yes → Step 5: result.add(num) // 將數字加入結果\n        Yes → Step 6: freq[num] = freq[num] - 1 // 減少剩餘計數\n        No  → // 不做任何事，因為不存在或已用盡\nEnd // 程式執行結束\n\nNeed to ensure indentation: the decision block lines should be indented under Step 4. Use proper arrow lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 freq // 用於記錄 nums1 中每個數字的出現次數\n→ Step 2: 對 nums1 迭代，對每個 num 執行 freq[num] = freq.get(num,0) + 1 // 更新頻率\n→ Step 3: 建立空陣列 result // 用於儲存交集\n→ Step 4: 對 nums2 迭代，對每個 num 執行\n    → Decision: 若 freq.get(num,0) > 0? // 判斷 nums1 中是否還有此數字\n        Yes → Step 5: result.add(num) // 將數字加入結果\n        Yes → Step 6: freq[num] = freq[num] - 1 // 減少剩餘計數\n        No  → // 不做任何事，因為不存在或已用盡\nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []  # list of [start, end], non-overlapping and sorted\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:  # overlap\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        l, r = self.ranges[i - 1]\n        return l <= left and right <= r\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\n\ndef parse_line(line: str):\n    \"\"\"Return (method, left, right) or (method, None, None)\"\"\"\n    if '(' not in line or ')' not in line:\n        return None, None, None\n    start = line.find('(') + 1\n    end = line.find(')')\n    nums = line[start:end].split(',')\n    left = int(nums[0].strip())\n    right = int(nums[1].strip())\n    return line.split('(')[0].strip(), left, right\n\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    module = None\n    results = []\n\n    for line in data:\n        line = line.strip()\n        if not line:\n            continue\n        if 'RangeModule' in line:\n            module = RangeModule()\n            results.append(None)\n        elif line.startswith('rangeModule.addRange'):\n            _, left, right = parse_line(line)\n            module.addRange(left, right)\n            results.append(None)\n        elif line.startswith('rangeModule.removeRange'):\n            _, left, right = parse_line(line)\n            module.removeRange(left, right)\n            results.append(None)\n        elif line.startswith('rangeModule.queryRange'):\n            _, left, right = parse_line(line)\n            res = module.queryRange(left, right)\n            results.append(res)\n        # ignore any other lines\n\n    # Output in JSON format to match expected \"null\", \"true\", \"false\"\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing a RangeModule data structure with add, query, remove. Use virtual steps, explanation each line. Should be a design: likely using a sorted list of intervals. Provide steps for initialization, addRange, queryRange, removeRange. Must use virtual code syntax as described: Start, End, Decision. Provide line by line with \"→\" arrow.\n\nWe should produce something like:\n\nStart\n→ Step 1: 初始化一個空的區間列表 // etc.\n\nBut we need to include all methods. Each method could be separate block maybe. Provide virtual steps for each method. Use Decision nodes for checking overlap, etc.\n\nLet's craft.\n\nWill produce:\n\nStart\n→ Step 1: 定義 RangeModule 類 // ...\n→ Step 2: 建立空列表 intervals // ...\n→ End\n\nThen AddRange method:\n\nStart\n→ Step 1: 定義 addRange(left, right) // ...\n→ Step 2: 設定 i = 0 // ...\n→ Decision: intervals[i] 與 [left, right) 是否有交集? // ...\n... Use while loop to merge overlapping intervals.\n\nBut we cannot produce actual loops? Virtual code can use iteration concept maybe \"→ While i < intervals.size() and intervals[i].right < left: i++\" but that's a loop, not arrow maybe we can use Step with loop indicator. The specification does not restrict loops but uses arrows.\n\nWe'll include pseudo loops: \"→ While condition: ...\" is okay.\n\nWe also need queryRange: check if all intervals cover [left, right). Use binary search maybe, but virtual can just iterate.\n\nRemoveRange: similar merging.\n\nOk produce step-by-step.\n\nLet's create a high-level description:\n\n- Data structure: list of intervals sorted by start, non-overlapping.\n\n- Methods:\n\nAddRange: find position to insert, merge overlaps.\n\nQueryRange: find first interval with start <= left, check covers right.\n\nRemoveRange: split intervals around [left, right).\n\nWe can produce steps.\n\nMake sure to include comment after each line.\n\nLet's draft.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 RangeModule 類 // 建立範圍模組的基礎結構\n→ Step 2: 建立一個空的區間列表 intervals，類型為 List<Interval>，每個 Interval 包含 start, end // 用於儲存已追蹤的非重疊區間\n→ End // 初始設定完成\n\n//----------------------------------------------\n// 方法: addRange(left, right)\n//----------------------------------------------\nStart // addRange 方法開始\n→ Step 1: 設定 i = 0 // 用於遍歷 intervals\n→ Decision: i < intervals.size() 且 intervals[i].end < left? // 判斷目前區間是否完全在新增區間左側\n    Yes → Step 2: i++ // 移至下一個區間\n    No  → Decision: i < intervals.size() 且 intervals[i].start > right? // 判斷目前區間是否完全在新增區間右側\n        Yes → Step 3: 插入 Interval(left, right) 到位置 i // 沒有重疊，直接插入\n        No  → Decision: intervals[i].start <= right && intervals[i].end >= left? // 判斷是否有重疊\n            Yes → Step 4: left = min(left, intervals[i].start) // 更新新增區間左端為最左\n                   → Step 5: right = max(right, intervals[i].end) // 更新新增區間右端為最右\n                   → Step 6: 移除 intervals[i] // 移除已重疊的區間\n                   → Step 7: i-- // 回到上一個位置以便繼續合併\n            No  → Step 8: i++ // 當前區間不與新增區間重疊，往後移動\n→ Step 9: 迴圈結束後，插入合併後的 Interval(left, right) 到位置 i // 將最終合併結果加入列表\n→ End // addRange 方法結束\n\n//----------------------------------------------\n// 方法: queryRange(left, right)\n//----------------------------------------------\nStart // queryRange 方法開始\n→ Step 1: 找到第一個 intervals[i] 使得 intervals[i].start <= left 且 intervals[i].end > left // 確認 left 位置是否在已追蹤區間內\n→ Decision: i == intervals.size() 或 intervals[i].start > left? // 無此區間\n    Yes → Step 2: 返回 false // left 未被追蹤，直接返回\n    No  → Step 3: 如果 intervals[i].end < right? // 区间結束小於 right\n        Yes → Step 4: 返回 false // 未完全覆蓋\n        No  → Step 5: 返回 true // 完全覆蓋\n→ End // queryRange 方法結束\n\n//----------------------------------------------\n// 方法: removeRange(left, right)\n//----------------------------------------------\nStart // removeRange 方法開始\n→ Step 1: 設定 i = 0 // 遍歷 intervals\n→ Decision: i < intervals.size() 且 intervals[i].end <= left? // 當前區間在要刪除區間左側\n    Yes → Step 2: i++ // 跳過此區間\n    No  → Decision: i < intervals.size() 且 intervals[i].start >= right? // 當前區間在要刪除區間右側\n        Yes → Step 3: 退出迴圈 // 後續區間不受影響\n        No  → Decision: intervals[i].start < left 且 intervals[i].end > right? // 需要拆分\n            Yes → Step 4: 右半區間 = Interval(right, intervals[i].end) // 保留右側未刪除區間\n                   → Step 5: intervals[i].end = left // 將左側保留區間結束於 left\n                   → Step 6: 插入右半區間到位置 i+1\n                   → Step 7: 退出迴圈 // 完成拆分\n            No → Decision: intervals[i].start < left? // 左側部分被保留\n                Yes → Step 8: intervals[i].end = left // 截斷左側\n                    → Step 9: i++ // 移至下一個區間\n                No → Decision: intervals[i].end > right? // 右側部分被保留\n                    Yes → Step 10: intervals[i].start = right // 截斷右側\n                        → Step 11: i++ // 移至下一個區間\n                    No → Step 12: 移除 intervals[i] // 完全被刪除\n                        → Step 13: i-- // 回到上一個位置以便重新檢查\n→ End // removeRange 方法結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,true,true,false,2,true,true,true,4]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, true, true, true, false, 2, true, true, true, 4]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyCircularDeque:\n    \"\"\"循環雙端佇列實作\"\"\"\n\n    def __init__(self, k: int):\n        self.k = k                    # 最大容量\n        self.buf = [0] * k            # 儲存區\n        self.head = 0                 # 前端指標\n        self.count = 0                # 目前佇列長度\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    methods = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n\n    obj = None\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"MyCircularDeque\":\n            obj = MyCircularDeque(args[0])\n            results.append(None)          # constructor returns null\n        elif method == \"insertFront\":\n            results.append(obj.insertFront(args[0]))\n        elif method == \"insertLast\":\n            results.append(obj.insertLast(args[0]))\n        elif method == \"deleteFront\":\n            results.append(obj.deleteFront())\n        elif method == \"deleteLast\":\n            results.append(obj.deleteLast())\n        elif method == \"getFront\":\n            results.append(obj.getFront())\n        elif method == \"getRear\":\n            results.append(obj.getRear())\n        elif method == \"isEmpty\":\n            results.append(obj.isEmpty())\n        elif method == \"isFull\":\n            results.append(obj.isFull())\n        else:\n            # 未知方法，忽略\n            results.append(None)\n\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, with explanations. Not actual code. We need to design a circular deque. Use start, decision, etc. We'll produce a structured algorithm. We'll cover initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Probably using array of size k, front, rear indices. Provide step-by-step pseudo. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Let's produce sequential pseudocode. We'll start with Start, then define class, constructor, methods. For each method, describe steps. We'll produce as per format. Let's do it.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCircularDeque 類別 // 建立循環雙端佇列的結構  \n→ Step 2: 初始化變數: capacity, data[], front, rear // capacity 為最大大小，data 為儲存空間，front 與 rear 為指標  \n\n// ---------- 建構子 ----------\n→ Step 3: MyCircularDeque(int k) // 建構子  \n→ Decision: k 是否為正數? // 檢查輸入參數合法性  \n  Yes → Step 4: capacity ← k  \n    → Step 5: data ← 新陣列(capacity)  \n    → Step 6: front ← 0  \n    → Step 7: rear ← 0  \n  No  → Step 8: 抛出錯誤或設置預設值  \n\n// ---------- insertFront ----------\n→ Step 9: insertFront()  \n→ Decision: isFull()? // 檢查是否已滿  \n  Yes → Step 10: 返回 false // 無法插入  \n  No  → Step 11: front ← (front - 1 + capacity) mod capacity // 向前移動指標  \n    → Step 12: data[front] ← new_value // 將值放入 front  \n    → Step 13: 返回 true  \n\n// ---------- insertLast ----------\n→ Step 14: insertLast()  \n→ Decision: isFull()?  \n  Yes → Step 15: 返回 false  \n  No  → Step 16: data[rear] ← new_value // 放入 rear  \n    → Step 17: rear ← (rear + 1) mod capacity // 向後移動指標  \n    → Step 18: 返回 true  \n\n// ---------- deleteFront ----------\n→ Step 19: deleteFront()  \n→ Decision: isEmpty()? // 檢查是否為空  \n  Yes → Step 20: 返回 false // 無法刪除  \n  No  → Step 21: front ← (front + 1) mod capacity // 向後移動指標  \n    → Step 22: 返回 true  \n\n// ---------- deleteLast ----------\n→ Step 23: deleteLast()  \n→ Decision: isEmpty()?  \n  Yes → Step 24: 返回 false  \n  No  → Step 25: rear ← (rear - 1 + capacity) mod capacity // 向前移動指標  \n    → Step 26: 返回 true  \n\n// ---------- getFront ----------\n→ Step 27: getFront()  \n→ Decision: isEmpty()?  \n  Yes → Step 28: 返回 -1 // 佇列為空  \n  No  → Step 29: 返回 data[front] // 回傳前端值  \n\n// ---------- getRear ----------\n→ Step 30: getRear()  \n→ Decision: isEmpty()?  \n  Yes → Step 31: 返回 -1  \n  No  → Step 32: idx ← (rear - 1 + capacity) mod capacity // 取得最後一個元素索引  \n    → Step 33: 返回 data[idx]  \n\n// ---------- isEmpty ----------\n→ Step 34: isEmpty()  \n→ Decision: front == rear? // 前後指標相同表示空  \n  Yes → Step 35: 返回 true  \n  No  → Step 36: 返回 false  \n\n// ---------- isFull ----------\n→ Step 37: isFull()  \n→ Decision: (rear + 1) mod capacity == front? // 若 rear 前一個位置即為 front 表示已滿  \n  Yes → Step 38: 返回 true  \n  No  → Step 39: 返回 false  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Distinct Subsequences",
      "source_file": "Leetcode/leetcode115.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"rabbbit\", t = \"rabbit\"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "s = \"babgbag\", t = \"bag\"",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef num_distinct(s: str, t: str) -> int:\n    \"\"\"Count distinct subsequences of s that equal t using 1‑D DP.\"\"\"\n    m, n = len(s), len(t)\n    # dp[j] = number of ways to match first j chars of t in processed prefix of s\n    dp = [0] * (n + 1)\n    dp[0] = 1  # empty t matches any prefix once\n\n    for ch in s:\n        # iterate backwards to avoid overwriting dp[j-1] needed for current j\n        for j in range(n, 0, -1):\n            if ch == t[j - 1]:\n                dp[j] += dp[j - 1]\n    return dp[n]\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input that may be in two formats:\n    1) Two separate lines, each containing the string value.\n    2) A single line like: s = 'rabbbit', t = 'rabbit'.\n    \"\"\"\n    # Try regex extraction for format 2\n    s_match = re.search(r\"s\\s*=\\s*'([^']*)'\", data)\n    t_match = re.search(r\"t\\s*=\\s*'([^']*)'\", data)\n    if s_match and t_match:\n        return s_match.group(1), t_match.group(1)\n\n    # Fallback: split by lines, strip whitespace\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    # If only one line but contains two words, split by space\n    if len(lines) == 1:\n        parts = lines[0].split()\n        if len(parts) == 2:\n            return parts[0], parts[1]\n    # Default empty strings if parsing fails\n    return \"\", \"\"\n\ndef main():\n    data = sys.stdin.read()\n    s, t = parse_input(data)\n    result = num_distinct(s, t)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for problem: count distinct subsequences of s equal to t. Classic DP: dp[i][j] = number of ways to match t[0..j-1] in s[0..i-1]. Use 1D DP j loop backwards. Output virtual code lines with explanation.\n\nWe should provide line by line virtual code using arrows. Use Start, End. Provide steps: input strings, initialize dp array size len(t)+1 with zeros, dp[0]=1. For each char in s iterate over t backwards: if s[i]==t[j-1] dp[j] += dp[j-1]. After loops, answer dp[len(t)].\n\nWe must not output real code, just virtual steps. Let's produce. Use arrow \"→\" and decisions if needed? Might not need decisions. But we can include condition check in loop. Provide loops as steps.\n\nWe'll produce something like:\n\nStart\n→ Step 1: 讀取字串 s, t //取得輸入\n→ Step 2: 令 n = 長度(s), m = 長度(t) //計算長度\n→ Step 3: 建立一維陣列 dp 長度 m+1，全部設為 0 //準備 DP\n→ Step 4: 設定 dp[0] = 1 //空子序列與空字串匹配\n→ Step 5: Decision: 迴圈 i 從 1 到 n //遍歷 s\n    Yes → Step 6: 內層迴圈 j 從 m 到 1 逆序 //為避免覆蓋前一步結果\n        Yes → Step 7: Decision: 如果 s[i-1] == t[j-1]?\n            Yes → Step 8: dp[j] = dp[j] + dp[j-1] //更新計數\n            No  → Step 9: //不做任何改動\n→ Step 10: 回傳 dp[m] //結果\nEnd\n\nAlso need explanation after each line. We'll format accordingly.\n\nWe must keep each line as \"虛擬碼步驟 // 解釋\". Use arrows. Ensure each step ends with // explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 s, t // 取得輸入字串  \n→ Step 2: 令 n = 長度(s), m = 長度(t) // 計算兩字串長度  \n→ Step 3: 建立一維陣列 dp 長度 m+1，全部設為 0 // 初始化 DP 陣列  \n→ Step 4: 設定 dp[0] = 1 // 空子序列與空字串匹配的方式為 1  \n→ Step 5: Decision: 迴圈 i 從 1 到 n // 遍歷 s 的每個字元  \n    Yes → Step 6: 內層迴圈 j 從 m 到 1 逆序 // 逆序遍歷 t 以避免覆蓋前一步結果  \n        Yes → Step 7: Decision: 如果 s[i-1] == t[j-1]？ // 判斷兩字元是否相同  \n            Yes → Step 8: dp[j] = dp[j] + dp[j-1] // 若相同，累加前一步 dp[j-1]  \n            No  → Step 9: // 不做任何改動，保持原值  \n→ Step 10: 回傳 dp[m] // dp[m] 為 s 中等於 t 的子序列數量  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        content_map = defaultdict(list)\n        for path in paths:\n            parts = path.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content[:-1]  # 去掉末尾的 ')'\n                content_map[content].append(f\"{root}/{name}\")\n        return [files for files in content_map.values() if len(files) > 1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析形如 \"paths = [...]\" 的輸入\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    try:\n        paths = ast.literal_eval(expr)\n    except Exception:\n        paths = eval(expr)\n    sol = Solution()\n    result = sol.findDuplicate(paths)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps to solve the problem: given list of directory info strings, parse them, map file content to list of paths, then filter groups of size>=2, output.\n\nWe should output step-by-step with comments.\n\nLet's structure:\n\nStart\n→ Step 1: Initialize map contentMap: map<string, list<string>> // map content to file paths\n→ Decision: if paths list empty? maybe just return empty list? We'll not complicate.\n\nFor each dirInfo in paths:\n  Parse dirInfo into parts split by space: first part is dirPath, rest are fileInfo.\n  For each fileInfo:\n    Extract fileName and content inside parentheses.\n    Build fullPath = dirPath + \"/\" + fileName\n    Append fullPath to contentMap[content]\n\nAfter processing all:\n  Initialize result list\n  For each entry in contentMap:\n    If entry.second size >=2:\n      Append entry.second to result\n\nEnd return result\n\nWe need each line with arrow or Start/End.\n\nWe'll use `→` and indent decisions.\n\nWe should include arrow at each step. We'll show loops and decisions.\n\nLet's write lines:\n\nStart // 程式開始執行\n→ Step 1: 建立字典 contentMap 以內容作為鍵，對應檔案路徑列表 // 初始化內容到路徑的映射\n→ Decision: 是否有輸入清單 paths? // 若無，直接返回空結果\n    No  → Step 2: 回傳空列表 // 早期返回\n    Yes → For each dirInfo 在 paths 中 // 逐個處理每個目錄資訊\n        → Step 3: 用空格分割 dirInfo 成 parts // 取得目錄路徑與檔案資訊\n        → Step 4: dirPath = parts[0] // 第一項為目錄路徑\n        → For每個 filePart 在 parts[1..] // 逐個檔案資訊\n            → Step 5: 找到括號位置 '(' 與 ')' // 拿到內容起始與結束\n            → Step 6: fileName = substring before '(' // 取得檔名\n            → Step 7: content = substring inside '(' and ')' // 取得檔案內容\n            → Step 8: fullPath = dirPath + \"/\" + fileName // 組合完整路徑\n            → Step 9: contentMap[content].append(fullPath) // 加入映射\n    → Step 10: result = 空列表 // 初始化結果\n    → For每個 entry 在 contentMap 中 // 遍歷內容對應的路徑列表\n        → Decision: entry.value.size >= 2? // 是否至少兩個相同內容\n            Yes → result.append(entry.value) // 加入重複檔案組\n    → Step 11: 回傳 result // 結束\nEnd // 程式執行結束\n\nBut we need to use proper indentation with arrow lines. Also use `Decision:` for if/else.\n\nLet's structure properly:\n\nStart // 程式開始執行\n→ Step 1: contentMap ← 空字典 // 以內容映射到檔案路徑\n→ Decision: paths 為空? // 檢查輸入\n    Yes → Step 2: return [] // 無輸入，直接返回空結果\n    No  → For dirInfo in paths // 逐個處理\n        → Step 3: parts ← split dirInfo by space // 取得目錄與檔案\n        → Step 4: dirPath ← parts[0] // 目錄路徑\n        → For filePart in parts[1:] // 逐檔案\n            → Step 5: openIdx ← index of '(' in filePart // 括號起始\n            → Step 6: closeIdx ← index of ')' in filePart // 括號結束\n            → Step 7: fileName ← substring filePart[0:openIdx] // 檔名\n            → Step 8: content ← substring filePart[openIdx+1:closeIdx] // 內容\n            → Step 9: fullPath ← dirPath + \"/\" + fileName // 完整路徑\n            → Step 10: contentMap[content].append(fullPath) // 加入映射\n→ Step 11: result ← 空列表 // 儲存重複檔案群\n→ For entry in contentMap // 遍歷內容\n    → Decision: entry.value.size ≥ 2? // 至少兩個相同內容\n        Yes → result.append(entry.value) // 加入結果\n→ Step 12: return result // 輸出\nEnd // 程式結束\n\nThis meets requirements. Ensure each line has `虛擬碼步驟` + ` // 解釋`. Use arrow.\n\nWe need to keep each line unique. Let's write exactly.\n\nWe can keep indentation by using spaces.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: contentMap ← 空字典 // 以檔案內容映射到檔案路徑列表  \n→ Decision: paths 為空? // 檢查是否有輸入  \n  Yes → Step 2: return [] // 沒有輸入直接回傳空列表  \n  No  → For dirInfo in paths // 逐個處理每個目錄資訊  \n    → Step 3: parts ← split dirInfo by 空格 // 取得目錄路徑與檔案資訊  \n    → Step 4: dirPath ← parts[0] // 第一項為目錄路徑  \n    → For filePart in parts[1:] // 逐個檔案資訊  \n      → Step 5: openIdx ← index of '(' in filePart // 找到左括號位置  \n      → Step 6: closeIdx ← index of ')' in filePart // 找到右括號位置  \n      → Step 7: fileName ← substring filePart[0:openIdx] // 取得檔名  \n      → Step 8: content ← substring filePart[openIdx+1:closeIdx] // 取得檔案內容  \n      → Step 9: fullPath ← dirPath + \"/\" + fileName // 組合完整路徑  \n      → Step 10: contentMap[content].append(fullPath) // 將路徑加入對應內容的列表  \n→ Step 11: result ← 空列表 // 用於儲存重複檔案群  \n→ For entry in contentMap // 遍歷所有內容對應的路徑列表  \n    → Decision: entry.value.size ≥ 2? // 是否至少有兩個相同內容的檔案  \n      Yes → result.append(entry.value) // 加入重複檔案組  \n→ Step 12: return result // 回傳所有重複檔案路徑群  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[8]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[8]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[3,8]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[3, 8]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[10,7,4]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[10, 7, 4]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport re\n\n# 假設有一個 API rand7()，這裡用 random 來模擬\ndef rand7():\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        while True:\n            # 兩次 rand7 產生 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\ndef main():\n    # 從 stdin 讀取輸入，示例格式為 'n = 3'\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 抓取第一個整數作為 n\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    sol = Solution()\n    result = [sol.rand10() for _ in range(n)]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines explaining algorithm to generate uniform 1-10 using rand7. Classic solution: use two rand7 to create 49 outcomes; discard 40-49? Wait we want 1-10. Use 7*7=49; we can map 1-40 to 1-10 (each 4). Then discard 41-49. Or use rejection sampling: generate number in 1-49, if <=40, map to 1-10 via ((x-1)%10)+1. Repeat until valid.\n\nSo virtual code: Start, Step: repeat loop, inside generate rand7 twice, compute value = (a-1)*7 + b (1-49). Decision: if <=40 then output mapping else loop again.\n\nLet's produce virtual code lines.\n\nWe also need to follow arrow syntax: \"→ Step: ...\" Provide comment after //.\n\nNeed to include Decision lines with Yes → and No → branches.\n\nStructure:\n\nStart\n→ Step: repeat indefinitely // start loop\n    → Step: a ← rand7() // first random\n    → Step: b ← rand7() // second random\n    → Step: val ← (a-1)*7 + b // combine to 1-49\n    → Decision: 如果 val <= 40? // check if in usable range\n        Yes → Step: output ((val-1)%10)+1 // map to 1-10\n        No  → Step: repeat // discard and repeat loop\nEnd\n\nWe need to handle the loop: maybe use a label \"Loop:\" or \"Repeat:\"; but the example shows \"Step 1\" etc.\n\nCould use \"Loop:\" as a step, then \"→ Step\" etc. But we need to maintain flow. Provide \"→ Step: 循環開始\" etc.\n\nBetter to use \"→ Loop\" label.\n\nWe can represent loop as:\n\n→ Step: Repeat // 迴圈開始\n    ...\n    → Decision: ...\n        Yes → ...\n        No  → Step: 跳回 Repeat // 重複\n\nAlternatively, we can use \"→ Step: while True:\" but keep abstract.\n\nWe need to ensure each line has virtual code and comment. Use \"→ Decision: ...\"\n\nWe can produce:\n\nStart // 程式開始執行\n→ Step: repeat // 重複直至得到合法數值\n    → Step: a ← rand7() // 產生第一個亂數\n    → Step: b ← rand7() // 產生第二個亂數\n    → Step: val ← (a-1)*7 + b // 組合為 1-49\n    → Decision: 如果 val <= 40? // 判斷是否落在可用範圍\n        Yes → Step: result ← ((val-1) % 10) + 1 // 將 1-40 映射到 1-10\n        No  → Step: repeat // 失敗，重複迴圈\nEnd // 程式執行結束\n\nBut \"repeat\" is ambiguous. We need to show arrow to loop back. Could do:\n\n→ Decision: ... No → Step: 重新進入 repeat // but that's same.\n\nMaybe better:\n\n→ Step: start_loop // 開始迴圈\n    ...\n    → Decision: ... No → Step: start_loop // 重新回到迴圈起點\n\nLet's produce that.\n\nAlso need to indicate that output function returns result.\n\nWe might include \"→ Step: return result\" inside Yes branch.\n\nBetter: Yes branch includes returning the result and exit loop.\n\nLet's design:\n\nStart\n→ Step: loop_start // 迴圈起點\n    → Step: a ← rand7()\n    → Step: b ← rand7()\n    → Step: val ← (a-1)*7 + b\n    → Decision: 如果 val <= 40?\n        Yes → Step: result ← ((val-1) % 10) + 1\n        Yes → Step: return result // 產生 rand10\n        No  → Step: loop_start // 失敗，重新迴圈\nEnd\n\nBut we need to maintain \"Yes\" and \"No\" branches separately. In example, they had nested decisions. We can use nested structure: Yes branch contains two steps: mapping and return. No branch returns to loop_start.\n\nLet's produce lines accordingly.\n\nEnsure each line ends with // explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: loop_start // 進入迴圈以嘗試產生合法數值  \n → Step: a ← rand7() // 取得第一個 1~7 的亂數  \n → Step: b ← rand7() // 取得第二個 1~7 的亂數  \n → Step: val ← (a-1)*7 + b // 將兩個亂數結合得到 1~49  \n → Decision: 如果 val <= 40? // 檢查是否在可映射範圍內  \n  Yes → Step: result ← ((val-1) % 10) + 1 // 把 1~40 映射到 1~10  \n  Yes → Step: return result // 產生 rand10() 的結果並結束  \n  No  → Step: loop_start // val 超過 40，重新進入迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Search Insert Position",
      "source_file": "Leetcode/leetcode35.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprc4vgp7j.py\", line 43, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmprc4vgp7j.py\", line 31, in parse_input\n    target_str = target_part.split('=')[1]\n                 ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuczgz4mt.py\", line 43, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpuczgz4mt.py\", line 31, in parse_input\n    target_str = target_part.split('=')[1]\n                 ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpijryx7im.py\", line 43, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpijryx7im.py\", line 31, in parse_input\n    target_str = target_part.split('=')[1]\n                 ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef search_insert(nums, target):\n    \"\"\"\n    使用二分搜尋找出 target 在有序且唯一的整數陣列中的插入位置。\n    若 target 已存在於陣列，則回傳其索引；若不存在，回傳應插入的索引。\n    時間複雜度 O(log n)。\n    \"\"\"\n    left, right = 0, len(nums)\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef parse_input(raw):\n    \"\"\"\n    解析形如 'nums = [1,3,5,6], target = 5' 的字串。\n    先把兩個參數切開，再用 ast.literal_eval 解析數列。\n    \"\"\"\n    # 去除空白並確保以逗號分隔\n    parts = raw.replace(' ', '').split(',')\n    nums_part = parts[0]\n    target_part = parts[1]\n\n    # 取得等號右邊的值\n    nums_str = nums_part.split('=')[1]\n    target_str = target_part.split('=')[1]\n\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n    return nums, target\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    nums, target = parse_input(raw_input)\n    index = search_insert(nums, target)\n    print(index)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for binary search insertion position. Must output line by line with virtual code step + comment. Use Start, End, Decision. Provide explanation. Ensure not actual code. We'll write steps: Start, set left=0, right=len-1. Decision: left<=right? Yes -> mid = (left+right)//2. Decision: arr[mid]==target? Yes → output mid. No -> arr[mid] < target? Yes → left=mid+1. No → right=mid-1. Loop back. After loop, output left as insertion index. End.\n\nWe need to use arrows: \"→\" to indent substeps. Use indentation.\n\nMake sure each line includes a single step and comment. Use spaces. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 0, right = n - 1 // 初始化左右指標  \n→ Decision: left <= right? // 判斷是否還有區間可搜尋  \n  Yes → Step 2: mid = (left + right) // 2 // 計算中點索引  \n  Yes → Decision: arr[mid] == target? // 檢查中點是否為目標  \n    Yes → Step 3: 返回 mid // 找到目標，返回其索引  \n    No → Decision: arr[mid] < target? // 中點值是否小於目標  \n     Yes → Step 4: left = mid + 1 // 目標在右半區，更新左指標  \n     No → Step 5: right = mid - 1 // 目標在左半區，更新右指標  \n       → 回到 Decision: left <= right? // 重新判斷是否繼續搜尋  \n    No → Step 6: 循環結束，左指標即為插入位置  \n→ Step 7: 返回 left // 回傳插入索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpi17nud9v.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpi17nud9v.py\", line 35, in main\n    data = ast.literal_eval('{' + raw + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]}\n     ^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp08j4j9v.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpp08j4j9v.py\", line 35, in main\n    data = ast.literal_eval('{' + raw + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]}\n     ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # Cost if buying everything at regular price\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef main():\n    # Read the whole input\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # Convert the input into a dictionary\n    # Example input: 'price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]'\n    data = ast.literal_eval('{' + raw + '}')\n    price = data['price']\n    special = data['special']\n    needs = data['needs']\n\n    sol = Solution()\n    result = sol.shoppingOffers(price, special, needs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for LeetCode \"Shopping Offers\" problem. Provide step-by-step pseudo code. Not actual code, just structured steps. Use virtual code with arrows, decision etc. Provide each line with explanation. Must follow output format: each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision. Provide steps: define memoization map, DFS function to compute min cost, prune offers that exceed needs, try all offers including not using any offers, compute cost, use recursion.\n\nWe should include base case: all needs zero => cost 0. At each recursion, compute minimal price: price of buying remaining items at normal price vs each applicable offer. Use recursion with updated needs.\n\nNeed to show loop over offers, check if applicable, subtract counts, compute cost.\n\nWe also need to incorporate special offers can be used multiple times. Should we consider repeated offers in recursion? Yes.\n\nMemoization key: tuple of needs.\n\nReturn minimal price.\n\nAlso we need to mention sorting offers? Not necessary.\n\nLet's write lines.\n\nWe can do pseudo code:\n\nStart\n→ Define memo dictionary // cache computed results\n→ Define function DFS(current_needs) // compute min cost for needs\n    → Key ← tuple(current_needs) // create key\n    → Decision: If key in memo? // already computed\n        Yes → Return memo[key] // reuse\n        No → Proceed\n    → Compute normal_cost = sum(current_needs[i] * price[i]) // buy all at regular price\n    → min_cost ← normal_cost // initialize\n    → Loop over each offer in special:\n        → Decision: If offer can be applied to current_needs? // all counts <= need\n            Yes → new_needs ← current_needs - offer_counts\n            → offer_cost ← offer_price + DFS(new_needs) // recursive\n            → Decision: If offer_cost < min_cost?\n                Yes → min_cost ← offer_cost // update\n                No → continue\n        No → continue\n    → memo[key] ← min_cost // store\n    → Return min_cost\n→ Call DFS(needs) // start with desired needs\n→ End\n\nWe need each line with // explanation.\n\nNeed to use arrows, decisions.\n\nMake sure each line has \"虛擬碼步驟\" part and comment.\n\nWe must use format: \"Start // 程式開始執行\" etc.\n\nLet's produce lines accordingly.\n\nAlso need to mention \"→\" for each step; for loops maybe use \"→ Loop over offer\" etc. For decisions, indent maybe with spaces.\n\nBut formatting: The example shows indent using spaces before \"Yes →\". We should maintain similar style.\n\nThus:\n\nStart // 程式開始執行\n→ Define memo as empty map // 用於記錄已計算的需求對應最小價格\n→ Define function DFS(need) // 針對給定需求計算最小價格\n    → Key ← tuple(need) // 將需求列表轉為不可變鍵\n    → Decision: Key exists in memo? // 檢查是否已計算\n        Yes → Return memo[Key] // 回傳緩存結果\n        No → Continue\n    → normal_cost ← Σ need[i] * price[i] // 全部按單價購買的成本\n    → min_cost ← normal_cost // 初始化最小成本為全單價購買\n    → Loop over each offer in special // 嘗試每個特價方案\n        → Decision: Offer 可應用於 need? // 每項數量 <= 需求\n            Yes →\n                new_need ← need - offer_counts // 用後需求\n                offer_cost ← offer_price + DFS(new_need) // 方案成本 + 其後成本\n                → Decision: offer_cost < min_cost?\n                    Yes → min_cost ← offer_cost // 更新最小成本\n                    No → // 保持 min_cost\n            No → // 方案不可用，跳過\n    → memo[Key] ← min_cost // 存儲結果\n    → Return min_cost\n→ Result ← DFS(needs) // 取得最終最小價格\nEnd // 程式執行結束\n\nNeed to add space indent after decision lines.\n\nBut each line must be separate line with \"虛擬碼步驟\" part and comment. The lines for decisions might be considered separate lines: \"Decision: ...\". So each line is separate.\n\nHence, format:\n\nStart // ...\n→ Define memo ...\n→ Define function DFS(need) ...\n    → Key ← ...\n    → Decision: Key exists in memo? ...\n        Yes → Return memo[Key] ...\n        No → // continue\n\nBut \"No → // continue\" is line.\n\nWe must maintain consistent indentation. Use spaces to show nested steps.\n\nOk.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define memo as empty map // 用於記錄已計算的需求對應最小價格  \n→ Define function DFS(need) // 針對給定需求計算最小價格  \n    → Key ← tuple(need) // 將需求列表轉為不可變鍵  \n    → Decision: Key exists in memo? // 檢查是否已計算  \n        Yes → Return memo[Key] // 回傳緩存結果  \n        No → // 需要進行計算  \n    → normal_cost ← Σ need[i] * price[i] // 全部按單價購買的成本  \n    → min_cost ← normal_cost // 初始化最小成本為全單價購買  \n    → Loop over each offer in special // 嘗試每個特價方案  \n        → Decision: Offer 可應用於 need? // 每項數量 <= 需求  \n            Yes →  \n                new_need ← need - offer_counts // 用後需求  \n                offer_cost ← offer_price + DFS(new_need) // 方案成本 + 其後成本  \n                → Decision: offer_cost < min_cost?  \n                    Yes → min_cost ← offer_cost // 更新最小成本  \n                    No → // 保持 min_cost  \n            No → // 方案不可用，跳過  \n    → memo[Key] ← min_cost // 存儲結果  \n    → Return min_cost  \n→ Result ← DFS(needs) // 取得最終最小價格  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Linked List",
      "source_file": "Leetcode/leetcode707.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n[[], [1], [3], [1, 2], [1], [1], [1]]",
          "expected_output": "[null, null, null, null, 2, null, 3]",
          "actual_output_or_error": "File \"/tmp/tmpvfatxgzc.py\", line 82\n    output.append rédaction(None)\n                  ^^^^^^^^^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyLinkedList:\n    class Node:\n        def __init__(self, val=0):\n            self.val = val\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.size = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n        curr = self.head\n        for _ in range(index):\n            curr = curr.next\n        return curr.val\n\n    def addAtHead(self, val: int) -> None:\n        node = self.Node(val)\n        node.next = self.head\n        self.head = node\n        self.size += 1\n\n    def addAtTail(self, val: int) -> None:\n        node = self.Node(val)\n        if not self.head:\n            self.head = node\n        else:\n            curr = self.head\n            while curr.next:\n                curr = curr.next\n            curr.next = node\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0 or index > self.size:\n            return\n        if index == 0:\n            self.addAtHead(val)\n            return\n        node = self.Node(val)\n        curr = self.head\n        for _ in range(index - 1):\n            curr = curr.next\n        node.next = curr.next\n        curr.next = node\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n        if index == 0:\n            self.head = self.head.next\n        else:\n            curr = self.head\n            for _ in range(index - 1):\n                curr = curr.next\n            curr.next = curr.next.next\n        self.size -= 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    lines = data.splitlines()\n    ops = json.loads(lines[0])\n    args = json.loads(lines[1]) if len(lines) > 1 else []\n\n    obj = None\n    output = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyLinkedList\":\n            obj = MyLinkedList()\n            output.append(None)\n        elif op == \"addAtHead\":\n            obj.addAtHead(arg[0])\n            output.append rédaction(None)\n        elif op == \"addAtTail\":\n            obj.addAtTail(arg[0])\n            output.append(None)\n        elif op == \"addAtIndex\":\n            obj.addAtIndex(arg[0], arg[1])\n            output.append(None)\n        elif op == \"deleteAtIndex\":\n            obj.deleteAtIndex(arg[0])\n            output.append(None)\n        elif op == \"get\":\n            output.append(obj.get(arg[0]))\n        else:\n            output.append(None)\n\n    print(json.dumps(output))",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for implementation of MyLinkedList. Use singly linked list. Provide steps with Start, End, Decision etc. Provide explanation after each line. We need to cover methods: constructor, get, addAtHead, addAtTail, addAtIndex, deleteAtIndex. Each method needs algorithm steps. We need to output each line as virtual code. We'll include internal operations like node creation, pointer updates, length variable. Use Decision for index validity checks. Also include loops for traversing to index.\n\nLet's outline high-level structure:\n\n- Define Node structure with val, next.\n- MyLinkedList class: head pointer, tail pointer, size variable.\n\nConstructor: set head=None, tail=None, size=0.\n\nget(index):\n    if index<0 or index>=size: return -1\n    current=head\n    for i in 0..index-1: current=current.next\n    return current.val\n\naddAtHead(val):\n    newNode=Node(val)\n    newNode.next=head\n    head=newNode\n    if size==0: tail=newNode\n    size+=1\n\naddAtTail(val):\n    newNode=Node(val)\n    if size==0: head=tail=newNode\n    else: tail.next=newNode; tail=newNode\n    size+=1\n\naddAtIndex(index, val):\n    if index>size: return\n    if index==0: addAtHead(val)\n    else if index==size: addAtTail(val)\n    else:\n        prev=head\n        for i in 1..index-1: prev=prev.next\n        newNode=Node(val)\n        newNode.next=prev.next\n        prev.next=newNode\n        size+=1\n\ndeleteAtIndex(index):\n    if index<0 or index>=size: return\n    if index==0:\n        head=head.next\n        if size==1: tail=None\n    else:\n        prev=head\n        for i in 1..index-1: prev=prev.next\n        prev.next=prev.next.next\n        if index==size-1: tail=prev\n    size-=1\n\nWe will translate to virtual steps.\n\nNeed to use arrow lines.\n\nLet's produce.\n\nWe'll start with Start for whole algorithm? The example uses Start for program, but we are implementing a class. We'll treat \"Start\" as initialization of MyLinkedList class. But maybe just for each method, but we can start with \"Start MyLinkedList\" etc.\n\nLet's produce steps for entire class definition? The user wants virtual code and explanation line by line. We'll produce as a sequence of lines covering all methods. Use indentation via arrow lines? Use arrow for steps.\n\nWe'll structure:\n\nStart // 開始定義 MyLinkedList\n→ Node(val) // 建立節點結構\n    → Step: Node has attributes val, next // node fields\n→ MyLinkedList() // 建構子\n    → Step: 初始化 head, tail 為 null // ...\n    → Step: 初始化 size 為 0\n...\n\nBut we need to maintain arrow lines per step.\n\nLet's generate each method step by step.\n\nWill include decisions.\n\nUse indentation via arrow \"→\" each line.\n\nFor loops, we might express as Decision and loop?\n\nBetter to express traversal loops: we can write \"→ For i in 0 to index-1: current=current.next\" as a step. But the format expects each line to be virtual code step, with arrow. So we can do a step: \"→ Step: current = current.next // 移動到下一節點\" inside loop.\n\nBut to keep simple, we can express loops as a single line \"→ Step: Traverse to index node\" with explanation.\n\nHowever the requirement: \"逐行地產生對應的虛擬碼\" means each line is a virtual step. Loops could be represented as separate lines? We can approximate.\n\nMaybe we can just represent loop as a decision with \"Yes\" path for each iteration? Might be too complex.\n\nSimpler: Represent loop as a single step that implies repeated traversal. That might be acceptable.\n\nBut they want arrow \"Yes →\", \"No →\" etc. For loops we can just use \"→ Loop: Move current to next node until index reached\" but not using arrow. The format might accept. Example didn't show loop explicitly.\n\nWe can include \"→ Loop: Move current = current.next\" but then explanation.\n\nOk.\n\nLet's craft final output accordingly.\n\nMake sure to follow format exactly: Each line: \"虛擬碼步驟 [space] // 解釋/說明\".\n\nLet's produce.\n\n...done thinking.\n\nStart // 開始定義 MyLinkedList\n→ Node(val) // 建立節點結構，具有 val 與 next 兩個屬性\n→ MyLinkedList() // 建構子\n    → Step: head = null // 初始頭節點為空\n    → Step: tail = null // 初始尾節點為空\n    → Step: size = 0 // 初始鏈表長度為 0\n→ get(index) // 取得 index 號節點的值\n    → Decision: 如果 index < 0 或 index >= size? // 檢查索引是否有效\n        Yes → Step: return -1 // 索引無效，回傳 -1\n        No  → Step: current = head // 從頭節點開始\n        No  → Loop: index 次迴圈 current = current.next // 移動到 index 號節點\n        No  → Step: return current.val // 回傳該節點的值\n→ addAtHead(val) // 在頭部新增節點\n    → Step: newNode = Node(val) // 建立新節點\n    → Step: newNode.next = head // 新節點指向舊頭節點\n    → Step: head = newNode // 更新頭節點為新節點\n    → Decision: 如果 size == 0? // 檢查鏈表是否為空\n        Yes → Step: tail = newNode // 若空，尾節點也指向新節點\n        No  → // 無操作\n    → Step: size += 1 // 長度加 1\n→ addAtTail(val) // 在尾部新增節點\n    → Step: newNode = Node(val) // 建立新節點\n    → Decision: 如果 size == 0? // 檢查鏈表是否為空\n        Yes → Step: head = newNode // 空時，頭節點為新節點\n        Yes → Step: tail = newNode // 空時，尾節點也為新節點\n        No  → Step: tail.next = newNode // 尾節點指向新節點\n        No  → Step: tail = newNode // 更新尾節點為新節點\n    → Step: size += 1 // 長度加 1\n→ addAtIndex(index, val) // 在 index 位置前插入節點\n    → Decision: 如果 index > size? // 檢查索引是否超過長度\n        Yes → // 不做任何操作\n        No  → Decision: 如果 index == 0? // 插入到頭部\n            Yes → Step: addAtHead(val) // 直接使用 addAtHead\n            No  → Decision: 如果 index == size? // 插入到尾部\n                Yes → Step: addAtTail(val) // 直接使用 addAtTail\n                No  → Step: prev = head // 找到 index-1 號節點\n                No  → Loop: index-1 次迴圈 prev = prev.next // 從頭遍歷到前一個節點\n                No  → Step: newNode = Node(val) // 建立新節點\n                No  → Step: newNode.next = prev.next // 新節點指向原 index 號節點\n                No  → Step: prev.next = newNode // 前一節點指向新節點\n                No  → Step: size += 1 // 長度加 1\n→ deleteAtIndex(index) // 刪除 index 號節點\n    → Decision: 如果 index < 0 或 index >= size? // 檢查索引是否有效\n        Yes → // 無操作\n        No  → Decision: 如果 index == 0? // 刪除頭節點\n            Yes → Step: head = head.next // 更新頭節點為下一個\n            Yes → Decision: 如果 size == 1? // 只剩一個節點\n                Yes → Step: tail = null // 刪除後尾節點為空\n                No  → // 無操作\n            No  → Step: size -= 1 // 長度減 1\n            No  → // 刪除完成\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  → // 走完此分支\n            No  → // 回到外層\n            No  // 走完 deleteAtIndex 的流程結束\nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                parent.setdefault(email, email)\n                parent.setdefault(first_email, first_email)\n                root_first = find(first_email)\n                root_email = find(email)\n                parent[root_email] = root_first\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        return [[email_to_name[root]] + sorted(emails) for root, emails in merged.items()]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 支持 \"accounts = [...]\" 或直接給列表字面量\n    if '=' in data:\n        _, accounts_part = data.split('=', 1)\n    else:\n        accounts_part = data\n    accounts = ast.literal_eval(accounts_part.strip())\n    result = Solution().accountsMerge(accounts)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line. The problem: merge accounts with common emails. Approach: union-find or graph. We'll produce steps: map email->name, build adjacency graph of emails, DFS to find connected components, sort emails, build result. Let's produce steps with Start, decisions, loops, etc. Provide explanations after each line. Ensure we use virtual code arrow syntax. Provide step numbering? In example, they use \"Step 1:\" etc. We can use \"Step 1:\" etc. Use arrow. Also decisions. We'll produce steps like:\n\nStart\n→ Step 1: 建立 emailToName 映射 // map email to name\n→ Step 2: 建立 graph 邊 list // email adjacency\n→ Step 3: 為每個帳號建立邊\n    → Loop each account in accounts\n        → Step 3.1: name = account[0]\n        → Step 3.2: For i from 1 to len(account)-1\n            → Step 3.2.1: email = account[i]\n            → Step 3.2.2: emailToName[email] = name\n            → Step 3.2.3: For each j>i in same account\n                → Step 3.2.3.1: email2 = account[j]\n                → Step 3.2.3.2: add edge between email and email2\n...\nBut maybe too many nested lines. Use decision: If account has emails >1. Provide loops. Provide DFS. Provide visited set. Then compile result.\n\nLet's produce minimal but clear lines. Use decisions: If email not visited then DFS. Provide DFS as a procedure? We can embed.\n\nWe'll produce:\n\nStart\n→ Step 1: Initialize emailToName map, adjacency list, visited set\n→ Decision: 遍歷每個帳號\n    Yes → Step 2: 將帳號中所有 email 加入映射並連接相鄰 email\n        → Step 3: 取出第一個 email 作為根\n        → Step 4: 執行 DFS 來收集連通分量\n        → Step 5: 將收集到的 email 排序並加入結果\nEnd\n\nBut need more detail: Provide loops. Provide DFS function.\n\nWe'll produce pseudo code lines like:\n\nStart\n→ Step 1: emailToName = {} // map email -> name\n→ Step 2: graph = {} // map email -> list of neighboring emails\n→ Step 3: visited = set() // 已訪問的 email\n→ Decision: 迭代每個帳號 in accounts\n    Yes → Step 4: name = account[0]\n    Yes → Step 5: For i in 1 .. len(account)-1\n        Yes → Step 6: email = account[i]\n        Yes → Step 7: emailToName[email] = name\n        Yes → Step 8: If email not in graph: graph[email] = []\n    Yes → Step 9: For i in 1 .. len(account)-1\n        Yes → Step 10: For j in i+1 .. len(account)-1\n            Yes → Step 11: email1 = account[i]\n            Yes → Step 12: email2 = account[j]\n            Yes → Step 13: graph[email1].append(email2)\n            Yes → Step 14: graph[email2].append(email1)\n→ Decision: 迭代每個 email in graph keys\n    Yes → Step 15: If email not in visited\n        Yes → Step 16: component = [] // 用來收集連通分量\n        Yes → Step 17: Stack = [email] // DFS stack\n        → Decision: Stack not empty\n            Yes → Step 18: cur = Stack.pop()\n            Yes → Step 19: If cur in visited: continue\n            Yes → Step 20: visited.add(cur)\n            Yes → Step 21: component.append(cur)\n            Yes → Step 22: For neighbor in graph[cur]\n                Yes → Step 23: If neighbor not in visited: Stack.append(neighbor)\n        → Decision: 迭代結束\n        Yes → Step 24: component.sort()\n        Yes → Step 25: name = emailToName[component[0]]\n        Yes → Step 26: result.append([name] + component)\n→ End\n\nAdd explanations after each line. We'll ensure arrow lines with // after. Provide indentation for decisions maybe. Use `Decision:`. For loops, maybe use `Loop`? But not required. We'll just show loops as steps.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: emailToName = {} // 建立 email → 名稱 的映射表  \n→ Step 2: graph = {} // 建立 email → 鄰接 email 的鄰接表  \n→ Step 3: visited = set() // 用來標記已探訪的 email  \n\n→ Decision: 迭代每個帳號 in accounts  \n    Yes → Step 4: name = account[0] // 取得帳號擁有者名稱  \n    Yes → Step 5: For i in 1 .. len(account)-1  \n        Yes → Step 6: email = account[i] // 取得帳號中的每一個 email  \n        Yes → Step 7: emailToName[email] = name // 以 email 為鍵存名稱  \n        Yes → Step 8: If email not in graph: graph[email] = [] // 初始化鄰接表項目  \n    Yes → Step 9: For i in 1 .. len(account)-1  \n        Yes → Step 10: For j in i+1 .. len(account)-1  \n            Yes → Step 11: email1 = account[i]  \n            Yes → Step 12: email2 = account[j]  \n            Yes → Step 13: graph[email1].append(email2) // 建立 email1 與 email2 的雙向邊  \n            Yes → Step 14: graph[email2].append(email1)  \n\n→ Decision: 迭代每個 email in graph.keys()  \n    Yes → Step 15: If email not in visited  \n        Yes → Step 16: component = [] // 存放同一連通分量的所有 email  \n        Yes → Step 17: stack = [email] // DFS 堆疊，從這個 email 開始  \n        → Decision: stack not empty  \n            Yes → Step 18: cur = stack.pop() // 取出當前 email  \n            Yes → Step 19: If cur in visited: continue // 已探訪則跳過  \n            Yes → Step 20: visited.add(cur) // 標記為已探訪  \n            Yes → Step 21: component.append(cur) // 加入本分量  \n            Yes → Step 22: For neighbor in graph[cur]  \n                Yes → Step 23: If neighbor not in visited: stack.append(neighbor) // 推入尚未探訪的鄰接 email  \n        → Decision: 迭代結束  \n        Yes → Step 24: component.sort() // 將同一連通分量的 email 排序  \n        Yes → Step 25: name = emailToName[component[0]] // 取分量中任一 email 的名稱  \n        Yes → Step 26: result.append([name] + component) // 組成最終帳號格式並加入結果  \n\nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar I",
      "source_file": "Leetcode/leetcode729.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, true, false, true]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyCalendar:\n    \"\"\"簡易的日曆類別，僅允許不重疊的事件。\"\"\"\n    def __init__(self):\n        self.bookings = []\n\n    def book(self, start, end):\n        \"\"\"若能成功加入事件，回傳 True；否則回傳 False。\"\"\"\n        for s, e in self.bookings:\n            if max(s, start) < min(e, end):   # 兩區間有交集\n                return False\n        self.bookings.append((start, end))\n        return True\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    ops = ast.literal_eval(data[0].strip())\n    args = ast.literal_eval(data[1].strip())\n\n    objects = {}\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyCalendar\":\n            # 建構新物件，key 為索引字串以便後續呼叫\n            obj = MyCalendar()\n            key = f\"obj_{len(objects)}\"\n            objects[key] = obj\n            results.append(None)  # Constructor 對應 null\n        else:  # method call\n            # 假設只有 book 方法，且呼叫時的物件為最新一個\n            obj = objects[f\"obj_{len(objects)-1}\"]\n            if op == \"book\":\n                res = obj.book(*arg)\n                results.append(res)\n\n    # 輸出結果，使用 json.dumps 以得到正確的 true/false/null 格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for this problem. It's about designing a calendar with no double booking. The usual solution: maintain sorted list of intervals; book: binary search or loop to check for overlap. We'll produce a simple approach: store intervals in sorted list by start. For book, iterate to find conflict; if none, insert.\n\nVirtual code steps: Start, instantiate MyCalendar class, list of intervals. For book method: loop over intervals; if overlap, return false. Else insert. Use decision etc.\n\nWe need to output step-by-step with virtual code and explanation per line.\n\nLet's produce:\n\nStart\n→ MyCalendar() // 初始化日曆物件\n→   Intervals = [] // 存放已預訂的事件，按 startTime 排序\nEnd // MyCalendar 初始化完成\n\nThen book method:\n\nStart\n→ book(start, end) // 嘗試新增事件\n→   Decision: Intervals 為空？ // 若無任何已預訂事件\n        Yes → Step: Intervals.add([start, end]) // 直接加入\n        No  → Step: ConflictFound = false // 假設沒有衝突\n→   Loop: for each interval in Intervals // 檢查每個已存在事件\n→       Decision: if interval.end <= start OR interval.start >= end? // 不重疊\n                Yes → Continue // 這個事件不會衝突，檢查下一個\n                No  → Step: ConflictFound = true; Break // 发现冲突\n→   Decision: ConflictFound? // 有衝突？\n        Yes → Step: return false // 不加入，返回失敗\n        No  → Step: Intervals.add([start, end]) // 無衝突，加入事件\n        No  → Step: return true // 成功加入\nEnd\n\nBut we need to format exactly: Each line: virtual code step + space + // explanation.\n\nNeed to use arrow symbols. For loop and decisions we must format accordingly.\n\nLet's create full virtual code.\n\nLet's write the structure:\n\nStart\n→ MyCalendar() // 初始化日曆\n    → Intervals = [] // 空列表存儲已預訂事件\nEnd\n\nThen for book:\n\nStart\n→ book(start, end) // 嘗試新增事件\n    → Decision: Intervals 為空? // 檢查是否已有事件\n        Yes → Intervals.add([start, end]) // 無衝突，直接加入\n        No  → ConflictFound = false // 假設無衝突\n    → Loop: for each interval in Intervals // 檢查所有已存在事件\n        → Decision: interval.end <= start OR interval.start >= end? // 不重疊\n            Yes → Continue // 無衝突，檢查下一個\n            No  → ConflictFound = true; Break // 發現衝突\n    → Decision: ConflictFound? // 是否發現衝突\n        Yes → Return false // 不能加入，返回失敗\n        No  → Intervals.add([start, end]); Return true // 成功加入，返回成功\nEnd\n\nWe also need to include the End line. Add final End.\n\nLet's produce each line with the arrow formatting. Use spaces after arrow. Example: \"→ MyCalendar() // 初始化日曆\".\n\nAlso note that nested indent? Not required but we can indent with spaces.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ MyCalendar() // 初始化日曆物件  \n→   Intervals = [] // 用空列表儲存已預訂的事件，按 startTime 排序  \nEnd // MyCalendar 初始化結束  \n\nStart // book 方法開始執行  \n→ book(start, end) // 嘗試新增一個 [start, end) 事件  \n→   Decision: Intervals 為空？ // 檢查是否已有事件  \n        Yes → Intervals.add([start, end]) // 無衝突，直接加入並結束  \n        No  → ConflictFound = false // 假設目前沒有衝突，進行檢查  \n→   Loop: for each interval in Intervals // 檢查所有已存在的事件  \n        → Decision: interval.end <= start OR interval.start >= end? // 兩事件是否不重疊？  \n            Yes → Continue // 無衝突，繼續檢查下一個  \n            No  → ConflictFound = true; Break // 發現衝突，停止檢查  \n→   Decision: ConflictFound？ // 有衝突嗎？  \n        Yes → Return false // 不能加入，回傳失敗  \n        No  → Intervals.add([start, end]); Return true // 成功加入，回傳成功  \nEnd // book 方法結束"
    },
    {
      "title": "Search in Rotated Sorted Array II",
      "source_file": "Leetcode/leetcode81.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,5,6,0,0,1,2], target = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp93g70sp.py\", line 38, in <module>\n    main()\n  File \"/tmp/tmpp93g70sp.py\", line 31, in main\n    data_dict = ast.literal_eval('{' + data.replace('=', ':') + '}')\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7675780f7790>"
        },
        {
          "example_index": 1,
          "input": "nums = [2,5,6,0,0,1,2], target = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpls80_0q8.py\", line 38, in <module>\n    main()\n  File \"/tmp/tmpls80_0q8.py\", line 31, in main\n    data_dict = ast.literal_eval('{' + data.replace('=', ':') + '}')\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x765f00ffb710>"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[left] == nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Convert the input into a dictionary by replacing '=' with ':' and wrapping with braces\n    data_dict = ast.literal_eval('{' + data.replace('=', ':') + '}')\n    nums = data_dict['nums']\n    target = data_dict['target']\n    result = Solution().search(nums, target)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for searching in rotated sorted array with duplicates. Use modified binary search. Provide each line step with explanation. Let's outline algorithm:\n\nStart\n→ Step 1: Set low=0, high=nums.length-1\n→ Decision: While low <= high? // main loop\n    Yes → Step 2: mid=(low+high)/2\n    → Decision: nums[mid]==target? // found\n        Yes → Return true\n        No → Decision: nums[low]==nums[mid] && nums[mid]==nums[high]? // duplicates handling\n            Yes → low++; high--; // skip duplicates\n            No → Decision: nums[low] <= nums[mid]? // left part sorted\n                Yes → Decision: nums[low] <= target < nums[mid]? // target in left\n                    Yes → high=mid-1\n                    No → low=mid+1\n                No → Decision: target > nums[mid] && target <= nums[high]? // target in right\n                    Yes → low=mid+1\n                    No → high=mid-1\n    End Decision\nEnd while\n→ Step 3: Return false\nEnd\n\nWe need each line with explanation. Use indentation with spaces. For each line.\n\nLet's craft.\n\nWe also might need to include `Start` and `End`. Provide each line with `// 解釋`.\n\nWe must use virtual code arrows and decision syntax as specified. Use `→` for actions. Use `Decision:`.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← 0, high ← nums.length – 1 // 初始化搜尋區間  \n→ Decision: low ≤ high? // 判斷是否仍有未檢查元素  \n  Yes → Step 2: mid ← (low + high) / 2 // 計算中間索引  \n   → Decision: nums[mid] == target? // 檢查中間是否為目標  \n     Yes → Return true // 找到目標，結束搜尋  \n     No → Decision: nums[low] == nums[mid] AND nums[mid] == nums[high]? // 遇到重複值時的特別處理  \n      Yes → low ← low + 1, high ← high – 1 // 把重複邊界縮小，避免無法判斷  \n      No → Decision: nums[low] ≤ nums[mid]? // 左半段是否為升序  \n       Yes → Decision: nums[low] ≤ target < nums[mid]? // 目標在左半段  \n         Yes → high ← mid – 1 // 搜尋左半段  \n         No → low ← mid + 1 // 搜尋右半段  \n       No → Decision: target > nums[mid] AND target ≤ nums[high]? // 目標在右半段  \n         Yes → low ← mid + 1 // 搜尋右半段  \n         No → high ← mid – 1 // 搜尋左半段"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,4,6,0,4,4,0,6]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 4, 6, 0, 4, 4, 0, 6]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        index = random.randint(0, self.size - 1)\n        return self.mapping.get(index, index)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    ops = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1])\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            res.append(None)\n        elif op == \"pick\":\n            res.append(obj.pick())\n        else:\n            res.append(None)  # fallback for unexpected ops\n\n    def fmt(v):\n        return \"null\" if v is None else str(v)\n\n    output = \"[\" + \", \".join(fmt(v) for v in res) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code, line by line with comments, using arrow, Start, End, Decision. The user wants algorithm for weighted random pick avoiding blacklist, minimizing calls to random.\n\nStandard solution: map blacklisted numbers in [0, n-1] to allowed numbers in [0, n-m-1] via mapping. Preprocess: let m = len(blacklist). Create set of blacklist. Create mapping for blacklisted numbers less than n-m to the largest allowed numbers. In constructor: iterate over blacklist, and build mapping for those < n-m. Then pick: get r = random int between 0 and n-m-1. If r in map, return map[r], else return r.\n\nNeed to produce virtual code: step by step. Should include loops, set, map, random call. Use decision, arrows.\n\nWill produce a structure:\n\nStart\n→ Step: n, blacklist input\n→ Step: m = length(blacklist)\n→ Step: white = n - m\n→ Step: create set B from blacklist\n→ Step: create empty map M\n→ Step: pointer = n-1\n→ Decision: for each b in B\n    Yes → Decision: if b < white? // need to map\n        Yes → Step: while pointer in B: pointer--\n        Yes → Step: M[b] = pointer\n        Yes → Step: pointer--\n    No → (skip)\n→ End Constructor\n→ Step: pick() // method\n→ Step: r = random integer between 0 and white-1\n→ Decision: if r in M? // mapping\n    Yes → Step: return M[r]\n    No  → Step: return r\nEnd\n\nWe need to output each line with arrow and explanation.\n\nWe should also include comments for random call minimization: only one call per pick.\n\nLet's format as required: Each line: \"虛擬碼步驟 // 解釋/說明\".\n\nUse arrow '→' for flow. Start and End. Decision with Yes/No.\n\nLet's produce lines accordingly.\n\nAlso note: In constructor we need to loop over blacklist set, but we need to create mapping only for those < white. The pointer starts from n-1 and decreases.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step: 參數 n, blacklist // 初始化輸入\n\n→ Step: m ← length(blacklist) // 黑名單長度\n\n→ Step: white ← n - m // 可用數量\n\n→ Step: B ← set(blacklist) // 建立黑名單集合方便查找\n\n→ Step: M ← empty map // 用於映射被排除的下標\n\n→ Step: ptr ← n - 1 // 從最高值開始尋找可用數\n\n→ Decision: for each b in B // 逐個處理黑名單元素\n    Yes → Decision: if b < white? // 僅需映射小於白名單界限的元素\n        Yes → Step: while ptr ∈ B // 跳過所有黑名單中的高位數\n            Yes → ptr ← ptr - 1\n        Yes → Step: M[b] ← ptr // 將黑名單元素映射到一個合法數\n        Yes → Step: ptr ← ptr - 1 // 移動指標以備下一個映射\n        No → // b ≥ white，已在可用範圍內，無需映射\nEnd // 結構化構造完成\n\n→ Step: pick() // 定義隨機選取方法\n\n→ Step: r ← random integer in [0, white-1] // 一次隨機調用\n\n→ Decision: if r ∈ M? // 判斷是否需要映射\n    Yes → Step: return M[r] // 返回映射後的合法數\n    No  → Step: return r // 直接返回合法數\n\nEnd // 程式結束\n\nBut need to maintain each line with arrow or step etc. Format: \"虛擬碼步驟 // 解釋\".\n\nLet's produce each line accordingly. Ensure no extra explanation.\n\nLet's finalize.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 參數 n, blacklist // 接收總範圍長度與黑名單  \n→ Step: m ← length(blacklist) // 計算黑名單個數  \n→ Step: white ← n - m // 可用數量（[0, white-1] 範圍）  \n→ Step: B ← set(blacklist) // 建立黑名單集合以支援 O(1) 判斷  \n→ Step: M ← empty map // 用於映射被排除的低位索引  \n→ Step: ptr ← n - 1 // 從最高索引開始尋找合法數字  \n→ Decision: for each b in B // 逐個處理黑名單元素  \n  Yes → Decision: if b < white? // 只需映射落在 [0, white-1] 內的元素  \n    Yes → Step: while ptr ∈ B // 跳過所有高位黑名單  \n      Yes → ptr ← ptr - 1  \n    Yes → Step: M[b] ← ptr // 把黑名單元素映射到合法數字  \n    Yes → Step: ptr ← ptr - 1 // 移動指標以備下一次映射  \n    No → // b ≥ white，已在合法範圍內，無需映射  \nEnd // 結構化構造完成  \n\n→ Step: pick() // 定義隨機選取方法  \n→ Step: r ← random integer in [0, white-1] // 只調用一次 random  \n→ Decision: if r ∈ M? // 判斷是否需要映射  \n  Yes → Step: return M[r] // 返回映射後的合法數字  \n  No  → Step: return r // 直接返回合法數字  \n\nEnd // 程式結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.6832185415262062,0.26246587977042957],[-0.4246908947378205,-0.7532802375646641],[-0.7772878417510298,-0.08505368408795717]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.6832185415262062, 0.26246587977042957], [-0.4246908947378205, -0.7532802375646641], [-0.7772878417510298, -0.08505368408795717]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    \"\"\"\n    用於產生圓內均勻隨機點的類別。\n    \"\"\"\n    def __init__(self, radius, x_center, y_center):\n        \"\"\"\n        初始化圓的半徑與中心座標。\n        \"\"\"\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        \"\"\"\n        產生一個在圓內均勻分布的隨機點。\n        透過極座標方式：先隨機產生半徑 r (需平方根調整以保持均勻性)，\n        再隨機產生角度 theta。\n        最後轉換回 Cartesian 座標。\n        \"\"\"\n        # 1. 隨機半徑 r，使用 sqrt 保證面積均勻\n        r = self.radius * math.sqrt(random.random())\n        # 2. 隨機角度 theta\n        theta = random.uniform(0, 2 * math.pi)\n        # 3. 轉換為 Cartesian 座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    \"\"\"\n    讀取標準輸入，模擬 LeetCode 的互動測試。\n    第一行：方法呼叫序列（例如 [\"Solution\", \"randPoint\", \"randPoint\"]）\n    第二行：每個呼叫對應的參數（例如 [[1.0,0.0,0.0], [], []]）\n    輸出：JSON 形式的結果列表（使用 json.dumps 以確保 None 變為 null）\n    \"\"\"\n    # 取得所有非空行\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if not lines:\n        return\n\n    # 解析命令與參數\n    commands = json.loads(lines[0])\n    args_list = json.loads(lines[1]) if len(lines) > 1 else []\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # 建構物件\n            obj = Solution(*args)\n            results.append(None)  # 建構函式回傳值為 null\n        else:\n            # 呼叫對應方法\n            method = getattr(obj, cmd)\n            res = method(*args)\n            results.append(res)\n\n    # 輸出結果，以 JSON 格式保證 null 的正確表示\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps, each line with // explanation, using arrows, decisions. We need to explain implementation of Solution class with constructor and randPoint method. Should show uniform random point generation: sample random radius sqrt(r)*R? Actually uniform in area: choose r = sqrt(random()) * radius; choose theta uniform [0,2π). Then x = centerX + r*cos(theta), y = centerY + r*sin(theta). We'll produce steps.\n\nWe need to output step-by-step pseudocode. Use Start, End, Decision. Use arrows \"→\". Let's produce something like:\n\nStart // program start\n→ Step 1: 定義類別 Solution // 建立類別\n    → Step 2: 定義屬性 radius, centerX, centerY // 儲存圓參數\n→ Decision: 若呼叫建構函式? // 初始化\n    Yes → Step 3: 接收 radius, x_center, y_center // 參數\n        → Step 4: 設定 radius = radius, centerX = x_center, centerY = y_center // 儲存\n→ Step 5: 定義方法 randPoint() // 產生隨機點\n    → Step 6: 產生亂數 u1 in [0,1) // 生成 uniform\n    → Step 7: 產生亂數 u2 in [0,1) // 生成 uniform\n    → Step 8: 計算 r = sqrt(u1) * radius // 對半徑進行平方根調整\n    → Step 9: 計算 theta = 2π * u2 // 隨機角度\n    → Step 10: 計算 x = centerX + r * cos(theta) // 轉換到座標系\n    → Step 11: 計算 y = centerY + r * sin(theta) // 同上\n    → Step 12: 回傳 [x, y] // 結果\nEnd // 程式結束\n\nMake sure each line includes // explanation. Use Start, End. We can optionally include Decision for constructor but not necessary. Keep simple.\n\nAlso might include that randPoint can be called multiple times. Could mention that radius, centerX, centerY stored. Provide explanation lines.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立一個名為 Solution 的類別  \n    → Step 2: 定義屬性 radius, centerX, centerY // 用來儲存圓的半徑與中心座標  \n→ Step 3: 定義建構函式 Solution(radius, x_center, y_center) // 初始化物件時傳入參數  \n    → Step 4: 設定 this.radius = radius // 儲存半徑  \n    → Step 5: 設定 this.centerX = x_center // 儲存中心 x 座標  \n    → Step 6: 設定 this.centerY = y_center // 儲存中心 y 座標  \n→ Step 7: 定義方法 randPoint() // 產生一個均勻分布的隨機點  \n    → Step 8: 產生隨機數 u1 ∈ [0,1) // 第一個均勻亂數  \n    → Step 9: 產生隨機數 u2 ∈ [0,1) // 第二個均勻亂數  \n    → Step 10: 計算 r = sqrt(u1) * this.radius // 透過平方根調整半徑，確保面積均勻  \n    → Step 11: 計算 theta = 2π * u2 // 生成均勻角度  \n    → Step 12: 計算 x = this.centerX + r * cos(theta) // 轉換為 Cartesian 坐標  \n    → Step 13: 計算 y = this.centerY + r * sin(theta) // 同上  \n    → Step 14: 回傳 [x, y] // 返回隨機點的座標陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "First Missing Positive",
      "source_file": "Leetcode/leetcode41.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,0]",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpc9iawcmt.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmpc9iawcmt.py\", line 35, in main\n    nums = eval(data, {}, {})\n           ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    nums = [1,2,0]\n         ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "nums = [3,4,-1,1]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp10ilrx9i.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmp10ilrx9i.py\", line 35, in main\n    nums = eval(data, {}, {})\n           ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    nums = [3,4,-1,1]\n         ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "nums = [7,8,9,11,12]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2f1jdj4u.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmp2f1jdj4u.py\", line 35, in main\n    nums = eval(data, {}, {})\n           ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    nums = [7,8,9,11,12]\n         ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\n\ndef first_missing_positive(nums):\n    \"\"\"\n    找出 nums 中最小的未出現的正整數。\n    這個實作採用原地交換，時間 O(n)，額外空間 O(1)。\n    \"\"\"\n    n = len(nums)\n\n    # 把所有能夠放在對應位置的數字進行交換\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            target = nums[i] - 1\n            nums[i], nums[target] = nums[target], nums[i]\n\n    # 找第一個位置 i 使得 nums[i] != i+1\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n\n    # 所有 1~n 都已經出現，答案是 n+1\n    return n + 1\n\n\ndef main():\n    \"\"\"\n    主程式：從標準輸入讀取一行，假設格式為 Python 可評估的\n    數組表達式（例如 'nums = [1,2,0]'），輸出最小缺失正整數。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 評估輸入，允許表達式如 'nums = [1,2,0]'\n    nums = eval(data, {}, {})\n\n    result = first_missing_positive(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line, with each line having \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Need to follow start, decisions, end. Should produce algorithm for smallest missing positive integer with O(n) time and O(1) extra space. Typical solution: first, segregate positive numbers to front, then use index marking. Or use in-place indexing.\n\nWe need to produce virtual code: Steps: 1. Partition array: move all positives to front. 2. For each element in first part, mark presence by setting arr[abs(val)-1] negative. 3. Find first index that is positive, answer is index+1. 4. If none, answer is len(positives)+1. Complexity O(n). Let's generate pseudocode.\n\nWe need to use Start, End. Use Decision nodes. Also we should show loops. Use \"For i in 0..n-1\". For marking loop.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: posIndex ← 0 // 指向正數區塊開始位置\n→ For i ← 0 to n-1: // 將所有正數移到前面\n    If nums[i] > 0:\n        Swap nums[posIndex] and nums[i] // 交換正數到前\n        posIndex ← posIndex + 1 // 移動正數區塊指標\n→ Step 3: m ← posIndex // 正數總數\n→ For i ← 0 to m-1: // 標記出現的正整數\n    index ← abs(nums[i]) - 1\n    If index < m and nums[index] > 0:\n        nums[index] ← -nums[index] // 標記\n→ Step 4: For i ← 0 to m-1:\n    If nums[i] > 0:\n        Return i + 1 // 第一個未標記的正整數\n→ Step 5: Return m + 1 // 所有 1..m 都存在\nEnd // 程式執行結束\n\nWe need to include arrow \"→\" for each step. For loops, we can show \"For i ← 0 to n-1:\". For decisions, we use Decision: ... Yes → ... No → ... But we can also embed if statements.\n\nWe must obey the format: each line \"虛擬碼步驟 // 解釋\". We can include indentation? Not necessary.\n\nUse arrow for loops? We'll keep \"→\" for each line.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: posIndex ← 0 // 指向正數區塊開始位置  \n→ Decision: 是否有元素? // 檢查陣列是否為空  \n    Yes → For i ← 0 to n-1: // 迭代所有元素  \n        Decision: nums[i] > 0? // 檢查是否為正整數  \n            Yes → Swap nums[posIndex] with nums[i] // 交換正數到前面  \n                posIndex ← posIndex + 1 // 移動正數區塊指標  \n            No → // 若不是正數，保持原位  \n    No  → // 空陣列不需要處理  \n→ Step 3: m ← posIndex // m 為正數總數  \n→ For i ← 0 to m-1: // 標記出現的正整數  \n    index ← abs(nums[i]) - 1  \n    Decision: index < m and nums[index] > 0? // 確認索引有效且未標記  \n        Yes → nums[index] ← -nums[index] // 使用負號標記存在  \n        No  → // 若已標記或超出範圍，忽略  \n→ For i ← 0 to m-1: // 找第一個未標記的正整數  \n    Decision: nums[i] > 0? // 若為正數，表示該位置未出現  \n        Yes → Return i + 1 // 返回缺失的最小正整數  \n        No  → // 繼續檢查下一個位置  \n→ Step 4: Return m + 1 // 若所有 1..m 都存在，答案為 m+1  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[[1,2,3]],[[1,2,3]],[[1,2,3]]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [[1, 2, 3]], [[1, 2, 3]], [[1, 2, 3]]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列，並建立可變動的副本\n        self.original = list(nums)\n        self.arr = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列的複本\n        return list(self.original)\n\n    def shuffle(self):\n        # 使用 Fisher–Yates 洗牌演算法\n        shuffled = list(self.original)\n        n = len(shuffled)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入: 前面為操作序列，後面為對應參數\n    pos = data.find(']')\n    ops = json.loads(data[:pos + 1])\n    rest = data[pos + 1:].strip()\n    if rest.startswith(','):\n        rest = rest[1:].strip()\n    args = json.loads(rest)\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg)\n            results.append(None)\n        elif op == \"reset\":\n            results.append(obj.reset())\n        elif op == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            results.append(None)\n\n    # 將結果輸出為 JSON 格式，Python 的 None 對應到 JSON 的 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps. The user wants algorithm: initialize, reset, shuffle. Should be random shuffle with equal probability: Fisher-Yates.\n\nWe need to produce virtual code lines with arrow and explanation. We should include steps: store original array copy; reset returns original copy; shuffle uses Fisher-Yates: iterate i from n-1 downto 1, pick random j from 0..i, swap.\n\nWe need to represent class and methods. In virtual code, we can represent method definitions like \"Method: Solution(nums)\" etc. Let's create steps:\n\nStart\n→ Step 1: Store original array copy → etc.\n\nNeed to produce lines with // explanation.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: Save input array nums into original → 儲存傳入的原始陣列\n→ Step 2: Create working array copy of original → 建立可變動的複本\n\nBut methods: Constructor, reset, shuffle. We can structure:\n\nMethod: Solution(nums) // Constructor\n→ Save original array copy\n→ Create working array copy\n\nMethod: reset() // Reset array\n→ Return copy of original array\n\nMethod: shuffle() // Shuffle array\n→ For i from n-1 downto 1\n    → Pick random j between 0 and i\n    → Swap array[i] and array[j]\n→ Return shuffled array\n\nWe need arrow and decision where needed? No decision needed in shuffle except loop. Use \"→\" for linear steps, \"→ For\" maybe.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Method: Solution(nums) // 建構子\n    → Save original copy of nums to this.original // 儲存原始陣列\n    → Clone original to this.arr // 建立工作複本\n→ Method: reset() // 重設陣列\n    → Return clone of this.original // 回傳原始陣列的複本\n→ Method: shuffle() // 隨機洗牌\n    → For i from this.arr.length - 1 down to 1 // 從最後一個元素開始\n        → Generate random integer j in [0, i] // 隨機索引\n        → Swap this.arr[i] and this.arr[j] // 交換兩個位置\n    → Return this.arr // 回傳洗牌後的陣列\nEnd // 程式執行結束\n\nCheck formatting: Each line with arrow and comment. Use indent? We may include indentation but each line must start with arrow? In example, they use \"→ Step 1: ...\" and nested decisions indented. We can indent lines with spaces. We'll just use a single arrow for top-level and indent nested.\n\nLet's format each line with a preceding arrow and maybe nested ones with spaces then arrow. For method lines we can just use \"→ Method:\" lines and indent internal steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Method: Solution(nums) // 建構子\n  → Step 1: this.original = copy(nums) // 儲存原始陣列\n  → Step 2: this.arr = copy(this.original) // 建立可變動複本\n→ Method: reset() // 重設陣列\n  → Return copy(this.original) // 回傳原始陣列的複本\n→ Method: shuffle() // 隨機洗牌\n  → For i = this.arr.length - 1 down to 1\n    → j = randomInt(0, i) // 產生隨機索引\n    → Swap(this.arr[i], this.arr[j]) // 交換元素\n  → Return this.arr // 回傳洗牌後的陣列\nEnd // 程式執行結束\n\nMake sure each line has arrow and comment. For loop lines we may use arrow too. For nested, we can indent and still use arrow. Provide explanation after //.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Method: Solution(nums) // 建構子  \n  → Step 1: this.original = copy(nums) // 儲存傳入的原始陣列  \n  → Step 2: this.arr = copy(this.original) // 建立可變動的複本  \n\n→ Method: reset() // 重設陣列  \n  → Return copy(this.original) // 回傳原始陣列的完整複本  \n\n→ Method: shuffle() // 隨機洗牌  \n  → For i = this.arr.length - 1 downto 1 // 從陣列最後一個位置開始迭代  \n   → j = randomInt(0, i) // 產生 0 到 i 之間的隨機整數  \n  → Swap(this.arr[i], this.arr[j]) // 交換索引 i 與 j 的元素  \n  → Return this.arr // 回傳洗牌後的陣列  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        nums = []\n    else:\n        try:\n            # Extract the list from input like \"nums = [1,2,3]\"\n            start = data.find('[')\n            end = data.rfind(']')\n            nums = ast.literal_eval(data[start:end+1])\n        except Exception:\n            nums = []\n    sol = Solution()\n    result = sol.subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating power set of unique integer array, no duplicates. Use backtracking. Must use Start, End, Decision, arrow syntax.\n\nWe output line by line: each line with virtual code then // explanation. Use \"→\" for step, \"Decision:\" for condition, \"Yes →\", \"No →\". Include Start and End.\n\nWe need to produce algorithm: input array nums. Output list of subsets. Use recursion or iterative.\n\nWe need to produce virtual code. Each line must contain: virtual step + space + // explanation.\n\nExamples: \"Start // 程式開始執行\" etc.\n\nLet's craft.\n\nFirst line: Start // 程式開始執行\n\nNext: → Initialize result as empty list of lists // 建立結果集合\n\n→ Sort nums (optional) // 為了穩定性，將數列排序\n\n→ Define recursive function backtrack(start, current) // 回溯函式\n\nInside backtrack: record current subset.\n\n→ Append current to result // 將目前子集加入結果\n\n→ For i from start to length(nums)-1 // 遍歷剩餘元素\n\n   → Decision: If i > start AND nums[i] == nums[i-1]? // 處理重複元素 (though unique, but general)\n\n        No → (continue) // 若不是重複，執行下一步\n\n   → Append nums[i] to current // 加入元素\n\n   → Call backtrack(i+1, current) // 進一步探索\n\n   → Remove last element from current // 回溯，移除\n\nAfter loop, return\n\nThen call backtrack(0, []) // 開始回溯\n\nReturn result // 回傳結果\n\nEnd // 程式結束\n\nBut need to ensure each line has arrow and explanation. Use indentation: maybe \"→\" each line; for nested steps indent with spaces? The example didn't show indentation, but uses \"    Yes →\" with spaces.\n\nThus we can show nested steps with indentation spaces. Provide \"Decision:\" lines with Yes/No branches. For loop and recursion we can use \"→ For i ...\" then nested inside with indentation.\n\nLet's format.\n\nStart // 程式開始執行\n→ Initialize result = [] // 建立結果集合\n→ Sort nums // 讓數列有序，雖然元素唯一\n→ Define function backtrack(start, current) // 回溯函式，start 為索引起點\n    → Append a copy of current to result // 將目前子集加入結果\n    → For i from start to nums.length - 1 // 遍歷剩餘元素\n        → Decision: 如果 i > start 且 nums[i] == nums[i-1]? // 檢查重複元素\n            Yes → Continue // 若是重複，跳過\n            No  →\n                → Append nums[i] to current // 加入元素進行下一層\n                → Call backtrack(i + 1, current) // 進一步遞迴\n                → Remove last element from current // 回溯，移除\n← End of function backtrack // 函式結束\n→ Call backtrack(0, []) // 從第一個元素開始回溯\n→ Return result // 回傳所有子集\nEnd // 程式結束執行\n\nBut we need to ensure each line includes \"→\" at start, but for lines that are nested we still start with \"→\"? In example, nested lines still start with spaces then Yes → etc. So we can keep the \"→\" at each step, but indent accordingly.\n\nHowever, \"← End of function backtrack\" not needed. We can just close function with \"End function backtrack\" maybe.\n\nWe also need \"Decision:\" lines. The \"Decision:\" line itself must have \"Decision: ...?\" as example. Use \"Decision: 如果 i > start 且 nums[i] == nums[i-1]?\". Then indent branches.\n\nOk.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize result = [] // 建立結果集合  \n→ Sort nums // 讓數列有序，雖然元素唯一但有利後續處理  \n→ Define function backtrack(start, current) // 回溯函式，start 為索引起點  \n → Append a copy of current to result // 將目前子集加入結果  \n → For i from start to nums.length - 1 // 遍歷剩餘元素  \n  → Decision: 如果 i > start 且 nums[i] == nums[i-1]? // 檢查重複元素（此處可忽略）  \n   Yes → Continue // 若是重複，跳過此迴圈  \n   No  →  \n    → Append nums[i] to current // 加入元素進行下一層  \n    → Call backtrack(i + 1, current) // 進一步遞迴  \n    → Remove last element from current // 回溯，移除  \n← End function backtrack // 函式結束  \n→ Call backtrack(0, []) // 從第一個元素開始回溯  \n→ Return result // 回傳所有子集  \nEnd // 程式結束執行"
    },
    {
      "title": "Design Twitter",
      "source_file": "Leetcode/leetcode355.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_wdduoyp.py\", line 100, in <module>\n    main()\n  File \"/tmp/tmp_wdduoyp.py\", line 70, in main\n    args_list = ast.literal_eval(m.group(2))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        # global timestamp counter\n        self.time = 0\n        # userId -> list of (timestamp, tweetId)\n        self.tweets = defaultdict(list)\n        # userId -> set of followeeIds (including self when first tweet)\n        self.following = defaultdict(set)\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        \"\"\"Compose a new tweet.\"\"\"\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        # ensure the user follows himself for news feed\n        if userId not in self.following[userId]:\n            self.following[userId].add(userId)\n\n    def getNewsFeed(self, userId: int):\n        \"\"\"Retrieve 10 most recent tweet IDs.\"\"\"\n        res = []\n        if userId not in self.following:\n            return res\n\n        # max-heap: store (-timestamp, tweetId, sourceUserId, idx)\n        heap = []\n        for fid in self.following[userId]:\n            tws = self.tweets.get(fid)\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx > 0:\n                idx -= 1\n                ttime, tid_prev = self.tweets[fid][idx]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx))\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        \"\"\"follower starts following followee.\"\"\"\n        if followerId == followeeId:\n            # no-op, but ensure self-follow for consistency\n            self.following[followerId].add(followerId)\n            return\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        \"\"\"follower stops following followee.\"\"\"\n        if followerId == followeeId:\n            return\n        self.following[followerId].discard(followeeId)\n\ndef main():\n    data = sys.stdin.read().strip()\n    # parse the two top-level lists\n    m = re.match(r'\\s*(\\[[^\\]]*\\])\\s*,\\s*(\\[[^\\]]*\\])\\s*', data)\n    if not m:\n        print(\"[]\")\n        return\n    cmds = ast.literal_eval(m.group(1))\n    args_list = ast.literal_eval(m.group(2))\n\n    twitter = None\n    results = []\n\n    for cmd, args in zip(cmds, args_list):\n        if cmd == \"Twitter\":\n            twitter = Twitter()\n            results.append(None)\n        elif cmd == \"postTweet\":\n            twitter.postTweet(*args)\n            results.append(None)\n        elif cmd == \"follow\":\n            twitter.follow(*args)\n            results.append(None)\n        elif cmd == \"unfollow\":\n            twitter.unfollow(*args)\n            results.append(None)\n        elif cmd == \"getNewsFeed\":\n            res = twitter.getNewsFeed(*args)\n            results.append(res)\n        else:\n            # unknown command, ignore\n            results.append(None)\n\n    # output results in JSON format (None -> null)\n    import json\n    print(json.dumps(results, ensure_ascii=False))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Must not output actual code. Use structure. So outline the classes, methods, internal data structures. Use Start, End, Decision. Provide step-by-step operations: initialization, posting, following/unfollowing, getting feed.\n\nWe should describe each method: Twitter() creates data structures: map userId to set of followees, and map userId to list of tweet tuples (timestamp or order). We'll use global timestamp counter.\n\nIn getNewsFeed, gather tweets from self and followees, use priority queue to get 10 most recent. Since no actual code, just describe steps.\n\nWe need to be careful to match format: each line: `虛擬碼步驟 // 解釋`. Use arrows.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化全局時間戳為 0 // 用於標記推文發佈順序\n→ Step 2: 初始化 map followMap: userId → set of followeeIds // 追蹤誰跟誰\n→ Step 3: 初始化 map tweetMap: userId → list of (tweetId, timestamp) // 儲存推文\nEnd\n\nDefine method Twitter() : use above steps.\n\nBut we need to produce the entire algorithm in virtual code.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 Twitter 類別\n    → Step 1.1: 初始化時間戳 currentTime ← 0 // 用於確定推文順序\n    → Step 1.2: 建立 followMap ← 空 map // key: userId, value: set of followeeIds\n    → Step 1.3: 建立 tweetMap ← 空 map // key: userId, value: list of tweetId with timestamp\n\nDefine method postTweet(userId, tweetId)\n    → Step 2.1: 若 userId 未在 tweetMap 中，加入空列表\n    → Step 2.2: currentTime ← currentTime + 1 // 更新時間戳\n    → Step 2.3: 將 (tweetId, currentTime) 加入 tweetMap[userId] 的尾端 // 推文記錄\n\nDefine method follow(followerId, followeeId)\n    → Step 3.1: 若 followerId 未在 followMap 中，加入空集合\n    → Step 3.2: 在 followMap[followerId] 中加入 followeeId // 追蹤對象\n\nDefine method unfollow(followerId, followeeId)\n    → Step 4.1: 若 followerId 在 followMap 中\n        Yes → remove followeeId from followMap[followerId] // 解除追蹤\n        No  → Do nothing // 若不存在則忽略\n\nDefine method getNewsFeed(userId)\n    → Step 5.1: 建立 result 列表 // 儲存最終推文\n    → Step 5.2: 建立 candidates 集合 // 所有可能的推文來源\n        → Step 5.2.1: 將 userId 自身加入 candidates\n        → Step 5.2.2: 若 followMap[userId] 存在，將其所有 followeeId 加入 candidates\n    → Step 5.3: 建立 max-heap PQ，鍵為時間戳，值為 (tweetId, iteratorIndex, sourceUserId)\n        // 用於提取最新推文\n    → Step 5.4: 對於每個 sourceId in candidates\n        → Step 5.4.1: 若 tweetMap[sourceId] 非空\n            → Step 5.4.1.1: 取得最後一個推文索引 idx ← len(tweetMap[sourceId]) - 1\n            → Step 5.4.1.2: 將 (tweetMap[sourceId][idx].timestamp, tweetMap[sourceId][idx].tweetId, idx, sourceId) 推入 PQ\n    → Step 5.5: While PQ 非空 且 len(result) < 10\n        → Step 5.5.1: 取出 PQ 中最大的時間戳元素 (ts, tweetId, idx, sourceId)\n        → Step 5.5.2: result.add(tweetId) // 加入最終列表\n        → Step 5.5.3: 若 idx > 0\n            → Step 5.5.3.1: idx ← idx - 1\n            → Step 5.5.3.2: 推入新的元素 (tweetMap[sourceId][idx].timestamp, tweetMap[sourceId][idx].tweetId, idx, sourceId)\n    → Step 5.6: 返回 result // 10 個最新推文，從最新到最舊\n\nEnd // 程式執行結束\n\nWe must maintain the format: each line should be like `虛擬碼步驟 // 解釋`. We need arrows for steps. We can nest using indentation and arrows. Must be clear.\n\nWe also need to ensure no actual code: we should avoid syntax. Use descriptions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 Twitter 類別  \n → Step 1.1: 初始化全局時間戳 currentTime ← 0 // 用於確定推文的先後順序  \n → Step 1.2: 建立 followMap ← 空 map // key: userId, value: 追蹤者集合  \n → Step 1.3: 建立 tweetMap ← 空 map // key: userId, value: 推文列表（每筆含 tweetId 與時間戳）  \nEnd // Twitter 物件初始化完成  \n\n// ──────────────────────────────────────  \n// postTweet(userId, tweetId)  \n// ──────────────────────────────────────  \n→ Step 2: postTweet(userId, tweetId)  \n → Step 2.1: 若 userId 尚未在 tweetMap 中，加入空列表 // 以備存儲推文  \n → Step 2.2: currentTime ← currentTime + 1 // 時間戳遞增  \n → Step 2.3: 把 (tweetId, currentTime) 附加到 tweetMap[userId] 的尾端 // 記錄此推文  \n\n// ──────────────────────────────────────  \n// follow(followerId, followeeId)  \n// ──────────────────────────────────────  \n→ Step 3: follow(followerId, followeeId)  \n → Step 3.1: 若 followerId 未在 followMap 中，加入空集合 // 初始追蹤列表  \n → Step 3.2: 把 followeeId 加入 followMap[followerId] // 開始追蹤  \n\n// ──────────────────────────────────────  \n// unfollow(followerId, followeeId)  \n// ──────────────────────────────────────  \n→ Step 4: unfollow(followerId, followeeId)  \n → Step 4.1: 若 followerId 在 followMap 中  \n  Yes → 從 followMap[followerId] 刪除 followeeId // 解除追蹤  \n  No  → 不作任何動作 // 若不存在，忽略  \n\n// ──────────────────────────────────────  \n// getNewsFeed(userId)  \n// ──────────────────────────────────────  \n→ Step 5: getNewsFeed(userId)  \n → Step 5.1: 建立 result 列表 // 儲存最終輸出的推文 ID  \n → Step 5.2: 建立候選來源集合 candidates  \n  → Step 5.2.1: 加入 userId 本身 // 自己的推文也算進來  \n  → Step 5.2.2: 若 followMap[userId] 存在，將其所有 followeeId 加入 candidates // 追蹤者的推文  \n → Step 5.3: 建立最大堆 PQ，鍵為時間戳，值為 (tweetId, currentIndex, sourceUserId) // 方便取出最新推文  \n → Step 5.4: 對每個 sourceId 於 candidates  \n  → Step 5.4.1: 若 tweetMap[sourceId] 非空  \n   → Step 5.4.1.1: 計算最後一筆推文的索引 idx ← len(tweetMap[sourceId]) - 1  \n   → Step 5.4.1.2: 將 (tweetMap[sourceId][idx].timestamp, tweetMap[sourceId][idx].tweetId, idx, sourceId) 插入 PQ // 初始推入最新的推文  \n → Step 5.5: 當 PQ 非空 且 result 長度 < 10 時  \n  → Step 5.5.1: 從 PQ 取出時間戳最大的元素 (ts, tweetId, idx, sourceId) // 最新推文  \n  → Step 5.5.2: 把 tweetId 加入 result // 加到最終回傳列表  \n  → Step 5.5.3: 若 idx > 0  \n   → Step 5.5.3.1: idx ← idx - 1 // 移到前一筆推文  \n   → Step 5.5.3.2: 把 (tweetMap[sourceId][idx].timestamp, tweetMap[sourceId][idx].tweetId, idx, sourceId) 插入 PQ // 再次排入堆  \n → Step 5.6: 返回 result // 10 筆最新推文，依時間倒序  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxp11s4nj.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmpxp11s4nj.py\", line 32, in main\n    left, right = args[0]\n    ^^^^^^^^^^^\nTypeError: cannot unpack non-iterable int object"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\ndef main():\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 將輸入字串包成一個元組，使之可被 ast.literal_eval 解析\n    data = ast.literal_eval('(' + raw_input + ')')\n    ops, args_list = data[0], data[1]\n\n    results = []\n    obj = None  # 存放 NumArray 物件\n    for op, args in zip(ops, args_list):\n        if op == 'NumArray':\n            obj = NumArray(args[0])   # args[0] 為整數陣列\n            results.append(None)      # NumArray 創建返回 null\n        elif op == 'sumRange':\n            left, right = args[0]\n            results.append(obj.sumRange(left, right))\n        else:\n            # 若有其他操作，暫時略過\n            results.append(None)\n\n    # 將結果轉成符合題目輸出的字串，null 以 JSON 風格顯示\n    output = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, not actual code, with arrow notation. It's about building a NumArray class with constructor and sumRange, using prefix sum perhaps. Provide step-by-step algorithm.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\". Use Start, Decision, etc.\n\nProbably: Start -> Initialize prefix array length n+1 zero. Compute prefix sums. Then sumRange returns prefix[right+1]-prefix[left]. That's the algorithm.\n\nLet's produce steps: Start; Step 1: Input nums; Step 2: Compute prefix; Step 3: store prefix; Step 4: Return sumRange; sumRange uses prefix. Use Decision? Maybe none.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建構子 NumArray(nums) // 接收整數陣列  \n→ Decision: nums 是否為空? // 檢查輸入陣列是否有元素  \n  Yes → Step 2: 建立長度為 len(nums)+1 的前綴和陣列 pref，初始化為 0 // 用來儲存累加和  \n  No → Step 3: pref[0] = 0 // 空陣列時前綴和為零  \n→ Step 4: 循環 i 從 0 到 len(nums)-1  \n  pref[i+1] = pref[i] + nums[i] // 計算前綴和，pref[j] 表示 nums[0..j-1] 的總和  \n→ Step 5: 存儲 pref 作為物件屬性 // 方便後續查詢  \nEnd // 建構子執行完畢  \n\nStart // sumRange 方法執行  \n→ Step 1: 接收參數 left, right // 索引範圍  \n→ Decision: left > right? // 檢查參數合法性  \n  Yes → Step 2: 回傳 0 // 或拋出錯誤，這裡簡化為 0  \n  No → Step 3: result = pref[right+1] - pref[left] // 前綴和差值即為區間和  \n→ Step 4: 回傳 result // 結果返回給呼叫者  \nEnd // sumRange 方法執行完畢"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        # 建立前綴和陣列\n        self.prefix = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 產生 1~total 的隨機整數\n        target = random.randint(1, self.total)\n        # 以二分搜尋找第一個不小於 target 的索引\n        return bisect.bisect_left(self.prefix, target)\n\nif __name__ == \"__main__\":\n    # 讀取整行輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 以 '], [' 作為分隔符拆分方法名稱與對應參數\n    split_idx = data.find('], [')\n    if split_idx == -1:\n        raise ValueError(\"Invalid input format\")\n    names_str = data[:split_idx + 1]\n    args_str = data[split_idx + 3:]\n\n    # 解析成 Python 物件\n    method_names = json.loads(names_str)\n    method_args = json.loads(args_str)\n\n    results = []\n    instance = None\n\n    for name, args in zip(method_names, method_args):\n        if name == \"Solution\":\n            # 建構子，傳入 w\n            instance = Solution(args[0])\n            results.append(None)\n        elif name == \"pickIndex\":\n            # 呼叫 pickIndex，記錄結果\n            if instance is None:\n                raise RuntimeError(\"Solution instance not created\")\n            results.append(instance.pickIndex())\n        else:\n            raise ValueError(f\"Unknown method: {name}\")\n\n    # 輸出結果，使用 JSON 以符合「null」的格式\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for class with constructor to build prefix sums, pickIndex uses random and binary search. Provide line-by-line with arrow. Use Start, End, Decision etc. No actual code. Provide explanation comments. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的前綴和陣列 prefix // 用來存每個索引的累計權重  \n→ Step 2: sum ← 0 // 變數儲存總權重  \n→ Decision: 是否有 w[0]? // 判斷輸入陣列是否為空  \n    Yes → Step 3: For i從0到 w.length-1 迴圈 // 遍歷所有權重  \n            sum ← sum + w[i] // 更新總權重  \n            prefix[i] ← sum // 目前為止的累計權重  \n    No  → Step 4: prefix ← [] // 空陣列，無可選索引  \n→ Step 5: pickIndex 呼叫時  \n    → Step 6: r ← 隨機數(0, sum) // 產生 0~sum 之間的隨機數  \n    → Decision: 是否存在 prefix[i] ≥ r 的最小索引 i？ // 尋找第一個累計值不小於 r 的位置  \n        Yes → Step 7: return i // 返回對應索引  \n        No  → Step 8: return -1 // 理論上不會發生，總是有匹配  \nEnd // 程式執行結束"
    }
  ]
}