{
  "run_index": 9,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 398,
  "generation_or_validation_failure_count": 41,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[2,5,6,3,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[2, 5, 6, 3, 3]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"擲 n 次六面骰，回傳結果列表。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取全部程式碼，並執行\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines as per format: each line with \"虛擬碼步驟\" and // 解釋. Use arrow syntax. It's a function roll_dice(n). Steps: Start, Function definition, Input parameter, Initialize list, Loop from 1 to n, inside loop generate random.randint(1,6) add to list, end loop, return list, End. Also import random. Let's produce.\n\nWe need to ensure each line includes \"Start\" and \"End\". Use Decision only if needed, but not necessary.\n\nLet's produce:\n\nStart\n→ Step 1: Import random module // 匯入 random 模組\n→ Step 2: 定義函數 roll_dice(n) // 宣告 roll_dice 函數，接受 n\n    → Step 3: 初始化結果清單 results = [] // 用來存放每次擲骰結果\n    → Step 4: For i from 1 to n // 進行 n 次迴圈\n        → Step 5: 產生亂數 dice = random.randint(1, 6) // 產生 1~6 的隨機數\n        → Step 6: 將 dice 加入 results // 把結果放進清單\n    → Step 7: 回傳 results // 完成擲骰，回傳所有結果\nEnd\n\nNeed to ensure each line is separate line. Provide arrow lines with proper indentation. Use \"→\" for steps, \"→ Step X: ...\" etc. Should not output code. Provide short explanation after //.\n\nMake sure lines count. We'll produce.\n\nAlso need to add \"Start\" and \"End\" at top and bottom.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 匯入 random 模組，供擲骰使用  \n→ Step 2: 定義函數 roll_dice(n) // 宣告 roll_dice 函數，接受擲骰次數 n  \n    → Step 3: 初始化結果清單 results = [] // 用於儲存每次擲骰的數值  \n    → Step 4: For i from 1 to n // 進行 n 次迴圈，每次擲一顆骰子  \n        → Step 5: 產生亂數 dice = random.randint(1, 6) // 產生 1 至 6 的隨機整數  \n        → Step 6: 將 dice 加入 results // 把本次擲骰結果加入清單  \n    → Step 7: 回傳 results // 擲骰完成，回傳整個結果清單  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"測量函式 func 執行時間，返回秒數，四捨五入到小數點 3 位\"\"\"\n    start = time.time()\n    result = func(*args)\n    end = time.time()\n    elapsed = end - start\n    return round(elapsed, 3)\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin 作為程式碼\n    code = sys.stdin.read()\n    # 設定 exec 執行環境，提供 measure_time 及 time 模組\n    exec_globals = {\"measure_time\": measure_time, \"time\": time}\n    exec(code, exec_globals)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with comments. Format: \"虛擬碼步驟 // 解釋\". Use arrows etc. Include Start, End, Decision: maybe no decisions. Should show function definition, import time, record start, call func, record end, compute duration, round, return. Use *args. Show steps. We'll use \"→ Step X\". Use indentation for steps inside function. Show return. Use \"End\" for function end and program end.\n\nWe need to produce virtual code. Each line should include step and comment. Example lines:\n\nStart // 程式開始執行\n→ Step 1: Import time module // 匯入 time\n→ Step 2: Define function measure_time(func, *args) // 定義測量時間函式\n    → Step 3: start_time = time.time() // 紀錄開始時間\n    → Step 4: result = func(*args) // 執行傳入函式並傳回結果\n    → Step 5: end_time = time.time() // 紀錄結束時間\n    → Step 6: elapsed = end_time - start_time // 計算耗時\n    → Step 7: rounded_elapsed = round(elapsed, 3) // 四捨五入到小數點3位\n    → Step 8: return result, rounded_elapsed // 回傳結果與耗時\nEnd // 程式結束\n\nBut need to show end of function? Probably End for function. Could have separate End function.\n\nFollow format: \"End\" as a step. For function we can have \"End Function\" but just \"End\" maybe ambiguous. Maybe use \"End\" after function. Provide final End for program.\n\nMake sure each line follows \"虛擬碼步驟 // 解釋\".\n\nUse arrow \"→\". Use indentation for nested steps? Example above: \"→ Step 2:\" then indent steps. The example uses indentation inside Decision. So we can indent lines under Step 2.\n\nWe need to include \"Start\" and \"End\" for program. But we could also have End for function. We'll follow example: \"Start\", \"→ Step 1: ...\", \"→ Step 2: ...\", \"    → Step 3: ...\" etc, then \"End // 程式執行結束\". That includes function definition.\n\nWe might also show \"End Function\" but not necessary. Let's keep simple.\n\nLet's produce virtual code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 匯入 time 模組  \n→ Step 2: Define function measure_time(func, *args) // 定義 measure_time 函式  \n    → Step 3: start_time = time.time() // 紀錄執行開始時間  \n    → Step 4: result = func(*args) // 執行傳入的 func，並傳回結果  \n    → Step 5: end_time = time.time() // 紀錄執行結束時間  \n    → Step 6: elapsed = end_time - start_time // 計算實際耗時（秒）  \n    → Step 7: rounded_elapsed = round(elapsed, 3) // 將耗時四捨五入到小數點三位  \n    → Step 8: return result, rounded_elapsed // 回傳函式結果與耗時  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import requests\nimport tkinter as tk\nimport sys\n\ndef get_rate(return_text=False):\n    \"\"\"\n    取得美元兌台幣匯率。\n    如果 return_text 為 True，回傳文字；否則直接更新 GUI 標籤。\n    \"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=5)\n        r.raise_for_status()\n        data = r.json()\n        rate = data['rates']['TWD']\n        text = f'目前美元匯率：約 {rate} TWD'\n    except Exception:\n        text = '更新失敗，請檢查網路連線'\n\n    if return_text:\n        return text\n    else:\n        label.config(text=text)\n\n# 建立 tkinter 主視窗\nwin = tk.Tk()\nwin.title('匯率查詢')\n\nlabel = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\nlabel.pack(pady=10)\n\ntk.Button(win, text='更新匯率', command=lambda: get_rate()).pack(pady=5)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取指令\n    command = sys.stdin.read().strip()\n    if command == '按下「更新匯率」按鈕':\n        # 取得匯率並輸出至標準輸出\n        print(get_rate(return_text=True))\n    # 啟動 GUI 事件迴圈\n    win.mainloop()",
      "virtual_code": "Thinking...\nWe need to generate virtual code, line by line, with explanation. Must use structure: Start, End, Decision, etc. Should not output actual code. Use arrow arrows and steps.\n\nRequirement: Use requests to call API https://api.exchangerate-api.com/v4/latest/USD, get rate for TWD. Use tkinter window, with button to update rate. The code structure: import modules, create Tk root, label for rate, button. When button pressed, call function to fetch rate and update label. Use requests.get, parse JSON, extract 'rates'->'TWD'.\n\nWe must use virtual code with steps and explanations. Use arrow →.\n\nWe'll create steps: Start, initialize variables, define fetch function, set up GUI, set button command, mainloop, End.\n\nAlso we need Decision steps maybe for error handling: if request successful? If rate exists? Use Decision blocks.\n\nLet's produce. Use each line as one step. The virtual code arrow lines start with \"→\". After arrow, the step description, then // explanation. For decision, \"Decision:\" lines. Provide nested indentation maybe with spaces? In example, they used indentation inside decision. We can follow similar.\n\nWe'll create:\n\nStart\n→ Step 1: Import requests and tkinter // Load necessary modules\n→ Step 2: Define function fetch_rate // Function to get rate from API\n    → Decision: HTTP request successful? // Check if response OK\n        Yes → Step 3: Parse JSON // Convert response to dictionary\n            → Decision: 'TWD' in rates? // Ensure rate exists\n                Yes → Step 4: Return rate value // Provide rate\n                No  → Step 5: Return None // Rate not found\n        No  → Step 6: Return None // Request failed\n→ Step 7: Initialize Tk window // Create main window\n→ Step 8: Create Label to display rate // Label for showing exchange rate\n→ Step 9: Create Button labeled '更新匯率' // Button to trigger update\n    → Decision: Button click triggers fetch_rate? // When button clicked\n        Yes → Step 10: Call fetch_rate and update label // Update label text\n→ Step 11: Set button command to update function // Bind button to action\n→ Step 12: Start Tk main loop // Run GUI event loop\nEnd\n\nWe need to produce each line exactly as: \"虛擬碼步驟 // 解釋\".\n\nAlso use arrow characters. Let's craft:\n\nStart // 程式開始執行\n→ Step 1: Import requests, tkinter // 載入網路請求與 GUI 模組\n→ Step 2: Define function fetch_rate // 建立取得匯率的函式\n    → Decision: HTTP request successful? // 檢查網路回應是否成功\n        Yes → Step 3: Parse JSON data // 將回應內容轉為字典\n            → Decision: 'TWD' in rates? // 確認是否包含台幣匯率\n                Yes → Step 4: Return rate value // 回傳 TWD 匯率\n                No  → Step 5: Return None // 匯率不存在，回傳 None\n        No  → Step 6: Return None // 網路請求失敗，回傳 None\n→ Step 7: Initialize Tk window // 建立 tkinter 主視窗\n→ Step 8: Create Label to display rate // 新增文字標籤顯示匯率\n→ Step 9: Create Button labeled '更新匯率' // 新增按鈕觸發更新\n    → Decision: Button click triggers fetch_rate? // 按鈕被點擊時\n        Yes → Step 10: Call fetch_rate and update label // 取得匯率並更新標籤\n→ Step 11: Set button command to update function // 將按鈕事件指向更新函式\n→ Step 12: Start Tk main loop // 啟動 GUI 事件迴圈\nEnd // 程式執行結束\n\nNeed to ensure indentation for decisions: use 4 spaces? The example uses 4 spaces indentation for nested lines. We'll use similar.\n\nMake sure each line has '→' arrow and text and comment. For Decision lines, start with \"Decision:\" not arrow? In example: \"Decision: 如果數字大於 0?\" preceded by no arrow. So we need to match: Use \"Decision:\" not arrow. The example had \"Decision: 如果數字大於 0?\" without arrow. So for Decision lines, we start with \"Decision:\" and then spaces then \"Yes →\" etc. So correct format:\n\nDecision: 如果數字大於 0?\n    Yes → Step 2: ...\n\nSo we need to format accordingly.\n\nThus for our code:\n\nStart // 程式開始執行\n→ Step 1: Import requests, tkinter // 載入網路請求與 GUI 模組\n→ Step 2: Define function fetch_rate // 建立取得匯率的函式\nDecision: HTTP request successful?\n    Yes → Step 3: Parse JSON data // 將回應內容轉為字典\n        Decision: 'TWD' in rates?\n            Yes → Step 4: Return rate value // 回傳 TWD 匯率\n            No  → Step 5: Return None // 匯率不存在，回傳 None\n    No  → Step 6: Return None // 網路請求失敗，回傳 None\n→ Step 7: Initialize Tk window // 建立 tkinter 主視窗\n→ Step 8: Create Label to display rate // 新增文字標籤顯示匯率\n→ Step 9: Create Button labeled '更新匯率' // 新增按鈕觸發更新\nDecision: Button click triggers fetch_rate?\n    Yes → Step 10: Call fetch_rate and update label // 取得匯率並更新標籤\n→ Step 11: Set button command to update function // 將按鈕事件指向更新函式\n→ Step 12: Start Tk main loop // 啟動 GUI 事件迴圈\nEnd // 程式執行結束\n\nYes, that fits format.\n\nCheck: each line has step text, followed by space and comment. Decision lines also have comment after //.\n\nNow output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests, tkinter // 載入網路請求與 GUI 模組  \n→ Step 2: Define function fetch_rate // 建立取得匯率的函式  \nDecision: HTTP request successful? // 檢查網路回應是否成功  \n    Yes → Step 3: Parse JSON data // 將回應內容轉為字典  \n        Decision: 'TWD' in rates? // 確認是否包含台幣匯率  \n            Yes → Step 4: Return rate value // 回傳 TWD 匯率  \n            No → Step 5: Return None // 匯率不存在，回傳 None  \n    No → Step 6: Return None // 網路請求失敗，回傳 None  \n→ Step 7: Initialize Tk window // 建立 tkinter 主視窗  \n→ Step 8: Create Label to display rate // 新增文字標籤顯示匯率  \n→ Step 9: Create Button labeled '更新匯率' // 新增按鈕觸發更新  \nDecision: Button click triggers fetch_rate? // 按鈕被點擊時  \n    Yes → Step 10: Call fetch_rate and update label // 取得匯率並更新標籤  \n→ Step 11: Set button command to update function // 將按鈕事件指向更新函式  \n→ Step 12: Start Tk main loop // 啟動 GUI 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmq73uwc4.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpmq73uwc4.py\", line 33, in main\n    commands = json.loads(data[0])\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 54 (char 53)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m: int, n: int):\n        self.m = m\n        self.n = n\n        self.total = m * n          # 剩餘可翻轉的格子數\n        self.mapping = {}           # 已交換的索引映射表\n\n    def flip(self):\n        # 隨機挑選一個還未翻轉的格子\n        r = random.randint(0, self.total - 1)\n        # 取得實際要翻轉的索引（可能已被映射）\n        actual = self.mapping.get(r, r)\n        # 更新剩餘數量\n        self.total -= 1\n        # 把 r 位置映射到最後一個可用位置\n        self.mapping[r] = self.mapping.get(self.total, self.total)\n        # 轉成行列座標返回\n        return [actual // self.n, actual % self.n]\n\n    def reset(self):\n        # 重設為全 0\n        self.total = self.m * self.n\n        self.mapping.clear()\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = json.loads(data[0])\n    arguments = json.loads(data[1])\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)          # 建構子返回 null\n        elif cmd == \"flip\":\n            results.append(obj.flip())\n        elif cmd == \"reset\":\n            obj.reset()\n            results.append(None)          # reset 也返回 null\n        else:\n            # 若有未知指令，可忽略或自行處理\n            pass\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Need to design algorithm: use reservoir-like mapping technique: treat indices 0..m*n-1. Use dictionary to map from chosen index to actual index. When flip called: pick random from [0, total-1], decrement total. If map contains key, actual=map[key], else actual=key. Then if total>0 and map contains total key: map[key] = map[total] else map[key] = total. Reset: clear map, total=m*n.\n\nNeed to output stepwise algorithm for Solution class and methods.\n\nWe must produce lines with \"Start\", \"End\" etc. Provide steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nWe need to produce code for entire class but in virtual code. So:\n\nStart // initialize solution\n→ Variable: m, n, total, mapping // store dimensions, remaining zeros, mapping\n→ mapping = empty dictionary // map indices\n→ total = m*n // total zeros\nEnd // initialization done\n\nFlip method:\nStart // flip called\n→ Step: If total == 0 → return None? but problem ensures at least one zero? We'll ignore.\n→ Step: randIndex = random integer in [0, total-1] // choose random zero\n→ Step: total = total - 1 // decrement remaining zeros\n→ Decision: If randIndex in mapping? // mapping holds if previously swapped\n    Yes → actualIndex = mapping[randIndex] // get mapped actual index\n    No  → actualIndex = randIndex\n→ Decision: If total in mapping? // mapping for last index\n    Yes → mapping[randIndex] = mapping[total]\n    No  → mapping[randIndex] = total\n→ Return actualIndex // return as [i,j] via division mod n\n\nReset method:\nStart // reset called\n→ mapping = empty dictionary\n→ total = m*n\nEnd\n\nAlso include converting actualIndex to coordinates: i=actualIndex//n, j=actualIndex%n.\n\nBut we need step lines.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 初始化 Solution 物件，設定矩陣尺寸與剩餘可翻轉格子數\n→ 設定 m, n, total ← m * n // 先算出所有格子總數\n→ 建立空字典 mapping ← {} // 用來記錄已交換的索引對應\nEnd // 物件建構完成\n\nStart // flip() 被呼叫時，隨機選取一個尚未翻轉的格子並將其翻轉\n→ Step 1: randIdx ← 隨機整數 [0, total-1] // 隨機挑選一個可用索引\n→ Step 2: total ← total - 1 // 應該要翻轉的格子數量減一\n→ Decision: 若 randIdx 在 mapping 中? // 是否已經被映射到其他索引\n    Yes → actualIdx ← mapping[randIdx] // 取得實際要翻轉的索引\n    No  → actualIdx ← randIdx // 直接使用隨機索引\n→ Decision: 若 total 在 mapping 中? // 判斷最後一個可用索引是否已被映射\n    Yes → mapping[randIdx] ← mapping[total] // 把 randIdx 指向 total 的映射\n    No  → mapping[randIdx] ← total // 把 randIdx 指向總剩餘索引\n→ Step 3: i ← actualIdx // n\n→ Step 4: j ← actualIdx % n // 轉成行列座標\n→ Return [i, j] // 回傳隨機且均勻的格子座標\nEnd // flip() 完成\n\nStart // reset() 被呼叫時，將所有格子重設為 0\n→ mapping ← {} // 清空映射表\n→ total ← m * n // 重新設定剩餘可翻轉格子數\nEnd // reset() 完成\n```"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpb_tum09n.py\", line 56, in <module>\n    obj.buildDict(arg)\n  File \"/tmp/tmpb_tum09n.py\", line 13, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MagicDictionary:\n    def __init__(self):\n        # 存放所有單詞\n        self.words = set()\n        # 存放通配符模式到出現次數的映射\n        self.patterns = {}\n\n    def buildDict(self, dictionary):\n        # 重新設定字典與模式表\n        self.words = set(dictionary)\n        self.patterns.clear()\n        # 為每個單詞建立所有通配符模式\n        for word in self.words:\n            for i in range(len(word)):\n                pattern = word[:i] + '*' + word[i+1:]\n                self.patterns[pattern] = self.patterns.get(pattern, 0) + 1\n\n    def search(self, searchWord):\n        # 對於每個位置替換成 '*'\n        for i in range(len(searchWord)):\n            pattern = searchWord[:i] + '*' + searchWord[i+1:]\n            cnt = self.patterns.get(pattern, 0)\n            if cnt:\n                # 需要至少一個不同的單詞\n                if cnt > 1 or searchWord not in self.words:\n                    return True\n        return False\n\ndef _format_output(value):\n    if value is None:\n        return 'null'\n    if value is True:\n        return 'true'\n    if value is False:\n        return 'false'\n    return repr(value)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 將輸入視為 (commands, args) 的字串，使用 ast.literal_eval 解析\n    commands, args = ast.literal_eval('(' + data + ')')\n\n    obj = None\n    outputs = []\n    for cmd, arg in zip(commands, args):\n        if cmd == 'MagicDictionary':\n            obj = MagicDictionary()\n            outputs.append(None)\n        elif cmd == 'buildDict':\n            obj.buildDict(arg)\n            outputs.append(None)\n        elif cmd == 'search':\n            outputs.append(obj.search(arg))\n\n    # 轉換為符合題目要求的輸出格式\n    formatted = '[' + ', '.join(_format_output(v) for v in outputs) + ']'\n    print(formatted)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with comments, using Start, End, Decision, etc. Steps: Initialize, buildDict, search. For each step: build dictionary, likely store words in a set and also precompute patterns with a placeholder or use map of patterns to count. Then search: iterate over each character, replace with '*', check if any word in map matches with count >0. Ensure exactly one change, so need to handle same word not counted if no change. Use algorithm from Leetcode 676. So produce virtual code steps.\n\nWe need to output line by line: each line: 虛擬碼步驟 [space] // 解釋. Use arrows. Use Start, End. Use Decision.\n\nLet's produce steps:\n\nStart\n→ Step 1: 定義 MagicDictionary 類 // 建立類別\n→ Step 2: 定義字典變數 wordsSet // 存所有單詞\n→ Step 3: 定義字典變數 patternMap // 存通配符模式到出現次數\n→ Step 4: 初始化 wordsSet 為空集合 // 建構子\n→ Step 5: 初始化 patternMap 為空映射 // 建構子\nEnd // 結束建構子\n\nStart // buildDict\n→ Step 1: 清空 wordsSet 與 patternMap // 重新建構\n→ Step 2: 對每個單詞 word 在 dictionary 迭代\n    → Decision: 是否將 word 加入 wordsSet? // 確保唯一\n        Yes → Step 3: wordsSet 加入 word // 存入集合\n    → Step 4: 對每個索引 i 在 word 長度\n        → Step 5: 產生 pattern = word[0..i-1] + '*' + word[i+1..] // 替換第 i 個字\n        → Step 6: patternMap[pattern] += 1 // 記錄此模式出現次數\nEnd // buildDict 完成\n\nStart // search\n→ Step 1: 對每個索引 i 在 searchWord 長度\n    → Step 2: 產生 pattern = searchWord[0..i-1] + '*' + searchWord[i+1..] // 替換第 i 個字\n    → Step 3: Decision: patternMap 中是否有此 pattern? // 檢查是否存在\n        Yes → Step 4: Decision: 是否存在另一個不同的單詞? // 需要至少一個不同單詞\n            Yes → Return True // 找到符合條件\n            No  → Continue // 這個 pattern 只能匹配相同單詞\n        No  → Continue // 該位置不匹配任何單詞\n→ Decision: 是否已找到符合? // 所有位置檢查完畢\n    Yes → Return True\n    No  → Return False\nEnd // search 完成\n\nBut need to ensure only one character changed, and not same word. The typical algorithm checks patternMap[pattern] > 1 or word not equal. In search, we need to check if patternMap[pattern] >=1, and either patternMap[pattern] > 1 or the word at that pattern is not equal to searchWord. But we don't store word mapping. Alternative: we can check if any word in dictionary equal to searchWord -> skip because would be zero changes. But we need exactly one change, so we only return true if patternMap[pattern] >0 and (patternMap[pattern] >1 or word not equal). But we don't store which word. Simpler: we can store patternMap as set of patterns with word count. In search, if patternMap[pattern] >0 and (patternMap[pattern] >1 or searchWord not in wordsSet). That ensures not same word. Let's incorporate that.\n\nLet's produce virtual code accordingly.\n\nNeed to use arrow for decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 MagicDictionary 類 // 建立類別\n→ Step 2: 定義 wordsSet 為空集合 // 用來存所有單詞\n→ Step 3: 定義 patternMap 為空映射 // 存通配符模式對應出現次數\n→ Step 4: 建構子 MagicDictionary() 初始化 wordsSet 與 patternMap // 準備資料結構\nEnd // 建構子結束\n\nStart // buildDict(dictionary) 方法開始\n→ Step 1: 清空 wordsSet 與 patternMap // 重新設定資料結構\n→ Step 2: 對每個 word 在 dictionary 迭代\n    → Decision: word 是否已存在於 wordsSet? // 確保單詞唯一\n        Yes → Continue // 已存在則略過\n        No  → Step 3: wordsSet 加入 word // 存入集合\n    → Step 4: 對每個索引 i 在 word 長度\n        → Step 5: 產生 pattern = word[0..i-1] + '*' + word[i+1..] // 替換第 i 個字\n        → Step 6: patternMap[pattern] = patternMap.get(pattern, 0) + 1 // 記錄此模式出現次數\nEnd // buildDict 完成\n\nStart // search(searchWord) 方法開始\n→ Step 1: Decision: searchWord 是否存在於 wordsSet? // 若完全相同則無法只改一個字元\n    Yes → Return False // 需要改一個字元\n    No  → Continue\n→ Step 2: 對每個索引 i 在 searchWord 長度\n    → Step 3: 產生 pattern = searchWord[0..i-1] + '*' + searchWord[i+1..] // 替換第 i 個字\n    → Step 4: Decision: pattern 是否在 patternMap? // 檢查此模式是否對應任何單詞\n        Yes → Step 5: Decision: patternMap[pattern] > 1 或 searchWord 不在 wordsSet? // 至少有一個不同單詞\n            Yes → Return True // 找到符合條件\n            No  → Continue // 只能對應到同一單詞，跳過\n        No  → Continue // 該位置不匹配任何單詞\n→ Step 6: Return False // 所有位置檢查完畢仍未找到符合條件\nEnd // search 完成\n\nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5hky1w_h.py\", line 33, in <module>\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5hky1w_h.py\", line 12, in __init__\n    self.lookup[(word[:i], word[j:])] = weight\n    ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    def __init__(self, words):\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):\n                for j in range(L + 1):\n                    # 使用元組作為 key，避免字串連接開銷\n                    self.lookup[(word[:i], word[j:])] = weight\n\n    def f(self, prefix, suffix):\n        return self.lookup.get((prefix, suffix), -1)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 把輸入包成元組，方便解析\n    try:\n        wrapped = f\"({data})\"\n        words, query = ast.literal_eval(wrapped)\n        pref, suff = query[0], query[1]\n    except Exception as e:\n        # 如果解析失敗，直接退出\n        print(-1)\n        sys.exit(0)\n\n    wf = WordFilter(words)\n    result = wf.f(pref, suff)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line. This is algorithm design for WordFilter: given words array, we want to support f(pref, suff) queries. The standard solution uses Trie for prefixes and suffixes, or use combined key of suffix#prefix and store max index.\n\nSimplify: Build a hash map from combined key to max index. For each word and its index, for all prefixes and suffixes? That would be O(n * L^2) too heavy. Better solution: For each word, for all possible suffixes, we create key suffix + '#' + prefix and store index. But standard solution from LeetCode: build Trie of suffixes? But easier explanation: We'll build a hash map where key is \"prefix#suffix\" and value is max index. We generate all prefix-suffix pairs by iterating over word characters. Complexity okay for moderate constraints.\n\nWe'll provide virtual code accordingly.\n\nNow produce virtual code lines with explanation.\n\nLet's craft:\n\nStart\n→ Step 1: Define WordFilter class with constructor and method f\n→ Step 2: In constructor, store words array and build hash map\n→ Build map: For each word with index i, iterate over all prefixes (including full word)\n→ For each prefix, iterate over all suffixes\n→ Create key = prefix + \"#\" + suffix\n→ Store max index for key\n→ f method: look up key pref + \"#\" + suff in map; if found return value else -1\nEnd\n\nNow produce lines with arrows and explanations.\n\nWe'll produce steps: \nStart\n→ Define WordFilter class // 宣告類別\n→ Step 1: WordFilter(words) // 建構子\n    → Store words // 儲存單字陣列\n    → Step 2: Build map // 建立查詢表\n        → For each word index i\n            → For each prefix end p\n                → For each suffix start s\n                    → key = prefix + \"#\" + suffix\n                    → map[key] = i // 只保留最大索引\n→ Step 3: f(pref, suff) // 查詢方法\n    → key = pref + \"#\" + suff\n    → If key in map → return map[key] else -1\nEnd\n\nMake sure each line is separate, with arrows. Use indentation with spaces. Provide comments. Use \"Start\" and \"End\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define WordFilter class // 宣告 WordFilter 類別  \n→ Step 1: WordFilter(words) // 建構子  \n  → Store words // 儲存單字陣列  \n  → Step 2: Build map // 建立查詢表  \n    → For each word index i  \n      → For each prefix end p (0..len)  \n        → For each suffix start s (0..len)  \n          → key = prefix + \"#\" + suffix // 以 \"#\" 分隔前綴與後綴  \n          → map[key] = i // 只保留最大的索引  \n→ Step 3: f(pref, suff) // 查詢方法  \n  → key = pref + \"#\" + suff // 組合鍵  \n  → If key in map → return map[key] else -1 // 回傳對應索引或 -1  \nEnd // 程式執行結束"
    },
    {
      "title": "Two Sum",
      "source_file": "Leetcode/leetcode1.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,7,11,15], target = 9",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpob9pyxmt.py\", line 32, in <module>\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,4], target = 6",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpb522t07t.py\", line 32, in <module>\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3], target = 6",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpq2l_jx8w.py\", line 32, in <module>\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        Find indices of two numbers that add up to target.\n        Uses a hash map to achieve O(n) time complexity.\n        \"\"\"\n        index_map = {}  # maps number to its index\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in index_map:\n                return [index_map[complement], i]\n            index_map[num] = i\n        # Problem guarantees one solution, so this line is never reached.\n        return []\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Expected format: \"nums = [...], target = ...\"\n    # Split on the first comma that separates nums and target\n    parts = data.split(',', 1)\n    nums_part = parts[0].split('=', 1)[1].strip()\n    target_part = parts[1].split('=', 1)[1].strip()\n\n    # Safely parse the list and integer using ast.literal_eval\n    nums = ast.literal_eval(nums_part)\n    target = ast.literal_eval(target_part)\n\n    # Compute result\n    solution = Solution()\n    result = solution.twoSum(nums, target)\n\n    # Output as a list\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for the two-sum problem. Virtual code with arrows, Start, End, Decision. No real code. Provide explanation for each line. We'll create a hash map approach. Steps: Start; Step 1: Initialize empty map; Step 2: For each index i in array; Step 3: Compute complement = target - nums[i]; Step 4: Decision: if complement exists in map; Yes → return indices; No → add current number to map; End. We also need to output indices. Provide pseudocode lines. Provide brief explanations. Use arrow syntax exactly. We'll format each line as \"→ Step ... // explanation\". Also \"Decision:\" line with indent. Provide Start and End. Ensure each line contains arrow and explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立一個空的哈希表 map // 用於儲存已遍歷數字及其索引\n→ Step 2: 對 nums 中的每個元素執行迴圈，取得索引 i 和數值 num // 逐個檢查每個數字\n    → Decision: 如果 target - num 存在於 map? // 判斷是否已找到能配對的數字\n        Yes → Step 3: 回傳 [map[target - num], i] // 找到答案，輸出兩個索引\n        No  → Step 4: 將 num 和索引 i 存入 map // 未找到，將目前數字加入查找表\nEnd // 程式執行結束，假設一定有解且只返回一次結果"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,null,-3,null,0,-2]'\nGot (Norm):      '[null,null,null,-3,null,0,-2]'\n--- (Raw) ---\nRaw Expected: '[null,null,null,null,-3,null,0,-2]'\nRaw Got:      '[null,null,null,-3,null,0,-2]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self):\n        if self.stack:\n            val = self.stack.pop()\n            if self.min_stack and val == self.min_stack[-1]:\n                self.min_stack.pop()\n\n    def top(self):\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self):\n        return self.min_stack[-1] if self.min_stack else None\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # Remove possible whitespace/newlines\n    raw = raw.replace('\\n', '').replace('\\r', '')\n\n    # Split into operation list and argument list\n    parts = raw.split('],', 1)\n    ops_text = parts[0] + ']'\n    args_text = parts[1] if len(parts) > 1 else '[]'\n\n    ops = json.loads(ops_text)\n    args = json.loads(args_text)\n\n    min_stack = MinStack()\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == 'MinStack':\n            continue  # already initialized\n        if op == 'push':\n            min_stack.push(arg[0])\n            outputs.append('null')\n        elif op == 'pop':\n            min_stack.pop()\n            outputs.append('null')\n        elif op == 'top':\n            val = min_stack.top()\n            outputs.append(str(val) if val is not None else 'null')\n        elif op == 'getMin':\n            val = min_stack.getMin()\n            outputs.append(str(val) if val is not None else 'null')\n\n    print('[' + ','.join(outputs) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code line by line for design of MinStack with O(1) per operation. Provide virtual code steps, with arrow notation. We can produce algorithm: use two stacks: main stack and min stack storing min so far. Or store pairs. Provide steps for class init, push, pop, top, getMin. Use pseudo-step format.\n\nNeed to output line by line, each line: \"虛擬碼步驟 // 解釋\". Use Start, End. Use Decision: etc. For operations we show steps. Provide for each method? Probably yes. We'll produce structure.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 定義 MinStack 類 // 建立 MinStack 物件\n    → Step 2: 初始化兩個空堆疊: stack, minStack // 主堆疊與儲存最小值的堆疊\nEnd\n\nThen push:\n\n→ Step 3: push(val) // 將 val 推入主堆疊\n    → Decision: 如果 minStack 為空 或 val ≤ minStack.top()? // 判斷是否為新最小值\n        Yes → push val onto minStack // 新最小值加入 minStack\n        No  → 不改 minStack // 保持現有最小值\nEnd\n\nPop:\n\n→ Step 4: pop() // 移除主堆疊頂部\n    → Decision: 主堆疊頂部值等於 minStack.top()? // 判斷是否為最小值\n        Yes → pop minStack // 同時移除 minStack 的頂部\n        No  → 不改 minStack // 只移除主堆疊\nEnd\n\nTop:\n\n→ Step 5: top() // 回傳主堆疊頂部\n\ngetMin:\n\n→ Step 6: getMin() // 回傳 minStack.top()\n\nBut we need to use pseudo-steps. Let's produce as per format: Each line with \"虛擬碼步驟 // 解釋\". Use arrows: \"→\". Use \"Decision:\".\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 建立 MinStack 類 // 定義 MinStack 類別\n→ Step 2: 初始化 stack, minStack 為空堆疊 // 主堆疊與最小值堆疊\nEnd // 初始化完成\n\nPush(val):\n→ Step 3: 執行 push(val) // 將 val 推入主堆疊\n    → Decision: 如果 minStack 為空 或 val ≤ minStack.top()? // 判斷是否需要更新最小值\n        Yes → Step 4: push val 到 minStack // 新最小值加入 minStack\n        No  → Step 5: 不執行任何操作 // 保持 minStack 不變\nEnd // push 完成\n\nPop():\n→ Step 6: 執行 pop() // 從主堆疊移除頂部\n    → Decision: 被移除值 == minStack.top()? // 判斷是否是最小值\n        Yes → Step 7: pop minStack // 同時移除 minStack 頂部\n        No  → Step 8: 不執行任何操作 // minStack 不變\nEnd // pop 完成\n\nTop():\n→ Step 9: 回傳 stack.top() // 回傳主堆疊頂部值\nEnd // top 完成\n\nGetMin():\n→ Step 10: 回傳 minStack.top() // 回傳最小值\nEnd // getMin 完成\n\nBut the output format expects lines with \"虛擬碼步驟\" not method names. Maybe we can group. They didn't say to separate methods. We'll output all steps sequentially. Use Start and End only once. But easier to keep each method separate but we can embed in one flow. Provide step numbers.\n\nBetter produce a comprehensive flow:\n\nStart // 程式開始\n→ Step 1: 建立 MinStack 類 // 定義類別\n→ Step 2: 初始化兩個空堆疊: stack, minStack // 主堆疊與最小值堆疊\nEnd // 初始化完成\n\nBut then each method is separate. The user wants virtual code for the whole class. So we could produce all methods as steps. Use indentation for Decision. Use arrow. Use \"Step X:\" etc.\n\nLet's produce final answer with lines exactly as required.\n\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 建立 MinStack 類別 // 定義 MinStack 類\n→ Step 2: 初始化兩個空堆疊：stack, minStack // 主堆疊與最小值堆疊\nEnd // 初始化結束\n\nPush(val):\n→ Step 3: push(val) // 將 val 推入主堆疊\n    → Decision: 若 minStack 為空 或 val ≤ minStack.top()? // 判斷是否為新最小值\n        Yes → Step 4: push val 到 minStack // 新最小值加入 minStack\n        No  → Step 5: 不改 minStack // 保留現有最小值\nEnd // push 完成\n\nPop():\n→ Step 6: pop() // 從主堆疊移除頂部元素\n    → Decision: 被移除值 == minStack.top()? // 判斷是否是最小值\n        Yes → Step 7: pop minStack // 同時移除 minStack 的頂部\n        No  → Step 8: 不改 minStack // minStack 保持不變\nEnd // pop 完成\n\nTop():\n→ Step 9: return stack.top() // 回傳主堆疊頂部元素\nEnd // top 完成\n\nGetMin():\n→ Step 10: return minStack.top() // 回傳最小值\nEnd // getMin 完成"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpz9ec3vlc.py\", line 28, in <module>\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1, 2, 3, 3, 3]], [3], [1], [3]]\n                                    ^\nSyntaxError: unmatched ']'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立一個字典，將每個數字對應到所有出現的索引\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機挑選 target 所對應的索引\n        return random.choice(self.indices[target])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，將兩個列表分離\n    parts = data.split('], [', 1)\n    commands_str = parts[0] + ']'\n    args_str = parts[1]\n    commands = ast.literal_eval(commands_str)\n    args = ast.literal_eval(args_str)\n\n    result = []\n    sol = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            # arg 為 [[1,2,3,3,3]]，取第一個元素作為 nums\n            sol = Solution(arg[0] if isinstance(arg, list) else arg)\n            result.append(None)  # constructor 之回傳為 null\n        elif cmd == \"pick\":\n            # arg 為 [3]，取第一個元素作為 target\n            target = arg[0] if isinstance(arg, list) else arg\n            result.append(sol.pick(target))\n\n    # 將結果以 JSON 格式輸出，null 對應於 None\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step for the described algorithm: solution class with constructor storing array and pick method that selects random index with equal probability among indices equal to target.\n\nWe need to output virtual code steps line by line with comments. The code must be in virtual steps, using Start, End, Decision, etc. We should outline high-level algorithm: store array; pick method: initialize count=0, resultIndex=-1; iterate over array with index i; if nums[i]==target: increment count; generate random number r between 1 and count; if r==1: set resultIndex=i; return resultIndex. That's reservoir sampling.\n\nSo produce virtual code accordingly. Each line: \"虛擬碼步驟 // 解釋\". Use arrow for steps, decision, etc.\n\nWe need to show initialization, pick function, loop, decision for random selection.\n\nLet's craft steps:\n\nStart // 程式開始執行\n→ Step 1: 定義 Solution 類別 // 建立類別框架\n    → Step 1.1: 定義屬性 nums // 儲存輸入陣列\n→ End // 類別定義完成\n\nBut we also need methods: Constructor and pick. Use steps: Step 2: Solution(nums) // 建構子\n    → Step 2.1: 將 nums 複製到物件屬性 // 初始化\n→ Step 3: pick(target) // 選取目標數字的索引\n    → Step 3.1: 設定 count = 0 // 目前找到目標的個數\n    → Step 3.2: 設定 result = -1 // 預設回傳索引\n    → Step 3.3: 遍歷 nums，索引 i 從 0 到 length-1 // 逐一檢查\n        → Decision: 如果 nums[i] == target? // 判斷是否是目標\n            Yes → Step 3.3.a: count = count + 1 // 累計目標數量\n            → Step 3.3.b: 產生隨機整數 r 介於 1 與 count 之間 // 隨機選擇\n            → Decision: 如果 r == 1? // 是否選中\n                Yes → Step 3.3.c: result = i // 記錄當前索引\n                No → // 不選中，保持 result 不變\n        No → // 若不是目標，跳過\n    → Step 3.4: 回傳 result // 返回最終選取的索引\n→ End // 程式結束\n\nBut we need to use virtual code arrows and structure. Use \"Start\" at beginning and \"End\" at end. Use \"→\" for steps. Decision block with Yes→, No→.\n\nMake sure each line has space between virtual code and comment.\n\nLet's write line by line.\n\nAlso, we need to keep hierarchical indentation? The example uses indentation to show sub-steps. We can use indentation spaces.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 Solution 類別 // 建立類別框架\n    → Step 1.1: 定義屬性 nums // 儲存輸入陣列\n→ End // 類別定義結束\n\nThen constructor:\n\n→ Step 2: Solution(nums) // 建構子方法\n    → Step 2.1: 將 nums 參數複製到物件屬性 this.nums // 初始化陣列\n→ End // 建構子結束\n\nThen pick method:\n\n→ Step 3: pick(target) // 方法開始\n    → Step 3.1: 設 count = 0 // 目標個數統計\n    → Step 3.2: 設 result = -1 // 預設回傳值\n    → Step 3.3: 遍歷 this.nums，索引 i 從 0 到 length-1 // 逐一檢查\n        → Decision: 如果 this.nums[i] == target? // 判斷是否是目標\n            Yes → Step 3.3.a: count = count + 1 // 目標數量增加\n            → Step 3.3.b: r = 隨機整數 1..count // 產生隨機數\n            → Decision: 如果 r == 1? // 選中機率為 1/count\n                Yes → Step 3.3.c: result = i // 記錄當前索引\n                No  → // 不變\n            No  → // 不是目標，跳過\n    → Step 3.4: 回傳 result // 回傳隨機選取的索引\n→ End // 方法結束\n\nFinally End // 程式結束? The Start at top and End at bottom of whole algorithm? Actually earlier example had Start and End only once. But here we have multiple End for class definition, constructor, method. We could keep nested End? The example had nested End for Decision, but only one End for program. Let's use one End at bottom for whole algorithm.\n\nBut we might keep End for class and for method? The instructions: Use \"Start\" and \"End\". The example had Start and End at the outermost. So we should have only outer Start and End. We can include comment lines but keep them inside structure? In example, Decision had No  → Decision inside. So we can use End for each Decision? In example, they didn't have End for Decision, just nested steps. So we will only have outer Start and End. We'll not use End for class or constructor.\n\nThus we should produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 Solution 類別 // 建立類別框架\n    → Step 1.1: 定義屬性 nums // 儲存輸入陣列\n→ Step 2: Solution(nums) // 建構子方法\n    → Step 2.1: 將 nums 參數複製到物件屬性 this.nums // 初始化陣列\n→ Step 3: pick(target) // 方法開始\n    → Step 3.1: 設 count = 0 // 目標個數統計\n    → Step 3.2: 設 result = -1 // 預設回傳值\n    → Step 3.3: 遍歷 this.nums，索引 i 從 0 到 length-1 // 逐一檢查\n        → Decision: 如果 this.nums[i] == target? // 判斷是否是目標\n            Yes → Step 3.3.a: count = count + 1 // 目標數量增加\n            → Step 3.3.b: r = 隨機整數 1..count // 產生隨機數\n            → Decision: 如果 r == 1? // 選中機率為 1/count\n                Yes → Step 3.3.c: result = i // 記錄當前索引\n                No  → // 不變\n            No  → // 不是目標，跳過\n    → Step 3.4: 回傳 result // 回傳隨機選取的索引\nEnd // 程式結束\n\nBut need to maintain indentation spaces? The example uses indentation with spaces and arrow for steps. For Decision, the Yes and No lines are indented. We must replicate.\n\nAlso each line must have a single space between virtual code and comment.\n\nLet's ensure each line has \"→\" at beginning for steps. For Decision we use \"→ Decision:\"? Example had \"→ Decision: 如果數字大於 0?\" Yes. So for Decision, we start with \"→ Decision:\".\n\nThus we write:\n\nStart // 程式開始執行\n→ Step 1: 定義 Solution 類別 // 建立類別框架\n    → Step 1.1: 定義屬性 nums // 儲存輸入陣列\n→ Step 2: Solution(nums) // 建構子方法\n    → Step 2.1: 將 nums 參數複製到物件屬性 this.nums // 初始化陣列\n→ Step 3: pick(target) // 方法開始\n    → Step 3.1: 設 count = 0 // 目標個數統計\n    → Step 3.2: 設 result = -1 // 預設回傳值\n    → Step 3.3: 遍歷 this.nums，索引 i 從 0 到 length-1 // 逐一檢查\n        → Decision: 如果 this.nums[i] == target? // 判斷是否是目標\n            Yes → Step 3.3.a: count = count + 1 // 目標數量增加\n            → Step 3.3.b: r = 隨機整數 1..count // 產生隨機數\n            → Decision: 如果 r == 1? // 選中機率為 1/count\n                Yes → Step 3.3.c: result = i // 記錄當前索引\n                No  → // 不變\n            No  → // 不是目標，跳過\n    → Step 3.4: 回傳 result // 回傳隨機選取的索引\nEnd // 程式結束\n\nCheck formatting: each line has space after virtual code part. Need to include space before comment. Ensure \"Yes →\" and \"No  →\" each have space after arrow? In example, they used \"Yes → Step 2: ...\" with single space after arrow. For No, they used \"No  → Decision: ...\" with double spaces after No to align? Actually they used \"No  → Decision:\" with two spaces between No and arrow. So we replicate that style: \"No  →\" with two spaces between No and arrow. For Yes, one space. For Yes, we used \"Yes →\". For No, we used \"No  →\". Let's replicate for all No lines.\n\nIn Decision block: \"Yes → Step 3.3.a: ...\" and \"No  → // 不是目標，跳過\". Good.\n\nAlso after \"Decision:\" line we have a space before comment. We used \"→ Decision: 如果 this.nums[i] == target? // 判斷是否是目標\". That is fine.\n\nFor Decision lines inside we used \"Yes → Step 3.3.a: ...\" Good.\n\nThe line \"→ Step 3.3.b: r = 隨機整數 1..count // 產生隨機數\" but this is not preceded by a Decision; we need to include arrow before Step 3.3.b? In example they had \"→ Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\". So yes, we need arrow. That line is after Yes arrow but still part of same block. We could just keep arrow before Step 3.3.b.\n\nAlso for the second Decision we used \"→ Decision: 如果 r == 1? // 選中機率為 1/count\". Then Yes and No lines.\n\nEverything seems fine.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 Solution 類別 // 建立類別框架\n    → Step 1.1: 定義屬性 nums // 儲存輸入陣列\n→ Step 2: Solution(nums) // 建構子方法\n    → Step 2.1: 將 nums 參數複製到物件屬性 this.nums // 初始化陣列\n→ Step 3: pick(target) // 方法開始\n    → Step 3.1: 設 count = 0 // 目標個數統計\n    → Step 3.2: 設 result = -1 // 預設回傳值\n    → Step 3.3: 遍歷 this.nums，索引 i 從 0 到 length-1 // 逐一檢查\n        → Decision: 如果 this.nums[i] == target? // 判斷是否是目標\n            Yes → Step 3.3.a: count = count + 1 // 目標數量增加\n            → Step 3.3.b: r = 隨機整數 1..count // 產生隨機數\n            → Decision: 如果 r == 1? // 選中機率為 1/count\n                Yes → Step 3.3.c: result = i // 記錄當前索引\n                No  → // 不變\n            No  → // 不是目標，跳過\n    → Step 3.4: 回傳 result // 回傳隨機選取的索引\nEnd // 程式結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        Return the length of the longest uncommon subsequence among strs.\n        If none exists, return -1.\n        \"\"\"\n        if not strs:\n            return -1\n\n        # Count occurrences of each string\n        counts = Counter(strs)\n        max_len = -1\n\n        for s in strs:\n            if counts[s] == 1:               # s is unique\n                max_len = max(max_len, len(s))\n        return max_len\n\nif __name__ == \"__main__\":\n    # Read the whole input, which should be a JSON array of strings\n    data = sys.stdin.read().strip()\n    if not data:\n        print(-1)\n        sys.exit(0)\n\n    try:\n        strs = json.loads(data)\n    except json.JSONDecodeError:\n        # If input is not valid JSON, treat it as a raw string list separated by commas\n        strs = [s.strip() for s in data.strip('[]').split(',') if s.strip()]\n        strs = [s.strip('\"').strip(\"'\") for s in strs]\n\n    solution = Solution()\n    result = solution.findLUSlength(strs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code (flowchart-like). Steps: Start, check array length, iterate each string, check if unique, find max length. Approach: For each string s in strs: check if it's not a subsequence of any other string? Actually uncommon subsequence defined: string that is a subsequence of one string but not others. We want longest such subsequence. Known solution: if there exists a string that is unique (not equal to any other string), then answer is its length, otherwise -1. Because any subsequence of a string that is not subsequence of others must be the string itself if unique. So algorithm: Count occurrences of each string. For each string, if its count==1, candidate length= len. Take max. If max==0 return -1 else max.\n\nSo produce virtual code accordingly. Provide steps. Use Decision blocks. Provide explanation after each line. Use Start/End. Use arrows. Format.\n\nLet's craft:\n\nStart\n→ Step: Initialize maxLen = -1\n→ Step: Create map count of strings\n→ Decision: For each string s in strs\n    → Step: Increment count[s]\n→ Decision: For each string s in strs\n    → Decision: If count[s] == 1?\n        Yes → Step: Update maxLen = max(maxLen, len(s))\n        No  → Step: Continue\n→ Decision: If maxLen == -1?\n    Yes → Step: Output -1\n    No  → Step: Output maxLen\nEnd\n\nAdd explanations.\n\nAlso maybe handle empty array? If empty, return -1.\n\nAdd Step: If strs empty → output -1.\n\nLet's produce.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step: If strs 為空陣列? // 檢查輸入是否為空\n    Yes → Step: 輸出 -1 // 空陣列無不相同字串，直接回傳 -1\n    No  → Step: 初始化 maxLen 為 -1 // 儲存最大不相同子序列長度\n→ Step: 建立字串計數 map // 用於統計每個字串出現的次數\n→ Decision: 迭代每個字串 s 在 strs 中\n    → Step: map[s] += 1 // 記錄字串出現頻率\n→ Decision: 再次迭代每個字串 s 在 strs 中\n    → Decision: 若 map[s] == 1? // 判斷該字串是否唯一\n        Yes → Step: maxLen = max(maxLen, len(s)) // 更新最大長度\n        No  → Step: 跳過 // 非唯一字串不考慮\n→ Decision: 若 maxLen == -1? // 沒有唯一字串\n    Yes → Step: 輸出 -1 // 無不相同子序列\n    No  → Step: 輸出 maxLen // 輸出最大不相同子序列長度\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Generate all permutations of the list `nums` using backtracking.\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # If we've fixed all positions, record the current permutation.\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                # Swap to place the i-th element at the current start position.\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                # Swap back to restore original order for the next iteration.\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Parse the stdin input which may be in the form:\n        'nums = [1,2,3]'\n    or simply:\n        '[1,2,3]'\n    \"\"\"\n    input_str = input_str.strip()\n    # If the string contains an assignment, extract the part after the first '['\n    if 'nums' in input_str:\n        start = input_str.find('[')\n        end = input_str.rfind(']')\n        if start == -1 or end == -1:\n            raise ValueError(\"Invalid input format\")\n        expr = input_str[start:end + 1]\n    else:\n        expr = input_str\n    # Safely evaluate the list expression\n    return ast.literal_eval(expr)\n\nif __name__ == \"__main__\":\n    # Read all data from stdin\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit(0)\n\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The problem: Given array of distinct integers, return all permutations. Use recursion/backtracking. Provide virtual code lines with step names, decisions etc. We need to adhere to format: each line: virtual code step + space + // explanation. Use arrows →, Yes →, No →. Use Start, End, Decision:. Each step line should be indented for nested steps? Example shows indentation for nested steps: 4 spaces before decision? They used 4 spaces. Use similar.\n\nWe'll produce virtual code:\n\nStart // 程式開始執行\n→ Step 1: 初始化結果列表 result = [] // 用來儲存所有排列\n→ Step 2: 定義遞迴函式 backtrack(current, remaining) // 參數 current: 當前排列, remaining: 未使用數字\n    → Decision: 若 remaining 為空? // 檢查是否已使用完所有數字\n        Yes → Step 3: 將 current 複製並加入 result // 完成一組排列\n        No  → Decision: 遍歷 remaining 中每個元素 idx\n            → Step 4: 選取 idx 為下一個元素\n                → Step 5: 新建 nextCurrent = current + [idx] // 新排列\n                → Step 6: 新建 nextRemaining = remaining 之中除 idx 的子集 // 去除已使用\n                → Step 7: 呼叫 backtrack(nextCurrent, nextRemaining) // 進一步遞迴\n                → Step 8: 迴圈結束\n    → Step 9: 回傳 // 遞迴結束\n→ Step 10: 呼叫 backtrack([], nums) // 開始遞迴\n→ Step 11: 回傳 result // 最終結果\n\nBut we must use virtual code lines with arrow and explanation. Use indentation for nested.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化結果列表 result = [] // 用來儲存所有排列  \n→ Step 2: 定義遞迴函式 backtrack(current, remaining) // current: 當前排列, remaining: 未使用數字  \n  → Decision: 若 remaining 為空? // 檢查是否已使用完所有數字  \n    Yes → Step 3: 將 current 複製並加入 result // 完成一組排列  \n    No  → Decision: 遍歷 remaining 中每個元素 idx // 逐一選取剩餘元素  \n      → Step 4: 選取 idx 為下一個元素  \n       → Step 5: 新建 nextCurrent = current + [idx] // 新排列  \n       → Step 6: 新建 nextRemaining = remaining 之中除 idx 的子集 // 去除已使用  \n       → Step 7: 呼叫 backtrack(nextCurrent, nextRemaining) // 進一步遞迴  \n       → Step 8: 迴圈結束 // 回到 Decision 重新遍歷下一個 idx  \n  → Step 9: 回傳 // 遞迴結束  \n→ Step 10: 呼叫 backtrack([], nums) // 開始遞迴，從空排列與完整數組開始  \n→ Step 11: 回傳 result // 將所有排列返回  \nEnd // 程式執行結束"
    },
    {
      "title": "Text Justification",
      "source_file": "Leetcode/leetcode68.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnf1x9a2_.py\", line 44, in <module>\n    exec(code, globals())\n  File \"<string>\", line 1\n    words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuibj7i6a.py\", line 44, in <module>\n    exec(code, globals())\n  File \"<string>\", line 1\n    words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpygrediyd.py\", line 44, in <module>\n    exec(code, globals())\n  File \"<string>\", line 1\n    words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # Determine how many words fit in the current line\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            line_words = words[i:j]\n            num_words = len(line_words)\n\n            # Last line or line with a single word -> left-justified\n            if j == n or num_words == 1:\n                line = ' '.join(line_words)\n                line += ' ' * (maxWidth - len(line))\n            else:\n                # Fully justify\n                total_spaces = maxWidth - sum(len(w) for w in line_words)\n                gaps = num_words - 1\n                space, extra = divmod(total_spaces, gaps)\n                line = ''\n                for k in range(gaps):\n                    line += line_words[k]\n                    line += ' ' * (space + (1 if k < extra else 0))\n                line += line_words[-1]\n\n            res.append(line)\n            i = j\n\n        return res\n\nif __name__ == \"__main__\":\n    # Read the entire input\n    code = sys.stdin.read()\n    # Execute the input code to obtain words and maxWidth variables\n    exec(code, globals())\n    # Instantiate the solution and compute justification\n    solution = Solution()\n    result = solution.fullJustify(words, maxWidth)\n    # Output the result\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines for text justification algorithm. Provide each line with explanation. Use Start, End, Decision:, Yes →, No →. Use arrows. Provide step by step pseudo-code.\n\nNeed to include loops, conditions, building lines. Avoid actual code. Let's produce.\n\nWe need to pack words greedily: while words left, accumulate words until exceed maxWidth. Then compute spaces, build line accordingly.\n\nImplementation details: maintain index, current line words list, current length. When adding next word length+1 > maxWidth? Then build line.\n\nFor building line: if last line or single word: left justify with single spaces. Else distribute spaces.\n\nReturn list of lines.\n\nLet's produce pseudo steps. Use indentation via arrows? Use format: \"→ Step 1: ...\" etc.\n\nWe'll produce like:\n\nStart\n→ Step 1: 初始化 index=0, lines=[]\n→ Decision: 是否有未處理單詞? // Check if index < words.length\n    Yes → Step 2: 初始化 currentLine=[], numOfChars=0\n    → While index < words.length and numOfChars + words[index].length + currentLine.size() <= maxWidth\n         → Step 3: 將 words[index] 加入 currentLine\n         → Step 4: numOfChars += words[index].length\n         → Step 5: index += 1\n    → Decision: 是否為最後一行? // index == words.length\n        Yes → Step 6: 將 currentLine 用單一空格連結並右填充空格至 maxWidth\n        No  → Decision: currentLine.size()==1? // 只一個單詞\n            Yes → Step 7: 將該單詞後面填充空格至 maxWidth\n            No  → Step 8: 計算 totalSpaces = maxWidth - numOfChars\n            → Step 9: slotCount = currentLine.size() - 1\n            → Step 10: baseSpace = totalSpaces / slotCount\n            → Step 11: extraSpace = totalSpaces % slotCount\n            → Step 12: 初始化 line=\"\"\n            → For each word in currentLine except last\n                 → Step 13: line += word\n                 → Step 14: line += \" \" * (baseSpace + (extraSpace > 0 ? 1 : 0))\n                 → Step 15: if extraSpace>0 then extraSpace -=1\n            → Step 16: line += lastWord\n            → Step 17: 將 line 加入 lines\n    → Decision: 是否還有剩餘單詞? // index < words.length\n        Yes → 回到 Step 2\n        No  → End\nEnd\n\nNeed to ensure formatting with arrow. Also maintain indentation via tabs? Provide as per example.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 index = 0, lines = [] // 設定索引與結果清單  \n→ Decision: 是否還有未處理單詞? (index < words.length) // 判斷是否結束  \n Yes → Step 2: 初始化 currentLine = [], numOfChars = 0 // 開始新一行  \n → While index < words.length 且 numOfChars + words[index].length + currentLine.size() ≤ maxWidth  \n  → Step 3: 把 words[index] 加入 currentLine // 加入下一個單詞  \n  → Step 4: numOfChars += words[index].length // 更新已用字元數  \n  → Step 5: index += 1 // 移動到下一個單詞  \n → Decision: 是否為最後一行? (index == words.length) // 判斷是否是最後一行  \n  Yes → Step 6: 將 currentLine 用單一空格連結並右填充空格至 maxWidth // 左對齊最後一行  \n  No → Decision: currentLine.size() == 1? // 只有一個單詞  \n   Yes → Step 7: 把那個單詞後面填充空格至 maxWidth // 單詞單獨一行  \n   No → Step 8: 計算 totalSpaces = maxWidth - numOfChars // 總空格數  \n   → Step 9: slotCount = currentLine.size() - 1 // 空格插槽數  \n   → Step 10: baseSpace = totalSpaces / slotCount // 每個插槽的基本空格  \n   → Step 11: extraSpace = totalSpaces % slotCount // 需要額外分配的空格  \n   → Step 12: 初始化 line = \"\" // 準備組合最終字串  \n   → For each word 在 currentLine 除最後一個之外  \n    → Step 13: line += word // 加入單詞  \n    → Step 14: line += \" \" * (baseSpace + (extraSpace > 0 ? 1 : 0)) // 加入空格，左側多空格  \n    → Step 15: if extraSpace > 0 then extraSpace -= 1 // 減少剩餘額外空格  \n   → Step 16: line += lastWord // 加入最後一個單詞  \n   → Step 17: 將 line 加入 lines // 完成一行的加入  \n → Decision: 是否還有剩餘單詞? (index < words.length) // 檢查是否結束  \n  Yes → 回到 Step 2 // 重新開始下一行  \n  No → End // 所有單詞已處理，結束程式  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_mdf0b0m.py\", line 64, in <module>\n    main()\n  File \"/tmp/tmp_mdf0b0m.py\", line 47, in main\n    args = ast.literal_eval(lines[1].strip())\n                            ~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport collections\nimport random\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []  # 存放所有元素\n        self.idx_map = collections.defaultdict(set)  # 值 -> 所有索引集合\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入 val，返回是否為首次插入\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"移除一個 val，若存在則返回 True，否則 False\"\"\"\n        if not self.idx_map[val]:\n            return False\n        # 任意取一個索引\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n        # 若不是最後一個元素，替換位置\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n        # 刪除最後一個元素\n        self.data.pop()\n        # 清理空集合\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素\"\"\"\n        return random.choice(self.data)\n\ndef main():\n    lines = sys.stdin.read().strip().splitlines()\n    if not lines:\n        return\n    ops = ast.literal_eval(lines[0].strip())\n    args = ast.literal_eval(lines[1].strip())\n\n    obj = None\n    results = []\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            results.append(None)\n        elif op == \"insert\":\n            results.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            results.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            results.append(obj.getRandom())\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, explaining each. The structure: Start, steps, decisions, End. For RandomizedCollection, operations: insert, remove, getRandom. We'll outline algorithm: maintain a list/vector of values and a map from value to set of indices in the list. For insert: add val to list, record index in map set; return true if value not previously present (i.e., map size changes). Remove: if val not present -> false. Else get an index from its set; remove that index; if index != last index, move last element to that index, update map sets; pop back list. Return true. getRandom: random index from list size. We'll write pseudo steps.\n\nWe must use arrow arrows. Each line: \"→ Step ...\". Provide explanation comment. Use Start, End.\n\nWe should structure methods maybe as separate steps? But output must be line-by-line. We'll produce a generic flow? Maybe present initialization and then operations as subflows? Could present each method's pseudo.\n\nWe'll produce a high-level algorithm, not actual code but pseudo.\n\nLet's produce:\n\nStart\n→ Initialize: list = empty, map = empty // 1. data structures\n→ Define insert(val): // 2. function start\n    → Check if val in map? // 3. existence\n        Yes → Update: add current size index to map[val] // 4. add index\n        No  → Create new set in map[val], add index // 5. create set\n    → Append val to list // 6. store value\n    → Return (val not previously present) // 7. boolean\n→ Define remove(val):\n    → If val not in map or set empty → return false // 8. not found\n    → Retrieve an arbitrary index idx from map[val] // 9. get index\n    → Remove idx from map[val] //10. remove index\n    → If idx != last index in list:\n        → lastVal = list[lastIndex] // 11. get last\n        → list[idx] = lastVal // 12. overwrite\n        → Update map[lastVal]: remove lastIndex, add idx //13. update map\n    → Pop last element from list // 14. shrink\n    → If map[val] empty → delete map[val] // 15. cleanup\n    → Return true // 16. success\n→ Define getRandom():\n    → n = list.size // 17. size\n    → r = random(0, n-1) // 18. random index\n    → return list[r] // 19. return element\nEnd\n\nBut we must produce line-by-line with arrow and comments. Also we can use Decision structure for conditional checks.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 list = [] // 建立空陣列存儲元素\n\n→ Step 2: 初始化 map = {} // 建立空字典存儲值到索引集合\n\n→ Define insert // 定義 insert 方法\n\n    → Decision: 是否存在 key val? // 檢查 val 是否已在 map 中\n        Yes → Step 3: map[val].add(list.size) // 已存在，加入新索引\n        No  → Step 4: map[val] = {list.size} // 新建集合並加入索引\n\n    → Step 5: list.append(val) // 把 val 加到列表尾部\n\n    → Decision: 是否是第一次插入? // 判斷是否為新值\n        Yes → Step 6: return true // 返回 true\n        No  → Step 7: return false // 返回 false\n\n→ Define remove // 定義 remove 方法\n\n    → Decision: 是否存在 key val 且 map[val] 不空? // 檢查 val 是否存在\n        Yes → Step 8: idx = any(map[val]) // 任取一個索引\n            → Step 9: map[val].remove(idx) // 移除該索引\n\n            → Decision: idx == list.size-1? // 是否是最後一個元素\n                No  → Step 10: lastVal = list[list.size-1] // 取最後元素\n                    → Step 11: list[idx] = lastVal // 用最後元素覆蓋 idx\n                    → Step 12: map[lastVal].remove(list.size-1) // 刪除舊索引\n                    → Step 13: map[lastVal].add(idx) // 加入新索引\n\n            → Step 14: list.pop() // 刪除最後元素\n\n            → Decision: map[val] 为空? // 可能需要清理\n                Yes → Step 15: delete map[val] // 刪除空集合\n\n            → Step 16: return true // 成功移除\n\n        No  → Step 17: return false // val 不存在\n\n→ Define getRandom // 定義 getRandom 方法\n\n    → Step 18: n = list.size // 獲取列表長度\n    → Step 19: r = random_int(0, n-1) // 隨機生成索引\n    → Step 20: return list[r] // 返回隨機元素\n\nEnd // 程式執行結束\n\nWe need to match format: each line \"→ ... // ...\". For decision blocks, we must use \"Decision: ...\". Indentation might be represented with spaces. Use \"→\" for steps. Use \"Decision:\" lines, then Yes/No sub-steps with indentation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: list = [] // 建立空陣列存儲所有元素  \n→ Step 2: map = {} // 建立空字典，鍵為值，值為其在 list 中所有索引的集合  \n\nDefine insert // 定義 insert 方法  \n    → Decision: 是否已在 map 中存在鍵 val? // 檢查 val 是否已有出現  \n        Yes → Step 3: map[val].add(list.size) // 已存在，將新索引加入集合  \n        No  → Step 4: map[val] = {list.size} // 新建集合並加入索引  \n    → Step 5: list.append(val) // 把 val 加入 list 的尾部  \n    → Decision: 是否為第一次插入? // 判斷此值是否全新  \n        Yes → Step 6: return true // 先前不存在，返回 true  \n        No  → Step 7: return false // 先前已存在，返回 false  \n\nDefine remove // 定義 remove 方法  \n    → Decision: 是否存在鍵 val 且 map[val] 非空? // 檢查值是否在集合中  \n        Yes → Step 8: idx = any(map[val]) // 任意取得一個索引  \n            → Step 9: map[val].remove(idx) // 移除該索引  \n            → Decision: idx == list.size - 1? // 該索引是否為最後一個元素  \n                No  → Step 10: lastVal = list[list.size - 1] // 取得最後一個元素  \n                    → Step 11: list[idx] = lastVal // 用最後元素覆蓋 idx  \n                    → Step 12: map[lastVal].remove(list.size - 1) // 刪除舊索引  \n                    → Step 13: map[lastVal].add(idx) // 加入新索引  \n            → Step 14: list.pop() // 刪除 list 的最後一個元素  \n            → Decision: map[val] 为空? // 檢查是否需要清理空集合  \n                Yes → Step 15: delete map[val] // 刪除空集合  \n            → Step 16: return true // 成功移除  \n        No  → Step 17: return false // 值不存在，返回 false  \n\nDefine getRandom // 定義 getRandom 方法  \n    → Step 18: n = list.size // 取得 list 長度  \n    → Step 19: r = random_int(0, n - 1) // 隨機生成索引  \n    → Step 20: return list[r] // 返回隨機元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    \"\"\"使用兩個堆來維持中位數，左堆為最大堆，右堆為最小堆。\"\"\"\n    def __init__(self):\n        self.small = []  # max-heap（負值）\n        self.large = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        # 先把數值推入左堆（最大堆）\n        heapq.heappush(self.small, -num)\n\n        # 若左堆頂大於右堆頂，交換兩堆之間的元素以保持順序\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡兩堆大小，左堆最多多一個元素\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 把兩個列表包在一個 JSON 數組裡，方便解析\n    try:\n        commands, args = json.loads(f'[{data}]')\n    except json.JSONDecodeError:\n        # 若輸入格式不符，直接終止\n        return\n\n    result = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MedianFinder\":\n            obj = MedianFinder()\n            result.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(arg[0])\n            result.append(None)\n        elif cmd == \"findMedian\":\n            result.append(obj.findMedian())\n        else:\n            # 若出現未知指令，忽略\n            result.append(None)\n\n    # 用 json.dumps 以 null 代表 None，符合題目要求\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for implementing MedianFinder class with addNum and findMedian. Should use heap approach: maintain two heaps max-heap left and min-heap right. Steps: initialize both. In addNum: decide where to insert. Then balance sizes. In findMedian: if sizes equal, return average of tops. Else return top of larger heap. Provide step-by-step pseudocode with arrows and decisions.\n\nWe need to output per line: \"虛擬碼步驟 // 解釋\".\n\nWe should begin with \"Start\". Use arrows →. For decision, use \"Decision:\" with Yes → and No →. Use indent. Each line should follow format exactly.\n\nLet's craft. Ensure we include class structure. Use Start, then Step: create two heaps. Then addNum steps. Then findMedian steps. End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個優先佇列  \n&nbsp;&nbsp;&nbsp;&nbsp;左佇列 (MaxHeap) 用於儲存較小的一半數值  \n&nbsp;&nbsp;&nbsp;&nbsp;右佇列 (MinHeap) 用於儲存較大的一半數值  \n→ Step 2: 定義 addNum(num) 方法 // 新增一個整數  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: 左佇列是否為空或 num 小於等於 左佇列頂端？  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → 插入 num 到 左佇列 // 使左佇列保持較小數值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Decision: 右佇列是否為空或 num 大於等於 右佇列頂端？  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → 插入 num 到 右佇列 // 使右佇列保持較大數值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → 插入 num 到 左佇列 // 默認分配到左側  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: 左佇列大小是否 > 右佇列大小 + 1？  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → 從 左佇列彈出最大值並插入 右佇列 // 平衡兩側  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: 右佇列大小是否 > 左佇列大小 + 1？  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → 從 右佇列彈出最小值並插入 左佇列 // 平衡兩側  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → // 兩側已平衡，無需操作  \n→ Step 3: 定義 findMedian() 方法 // 回傳目前的中位數  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: 左佇列大小等於 右佇列大小？  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → 回傳 (左佇列頂端 + 右佇列頂端) / 2.0 // 兩側均等，取平均  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: 左佇列大小 > 右佇列大小？  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → 回傳 左佇列頂端 // 左側較大，直接取其頂端  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → 回傳 右佇列頂端 // 右側較大，直接取其頂端  \nEnd // 程式執行結束"
    },
    {
      "title": "K-diff Pairs in an Array",
      "source_file": "Leetcode/leetcode532.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[3,1,4,1,5], 2",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsz_owst5.py\", line 23, in <module>\n    nums = ast.literal_eval(list_part.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4,5], 1",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg03owbhx.py\", line 23, in <module>\n    nums = ast.literal_eval(list_part.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "[1,3,1,5,4], 0",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpux5ehgnm.py\", line 23, in <module>\n    nums = ast.literal_eval(list_part.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef find_pairs(nums, k):\n    \"\"\"Return the number of unique k‑diff pairs in the list `nums`.\"\"\"\n    if k < 0:\n        return 0\n    count = Counter(nums)\n    if k == 0:\n        # Count numbers that appear at least twice\n        return sum(v > 1 for v in count.values())\n    # Count unique pairs (n, n+k)\n    return sum((n + k) in count for n in count)\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Split input into list part and k part\n    list_part, k_part = data.split(',', 1)\n    nums = ast.literal_eval(list_part.strip())\n    k = int(k_part.strip())\n    result = find_pairs(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this algorithm. We must not output real code, just pseudo-code steps with arrows and explanations. We must produce each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: etc. We need to consider steps: maybe sort or use hash map. We'll produce algorithm: use hash map to count frequencies. Then for each unique number, depending on k. If k=0: count numbers with freq>1. Else for each unique number, if num+k exists, count pair. Ensure i!=j automatically. Unique pairs count. So we need to show steps.\n\nLet's produce step list:\n\nStart\n→ Step 1: Build frequency map of nums // Count occurrences\n→ Decision: Is k < 0? // Negative k invalid\n    Yes → Step 2: Return 0 // No pairs possible\n    No  → Decision: Is k == 0? // Special case\n        Yes → Step 3: Initialize count=0 // Count duplicates\n            → For each key in freqMap:\n                → Decision: freq[key] > 1? \n                    Yes → Increment count // duplicate pair\n                    No  → No action\n            → Step 4: Return count // Result\n        No  → Step 5: Initialize count=0\n            → For each key in freqMap:\n                → Decision: key + k exists in freqMap? \n                    Yes → Increment count // unique pair found\n                    No  → No action\n            → Step 6: Return count\nEnd\n\nNeed to ensure each line has arrow and comment. For loops etc we can denote \"→ For each key in freqMap:\" then indented decision. Use indentation like example.\n\nWe need to produce lines, each with \"虛擬碼步驟 // 解釋\". The arrow indicates step. Use Start, End.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: freqMap = Count frequencies of each number in nums // 建立數值頻率表\n→ Decision: k < 0? // k 為負值時無合法對\n    Yes → Step 2: Return 0 // 回傳 0 個對\n    No  → Decision: k == 0? // k 為零的特別情況\n        Yes → Step 3: count = 0 // 初始化計數\n            → For each number num in freqMap:\n                → Decision: freqMap[num] > 1? // 有重複才形成 (x,x) 對\n                    Yes → count = count + 1 // 计入一個對\n                    No  → No action // 無重複不計\n            → Step 4: Return count // 回傳結果\n        No  → Step 5: count = 0 // 初始化計數\n            → For each number num in freqMap:\n                → Decision: (num + k) exists in freqMap? // 若存在則形成一對\n                    Yes → count = count + 1 // 计入一個對\n                    No  → No action\n            → Step 6: Return count // 回傳結果\nEnd // 程式執行結束\n\nCheck formatting: need space after arrow? The example uses arrow after start then space before step. We'll use \"→ Step ...\" same. Indentation: use 4 spaces? Example uses tabs? We can use spaces before Decision lines. Keep structure.\n\nMake sure each line ends with comment after //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: freqMap = Count frequencies of each number in nums // 建立數值頻率表\n→ Decision: k < 0? // k 為負值時無合法對\n    Yes → Step 2: Return 0 // 回傳 0 個對\n    No  → Decision: k == 0? // k 為零的特別情況\n        Yes → Step 3: count = 0 // 初始化計數\n            → For each number num in freqMap:\n                → Decision: freqMap[num] > 1? // 有重複才形成 (x,x) 對\n                    Yes → count = count + 1 // 计入一個對\n                    No  → No action // 無重複不計\n            → Step 4: Return count // 回傳結果\n        No  → Step 5: count = 0 // 初始化計數\n            → For each number num in freqMap:\n                → Decision: (num + k) exists in freqMap? // 若存在則形成一對\n                    Yes → count = count + 1 // 计入一個對\n                    No  → No action\n            → Step 6: Return count // 回傳結果\nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    lines = data.splitlines()\n    module = None\n    results = []\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n        if line.startswith('RangeModule'):\n            module = RangeModule()\n            results.append('null')\n            continue\n        if 'addRange' in line:\n            args = line[line.find('(')+1:line.find(')')].split(',')\n            left, right = int(args[0].strip()), int(args[1].strip())\n            module.addRange(left, right)\n            results.append('null')\n        elif 'removeRange' in line:\n            args = line[line.find('(')+1:line.find(')')].split(',')\n            left, right = int(args[0].strip()), int(args[1].strip())\n            module.removeRange(left, right)\n            results.append('null')\n        elif 'queryRange' in line:\n            args = line[line.find('(')+1:line.find(')')].split(',')\n            left, right = int(args[0].strip()), int(args[1].strip())\n            res = module.queryRange(left, right)\n            results.append('true' if res else 'false')\n        else:\n            # Unknown line, ignore\n            continue\n    output = '[' + ', '.join(results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for a RangeModule data structure. We need to design steps: initialization, addRange, queryRange, removeRange. We need to use virtual code lines with arrow and decision, etc. Must produce line-by-line steps that represent algorithm. Provide explanation after space. Should not output actual code. Let's produce a high-level flow.\n\nWe need to choose internal representation: perhaps balanced BST of intervals. Use e.g., sorted list of non-overlapping intervals. The operations:\n\n- addRange: find overlapping intervals, merge.\n- queryRange: check if [left,right) fully covered by existing intervals.\n- removeRange: split intervals.\n\nWe need to output algorithm steps for each operation. We also might output entire class skeleton: Start, End. Might use separate steps for each method. For each step, we provide explanation.\n\nThe requirement: \"逐行地產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋。\". So each line must have the code step and explanation.\n\nWe need to use arrow and structure as per format.\n\nWe should produce a coherent flow, maybe something like:\n\nStart\n→ Initialize intervals list // list of non-overlapping intervals\n...\nBut we need methods.\n\nMaybe separate sections:\n\nRangeModule // Class definition\n→ Constructor // 初始化\n→ addRange method // ...\nWithin each method, step by step.\n\nAlso need to use Decision: lines for condition checks.\n\nLet's produce:\n\nStart // 程式開始執行\n→ RangeModule // 定義資料結構\n→ Constructor // 初始化 intervals 為空\n→ Method: addRange(left,right)\n  → Find first interval whose end > left\n  → While interval.start < right // 遍歷重疊區間\n      ...\n  → Merge overlapping intervals with [left,right)\n  → Insert merged interval\n→ Method: queryRange(left,right)\n  → Find interval whose end > left\n  → If no such interval or interval.start > left return false\n  → If interval.end < right return false\n  → Return true\n→ Method: removeRange(left,right)\n  → Find first interval whose end > left\n  → While interval.start < right\n      ... split\n  → Adjust intervals accordingly\nEnd\n\nBut each step must be separate line with explanation. Use arrow '→'. For decisions use 'Decision:'. Use 'Yes →', 'No →'.\n\nLet's build step by step.\n\nWe need to include arrows for each operation. Also show decisions.\n\nLet's produce like:\n\nStart // 程式開始執行\n→ RangeModule // 定義 RangeModule 類別\n→ Constructor // 初始化 intervals 為空集合\n    → intervals ← empty list // intervals 儲存非重疊區間\n→ Method addRange(left,right) // 新增區間\n    → idx ← binary search intervals 以尋找 first interval.end >= left\n    → newL ← left // 新區間左端\n    → newR ← right // 新區間右端\n    → While idx < intervals.size() AND intervals[idx].start < right\n        → newL ← min(newL, intervals[idx].start) // 合併左端\n        → newR ← max(newR, intervals[idx].end)   // 合併右端\n        → remove intervals[idx] // 刪除重疊區間\n    → Insert (newL,newR) at idx // 插入合併後區間\n→ Method queryRange(left,right) // 查詢區間是否完全被覆蓋\n    → idx ← binary search intervals 以尋找 first interval.end > left\n    → If idx == intervals.size() OR intervals[idx].start > left\n        → Return false // 左端未被覆蓋\n    → If intervals[idx].end < right\n        → Return false // 右端未被覆蓋\n    → Return true\n→ Method removeRange(left,right) // 移除區間\n    → idx ← binary search intervals 以尋找 first interval.end > left\n    → While idx < intervals.size() AND intervals[idx].start < right\n        → cur ← intervals[idx]\n        → If cur.start < left\n            → Insert (cur.start, left) // 保留左半段\n        → If cur.end > right\n            → Insert (right, cur.end) // 保留右半段\n        → remove intervals[idx] // 刪除原始區間\n        → idx ← idx + 1 // 位置不變，因已插入新區間\n    → End Method\nEnd // 程式結束\n\nBut need to use \"Decision:\" lines where applicable. Maybe at queryRange we can add decision lines.\n\nWe can produce each line accordingly.\n\nLet's produce final answer with correct formatting.\n\nWe must use '→', 'Yes →', 'No →', 'Decision:' etc.\n\nLet's write:\n\nStart // 程式開始執行\n→ RangeModule // 定義 RangeModule 類別\n→ Constructor // 初始化 intervals 為空\n    → intervals ← [] // intervals 儲存非重疊區間\n→ Method addRange(left,right) // 新增區間\n    → idx ← findFirst(intervals, interval.end >= left) // 找到第一個可能重疊的區間\n    → newL ← left\n    → newR ← right\n    → While idx < intervals.size() AND intervals[idx].start < right\n        → newL ← min(newL, intervals[idx].start) // 合併左端\n        → newR ← max(newR, intervals[idx].end)   // 合併右端\n        → remove intervals[idx] // 刪除重疊區間\n    → insert (newL,newR) at idx // 插入合併後區間\n→ Method queryRange(left,right) // 查詢區間是否完全被覆蓋\n    → idx ← findFirst(intervals, interval.end > left) // 找到第一個可能覆蓋左端的區間\n    → Decision: idx == intervals.size() OR intervals[idx].start > left? // 檢查左端是否被覆蓋\n        Yes → Return false // 左端未被覆蓋\n        No  → // 左端被覆蓋，繼續檢查右端\n    → Decision: intervals[idx].end < right? // 檢查右端是否被覆蓋\n        Yes → Return false // 右端未被覆蓋\n        No  → Return true // 完全覆蓋\n→ Method removeRange(left,right) // 移除區間\n    → idx ← findFirst(intervals, interval.end > left) // 找到第一個可能重疊的區間\n    → While idx < intervals.size() AND intervals[idx].start < right\n        → cur ← intervals[idx] // 取得當前區間\n        → Decision: cur.start < left? // 是否需要保留左半段\n            Yes → insert (cur.start, left) // 插入左半段\n            No  → // 無左半段\n        → Decision: cur.end > right? // 是否需要保留右半段\n            Yes → insert (right, cur.end) // 插入右半段\n            No  → // 無右半段\n        → remove cur // 刪除原始區間\n    → End Method\nEnd // 程式結束\n\nWe need to ensure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Also use arrow properly. For nested decisions, maybe use indent. But must follow format. We'll keep same.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ RangeModule // 定義 RangeModule 類別  \n→ Constructor // 初始化 intervals 為空  \n    → intervals ← [] // intervals 儲存非重疊區間  \n\n→ Method addRange(left,right) // 新增區間  \n    → idx ← findFirst(intervals, interval.end ≥ left) // 找到第一個可能重疊的區間  \n    → newL ← left // 初始化合併後區間左端  \n    → newR ← right // 初始化合併後區間右端  \n    → While idx < intervals.size() AND intervals[idx].start < right  \n        → newL ← min(newL, intervals[idx].start) // 合併左端  \n        → newR ← max(newR, intervals[idx].end)   // 合併右端  \n        → remove intervals[idx] // 刪除重疊區間  \n    → insert (newL, newR) at idx // 插入合併後的區間  \n\n→ Method queryRange(left,right) // 查詢區間是否完全被覆蓋  \n    → idx ← findFirst(intervals, interval.end > left) // 找到第一個可能覆蓋左端的區間  \n    → Decision: idx == intervals.size() OR intervals[idx].start > left? // 檢查左端是否被覆蓋  \n        Yes → Return false // 左端未被覆蓋  \n        No  → // 左端被覆蓋，繼續檢查右端  \n    → Decision: intervals[idx].end < right? // 檢查右端是否被覆蓋  \n        Yes → Return false // 右端未被覆蓋  \n        No  → Return true // 完全覆蓋  \n\n→ Method removeRange(left,right) // 移除區間  \n    → idx ← findFirst(intervals, interval.end > left) // 找到第一個可能重疊的區間  \n    → While idx < intervals.size() AND intervals[idx].start < right  \n        → cur ← intervals[idx] // 取得當前區間  \n        → Decision: cur.start < left? // 是否需要保留左半段  \n            Yes → insert (cur.start, left) // 插入左半段  \n            No  → // 無左半段  \n        → Decision: cur.end > right? // 是否需要保留右半段  \n            Yes → insert (right, cur.end) // 插入右半段  \n            No  → // 無右半段  \n        → remove cur // 刪除原始區間  \n    → End Method  \n\nEnd // 程式結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,true,true,false,2,true,true,true,4]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, true, true, true, false, 2, true, true, true, 4]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0\n        self.count = 0\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1 + self.k) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    commands = ast.literal_eval(data[0].strip())\n    args_list = ast.literal_eval(data[1].strip())\n\n    result = []\n    dq = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MyCircularDeque\":\n            dq = MyCircularDeque(args[0])\n            result.append(None)\n        elif cmd == \"insertFront\":\n            res = dq.insertFront(args[0])\n            result.append(res)\n        elif cmd == \"insertLast\":\n            res = dq.insertLast(args[0])\n            result.append(res)\n        elif cmd == \"deleteFront\":\n            res = dq.deleteFront()\n            result.append(res)\n        elif cmd == \"deleteLast\":\n            res = dq.deleteLast()\n            result.append(res)\n        elif cmd == \"getFront\":\n            res = dq.getFront()\n            result.append(res)\n        elif cmd == \"getRear\":\n            res = dq.getRear()\n            result.append(res)\n        elif cmd == \"isEmpty\":\n            res = dq.isEmpty()\n            result.append(res)\n        elif cmd == \"isFull\":\n            res = dq.isFull()\n            result.append(res)\n\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, not actual code. We need to explain each step. The user wants design of circular double-ended queue class with given methods. We'll output step-by-step pseudocode for implementation: define class, constructor with array, head, tail pointers, count, size. Methods: insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Use circular indices. We'll write virtual code lines with arrows. Ensure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use Start, End, Decision. Also need \"→\" arrow. Let's structure: Start class, constructor, methods.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Define Class MyCircularDeque // 宣告類別\n→ Constructor MyCircularDeque(k) // 初始化\n    → Allocate array arr of size k // 建立儲存空間\n    → Set head = 0 // 前端指標\n    → Set tail = 0 // 後端指標\n    → Set size = k // 最大容量\n    → Set count = 0 // 現有元素數\n→ Method insertFront(value)\n    → Decision: if count == size? // 檢查是否已滿\n        Yes → Return False // 已滿無法插入\n        No  → Set head = (head - 1 + size) mod size // 往前移指標\n              → arr[head] = value // 存入值\n              → count++ // 元素數加一\n              → Return True // 成功插入\n→ Method insertLast(value)\n    → Decision: if count == size?\n        Yes → Return False\n        No  → arr[tail] = value\n              → tail = (tail + 1) mod size // 往後移指標\n              → count++\n              → Return True\n→ Method deleteFront()\n    → Decision: if count == 0?\n        Yes → Return False\n        No  → head = (head + 1) mod size // 往後移指標\n              → count--\n              → Return True\n→ Method deleteLast()\n    → Decision: if count == 0?\n        Yes → Return False\n        No  → tail = (tail - 1 + size) mod size // 往前移指標\n              → count--\n              → Return True\n→ Method getFront()\n    → Decision: if count == 0?\n        Yes → Return -1\n        No  → Return arr[head]\n→ Method getRear()\n    → Decision: if count == 0?\n        Yes → Return -1\n        No  → Return arr[(tail - 1 + size) mod size]\n→ Method isEmpty()\n    → Return (count == 0) // 判斷是否空\n→ Method isFull()\n    → Return (count == size) // 判斷是否滿\nEnd // 程式結束\n\nWe must ensure each line includes // explanation. We'll produce step by step. Also need to include arrow for decisions: Use Decision: if... and Yes → ... No → ...\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Class MyCircularDeque // 宣告類別  \n→ Constructor MyCircularDeque(k) // 初始化  \n → Allocate array arr of size k // 建立儲存空間  \n → Set head = 0 // 前端指標初始為 0  \n → Set tail = 0 // 後端指標初始為 0  \n → Set size = k // 最大容量設定  \n → Set count = 0 // 初始時元素數為 0  \n→ Method insertFront(value) // 在前端插入元素  \n → Decision: if count == size? // 檢查是否已滿  \n  Yes → Return False // 已滿無法插入，返回 false  \n  No  → Set head = (head - 1 + size) mod size // 往前移前端指標  \n   → arr[head] = value // 把值存入陣列  \n   → count++ // 元素數增加  \n   → Return True // 成功插入，返回 true  \n→ Method insertLast(value) // 在後端插入元素  \n → Decision: if count == size? // 檢查是否已滿  \n  Yes → Return False // 已滿無法插入，返回 false  \n  No  → arr[tail] = value // 把值存入陣列  \n   → tail = (tail + 1) mod size // 往後移後端指標  \n   → count++ // 元素數增加  \n   → Return True // 成功插入，返回 true  \n→ Method deleteFront() // 從前端刪除元素  \n → Decision: if count == 0? // 檢查是否為空  \n  Yes → Return False // 空的，無法刪除，返回 false  \n  No  → head = (head + 1) mod size // 往後移前端指標  \n   → count-- // 元素數減少  \n   → Return True // 成功刪除，返回 true  \n→ Method deleteLast() // 從後端刪除元素  \n → Decision: if count == 0? // 檢查是否為空  \n  Yes → Return False // 空的，無法刪除，返回 false  \n  No  → tail = (tail - 1 + size) mod size // 往前移後端指標  \n   → count-- // 元素數減少  \n   → Return True // 成功刪除，返回 true  \n→ Method getFront() // 取得前端元素  \n → Decision: if count == 0? // 檢查是否為空  \n  Yes → Return -1 // 空的，返回 -1  \n  No  → Return arr[head] // 回傳前端元素  \n→ Method getRear() // 取得後端元素  \n → Decision: if count == 0? // 檢查是否為空  \n  Yes → Return -1 // 空的，返回 -1  \n  No  → Return arr[(tail - 1 + size) mod size] // 回傳後端元素  \n→ Method isEmpty() // 判斷是否空  \n → Return (count == 0) // 若元素數為 0，返回 true  \n→ Method isFull() // 判斷是否滿  \n → Return (count == size) // 若元素數等於容量，返回 true  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\", \"root/4.txt\"]]'"
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\"]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"Return groups of duplicate file paths based on file content.\"\"\"\n        content_map = defaultdict(list)\n\n        for path in paths:\n            parts = path.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content[:-1]  # remove trailing ')'\n                full_path = f\"{root}/{name}\"\n                content_map[content].append(full_path)\n\n        # Only keep groups that have at least two files\n        return [files for files in content_map.values() if len(files) > 1]\n\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n\n    # The input may look like: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\", ...]\n    # Extract the list expression after '=' if present\n    if raw_input.startswith(\"paths\"):\n        eq_index = raw_input.find(\"=\")\n        if eq_index != -1:\n            raw_input = raw_input[eq_index + 1:].strip()\n\n    # Evaluate the list expression safely (input is controlled by the judge)\n    try:\n        paths = eval(raw_input)\n    except Exception:\n        paths = []\n\n    # Compute duplicate file groups\n    result = Solution().findDuplicate(paths)\n\n    # Output as a JSON array to match the expected format\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code lines for the algorithm: parse paths, group by content, collect duplicates, output groups. Use the required format.\n\nWe need to produce each line with virtual code step and comment. Use arrow, Start, End, Decision.\n\nLet's craft. Outline:\n\nStart\n→ Step 1: 初始化哈希表 contentMap 以存储 content -> list of file paths\n→ Step 2: 遍歷輸入列表 paths\n   → Step 2.1: 用空格分割字符串得到 tokens\n   → Step 2.2: tokens[0] 是 directoryPath\n   → Step 2.3: 循環遍歷 tokens[1:] (fileInfo)\n        → Step 2.3.1: 用 '(' 分割得到 fileName, contentWithParen\n        → Step 2.3.2: 去除最後一個 ')' 取得 content\n        → Step 2.3.3: 組合 fullPath = directoryPath + '/' + fileName\n        → Step 2.3.4: contentMap[content].append(fullPath)\n→ Step 3: 初始化結果列表 result\n→ Step 4: 遍歷 contentMap 的項目\n   → Decision: 如果 len(value) > 1? // 只保留重複\n        Yes → Step 4.1: result.append(value)\n        No  → 步驟忽略\n→ End // 輸出結果\n\nWe should output with each line: \"虛擬碼步驟 // 解釋\". Use arrows for nested lines: indentation maybe. Format example: use indentation or \"    \". They used indentation in example.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 contentMap 為空哈希表，鍵為檔案內容，值為相同內容檔案的完整路徑列表 // 準備分組結構\n→ Step 2: 對輸入列表 paths 中的每一個 directoryInfo 字串進行迭代 // 逐行處理輸入\n    → Step 2.1: 用空白字符分割 directoryInfo 成 tokens // 分離路徑與檔案資訊\n    → Step 2.2: tokens[0] 為 directoryPath // 取得目錄完整路徑\n    → Step 2.3: 對 tokens[1:]（每個檔案資訊）進行迭代 // 逐檔案處理\n        → Step 2.3.1: 用 '(' 分割檔案資訊得到 fileName 與 contentWithParen // 拆解檔案名稱與內容\n        → Step 2.3.2: 去除 contentWithParen 最後一個 ')' 取得 fileContent // 取出純內容\n        → Step 2.3.3: 組合 fullPath = directoryPath + '/' + fileName // 形成完整檔案路徑\n        → Step 2.3.4: 若 contentMap 尚無 fileContent 鍵，則新增空列表；再將 fullPath 加入該列表 // 分組儲存\n→ Step 3: 初始化 result 為空列表 // 用於收集重複檔案群組\n→ Step 4: 對 contentMap 的每一項 key, value 進行迭代 // 檢視每個內容群組\n    → Decision: 如果 len(value) > 1? // 只有重複的才算\n        Yes → Step 4.1: result.append(value) // 加入重複檔案群組\n        No  → // 不重複，忽略\n→ End // 程式執行結束，result 為所有重複檔案路徑的集合"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[1]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[1]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[4,10]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[4, 10]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[4,3,10]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[4, 3, 10]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport random\n\n# Placeholder implementation of rand7()\n# In the real environment this function will be provided.\ndef rand7() -> int:\n    \"\"\"Return a uniform random integer in [1, 7].\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"Return a uniform random integer in [1, 10] using only rand7().\"\"\"\n        while True:\n            # Combine two rand7() calls to get a uniform number in [1, 49]\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:\n                # Map 1~40 to 1~10\n                return 1 + (num - 1) % 10\n\ndef parse_n(input_line: str) -> int:\n    \"\"\"Extract the integer value of n from the input line.\"\"\"\n    match = re.search(r'\\d+', input_line)\n    return int(match.group()) if match else 0\n\ndef main() -> None:\n    # Read the entire input; we only need the first non-empty line\n    input_data = sys.stdin.read()\n    lines = [line.strip() for line in input_data.splitlines() if line.strip()]\n    if not lines:\n        return\n    n = parse_n(lines[0])\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, step-by-step, using arrows and decisions. We need to design rand10() using rand7(). Common solution: use two calls to get 49 outcomes, map 1-40 to 1-10 via modulo, else repeat. Or using rejection sampling.\n\nWe need to output virtual code steps. Each line with arrow or decision. We should produce a structure that explains algorithm. Provide line for Start, Step to get two rand7() calls, combine, check range, map, maybe loop until accepted. End.\n\nUse decision loops. Also mention rejection. Ensure each line has \"虛擬碼步驟 [space] // 解釋\". Format lines as per requirement.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: repeat\n    → Step 2: rand1 ← rand7() // 取得第一個亂數 1-7\n    → Step 3: rand2 ← rand7() // 取得第二個亂數 1-7\n    → Step 4: value ← (rand1 - 1) * 7 + rand2 // 產生 1-49 的組合編號\n    → Decision: 如果 value <= 40? // 只使用 1-40 的值，剩餘 41-49 重新取\n        Yes → Step 5: result ← ((value - 1) mod 10) + 1 // 將 1-40 映射到 1-10\n        No  → Step 6: 跳回 Step 2 // 重新呼叫 rand7() 取得新的組合\n→ Step 7: return result // 回傳隨機 1-10\nEnd // 程式執行結束\n\nBut need to reflect loop; maybe use Decision loop: Decision: 需要重試? Yes → 回到 Step 2. Use a loop arrow. But we can just show as loop inside.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: repeat // 重複直到得到合法值  \n&nbsp;&nbsp;→ Step 2: rand1 ← rand7() // 取得第一個亂數 1-7  \n&nbsp;&nbsp;→ Step 3: rand2 ← rand7() // 取得第二個亂數 1-7  \n&nbsp;&nbsp;→ Step 4: value ← (rand1 - 1) * 7 + rand2 // 產生 1-49 的組合編號  \n&nbsp;&nbsp;→ Decision: 如果 value ≤ 40? // 只使用 1-40 的值，剩餘 41-49 重新取  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: result ← ((value - 1) mod 10) + 1 // 將 1-40 映射到 1-10  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6: 跳回 Step 2 // 重新呼叫 rand7() 取得新的組合  \n→ Step 7: return result // 回傳隨機 1-10  \nEnd // 程式執行結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n        return (\n            dists[0] > 0\n            and dists[0] == dists[1] == dists[2] == dists[3]\n            and dists[4] == dists[5]\n            and dists[4] == 2 * dists[0]\n        )\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(numbers) < 8:\n        print(\"false\")\n        sys.exit(0)\n\n    p1 = [numbers[0], numbers[1]]\n    p2 = [numbers[2], numbers[3]]\n    p3 = [numbers[4], numbers[5]]\n    p4 = [numbers[6], numbers[7]]\n\n    sol = Solution()\n    result = sol.validSquare(p1, p2, p3, p4)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Need to decide algorithm: compute all pairwise distances squared, sort, check first 4 equal >0 and last 4 equal and last = 2*first. Steps: Input 4 points list. Compute distances. Sort. Check.\n\nWe need to produce step-by-step pseudocode lines with explanations. Use Start, Decision etc. Provide arrows. Let's craft:\n\nStart\n→ Step 1: 取 p1,p2,p3,p4 // 取得四點座標\n→ Step 2: 建立空陣列 distances // 用來存距離平方\n→ Step 3: For each unordered pair among four points:\n    → Step 3.1: 計算距離平方 d = (x_i - x_j)^2 + (y_i - y_j)^2\n    → Step 3.2: 將 d 加入 distances\n→ Step 4: 將 distances 排序 // 由小到大\n→ Step 5: Decision: distances[0] == 0? // 是否有重點\n    Yes → Step 5.1: 返回 false // 重點不合法\n    No → Step 5.2: Decision: distances[0] == distances[3]? // 四條邊相等\n        Yes → Step 5.3: Decision: distances[4] == distances[7]? // 四條對角相等\n            Yes → Step 5.4: Decision: distances[4] == 2 * distances[0]? // 對角平方為邊平方*2\n                Yes → Step 5.5: 返回 true // 成立正方形\n                No → Step 5.6: 返回 false\n            No → Step 5.7: 返回 false\n        No → Step 5.8: 返回 false\nEnd\n\nAlso need to mention there are 6 distances? Wait: for 4 points, unordered pairs = 6 distances: 4 sides + 2 diagonals. But the algorithm using 8 distances? That typical algorithm for 4 points uses 6 distances: side repeated 4 times? Actually each side appears once, each diagonal appears once. But if you compute all pairwise distances among 4 points, you get 6 distances: 4 sides + 2 diagonals. Sorting them: first 4 smallest may be sides, last 2 are diagonals. So we need to check that first 4 equal and >0, last 2 equal and equal to 2*first. But there are only 6 distances, not 8. The typical approach: after sorting, check distances[0]==distances[1]==distances[2]==distances[3] >0; distances[4]==distances[5] and distances[4]==2*distances[0].\n\nSo adjust accordingly.\n\nThus steps: compute 6 distances. Sorting. Check first four equal. Check last two equal and double first. Return.\n\nLet's craft virtual code lines accordingly.\n\nAlso need to show arrows: \"→\". For Decision, use indentation. Provide explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得四個點 p1, p2, p3, p4 // 從輸入中取得四點座標  \n→ Step 2: 初始化空陣列 distances // 用來存儲所有點對之間的距離平方  \n→ Step 3: 對每一組不重複的點對 (pi, pj) 進行  \n    → Step 3.1: 計算距離平方 d = (xi - xj)² + (yi - yj)² // 不需要平方根，避免浮點誤差  \n    → Step 3.2: 把 d 加入 distances // 收集所有距離  \n→ Step 4: 將 distances 依升序排序 // 以便比較相等的長度  \n→ Decision: 是否存在距離為 0? // 檢查是否有重複點  \n    Yes → Step 5.1: 回傳 false // 有重點不可能形成正方形  \n    No  → Step 5.2: Decision: distances[0] == distances[3]? // 前四個距離是否相等（四條邊）  \n        Yes → Step 5.3: Decision: distances[4] == distances[5]? // 後兩個距離是否相等（兩條對角線）  \n            Yes → Step 5.4: Decision: distances[4] == 2 * distances[0]? // 對角平方是否為邊平方的兩倍（90°角）  \n                Yes → Step 5.5: 回傳 true // 四邊相等且對角線符合正方形條件  \n                No  → Step 5.6: 回傳 false // 對角線長度不符  \n            No  → Step 5.7: 回傳 false // 對角線長度不相等  \n        No  → Step 5.8: 回傳 false // 四條邊長不相等  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '14'\nGot (Norm):      'Invalidinputformat'\n--- (Raw) ---\nRaw Expected: '14'\nRaw Got:      'Invalid input format'"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '11'\nGot (Norm):      'Invalidinputformat'\n--- (Raw) ---\nRaw Expected: '11'\nRaw Got:      'Invalid input format'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # 不使用任何特價，直接按原價購買\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            # 嘗試每個特價方案\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break  # 不能套用此特價\n                    temp.append(curr_needs[i] - offer[i])\n                else:  # 只在整個 offer 都能套用時執行\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將「變數 = 值」的格式轉換為「變數: 值」的字典字面量\n    data = data.replace('=', ':')\n    data = '{' + data + '}'\n    try:\n        vars_dict = ast.literal_eval(data)\n    except Exception:\n        print(\"Invalid input format\")\n        sys.exit()\n\n    price = vars_dict.get('price')\n    special = vars_dict.get('special')\n    needs = vars_dict.get('needs')\n\n    if price is None or special is None or needs is None:\n        print(\"Missing required variables\")\n        sys.exit()\n\n    solution = Solution()\n    result = solution.shoppingOffers(price, special, needs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for solving the \"Shopping Offers\" problem (LeetCode). We need to produce step-by-step pseudo-code with explanations. Must use Start, Decision, arrow, etc. The user didn't ask for algorithm detail? We should provide algorithm: DFS with memoization/backtracking. So we produce pseudo-code lines: Start, Step 1: define function DFS(remaining). Use memoization map. For each special offer, check if applicable, subtract, recursive. Compute min cost. Return min cost. End.\n\nLet's produce lines with arrows: \"Start // 程式開始執行\", etc.\n\nMake sure to use 虛擬碼步驟 with arrow '→'.\n\nLet's write: Start → Define function dfs(needList) // 递归计算最小费用\n\nWe need to handle memoization: map key string of need list.\n\nAlso need base case: if all zero → 0.\n\nCompute costWithoutSpecial = sum(need[i] * price[i])\n\nFor each offer in specials:\n\nCheck if offer can be applied: for all i: need[i] >= offer[i]\n\nIf yes: newNeed = need[i] - offer[i]; cost = offerPrice + dfs(newNeed)\n\nTake min of cost and costWithoutSpecial.\n\nStore in memo and return.\n\nReturn result of dfs(needs).\n\nAlso need to parse input arrays? Not required, just algorithm.\n\nLet's output as lines.\n\nLet's produce about 20-30 lines.\n\nEnsure each line ends with // 解釋.\n\nAlso need End.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define function dfs(remaining) // 以遞迴方式計算目前未購買物品的最小總價  \n\n→   Decision: 若 all remaining[i] == 0? // 檢查是否已購買所有需要的數量  \n        Yes → Return 0 // 已無剩餘物品，價格為 0  \n        No  →  \n\n→   將 remaining 編碼成 key = join(remaining, ',') // 生成唯一鍵用於 memoization  \n\n→   Decision: 若 key 在 memo 中? // 若已計算過，直接返回已存值  \n        Yes → Return memo[key] // 回傳已緩存的最小價格  \n        No  →  \n\n→   計算不使用任何優惠的價格  \n→   costWithoutOffer = sum(remaining[i] * price[i]) // 直接按原價購買  \n\n→   best = costWithoutOffer // 初始最小價格設為不使用優惠的價格  \n\n→   Loop over each offer in specials  \n→     Decision: 若 offer 可用? // 檢查每項商品的需求是否足以套用此優惠  \n            Yes →  \n                newRemaining[i] = remaining[i] - offer[i] for all i // 取得套用優惠後剩餘需求  \n                offerPrice = offer[n] // 奖励价格是offer数组的最后一个元素  \n                costWithOffer = offerPrice + dfs(newRemaining) // 递归计算套用优惠后的总价  \n                best = min(best, costWithOffer) // 更新最小价格  \n            No  →  \n\n→   memo[key] = best // 将计算结果存入 memo 以备后续查询  \n→   Return best // 返回当前需求下的最小价格  \n\n→ Call result = dfs(needs) // 从原始需求开始计算  \n→ Output result // 返回最低总价  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Subarray Sum Equals K",
      "source_file": "Leetcode/leetcode560.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[1,1,1], k = 2",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6xp1pb_v.py\", line 54, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6xp1pb_v.py\", line 40, in parse_input\n    nums = ast.literal_eval(array_part.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "[1,2,3], k = 3",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4psa88fq.py\", line 54, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4psa88fq.py\", line 40, in parse_input\n    nums = ast.literal_eval(array_part.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subarraySum(self, nums, k):\n        \"\"\"Count subarrays whose sum equals k using prefix sums and a hash map.\"\"\"\n        count = 0\n        prefix_sum = 0\n        sum_map = {0: 1}  # prefix sum 0 occurs once before starting\n\n        for num in nums:\n            prefix_sum += num\n            # If (prefix_sum - k) has been seen, add its frequency to count\n            if prefix_sum - k in sum_map:\n                count += sum_map[prefix_sum - k]\n            # Record the current prefix_sum\n            sum_map[prefix_sum] = sum_map.get(prefix_sum, 0) + 1\n\n        return count\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input formatted like: '[1,1,1], k = 2'\n    Returns a tuple (nums_list, k_value).\n    \"\"\"\n    # Remove any surrounding whitespace\n    data = data.strip()\n    if not data:\n        return [], 0\n\n    # Split into the array part and the k part\n    try:\n        array_part, k_part = data.split(',', 1)\n    except ValueError:\n        # If no comma, assume the entire input is the array and k=0\n        array_part = data\n        k_part = 'k = 0'\n\n    # Parse the list of integers\n    nums = ast.literal_eval(array_part.strip())\n\n    # Parse k value\n    if '=' in k_part:\n        _, k_str = k_part.split('=', 1)\n        k = int(k_str.strip())\n    else:\n        k = int(k_part.strip())\n\n    return nums, k\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.subarraySum(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: count subarrays with sum k. Use hashmap for prefix sums. Steps: Start, read array, read k, init map {0:1}, sum=0, count=0. For each num in nums: sum+=num, if map contains sum-k, add its count to result. Increment map[sum]++. End. Provide explanation each line.\n\nEnsure each line with `虛擬碼步驟` + space + `// 解釋/說明`. Use arrow arrow. Use Start End. Use Decision? Might not need decision. But we can use decision when checking map contains sum-k. Use arrow.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 map ← {0:1} // 用於儲存前綴和出現次數\n→ Step 2: 設定 sum ← 0 // 用於累計目前為止的前綴和\n→ Step 3: 設定 count ← 0 // 用於統計滿足條件的子陣列數量\n→ Step 4: 對每個 num 於 nums 迭代 // 開始遍歷整個陣列\n    → sum ← sum + num // 更新前綴和\n    → Decision: 若 map 包含 key (sum - k)？ // 檢查是否存在符合子陣列和\n        Yes → count ← count + map[sum - k] // 若存在，累加對應次數\n        No → // 不需要任何操作\n    → map[sum] ← map.get(sum, 0) + 1 // 更新前綴和的出現次數\n→ Step 5: 輸出 count // 回傳符合條件的子陣列總數\nEnd // 程式執行結束\n\nMake sure arrow formatting: Use \"→\" before each step, indentation? For decision we may indent. Use arrow inside indentation. Use `→` on same line.\n\nLet's format exactly as required. Use line breaks. Provide explanation after `//`. Ensure each line has space after step? Eg: \"→ Step 1: 設定 map ← {0:1} // 用於儲存前綴和出現次數\".\n\nInclude arrow at start.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 map ← {0:1} // 用於儲存前綴和出現次數  \n→ Step 2: 設定 sum ← 0 // 用於累計目前為止的前綴和  \n→ Step 3: 設定 count ← 0 // 用於統計滿足條件的子陣列數量  \n→ Step 4: 對每個 num 於 nums 迭代 // 開始遍歷整個陣列  \n  → sum ← sum + num // 更新前綴和  \n  → Decision: 若 map 包含 key (sum - k)？ // 檢查是否存在符合子陣列和  \n    Yes → count ← count + map[sum - k] // 若存在，累加對應次數  \n    No → // 不需要任何操作  \n  → map[sum] ← map.get(sum, 0) + 1 // 更新前綴和的出現次數  \n→ Step 5: 輸出 count // 回傳符合條件的子陣列總數  \nEnd // 程式執行結束"
    },
    {
      "title": "Time Based Key-Value Store",
      "source_file": "Leetcode/leetcode981.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsstpubxi.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpsstpubxi.py\", line 30, in main\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 54 (char 53)"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict\nimport bisect\n\nclass TimeMap:\n    def __init__(self):\n        # 每個 key 對應一個按時間排序的清單 (timestamp, value)\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        # 直接把 (timestamp, value) 加到對應 key 的清單尾端\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # bisect_right 找到第一個 timestamp 大於 query 的位置\n        i = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if i == 0:\n            return \"\"\n        return arr[i - 1][1]\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，格式為 [\"op1\", \"op2\", ...], [[arg1], [arg2], ...]\n    ops, args = json.loads(data)\n\n    outputs = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"TimeMap\":\n            obj = TimeMap()\n            outputs.append(None)          # 代表 null\n        elif op == \"set\":\n            key, value, ts = arg\n            obj.set(key, value, ts)\n            outputs.append(None)          # 代表 null\n        elif op == \"get\":\n            key, ts = arg\n            res = obj.get(key, ts)\n            outputs.append(res)\n        else:\n            # 若有其他不常見操作，可擴充處理\n            outputs.append(None)\n\n    # 使用 json.dumps 以 JSON 格式輸出，None 會轉成 null\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing design of TimeMap. Use Start, End, Decision, Step lines with explanation comments. Should reflect storing multiple values per key with timestamps, retrieving latest <= timestamp. Likely use dictionary mapping key to sorted list of (timestamp, value). For set: add pair; for get: binary search or linear search to find <= timestamp. We'll design algorithm. Each line: \"虛擬碼步驟\" + space + \"// explanation\". Use arrow \"→\". Provide steps for initialization, set, get, binary search. Use Decision and loops. Must be line-by-line, no actual code. Let's craft.\n\nOutline:\n\nStart\n→ Step 1: Initialize hash map // map key to list of (timestamp, value)\nDefine class TimeMap\n\nTimeMap()\n    → Step 2: create empty map // holds key->list\n\nset(key, value, timestamp)\n    → Step 3: if key not in map, create empty list // ensure list exists\n    → Step 4: append (timestamp, value) to list // store pair\n\nget(key, timestamp)\n    → Step 5: if key not in map → return \"\" // no values\n    → Step 6: list = map[key] // retrieve list\n    → Step 7: perform binary search to find largest idx with timestamp <= query\n        → Decision: if list empty → return \"\"\n        → Step 8: low = 0, high = length(list)-1\n        → Decision: while low <= high? // binary search loop\n            → Step 9: mid = (low+high)/2\n            → Decision: if list[mid].timestamp <= query? // suitable\n                Yes → record result index = mid; low = mid+1 // look right for larger\n                No  → high = mid-1 // look left\n        → Step 10: if found index else return \"\" // if none found\n        → Step 11: return list[index].value // latest value\n\nEnd\n\nNeed to use arrows.\n\nLet's produce line-by-line. Ensure each line ends with comment.\n\nLet's start.\n\nUse \"Start // 程式開始執行\" etc.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 TimeMap 類別 // 定義時間鍵值資料結構\nTimeMap() // 初始化函式\n    → Step 2: 建立空字典 map // key → 清單 (timestamp, value)\n    → End // 完成初始化\n\nset(key, value, timestamp) // 儲存方法\n    → Step 3: 若 key 不在 map 中, 則 map[key] = 空清單 // 確保有清單可存\n    → Step 4: 在 map[key] 末尾新增 (timestamp, value) // 儲存值與時間戳\n\nget(key, timestamp) // 取得方法\n    → Step 5: 若 key 不在 map 中, 返回 \"\" // 無資料可取\n    → Step 6: list = map[key] // 取得對應清單\n    → Step 7: 若 list 為空, 返回 \"\" // 無值存在\n    → Step 8: low = 0, high = list.size - 1 // 初始搜尋範圍\n    → Decision: low <= high? // 是否還有可搜尋區段？\n        Yes → Step 9: mid = (low + high) / 2 // 取中點\n            → Decision: list[mid].timestamp <= timestamp? // 是否符合時間條件？\n                Yes → Step 10: result = mid; low = mid + 1 // 记录位置并向右搜尋更大時間\n                No  → Step 11: high = mid - 1 // 向左搜尋更小時間\n        No  → Step 12: 若 result 未設定, 返回 \"\" // 沒有小於等於 timestamp 的項目\n        → Step 13: 返回 list[result].value // 取最新符合的值\nEnd // 程式結束\n\nBut we need to keep consistent with format. Each line: \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows '→' only for step lines? Example format shows:\n\nStart // 程式開始執行\n→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\n\nSo each line starts with \"→\" or \"Start\" etc. Indentation can be used for nested but not necessary.\n\nLet's produce full.\n\nWe'll ensure all steps have explanation comments.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 TimeMap 類別 // 定義時間鍵值資料結構  \n→ TimeMap() // 初始化函式  \n  → Step 2: 建立空字典 map // key → 清單 (timestamp, value)  \n  → End // 完成初始化  \n→ set(key, value, timestamp) // 儲存方法  \n  → Step 3: 若 key 不在 map 中, 則 map[key] = 空清單 // 確保有清單可存  \n  → Step 4: 在 map[key] 末尾新增 (timestamp, value) // 儲存值與時間戳  \n→ get(key, timestamp) // 取得方法  \n  → Step 5: 若 key 不在 map 中, 返回 \"\" // 無資料可取  \n  → Step 6: list = map[key] // 取得對應清單  \n  → Step 7: 若 list 為空, 返回 \"\" // 無值存在  \n  → Step 8: low = 0, high = list.size - 1 // 初始搜尋範圍  \n  → Decision: low <= high? // 是否還有可搜尋區段？  \n   Yes → Step 9: mid = (low + high) / 2 // 取中點  \n    → Decision: list[mid].timestamp <= timestamp? // 是否符合時間條件？  \n     Yes → Step 10: result = mid; low = mid + 1 // 記錄位置並向右搜尋更大時間  \n     No  → Step 11: high = mid - 1 // 向左搜尋更小時間  \n   No  → Step 12: 若 result 未設定, 返回 \"\" // 沒有小於等於 timestamp 的項目  \n  → Step 13: 返回 list[result].value // 取最新符合的值  \nEnd // 程式結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"\n        Rearranges nums in-place so that nums[0] < nums[1] > nums[2] < nums[3] ...\n        \"\"\"\n        n = len(nums)\n        for i in range(n - 1):\n            # i is even -> nums[i] should be less than nums[i+1]\n            # i is odd  -> nums[i] should be greater than nums[i+1]\n            if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 == 1 and nums[i] < nums[i + 1]):\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\nif __name__ == \"__main__\":\n    # Read the whole input (e.g., \"nums = [1,5,1,1,6,4]\")\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Try to parse the list from the input\n    try:\n        # If the input contains an assignment, split on '='\n        if '=' in data:\n            _, list_part = data.split('=', 1)\n        else:\n            list_part = data\n        nums = ast.literal_eval(list_part.strip())\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    # Apply wiggle sort\n    Solution().wiggleSort(nums)\n\n    # Output the resulting list\n    print(nums)",
      "virtual_code": "Thinking...\nWe need produce step-by-step virtual code for algorithm that reorders array into wiggle sort. Approach: iterate and if violation, swap with neighbor. For i from 0 to n-2: if (i%2==0 && nums[i] > nums[i+1]) or (i%2==1 && nums[i] < nums[i+1]) then swap. That yields wiggle. Provide lines with Start, End, Decision.\n\nNeed each line with virtual code and explanation.\n\nLet's craft:\n\nStart\n→ Step 1: For i from 0 to length(nums)-2: // 循環遍歷陣列\n    → Decision: i 是偶數? // 判斷索引奇偶\n        Yes → Decision: nums[i] > nums[i+1]? // 偶數位置需小於下一個\n            Yes → Step 2: Swap nums[i] and nums[i+1] // 交換以滿足條件\n            No  → No operation // 已符合條件\n        No  → Decision: nums[i] < nums[i+1]? // 奇數位置需大於下一個\n            Yes → Step 2: Swap nums[i] and nums[i+1] // 交換以滿足條件\n            No  → No operation // 已符合條件\nEnd\n\nNeed to make sure lines formatted each line with \"虛擬碼步驟\" and comment. Use arrow indentation for nested.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: For i from 0 to length(nums)-2: // 循環遍歷陣列  \n  → Decision: i 是偶數? // 判斷索引奇偶  \n    Yes → Decision: nums[i] > nums[i+1]? // 偶數位置應該小於下一個元素  \n      Yes → Step 2: Swap nums[i] and nums[i+1] // 交換以滿足條件  \n      No → No operation // 已符合條件，保持不變  \n    No → Decision: nums[i] < nums[i+1]? // 奇數位置應該大於下一個元素  \n      Yes → Step 2: Swap nums[i] and nums[i+1] // 交換以滿足條件  \n      No → No operation // 已符合條件，保持不變  \nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjtopztuw.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmpjtopztuw.py\", line 45, in main\n    equations, values, queries = parse_input(data)\n                                 ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjtopztuw.py\", line 34, in parse_input\n    raise ValueError(\"Input format not recognized\")\nValueError: Input format not recognized"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpv3swonoh.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmpv3swonoh.py\", line 45, in main\n    equations, values, queries = parse_input(data)\n                                 ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpv3swonoh.py\", line 34, in parse_input\n    raise ValueError(\"Input format not recognized\")\nValueError: Input format not recognized"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpompoop3c.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmpompoop3c.py\", line 45, in main\n    equations, values, queries = parse_input(data)\n                                 ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpompoop3c.py\", line 34, in parse_input\n    raise ValueError(\"Input format not recognized\")\nValueError: Input format not recognized"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict\n\ndef calcEquation(equations, values, queries):\n    graph = defaultdict(dict)\n    for (a, b), val in zip(equations, values):\n        graph[a][b] = val\n        graph[b][a] = 1 / val\n\n    def dfs(src, dst, visited):\n        if src not in graph or dst not in graph:\n            return -1.0\n        if src == dst:\n            return 1.0\n        visited.add(src)\n        for neighbor, weight in graph[src].items():\n            if neighbor not in visited:\n                res = dfs(neighbor, dst, visited)\n                if res != -1.0:\n                    return weight * res\n        return -1.0\n\n    results = []\n    for u, v in queries:\n        results.append(dfs(u, v, set()))\n    return results\n\ndef parse_input(data):\n    pattern = r\"equations\\s*=\\s*(\\[[^\\]]*?\\])\\s*,\\s*values\\s*=\\s*(\\[[^\\]]*?\\])\\s*,\\s*queries\\s*=\\s*(\\[[^\\]]*?\\])\"\n    match = re.search(pattern, data, re.DOTALL)\n    if not match:\n        raise ValueError(\"Input format not recognized\")\n    eq_str, val_str, q_str = match.groups()\n    equations = ast.literal_eval(eq_str)\n    values = ast.literal_eval(val_str)\n    queries = ast.literal_eval(q_str)\n    return equations, values, queries\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    equations, values, queries = parse_input(data)\n    results = calcEquation(equations, values, queries)\n    formatted = \"[\" + \",\".join(f\"{r:.5f}\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving this problem. Steps: Build graph, DFS/BFS queries, handle missing. Provide line-by-line. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立鄰接圖 graph ← 空字典 // 用來存放變數間的除法關係\n→ Decision: 如果 equations 不是空? // 確認是否有給定等式\n    Yes → → Step 2: 對於每一個 (Ai, Bi, values[i]) 進行\n        → Step 3: 在 graph[Ai] 加入 (Bi, values[i]) // Ai / Bi = value\n        → Step 4: 在 graph[Bi] 加入 (Ai, 1 / values[i]) // Bi / Ai = 1/value\n    No  → // 無等式，所有查詢結果為 -1.0\n→ Step 5: 建立 answers ← 空列表 // 儲存所有查詢答案\n→ Step 6: 對於每一個 query (Cj, Dj) 進行\n    → Decision: 如果 Cj 與 Dj 同時在 graph? // 需要兩邊都已定義\n        Yes →\n            → Step 7: 呼叫 DFS(Cj, Dj, 初始乘積=1.0, 已訪問集合) // 開始深度優先搜尋\n                → Decision: DFS 是否找到路徑?\n                    Yes → Step 8: 回傳找到的乘積 // 這即為 Cj / Dj 的值\n                    No  → Step 9: 回傳 -1.0 // 無法連通\n        No  → Step 10: 回傳 -1.0 // 任何一個變數未定義\n    → Step 11: 將 DFS 結果加入 answers\n→ Step 12: 回傳 answers // 回傳所有查詢結果\nEnd // 程式執行結束\n\n// DFS 伺服器（非內部步驟，僅供說明）\n// Function DFS(current, target, product, visited):\n//     若 current == target: 回傳 product\n//     若 current 已在 visited: 回傳 None\n//     加入 current 到 visited\n//     對於每 (neighbor, value) 在 graph[current] 中:\n//         回傳 DFS(neighbor, target, product * value, visited)\n//     回傳 None // 所有路徑均失敗"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        # Union‑Find data structure\n        parent = {}\n\n        def find(x):\n            # 初始化父節點\n            if x not in parent:\n                parent[x] = x\n                return x\n            # 路徑壓縮\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            # 把兩個節點連結\n            root_x, root_y = find(x), find(y)\n            if root_x != root_y:\n                parent[root_y] = root_x\n\n        email_to_name = {}\n\n        # 1. 把同一帳號內的所有 email 連結起來\n        for acc in accounts:\n            name = acc[0]\n            emails = acc[1:]\n            if not emails:\n                continue\n            first_email = emails[0]\n            email_to_name[first_email] = name\n            for email in emails[1:]:\n                email_to_name[email] = name\n                union(first_email, email)\n\n        # 2. 把同一個根的所有 email 收集起來\n        groups = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            groups[root].append(email)\n\n        # 3. 建立結果並排序\n        merged = []\n        for root, em_list in groups.items():\n            name = email_to_name[root]\n            merged.append([name] + sorted(em_list))\n\n        return merged\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 允許輸入類似 \"accounts = [ ... ]\"\n    if raw_input.startswith(\"accounts\"):\n        raw_input = raw_input.split(\"=\", 1)[1].strip()\n\n    try:\n        accounts = ast.literal_eval(raw_input)\n    except Exception as e:\n        # 若無法解析，直接退出\n        print(\"Invalid input format\")\n        return\n\n    sol = Solution()\n    result = sol.accountsMerge(accounts)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code lines for merging accounts as per Leetcode problem 721. Provide step by step. Ensure using arrow notation. Provide each line with explanation. Let's produce structure.\n\nWe'll start with Start. Then iterate through accounts, build email->name mapping and DSU or graph. Use union find.\n\nWe'll produce DSU steps. For each account, union all emails within account. Then build groups mapping root->list of emails. Then produce result.\n\nLet's write lines.\n\nUse arrows.\n\nWill include decisions: none.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 Union-Find 結構 parent, rank 以及 emailToName 映射 // 用來追蹤電子信箱之間的關聯與對應姓名  \n→ Decision: 若 accounts 為空?  \n    Yes → End // 無帳號可處理，直接結束  \n    No  →  \n        → Step 2: 遍歷每個 account in accounts  \n            → Step 3: name ← account[0] // 取得帳號持有人姓名  \n            → Step 4: firstEmail ← account[1] // 取第一個電子信箱作為基準  \n            → Step 5: emailToName[firstEmail] ← name // 記錄姓名對應  \n            → Step 6: 若 firstEmail 未在 parent 中，則 parent[firstEmail] ← firstEmail, rank[firstEmail] ← 0  \n            → Decision: 是否存在其他電子信箱?  \n                Yes →  \n                    → Step 7: 遍歷 account[2:] 的每個 email  \n                        → Step 8: emailToName[email] ← name // 記錄姓名對應  \n                        → Step 9: 若 email 未在 parent 中，則 parent[email] ← email, rank[email] ← 0  \n                        → Step 10: union(firstEmail, email) // 將該帳號內所有電子信箱聯結  \n                No → // 只有一個電子信箱，已在 Step 5 記錄完畢  \n        → Step 11: 建立空字典 rootToEmails // 以根節點為鍵，聚集所有屬於同一個人員的電子信箱  \n        → Step 12: 遍歷 emailToName 的每個 email  \n            → Step 13: root ← find(email) // 找到電子信箱所在的連通分量根  \n            → Step 14: rootToEmails[root].append(email) // 將電子信箱加入對應根的列表  \n        → Step 15: 初始化結果列表 result = []  \n        → Step 16: 遍歷 rootToEmails 的每個 root, emails  \n            → Step 17: sort(emails) // 將電子信箱按字典序排序  \n            → Step 18: name ← emailToName[emails[0]] // 取得此組的姓名  \n            → Step 19: result.append([name] + emails) // 以姓名開頭組裝帳號  \n        → Step 20: Return result // 回傳合併後的帳號列表  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp1k9g7rl.py\", line 54, in <module>\n    beginWord, endWord, wordList = parse_input(raw)\n                                   ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpp1k9g7rl.py\", line 47, in parse_input\n    data = eval('{' + line + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'beginWord' is not defined"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgl2cv4vn.py\", line 54, in <module>\n    beginWord, endWord, wordList = parse_input(raw)\n                                   ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgl2cv4vn.py\", line 47, in parse_input\n    data = eval('{' + line + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'beginWord' is not defined"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        layer = {}\n        layer[beginWord] = 0\n        parents = defaultdict(list)\n\n        queue = deque([beginWord])\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\ndef parse_input(line: str):\n    # 把 input line 轉成字典\n    line = line.strip()\n    line = line.replace('beginWord =', 'beginWord:').replace('endWord =', 'endWord:').replace('wordList =', 'wordList:')\n    data = eval('{' + line + '}')\n    return data['beginWord'], data['endWord'], data['wordList']\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    if not raw.strip():\n        sys.exit()\n    beginWord, endWord, wordList = parse_input(raw)\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code description for the algorithm to find all shortest transformation sequences from beginWord to endWord given wordList. Classic LeetCode problem 126 Word Ladder II. Use BFS to find shortest paths and then DFS/backtracking to build all paths.\n\nWe must produce step-by-step virtual code, each line with explanation. Use arrows etc. Need to adhere to format. Let's craft algorithm.\n\nOutline:\n\nStart\n→ Prepare set wordSet from wordList\n→ If endWord not in wordSet → Return empty list // no path\n\n→ BFS: queue of words, level dict to store distance, parents dict to record predecessors\n\n→ Initialize queue with beginWord\n→ Set level[beginWord] = 0\n→ While queue not empty:\n    → current = queue.pop\n    → For each neighbor of current (change each char to a-z):\n        → If neighbor in wordSet:\n            → If neighbor not in level:\n                → level[neighbor] = level[current] + 1\n                → queue.append(neighbor)\n                → parents[neighbor] = [current]\n            → Else if level[neighbor] == level[current] + 1:\n                → parents[neighbor].append(current)\n\n→ After BFS, if endWord not in level → return []\n\n→ Backtracking DFS from endWord to beginWord using parents to build paths:\n    → Define recursive function backtrack(word, path)\n        → If word == beginWord:\n            → Add reversed path to result\n        → Else:\n            → For each prev in parents[word]:\n                → backtrack(prev, path + [prev])\n\n→ Call backtrack(endWord, [endWord])\n→ Return result\n\nLet's format with arrows:\n\nStart\n→ Initialize wordSet = set(wordList)\n→ Decision: If endWord not in wordSet? // 沒有終點單詞\n    Yes → Step: Return [] // 直接返回空列表\n    No  → ...\n\nThen BFS steps, use decisions inside loops.\n\nWe need to provide step-by-step code lines, not actual code. Use arrow syntax. Provide explanation comments.\n\nLet's produce maybe around 35 lines.\n\nAlso need to handle wordSet removal to avoid revisiting? But level dict handles.\n\nWe can produce steps:\n\nStart\n→ Set result = []\n→ Prepare wordSet\n→ Decision: endWord in wordSet?\n...\nBFS start:\n→ Initialize queue with beginWord\n→ level[beginWord] = 0\n→ parents[beginWord] = [] maybe no parents.\n\nWhile queue not empty:\n→ current = queue.pop(0)\n→ For i from 0 to len(current)-1:\n    → For c from 'a' to 'z':\n        → neighbor = current[:i]+c+current[i+1:]\n        → Decision: neighbor in wordSet?\n            Yes → Decision: neighbor not in level?\n                Yes → level[neighbor] = level[current]+1\n                     queue.append(neighbor)\n                     parents[neighbor] = [current]\n                No → Decision: level[neighbor] == level[current]+1?\n                    Yes → parents[neighbor].append(current)\n                    No → No action\n        → No → Continue\n\nAfter BFS:\n→ Decision: endWord in level?\n    Yes → ...\n    No → Return result\n\nThen DFS:\n→ Define recursive function DFS(word, path)\n    → Decision: word == beginWord?\n        Yes → Add reversed path to result\n        No → For each prev in parents[word]:\n                DFS(prev, [prev]+path)\n→ Call DFS(endWord, [endWord])\n→ Return result\n\nWe need to maintain that path includes current word.\n\nOk produce formatted output. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Set result = [] // 用於儲存所有最短轉換序列  \n→ Prepare wordSet = Set(wordList) // 方便 O(1) 查找  \n\n→ Decision: endWord 是否在 wordSet? // 判斷終點單詞是否存在  \n Yes → End // 若不存在則無路徑，直接結束  \n No  →  \n\n// ---------- BFS：尋找最短距離與前驅關係 ----------\n→ Initialize queue = [beginWord] // BFS 起點  \n→ Set level[beginWord] = 0 // 層級距離  \n→ Initialize parents[beginWord] = [] // 起點無前驅  \n\n→ While queue 非空?  \n Yes →  \n  → current = queue.pop(0) // 取隊列首元素  \n  → For i = 0 to len(current)-1? // 遍歷每個字母位置  \n   Yes →  \n    → For c in 'a' to 'z'? // 嘗試所有字母替換  \n     Yes →  \n      → neighbor = current[:i] + c + current[i+1:] // 產生相鄰單詞  \n      → Decision: neighbor 在 wordSet?  \n       Yes →  \n         Decision: neighbor 尚未被訪問?  \n          Yes →  \n           → level[neighbor] = level[current] + 1 // 記錄距離  \n           → queue.append(neighbor) // 加入 BFS 隊列  \n           → parents[neighbor] = [current] // 初始前驅"
    },
    {
      "title": "Monotone Increasing Digits",
      "source_file": "Leetcode/leetcode738.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "9",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpncmreehz.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpncmreehz.py\", line 31, in main\n    data = sys.stdin.read()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        },
        {
          "example_index": 1,
          "input": "n = 1234",
          "expected_output": "1234",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpv1iuvog_.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpv1iuvog_.py\", line 31, in main\n    data = sys.stdin.read()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        },
        {
          "example_index": 2,
          "input": "n = 332",
          "expected_output": "299",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpc1g0poov.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpc1g0poov.py\", line 31, in main\n    data = sys.stdin.read()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        }
      ],
      "generated_code": "import re\n\nclass Solution:\n    def monotoneIncreasingDigits(self, n: int) -> int:\n        \"\"\"\n        找到不大於 n 且數位單調遞增的最大數字。\n        \"\"\"\n        digits = list(str(n))          # 逐位拆解成字串\n        i = 1\n        # 從左至右尋找第一個遞減位置\n        while i < len(digits) and digits[i] >= digits[i - 1]:\n            i += 1\n\n        # 若存在遞減，需做調整\n        if i < len(digits):\n            # 從遞減點往左回溯，將前一位減 1\n            while i > 0 and digits[i] < digits[i - 1]:\n                digits[i - 1] = str(int(digits[i - 1]) - 1)\n                i -= 1\n            # 後續所有位數設為 9，保持最大\n            for j in range(i + 1, len(digits)):\n                digits[j] = '9'\n\n        return int(''.join(digits))\n\ndef main() -> None:\n    \"\"\"\n    主函式：從標準輸入讀取資料，輸出結果。\n    支援輸入形式如 'n = 10' 或純數字 '10'。\n    \"\"\"\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    # 從輸入中擷取第一個數字\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n\n    # 呼叫解法並輸出結果\n    result = Solution().monotoneIncreasingDigits(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode. The task: given integer n, find largest <= n with monotone increasing digits. Classic Leetcode 738. Approach: iterate digits from left to right, find first where decreasing, then decrement previous digit and set following to 9. Ensure no leading zeros issues.\n\nWe output each line as \"虛擬碼步驟 // 解釋\". Use arrow and structure. Must be step by step. We'll start with Start. Then convert n to string digits list. Then find first decreasing index. Use Decision etc. We can produce pseudo algorithm.\n\nWe should not output actual code but virtual steps.\n\nWe need to produce lines with arrows. Use \"→\" for steps. For decisions use \"Decision:\" with Yes → and No →.\n\nWe'll produce something like:\n\nStart // ...\n→ Step 1: Convert n to string s and get array digits // ...\n→ Step 2: Initialize index i = 1 // ...\n→ Decision: While i < length and digits[i-1] <= digits[i]? // ...\n    Yes → i++ // continue\n    No → set flag at i-1 // break\n\nBut need to find first decreasing. So:\n\n→ Step 3: Find first index i where digits[i] < digits[i-1] // ...\n→ Decision: If none? // No decreasing => return n\n    Yes → Step 4: Return n // already monotone\n    No → proceed\n\nBut we need to handle decrement of digits[i-1] and propagate back if becomes negative etc.\n\nSimpler: scan from left, find first decreasing. Then decrement the previous digit by 1 and set all following digits to 9. But also need to handle cascade: after decrement, check if earlier digits now violate.\n\nSo algorithm: Find first i such that digits[i] < digits[i-1]. While i>0 and digits[i-1]==0? Actually if we decrement digits[i-1], might create new decreasing with digits[i-2]. So we need while loop: decrement digits[i-1], then set digits[j] for j>=i to 9, then check again from i-1 backward.\n\nPseudo:\n\nSet idx = -1\nFor i from 1 to len-1:\n    if digits[i] < digits[i-1]:\n        idx = i\n        break\n\nIf idx == -1: return n\n\n// Decrement at idx-1\ndigits[idx-1] -= 1\n// set following to 9\nfor j from idx to len-1:\n    digits[j] = 9\n\n// Now need to propagate left if any digit becomes negative\ni = idx-1\nwhile i > 0 and digits[i] < digits[i-1]:\n    digits[i-1] -= 1\n    for j from i to len-1:\n        digits[j] = 9\n    i -= 1\n\n// Convert digits back to number, return\n\nOk. Provide each step line.\n\nMake sure to use \"→\" arrow.\n\nWe'll also use Decision and Yes/No arrows.\n\nLet's produce.\n\nAlso need to ensure \"虛擬碼步驟\" includes steps like \"Step 1: ...\" etc.\n\nLet's produce.\n\nWe need to include \"Start // 程式開始執行\".\n\nWe can structure:\n\nStart // 程式開始執行\n→ Step 1: 把 n 轉成字串 s 並拆成數字陣列 digits // 方便逐位操作\n→ Step 2: 設定變數 len = digits.length // 總位數\n→ Step 3: 設定變數 idx = -1 // 用來記錄第一個遞減位置\n→ Decision: 遍歷 i 從 1 到 len-1 是否存在 digits[i] < digits[i-1]？ // 判斷是否有遞減\n    Yes → Step 4: 把 idx 設為 i 並停止遍歷 // 找到遞減點\n    No  → Step 5: 迴圈結束 // 仍然沒有遞減\n→ Decision: idx == -1? // 若沒有遞減，數字已經單調\n    Yes → Step 6: 直接返回 n // 最高可用數字就是 n 本身\n    No  → Step 7: 進行遞減處理 // 接下來要調整數字\n\nWe can continue steps after that.\n\nBut need to handle loops.\n\nWe can include a loop with arrow maybe.\n\nWe can describe the process: decrement digits[idx-1], set following to 9, then propagate left.\n\nWe'll structure:\n\n→ Step 8: 把 digits[idx-1] 減 1 // 縮小數字\n→ Step 9: 將從 idx 到 len-1 的所有 digits 設為 9 // 使後續位數最大\n→ Step 10: 設定 i = idx-1 // 用於向左傳遞\n→ Decision: i > 0 且 digits[i] < digits[i-1]? // 檢查前一位是否還遞減\n    Yes → Step 11: 把 digits[i-1] 減 1 // 再次縮小\n    → Step 12: 將從 i 到 len-1 的所有 digits 設為 9 // 重新填滿 9\n    → Step 13: i -= 1 // 繼續往左\n    No  → End of loop // no further adjustment\n\nAfter loop:\n\n→ Step 14: 將 digits 陣列轉回整數 result // 重新組合\n→ Step 15: 返回 result // 最終答案\n\nWe'll mark End after return.\n\nWe must use \"End // 程式執行結束\" at the end.\n\nAlso include arrow lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 把 n 轉成字串 s 並拆成數字陣列 digits // 方便逐位操作  \n→ Step 2: 設定變數 len = digits.length // 總位數  \n→ Step 3: 設定變數 idx = -1 // 用來記錄第一個遞減位置  \n→ Decision: 是否存在 i（1 ≤ i < len）使得 digits[i] < digits[i-1]? // 判斷是否有遞減  \n Yes → Step 4: 把 idx 設為 i 並停止遍歷 // 找到遞減點  \n No  → Step 5: 迴圈結束 // 仍然沒有遞減  \n→ Decision: idx == -1? // 若沒有遞減，數字已經單調  \n Yes → Step 6: 直接返回 n // 最高可用數字就是 n 本身  \n No  → Step 7: 進行遞減處理 // 接下來要調整數字  \n→ Step 8: 把 digits[idx-1] 減 1 // 縮小數字至前一位  \n→ Step 9: 將從 idx 到 len-1 的所有 digits 設為 9 // 使後續位數最大  \n→ Step 10: 設定 i = idx-1 // 用於向左傳遞  \n→ Decision: i > 0 且 digits[i] < digits[i-1]? // 檢查前一位是否還遞減  \n Yes → Step 11: 把 digits[i-1] 減 1 // 再次縮小  \n  → Step 12: 將從 i 到 len-1 的所有 digits 設為 9 // 重新填滿 9  \n  → Step 13: i -= 1 // 繼續往左  \n  → Decision: i > 0 且 digits[i] < digits[i-1]? // 重新檢查  \n   Yes → (重複 Step 11-13)  \n   No  → Exit loop // 無需進一步調整  \n No  → Exit loop // 前一位已經符合 monotone  \n→ Step 14: 將 digits 陣列轉回整數 result // 重新組合數字  \n→ Step 15: 返回 result // 最終答案  \nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar I",
      "source_file": "Leetcode/leetcode729.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg5130rro.py\", line 58, in <module>\n    main()\n  File \"/tmp/tmpg5130rro.py\", line 35, in main\n    methods = ast.literal_eval(methods_str)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MyCalendar\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MyCalendar:\n    \"\"\"\n    MyCalendar 使用一個簡單的列表來保存已經成功預約的事件。\n    每次 book 時先檢查新事件是否與已有事件有重疊，\n    若無重疊則加入列表並回傳 True，否則回傳 False。\n    \"\"\"\n    def __init__(self):\n        self.bookings = []\n\n    def book(self, start: int, end: int) -> bool:\n        for s, e in self.bookings:\n            # 判斷兩個半開區間是否有交集\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\ndef main():\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 把輸入拆成兩個列表：方法名和對應參數\n    # 這裡假設輸入格式為 [\"method1\", ...], [params1, ...]\n    try:\n        methods_str, params_str = raw.split(', ', 1)\n    except ValueError:\n        # 如果中間沒有空格則再嘗試不帶空格的分隔\n        methods_str, params_str = raw.split(',', 1)\n    methods = ast.literal_eval(methods_str)\n    params = ast.literal_eval(params_str)\n\n    # 執行方法並收集結果\n    result = []\n    obj = None\n    for method, param in zip(methods, params):\n        if method == \"MyCalendar\":\n            obj = MyCalendar()\n            result.append(None)  # constructor 返回 null\n        else:\n            if method == \"book\":\n                # book 的參數是一個兩元素列表 [start, end]\n                res = obj.book(param[0], param[1])\n                result.append(res)\n            else:\n                # 若未定義的其他方法，直接 None\n                result.append(None)\n\n    # 輸出結果，使用 json.dumps 以得到與題目示例相同的格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation for MyCalendar implementation. Probably use binary tree or list. Provide steps for initialization and book logic. Let's produce simple sorted list, then check overlaps. Provide algorithm steps.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 MyCalendar // 建立一個空的事件集合\n    → SubStep: events ← 空清單 // 用來存放已經成功預訂的 [start, end) 事件\n→ End // 初始化完成\n\n→ Step 2: 定義 book(startTime, endTime) 方法 // 接收一個新事件的起始與結束時間\n    → Decision: 檢查新事件是否與已存在事件重疊？ // 只要有一個已預訂事件與新事件有交集，即為 double booking\n        → SubDecision: 依序遍歷 events 中的每個 (s, e)\n            → Decision: 如果 startTime < e 且 endTime > s? // 判斷兩個半開區間是否有重疊\n                → Yes → Step 3: 回傳 false // 重疊，不能加入\n                → No  → 續迴到下一個事件\n        → No → Step 4: events ← events ∪ {(startTime, endTime)} // 沒有重疊，加入事件集合\n            → Step 5: 回傳 true // 成功預訂\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[None,0,4,4,1,1,0,6]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[None, 0, 4, 4, 1, 1, 0, 6]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)        # number of allowed values\n        black_set = set(blacklist)\n        last = n - 1                          # candidate for mapping target\n        for b in blacklist:\n            if b < self.size:                 # only those below size need mapping\n                while last in black_set:      # find a valid target\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        index = random.randint(0, self.size - 1)\n        return self.mapping.get(index, index)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        sys.exit()\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    instance = None\n    outputs = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            instance = Solution(*args)\n            outputs.append(None)\n        elif cmd == \"pick\":\n            outputs.append(instance.pick())\n        else:\n            # 若有其他方法，可按需處理\n            outputs.append(None)\n\n    print(outputs)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: known solution mapping technique: Use mapping of blacklisted numbers that are in allowed range to allowed numbers in high range. Use random index from 0 to M-1 (M = n - len(blacklist)). Preprocess: create set of blacklisted numbers < M. For each such number, map it to some number >= M that is not blacklisted. Use dictionary mapping.\n\nThen pick: r = random_int(0, M-1); if r in mapping: return mapping[r] else return r.\n\nWe'll output virtual steps. Each line with virtual code step and comment.\n\nLet's craft step-by-step:\n\nStart\n→ Step 1: Initialize n, blacklist, calculate M = n - len(blacklist) // Determine number of allowed values\n→ Step 2: Create empty set low_blacklist // blacklisted numbers that are less than M\n→ Step 3: For each b in blacklist:\n    → Decision: If b < M?\n        Yes → Add b to low_blacklist // keep for mapping\n        No  → Continue // ignore, not needed\n→ Step 4: Create empty set high_candidates // numbers >= M not in blacklist\n→ Step 5: For each i from M to n-1:\n    → Decision: If i not in blacklist?\n        Yes → Add i to high_candidates // possible mapping targets\n→ Step 6: Create empty map // mapping from low blacklisted to high candidate\n→ Step 7: Create iterator over high_candidates\n→ Step 8: For each b in low_blacklist:\n    → Get next candidate c from iterator\n    → Map[b] = c // map low blacklisted number to a valid high number\n→ Step 9: Define function pick():\n    → Step 9a: r = random_int(0, M-1) // random index in allowed range\n    → Step 9b: Decision: If r in map?\n        Yes → Return map[r] // mapped to valid number\n        No  → Return r // number is already valid\nEnd\n\nNeed to produce lines accordingly. Use arrows and Decision blocks.\n\nLet's output each line.\n\nWe'll include indentation maybe but each line separate. Use \"→\" for arrow.\n\nMake sure each line ends with comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 n 與 blacklist，計算 M = n - blacklist.length // 取得可用數字的個數  \n→ Step 2: 建立空集合 low_blacklist // 用於存放小於 M 的被列入黑名單的數字  \n→ Step 3: 對於 blacklist 中的每個 b  \n  Decision: 如果 b < M? // 判斷黑名單數字是否落在可用範圍內  \n   Yes → low_blacklist.add(b) // 存入待映射集合  \n   No  → Continue // 其餘數字不需要處理  \n→ Step 4: 建立空集合 high_candidates // 用於存放大於等於 M 且不在黑名單的數字  \n→ Step 5: 對 i 從 M 到 n-1  \n  Decision: 如果 i 不在 blacklist? // 判斷是否可作為映射目標  \n   Yes → high_candidates.add(i) // 加入候選集合  \n   No  → Continue  \n→ Step 6: 建立空映射 map // 存放 low_blacklist 與 high_candidates 的對應關係  \n→ Step 7: 建立 high_candidates 的迭代器 it  \n→ Step 8: 對 low_blacklist 中的每個 b  \n  c = it.next() // 取得下一個可用高位數字  \n  map[b] = c // 建立映射  \n→ Step 9: 定義函式 pick()  \n  Step 9a: r = random_int(0, M-1) // 隨機選取一個索引  \n  Decision: 如果 r 在 map? // 判斷此索引是否被映射  \n   Yes → Return map[r] // 返還映射後的合法數字  \n   No  → Return r // 直接返還合法數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.017873306199522224,-0.651619740823795],[-0.5642450820276618,0.7794939002364103],[0.9430619533259234,-0.09505766915192862]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.017873306199522224, -0.651619740823795], [-0.5642450820276618, 0.7794939002364103], [0.9430619533259234, -0.09505766915192862]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().splitlines()\n    if len(data) < 2:\n        sys.exit()\n    commands = json.loads(data[0])\n    arguments = json.loads(data[1])\n\n    instance = None\n    results = []\n\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"Solution\":\n            instance = Solution(*args)\n            results.append(None)\n        else:\n            method = getattr(instance, cmd)\n            results.append(method(*args))\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode with explanation line by line. Requirements: Use arrows, decision, start, end. Use simple pseudocode steps.\n\nWe need to implement a class Solution with constructor and method randPoint.\n\nThe random point inside circle: use rejection sampling or polar coordinates. Use polar: generate r = sqrt(random() * radius^2), theta=random()*2π, then x=x_center + r*cosθ, y=y_center + r*sinθ.\n\nSo pseudocode: Start, initialize radius, x_center, y_center. Then randPoint: generate uniform random number u1, u2. Compute r, theta. Compute x,y. Return [x,y]. End.\n\nWe need to output step by step. Use virtual code lines: \"Start\", \"→ Step: initialize\", etc. Use \"Decision\" maybe not needed. But we can include if conditions. But simple.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取 radius, x_center, y_center // 建構子接收參數\n→ Step 2: 儲存 radius, x_center, y_center 作為物件屬性 // 用於之後的隨機點產生\n→ End // 建構子結束\n\nNow method randPoint:\nStart // 進入 randPoint 方法\n→ Step 3: 產生 u1 = random() // 產生 0~1 之間的隨機數\n→ Step 4: 產生 u2 = random() // 第二個隨機數用於角度\n→ Step 5: 計算 r = sqrt(u1) * radius // 取得半徑範圍內的隨機半徑\n→ Step 6: 計算 theta = u2 * 2π // 取得隨機角度\n→ Step 7: 計算 x = x_center + r * cos(theta) // 將極座標轉為直角座標\n→ Step 8: 計算 y = y_center + r * sin(theta) // 同上\n→ Step 9: 回傳 [x, y] // 產生的隨機點\nEnd // randPoint 結束\n\nAlso mention rejection? But not needed.\n\nWe need to use virtual code with arrows, maybe Decision: but not needed. But we can show a decision for checking if random() returned? Not necessary.\n\nThus produce lines exactly as required: each line \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建構子(Solution)接收參數 radius, x_center, y_center // 取得圓半徑及中心座標  \n→ Step 2: 儲存 radius, x_center, y_center 為物件屬性 // 方便後續隨機點計算  \n→ End // 建構子結束  \n\nStart // 進入 randPoint 方法  \n→ Step 3: 產生 u1 = random() // 取得 0~1 的隨機數，作為半徑分布的比例  \n→ Step 4: 產生 u2 = random() // 取得 0~1 的隨機數，作為角度的比例  \n→ Step 5: 計算 r = sqrt(u1) * radius // 透過 sqrt 使半徑分布均勻  \n→ Step 6: 計算 theta = u2 * 2π // 產生 0~2π 的隨機角度  \n→ Step 7: 計算 x = x_center + r * cos(theta) // 極座標轉直角座標 (x)  \n→ Step 8: 計算 y = y_center + r * sin(theta) // 極座標轉直角座標 (y)  \n→ Step 9: 回傳 [x, y] // 輸出隨機點的座標  \nEnd // randPoint 結束"
    },
    {
      "title": "Count Different Palindromic Subsequences",
      "source_file": "Leetcode/leetcode730.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '7'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '7'"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '104860361'\nGot (Norm):      '104860362'\n--- (Raw) ---\nRaw Expected: '104860361'\nRaw Got:      '104860362'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # dp[i][j] : number of distinct palindromic subsequences in s[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    # next_pos[char][i] : next occurrence of char at or after position i\n    # prev_pos[char][i] : previous occurrence of char at or before position i\n    next_pos = [[-1] * n for _ in range(26)]\n    prev_pos = [[-1] * n for _ in range(26)]\n\n    # Compute next_pos from right to left\n    for c in range(26):\n        nxt = -1\n        for i in range(n - 1, -1, -1):\n            if ord(s[i]) - 97 == c:\n                nxt = i\n            next_pos[c][i] = nxt\n\n    # Compute prev_pos from left to right\n    for c in range(26):\n        prv = -1\n        for i in range(n):\n            if ord(s[i]) - 97 == c:\n                prv = i\n            prev_pos[c][i] = prv\n\n    # Initialize dp for single characters\n    for i in range(n):\n        dp[i][i] = 1\n\n    # DP for longer substrings\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] != s[j]:\n                dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]) % MOD\n            else:\n                c = ord(s[i]) - 97\n                # Find next occurrence after i\n                left = next_pos[c][i + 1] if i + 1 < n else n\n                if left == -1:\n                    left = n\n                # Find previous occurrence before j\n                right = prev_pos[c][j - 1] if j - 1 >= 0 else -1\n                if right == -1:\n                    right = -1\n\n                if left > right:          # No same char inside\n                    dp[i][j] = (dp[i + 1][j - 1] * 2 + 2) % MOD\n                elif left == right:       # Exactly one same char inside\n                    dp[i][j] = (dp[i + 1][j - 1] * 2 + 1) % MOD\n                else:                     # At least two same chars inside\n                    dp[i][j] = (dp[i + 1][j - 1] * 2 - dp[left + 1][right - 1]) % MOD\n\n            dp[i][j] %= MOD\n\n    return dp[0][n - 1] % MOD\n\ndef main():\n    data = sys.stdin.read()\n    # Extract only alphabetic characters (handles inputs like s = \"bccb\")\n    s = ''.join(re.findall('[a-zA-Z]', data))\n    result = count_palindromic_subsequences(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines that implement solution for counting distinct non-empty palindromic subsequences in string s. Classic DP with dp[i][j] number of distinct palindromic subseqs in s[i..j]. Use recurrence with next and prev arrays. We need to produce virtual code steps line by line with explanation, no actual code. Should be algorithm description.\n\nWe'll structure steps: Start, read s, define n, mod, next/prev arrays, dp array. Then compute next occurrence of each char from left, prev from right. Then iterate length from 1..n, compute dp[i][j]. Provide transitions. At the end output dp[0][n-1] mod.\n\nUse virtual code lines: Start // etc. Use arrows.\n\nLet's craft lines:\n\nStart\n→ Step 1: 讀取輸入字串 s // 獲取待處理字串\n→ Step 2: 設定 n = s.length // 字串長度\n→ Step 3: 定義 MOD = 1_000_000_007 // 結果取模\n→ Step 4: 初始化 2D 陣列 dp[n][n] // dp[i][j] 代表 s[i..j] 的不同回文子序數量\n→ Step 5: 初始化 陣列 next[26][n] // 每個位置右側最近一次出現的字母\n→ Step 6: 初始化 陣列 prev[26][n] // 每個位置左側最近一次出現的字母\n→ Step 7: 計算 next 陣列，從右向左掃描字串\n    → For i from n-1 downto 0\n        → For each ch 0..25\n            → If s[i] == ch\n                → next[ch][i] = i\n                → 否則 next[ch][i] = next[ch][i+1] // 將右側最近位置傳遞下來\n→ Step 8: 計算 prev 陣列，從左向右掃描字串\n    → For i from 0 to n-1\n        → For each ch 0..25\n            → If s[i] == ch\n                → prev[ch][i] = i\n                → 否則 prev[ch][i] = prev[ch][i-1] // 將左側最近位置傳遞下來\n→ Step 9: 對所有單一字符子串初始化 dp[i][i] = 1 // 每個字符本身是一個回文子序\n→ Step 10: 循環子串長度 len 從 2 到 n\n    → For i from 0 to n-len\n        → 設定 j = i + len - 1 // 子串結束位置\n        → 若 s[i] != s[j]\n            → Yes → dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]) mod MOD\n        → 否則 // s[i] == s[j]\n            → 設定 left = next[s[i]][i+1] // 第一次在右側出現的同一字母\n            → 設定 right = prev[s[j]][j-1] // 最後一次在左側出現的同一字母\n            → 若 left > right // 兩端字母之間沒有相同字母\n                → Yes → dp[i][j] = (dp[i+1][j-1] * 2 + 2) mod MOD\n            → 否若 left == right // 兩端字母之間恰好有一個相同字母\n                → Yes → dp[i][j] = (dp[i+1][j-1] * 2 + 1) mod MOD\n            → 否 // 兩端字母之間至少有兩個相同字母\n                → Yes → dp[i][j] = (dp[i+1][j-1] * 2 - dp[left+1][right-1]) mod MOD\n→ Step 11: 輸出 dp[0][n-1] mod MOD // 最終答案\nEnd\n\nWe need to produce lines with \"→\" each step. Indentation for nested decisions.\n\nWe need to use \"Decision:\" lines? They used for if-else. Let's mimic style:\n\n→ Decision: 如果 s[i] != s[j]? // 判斷左右兩端是否不同\n    Yes → ... else No → ...\n\nAlso for left>right etc.\n\nLet's create detailed virtual code accordingly.\n\nMake sure each line ends with comment explaining. Use mod operation with addition/subtraction and adjustment to keep positive.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 s // 獲取待處理字串\n→ Step 2: 設定 n = s.length // 字串長度\n→ Step 3: 定義 MOD = 1_000_000_007 // 結果取模\n→ Step 4: 初始化 2D 陣列 dp[n][n] // dp[i][j] 代表 s[i..j] 的不同回文子序數量\n→ Step 5: 初始化 陣列 next[26][n] // 每個位置右側最近一次出現的字母\n→ Step 6: 初始化 陣列 prev[26][n] // 每個位置左側最近一次出現的字母\n→ Step 7: 計算 next 陣列，從右向左掃描字串\n    → For i from n-1 downto 0\n        → For ch from 0 to 25\n            → Decision: 如果 s[i] == ch?\n                Yes → next[ch][i] = i // 設置本位置為最近位置\n                No  → Decision: 如果 i+1 < n?\n                    Yes → next[ch][i] = next[ch][i+1] // 取右側最近位置\n                    No  → next[ch][i] = -1 // 無後續位置\n→ Step 8: 計算 prev 陣列，從左向右掃描字串\n    → For i from 0 to n-1\n        → For ch from 0 to 25\n            → Decision: 如果 s[i] == ch?\n                Yes → prev[ch][i] = i // 設置本位置為最近位置\n                No  → Decision: 如果 i-1 >= 0?\n                    Yes → prev[ch][i] = prev[ch][i-1] // 取左側最近位置\n                    No  → prev[ch][i] = -1 // 無前置位置\n→ Step 9: 初始化單字符子串\n    → For i from 0 to n-1\n        → dp[i][i] = 1 // 每個字符本身是一個回文子序\n→ Step 10: 計算長度遞增的子串\n    → For len from 2 to n\n        → For i from 0 to n-len\n            → 設定 j = i + len - 1 // 子串結束位置\n            → Decision: 如果 s[i] != s[j]?\n                Yes → dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]) mod MOD\n                No  → Decision: 設定 left = next[ s[i] ][i+1]\n                           設定 right = prev[ s[j] ][j-1]\n                           Decision: 如果 left > right?\n                               Yes → dp[i][j] = (dp[i+1][j-1] * 2 + 2) mod MOD // 兩端字母之間沒有相同字母\n                               No  → Decision: 如果 left == right?\n                                   Yes → dp[i][j] = (dp[i+1][j-1] * 2 + 1) mod MOD // 恰好一個相同字母\n                                   No  → dp[i][j] = (dp[i+1][j-1] * 2 - dp[left+1][right-1]) mod MOD // 至少兩個相同字母\n→ Step 11: 輸出答案\n    → result = dp[0][n-1] mod MOD\n    → 輸出 result // 最終答案\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [3,2,2,3], val = 3",
          "expected_output": "2, nums = [2,2,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2,nums=[2,2,_,_]'\nGot (Norm):      '2,nums=[2,2,\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '2, nums = [2,2,_,_]'\nRaw Got:      \"2, nums = [2, 2, '_', '_']\""
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,3,0,4,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,3,0,4,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,\"_\",\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,3,0,4,_,_,_]'\nRaw Got:      \"5, nums = [0, 1, 3, 0, 4, '_', '_', '_']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        移除 nums 中所有等於 val 的元素，並在原地返回新長度 k。\n        \"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 從輸入中提取 nums 列表\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    nums_str = nums_match.group(1) if nums_match else '[]'\n    # 從輸入中提取 val 整數\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n    val = int(val_match.group(1)) if val_match else 0\n\n    # 評估列表字串得到實際數字列表\n    nums = eval(nums_str)\n\n    # 執行移除操作\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # 準備輸出：前 k 個元素為有效值，其餘用 '_' 表示\n    display = nums[:k] + ['_'] * (len(nums) - k)\n\n    # 輸出結果，格式符合範例\n    print(f\"{k}, nums = {display}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines for algorithm to remove element in-place. Provide explanation. Use arrows, Decision etc.\n\nWe should include Start, End. Also need to maintain in-place: typical two-pointer approach: fast pointer iterate over array, slow pointer indicates next position to write. For each element not equal to val, write at slow and increment slow.\n\nLet's craft step-by-step:\n\nStart\n→ Step 1: 初始化 slow = 0 // 用於寫入非 val 的元素位置\n→ For i from 0 to nums.length-1: // 遍歷所有元素\n   → Decision: nums[i] == val? // 檢查是否為要移除的值\n        Yes → Continue // 跳過此元素\n        No → Step 2: nums[slow] = nums[i] // 將非 val 元素寫入 slow\n           → Step 3: slow = slow + 1 // 移動寫入指標\n→ End // 完成遍歷\n→ Return slow // slow 即為新長度 k\n\nBut we need arrow lines with \"→\". For loops we might write \"→ Step 4: For i = 0 to n-1\" etc.\n\nLet's produce format:\n\nStart // 程式開始執行\n→ Step 1: Set slow = 0 // 初始化寫入指標\n→ Step 2: For i = 0 to nums.length - 1 // 遍歷陣列\n    → Decision: nums[i] == val? // 判斷當前元素是否要移除\n        Yes → Continue // 跳過此元素\n        No  → Step 3: nums[slow] = nums[i] // 將非 val 元素寫入 slow\n            → Step 4: slow = slow + 1 // 移動寫入指標\n→ End // 所有元素已處理\n→ Return slow // 返回新陣列長度 k\n\nEnsure we have correct arrows. Also include indentation.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Set slow = 0 // 初始化寫入指標，將放置非 val 元素的位置\n→ Step 2: For i = 0 to nums.length - 1 // 遍歷整個陣列\n    → Decision: nums[i] == val? // 檢查當前元素是否為要移除的值\n        Yes → Continue // 若為 val，直接跳過此元素\n        No  → Step 3: nums[slow] = nums[i] // 把非 val 元素寫入 slow 位置\n            → Step 4: slow = slow + 1 // 移動寫入指標，準備寫入下一個非 val 元素\n→ End // 所有元素已處理完畢\n→ Return slow // slow 即為新的長度 k，並返回此值\n```"
    },
    {
      "title": "Count Numbers with Unique Digits",
      "source_file": "Leetcode/leetcode357.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "91",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '91'\nGot (Norm):      '82'\n--- (Raw) ---\nRaw Expected: '91'\nRaw Got:      '82'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\n        # 只有 0 的情況\n        if n == 0:\n            return 1\n\n        # 超過 10 位數就一定會重複\n        n = min(n, 10)\n\n        count = 1          # 包含數字 0\n        current = 9        # 1 位數字可選 1-9\n        count += current   # 加上所有 1 位數字\n\n        # 處理 2 位以上的數字\n        for length in range(2, n + 1):\n            current *= (10 - length)  # 新增一位的可選數量\n            count += current\n\n        return count\n\ndef main() -> None:\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    solution = Solution()\n    print(solution.countNumbersWithUniqueDigits(n))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines: Start, steps, decisions. The problem: count of numbers with unique digits less than 10^n. We need to produce pseudocode, not actual code. Provide explanation each line.\n\nLet's think algorithm: For n=0, count=1 (just zero?). Usually LeetCode 357: count numbers with unique digits. For n=0 => 1. For n>0: count = 1 + sum_{i=1..n} 9 * P(9, i-1) where P(9, i-1) is permutations of 9 digits taken i-1. So algorithm: initialize count=1; if n>0, for i from 1 to n: if i==1: count +=9 else: count +=9 * product of (9 - j +1) for j=1 to i-1. Or maintain current=9; for i from 2 to n: current*= (10-i); count+=current. But we produce virtual steps.\n\nWe need to show Start, Step to input n, Decision if n==0, etc. Let's outline.\n\n- Start\n- Input n\n- Decision: n == 0? -> if Yes: set count=1; goto End. else proceed.\n- Set count = 1 // count includes 0\n- Set current = 9 // first digit choices (1-9)\n- Set count = count + current // numbers with 1 digit\n- Set i = 2 // length of number\n- Decision: i <= n? -> if Yes:\n    - current = current * (10 - i) // because for each new digit, options decrease\n    - count = count + current\n    - i = i + 1\n    - go back to Decision\n  else No:\n- End, output count\n\nAdd explanation comments.\n\nNeed to show \"→\" arrow for each step.\n\nLet's produce the lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 取得使用者輸入的 n\n→ Decision: n 是否等於 0? // 檢查特殊情況\n    Yes → Step 2: 設置 count = 1 // 只有數字 0\n    No  → Step 3: 設置 count = 1 // 包含數字 0\n        → Step 4: 設置 current = 9 // 1 位數字可選 1-9\n        → Step 5: count = count + current // 加上所有 1 位數字\n        → Step 6: 設置 i = 2 // 目前已處理 1 位數字\n        → Decision: i 是否小於等於 n? // 檢查是否還需要更長位數\n            Yes → Step 7: current = current * (10 - i) // 新增一位的可選數量\n            → Step 8: count = count + current // 加入這長度的數字\n            → Step 9: i = i + 1 // 進到下一個長度\n            → 回到 Decision\n            No  → End // 所有長度已計算完畢\n→ End // 程式執行結束\n\nBut need to use \"→\" for each line. Should also include decision structure.\n\nBetter to structure with indentation like example.\n\nAlso need to output virtual code lines and explanations.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 從使用者處取得 n  \n→ Decision: n 是否等於 0? // 檢查特殊情況  \n  Yes → Step 2: 設置 count = 1 // 只有數字 0 需要計數  \n  No  → Step 3: 設置 count = 1 // 包含 0  \n    → Step 4: 設置 current = 9 // 1 位數字可選 1-9  \n    → Step 5: count = count + current // 加入所有 1 位數字  \n    → Step 6: 設置 i = 2 // 目前已處理 1 位數字  \n    → Decision: i 是否小於等於 n? // 檢查是否還需要更長位數  \n      Yes → Step 7: current = current * (10 - i) // 新增一位的可選數量  \n        → Step 8: count = count + current // 加入這長度的數字  \n        → Step 9: i = i + 1 // 進到下一個長度  \n        → 回到 Decision  \n      No  → End // 所有長度已計算完畢  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3kmo2240.py\", line 28, in <module>\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 44 (char 43)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列的複本\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列（複製後回傳以避免外部修改）\n        return list(self.original)\n\n    def shuffle(self):\n        # Fisher‑Yates 洗牌演算法\n        res = list(self.original)\n        n = len(res)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            res[i], res[j] = res[j], res[i]\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入並解析 JSON\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    ops, args = json.loads(data)\n\n    output = []\n    solution = None\n\n    for idx, op in enumerate(ops):\n        if op == \"Solution\":\n            # args[idx] 是 [[1,2,3]] 這樣的結構，取第一個元素作為陣列\n            solution = Solution(args[idx][0])\n            output.append(None)  # 第一個呼叫回傳 null\n        elif op == \"reset\":\n            output.append(solution.reset())\n        elif op == \"shuffle\":\n            output.append(solution.shuffle())\n\n    # 輸出結果為 JSON 陣列\n    print(json.dumps(output))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this problem: array shuffle, with reset and shuffle. We need to provide a step-by-step pseudocode: initialization, reset, shuffle. Use Start, End, Decision, arrow, etc. Provide per line: \"虛擬碼步驟 // 解釋\".\n\nWe must not output actual code, just virtual steps. Let's craft solution:\n\nStart // start\n→ Step 1: Store original array copy // keep original for reset\n→ Step 2: Create a working copy of array // used for shuffle\n→ Decision: None (just initialization)\n\nFor reset:\n\n→ Step 3: Reset working copy to original array copy // restore\n→ Step 4: Return working copy // give array\n\nFor shuffle:\n\n→ Step 5: For i from 0 to length-1: // iterate each position\n    → Decision: Random index j between i and n-1 // choose random\n        → Step 6: Swap elements at i and j // perform swap\n→ Step 7: Return shuffled array\n\nWe need to use virtual code lines with arrows. Each line must be a step, with // explanation.\n\nNeed to include decision blocks. Use indentation for decisions.\n\nWe should include \"Start\" and \"End\" at the top and bottom? Might need to separate sections. Provide Start, then steps, then End. But we also need to show separate methods maybe. Perhaps we can include the class structure: Start // start of program, then Step: Define class Solution, etc. Then separate methods.\n\nBetter: Use Start, then define steps for constructor, reset, shuffle, then End.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: Define class Solution // 建立 Solution 類別\n\n→ Step 2: Constructor receives int[] nums // 初始化時接受陣列\n    → Step 3: Store nums as originalCopy // 保留原始陣列以供 reset\n    → Step 4: Clone nums into workingCopy // 建立工作副本用於 shuffle\n\n→ Step 5: Method reset() // 重新設定陣列\n    → Step 6: Set workingCopy to clone of originalCopy // 恢復原始順序\n    → Step 7: Return workingCopy // 回傳重設後的陣列\n\n→ Step 8: Method shuffle() // 隨機打亂陣列\n    → Step 9: For i from 0 to length-1 // 逐個位置\n        → Decision: Random j in [i, n-1] // 隨機挑選交換位置\n            → Step 10: Swap workingCopy[i] with workingCopy[j] // 交換元素\n    → Step 11: Return workingCopy // 回傳打亂後的陣列\n\nEnd // 程式執行結束\n\nBut we might need to indent decisions: use \"Decision:\" and arrows. Use \"Yes →\" maybe not needed. For random selection, we just choose random j. No Yes/No decision.\n\nAlso we can break into substeps.\n\nLet's format accordingly:\n\n```\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立解決方案類別\n→ Step 2: Constructor(nums) // 接收整數陣列\n    → Step 3: original = clone(nums) // 儲存原始陣列\n    → Step 4: current = clone(nums) // 建立可變副本\n→ Step 5: Method reset() // 重置陣列\n    → Step 6: current = clone(original) // 還原為原始順序\n    → Step 7: Return current // 傳回重置後陣列\n→ Step 8: Method shuffle() // 亂序\n    → Step 9: For i from 0 to len(current)-1\n        → Step 10: j = random integer between i and len(current)-1\n        → Step 11: swap current[i] and current[j]\n    → Step 12: Return current // 傳回打亂後陣列\nEnd // 程式執行結束\n```\n\nWe must use arrow symbol '→' for each step. And include \"Decision:\" lines where needed, but we don't have a decision with Yes/No. For random selection, not a decision. We can use \"Decision:\" to denote random? But no need. Let's keep simple.\n\nBut the requirement: Use virtual code arrow (→, Yes →, No →) and Decision:. So we should include at least one Decision block maybe for loop? But loop not decision. But we could treat \"For i...\" as a Decision? Probably not.\n\nBetter to include Decision block for random j selection: maybe \"Decision: Choose j randomly between i and n-1\". That is not a yes/no but we can use Decision: \"j 在 [i, n-1] 中隨機選擇\". It's fine.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立解決方案類別  \n→ Step 2: Constructor(nums) // 接收整數陣列  \n  → Step 3: original = clone(nums) // 儲存原始陣列以供 reset  \n  → Step 4: current = clone(nums) // 建立可變副本用於 shuffle  \n→ Step 5: Method reset() // 重置陣列  \n  → Step 6: current = clone(original) // 還原為原始順序  \n  → Step 7: Return current // 傳回重置後陣列  \n→ Step 8: Method shuffle() // 亂序  \n  → Decision: For i from 0 to len(current)-1 // 逐個位置  \n    Yes → Step 9: j = random integer between i and len(current)-1 // 隨機挑選交換位置  \n    Yes → Step 10: swap current[i] and current[j] // 交換元素  \n  → Step 11: Return current // 傳回打亂後陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Comments",
      "source_file": "Leetcode/leetcode722.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "source = [\"a/*comment\", \"line\", \"more_comment*/b\"]",
          "expected_output": "[\"ab\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpq12c3kof.py\", line 52, in <module>\n    result = Solution().removeComments(source)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpq12c3kof.py\", line 31, in removeComments\n    new_line.append(line[i])\n    ^^^^^^^^^^^^^^^\nAttributeError: 'NoneType' object has no attribute 'append'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeComments(self, source):\n        res = []\n        in_block = False\n\n        for line in source:\n            i = 0\n            if not in_block:\n                new_line = []\n            else:\n                new_line = None  # keep reference to avoid reallocation\n            while i < len(line):\n                # Check for start of block comment\n                if not in_block and i + 1 < len(line) and line[i] == '/' and line[i+1] == '*':\n                    in_block = True\n                    i += 2\n                    continue\n                # Check for end of block comment\n                if in_block and i + 1 < len(line) and line[i] == '*' and line[i+1] == '/':\n                    in_block = False\n                    i += 2\n                    continue\n                # Check for line comment when not in a block\n                if not in_block and i + 1 < len(line) and line[i] == '/' and line[i+1] == '/':\n                    break  # ignore rest of line\n                # Normal character when not in a comment\n                if not in_block:\n                    new_line.append(line[i])\n                i += 1\n            # If we finished a line outside a block comment and it has content, add it\n            if new_line and not in_block:\n                res.append(''.join(new_line))\n        return res\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    raw_input = raw_input.strip()\n    # Extract the list assigned to source\n    if raw_input.startswith(\"source\"):\n        # Split at the first '='\n        _, _, list_str = raw_input.partition(\"=\")\n        list_str = list_str.strip()\n    else:\n        list_str = raw_input\n    # Safely evaluate the list literal\n    source = ast.literal_eval(list_str)\n    # Process and output the result\n    result = Solution().removeComments(source)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for removing comments. Provide line-by-line explanation. Must not output actual code. Use structure: Start, Steps, Decision, End. Provide arrow. Should reflect algorithm: iterate over lines, char by char, maintain inBlock flag, handle line comment. When encountering line comment outside block, ignore rest of line. When encountering block start outside block, set flag, skip until block end found. Also handle nested? No nested. So algorithm: For each line i, pointer j, build result line. While j < len(line): if inBlock: check if line[j:j+2]==\"*/\": set inBlock=false; j+=2; continue; else j+=1; continue. else not inBlock: if line[j:j+2]==\"//\": break (ignore rest). elif line[j:j+2]==\"/*\": inBlock=true; j+=2; continue. else: add line[j] to result; j+=1. After processing line, if result non-empty: add to output. After all lines, return output. Need to show this in virtual steps.\n\nThus produce virtual steps: Start, → Step 1: Initialize output list, inBlock=false. Then loop each line. Show decisions. Use arrow \"→\". Provide explanation. Must use each line of virtual code plus comment. Ok. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化輸出列表 output ← 空清單 // 用於儲存去除註解後的每一行  \n→ Step 2: 設定布林變數 inBlock ← False // 表示目前是否處於區塊註解內  \n\n→ Step 3: 從 source 開始逐行迴圈 // 逐行處理原始程式碼  \n    → Decision: 是否已經處理完所有行？  \n        Yes → End // 所有行已處理完畢，結束程式  \n        No →  \n\n        → Step 4: 取出目前行 currLine ← source[i]  \n        → Step 5: 建立空字串 lineBuffer ← \"\" // 儲存當前行去註解後的內容  \n        → Step 6: 設定指標 j ← 0 // 用於逐字元遍歷 currLine  \n\n        → Step 7: 進入字元迴圈 // 逐字元處理  \n            → Decision: j 是否已超過 currLine 長度？  \n                Yes → 進入第 9 步 // 完成本行字元遍歷  \n                No →  \n\n                → Step 8: 讀取子字串 pair ← currLine[j:j+2] // 取得當前兩個字元  \n\n                    → Decision: 是否在區塊註解內 (inBlock == True)？  \n                        Yes →  \n                            → Decision: pair == \"*/\"？  \n                                Yes → inBlock ← False; j += 2; // 結束區塊註解  \n                                No → j += 1; // 繼續忽略區塊內字元  \n                        No →  \n\n                            → Decision: pair == \"//\"？  \n                                Yes → break; // 這行剩餘皆為行註解，結束本行處理  \n                                No →  \n\n                            → Decision: pair == \"/*\"？  \n                                Yes → inBlock ← True; j += 2; // 開始區塊註解  \n                                No →  \n\n                            → Step 9: 將 currLine[j] 加入 lineBuffer ← lineBuffer + currLine[j]; j += 1; // 正常字元加入輸出  \n\n            → End 循環 // 完成字元處理  \n\n        → Step 10: 判斷 lineBuffer 是否非空  \n            → Decision: lineBuffer 不是空字串？  \n                Yes → output.append(lineBuffer); // 把去註解後的行加入輸出  \n                No → // 空行直接忽略  \n\n    → End 迴圈 // 處理完所有行  \n\nEnd // 程式執行結束，輸出即為去除註解後的 source 代碼列表"
    },
    {
      "title": "Design Twitter",
      "source_file": "Leetcode/leetcode355.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpn_90ttvw.py\", line 92, in <module>\n    main()\n  File \"/tmp/tmpn_90ttvw.py\", line 62, in main\n    args_list = ast.literal_eval(parts[1])\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)          # userId -> list of (time, tweetId)\n        self.following = defaultdict(set)       # userId -> set of followeeIds\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        # Ensure the user follows themselves\n        self.following[userId].add(userId)\n\n    def getNewsFeed(self, userId: int):\n        res = []\n        # If user has no followees (including themselves), return empty list\n        if userId not in self.following:\n            return res\n        followees = self.following[userId] | {userId}\n        heap = []\n        # Initialise heap with the most recent tweet from each followee\n        for fid in followees:\n            tws = self.tweets.get(fid)\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n        # Extract up to 10 most recent tweets\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx - 1 >= 0:\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            # A user always follows themselves\n            self.following[followerId].add(followerId)\n            return\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            return\n        self.following[followerId].discard(followeeId)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the two lists in the input\n    # Replace the first occurrence of '], [' with a unique separator\n    data = data.replace('], [', ']|[')\n    parts = data.split('|')\n    commands = ast.literal_eval(parts[0])\n    args_list = ast.literal_eval(parts[1])\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == 'Twitter':\n            obj = Twitter()\n            results.append(None)\n        elif cmd == 'postTweet':\n            obj.postTweet(*args)\n            results.append(None)\n        elif cmd == 'getNewsFeed':\n            results.append(obj.getNewsFeed(*args))\n        elif cmd == 'follow':\n            obj.follow(*args)\n            results.append(None)\n        elif cmd == 'unfollow':\n            obj.unfollow(*args)\n            results.append(None)\n\n    # Format output: None -> null, lists -> Python list string\n    output = []\n    for r in results:\n        if r is None:\n            output.append('null')\n        else:\n            output.append(str(r))\n    print(f\"[{', '.join(output)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. We should create steps for initializing data structures, posting tweet, following/unfollowing, getNewsFeed. Use arrows etc. Provide explanation comments after each line. Should be line-by-line. Not actual code. Let's produce structured algorithm description.\n\nWe need to cover initialization: maps for userFollowers or followees, tweets list per user with timestamps. Use global timestamp increment.\n\nLet's produce pseudo steps:\n\nStart\n→ Step 1: Initialize global timestamp = 0 // counter for tweet order\n→ Step 2: Initialize followMap: Map userId -> Set of followeeIds // who each user follows\n→ Step 3: Initialize tweetsMap: Map userId -> List of (tweetId, timestamp) // user's tweets\n→ Step 4: // ensure each user has empty set and list when first seen\n\nThen functions:\n\nPostTweet(userId, tweetId):\n→ Step 1: If userId not in followMap, add empty set // new user\n→ Step 2: If userId not in tweetsMap, add empty list // new user\n→ Step 3: Increment global timestamp // mark time\n→ Step 4: Append (tweetId, timestamp) to tweetsMap[userId] // store tweet\n→ Step 5: // optionally maintain size limit? not required\n\nGetNewsFeed(userId):\n→ Step 1: If userId not in followMap, create empty set // new user\n→ Step 2: Define feedCandidates = empty min-heap of size 10 // store top tweets\n→ Step 3: For each followee in followMap[userId] plus userId itself:\n→ Step 4: For each tweet in tweetsMap[followee] from most recent to older:\n→ Step 5: If heap size < 10, push tweet; else if tweet.timestamp > heap.peek().timestamp, replace\n→ Step 6: Break when heap full and older tweets can't beat top? optimization\n→ Step 7: Extract tweets from heap and sort descending timestamp\n→ Step 8: Return list of tweetIds\n\nFollow(followerId, followeeId):\n→ Step 1: Ensure followerId has entry in followMap\n→ Step 2: Add followeeId to followMap[followerId] // follow\n\nUnfollow(followerId, followeeId):\n→ Step 1: If followerId in followMap, remove followeeId from set // unfollow\n\nWe must provide each line with virtual code step and explanation. Use arrow syntax: \"→ Step 1: ...\". For loops, decisions.\n\nLet's craft pseudo algorithm line by line. We can structure the class with methods. Each method's steps.\n\nLet's output:\n\nStart\n→ Step 1: Initialize globalTimestamp = 0\n...\n\nMake sure to include decisions: \"Decision: if user exists?\" etc.\n\nWe need to provide a step-by-step for each method. The user wants a simplified Twitter design. Provide virtual code.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: globalTimestamp ← 0 // 用於確保每條 tweet 的先後順序\n→ Step 2: followMap ← new Map() // key: userId, value: Set<followeeId>\n→ Step 3: tweetsMap ← new Map() // key: userId, value: List<(tweetId, timestamp)>\n\n// -------------------- Twitter() --------------------\n→ Step 4: // Twitter() 只需要初始化上述資料結構，已於全域完成\n\n// -------------------- postTweet(userId, tweetId) --------------------\n→ Step 5: Decision: 如果 userId 尚未存在於 followMap? // 確保每位使用者都有跟隨集合\n    Yes → Step 6: followMap[userId] ← new Set()\n    No  → No change\n→ Step 7: Decision: 如果 userId 尚未存在於 tweetsMap? // 為新使用者建立 tweet 列表\n    Yes → Step 8: tweetsMap[userId] ← new List()\n    No  → No change\n→ Step 9: globalTimestamp ← globalTimestamp + 1 // 取得目前時間戳\n→ Step 10: tweetsMap[userId].append((tweetId, globalTimestamp)) // 將 tweet 加入使用者的貼文列表\n\n// -------------------- getNewsFeed(userId) --------------------\n→ Step 11: Decision: 如果 userId 尚未存在於 followMap? // 新使用者無跟隨資訊\n    Yes → Step 12: followMap[userId] ← new Set()\n    No  → No change\n→ Step 13: feedCandidates ← new MinHeap(capacity = 10) // 儲存前 10 條最新 tweet\n→ Step 14: allUsers ← followMap[userId] ∪ {userId} // 包含自己\n→ Step 15: For each uid in allUsers:\n        → Step 16: For each (tid, ts) in tweetsMap[uid]  // 依時間遞增或遞減遍歷\n            → Step 17: Decision: feedCandidates.size < 10? // 先塞滿\n                Yes → Step 18: feedCandidates.push((tid, ts))\n                No  → Decision: ts > feedCandidates.peek().ts? // 只保留較新的\n                    Yes → Step 19: feedCandidates.pop()\n                    Yes → Step 20: feedCandidates.push((tid, ts))\n                    No  → No change\n→ Step 21: result ← empty List()\n→ Step 22: While feedCandidates is not empty:\n        → Step 23: (tid, ts) ← feedCandidates.pop()\n        → Step 24: result.prepend(tid) // 由小到大彈出，前面放入得到從新到舊\n→ Step 25: return result // 最終返回最多 10 條 tweetId\n\n// -------------------- follow(followerId, followeeId) --------------------\n→ Step 26: Decision: 如果 followerId 尚未存在於 followMap? // 新使用者\n    Yes → Step 27: followMap[followerId] ← new Set()\n    No  → No change\n→ Step 28: followMap[followerId].add(followeeId) // 加入跟隨關係\n\n// -------------------- unfollow(followerId, followeeId) --------------------\n→ Step 29: Decision: followerId 是否存在於 followMap? // 防止錯誤\n    Yes → Step 30: followMap[followerId].remove(followeeId) // 移除跟隨\n    No  → No action // 若不存在，什麼也不做\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Shortest Unsorted Continuous Subarray",
      "source_file": "Leetcode/leetcode581.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,6,4,8,10,9,15]",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8hh064w2.py\", line 58, in <module>\n    result = solution.findUnsortedSubarray(nums)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8hh064w2.py\", line 32, in findUnsortedSubarray\n    sub_min = min(nums[left:right + 1])\n              ^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: min() iterable argument is empty"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findUnsortedSubarray(self, nums):\n        n = len(nums)\n        if n <= 1:\n            return 0\n\n        # 找左邊界：從左往右，尋找第一次比前面最大值還小的點\n        left = n\n        max_so_far = nums[0]\n        for i in range(1, n):\n            if nums[i] < max_so_far:\n                left = i\n            else:\n                max_so_far = nums[i]\n\n        # 找右邊界：從右往左，尋找第一次比後面最小值還大\n        right = -1\n        min_so_far = nums[-1]\n        for i in range(n - 2, -1, -1):\n            if nums[i] > min_so_far:\n                right = i\n            else:\n                min_so_far = nums[i]\n\n        # 若整個陣列已經有序\n        if right == -1:\n            return 0\n\n        # 子陣列的最小最大值，用來擴展邊界\n        sub_min = min(nums[left:right + 1])\n        sub_max = max(nums[left:right + 1])\n\n        # 擴展左邊界\n        while left > 0 and nums[left - 1] > sub_min:\n            left -= 1\n        # 擴展右邊界\n        while right < n - 1 and nums[right + 1] < sub_max:\n            right += 1\n\n        return right - left + 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，例如 \"nums = [2,6,4,8,10,9,15]\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        print(0)\n        sys.exit()\n    nums = eval(data[start:end + 1])\n\n    solution = Solution()\n    result = solution.findUnsortedSubarray(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce pseudocode steps. Problem: find shortest subarray which when sorted will sort whole array. Standard solution: find left and right boundaries of unsorted subarray by scanning from left and right and find max/min. Steps: find max to left, min to right etc. Provide pseudocode.\n\nWe'll produce line-by-line. Use Start, End. Use Decision, etc.\n\nLet's craft.\n\nStart // Start program\n→ Input: array nums // Read array\n→ If nums is empty or length <=1: // No need to sort\n    → Output 0 // Length 0\n    → End\n→ Compute n = length(nums)\n→ Step 1: Find initial left boundary\n    → Set left = n\n    → Set max_so_far = nums[0]\n    → For i from 1 to n-1:\n        → If nums[i] < max_so_far:\n            → left = i\n        → Else:\n            → max_so_far = nums[i]\n→ Step 2: Find initial right boundary\n    → Set right = -1\n    → Set min_so_far = nums[n-1]\n    → For i from n-2 downto 0:\n        → If nums[i] > min_so_far:\n            → right = i\n        → Else:\n            → min_so_far = nums[i]\n→ Decision: If right == -1:\n    → Yes → Output 0 // Array already sorted\n    → No → Continue\n→ Step 3: Determine bounds of subarray to sort\n    → Compute subarray_min = min(nums[left:right+1])\n    → Compute subarray_max = max(nums[left:right+1])\n→ Step 4: Expand left boundary if necessary\n    → While left > 0 and nums[left-1] > subarray_min:\n        → left = left - 1\n→ Step 5: Expand right boundary if necessary\n    → While right < n-1 and nums[right+1] < subarray_max:\n        → right = right + 1\n→ Step 6: Compute length = right - left + 1\n→ Output length\nEnd // End program\n\nBut need each line as \"虛擬碼步驟 // 解釋\". Use arrow. Let's incorporate. Use → and indent. Decision lines with Yes → etc.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: array nums // 取得輸入的整數陣列  \n→ Decision: 如果 nums 為空或長度 <= 1? // 檢查陣列是否已經無需排序  \n  Yes → Output 0 // 已經有序，子陣列長度為 0  \n  No → // 繼續處理  \n→ Step 1: 計算 n = length(nums) // 取得陣列長度  \n→ Step 2: 初始化左邊界 left = n, max_so_far = nums[0] // 設定初始最大值  \n→ For i from 1 to n-1: // 從左到右掃描  \n  Decision: 如果 nums[i] < max_so_far? // 找到逆序點  \n   Yes → left = i // 记录左边界  \n   No → max_so_far = nums[i] // 更新最大值  \n→ Step 3: 初始化右邊界 right = -1, min_so_far = nums[n-1] // 設定初始最小值  \n→ For i from n-2 downto 0: // 從右到左掃描  \n  Decision: 如果 nums[i] > min_so_far? // 找到逆序點  \n   Yes → right = i // 记录右边界  \n   No → min_so_far = nums[i] // 更新最小值  \n→ Decision: 如果 right == -1? // 若未找到逆序點  \n  Yes → Output 0 // 整個陣列已經有序  \n  No → // 繼續  \n→ Step 4: 取子陣列 nums[left:right+1] 的最小值 subarray_min, 最大值 subarray_max // 用於擴展邊界  \n→ Step 5: 擴展左邊界 while left > 0 and nums[left-1] > subarray_min: // 若左側元素大於子陣列最小值，需要包含它  \n  left = left - 1  \n→ Step 6: 擴展右邊界 while right < n-1 and nums[right+1] < subarray_max: // 若右側元素小於子陣列最大值，需要包含它  \n  right = right + 1  \n→ Step 7: 計算結果 length = right - left + 1 // 子陣列長度  \n→ Output length // 輸出最短子陣列長度  \nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0hck6ehv.py\", line 87, in <module>\n    main()\n  File \"/tmp/tmp0hck6ehv.py\", line 62, in main\n    ops = json.loads(ops_part.replace('null', 'None'))\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 12 (char 11)"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity          # 最大容量\n        self.min_freq = 0                 # 目前最小使用頻率\n        self.key_to_val_freq = {}         # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict[key, None]\n\n    def _update(self, key: int) -> None:\n        \"\"\"將 key 的頻率升級 1，並調整資料結構。\"\"\"\n        value, freq = self.key_to_val_freq[key]\n        # 從舊頻率的 OrderedDict 移除\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # 加入新頻率的 OrderedDict\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # 更新 value，並視為使用一次\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # 失效最少使用且最舊的 key\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # 新增 key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 讀入兩行：操作與對應參數\n    parts = data.splitlines()\n    if len(parts) == 1:\n        # 如果只是一行，使用逗號分隔\n        ops_part, args_part = data.split(',', 1)\n    else:\n        ops_part, args_part = parts[0], parts[1]\n    # 解析為 Python 物件\n    ops = json.loads(ops_part.replace('null', 'None'))\n    args = json.loads(args_part.replace('null', 'None'))\n\n    res = []\n    cache = None\n    for i, op in enumerate(ops):\n        if op == \"LFUCache\":\n            cache = LFUCache(args[i][0])\n            res.append(None)\n        elif op == \"put\":\n            key, value = args[i][0], args[i][1]\n            cache.put(key, value)\n            res.append(None)\n        elif op == \"get\":\n            key = args[i][0]\n            res.append(cache.get(key))\n        else:\n            # 忽略未知操作\n            res.append(None)\n\n    # 轉換為輸出格式：None -> null，其他數值保持原樣\n    out = '[' + ', '.join('null' if x is None else str(x) for x in res) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. Use structure: Start, Steps, Decision, End. Must not produce actual code. Provide each line: virtual code step + comment. The user wants a design and implementation of LFUCache. Need to outline data structures: Hash map key->Node, frequency map freq->DLL of keys, minFreq. Node contains key, value, freq. Steps: init, get, put. Complexity O(1).\n\nWe produce step-by-step virtual algorithm. We need to include decision points. For get: if not exist -> return -1. Else increment frequency: remove from old freq list, add to new freq list; update minFreq if needed. For put: if capacity==0, nothing. If key exists: update value, treat as get (increase freq). Else: if size==capacity: evict key from minFreq list's head (LRU). Then insert new node with freq=1, add to freq list 1, set minFreq=1.\n\nUse virtual steps: Start, Step: Initialize structures, etc. Use arrows for flow. We'll use Decision: ... etc. Provide comments.\n\nLet's craft. Each line must have \"→\" arrow, etc. Example earlier. We'll follow format. Let's produce a complete virtual code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 capacity, size, minFreq // 設定快取容量、目前儲存項目數量與最小頻率  \n→ Step 2: 建立 HashMap keyToNode // 存放 key → node 的對應表，node 包含 key, value, freq  \n→ Step 3: 建立 HashMap freqToDLL // 存放 freq → 雙向鏈結串列 (LRU 方式) 的對應表  \n→ End // 初始結構設定完成  \n\n---  \n**get(key)**  \n\n→ Step 4: Decision: key 是否存在於 keyToNode?  \n    Yes → Step 5: 取得 node = keyToNode[key] // 取得對應節點  \n    → Step 6: 取得 currFreq = node.freq // 目前頻率  \n    → Step 7: 移除 node 從 freqToDLL[currFreq] // 先從舊頻率串列移除  \n    → Step 8: Decision: freqToDLL[currFreq] 是否為空?  \n        Yes → Step 9: 刪除 freqToDLL[currFreq] // 若該頻率串列已空，刪除映射  \n        No  → No-op  \n    → Step 10: node.freq ← currFreq + 1 // 更新頻率  \n    → Step 11: 若 freqToDLL[currFreq + 1] 不存在，建立新 DLL // 需要新頻率串列  \n    → Step 12: 把 node 加到 freqToDLL[currFreq + 1] 的尾端 // 代表最近使用  \n    → Step 13: Decision: currFreq == minFreq 且 freqToDLL[minFreq] 為空?  \n        Yes → Step 14: minFreq ← currFreq + 1 // 更新最小頻率  \n        No  → No-op  \n    → Step 15: Return node.value // 回傳值  \n    No  → Step 16: Return -1 // key 不存在  \n\n---  \n**put(key, value)**  \n\n→ Step 17: Decision: capacity == 0?  \n    Yes → Step 18: Return // 無法存放任何項目  \n    No  → No-op  \n→ Step 19: Decision: key 是否存在於 keyToNode?  \n    Yes → Step 20: 取得 node = keyToNode[key] // 已存在項目  \n    → Step 21: node.value ← value // 更新值  \n    → Step 22: 回傳到 get(key) 以更新頻率  \n    No  → Step 23: Decision: size == capacity?  \n        Yes → Step 24: Decision: freqToDLL[minFreq] 的 head 為要移除的 LRU node  \n            → Step 25: 移除 nodeToEvict = head // 擊掉最舊的 LRU 節點  \n            → Step 26: 刪除 keyToNode[nodeToEvict.key] // 從 key 映射移除  \n            → Step 27: 移除 nodeToEvict 從 freqToDLL[minFreq] // 從頻率串列移除  \n            → Step 28: 若 freqToDLL[minFreq] 為空，刪除映射 // 清除空串列  \n            → Step 29: size ← size - 1 // 釋放空間  \n        No  → No-op  \n    → Step 30: 建立 newNode(key, value, freq=1) // 新增節點  \n    → Step 31: keyToNode[key] ← newNode // 加入 key 映射  \n    → Step 32: 若 freqToDLL[1] 不存在，建立新 DLL // 新頻率串列  \n    → Step 33: 把 newNode 加到 freqToDLL[1] 的尾端 // 代表最近使用  \n    → Step 34: minFreq ← 1 // 新項目頻率為 1，更新 minFreq  \n    → Step 35: size ← size + 1 // 更新儲存數量  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Shortest Completing Word",
      "source_file": "Leetcode/leetcode748.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]",
          "expected_output": "\"steps\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp30pzwuho.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmp30pzwuho.py\", line 38, in main\n    data = ast.literal_eval(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7c4e0fdfbad0>"
        },
        {
          "example_index": 1,
          "input": "licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"]",
          "expected_output": "\"pest\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpf5cu5pz_.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmpf5cu5pz_.py\", line 38, in main\n    data = ast.literal_eval(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x733d80ef7ad0>"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef shortest_completing_word(license_plate: str, words: list[str]) -> str:\n    # Count letters in license_plate (ignore non-letters, case-insensitive)\n    plate_count = Counter(c.lower() for c in license_plate if c.isalpha())\n\n    best_word = None\n    best_len = float('inf')\n\n    for word in words:\n        # Count letters in current word\n        word_count = Counter(word.lower())\n\n        # Check if word satisfies all required counts\n        if all(word_count[c] >= plate_count[c] for c in plate_count):\n            if len(word) < best_len:\n                best_len = len(word)\n                best_word = word\n\n    return best_word\n\ndef main() -> None:\n    # Read all input\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n\n    # Normalize input: replace '=' with ':' and wrap in braces to form a dict literal\n    # This handles cases where the input is like:\n    # licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]\n    raw_input = raw_input.replace('\\n', ' ').replace('\\r', ' ')\n    raw_input = raw_input.replace('=', ':')\n    raw_input = '{' + raw_input + '}'\n\n    # Safely evaluate the dict\n    data = ast.literal_eval(raw_input)\n\n    license_plate = data['licensePlate']\n    words = data['words']\n\n    result = shortest_completing_word(license_plate, words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code steps. Provide step by step algorithm. Use Start, End, Decision etc. Must be Chinese explanations.\n\nNeed to produce for the problem: find shortest completing word. Approach: preprocess licensePlate letters counts ignoring non-letters; for each word in words, check if word contains required counts; keep shortest. Use first if tie.\n\nPseudo: parse licensePlate: for each char c in licensePlate: if isLetter: lower-case; increment count.\n\nInitialize bestWord = \"\"; bestLen = INF.\n\nFor each word in words:\n   compute wordCounts of letters lower-case.\n   Check if all required counts <= wordCounts.\n   If true:\n       if len(word) < bestLen: update bestWord, bestLen.\nReturn bestWord.\n\nLet's produce virtual code lines with arrow. Each line with // explanation.\n\nNeed to include loops, decision.\n\nAlso we might need variable declarations etc.\n\nWe'll produce something like:\n\nStart // 程式開始\n→ Step 1: 初始化 licenseCount[26] 為 0 // 建立字母出現次數表\n→ Step 2: 逐字元遍歷 licensePlate\n    → Decision: 是否為英文字母? // 濾除數字與空白\n        Yes → Step 3: 轉為小寫並增加對應 index 的計數 // 將字母轉小寫後統計\n        No  → Step 4: 跳過該字元 // 非字母不處理\n→ Step 5: 設定 bestWord 為空字串，bestLen 為無限大 // 用於存最短符合條件的字\n→ Step 6: 逐字串遍歷 words\n    → Step 7: 生成 wordCount[26] 為 0 // 針對當前單字初始化字母計數\n    → Step 8: 逐字元遍歷該單字\n        → Decision: 是否為英文字母? // 所有單字已經是字母，但確認一下\n            Yes → Step 9: 轉為小寫並增加對應 index 的計數 // 統計單字中字母出現次數\n            No  → Step 10: 跳過\n    → Step 11: 判斷 wordCount 是否滿足 licenseCount\n        → Decision: 所有字母計數 >= 需求? // 檢查是否為完成字\n            Yes → Step 12: 比較長度\n                → Decision: len(word) < bestLen? // 若更短\n                    Yes → Step 13: 更新 bestWord 與 bestLen // 儲存更短字\n                    No  → Step 14: 留下現有答案 // 不更新\n            No  → Step 15: 跳過此單字 // 不符合需求\n→ Step 16: 輸出 bestWord // 最短完成字\nEnd // 程式結束\n\nWe should include arrow for decisions. Also include Indentation. Use \"Yes →\" \"No →\". Provide step numbers optional.\n\nLet's format accordingly. Use Chinese explanation. Provide each line as per requirement.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 licenseCount[26] 為 0 // 建立字母頻率表\n→ Step 2: 逐字元遍歷 licensePlate\n    → Decision: 是否為英文字母? // 濾除數字與空白\n        Yes → Step 3: 轉為小寫並增加 licenseCount[char-'a'] // 計數字母\n        No  → Step 4: 跳過該字元 // 非字母不做處理\n→ Step 5: 設定 bestWord 為空字串，bestLen 為無限大 // 儲存最短符合條件的字\n→ Step 6: 逐字串遍歷 words\n    → Step 7: 生成 wordCount[26] 為 0 // 針對當前單字初始化頻率表\n    → Step 8: 逐字元遍歷該單字\n        → Decision: 是否為英文字母? // 雖然單字全為字母，但先確認\n            Yes → Step 9: 轉為小寫並增加 wordCount[char-'a'] // 計數\n            No  → Step 10: 跳過此字元 // 不會發生\n    → Step 11: 判斷 wordCount 是否滿足 licenseCount\n        → Decision: 所有字母計數 >= 需求? // 是否為完成字\n            Yes → Step 12: 比較長度\n                → Decision: len(word) < bestLen? // 更短則更新\n                    Yes → Step 13: 更新 bestWord 與 bestLen // 儲存新答案\n                    No  → Step 14: 保留現有 bestWord // 不更新\n            No  → Step 15: 跳過此單字 // 不符合條件\n→ Step 16: 輸出 bestWord // 回傳最短完成字\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpd7x5zkw5.py\", line 52, in <module>\n    main()\n  File \"/tmp/tmpd7x5zkw5.py\", line 39, in main\n    instance = Solution(*arg[0] if arg else [])\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpd7x5zkw5.py\", line 11, in __init__\n    for weight in w:\nTypeError: 'int' object is not iterable"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpyl_p7yyy.py\", line 52, in <module>\n    main()\n  File \"/tmp/tmpyl_p7yyy.py\", line 39, in main\n    instance = Solution(*arg[0] if arg else [])\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: Solution.__init__() takes 2 positional arguments but 3 were given"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        # 建立前綴和陣列，用於快速定位隨機索引\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 產生 [1, total] 範圍內的隨機整數\n        target = random.randint(1, self.total)\n        # 透過二分搜尋找到第一個 prefix_sum >= target 的索引\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把整個輸入包在一對方括號，讓 json 解析成兩個元素的列表\n    try:\n        methods, args = json.loads(f'[{data}]')\n    except json.JSONDecodeError as e:\n        # 如果輸入格式不符合，直接終止\n        sys.exit(1)\n\n    outputs = []\n    instance = None\n\n    for method, arg in zip(methods, args):\n        if method == \"Solution\":\n            # 參數本身是一個列表，例如 [[1,3]]\n            instance = Solution(*arg[0] if arg else [])\n            outputs.append(None)\n        else:\n            if instance is None:\n                raise RuntimeError(\"Solution instance not initialized\")\n            # 呼叫相應方法\n            result = getattr(instance, method)(*arg)\n            outputs.append(result)\n\n    # 輸出結果，None 會自動轉為 null\n    sys.stdout.write(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code for implementing pickIndex with weighted random selection. The code should be line by line, with arrow etc. Provide steps: Start, compute prefix sums, random number generation, binary search or linear search to find index, return. Also initialization step. Provide explanation. No actual code. Just virtual steps.\n\nWe must use the format: \"虛擬碼步驟 [space] // 解釋\". Use arrows like →. Provide Start, End. Use Decision: for branching.\n\nWe need to include initialization of prefix sum array and total sum. Also need pickIndex method: generate random number r between 1 and total inclusive, then find index where prefix >= r. Use binary search decision? Could be linear search.\n\nLet's produce. Ensure each line separate. Provide step names like \"Initialize\", \"Generate random\", \"Find index\". Use decision: if r <= prefix[i] etc.\n\nMake sure to reflect that this is virtual code. Provide lines. Use arrow: \"→ Step: ...\". End.\n\nLet's draft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 w // 取得權重陣列\n→ Step 2: 建立 prefix[0..len-1] // 前綴和陣列用於快速查找\n→ Decision: 是否為第一個元素? // 初始化前綴和\n    Yes → Step 3: prefix[0] ← w[0] // 第一個前綴和為其自身\n    No  → Step 4: prefix[i] ← prefix[i-1] + w[i] // 之後的前綴和累加\n→ Step 5: 計算 total ← prefix[len-1] // 總權重\n→ Step 6: 定義函式 pickIndex() // 需要回傳隨機索引\n    → Step 7: 產生隨機整數 r ∈ [1, total] // 生成隨機數\n    → Decision: 進行二分搜尋? // 快速定位索引\n        Yes → Step 8: low ← 0, high ← len-1\n        → Decision: low ≤ high? // 二分搜尋迴圈條件\n            Yes → Step 9: mid ← (low + high) // 取中點\n            → Decision: r ≤ prefix[mid]? // 判斷是否在左半區\n                Yes → Step 10: high ← mid - 1 // 將搜尋區間縮小到左側\n                No  → Step 11: low ← mid + 1 // 否則搜尋右側\n            No  → Step 12: return low // 二分搜尋結束，low 為答案\n        No  → Step 13: // 如果不使用二分，可改用線性搜尋\n            → Step 14: for i from 0 to len-1\n                → Decision: r ≤ prefix[i]? // 找到符合條件的索引\n                    Yes → Step 15: return i // 返回該索引\n                    No  → Step 16: continue // 檢查下一個\n→ End // 程式執行結束"
    }
  ]
}