{
  "run_index": 3,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 396,
  "generation_or_validation_failure_count": 43,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[5,2,4,4,2]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[5, 2, 4, 4, 2]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n    return [random.randint(1,6) for _ in range(n)]\n\nif __name__ == \"__main__\":\n    input_code = sys.stdin.read()\n    if input_code.strip():\n        exec(input_code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The user wants a function roll_dice(n) using random module, simulate rolling n six-sided dice, return list of results. Provide virtual code in Chinese explanation. Use arrows and Decision. Should include Start, End. Provide step by step.\n\nWe will create steps:\n\nStart\n→ Step 1: Import random // import random module\n→ Step 2: Define function roll_dice(n): // 定義函數\n→ Inside function: Initialize results = [] // 儲存結果\n→ Decision: n <= 0? // 如果 n 非正\n    Yes → Step 3: Raise ValueError('n must be positive') // 提示錯誤\n    No  → Loop: For i in range(n): // 進行 n 次\n        → Step 4: Roll = random.randint(1,6) // 擲骰子\n        → Step 5: Append roll to results // 存入結果\n→ Step 6: Return results // 返回列表\nEnd\n\nBut we need to produce virtual code with arrows and each line's explanation. The formatting: each line \"虛擬碼步驟 // 解釋\". Use arrows → and Decision: ... Yes →, No →. Provide Step numbers maybe.\n\nMake sure to include End // 程式執行結束\n\nLet's produce. Use \"Start // 程式開始執行\". Then arrow lines. Use \"Decision:\" lines with indent. Use \"Yes →\" \"No →\" within Decision block. Provide final. Let's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Import random // 匯入 random 模組，為擲骰子做準備\n→ Step 2: Define function roll_dice(n): // 定義 roll_dice 函式，接收擲骰次數 n\n→ Step 3: Initialize results = [] // 建立空列表來儲存每次擲骰的結果\n→ Decision: If n <= 0? // 檢查 n 是否為正整數\n    Yes → Step 4: Raise ValueError('n must be positive') // 若 n 小於等於 0，拋出錯誤\n    No  → Loop: For i in range(n): // 若 n 為正，開始擲 n 次骰子\n        → Step 5: roll = random.randint(1, 6) // 擲一顆六面骰，取得 1~6 的隨機數\n        → Step 6: Append roll to results // 將擲骰結果加入列表\n→ Step 7: Return results // 回傳完整的結果列表\nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行時間，返回秒數，保留三位小數。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入的程式碼，並執行\n    src_code = sys.stdin.read()\n    exec(src_code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The function measure_time(func, *args) uses time module, measure execution time in seconds, round to 3 decimal places, and return result. Provide step-by-step. Probably include import time, define function, record start, call func, record end, compute elapsed, round, return. Include End marker. Use Decision? No. Just straightforward. Provide each line with arrow arrow. Let's structure:\n\nStart\n→ Import time module\n→ Define function measure_time(func, *args)\n→ Inside: record start time // record current time\n→ Call func(*args) and store result // execute function\n→ Record end time // capture time after execution\n→ Compute elapsed = end - start // difference\n→ Round elapsed to 3 decimal places // round\n→ Return rounded elapsed // output\n→ End\n\nBut maybe we also need to return the function's result? The requirement says \"測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。\" It might refer to returning the elapsed time. So just return time.\n\nThus final.\n\nUse format:\n\nStart // 程式開始執行\n→ Import time module // 引入 time 模組\n→ Define function measure_time(func, *args) // 定義計時函式\n→ Inside: start = time.time() // 記錄開始時間\n→ result = func(*args) // 執行傳入的函式\n→ end = time.time() // 記錄結束時間\n→ elapsed = end - start // 計算執行時間\n→ rounded_time = round(elapsed, 3) // 四捨五入到三位小數\n→ Return rounded_time // 回傳計時結果\nEnd // 程式執行結束\n\nBut we need to format each line: \"虛擬碼步驟 [space] // 解釋\". So we must write:\n\nStart // 程式開始執行\n→ Import time // 引入 time 模組\n→ Define function measure_time(func, *args) // 定義計時函式\n→ Inside: start = time.time() // 記錄開始時間\n→ result = func(*args) // 執行傳入的函式\n→ end = time.time() // 記錄結束時間\n→ elapsed = end - start // 計算執行時間\n→ rounded_time = round(elapsed, 3) // 四捨五入到三位小數\n→ Return rounded_time // 回傳計時結果\nEnd // 程式執行結束\n\nHowever, we need to indicate the body lines with \"→\". Use arrow for each step after the function definition. Let's produce with indentation. The format example shows indentation for decisions. We can use simple arrows for each step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Import time // 引入 time 模組\n→ Define function measure_time(func, *args) // 定義計時函式\n→ Inside: start = time.time() // 記錄開始時間\n→ Inside: result = func(*args) // 執行傳入的函式\n→ Inside: end = time.time() // 記錄結束時間\n→ Inside: elapsed = end - start // 計算執行時間\n→ Inside: rounded_time = round(elapsed, 3) // 四捨五入到三位小數\n→ Inside: Return rounded_time // 回傳計時結果\nEnd // 程式執行結束\n\nBut need \"→\" before each step, not \"Inside:\" maybe we don't need that. But we can include \"Inside:\" as part of step. The arrow is used to denote step after start. But we can also indent under function. For clarity, maybe use arrow for all.\n\nAlternatively:\n\nStart // 程式開始執行\n→ Import time // 引入 time 模組\n→ Define function measure_time(func, *args) // 定義計時函式\n→    start = time.time() // 記錄開始時間\n→    result = func(*args) // 執行傳入的函式\n→    end = time.time() // 記錄結束時間\n→    elapsed = end - start // 計算執行時間\n→    rounded_time = round(elapsed, 3) // 四捨五入到三位小數\n→    Return rounded_time // 回傳計時結果\nEnd // 程式執行結束\n\nBut we need arrow arrow. Use \"→\" at start of each line. For indentation we can use space indentation after arrow.\n\nI think best is:\n\nStart // 程式開始執行\n→ Import time // 引入 time 模組\n→ Define function measure_time(func, *args) // 定義計時函式\n→    start = time.time() // 記錄開始時間\n→    result = func(*args) // 執行傳入的函式\n→    end = time.time() // 記錄結束時間\n→    elapsed = end - start // 計算執行時間\n→    rounded_time = round(elapsed, 3) // 四捨五入到三位小數\n→    Return rounded_time // 回傳計時結果\nEnd // 程式執行結束\n\nBut arrow before \"Return\"? Should be \"→ Return rounded_time // 回傳計時結果\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import time // 引入 time 模組  \n→ Define function measure_time(func, *args) // 定義計時函式  \n→    start = time.time() // 記錄開始時間  \n→    result = func(*args) // 執行傳入的函式  \n→    end = time.time() // 記錄結束時間  \n→    elapsed = end - start // 計算執行時間  \n→    rounded_time = round(elapsed, 3) // 四捨五入到小數點 3 位  \n→    Return rounded_time // 回傳計時結果  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"apple\",\"grape\",\"melon\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'apple', 'grape', 'melon', 'orange'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取標準輸入但不需要處理任何資料\n    sys.stdin.read()\n\n    # 建立並操作集合\n    fruits = {'apple', 'banana'}\n    fruits.add('orange')\n    fruits.update(['grape', 'melon'])\n    fruits.remove('banana')\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps with explanations in Chinese. Each line: \"虛擬碼步驟 // 解釋\". Must use arrows and structure. Provide steps for creating set, adding, updating, removing, discarding, printing. Use Start, End. Use Decision? Not necessary. Use arrows. Provide each step. Use \"Step 1\", \"Step 2\", etc. Use arrows. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: 呼叫 fruits.add('orange') // 加入 'orange'\n→ Step 3: 呼叫 fruits.update({'grape', 'melon'}) // 一次加入 'grape' 與 'melon'\n→ Step 4: 呼叫 fruits.remove('banana') // 移除 'banana'（若不存在會拋錯誤）\n→ Step 5: 呼叫 fruits.discard('pineapple') // 嘗試移除 'pineapple'（不存在則不動作）\n→ Step 6: 輸出 fruits // 顯示最終集合內容\nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.88TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.88 TWD'"
        }
      ],
      "generated_code": "import requests\nimport sys\nimport tkinter as tk\n\ndef fetch_rate():\n    \"\"\"取得美元兌台幣匯率並回傳字串。\"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n        data = response.json()\n        rate = data[\"rates\"].get(\"TWD\")\n        if rate is None:\n            return \"無法取得台幣匯率\"\n        return f\"目前美元匯率：約 {rate} TWD\"\n    except Exception:\n        return \"更新失敗，請檢查網路連線\"\n\n# ===================== GUI 部分 (可選) =====================\ndef create_gui():\n    \"\"\"建立簡易 tkinter 視窗，按下按鈕即更新匯率。\"\"\"\n    root = tk.Tk()\n    root.title(\"匯率查詢\")\n\n    label = tk.Label(root, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def on_update():\n        result = fetch_rate()\n        label.config(text=result)\n\n    btn = tk.Button(root, text=\"更新匯率\", command=on_update)\n    btn.pack(pady=5)\n\n    root.mainloop()\n\n# ===================== 主程式區塊 =====================\nif __name__ == \"__main__\":\n    # 讀取所有輸入，主要為符合測試需求\n    _ = sys.stdin.read()\n\n    # 執行匯率查詢並輸出結果\n    print(fetch_rate())",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with explanations, following format. The user wants code for requests API fetch, tkinter window, button to update. Must use virtual code, not actual code, just steps. We need to output line by line with arrow. Format: Start // description. Then steps. Use arrows \"→\". Decision statements if needed. No actual code. Just steps.\n\nLet's design steps:\n\nStart\n→ Step 1: 匯入所需模組: requests, tkinter, json // 先載入庫\n→ Step 2: 定義函式 fetch_rate() // 取得匯率\n    → Step 3: 設定 API URL\n    → Step 4: 使用 requests.get 取得回應\n    → Decision: 回應成功? // 檢查 status\n        Yes → Step 5: 解析 JSON 取出 'rates' → 'TWD'\n        No → Step 6: 回傳 None 或錯誤訊息\n→ Step 7: 建立 tkinter 視窗 root\n→ Step 8: 建立標籤 label_rate 以顯示匯率\n→ Step 9: 建立更新按鈕 btn_update，點擊時呼叫 fetch_rate 並更新 label\n→ Step 10: 呼叫 fetch_rate 初始顯示匯率\n→ Step 11: 啟動 tkinter 主迴圈 mainloop\nEnd\n\nAlso we might include some explanation lines for decision. Ensure each line ends with // 解釋.\n\nWe need to ensure no actual code, just description. Use arrows properly. Use \"Decision:\" for condition.\n\nWe should maintain arrow indentation as per example. Use \"Yes →\" and \"No →\".\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入所需模組: requests, tkinter, json // 先載入網路與 UI 庫  \n→ Step 2: 定義函式 fetch_rate() // 建立取得匯率的功能  \n    → Step 3: 設定 API URL 為 'https://api.exchangerate-api.com/v4/latest/USD' // API 端點  \n    → Step 4: 使用 requests.get 取得回應 // 發送 HTTP GET 請求  \n    → Decision: 回應成功? // 檢查 HTTP 狀態碼是否 200  \n        Yes → Step 5: 解析 JSON 並取出 'rates' → 'TWD' 的值 // 取得美元兌台幣匯率  \n        No  → Step 6: 回傳 None 或錯誤訊息 // 失敗時回傳空值  \n→ Step 7: 建立 tkinter 視窗 root // 初始化主視窗  \n→ Step 8: 建立標籤 label_rate 以顯示匯率 // 供使用者查看匯率  \n→ Step 9: 建立更新按鈕 btn_update，點擊時呼叫 fetch_rate 並更新 label_rate // 按鈕功能  \n→ Step 10: 呼叫 fetch_rate 初始顯示匯率 // 第一次載入時顯示匯率  \n→ Step 11: 啟動 tkinter 主迴圈 mainloop // 開始 UI 事件循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val):\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        if val not in self.val_to_index:\n            return False\n        index = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[index] = last_val\n        self.val_to_index[last_val] = index\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.values)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將輸入包裝成一個合法的 Python 列表格式\n    wrapped = f'[{data}]'\n    try:\n        commands, args_list = ast.literal_eval(wrapped)\n    except Exception as e:\n        raise ValueError(\"Invalid input format\") from e\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"RandomizedSet\":\n            obj = RandomizedSet()\n            results.append(None)  # constructor returns null\n        elif cmd == \"insert\":\n            res = obj.insert(*args)\n            results.append(res)\n        elif cmd == \"remove\":\n            res = obj.remove(*args)\n            results.append(res)\n        elif cmd == \"getRandom\":\n            res = obj.getRandom()\n            results.append(res)\n        else:\n            # 忽略未知命令\n            results.append(None)\n\n    # 輸出結果，使用 json.dumps 以得到正確的格式\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for implementing RandomizedSet with operations in O(1). We need to produce lines: Start, then step lines with arrows. The code should use data structures: array (list) and hash map (value to index). Insert: if exists return false; else append to list, add to map, return true. Remove: if not exists return false; else get index of val, get last element, swap with last, update map for last, pop last from list, delete val from map, return true. getRandom: generate random index between 0 and len(list)-1, return list[index]. So we need to produce virtual code steps, not actual code, but structure.\n\nWe need to produce per line: \"虛擬碼步驟 // 解釋/說明\"\n\nWe should use Start, End. Use arrows for decisions. Provide steps. Let's produce high-level algorithm in lines.\n\nLet's consider: Start // Program start. Then maybe we need initialization. Step 1: Initialize array and map. Then operations: Insert, Remove, GetRandom.\n\nWe can produce separate subroutines? Use \"Subroutine: insert\" etc. For each, show steps. Provide decision lines.\n\nWe need to produce each line with \"→\" arrow from previous. We'll produce lines sequentially, maybe with indentation for substeps. For decisions we use \"Decision:\" and then Yes → etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Initialize 空的 list 'vals' 和 hash map 'idxMap' // 用於儲存元素及其索引\n\nNow for insert:\n\n→ Subroutine: insert(val) // 插入操作\n    → Decision: 如果 val 已存在於 idxMap? // 檢查元素是否已在集合中\n        Yes → Step: Return False // 既然已存在，插入失敗\n        No  → Step: 將 val 附加到 vals 列表尾部 // 將新元素加入\n        No  → Step: 在 idxMap 中記錄 val 的索引為 vals.size-1 // 建立索引對應\n        No  → Step: Return True // 插入成功\n\nSimilarly remove:\n\n→ Subroutine: remove(val) // 刪除操作\n    → Decision: 如果 val 不存在於 idxMap? // 檢查元素是否在集合中\n        Yes → Step: Return False // 不存在，刪除失敗\n        No  → Step: 取得 val 的索引 idx = idxMap[val] // 取得索引\n        No  → Step: 取得最後一個元素 lastVal = vals.last // 獲取最後一個元素\n        No  → Step: 將 lastVal 放到 idx 位置 vals[idx] = lastVal // 覆蓋待刪元素\n        No  → Step: 更新 idxMap[lastVal] = idx // 更新被覆蓋元素的索引\n        No  → Step: 從 vals 刪除最後一個元素 vals.pop() // 真正刪除\n        No  → Step: 從 idxMap 刪除 val // 移除索引映射\n        No  → Step: Return True // 刪除成功\n\nGetRandom:\n\n→ Subroutine: getRandom() // 隨機取得元素\n    → Step: 產生隨機索引 r 在 0 到 vals.size-1 之間 // 生成隨機位置\n    → Step: Return vals[r] // 返回該位置的元素\n\nEnd // 程式結束\n\nWe need to ensure each line uses \"→\" arrow, but for subroutine we might indent. But keep same format.\n\nWe must ensure each line contains \"虛擬碼步驟 // 解釋/說明\" format.\n\nLet's output each line accordingly.\n\nWe need to preserve indentation? Not required but maybe.\n\nLet's produce:\n\nStart // 程式開始執行\n→ 初始化 vals 為空列表，idxMap 為空哈希表 // 用於儲存元素及其索引\n→ Subroutine: insert(val) // 插入操作\n    → Decision: val 是否已在 idxMap? // 檢查元素是否存在\n        Yes → 返回 False // 已存在，插入失敗\n        No  → 附加 val 至 vals // 新元素放到尾部\n        No  → 記錄 idxMap[val] = vals.size-1 // 建立索引對應\n        No  → 返回 True // 插入成功\n→ Subroutine: remove(val) // 刪除操作\n    → Decision: val 是否在 idxMap? // 檢查元素是否存在\n        Yes → 返回 False // 不存在，刪除失敗\n        No  → 取得 idx = idxMap[val] // 取得元素索引\n        No  → 取得 lastVal = vals.last // 最後一個元素\n        No  → 把 lastVal 放到 vals[idx] // 覆蓋待刪元素\n        No  → 更新 idxMap[lastVal] = idx // 更新被覆蓋元素索引\n        No  → 刪除 vals.last // 真正移除最後元素\n        No  → 刪除 idxMap[val] // 移除索引映射\n        No  → 返回 True // 刪除成功\n→ Subroutine: getRandom() // 隨機取得元素\n    → 生成隨機索引 r 在 0~vals.size-1 // 隨機位置\n    → 返回 vals[r] // 返回隨機元素\nEnd // 程式執行結束\n\nBut we must ensure arrow format exactly: `→` before each step, but substeps maybe use same. But we need each line to have `虛擬碼步驟 // 解釋`. So each line should start with `→` or start with `Start`.\n\nBetter to not use indentation but maintain line breaks. But each line must contain `→` at beginning except Start, End. But subroutine lines may still start with `→` arrow. That's fine.\n\nLet's produce final answer accordingly.\n\nUse traditional Chinese explanations. Ensure each line ends with `//` comment.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化 vals 為空列表，idxMap 為空哈希表 // 用於儲存元素及其索引  \n→ Subroutine: insert(val) // 插入操作  \n→ → Decision: val 是否已在 idxMap? // 檢查元素是否存在  \n→ → → Yes → 返回 False // 已存在，插入失敗  \n→ → → No  → 附加 val 至 vals // 新元素放到尾部  \n→ → → No  → 記錄 idxMap[val] = vals.size-1 // 建立索引對應  \n→ → → No  → 返回 True // 插入成功  \n→ Subroutine: remove(val) // 刪除操作  \n→ → Decision: val 是否在 idxMap? // 檢查元素是否存在  \n→ → → Yes → 返回 False // 不存在，刪除失敗  \n→ → → No  → 取得 idx = idxMap[val] // 取得元素索引  \n→ → → No  → 取得 lastVal = vals.last // 最後一個元素  \n→ → → No  → 把 lastVal 放到 vals[idx] // 覆蓋待刪元素  \n→ → → No  → 更新 idxMap[lastVal] = idx // 更新被覆蓋元素索引  \n→ → → No  → 刪除 vals.last // 真正移除最後元素  \n→ → → No  → 刪除 idxMap[val] // 移除索引映射  \n→ → → No  → 返回 True // 刪除成功  \n→ Subroutine: getRandom() // 隨機取得元素  \n→ → 生成隨機索引 r 在 0~vals.size-1 // 隨機位置  \n→ → 返回 vals[r] // 返回隨機元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[1,0],[0,0],[2,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [1, 0], [0, 0], [2, 0], null, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, n_rows, n_cols):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        sys.exit()\n\n    # Wrap the input with brackets to parse it as a list of two lists\n    data = ast.literal_eval('[' + data_str + ']')\n    ops, args_list = data\n\n    results = []\n    sol = None\n\n    for i, op in enumerate(ops):\n        if op == \"Solution\":\n            sol = Solution(*args_list[i])\n            results.append(None)\n        elif op == \"flip\":\n            results.append(sol.flip())\n        elif op == \"reset\":\n            sol.reset()\n            results.append(None)\n\n    # Output the results as a JSON array to match expected format\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for algorithm to randomly pick index where 0, flip to 1. Need to minimize random calls, optimize time and space. Classic problem: Reservoir? Actually typical solution uses mapping of available indices: maintain a dictionary mapping from chosen index to last available index. Use a variable remaining = m*n. When flip: generate random k in [0, remaining-1], choose index k or mapping if exists else k. Then set mapping[k] = mapping[remaining-1] or remaining-1 if absent. decrement remaining. For reset: clear map, remaining = m*n.\n\nSo produce virtual code: Start, initialize map empty, remaining = m*n. Flip: if remaining==0? maybe error. random_k = random(0, remaining-1). i = k // n, j = k % n. Map k if present else k. After choosing chosen index, mapping[k] = mapping[remaining-1] if present else remaining-1. decrement remaining. Return [i, j]. Reset: clear map, remaining = m*n.\n\nProvide each line as virtual code step with comment. Use arrow \"→\". Use Start and End. Use Decision: but algorithm simple.\n\nLet's produce steps:\n\nStart\n→ Initialize variable rows=m, cols=n // store dimensions\n→ Initialize variable total=rows*cols // total cells\n→ Initialize variable remaining=total // remaining zero cells\n→ Initialize map = {} // mapping from index to replacement\n→ Define method flip()\n→ Decision: If remaining==0? // no zeros left\n→ Yes → Throw exception or return null // handle\n→ No  → Proceed\n→ Generate random integer k in [0, remaining-1] // random choice\n→ Set idx = map[k] if k in map else k // actual index to flip\n→ Compute i = idx // cols // row\n→ Compute j = idx % cols // column\n→ Set map[k] = map[remaining-1] if remaining-1 in map else remaining-1 // swap\n→ Decrement remaining\n→ Return [i, j] // flipped position\n→ End method flip\n→ Define method reset()\n→ Set remaining = total // reset count\n→ Clear map // empty mapping\n→ End method reset\nEnd\n\nBut each line must be a step. Use \"→\" and \"Decision:\". Should include each line with comment. Use the structure: \"→ Step: ... // explanation\". For decision, use \"Decision: If ...\". Use \"Yes →\" and \"No →\".\n\nLet's format:\n\nStart // 程式開始執行\n→ Initialize rows = m, cols = n // 儲存矩陣尺寸\n→ Initialize total = rows * cols // 總格數\n→ Initialize remaining = total // 尚未翻轉的 0 的格數\n→ Initialize map = {} // 目錄存放已選格的對應\n→ Define flip() // 定義翻轉方法\n→ Decision: 若 remaining == 0? // 檢查是否還有 0\n    Yes → Throw Exception // 無可選格，拋出例外\n    No  → Continue\n→ Generate random integer k in [0, remaining-1] // 隨機選一個位置\n→ Set idx = map[k] if k in map else k // 若 k 已映射則取映射值\n→ Set i = idx // cols // 計算列\n→ Set j = idx % cols // 計算行\n→ Set map[k] = map[remaining-1] if remaining-1 in map else remaining-1 // 更新映射以避免重複\n→ Decrement remaining by 1 // 減少未翻轉格數\n→ Return [i, j] // 回傳被翻轉的座標\n→ End flip // 結束 flip 方法\n→ Define reset() // 定義重置方法\n→ Set remaining = total // 將剩餘格數恢復\n→ Clear map // 清空映射\n→ End reset // 結束 reset 方法\nEnd // 程式執行結束\n\nNeed to use arrow arrow and indent? The example uses indentation for nested steps. So we need to indent under Decision lines. Also each step line includes \"→\" at beginning. For Decision line we use \"Decision: ...\" without arrow? Example uses \"Decision: 如果數字大於 0?\" So use \"Decision: ...\" as a line.\n\nUnder Decision we have \"Yes →\" etc lines.\n\nThus final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize rows = m, cols = n // 儲存矩陣尺寸  \n→ Initialize total = rows * cols // 總格數  \n→ Initialize remaining = total // 尚未翻轉的 0 的格數  \n→ Initialize map = {} // 目錄存放已選格的對應  \n→ Define flip() // 定義翻轉方法  \n→ Decision: 若 remaining == 0? // 檢查是否還有 0  \n  Yes → Throw Exception // 無可選格，拋出例外  \n  No  → Continue  \n→ Generate random integer k in [0, remaining-1] // 隨機選一個位置  \n→ Set idx = map[k] if k in map else k // 若 k 已映射則取映射值  \n→ Set i = idx // cols // 計算列  \n→ Set j = idx % cols // 計算行  \n→ Set map[k] = map[remaining-1] if remaining-1 in map else remaining-1 // 更新映射以避免重複  \n→ Decrement remaining by 1 // 減少未翻轉格數  \n→ Return [i, j] // 回傳被翻轉的座標  \n→ End flip // 結束 flip 方法  \n→ Define reset() // 定義重置方法  \n→ Set remaining = total // 將剩餘格數恢復  \n→ Clear map // 清空映射  \n→ End reset // 結束 reset 方法  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp31bzec0t.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmp31bzec0t.py\", line 40, in main\n    obj.buildDict(arg)\n  File \"/tmp/tmp31bzec0t.py\", line 9, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nfrom typing import List, Set\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words: Set[str] = set()\n\n    def buildDict(self, dictionary: List[str]) -> None:\n        self.words = set(dictionary)\n\n    def search(self, searchWord: str) -> bool:\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = 0\n            for a, b in zip(word, searchWord):\n                if a != b:\n                    diff += 1\n                    if diff > 1:\n                        break\n            if diff == 1:\n                return True\n        return False\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Input format: [\"op1\", \"op2\", ...], [arg1, arg2, ...]\n    ops, args = eval(data)\n\n    obj: MagicDictionary | None = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MagicDictionary\":\n            obj = MagicDictionary()\n            results.append(None)\n        elif op == \"buildDict\":\n            obj.buildDict(arg)\n            results.append(None)\n        elif op == \"search\":\n            res = obj.search(arg)\n            results.append(res)\n\n    # Convert results to the required string format\n    out_str = '[' + ', '.join(\n        'null' if r is None else ('true' if r else 'false')\n        for r in results\n    ) + ']'\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with comments. The requirement: not actual code, but pseudocode. Use Start, End, Decision, etc.\n\nWe need to design data structure: maybe store dictionary in a Trie or map of word lengths, but pseudocode is simple. For each word in dictionary, we could generate all patterns with one character replaced by placeholder, store mapping from pattern to word set. Then search: generate all patterns of searchWord by replacing each character with placeholder, check if any matches and not same word? Since requirement exactly one change, we need check if pattern exists but either pattern maps to multiple words or to same word? Actually if pattern exists but mapping to different word(s) or same but different index? For \"ab\" searchWord \"ab\" we can change one char to \"bb\" etc. If pattern exists mapping to other word than searchWord, return true.\n\nBut for simplicity pseudocode: store dictionary words; search: for each index i, for each char 'a' to 'z', if char != searchWord[i], replace char, check if exists in dictionary; if found, return true. This O(N * L * 26). But easier to understand.\n\nBut we need to produce virtual code lines with explanation. Use steps: Initialize, BuildDict, Search. We'll produce steps with loops. Use Decision. Show pseudo loops.\n\nWe must not output actual code but virtual pseudocode lines with arrow notation. Provide explanation after comment.\n\nLet's produce:\n\nStart\n→ MagicDictionary // 定義類別\n    → BuildDict(dictionary) // 建構字典\n        → For each word in dictionary\n            → Store word in set // 方便 O(1) 查找\n    → Search(searchWord) // 搜尋\n        → For i from 0 to length-1\n            → For each ch from 'a' to 'z'\n                → If ch != searchWord[i]\n                    → modified = replace character at i with ch\n                    → Decision: modified in set?\n                        Yes → Return true\n        → Return false\nEnd\n\nNeed to include Start and End. Provide virtual code lines.\n\nWe'll need to show loops and decisions. Use indentation? It's okay. Provide each line.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ MagicDictionary // 定義 MagicDictionary 類別  \n    → Constructor() // 建構子，初始化資料結構  \n        → wordSet ← Empty Set // 用於快速存取字典中的單字  \n    → buildDict(dictionary) // 設定字典  \n        → For each word in dictionary  \n            → wordSet.Add(word) // 將每個單字加入集合  \n    → search(searchWord) // 搜尋是否能改一個字符合字典  \n        → For i from 0 to Length(searchWord)-1  \n            → For ch from 'a' to 'z'  \n                → If ch ≠ searchWord[i]  \n                    → modified ← Replace character at i in searchWord with ch  \n                    → Decision: modified ∈ wordSet? // 檢查改後字是否在字典中  \n                        Yes → Return true // 找到符合條件的單字  \n        → Return false // 沒有任何一個改動能匹配字典  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Smallest Letter Greater Than Target",
      "source_file": "Leetcode/leetcode744.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"a\"",
          "expected_output": "\"c\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0_l09nt0.py\", line 21, in <module>\n    exec(data, {}, ns)\n  File \"<string>\", line 1\n    letters = [\"c\",\"f\",\"j\"], target = \"a\"\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp0_l09nt0.py\", line 23, in <module>\n    raise ValueError(\"Input format should contain 'letters' and 'target' assignments.\") from e\nValueError: Input format should contain 'letters' and 'target' assignments."
        },
        {
          "example_index": 1,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"c\"",
          "expected_output": "\"f\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpoz3doo8j.py\", line 21, in <module>\n    exec(data, {}, ns)\n  File \"<string>\", line 1\n    letters = [\"c\",\"f\",\"j\"], target = \"c\"\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpoz3doo8j.py\", line 23, in <module>\n    raise ValueError(\"Input format should contain 'letters' and 'target' assignments.\") from e\nValueError: Input format should contain 'letters' and 'target' assignments."
        },
        {
          "example_index": 2,
          "input": "letters = [\"x\",\"x\",\"y\",\"y\"], target = \"z\"",
          "expected_output": "\"x\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpad3qsjli.py\", line 21, in <module>\n    exec(data, {}, ns)\n  File \"<string>\", line 1\n    letters = [\"x\",\"x\",\"y\",\"y\"], target = \"z\"\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpad3qsjli.py\", line 23, in <module>\n    raise ValueError(\"Input format should contain 'letters' and 'target' assignments.\") from e\nValueError: Input format should contain 'letters' and 'target' assignments."
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def nextGreatestLetter(self, letters, target):\n        left, right = 0, len(letters) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if letters[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return letters[left % len(letters)]\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    # Prepare a namespace for exec to extract variables\n    ns = {}\n    try:\n        # Execute the input string as Python code to get 'letters' and 'target'\n        exec(data, {}, ns)\n    except Exception as e:\n        raise ValueError(\"Input format should contain 'letters' and 'target' assignments.\") from e\n    letters = ns.get(\"letters\")\n    target = ns.get(\"target\")\n    if letters is None or target is None:\n        raise ValueError(\"Input must define 'letters' and 'target' variables.\")\n    # Compute and output the result\n    result = Solution().nextGreatestLetter(letters, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines. Use Start, End, Decision, arrow, etc. No actual code. Provide explanation after //.\n\nThe problem: array of chars sorted non-decreasing, at least 2 distinct. Find smallest char > target; wrap around to first if none.\n\nWe need steps: Start, input array, target. We could iterate over array, check if char > target, return first found. If loop completes, return first char. Complexity O(n). Or binary search. But simpler linear scan is fine.\n\nSo virtual code:\n\nStart\n→ Step 1: 初始化 i = 0 // index\n→ Decision: i < length(letters)? // 检查是否还有元素\n    Yes → Step 2: 如果 letters[i] > target? // 比较当前字符\n        Yes → Step 3: 返回 letters[i] // 找到比目标大的最小字符\n        No  → Step 4: i = i + 1 // 移动到下一个字符\n    No  → Step 5: 返回 letters[0] // 所有字符都不大于目标，返回首字符\nEnd\n\nBut we need to incorporate loop; maybe use while. Could also use Decision inside loop.\n\nLet's produce:\n\nStart\n→ Step 1: i = 0 // 开始索引\n→ Decision: i < len(letters)? // 是否还有字符可检查\n    Yes → Decision: letters[i] > target? // 当前字符是否大于目标\n        Yes → Step 2: return letters[i] // 找到满足条件的字符\n        No  → Step 3: i = i + 1 // 继续检查下一个字符\n    No  → Step 4: return letters[0] // 没有找到，返回首字符\nEnd\n\nThat's it. Ensure no actual code. Use \"→\" arrows. Include each line. Use \"//\" explanation.\n\nLet's output exactly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i = 0 // 初始化索引指向陣列起始位置  \n→ Decision: i < len(letters)? // 是否還有字符可以檢查  \n Yes → Decision: letters[i] > target? // 判斷當前字符是否大於目標  \n  Yes → Step 2: return letters[i] // 找到最小且大於目標的字符，直接返回  \n  No  → Step 3: i = i + 1 // 沒找到，移動到下一個字符  \n No  → Step 4: return letters[0] // 所有字符都不大於目標，回傳陣列第一個字符  \nEnd // 程式執行結束"
    },
    {
      "title": "Find K Closest Elements",
      "source_file": "Leetcode/leetcode658.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "arr = [1,2,3,4,5], k = 4, x = 3",
          "expected_output": "[1,2,3,4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_96q2p2q.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmp_96q2p2q.py\", line 31, in main\n    data_dict = ast.literal_eval('{' + data + '}')\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {arr = [1,2,3,4,5], k = 4, x = 3}\n     ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "arr = [1,1,2,3,4,5], k = 4, x = -1",
          "expected_output": "[1,1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzix0onx2.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmpzix0onx2.py\", line 31, in main\n    data_dict = ast.literal_eval('{' + data + '}')\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {arr = [1,1,2,3,4,5], k = 4, x = -1}\n     ^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    @staticmethod\n    def findClosestElements(arr, k, x):\n        \"\"\"\n        使用二分搜尋確定最左側起點。\n        之後直接取連續的 k 個元素即可。\n        \"\"\"\n        left, right = 0, len(arr) - k\n        while left < right:\n            mid = (left + right) // 2\n            # 若 x 與 arr[mid] 的距離比 x 與 arr[mid + k] 的距離大，則左側不夠靠近\n            if x - arr[mid] > arr[mid + k] - x:\n                left = mid + 1\n            else:\n                right = mid\n        return arr[left:left + k]\n\ndef main():\n    \"\"\"\n    主函式：從標準輸入讀取字串，解析為 arr、k、x，\n    呼叫解法並將結果以「[a,b,c]」的格式輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入轉為字典，格式為 {arr: [...], k: ..., x: ...}\n    data_dict = ast.literal_eval('{' + data + '}')\n    arr = data_dict['arr']\n    k = data_dict['k']\n    x = data_dict['x']\n\n    result = Solution.findClosestElements(arr, k, x)\n    # 以不含空格的方式輸出\n    print('[' + ','.join(map(str, result)) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce step-by-step virtual code for the algorithm. It's typical: use binary search to find closest index, then two pointers to expand. We need to output each line with explanation.\n\nWe must not output actual code. Just virtual steps. We'll include Start, End, Decision blocks, arrows.\n\nLet's produce steps:\n\nStart\n→ Step 1: Input arr, k, x\n→ Step 2: Binary search to find insertion point index i where arr[i] >= x\n→ Decision: If i equals 0? // x smaller than all\n   Yes → Set left = 0, right = i (i=0)\n   No  → Decision: If i equals arr.length? // x larger than all\n         Yes → Set left = i-1, right = i-1\n         No  → Set left = i-1, right = i // two candidates\n→ Step 3: While k > 0\n   → Decision: If left < 0? // left out of bounds\n         Yes → right = right + 1\n         No  → Decision: If right >= arr.length? // right out of bounds\n                Yes → left = left - 1\n                No  → Decision: If |arr[left] - x| <= |arr[right] - x|? // choose closer\n                       Yes → left = left - 1\n                       No  → right = right + 1\n   → k = k - 1\n→ Step 4: Collect elements from left+1 to right inclusive into result\n→ Step 5: Return result\n\nBut need to format with arrows and comments. Use \"Decision:\" lines and sub-indents. Must use arrow \"Yes →\" and \"No →\". Also each line preceded by \"→\" except Start and End. For nested decisions, we can indent with spaces.\n\nLet's write it.\n\nAlso must ensure each line contains virtual code step + space + // explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 arr, k, x // 取得輸入的陣列、所需數量與目標值  \n→ Step 2: BinarySearch(arr, x) → idx // 用二分搜尋找出第一個 ≥ x 的索引  \n→ Decision: 如果 idx == 0? // x 小於所有元素  \n  Yes → left = -1, right = 0 // 左邊已不存在，右邊從第一個元素開始  \n  No  → Decision: 如果 idx == arr.length? // x 大於所有元素  \n    Yes → left = arr.length - 1, right = arr.length // 右邊已不存在，左邊從最後一個元素開始  \n    No  → left = idx - 1, right = idx // 左右各有一個候選  \n→ Step 3: While k > 0  \n  → Decision: 如果 left < 0? // 左邊已越界  \n    Yes → right = right + 1 // 只擴右邊  \n    No  → Decision: 如果 right >= arr.length? // 右邊已越界  \n      Yes → left = left - 1 // 只擴左邊  \n      No  → Decision: 如果 |arr[left] - x| <= |arr[right] - x|? // 選擇更接近 x 的邊  \n       Yes → left = left - 1 // 擴左邊  \n       No  → right = right + 1 // 擴右邊  \n  → k = k - 1 // 已選一個元素，遞減需要的數量  \n→ Step 4: result = SubArray(arr, left + 1, right) // 取從 left+1 到 right 的子陣列  \n→ Step 5: 返回 result // 結果已按升序排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpu9sofh6w.py\", line 85, in <module>\n    main()\n  File \"/tmp/tmpu9sofh6w.py\", line 80, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpu9sofh6w.py\", line 23, in __init__\n    self.lookup[(pref, suff)] = idx\n    ~~~~~~~~~~~^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom typing import List, Tuple, Dict\n\nclass WordFilter:\n    \"\"\"\n    特殊字典：根據前綴和後綴查詢詞彙索引。\n    使用哈希表將所有 (前綴, 後綴) 對映到最大索引值。\n    \"\"\"\n\n    def __init__(self, words: List[str]) -> None:\n        # key: (前綴, 後綴)，value: 詞彙的最大索引\n        self.lookup: Dict[Tuple[str, str], int] = {}\n        for idx, word in enumerate(words):\n            L = len(word)\n            # 對於每個前綴長度 i (0 .. L)\n            for i in range(L + 1):\n                pref = word[:i]\n                # 對於每個後綴長度 j (0 .. L)\n                for j in range(L + 1):\n                    suff = word[j:]\n                    # 只保留最大的索引\n                    self.lookup[(pref, suff)] = idx\n\n    def f(self, prefix: str, suffix: str) -> int:\n        \"\"\"\n        返回同時滿足前綴 prefix 和後綴 suffix 的詞彙索引。\n        若不存在則回傳 -1。\n        \"\"\"\n        return self.lookup.get((prefix, suffix), -1)\n\ndef split_top_level(s: str) -> List[str]:\n    \"\"\"\n    把以逗號分隔的兩個 JSON 陣列拆成兩個字串。\n    逗號只在最外層才是分隔符號。\n    \"\"\"\n    parts = []\n    cur = []\n    depth = 0\n    for ch in s:\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        if ch == ',' and depth == 0:\n            parts.append(''.join(cur).strip())\n            cur = []\n        else:\n            cur.append(ch)\n    if cur:\n        parts.append(''.join(cur).strip())\n    return parts\n\ndef main() -> None:\n    \"\"\"\n    主程式：\n    1. 讀取整行輸入，格式為兩個 JSON 陣列以逗號分隔，例如\n       '[[\"apple\"]], [\"a\", \"e\"]'\n    2. 解析成 words、prefix、suffix。\n    3. 建立 WordFilter，執行查詢，輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 拆分成兩個部分\n    parts = split_top_level(data)\n    if len(parts) != 2:\n        raise ValueError(\"輸入格式錯誤，應包含兩個 JSON 陣列\")\n\n    # 解析 JSON\n    words = json.loads(parts[0])\n    pref_suff = json.loads(parts[1])\n    if not isinstance(pref_suff, list) or len(pref_suff) != 2:\n        raise ValueError(\"後綴和前綴應為長度為 2 的陣列\")\n\n    prefix, suffix = pref_suff[0], pref_suff[1]\n\n    # 建構字典並查詢\n    wf = WordFilter(words)\n    result = wf.f(prefix, suffix)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations, step-by-step. The user wants to design a special dictionary with prefix and suffix search, implement WordFilter class with constructor and f method. We need to give a virtual algorithm. Likely use trie for prefix and suffix and combine indices. The virtual code can describe building two tries, storing list of indices, then intersection. So produce steps. Let's produce a structured plan: Start, build prefix trie, suffix trie (reversed), then f method logic: get list of indices for pref and suff, find largest common index. Also handle -1. End. Use arrow notation. Provide explanation for each line. Ensure each line includes virtual code step and comment. No actual code, just steps. Let's output.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 建立空的前綴 Trie 以及反向後綴 Trie // 準備兩棵樹以存儲前綴與後綴\n\n→ Decision: words 是否為空? // 檢查是否有單字供建構\n    Yes → Step 2: 直接回傳 // 若無單字，結束建構\n    No  → Continue // 有單字，進行建構\n\n→ Step 3: For each word 在 words 逐一遍歷 // 對每個單字進行插入\n    → Step 4: wordIndex ← 該單字在 words 中的索引 // 取得索引值\n    → Step 5: Insert word into 前綴 Trie，將 wordIndex 加入每個節點的索引列表 // 前綴查找使用\n    → Step 6: Reverse word 並 Insert into 後綴 Trie，將 wordIndex 加入每個節點的索引列表 // 後綴查找使用\n\n→ End // 建構完成\n\n→ Function f(pref, suff) // 定義查詢方法\n    → Step 7: prefList ← Search pref 在 前綴 Trie，獲得所有包含該前綴的索引列表 // 取得符合前綴的索引\n    → Step 8: suffList ← Search suff 在 後綴 Trie，獲得所有包含該後綴的索引列表 // 取得符合後綴的索引\n    → Decision: prefList 為空 或 suffList 為空? // 若任一列表為空，表示無符合\n        Yes → Step 9: Return -1 // 沒有符合單字，返回 -1\n        No  → Continue // 兩個列表皆非空，進一步搜尋\n\n    → Step 10: pointer1 ← prefList 結尾索引（最大值） // 從較大索引開始\n    → Step 11: pointer2 ← suffList 結尾索引（最大值） // 同上\n    → Step 12: While pointer1 >= 0 且 pointer2 >= 0 // 兩個指標同時向前移動\n        → Decision: prefList[pointer1] 與 suffList[pointer2] 是否相等? // 檢查是否同一個索引\n            Yes → Step 13: Return prefList[pointer1] // 找到最大的共同索引，直接回傳\n            No  → Decision: prefList[pointer1] > suffList[pointer2]? // 判斷哪個指標較大\n                Yes → pointer1 ← pointer1 - 1 // 移動前綴指標\n                No  → pointer2 ← pointer2 - 1 // 移動後綴指標\n\n    → Step 14: Return -1 // 若迴圈結束仍無匹配，表示無符合單字\n\n→ End // 程式執行結束"
    },
    {
      "title": "IPO",
      "source_file": "Leetcode/leetcode502.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplof4gnwx.py\", line 62, in <module>\n    main()\n  File \"/tmp/tmplof4gnwx.py\", line 57, in main\n    k, w, profits, capital = parse_input(input_data)\n                             ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmplof4gnwx.py\", line 46, in parse_input\n    vars_map[key] = ast.literal_eval(val)\n                    ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphvs05pc7.py\", line 62, in <module>\n    main()\n  File \"/tmp/tmphvs05pc7.py\", line 57, in main\n    k, w, profits, capital = parse_input(input_data)\n                             ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmphvs05pc7.py\", line 46, in parse_input\n    vars_map[key] = ast.literal_eval(val)\n                    ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, W: int, Profits: list[int], Capital: list[int]) -> int:\n        \"\"\"\n        使用二層堆疊的方式，在每一次選擇專案時\n        1. 把所有可負擔的專案利潤塞進最大堆\n        2. 取最大利潤並更新現有資本\n        \"\"\"\n        # 依資本需求升序排列所有專案，方便逐一掃描\n        projects = sorted(zip(Capital, Profits))\n        max_heap = []          # 儲存可負擔專案的利潤（負數存進最大堆）\n        i = 0                  # 指向下一個未處理專案\n        n = len(Profits)\n\n        for _ in range(k):\n            # 把所有目前可負擔的專案利潤塞進堆\n            while i < n and projects[i][0] <= W:\n                heapq.heappush(max_heap, -projects[i][1])  # 用負數做最大堆\n                i += 1\n            # 若堆中有可選專案，取最大利潤並更新資本\n            if max_heap:\n                W += -heapq.heappop(max_heap)\n            else:\n                # 沒有可負擔專案，結束迴圈\n                break\n        return W\n\ndef parse_input(data: str):\n    \"\"\"\n    從形如 'k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]' 的字串\n    解析出 k, w, profits, capital 四個參數。\n    \"\"\"\n    # 去除換行與空白，並拆分成各個變數表達式\n    parts = [p.strip() for p in data.split(',')]\n    vars_map = {}\n    for part in parts:\n        if not part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip().lower()          # 轉成小寫做對應\n        val = val.strip()\n        # 使用 literal_eval 解析字串成 Python 對象\n        vars_map[key] = ast.literal_eval(val)\n    k = vars_map.get('k', 0)\n    w = vars_map.get('w', 0)\n    profits = vars_map.get('profits', [])\n    capital = vars_map.get('capital', [])\n    return k, w, profits, capital\n\ndef main():\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return\n    k, w, profits, capital = parse_input(input_data)\n    result = Solution().findMaximizedCapital(k, w, profits, capital)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for the algorithm: classic Leetcode problem \"IPO\" (maximize capital). Use priority queue. Steps: create array of projects with profit and capital, sort by capital ascending. Use min-heap for capital requirement? Actually we need max-heap for profits of affordable projects. Process k times: while next project's capital <= current capital, push profit to max-heap. Then pop max profit, add to capital. Continue.\n\nWe produce virtual code lines, each with explanation. Use arrow. Use Start, End. Use Decision. Use variable names: projects, sorted, i, maxProfitHeap.\n\nWe should produce each step line by line.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 Project 類別，存放 profit 與 capital // 將每個專案的利潤和所需資本封裝\n→ Step 2: 將所有 project 轉成 list< Project > projects // 收集所有專案資料\n→ Decision: 是否需要對 projects 進行排序? // 為了能快速找出可負擔的專案\n    Yes → Step 3: 對 projects 按 capital 升序排序 // 先依資本需求排序，方便後續遍歷\n→ Step 4: 初始化 i = 0 // 用於指向排序後列表的下一個專案\n→ Step 5: 建立 maxProfitHeap // 儲存目前可負擔專案的利潤，取最大值\n→ Step 6: 將 initialCapital w 設為 currentCapital // 初始資本\n→ Decision: 是否還有剩餘的選擇次數 (k > 0)？ // 檢查是否可再選專案\n    Yes → Step 7: While i < projects.size() 且 projects[i].capital ≤ currentCapital\n        → Step 8: maxProfitHeap.add(projects[i].profit) // 把可負擔專案的利潤加入堆疊\n        → Step 9: i += 1 // 移動到下一個專案\n    End While\n    → Decision: maxProfitHeap 是否非空？ // 檢查是否有可執行專案\n        Yes → Step 10: currentCapital += maxProfitHeap.poll() // 取最大利潤，更新資本\n        No  → Step 11: 退出迴圈，無法再執行任何專案 // 所有剩餘專案都超出資本限制\n    → Step 12: k -= 1 // 已完成一個專案，減少可選項數\n    → Go back to Decision: 是否還有剩餘的選擇次數？ // 重複處理剩餘次數\n    No  → Step 13: 將 currentCapital 作為最終結果輸出 // 完成所有選擇或無法再執行\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()()\", \"(a())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\nimport threading\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        res = set()\n\n        # Count how many left and right parentheses need to be removed\n        left_rem, right_rem = 0, 0\n        for ch in s:\n            if ch == '(':\n                left_rem += 1\n            elif ch == ')':\n                if left_rem > 0:\n                    left_rem -= 1\n                else:\n                    right_rem += 1\n\n        def dfs(index, left_count, right_count, left_rem, right_rem, path):\n            # If we have processed all characters\n            if index == len(s):\n                if left_rem == 0 and right_rem == 0:\n                    res.add(path)\n                return\n\n            ch = s[index]\n\n            # If the current character is not a parenthesis, keep it\n            if ch not in ('(', ')'):\n                dfs(index + 1, left_count, right_count,\n                    left_rem, right_rem, path + ch)\n                return\n\n            # Option 1: skip the current parenthesis if we still need to remove one\n            if ch == '(' and left_rem > 0:\n                dfs(index + 1, left_count, right_count,\n                    left_rem - 1, right_rem, path)\n            if ch == ')' and right_rem > 0:\n                dfs(index + 1, left_count, right_count,\n                    left_rem, right_rem - 1, path)\n\n            # Option 2: keep the current parenthesis\n            if ch == '(':\n                dfs(index + 1, left_count + 1, right_count,\n                    left_rem, right_rem, path + ch)\n            else:  # ch == ')'\n                if left_count > right_count:\n                    dfs(index + 1, left_count, right_count + 1,\n                        left_rem, right_rem, path + ch)\n\n        dfs(0, 0, 0, left_rem, right_rem, \"\")\n        return list(res)\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Extract the string value after \"s = \"\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # If no match, use the whole input as the string\n        s = data.strip('\"')\n\n    solution = Solution()\n    results = solution.removeInvalidParentheses(s)\n    # Output as a JSON array to use double quotes\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    # Increase recursion limit and run main in a separate thread to avoid recursion depth issues\n    threading.stack_size(1 << 25)\n    thread = threading.Thread(target=main)\n    thread.start()\n    thread.join()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve: given string with parentheses, remove min invalid parentheses to make valid, return all unique solutions. This is classic problem (Leetcode 301). We need to produce pseudo-code step-by-step with explanations, using Start, Decision, etc.\n\nWe should outline BFS or DFS with pruning, counting removals.\n\nSimpler: compute left_removals, right_removals by scanning left to right. Then DFS with backtracking, generating all possible results, ensuring uniqueness via set, pruning when too many removals. The pseudocode should be line by line. We need to produce \"虛擬碼步驟\" and comment after space //.\n\nWe also need arrow notation, Start, End, Decision.\n\nLet's produce the algorithm in pseudo steps: Start, compute left_removal, right_removal. Then call DFS with index, left_count, right_count, left_rem, right_rem, path string builder, result set. In DFS: if index == len(s): if left_rem==0 and right_rem==0: add to result. return.\n\nOtherwise char = s[index]. If char not '(' or ')', add to path and call next. If char == '(':\n\n- Option 1: remove it if left_rem >0: DFS(index+1, left_count, right_count, left_rem-1, right_rem, path, result).\n- Option 2: keep it: DFS(index+1, left_count+1, right_count, left_rem, right_rem, path+'(', result).\n\nIf char == ')':\n\n- Option 1: remove it if right_rem >0: DFS(index+1, left_count, right_count, left_rem, right_rem-1, path, result).\n- Option 2: keep it if left_count>right_count: DFS(index+1, left_count, right_count+1, left_rem, right_rem, path+')', result).\n\nAdd pruning: if left_rem<0 or right_rem<0 return; if left_count>right_count? Actually left_count cannot be less than right_count? Wait, we maintain left_count as number of '(' kept, right_count as number of ')' kept. When encountering ')', we only keep it if left_count>right_count. This ensures validity.\n\nWe also need to avoid duplicates; we can use a result set.\n\nWe should produce pseudocode with line numbers? Not necessary. Just each line with explanation.\n\nWe'll produce algorithm steps:\n\nStart\n→ Step 1: Initialize left_rem = 0, right_rem = 0 // count mismatched parentheses to remove\n→ Decision: For each char c in s\n    Yes → If c == '(' → left_rem++ // need to remove later\n    No → If c == ')' → if left_rem > 0 → left_rem-- else → right_rem++ // unmatched right\nAfter loop, we have counts.\n\n→ Step 2: Initialize result set // store unique valid strings\n\n→ Step 3: Call DFS(0, 0, 0, left_rem, right_rem, \"\", result) // start recursion\n\nDFS function defined with parameters: index, left_count, right_count, left_rem, right_rem, path, result.\n\nInside DFS:\nStart // DFS function start\n→ Decision: If index == len(s)\n    Yes → Decision: If left_rem == 0 and right_rem == 0\n        Yes → Add path to result // valid string\n        No → Return // not valid\n    No → Continue\n\n→ Decision: Let c = s[index]\n    If c is not '(' or ')' // letter\n        → Step: Call DFS(index+1, left_count, right_count, left_rem, right_rem, path+c, result) // keep letter\n    Else If c == '('\n        → Decision: If left_rem > 0\n            Yes → Step: Call DFS(index+1, left_count, right_count, left_rem-1, right_rem, path, result) // remove '('\n        → Step: Call DFS(index+1, left_count+1, right_count, left_rem, right_rem, path+'(', result) // keep '('\n    Else // c == ')'\n        → Decision: If right_rem > 0\n            Yes → Step: Call DFS(index+1, left_count, right_count, left_rem, right_rem-1, path, result) // remove ')'\n        → Decision: If left_count > right_count\n            Yes → Step: Call DFS(index+1, left_count, right_count+1, left_rem, right_rem, path+')', result) // keep ')'\nEnd // DFS function end\n\nAfter DFS returns to main:\n→ Step: Convert result set to list // unique strings\n\n→ End // program finished\n\nWe should ensure each line has arrow notation. For Start/End lines we might not need arrow. We'll use format: Start // comment. Then \"→ Step...\" etc.\n\nLet's craft output lines accordingly.\n\nNeed to ensure \"虛擬碼步驟\" is before comment. The example used \"Start\" no arrow. So we follow that. For decisions we use \"Decision:\" etc.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 左刪除計數 left_rem ← 0, 右刪除計數 right_rem ← 0 // 初始化要刪除的括號數量  \n→ Decision: 遍歷 s 的每個字元 c  \n  Yes → Decision: 若 c = '('  \n    Yes → left_rem ← left_rem + 1 // 多餘左括號待刪除  \n    No → Decision: 若 c = ')'  \n     Yes → Decision: 若 left_rem > 0  \n       Yes → left_rem ← left_rem - 1 // 對應左括號已匹配，減少右刪除計數  \n      No → right_rem ← right_rem + 1 // 無對應左括號，右括號待刪除  \n  No → // 非括號字符，忽略  \n→ Step 2: 建立結果集合 result ← {} // 儲存所有唯一合法字串  \n→ Step 3: 呼叫 DFS(0, 0, 0, left_rem, right_rem, \"\", result) // 從索引0開始遞迴  \n→ End // 程式執行結束  \n\nDFS(index, left_cnt, right_cnt, left_rem, right_rem, path, result) // DFS 函式開始  \n → Decision: 若 index = len(s)  \n  Yes → Decision: 若 left_rem = 0 且 right_rem = 0  \n    Yes → result.add(path) // 已完成合法字串，加入集合  \n    No → Return // 刪除數量不正確，直接返回  \n  No → // 尚未遍歷完字元  \n → Let c ← s[index] // 取得目前字元  \n → Decision: 若 c 不是 '(' 或 ')'  \n  Yes → Step: DFS(index+1, left_cnt, right_cnt, left_rem, right_rem, path + c, result) // 保留字母  \n  No → Decision: 若 c = '('  \n    Yes → Decision: 若 left_rem > 0  \n      Yes → Step: DFS(index+1, left_cnt, right_cnt, left_rem-1, right_rem, path, result) // 刪除左括號  \n      No → // 無法刪除  \n      // 仍嘗試保留左括號  \n      Step: DFS(index+1, left_cnt+1, right_cnt, left_rem, right_rem, path + '(', result) // 保留左括號  \n    No → // c = ')'  \n    Yes → Decision: 若 right_rem > 0  \n      Yes → Step: DFS(index+1, left_cnt, right_cnt, left_rem, right_rem-1, path, result) // 刪除右括號  \n      No → // 無法刪除  \n      // 仍嘗試保留右括號  \n      Decision: 若 left_cnt > right_cnt  \n       Yes → Step: DFS(index+1, left_cnt, right_cnt+1, left_rem, right_rem, path + ')', result) // 保留右括號，確保左右平衡  \n      No → // 右括號保留會不平衡，直接返回  \n → End // DFS 函式結束  \n\n→ Step 4: 將 result 集合轉為列表 ans ← list(result) // 取得所有唯一合法字串  \n→ End // 程式結束。"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpthq1b2wx.py\", line 62, in <module>\n    main()\n  File \"/tmp/tmpthq1b2wx.py\", line 33, in main\n    ops_part, args_part = data.split('],[')\n    ^^^^^^^^^^^^^^^^^^^\nValueError: too many values to unpack (expected 2)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self):\n        if self.stack:\n            val = self.stack.pop()\n            if self.min_stack and val == self.min_stack[-1]:\n                self.min_stack.pop()\n\n    def top(self):\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self):\n        return self.min_stack[-1] if self.min_stack else None\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split the input into two lists: operations and arguments\n    ops_part, args_part = data.split('],[')\n    ops_part += ']'\n    args_part = '[' + args_part\n\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    stack = None\n    results = []\n\n    for i, op in enumerate(ops):\n        if op == 'MinStack':\n            stack = MinStack()\n            results.append(None)          # null in JSON\n        elif op == 'push':\n            val = args[i][0] if args[i] else None\n            stack.push(val)\n            results.append(None)\n        elif op == 'pop':\n            stack.pop()\n            results.append(None)\n        elif op == 'top':\n            results.append(stack.top())\n        elif op == 'getMin':\n            results.append(stack.getMin())\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, not actual code, but steps that correspond to implementing MinStack class with O(1). Provide each line with // explanation. Use arrow and decision. We'll need to illustrate using two stacks or single stack with min tracking. Probably two stacks: main stack and min stack. We'll produce steps: initialize, push: push val to main, if min stack empty or val <= top of min stack push val to min stack. pop: pop from main, if popped equals top of min stack then pop min stack. top: return top of main. getMin: return top of min stack. All O(1). Provide start/end. Let's produce as virtual code with steps.\n\nBe mindful to output each line as:\n\nStart // 程式開始執行\n→ Step 1: 定義 MinStack 類別 // 定義資料結構\n... etc.\n\nWe need to include decision nodes maybe for push/pop. For push: Decision: min stack empty? etc. For pop: Decision: popped equals min top? etc.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MinStack 類別，內部包含兩個空堆疊 mainStack 與 minStack // 兩個堆疊分別儲存所有元素與目前最小值  \n→ Step 2: 初始化 minStack 為空 // 以便後續推入元素時做比較  \n\n→ Step 3: push(val) // 將新值加入主堆疊  \n→ Decision: 是否 minStack 為空 或 val ≤ minStack.top()? // 判斷是否需要更新最小值  \n  Yes → Step 4: minStack.push(val) // 新值成為新的最小值  \n  No  → Step 5: 不做任何事 // 主堆疊已完成，最小值不變  \n\n→ Step 6: pop() // 移除主堆疊頂部元素  \n→ Step 7: temp ← mainStack.pop() // 取得被移除的值  \n→ Decision: temp == minStack.top()? // 判斷被移除的值是否是目前最小值  \n  Yes → Step 8: minStack.pop() // 同時移除 minStack 的最小值  \n  No  → Step 9: 不做任何事 // 最小值不受影響  \n\n→ Step 10: top() // 回傳主堆疊頂部元素  \n  Return mainStack.top() // 直接取得最上方值  \n\n→ Step 11: getMin() // 回傳目前最小值  \n  Return minStack.top() // 取得 minStack 的頂部即為全堆疊最小值  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder",
      "source_file": "Leetcode/leetcode127.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList) -> int:\n        \"\"\"\n        使用 BFS 找出最短轉換序列長度。\n        先把 wordList 放進集合，方便 O(1) 判斷。若 endWord 不在集合直接返回 0。\n        然後以 (current_word, current_length) 為佇列元素進行 BFS，當遇到 endWord 時即為最短路徑。\n        每個字串可透過替換每個位置的字母來生成相鄰字串，若相鄰字串存在於集合中，將其加入佇列並從集合移除以避免重複訪問。\n        \"\"\"\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return 0\n\n        queue = deque([(beginWord, 1)])  # (單字, 目前路徑長度)\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        wordSet.remove(new_word)\n                        queue.append((new_word, length + 1))\n        return 0\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    讀取整個輸入，期望的格式為：\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    這行會被包成字典後使用 eval 解析。若解析失敗則直接輸出 0。\n    \"\"\"\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        print(0)\n        sys.exit()\n\n    try:\n        # 將輸入字串包成字典字面值再 eval 取得 dict\n        data = eval(\"{\" + input_data + \"}\")\n        begin = data.get(\"beginWord\")\n        end = data.get(\"endWord\")\n        lst = data.get(\"wordList\", [])\n    except Exception:\n        # 無法解析輸入，回傳 0\n        print(0)\n        sys.exit()\n\n    solution = Solution()\n    result = solution.ladderLength(begin, end, lst)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines describing algorithm to find length of shortest transformation sequence. Use BFS. Steps: build adjacency by checking one-letter difference or precompute intermediate patterns. BFS queue of word and level. Return level+1 when end found. If no found return 0.\n\nWe produce each step line with virtual code syntax. Use Start, End, Decision, etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空集合 visited, 空佇列 queue // 用來追蹤已訪問過的單詞與 BFS 的佇列  \n→ Decision: 是否將 beginWord 加入 queue? // 確認起始點  \n    Yes → Step 2: queue.push(beginWord, 1) // 把 beginWord 及其距離 1 放入佇列  \n    No  → End // 若無法加入，直接結束  \n→ Step 3: 建立字典中所有單詞的通用模式映射 // 例如 \"hot\" → \"*ot\",\"h*t\",\"ho*\"  \n→ Step 4: 轉換為字典 wordMap: pattern → 所有匹配單詞列表  \n→ Decision: endWord 是否在 wordList? // 若不存在，無法轉換  \n    Yes → Step 5: 開始 BFS 迴圈  \n    No  → Step 6: 返回 0 // 直接結束  \n→ Step 5: While queue 不為空 // BFS 主迴圈  \n    → Step 5.1: 取出 (currentWord, level) 從 queue  \n    → Decision: currentWord 是否等於 endWord? // 找到最短路徑  \n        Yes → Step 5.1.1: 返回 level // 這即為最短序列長度  \n        No  → Step 5.1.2: 生成 currentWord 所有通用模式 list // \"*ot\",\"h*t\",\"ho*\"  \n            → Step 5.1.3: For 每個 pattern in list  \n                → Step 5.1.3.1: For 每個 neighborWord 在 wordMap[pattern]  \n                    → Decision: neighborWord 是否已在 visited?  \n                        Yes → Skip // 已處理過，跳過  \n                        No  → Step 5.1.3.1.1: visited.add(neighborWord)  \n                                → Step 5.1.3.1.2: queue.push(neighborWord, level + 1) // 探索下一層  \n→ End // BFS 結束，未找到 endWord，返回 0  \n→ Step 7: 返回 0 // 無法達到目標單詞的最短序列長度  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\ndef subsets_with_dup(nums):\n    nums.sort()\n    res = [[]]\n    prev = 0  # length of res before adding the previous element\n    for i, num in enumerate(nums):\n        start = prev if i > 0 and nums[i] == nums[i - 1] else 0\n        prev = len(res)\n        for j in range(start, len(res)):\n            res.append(res[j] + [num])\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        return\n    # Extract the list part from the input, e.g., \"nums = [1,2,2]\"\n    try:\n        if 'nums' in data:\n            start = data.index('[')\n            end = data.rindex(']') + 1\n            nums_str = data[start:end]\n        else:\n            nums_str = data\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        print(\"[]\")\n        return\n    result = subsets_with_dup(nums)\n    # Produce compact JSON-like output without spaces\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating power set of an integer array possibly with duplicates, ensuring no duplicate subsets. Approach: backtracking with sorting and skipping duplicates when same element repeated at same depth. Steps: sort nums, start backtrack(index, current). For each i from index to len(nums)-1: if i > index and nums[i]==nums[i-1] skip; add nums[i] to current, recurse with i+1, then pop. Also add current to results before loop. At the start, add empty set.\n\nWe need to output step-by-step virtual code, each line: \"虛擬碼步驟 // 解釋\". Use arrows and decision structure.\n\nLet's produce.\n\nNeed to start: Start // 程式開始執行\n→ Step 1: Sort input array nums // 先排序方便去重\n→ Step 2: Initialize result list res = [] // 用來儲存所有子集\n→ Step 3: Define recursive function backtrack(start, path) // 回溯函式，start 為下一個可選元素索引，path 為目前子集\n\nWe need to show inside backtrack: add copy of path to res; then for loop i from start to len(nums)-1; Decision: if i > start and nums[i]==nums[i-1] then skip; else add nums[i] to path, call backtrack(i+1, path), then pop.\n\nWe need to use virtual code lines.\n\nLet's craft lines:\n\nStart\n→ Step 1: Sort nums ascending // 排序後相同數字相鄰，便於跳過重複\n→ Step 2: Initialize empty list res // 用於收集所有子集\n→ Step 3: Define function backtrack(start, path) // 回溯函式，start 是下一個可選的索引\n\nInside function:\n\n→     // 將目前子集 path 加入結果\n→     Append a copy of path to res\n\n→     For i from start to length(nums)-1\n→         // 檢查是否為重複元素，且不是第一次遍歷\n→         Decision: If i > start AND nums[i] == nums[i-1]?\n→             Yes → Continue // 跳過此重複元素，避免重複子集\n→             No  → // 不重複\n→                 Append nums[i] to path\n→                 Call backtrack(i+1, path)\n→                 Remove last element from path // 回溯\n\nAfter function definition, call backtrack(0, [])\n\n→ Step 4: Return res // 完成後回傳所有子集\n\nEnd\n\nMake sure each line ends with // 解釋. Use arrow \"→\" preceding lines except Start and End. For decisions, show indentation. Also need to follow format: \"虛擬碼步驟 // 解釋\". The \"虛擬碼步驟\" includes the arrow if needed.\n\nMake sure no actual code, just pseudo. Use placeholders like \"Append copy of path to res\" etc.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先排序，方便後續跳過重複的元素  \n→ Step 2: Initialize empty list res // 用於收集所有子集  \n→ Step 3: Define function backtrack(start, path) // 回溯函式，start 為下一個可選的索引，path 為目前子集  \n\n    → Append copy of path to res // 將目前子集加入結果  \n\n    → For i from start to length(nums)-1 // 遍歷從 start 開始的所有元素  \n        → Decision: If i > start AND nums[i] == nums[i-1]? // 檢查是否為重複元素  \n            Yes → Continue // 跳過此重複元素，避免重複子集  \n            No  → // 非重複，進行以下步驟  \n                → Append nums[i] to path // 把元素加入當前子集  \n                → Call backtrack(i+1, path) // 以下一個索引遞迴  \n                → Remove last element from path // 回溯，移除剛加入的元素  \n\n→ Call backtrack(0, []) // 從索引 0 開始，初始子集為空  \n→ Step 4: Return res // 完成後回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,2]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    \"\"\"根據題目需求實作，將每個數字對應的索引保存在字典中，\n    並在 pick 時隨機挑選其中一個索引。\"\"\"\n    def __init__(self, nums):\n        # 建立數字 -> 所有索引的映射\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機選擇 target 的任一索引\n        return random.choice(self.indices[target])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入拆成操作列表和對應的參數列表\n    parts = data.split('],', 1)\n    ops_str = parts[0] + ']'          # 加回右括號\n    args_str = parts[1]\n\n    # 使用安全的 literal_eval 解析為 Python 結構\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    # 固定隨機種子，讓輸出可重現（方便範例驗證）\n    random.seed(0)\n\n    obj = None\n    outputs = []\n\n    for i, op in enumerate(ops):\n        if op == \"Solution\":\n            # 這個操作對應於建構子，參數為一個列表（nums）\n            obj = Solution(args[i][0])\n            outputs.append(None)      # 建構子不返回任何值\n        elif op == \"pick\":\n            # pick 的參數是目標值\n            res = obj.pick(args[i][0])\n            outputs.append(res)\n        else:\n            # 若出現未知操作，直接回傳 None\n            outputs.append(None)\n\n    # 將結果轉成 JSON 字串，確保 None 變成 null\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Should include Start, End, Decision. Outline algorithm: pre-process mapping from target to list of indices. pick selects random from list. Use reservoir? But simple random index from list.\n\nSteps:\nStart\n→ Initialize mapping (hash table) from target to list of indices. For each index i in nums: add i to map[nums[i]].\nImplement Solution constructor\nImplement pick: get list = map[target]; choose random index using uniform distribution: pick random integer between 0 and len-1; return list[random].\nReturn.\n\nUse virtual code arrows. Provide explanation after each line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n\n→ Step 1: 建立一個空的雜湊表 Map<Integer, List<Integer>> indexMap // 用來存放每個數字對應的所有索引  \n\n→ Decision: 是否已初始化 Solution？ // 判斷是否進入建構子  \n    Yes → Step 2: Constructor Solution(nums)  \n        → Step 2.1: 對於每個索引 i 從 0 到 nums.length-1  \n            → Step 2.1.1: key ← nums[i] // 取得當前數字  \n            → Decision: indexMap 是否已含 key?  \n                Yes → Step 2.1.2: list ← indexMap[key] // 取得已存在的索引列表  \n                No  → Step 2.1.3: list ← 新的空 List  \n                        → Step 2.1.4: indexMap[key] ← list // 將列表放入雜湊表  \n            → Step 2.1.5: list.add(i) // 把索引 i 加入對應數字的列表  \n        → End // 建構子完成，雜湊表已填充  \n    No  → End // 沒有建構子呼叫，結束  \n\n→ Decision: 是否要呼叫 pick(target)? // 判斷是否進入 pick 方法  \n    Yes → Step 3: pick(target)  \n        → Step 3.1: list ← indexMap[target] // 取得所有等於 target 的索引列表  \n        → Step 3.2: n ← list.size() // 列表長度  \n        → Step 3.3: r ← 隨機整數，範圍 [0, n-1] // 隨機選取位置  \n        → Step 3.4: return list[r] // 回傳隨機選出的索引  \n    No  → End // 沒有呼叫 pick，結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Regular Expression Matching",
      "source_file": "Leetcode/leetcode10.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "actual_output_or_error": "File \"/tmp/tmpmf5t1e2o.py\", line 6\n    \"\"\"正規表示式匹配，支援 '.' 與 '*'\" \n    ^\nSyntaxError: unterminated triple-quoted string literal (detected at line 41)"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"a*\"",
          "expected_output": "true",
          "actual_output_or_error": "File \"/tmp/tmpxhktjman.py\", line 6\n    \"\"\"正規表示式匹配，支援 '.' 與 '*'\" \n    ^\nSyntaxError: unterminated triple-quoted string literal (detected at line 41)"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\", p = \".*\"",
          "expected_output": "true",
          "actual_output_or_error": "File \"/tmp/tmpnr1ee03r.py\", line 6\n    \"\"\"正規表示式匹配，支援 '.' 與 '*'\" \n    ^\nSyntaxError: unterminated triple-quoted string literal (detected at line 41)"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"正規表示式匹配，支援 '.' 與 '*'\" \n        # 取得字串與模式長度\n        m, n = len(s), len(p)\n        # 建立 DP 表格，尺寸 (m+1) x (n+1)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        # 處理模式可否匹配空字串（僅 '*' 可以消除前面元素）\n        for j in range(2, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        # 主循環：逐字符對齊\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    # '*' 可能表示零次或多次前一元素\n                    dp[i][j] = dp[i][j - 2]  # 先嘗試零次\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n        return dp[m][n]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 從輸入中提取所有雙引號內的字串\n    parts = re.findall(r'\"([^\"]*)\"', raw_input)\n    # 依次取 s 與 p（若只有一個輸入則 p 為空字串）\n    s = parts[0] if len(parts) > 0 else \"\"\n    p = parts[1] if len(parts) > 1 else \"\"\n    # 執行匹配\n    result = Solution().isMatch(s, p)\n    # 輸出結果，使用小寫符合範例\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for regex matching with '.' and '*' support. Essentially implement isMatch(s, p) similar to Leetcode 10. Use DP. Provide virtual code line by line with explanation. Use Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋/說明\".\n\nWe should outline steps: initialize dp array (m+1)x(n+1). dp[0][0]=True. For j in 1..n: if p[j-1]=='*' and dp[0][j-2] True set dp[0][j] = True (pattern matches empty). Then iterate i in 1..m, j in 1..n. If p[j-1]==s[i-1] or p[j-1]=='.' then dp[i][j] = dp[i-1][j-1]. Else if p[j-1]=='*' then if p[j-2]==s[i-1] or p[j-2]=='.' then dp[i][j] = dp[i][j-2] or dp[i-1][j] else dp[i][j] = dp[i][j-2]. At end return dp[m][n].\n\nNeed to represent loops and decisions. Use arrow and indentation. Use \"→ Step: ...\" For loops we may use \"→ Loop: i from 1 to m\" etc.\n\nWe also need to consider variable names: m = len(s), n = len(p). Use Start. Use End.\n\nWe should include explanation each line. Avoid actual code. Just virtual steps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 m ← length of s, n ← length of p // 取得字串與模式長度  \n→ Step 2: 建立 dp 陣列，尺寸 (m+1) × (n+1)，預設 False // DP 表格初始化  \n→ Step 3: 設定 dp[0][0] ← True // 空字串與空模式匹配  \n→ Loop: j ← 1 to n // 處理模式能否匹配空字串  \n    → Decision: 如果 p[j-1] == '*'? // '*' 可能使前面元素消失  \n        Yes → Step 4: dp[0][j] ← dp[0][j-2] // 以前兩個位置決定是否能匹配空字串  \n        No → Step 5: dp[0][j] ← False // 其他字符無法匹配空字串  \n→ Loop: i ← 1 to m // 遍歷字串每個字符  \n    → Loop: j ← 1 to n // 遍歷模式每個字符  \n        → Decision: 如果 p[j-1] == '.' 或 p[j-1] == s[i-1]? // 正常字符匹配  \n            Yes → Step 6: dp[i][j] ← dp[i-1][j-1] // 匹配上一個位置的結果  \n            No → Step 7: Decision: p[j-1] == '*'? // '*' 需要特殊處理  \n                Yes → Step 8: Decision: p[j-2] == '.' 或 p[j-2] == s[i-1]? // '*' 前面元素能否匹配當前字符  \n                    Yes → Step 9: dp[i][j] ← dp[i][j-2] OR dp[i-1][j] // 零次或多次匹配  \n                    No  → Step 10: dp[i][j] ← dp[i][j-2] // '*' 只能消除前面元素，無字符匹配  \n                No → Step 11: dp[i][j] ← False // 其他情況不匹配  \n→ Step 12: 回傳 dp[m][n] // 完整字串是否與模式匹配  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef permute(nums):\n    \"\"\"\n    生成所有排列\n    \"\"\"\n    res = []\n\n    def backtrack(start):\n        if start == len(nums):\n            # 加入一個排列的複製\n            res.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            # 交換\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            # 反轉交換\n            nums[start], nums[i] = nums[i], nums[start]\n\n    backtrack(0)\n    return res\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析「nums = [1,2,3]」等格式\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n    # 使用 literal_eval 以安全方式解析列表\n    nums = ast.literal_eval(list_part.strip())\n\n    # 取得所有排列\n    perms = permute(nums)\n\n    # 手動格式化輸出，避免空格\n    out = '[' + ','.join('[' + ','.join(str(x) for x in p) + ']' for p in perms) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for generating all permutations of an array of distinct integers. Provide each line with virtual code and explanation. Use arrow, decision etc. Format lines with `→` or `Start`, `End`. Let's design algorithm: backtracking.\n\nSteps:\n\nStart\n→ Step 1: Initialize result list\n→ Step 2: Define recursive function backtrack(current permutation, used boolean array)\n→ Step 3: If current length == n, add to result\n→ Decision: For each index i 0..n-1\n   → Decision: If used[i] false?\n       Yes → Step 4: Mark used[i] true, append nums[i] to current\n              → Step 5: Call backtrack\n              → Step 6: Pop last element from current, set used[i] false\nEnd\n\nAlso we need to call backtrack initially.\n\nLet's format each line:\n\nStart // 程式開始執行\n→ Step 1: Let n ← length of nums // 取得陣列長度\n→ Step 2: Initialize result ← empty list // 儲存所有排列\n→ Step 3: Define backtrack(cur, used) // 回溯函式，cur為目前排列，used為已選擇指標\n→ Step 4: If length of cur == n → result.append(cur.copy()) // 完整排列時加入結果\n→ Step 5: For i from 0 to n-1\n    → Decision: If used[i] == False ?\n        Yes → Step 6: used[i] ← True // 標記第i個元素已使用\n              → Step 7: cur.append(nums[i]) // 加入排列\n              → Step 8: backtrack(cur, used) // 進行下一層\n              → Step 9: cur.pop() // 回溯：移除最後一個元素\n              → Step 10: used[i] ← False // 解除標記\n        No  → (跳過) // 當元素已被使用不再選取\n→ Step 11: Call backtrack([], [False]*n) // 開始回溯\n→ Step 12: Return result // 傳回所有排列\nEnd // 程式執行結束\n\nBut each line must have virtual code and explanation. For lines with indentation, we need arrow `→` for sub-steps. For decisions we use `Decision:` and `Yes →`, `No →`. Let's produce properly. Ensure each line is one line.\n\nUse Chinese explanation. Let's produce.\n\nAlso note that each sub-step inside loop must be indented with arrow. Use nested indentation but still each line separate.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: Let n ← length of nums // 取得輸入陣列長度\n→ Step 2: result ← empty list // 用來存放所有排列\n→ Step 3: Define backtrack(cur, used) // 回溯函式，cur為目前排列，used為已選指標\n→ Step 4: If length of cur == n → result.append(copy of cur) // 完成一個排列，加入結果\n→ Step 5: For i from 0 to n-1\n    → Decision: If used[i] == False ?\n        Yes → Step 6: used[i] ← True // 標記第i個元素已使用\n              → Step 7: cur.append(nums[i]) // 加入元素到排列\n              → Step 8: backtrack(cur, used) // 進一步回溯\n              → Step 9: cur.pop() // 回溯：移除最後加入的元素\n              → Step 10: used[i] ← False // 解除使用標記\n        No  → (跳過此 i) // 這個元素已被使用，不能再次選取\n→ Step 11: Call backtrack([], [False]*n) // 開始回溯過程\n→ Step 12: Return result // 傳回所有排列\nEnd // 程式執行結束\n\nNeed to ensure each line has arrow or start or end. For Decision, we need `Decision:` line and then Yes and No branches each preceded by arrow.\n\nWe must format like sample.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n ← length of nums // 取得輸入陣列長度  \n→ Step 2: result ← empty list // 用來存放所有排列  \n→ Step 3: Define backtrack(cur, used) // 回溯函式，cur為目前排列，used為已選指標  \n→ Step 4: If length of cur == n → result.append(copy of cur) // 完成一個排列，加入結果  \n→ Step 5: For i from 0 to n-1  \n  Decision: 如果 used[i] == False? // 檢查第 i 個元素是否未被使用  \n   Yes → Step 6: used[i] ← True // 標記第 i 個元素已使用  \n    → Step 7: cur.append(nums[i]) // 加入元素到目前排列  \n     → Step 8: backtrack(cur, used) // 進一步回溯  \n      → Step 9: cur.pop() // 回溯：移除最後加入的元素  \n       → Step 10: used[i] ← False // 解除使用標記  \n   No → (跳過此 i) // 此元素已被使用，不能再次選取  \n→ Step 11: Call backtrack([], [False]*n) // 開始回溯過程  \n→ Step 12: Return result // 傳回所有排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Rotate Array",
      "source_file": "Leetcode/leetcode189.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "expected_output": "[5,6,7,1,2,3,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[5,6,7,1,2,3,4]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[5,6,7,1,2,3,4]'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,-100,3,99], k = 2",
          "expected_output": "[3,99,-1,-100]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,99,-1,-100]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[3,99,-1,-100]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def rotate(self, nums, k):\n        if not nums:\n            return\n        k %= len(nums)\n        if k == 0:\n            return\n        nums[:] = nums[-k:] + nums[:-k]\n\ndef main():\n    # 讀取整行輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 轉換成字典字串，將 '=' 改成 ':'\n    transformed = raw_input.replace('nums =', 'nums:').replace('k =', 'k:')\n    # 包裝成字典，安全解析\n    try:\n        data = ast.literal_eval('{' + transformed + '}')\n    except Exception:\n        # 若解析失敗，直接退出\n        return\n    nums = data.get('nums', [])\n    k = data.get('k', 0)\n    sol = Solution()\n    sol.rotate(nums, k)\n    # 輸出結果\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code for rotating array to right by k steps. Use virtual pseudocode format. We should handle cases: k could be >= length. So k = k % n. Then reverse entire array, reverse first k, reverse rest. Or shift algorithm. We'll produce steps.\n\nNeed to adhere to format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Use arrow arrow → etc. We'll produce lines.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\nLine 2: → Step 1: 輸入 nums, k // 取得陣列和步數\nLine 3: → Decision: nums 是否為空? // 檢查陣列是否為空\n   Yes → End // 空陣列直接結束\n   No → Step 2: 計算 n = nums.length // 取得陣列長度\nLine 4: → Step 3: 計算 k = k % n // 將 k 取模以避免超過長度\nLine 5: → Decision: k 是否等於 0? // 如果 k 為 0，無需旋轉\n   Yes → End // 結束\n   No → Step 4: 反轉整個陣列 // 第一個子步驟：將陣列完全反轉\nLine 6: → Step 5: 反轉前 k 個元素 // 第二個子步驟：將前 k 個元素反轉\nLine 7: → Step 6: 反轉後 k 個元素 // 第三個子步驟：將剩餘元素反轉\nLine 8: End // 程式執行結束\n\nNeed to include arrow lines with indent. Use arrow arrow. Format: \"→ Step 1: ...\". For Decision branches use indentation and Yes → etc.\n\nLet's craft properly. Ensure each line ends with \"// 解釋\". Provide proper indentation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入 nums, k // 取得陣列與旋轉步數\n→ Decision: nums 是否為空? // 檢查陣列是否為空\n    Yes → End // 空陣列不做任何處理，結束程式\n    No  → Step 2: 計算 n = nums.length // 取得陣列長度\n→ Step 3: 計算 k = k % n // 將 k 取模，避免步數超過陣列長度\n→ Decision: k 是否等於 0? // 若步數為 0，陣列不變\n    Yes → End // 直接結束程式\n    No  → Step 4: 反轉整個陣列 // 將整個陣列倒序\n→ Step 5: 反轉前 k 個元素 // 將前 k 個元素倒序，完成第一段旋轉\n→ Step 6: 反轉後 k 個元素 // 將剩餘 n-k 個元素倒序，完成整體旋轉\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport collections\nimport ast\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 存放所有元素，支持 O(1) 取尾和替換\n        self.data = []\n        # 字典：value -> 集合，集合裡保存該 value 在 data 中的所有索引\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        # 把新值加到末尾\n        self.data.append(val)\n        # 索引是新元素在 data 中的位置\n        idx = len(self.data) - 1\n        self.idx_map[val].add(idx)\n        # 若是第一次出現，返回 True，否則 False\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        # 若該值不存在，直接返回 False\n        if not self.idx_map[val]:\n            return False\n        # 從索引集合取一個索引\n        remove_idx = self.idx_map[val].pop()\n        last_idx = len(self.data) - 1\n        last_val = self.data[last_idx]\n\n        # 用最後一個元素覆蓋要刪除的位置\n        self.data[remove_idx] = last_val\n\n        # 更新 last_val 的索引集合\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n\n        # 刪除尾部元素\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        # 隨機選取索引並返回對應元素\n        return random.choice(self.data)\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並解析成兩個列表\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 把輸入包成一個 tuple，使用 ast.literal_eval 解析\n    try:\n        ops, args = ast.literal_eval(f\"({raw_input})\")\n    except Exception as e:\n        # 若解析失敗，直接終止\n        sys.exit()\n\n    # 依序執行操作\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            results.append(None)  # constructor returns null\n        elif op == \"insert\":\n            res = obj.insert(arg[0])\n            results.append(res)\n        elif op == \"remove\":\n            res = obj.remove(arg[0])\n            results.append(res)\n        elif op == \"getRandom\":\n            res = obj.getRandom()\n            results.append(res)\n        else:\n            # 未知操作，忽略\n            results.append(None)\n\n    # 輸出結果，使用 json.dumps 以符合 LeetCode 風格（None -> null）\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this problem. The user wants \"逐行地產生對應的虛擬碼 (Virtual Code)\" for implementing RandomizedCollection. We should output each line with virtual code step and comment explanation. Use Start, End, Decision, arrows. We should not output actual code. Just a structured algorithm description. Should reflect average O(1) operations. Typical solution uses vector and hashmap from value to set of indices. So pseudo:\n\nStart // Initialize structures\n→ Step: Create list = [] // array of values\n→ Step: Create map = {} // val -> set of indices\nEnd\n\nFor insert:\n→ Step: Add val to list\n→ Step: index = list length -1\n→ Step: If val not in map then create set\n→ Step: Add index to map[val]\n→ Decision: If val was not previously in map? // check size of set before adding\n    Yes → Return true // new element\n    No  → Return false // existed before\n\nRemove:\n→ Decision: If val not in map or map[val] empty? // no occurrence\n    Yes → Return false\n    No  → Step: Pick an arbitrary index idx from map[val]\n    Step: Remove idx from map[val]\n    Step: last = list last element\n    Step: lastIdx = list length -1\n    Step: Replace list[idx] with last\n    Step: Remove last from list\n    Step: If idx != lastIdx:\n        → Step: Remove lastIdx from map[last]\n        → Step: Add idx to map[last]\n    → Decision: If map[val] empty? // after removal\n        Yes → Delete map[val]\n    → Return true\n\ngetRandom:\n→ Step: Randomly pick index from 0 to len(list)-1\n→ Return list[index]\n\nWe need to output each line with explanation. Use arrow '→'. For decisions we need indentation.\n\nLet's produce lines accordingly.\n\nWe should include Start and End of overall algorithm? Possibly separate for each method. We can produce sections: class initialization, insert, remove, getRandom. Each with Start and End. Let's format.\n\nEnsure each line: \"虛擬碼步驟 // 解釋\". Use arrow at beginning of steps, decision lines use \"Decision:\".\n\nLet's craft.\n\n...done thinking.\n\nStart // 初始化 RandomizedCollection\n→ Step: Create list = [] // 用於存放所有元素，支持 O(1) 取尾和替換\n→ Step: Create map = {} // 字典：key 為值，value 為該值所在 list 的所有索引集合\nEnd // 初始化完成\n\n// ---------- insert ----------\nStart // 插入元素\n→ Step: Append val to list // 把新值放到末尾，時間 O(1)\n→ Step: index = list length - 1 // 獲取新值的索引\n→ Decision: 如果 map 中沒有 key val? // 判斷 val 是否首次出現\n    Yes → Step: map[val] = new empty set // 建立索引集合\n    No  → // 已有集合，直接使用\n→ Step: Add index to map[val] // 將索引加入集合\n→ Decision: 如果 map[val] 大小剛好為 1? // 判斷是否為第一次插入\n    Yes → Step: Return true // val 原本不存在\n    No  → Step: Return false // val 已存在\nEnd // 插入結束\n\n// ---------- remove ----------\nStart // 刪除元素\n→ Decision: 如果 val 不在 map 或 map[val] 為空? // 沒有該值可刪\n    Yes → Step: Return false // 無法刪除\n    No  → // 有可刪元素\n→ Step: Pick an arbitrary idx from map[val] // 取其中一個索引\n→ Step: Remove idx from map[val] // 從索引集合中移除\n→ Step: lastIdx = list length - 1 // 取得最後一個元素的索引\n→ Step: lastVal = list[lastIdx] // 取得最後一個元素\n→ Step: Replace list[idx] with lastVal // 用最後元素覆蓋被刪元素\n→ Step: Remove last element from list // 把尾部刪除，時間 O(1)\n→ Decision: 如果 idx != lastIdx? // 需要更新索引映射\n    Yes →\n        → Step: Remove lastIdx from map[lastVal] // 移除舊索引\n        → Step: Add idx to map[lastVal] // 加入新索引\n    No → // idx 與 lastIdx 相同，無需更新\n→ Decision: 如果 map[val] 現在為空? // 刪除完畢後是否還有該值\n    Yes → Step: Delete map[val] // 清理鍵\n    No  → // 仍有剩餘元素\n→ Step: Return true // 成功刪除一個\nEnd // 刪除結束\n\n// ---------- getRandom ----------\nStart // 隨機取元素\n→ Step: randomIdx = random integer in [0, list length - 1] // 隨機索引\n→ Step: Return list[randomIdx] // 取出並返回\nEnd // 隨機取結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport json\nimport ast\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (invert sign)\n        self.large = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        heapq.heappush(self.small, -num)\n        # maintain order property\n        if self.large and -self.small[0] > self.large[0]:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # rebalance sizes\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入分為兩個列表：操作名稱和對應參數\n    if data.count('[') >= 2:\n        idx = data.find('],')\n        if idx != -1:\n            ops_str = data[:idx + 1]\n            args_str = data[idx + 2:].strip()\n        else:\n            parts = data.splitlines()\n            if len(parts) >= 2:\n                ops_str = parts[0].strip()\n                args_str = parts[1].strip()\n            else:\n                parts = data.split(',')\n                ops_str = parts[0]\n                args_str = parts[1]\n    else:\n        parts = data.splitlines()\n        if len(parts) >= 2:\n            ops_str = parts[0].strip()\n            args_str = parts[1].strip()\n        else:\n            parts = data.split(',')\n            ops_str = parts[0]\n            args_str = parts[1]\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            results.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            results.append(None)\n        elif op == \"findMedian\":\n            results.append(obj.findMedian())\n\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code with step-by-step explanation, no actual code, just pseudocode. We need to implement MedianFinder with addNum and findMedian. Typically use two heaps: max-heap for lower half, min-heap for upper half. So pseudocode: Start; Step 1: initialize two heaps; addNum: if lower empty or num <= top of lower, insert into lower else insert into upper; rebalance sizes difference <=1; findMedian: if sizes equal, return (top lower + top upper)/2; else return top of larger heap.\n\nWe'll output line by line with arrows and decision structures.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 初始化兩個堆：max-heap low, min-heap high // 用於分割數據\n\n→ Step 2: addNum(num) // 由使用者添加新數字\n\n→ Decision: 是否 low 堆為空或 num <= low.top? // 判斷放入哪個堆\n\n    Yes → low.push(num) // 放入低半堆\n\n    No  → high.push(num) // 放入高半堆\n\n→ Step 3: 調整堆平衡 // 使兩堆大小差不超過1\n\n    Decision: low.size() > high.size() + 1? // low 太大\n\n        Yes → high.push(low.top()); low.pop(); // 移到 high\n\n        No  → Decision: high.size() > low.size() + 1? // high 太大\n\n            Yes → low.push(high.top()); high.pop(); // 移到 low\n\n            No → // 平衡 OK\n\n→ Step 4: findMedian() // 計算中位數\n\n→ Decision: low.size() == high.size()? // 大小相等\n\n    Yes → return (low.top() + high.top()) / 2.0 // 平均\n\n    No  → Decision: low.size() > high.size()? // low 大\n\n        Yes → return low.top() // 返回低堆最大值\n\n        No  → return high.top() // 返回高堆最小值\n\nEnd // 程式結束\n\nWe need to maintain virtual code lines each with explanation comment. We should use arrow for decisions and steps. Also mention End.\n\nMake sure each line ends with // explanation.\n\nAlso use proper Chinese comments. Ensure each line is separate. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個堆：max-heap low（存較小的一半）、min-heap high（存較大的一半） // 建立兩個資料結構以分割數據  \n→ Step 2: addNum(num) // 由使用者加入新數字到資料結構  \n→ Decision: 是否 low 堆為空或 num ≤ low.top()？ // 判斷數字屬於哪一半  \n    Yes → low.push(num) // 放入低半堆  \n    No  → high.push(num) // 放入高半堆  \n→ Step 3: 調整堆平衡 // 使兩堆大小差不超過 1  \n    Decision: low.size() > high.size() + 1? // low 堆過大  \n        Yes → high.push(low.top()); low.pop(); // 將最大值移至 high  \n        No  → Decision: high.size() > low.size() + 1? // high 堆過大  \n            Yes → low.push(high.top()); high.pop(); // 將最小值移至 low  \n            No → // 堆已平衡，無需操作  \n→ Step 4: findMedian() // 計算目前所有元素的中位數  \n→ Decision: low.size() == high.size()? // 兩堆大小相等  \n    Yes → return (low.top() + high.top()) / 2.0 // 返回兩中位值的平均  \n    No  → Decision: low.size() > high.size()? // low 堆較大  \n        Yes → return low.top() // 返回低堆最大值  \n        No  → return high.top() // 返回高堆最小值  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        # 存放的區間皆為非重疊且已排序的 [start, end) 形式\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                # 完全在左側，保持不變\n                new_ranges.append([l, r])\n            elif right < l:\n                # 完全在右側，先插入新的區間\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                # 重疊，合併區間\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        # 用 bisect 取得最靠近 left 的區間\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                # 完全不重疊，保持\n                new_ranges.append([l, r])\n            else:\n                # 有重疊，按情況裁切\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main():\n    lines = [line.strip() for line in sys.stdin.read().splitlines() if line.strip()]\n    objects = {}\n    outputs = []\n\n    for line in lines:\n        # 初始化物件\n        if line.startswith('RangeModule'):\n            # 例如: RangeModule rangeModule = new RangeModule();\n            parts = line.split('=')\n            left_part = parts[0].strip()  # \"RangeModule rangeModule\"\n            var_name = left_part.split()[-1]  # \"rangeModule\"\n            objects[var_name] = RangeModule()\n            outputs.append(None)\n            continue\n\n        # 方法呼叫\n        if '.' in line:\n            var_name, method_call = line.split('.', 1)\n            method_name, args_part = method_call.split('(')\n            args_part = args_part.rstrip(');')\n            args = [int(a.strip()) for a in args_part.split(',')] if args_part else []\n\n            obj = objects.get(var_name)\n            if obj is None:\n                continue  # 未定義物件，忽略\n\n            if method_name == 'addRange':\n                obj.addRange(*args)\n                outputs.append(None)\n            elif method_name == 'removeRange':\n                obj.removeRange(*args)\n                outputs.append(None)\n            elif method_name == 'queryRange':\n                result = obj.queryRange(*args)\n                outputs.append(result)\n\n    # 以指定格式輸出結果\n    result_str = '[' + ', '.join(\n        'null' if v is None else ('true' if v else 'false')\n        for v in outputs\n    ) + ']'\n    print(result_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing RangeModule with addRange, queryRange, removeRange. Use steps and decisions. Just pseudo-logic. Use intervals stored maybe as list of non-overlapping sorted intervals. Implementation: Use list, or TreeMap. We'll just design conceptual. Provide steps like Start, Step 1: Initialize empty list. For addRange: find position, merge overlaps, insert. For queryRange: iterate intervals. For removeRange: find overlaps and cut.\n\nWe must output line by line virtual code with explanation comments. Use arrows and decisions.\n\nLet's produce pseudo-steps.\n\nStart.\n\n→ Step 1: Create empty list Intervals // list of [start, end) non-overlapping sorted.\n\nThen implement methods.\n\nMethod addRange(left,right):\n\n→ Step 2: Find first interval with end > left? Or use binary search. We'll just say iterate.\n\n→ Decision: If left <= interval.start and right >= interval.end? etc.\n\nBetter: Use while loop to merge.\n\nSimplify: Use variable newL=left, newR=right, remove overlapped intervals, then insert new interval.\n\nWe'll produce pseudo code:\n\n→ Step 3: For each interval in Intervals:\n    - If interval.end < left: continue\n    - If interval.start > right: break\n    - Update newL = min(newL, interval.start)\n    - Update newR = max(newR, interval.end)\n    - Mark interval for removal\n→ Step 4: Remove marked intervals\n→ Step 5: Insert [newL,newR] in sorted position\n\nFor queryRange:\n\n→ Step 6: For each interval:\n    - If interval.start <= left and interval.end >= right: return true\n    - If interval.end < left: continue\n    - If interval.start > left: return false\n→ return false\n\nFor removeRange:\n\n→ Step 7: For each interval overlapping with [left,right):\n    - If interval.start < left and interval.end > right: split into [interval.start, left) and [right, interval.end)\n    - Else if interval.start < left and interval.end <= right: adjust end to left\n    - Else if interval.start >= left and interval.end > right: adjust start to right\n    - Else if interval.start >= left and interval.end <= right: remove entire interval\n\nImplementation details: We'll need to collect modifications, then apply.\n\nLet's craft virtual code lines.\n\nWe should also provide class definition.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 RangeModule：空列表 Intervals ← [] // 存放非重疊且已排序的 [start, end)  \n\n// -------------------------- addRange --------------------------  \n→ Step 2: addRange(left, right)：  \n    → Variable newL ← left, newR ← right  \n    → List removeList ← [] // 需要刪除的區間  \n    → Decision: 遍歷 Intervals  \n        Yes → For each interval [s, e) in Intervals  \n            → Decision: e <= newL? // 完全在左側  \n                Yes → 跳過 // 仍不重疊  \n                No → Decision: s >= newR? // 完全在右側  \n                    Yes → Break // 之後的區間不可能再重疊  \n                    No → // 重疊部分  \n                        → newL ← min(newL, s) // 合併左邊界  \n                        → newR ← max(newR, e) // 合併右邊界  \n                        → removeList.add([s, e]) // 記錄要刪除的區間  \n        No → // 迴圈結束  \n    → Decision: removeList 不是空？  \n        Yes → For each rem in removeList: Intervals.remove(rem) // 刪除所有重疊區間  \n        No → // 無需刪除  \n    → Decision: newL >= newR? // 加入後區間為空  \n        Yes → Return // nothing to add  \n        No → // 將新的合併區間插入並保持排序  \n            → Find insertPos：索引 i 使得 Intervals[i].start > newL  \n            → Intervals.insert(insertPos, [newL, newR])  \n→ End addRange // addRange 方法結束  \n\n// -------------------------- queryRange --------------------------  \n→ Step 3: queryRange(left, right)：  \n    → Decision: Intervals 為空？  \n        Yes → Return False // 無區間覆蓋任何數  \n        No → // 進行遍歷  \n    → For each interval [s, e) in Intervals  \n        → Decision: s <= left AND e >= right? // 完全覆蓋  \n            Yes → Return True  \n            No → Decision: e < left? // 仍在左側  \n                Yes → Continue // 進入下一區間  \n                No → Decision: s > left? // 下一區間開始在左側之外  \n                    Yes → Return False // 右側區間不覆蓋 left  \n                    No → // 進一步檢查下一區間  \n    → Return False // 沒有一個區間能覆蓋整個 [left, right)  \n\n// -------------------------- removeRange --------------------------  \n→ Step 4: removeRange(left, right)：  \n    → List newIntervals ← [] // 重新組裝後的區間  \n    → For each interval [s, e) in Intervals  \n        → Decision: e <= left OR s >= right? // 完全不重疊  \n            Yes → newIntervals.append([s, e]) // 保留不變  \n            No → // 需要裁剪或分割  \n                → Decision: s < left AND e > right? // 整個區間被 [left, right) 截斷  \n                    Yes → newIntervals.append([s, left]) // 左半部分保留  \n                    Yes → newIntervals.append([right, e]) // 右半部分保留  \n                    No → Decision: s < left AND e <= right? // 右邊被移除  \n                        Yes → newIntervals.append([s, left]) // 只保留左半  \n                        No → Decision: s >= left AND e > right? // 左邊被移除  \n                            Yes → newIntervals.append([right, e]) // 只保留右半  \n                            No → // 整個區間完全在 [left, right) 內，直接丟棄  \n    → Intervals ← newIntervals // 更新為裁剪後的區間  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpamwqx3x6.py\", line 61, in <module>\n    commands = json.loads(data[0])      # 例如 [\"MyCircularDeque\",\"insertLast\",...]\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k):\n        self.k = k                      # 最大容量\n        self.buf = [0] * k              # 儲存元素的固定長度陣列\n        self.head = 0                   # 指向前端元素的索引\n        self.count = 0                  # 當前元素個數\n\n    def insertFront(self, value):\n        if self.count == self.k:\n            return False                # 已滿，無法插入\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value):\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self):\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self):\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self):\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self):\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self):\n        return self.count == 0\n\n    def isFull(self):\n        return self.count == self.k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    commands = json.loads(data[0])      # 例如 [\"MyCircularDeque\",\"insertLast\",...]\n    args = json.loads(data[1])          # 例如 [[3],[1],[2],...]\n\n    result = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MyCircularDeque\":\n            obj = MyCircularDeque(*arg)\n            result.append(None)        # constructor的返回值為 null\n        else:\n            func = getattr(obj, cmd)\n            ret = func(*arg)\n            result.append(ret)\n\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines following the format: each line has \"虛擬碼步驟 // 解釋\". Use arrows and structure: Start, End, Decision:. We need to design implementation of circular double-ended queue. Provide steps for methods.\n\nWe need to output virtual code step by step for entire class. Probably include initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.\n\nUse comments in Chinese.\n\nMake sure to use \"→\" arrow for steps. For decision blocks use \"Decision:\".\n\nStructure: Start, then steps, then End.\n\nLet's produce.\n\nWe need to incorporate array, head, tail, size, capacity.\n\nOk. Let's produce lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCircularDeque 類別 // 建立類別框架  \n→ Step 2: 宣告 private 數組 buffer[capacity] // 用來儲存元素  \n→ Step 3: 宣告 private 整數 head = 0 // 指向前端索引  \n→ Step 4: 宣告 private 整數 tail = 0 // 指向後端索引  \n→ Step 5: 宣告 private 整數 size = 0 // 當前元素個數  \n→ Step 6: 宣告 private 整數 capacity // 最大容量  \n\n→ Step 7: MyCircularDeque(int k) // 建構子  \n  → Assignment: capacity = k  \n  → Allocation: buffer = new 數組[capacity]  \n  → Initialization: head = 0, tail = 0, size = 0  \n\n→ Step 8: boolean insertFront(int value) // 前端插入  \n  → Decision: 如果 isFull()? // 檢查是否已滿  \n    Yes → Return false // 無法插入，返回失敗  \n    No  → Step 9: head = (head - 1 + capacity) mod capacity // 移動前端索引  \n      → buffer[head] = value // 放入新值  \n      → size++  \n      → Return true // 插入成功  \n\n→ Step 9: boolean insertLast(int value) // 後端插入  \n  → Decision: 如果 isFull()?  \n    Yes → Return false  \n    No  → Step 10: buffer[tail] = value // 放入新值  \n      → tail = (tail + 1) mod capacity // 移動後端索引  \n      → size++  \n      → Return true  \n\n→ Step 11: boolean deleteFront() // 前端刪除  \n  → Decision: 如果 isEmpty()? // 檢查是否空  \n    Yes → Return false // 無法刪除，返回失敗  \n    No  → Step 12: head = (head + 1) mod capacity // 移動前端索引  \n      → size--  \n      → Return true // 刪除成功  \n\n→ Step 13: boolean deleteLast() // 後端刪除  \n  → Decision: 如果 isEmpty()?  \n    Yes → Return false  \n    No  → Step 14: tail = (tail - 1 + capacity) mod capacity // 移動後端索引  \n      → size--  \n      → Return true  \n\n→ Step 15: int getFront() // 取得前端元素  \n  → Decision: 如果 isEmpty()?  \n    Yes → Return -1 // 空，返回 -1  \n    No  → Return buffer[head] // 返回前端值  \n\n→ Step 16: int getRear() // 取得後端元素  \n  → Decision: 如果 isEmpty()?  \n    Yes → Return -1  \n    No  → Let idx = (tail - 1 + capacity) mod capacity // 後端實際索引  \n      → Return buffer[idx]  \n\n→ Step 17: boolean isEmpty() // 判斷是否空  \n  → Return size == 0 // 若 size 為 0 表示空  \n\n→ Step 18: boolean isFull() // 判斷是否滿  \n  → Return size == capacity // 若 size 等於容量表示滿  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,5,5,8,8]'\nGot (Norm):      '[None,4,5,5,8,8]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 5, 5, 8, 8]'\nRaw Got:      '[None, 4, 5, 5, 8, 8]'"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,7,7,7,8]'\nGot (Norm):      '[None,7,7,7,8]'\n--- (Raw) ---\nRaw Expected: '[null, 7, 7, 7, 8]'\nRaw Got:      '[None, 7, 7, 7, 8]'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把整個輸入包成一個列表，方便解析成兩個子列表\n    data = '[' + data + ']'\n    methods, args_list = ast.literal_eval(data)\n\n    results = []\n    obj = None\n    for i, method in enumerate(methods):\n        if i == 0:  # 建構子\n            k, nums = args_list[i][0], args_list[i][1]\n            obj = KthLargest(k, nums)\n            results.append(None)\n        else:\n            # args_list[i] 本身是個列表，例如 [3] 或 [5]\n            res = getattr(obj, method)(*args_list[i])\n            results.append(res)\n\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo code for class KthLargest with constructor and add method, maintaining kth largest. We must not output actual code, just virtual code lines with explanation. Use arrow notation. Let's design algorithm: Use min-heap of size k. Insert initial nums: for each number, push to heap; if size > k, pop smallest. After construction, kth largest is heap root. For add(val): push val; if size > k pop smallest. Return heap root.\n\nLet's produce virtual code steps. Include Start, End. Use steps, decisions.\n\nWe need to produce per-line steps. Provide explanation. We'll use \"Start\" at top. Then \"Step 1: Initialize k and heap\" etc.\n\nBetter to structure:\n\nStart\n→ Step 1: Set k = input k // store k\n→ Step 2: Create empty min-heap // to hold k largest scores\n→ Decision: Are there initial nums? // if array provided\n    Yes → Loop over each num in nums\n        → Step 3: Add num to heap\n        → Decision: Heap size > k?\n            Yes → Step 4: Remove smallest from heap\n            No → (do nothing)\n    No → (skip)\n→ Step 5: Return heap root // initial kth largest? maybe not needed\nConstructor End\n\nThen add method:\n\n→ Step 6: Add val to heap\n→ Decision: Heap size > k?\n    Yes → Step 7: Remove smallest from heap\n→ Step 8: Return heap root // current kth largest\n\nEnd.\n\nWe need to ensure each line has virtual code and comment. Use arrow, decisions with Yes/No. Use spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Set k = input_k // 儲存 k 的值\n→ Step 2: Create empty MinHeap // 建立最小堆，大小不超過 k\n→ Decision: nums 不是空嗎? // 檢查是否有初始分數\n    Yes → Loop for each num in nums // 逐個處理初始分數\n        → Step 3: Insert num into MinHeap // 將分數加入堆中\n        → Decision: MinHeap size > k? // 堆是否已超過 k 個\n            Yes → Step 4: Remove MinHeap root // 移除最小分數，維持堆大小為 k\n            No  → (不執行任何操作) // 堆仍未超過 k\n    No  → (跳過初始分數處理) // 沒有初始分數\n→ Step 5: // 建構完成，堆中存有前 k 大的分數，堆頂即為第 k 大分數\nEnd // 程式結束\n\nAddMethod: // 新增一筆分數並回傳第 k 大分數\n→ Step 6: Insert val into MinHeap // 將新分數加入堆中\n→ Decision: MinHeap size > k? // 檢查堆是否超過 k 個\n    Yes → Step 7: Remove MinHeap root // 移除最小分數，保持堆大小為 k\n    No  → (不執行任何操作) // 堆已在 k 個或更少\n→ Step 8: Return MinHeap root // 回傳目前第 k 大分數\nEnd // 方法結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\", \"root/4.txt\"]]'"
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"Return groups of duplicate file paths based on file contents.\"\"\"\n        content_map = defaultdict(list)\n        for path in paths:\n            parts = path.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content[:-1]  # remove trailing ')'\n                content_map[content].append(f\"{root}/{name}\")\n        # Keep only groups with at least two files\n        return [files for files in content_map.values() if len(files) > 1]\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Parse the input string which is expected to be of the form:\n    paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\", ...]\n    \"\"\"\n    input_str = input_str.strip()\n    if '=' in input_str:\n        _, list_part = input_str.split('=', 1)\n    else:\n        list_part = input_str\n    # Use literal_eval for safe parsing of the list literal\n    return ast.literal_eval(list_part)\n\nif __name__ == \"__main__\":\n    # Read entire stdin content\n    raw_input = sys.stdin.read()\n    # Parse the list of path strings\n    try:\n        paths = parse_input(raw_input)\n    except Exception as e:\n        # If parsing fails, assume raw_input is a JSON array\n        paths = json.loads(raw_input.strip())\n    # Compute duplicate file groups\n    solution = Solution()\n    result = solution.findDuplicate(paths)\n    # Output as JSON string\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need produce virtual code for solving the duplicate file finding problem. We'll output step-by-step pseudocode with explanation after each line. Use structure: Start, →, Decision, End. We'll need to parse input list of strings, split directory and file parts, build mapping content->list of paths, then collect lists with size>1.\n\nWe'll produce pseudo steps: Start, → Step 1: initialize map, etc.\n\nMake sure to not output actual code. Use virtual code syntax with arrows.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 contentMap (key: 檔案內容, value: 文字路徑列表) // 準備存放相同內容檔案的路徑  \n→ Step 2: 針對每個 directoryInfo 在 paths 列表中執行  \n  → Decision: 分割 directoryInfo 為 pathPart 與 filesPart (以空格為分隔) // 取得目錄與檔案資訊  \n    Yes → Step 3: 設定 dirPath 為 pathPart // 目錄路徑  \n     → Decision: filesPart 是否為空？ // 檢查是否有檔案  \n      Yes → Step 4: 跳過此目錄 // 沒有檔案不處理  \n      No → Step 5: 將 filesPart 以空格切割為 fileTokens 列表 // 每個 token 形如 file.txt(content)  \n       → Loop over fileTokens  \n         → Step 6: 用 '(' 分割 token 成 fileName 與 contentWithParen // 取得檔名與含括號內容  \n          → Step 7: 去除 contentWithParen 兩端的 ')' 取得純內容 contentStr  \n          → Step 8: 組合完整路徑 fullPath = dirPath + '/' + fileName // 生成完整檔案路徑  \n          → Step 9: 若 contentStr 在 contentMap 中則 append fullPath，否則建立新列表含 fullPath // 更新內容對應的路徑列表  \n          → End Loop  \n        → End Loop  \n       → End Decision  \n      → End Decision  \n→ Step 10: 建立結果列表 result  \n  → Loop over contentMap 的每個 (content, pathList)  \n    → Decision: 若 pathList 長度 >= 2？ // 至少兩個檔案相同內容  \n      Yes → Step 11: 將 pathList 加入 result // 加入重複檔案組  \n      No → Step 12: 跳過此內容 // 唯一內容不加入  \n    → End Decision  \n   → End Loop  \n→ Step 13: 回傳 result // 傳回所有重複檔案路徑群組  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[7]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[7]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[3,7]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[3, 7]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[4,9,4]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[4, 9, 4]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\n# ------------------------------------------------------------\n# 只使用 rand7() 這個 API 來產生 1~10 的均勻隨機數\n# ------------------------------------------------------------\ndef rand7() -> int:\n    \"\"\"回傳 1~7 的均勻隨機整數\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"產生 1~10 的均勻隨機整數，僅使用 rand7()\"\"\"\n        while True:\n            # 兩次 rand7() 產生 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:                     # 只保留 1~40，因為 40 可被 10 整除\n                return 1 + (num - 1) % 10\n\n# ------------------------------------------------------------\n# 讀取輸入並執行測試\n# ------------------------------------------------------------\ndef main():\n    # 讀取整個輸入，預期格式為 \"n = X\" 或 \"n=X\"\n    data = sys.stdin.read().strip()\n    # 從輸入中找出整數 n\n    try:\n        # 取所有數字並轉成整數\n        n = int(''.join(ch for ch in data if ch.isdigit()))\n    except ValueError:\n        # 若找不到數字，則默認 n 為 0\n        n = 0\n\n    sol = Solution()\n    results = []\n    for _ in range(n):\n        results.append(sol.rand10())\n\n    # 將結果以 Python list 的形式輸出\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps for rand10() using rand7() as only random generator. Classic solution: use two rand7() calls to get 1-49 uniformly (by mapping (a-1)*7 + b). Then reject if > 40, because 40 is multiple of 10, then map result to 1-10. Alternative: use 2 calls to produce 1-49, if >40 reject and retry. Explanation lines for each step. Format: Start, steps, Decision, Yes→ etc. We need to output line by line pseudocode and explanation. Let's create steps:\n\nStart\n→ Step 1: repeat\n    → Step 1.1: r1 = rand7()\n    → Step 1.2: r2 = rand7()\n    → Step 1.3: val = (r1-1)*7 + r2  // val in 1-49\n    → Decision: If val <= 40?\n        Yes → Step 1.4: return (val-1) mod 10 + 1 // uniform 1-10\n        No → go back to Step 1 (repeat)\nEnd\n\nBut we need to use arrow arrows. Use \"Start\" and \"End\". Use indentation maybe but keep format as per example. Let's format:\n\nStart // 程式開始執行\n→ Decision: 開始重複流程? // 進入重複迴圈\n    Yes → Step 1: r1 = rand7() // 產生第一個隨機數\n    → Step 2: r2 = rand7() // 產生第二個隨機數\n    → Step 3: val = (r1-1)*7 + r2 // 將兩個 1-7 映射為 1-49\n    → Decision: val <= 40? // 判斷是否在可接受範圍\n        Yes → Step 4: return (val-1) mod 10 + 1 // 轉為 1-10\n        No  → Decision: 重新進行 Step 1? // 重新循環\n            Yes → ... (go back)\n            No  → End // 雖然 No不會發生，作為結束\nEnd\n\nBut we can structure simpler: Use repeat-until loop: repeat { ... } until accepted. Pseudocode can use \"Repeat\" but spec expects Decision, maybe we can just loop until accepted. Let's use Decision.\n\nBetter: Use while True style:\n\nStart\n→ Step 1: Loop\n    → Step 1.1: r1 = rand7()\n    → Step 1.2: r2 = rand7()\n    → Step 1.3: val = (r1-1)*7 + r2\n    → Decision: val <= 40?\n        Yes → Step 1.4: return (val-1) mod 10 + 1\n        No  → Step 1: (loop again)\n\nBut need arrow to go back to Step 1. Use \"→\" to show loop.\n\nWe need to follow example: Decision: If condition? ; Yes→; No→. Use arrow lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Decision: 是否已獲得合法數值? // 進入重複迴圈，直到得到合法值\n    No  → Step 1: r1 = rand7() // 產生第一個 1-7 的隨機數\n    → Step 2: r2 = rand7() // 產生第二個 1-7 的隨機數\n    → Step 3: val = (r1-1)*7 + r2 // 把兩個 1-7 轉成 1-49\n    → Decision: val <= 40? // 檢查是否在 1-40 的可接受範圍\n        Yes → Step 4: return (val-1) mod 10 + 1 // 映射到 1-10\n        No  → Decision: 重新進行 Step 1? // 若 >40，重新迴圈\n            Yes → (loop back to No branch)\n            No  → End // 這裡不會發生，作為結束標記\nEnd // 程式執行結束\n\nBut this seems messy. We can use \"Repeat\" as step. But example didn't use Repeat, but we can use \"Step: 重複\" maybe.\n\nSimplify:\n\nStart // 程式開始執行\n→ Decision: 是否開始重複? // 進入循環，直到取得合法值\n    Yes → Step 1: r1 = rand7() // 產生第一個隨機數\n    → Step 2: r2 = rand7() // 產生第二個隨機數\n    → Step 3: val = (r1-1)*7 + r2 // 組合為 1-49\n    → Decision: val <= 40? // 判斷是否在可接受區間\n        Yes → Step 4: return (val-1) mod 10 + 1 // 將 1-40 映射為 1-10\n        No  → Decision: 重新進行循環? // 若 >40，回到開始\n            Yes → (loop back to Yes branch of first Decision)\n            No  → End // 不會發生\nEnd\n\nHowever, the example uses arrow for Decision: If condition?; Yes→; No→; Indentation.\n\nWe need to be careful: Each line of pseudocode includes code and comment. Indentation not required but should use arrows.\n\nLet's propose final pseudocode:\n\nStart // 程式開始執行\n→ Decision: 是否已獲得合法數值? // 進入重複迴圈，直到得到合法值\n    No  → Step 1: r1 = rand7() // 產生第一個 1-7 的隨機數\n    → Step 2: r2 = rand7() // 產生第二個 1-7 的隨機數\n    → Step 3: val = (r1-1)*7 + r2 // 將兩個隨機數合併成 1-49\n    → Decision: val <= 40? // 檢查是否在可接受範圍內\n        Yes → Step 4: return (val-1) mod 10 + 1 // 映射 1-40 為 1-10\n        No  → Decision: 重新開始迴圈? // >40 時重新嘗試\n            Yes → (loop back to No branch of first Decision)\n            No  → End // 結束程式（理論上不會到這裡）\nEnd // 程式執行結束\n\nBut arrow lines might not be accepted. The example shows \"Yes →\" and \"No →\" as separate lines. So we need to format as:\n\nStart\n→ Decision: ...\n    Yes → ...\n    No  → ...\n\nBut we need to use indentation.\n\nAlso we need to incorporate the repeated steps within loop. Example shows nested Decision. We can mimic.\n\nWe can do:\n\nStart // 程式開始執行\n→ Decision: 需要重複產生隨機數? // 迴圈條件，直到合法\n    Yes → Step 1: r1 = rand7() // 取得第一個隨機數\n    → Step 2: r2 = rand7() // 取得第二個隨機數\n    → Step 3: val = (r1-1)*7 + r2 // 合併為 1-49\n    → Decision: val <= 40? // 檢查是否可接受\n        Yes → Step 4: return (val-1) mod 10 + 1 // 轉為 1-10\n        No  → Decision: 重新開始? // 若 >40，回到最上面\n            Yes → (回到 Yes 分支)\n            No  → End\nEnd\n\nBut we need to use \"Yes →\" lines for decisions. So inside the No branch we again ask decision. Might not need \"Need to repeat\" decision at start; just start with a loop.\n\nAlternate: Use Step: loop\n\nStart // 程式開始執行\n→ Step 1: Loop\n    → Step 2: r1 = rand7() // 產生第一個隨機數\n    → Step 3: r2 = rand7() // 產生第二個隨機數\n    → Step 4: val = (r1-1)*7 + r2 // 組合為 1-49\n    → Decision: val <= 40? // 檢查是否在可接受範圍\n        Yes → Step 5: return (val-1) mod 10 + 1 // 返回 1-10\n        No  → Step 1 // 重新進入迴圈\n\nBut we need to keep the same arrow format. We can just treat \"Loop\" as Step. But example didn't show loop; but we can still use \"Decision\" for loop.\n\nLet's produce final code with nested Decision.\n\nI'll provide:\n\nStart // 程式開始執行\n→ Decision: 需要重複產生隨機數? // 迴圈條件，直到得到合法值\n    No  → Step 1: r1 = rand7() // 取得第一個隨機數\n    → Step 2: r2 = rand7() // 取得第二個隨機數\n    → Step 3: val = (r1-1)*7 + r2 // 將兩個隨機數合併為 1-49\n    → Decision: val <= 40? // 檢查是否在可接受範圍\n        Yes → Step 4: return (val-1) mod 10 + 1 // 映射 1-40 為 1-10\n        No  → Decision: 重新開始迴圈? // 若 >40，重新嘗試\n            Yes → (回到 No 分支的起點)\n            No  → End // 程式結束（理論上不會到此）\nEnd // 程式執行結束\n\nBut the syntax may be confusing. Maybe simpler: just produce sequential steps:\n\nStart\n→ Step 1: repeat\n    → Step 2: r1 = rand7()\n    → Step 3: r2 = rand7()\n    → Step 4: val = (r1-1)*7 + r2\n    → Decision: val <= 40?\n        Yes → Step 5: return (val-1) mod 10 + 1\n        No  → Step 1 // repeat\nEnd\n\nBut we need to use \"→\" before each step. The \"repeat\" can be Step: Loop. Let's adopt this:\n\nStart // 程式開始執行\n→ Step 1: Loop // 開始無限迴圈，直到返回\n    → Step 2: r1 = rand7() // 產生第一個隨機數 1-7\n    → Step 3: r2 = rand7() // 產生第二個隨機數 1-7\n    → Step 4: val = (r1-1)*7 + r2 // 組合為 1-49\n    → Decision: val <= 40? // 判斷是否在 1-40 可接受範圍\n        Yes → Step 5: return (val-1) mod 10 + 1 // 將 1-40 映射到 1-10\n        No  → Step 1 // 重新進入 Loop\nEnd // 程式執行結束\n\nThis is simple and clear.\n\nWe should output exactly that.\n\nLet's ensure each line has the code and comment after //. Use Chinese comment. Provide arrow before each step except Start and End maybe.\n\nOk final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Loop // 開始無限迴圈，直到有合法值返回  \n → Step 2: r1 = rand7() // 產生第一個隨機數 1-7  \n → Step 3: r2 = rand7() // 產生第二個隨機數 1-7  \n → Step 4: val = (r1-1)*7 + r2 // 組合為 1-49 的隨機數  \n → Decision: val <= 40? // 判斷是否在可接受的 1-40 範圍  \n  Yes → Step 5: return (val-1) mod 10 + 1 // 將 1-40 映射到 1-10，完成  \n  No  → Step 1 // val > 40，重新進入 Loop  \nEnd // 程式執行結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n        return (\n            dists[0] > 0\n            and dists[0] == dists[1] == dists[2] == dists[3]\n            and dists[4] == dists[5]\n            and dists[4] == 2 * dists[0]\n        )\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(numbers) < 8:\n        print(\"false\")\n        sys.exit(0)\n\n    p1 = [numbers[0], numbers[1]]\n    p2 = [numbers[2], numbers[3]]\n    p3 = [numbers[4], numbers[5]]\n    p4 = [numbers[6], numbers[7]]\n\n    solution = Solution()\n    result = solution.validSquare(p1, p2, p3, p4)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for algorithm to check if four given points form a square, independent of order. So algorithm: compute all pairwise distances squared between points. There will be 6 distances. For a square, there are 4 equal smaller distances (sides) and 2 equal larger distances (diagonals). Need positive side length. And check ratio between diagonal and side: diagonal^2 = 2 * side^2. So algorithm: compute distances squared, sort, check first 4 equal and >0, last 2 equal, and 5th equals 2*1st. Or use set of distances counts. Also verify no degenerate cases: points distinct.\n\nVirtual code steps: Start, Step 1: Input p1 p2 p3 p4. Step 2: Compute all pairwise distances squared and store in list distances. Step 3: Sort distances. Step 4: Check first distance >0. Step 5: Check distances[0]==distances[1]==distances[2]==distances[3]. Step 6: Check distances[4]==distances[5]. Step 7: Check distances[4]==2*distances[0]. Return true if all satisfied else false.\n\nEdge cases: maybe points repeated causing zero distance. We check >0.\n\nWe also might check that there are exactly two distinct distances. That is part of steps.\n\nThus produce virtual code lines. Use arrows. Let's produce something like:\n\nStart // 程式開始\n→ Step 1: 接收四個點 p1, p2, p3, p4 // 取得輸入\n→ Step 2: 建立空陣列 distances // 用於存距離\n→ Step 3: For each unordered pair (pi, pj) among the four points:\n    → Step 3a: 計算距離平方 d = (xi - xj)^2 + (yi - yj)^2\n    → Step 3b: Append d 到 distances\n→ Step 4: 排序 distances\n→ Step 5: Decision: 如果 distances[0] == 0? // 檢查邊長不為零\n    Yes → Step 5a: Return False // 重複點，非正方形\n    No  →\n→ Step 6: Decision: 如果 distances[0] == distances[1] == distances[2] == distances[3]? // 四邊相等\n    Yes →\n    No  → Step 6a: Return False\n→ Step 7: Decision: 如果 distances[4] == distances[5]? // 兩條對角相等\n    Yes →\n    No  → Step 7a: Return False\n→ Step 8: Decision: 如果 distances[4] == 2 * distances[0]? // 對角長平方為兩倍邊長平方\n    Yes → Step 8a: Return True\n    No  → Step 8b: Return False\nEnd // 程式結束\n\nBut we must use virtual code format: each line \"→ Step ...\". For decision use \"Decision:\" with Yes→ and No→. We need to maintain indentation? Format example shows indentation under Decision. So we can indent lines following Decision.\n\nAlso we must not output actual code but virtual steps.\n\nLet's create accordingly.\n\nMake sure to keep each line as separate. Provide concise explanation after //. Use Chinese. Provide \"Start\" and \"End\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取四點 p1, p2, p3, p4 // 取得輸入座標\n→ Step 2: 建立空列表 distances // 用來儲存六個點對之距離平方\n→ Decision: 是否有重複點? // 檢查輸入是否唯一\n    Yes → Step 3: 直接回傳 False // 重複點無法形成正方形\n    No  →  \n→ Step 3: 對所有 6 組不重複點對 (pi, pj)\n    → Step 3a: 計算距離平方 d = (xi - xj)^2 + (yi - yj)^2\n    → Step 3b: 加入 d 到 distances\n→ Step 4: 對 distances 進行排序 // 由小到大排列\n→ Step 5: Decision: distances[0] == 0? // 第一個距離是否為零\n    Yes → Step 5a: 回傳 False // 至少有兩點重合，邊長為零\n    No  →  \n→ Step 6: Decision: distances[0] == distances[1] == distances[2] == distances[3]? // 四條邊相等\n    Yes →  \n    No  → Step 6a: 回傳 False // 四條邊不相等，非正方形\n→ Step 7: Decision: distances[4] == distances[5]? // 兩條對角相等\n    Yes →  \n    No  → Step 7a: 回傳 False // 對角不相等，非正方形\n→ Step 8: Decision: distances[4] == 2 * distances[0]? // 對角平方為兩倍邊平方\n    Yes → Step 8a: 回傳 True // 符合正方形條件\n    No  → Step 8b: 回傳 False // 對角長不符合 90 度角關係\nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpq9pzjalg.py\", line 71, in <module>\n    main()\n  File \"/tmp/tmpq9pzjalg.py\", line 49, in main\n    arguments = ast.literal_eval(arg_str)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[1, 3, 5]\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]\n        self.tree = [0] * (self.n + 1)\n        for i in range(self.n):\n            self._update_tree(i + 1, nums[i])\n\n    def _update_tree(self, i, val):\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, i):\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract two JSON-like lists: commands and arguments\n    match = re.match(r'\\s*(\\[[^\\]]*\\])\\s*,\\s*(\\[[^\\]]*\\])\\s*', data)\n    if not match:\n        # If the input is split into two lines, read again\n        parts = data.splitlines()\n        if len(parts) >= 2:\n            cmd_str, arg_str = parts[0], parts[1]\n        else:\n            return\n    else:\n        cmd_str, arg_str = match.group(1), match.group(2)\n    commands = ast.literal_eval(cmd_str)\n    arguments = ast.literal_eval(arg_str)\n\n    obj = None\n    results = []\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"NumArray\":\n            obj = NumArray(arg[0])\n            results.append(None)\n        elif cmd == \"update\":\n            obj.update(arg[0], arg[1])\n            results.append(None)\n        elif cmd == \"sumRange\":\n            res = obj.sumRange(arg[0], arg[1])\n            results.append(res)\n        else:\n            # Unknown command; skip\n            results.append(None)\n\n    output = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for a data structure supporting point updates and range sum queries. Use a Binary Indexed Tree (Fenwick) or Segment Tree. Provide step-by-step virtual code for class NumArray with constructor, update, sumRange, plus internal BIT.\n\nWe need to output each line with virtual code and explanation. Use arrow notation and decision etc. We need to include Start, End.\n\nLet's write virtual code:\n\nStart\n→ Step 1: 定義 NumArray 類別，內部包含 arr 與 bit\n→ Step 2: 構造函式 NumArray(nums) // 初始化 arr 與 bit\n    → 初始化 arr = nums\n    → 初始化 bit 大小為 len(nums)+1，全部設為 0\n    → 對每個 i 從 1 到 n 執行 add(i, arr[i-1]) // 建立 BIT\n→ Step 3: 定義方法 update(index, val)\n    → 計算 delta = val - arr[index]\n    → arr[index] = val\n    → 執行 add(index+1, delta) // BIT 更新\n→ Step 4: 定義方法 sumRange(left, right)\n    → 計算 prefixSum(right+1) - prefixSum(left)\n    → 回傳結果\n→ Function add(idx, delta)\n    → while idx <= n\n        → bit[idx] += delta\n        → idx += idx & -idx\n→ Function prefixSum(idx)\n    → res = 0\n    → while idx > 0\n        → res += bit[idx]\n        → idx -= idx & -idx\n    → 回傳 res\nEnd\n\nBut need to use virtual code lines with arrow and comments. Use indentation for nested.\n\nWe should start with Start, then each step. Use \"→\" and \"Decision:\" if needed. We can use simple steps.\n\nLet's format each line with `→` preceding.\n\nWe must include explanation after `//`. Each line must contain virtual code then space then comment. We'll indent nested lines maybe with tab or spaces. We just need to produce a clear step-by-step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Class NumArray // 定義 NumArray 類別\n    → Member arr // 原始陣列\n    → Member bit // Binary Indexed Tree\n    → Member n // 陣列長度\n→ Constructor NumArray(nums) // 初始化\n    → n = length(nums)\n    → arr = nums\n    → bit = array of size n+1, all 0\n    → For i = 1 to n\n        → add(i, arr[i-1]) // 建立 BIT\n→ Method update(index, val) // 更新元素\n    → delta = val - arr[index]\n    → arr[index] = val\n    → add(index+1, delta) // 更新 BIT\n→ Method sumRange(left, right) // 取得區間和\n    → result = prefixSum(right+1) - prefixSum(left)\n    → return result\n→ Function add(idx, delta) // BIT 內部點增\n    → While idx <= n\n        → bit[idx] = bit[idx] + delta\n        → idx = idx + (idx & -idx)\n→ Function prefixSum(idx) // BIT 前綴和\n    → res = 0\n    → While idx > 0\n        → res = res + bit[idx]\n        → idx = idx - (idx & -idx)\n    → return res\nEnd // 程式執行結束\n\nMake sure each line is one statement or a block header. Use indentation.\n\nWe must ensure no actual code, just pseudo.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class NumArray // 定義 NumArray 類別  \n    → Member arr // 儲存原始陣列  \n    → Member bit // Binary Indexed Tree（樹）  \n    → Member n // 陣列長度  \n→ Constructor NumArray(nums) // 初始化物件  \n    → n = length(nums) // 取得陣列長度  \n    → arr = nums // 存放原始資料  \n    → bit = array of size n+1, all 0 // 初始化 BIT  \n    → For i = 1 to n // 建立 BIT  \n        → add(i, arr[i-1]) // 將每個元素加入 BIT  \n→ Method update(index, val) // 更新指定索引的值  \n    → delta = val - arr[index] // 計算變動量  \n    → arr[index] = val // 更新原始陣列  \n    → add(index+1, delta) // 在 BIT 中更新  \n→ Method sumRange(left, right) // 計算區間和  \n    → result = prefixSum(right+1) - prefixSum(left) // 前綴和差值  \n    → return result // 回傳區間總和  \n→ Function add(idx, delta) // BIT 的點增操作  \n    → While idx <= n  \n        → bit[idx] = bit[idx] + delta // 更新節點值  \n        → idx = idx + (idx & -idx) // 移動到父節點  \n→ Function prefixSum(idx) // BIT 的前綴和  \n    → res = 0 // 初始化累加器  \n    → While idx > 0  \n        → res = res + bit[idx] // 加入節點值  \n        → idx = idx - (idx & -idx) // 移動到前一節點  \n    → return res // 回傳累計結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"\n        Rearranges nums into a wiggle sequence where\n        nums[0] < nums[1] > nums[2] < nums[3] ...\n        The algorithm scans once and swaps adjacent elements\n        whenever the current ordering violates the required inequality.\n        \"\"\"\n        n = len(nums)\n        for i in range(n - 1):\n            # Even index: want nums[i] < nums[i+1]\n            if i % 2 == 0:\n                if nums[i] > nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n            # Odd index: want nums[i] > nums[i+1]\n            else:\n                if nums[i] < nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n\n    # Remove possible \"nums =\" prefix and parse the list safely\n    if data.lower().startswith(\"nums\"):\n        # Find the first '[' and the matching ']'\n        start = data.find('[')\n        end = data.rfind(']')\n        if start != -1 and end != -1:\n            data = data[start:end+1]\n    # Parse list using ast.literal_eval for safety\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        # If parsing fails, treat the whole input as a literal list string\n        nums = ast.literal_eval(data.strip())\n\n    # Ensure we have a list of integers\n    if not isinstance(nums, list):\n        raise ValueError(\"Input must be a list of integers\")\n\n    sol = Solution()\n    sol.wiggleSort(nums)\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code that reorders array into wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3] ... The known solution: iterate and swap when condition violated. For i from 0 to len-2: if i%2==0 and nums[i] > nums[i+1] swap; if i%2==1 and nums[i] < nums[i+1] swap. That ensures wiggle. So we produce steps.\n\nWe must produce in virtual code line by line with explanation. Use Start, End, Decision, etc. Should describe algorithm: input array, for loop, decisions, swaps, end.\n\nLet's write:\n\nStart // begin\n→ Step 1: 取得輸入陣列 nums // Acquire input\n→ Step 2: 計算長度 n = nums.length // length\n→ Decision: n <= 1? // if array length <=1 no need\n    Yes → End // finish\n    No  → Step 3: 針對 i = 0 至 n-2 執行迴圈 // iterate indices\n        → Decision: i is even? // check parity\n            Yes → Step 4: 如果 nums[i] > nums[i+1] → Swap nums[i] 與 nums[i+1] // ensure < for even index\n            No  → Step 5: 如果 nums[i] < nums[i+1] → Swap nums[i] 與 nums[i+1] // ensure > for odd index\n        → Step 6: i++ // increment\n→ End // done\n\nNeed to format each line: \"虛擬碼步驟 // 解釋\". Use arrows and Decision etc.\n\nMake sure each step line has arrow or indent. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入陣列 nums // 取得輸入的整數陣列\n→ Step 2: 計算長度 n = nums.length // 取得陣列長度\n→ Decision: n <= 1? // 若長度不足 2，已是合法排列\n    Yes → End // 結束程式\n    No  → Step 3: 初始化 i = 0 // 開始從第一個索引處迭代\n→ Decision: i < n-1? // 判斷是否還有相鄰元素\n    Yes →\n        → Decision: i % 2 == 0? // 判斷索引為偶數\n            Yes →\n                → Step 4: 如果 nums[i] > nums[i+1] → Swap(nums[i], nums[i+1]) // 使 nums[i] < nums[i+1]\n            No →\n                → Step 5: 如果 nums[i] < nums[i+1] → Swap(nums[i], nums[i+1]) // 使 nums[i] > nums[i+1]\n        → Step 6: i = i + 1 // 移至下一個索引\n        → Go to Decision: i < n-1? // 重複迴圈\n    No  → End // 迴圈結束，完成排列\n\nEnd // 程式執行結束\n\nWe need to ensure each line has single arrow? In example, arrow used to denote next step: \"→ Step 1\". For decision we indent with spaces and arrow? They used \"Decision:\" with indentation. So keep that formatting.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入陣列 nums // 取得輸入的整數陣列  \n→ Step 2: 計算長度 n = nums.length // 取得陣列長度  \n→ Decision: n <= 1? // 若長度不足 2，已是合法排列  \n    Yes → End // 結束程式  \n    No  → Step 3: 初始化 i = 0 // 開始從第一個索引處迭代  \n→ Decision: i < n-1? // 判斷是否還有相鄰元素  \n    Yes →  \n        → Decision: i % 2 == 0? // 判斷索引為偶數  \n            Yes →  \n                → Step 4: 如果 nums[i] > nums[i+1] → Swap(nums[i], nums[i+1]) // 使 nums[i] < nums[i+1]  \n            No →  \n                → Step 5: 如果 nums[i] < nums[i+1] → Swap(nums[i], nums[i+1]) // 使 nums[i] > nums[i+1]  \n        → Step 6: i = i + 1 // 移至下一個索引  \n        → Go to Decision: i < n-1? // 重複迴圈  \n    No → End // 迴圈結束，完成排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpln6tlkpx.py\", line 58, in <module>\n    main()\n  File \"/tmp/tmpln6tlkpx.py\", line 50, in main\n    equations, values, queries = parse_input()\n                                 ^^^^^^^^^^^^^\n  File \"/tmp/tmpln6tlkpx.py\", line 35, in parse_input\n    tree = ast.parse(text, mode='exec')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe8mrltlh.py\", line 58, in <module>\n    main()\n  File \"/tmp/tmpe8mrltlh.py\", line 50, in main\n    equations, values, queries = parse_input()\n                                 ^^^^^^^^^^^^^\n  File \"/tmp/tmpe8mrltlh.py\", line 35, in parse_input\n    tree = ast.parse(text, mode='exec')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpojgv471r.py\", line 58, in <module>\n    main()\n  File \"/tmp/tmpojgv471r.py\", line 50, in main\n    equations, values, queries = parse_input()\n                                 ^^^^^^^^^^^^^\n  File \"/tmp/tmpojgv471r.py\", line 35, in parse_input\n    tree = ast.parse(text, mode='exec')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        # 建立圖: graph[變數][相鄰變數] = 比值\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        # 深度優先搜尋計算從 src 到 dst 的乘積\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        results = []\n        for u, v in queries:\n            results.append(dfs(u, v, set()))\n        return results\n\ndef parse_input():\n    # 讀取所有輸入並解析為 equations、values、queries\n    text = sys.stdin.read()\n    tree = ast.parse(text, mode='exec')\n    data = {}\n    for node in tree.body:\n        if isinstance(node, ast.Assign):\n            target = node.targets[0]\n            if isinstance(target, ast.Name):\n                name = target.id\n                if name in ('equations', 'values', 'queries'):\n                    data[name] = ast.literal_eval(node.value)\n    equations = data.get('equations', [])\n    values = data.get('values', [])\n    queries = data.get('queries', [])\n    return equations, values, queries\n\ndef main():\n    equations, values, queries = parse_input()\n    solution = Solution()\n    res = solution.calcEquation(equations, values, queries)\n    # 格式化輸出: 每個數字保留 5 位小數，列表之間無空格\n    formatted = '[' + ','.join(f'{x:.5f}' for x in res) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for solving the problem: evaluate division queries given equations with known ratios, return -1.0 if not determinable. Typical solution: build graph of variables, weighted edges with ratio values, then for each query perform DFS/BFS to find product.\n\nWe produce virtual code step by step with explanations.\n\nWe'll do: Build graph, then process each query: if variables missing, return -1.0; else if same variable return 1.0; else DFS.\n\nLet's create steps: Start, Build graph, For each variable, etc.\n\nWe'll use arrow notation. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to ensure each line contains \"虛擬碼步驟\" + space + \"// 解釋\".\n\nLet's produce.\n\nWe can use comments: e.g., \"Build graph // 建立變數之間的加權圖\".\n\nUse \"→\" to show step.\n\nWe need to include \"Decision:\" lines with Yes/No.\n\nMake sure to keep it concise but intuitive.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Build graph // 建立變數之間的加權圖，節點為變數，邊權重為比值  \n→ For each equation i  \n  → Add edge Ai → Bi with weight values[i] // Ai / Bi = values[i]  \n  → Add edge Bi → Ai with weight 1/values[i] // 逆向比值  \n→ End // 圖建構完成  \n\nStart // 處理查詢  \n→ For each query j  \n  → Decision: 若 Cj 或 Dj 未出現在圖中? // 檢查是否有定義  \n    Yes → Append -1.0 to answer list // 未定義，直接返回 -1.0  \n    No → Decision: 若 Cj == Dj? // 同一個變數  \n      Yes → Append 1.0 to answer list // 同一變數比值為 1  \n      No → Perform DFS to find path from Cj to Dj  \n       → Initialize visited set, stack with (Cj, 1.0) // 初始累積乘積為 1  \n       → While stack not empty  \n         → Pop (current, product)  \n         → Decision: 若 current == Dj? // 到達目標  \n            Yes → Append product to answer list // 乘積即為答案  \n            No → For each neighbor n of current  \n              → 若 n 未訪問  \n                → Push (n, product * edgeWeight(current→n))  \n         → If stack 空且未找到路徑  \n            Append -1.0 to answer list // 無路徑可達  \n→ End // 所有查詢處理完成  \nEnd // 程式結束執行"
    },
    {
      "title": "Max Consecutive Ones",
      "source_file": "Leetcode/leetcode485.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,0,1,1,1]",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp36hcr4t1.py\", line 41, in <module>\n    result = sol.findMaxConsecutiveOnones(nums)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAttributeError: 'Solution' object has no attribute 'findMaxConsecutiveOnones'. Did you mean: 'findMaxConsecutiveOnes'?"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1,0,1]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9zlhn45k.py\", line 41, in <module>\n    result = sol.findMaxConsecutiveOnones(nums)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAttributeError: 'Solution' object has no attribute 'findMaxConsecutiveOnones'. Did you mean: 'findMaxConsecutiveOnes'?"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        计算并返回二进制数组中连续 1 的最大长度。\n        \"\"\"\n        max_count = 0\n        count = 0\n        for num in nums:\n            if num == 1:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count = 0\n        return max_count\n\nif __name__ == \"__main__\":\n    # 从标准输入读取完整内容\n    data = sys.stdin.read().strip()\n\n    # 处理输入格式，例如 \"nums = [1,1,0,1,1,1]\"\n    if \"=\" in data:\n        # 取等号右侧的内容\n        _, list_part = data.split(\"=\", 1)\n        list_str = list_part.strip()\n    else:\n        list_str = data\n\n    # 安全解析列表\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # 若解析失败，直接打印错误并退出\n        print(\"Invalid input format.\")\n        sys.exit(1)\n\n    # 调用解决方案并输出结果\n    sol = Solution()\n    result = sol.findMaxConsecutiveOnones(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line for problem: maximum consecutive 1's in binary array.\n\nWe need to include Start, End, Decision etc.\n\nWe need to not output real code but virtual steps.\n\nSteps: initialize maxCount, currentCount. Iterate through array indices. For each element, if 1 then currentCount++ else set maxCount = max(maxCount, currentCount); currentCount=0. After loop, final check maxCount. Return.\n\nWe must output each line with \"虛擬碼步驟 // 解釋\".\n\nUse arrow. Use Decision: If nums[i]==1? Yes→ increment; No→ reset.\n\nAlso need to consider initial maxCount=0 currentCount=0.\n\nAlso at end after loop: Decision: Update max? Yes.\n\nReturn result.\n\nLet's structure:\n\nStart\n\n→ Step 1: 設定 maxCount ← 0, currentCount ← 0 // 初始化計數\n\n→ Step 2: 設定 i ← 0 // 索引起始\n\n→ Decision: i < length(nums)? // 迴圈條件\n\n    Yes →\n\n        → Step 3: 判斷 nums[i] == 1 // 檢查元素\n\n            Yes →\n\n                → Step 4: currentCount ← currentCount + 1 // 連續 1 增加\n\n            No →\n\n                → Step 5: maxCount ← max(maxCount, currentCount) // 更新最大值\n\n                → Step 6: currentCount ← 0 // 重置計數\n\n        → Step 7: i ← i + 1 // 移動到下一個\n\n        → Jump to Decision: i < length(nums)? // 重複\n\n    No →\n\n        → Decision: currentCount > maxCount? // 最後一次更新\n\n            Yes →\n\n                → Step 8: maxCount ← currentCount // 更新最大值\n\n            No →\n\n                → Step 9: // 不更新\n\n→ Step 10: return maxCount // 回傳結果\n\nEnd\n\nMake sure each line includes // explanation.\n\nLet's write accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 maxCount ← 0, currentCount ← 0 // 初始化最大連續 1 的計數與目前計數  \n→ Step 2: 設定 i ← 0 // 初始化索引  \n→ Decision: i < length(nums) ? // 判斷是否還有元素可處理  \n  Yes →  \n   → Step 3: 判斷 nums[i] == 1 // 檢查當前元素是否為 1  \n     Yes →  \n      → Step 4: currentCount ← currentCount + 1 // 連續 1 的計數加 1  \n     No →  \n      → Step 5: maxCount ← max(maxCount, currentCount) // 更新最大值  \n      → Step 6: currentCount ← 0 // 重置目前計數  \n    → Step 7: i ← i + 1 // 移動至下一個索引  \n    → Jump to Decision: i < length(nums) ? // 迴圈繼續  \n  No →  \n   → Decision: currentCount > maxCount ? // 最後一次可能還沒更新最大值  \n     Yes →  \n      → Step 8: maxCount ← currentCount // 更新最大值  \n     No →  \n      → Step 9: // 無需更新  \n→ Step 10: return maxCount // 回傳最大連續 1 的個數  \nEnd // 程式執行結束"
    },
    {
      "title": "Integer to English Words",
      "source_file": "Leetcode/leetcode273.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = 123",
          "expected_output": "\"One Hundred Twenty Three\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpyjxzr7km.py\", line 72, in <module>\n    main()\n  File \"/tmp/tmpyjxzr7km.py\", line 65, in main\n    data = sys.stdin.read()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        },
        {
          "example_index": 1,
          "input": "num = 12345",
          "expected_output": "\"Twelve Thousand Three Hundred Forty Five\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9cuj94l1.py\", line 72, in <module>\n    main()\n  File \"/tmp/tmp9cuj94l1.py\", line 65, in main\n    data = sys.stdin.read()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        },
        {
          "example_index": 2,
          "input": "num = 1234567",
          "expected_output": "\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpeuc33f36.py\", line 72, in <module>\n    main()\n  File \"/tmp/tmpeuc33f36.py\", line 65, in main\n    data = sys.stdin.read()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        }
      ],
      "generated_code": "import re\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        def one(n: int) -> str:\n            switcher = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n            return switcher[n]\n\n        def two_less_20(n: int) -> str:\n            switcher = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\",\n                        \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n            return switcher[n - 10]\n\n        def ten(n: int) -> str:\n            switcher = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n            return switcher[n]\n\n        def two(n: int) -> str:\n            if n == 0:\n                return \"\"\n            elif n < 10:\n                return one(n)\n            elif n < 20:\n                return two_less_20(n)\n            else:\n                tens = n // 10\n                rest = n % 10\n                return ten(tens) + (\" \" + one(rest) if rest != 0 else \"\")\n\n        def three(n: int) -> str:\n            hundred = n // 100\n            rest = n % 100\n            if hundred != 0 and rest != 0:\n                return one(hundred) + \" Hundred \" + two(rest)\n            elif hundred == 0 and rest != 0:\n                return two(rest)\n            elif hundred != 0 and rest == 0:\n                return one(hundred) + \" Hundred\"\n            else:\n                return \"\"\n\n        billion = num // 1000000000\n        million = (num - billion * 1000000000) // 1000000\n        thousand = (num - billion * 1000000000 - million * 1000000) // 1000\n        rest = num % 1000\n\n        result = \"\"\n        if billion != 0:\n            result += three(billion) + \" Billion\"\n        if million != 0:\n            result += \" \" if result != \"\" else \"\"\n            result += three(million) + \" Million\"\n        if thousand != 0:\n            result += \" \" if result != \"\" else \"\"\n            result += three(thousand) + \" Thousand\"\n        if rest != 0:\n            result += \" \" if result != \"\" else \"\"\n            result += three(rest)\n        return result\n\ndef main():\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    num = int(match.group(0)) if match else 0\n    sol = Solution()\n    print(sol.numberToWords(num))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for converting non-negative integer to English words. Provide line by line with arrows etc. No actual code. Should cover steps: input num, handle zero, break into groups of three digits, map to words, build result, etc.\n\nWe need to follow format: Start // 程式開始執行\n→ Step ... // explanation.\n\nUse Decision blocks.\n\nLet's produce pseudo algorithm. Probably steps:\n\nStart\n→ Step 1: Read integer num // get input\n→ Decision: 如果 num 等於 0? // check zero\n    Yes → Step 2: Return \"Zero\" // output\n    No  → Step 3: 初始化 words list // create list\n→ Step 4: 定義單位 words for ones, tens, teens, thousands // mapping arrays\n→ Step 5: 定義輔助函數 convert_three_digits(n) // convert 3-digit chunk\n→ Step 6: 反覆取 num 的最後三位數，對應千級別，存入 words\n→ Step 7: 逆序 words 並連接\n→ Step 8: Return words\n\nWe need to be more explicit with steps and decisions.\n\nLet's create virtual code lines:\n\nStart\n→ Step 1: num ← 讀取輸入 // get number\n→ Decision: num == 0? \n    Yes → Step 2: 輸出 \"Zero\" // return\n    No → Step 3: words ← 空串 // result string\n→ Step 4: 定義 arrays ones, teens, tens, thousands // mapping\n→ Step 5: 定義函數 ConvertChunk(chunk, scale) // chunk: 0-999, scale: \"\", \"Thousand\",...\n→ Step 6: Decision: chunk > 0? inside ConvertChunk\n    Yes → Step 7: 處理百位、十位、個位 // map digits\n    No → Step 8: 返回空串 // no contribution\n→ Step 9: 主循環: while num > 0:\n    ← chunk ← num mod 1000\n    ← num ← num / 1000\n    ← scale ← thousands[scale_index]\n    ← result ← ConvertChunk(chunk, scale) + result\n    ← scale_index ++\n→ Decision: num > 0? loop continues\n→ Step 10: 輸出 result // final string\n\nWe must keep \"→\" arrows and decisions. Use indentation? In example, indentation not needed but we can keep same formatting: indent inside decisions.\n\nNeed to be careful to not output actual code but virtual steps. Provide explanation per line. Use Traditional Chinese comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: num ← 讀取輸入 // 從使用者或系統取得整數\n→ Decision: num == 0? // 檢查是否為 0\n    Yes → Step 2: 輸出 \"Zero\" // 數字為 0 時直接輸出\n    No  → Step 3: result ← 空字串 // 初始化最終結果\n→ Step 4: 定義陣列 ones = [\"One\",\"Two\",...,\"Nine\"] // 個位數字對應字串\n→ Step 5: 定義陣列 teens = [\"Ten\",\"Eleven\",...,\"Nineteen\"] // 10-19 的特殊字串\n→ Step 6: 定義陣列 tens  = [\"Twenty\",\"Thirty\",...,\"Ninety\"] // 20,30… 的十位字串\n→ Step 7: 定義陣列 thousands = [\"\",\"Thousand\",\"Million\",\"Billion\"] // 千級別標籤\n→ Step 8: 定義函式 ConvertChunk(chunk, scale) // 將 0-999 的數字轉成字串，並加上對應 scale\n    → Decision: chunk == 0? // 若 chunk 為 0 不輸出\n        Yes → Return 空字串\n        No  →\n            → Step 9: hundreds ← chunk / 100 // 百位數\n            → Step 10: remainder ← chunk % 100 // 剩下兩位\n            → Step 11: segment ← 空字串\n            → Decision: hundreds > 0? // 處理百位\n                Yes → segment ← ones[hundreds-1] + \" Hundred\"\n                No  → No change\n            → Decision: remainder >= 20? // 處理十位及個位\n                Yes →\n                    → Step 12: tens_digit ← remainder / 10\n                    → Step 13: ones_digit ← remainder % 10\n                    → segment ← segment + \" \" + tens[tens_digit-2]\n                    → Decision: ones_digit > 0?\n                        Yes → segment ← segment + \" \" + ones[ones_digit-1]\n                        No  → No change\n                No →\n                    → Decision: remainder >= 10? // 10-19 的特殊處理\n                        Yes → segment ← segment + \" \" + teens[remainder-10]\n                        No  → // 個位小於 10\n                            → Decision: remainder > 0?\n                                Yes → segment ← segment + \" \" + ones[remainder-1]\n                                No  → No change\n            → Decision: scale != \"\"? // 加上千級別標籤\n                Yes → segment ← segment + \" \" + scale\n                No  → No change\n            → Return segment\n→ Step 14: index ← 0 // 用於追蹤千級別\n→ Step 15: Loop: while num > 0\n    → Step 16: chunk ← num % 1000 // 取得最低三位數\n    → Step 17: num ← num / 1000 // 去除已處理的部分\n    → Step 18: scale ← thousands[index] // 取得對應的千級別字串\n    → Step 19: chunk_str ← ConvertChunk(chunk, scale) // 轉成文字片段\n    → Decision: chunk_str != \"\"? // 若此段非空則加入結果\n        Yes → result ← chunk_str + \" \" + result\n        No  → No change\n    → Step 20: index ← index + 1 // 移至下一千級別\n→ Decision: num > 0? // 迴圈判斷\n    Yes → Loop again\n    No  → No\n→ Step 21: result ← Trim(result) // 去除前後空格\n→ Step 22: 輸出 result // 輸出完整英文表達\nEnd // 程式執行結束"
    },
    {
      "title": "Valid Number",
      "source_file": "Leetcode/leetcode65.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"0\"",
          "expected_output": "True",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'True'\nGot (Norm):      'False'\n--- (Raw) ---\nRaw Expected: 'True'\nRaw Got:      'False'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef is_number(s: str) -> bool:\n    \"\"\"\n    判斷字串 s 是否為合法的數字。\n    \"\"\"\n    s = s.strip()\n    if not s:\n        return False\n\n    num_seen = False   # 是否已看到至少一位數字\n    dot_seen = False   # 是否已看到小數點\n    e_seen = False     # 是否已看到指數符號\n\n    for i, char in enumerate(s):\n        if char.isdigit():\n            num_seen = True\n        elif char == '.':\n            if dot_seen or e_seen:       # 小數點只能出現一次且不能在 e 之後\n                return False\n            dot_seen = True\n        elif char in 'eE':\n            if e_seen or not num_seen:   # e 只能出現一次且前面必須有數字\n                return False\n            e_seen = True\n            num_seen = False             # 需要在 e 之後再次出現數字\n        elif char in '+-':\n            # 符號只能出現在字串開頭或 e 之後\n            if i != 0 and s[i-1] not in 'eE':\n                return False\n        else:\n            return False\n\n    return num_seen\n\ndef main():\n    \"\"\"\n    從標準輸入讀取字串，判斷其是否為合法數字並輸出布林值。\n    支援輸入格式如：\n        s = \"0\"\n    或直接輸入字串：\n        0\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中擷取字串內容\n    # 優先尋找雙引號、單引號中的內容，若沒有則直接使用非空白字串\n    m = re.search(r'(?:\"([^\"]*)\"|\\'([^\\']*)\\'|(\\S+))', data)\n    if m:\n        s = m.group(1) or m.group(2) or m.group(3)\n    else:\n        s = data\n\n    result = is_number(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for checking if string is valid number according to rules. We need step-by-step pseudocode, with explanations. Use Start, Decision, Yes/No arrows, etc. No actual code, just steps. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to parse string s.\n\nWe can outline algorithm: trim spaces, use index pointer, parse sign, parse digits, parse decimal point, parse exponent. Use flags for digits before/after dot, digits in exponent. Then final check: at least one digit either before or after dot or exponent digits. No other chars. Provide stepwise decisions.\n\nLet's write:\n\nStart\n→ Step: Trim leading and trailing spaces // remove whitespace\n→ Step: If string empty -> return false // no characters\n\nUse index i = 0\n\n→ Decision: Current char is '+' or '-'? // optional sign\n    Yes → i++ // skip sign\n\nNow parse integer part before dot:\n\n→ Step: ParseDigits(ref i) → returns count digitsBefore // number of digits before dot\n\n→ Decision: Current char is '.'? // optional decimal point\n    Yes → i++ // skip dot\n        → Step: ParseDigits(ref i) → returns count digitsAfter // digits after dot\n        → Decision: digitsBefore > 0 OR digitsAfter > 0? // at least one digit either side\n            Yes → continue\n            No → return false\n    No → // no dot\n        → Decision: digitsBefore > 0? // must have digits if no dot? Actually if no dot, digitsBefore must >0 to be integer\n            Yes → continue\n            No → // maybe exponent only? But number without digits is invalid\n                return false\n\nNow check exponent:\n\n→ Decision: Current char is 'e' or 'E'? // optional exponent\n    Yes → i++ // skip\n        → Decision: Current char is '+' or '-'? // optional sign in exponent\n            Yes → i++\n        → Step: ParseDigits(ref i) → returns count expDigits\n        → Decision: expDigits > 0? // exponent must have digits\n            Yes → continue\n            No → return false\n    No → // no exponent\n\n→ Decision: i == length of string? // no remaining chars\n    Yes → return true\n    No → return false\n\nAlso need ParseDigits function: while i < n and is digit, i++ count++.\n\nProvide virtual code steps accordingly. Each line with explanation. Use arrows for decisions. Must be逐行.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step: Remove all leading/trailing spaces from s // 清除字串兩端空白\n→ Decision: s is empty? // 是否為空字串\n    Yes → Return false // 空字串不是合法數字\n    No  → Continue\n\n→ Step: Set i = 0 // 指向字串起始位置\n\n→ Decision: s[i] is '+' or '-'? // 可選符號\n    Yes → i++ // 跳過符號\n    No  → Continue\n\n→ Step: Parse digits before decimal point: countBefore = 0\n→ While i < len(s) AND s[i] is digit:\n        countBefore++; i++\n\n→ Decision: s[i] is '.'? // 有無小數點\n    Yes → i++ // 跳過小數點\n        → Step: Parse digits after decimal point: countAfter = 0\n        → While i < len(s) AND s[i] is digit:\n                countAfter++; i++\n        → Decision: countBefore > 0 OR countAfter > 0? // 至少一位數\n            Yes → Continue\n            No  → Return false\n    No  → // 沒有小數點\n        → Decision: countBefore > 0? // 必須有整數位\n            Yes → Continue\n            No  → Return false\n\n→ Decision: s[i] is 'e' or 'E'? // 是否有指數部分\n    Yes → i++ // 跳過 e/E\n        → Decision: s[i] is '+' or '-'? // 指數的可選符號\n            Yes → i++ // 跳過符號\n        → Step: Parse exponent digits: expCount = 0\n        → While i < len(s) AND s[i] is digit:\n                expCount++; i++\n        → Decision: expCount > 0? // 指數必須至少一位\n            Yes → Continue\n            No  → Return false\n    No  → Continue\n\n→ Decision: i == len(s)? // 是否已讀完字串\n    Yes → Return true // 合法數字\n    No  → Return false // 仍有非法字符\n\nEnd // 程式執行結束\n\nMake sure each line has the format \"虛擬碼步驟 // 解釋\". Use \"→\" arrow before each step line? In example, they used \"→ Step 1:\" etc. We'll follow pattern: Start, then lines with arrows. For decisions, use \"→ Decision:\" with indentation.\n\nWe need to include indentation for nested decisions? Example shows indent with spaces. We'll produce accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: Remove all leading/trailing spaces from s // 清除字串兩端空白\n→ Decision: s is empty? // 是否為空字串\n    Yes → Return false // 空字串不是合法數字\n    No  → Continue\n→ Step: Set i = 0 // 指向字串起始位置\n→ Decision: s[i] is '+' or '-'? // 可選符號\n    Yes → i++ // 跳過符號\n    No  → Continue\n→ Step: Parse digits before decimal point: countBefore = 0\n→ While i < len(s) AND s[i] is digit:\n        countBefore++; i++\n→ Decision: s[i] is '.'? // 有無小數點\n    Yes → i++ // 跳過小數點\n        → Step: Parse digits after decimal point: countAfter = 0\n        → While i < len(s) AND s[i] is digit:\n                countAfter++; i++\n        → Decision: countBefore > 0 OR countAfter > 0? // 至少一位數\n            Yes → Continue\n            No  → Return false\n    No  → // 沒有小數點\n        → Decision: countBefore > 0? // 必須有整數位\n            Yes → Continue\n            No  → Return false\n→ Decision: s[i] is 'e' or 'E'? // 是否有指數部分\n    Yes → i++ // 跳過 e/E\n        → Decision: s[i] is '+' or '-'? // 指數的可選符號\n            Yes → i++ // 跳過符號\n        → Step: Parse exponent digits: expCount = 0\n        → While i < len(s) AND s[i] is digit:\n                expCount++; i++\n        → Decision: expCount > 0? // 指數必須至少一位\n            Yes → Continue\n            No  → Return false\n    No  → Continue\n→ Decision: i == len(s)? // 是否已讀完字串\n    Yes → Return true // 合法數字\n    No  → Return false // 仍有非法字符\nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            rest = acc[2:]\n            for email in [first_email] + rest:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        return [[email_to_name[root]] + sorted(emails) for root, emails in merged.items()]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Remove surrounding quotes if present\n    if (data[0] == data[-1]) and data[0] in ('\"', \"'\"):\n        data = data[1:-1].strip()\n\n    # Strip any variable assignment like \"accounts = \"\n    if data.startswith('accounts'):\n        idx = data.find('[')\n        if idx != -1:\n            data = data[idx:]\n        else:\n            data = ''\n\n    # Parse the list of accounts\n    try:\n        accounts = ast.literal_eval(data)\n    except Exception:\n        accounts = []\n\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n    print(merged_accounts)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps in required format, line by line, with arrow etc. Should cover algorithm: union-find, mapping email to name, grouping, sorting, output. Provide explanation per line. Each line \"虛擬碼步驟\" + \" // 解釋\". Use arrow like \"→\". Must not output actual code.\n\nLet's craft steps:\n\nStart\n→ Step 1: 初始化 union-find 資料結構 // 建立 parent map\n→ Step 2: 初始化字典 emailToName // 儲存 email 與對應名稱\n→ Step 3: 遍歷每個帳戶 accounts[i]\n    → SubStep 3.1: 取得 name\n    → SubStep 3.2: 從 accounts[i][1:] 取得 email 列表\n    → SubStep 3.3: 若 email 列表非空\n        → SubStep 3.3.1: 對第一個 email 設為 root\n        → SubStep 3.3.2: 對其餘 email 進行 union 與第一個\n    → SubStep 3.4: 為每個 email 建立 name 映射\n→ Step 4: 建立集合 dict rootToEmails\n→ Step 5: 遍歷每個 email\n    → Step 5.1: 找到其 root via find\n    → Step 5.2: 將 email 加入 rootToEmails[root]\n→ Step 6: 建立結果列表 result\n→ Step 7: 對於每個 root, emails in rootToEmails\n    → Step 7.1: 取得對應名稱 emailToName[any email]\n    → Step 7.2: 將名稱加至排序後的 email 列表\n    → Step 7.3: 加入 result\n→ End\n\nWe must use decision arrow for conditions maybe.\n\nWe must adhere to format: each line with step and explanation. Indent lines using tabs or spaces? Format example uses indentation via spaces. Use \"→\" arrow each line.\n\nNeed to include decision lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 union-find 結構 // 建立 email 與其父節點映射\n→ Step 2: 初始化字典 emailToName // 用來記錄每個 email 對應的姓名\n→ Step 3: 遍歷 accounts 中每一筆資料 // 對所有帳戶進行處理\n    → SubStep 3.1: 取得 name = accounts[i][0] // 取得帳戶擁有者姓名\n    → SubStep 3.2: 取得 emails = accounts[i][1:] // 取得此帳戶的所有 email\n    → SubStep 3.3: Decision: 如果 emails 非空? // 只有存在 email 才需要處理\n        Yes → SubStep 3.3.1: 設定 root = emails[0] // 第一次遇到的 email 為 root\n        Yes → SubStep 3.3.2: Decision: 如果 emails 長度 > 1? // 多於一個 email\n            Yes → SubStep 3.3.2.1: 對於每個 email 於 emails[1:]:\n                → Step 3.3.2.1.a: union(root, email) // 將同一人其他 email 與 root 合併\n        Yes → SubStep 3.3.3: For 每個 email in emails:\n            → Step 3.3.3.a: emailToName[email] = name // 建立 email 對應姓名映射\n→ Step 4: 初始化字典 rootToEmails // 用來收集每個 root 代表的 email 集合\n→ Step 5: 遍歷 emailToName 中每一個 email // 為每個 email 找到其 root\n    → Step 5.1: root = find(email) // 取得該 email 的最終根節點\n    → Step 5.2: Decision: 如果 root 仍不存在於 rootToEmails? // 檢查是否已有此 root\n        Yes → rootToEmails[root] = 空集合\n    → Step 5.3: rootToEmails[root].add(email) // 把 email 加進相對應的集合\n→ Step 6: 初始化結果列表 result = [] // 用於儲存最終合併後的帳戶\n→ Step 7: 遍歷 rootToEmails 中每一個 root, emails 集合\n    → Step 7.1: name = emailToName[任意一個 emails 內的 email] // 取得該組的姓名\n    → Step 7.2: sortedEmails = sort(emails) // 將 email 依字典序排序\n    → Step 7.3: account = [name] + sortedEmails // 以姓名為首，接著排序後的 email\n    → Step 7.4: result.append(account) // 加入最終結果\n→ End // 程式執行結束\n\n(Note: 以上虛擬碼以逐行步驟呈現，包含條件判斷、迴圈與 union‑find 操作，並在每行附上簡短說明。)"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,1,4,6,1,6,1,6]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 1, 4, 6, 1, 6, 1, 6]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black_set = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        idx = random.randint(0, self.size - 1)\n        return self.mapping.get(idx, idx)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1]) if len(data) > 1 else []\n\n    obj = None\n    results = []\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(args[0], args[1])\n            results.append(None)\n        elif op == \"pick\":\n            results.append(obj.pick())\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Provide algorithm: map allowed numbers. Use technique: white list mapping of black numbers < n - b to non-black numbers >= n - b. Preprocess mapping dict. Then pick random in [0, m-1] where m = n - b. Then if in mapping, return mapping value, else return the number itself.\n\nSo steps: Start, init with n, blacklist. Compute m = n - len(blacklist). Build set of blacklist for fast membership. Build mapping dictionary for black numbers < m. Build list of white numbers >= m not in blacklist. Then mapping[black] = white numbers list index. Provide pick function: generate random int k in [0, m-1]; if k in mapping return mapping[k] else return k.\n\nWe need to produce virtual code line by line with explanations. Must not output actual code, just virtual steps with arrows.\n\nWe can produce like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 n, blacklist // 取得輸入參數\n→ Step 2: 計算 m = n - blacklist.length // 可用數量\n→ Step 3: 建立 blacklistSet = {…} // 方便 O(1) 判斷\n→ Step 4: 建立 mapping = {} // 用於映射被列黑且小於 m 的數\n→ Step 5: 建立白色數列表 whiteList = [] // 大於等於 m 且不在 blacklist\n→ Decision: For each x in blacklist\n    → Decision: 如果 x < m? // 需要映射\n        Yes → Step 6: 將 x 加入 mapping待映射 // 暫存\n        No → Continue // 不需映射\n→ Step 7: 從 n-1 降序遍歷 i = n-1 downto m\n    → Decision: 如果 i 不在 blacklistSet? // 找到可用白色數\n        Yes → Step 8: 取下一個待映射黑數 key = mapping.popKey()\n            → Step 9: mapping[key] = i // 生成映射\n        No → Skip // i 為黑數\n→ End // 初始化完成\n\nPick function steps:\n\nStart pick // 選擇隨機數\n→ Step 10: randIndex = randomInt(0, m-1) // 隨機下標\n→ Decision: 是否在 mapping? // 檢查是否被映射\n    Yes → Step 11: return mapping[randIndex] // 轉到白色數\n    No  → Step 12: return randIndex // 原始數可用\nEnd // pick 執行結束\n\nNeed to ensure use of arrow structure. Format: \"→ Step X:\" etc. Use \"Decision:\" lines with indent for Yes/No.\n\nMake sure each line ends with // explanation. Use Chinese explanation.\n\nLet's craft final output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 n 與 blacklist // 取得輸入參數\n→ Step 2: 計算 m = n - blacklist.length // 可用數量\n→ Step 3: 建立 blacklistSet = {…} // 方便 O(1) 判斷\n→ Step 4: 建立 mapping = {} // 用於映射被列黑且小於 m 的數\n→ Step 5: 建立 whiteList = [] // 大於等於 m 且不在 blacklist\n→ Decision: 對 blacklist 逐一處理\n    Yes → Step 6: 若 x < m，將 x 加入 mapping 以待映射 // 需要映射的黑數\n    No  → Continue // x >= m 不需要映射\n→ Step 7: 從 i = n-1 降至 m\n    → Decision: 如果 i 不在 blacklistSet\n        Yes → Step 8: 取出 mapping 中任一鍵 key\n            → Step 9: mapping[key] = i // 建立黑數到白數的映射\n        No  → Skip // i 為黑數，忽略\n→ End // 初始化完成，已構建 mapping\n\nStart pick // 隨機選取\n→ Step 10: randIndex = randomInt(0, m-1) // 產生 0~m-1 的隨機整數\n→ Decision: randIndex 是否在 mapping\n    Yes → Step 11: return mapping[randIndex] // 轉為對應的白數\n    No  → Step 12: return randIndex // 直接返回，已是可用數\nEnd // pick 執行結束\n```"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,3,null,5]'\nGot (Norm):      '[null,null,0,null,0]'\n--- (Raw) ---\nRaw Expected: '[null, null, 3, null, 5]'\nRaw Got:      '[null, null, 0, null, 0]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass TrieNode:\n    \"\"\"Trie 節點，存放子節點與累積和\"\"\"\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n\nclass MapSum:\n    \"\"\"實作 MapSum，支援 insert 與 sum\"\"\"\n    def __init__(self):\n        self.root = TrieNode()\n        self.key_val = {}  # 追蹤每個 key 的現值\n\n    def insert(self, key: str, val: int) -> None:\n        \"\"\"插入或覆蓋 key-val，並更新 Trie 上的累積和\"\"\"\n        diff = val - self.key_val.get(key, 0)   # 變化量\n        self.key_val[key] = val\n        node = self.root\n        node.sum += diff\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += diff\n\n    def sum(self, prefix: str) -> int:\n        \"\"\"回傳所有以 prefix 為前綴的 key 對應值之總和\"\"\"\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef parse_input(raw: str):\n    \"\"\"依照 LeetCode 風格解析輸入，返回 commands 與 args\"\"\"\n    raw = raw.strip()\n    # 先嘗試找出「], [」分隔符號\n    split_index = raw.find('], [')\n    if split_index != -1:\n        left = raw[:split_index + 1]           # 第一個 list (commands)\n        right = raw[split_index + 3:]          # 第二個 list (args)\n        # 若第二個 list 之開頭不是 '['，補上\n        if not right.startswith('['):\n            right = '[' + right\n        commands = ast.literal_eval(left)\n        args = ast.literal_eval(right)\n    else:\n        # 以換行分隔\n        parts = raw.splitlines()\n        commands = ast.literal_eval(parts[0])\n        args = ast.literal_eval(parts[1])\n    return commands, args\n\ndef main():\n    raw = sys.stdin.read()\n    commands, args = parse_input(raw)\n\n    ms = MapSum()\n    results = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == 'insert':\n            ms.insert(arg[0], arg[1])\n            results.append(None)      # 代表 null\n        elif cmd == 'sum':\n            results.append(ms.sum(arg))\n        else:\n            # 未知命令，跳過\n            results.append(None)\n\n    # 使用 json.dumps 讓 None 轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for a MapSum class, with methods and explanation each line. We must use structure arrows, Start, End, Decision etc. Each line: \"虛擬碼步驟 // 解釋\". Need to outline the data structure: probably Trie nodes with sum fields, mapping for existing keys. Steps: initialize root, map. insert: update map, compute diff, propagate along trie. sum: traverse trie by prefix, return sum.\n\nWe produce virtual code lines. Use arrow for steps. Use \"Start\", \"End\", \"Decision:\".\n\nLet's create steps:\n\nStart // 初始化 MapSum\n→ Step 1: 創建 TrieNode root // 根節點\n→ Step 2: 建立 keyToVal 哈希表 // 儲存 key 的現值\nEnd // 初始化結束\n\nInsert:\nStart // insert 方法開始\n→ Step 1: 如果 key 在 keyToVal 中，則 diff = val - keyToVal[key]; 否則 diff = val // 計算差值\n→ Step 2: keyToVal[key] = val // 更新哈希表\n→ Step 3: node = root // 以根節點為起點\n→ Step 4: For 每個字符 c 在 key: // 遍歷字串\n    → Decision: 是否存在 node.children[c]? // 檢查子節點\n        Yes → node = node.children[c] // 移動到子節點\n        No  → 創建 new TrieNode 並指向 node.children[c]，node = node.children[c]\n    → node.sum += diff // 更新節點 sum\nEnd // insert 方法結束\n\nSum:\nStart // sum 方法開始\n→ Step 1: node = root // 從根開始\n→ Step 2: For 每個字符 c 在 prefix: // 遍歷前綴\n    → Decision: node.children[c] 是否存在? // 確認路徑\n        Yes → node = node.children[c] // 移動\n        No  → Return 0 // 前綴不存在，總和為 0\n→ Step 3: Return node.sum // 返回前綴對應節點的 sum\nEnd // sum 方法結束\n\nWe need to write these as virtual code lines with explanation. Use arrow for steps. Use Decision for condition. Should be clear.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 創建 TrieNode 根節點 // 初始化 Trie 結構\n→ Step 2: 建立 keyToVal 哈希表 // 用於快速查詢已插入鍵的原始值\nEnd // 初始化結束\n\n// MapSum 類別定義\nStart // MapSum 類別方法開始\n\n→ Step 1: insert(key, val) // 插入或覆蓋鍵值對\n    → Decision: key 是否已存在於 keyToVal？ // 判斷是否是覆蓋操作\n        Yes → Step 2: diff = val - keyToVal[key] // 計算值變化量\n        No  → Step 2: diff = val // 新鍵，差值即為 val\n    → Step 3: keyToVal[key] = val // 更新鍵對應的新值\n    → Step 4: node = root // 從根節點開始\n    → Step 5: For 每個字符 c 在 key 之中： // 遍歷鍵字的每個字符\n        → Decision: node.children[c] 是否存在？ // 檢查是否已有該子節點\n            Yes → node = node.children[c] // 移動到已存在的子節點\n            No  → Step 6: 創建新 TrieNode 並設為 node.children[c]，node = node.children[c] // 建立缺失的節點\n        → Step 7: node.sum += diff // 更新沿途所有節點的累積和\nEnd // insert 方法結束\n\n→ Step 1: sum(prefix) // 計算前綴和\n    → Step 2: node = root // 從根節點開始\n    → Step 3: For 每個字符 c 在 prefix 之中： // 遍歷前綴字串\n        → Decision: node.children[c] 是否存在？ // 確認路徑\n            Yes → node = node.children[c] // 移動到子節點\n            No  → Step 4: 返回 0 // 前綴不存在，直接返回 0\n    → Step 5: 返回 node.sum // 前綴對應節點的累積和即為結果\nEnd // sum 方法結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.566806752360653,0.1738285600192901],[0.26969930313037627,-0.12949460868860443],[0.4218412398781559,0.43967335643698563]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.566806752360653, 0.1738285600192901], [0.26969930313037627, -0.12949460868860443], [0.4218412398781559, 0.43967335643698563]]'"
        }
      ],
      "generated_code": "import sys\nimport math\nimport random\nimport json\nimport ast\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機產生均勻分佈的半徑與角度\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1]) if len(data) > 1 else []\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)          # 建構子沒有回傳值\n        else:\n            method = getattr(obj, cmd)\n            results.append(method(*args))\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation, no real code. Steps for class initialization and randPoint: choose random radius sqrt(U)*R, random angle theta uniform [0,2π). Then x = x_center + r*cos(theta), y = y_center + r*sin(theta). Need to generate uniform point inside circle. Provide pseudocode lines with arrows etc. Let's craft.\n\nWe should start with Start, then initialize solution: store radius, x_center, y_center. Then method randPoint: generate uniform random angle, uniform random radius using sqrt trick. Then compute x, y, return array. Then End.\n\nMake sure each line ends with // explanation.\n\nWe must use arrow syntax: → Step: ... ; For decision maybe not needed. Use Start and End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 宣告要實作的類別  \n→ Step 2: 建構子 Solution(radius, x_center, y_center)  \n    → Store radius as this.radius // 以防未來使用  \n    → Store x_center as this.xCenter // 中心 x 座標  \n    → Store y_center as this.yCenter // 中心 y 座標  \n→ Step 3: 定義方法 randPoint() // 產生隨機點  \n    → 產生均勻角度 θ ← Random(0, 2π) // 隨機角度  \n    → 產生均勻半徑值 u ← Random(0, 1) // 隨機 0~1  \n    → 計算實際半徑 r ← sqrt(u) * this.radius // 轉換為均勻分佈  \n    → 計算座標 x ← this.xCenter + r * cos(θ) // 根據極座標轉換  \n    → 計算座標 y ← this.yCenter + r * sin(θ) // 同上  \n    → 回傳 [x, y] // 返回隨機點的座標陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [3,2,2,3], val = 3",
          "expected_output": "2, nums = [2,2,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2,nums=[2,2,_,_]'\nGot (Norm):      '2,nums=[2,2,\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '2, nums = [2,2,_,_]'\nRaw Got:      \"2, nums = [2, 2, '_', '_']\""
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,3,0,4,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,3,0,4,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,\"_\",\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,3,0,4,_,_,_]'\nRaw Got:      \"5, nums = [0, 1, 3, 0, 4, '_', '_', '_']\""
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"移除所有等於 val 的元素，返回新的有效長度 k。\n        這個實作使用雙指針技巧，將非 val 元素覆蓋到前面。\n        \"\"\"\n        slow = 0  # 指向下個要放置非 val 元素的位置\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中解析出 nums 與 val。\"\"\"\n    # 取得方括號中的數字序列\n    list_match = re.search(r'\\[(.*?)\\]', data)\n    if not list_match:\n        raise ValueError(\"未找到陣列資料\")\n    nums = ast.literal_eval(f'[{list_match.group(1)}]')\n\n    # 取得 val 的整數值\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n    if not val_match:\n        raise ValueError(\"未找到 val 資料\")\n    val = int(val_match.group(1))\n    return nums, val\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    nums, val = parse_input(raw)\n\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # 建立輸出格式：前 k 個元素顯示，後面填 '_' 以示未使用\n    remaining = ['_'] * (len(nums) - k)\n    display = nums[:k] + remaining\n    print(f\"{k}, nums = {display}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, per spec. It's a typical two-pointer solution: use fast pointer iterate array, slow pointer to place non-val. Return slow index.\n\nWe need step-by-step virtual code lines with comments.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize slow = 0 // point to next position to place non-val\n→ Decision: If fast < nums.length? // iterate\n    Yes → Decision: nums[fast] == val? // skip val\n        Yes → Step 2: fast++ // skip\n        No → Step 3: nums[slow] = nums[fast] // place\n            → Step 4: slow++ // increment slow\n            → Step 5: fast++ // move fast\n    No → End\n\nAfter loop, return slow\n\nEdge: need fast pointer.\n\nLet's output. Ensure each line includes virtual code step then // explanation.\n\nMake sure arrow formatting as spec.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 slow = 0 // slow 指向下一個可放置非 val 元素的位置  \n→ Step 2: 初始化 fast = 0 // fast 用來掃描整個陣列  \n→ Decision: fast < nums.length? // 是否還有元素未掃描？  \n  Yes → Decision: nums[fast] == val? // 目前元素是否等於要移除的 val？  \n    Yes → Step 3: fast++ // 如果是 val，直接跳過  \n    No → Step 4: nums[slow] = nums[fast] // 把非 val 元素放到 slow 所指位置  \n       → Step 5: slow++ // slow 移動到下一個可放置位置  \n       → Step 6: fast++ // fast 前進到下一個元素  \n  No → End // 所有元素已掃描完畢  \n→ Step 7: 返回 slow // slow 即為不等於 val 的元素數量 k  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[None,[2,3,1],[1,2,3],[1,2,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[None, [2, 3, 1], [1, 2, 3], [1, 2, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = list(nums)   # 儲存原始陣列\n        self.current = list(nums)    # 可變陣列\n\n    def reset(self):\n        self.current = list(self.original)  # 重新設定為原始陣列\n        return self.current\n\n    def shuffle(self):\n        n = len(self.current)\n        for i in range(n):\n            j = random.randint(i, n - 1)  # 隨機選取索引\n            self.current[i], self.current[j] = self.current[j], self.current[i]\n        return self.current\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 將輸入分為方法列表和參數列表\n    parts = data.split('],', 1)\n    methods = ast.literal_eval(parts[0] + ']')\n    args = ast.literal_eval(parts[1])\n\n    # 建構物件（第一個方法為 'Solution'）\n    obj = None\n    results = [None]  # 第一個元素對應建構子，返回值為 None\n    if methods[0] == \"Solution\":\n        obj = Solution(*args[0])\n\n    # 執行其餘方法\n    for m, a in zip(methods[1:], args[1:]):\n        if m == \"reset\":\n            res = obj.reset()\n        elif m == \"shuffle\":\n            res = obj.shuffle()\n        else:\n            res = None\n        results.append(res)\n\n    # 輸出結果\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments. Must follow the format: each line: \"虛擬碼步驟 // 解釋\". Use arrows. Start, Decision, etc.\n\nWe need to design algorithm to randomly shuffle array: using Fisher-Yates. Need to store original array for reset.\n\nThus steps: Start, set original array, copy array to current, etc.\n\nWe need to include methods: constructor, reset, shuffle.\n\nIn pseudocode: Start. -> initialize original array. -> store current array.\n\nReset: -> copy original to current. -> return current.\n\nShuffle: -> for i from 0 to n-1: pick j random between i and n-1. swap arr[i], arr[j]. -> return arr.\n\nNeed to incorporate decision for random selection. Also include storing original copy.\n\nMake sure to follow format exactly: \"Start // 程式開始執行\" etc.\n\nEach line: \"虛擬碼步驟 // 解釋\". We should keep steps with arrows.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 儲存原始陣列 nums 為 original // 保存傳入的陣列作為原始狀態\n→ Step 2: 複製 original 為 current // 生成一個可變的陣列以供後續操作\n→ End // 物件初始化完成\n\nBut we need to show separate methods: maybe we need separate blocks for constructor, reset, shuffle.\n\nWe'll write like:\n\nStart // 程式開始執行\n→ Decision: 是否為建構子? // 判斷執行的動作類型\n    Yes → Constructor // 建構子執行\n        → Step 1: original ← copy(nums) // 將輸入陣列複製為原始\n        → Step 2: current ← copy(original) // 初始化可變陣列\n        → Return // 建構完成\n    No  → Decision: 方法為 reset? // 檢查是否為 reset 方法\n        Yes → reset // 重置方法執行\n            → Step 1: current ← copy(original) // 重新把 current 設為原始\n            → Return current // 回傳重置後的陣列\n        No  → Decision: 方法為 shuffle? // 檢查是否為 shuffle 方法\n            Yes → shuffle // 洗牌方法執行\n                → Step 1: n ← length(current) // 取得陣列長度\n                → Step 2: for i from 0 to n-1 // 逐一遍歷陣列\n                    → Step 2a: j ← random integer in [i, n-1] // 隨機選取範圍內的索引\n                    → Step 2b: swap current[i] with current[j] // 交換位置\n                → Return current // 回傳洗牌後的陣列\n            No → End // 不符合任何方法\n\nBut we need to maintain \"End // 程式執行結束\" at the end of each method? The specification example shows Start and End for program.\n\nWe might produce a flowchart: Start, then method-specific steps, then End. But maybe simpler: just produce lines as described with arrows.\n\nProbably they expect something like:\n\nStart // 程式開始執行\n→ Step 1: 定義變數 original, current // 用於儲存陣列\n→ Step 2: Constructor(nums) // 建構子初始化\n    → original ← copy(nums)\n    → current ← copy(original)\n→ End // 建構完成\n\nBut they want to produce virtual code for the whole algorithm. We can produce a simple linear flow:\n\nStart // 程式開始執行\n→ Constructor: 設定 original 與 current\n    → original ← copy(nums)\n    → current ← copy(original)\n→ reset() // 重置陣列\n    → current ← copy(original)\n    → Return current\n→ shuffle() // 隨機洗牌\n    → n ← length(current)\n    → for i from 0 to n-1\n        → j ← random integer in [i, n-1]\n        → swap current[i] with current[j]\n    → Return current\nEnd // 程式執行結束\n\nBut each line must have \"// 解釋\". For loops and nested steps maybe separate lines.\n\nLet's produce following format:\n\nStart // 程式開始執行\n→ Step 1: 定義變數 original, current // 用於存儲陣列\n→ Constructor(nums) // 建構子：初始化\n    → original ← copy(nums) // 儲存原始陣列\n    → current ← copy(original) // 初始化可變陣列\n→ reset() // 重置方法：恢復原始陣列\n    → current ← copy(original) // 把 current 設回原始\n    → Return current // 返回重置後的陣列\n→ shuffle() // 洗牌方法：隨機排列\n    → n ← length(current) // 取得陣列長度\n    → for i from 0 to n-1\n        → j ← random integer in [i, n-1] // 隨機選擇位置\n        → swap current[i] with current[j] // 交換元素\n    → Return current // 返回洗牌後的陣列\nEnd // 程式執行結束\n\nBut need to maintain arrow formatting: \"→\". For nested lines maybe indent? But example shows \"→ Decision:\" with indentation. So we need to use indentation.\n\nLet's format as:\n\nStart // 程式開始執行\n→ Step 1: 定義變數 original, current // 用於存儲陣列\n→ Decision: 是否為建構子? // 判斷執行動作\n    Yes → Constructor(nums) // 建構子初始化\n        → original ← copy(nums) // 儲存原始陣列\n        → current ← copy(original) // 初始化可變陣列\n    No → Decision: 是否為 reset? // 檢查是否為 reset 方法\n        Yes → reset() // 重置陣列\n            → current ← copy(original) // 把 current 設回原始\n            → Return current // 返回重置後的陣列\n        No → Decision: 是否為 shuffle? // 檢查是否為 shuffle 方法\n            Yes → shuffle() // 洗牌方法\n                → n ← length(current) // 取得陣列長度\n                → for i from 0 to n-1\n                    → j ← random integer in [i, n-1] // 隨機選擇位置\n                    → swap current[i] with current[j] // 交換元素\n                → Return current // 返回洗牌後的陣列\n            No → End // 不符合任何方法\nEnd // 程式執行結束\n\nBut note: We used \"End\" twice; maybe not needed. The example had End after program. Let's adjust: Keep End at the bottom. For \"No → End\" we might just skip.\n\nSimplify: Provide separate sections: Constructor, reset, shuffle. Not using decision flow. The example used decision only for condition inside algorithm, not for method selection. So we can just present each method's steps.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: 定義變數 original, current // 用於存儲陣列\n→ Constructor(nums) // 建構子：初始化\n    → original ← copy(nums) // 儲存原始陣列\n    → current ← copy(original) // 初始化可變陣列\n→ reset() // 重置方法：恢復原始陣列\n    → current ← copy(original) // 把 current 設回原始\n    → Return current // 返回重置後的陣列\n→ shuffle() // 洗牌方法：隨機排列\n    → n ← length(current) // 取得陣列長度\n    → for i from 0 to n-1\n        → j ← random integer in [i, n-1] // 隨機選擇位置\n        → swap current[i] with current[j] // 交換元素\n    → Return current // 返回洗牌後的陣列\nEnd // 程式執行結束\n\nBut the example had \"Step 1:\" style with arrow. The lines for constructor etc might not have arrow? Actually example: \"→ Step 1: 輸入使用者數字\". So arrow before Step. For method names we can also use arrow.\n\nThus we can format as:\n\nStart // 程式開始執行\n→ Step 1: 定義變數 original, current // 用於存儲陣列\n→ Constructor(nums) // 建構子：初始化\n    → original ← copy(nums) // 儲存原始陣列\n    → current ← copy(original) // 初始化可變陣列\n→ reset() // 重置方法：恢復原始陣列\n    → current ← copy(original) // 把 current 設回原始\n    → Return current // 返回重置後的陣列\n→ shuffle() // 洗牌方法：隨機排列\n    → n ← length(current) // 取得陣列長度\n    → for i from 0 to n-1\n        → j ← random integer in [i, n-1] // 隨機選擇位置\n        → swap current[i] with current[j] // 交換元素\n    → Return current // 返回洗牌後的陣列\nEnd // 程式執行結束\n\nCheck format: each line must be \"虛擬碼步驟\" + space + \"// 解釋\". The lines for nested steps are indented but still have arrow at start. That's fine.\n\nBut need to use \"Step 1:\"? Already used. For other lines we didn't use \"Step\". But not necessary. Use \"→ Constructor(nums)\". Provide comment. That fits.\n\nAlternatively, we could combine steps within constructor but it's okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 original, current // 用於存儲陣列  \n→ Constructor(nums) // 建構子：初始化  \n → original ← copy(nums) // 儲存原始陣列  \n → current ← copy(original) // 初始化可變陣列  \n→ reset() // 重置方法：恢復原始陣列  \n → current ← copy(original) // 把 current 設回原始  \n → Return current // 返回重置後的陣列  \n→ shuffle() // 洗牌方法：隨機排列  \n → n ← length(current) // 取得陣列長度  \n → for i from 0 to n-1  \n  → j ← random integer in [i, n-1] // 隨機選擇位置  \n  → swap current[i] with current[j] // 交換元素  \n → Return current // 返回洗牌後的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def subsets(self, nums):\n        \"\"\"\n        回溯生成所有子集\n        \"\"\"\n        res = []\n\n        def backtrack(start, path):\n            # 把目前的子集加入結果\n            res.append(path[:])\n            # 從 start 位置開始嘗試加入更多元素\n            for i in range(start, len(nums)):\n                path.append(nums[i])          # 加入元素\n                backtrack(i + 1, path)        # 進一步遞迴\n                path.pop()                    # 回溯，移除最後加入的元素\n\n        backtrack(0, [])\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    從形如 'nums = [1,2,3]' 的字串解析出 list。\n    \"\"\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n    # 為安全起見僅允許 eval 數字與列表\n    # 這裡假設輸入正確且為合法 Python 列表表達式\n    return eval(expr)\n\nif __name__ == \"__main__\":\n    # 讀取所有標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(\"[]\")\n        sys.exit()\n\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.subsets(nums)\n\n    # 將結果轉成不帶空格的字串\n    result_str = '[' + ','.join(subset_str.replace(' ', '')\n                                   for subset_str in map(str, result)) + ']'\n    print(result_str)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating power set of unique elements array. Use recursive backtracking or iterative. Provide each line with arrow. Provide explanation in Chinese.\n\nLet's produce steps: Start, Input array, sort maybe not necessary, Step: initialize result, Step: define backtrack function, Recursively generate subsets. Use for loop from index to len(nums). Add current subset to result, call recursively, then backtrack remove last. After recursion start backtrack from 0 with empty subset. Return result. End.\n\nAlso need to include the initial addition of empty subset.\n\nLet's produce.\n\nUse format: Start, → Step: etc. Use decision maybe not necessary.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input integer array `nums` of unique elements // 取得輸入陣列  \n→ Step 2: Initialize empty list `result` to store all subsets // 用於儲存結果  \n→ Step 3: Define recursive function `backtrack(start, current)` // 設定回溯函式  \n&nbsp;&nbsp;→ Step 4: Append copy of `current` to `result` // 將目前子集加入結果  \n&nbsp;&nbsp;→ Step 5: For `i` from `start` to `len(nums)-1` // 遍歷剩餘元素  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: If `i` is valid? // 確保索引在範圍內  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: Append `nums[i]` to `current` // 加入當前元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 7: Call `backtrack(i+1, current)` // 進一步遞迴  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 8: Pop last element from `current` // 回溯，移除最後加入的元素  \n&nbsp;&nbsp;→ End of For  \n&nbsp;&nbsp;→ End of backtrack function  \n→ Step 9: Call `backtrack(0, [])` to start recursion with empty subset // 開始回溯  \n→ Step 10: Return `result` // 回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Binary Search",
      "source_file": "Leetcode/leetcode704.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,3,5,9,12], target = 9",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4l95upzp.py\", line 27, in <module>\n    target_str = parts[1].split('=')[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0,3,5,9,12], target = 2",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpq8q0zcr_.py\", line 27, in <module>\n    target_str = parts[1].split('=')[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入資料\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 假設輸入格式為：'nums = [...], target = ...'\n    parts = data.split(',')\n    # 取得 nums 部分\n    nums_str = parts[0].split('=')[1].strip()\n    # 取得 target 部分\n    target_str = parts[1].split('=')[1].strip()\n\n    # 使用 eval 解析列表與整數\n    nums = eval(nums_str)\n    target = eval(target_str)\n\n    # 執行搜尋\n    sol = Solution()\n    result = sol.search(nums, target)\n\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for binary search algorithm. Provide step-by-step with explanations. Use the given format. Ensure each line is a virtual step. The steps: Start, set low=0, high=length-1, loop while low <= high, compute mid, compare, adjust, break, return index or -1. Use decision arrows.\n\nLet's produce lines:\n\nStart // start\n\n→ Step 1: 初始化 low=0, high=nums.length-1 // set pointers\n\n→ Decision: low <= high? // check loop condition\n\n    Yes → Step 2: mid = (low + high) // 2 // compute middle index\n\n    Yes → Decision: nums[mid] == target? // check if found\n\n        Yes → Step 3: 返回 mid // found target\n\n        No  → Decision: nums[mid] < target? // decide to search right\n\n            Yes → Step 4: low = mid + 1 // adjust low\n\n            No  → Step 5: high = mid - 1 // adjust high\n\n    No  → Step 6: 返回 -1 // target not found\n\nEnd // finish\n\nNeed to ensure proper indentation and arrow usage. Use \"→\" before each step. For decision, \"Decision:\" line. Use \"Yes →\" and \"No →\" branches.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 low = 0, high = nums.length - 1 // 設定二分搜尋的左右指標  \n→ Decision: low <= high? // 判斷是否仍有區間可搜尋  \n  Yes → Step 2: mid = (low + high) // 2 // 計算中間索引  \n  Yes → Decision: nums[mid] == target? // 檢查中間元素是否為目標  \n    Yes → Step 3: 返回 mid // 找到目標，回傳索引  \n    No  → Decision: nums[mid] < target? // 判斷目標在右半區段  \n      Yes → Step 4: low = mid + 1 // 將左指標移至右側  \n      No  → Step 5: high = mid - 1 // 將右指標移至左側  \n  No  → Step 6: 返回 -1 // 沒有找到目標，回傳 -1  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp002xqult.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmp002xqult.py\", line 30, in main\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 25 (char 24)"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp764zw0yj.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmp764zw0yj.py\", line 30, in main\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 73 (char 72)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"Pre‑compute prefix sums of the weights.\"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"Return an index weighted by the given probabilities.\"\"\"\n        # Choose a random integer in [1, total]\n        target = random.randint(1, self.total)\n        # Binary search to find the first prefix sum >= target\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    # Read entire stdin and split into lines\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n\n    # Expect two lines: operations and arguments\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    solution = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # arg[0] is the list of weights\n            solution = Solution(arg[0])\n            results.append(None)  # Constructor returns null\n        elif op == \"pickIndex\":\n            results.append(solution.pickIndex())\n\n    # Output the results as a JSON array\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. The user wants the algorithm for weighted random selection: given array w, implement pickIndex returning index according to weights. Usually we precompute prefix sums and random between 1 and total. Steps: preprocess: compute prefix sum array, total sum. Then pickIndex: generate random integer r between 1 and total inclusive. Find first prefix >= r using binary search. Return index. Provide virtual code lines with comments. Use Start, End, Decision. Use arrows. Provide each line step. Should include preprocessing steps maybe in constructor or initialization. Then pickIndex function. We can structure: Start, Step: Build prefix sums. Step: End. Then Decision for pickIndex: generate random. Decision: use binary search. etc.\n\nWe need to ensure each line: \"虛擬碼步驟 // 解釋\". Use arrow and indentation maybe. Use \"→\" etc. Provide steps line by line. So like:\n\nStart // 開始\n→ Step 1: 初始化 prefixSum array // 建立前綴和\n→ Step 2: 計算 prefixSum[i] = prefixSum[i-1] + w[i] // 累加權重\n→ Step 3: 設定 total = prefixSum[last] // 整體權重總和\nEnd // 完成初始化\n\nStart // pickIndex 呼叫\n→ Step 1: 產生隨機數 r ∈ [1, total] // 隨機整數\n→ Decision: 如果 r ≤ prefixSum[0]? // 檢查第一個前綴和\n    Yes → Return 0 // 找到索引\n    No  → Decision: r ≤ prefixSum[1]? // 依次檢查\n        Yes → Return 1\n        No  → ...\nAlternatively use binary search.\n\nBetter to show binary search: Use left=0, right=last. While left<right: mid = (left+right)//2; if r <= prefixSum[mid] then right=mid else left=mid+1. Return left.\n\nSo steps accordingly.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的前綴和陣列 prefixSum // 用來存每個索引的累加權重  \n→ Step 2: 初始化 total = 0 // 用來儲存所有權重之和  \n→ Step 3: 循環遍歷 w，對每個索引 i  \n  → Decision: 如果 i==0? // 第一個元素需要特殊處理  \n   Yes → prefixSum[0] = w[0]  \n   No  → prefixSum[i] = prefixSum[i-1] + w[i] // 累加前一個前綴和  \n  → total = prefixSum[last] // 計算總權重  \nEnd // 前綴和與總權重已完成  \n\nStart // pickIndex() 之執行  \n→ Step 1: 產生隨機整數 r 介於 1 與 total 之間 // r 代表累加權重位置  \n→ Step 2: 設定 left = 0, right = w.length - 1 // 二分搜尋範圍  \n→ Decision: left < right? // 是否仍可繼續二分  \n  Yes → Step 3: 計算 mid = (left + right) // 2 // 取中點索引  \n   Decision: r <= prefixSum[mid]? // r 在 mid 前綴和之內  \n    Yes → right = mid // 將搜尋範圍縮到左半部  \n    No  → left = mid + 1 // r 在右半部  \n   → 回到 Decision: left < right? // 重新檢查條件  \n  No  → Step 4: 回傳 left // 左右邊界相同，即找到對應索引  \nEnd // pickIndex() 執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4jm009on.py\", line 35, in <module>\n    main()\n  File \"/tmp/tmp4jm009on.py\", line 26, in main\n    k_str = parts[1].split('=', 1)[1].strip()\n            ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy76s7jwl.py\", line 35, in <module>\n    main()\n  File \"/tmp/tmpy76s7jwl.py\", line 26, in main\n    k_str = parts[1].split('=', 1)[1].strip()\n            ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()\n        return [i for _, i in soldiers[:k]]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expect format: 'mat = [...], k = ...'\n    parts = data.split(',')\n    mat_str = parts[0].split('=', 1)[1].strip()\n    k_str = parts[1].split('=', 1)[1].strip()\n    mat = eval(mat_str)\n    k = int(k_str)\n\n    sol = Solution()\n    result = sol.kWeakestRows(mat, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The problem: given binary matrix where each row is sorted (1's then 0's). We need k weakest rows by number of soldiers, tie by row index. Output indices of k weakest rows sorted. We'll produce algorithm: For each row compute number of soldiers (count of 1's). Use binary search since sorted. Or simple loop until first 0. Then sort pairs (count, index). Then pick first k indices. We'll generate pseudocode with steps.\n\nWe need to output in the format: each line \"虛擬碼步驟 // 解釋\" with arrow etc. Should include Start, End, Decision. Provide step by step.\n\nWe need to produce for user request: the algorithm pseudocode. We'll include comments. Use arrow for steps. Use Decision structure for binary search or counting? Probably we can use a decision to search the boundary.\n\nWe need to be careful: the code should not contain actual code; only pseudo-code steps. Provide explanation after each line.\n\nWe'll start with Start, then Step: Input mat, m, n, k. Then for each row i, compute soldierCount(i). We'll show count by binary search or scanning. Then store pair. Then sort pairs ascending by soldierCount, then index. Then output first k indices. Then End.\n\nWe need to show decisions for binary search: Decision: If mat[i][mid]==1? etc.\n\nWe also may skip actual binary search details; we can describe: Step: Count soldiers by binary search.\n\nBut the requirement: \"逐行\" produce pseudocode with arrows and decision. We should include at least one decision. Use Decision for binary search. We can show decision tree:\n\nDecision: while low < high: mid = (low+high)/2; if mat[i][mid]==1 -> low=mid+1 else high=mid. At end soldierCount = low.\n\nBut we must keep pseudocode simple but include Decision. Use arrow for steps.\n\nLet's produce:\n\nStart\n→ Input: mat, k\n→ Set m = number of rows, n = number of columns\n→ Create empty list rowsInfo\n→ For each i from 0 to m-1:\n    → Step: low=0, high=n\n    → While low < high:\n        → Decision: If mat[i][low]==1? maybe mid? We can use mid.\nBut to keep simple we can show high=mid if 0 else low=mid+1. We'll produce Decision: If mat[i][mid]==1?\n\nWe'll produce:\n\n    → Decision: If mat[i][mid] == 1? // Check mid element\n        Yes → low = mid + 1 // soldier extends right\n        No  → high = mid // soldier ends before mid\n    → End While\n    → soldierCount = low\n    → Append (soldierCount, i) to rowsInfo\n\nAfter loop: Sort rowsInfo by soldierCount ascending, then index ascending. Then select first k indices. Then output indices list.\n\nWe need to provide explanation after each line.\n\nLet's craft final answer. Use proper formatting.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: mat, k // 讀取二維矩陣與需要輸出的弱行數  \n→ Set m = row count of mat, n = column count of mat // 獲得矩陣尺寸  \n→ Create empty list rowsInfo // 用於儲存每行的 (soldierCount, rowIndex)  \n→ For each i from 0 to m-1: // 逐行處理  \n    → Set low = 0, high = n // 初始化二分搜尋範圍  \n    → While low < high: // 找出第一個 0 的位置，亦即 1 的個數  \n        → Set mid = (low + high) / 2 // 計算中點  \n        → Decision: mat[i][mid] == 1? // 檢查中點元素  \n            Yes → low = mid + 1 // 仍在 1 的範圍內，繼續往右搜尋  \n            No  → high = mid // 0 出現在 mid 左側，縮小範圍  \n    → End While // 退出搜尋，low 即為 1 的總數  \n    → Set soldierCount = low // 取得第 i 行的士兵數目  \n    → Append (soldierCount, i) to rowsInfo // 儲存結果  \n→ End For // 所有行已計算完畢  \n→ Sort rowsInfo by (soldierCount ascending, rowIndex ascending) // 按弱度排序  \n→ Create empty list weakestIndices // 用於儲存前 k 個弱行索引  \n→ For each j from 0 to k-1: // 取前 k 個  \n    → Append rowsInfo[j].rowIndex to weakestIndices // 把索引放入結果  \n→ End For // 取得所有弱行索引  \n→ Output weakestIndices // 回傳答案  \nEnd // 程式執行結束"
    }
  ]
}