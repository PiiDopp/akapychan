{
  "run_index": 33,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 391,
  "generation_or_validation_failure_count": 48,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[6,5,5,1,5]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[6, 5, 5, 1, 5]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\ndef roll_dice(n):\n    \"\"\"擲 n 次六面骰，回傳所有結果的列表\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個程式碼（例如：print(roll_dice(5))）\n    code = sys.stdin.read()\n    if code.strip():\n        # 執行輸入的程式碼，使用全域名稱空間\n        exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to output virtual code with steps per line. Each line: virtual code step + space + // explanation. Use arrows etc. Start and End. Need to simulate function roll_dice(n). Use random module. Steps: import random, define function, create list, loop n times, roll dice random.randint(1,6), append, return list. Use virtual code arrows. Should we include function signature? Use Start, Step 1: Import random module. Step 2: Define function roll_dice(n). Inside: Step 3: Initialize results list. Step 4: For loop i from 1 to n. Step 5: roll = random.randint(1,6). Step 6: Append roll. Step 7: After loop, return results. End. Also note the random module usage. Provide comments. Use indentation? They didn't mention but can use arrow arrows. I'll produce each line as described.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 導入 random 模組以便生成隨機數  \n→ Step 2: Define function roll_dice(n) // 建立 roll_dice(n) 函式，接收擲骰次數  \n→ Step 3: Initialize empty list results // 用於存放每一次擲骰的結果  \n→ Step 4: For i from 1 to n // 重複擲骰 n 次  \n  → Step 5: roll = random.randint(1, 6) // 生成 1~6 的隨機整數代表一次擲骰結果  \n  → Step 6: Append roll to results // 將結果加入列表  \n→ Step 7: Return results // 回傳所有擲骰結果的列表  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\n# ──────────────────────────────────────\n# 測量任意函數執行時間的工具函數\n# ──────────────────────────────────────\ndef measure_time(func, *args):\n    \"\"\"\n    呼叫 func(*args)，並測量它執行所需的秒數。\n    回傳四捨五入到小數點 3 位的耗時。\n    \"\"\"\n    start = time.perf_counter()          # 記錄開始時間（高精度）\n    result = func(*args)                 # 執行目標函數\n    end = time.perf_counter()            # 記錄結束時間\n    elapsed = end - start                # 計算耗時\n    return round(elapsed, 3)             # 四捨五入到 3 位小數\n\n# ──────────────────────────────────────\n# 主程式入口：從標準輸入讀取程式碼並執行\n# ──────────────────────────────────────\nif __name__ == \"__main__\":\n    # 讀取整個 stdin 內容，預期是使用者撰寫的程式碼\n    code = sys.stdin.read()\n    # 在目前的全域命名空間執行這段程式碼\n    # 這樣就能直接使用上面定義的 measure_time\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. Should be in Traditional Chinese. We need each line: \"虛擬碼步驟 // 解釋\". Use arrows etc. Need Start, End. Steps: import time, define function measure_time, record start, call func, record end, compute elapsed, round to 3 decimal places, return elapsed and result? Wait \"測量函數 func 執行所需的秒數，並回傳結果\" unclear: return the result? It might return the rounded time? Or return tuple? Usually measure_time returns the result of func? They want time only? It says \"回傳結果\" maybe the time. So function returns elapsed time. We'll produce steps accordingly. Use Decision? No.\n\nLet's produce virtual code.\n\nStart\n→ Step 1: Import time module // 導入計時模組\n→ Step 2: Define function measure_time(func, *args) // 定義測時函數，接受目標函數及任意參數\n→ Step 3: Record start_time = time.perf_counter() // 取得高精度起始時間\n→ Step 4: Execute result = func(*args) // 呼叫目標函數並儲存回傳值\n→ Step 5: Record end_time = time.perf_counter() // 取得結束時間\n→ Step 6: Compute elapsed = end_time - start_time // 計算耗時\n→ Step 7: Round elapsed_rounded = round(elapsed, 3) // 四捨五入到小數點 3 位\n→ Step 8: Return elapsed_rounded // 回傳計算好的耗時\n\nBut maybe also return result. Could mention that. We can include both. Let's choose to return tuple (elapsed_rounded, result). Provide explanation accordingly.\n\nWe need to include arrows. Use \"→\" each line.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 導入 time 模組以便使用高精度計時功能  \n→ Step 2: Define function measure_time(func, *args) // 定義測量函數，接受目標函數與其參數  \n→ Step 3: Record start_time = time.perf_counter() // 記錄執行前的起始時間（高精度）  \n→ Step 4: Execute result = func(*args) // 呼叫目標函數並保存其回傳值  \n→ Step 5: Record end_time = time.perf_counter() // 記錄執行後的結束時間  \n→ Step 6: Compute elapsed = end_time - start_time // 計算函數執行所花費的秒數  \n→ Step 7: Round elapsed_rounded = round(elapsed, 3) // 將耗時四捨五入到小數點 3 位  \n→ Step 8: Return elapsed_rounded // 回傳四捨五入後的秒數（若需保留原始結果可改為返回 (elapsed_rounded, result)）  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"melon\",\"apple\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'melon', 'apple', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取標準輸入（若有提供，但此題不需要實際資料）\n    sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除 'pineapple'（不存在時不會報錯）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps. The user wants virtual code steps to create set, add, update, remove, discard, print. Use Start, End, Decision maybe not necessary, but we can use Decision to show conditions. We'll produce each step as line.\n\nStructure:\nStart\n→ Step 1: 初始化集合 fruits = {'apple', 'banana'} // 設定起始集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除 'pineapple'，若不存在不報錯\n→ Step 6: print(fruits) // 輸出最終集合\nEnd\n\nWe might use Decision to show if remove would error? We can include Decision: If 'banana' exists? but it's known. The user didn't ask for decision. We can just show steps.\n\nWe should produce each line with the format: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" for each step after Start. For End.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化集合 fruits = {'apple', 'banana'} // 建立初始集合\n→ Step 2: fruits.add('orange') // 新增 'orange' 至集合\n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'，若不存在會錯誤\n→ Step 5: fruits.discard('pineapple') // 嘗試移除 'pineapple'，不存在時不報錯\n→ Step 6: print(fruits) // 輸出最終集合\nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.76TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.76 TWD'"
        }
      ],
      "generated_code": "import requests\nimport tkinter as tk\nimport sys\n\ndef fetch_rate() -> float | None:\n    \"\"\"向匯率 API 發送請求，並回傳台幣匯率。失敗時回傳 None。\"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n        data = resp.json()\n        return data[\"rates\"].get(\"TWD\")\n    except Exception:\n        return None\n\ndef get_rate_string() -> str:\n    \"\"\"取得匯率字串，失敗時回傳錯誤訊息。\"\"\"\n    rate = fetch_rate()\n    if rate is not None:\n        return f\"目前美元匯率：約 {rate} TWD\"\n    return \"更新失敗，請檢查網路連線\"\n\ndef update_label(label: tk.Label) -> None:\n    \"\"\"更新 tkinter 標籤文字為最新匯率。\"\"\"\n    label.config(text=get_rate_string())\n\ndef launch_gui() -> None:\n    \"\"\"啟動 GUI，包含標籤與更新按鈕。\"\"\"\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    tk.Button(win, text=\"更新匯率\", command=lambda: update_label(label)).pack(pady=5)\n\n    win.mainloop()\n\ndef main() -> None:\n    \"\"\"主程式入口：若有 stdin 輸入則回覆匯率；否則啟動 GUI。\"\"\"\n    input_data = sys.stdin.read().strip()\n    if input_data:\n        # 若輸入中包含「更新」或「匯率」，則印出結果\n        if \"更新\" in input_data or \"匯率\" in input_data:\n            print(get_rate_string())\n        else:\n            launch_gui()\n    else:\n        launch_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line with comments. We need to include Start, End, Decision, arrow. Use virtual code, no actual code. Should cover imports, tkinter window, request to API, parse JSON, extract TWD rate, display label, button to update. Should show updating. Also handle error maybe. Provide explanation.\n\nLet's structure:\n\nStart\n\n→ Step 1: Import requests and tkinter // 依賴\n\n→ Step 2: 定義函數 fetch_rate() // 用來抓取匯率\n\n→ Decision: 是否成功取得回應? // 判斷HTTP status\n\n    Yes → Step 3: 解析 JSON 並取得 TWD 率 // 取值\n\n    No  → Step 4: 返回 '無法取得匯率' // 錯誤訊息\n\n→ Step 5: 定義函數 update_display() // 按鈕回調\n\n→ Step 6: 在 update_display() 裡呼叫 fetch_rate() 並更新 label 文字 // UI\n\n→ Step 7: 初始化 tkinter 主視窗 // 建立 GUI\n\n→ Step 8: 建立 Label 顯示匯率 // UI元件\n\n→ Step 9: 建立 Button，點擊時呼叫 update_display() // UI元件\n\n→ Step 10: 執行一次 update_display() 以顯示初始匯率 // 開始時更新\n\n→ Step 11: 呼叫 mainloop() // 進入事件循環\n\nEnd\n\nBut must include arrow lines with `→`. Use indentation for Decision.\n\nLet's produce each line with code step. Provide comment after `//`. Use \"虛擬碼步驟\" placeholders. We need to show Step numbers? In example they used \"Step 1:\" etc. We'll follow.\n\nImportant: each line must have \"虛擬碼步驟\" and comment. Eg:\n\nStart // 程式開始執行\n\n→ Step 1: Import requests, tkinter // 依賴\n\nUse `→` to indicate next step. For Decision, we use `Decision:` and indent.\n\nLet's craft.\n\nAlso show \"Yes →\" and \"No →\" inside decision.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Import requests, tkinter // 引入 HTTP 請求與 GUI 套件\n→ Step 2: Define fetch_rate() // 建立取得匯率的函式\n    → Decision: 是否成功取得 HTTP 回應? // 檢查請求是否成功\n        Yes → Step 3: 解析 JSON，提取 'TWD' 匯率 // 從回應中取出台幣匯率\n        No  → Step 4: Return 'Error: 無法取得匯率' // 失敗時回傳錯誤訊息\n→ Step 5: Define update_display() // 定義按鈕點擊時的回調函式\n    → Call fetch_rate() and store result // 取得最新匯率\n    → Update label text with result // 將結果顯示在 Label 上\n→ Step 6: Initialize tkinter 主視窗 // 建立 GUI 視窗\n→ Step 7: Create a Label widget for displaying the rate // 顯示匯率的文字框\n→ Step 8: Create a Button widget，clicking calls update_display() // 更新匯率的按鈕\n→ Step 9: Call update_display() once to show initial rate // 程式啟動時先更新一次\n→ Step 10: Run mainloop() // 啟動 tkinter 事件循環\nEnd // 程式執行結束"
    },
    {
      "title": "Top K Frequent Elements",
      "source_file": "Leetcode/leetcode347.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,2]'\nGot (Norm):      '[2,1]'\n--- (Raw) ---\nRaw Expected: '[1,2]'\nRaw Got:      '[2, 1]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\nimport heapq\n\nclass Solution:\n    def topKFrequent(self, nums, k):\n        # Count frequency of each element\n        freq = Counter(nums)\n        # Use a heap to keep the k most frequent items\n        min_heap = []\n        for num, cnt in freq.items():\n            if len(min_heap) < k:\n                heapq.heappush(min_heap, (cnt, num))\n            elif cnt > min_heap[0][0]:\n                heapq.heappop(min_heap)\n                heapq.heappush(min_heap, (cnt, num))\n        # Extract numbers from the heap\n        return [num for _, num in min_heap]\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中解析 nums 和 k。\"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not k_match:\n        raise ValueError(\"輸入格式錯誤\")\n    nums = ast.literal_eval(nums_match.group(1))\n    k = int(k_match.group(1))\n    return nums, k\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    sol = Solution()\n    result = sol.topKFrequent(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line for solving \"k most frequent elements\" problem. Provide explanation after each line. Must follow format: \"虛擬碼步驟 [space] // 解釋/說明\". Use Start, End, Decision, arrows. Let's design steps:\n\n- Start\n- Step 1: Initialize frequency map\n- Step 2: Iterate over nums, update map\n- Step 3: Initialize a min-heap of size k\n- Step 4: Iterate over map entries\n- Step 5: If heap size < k, push entry\n- Decision: Else if current freq > min freq in heap, pop and push\n- Step 6: Build result array from heap\n- End\n\nBut need to use arrows \"→\" to indicate flow. Use \"Decision:\" with Yes/No arrows. Provide each line with explanation.\n\nAlso include step to convert heap to array. Use \"→ Step 5: Build result array from heap\" etc.\n\nLet's produce.\n\nWe also may need to represent heap operations. Use generic names.\n\nImportant: We must not output actual code, just pseudo-code lines with explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立頻率映射 dictFreq // 用來記錄每個數字出現的次數  \n→ Step 2: 對 nums 中的每個數字 num 進行  \n  → dictFreq[num] ← dictFreq.get(num, 0) + 1 // 更新對應數字的頻率  \n→ Step 3: 建立最小堆 minHeap，容量為 k // 只保留頻率最高的 k 個元素  \n→ Step 4: 對 dictFreq 的每個 (num, freq) 元素進行  \n  → Decision: minHeap.size < k? // 堆還未滿 k 個元素  \n   Yes → minHeap.push((num, freq)) // 直接加入堆中  \n   No  → Decision: freq > minHeap.peek().freq? // 與堆中最小頻率比較  \n     Yes → minHeap.pop() → minHeap.push((num, freq)) // 用更高頻率的替換  \n     No  → No action // 當前元素頻率不高於堆中最小，忽略  \n→ Step 5: 建立空列表 result // 用來儲存最終答案  \n  → 對 minHeap 的每個元素 (num, _) 進行  \n    → result.append(num) // 把數字加入結果中  \n→ End // 程式執行結束，result 為返回的 k 個最頻繁元素"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[None,True,False,True,2,True,False,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[None, True, False, True, 2, True, False, 2]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\n\nclass RandomizedSet:\n    def __init__(self):\n        # dict: value -> index in values list\n        self.val_to_index = {}\n        # list of current values\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        \"\"\"Insert val if not present. O(1) average.\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"Remove val if present. O(1) average.\"\"\"\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        # Move last element to the spot of the removed element\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        # Remove last element\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"Return a random element. O(1).\"\"\"\n        return random.choice(self.values)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse input like: [\"RandomizedSet\",\"insert\",\"remove\"], [[],[1],[2]]\n    ops, args = ast.literal_eval(data)\n    results = [None]  # First operation is constructor, no return value\n    rs = RandomizedSet()\n    for i in range(1, len(ops)):\n        op = ops[i]\n        arg = args[i]\n        if op == \"insert\":\n            results.append(rs.insert(arg[0]))\n        elif op == \"remove\":\n            results.append(rs.remove(arg[0]))\n        elif op == \"getRandom\":\n            results.append(rs.getRandom())\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for RandomizedSet class operations with O(1). Use hash map and array. Each line: step + comment.\n\nLet's structure:\n\nStart\n→ Step: Initialize data structures // dict and list\nInsert: check dict; if not present add to list and dict; return true else false\nRemove: check dict; if present remove from list by swapping with last, update dict; pop; return true else false\ngetRandom: pick random index from list; return value\n\nWe need to use Decision structure.\n\nLet's produce virtual steps:\n\nStart\n→ Step 1: 初始化空列表 elements // 存放元素\n→ Step 2: 初始化空字典 indices // 元素到索引的映射\nInsert(val):\n→ Decision: 如果 val 在 indices? // 判斷是否已存在\n    No → Step 3: 将 val 添加到 elements 的末尾 // 追加\n    → Step 4: indices[val] = len(elements) - 1 // 記錄索引\n    → Step 5: 返回 true\n    Yes → Step 6: 返回 false\nRemove(val):\n→ Decision: 如果 val 在 indices? // 判斷是否存在\n    No → Step 7: 返回 false\n    Yes → Step 8: idx = indices[val] // 取得索引\n    → Step 9: last = elements[-1] // 取最後一個元素\n    → Decision: 如果 idx != len(elements)-1? // 是否不是最後一個\n        Yes → Step 10: elements[idx] = last // 覆蓋\n        → Step 11: indices[last] = idx // 更新索引\n    → Step 12: elements.pop() // 刪除最後元素\n    → Step 13: 删除 indices[val] // 從映射中移除\n    → Step 14: 返回 true\ngetRandom:\n→ Step 15: n = len(elements) // 取得長度\n→ Step 16: randomIndex = 随机数[0, n-1] // 随机選取索引\n→ Step 17: 返回 elements[randomIndex] // 返回隨機元素\n\nEnd.\n\nNeed to maintain O(1). Provide comments.\n\nLet's output exactly format. Use 虛擬碼步驟 then comment.\n\nEnsure each line begins with \"→\" except Start and End? Example shows Start line without arrow? The example shows \"Start\" then arrow for steps. We can follow. So first line \"Start // 程式開始執行\" then steps.\n\nUse arrow for each step.\n\nAlso decision lines: \"Decision: ...\"\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空列表 elements // 用於存放所有元素  \n→ Step 2: 初始化空字典 indices // 用於存放元素到索引的映射  \n\nInsert(val)  \n→ Decision: 如果 val 在 indices? // 判斷元素是否已存在  \n    No → Step 3: 把 val 添加到 elements 的末尾 // 追加元素  \n    → Step 4: indices[val] = len(elements) - 1 // 記錄新元素的索引  \n    → Step 5: 返回 true // 成功插入  \n    Yes → Step 6: 返回 false // 元素已存在，插入失敗  \n\nRemove(val)  \n→ Decision: 如果 val 在 indices? // 判斷元素是否存在  \n    No → Step 7: 返回 false // 無此元素，移除失敗  \n    Yes → Step 8: idx = indices[val] // 取得待移除元素的索引  \n    → Step 9: last = elements[-1] // 取得最後一個元素  \n    → Decision: 如果 idx != len(elements)-1? // 判斷待移除元素是否為最後一個  \n        Yes → Step 10: elements[idx] = last // 用最後一個元素覆蓋待移除位置  \n        → Step 11: indices[last] = idx // 更新最後一個元素的新索引  \n    → Step 12: elements.pop() // 刪除列表末尾（原本最後一個元素）  \n    → Step 13: 删除 indices[val] // 從字典中移除已刪除元素的映射  \n    → Step 14: 返回 true // 成功移除  \n\ngetRandom()  \n→ Step 15: n = len(elements) // 取得目前元素數量  \n→ Step 16: randomIndex = 隨機數[0, n-1] // 隨機產生索引  \n→ Step 17: 返回 elements[randomIndex] // 返回隨機選中的元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,false,true,false,false]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, null, false, true, false, false]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MagicDictionary:\n    \"\"\"字典資料結構，允許在搜尋時改一個字元匹配任何單字。\"\"\"\n\n    def __init__(self):\n        # 以集合存放所有單字，便於 O(1) 查詢\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        \"\"\"設定字典內容，dictionary 為不同單字的 list。\"\"\"\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        \"\"\"\n        若能改一個字元使 searchWord 與字典中任一單字相同，回傳 True，\n        否則回傳 False。\n        \"\"\"\n        n = len(searchWord)\n        # 若字典中無相同長度的單字，直接返回 False\n        for word in self.words:\n            if len(word) != n:\n                continue\n            # 計算差異字元個數\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\n\ndef main():\n    # 從標準輸入讀取兩行：函式名稱列表與對應參數列表\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    lines = data.splitlines()\n    if len(lines) < 2:\n        return\n\n    funcs = ast.literal_eval(lines[0].strip())\n    args_list = ast.literal_eval(lines[1].strip())\n\n    result = []\n    obj = None\n\n    for func, args in zip(funcs, args_list):\n        if func == \"MagicDictionary\":\n            obj = MagicDictionary()\n            result.append(None)  # 建構子不返回任何值\n        elif func == \"buildDict\":\n            # args 形如 [[\"hello\",\"leetcode\"]]\n            obj.buildDict(args[0])\n            result.append(None)\n        elif func == \"search\":\n            # args 形如 [\"hello\"]\n            result.append(obj.search(args[0]))\n        else:\n            result.append(None)\n\n    # 將結果轉成 LeetCode 樣式輸出：null / true / false\n    out_parts = []\n    for item in result:\n        if item is None:\n            out_parts.append(\"null\")\n        elif isinstance(item, bool):\n            out_parts.append(\"true\" if item else \"false\")\n        else:\n            out_parts.append(str(item))\n    print(\"[\" + \", \".join(out_parts) + \"]\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation per line. The requirement: start with Start, use arrows. We'll design algorithm: Build dictionary, maybe store words by length and also maybe precompute patterns with wildcard or use trie. For simplicity, algorithm: store words in a hash set; for search: for each position in searchWord, try replace with 'a'-'z' except original char, form new string, check in set; if found return true. Complexity O(n*26). That's fine. Build: set insertion. Provide virtual code.\n\nAlso need to mention that dictionary words distinct. We'll handle length mismatches quickly. Use length grouping for optimization: only try same length words.\n\nImplement pseudocode.\n\nLet's produce:\n\nStart\n→ MagicDictionary() // 初始化物件，建立空集合與長度索引\n→ buildDict(dictionary) // 建立字典\n    → Initialize empty set AllWords\n    → Initialize empty map LengthMap: length -> list\n    → For each word in dictionary:\n        → Add word to AllWords\n        → Append word to LengthMap[word.length]\n→ search(searchWord) // 判斷是否能改一字得到字典中單字\n    → If LengthMap[searchWord.length] does not exist:\n        → Return false\n    → For each position i in 0..len-1:\n        → OriginalChar = searchWord[i]\n        → For each c in 'a' to 'z':\n            → If c == OriginalChar: continue\n            → NewWord = searchWord with char at i replaced by c\n            → If NewWord in AllWords:\n                → Return true\n    → Return false\nEnd\n\nNeed to ensure each line with virtual code + explanation. Use arrow syntax. Provide indentation with tabs? Not necessary but can use spaces.\n\nWe'll use arrow \"→\" at beginning of each line after Start, except decisions maybe. For decisions we need Decision: If condition? etc. Provide nested blocks.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ MagicDictionary() // 初始化物件：建立空集合與長度索引  \n→ buildDict(dictionary) // 建立字典資料結構  \n    → Initialize empty set AllWords // 用於快速檢查完整單字  \n    → Initialize empty map LengthMap: length → list // 分組相同長度的單字  \n    → For each word in dictionary: // 逐個字插入集合與分組  \n        → Add word to AllWords // 將單字加入全集  \n        → Append word to LengthMap[word.length] // 將單字加入相同長度分組  \n→ search(searchWord) // 判斷是否可改一字得到字典中單字  \n    → Decision: 如果 LengthMap 沒有 searchWord.length? // 檢查長度是否可匹配  \n        Yes → Return false // 若無同長度單字，直接返回 false  \n    → For each position i in 0 .. searchWord.length-1: // 逐位嘗試改字  \n        → OriginalChar = searchWord[i] // 取得原始字元  \n        → For each c in 'a' to 'z': // 嘗試所有 26 個字母  \n            → Decision: 如果 c 等於 OriginalChar? // 避免不改動  \n                Yes → Continue // 跳過不改變的字母  \n            → NewWord = searchWord with char at i replaced by c // 產生新單字  \n            → Decision: 如果 NewWord 在 AllWords? // 檢查是否為字典單字  \n                Yes → Return true // 找到符合條件的單字，結束搜尋  \n    → Return false // 所有嘗試結束仍未找到，返回 false  \nEnd // 程式執行結束"
    },
    {
      "title": "24 Game",
      "source_file": "Leetcode/leetcode679.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "cards = [1,2,1,2]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpa2exb93w.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmpa2exb93w.py\", line 57, in main\n    result = judge_point_24(nums)\n             ^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpa2exb93w.py\", line 41, in judge_point_24\n    if dfs(list(perm)):\n       ^^^^^^^^^^^^^^^\n  File \"/tmp/tmpa2exb93w.py\", line 33, in dfs\n    if dfs(rest):\n       ^^^^^^^^^\n  File \"/tmp/tmpa2exb93w.py\", line 33, in dfs\n    if dfs(rest):\n       ^^^^^^^^^\n  File \"/tmp/tmpa2exb93w.py\", line 33, in dfs\n    if dfs(rest):\n       ^^^^^^^^^\n  File \"/tmp/tmpa2exb93w.py\", line 13, in dfs\n    return abs(current[0] - 24) < eps\n               ~~~~~~~~~~~^~~~\nTypeError: unsupported operand type(s) for -: 'NoneType' and 'int'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom typing import List\n\ndef judge_point_24(nums: List[float]) -> bool:\n    \"\"\"判斷給定四個數字能否透過 + - * / 及括號得到 24.\"\"\"\n    eps = 1e-6\n\n    def dfs(current: List[float]) -> bool:\n        # 只剩一個數字，檢查是否接近 24\n        if len(current) == 1:\n            return abs(current[0] - 24) < eps\n\n        # 取兩個數字做運算\n        for i in range(len(current)):\n            for j in range(len(current)):\n                if i == j:\n                    continue\n                a, b = current[i], current[j]\n                # 產生剩下的數字列表\n                rest = [current[k] for k in range(len(current)) if k != i and k != j]\n\n                # 四種運算\n                for op in (lambda x, y: x + y,\n                           lambda x, y: x - y,\n                           lambda x, y: x * y,\n                           lambda x, y: x / y if abs(y) > eps else None):\n                    if op is None:\n                        continue  # 除以零的情況\n                    res = op(a, b)\n                    rest.append(res)\n                    if dfs(rest):\n                        return True\n                    rest.pop()\n        return False\n\n    # 嘗試所有數字排列\n    from itertools import permutations\n    for perm in permutations(nums):\n        if dfs(list(perm)):\n            return True\n    return False\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中抽取列表\n    match = re.search(r'\\[([^\\]]+)\\]', data)\n    if not match:\n        nums: List[float] = []\n    else:\n        nums = ast.literal_eval('[' + match.group(1) + ']')\n\n    result = judge_point_24(nums)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for solving 24 game. Outline: permutations of numbers, recursive evaluate all binary operations and parentheses. Use backtracking to combine two numbers at a time. Check tolerance due to floating point. Provide steps. Ensure each line has virtual code and explanation. Use Start, Decision, etc. Let's produce lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 `canReach24(cards)` 以判斷是否能得到 24 // 主入口函式  \n→ Decision: 如果 `cards` 長度為 1? // 只剩一個數字  \n    Yes → Step 2: 回傳 `abs(cards[0] - 24) < ε` // 若接近 24 就成功  \n    No  → Step 3: 執行 `for each permutation of cards` // 嘗試所有數字順序  \n→ Step 4: 對於每個排列，呼叫遞迴函式 `solve(nums)` 以組合運算  \n→ Decision: `solve(nums)` 內部：  \n    ← If `nums` 只剩一個元素?  \n        → 回傳 `abs(nums[0] - 24) < ε`  \n    ← 否則  \n        → `for i` in 0..len(nums)-1  \n            → `for j` in 0..len(nums)-1, j≠i  \n                → 取兩個數字 `a = nums[i]`, `b = nums[j]`  \n                → `next_nums = nums` 去除索引 i 與 j 的元素並加入新結果  \n                → `for op in ['+','-','*','/']`  \n                    → Decision: 如果 op 為 '/' 且 b == 0?  \n                        Yes → 跳過此操作 // 避免除以零  \n                        No  → 進行 `result = apply(op, a, b)` // 計算 a op b  \n                    → 再呼叫 `solve(next_nums + [result])`  \n                    → Decision: 若遞迴回傳 True?  \n                        Yes → 返回 True // 成功  \n                    → 否則繼續迴圈  \n→ Step 5: 若所有排列及所有遞迴都未成功，返回 False // 無法達成 24  \nEnd // 程式執行結束"
    },
    {
      "title": "Non-decreasing Subsequences",
      "source_file": "Leetcode/leetcode491.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,6,7,7]",
          "expected_output": "[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]'\nGot (Norm):      '[[7,7],[4,6],[4,7,7],[6,7],[6,7,7],[4,6,7],[4,6,7,7],[4,7]]'\n--- (Raw) ---\nRaw Expected: '[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]'\nRaw Got:      '[[7, 7], [4, 6], [4, 7, 7], [6, 7], [6, 7, 7], [4, 6, 7], [4, 6, 7, 7], [4, 7]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findSubsequences(self, nums):\n        \"\"\"\n        Return all unique non‑decreasing subsequences of length at least 2.\n        \"\"\"\n        res_set = set()  # 用於儲存唯一的子序列\n\n        def backtrack(start, path):\n            # 若目前子序列已足夠長，加入結果集合\n            if len(path) >= 2:\n                res_set.add(tuple(path))\n\n            used = set()  # 本層已使用過的值，避免重複探索\n            for i in range(start, len(nums)):\n                # 只在子序列非遞減且本層未使用過相同值時才繼續\n                if (not path or nums[i] >= path[-1]) and nums[i] not in used:\n                    used.add(nums[i])\n                    path.append(nums[i])          # 擴充子序列\n                    backtrack(i + 1, path)       # 深度優先探索下一層\n                    path.pop()                   # 回溯，恢復原狀\n\n        backtrack(0, [])\n        # 把集合中的元組轉回列表形式\n        return [list(seq) for seq in res_set]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析輸入，假設格式為 \"nums = [1,2,3]\" 或僅 \"[1,2,3]\"\n    if '=' in raw_input:\n        _, nums_str = raw_input.split('=', 1)\n    else:\n        nums_str = raw_input\n    nums = ast.literal_eval(nums_str.strip())\n\n    solution = Solution()\n    result = solution.findSubsequences(nums)\n\n    # 輸出結果，保持列表列表的文字表示\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code for solution of LeetCode problem 491. Need to produce line-by-line steps with explanations. Use Start, End, Decision. Include arrow → etc. Should not output actual code. Just pseudocode steps. Must generate solution that uses backtracking to find all non-decreasing subsequences length≥2, ensuring uniqueness by using set to avoid duplicates. Provide steps: Start, input array, initialize result set, define backtrack(index, path). In backtrack: iterate i from index to n-1, if path empty or nums[i] >= last in path, add to path, if len≥2 add to result set, then recursive call on i+1, then pop. After backtrack, output result as list of lists. End. Also handle duplicates? Use set of tuples or use dictionary to avoid duplicate subsequences in same level. Provide pseudocode accordingly. Provide each line with explanation. Ensure no actual code. Use arrow format. Let's produce.\n\nWe'll produce something like:\n\nStart // 程式開始\n→ Step 1: 定義輸入 nums // 取得輸入陣列\n→ Step 2: 初始化 res 為空集合 // 存儲唯一子序列\n→ Decision: 定義遞歸函式 backtrack(start, path) // 用於探索子序列\n    → Step 3: 如果 path 長度 ≥ 2 → Add path 為元組到 res // 記錄符合條件的子序列\n    → Step 4: 對 i 從 start 到 n-1 循環\n        → Decision: 如果 path 為空或 nums[i] ≥ path[-1]? // 判斷是否可擴充\n            Yes → Step 5: path 加上 nums[i] // 添加元素\n            Yes → Step 6: backtrack(i+1, path) // 深度優先探索\n            Yes → Step 7: 從 path 移除最後元素 // 回溯\n        → No  → Next i\n→ Step 8: 呼叫 backtrack(0, 空列表) // 開始遞歸\n→ Step 9: 將 res 中的元組轉為列表列表返回 // 將集合轉為列表輸出\nEnd // 程式結束\n\nNeed to incorporate uniqueness. In pseudo we can mention using set. Also maybe use dictionary to avoid duplicates at same level. But for simplicity mention using set of tuples. Provide explanation accordingly. Ensure each line uses \"虛擬碼步驟\" with arrow. Also use \"Decision:\" lines with Yes → and No →. Provide explanation after //.\n\nMake sure to maintain required format. Let's craft final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 定義輸入 nums // 取得輸入陣列\n→ Step 2: 初始化 res 為空集合 // 用於儲存唯一的非遞減子序列\n→ Step 3: 定義遞歸函式 backtrack(start, path) // 從索引 start 開始，path 為目前的子序列\n    → Decision: path 長度 ≥ 2? // 是否已經形成合法子序列\n        Yes → Step 4: 把 path 轉成元組並加入 res // 記錄結果，元組可在集合中作唯一鍵\n        No  → 無操作\n    → Step 5: 對 i 從 start 到 nums 長度-1 進行迭代 // 探索所有剩餘位置\n        → Decision: path 為空 或 nums[i] ≥ path[-1]? // 判斷是否能保持非遞減順序\n            Yes → Step 6: path 加上 nums[i] // 暫時擴展子序列\n            Yes → Step 7: backtrack(i+1, path) // 深度優先繼續搜尋\n            Yes → Step 8: 從 path 移除最後一個元素 // 回溯，恢復原狀\n            No  → Next i // 該位置不符合條件，直接跳過\n→ Step 9: 呼叫 backtrack(0, 空列表) // 從索引 0 開始搜索\n→ Step 10: 將 res 中所有元組轉為列表形式並返回 // 最終輸出為列表列表\nEnd // 程式結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphwbhx2q1.py\", line 33, in <module>\n    words = ast.literal_eval(arrays[0])\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"apple\"]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass WordFilter:\n    def __init__(self, words):\n        # dictionary that maps (prefix, suffix) to the largest index\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            # iterate over all possible prefixes\n            for i in range(L + 1):\n                pref = word[:i]\n                # iterate over all possible suffixes\n                for j in range(L + 1):\n                    suff = word[j:]\n                    self.lookup[(pref, suff)] = weight\n\n    def f(self, prefix, suffix):\n        # return the stored index or -1 if not found\n        return self.lookup.get((prefix, suffix), -1)\n\nif __name__ == \"__main__\":\n    # read all input\n    data = sys.stdin.read().strip()\n    # find the first two JSON-like arrays in the input\n    arrays = re.findall(r'\\[.*?\\]', data, re.S)\n    if len(arrays) < 2:\n        print(-1)\n        sys.exit(0)\n\n    # parse the arrays into Python objects\n    words = ast.literal_eval(arrays[0])\n    query = ast.literal_eval(arrays[1])\n\n    if not isinstance(query, (list, tuple)) or len(query) != 2:\n        print(-1)\n        sys.exit(0)\n\n    pref, suff = query[0], query[1]\n\n    # create WordFilter instance and output the answer\n    wf = WordFilter(words)\n    print(wf.f(pref, suff))",
      "virtual_code": "Thinking...\nWe need to output virtual code, step by step. The requirement: Design a special dictionary that searches words by prefix and suffix. Implement WordFilter class with constructor and f method. We need to give virtual code steps that outline algorithm. Use Start, Decision, etc. Probably use a trie or prefix-suffix combination. We can use a combined trie where keys are suffix+ \"#\" + prefix, store max index. The algorithm: Build a trie for all words: for each word at index i, for each suffix length, combine suffix + \"#\" + prefix and insert into trie with max index. Query f by searching trie for suff + \"#\" + pref. If found return stored index else -1. Virtual code step-by-step: initialization, building trie, inserting, querying. Provide explanation after each line. Let's produce steps. Use arrow →, decisions, etc. Provide comments. Ensure no actual code. Use virtual code steps like \"Start\" etc.\n\nWe need to output each line with // explanation.\n\nLet's craft.\n\nPossible steps:\n\nStart // Start of algorithm\n→ Build data structure: Trie // Create empty trie to store combined keys\n→ For each word in words array // Iterate through words\n    → Store its index i // Record index\n    → For each possible prefix length from 0 to len(word) // iterate prefixes\n        → For each possible suffix length from 0 to len(word) // iterate suffixes\n            → Construct key = suffix + \"#\" + prefix // combine\n            → Insert key into trie with value i // store max index\n... But we can be more efficient: Actually we don't need all combinations; but for virtual code we can show simplified.\n\nThen f method: \nStart\n→ Combine suff + \"#\" + pref // key\n→ Search trie for key\n→ If found return value else -1\n\nWe can include decisions.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化 Trie 以儲存 (後綴 + \"#\" + 前綴) → key → 整數值 // 建立一棵空樹，鍵為後綴+「#」+前綴，值為最大字元索引  \n→ Decision: 是否有字串? // 檢查輸入字串是否存在  \n    Yes → Step: 為每個字串 words[i] 進行處理 // 逐一處理每個字  \n        → 取得字串 word 和其索引 i // 取得目前字與其位置  \n        → For each 預備前綴長度 p (0..len(word)) // 產生所有可能的前綴  \n            → 前綴 prefix = word[0:p] // 取前 p 個字元  \n            → For each 後綴長度 s (0..len(word)) // 產生所有可能的後綴  \n                → 後綴 suffix = word[len(word)-s:len(word)] // 取最後 s 個字元  \n                → 形成 key = suffix + \"#\" + prefix // 組合後綴、分隔符、前綴  \n                → Decision: Trie 已存在此 key? // 檢查樹中是否已有此鍵  \n                    Yes → Step: 更新值為 max(existing, i) // 若已有，取較大的索引  \n                    No  → Step: 插入 key 與值 i // 若不存在，直接插入  \n        → End For 後綴迴圈  \n        → End For 前綴迴圈  \n    → End For 字串迴圈  \n→ End // 完成字典構造  \n\n// WordFilter.f 方法  \nStart // f 方法開始執行  \n→ 形成查詢 key = suff + \"#\" + pref // 將後綴和前綴組合成鍵  \n→ Decision: Trie 中存在 key? // 在樹中搜尋此鍵  \n    Yes → Step: 回傳 key 對應的值 // 取得儲存的最大索引  \n    No  → Step: 回傳 -1 // 未找到符合條件的字  \nEnd // f 方法結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"\"()()()\"\",\"\"(())()\"\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\\' \"()()()\"\\', \\' \"(())()\"\\']'"
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"\"(a)()()\"\",\"\"(a())()\"\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\\' \"(a)()()\"\\', \\' \"(a())()\"\\']'"
        },
        {
          "example_index": 2,
          "input": "s = \")(\"",
          "expected_output": "[\"\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"\"]'\nGot (Norm):      '[\"\"\"\"]'\n--- (Raw) ---\nRaw Expected: '[\"\"]'\nRaw Got:      '[\\' \"\"\\']'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"\n        Return all possible strings by removing the minimum number of invalid parentheses.\n        \"\"\"\n        # Helper to check if a string has valid parentheses\n        def is_valid(string: str) -> bool:\n            count = 0\n            for ch in string:\n                if ch == '(':\n                    count += 1\n                elif ch == ')':\n                    count -= 1\n                    if count < 0:          # too many closing\n                        return False\n            return count == 0            # all opening matched\n\n        # BFS level by level\n        level = {s}\n        while level:\n            # Collect all valid strings in the current level\n            valid = [item for item in level if is_valid(item)]\n            if valid:\n                return valid\n\n            # Generate next level by removing one parenthesis from each string\n            next_level = set()\n            for item in level:\n                for i, ch in enumerate(item):\n                    if ch in ('(', ')'):\n                        nxt = item[:i] + item[i+1:]\n                        if nxt not in level:\n                            next_level.add(nxt)\n            level = next_level\n\n        return []\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    Parse the input string. The input may be formatted as:\n        s = \"()())()\"\n    or simply:\n        ()())()\n    or may contain surrounding quotes. This helper normalises it to a plain string.\n    \"\"\"\n    raw = raw.strip()\n    # Remove a leading assignment if present\n    if raw.lower().startswith('s'):\n        parts = raw.split('=', 1)\n        if len(parts) == 2:\n            raw = parts[1]\n    # Strip surrounding quotes if any\n    if (raw.startswith('\"') and raw.endswith('\"')) or (raw.startswith(\"'\") and raw.endswith(\"'\")):\n        raw = raw[1:-1]\n    return raw\n\nif __name__ == \"__main__\":\n    # Read entire input\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    sol = Solution()\n    result = sol.removeInvalidParentheses(s)\n    print(result)",
      "virtual_code": "Thinking...\nThe user wants virtual code for the problem: remove minimum parentheses to make string valid, return all unique results.\n\nWe need to produce step-by-step pseudocode, line by line, with explanations, using Start, Decision, Yes →, No → etc.\n\nWe should outline algorithm: BFS approach to generate all states, remove one parenthesis each step until valid. Or DFS with counting removals. We need minimal removal. We'll propose BFS.\n\nPseudo:\n\nStart\n→ Step 1: 初始化 queue with original string\n→ Step 2: 初始化 visited set with original string\n→ Step 3: 定義答案 list\n→ Step 4: 定義 flag found=false\n→ Step 5: BFS loop while queue not empty\n    → Decision: If found and current depth > minDepth? skip? We'll just proceed until we find level.\n\nSimpler: BFS level by level until we find valid strings, then stop.\n\nWe'll implement BFS: while queue not empty, for each string in queue size: if isValid(str) then add to answer; found=true. After processing level, if found break. Else generate next strings by removing each parenthesis char at each position not visited.\n\nReturn answer.\n\nWe'll include isValid function: iterate char, count bal. if char '(' inc, ')' dec, if bal<0 return false; at end bal==0.\n\nUnique: visited set ensures uniqueness.\n\nReturn list.\n\nWe need virtual code lines with explanation. We'll produce each step. Ensure we use arrow arrow and decisions. We'll break loops.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: queue ← [s] // 將原始字串放入 BFS 隊列  \n→ Step 2: visited ← {s} // 記錄已處理過的字串，避免重複  \n→ Step 3: answer ← [] // 儲存最小刪除後得到的有效字串  \n→ Step 4: found ← False // 標記是否已找到有效字串  \n→ Decision: queue 是否為空? // 判斷是否還有待處理字串  \n    Yes → End // 若沒有待處理字串，結束程式  \n    No → → Step 5: levelSize ← length(queue) // 本層待處理字串數目  \n\n    → Step 6: for i = 1 to levelSize do // 逐一處理本層字串  \n        → Step 7: cur ← pop(queue) // 取出目前字串  \n        → Decision: isValid(cur)？ // 檢查字串是否有效  \n            Yes → → Step 8: append cur to answer // 加入答案集合  \n            → Step 9: found ← True // 標記已找到有效字串  \n            No → → Step 10: if not found then // 若未找到有效字串，繼續產生子字串  \n                → Step 11: for pos = 0 to length(cur)-1 do // 逐個位置嘗試刪除  \n                    → Decision: cur[pos] 是否為 '(' 或 ')'？ // 僅對括號進行刪除  \n                        Yes → → Step 12: next ← cur[:pos] + cur[pos+1:] // 刪除該括號  \n                        → Decision: next 是否在 visited？  \n                            Yes → // 已處理過，跳過  \n                            No → → Step 13: append next to queue // 加入下一層待處理  \n                                → Step 14: visited ← visited ∪ {next} // 標記已處理  \n                        No → // 非括號，跳過  \n        → // 迴圈結束  \n\n    → Decision: found？ // 本層是否已找到有效字串？  \n        Yes → → Step 15: break // 跳出 BFS 迴圈，停止進一步刪除  \n        No → → Step 16: continue // 繼續處理下一層  \n\n→ Step 17: return answer // 回傳所有最小刪除後的有效字串集合  \nEnd // 程式執行結束  \n\n// isValid(string str) 函式  \n→ Step 18: balance ← 0 // 平衡計數  \n→ Step 19: for each ch in str do  \n    → Decision: ch == '('？  \n        Yes → → Step 20: balance ← balance + 1  \n        No → → Decision: ch == ')'？  \n            Yes → → Step 21: balance ← balance - 1  \n                → Decision: balance < 0？  \n                    Yes → → Step 22: return False // 右括號過多  \n                    No → // 繼續  \n            No → // 非括號，忽略  \n→ Step 23: return balance == 0 // 只有平衡為 0 時才有效"
    },
    {
      "title": "My Calendar III",
      "source_file": "Leetcode/leetcode732.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpw16ksvvw.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmpw16ksvvw.py\", line 36, in main\n    args = json.loads(lists[1])\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 4 (char 3)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\nimport bisect\n\nclass MyCalendarThree:\n    \"\"\"\n    與題目描述相同，使用差分 + 緩存方式計算最大重疊次數。\n    \"\"\"\n    def __init__(self):\n        # 儲存時間點與差分，使用列表以便 bisect 插入\n        self.timeline = []\n\n    def book(self, start, end):\n        # 插入開始與結束時的差分\n        bisect.insort(self.timeline, (start, 1))\n        bisect.insort(self.timeline, (end, -1))\n\n        # 計算目前所有事件的最大重疊數\n        active = 0\n        max_active = 0\n        for time, delta in self.timeline:\n            active += delta\n            if active > max_active:\n                max_active = active\n        return max_active\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中擷取兩個列表\n    lists = re.findall(r'\\[.*?\\]', data, re.DOTALL)\n    ops = json.loads(lists[0])\n    args = json.loads(lists[1])\n\n    results = []\n    calendar = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MyCalendarThree\":\n            calendar = MyCalendarThree()\n            results.append(None)          # constructor 對應 null\n        elif op == \"book\":\n            results.append(calendar.book(arg[0], arg[1]))\n\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for MyCalendarThree with book method. Should be virtual code. We need line by line with explanation.\n\nWe need to implement a segment tree or difference array? For k-booking problem typical solution uses line sweep or segment tree. We'll produce pseudocode: Use a tree map storing events difference counts, and maintain max. Simpler: Use a map to store difference array. On book, add +1 at start, -1 at end, then iterate sorted keys to find max prefix sum.\n\nThus virtual code lines: Start, initialize map, etc.\n\nWe need to maintain data structure for incremental updates.\n\nPseudo:\n\nClass MyCalendarThree\n    Start\n    → Initialize: eventsDiff ← empty sorted map // key time, value diff\n    → maxOverlap ← 0 // maximum k found\n\nMethod book(start, end)\n    → Add +1 to eventsDiff at start\n    → Add -1 to eventsDiff at end\n    → current ← 0\n    → Iterate through eventsDiff in sorted order\n        → current ← current + diff\n        → If current > maxOverlap\n            → maxOverlap ← current\n    → Return maxOverlap\n\nWe need each line with explanation.\n\nAlso include End for class? But we might not need End. But follow format. Provide Start, End for class constructor? Let's produce:\n\nStart MyCalendarThree // Class initialization\n→ eventsDiff ← empty sorted map // store time -> diff\n→ maxOverlap ← 0 // store max k\n\nMethod book\n→ eventsDiff[start] ← eventsDiff.get(start, 0) + 1 // add start diff\n→ eventsDiff[end] ← eventsDiff.get(end, 0) - 1 // add end diff\n→ current ← 0 // running sum\n→ For each time in sorted(eventsDiff.keys())\n    → current ← current + eventsDiff[time]\n    → If current > maxOverlap\n        → maxOverlap ← current\n→ Return maxOverlap\n\nEnd MyCalendarThree // class end\n\nBut we need to ensure each line includes virtual code step plus explanation. Use arrows. Provide each line.\n\nAlso we need \"Start\" line maybe for constructor and for book method. Use 'Start MyCalendarThree' for class. Then 'End MyCalendarThree'.\n\nLet's produce lines.\n...done thinking.\n\nStart MyCalendarThree // 類別初始化，準備記錄時間差與最大重疊次數  \n→ eventsDiff ← 空的排序映射 // key: 時間點，value: 時間差 (+1 或 -1)  \n→ maxOverlap ← 0 // 目前已知的最大 k-booking  \n\nMethod book(start, end) // 新增一段 [start, end)  \n→ eventsDiff[start] ← eventsDiff.get(start, 0) + 1 // 在開始時間加 +1  \n→ eventsDiff[end] ← eventsDiff.get(end, 0) - 1 // 在結束時間加 -1  \n→ current ← 0 // 目前累積的重疊次數  \n→ For each time in eventsDiff.keys() sorted ascending  \n    → current ← current + eventsDiff[time] // 更新累積重疊  \n    → If current > maxOverlap  \n        → maxOverlap ← current // 更新全局最大值  \n→ Return maxOverlap // 回傳目前最高的 k-booking  \n\nEnd MyCalendarThree // 類別結束，程式結束執行"
    },
    {
      "title": "Word Ladder",
      "source_file": "Leetcode/leetcode127.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphqs15v0h.py\", line 35, in main\n    data = json.loads(json_str)\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmphqs15v0h.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmphqs15v0h.py\", line 41, in main\n    key, val = part.split('=', 1)\n    ^^^^^^^^\nValueError: not enough values to unpack (expected 2, got 1)"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpngr8394q.py\", line 35, in main\n    data = json.loads(json_str)\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpngr8394q.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmpngr8394q.py\", line 41, in main\n    key, val = part.split('=', 1)\n    ^^^^^^^^\nValueError: not enough values to unpack (expected 2, got 1)"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: list[str]) -> int:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return 0\n\n        queue = deque([(beginWord, 1)])  # (current word, current depth)\n\n        while queue:\n            word, depth = queue.popleft()\n            if word == endWord:\n                return depth\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c == word[i]:\n                        continue\n                    new_word = word[:i] + c + word[i + 1 :]\n                    if new_word in wordSet:\n                        wordSet.remove(new_word)\n                        queue.append((new_word, depth + 1))\n        return 0\n\ndef main() -> None:\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # Transform input into JSON format\n    # Replace '=' with ':' and wrap the whole string with braces\n    json_str = '{' + raw.replace('=', ':') + '}'\n    try:\n        data = json.loads(json_str)\n    except json.JSONDecodeError:\n        # Fallback: simple manual parsing if JSON fails\n        data = {}\n        parts = raw.split(',')\n        for part in parts:\n            key, val = part.split('=', 1)\n            key = key.strip()\n            val = val.strip()\n            if val.startswith('['):\n                # list of strings\n                val = val.strip('[]')\n                val = [s.strip().strip('\"') for s in val.split(',')]\n            else:\n                val = val.strip('\"')\n            data[key] = val\n\n    beginWord = data.get('beginWord', '')\n    endWord = data.get('endWord', '')\n    wordList = data.get('wordList', [])\n\n    sol = Solution()\n    result = sol.ladderLength(beginWord, endWord, wordList)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm that finds length of shortest transformation sequence between beginWord and endWord using wordList. Essentially Word Ladder problem. Use BFS. Steps: create set from wordList, check endWord in set else return 0. Use queue for BFS starting from beginWord, distance = 1. While queue not empty: pop current word, for each position replace with a-z generate neighbors, if neighbor == endWord return distance+1. If neighbor in wordList set, add to queue and remove from set to avoid revisiting. After loop, return 0. Also need to mention that beginWord not necessarily in wordList.\n\nWe'll produce virtual code line by line with comments. Use Start, Decision, etc. Provide explanation after each line.\n\nLet's produce stepwise.\n\nStart\n→ Step 1: 初始化詞典集合 dictSet = Set(wordList) // 將字典轉成集合，方便 O(1) 查找\n→ Decision: 若 endWord 不在 dictSet? // 檢查目標詞是否存在\n    Yes → Return 0 // 若不存在，無法轉換\n→ Step 2: 初始化 BFS 佇列 queue = [(beginWord, 1)] // 每項包含詞與目前步數\n→ Step 3: 循環 while queue 非空 // 探索每層\n    → Step 4: 從 queue 取出 frontWord, level // 取得當前詞與距離\n    → Decision: 若 frontWord == endWord? // 到達終點\n        Yes → Return level // 返回最短距離\n    → Step 5: 逐個字母位置 i 於 frontWord\n        → Step 6: 逐個字母 c 從 'a' 到 'z'\n            → Step 7: 若 c 與 frontWord[i] 相同則繼續 // 跳過不變更\n            → Step 8: 生成新詞 newWord = 前半 + c + 後半 // 替換字母\n            → Decision: 若 newWord 在 dictSet? // 是否有效且未訪問\n                Yes →\n                    → Step 9: 加入 queue (newWord, level+1) // 訪問新詞\n                    → Step 10: 從 dictSet 移除 newWord // 防止重訪\n                No → // 無效詞，忽略\n    → End of inner loops\n→ End of while\n→ Return 0 // 無路徑可達\n\nNeed to format with arrows etc. Use \"Decision:\" for if. For loops use indent lines with arrow but still \"Step\". Use \"Yes →\" \"No →\". Provide explanation comments.\n\nLet's craft.\n\nAlso include \"Start\" and \"End\".\n\nMake sure each line has virtual code step then space then // explanation. Use spaces between arrow and next. Provide proper indent? In example, indent lines under Decision block.\n\nWe'll write:\n\nStart // 程式開始執行\n→ Step 1: dictSet = Set(wordList) // 建立可快速查詢的字典集合\n→ Decision: 是否 endWord 在 dictSet? // 判斷目標詞是否存在於字典\n    Yes → Return 0 // 若不存在，立即回傳 0\n→ Step 2: queue = [(beginWord, 1)] // 初始化 BFS 佇列，存放 (詞, 層級)\n→ Step 3: while queue 非空 // 進行層序搜尋\n    → Step 4: current, level = queue.pop_front() // 取出最先加入的詞與其層級\n    → Decision: current == endWord? // 是否已到達終點\n        Yes → Return level // 回傳最短步數\n    → Step 5: for i in 0..len(current)-1 // 逐字母位置\n        → Step 6: for c in 'a'..'z' // 逐個字母替換\n            → Decision: c == current[i]? // 若不變則跳過\n                Yes → Continue\n            → Step 7: newWord = current[:i] + c + current[i+1:] // 生成新詞\n            → Decision: newWord 在 dictSet? // 判斷是否為有效且未訪問的詞\n                Yes →\n                    → Step 8: queue.append((newWord, level+1)) // 加入佇列\n                    → Step 9: dictSet.remove(newWord) // 移除以免重訪\n                No → // 不符合條件，忽略\n    → End of inner loops\n→ End while\n→ Return 0 // 無法到達終點，回傳 0\nEnd // 程式結束\n\nMake sure each line ends with comment.\n\nAlso, after Decision lines we need sub-steps. In example they used indentation with tab? We'll follow same style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: dictSet = Set(wordList) // 將字典轉成集合，方便 O(1) 查找  \n→ Decision: 是否 endWord 在 dictSet? // 判斷目標詞是否存在於字典  \n    Yes → Return 0 // 若不存在，立即回傳 0  \n→ Step 2: queue = [(beginWord, 1)] // 初始化 BFS 佇列，存放 (詞, 層級)  \n→ Step 3: while queue 非空 // 進行層序搜尋  \n    → Step 4: current, level = queue.pop_front() // 取出最先加入的詞與其層級  \n    → Decision: current == endWord? // 是否已到達終點  \n        Yes → Return level // 回傳最短步數  \n    → Step 5: for i in 0..len(current)-1 // 逐字母位置  \n        → Step 6: for c in 'a'..'z' // 逐個字母替換  \n            → Decision: c == current[i]? // 若不變則跳過  \n                Yes → Continue  \n            → Step 7: newWord = current[:i] + c + current[i+1:] // 生成新詞  \n            → Decision: newWord 在 dictSet? // 判斷是否為有效且未訪問的詞  \n                Yes →  \n                    → Step 8: queue.append((newWord, level+1)) // 加入佇列  \n                    → Step 9: dictSet.remove(newWord) // 移除以免重訪  \n                No → // 不符合條件，忽略  \n    → End of inner loops  \n→ End while  \n→ Return 0 // 無法到達終點，回傳 0  \nEnd // 程式結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[None,2,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[None, 2, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立每個數字對應的索引清單\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機選取 target 的索引，等機率\n        return random.choice(self.indices[target])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，格式為 ('[\"Solution\", ...]', [[[...]], ...])\n    ops, args = ast.literal_eval(data)\n\n    outputs = []\n    sol = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # arg 是 [[1, 2, 3, 3, 3]]\n            sol = Solution(arg[0])\n            outputs.append(None)          # 建構子沒有回傳值\n        else:  # \"pick\"\n            # arg 是 [target]\n            outputs.append(sol.pick(arg[0]))\n\n    print(outputs)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code in lines with comments. Use Start, End, Decision. The algorithm: store mapping from number to list of indices or use reservoir sampling during pick. Simpler: store map. But requirement: random pick index with equal probability. We'll implement constructor storing array and maybe mapping of number to list of indices. In pick, get list and random pick.\n\nWe need to provide virtual code line by line with arrow arrows. Use \"Start\" then \"→ Step\" etc. Provide explanation after //.\n\nLet's produce:\n\nStart // start program\n→ Step 1: Define class Solution with attributes nums, indexMap // store array and map\n→ Step 2: Constructor Solution(nums) // initialize\n    → Step 2a: Assign this.nums = nums // keep reference\n    → Step 2b: Initialize indexMap as empty map // number -> list of indices\n    → Step 2c: For each index i in nums:\n        → Decision: if nums[i] not in indexMap?\n            Yes → Step 2c1: Create new empty list for nums[i]\n            No → (nothing)\n        → Step 2c2: Append i to indexMap[nums[i]] // record index\n→ Step 3: Define method pick(target)\n    → Step 3a: Retrieve list = indexMap[target] // indices where target occurs\n    → Step 3b: Generate random integer r between 0 and len(list)-1 // uniformly\n    → Step 3c: Return list[r] // selected index\nEnd // end of code\n\nWe need to use \"→\" and \"Decision:\" and \"Yes →\" etc. Provide comments after //.\n\nMake sure each line ends with comment. Provide arrow for nested decisions.\n\nLet's format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution，包含屬性 nums 與 indexMap // 用於存放原陣列與每個數字對應的索引清單  \n→ Step 2: 構造函式 Solution(nums) // 初始化物件  \n  → Step 2a: 把傳入的 nums 賦值給 this.nums // 保留陣列參考  \n  → Step 2b: 初始化 indexMap 為空字典 // key: 數字, value: 索引清單  \n  → Step 2c: 遍歷 nums 的每個索引 i  \n    → Decision: 若 nums[i] 尚未存在於 indexMap? // 檢查是否已建立清單  \n     Yes → Step 2c1: 在 indexMap[nums[i]] 建立空清單 // 新增鍵值對  \n     No  → Step 2c2: // 既有清單可直接使用  \n      Step 2c2: 將 i 加入 indexMap[nums[i]] 的清單 // 記錄索引  \n→ Step 3: 定義方法 pick(target) // 隨機選取 target 的索引  \n  → Step 3a: 取出 list = indexMap[target] // 取得所有符合 target 的索引集合  \n  → Step 3b: 產生隨機整數 r，範圍為 0 到 len(list)-1 // 等機率選取索引  \n  → Step 3c: 回傳 list[r] // 返回隨機選中的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\ndef find_lus_length(strs):\n    \"\"\"\n    找出陣列中「最長不常見子序列」的長度。\n    若所有字串皆重複，則回傳 -1。\n    \"\"\"\n    freq = Counter(strs)          # 先計算每個字串的出現次數\n    max_len = -1\n    for s in strs:\n        # 只考慮出現次數為 1 的字串\n        if freq[s] == 1 and len(s) > max_len:\n            max_len = len(s)\n    return max_len\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：預期為類似 '[\"aba\",\"cdc\",\"eae\"]' 的 JSON 字串\n    try:\n        strs = json.loads(data)\n    except json.JSONDecodeError:\n        # 若無法以 JSON 解析，使用 eval 做最後的容錯處理\n        strs = eval(data)\n\n    result = find_lus_length(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps explaining algorithm to solve longest uncommon subsequence length. Classic solution: If there are duplicates, answer -1. Else answer length of longest string. Explanation: Because any string that is unique in array cannot be subsequence of any other of same length? Actually longest uncommon subsequence is longest string if all strings unique, else -1. So algorithm: Count frequencies, find max length of string with freq 1; if none return -1.\n\nWe need to produce step-by-step virtual code with arrows, decisions, etc. Provide one line per step. Use Start, End, Decision, etc. Use arrow →. Provide comment after space. Provide explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字串頻率表 freq ← 空字典 // 用於統計每個字串出現次數  \n→ Step 2: 對於每個字串 s 於 strs 中  \n    → Decision: s 是否已在 freq 中? // 判斷字串是否已被計數  \n        Yes → freq[s] ← freq[s] + 1 // 已存在，頻率加一  \n        No  → freq[s] ← 1 // 第一次出現，設定頻率為一  \n→ Step 3: maxLen ← -1 // 初始化最長不常見子序列長度為 -1  \n→ Step 4: 對於每個字串 s 於 strs 中  \n    → Decision: freq[s] 等於 1? // 只考慮唯一出現的字串  \n        Yes → Decision: len(s) 大於 maxLen? // 是否比目前已知最長長度更長  \n            Yes → maxLen ← len(s) // 更新最長長度  \n            No  → // 仍保持 maxLen  \n        No  → // 非唯一字串不考慮  \n→ Step 5: 回傳 maxLen // 若無唯一字串，maxLen 仍為 -1；否則為最大長度  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> list[str]:\n        \"\"\"\n        找出 DNA 序列中所有長度為 10 的子字串，且至少出現兩次。\n        \"\"\"\n        seen = set()       # 已經看到過的 10 字長子字串\n        repeated = set()   # 重複出現的 10 字長子字串\n        n = len(s)\n        if n < 10:\n            return []\n\n        # 遍歷所有可能的起始位置\n        for i in range(n - 9):  # i <= n-10\n            seq = s[i:i + 10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n\n        return list(repeated)\n\ndef _extract_string_from_input(raw: str) -> str:\n    \"\"\"\n    從輸入字串中提取 DNA 序列。預期輸入格式類似於\n    \"s = 'ACGTACGTAC'\" 或只包含 DNA 序列本身。\n    \"\"\"\n    # 先嘗試找單引號中的內容\n    first_quote = raw.find(\"'\")\n    if first_quote != -1:\n        second_quote = raw.find(\"'\", first_quote + 1)\n        if second_quote != -1:\n            return raw[first_quote + 1:second_quote]\n    # 若找不到單引號，嘗試雙引號\n    first_quote = raw.find('\"')\n    if first_quote != -1:\n        second_quote = raw.find('\"', first_quote + 1)\n        if second_quote != -1:\n            return raw[first_quote + 1:second_quote]\n    # 最後直接去除空白並返回整個字串\n    return raw.strip()\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    dna_seq = _extract_string_from_input(raw_input)\n\n    solution = Solution()\n    result = solution.findRepeatedDnaSequences(dna_seq)\n\n    # 輸出 JSON 格式的列表，以符合範例輸出的風格\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to generate virtual code that finds all 10-letter-long substrings that occur more than once in string s. Provide step by step, each line with virtual code step and explanation. Use Start, End, Decision, etc.\n\nWe need to produce steps like: Start, read input string s, create dictionary/ hash map, iterate over i from 0 to len(s)-10, extract substring, update count, after loop collect substrings with count>1, output list. Also handle case s shorter than 10.\n\nLet's produce a clear flow with decision points. Use arrows. Each line: \"虛擬碼步驟 // 解釋\". Use 1-based maybe. Use → for flow.\n\nMake sure to use \"Decision:\" for condition.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 DNA 字串 s // 從使用者或輸入中取得整個 DNA 序列  \n→ Decision: s 長度 < 10? // 檢查是否足夠長以容納 10 個字母  \n Yes → Step 2: 回傳空集合 // 直接回傳空列表，因為無法得到 10 字長子字串  \n No → Step 3: 初始化 空字典 counts // 用來記錄每個 10 字長子字串的出現次數  \n→ Step 4: 設定 i = 0 // 開始索引  \n→ Decision: i ≤ len(s) - 10? // 判斷是否還有足夠長度的子字串可提取  \n Yes → Step 5: 取得 substring = s[i : i+10] // 取出從 i 開始的 10 個字母  \n  → Decision: substring 是否已在 counts?  \n   Yes → Step 6: counts[substring] = counts[substring] + 1 // 出現次數加 1  \n   No  → Step 7: counts[substring] = 1 // 初始化計數為 1  \n  → Step 8: i = i + 1 // 移動到下一個索引  \n  → Decision: i ≤ len(s) - 10? // 再次判斷是否繼續循環  \n   Yes → 轉回 Step 5  \n   No  → Step 9: 初始化 空集合 result // 用來收集重複出現的 10 字長子字串  \n→ Step 10: 對每個 key, value 在 counts 中  \n  → Decision: value > 1? // 判斷是否出現超過一次  \n   Yes → Step 11: 把 key 加入 result // 把重複子字串加入結果集合  \n   No  → 轉到下一個 key  \n→ Step 12: 回傳 result // 將所有重複 10 字長子字串返回  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])          # copy current permutation\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # swap\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # backtrack\n\n        backtrack(0)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入中的列表提取出來\n    start = data.find('[')\n    if start != -1:\n        nums_str = data[start:]\n        nums = ast.literal_eval(nums_str)\n    else:\n        nums = []\n\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step for generating all permutations of array of distinct integers. Use recursion/backtracking. Each step line must be \"虛擬碼步驟 // 解釋\". Use arrow →, decisions.\n\nLet's produce:\n\nStart\n→ Step 1: 定義結果列表 res // 用於存放所有排列\n→ Step 2: 呼叫 backtrack(目前排列 curr, 剩餘元素 remain) // 從空排列開始\n→ Decision: 如果 remain 為空? // 若無剩餘元素\n    Yes → Step 3: 把 curr 複製並加入 res // 完整排列加入結果\n    No  → For each num in remain:\n        → Step 4: 添加 num 至 curr\n        → Step 5: 產生新的 remain2 = remain 去除 num\n        → Step 6: 呼叫 backtrack(curr, remain2)\n        → Step 7: 移除 curr 末尾 num // 回溯\nEnd\n\nAlso need to show how backtrack initial call: backtrack([], nums)\n\nLet's incorporate. Use proper indentation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義結果列表 res // 用於儲存所有排列  \n→ Step 2: 呼叫 backtrack(目前排列 curr = [], 剩餘元素 remain = nums) // 從空排列開始  \n→ Decision: 如果 remain 為空? // 判斷是否已經選完所有數字  \n  Yes → Step 3: 把 curr 的拷貝加入 res // 完整排列加入結果  \n  No  → Step 4: 循環遍歷 remain 中的每個 num  \n    → Step 5: 把 num 加入 curr // 選擇這個數字  \n    → Step 6: 產生 remain2 = remain 去除 num // 新的剩餘列表  \n    → Step 7: 呼叫 backtrack(curr, remain2) // 進一步遞迴  \n    → Step 8: 從 curr 中移除最後一個元素 // 回溯到上一狀態  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []                       # 存放所有元素\n        self.idx_map = collections.defaultdict(set)  # value -> set(indices)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入元素，若第一次出現回傳 True，否則 False\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"移除一個 val，若存在回傳 True，否則 False\"\"\"\n        if not self.idx_map[val]:\n            return False\n        # 取任意一個索引\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        # 如果要刪除的不是最後一個，將最後一個覆蓋到它的位置\n        if remove_idx != len(self.data) - 1:\n            self.data[remove_idx] = last_val\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(len(self.data) - 1)\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機回傳一個元素\"\"\"\n        return random.choice(self.data)\n\ndef parse_input():\n    \"\"\"解析標準輸入，返回操作列表與參數列表\"\"\"\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return [], []\n    ops = ast.literal_eval(data[0].strip())\n    args = ast.literal_eval(data[1].strip()) if len(data) > 1 else []\n    return ops, args\n\ndef result_to_str(res):\n    \"\"\"將結果轉換為 LeetCode 風格的字串\"\"\"\n    out = []\n    for x in res:\n        if x is None:\n            out.append(\"null\")\n        elif isinstance(x, bool):\n            out.append(\"true\" if x else \"false\")\n        else:\n            out.append(str(x))\n    return \"[\" + \", \".join(out) + \"]\"\n\ndef main():\n    ops, args = parse_input()\n    obj = None\n    results = []\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            results.append(None)\n        elif op == \"insert\":\n            results.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            results.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            results.append(obj.getRandom())\n    print(result_to_str(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations, following format.\n\nWe need to describe algorithm for RandomizedCollection. We can use arrays (vector) and hashmap mapping val to set of indices. Inserting: push_back to list, add index to map. Return true if first time. Removing: if not present return false. Get an index to remove: get any index from map[val] set. Replace with last element in list if not same. Update mappings accordingly. Pop back. Return true. getRandom: choose random index.\n\nWe need to produce virtual code steps. Use Start, Decision, etc.\n\nLet's produce high-level pseudo algorithm with steps. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe must produce in Traditional Chinese. Use arrows. Use \"Start\", \"End\". Provide explanation.\n\nLet's create:\n\nStart // initialize empty structure\n\n→ Initialize list: empty array // store elements\n→ Initialize map: value->set of indices // track positions\n\nNow define insert:\n\n→ Function insert(val) // inserting element\n→ Append val to list // add to end\n→ Add new index to map[val] // record position\n→ Decision: if map[val] size == 1? // first occurrence?\n    Yes → Return true // element not present before\n    No  → Return false // duplicate\n\nBut we need average O(1). This works.\n\nRemove:\n\n→ Function remove(val) // remove one occurrence\n→ Decision: if map[val] empty? // element absent?\n    Yes → Return false // nothing to remove\n    No  → Continue\n→ Get an index i from map[val] // arbitrary\n→ Remove i from map[val] // delete occurrence\n→ Get last element lastVal = list.back()\n→ Decision: if i != list.size()-1? // removing not last\n    Yes → Replace list[i] = lastVal // move last to i\n    → Remove i from map[lastVal] // remove old index\n    → Add i to map[lastVal] // add new index\n    No  → // removing last element, nothing to move\n→ Pop list.back() // remove last element\n→ Return true\n\ngetRandom:\n\n→ Function getRandom()\n→ Generate random index r in [0, list.size()-1]\n→ Return list[r]\n\nEnd\n\nMake sure to annotate each step with comment.\n\nWe need to ensure each line has format: \"虛擬碼步驟 // 解釋\".\n\nAlso we may need to include Start and End markers.\n\nLet's produce each step.\n\nWe might want to separate initialization and functions as separate blocks.\n\nUse indentation for decision branches.\n\nOk produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化 list 為空陣列 // 存放所有元素  \n→ 初始化 map 為空映射 (value → 設) // 記錄每個值所在索引  \n\n// ----------------------------  \n// Insert 功能  \n// ----------------------------  \n→ Function insert(val) // 進行插入操作  \n→ list.append(val) // 把 val 放到陣列尾部  \n→ map[val].add(list.size() - 1) // 在 map 中記錄新索引  \n→ Decision: 若 map[val] 的大小 == 1? // 這是第一次出現 val?  \n    Yes → Return true // 未出現過，返回 true  \n    No  → Return false // 已存在，返回 false  \n\n// ----------------------------  \n// Remove 功能  \n// ----------------------------  \n→ Function remove(val) // 進行刪除操作  \n→ Decision: 若 map[val] 為空? // val 不在集合中?  \n    Yes → Return false // 沒有可刪除的元素  \n    No  → Continue  \n→ 取任意 index i 從 map[val] 取得 // 任取一個位置  \n→ map[val].remove(i) // 從映射中移除該位置  \n→ let lastVal = list.back() // 取陣列最後一個元素  \n→ Decision: 若 i != list.size() - 1? // 被刪除元素不是最後一個?  \n    Yes → list[i] = lastVal // 把最後一個元素覆蓋到 i  \n    → map[lastVal].remove(list.size() - 1) // 移除 lastVal 原來的最後位置  \n    → map[lastVal].add(i) // 加入 lastVal 新的索引 i  \n    No  → // 被刪除元素就是最後一個，無需覆蓋  \n→ list.pop_back() // 刪除陣列最後一個位置  \n→ Return true // 成功刪除一個 val  \n\n// ----------------------------  \n// getRandom 功能  \n// ----------------------------  \n→ Function getRandom() // 取得隨機元素  \n→ let idx = random integer in [0, list.size() - 1] // 隨機索引  \n→ Return list[idx] // 回傳對應元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppxfr05tv.py\", line 47, in <module>\n    params = parse_input(data)\n             ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppxfr05tv.py\", line 41, in parse_input\n    return eval(expr, {}, {})\n           ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]}\n     ^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppb2_s6ku.py\", line 47, in <module>\n    params = parse_input(data)\n             ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppb2_s6ku.py\", line 41, in parse_input\n    return eval(expr, {}, {})\n           ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]}\n     ^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list) -> int:\n        \"\"\"Return the minimum number of mutations to transform start into end using\n        only genes present in bank. If impossible, return -1.\"\"\"\n        # 若終點基因不在 bank，直接無法達成\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n\n            # 逐位產生所有可能的一步變異\n            for i in range(len(current)):\n                for g in genes:\n                    if g == current[i]:\n                        continue\n                    mutation = current[:i] + g + current[i + 1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n        # 走完所有可達基因仍未找到終點\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中解析 startGene, endGene 與 bank。\"\"\"\n    # 把輸入視作 Python 字典表達式，並使用 eval 進行解析\n    # 這裡假設輸入格式類似：\n    # startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n    # 因此把它包成 { ... } 之後直接 eval\n    expr = \"{\" + data.strip() + \"}\"\n    return eval(expr, {}, {})\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit(0)\n    params = parse_input(data)\n    start_gene = params[\"startGene\"]\n    end_gene = params[\"endGene\"]\n    bank = params[\"bank\"]\n    solution = Solution()\n    result = solution.minMutation(start_gene, end_gene, bank)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for BFS mutation minimal steps problem. Provide each line with explanation. No actual code. Use Start, End, Decision etc.\n\nLet's produce steps: Convert bank to set, check if end in bank else -1, BFS queue, visited set, count levels, for each gene generate neighbors by changing each char to other 3, if neighbor in bank and not visited, add queue, track steps. If find end, return steps. If finish queue, return -1. Also handle case start==end -> 0. Also handle empty bank maybe.\n\nWe'll produce pseudo code lines. Use arrow to show flow. We'll use indent for decisions. Use \"→\" arrow. Provide each line explanation comment. Use \"Start\" \"End\". Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義字母集 alphabet = {'A', 'C', 'G', 'T'} // DNA 可能的字元集合  \n→ Step 2: 將 bank 轉成 set bankSet // 方便 O(1) 查找  \n→ Decision: 如果 endGene 不在 bankSet? // 先判斷終點是否有效  \n    Yes → Step 3: 回傳 -1 // 無法達到終點  \n    No → Step 4: 如果 startGene 等於 endGene? // 起點即終點  \n        Yes → Step 5: 回傳 0 // 無需變異  \n        No  → Step 6: 初始化 queue 為 [(startGene, 0)] // 佇列存放 (基因, 變異步數)  \n            → Step 7: 初始化 visited 為 {startGene} // 記錄已探索基因  \n            → Decision: 佇列不為空? // BFS 循環  \n                Yes → Step 8: 取出 frontGene, steps = queue.pop() // 取得目前基因與已變異步數  \n                    → Step 9: 對每個位置 i 從 0 到 7  \n                        → Step 10: 對每個 letter 在 alphabet  \n                            → Decision: letter 與 frontGene[i] 不同? // 確保真的變異  \n                                Yes → Step 11: 新基因 newGene = frontGene 的第 i 位改為 letter  \n                                    → Decision: newGene 在 bankSet 且 newGene 未在 visited? // 有效且未訪問  \n                                        Yes → Step 12: 如果 newGene 等於 endGene? // 到達終點  \n                                            Yes → Step 13: 回傳 steps + 1 // 回傳最小變異步數  \n                                            No  → Step 14: 加入 queue (newGene, steps + 1) // 進一步探索  \n                                                → Step 15: 將 newGene 加入 visited  \n                                        No  → // 跳過此新基因  \n                                    No  → // 跳過此新基因  \n                        → // 位置 i 迴圈結束  \n                    → // 位置迴圈結束  \n                No  → Step 16: 回傳 -1 // 佇列空，無法到達終點  \nEnd // 程式執行結束"
    },
    {
      "title": "Merge k Sorted Lists",
      "source_file": "Leetcode/leetcode23.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
          "expected_output": "[1,1,2,3,4,4,5,6]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0f1e2l4k.py\", line 80, in <module>\n    merged_head = solution.mergeKLists(list_nodes)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp0f1e2l4k.py\", line 36, in mergeKLists\n    heapq.heappush(heap, (node.next.val, idx, node.next))\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\n# 定義單向鏈表節點\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists):\n        \"\"\"\n        Merge k sorted linked lists using a min-heap.\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if not lists:\n            return None\n\n        dummy = ListNode(0)\n        tail = dummy\n        heap = []\n\n        # 將每個列表的頭節點加入堆中\n        for idx, node in enumerate(lists):\n            if node:\n                heapq.heappush(heap, (node.val, idx, node))\n\n        # 按照最小值彈出節點並將其後續節點加入堆\n        while heap:\n            _, _, node = heapq.heappop(heap)\n            tail.next = node\n            tail = node\n            if node.next:\n                heapq.heappush(heap, (node.next.val, idx, node.next))\n\n        return dummy.next\n\ndef build_linked_list(values):\n    \"\"\"將值列表轉換為單向鏈表，返回頭節點\"\"\"\n    dummy = ListNode()\n    current = dummy\n    for v in values:\n        current.next = ListNode(v)\n        current = current.next\n    return dummy.next\n\ndef linked_list_to_list(head):\n    \"\"\"將單向鏈表轉換為值列表\"\"\"\n    result = []\n    current = head\n    while current:\n        result.append(current.val)\n        current = current.next\n    return result\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read().strip()\n\n    # 若輸入以 \"lists =\" 開頭，去掉前綴\n    if raw_input.startswith(\"lists\"):\n        raw_input = raw_input.split(\"=\", 1)[1].strip()\n\n    # 解析輸入成 Python 對象，若為空則視為 []\n    if raw_input:\n        try:\n            lists_data = ast.literal_eval(raw_input)\n        except Exception:\n            lists_data = []\n    else:\n        lists_data = []\n\n    # 轉換為 ListNode 對象列表\n    list_nodes = [build_linked_list(sublist) if sublist else None for sublist in lists_data]\n\n    # 合併\n    solution = Solution()\n    merged_head = solution.mergeKLists(list_nodes)\n\n    # 轉換回值列表並輸出\n    merged_list = linked_list_to_list(merged_head)\n    print(merged_list)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for merging k sorted linked lists into one sorted linked list. Provide virtual code lines with comments, using arrows and decision structures. Should be step-by-step. Use virtual steps like Start, etc. Provide each line as \"Step\" with arrow. Must not output real code. Each line must have \"虛擬碼步驟\" and comment. Use Chinese. Provide explanation after space.\n\nWe need to think algorithm: Use min-heap or priority queue to pick smallest head among lists. Or pairwise merge. Provide generic algorithm. We can produce steps: Initialize min-heap with first node of each list; create dummy head; while heap not empty: pop min node; append to result; if popped node has next, push that next node into heap; end; return dummy.next.\n\nLet's produce pseudocode.\n\nUse steps: Start, Step 1: Initialize min-heap, etc.\n\nNeed decision steps? The algorithm may involve condition like \"If list head is null skip\".\n\nLet's produce lines with arrow: \"→ Step 1: Initialize min-heap H\" etc. Provide comment.\n\nLet's format like:\n\nStart // 程式開始執行\n→ Step 1: 建立空的最小堆 H // 用來儲存每個列表目前最小的節點\n→ Step 2: 對於每個 linked-list l in lists\n    → Decision: 如果 l 不為空? // 檢查列表是否非空\n        Yes → Step 3: 插入 l 的頭節點到 H // 把每個非空列表的頭節點放入堆中\n        No  → Step 4: 跳過該列表 // 空列表不做處理\n...\n\nBut we cannot indent lines? In the example they used indentation for nested decisions. Use same style.\n\nLet's produce steps accordingly. Use \"Decision:\" lines for if.\n\nMake sure each line has \"虛擬碼步驟\" and comment after space. Use arrow arrow.\n\nAlso End // 程式執行結束\n\nWe need to ensure each line ends with comment. No actual code. Use virtual code like \"Step X: ...\" but we must maintain arrow.\n\nWe must produce step-by-step. Let's produce around 15 lines.\n\nLet's craft.\n\nStart\n→ Step 1: 建立空的最小堆 H // 用來按節點值排序\n→ Step 2: 建立 dummy head node dummy // 作為結果鏈表的前置節點\n→ Step 3: 設 current = dummy // 指向結果鏈表的當前節點\n\n→ Decision: 對於每個 linked-list l in lists\n    Yes → Decision: 如果 l.head 不為空?\n        Yes → Step 4: 將 l.head 插入 H // 把非空列表的第一個節點加入堆\n        No  → Step 5: 跳過此 l // 空列表直接跳過\n    No  → // 已處理所有列表\n\n→ Decision: 如果 H 不為空?\n    Yes → Step 6: 從 H 中取出節點 node // 取出目前最小的節點\n    No  → Step 7: 進入結束流程 // 堆已空，合併完成\n\n→ Step 7: current.next = node // 把取出的節點連接到結果鏈表\n→ Step 8: current = node // 移動 current 到新加入的節點\n→ Decision: 如果 node.next 不為空?\n    Yes → Step 9: 將 node.next 插入 H // 把該節點的後續節點加入堆\n    No  → // 此節點已是其列表的最後節點\n\n→ Decision: 重複 Step 6-9 直到 H 為空 // 持續取出最小節點並合併\n→ Step 10: Return dummy.next // 回傳合併後的排序鏈表\n\nEnd\n\nBut we need to maintain consistent formatting. Use \"Decision:\" lines for if. Indentation for nested steps.\n\nIn example, they used:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nSo we need to indent nested lines with spaces. For our lines, we may use 4 spaces indent for nested.\n\nLet's produce final output. Ensure each line has arrow or start, and comment. Provide only pseudocode, no actual code.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的最小堆 H // 用來按節點值排序  \n→ Step 2: 建立 dummy head node dummy // 作為結果鏈表的前置節點  \n→ Step 3: 設 current = dummy // 指向結果鏈表的當前節點  \n\n→ Decision: 對於每個 linked-list l in lists  \n    Yes → Decision: 如果 l.head 不為空?  \n        Yes → Step 4: 將 l.head 插入 H // 把非空列表的第一個節點加入堆  \n        No  → Step 5: 跳過此 l // 空列表直接跳過  \n    No  → // 已處理所有列表  \n\n→ Decision: 如果 H 不為空?  \n    Yes → Step 6: 從 H 中取出節點 node // 取出目前最小的節點  \n    No  → Step 7: 進入結束流程 // 堆已空，合併完成  \n\n→ Step 7: current.next = node // 把取出的節點連接到結果鏈表  \n→ Step 8: current = node // 移動 current 到新加入的節點  \n→ Decision: 如果 node.next 不為空?  \n    Yes → Step 9: 將 node.next 插入 H // 把該節點的後續節點加入堆  \n    No  → // 此節點已是其列表的最後節點  \n\n→ Decision: 重複 Step 6-9 直到 H 為空 // 持續取出最小節點並合併  \n→ Step 10: Return dummy.next // 回傳合併後的排序鏈表  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (store negatives)\n        self.large = []  # min-heap\n\n    def addNum(self, num):\n        heapq.heappush(self.small, -num)\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self):\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # Wrap the two lists into a single JSON array for parsing\n    data = json.loads('[' + raw_input + ']')\n    operations = data[0]\n    arguments = data[1]\n\n    results = []\n    mf = None\n    for op, arg in zip(operations, arguments):\n        if op == \"MedianFinder\":\n            mf = MedianFinder()\n            results.append(None)\n        elif op == \"addNum\":\n            mf.addNum(arg[0])\n            results.append(None)\n        elif op == \"findMedian\":\n            results.append(mf.findMedian())\n\n    # Convert results to LeetCode-style output with 'null' for None\n    output = '['\n    output += ', '.join('null' if r is None else str(r) for r in results)\n    output += ']'\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MedianFinder class with addNum and findMedian. The code uses two heaps approach. Steps: Start, initialize two heaps (max-heap left, min-heap right). addNum: push to left or right depending. Rebalance. findMedian: if odd, return top of left. else average.\n\nWe need to produce virtual code lines with arrows etc. Let's format each line.\n\nAlso include comments after space. Need each line \"虛擬碼步驟 // 解釋\". Provide start, end, decisions. Use arrow arrow. Let's produce steps.\n\nWe'll include decisions: if left size > right size+1, rebalance, etc. Use typical algorithm.\n\nWe should show initialization: Start, → Step 1: Initialize two heaps // left max-heap, right min-heap\n\nStep 2: addNum procedure: // input num\n\n→ Decision: If left empty or num <= left.top? // choose heap\n\nYes → Insert into left\n\nNo → Insert into right\n\n→ Rebalance: If left.size > right.size + 1? // left too big\n\nYes → Move top of left to right\n\nNo  → Decision: If right.size > left.size? // right too big\n\nYes → Move top of right to left\n\nNo → Nothing\n\nfindMedian:\n\n→ Decision: If left.size == right.size? // even\n\nYes → Return (left.top + right.top)/2\n\nNo  → Return left.top // left larger\n\nEnd\n\nLet's ensure each line has \"虛擬碼步驟 // 解釋\". Use \"→\" arrow at each step.\n\nMake sure to include \"Start\" and \"End\".\n\nNow produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化左堆 (最大堆) 與右堆 (最小堆) // 用來分別存儲較小與較大的半數元素  \n→ Step 2: 定義 addNum(num) 方法 // 接收新數字並插入堆中  \n→     Decision: 若左堆為空或 num <= 左堆頂? // 判斷應放入哪個堆  \n→         Yes → Insert num into 左堆 // 新數字比左堆最大值小或等，放入左堆  \n→         No  → Insert num into 右堆 // 新數字比左堆最大值大，放入右堆  \n→     Decision: 若 左堆大小 > 右堆大小 + 1? // 左堆過大需要平衡  \n→         Yes → Move 左堆頂元素到 右堆 // 將左堆最大值搬到右堆  \n→         No  → Decision: 若 右堆大小 > 左堆大小? // 右堆過大需要平衡  \n→             Yes → Move 右堆頂元素到 左堆 // 將右堆最小值搬到左堆  \n→             No  → // 平衡完畢，無需其他操作  \n→ Step 3: 定義 findMedian() 方法 // 回傳目前所有數字的中位數  \n→     Decision: 若 左堆大小 == 右堆大小? // 數量為偶數  \n→         Yes → Return (左堆頂 + 右堆頂) / 2.0 // 兩中間值的平均  \n→         No  → Return 左堆頂 // 左堆多一個，直接取最大值  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7_x34ylo.py\", line 64, in <module>\n    main()\n  File \"/tmp/tmp7_x34ylo.py\", line 57, in main\n    intervals, newInterval = parse_input(raw)\n                             ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7_x34ylo.py\", line 41, in parse_input\n    intervals = eval(lists[0])\n                ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpez_kkqxo.py\", line 64, in <module>\n    main()\n  File \"/tmp/tmpez_kkqxo.py\", line 57, in main\n    intervals, newInterval = parse_input(raw)\n                             ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpez_kkqxo.py\", line 41, in parse_input\n    intervals = eval(lists[0])\n                ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # 1. 先加入不會重疊且在 newInterval 前面的區間\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # 2. 合併所有與 newInterval 重疊的區間\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        result.append(newInterval)\n\n        # 3. 加入剩下的區間\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入文字中抽取 intervals 與 newInterval。\n    支援形如:\n        intervals = [[1,3],[6,9]], newInterval = [2,5]\n    或\n        [[1,3],[6,9]]\n        [2,5]\n    \"\"\"\n    # 先找所有方括號內的表達式\n    lists = re.findall(r'\\[.*?\\]', data, flags=re.S)\n    if len(lists) >= 2:\n        intervals = eval(lists[0])\n        newInterval = eval(lists[1])\n        return intervals, newInterval\n\n    # 若無法直接抽取，嘗試按行讀取\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        intervals = eval(lines[0].strip())\n        newInterval = eval(lines[1].strip())\n        return intervals, newInterval\n\n    # 仍無法解析時回傳空值\n    return [], []\n\ndef main():\n    raw = sys.stdin.read()\n    intervals, newInterval = parse_input(raw)\n\n    sol = Solution()\n    result = sol.insert(intervals, newInterval)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line. The problem: insert new interval into sorted list, merging overlaps.\n\nWe need to output virtual code steps with comments.\n\nUse arrow →, Decision: etc.\n\nWe should start with Start.\n\nWe need steps: initialize result list, iterate through intervals, add those ending before newInterval.start, then merge overlaps, then add remaining after newInterval.end.\n\nLet's produce lines accordingly.\n\nWe need to use format: virtual step + space + // explanation\n\nWe should include arrows and decisions.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 定義 result 為空列表 // 用來儲存最終的間隔集合\n→ Step 2: 定義 i = 0 // 用來遍歷 intervals\n→ Decision: i < intervals.length? // 判斷是否還有間隔未處理\n    Yes → Decision: intervals[i].end < newInterval.start? // 判斷當前間隔是否完全在新間隔之前\n        Yes → Step 3: result.append(intervals[i]) // 將不會重疊的前面區間加入結果\n              → Step 4: i += 1 // 移到下一個間隔\n              → Go back to Decision: i < intervals.length?\n        No  → Decision: intervals[i].start <= newInterval.end? // 判斷當前間隔是否與新間隔重疊\n            Yes → Step 5: newInterval.start = min(newInterval.start, intervals[i].start) // 更新新間隔的起點\n                  → Step 6: newInterval.end = max(newInterval.end, intervals[i].end) // 更新新間隔的終點\n                  → Step 7: i += 1 // 移到下一個間隔\n                  → Go back to Decision: i < intervals.length?\n            No  → Step 8: result.append(newInterval) // 將合併後的新間隔加入結果\n                  → Step 9: i = intervals.length // 跳出循環，後續不再處理\n    No  → Step 10: // 已處理完所有原始間隔\n→ Decision: newInterval 尚未加入? // 檢查是否還沒有把新間隔加入\n    Yes → Step 11: result.append(newInterval) // 加入新間隔\n    No  → // 已經加入\n→ Step 12: 返回 result // 回傳最終結果\nEnd // 程式結束\n\nBut we need to use proper virtual code formatting: \"Step 1:\" etc. We can add arrows for decisions. The arrow syntax: \"→ Decision:\" lines, with nested Yes→ and No→ lines.\n\nWe must ensure each line ends with comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← [] // 用來儲存最終的間隔集合  \n→ Step 2: i ← 0 // 用來遍歷 intervals  \n→ Decision: i < intervals.length? // 判斷是否還有間隔未處理  \n  Yes → Decision: intervals[i].end < newInterval.start? // 當前區間是否完全在新區間之前  \n   Yes → Step 3: result.append(intervals[i]) // 將不會重疊的前面區間加入結果  \n    → Step 4: i ← i + 1 // 移到下一個區間  \n    → Go back to Decision: i < intervals.length?  \n   No → Decision: intervals[i].start <= newInterval.end? // 當前區間是否與新區間重疊  \n    Yes → Step 5: newInterval.start ← min(newInterval.start, intervals[i].start) // 更新新區間的起點  \n     → Step 6: newInterval.end ← max(newInterval.end, intervals[i].end) // 更新新區間的終點  \n     → Step 7: i ← i + 1 // 移到下一個區間  \n     → Go back to Decision: i < intervals.length?  \n    No → Step 8: result.append(newInterval) // 將合併後的新區間加入結果  \n     → Step 9: i ← intervals.length // 跳出循環，後續不再處理  \n  No → Step 10: // 已處理完所有原始區間  \n→ Decision: newInterval 尚未加入? // 檢查是否還沒有把新區間加入  \n  Yes → Step 11: result.append(newInterval) // 加入新區間  \n  No → // 已經加入  \n→ Step 12: return result // 回傳最終結果  \nEnd // 程式結束"
    },
    {
      "title": "Substring with Concatenation of All Words",
      "source_file": "Leetcode/leetcode30.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,9]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[0,9]'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "expected_output": "[]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[]'\nRaw Got:      ''"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[6,9,12]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[6,9,12]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findSubstring(self, s, words):\n        \"\"\"\n        Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once.\n        \"\"\"\n        if not s or not words:\n            return []\n\n        word_len = len(words[0])          # length of each word\n        word_count = len(words)           # number of words\n        total_len = word_len * word_count # length of the concatenated substring\n\n        # If s is shorter than the total concatenated length, no possible result\n        if len(s) < total_len:\n            return []\n\n        # Frequency map of words\n        target = Counter(words)\n\n        result = []\n\n        # We slide over each possible starting position modulo word_len\n        for offset in range(word_len):\n            left = offset\n            right = offset\n            window = Counter()\n            count = 0  # number of words matched in current window\n\n            while right + word_len <= len(s):\n                # Take a word from the right side\n                word = s[right:right + word_len]\n                right += word_len\n\n                # If it is part of words list, add to window\n                if word in target:\n                    window[word] += 1\n                    count += 1\n\n                    # If window contains more of this word than needed, shrink from left\n                    while window[word] > target[word]:\n                        left_word = s[left:left + word_len]\n                        window[left_word] -= 1\n                        left += word_len\n                        count -= 1\n\n                    # If window has exactly all words, record the start index\n                    if count == word_count:\n                        result.append(left)\n                        # Move left to look for next possible window\n                        left_word = s[left:left + word_len]\n                        window[left_word] -= 1\n                        left += word_len\n                        count -= 1\n                else:\n                    # Word not in words, reset window\n                    window.clear()\n                    count = 0\n                    left = right\n\n        return result\n\ndef main():\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Convert input like: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n    # into a Python dictionary {'s': ..., 'words': [...]}\n    # Replace assignments with JSON-style keys\n    data = data.replace('s =', '\"s\":').replace('words =', '\"words\":')\n    data = '{' + data + '}'\n    try:\n        input_dict = ast.literal_eval(data)\n    except Exception:\n        # If parsing fails, exit silently\n        return\n\n    s = input_dict.get('s', '')\n    words = input_dict.get('words', [])\n\n    sol = Solution()\n    res = sol.findSubstring(s, words)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with comments. The problem: find start indices where substring is concatenation of all words of equal length. Standard sliding window with word counts. Let's produce steps: Start, compute word length, total length, build frequency map, loop i from 0 to s.length - totalLen. For each i, check using inner loop over words positions, extract substring, count. Use map to compare. Complexity.\n\nLet's output virtual code lines with arrow etc. Use \"→\" for steps. Use \"Decision:\" lines. Provide explanation comments.\n\nWe'll avoid actual code; just steps.\n\nLet's produce maybe 30 lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 wordLen ← words[0].length // 取得每個單字的長度  \n→ Step 2: 設定 totalLen ← wordLen * words.length // 需要檢查的子字串總長  \n→ Step 3: 建立 mapWordCount ← 空字典 // 存放每個單字出現的頻率  \n→ Step 4: 為每個 word 在 words 裡，更新 mapWordCount[word] ← mapWordCount.getOrDefault(word, 0) + 1 // 統計單字頻率  \n→ Decision: 若 s.length < totalLen? // s 不能包含任何符合條件的子字串  \n    Yes → Step 5: Return 空陣列 // 沒有可能的起點  \n    No  → Step 6: 初始化 result ← 空陣列 // 儲存所有符合條件的起點  \n→ Step 7: 從 i = 0 到 s.length - totalLen 執行迴圈 // 嘗試每個可能的起點  \n    → Step 8: 建立 currentCount ← 空字典 // 存放此窗口中單字的頻率  \n    → Step 9: 為 j = 0 到 words.length - 1 執行子迴圈 // 逐個提取單字  \n        → Step 10: startIndex ← i + j * wordLen // 子字串的起始位置  \n        → Step 11: endIndex ← startIndex + wordLen // 子字串的結束位置  \n        → Step 12: word ← s.substring(startIndex, endIndex) // 取出當前單字  \n        → Decision: 若 word 不在 mapWordCount? // 不是合法的單字  \n            Yes → Step 13: 跳過此 i，執行下一個起點  \n            No  → Step 14: currentCount[word] ← currentCount.getOrDefault(word, 0) + 1 // 更新頻率  \n    → Step 15: Decision: 若 currentCount 與 mapWordCount 完全相同? // 判斷是否為合法排列  \n        Yes → Step 16: result.add(i) // 將起點加入結果  \n        No  → Step 17: 不做任何事  \n→ Step 18: Return result // 回傳所有起點  \nEnd // 程式執行結束"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5ou2imbm.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmp5ou2imbm.py\", line 29, in main\n    methods, args_list = json.loads(data)\n                         ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 76 (char 75)"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value  # move to the end (most recent)\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)  # remove least recently used\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse input as a JSON array: [methods, args]\n    methods, args_list = json.loads(data)\n    outputs = [None]  # first call (LRUCache) has no return value\n    cache = None\n    for method, args in zip(methods[1:], args_list[1:]):\n        if method == \"LRUCache\":\n            cache = LRUCache(*args)\n            outputs.append(None)\n        elif method == \"put\":\n            cache.put(*args)\n            outputs.append(None)\n        elif method == \"get\":\n            result = cache.get(*args)\n            outputs.append(result)\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Virtual code for LRUCache design with O(1). Use hash map + doubly linked list. Steps: Initialize capacity, map, head/tail. get: if key not in map return -1; else move node to front, return value. put: if key exists update value and move to front; else create node, insert front; add to map; if size > capacity, remove tail's prev node (LRU), delete from map. End.\n\nWe need to use \"Start\", \"End\", \"Decision:\" etc. Each line has virtual code and // explanation. Use arrow →. We need to include decisions, loops? We need to show operations.\n\nLet's produce lines:\n\nStart\n→ Step 1: Initialize LRUCache(capacity) // Store capacity, create empty hashmap and dummy head/tail nodes\n→ Step 2: Set head.next = tail, tail.prev = head // Prepare empty double-linked list\n→ Decision: If key exists in map? // For get\n    Yes → Step 3: Move node to head // Update recency\n    No  → Step 4: Return -1 // Key missing\n→ End get\n→ Decision: If key exists in map? // For put\n    Yes → Step 5: Update node.value\n    No  → Step 6: Create new node\n    No → Step 7: Insert new node after head\n    No → Step 8: Add to hashmap\n→ Decision: If size > capacity? // Evict\n    Yes → Step 9: Remove tail.prev node\n    Yes → Step 10: Delete node.key from hashmap\n→ End put\nEnd\n\nBut need to maintain correct sequence. Provide more detailed.\n\nLet's produce each step as a line with arrow and explanation.\n\nUse \"Start\" then \"→\" lines.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: LRUCache(capacity) // 初始化 LRUCache，存儲容量\n→ Step 2: map = empty hash map // 用於 O(1) 查找\n→ Step 3: head = new Node() ; tail = new Node() // 雙向鏈表的哨兵節點\n→ Step 4: head.next = tail ; tail.prev = head // 初始化空鏈表\n\nFor get:\n→ Decision: 如果 key 在 map 中? // 判斷 key 是否存在\n    Yes → Step 5: node = map[key] // 取得節點\n    Yes → Step 6: Move node to head // 把節點移到最近使用位置\n    Yes → Step 7: Return node.value // 返回值\n    No  → Step 8: Return -1 // 不存在\n\nFor put:\n→ Decision: 如果 key 在 map 中? // 判斷是否已有此 key\n    Yes → Step 9: node = map[key]\n    Yes → Step 10: node.value = value // 更新值\n    Yes → Step 11: Move node to head // 更新最近使用\n    No  → Step 12: node = new Node(key, value) // 創建節點\n    No  → Step 13: Insert node after head // 插入鏈表\n    No  → Step 14: map[key] = node // 加入哈希表\n    No  → Step 15: size += 1 // 記錄大小\n\n→ Decision: 如果 size > capacity? // 檢查是否超載\n    Yes → Step 16: lru = tail.prev // 最舊節點\n    Yes → Step 17: Remove lru from list // 從鏈表移除\n    Yes → Step 18: Delete map[lru.key] // 從哈希表移除\n    Yes → Step 19: size -= 1 // 更新大小\n\nEnd // 程式執行結束\n\nWe need \"End\" for each method? The spec might not require method-specific End, only overall End. But we can show End for get and put.\n\nLet's incorporate \"End get\" and \"End put\" lines.\n\nAdd \"End get // get 方法執行結束\" and \"End put // put 方法執行結束\"\n\nLet's craft.\n\nEnsure we use virtual code arrow and comments.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: LRUCache(capacity) // 初始化 LRUCache，存儲容量\n→ Step 2: map = empty hash map // 用於 O(1) 查找 key\n→ Step 3: head = new Node() ; tail = new Node() // 雙向鏈表的哨兵節點\n→ Step 4: head.next = tail ; tail.prev = head // 初始化空鏈表\n\n// ---------- get 方法 ----------\n→ Decision: 如果 key 在 map 中? // 判斷 key 是否存在\n    Yes → Step 5: node = map[key] // 取得對應節點\n    Yes → Step 6: Remove node from its current position // 從鏈表中移除節點\n    Yes → Step 7: Insert node after head // 把節點插入到最近使用位置\n    Yes → Step 8: Return node.value // 回傳值\n    No  → Step 9: Return -1 // 若不存在則回傳 -1\n→ End get // get 方法執行結束\n\n// ---------- put 方法 ----------\n→ Decision: 如果 key 在 map 中? // 判斷 key 是否已存在\n    Yes → Step 10: node = map[key] // 取得節點\n    Yes → Step 11: node.value = value // 更新值\n    Yes → Step 12: Remove node from its current position // 從鏈表中移除節點\n    Yes → Step 13: Insert node after head // 把節點插入到最近使用位置\n    No  → Step 14: node = new Node(key, value) // 創建新節點\n    No  → Step 15: Insert node after head // 將新節點插入鏈表\n    No  → Step 16: map[key] = node // 加入哈希表\n    No  → Step 17: size += 1 // 記錄當前大小\n\n→ Decision: 如果 size > capacity? // 檢查是否超過容量\n    Yes → Step 18: lru = tail.prev // 最舊節點\n    Yes → Step 19: Remove lru from its current position // 從鏈表中移除最舊節點\n    Yes → Step 20: Delete map[lru.key] // 從哈希表移除該 key\n    Yes → Step 21: size -= 1 // 更新大小\n→ End put // put 方法執行結束\n\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Design Circular Queue",
      "source_file": "Leetcode/leetcode622.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"Rear\", \"isFull\", \"deQueue\", \"enQueue\", \"Rear\"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 3, true, true, true, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,true,true,false,3,true,true,true,4]'\nGot (Norm):      '[None,True,True,True,False,3,True,True,True,4]'\n--- (Raw) ---\nRaw Expected: '[null, true, true, true, false, 3, true, true, true, 4]'\nRaw Got:      '[None, True, True, True, False, 3, True, True, True, 4]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularQueue:\n    def __init__(self, k: int):\n        self.queue = [0] * k      # 固定長度陣列\n        self.head = 0             # 指向隊列頭\n        self.tail = -1            # 指向隊列尾，初始為 -1 表示空\n        self.size = k             # 容量\n        self.count = 0            # 當前元素數量\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.tail = (self.tail + 1) % self.size\n        self.queue[self.tail] = value\n        self.count += 1\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.head = (self.head + 1) % self.size\n        self.count -= 1\n        return True\n\n    def Front(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.tail]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.size\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])          # 解析操作名稱列表\n    args = json.loads(data[1])         # 解析每個操作對應的參數列表\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyCircularQueue\":\n            obj = MyCircularQueue(arg[0])\n            results.append(None)           # 建構子不回傳值\n        elif op == \"enQueue\":\n            results.append(obj.enQueue(arg[0]))\n        elif op == \"deQueue\":\n            results.append(obj.deQueue())\n        elif op == \"Front\":\n            results.append(obj.Front())\n        elif op == \"Rear\":\n            results.append(obj.Rear())\n        elif op == \"isEmpty\":\n            results.append(obj.isEmpty())\n        elif op == \"isFull\":\n            results.append(obj.isFull())\n        else:\n            # 若有未知操作，回傳 None\n            results.append(None)\n\n    print(results)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step by step with explanations, not actual code. The user wants design of circular queue implementation. Provide steps: initialization, enqueue, dequeue, front, rear, isEmpty, isFull. Use virtual code with arrows, decisions.\n\nWe need to output each line with \"虛擬碼步驟 // 解釋/說明\". Must be in Traditional Chinese. Use arrow →. Use Start, End. Use Decision lines.\n\nLet's create algorithm: Use array of size k, head, tail, count. For circular, head points to first element, tail points to last element? We can use front index and rear index, and count or use head and size. Many designs. Provide steps for each method.\n\nWe should output pseudo-code in a flowchart-like style: For each method, start with \"Start\". For initialization: assign array, head=0, tail=-1, count=0.\n\nThen enQueue: if full return false; else: tail = (tail+1)%k; array[tail]=value; count++; return true.\n\ndeQueue: if empty return false; else: head = (head+1)%k; count--; return true.\n\nFront: if empty return -1 else return array[head].\n\nRear: if empty return -1 else return array[tail].\n\nisEmpty: return count==0.\n\nisFull: return count==k.\n\nWe need to output virtual code lines for each method maybe grouped. Since we want step-by-step pseudo-code, we can present each method's algorithm.\n\nWe need to keep the format: each line with virtual code and comment.\n\nWe'll produce a block of virtual code like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 MyCircularQueue(k) // 建立固定大小的陣列\n→ Step 2: 設定 head = 0 // 指向陣列起始\n→ Step 3: 設定 tail = -1 // 未插入元素前的尾指標\n→ Step 4: 設定 count = 0 // 現有元素個數\nEnd // 初始化完成\n\nThen for enQueue, deQueue, Front, Rear, isEmpty, isFull.\n\nWe should maintain flow: For each method, Start, then Decision or steps, then End.\n\nAlso mention using modulo operation for wrap-around.\n\nLet's write in Traditional Chinese. Use proper indentation: Use spaces before Decision lines maybe but not required.\n\nEnsure each line ends with // comment.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 MyCircularQueue(k) // 建立固定大小為 k 的陣列 arr\n→ Step 2: 設定 head = 0 // 指向隊列頭位置\n→ Step 3: 設定 tail = -1 // 指向隊列尾位置，初始為 -1 表示空\n→ Step 4: 設定 count = 0 // 追蹤目前佔用的元素數量\nEnd // 初始化完成\n\nStart // enQueue(value) // 插入元素\n→ Decision: 如果 count == k? // 判斷隊列是否已滿\n    Yes → Step 1: 回傳 false // 若滿則插入失敗\n    No  → Step 2: tail = (tail + 1) mod k // 將尾指標向後移動並環繞\n        → Step 3: arr[tail] = value // 將值存入新尾位置\n        → Step 4: count = count + 1 // 元素數量加一\n        → Step 5: 回傳 true // 插入成功\nEnd // enQueue 結束\n\nStart // deQueue() // 刪除元素\n→ Decision: 如果 count == 0? // 判斷隊列是否為空\n    Yes → Step 1: 回傳 false // 若空則刪除失敗\n    No  → Step 2: head = (head + 1) mod k // 將頭指標向後移動並環繞\n        → Step 3: count = count - 1 // 元素數量減一\n        → Step 4: 回傳 true // 刪除成功\nEnd // deQueue 結束\n\nStart // Front() // 取得隊列首項\n→ Decision: 如果 count == 0? // 判斷隊列是否為空\n    Yes → Step 1: 回傳 -1 // 空時回傳 -1\n    No  → Step 2: 回傳 arr[head] // 回傳頭位置的值\nEnd // Front 結束\n\nStart // Rear() // 取得隊列尾項\n→ Decision: 如果 count == 0? // 判斷隊列是否為空\n    Yes → Step 1: 回傳 -1 // 空時回傳 -1\n    No  → Step 2: 回傳 arr[tail] // 回傳尾位置的值\nEnd // Rear 結束\n\nStart // isEmpty() // 檢查隊列是否為空\n→ Step 1: 回傳 (count == 0) // 直接以計數判斷\nEnd // isEmpty 結束\n\nStart // isFull() // 檢查隊列是否已滿\n→ Step 1: 回傳 (count == k) // 直接以計數判斷\nEnd // isFull 結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\nimport re\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []  # list of [l, r), non‑overlapping, sorted by l\n\n    def addRange(self, left, right):\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:  # overlap\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left, right):\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        l, r = self.ranges[i - 1]\n        return l <= left and right <= r\n\n    def removeRange(self, left, right):\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    outputs = []\n    rm = None\n    for line in lines:\n        if line.startswith('RangeModule'):\n            rm = RangeModule()\n            outputs.append('null')\n        elif line.startswith('addRange'):\n            m = re.search(r'addRange\\(([^,]+),\\s*([^)]+)\\)', line)\n            left, right = int(m.group(1)), int(m.group(2))\n            rm.addRange(left, right)\n            outputs.append('null')\n        elif line.startswith('removeRange'):\n            m = re.search(r'removeRange\\(([^,]+),\\s*([^)]+)\\)', line)\n            left, right = int(m.group(1)), int(m.group(2))\n            rm.removeRange(left, right)\n            outputs.append('null')\n        elif line.startswith('queryRange'):\n            m = re.search(r'queryRange\\(([^,]+),\\s*([^)]+)\\)', line)\n            left, right = int(m.group(1)), int(m.group(2))\n            ans = rm.queryRange(left, right)\n            outputs.append('true' if ans else 'false')\n    print('[' + ', '.join(outputs) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for designing RangeModule data structure with operations addRange, queryRange, removeRange. Use steps and decisions. No real code. Provide line by line with comments. Use Start, End. Each line: 虛擬碼步驟 + space + // explanation.\n\nWe need to outline algorithm: Use an ordered structure like balanced BST storing non-overlapping intervals. We'll use list of intervals sorted. For each operation, find overlapping segments. For add: merge. For query: check full coverage. For remove: split intervals.\n\nWe need to produce pseudocode lines. Should show high-level algorithm. Not actual code. Should use decisions. Let's produce steps:\n\nStart\n→ Step 1: Initialize an empty list of intervals // store non-overlapping intervals sorted\n→ Step 2: Define helper FindLeftIndex(left) // binary search to find first interval with end >= left\n→ Step 3: Define helper FindRightIndex(right) // binary search to find first interval with start > right\nThen operations:\nAddRange\n→ Step 4: AddRange(left,right):\n    → Step 5: Find idxStart = FindLeftIndex(left)\n    → Step 6: Find idxEnd = FindRightIndex(right)\n    → Decision: If idxStart < idxEnd? // overlapping intervals exist\n        Yes → Step 7: newLeft = min(left, intervals[idxStart].start)\n        Yes → Step 8: newRight = max(right, intervals[idxEnd-1].end)\n        Yes → Step 9: Remove intervals from idxStart to idxEnd-1\n        Yes → Step 10: Insert [newLeft,newRight] at idxStart\n        No → Step 11: Insert [left,right] at idxStart\nSimilarly queryRange\n→ Step 12: QueryRange(left,right):\n    → Step 13: Find idx = FindLeftIndex(left)\n    → Decision: If idx == size or intervals[idx].start > left? // no interval covering left\n        Yes → Step 14: return false\n        No → Step 15: If intervals[idx].end < right? // interval ends before right\n            Yes → Step 16: return false\n            No → Step 17: return true\nRemoveRange\n→ Step 18: RemoveRange(left,right):\n    → Step 19: Find idxStart = FindLeftIndex(left)\n    → Step 20: Find idxEnd = FindRightIndex(right)\n    → Decision: If idxStart >= idxEnd? // no overlap\n        Yes → Step 21: return\n        No →\n            → Step 22: If intervals[idxStart].start < left? // left inside interval\n                Yes → Step 23: Create leftPart = [intervals[idxStart].start, left]\n            → Step 24: If intervals[idxEnd-1].end > right? // right inside interval\n                Yes → Step 25: Create rightPart = [right, intervals[idxEnd-1].end]\n            → Step 26: Remove intervals from idxStart to idxEnd-1\n            → Step 27: Insert leftPart if exists at idxStart\n            → Step 28: Insert rightPart if exists at idxStart+1\nEnd\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\". Use Chinese explanation. Use arrow etc.\n\nLet's write each line.\n\nBe careful to keep arrow and indentation. Use \"→\" to indicate new line. Use \"Decision:\".\n\nWe need to include Start and End.\n\nWe can write:\n\nStart // 程式開始\n\n→ Step 1: 初始化一個空的區間列表 intervals，按起點排序 // 用於存儲非重疊區間\n\n→ Step 2: 定義 Helper FindLeftIndex(left) // 二分搜尋第一個區間的 end >= left\n\n→ Step 3: 定義 Helper FindRightIndex(right) // 二分搜尋第一個區間的 start > right\n\n→ Step 4: 方法 addRange(left,right) // 將區間 [left,right) 加入\n\n   → Step 5: idxStart = FindLeftIndex(left) // 找到可能重疊的起始位置\n\n   → Step 6: idxEnd = FindRightIndex(right) // 找到可能重疊的結束位置\n\n   → Decision: idxStart < idxEnd? // 是否存在重疊區間？\n\n       Yes → Step 7: newLeft = min(left, intervals[idxStart].start) // 合併左端\n\n       Yes → Step 8: newRight = max(right, intervals[idxEnd-1].end) // 合併右端\n\n       Yes → Step 9: 從 intervals 刪除 idxStart 到 idxEnd-1 的區間 // 移除舊重疊區間\n\n       Yes → Step 10: 在 idxStart 處插入 [newLeft,newRight] // 新合併區間\n\n       No  → Step 11: 在 idxStart 處插入 [left,right] // 無重疊，直接插入\n\n→ Step 12: 方法 queryRange(left,right) // 檢查整個區間是否被覆蓋\n\n   → Step 13: idx = FindLeftIndex(left) // 找到第一個可能覆蓋 left 的區間\n\n   → Decision: idx == intervals.size 或 intervals[idx].start > left? // left 未被覆蓋\n\n       Yes → Step 14: 返回 false // 未覆蓋\n\n       No  → Decision: intervals[idx].end < right? // 覆蓋不足至 right\n\n           Yes → Step 15: 返回 false // 未覆蓋\n\n           No  → Step 16: 返回 true // 完全覆蓋\n\n→ Step 17: 方法 removeRange(left,right) // 刪除區間\n\n   → Step 18: idxStart = FindLeftIndex(left) // 找到重疊起始位置\n\n   → Step 19: idxEnd = FindRightIndex(right) // 找到重疊結束位置\n\n   → Decision: idxStart >= idxEnd? // 無重疊\n\n       Yes → Step 20: 返回 // 無需操作\n\n       No  →\n\n           → Step 21: leftPart = null, rightPart = null\n\n           → Decision: intervals[idxStart].start < left? // left 在區間內\n\n               Yes → Step 22: leftPart = [intervals[idxStart].start, left] // 保留左側\n\n           → Decision: intervals[idxEnd-1].end > right? // right 在區間內\n\n               Yes → Step 23: rightPart = [right, intervals[idxEnd-1].end] // 保留右側\n\n           → Step 24: 從 intervals 刪除 idxStart 到 idxEnd-1 的區間 // 刪除重疊部分\n\n           → Decision: leftPart != null? // 是否有左側剩餘\n\n               Yes → Step 25: 在 idxStart 插入 leftPart // 插入左側\n\n           → Decision: rightPart != null? // 是否有右側剩餘\n\n               Yes → Step 26: 在 idxStart+1 插入 rightPart // 插入右側\n\nEnd // 程式結束\n\nWe need to ensure each line ends with // explanation. Also include arrow for steps. Use indentation with spaces.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 初始化一個空的區間列表 intervals，按起點排序 // 用於存儲非重疊區間\n\n→ Step 2: 定義 Helper FindLeftIndex(left) // 二分搜尋第一個區間的 end ≥ left\n\n→ Step 3: 定義 Helper FindRightIndex(right) // 二分搜尋第一個區間的 start > right\n\n→ Step 4: 方法 addRange(left,right) // 將區間 [left,right) 加入\n\n   → Step 5: idxStart = FindLeftIndex(left) // 找到可能重疊的起始位置\n\n   → Step 6: idxEnd = FindRightIndex(right) // 找到可能重疊的結束位置\n\n   → Decision: idxStart < idxEnd? // 是否存在重疊區間？\n\n       Yes → Step 7: newLeft = min(left, intervals[idxStart].start) // 合併左端\n\n       Yes → Step 8: newRight = max(right, intervals[idxEnd-1].end) // 合併右端\n\n       Yes → Step 9: 從 intervals 刪除 idxStart 到 idxEnd-1 的區間 // 移除舊重疊區間\n\n       Yes → Step 10: 在 idxStart 處插入 [newLeft,newRight] // 新合併區間\n\n       No  → Step 11: 在 idxStart 處插入 [left,right] // 無重疊，直接插入\n\n→ Step 12: 方法 queryRange(left,right) // 檢查整個區間是否被覆蓋\n\n   → Step 13: idx = FindLeftIndex(left) // 找到第一個可能覆蓋 left 的區間\n\n   → Decision: idx == intervals.size 或 intervals[idx].start > left? // left 未被覆蓋\n\n       Yes → Step 14: 返回 false // 未覆蓋\n\n       No  → Decision: intervals[idx].end < right? // 覆蓋不足至 right\n\n           Yes → Step 15: 返回 false // 未覆蓋\n\n           No  → Step 16: 返回 true // 完全覆蓋\n\n→ Step 17: 方法 removeRange(left,right) // 刪除區間\n\n   → Step 18: idxStart = FindLeftIndex(left) // 找到重疊起始位置\n\n   → Step 19: idxEnd = FindRightIndex(right) // 找到重疊結束位置\n\n   → Decision: idxStart >= idxEnd? // 無重疊\n\n       Yes → Step 20: 返回 // 無需操作\n\n       No  →\n\n           → Step 21: leftPart = null, rightPart = null\n\n           → Decision: intervals[idxStart].start < left? // left 在區間內\n\n               Yes → Step 22: leftPart = [intervals[idxStart].start, left] // 保留左側\n\n           → Decision: intervals[idxEnd-1].end > right? // right 在區間內\n\n               Yes → Step 23: rightPart = [right, intervals[idxEnd-1].end] // 保留右側\n\n           → Step 24: 從 intervals 刪除 idxStart 到 idxEnd-1 的區間 // 刪除重疊部分\n\n           → Decision: leftPart != null? // 是否有左側剩餘\n\n               Yes → Step 25: 在 idxStart 插入 leftPart // 插入左側\n\n           → Decision: rightPart != null? // 是否有右側剩餘\n\n               Yes → Step 26: 在 idxStart+1 插入 rightPart // 插入右側\n\nEnd // 程式結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,true,true,false,2,true,true,true,4]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, true, true, true, false, 2, true, true, true, 4]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k          # 用來存放元素的循環緩衝區\n        self.head = 0               # 前端指標\n        self.count = 0              # 當前元素數量\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:    # 判斷是否已滿\n            return False\n        self.head = (self.head - 1) % self.k  # 前移頭指標\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:    # 判斷是否已滿\n            return False\n        idx = (self.head + self.count) % self.k  # 計算尾端索引\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:         # 判斷是否為空\n            return False\n        self.head = (self.head + 1) % self.k  # 後移頭指標\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:         # 判斷是否為空\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data or len(data) < 2:\n        sys.exit()\n    ops = ast.literal_eval(data[0].strip())\n    args = ast.literal_eval(data[1].strip())\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(arg[0])\n            results.append(None)          # 生成器對應 null\n        else:\n            func = getattr(obj, op)\n            res = func(*arg)\n            results.append(res)\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. The virtual code should be structured. For a circular deque, we need to maintain array, head, tail, size, capacity. Provide operations accordingly. Each step should be one line. Use arrow. We must not output actual code. Just virtual steps. Provide explanation after //.\n\nLet's outline:\n\nStart\n→ Step 1: 初始化容量 k // set capacity\n→ Step 2: 建立長度為 k 的陣列 storage // storage array\n→ Step 3: 設置 head = 0 // head index\n→ Step 4: 設置 tail = 0 // tail index\n→ Step 5: 設置 size = 0 // 当前元素數量\n\nInsertFront:\n→ Step 1: 判斷 if size == capacity? // if full\n    Yes → return false\n    No → head = (head - 1 + capacity) mod capacity // move head backward\n         storage[head] = value // place value\n         size++ // increment size\n         return true\n\nInsertLast:\n→ Step 1: 判斷 if size == capacity? \n    Yes → return false\n    No → storage[tail] = value // place at tail\n         tail = (tail + 1) mod capacity // move tail forward\n         size++\n         return true\n\nDeleteFront:\n→ Step 1: 判斷 if size == 0?\n    Yes → return false\n    No → head = (head + 1) mod capacity // move head forward\n         size--\n         return true\n\nDeleteLast:\n→ Step 1: 判斷 if size == 0?\n    Yes → return false\n    No → tail = (tail - 1 + capacity) mod capacity // move tail backward\n         size--\n         return true\n\nGetFront:\n→ Step 1: 判斷 if size == 0? \n    Yes → return -1\n    No → return storage[head]\n\nGetRear:\n→ Step 1: 判斷 if size == 0? \n    Yes → return -1\n    No → index = (tail - 1 + capacity) mod capacity\n        return storage[index]\n\nIsEmpty:\n→ Step 1: return size == 0\n\nIsFull:\n→ Step 1: return size == capacity\n\nEnd\n\nNeed to ensure formatting with arrows and decisions. Use \"Decision:\" lines for if statements. Provide comments.\n\nWe need to output each line with virtual code step + // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化容量 k // 設定最大容量  \n→ Step 2: 建立長度為 k 的陣列 storage // 用於儲存元素  \n→ Step 3: 設置 head = 0 // front 指標起始位置  \n→ Step 4: 設置 tail = 0 // rear 指標起始位置  \n→ Step 5: 設置 size = 0 // 現在元素數量  \n\n**insertFront(value)**  \n→ Decision: 若 size == capacity? // 檢查是否已滿  \n  Yes → return false // 無法插入，返回失敗  \n  No → head = (head - 1 + capacity) mod capacity // 將 head 往前移  \n    storage[head] = value // 放入值  \n    size++ // 元素數量增加  \n    return true // 成功插入  \n\n**insertLast(value)**  \n→ Decision: 若 size == capacity? // 檢查是否已滿  \n  Yes → return false // 無法插入，返回失敗  \n  No → storage[tail] = value // 放入值  \n    tail = (tail + 1) mod capacity // 將 tail 往後移  \n    size++ // 元素數量增加  \n    return true // 成功插入  \n\n**deleteFront()**  \n→ Decision: 若 size == 0? // 檢查是否為空  \n  Yes → return false // 無法刪除，返回失敗  \n  No → head = (head + 1) mod capacity // 將 head 往後移  \n    size-- // 元素數量減少  \n    return true // 成功刪除  \n\n**deleteLast()**  \n→ Decision: 若 size == 0? // 檢查是否為空  \n  Yes → return false // 無法刪除，返回失敗  \n  No → tail = (tail - 1 + capacity) mod capacity // 將 tail 往前移  \n    size-- // 元素數量減少  \n    return true // 成功刪除  \n\n**getFront()**  \n→ Decision: 若 size == 0? // 檢查是否為空  \n  Yes → return -1 // 空時返回 -1  \n  No → return storage[head] // 回傳 front 元素  \n\n**getRear()**  \n→ Decision: 若 size == 0? // 檢查是否為空  \n  Yes → return -1 // 空時返回 -1  \n  No → index = (tail - 1 + capacity) mod capacity // 取得 rear 索引  \n    return storage[index] // 回傳 rear 元素  \n\n**isEmpty()**  \n→ Step 1: return size == 0 // 判斷是否空  \n\n**isFull()**  \n→ Step 1: return size == capacity // 判斷是否滿  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0+-2i'\nGot (Norm):      '0-2i'\n--- (Raw) ---\nRaw Expected: '\"0+-2i\"'\nRaw Got:      '0-2i'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef parse_complex(s: str):\n    \"\"\"將 'real+imagi' 或 'real-imagi'（可能包含 '+-'）轉成 (real, imag) 整數對\"\"\"\n    # 先把 '+-' 改成 '-'，方便後續解析\n    s = s.replace('+-', '-')\n    # 找到 'i' 的位置（假設一定存在）\n    i_pos = s.rfind('i')\n    if i_pos == -1:\n        raise ValueError(\"輸入字串缺少 'i'\")\n    # 在 i 前面找最後一個 '+' 或 '-'，但要排除字串開頭\n    sep_pos = s.rfind('+', 0, i_pos)\n    if sep_pos == -1:\n        sep_pos = s.rfind('-', 1, i_pos)\n    if sep_pos == -1:\n        raise ValueError(\"無法找到實部與虛部分隔符\")\n    real_part = int(s[:sep_pos])\n    imag_part = int(s[sep_pos:i_pos])\n    return real_part, imag_part\n\ndef format_complex(real: int, imag: int) -> str:\n    \"\"\"將 (real, imag) 整數對轉回字串形式 'real+imagi' 或 'real-imagi'\"\"\"\n    if imag >= 0:\n        return f\"{real}+{imag}i\"\n    else:\n        return f\"{real}{imag}i\"  # imag 已經是負數，直接拼接\n\ndef complex_multiply(a: str, b: str) -> str:\n    a_real, a_imag = parse_complex(a)\n    b_real, b_imag = parse_complex(b)\n    real = a_real * b_real - a_imag * b_imag\n    imag = a_real * b_imag + a_imag * b_real\n    return format_complex(real, imag)\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從引號內提取兩個複數字串\n    matches = re.findall(r'\"([^\"]+)\"', data)\n    if len(matches) < 2:\n        # 若沒有使用引號，也嘗試以逗號分隔\n        parts = [p.strip() for p in data.split(',')]\n        if len(parts) >= 2:\n            a, b = parts[0], parts[1]\n        else:\n            raise ValueError(\"無法解析輸入\")\n    else:\n        a, b = matches[0], matches[1]\n    result = complex_multiply(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines that handle multiplication of complex numbers given as strings like \"a+bi\". Steps: parse, compute product: (a+bi)*(c+di) = (ac - bd) + (ad + bc)i. Then output as string. Need to consider negative signs? Input form maybe \"real+imaginaryi\" but imaginary can be negative, then maybe \"real-bi\"? Actually string like \"a+bi\" where imaginary part is integer, may include negative sign, so string can be \"a-bi\". So parsing: split at '+' or '-'. But easier: replace 'i' with '' and split by '+'? But with negative imaginary, it's \"a-bi\". We could find last '+' or '-' that separates real and imaginary. Approach: find position of 'i', then find last '+' or '-' before that position. Use regex? But pseudo code: find index of 'i', then find last '+' or '-' before i. Then parse real part substring from 0 to that index, parse imaginary part substring from that index to i (including sign). Then compute.\n\nFinally produce string: realPart + \"+\" + imaginaryPart + \"i\" if imaginary >=0 else realPart + \"-\" + abs(imaginary) + \"i\". Or just use sign accordingly.\n\nWe'll produce virtual code line by line. Use Start, End, Decision.\n\nLet's produce:\n\nStart\n→ Step 1: Input num1, num2\n→ Step 2: Parse num1 into (r1, i1) using ParseComplex(num1)\n→ Step 3: Parse num2 into (r2, i2) using ParseComplex(num2)\n→ Step 4: Compute realProd = r1 * r2 - i1 * i2\n→ Step 5: Compute imagProd = r1 * i2 + i1 * r2\n→ Step 6: Format result = FormatComplex(realProd, imagProd)\n→ End\n\nNeed to define ParseComplex and FormatComplex.\n\nDefine ParseComplex(s):\nStart\n→ Find index of 'i' in s\n→ Find separatorPos = last index of '+' or '-' before index of 'i' (but not at start)\n→ Decision: If separatorPos == -1? // Handle invalid\n    No → ... but we can assume valid.\n→ realStr = substring(0, separatorPos)\n→ imagStr = substring(separatorPos, index of 'i')\n→ real = ConvertToInt(realStr)\n→ imag = ConvertToInt(imagStr)\n→ Return (real, imag)\nEnd\n\nFormatComplex(r, i):\nStart\n→ Decision: If i >= 0?\n    Yes → result = r + \"+\" + i + \"i\"\n    No  → result = r + \"-\" + abs(i) + \"i\"\n→ Return result\nEnd\n\nWe need to produce in virtual code format with arrows. Let's use arrows for steps.\n\nWe must not output actual code but pseudo. We'll include lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input num1, num2 // 取得兩個複數字串  \n→ Step 2: (r1, i1) = ParseComplex(num1) // 解析 num1 為實部 r1 與虛部 i1  \n→ Step 3: (r2, i2) = ParseComplex(num2) // 解析 num2 為實部 r2 與虛部 i2  \n→ Step 4: realProd = r1 * r2 - i1 * i2 // 計算實部乘法結果  \n→ Step 5: imagProd = r1 * i2 + i1 * r2 // 計算虛部乘法結果  \n→ Step 6: result = FormatComplex(realProd, imagProd) // 將計算結果格式化為字串  \n→ End // 程式執行結束  \n\n---  \n\nStart // 解析複數字串為實部與虛部  \n→ Step 1: posI = IndexOf(s, 'i') // 找到 'i' 的位置  \n→ Step 2: sepPos = LastIndexOf(s, '+', 0, posI) // 先尋找 '+'  \n→ Decision: 若 sepPos == -1? // 若沒有 '+', 代表是負虛部  \n    Yes → sepPos = LastIndexOf(s, '-', 1, posI) // 再尋找 '-'，不包括首位  \n→ Step 3: realStr = Substring(s, 0, sepPos) // 取實部字串  \n→ Step 4: imagStr = Substring(s, sepPos, posI) // 取虛部字串（含符號）  \n→ Step 5: real = ConvertToInt(realStr) // 轉成整數  \n→ Step 6: imag = ConvertToInt(imagStr) // 轉成整數  \n→ Step 7: Return (real, imag) // 回傳實部與虛部  \nEnd // 解析結束  \n\n---  \n\nStart // 將實部與虛部組成字串  \n→ Step 1: Decision: 若 imag >= 0? // 判斷虛部符號  \n    Yes → result = real + \"+\" + imag + \"i\" // 正虛部，使用 '+'  \n    No  → result = real + \"-\" + Abs(imag) + \"i\" // 負虛部，使用 '-' 並取絕對值  \n→ Step 2: Return result // 回傳格式化字串  \nEnd // 格式化結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"找出所有重複檔案，返回以內容為鍵的路徑列表，並只保留至少兩個檔案的組別。\"\"\"\n        content_map = defaultdict(list)\n\n        for path in paths:\n            parts = path.split()\n            root = parts[0]  # 目錄路徑\n            for file_info in parts[1:]:\n                # 例: \"1.txt(abcd)\"\n                name, content = file_info.split('(')\n                content = content.rstrip(')')  # 去掉右括號\n                full_path = f\"{root}/{name}\"\n                content_map[content].append(full_path)\n\n        # 只保留重複組別\n        return [files for files in content_map.values() if len(files) > 1]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 若輸入包含 \"paths =\"，則移除前綴\n    if raw_input.startswith(\"paths\"):\n        raw_input = raw_input.split(\"=\", 1)[1].strip()\n\n    # 解析為 Python 列表\n    try:\n        paths = ast.literal_eval(raw_input)\n    except Exception as e:\n        print(f\"輸入格式錯誤: {e}\")\n        sys.exit(1)\n\n    # 計算重複檔案\n    solution = Solution()\n    result = solution.findDuplicate(paths)\n\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for the described problem, with explanation each line. Need to be in Traditional Chinese. Use the format: each line: 虛擬碼步驟 [space] // 解釋/說明. Use arrow symbols. Should show the algorithm: iterate over input list, parse each directory string, split by space to get directory path and file infos. For each file info, extract file name and content within parentheses. Build map content -> list of full paths. After processing all, iterate over map, pick those lists with size>=2, add to result list. Return result. Also need Start and End markers. We'll include steps: Start, Step: initialize map, Step: iterate paths, Step: parse line, Step: split directory and file parts, etc.\n\nUse Decision: maybe for checking size>=2. Provide explanation.\n\nLet's write lines accordingly.\n\nWe'll need to use virtual arrows: \"→\". Use indent for nested. Use \"Yes →\" \"No →\". Use \"Decision:\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 Map<string, list<string>> contentMap // 建立內容到完整路徑的對應表  \n→ Step 2: 初始化 list<list<string>> result // 儲存重複檔案組的結果  \n→ Step 3: 迭代輸入 list<string> paths // 逐一處理每一條目  \n  → Sub-step: 將 currentPath 以第一個空格拆分成 dirPath 與 fileInfos // 取得目錄與檔案資訊  \n  → Sub-step: 迭代 fileInfos 列表 // 逐一處理每個檔案  \n    → Decision: 是否包含 '(' 與 ')'？ // 確認格式正確  \n      Yes → Sub-step: 取出 fileName 與 content（利用 '(' 與 ')' 位置）  \n      No → Sub-step: 跳過此檔案 // 非法格式時忽略  \n       → Step: 建立 fullPath = dirPath + \"/\" + fileName // 組合完整路徑  \n       → Step: 若 contentMap 尚無 content 鍵，建立新 list  \n       → Step: contentMap[content].add(fullPath) // 將完整路徑加入對應內容的列表  \n  → Step 4: 迭代 contentMap 的每一個 entry // 檢查是否為重複檔案  \n    → Decision: entry.value.size >= 2? // 至少兩個檔案相同內容  \n      Yes → Step 5: result.add(entry.value) // 加入結果  \n      No → No action // 只保留重複組  \nEnd // 程式執行結束，返回 result\n\n--- \n\n此虛擬碼展示了如何從目錄資訊字串中解析檔案路徑與內容，並利用映射資料結構找出所有重複內容的檔案群組。"
    },
    {
      "title": "Implement Trie (Prefix Tree)",
      "source_file": "Leetcode/leetcode208.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,true,false,true,null,true]'\nGot (Norm):      '[null,true,false,true,null,true]'\n--- (Raw) ---\nRaw Expected: '[null, null, true, false, true, null, true]'\nRaw Got:      '[null, true, false, true, null, true]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    commands, args_list = eval(data)\n    trie = Trie()\n    results = []\n    for cmd, args in zip(commands, args_list):\n        if cmd == 'insert':\n            trie.insert(args[0])\n            results.append(None)\n        elif cmd == 'search':\n            results.append(trie.search(args[0]))\n        elif cmd == 'startsWith':\n            results.append(trie.startsWith(args[0]))\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for implementing a Trie class with methods. Provide step-by-step pseudo-code, using arrows and decision structure. Should be in Traditional Chinese. Should not produce actual code. So we need to outline initialization, insert, search, startsWith.\n\nWe need to output line by line: each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use arrows (→). Start and End.\n\nLet's think of high-level structure:\n\nStart\n→ Step: Initialize Trie\n    → Define root node: child map, endFlag\n→ Step: insert(word)\n    → For each char in word\n        → If child not exist, create\n        → Move to child\n    → Mark endFlag true\n→ Step: search(word)\n    → For each char in word\n        → If child not exist, return false\n        → Move to child\n    → Return endFlag\n→ Step: startsWith(prefix)\n    → For each char in prefix\n        → If child not exist, return false\n        → Move to child\n    → Return true\nEnd\n\nAlso define Node structure.\n\nWe need to use Decision structure when checking existence.\n\nLet's produce.\n\nNeed to output \"Start // 程式開始執行\". Then \"→ Node class: children map, isEnd bool // 定義節點結構\" etc.\n\nWe need to ensure each line ends with comment.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Node class: children map, isEnd bool // 定義節點結構，children 儲存子節點，isEnd 標記是否為單詞結尾  \n→ Trie constructor: root ← new Node() // 初始化 Trie，根節點不代表任何字元  \n→ Method insert(word): // 插入單詞的流程  \n    → For each char c in word  \n        → Decision: 如果 root.children 沒有 c? // 檢查是否已有此字元的子節點  \n            Yes →  // 已有，直接使用該節點  \n            No  → root.children[c] ← new Node() // 沒有則創建新節點  \n        → root ← root.children[c] // 進入下一層節點  \n    → root.isEnd ← true // 標記最後一個節點為單詞結尾  \n→ Method search(word): // 搜尋完整單詞是否存在  \n    → For each char c in word  \n        → Decision: 如果 current.children 沒有 c? // 檢查路徑是否完整  \n            Yes → Return false // 路徑不完整，單詞不存在  \n            No  → current ← current.children[c] // 進入下一層  \n    → Return current.isEnd // 只有在最後節點標記為終結才算存在  \n→ Method startsWith(prefix): // 判斷是否有單詞以 prefix 為前綴  \n    → For each char c in prefix  \n        → Decision: 如果 current.children 沒有 c? // 路徑必須完整  \n            Yes → Return false // 前綴不在 Trie 中  \n            No  → current ← current.children[c] // 進入下一層  \n    → Return true // 走完前綴，代表至少有一個單詞以此為前綴  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[5]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[5]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[5,8]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[5, 8]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[7,7,4]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[7, 7, 4]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\n# --- API 提供者 -------------------------------------------------\ndef rand7() -> int:\n    \"\"\"隨機產生 1~7 的整數（使用內建 random 模組）。\"\"\"\n    return random.randint(1, 7)\n\n# --- 主要邏輯 ----------------------------------------------------\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        使用 rand7() 產生 1~10 的均勻隨機數。\n        方法：兩次 rand7() 合併成 1~49 的整數；若 ≤ 40 則轉成 1~10，否則重試。\n        \"\"\"\n        while True:\n            # (a-1)*7 + b 產生 1~49 的數字\n            num = (rand7() - 1) * 7 + rand7()\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\n# --- 主程式 ------------------------------------------------------\ndef main() -> None:\n    \"\"\"\n    從 stdin 讀取形式為 'n = X' 的輸入，產生 X 個 rand10() 的結果並輸出列表。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    n = 0\n    if data:\n        # 解析 'n = X' 這類字串\n        try:\n            _, val = data.split('=', 1)\n            n = int(val.strip())\n        except ValueError:\n            pass  # 若解析失敗，保持 n=0\n\n    solver = Solution()\n    results = [solver.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating uniform 1-10 using rand7. Classic solution: use 7x7 grid to get 49 outcomes, reject 40-49? Actually 49 -> 10*4=40, reject 41-49 (9 numbers). So loop: generate two rand7, compute r = (a-1)*7 + b (1-49). If r <= 40, return (r-1)%10 + 1 else repeat.\n\nWe must output steps line by line with virtual code arrow. Use Start, End, Decision. Provide explanation comments. No actual code.\n\nWe need to generate steps for rand10() function. Also maybe a main test harness but not necessary. Just produce steps.\n\nWe'll include: Start rand10 function. Step: get x=rand7() as first random. Step: get y=rand7() as second. Step: compute r. Decision: if r <= 40? Yes -> return r % 10 + 1? Actually (r-1)%10+1. No -> loop again.\n\nWe might show loop via recursion or while. Virtual code with Decision loops.\n\nLet's craft:\n\nStart // Function rand10開始\n→ Step 1: a ← rand7() // 取得第一個隨機數\n→ Step 2: b ← rand7() // 取得第二個隨機數\n→ Step 3: r ← (a - 1) * 7 + b // 將兩個數合併成 1-49 的值\n→ Decision: r <= 40? // 檢查是否在可接受範圍內\n    Yes → Step 4: result ← (r - 1) % 10 + 1 // 轉換成 1-10\n    → Step 5: return result // 回傳隨機數\n    No  → Step 6: goto Step 1 // 重新開始取得隨機數\nEnd // 函式結束\n\nBut we need to represent loop properly. Use Decision and Yes/No branches; No goes back to Step 1. Might need to mark as 'Loop' or 'Go back to Step 1'.\n\nWe might use '→ Step 1' again inside No branch.\n\nWe need to keep structure.\n\nAlso need to include maybe an outer function call loop. But we just produce algorithm.\n\nMake sure each line ends with // 解釋.\n\nAdd arrow symbols.\n\nLet's output lines accordingly.\n\nWe'll also add a note at the end: End // 程式執行結束.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: a ← rand7() // 取得第一個隨機數（範圍 1-7）\n→ Step 2: b ← rand7() // 取得第二個隨機數（範圍 1-7）\n→ Step 3: r ← (a - 1) * 7 + b // 合併成 1-49 的整數\n→ Decision: r <= 40? // 判斷 r 是否在可接受的 1-40 範圍\n    Yes → Step 4: result ← (r - 1) % 10 + 1 // 轉換成 1-10 的數字\n    → Step 5: return result // 回傳隨機數\n    No  → Step 1 // 重新開始取得新的兩個 rand7()，重複流程\nEnd // 程式執行結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpupd9292y.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmpupd9292y.py\", line 36, in main\n    p1, p2, p3, p4 = parse_points(data)\n                     ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpupd9292y.py\", line 28, in parse_points\n    raise ValueError(\"Expected 8 integers for four points.\")\nValueError: Expected 8 integers for four points."
        },
        {
          "example_index": 1,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppaeumitr.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmppaeumitr.py\", line 36, in main\n    p1, p2, p3, p4 = parse_points(data)\n                     ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppaeumitr.py\", line 28, in parse_points\n    raise ValueError(\"Expected 8 integers for four points.\")\nValueError: Expected 8 integers for four points."
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe3bjo8fp.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmpe3bjo8fp.py\", line 36, in main\n    p1, p2, p3, p4 = parse_points(data)\n                     ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpe3bjo8fp.py\", line 28, in parse_points\n    raise ValueError(\"Expected 8 integers for four points.\")\nValueError: Expected 8 integers for four points."
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0]-b[0])**2 + (a[1]-b[1])**2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n\n        for i in range(4):\n            for j in range(i+1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n\n        return (\n            dists[0] > 0 and\n            dists[0] == dists[1] == dists[2] == dists[3] and\n            dists[4] == dists[5] and\n            dists[4] == 2 * dists[0]\n        )\n\ndef parse_points(input_str):\n    nums = list(map(int, re.findall(r'-?\\d+', input_str)))\n    if len(nums) != 8:\n        raise ValueError(\"Expected 8 integers for four points.\")\n    points = [(nums[i], nums[i+1]) for i in range(0, 8, 2)]\n    return points\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    p1, p2, p3, p4 = parse_points(data)\n    sol = Solution()\n    result = sol.validSquare(p1, p2, p3, p4)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: given 4 points (unordered), determine if they form a square. Steps: compute all pairwise distances; there should be 4 equal small distances (sides) and 2 equal larger distances (diagonals) which are twice side squared. Also all distances >0. Implementation: compute squared distances between all 6 pairs, store in array, sort. Check: first 4 equal, last 2 equal, and 4th element*2 == last element? Actually sorted: [d1,d1,d1,d1,d2,d2], with d1>0, d2>2*d1? For square, diagonals = 2*side^2. So d2 == 2*d1. Then return true else false.\n\nWe need virtual code lines with explanation. Let's produce step-by-step:\n\nStart\n→ Step 1: Accept 4 points p1,p2,p3,p4 // Input\n→ Step 2: Create list distances // Empty list\n→ Step 3: For each pair of points among 4: compute squared distance and add to distances // Generate 6 distances\n→ Step 4: Sort distances ascending // To group equal lengths\n→ Step 5: Decision: if distances[0]==0? // No zero length side\n        No → Continue\n        Yes → Return false // degenerate\n→ Step 6: Decision: if distances[0]==distances[3]? // First four equal sides\n        Yes →\n        No → Return false\n→ Step 7: Decision: if distances[4]==distances[5]? // Last two equal diagonals\n        Yes →\n        No → Return false\n→ Step 8: Decision: if distances[4]==2*distances[0]? // Diagonal squared equals twice side squared\n        Yes → Return true\n        No → Return false\nEnd\n\nAdd explanations. Provide virtual code lines with arrows and explanation. Also mention that distances sorted ensures order. Provide correct format. Ensure each line uses the format: \"虛擬碼步驟 // 解釋\".\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Accept 4 points p1, p2, p3, p4 // 取得四個不排序的座標  \n→ Step 2: Create list distances // 用來儲存六對點的距離平方值  \n→ Step 3: For each unordered pair of the 4 points: compute squared distance and add to distances // 產生所有 6 個距離平方  \n→ Step 4: Sort distances ascending // 方便檢查相等的四條邊與兩條對角線  \n→ Step 5: Decision: 如果 distances[0] == 0? // 是否有邊長為 0（退化情況）  \n    Yes → Return false // 無效，因為邊長必須正  \n    No → Continue // 邊長皆 > 0，繼續判斷  \n→ Step 6: Decision: 如果 distances[0] == distances[3]? // 前四個是否相等（四條邊相等）  \n    Yes → Continue  \n    No → Return false // 邊長不相等，不能為正方形  \n→ Step 7: Decision: 如果 distances[4] == distances[5]? // 後兩個是否相等（兩條對角線相等）  \n    Yes → Continue  \n    No → Return false // 對角線不相等，不能為正方形  \n→ Step 8: Decision: 如果 distances[4] == 2 * distances[0]? // 對角線平方是否等於兩倍邊平方（90°）  \n    Yes → Return true // 符合正方形條件  \n    No → Return false // 角度不為 90°，不是正方形  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpeyvm8867.py\", line 39, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\n    ^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdvhft5dd.py\", line 39, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]\n    ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs: List[int]) -> int:\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n\n            # Cost without any special offers\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n\n            for offer in special:\n                # Check if offer can be applied\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                else:\n                    # Apply offer and recurse\n                    new_needs = [curr_needs[i] - offer[i] for i in range(n)]\n                    res = min(res, offer[-1] + dfs(new_needs))\n\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\nif __name__ == \"__main__\":\n    import sys\n    # Read the whole input\n    data = sys.stdin.read().strip()\n    # Execute the input string so that price, special, needs are defined\n    # The input format is guaranteed to be something like:\n    # price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\n    exec(data, globals())\n\n    solution = Solution()\n    result = solution.shoppingOffers(price, special, needs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code for solving this problem. It's a classic DFS + memo with DP for shopping offers. We should produce line-by-line steps, using Start, Decision, etc. Each line includes \"虛擬碼步驟 // 解釋\".\n\nWe should give algorithm: use recursion with state vector needs. Use memo map keyed by tuple of needs. For each state, compute min cost = sum(price[i]*needs[i]). Then for each offer: check if can apply (needs >= offer quantities). If yes, new_needs = needs - offer quantities; cost = offer_price + dfs(new_needs). Update min. Return min.\n\nAdditionally handle pruning.\n\nWe need to output in structured lines.\n\nWe should produce steps like:\n\nStart // start of algorithm\n→ Step 1: 定義 DFS 函數以遞歸計算最小價格 // ...\n\nWe need to include decision branches.\n\nLet's craft about 30 lines.\n\nMake sure each line uses the format: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nWe can include indentation via tab? Not necessary but good.\n\nAlso we can include \"Decision:\" lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義遞歸函式 DFS(需要) → // 以當前需求為參數  \n → Decision: 需求向量是否為全零? → // 判斷是否已購完所有商品  \n  Yes → Return 0 // 沒有商品需要購買，價格為 0  \n  No → // 進行計算  \n   → Step 2: 計算「不使用任何特價」的價格：sum(price[i] * 需要[i]) → // 初始最小價格  \n   → Variable 最小價格 = 計算結果  \n   → Step 3: 遍歷每個特價方案 special[j] → // 嘗試使用每個特價  \n    → Decision: 能否使用該特價？(需要[i] >= special[j][i] 對所有 i) → // 確認足夠購買  \n     Yes →  \n      → Step 4: 計算新需求 vector = 需要 - special[j] 的各項數量 → // 更新需求  \n      → Step 5: Recursively 呼叫 DFS(新需求) → // 取得使用特價後的最小價格  \n      → Step 6: 總價格 = special[j][n] + DFS(新需求) → // 加上特價費用  \n      → Step 7: 更新 最小價格 = min(最小價格, 總價格) → // 選擇更低價格  \n     No → // 不能使用此特價，跳過  \n   → Step 8: 將 最小價格 缓存到 memo 以備後續查詢 → // 避免重複計算  \n   → Return 最小價格 // 回傳此需求的最小價格  \n→ Step 9: 呼叫 DFS(原始需求) → // 開始計算  \n→ End // 程式執行結束  \n\n(Note: 上述虛擬碼以逐行結構說明遞歸＋備忘錄的解法，符合「不買多餘商品」的限制，並允許重複使用特價。)"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpf_rqe0y7.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpf_rqe0y7.py\", line 37, in main\n    commands, arguments = json.loads(data)\n                          ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 47 (char 46)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]          # copy to avoid aliasing\n        self.tree = [0] * (self.n + 1)  # 1-indexed Fenwick tree\n        for i in range(self.n):\n            self._update_tree(i + 1, nums[i])\n\n    def _update_tree(self, idx, delta):\n        while idx <= self.n:\n            self.tree[idx] += delta\n            idx += idx & -idx\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, idx):\n        res = 0\n        while idx > 0:\n            res += self.tree[idx]\n            idx -= idx & -idx\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # The input is a JSON array: [commands, arguments]\n    commands, arguments = json.loads(data)\n    obj = None\n    results = []\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"NumArray\":\n            obj = NumArray(args[0])   # args[0] is the nums list\n            results.append(None)      # null for constructor\n        elif cmd == \"update\":\n            obj.update(args[0], args[1])\n            results.append(None)      # null for update\n        elif cmd == \"sumRange\":\n            res = obj.sumRange(args[0], args[1])\n            results.append(res)\n    # Output as JSON to match the expected format\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for a class with segment tree or BIT. Provide steps. Use Start, End, Decision, arrows. Each line: virtual code + space + // explanation.\n\nWe need to handle initialization, update, sumRange.\n\nProbably use Binary Indexed Tree or segment tree. We'll describe BIT.\n\nLet's produce steps:\n\nStart\n→ Step 1: Input array nums // Receive initial array\n→ Step 2: Initialize BIT array of size n+1 // BIT for range sum\n→ Decision: If n > 0? // Check array not empty\n    Yes → Step 3: For i from 0 to n-1: \n        → Step 3a: BIT_update(i, nums[i]) // Build BIT\n    No  → Step 4: Do nothing // Empty array\n→ Step 5: End Init // Completed initialization\n\nThen methods:\n\n→ Step 6: Method update(index, val): // Public method\n    → Step 6a: diff = val - nums[index] // Calculate change\n    → Step 6b: nums[index] = val // Update array\n    → Step 6c: BIT_update(index, diff) // Update BIT\n\n→ Step 7: Method sumRange(left, right):\n    → Step 7a: return BIT_query(right) - BIT_query(left-1) // Range sum via prefix sums\n\nWe need to include BIT_update and BIT_query operations as virtual steps.\n\nWe should also include internal helper functions.\n\nUse Decision nodes where needed.\n\nAlso produce steps for BIT_update and BIT_query.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Input array nums // 取得初始整數陣列\n→ Step 2: n ← length(nums) // 紀錄陣列長度\n→ Step 3: Initialize BIT array bit[0…n] with zeros // 建立長度 n+1 的 BIT\n→ Decision: If n > 0? // 若陣列非空則建立 BIT\n    Yes → Step 4: For i from 0 to n-1:\n        → Step 4a: BIT_update(i, nums[i]) // 把 nums[i] 加入 BIT\n    No  → Step 5: Skip // 空陣列不需要建構\n→ Step 6: End Init // 初始化結束\n\nDefine helper:\n→ Step 7: Function BIT_update(idx, delta):\n    → Step 7a: idx ← idx + 1 // BIT 索引從 1 開始\n    → Decision: While idx ≤ n? // 更新至 BIT 範圍\n        Yes → Step 7b: bit[idx] ← bit[idx] + delta // 加增量\n        → Step 7c: idx ← idx + (idx & -idx) // 移至下個區塊\n        No  → End of loop\n    → Step 7d: End BIT_update // 完成更新\n\n→ Step 8: Function BIT_query(idx):\n    → Step 8a: sum ← 0\n    → Step 8b: idx ← idx + 1\n    → Decision: While idx > 0? // 計算前綴和\n        Yes → Step 8c: sum ← sum + bit[idx]\n        → Step 8d: idx ← idx - (idx & -idx)\n        No  → End loop\n    → Step 8e: Return sum // 前綴和\n\nMain methods:\n→ Step 9: Method update(index, val):\n    → Step 9a: diff ← val - nums[index] // 計算變化量\n    → Step 9b: nums[index] ← val // 更新陣列\n    → Step 9c: BIT_update(index, diff) // 更新 BIT\n    → Step 9d: End update // 方法結束\n\n→ Step 10: Method sumRange(left, right):\n    → Step 10a: sumRight ← BIT_query(right) // 前綴和至 right\n    → Step 10b: sumLeft ← BIT_query(left - 1) // 前綴和至 left-1\n    → Step 10c: Return sumRight - sumLeft // 求區間和\n    → Step 10d: End sumRange // 方法結束\n\nEnd // 程式結束\n\nMake sure each line has format: virtual code step + space + // explanation.\n\nWe need arrows: Start, End, Decision.\n\nUse indentation for substeps. Let's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input array nums // 取得初始整數陣列  \n→ Step 2: n ← length(nums) // 紀錄陣列長度  \n→ Step 3: Initialize BIT array bit[0…n] with zeros // 建立長度 n+1 的 BIT  \n→ Decision: If n > 0? // 若陣列非空則建立 BIT  \n Yes → Step 4: For i from 0 to n-1:  \n  → Step 4a: BIT_update(i, nums[i]) // 把 nums[i] 加入 BIT  \n No → Step 5: Skip // 空陣列不需要建構  \n→ Step 6: End Init // 初始化結束  \n\n→ Step 7: Function BIT_update(idx, delta): // 更新 BIT 的輔助函式  \n → Step 7a: idx ← idx + 1 // BIT 索引從 1 開始  \n → Decision: While idx ≤ n? // 更新至 BIT 範圍  \n  Yes → Step 7b: bit[idx] ← bit[idx] + delta // 加增量  \n   → Step 7c: idx ← idx + (idx & -idx) // 移至下個區塊  \n  No → End loop  \n → Step 7d: End BIT_update // 完成更新  \n\n→ Step 8: Function BIT_query(idx): // 查詢 BIT 的前綴和輔助函式  \n → Step 8a: sum ← 0  \n → Step 8b: idx ← idx + 1  \n → Decision: While idx > 0? // 計算前綴和  \n  Yes → Step 8c: sum ← sum + bit[idx]  \n   → Step 8d: idx ← idx - (idx & -idx)  \n  No → End loop  \n → Step 8e: Return sum // 前綴和  \n\n→ Step 9: Method update(index, val): // 更新陣列元素並同步 BIT  \n → Step 9a: diff ← val - nums[index] // 計算變化量  \n → Step 9b: nums[index] ← val // 更新陣列  \n → Step 9c: BIT_update(index, diff) // 更新 BIT  \n → Step 9d: End update // 方法結束  \n\n→ Step 10: Method sumRange(left, right): // 回傳區間和  \n → Step 10a: sumRight ← BIT_query(right) // 前綴和至 right  \n → Step 10b: sumLeft ← BIT_query(left - 1) // 前綴和至 left-1  \n → Step 10c: Return sumRight - sumLeft // 求區間和  \n → Step 10d: End sumRange // 方法結束  \n\nEnd // 程式結束執行"
    },
    {
      "title": "Count The Repetitions",
      "source_file": "Leetcode/leetcode466.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef get_max_repetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    \"\"\"\n    計算可以從 str1=[s1,n1] 取得多少次 str2=[s2,n2]\n    \"\"\"\n    if n1 == 0:\n        return 0\n\n    # 每處理完一次 s1 後的 s2 位置與已取得的 s2 次數\n    recall = {}\n    s1_count = 0          # 已處理的 s1 重複次數\n    s2_count = 0          # 已取得的 s2 重複次數\n    index_in_s2 = 0       # 在 s2 中目前對應的索引\n\n    # 當遇到週期時，記錄前置與週期部分\n    pre_loop = (0, 0)\n    loop = (0, 0)\n\n    while s1_count < n1:\n        # 逐字處理一整個 s1\n        for ch in s1:\n            if ch == s2[index_in_s2]:\n                index_in_s2 += 1\n                if index_in_s2 == len(s2):\n                    index_in_s2 = 0\n                    s2_count += 1\n\n        s1_count += 1\n\n        # 只依據 index_in_s2 來偵測週期\n        if index_in_s2 in recall:\n            # 找到週期\n            prev_s1, prev_s2 = recall[index_in_s2]\n            pre_loop = (prev_s1, prev_s2)\n            loop = (s1_count - prev_s1, s2_count - prev_s2)\n            break\n        else:\n            recall[index_in_s2] = (s1_count, s2_count)\n\n    # 若整個 n1 都已走完，直接算\n    if s1_count == n1:\n        return s2_count // n2\n\n    # 先加上前置區段\n    total_s2 = pre_loop[1]\n    remaining_s1 = n1 - pre_loop[0]\n\n    # 再加上整個週期可重複的次數\n    times_loop = remaining_s1 // loop[0]\n    total_s2 += times_loop * loop[1]\n    remaining_s1 %= loop[0]\n\n    # 走完剩餘的 s1 次數\n    index_rest = index_in_s2\n    for _ in range(remaining_s1):\n        for ch in s1:\n            if ch == s2[index_rest]:\n                index_rest += 1\n                if index_rest == len(s2):\n                    index_rest = 0\n                    total_s2 += 1\n\n    return total_s2 // n2\n\ndef main():\n    data = sys.stdin.read()\n    # 取出所有被雙引號包住的字串\n    strings = re.findall(r'\"([^\"]*)\"', data)\n    # 取出所有數字\n    ints = list(map(int, re.findall(r'\\d+', data)))\n\n    # 預設順序為 s1, n1, s2, n2\n    s1 = strings[0] if len(strings) > 0 else \"\"\n    s2 = strings[1] if len(strings) > 1 else \"\"\n    n1 = ints[0] if len(ints) > 0 else 0\n    n2 = ints[1] if len(ints) > 1 else 1\n\n    result = get_max_repetitions(s1, n1, s2, n2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solution. Problem known: \"Maximum number of times that string s2 repeated n2 times can be obtained from string s1 repeated n1 times\". Standard solution uses tracking of repeats and cycle detection.\n\nWe need to provide step-by-step virtual code lines with explanation.\n\nLet's craft algorithm:\n\n- Initialize countS2 = 0, countS1 = 0\n- indexInS2 = 0\n- map indexInS1 -> (countS1, countS2)\n- While countS1 < n1:\n   - For each char in s1:\n       if char == s2[indexInS2]: indexInS2++ ; if indexInS2 == s2.length: indexInS2=0; countS2++\n   - countS1++\n   - If current countS1 is seen before in map: cycle found\n      - previousCountS1, previousCountS2 = map[countS1]\n      - cycleS1 = countS1 - previousCountS1\n      - cycleS2 = countS2 - previousCountS2\n      - remainingS1 = n1 - countS1\n      - timesCycle = remainingS1 / cycleS1\n      - countS1 += timesCycle * cycleS1\n      - countS2 += timesCycle * cycleS2\n   - else: store map[countS1] = (countS1, countS2)\n- result = countS2 / n2\n\nImplement in virtual code lines with explanations.\n\nWe need to use arrow and decision structure.\n\nLet's produce lines like:\n\nStart\n→ Initialize countS1 = 0 // Number of s1 repetitions processed\n→ Initialize countS2 = 0 // Number of s2 repetitions obtained\n→ Initialize indexInS2 = 0 // Current position in s2\n→ Initialize map = empty // To store previous state for cycle detection\n→ Decision: while countS1 < n1? // Process each repetition of s1\n    Yes → Step: For each char in s1: ... // inner loop\n\nWe need to represent loop over s1 characters: maybe \"For each char c in s1\" arrow etc.\n\nWe also need to incorporate cycle detection after each outer iteration.\n\nLet's produce pseudocode.\n\nEnsure each line has \"虛擬碼步驟 // 解釋\".\n\nWe need to use arrows. Provide indentation? Use spaces.\n\nLet's write final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize countS1 = 0 // 目前已處理的 s1 重複次數  \n→ Initialize countS2 = 0 // 目前已得到的 s2 重複次數  \n→ Initialize indexInS2 = 0 // 在 s2 中目前匹配到的位置  \n→ Initialize map = {} // 用於偵測週期的字典，鍵為 countS1，值為 (countS1, countS2)  \n\n→ Decision: countS1 < n1? // 只要還有 s1 需要處理就繼續  \n  Yes → Step: For each character c in s1: // 逐字處理一個 s1  \n    Decision: c == s2[indexInS2]? // 目前字是否符合 s2 的期望  \n      Yes → Action: indexInS2 = (indexInS2 + 1) % |s2| // 進入下一個 s2 字符，若走完則回到起點"
    },
    {
      "title": "Flatten Nested List Iterator",
      "source_file": "Leetcode/leetcode341.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nestedList = [[1,1],2,[1,1]]",
          "expected_output": "[1,1,2,1,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgmzpm0ps.py\", line 79, in <module>\n    nested_list_obj = build_nested_integer(nested_list)\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgmzpm0ps.py\", line 58, in build_nested_integer\n    result.append(NestedInteger(build_nested_integer(item)))\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgmzpm0ps.py\", line 17, in __init__\n    self._list.append(NestedInteger(v))\n                      ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgmzpm0ps.py\", line 16, in __init__\n    for v in value:\nTypeError: 'NestedInteger' object is not iterable"
        },
        {
          "example_index": 1,
          "input": "nestedList = [1,[4,[6]]]",
          "expected_output": "[1,4,6]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfvcgsfu5.py\", line 79, in <module>\n    nested_list_obj = build_nested_integer(nested_list)\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfvcgsfu5.py\", line 58, in build_nested_integer\n    result.append(NestedInteger(build_nested_integer(item)))\n                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfvcgsfu5.py\", line 58, in build_nested_integer\n    result.append(NestedInteger(build_nested_integer(item)))\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfvcgsfu5.py\", line 17, in __init__\n    self._list.append(NestedInteger(v))\n                      ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfvcgsfu5.py\", line 16, in __init__\n    for v in value:\nTypeError: 'NestedInteger' object is not iterable"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass NestedInteger:\n    \"\"\"A simple implementation of the NestedInteger interface.\"\"\"\n    def __init__(self, value=None):\n        if value is None:\n            self._integer = None\n            self._list = []\n        elif isinstance(value, int):\n            self._integer = value\n            self._list = None\n        else:\n            self._integer = None\n            self._list = []\n            for v in value:\n                self._list.append(NestedInteger(v))\n\n    def isInteger(self):\n        return self._integer is not None\n\n    def getInteger(self):\n        return self._integer\n\n    def getList(self):\n        return self._list\n\n\nclass NestedIterator:\n    \"\"\"Iterator that flattens a nested list of NestedInteger objects.\"\"\"\n    def __init__(self, nestedList):\n        # Use a stack to store NestedInteger objects in reverse order\n        self.stack = list(reversed(nestedList))\n\n    def next(self):\n        \"\"\"Return the next integer.\"\"\"\n        return self.stack.pop().getInteger()\n\n    def hasNext(self):\n        \"\"\"Return True if there is a next integer.\"\"\"\n        while self.stack:\n            top = self.stack[-1]\n            if top.isInteger():\n                return True\n            # top is a list: pop it and push its elements in reverse order\n            self.stack.pop()\n            self.stack.extend(reversed(top.getList()))\n        return False\n\n\ndef build_nested_integer(lst):\n    \"\"\"Recursively convert a nested Python list into a list of NestedInteger.\"\"\"\n    result = []\n    for item in lst:\n        if isinstance(item, int):\n            result.append(NestedInteger(item))\n        else:\n            result.append(NestedInteger(build_nested_integer(item)))\n    return result\n\n\nif __name__ == \"__main__\":\n    # Read the entire input\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Extract the expression after '=' if present\n    if \"=\" in raw_input:\n        _, expr = raw_input.split(\"=\", 1)\n        expr = expr.strip()\n    else:\n        expr = raw_input\n\n    # Safely evaluate the nested list expression\n    nested_list = ast.literal_eval(expr)\n\n    # Convert to NestedInteger objects\n    nested_list_obj = build_nested_integer(nested_list)\n\n    # Use the iterator to flatten the list\n    iterator = NestedIterator(nested_list_obj)\n    flattened = []\n    while iterator.hasNext():\n        flattened.append(iterator.next())\n\n    # Output the result\n    print(flattened)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines step by step. We should produce a design of NestedIterator with methods: constructor, next, hasNext. We'll use a stack of iterators or list of NestedInteger and index. We'll flatten on demand using recursion? We'll simulate algorithm: use stack of (list, index). While stack not empty, check top's current element; if it's integer, return; if list, push that list onto stack. Use hasNext to prepare next integer by moving stack accordingly. We'll maintain nextVal field to hold next integer and ready flag.\n\nLet's produce pseudocode lines with arrows and explanations.\n\nWe need to use \"Start\" and \"End\" markers. The code should show the class, constructor, hasNext, next. For each line, we provide explanation.\n\nLet's craft.\n\nFirst lines: Start. Then class declaration. Then fields: stack, nextVal, hasNextFlag. Constructor: initialize stack with nestedList and index 0. Then call prepareNext. Then method hasNext: return hasNextFlag. Next method: if not hasNextFlag return -1? or raise? We'll just return nextVal and then call prepareNext. prepareNext method: while stack not empty, look at top. If top index >= list size: pop. Else get element; if integer: set nextVal and hasNextFlag true; increment index; break; else if list: push new pair (list, 0). If loop ends, set hasNextFlag false.\n\nLet's output line by line. Ensure each line uses \"→\" arrow.\n\nLet's write:\n\nStart\n→ Class NestedIterator // 定義 NestedIterator 類別\n\n→   Stack<Pair<List<NestedInteger>, Integer>> stack // 儲存待處理列表與索引\n→   Integer nextVal // 下一個待返回的整數\n→   Boolean hasNextFlag // 是否存在下一個整數\n\n→   NestedIterator(List<NestedInteger> nestedList) // 建構子\n    →   // 初始化堆疊\n    →   stack.push(new Pair<>(nestedList, 0))\n    →   // 準備第一個整數\n    →   prepareNext()\n→ End // 建構子結束\n\n→   Boolean hasNext() // 檢查是否還有整數\n    →   return hasNextFlag\n→ End // hasNext 方法結束\n\n→   Integer next() // 取得下一個整數\n    →   Integer result = nextVal\n    →   // 移動到下一個整數\n    →   prepareNext()\n    →   return result\n→ End // next 方法結束\n\n→   void prepareNext() // 將堆疊前進至下一個整數\n    →   hasNextFlag = false\n    →   while (!stack.isEmpty()) // 當堆疊不為空時\n        →   Pair<List<NestedInteger>, Integer> top = stack.peek()\n        →   // 若索引已超過列表長度，彈出堆疊\n        →   if (top.index >= top.list.size())\n            →       stack.pop()\n            →   else\n                →   NestedInteger current = top.list.get(top.index)\n                →   // 進一步遞增索引\n                →   top.index += 1\n                →   // 若是整數，設置為下一個結果\n                →   if (current.isInteger())\n                    →       nextVal = current.getInteger()\n                    →       hasNextFlag = true\n                    →       break\n                →   else\n                    →       // 若是子列表，推入堆疊以便後續處理\n                    →       stack.push(new Pair<>(current.getList(), 0))\n    →   // 若循環結束且堆疊已空，hasNextFlag 已為 false\n→ End // prepareNext 方法結束\n\nEnd // 程式結束\n\nWe need to ensure each line uses the \"→\" arrow at start of each line except Start and End maybe not arrow. Format: Start // comment. Next lines: → Step. Use arrow before code. Provide explanation after //.\n\nLet's output accordingly. Ensure each line has arrow. We'll keep indentation with spaces? We can just show arrow for each logical line. Provide explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Class NestedIterator // 定義 NestedIterator 類別\n\n→   Stack<Pair<List<NestedInteger>, Integer>> stack // 堆疊，存放待處理的列表與當前索引\n→   Integer nextVal // 下一個即將返回的整數\n→   Boolean hasNextFlag // 是否還存在下一個整數\n\n→   NestedIterator(List<NestedInteger> nestedList) // 建構子\n    →   stack.push(new Pair<>(nestedList, 0)) // 將最外層列表推入堆疊，索引初始化為 0\n    →   prepareNext() // 先行定位到第一個可返回的整數\n\n→ End // 建構子結束\n\n→   Boolean hasNext() // 檢查是否還有可返回的整數\n    →   return hasNextFlag\n\n→ End // hasNext 方法結束\n\n→   Integer next() // 取得下一個整數\n    →   Integer result = nextVal // 保存當前即將返回的整數\n    →   prepareNext() // 移動到下一個可返回的整數\n    →   return result\n\n→ End // next 方法結束\n\n→   void prepareNext() // 內部方法：定位到堆疊頂部的下一個可返回整數\n    →   hasNextFlag = false // 預設為沒有下一個\n    →   while (!stack.isEmpty()) // 當堆疊不為空時\n        →   Pair<List<NestedInteger>, Integer> top = stack.peek() // 查看堆疊頂部\n        →   if (top.index >= top.list.size()) // 若索引已超出列表長度\n            →       stack.pop() // 彈出該列表，回到上一層\n            →   else\n                →   NestedInteger current = top.list.get(top.index) // 取出當前元素\n                →   top.index += 1 // 索引向前移動\n                →   if (current.isInteger()) // 若是整數\n                    →       nextVal = current.getInteger() // 設定為下一個返回值\n                    →       hasNextFlag = true // 表示存在下一個\n                    →       break // 結束定位\n                →   else // 若是子列表\n                    →       stack.push(new Pair<>(current.getList(), 0)) // 推入子列表，索引重置為 0\n    →   // 若循環結束且堆疊已空，hasNextFlag 已保持為 false\n\n→ End // prepareNext 方法結束\nEnd // 程式結束\n```"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7gzf5gcw.py\", line 46, in <module>\n    numCourses, prerequisites = parse_input(data)\n                                ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7gzf5gcw.py\", line 39, in parse_input\n    prerequisites = eval(pre_str)  # 直接使用 eval 解析列表\n                    ^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmhp5jnqv.py\", line 46, in <module>\n    numCourses, prerequisites = parse_input(data)\n                                ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmhp5jnqv.py\", line 39, in parse_input\n    prerequisites = eval(pre_str)  # 直接使用 eval 解析列表\n                    ^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return order if len(order) == numCourses else []\n\ndef parse_input(input_str: str):\n    \"\"\"\n    解析形如 'numCourses = 2, prerequisites = [[1,0]]' 的輸入字串\n    \"\"\"\n    # 移除空白\n    s = input_str.replace(' ', '')\n    # 取得數字部分\n    parts = s.split(',')\n    if len(parts) < 2:\n        raise ValueError(\"輸入格式錯誤\")\n    num_str = parts[0].replace('numCourses=', '')\n    pre_str = parts[1].replace('prerequisites=', '')\n    numCourses = int(num_str)\n    prerequisites = eval(pre_str)  # 直接使用 eval 解析列表\n    return numCourses, prerequisites\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    numCourses, prerequisites = parse_input(data)\n    sol = Solution()\n    result = sol.findOrder(numCourses, prerequisites)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code that solves the course schedule problem: find topological order of courses given prerequisites, using Kahn's algorithm or DFS. Provide each line as \"虛擬碼步驟 // 解釋\". Use arrow, Decision, etc. We'll produce generic algorithm.\n\nLet's output: Start, create graph adjacency, indegree array, queue, then while queue not empty, process, decrement indegrees, push new zero indegree nodes, build order. After loop, check if order length == numCourses, return order else empty.\n\nInclude decisions. Let's format. Use lines: \"Start // 程式開始執行\". Use arrows for steps: \"→\". Use decisions.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 adjacency list 及 indegree 陣列 // 為每門課建立鄰接清單與入度計數  \n→ Step 2: 對於每對 [a, b] in prerequisites:  \n    Adjacency[b] ← Adjacent(a) // b 必須先修，a 後修  \n    Indegree[a] ← Indegree[a] + 1 // a 的入度加一  \n→ Step 3: 建立一個空 Queue Q // 用於存放入度為 0 的課程  \n→ Decision: 若有課程入度為 0? // 判斷是否存在可立即修課的課程  \n  Yes → Step 4: 將所有入度為 0 的課程加入 Q  \n  No  → Step 5: // 若不存在入度為 0，圖中必定有環，直接返回空陣列  \n    End // 程式結束，回傳空結果  \n→ Step 6: 建立空 Array order // 用於儲存課程修習順序  \n→ Decision: Q 是否為空? // 處理所有可修課程  \n  Yes → Step 7: While Q 非空:  \n    Course ← Q.dequeue() // 取出一門課  \n    order.append(Course) // 加入順序  \n    對於每個 neighbor in Adjacent[Course]:  \n     Indegree[neighbor] ← Indegree[neighbor] - 1 // 完成此課後，對後續課程入度減一  \n     Decision: Indegree[neighbor] 是否為 0? // 判斷是否可以立即修  \n      Yes → Q.enqueue(neighbor) // 入度為 0，加入隊列  \n      No → // 仍有前置課程未完成，保持現狀  \n    Decision: Q 仍為空? // 迴圈結束判斷  \n     Yes → Step 8: Decision: order.length 是否等於 numCourses? // 檢查是否修完所有課程  \n      Yes → End // 回傳順序，程式結束  \n      No  → End // 有環，回傳空陣列  \n     No → // 回到 Step 7 的迴圈  \n  No  → // 若初始 Q 為空且有課程未處理，表示有環，回傳空陣列  \n    End // 程式結束，回傳空結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            # Ensure all emails are connected to the first email\n            for email in acc[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        return [[email_to_name[root]] + sorted(emails) for root, emails in merged.items()]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將「accounts = ...」或僅 list 的字串解析為 Python list\n    match = re.search(r'accounts\\s*=\\s*(.*)', data, re.S)\n    if match:\n        accounts_str = match.group(1)\n    else:\n        accounts_str = data\n\n    accounts = ast.literal_eval(accounts_str)\n\n    result = Solution().accountsMerge(accounts)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for merging accounts based on email union find, similar to LeetCode 721. Use union-find or graph DFS. We'll produce step-by-step pseudocode with explanation per line. Must use arrows, Decision, Start, End.\n\nLet's design steps:\n\nStart\n→ Build graph: email adjacency list\n→ For each account:\n   - name = first element\n   - For each email in account (skip first):\n        - if email not in graph: add\n        - Add edge between first email and current email\n   - Also map email to name\n→ After graph built, perform DFS or union-find\n→ visited set\n→ For each email in graph:\n    - if not visited:\n        → DFS to collect component emails\n        → sort emails\n        → prepend name (from email-to-name mapping)\n        → add to result\n→ Return result\nEnd\n\nWe need each line with explanation.\n\nLet's format using the required arrow syntax. For decision, use Decision: ... Yes→, No→.\n\nWe might include loops with indentation using arrow.\n\nWe need to show steps line by line. Provide each line as \"虛擬碼步驟 // 解釋\". Use arrow \"→\" to indicate next step. Indentation for sub-steps.\n\nLet's craft.\n\nExample:\n\nStart // 程式開始執行\n→ Step 1: 初始化空圖 graph = {} // 建立空字典以存儲 email 的鄰接\n→ Step 2: 初始化映射 email_to_name = {} // 存儲每個 email 對應的姓名\n→ Step 3: 初始化映射 graph = {} // 用於儲存 email 間的邊\n...\n\nNeed to ensure proper indentation: use tab or spaces? The format says arrow \"→\". For nested we can indent lines with spaces and arrow inside. Use typical style.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: graph ← empty dictionary // 建立 email → set 的圖\n→ Step 2: email_to_name ← empty dictionary // 記錄 email 對應姓名\n→ Step 3: For each account in accounts:\n    → name ← account[0] // 取得帳號名稱\n    → For each email in account[1:]:\n        → email_to_name[email] ← name // 將 email 連結姓名\n        → If email not in graph: graph[email] ← empty set // 初始化鄰接集合\n        → For each other_email in account[1:]:\n            → If other_email != email:\n                → graph[email].add(other_email) // 建立雙向連結\n                → graph[other_email].add(email)\n...\n\nBut that inner nested loops may produce repeated edges. Instead we can connect first email with others to reduce complexity.\n\nSimplify: for each account: first_email = account[1], for each email in account[2:], add edge between first_email and email.\n\nOk.\n\nLet's produce pseudocode:\n\n→ For each account in accounts:\n    → name ← account[0]\n    → first_email ← account[1]\n    → email_to_name[first_email] ← name\n    → If first_email not in graph: graph[first_email] ← empty set\n    → For each email in account[2:]:\n        → email_to_name[email] ← name\n        → If email not in graph: graph[email] ← empty set\n        → graph[first_email].add(email)\n        → graph[email].add(first_email)\n\nAfter building graph.\n\n→ visited ← empty set\n→ result ← empty list\n→ For each email in graph:\n    → If email not in visited:\n        → stack ← [email]\n        → component ← empty list\n        → While stack not empty:\n            → cur ← stack.pop()\n            → If cur in visited: continue\n            → visited.add(cur)\n            → component.add(cur)\n            → For each neighbor in graph[cur]:\n                → If neighbor not in visited:\n                    → stack.append(neighbor)\n        → component_sorted ← sort(component) // lexical\n        → name ← email_to_name[component[0]] // or any\n        → merged_account ← [name] + component_sorted\n        → result.append(merged_account)\n→ Return result\n\nWe need to represent decision points:\n\nDecision: 如果 email not in visited? etc.\n\nOk.\n\nLet's craft final answer.\n\nUse line numbers? Not necessary.\n\nBut each line must be separate, with arrow.\n\nLet's produce.\n\nEnsure \"Start // 程式開始執行\" first line.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: graph ← {} // 建立一個字典來儲存每個 email 的相鄰 email 集合  \n→ Step 2: email_to_name ← {} // 建立 email → name 的映射表  \n→ Step 3: For each account in accounts: // 逐筆處理輸入的帳戶列表  \n  → name ← account[0] // 取出帳戶的姓名  \n  → first_email ← account[1] // 取出該帳戶第一個 email 作為連結基準  \n  → email_to_name[first_email] ← name // 把第一個 email 與姓名對應  \n  → If first_email not in graph: graph[first_email] ← {} // 初始化集合  \n  → For each email in account[2:]: // 針對剩下的 email 建立連結  \n    → email_to_name[email] ← name // 把所有 email 與姓名對應  \n    → If email not in graph: graph[email] ← {} // 初始化集合  \n    → graph[first_email].add(email) // 第一個 email 與其他 email 連結  \n    → graph[email].add(first_email) // 兩向連結  \n→ Step 4: visited ← {} // 用於記錄已經處理過的 email  \n→ Step 5: result ← [] // 儲存最終合併後的帳戶  \n→ Step 6: For each email in graph: // 逐個 email 探索其聯結組  \n  → Decision: 如果 email 不在 visited? // 判斷是否已經處理過  \n    Yes → Step 6.1: stack ← [email] // 使用堆疊進行 DFS  \n     → component ← [] // 收集同一個聯結組的所有 email  \n     → While stack not empty: // DFS 迴圈  \n       → cur ← stack.pop() // 取出當前節點  \n       → Decision: 如果 cur 已在 visited?  \n         Yes → continue // 跳過已處理的節點  \n         No  →  \n          → visited.add(cur) // 標記為已訪問  \n          → component.append(cur) // 加入結果集合  \n          → For each neighbor in graph[cur]: // 探索鄰居  \n            Decision: 如果 neighbor 未在 visited?  \n            Yes → stack.append(neighbor) // 加入堆疊  \n            No → do nothing  \n     → Step 6.2: component_sorted ← sort(component) // 依字母順序排序  \n     → name ← email_to_name[component[0]] // 取任一 email 的姓名（全組相同）  \n     → merged_account ← [name] + component_sorted // 組合成最終帳戶格式  \n     → result.append(merged_account) // 加入結果列表  \n→ End // 程式執行結束（result 為合併後的帳戶清單）"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,1,6,1,4,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 1, 6, 1, 4, 6, 1, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        index = random.randint(0, self.size - 1)\n        return self.mapping.get(index, index)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        print(json.dumps([]))\n        sys.exit()\n    methods = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1])\n\n    obj = None\n    results = []\n\n    for method, arg in zip(methods, args):\n        if method == \"Solution\":\n            n, blacklist = arg\n            obj = Solution(n, blacklist)\n            results.append(None)\n        elif method == \"pick\":\n            results.append(obj.pick())\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. The problem: Random pick excluding blacklist. Approach: Map blacklisted numbers in range [0, m-1] to allowed numbers in [m, n-1] where m = n - len(blacklist). Preprocess: build a mapping dict for blacklisted numbers less than m to some allowed number >= m that is not blacklisted. In pick, generate random int in [0, m-1], if mapping exists return mapped value else return k.\n\nWe'll produce virtual code with Start, End, Decision etc.\n\nNeed to include steps: init: compute m, build mapping. pick: generate random in [0, m-1], check mapping.\n\nWe need to explain each line with // comments.\n\nNo actual code, just virtual code lines. Use arrows: →, Yes →, No →. Use Decision:.\n\nWe'll produce the steps.\n\nWe should ensure each line is a virtual code step, with explanation.\n\nLet's produce something like:\n\nStart\n→ Step 1: 接收參數 n 和 blacklist // 初始化輸入\n→ Step 2: 計算 m = n - blacklist.Length // 可用數量\n→ Step 3: 建立 HashSet banned // 方便查找\n→ Step 4: 建立 Dictionary map // 用於映射\n→ Step 5: 建立變數 last = n - 1 // 最高允許值指標\n→ Decision: 是否有 blacklist? // 判斷是否需要建圖\n    Yes →\n        → Step 6: 迭代 blacklist 並將其存入 banned // 方便查找\n        → Step 7: 迭代 i from 0 to m-1\n            → Decision: i 在 banned? // 判斷是否為黑名\n                Yes →\n                    → Decision: last 在 banned? // 確保 last 不是黑名\n                        Yes → last = last - 1 // 找下一個非黑名\n                        No →\n                    → Step 8: map[i] = last // 將 i 映射到 last\n                    → Step 9: last = last - 1 // 移動指標\n                No → // 若 i 不是黑名，無需映射\n    No →\n        // 無黑名，無需映射\n\n→ End\n\nThen pick function:\n\nStart pick\n→ Step 10: 隨機取 k in [0, m-1] // 基於可用數量\n→ Decision: map.ContainsKey(k)? // 檢查映射\n    Yes → → Step 11: return map[k] // 返回映射值\n    No  → → Step 12: return k // 返回原值\nEnd pick\n\nBut the problem says minimize calls to random. In this algorithm, only one call per pick.\n\nAlso we should mention that map may be empty if no blacklist.\n\nLet's produce virtual code lines accordingly.\n\nMake sure each line uses \"虛擬碼步驟\" then comment. Use arrows. We must separate lines with newline.\n\nLet's produce.\n\nAlso we might include separate blocks: \"Solution Constructor\" and \"pick\" function.\n\nLet's produce accordingly.\n\nAlso we might add comments like // 建構子, // pick function.\n\nWe'll output lines. Let's do.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收參數 n 與 blacklist // 初始化輸入  \n→ Step 2: 計算 m = n - blacklist.Length // 可用數量  \n→ Step 3: 建立 HashSet banned // 用於快速判斷黑名  \n→ Step 4: 建立 Dictionary map // 用於映射被封鎖的低位數值  \n→ Step 5: 設置 last = n - 1 // 指向最高可能值  \n\nDecision: 是否存在 blacklist? // 若無需處理  \nYes →  \n    → Step 6: 迭代 blacklist 并將每個元素加入 banned // 方便查找  \n    → Step 7: 迭代 i 從 0 到 m-1  \n        → Decision: i ∈ banned? // i 是黑名嗎？  \n            Yes →  \n                → Decision: last ∈ banned? // last 是否也是黑名？  \n                    Yes → → Step 8: last = last - 1 // 找到下一个非黑名  \n                    No  → // last 已安全  \n                → Step 9: map[i] = last // 把 i 映射到一個合法值  \n                → Step 10: last = last - 1 // 更新指標到下一個可能的合法值  \n            No → // i 本身合法，無需映射  \nNo → // blacklist 為空，map 留空  \n\nEnd // 構造完成  \n\n---  \n\nStart pick // pick 方法開始執行  \n→ Step 11: 隨機生成 k ∈ [0, m-1] // 只呼叫一次 random  \n→ Decision: map.ContainsKey(k)? // k 是否被映射？  \n    Yes → → Step 12: return map[k] // 返回映射後的合法值  \n    No  → → Step 13: return k // k 本身就是合法值  \nEnd // pick 方法結束\n\n---  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.78465,0.43533],[0.84589,0.50708],[-0.30634,-0.37757]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.78465, 0.43533], [0.84589, 0.50708], [-0.30634, -0.37757]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機產生極座標 (r, θ)，並轉換為直角座標\n        r = self.radius * math.sqrt(random.random())   # 保證均勻分布\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    commands = json.loads(data[0])\n    arguments = json.loads(data[1])\n\n    obj = None\n    results = []\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)          # 代表 constructor, 輸出為 null\n        elif cmd == \"randPoint\":\n            point = obj.randPoint()\n            # 只保留 5 位小數，方便比較\n            point = [round(point[0], 5), round(point[1], 5)]\n            results.append(point)\n\n    # 輸出結果，使用 json.dumps 以得到 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps, line by line, using the structure: Start, Steps with arrows, decisions. Must explain each line in comment. Need to implement random point generation inside a circle uniformly.\n\nApproach: Generate random angle uniform 0 to 2π, and radius sqrt(random)*R to get uniform distribution. Then compute x = x_center + r*cos(angle), y = y_center + r*sin(angle). Return [x,y].\n\nImplement Solution class with constructor storing radius, x_center, y_center. randPoint() uses random number generator.\n\nWe need to produce lines: Start, → Step: initializations, etc. Provide decision? Not many decisions.\n\nWe should show pseudo-code structure. Provide step lines: Start, constructor, initialization, then randPoint function steps.\n\nLet's produce: Start // program start\n→ Step 1: Define class Solution // create class\n→ Step 2: Define constructor with parameters radius, x_center, y_center // store them\n→ Step 3: Store radius, x_center, y_center as instance variables // data members\n→ Step 4: End of constructor // return\n→ Step 5: Define method randPoint // generate random point\n→ Step 6: Generate uniform angle theta in [0, 2π) // random\n→ Step 7: Generate uniform radius r' = sqrt(rand in [0,1)) * radius // adjust\n→ Step 8: Compute x = x_center + r'*cos(theta) // convert polar to Cartesian\n→ Step 9: Compute y = y_center + r'*sin(theta) // convert polar to Cartesian\n→ Step 10: Return [x, y] // output array\nEnd // program end\n\nWe can add decision maybe: None.\n\nBut we need to adhere to format: Each line \"虛擬碼步驟\" + space + \"// 解釋\". Use arrows and structure. They want arrows with →.\n\nWe can produce lines like:\n\nStart // 程式開始執行\n→ Define class Solution // 建立類別\n→ Constructor: Solution(radius, x_center, y_center) // 初始化物件\n    → Store radius in instance variable // 保存半徑\n    → Store x_center in instance variable // 保存 x 坐標\n    → Store y_center in instance variable // 保存 y 坐標\n→ Method: randPoint() // 產生隨機點\n    → Generate random number u in [0,1) // 產生 0~1 的隨機數\n    → Compute angle θ = 2π * u // 隨機角度\n    → Generate another random number v in [0,1) // 產生另一個隨機數\n    → Compute radius r = sqrt(v) * radius // 確保均勻分佈\n    → x = x_center + r * cos(θ) // 轉換為 x 坐標\n    → y = y_center + r * sin(θ) // 轉換為 y 坐標\n    → Return [x, y] // 回傳座標\nEnd // 程式結束\n\nMake sure each line has arrow? Only top-level steps maybe. For nested we can indent but still use arrow? They didn't specify indentation but could use sub-steps with arrow. But keep each line with arrow. Provide \"Decision:\" not needed.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define class Solution // 建立類別  \n→ Constructor: Solution(radius, x_center, y_center) // 初始化物件  \n  → Store radius in instance variable // 保存半徑  \n  → Store x_center in instance variable // 保存 x 坐標  \n  → Store y_center in instance variable // 保存 y 坐標  \n→ Method: randPoint() // 產生隨機點  \n  → Generate random number u in [0,1) // 產生 0~1 的隨機數  \n  → Compute angle θ = 2π * u // 隨機角度  \n  → Generate random number v in [0,1) // 產生另一個隨機數  \n  → Compute radius r = sqrt(v) * radius // 確保均勻分佈  \n  → x = x_center + r * cos(θ) // 轉換為 x 坐標  \n  → y = y_center + r * sin(θ) // 轉換為 y 坐標  \n  → Return [x, y] // 回傳座標  \nEnd // 程式結束"
    },
    {
      "title": "Longest Palindromic Substring",
      "source_file": "Leetcode/leetcode5.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'babad'",
          "expected_output": "'bab'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'bab'\nGot (Norm):      'aba'\n--- (Raw) ---\nRaw Expected: \"'bab'\"\nRaw Got:      'aba'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"Return the longest palindromic substring of s.\"\"\"\n        if not s:\n            return \"\"\n\n        n = len(s)\n        start, end = 0, 0  # indices of the longest palindrome found\n\n        for i in range(n):\n            # 奇數長度回文（中心在 i）\n            l, r = i, i\n            while l >= 0 and r < n and s[l] == s[r]:\n                l -= 1\n                r += 1\n            if r - l - 1 > end - start:\n                start, end = l + 1, r - 1\n\n            # 偶數長度回文（中心在 i, i+1）\n            l, r = i, i + 1\n            while l >= 0 and r < n and s[l] == s[r]:\n                l -= 1\n                r += 1\n            if r - l - 1 > end - start:\n                start, end = l + 1, r - 1\n\n        return s[start:end + 1]\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 解析輸入字串\n    if \"=\" in raw_input:\n        # 取等號右邊並安全評估為字串\n        expr = raw_input.split(\"=\", 1)[1].strip()\n        try:\n            s = ast.literal_eval(expr)\n        except Exception:\n            # 如果 eval 失敗，直接使用原始字串\n            s = expr.strip(\"'\\\"\")\n    else:\n        s = raw_input.strip(\"'\\\"\")\n\n    # 取得答案並輸出\n    solution = Solution()\n    result = solution.longestPalindrome(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: \"Longest Palindromic Substring\". We should produce step-by-step pseudocode with decision arrows etc.\n\nWe need to ensure \"逐行\" meaning each line as a step. Use arrow \"→\" for steps. Use \"Decision:\" for if conditions. Must include // explanation each line.\n\nWe cannot output real code, just pseudocode steps.\n\nWe need to show algorithm: Expand around center. For each index i, expand left i-1 and right i+1, track longest. Also handle even length center between i and i+1.\n\nWe need steps: Start, Input string s, initialize start, end indices, length 0, for loop i from 0 to len(s)-1: expandOdd(i,i), expandEven(i,i+1), update start,end,length accordingly. At the end, output substring s[start:end+1].\n\nWe must use decision arrows. Provide line like \"→ For i from 0 to n-1: // 迴圈遍歷每個中心位置\".\n\nBut we need to structure with decision lines? Expand function can be represented as Decision: 左右指標是否相等? Yes -> expand left--right++ else No.\n\nOk.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 s // 取得輸入字串  \n→ Step 2: 設定 n ← length(s) // 字串長度  \n→ Step 3: 初始化 start ← 0, end ← 0 // 最長回文子字串的起止索引  \n→ Step 4: for i from 0 to n-1: // 依序以每個字元為中心  \n    → Decision: 以 i 為中心擴展奇數長度回文  \n        Yes → Step 5: left ← i, right ← i // 奇數中心左、右指標  \n        → Decision: 左右指標在範圍內且 s[left] = s[right]?  \n            Yes → Step 6: left ← left - 1, right ← right + 1 // 進一步擴展  \n            No  → Step 7: current_len ← right - left - 1 // 取得擴展後長度  \n            → Decision: current_len > end - start?  \n                Yes → Step 8: start ← left + 1, end ← right - 1 // 更新最長子字串  \n                No → Step 9: // 先前最長仍有效  \n    → Decision: 以 i 與 i+1 為中心擴展偶數長度回文  \n        Yes → Step 10: left ← i, right ← i + 1 // 偶數中心左、右指標  \n        → Decision: 左右指標在範圍內且 s[left] = s[right]?  \n            Yes → Step 11: left ← left - 1, right ← right + 1 // 進一步擴展  \n            No  → Step 12: current_len ← right - left - 1 // 取得擴展後長度  \n            → Decision: current_len > end - start?  \n                Yes → Step 13: start ← left + 1, end ← right - 1 // 更新最長子字串  \n                No → Step 14: // 先前最長仍有效  \n→ Step 15: 輸出子字串 s[start … end] // 返回最長回文子字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,2,1],[2,1,3],[2,1,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [3, 2, 1], [2, 1, 3], [2, 1, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    \"\"\"隨機洗牌的實作。\"\"\"\n\n    def __init__(self, nums):\n        \"\"\"接收原始陣列，並複製一份以備回復。\"\"\"\n        self.original = list(nums)          # 保留原始順序\n        self.current = list(nums)           # 可變動的陣列\n\n    def reset(self):\n        \"\"\"還原到原始順序並回傳。\"\"\"\n        self.current = list(self.original)  # 重新複製一次\n        return self.current\n\n    def shuffle(self):\n        \"\"\"使用 Fisher‑Yates 洗牌演算法產生隨機排列。\"\"\"\n        n = len(self.current)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            self.current[i], self.current[j] = self.current[j], self.current[i]\n        return self.current\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並確保它是個可 eval 的 tuple\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n    if not raw.startswith('('):\n        raw = '(' + raw + ')'\n    # 解析輸入為 (methods, args_list)\n    methods, args_list = eval(raw, {})\n    \n    outputs = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            outputs.append(None)            # 創建物件時無回傳值\n        else:\n            func = getattr(obj, method)\n            outputs.append(func(*args))\n    # 使用 json.dumps 讓 None 轉成 null，符合範例輸出格式\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nThe user wants virtual code that describes the algorithm for shuffle and reset. We'll provide step-by-step with arrows and explanation. Use Start, End. For class structure. We'll provide class definition, constructor, methods. For shuffle, use Fisher-Yates algorithm. Provide steps: copy array, iterate from end to beginning, swap with random index. Provide explanation. Ensure we follow format exactly: \"Start // 程式開始執行\", arrow lines: \"→ Step X: ...\" with comment. Use Decision lines if needed. For random, just \"Get random integer between 0 and i\". Also store original array.\n\nLet's produce.\n\nNote: Provide as plain text lines. Ensure no real code. Use virtual syntax: \"→ Step 1: ...\" etc.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立類別 Solution，宣告成員變數 originalArray 及 currentArray // 用於儲存原始與當前陣列  \n→ Step 2: 建構子 Solution(int[] nums)  \n  → Action: 複製 nums 為 originalArray // 保存原始順序  \n  → Action: 複製 nums 為 currentArray // 初始化為原始陣列  \n→ Step 3: int[] reset()  \n  → Action: 複製 originalArray 為 currentArray // 重新還原陣列  \n  → Return: currentArray // 回傳還原後的陣列  \n→ Step 4: int[] shuffle()  \n  → Decision: 設定 n 為 currentArray 長度 // 取得陣列長度  \n   Yes → Step 5: 從 i = n-1 下降到 1  \n     → Action: 產生隨機整數 j，範圍 0 ≤ j ≤ i // Fisher–Yates 隨機指標  \n     → Action: 交換 currentArray[i] 與 currentArray[j] // 交換兩個元素  \n     → Continue 迴圈  \n  → Return: currentArray // 回傳隨機排列的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Reconstruct Original Digits from English",
      "source_file": "Leetcode/leetcode423.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '012'\nGot (Norm):      '0127'\n--- (Raw) ---\nRaw Expected: '\"012\"'\nRaw Got:      '0127'"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '45'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"45\"'\nRaw Got:      '457'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def originalDigits(self, s: str) -> str:\n        count = Counter(s)\n        out = {}\n\n        out['0'] = count['z']\n        out['2'] = count['w']\n        out['4'] = count['u']\n        out['6'] = count['x']\n        out['8'] = count['g']\n\n        out['3'] = count['h'] - out['8']\n        out['5'] = count['f'] - out['4']\n        out['7'] = count['s'] - out['6']\n\n        out['1'] = count['o'] - out['0'] - out['2'] - out['4']\n        out['9'] = count['i'] - out['5'] - out['6'] - out['8']\n\n        res = [k * out[k] for k in sorted(out.keys())]\n        return ''.join(res)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract only lowercase letters from the input (handles quoted or raw strings)\n    s = ''.join(re.findall(r'[a-z]+', data))\n    result = Solution().originalDigits(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm. We need to generate steps for the problem: given a string s containing an out-of-order English representation of digits 0-9, return digits in ascending order.\n\nWe need to produce pseudocode with arrows, Start, End, Decision, etc. No actual code, just steps. Each line has virtual code and comment.\n\nWe should produce step by step: counting letters, identifying unique letters for digits, etc. Steps: start, initialize count map, count letters, determine digits using unique letters for 0,2,4,6,8,1,3,5,7,9; build result string sorted ascending. Then output.\n\nWe must include all logic.\n\nWe need to use virtual code lines with \"→\". Provide explanation after //.\n\nWe need to produce \"逐行\" with each line including the arrow and comment.\n\nWe need to include decisions: e.g., while there are digits left.\n\nOk, produce a list.\n\nAlso we might incorporate a mapping of unique letters: 0:'z', 2:'w', 4:'u', 6:'x', 8:'g', 1:'o', 3:'h', 5:'f', 7:'s', 9:'i'.\n\nLet's produce steps:\n\nStart\n\n→ Step 1: Initialize letter frequency map // Count each character in s\n\n→ Step 2: Initialize digit count array size 10 // Store counts for digits 0-9\n\n→ Step 3: For each unique letter-digital pair in order [z-0, w-2, u-4, x-6, g-8, o-1, h-3, f-5, s-7, i-9] // Determine digits using unique letters\n\n→ Decision: If count of unique letter > 0? // Check if letter appears\n\n   Yes → Step 4: Set digit count[d] = frequency[uniqueLetter] // Assign count for digit d\n\n   No → Step 4: Continue to next pair\n\n→ Step 5: Subtract used letters from frequency map for each letter in digit word times count // Remove letters accounted for\n\nWe may need to loop or handle subtraction. We can produce loop: For each letter in word, subtract count times.\n\n→ Step 6: After all digits processed, construct result string by repeating digit character d digit_count[d] times in ascending order // Build final string\n\n→ End\n\nBut we need to ensure we use decisions for subtract.\n\nLet's produce a more detailed step:\n\nAfter setting digit count, subtract letters:\n\n→ Step 5: For each character c in word of digit d\n\n→ Decision: While frequency[c] > 0? // Subtract\n\n   Yes → frequency[c] -= count[d]\n\nBut we might do a loop: frequency[c] -= count[d]; but we need to ensure we don't go negative.\n\nSimpler: frequency[c] -= count[d]; but that's fine.\n\nWe need to produce explanation after each line.\n\nWe should produce lines in order.\n\nMake sure each line has virtual code, arrow, and comment.\n\nLet's craft the pseudocode:\n\nStart // 程式開始執行\n\n→ Step 1: Initialize a map letterCount to 0 for all 'a'..'z' // 先把所有字母計數器設為 0\n\n→ Decision: For each character ch in s? // 逐字遍歷輸入字串\n\n    Yes → Step 2: Increment letterCount[ch] // 計算每個字母出現次數\n\n→ End of Decision // 結束字母計數\n\n→ Step 3: Initialize an array digitCount[10] to 0 // 用於紀錄 0~9 的數字個數\n\n→ Step 4: Define list of (uniqueLetter, digit, word) pairs in processing order // 以唯一字母辨識的順序\n\n        ( 'z', 0, \"zero\" ),\n\n        ( 'w', 2, \"two\" ),\n\n        ( 'u', 4, \"four\" ),\n\n        ( 'x', 6, \"six\" ),\n\n        ( 'g', 8, \"eight\" ),\n\n        ( 'o', 1, \"one\" ),\n\n        ( 'h', 3, \"three\" ),\n\n        ( 'f', 5, \"five\" ),\n\n        ( 's', 7, \"seven\" ),\n\n        ( 'i', 9, \"nine\" )\n\n→ Decision: For each (uniq, d, word) in list? // 逐一處理\n\n    Yes → Step 5: count = letterCount[uniq] // 取得唯一字母對應的數字個數\n\n    → Decision: count > 0? // 需要處理嗎？\n\n        Yes → Step 6: digitCount[d] = count // 設定該數字的個數\n\n        → Step 7: For each character c in word\n\n        → Decision: while count > 0? // 把字母消去\n\n            Yes → letterCount[c] -= count // 減少已計算數字所佔字母\n\n            No → Step 8: Continue to next letter\n\n        → End of For\n\n    No → Step 9: Continue to next pair\n\n→ End of Decision // 所有數字判斷完成\n\n→ Step 10: Initialize result as empty string // 準備輸出結果\n\n→ Decision: For d from 0 to 9? // 按升序排列\n\n    Yes → Step 11: Append digit d to result digitCount[d] times // 加入對應數字\n\n→ End of Decision\n\n→ End // 程式結束\n\nBut we need each line separately. Let's break them:\n\nStart // 程式開始執行\n\n→ Step 1: letterCount = map of 'a'..'z' to 0 // 初始化字母頻率表\n\n→ Decision: For each ch in s\n\n    Yes → Step 2: letterCount[ch] += 1 // 計數字母出現次數\n\n→ End of Decision\n\n→ Step 3: digitCount = array[10] initialized to 0 // 初始化數字頻率表\n\n→ Step 4: pairList = [ ('z',0,\"zero\"), ('w',2,\"two\"), ('u',4,\"four\"), ('x',6,\"six\"), ('g',8,\"eight\"), ('o',1,\"one\"), ('h',3,\"three\"), ('f',5,\"five\"), ('s',7,\"seven\"), ('i',9,\"nine\") ] // 定義唯一字母與對應數字\n\n→ Decision: For each (uniq, d, word) in pairList\n\n    Yes → Step 5: count = letterCount[uniq] // 取得唯一字母的頻率\n\n    → Decision: count > 0\n\n        Yes → Step 6: digitCount[d] = count // 設定數字個數\n\n        → Step 7: For each c in word\n\n        → Decision: count > 0\n\n            Yes → letterCount[c] -= count // 減少已使用的字母\n\n            No → Step 8: Continue\n\n        → End of For\n\n    No → Step 9: Continue\n\n→ End of Decision\n\n→ Step 10: result = \"\" // 建立空結果字串\n\n→ Decision: For d from 0 to 9\n\n    Yes → Step 11: result += string of digit d repeated digitCount[d] times // 追加數字到結果\n\n→ End of Decision\n\n→ End // 程式結束\n\nBut we need to ensure each line is a separate line. Provide arrow. Use \"→\".\n\nAlso need to use \"Decision:\" lines. Let's produce with proper indent.\n\nBetter to produce more concise but still clear. We can do:\n\nStart // 程式開始執行\n\n→ Step 1: Initialize letterCount map with 0 for all 'a'..'z' // 計算字母頻率\n\n→ Decision: For each ch in s\n\n    Yes → Step 2: letterCount[ch] += 1 // 逐字計數\n\n→ End of Decision\n\n→ Step 3: Initialize digitCount[10] to 0 // 0~9 的數字頻率\n\n→ Step 4: Define pairList = [ ('z',0,\"zero\"), ('w',2,\"two\"), ('u',4,\"four\"), ('x',6,\"six\"), ('g',8,\"eight\"), ('o',1,\"one\"), ('h',3,\"three\"), ('f',5,\"five\"), ('s',7,\"seven\"), ('i',9,\"nine\") ] // 唯一字母映射\n\n→ Decision: For each (uniq, d, word) in pairList\n\n    Yes → Step 5: count = letterCount[uniq] // 取得唯一字母數量\n\n    → Decision: count > 0\n\n        Yes → Step 6: digitCount[d] = count // 設定該數字個數\n\n        → Step 7: For each c in word\n\n        → Decision: count > 0\n\n            Yes → letterCount[c] -= count // 移除已計算的字母\n\n            No → Step 8: Continue\n\n        → End of For\n\n    No → Step 9: Continue\n\n→ End of Decision\n\n→ Step 10: result = \"\" // 建立結果字串\n\n→ Decision: For d from 0 to 9\n\n    Yes → Step 11: result += str(d) repeated digitCount[d] times // 添加數字\n\n→ End of Decision\n\n→ End // 程式結束\n\nBut we need \"→\" arrow before each line, but Decision lines use \"Decision:\" preceded by arrow? In example, they used \"Decision: ...\". So we need \"→ Decision:\" lines for decision blocks. For loops we can just use \"→\". Let's mimic the format.\n\nWe'll produce each step:\n\nStart // 程式開始執行\n→ Step 1: Initialize letterCount map with 0 for all 'a'..'z' // 初始化字母頻率表\n→ Decision: For each ch in s\n    Yes → Step 2: letterCount[ch] += 1 // 逐字計算頻率\n    No  → // 無需處理\n→ End of Decision\n→ Step 3: Initialize digitCount[10] to 0 // 0~9 的數字頻率表\n→ Step 4: Define pairList = [ ('z',0,\"zero\"), ('w',2,\"two\"), ('u',4,\"four\"), ('x',6,\"six\"), ('g',8,\"eight\"), ('o',1,\"one\"), ('h',3,\"three\"), ('f',5,\"five\"), ('s',7,\"seven\"), ('i',9,\"nine\") ] // 唯一字母到數字的映射\n→ Decision: For each (uniq, d, word) in pairList\n    Yes → Step 5: count = letterCount[uniq] // 取得唯一字母對應的數字個數\n    → Decision: count > 0\n        Yes → Step 6: digitCount[d] = count // 記錄該數字個數\n        → Step 7: For each c in word\n        → Decision: count > 0\n            Yes → letterCount[c] -= count // 把已使用的字母減去\n            No  → // 何不需要\n        → End of For\n    No  → // 無需處理\n→ End of Decision\n→ Step 10: result = \"\" // 建立空結果字串\n→ Decision: For d from 0 to 9\n    Yes → Step 11: result += str(d) repeated digitCount[d] times // 將數字按升序加入結果\n→ End of Decision\nEnd // 程式結束\n\nWe need to use the arrow for each line. The example used \"→\" before each line, including inside decisions they used \"Yes →\". Let's follow that.\n\nAlso we need to maintain the structure.\n\nBetter to format as:\n\nStart // 程式開始執行\n→ Step 1: Initialize letterCount map with 0 for all 'a'..'z' // 初始化字母頻率表\n→ Decision: For each ch in s\n    Yes → Step 2: letterCount[ch] += 1 // 計算字母出現次數\n→ End of Decision\n→ Step 3: Initialize digitCount[10] to 0 // 初始化數字頻率表\n→ Step 4: Define pairList = [ ('z',0,\"zero\"), ('w',2,\"two\"), ('u',4,\"four\"), ('x',6,\"six\"), ('g',8,\"eight\"), ('o',1,\"one\"), ('h',3,\"three\"), ('f',5,\"five\"), ('s',7,\"seven\"), ('i',9,\"nine\") ] // 唯一字母對應數字\n→ Decision: For each (uniq, d, word) in pairList\n    Yes → Step 5: count = letterCount[uniq] // 取得唯一字母的頻率\n    → Decision: count > 0\n        Yes → Step 6: digitCount[d] = count // 記錄該數字個數\n        → Step 7: For each c in word\n        → Decision: count > 0\n            Yes → letterCount[c] -= count // 減少已計算字母\n            No  → // 無需處理\n        → End of For\n    No  → // 無需處理\n→ End of Decision\n→ Step 10: result = \"\" // 建立空結果字串\n→ Decision: For d from 0 to 9\n    Yes → Step 11: result += str(d) repeated digitCount[d] times // 按升序添加數字\n→ End of Decision\nEnd // 程式結束\n\nNeed to maintain each line as separate. Use arrow before each. For nested decisions, we can indent but still use arrow? In example, they indent nested decisions with arrows for each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 letterCount 為一個 'a'..'z' 的頻率表，所有值設為 0 // 建立字母頻率表  \n→ Decision: 對輸入字串 s 的每個字元 ch 進行處理  \n  Yes → Step 2: letterCount[ch] += 1 // 計算每個字母的出現次數  \n→ End of Decision  \n→ Step 3: 初始化 digitCount[10] 為 0 // 建立 0~9 數字的頻率表  \n→ Step 4: 定義 pairList 為 [( 'z',0,\"zero\" ), ( 'w',2,\"two\" ), ( 'u',4,\"four\" ), ( 'x',6,\"six\" ), ( 'g',8,\"eight\" ), ( 'o',1,\"one\" ), ( 'h',3,\"three\" ), ( 'f',5,\"five\" ), ( 's',7,\"seven\" ), ( 'i',9,\"nine\" )] // 唯一字母與對應數字的映射  \n→ Decision: 遍歷 pairList 中的每個 (uniq, d, word)  \n  Yes → Step 5: count = letterCount[uniq] // 取得唯一字母對應的數字個數  \n  → Decision: count > 0  \n   Yes → Step 6: digitCount[d] = count // 記錄該數字個數  \n    → Step 7: 對 word 中的每個字元 c 進行處理  \n      → Decision: count > 0  \n       Yes → letterCount[c] -= count // 把已使用的字母從頻率表中減去  \n       No  → // 無需處理  \n      → End of For  \n   No  → // 無需處理  \n→ End of Decision  \n→ Step 8: 建立空字串 result = \"\" // 用於儲存最終答案  \n→ Decision: 對 d 從 0 到 9 進行處理  \n  Yes → Step 9: result += str(d) 重複 digitCount[d] 次 // 按升序把數字加到結果  \n→ End of Decision  \nEnd // 程式結束"
    },
    {
      "title": "Design Twitter",
      "source_file": "Leetcode/leetcode355.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnd_g4_81.py\", line 61, in <module>\n    commands, arguments = json.loads(data)\n                          ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 105 (char 104)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        # 時間戳，越大代表越新\n        self.time = 0\n        # 每個使用者的推文，列表從舊到新\n        self.tweets = defaultdict(list)\n        # 每個使用者追蹤的集合\n        self.following = defaultdict(set)\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        # 任何人發推都自動追蹤自己\n        self.following[userId].add(userId)\n\n    def getNewsFeed(self, userId: int):\n        # 若此使用者尚未追蹤任何人，先加自己\n        if userId not in self.following:\n            self.following[userId].add(userId)\n        res = []\n        heap = []\n        # 逐一將每位追蹤者的最近推文塞進堆疊\n        for fid in self.following[userId]:\n            tws = self.tweets.get(fid, [])\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n        # 取出最多10筆\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx - 1 >= 0:\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        # 不允許自己跟自己\n        if followerId == followeeId:\n            self.following[followerId].add(followerId)\n            return\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            return\n        if followeeId in self.following.get(followerId, set()):\n            self.following[followerId].remove(followeeId)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 解析輸入：兩個列表，分別是方法名和對應參數\n    commands, arguments = json.loads(data)\n    obj = None\n    results = []\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"Twitter\":\n            obj = Twitter()\n            results.append(None)\n        elif cmd == \"postTweet\":\n            obj.postTweet(*args)\n            results.append(None)\n        elif cmd == \"getNewsFeed\":\n            res = obj.getNewsFeed(*args)\n            results.append(res)\n        elif cmd == \"follow\":\n            obj.follow(*args)\n            results.append(None)\n        elif cmd == \"unfollow\":\n            obj.unfollow(*args)\n            results.append(None)\n    # 輸出結果，使用 json.dumps 以得到 null 的表示\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanation after space and comment. We need to design simplified Twitter with methods: constructor, postTweet, getNewsFeed, follow, unfollow. We need to use Start, End, Decision. Likely we show steps of each method? Probably show the algorithm for each method. Provide a sequence for the whole program flow? Could be pseudocode steps for each method and main operations. We need to output in Chinese.\n\nWe should list steps for initialization: create data structures: userMap, followerMap, tweetList maybe.\n\nWe should include the logic for each method. For getNewsFeed: gather followees + self, then collect tweets from each, sort by timestamp, pick top 10. Use priority queue.\n\nWe need to show steps for follow/unfollow.\n\nWe'll write virtual code steps like:\n\nStart\n→ Initialize data structures\n→ ...\nEnd\n\nBut we also need to show the methods separately? Maybe show each method's steps. Since requirement: \"逐行生成对应的虚拟码\". We can produce a flow for each method, maybe separate blocks with labels.\n\nWe need to use Decision: ... Yes/No arrows.\n\nWe need to not output actual code. Just virtual steps.\n\nLet's produce structure:\n\nStart // 程式開始執行\n→ Step 1: 建立 Twitter 物件 // 初始化資料結構\n\nThen inside the constructor:\n\n→ Step 2: 初始化 userTweets Map<userId, list of tweetIds> // 用於存放每個使用者的推文\n→ Step 3: 初始化 followees Map<userId, set of followeeIds> // 用於追蹤每個使用者的追蹤關係\n→ Step 4: 初始化 globalTime // 追蹤推文時間戳\nEnd // 結束建構\n\nThen method postTweet:\n\nStart\n→ Step 1: 增加全域時間戳\n→ Step 2: 創建推文物件 {tweetId, timestamp}\n→ Step 3: 將推文加入對應使用者的 tweet 列表\nEnd\n\nMethod getNewsFeed:\n\nStart\n→ Step 1: 取得使用者跟隨者集合\n→ Decision: 若無 followees? // 若使用者沒有追蹤任何人\n    Yes → 使用者自己\n    No  → 加入 self\n→ Step 2: 建立最小堆 (size 10) 以儲存最新推文\n→ Step 3: 對每個 followee 的 tweet 列表，遍歷最近的幾條推文\n→ Decision: 推文數量 < 10? // 若推文數量不足 10 條\n    Yes → 把所有推文加入堆\n    No  → 只取最近 10 條\n→ Step 4: 從堆中取出 tweetId，倒序排序\n→ Step 5: 返回結果\nEnd\n\nMethod follow:\n\nStart\n→ Decision: 是否已存在 followee in follower's set?\n    Yes → Do nothing\n    No  → 將 followee 加入 follower 的追蹤集合\nEnd\n\nMethod unfollow:\n\nStart\n→ Decision: 是否存在 followee in follower's set?\n    Yes → 移除 followee\n    No  → Do nothing\nEnd\n\nBut we need to present each step line by line. The above is a bit too high-level. We need to produce each line with comment. Possibly combine all into one block? We can label each method with its own Start/End.\n\nLet's produce:\n\nStart // 初始化 Twitter\n→ Step 1: 建立全域變數 userTweets // 存放每個使用者的推文列表\n→ Step 2: 建立全域變數 followees // 存放每個使用者追蹤的使用者集合\n→ Step 3: 建立全域變數 timeStamp // 用於給推文編排時間\nEnd // 初始化結束\n\nMethod: postTweet\n\nStart // postTweet 方法開始\n→ Step 1: timeStamp ← timeStamp + 1 // 取得當前時間戳\n→ Step 2: 新增推文 {tweetId, timeStamp} 到 userTweets[userId] // 存入使用者推文\nEnd // postTweet 方法結束\n\nMethod: getNewsFeed\n\nStart // getNewsFeed 方法開始\n→ Step 1: feedSet ← followees[userId] ∪ {userId} // 取出使用者追蹤者與自己\n→ Step 2: priorityQueue ← 空堆 // 儲存最近推文，優先級為時間戳\n→ Step 3: 對每個 uid in feedSet\n    → Step 3a: tweetList ← userTweets[uid] // 取得該使用者的推文\n    → Step 3b: 取 tweetList 的最後 10 條（最近的）推文\n    → Step 3c: 對每個推文 t\n        → Decision: priorityQueue.size() < 10?\n            Yes → priorityQueue.add(t)\n            No → Decision: t.timeStamp > priorityQueue.peek().timeStamp?\n                Yes → priorityQueue.poll(); priorityQueue.add(t)\n                No → 跳過\n→ Step 4: result ← 空列表\n→ Step 5: 將 priorityQueue 中的推文依時間戳倒序取出，加入 result\n→ Step 6: 返回 result\nEnd // getNewsFeed 方法結束\n\nMethod: follow\n\nStart // follow 方法開始\n→ Decision: followeeId 已在 followees[followerId] 中?\n    Yes → 跳過\n    No  → followees[followerId].add(followeeId)\nEnd // follow 方法結束\n\nMethod: unfollow\n\nStart // unfollow 方法開始\n→ Decision: followeeId 在 followees[followerId] 中?\n    Yes → followees[followerId].remove(followeeId)\n    No  → 跳過\nEnd // unfollow 方法結束\n\nWe need each line separate with \"→\". Provide explanation comment after //.\n\nAlso we need to incorporate decision arrow lines: Decision: ... Yes → ... No → ... The format must match.\n\nWe can present each step as separate lines.\n\nAlso we must maintain arrow indentation.\n\nThus final output: Use Start/End for each method.\n\nWe'll output in Chinese, each line with arrow and explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // Twitter 物件初始化\n→ Step 1: 建立 userTweets Map<userId, List<tweet>> // 儲存每個使用者的所有推文\n→ Step 2: 建立 followees Map<userId, Set<followeeId>> // 儲存每個使用者追蹤的對象\n→ Step 3: 建立 timeStamp 整數變數 // 用來給每條推文編號時間戳\nEnd // 初始化完成\n\nStart // postTweet 方法開始\n→ Step 1: timeStamp ← timeStamp + 1 // 取得全域時間戳\n→ Step 2: tweet ← {id: tweetId, ts: timeStamp} // 建立推文物件\n→ Step 3: userTweets[userId].append(tweet) // 把推文放進該使用者的列表\nEnd // postTweet 方法結束\n\nStart // getNewsFeed 方法開始\n→ Step 1: feedSet ← followees[userId] ∪ {userId} // 取得追蹤者集合加上自己\n→ Step 2: minHeap ← 空堆 // 儲存最多 10 條最新推文（最小堆，最小時間戳在頂）\n→ Step 3: 對每個 uid in feedSet\n    → Step 3a: tweetList ← userTweets[uid] // 取得該使用者所有推文\n    → Step 3b: 取 tweetList 的最後 10 條（即最近的）推文\n    → Step 3c: 對每個 t in 這 10 條推文\n        → Decision: minHeap.size() < 10?\n            Yes → minHeap.add(t) // 直接加入堆\n            No  → Decision: t.ts > minHeap.peek().ts?\n                Yes → minHeap.poll(); minHeap.add(t) // 替換最小的\n                No  → 跳過\n→ Step 4: result ← 空列表\n→ Step 5: 當 minHeap 非空時\n    → Step 5a: pop ← minHeap.poll() // 取出最小時間戳的推文\n    → Step 5b: result.prepend(pop.id) // 依時間戳倒序加入結果\n→ Step 6: 返回 result // 最高 10 條推文 ID\nEnd // getNewsFeed 方法結束\n\nStart // follow 方法開始\n→ Decision: followeeId 在 followees[followerId] 中?\n    Yes → 跳過 // 已經追蹤，不需要重複\n    No  → followees[followerId].add(followeeId) // 加入追蹤\nEnd // follow 方法結束\n\nStart // unfollow 方法開始\n→ Decision: followeeId 在 followees[followerId] 中?\n    Yes → followees[followerId].remove(followeeId) // 移除追蹤\n    No  → 跳過 // 本來就沒追蹤\nEnd // unfollow 方法結束"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,-1,-3]'\nGot (Norm):      '[None,1,-1,-3]'\n--- (Raw) ---\nRaw Expected: '[null, 1, -1, -3]'\nRaw Got:      '[None, 1, -1, -3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 依照第一個 '],' 來分割操作列表與參數列表\n    split_idx = data.find('],')\n    ops_str = data[:split_idx + 1]          # 例如 '[\"NumArray\", \"sumRange\"]'\n    args_str = data[split_idx + 2:].strip() # 例如 '[[[1,2,3]], [0,1]]'\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            # arg 為 [['nums']]，取其第一個元素作為 nums\n            obj = NumArray(arg[0])\n            results.append(None)\n        elif op == \"sumRange\":\n            res = obj.sumRange(*arg)\n            results.append(res)\n\n    # 輸出結果\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for NumArray class with constructor and sumRange method, using prefix sum array. Use Start, End, Decision. Provide step-by-step virtual code lines. No real code. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need multiple lines: Start, then build prefix array, maybe using for loop. Then sumRange: calculate sum = prefix[right+1]-prefix[left]. Provide Decision if need bounds? Just straightforward.\n\nLet's produce pseudo-code.\n\nWe'll have Start for constructor: Step 1: store nums length; Step 2: initialize prefix array of size n+1 with 0; Step 3: for i from 0 to n-1: prefix[i+1] = prefix[i] + nums[i] // compute prefix sums. End.\n\nSumRange: Step: return prefix[right+1] - prefix[left]. End.\n\nAdd a decision maybe: check if left and right within bounds? Could add decision.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 NumArray 類別，並宣告整數陣列 nums 與前綴和陣列 prefix // 定義物件屬性\n→ Step 2: NumArray(int[] nums) → 初始化物件 // 進入建構子\n    → Decision: nums 是否為空？ // 檢查輸入\n        Yes → Step 3: prefix = [0] // 空陣列時，前綴和只包含一個 0\n        No  → Step 4: n = length(nums) // 取得陣列長度\n        No  → Step 5: prefix = new int[n+1] // 前綴和陣列長度為 n+1\n        No  → Step 6: prefix[0] = 0 // 前綴和起始值\n        No  → Step 7: for i from 0 to n-1 // 計算前綴和\n            → prefix[i+1] = prefix[i] + nums[i] // 累加當前元素\nEnd // 建構子執行結束\n\n→ Step 8: sumRange(int left, int right) → 計算區間總和 // 進入 sumRange 方法\n    → Decision: 是否左索引 ≤ 右索引？ // 確保參數合法\n        Yes → Step 9: result = prefix[right+1] - prefix[left] // 利用前綴和快速求和\n        Yes → Step 10: return result // 返回區間和\n        No  → Step 11: return 0 // 若索引不合法，回傳 0（或可拋錯誤）\nEnd // sumRange 執行結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Jump Game",
      "source_file": "Leetcode/leetcode55.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1qmz9pjh.py\", line 31, in <module>\n    nums = parse_nums(data)\n           ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp1qmz9pjh.py\", line 25, in parse_nums\n    return ast.literal_eval(line[start:end])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2,3,1,1,4\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,0,4]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwukrp42g.py\", line 31, in <module>\n    nums = parse_nums(data)\n           ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwukrp42g.py\", line 25, in parse_nums\n    return ast.literal_eval(line[start:end])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3,2,1,0,4\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canJump(self, nums):\n        \"\"\"\n        Determine if we can reach the last index.\n        \"\"\"\n        max_reach = 0\n        n = len(nums)\n        for i in range(n):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\ndef parse_nums(line):\n    \"\"\"\n    Extract a list of integers from a string like 'nums = [1,2,3]'.\n    \"\"\"\n    start = line.find('[')\n    end = line.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        return []\n    return ast.literal_eval(line[start:end])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    nums = parse_nums(data)\n    solution = Solution()\n    result = solution.canJump(nums)\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: Jump Game, determining if can reach last index. The virtual code should be step-by-step with arrows and explanations. Use Start, End, Decision, etc.\n\nWe need to output only the virtual code lines, each line: \"虛擬碼步驟 // 解釋\". Use arrows →, Yes →, No →.\n\nLet's design algorithm: Greedy: track farthest reachable index.\n\nPseudo:\n\nStart\n→ Initialize farthest = 0 // farthest reachable index\n→ For i from 0 to nums.length-1\n    → Decision: if i > farthest? // cannot reach this index\n        Yes → Return false\n        No → farthest = max(farthest, i + nums[i]) // update farthest\n→ Return true // after loop, can reach last index\n\nThat's minimal.\n\nLet's produce virtual code line by line.\n\nNeed each line with virtual code step and explanation. Use arrow.\n\nWe might need to mention variable initialization, loop, decision, return.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: Set farthest = 0 // 初始化最遠可達索引\n→ Step 2: For i = 0 to nums.length - 1 // 逐個索引遍歷陣列\n    → Decision: if i > farthest? // 當當前索引超過已知最遠可達\n        Yes → Step 3: Return false // 無法再前進，直接結束\n        No  → Step 4: farthest = max(farthest, i + nums[i]) // 更新最遠可達\n→ Step 5: Return true // 完成遍歷，證明可以到達最後索引\nEnd // 程式執行結束\n\nMake sure each line includes \"虛擬碼步驟\" and comment. Use arrow as described: \"→\" at start of lines inside loop? Provide indentation with arrow.\n\nMake sure lines are exactly as needed. Use indentation maybe.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Set farthest = 0 // 初始化最遠可達索引\n→ Step 2: For i = 0 to nums.length - 1 // 逐個索引遍歷陣列\n    → Decision: if i > farthest? // 當前索引超過已知最遠可達\n        Yes → Step 3: Return false // 無法再前進，直接結束\n        No  → Step 4: farthest = max(farthest, i + nums[i]) // 更新最遠可達\n→ Step 5: Return true // 完成遍歷，證明可以到達最後索引\nEnd // 程式執行結束"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppqdw1qk5.py\", line 59, in <module>\n    data = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppqdw1qk5.py\", line 50, in parse_input\n    return eval(formatted)\n           ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'nums' is not defined"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpewfxir3o.py\", line 59, in <module>\n    data = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpewfxir3o.py\", line 50, in parse_input\n    return eval(formatted)\n           ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'nums' is not defined"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        使用桶（bucket）方法檢查是否存在滿足條件的索引對。\n        \"\"\"\n        if indexDiff <= 0 or valueDiff < 0:\n            return False\n\n        bucketSize = valueDiff + 1  # 每個桶的寬度\n        bucketMap = {}  # bucket -> num\n\n        for i, num in enumerate(nums):\n            # 取得桶索引（Python 的 // 為向下取整，可直接使用）\n            bucket = num // bucketSize\n\n            # 同桶內已有數值，差值必定 <= valueDiff\n            if bucket in bucketMap:\n                return True\n\n            # 左鄰桶\n            if bucket - 1 in bucketMap and abs(num - bucketMap[bucket - 1]) <= valueDiff:\n                return True\n\n            # 右鄰桶\n            if bucket + 1 in bucketMap and abs(num - bucketMap[bucket + 1]) <= valueDiff:\n                return True\n\n            # 將當前數值加入桶中\n            bucketMap[bucket] = num\n\n            # 如果窗口超過 indexDiff，移除最舊的元素\n            if i >= indexDiff:\n                oldNum = nums[i - indexDiff]\n                oldBucket = oldNum // bucketSize\n                bucketMap.pop(oldBucket, None)\n\n        return False\n\n\ndef parse_input(input_str: str):\n    \"\"\"\n    將類似 'nums = [1,2,3,1], indexDiff = 3, valueDiff = 0' 的字串\n    轉成 dict {'nums': [...], 'indexDiff': ..., 'valueDiff': ...}\n    \"\"\"\n    # 替換等號為冒號，並包裝成字典字面量\n    formatted = \"{\" + input_str.replace('=', ':') + \"}\"\n    return eval(formatted)\n\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    data = parse_input(raw_input)\n    nums = data.get('nums', [])\n    indexDiff = data.get('indexDiff', 0)\n    valueDiff = data.get('valueDiff', 0)\n\n    solution = Solution()\n    result = solution.containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to detect near duplicate pair. Classic solution: sliding window hash map or balanced BST. Use hash map for last indices? We need to find any pair within distance indexDiff and valueDiff. Standard Leetcode 2201. Approach: maintain BST of numbers in current window of size indexDiff+1. For each number, check if any number in BST within valueDiff. If found, return true. Use balanced BST: TreeSet. Or use bucket hash map. But we can use hash map of buckets size valueDiff+1. Let's produce virtual code using bucket method. Complexity O(n). Provide steps.\n\nWe produce line-by-line virtual code: Start, iterate over array with index i, bucketSize = valueDiff + 1. Compute bucket key = floorDiv(nums[i], bucketSize). Check same bucket, adjacent bucket left and right for difference <= valueDiff. Add to map. Remove old index when i-indexDiff>0.\n\nReturn false at end.\n\nWe need to adhere to format. Each line: \"虛擬碼步驟 // 解釋\". Use arrow →. Use Decision for conditions. Let's produce.\n\nWe'll create map<bucket, number>. But also need to check difference. Let's produce code accordingly.\n\nLet's output:\n\nStart // 程式開始\n→ Step 1: 設定 bucketSize = valueDiff + 1 // 定義桶大小\n→ Step 2: 建立空哈希表 bucketMap // 用於儲存當前窗口的數值與其桶索引\n→ Step 3: 循環遍歷 nums，索引 i 從 0 開始 // 主迴圈\n    → Step 4: 取得 nums[i] 並計算 bucket = floorDiv(nums[i], bucketSize) // 將數值映射到桶\n    → Decision: bucketMap 是否已存在 bucket? // 同桶內已存在數值\n        Yes → Step 5: 返回 true // 相同桶內差值 ≤ valueDiff\n        No  →\n    → Decision: bucket-1 是否在 bucketMap? // 左鄰桶\n        Yes → Step 6: 若 abs(nums[i] - bucketMap[bucket-1]) <= valueDiff → Step 7: 返回 true\n        No →\n    → Decision: bucket+1 是否在 bucketMap? // 右鄰桶\n        Yes → Step 8: 若 abs(nums[i] - bucketMap[bucket+1]) <= valueDiff → Step 9: 返回 true\n        No →\n    → Step 10: 將 nums[i] 插入 bucketMap[bucket] // 添加當前數值\n    → Decision: i >= indexDiff? // 檢查是否需要移除最舊的元素\n        Yes → Step 11: 取得 nums[i - indexDiff]，計算 oldBucket = floorDiv(nums[i - indexDiff], bucketSize)\n            → Step 12: 刪除 bucketMap[oldBucket] // 從窗口移除\n        No →\nEnd // 程式結束，若未找到則返回 false\n\nBut we need to have return false at end. Add at End: Step 13: 返回 false // 若遍歷完無符合條件\n\nAlso we need to format: Step X: ... // explanation. Use arrow lines. Provide Decision lines with indent.\n\nAlso use \"Start\" and \"End\". Each step line should start with \"→ Step ...\". Decision lines indent further with \"Decision:\".\n\nMake sure each line ends with comment. Provide Chinese explanation.\n\nLet's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: bucketSize = valueDiff + 1 // 設定桶的大小，保證同桶內差值不超過 valueDiff\n→ Step 2: bucketMap = {} // 建立空的哈希表，用於儲存當前窗口內每個桶對應的數值\n→ Step 3: 循環遍歷 nums，索引 i 從 0 開始 // 主迴圈，逐個檢查每個元素\n    → Step 4: num = nums[i] // 取得目前數值\n    → Step 5: bucket = floorDiv(num, bucketSize) // 將數值映射到對應的桶\n    → Decision: bucketMap 包含 bucket? // 同桶已存在數值，則差值一定 ≤ valueDiff\n        Yes → Step 6: 返回 true // 找到符合條件的對，直接結束\n        No →\n    → Decision: bucketMap 包含 bucket-1? // 檢查左鄰桶\n        Yes → Step 7: 若 abs(num - bucketMap[bucket-1]) <= valueDiff → Step 8: 返回 true // 左鄰桶內符合條件\n        No →\n    → Decision: bucketMap 包含 bucket+1? // 檢查右鄰桶\n        Yes → Step 9: 若 abs(num - bucketMap[bucket+1]) <= valueDiff → Step 10: 返回 true // 右鄰桶內符合條件\n        No →\n    → Step 11: bucketMap[bucket] = num // 將目前數值加入其桶中\n    → Decision: i >= indexDiff? // 判斷是否已超過窗口大小，需要移除最舊元素\n        Yes → Step 12: oldNum = nums[i - indexDiff] // 取得最舊的數值\n            → Step 13: oldBucket = floorDiv(oldNum, bucketSize) // 計算其桶\n            → Step 14: 刪除 bucketMap[oldBucket] // 從窗口中移除\n        No →\nEnd // 程式執行結束，若未找到符合條件的對\n→ Step 15: 返回 false // 所有元素都檢查完畢仍無符合條件，回傳 false\n```"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,0,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 0, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport bisect\nimport json\n\nclass Solution:\n    def __init__(self, w):\n        # 建立前綴和列表\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 產生 1~total 的隨機整數\n        target = random.randint(1, self.total)\n        # 使用 bisect 找到第一個 >= target 的索引\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入並解析為 tuple（commands, args）\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # 用 ast.literal_eval 解析安全地\n    data = ast.literal_eval('(' + raw_input + ')')\n    commands, arguments = data\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)          # constructor 的回傳值為 null\n        elif cmd == \"pickIndex\":\n            results.append(obj.pickIndex())\n        else:\n            # 若有其他方法，這裡可擴充\n            results.append(None)\n\n    # 輸出為 JSON 格式，None 會轉成 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step pseudocode for implementing pickIndex function with probability proportional to weights. Provide virtual code lines with explanation. Use Start, Decision, etc.\n\nWe need to handle array w, build cumulative sums in constructor; pick random number between 0 and total sum, binary search or linear search to find index. Provide steps.\n\nWe must output each line with virtual code step + explanation. Use arrow \"→\". Provide start and end. Use decision arrows. Provide algorithm: constructor Preprocess: compute prefix sums. pickIndex: generate random r in [0, total-1], find smallest index where prefixSum > r. Use binary search.\n\nWe need to produce lines accordingly. Ensure each line has \"虛擬碼步驟 // 解釋\". Use arrow after Start. Eg:\nStart // 程式開始執行\n→ Step 1: 初始化 prefixSum // etc.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 w 的長度 n // 確認輸入陣列大小  \n→ Step 2: 建立空陣列 prefix[n] // 用來儲存累積權重  \n→ Step 3: total ← 0 // 用來記錄所有權重之和  \n→ Decision: 是否還有未處理的元素? // 檢查是否完成累積  \n  Yes → Step 4: index ← 當前處理的元素索引  \n    total ← total + w[index] // 加總權重  \n    prefix[index] ← total // 儲存此時的累積值  \n    迴圈回到 Decision  \n  No → Step 5: 儲存 total 以備 pickIndex 使用 // 完成前處理  \n→ End // 前處理結束  \n\n// ---------- pickIndex() ----------  \n\nStart // pickIndex 開始執行  \n→ Step 6: r ← 亂數產生器產生整數 0 ≤ r < total // 產生隨機數  \n→ Decision: 是否使用線性搜尋? // 根據實作偏好  \n  Yes → Step 7: idx ← 0  \n    Decision: prefix[idx] > r?  \n      Yes → Step 8: 返回 idx // 找到對應區間  \n      No → idx ← idx + 1 // 檢查下一個區間  \n      　回到 Decision  \n  No → Step 9: 使用二分搜尋  \n    lo ← 0, hi ← n-1  \n    Decision: lo ≤ hi?  \n      Yes → mid ← (lo+hi) // 取中點  \n       Decision: prefix[mid] > r?  \n         Yes → hi ← mid - 1 // r 在左半部  \n         No  → lo ← mid + 1 // r 在右半部  \n       　回到 Decision  \n      No → Step 10: return lo // lo 即為對應索引  \nEnd // pickIndex 結束執行"
    }
  ]
}